{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012859000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 352716, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE822.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE822.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x07\\n'", "DS1TRBAL": "b'\\x1cJ'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\xa5\\x00\\x03\\x05\\xa5\\x00\\n\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04O\\x00\\x01\\x01\\x10\\x07\\x0f\\x01\\x10\\x07\\x0f!\\x12\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf9@@@'", "ispf": {"version": "04.79", "flags": 0, "createdate": "2010-03-11T00:00:00", "modifydate": "2010-03-11T21:12:01", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-479"}, "text": "REGULAR CBT TAPE - VERSION 479    FILE:  822\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT479.FILE822\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 21 MEMBERS COUNTED; CUMULATIVE SIZE IS 3,259 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   03/11/10    21:12:01    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01c\\x00@\\x01\\x04'_\\x01\\x10\\x06\\x8f\\x13E\\x00\\xaf\\x00\\xa5\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@\"", "ispf": {"version": "01.99", "flags": 0, "createdate": "2004-10-01T00:00:00", "modifydate": "2010-03-09T13:45:40", "lines": 175, "newlines": 165, "modlines": 0, "user": "TKMILLE"}, "text": " LAST UPDATE: 03/09/2010  Version 01.01.01\n                          Terry Miller\n                          ConocoPhillips\n                          tkmille@ConocoPhillips.com\n\n MODIFICATION LEVEL: V01.01.01\n\n This facility was written to assist in measuring Lpar cpu\n utilization against capacity for the purpose of Softcapping\n an Lpar or an Lpar group and using a 4 hour rolling average for\n IBM's subcapacity pricing metrics and reporting tool (SCRT).\n\n It can be used in conjuction with the SCPTOOL (SubCapacity\n Pricing Tool) that IBM provides.\n (http://www-03.ibm.com/systems/z/resources/swprice/subcap/scpt/\n instruct.html)\n\n Program SOFTCAPI will capture cpu utilization and capacity\n information and issue two WTO messages to Syslog and\n also write the two message to a log file (OUTPUT file).\n\n SOFTCAPI WTO Messages:\n\n 1) SOFTCAPI LPAR LPARX CURRENT ROLLING 4-HR AVG UTILIZATION IS 9 MSUS\n 2) SOFTCAPI SY6 CAPACITY IS 27 MSUS, LPAR CAPACITY IS 15 MSUS\n\n The program can be invoked by automation on a time interval\n to capture interval metrics to be graphed.\n\n The STCJOB (started job) member is used to execute the program\n and capture the data into a capture log file.\n\n Member CPULOG captures the daily log and builds a daily gdg\n backup file before emptying the capture log for the next day.\n It also executes a SAS program to create a .csv file of the\n daily usage for graphing.\n\n Please report any bugs to Terry Miller at tkmille@ConocoPhillips.com\n\n DESCRIPTION OF PDS MEMBERS:\n ---------------------------\n\n   $$DOC    - This documentation member\n   $CHANGES - Change Log of the 'SOFTCAPI' facility\n   $INSTALL - Installation steps to install the 'ICH' facility\n   $OBJECT1 - Object deck of program 'SOFTCAPI'\n   $OBJECT2 - Object deck of program 'JUL2GREG'\n   $OBJECT3 - Object deck of program 'DYBACKUP'\n   $OBJECT4 - Object deck of program 'ABENDER'\n   @FILEnnn - CBTTAPE file member\n   ABENDER  - Assembler Program to create a user abend\n              Used in the STCJOB.\n   ASSEM    - JCL to assemble programs 'SOFTCAPI', 'JUL2GREG'\n              'DYBACKUP' and 'ABENDER'.\n   CPULOG   - Builds daily gdg file from the msg capture file,\n              empties the daily capture file, and sends a daily\n              email attachment in csv format to specified users\n              to graph the interval metrics gathered and reported\n              by program SOFTCAPI. Batch submitted job.\n   CPUUTIL1 - SAS coded used in the CPULOG member above to create\n              a .csv file for graphing the cpu metrics.\n   DYBACKUP - Assembler Program to copy an input log (or file) to a\n              dynamically allocated backup of the log (or file).\n              Used by member STCJOB.\n   HOWCALLD - Macro used by program SOFTCAPI to determine if program\n              'SOFTCAPI' was called as a subroutine or via an\n              'EXEC PGM' call.\n   JUL2GREG - Assembler Program to convert a Julian Date to Gregorian\n              Called by programs SOFTCAPI and DYBACKUP.\n   LINKEDIT - JCL to link-edit programs 'SOFTCAPI', 'JUL2GREG',\n              'DYBACKUP' and 'ABENDER' from object members $OBJECT1,\n              $OBJECT2, $OBJECT3, and $OBJECT4 respectively.\n   SOFTCAPI - Assembler Program that retieves cpu capacity information\n              and stores the information in a capture log.\n   STCJOB   - Started job to execute program SOFTCAPI\n              Can be triggered by Automation on a time interval for\n              interval reporting purposes.\n\n DISCLAIMER OF LIABILITY:\n ------------------------\n\n                     DISCLAIMER\n\n Terry Miller and ConocoPhillips neither expresses nor implies\n any warranty as to the fitness of this SOFTCAPI facility.\n The use of this facility and the results therefrom is entirely\n at the risk of the user.  Consequently, the user may modify\n these programs in any way he/she thinks fit.\n\n All disclaimers that apply to CBT programs as described in\n the \"Disclaimer Section\" of File 001 of the CBT Tape Doc\n and on www.cbttape.org also apply to this package.\n\n INSTALLATION TAILORING/CUSTOMIZATION:\n -------------------------------------\n\n The Prefix to the Capture Log Message (File OUTPUT) uses a 3\n character sysid (system id) in program SOFTCAPI.  This is the\n CVTSNAME field.  If your system name is longer than 3\n characters in length, you will need to adjust the record.\n\n Note: the lpar name is also listed in the message elsewhere\n as an 8 character lpar name, so this may not be necessary\n to adjust.\n\n However, you should be aware of this as your sysname may be\n truncated in the prefix to the two WTO messages.\n\n If you do adjust the length of this field, you will also have\n to modify the SAS member \"CPUUTIL1\" as well.  It contains the\n record layout and format of the message capture file.\n\n The prefix to the SOFTCAPI messages is not shown above.\n The prefix to the SOFTCAPI messages is in format below.\n\n Date Time SYSID (22 Byte Prefix):\n\n Col 01-02: Month\n Col 03   : '/'\n Col 04-05: Day\n Col 06   : '/'\n Col 07-08: Year (2 digits)\n Col 09   : ' '\n Col 10-11: Time (Hours)\n Col 12   : ':'\n Col 13-14: Time (Minutes)\n Col 15   : ':'\n Col 16-17: Time (Seconds)\n Col 18   : ' '\n Col 19-21: Sysid (3 Characters) <= CVTSNAME\n Col 18   : ' '\n\n AUTHORIZATION:\n --------------\n\n No APF-Authorized libary is necessary for this facility.\n\n ASSUMPTIONS:\n ------------\n\n Member \"CPULOG\" assumes that you have some email facility to\n email a csv file such as Lionel's Dyck's XMITIP.  The XMITIP\n program is used in member \"CPULOG\" as it is delivered.  If\n you do not have XMITIP, you will need to substitute your own\n utilty for this purpose.\n\n You may obtain Lionel Dyck's XMITIP facility from the CBTTAPE\n File #314 or via Lionel's personal shareware web site\n http://www.lbdsoftware.com/tcpip.html.\n\n Member \"CPULOG\" also assumes that you have SAS installed at\n your installation.  If you do not have SAS installed, you will\n need to develop your own program for producing a .csv file\n for graphing (if you desire to graph the results).\n Note, only basic SAS is needed.  You do not have to have\n SAS GRAPHICS installed.  I use Microsoft excel for graphing.\n\n CERTIFICATION:\n --------------\n\n Program SOFTCAPI is certified for Z/oS 1.8 and higher.\n The softcapping information was made available in Z/oS 1.8\n at the Lpar Group Level.  You may be able to use this facility\n at a lower Z/oS Level, but it would not be certified at that\n lower Level.\n\n PROBLEM REPORTING\n -----------------\n\n Please report any bugs or suggestions for improvement to:\n        Terry Miller at email: Tkmille@ConocoPhillips.com\n\n\n **************************** Bottom of Data ***************************\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE1": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x15\\x01\\x10\\x05O\\x01\\x10\\x05O\"U\\x00F\\x00F\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-02-23T00:00:00", "modifydate": "2010-02-23T22:55:15", "lines": 70, "newlines": 70, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:   Re: New CBT Contribution - SOFTCAP Assistant\nFrom:      <Tkmille@ConocoPhillips.Com>\nDate:      09 Feb 2010 14:17:20 -0600\nTo:        <SbGolob@cbttape.org>\n\n\n Re: New SoftCapping Assistance Facility - SOFTCAP - Filennn ...\n\n Sam,\n\n 02/09/2010 - V01.01.01\n\n   - New Facility for measuring cpu utilization and 4 hour rolling\n     average inforatmion for assisting in setting a Softcap.\n\n This facility was written to assist in measuring Lpar cpu\n utilization against capacity for the purpose of Softcapping\n an Lpar or an Lpar group and using a 4 hour rolling average for\n IBM's subcapacity pricing metrics and reporting tool (SCRT).\n\n It can be used in conjuction with the SCPTOOL (SubCapacity\n Pricing Tool) that IBM provides.\n\n Program SOFTCAPI will capture cpu utilization and capacity\n information and issue two WTO messages to syslog and\n also write the two message to a log.\n\n SOFTCAPI WTO Messages:\n\n 1) SOFTCAPI LPAR LPARX CURRENT ROLLING 4-HR AVG UTILIZATION IS 9 MSUS\n 2) SOFTCAPI SY6 CAPACITY IS 27 MSUS, LPAR CAPACITY IS 15 MSUS\n\n The program can be issued by automation on a time interval\n to capture interval metrics to be graphed.\n\n The STCJOB (started job) member is used to execute the program\n and capture the data into a capture log.\n\n Member CPULOG captures the daily log and builds a daily gdg\n backup file before emptying the capture log for the next day.\n It also executes a SAS program to create a .csv file of the\n daily usage for graphing.\n\n See XMIT attachment for the new SOFTCAP assistant facility.\n\n For what it is worth ...\n\n Have a good week!\n\n Regards,\n\n Terry Miller\n ConocoPhillips\n 620-03 Information Center\n 511 S. Keeler Ave.\n Bartlesville, Oklahoma 74004\n Phone:    918-661-0327\n Fax:      918-661-3636\n Email:    Tkmille@ConocoPhillips.com\n\n\n* ------------------------ 5.66 ------------------------- *\n* E-Mail originated from:                                 *\n* Jobname:       XMITIPSC       Job Number:    JOB00292   *\n* Userid:        TKMILLE        User Name:     T.K.MILLER *\n* System:        SYH            Node:          BVOJ1      *\n* Date:          February 9, 2010  14:17:20  (Tuesday)    *\n* ------------------------------------------------------- *\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE2": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x10\\x06?\\x01\\x10\\x06?\"\\x13\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-03-04T00:00:00", "modifydate": "2010-03-04T22:13:21", "lines": 27, "newlines": 27, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: New CBT Contribution - SOFTCAPI - File 822\nFrom:     <Tkmille@ConocoPhillips.Com>\nDate:     04 Mar 2010 13:49:06 -0600\nTo:       <SbGolob@cbttape.org>\nCC:       <tkmille@ConocoPhillips.Com>\n\nRe: Update to SoftCapping Assistance Facility - SOFTCAPI - File822 ...\n\nSam,\n\n02/25/2010 - V01.01.01\n\n  - Modified the Summary messages from program DYBACKUP.\n\nSee XMIT attachment for the new SOFTCAP assistant facility.\n\nRegards,\n\nTerry Miller\nConocoPhillips\n620-03 Information Center\n511 S. Keeler Ave.\nBartlesville, Oklahoma 74004\nPhone:    918-661-0327\nFax:      918-661-3636\nEmail:    Tkmille@ConocoPhillips.com\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$CHANGES": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01.\\x00\\x19\\x01\\x054\\x7f\\x01\\x10\\x06\\x8f\\x14E\\x00\\x1a\\x00\\x01\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.46", "flags": 0, "createdate": "2005-12-13T00:00:00", "modifydate": "2010-03-09T14:45:19", "lines": 26, "newlines": 1, "modlines": 0, "user": "TKMILLE"}, "text": "                    SOFTCAPI Version Change History\n\n 03/09/2010 - V01.01.01\n\n   - Modified program DYBACKUP to add dsect for IHADVA macro.\n   - Modified some comments in programs SOFTCAPI and DYBACKUP.\n   - Modified STCJOB started job jcl\n\n 02/25/2010 - V01.01.01\n\n   - Modified the Summary messages from program DYBACKUP.\n\n 02/12/2010 - V01.01.01\n\n   - Added two SYSIN parameters (ALLOCWT and WAITINT) for program\n     DYBACKUP to allow overrides for the dynamic allocation routine.\n     ALLOCWT parameter specifies the number of times to attempt to\n         dynamically allocate the SYSUT2 file if it is busy.\n     WAITINT parameter specifies the number of seconds to wait\n         between dynamic allocation attempts for file SYSUT2.\n\n 02/09/2010 - V01.01.01\n\n   - New Facility for measuring cpu utilization and 4 hour rolling\n     average inforatmion for assisting in setting a softcap.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INSTALL": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00@\\x01\\x10\\x01O\\x01\\x10\\x04\\x0f\\x11T\\x00#\\x00\\x04\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2010-01-14T00:00:00", "modifydate": "2010-02-09T11:54:40", "lines": 35, "newlines": 4, "modlines": 0, "user": "TKMILLE"}, "text": "       Installation Steps for the \"SOFTCAPI\" Facility\n\n 1) Choose a Load Library to link the programs into.\n\n 2) Edit member \"ASSEM\" (assembles/links programs).\n    Make the tailoring changes (Change the Source location\n    and the Load Library etc).\n\n    Submit member \"ASSEM\" to assemble/link the programs\n    into the Load Library chosen in step 1) above.\n\n    Alternately, member \"LINKEDIT\" is included if you only\n    want to run the LINKEDIT (BINDER) step.  You must\n    tailor this member per the comments before submitting\n    it.\n\n 3) Allocate a message capture log dataset with DSORG=PS\n    and Lrecl=150 (allocate enough space for 100 records).\n    Apply security protection to this file.\n\n 4) Define and secure-protect a gdg dataset for a daily\n    backup of the message capture file chosen in step\n    3) above.\n\n 5) Tailor and place member 'STCJOB' into a system proc\n    library or in the started jobs library 'SYS1.STCJOBS'.\n    Substitute the dataset name chosen in step 3) above\n    and the load library chosen in step 1) above.\n\n 6) Place member \"CPULOG\" into some library which can be\n    executed as a daily job. You will need to tailor this member\n    for your installation.  It will input SAS member\n    \"CPUUTIL1\".  Use the gdg dataset defined in step 4) above.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$OBJECT1": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10\\x06?\\x01\\x10\\x06?!R\\x00)\\x00)\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-03-04T00:00:00", "modifydate": "2010-03-04T21:52:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "TKMILLE"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "$OBJECT2": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10\\x05O\\x01\\x10\\x05O#$\\x00\\x10\\x00\\x10\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-02-23T00:00:00", "modifydate": "2010-02-23T23:24:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "TKMILLE"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "$OBJECT3": {"ttr": 534, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10\\x07\\x0f\\x01\\x10\\x07\\x0f!\\x11\\x00\\x85\\x00\\x85\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-03-11T00:00:00", "modifydate": "2010-03-11T21:11:00", "lines": 133, "newlines": 133, "modlines": 0, "user": "TKMILLE"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "$OBJECT4": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10\\x05O\\x01\\x10\\x05O#$\\x00\\x08\\x00\\x08\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-02-23T00:00:00", "modifydate": "2010-02-23T23:24:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "TKMILLE"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "@FILE822": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04O\\x00S\\x01\\x10\\x07\\x0f\\x01\\x10\\x07\\x0f!\\x11\\x00+\\x00+\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf9@@@'", "ispf": {"version": "04.79", "flags": 0, "createdate": "2010-03-11T00:00:00", "modifydate": "2010-03-11T21:11:53", "lines": 43, "newlines": 43, "modlines": 0, "user": "CBT-479"}, "text": "//***FILE 822 is from Terry Miller, and contains code to capture    *   FILE 822\n//*           cpu utilization and limit information for use as a    *   FILE 822\n//*           metric in softcapping an Lpar or an Lpar group.       *   FILE 822\n//*                                                                 *   FILE 822\n//*             email:  tkmille@conocophillips.com                  *   FILE 822\n//*                                                                 *   FILE 822\n//*       LAST UPDATE: 03/09/2010  Terry Miller                     *   FILE 822\n//*                                ConocoPhillips                   *   FILE 822\n//*                                tkmille@ConocoPhillips.com       *   FILE 822\n//*                                                                 *   FILE 822\n//*       MODIFICATION LEVEL: V01.01.01                             *   FILE 822\n//*                                                                 *   FILE 822\n//*   * * * * * * * * * * * * * * * * * * * * * * * * * * * * *     *   FILE 822\n//*                                                                 *   FILE 822\n//*   This facility was written to assist in measuring Lpar cpu     *   FILE 822\n//*   utilization against capacity for the purpose of Softcapping   *   FILE 822\n//*   an Lpar or an Lpar group using a 4 hour rolling average with  *   FILE 822\n//*   IBM's subcapacity software pricing for monthly license        *   FILE 822\n//*   charges (MLC).  It can be used in conjuction with the         *   FILE 822\n//*   SCPTOOL (SubCapacity Pricing Tool) that IBM provides.         *   FILE 822\n//*   (http://www-03.ibm.com/systems/z/resources/swprice/subcap/    *   FILE 822\n//*    scpt/instruct.html)                                          *   FILE 822\n//*                                                                 *   FILE 822\n//*   Program SOFTCAPI will capture cpu utilization and capacity    *   FILE 822\n//*   information and issue two WTO messages to Syslog and          *   FILE 822\n//*   also write the two message to a log file (OUTPUT file).       *   FILE 822\n//*                                                                 *   FILE 822\n//*   SOFTCAPI WTO Messages:                                        *   FILE 822\n//*                                                                 *   FILE 822\n//*   1) SOFTCAPI LPAR LPARX CURRENT ROLLING 4-HR AVG UTILIZATION   *   FILE 822\n//*      IS 9 MSUS                                                  *   FILE 822\n//*   2) SOFTCAPI SY6 CAPACITY IS 27 MSUS, LPAR CAPACITY            *   FILE 822\n//*      IS 15 MSUS                                                 *   FILE 822\n//*                                                                 *   FILE 822\n//*   The program can be issued by automation on a time interval    *   FILE 822\n//*   to capture interval metrics to be graphed.                    *   FILE 822\n//*                                                                 *   FILE 822\n//*   The STCJOB (started job) member is used to execute the        *   FILE 822\n//*   program and capture the data into a capture log.              *   FILE 822\n//*                                                                 *   FILE 822\n//*   The daily capture log can then be used to graph daily         *   FILE 822\n//*   cpu utilization.                                              *   FILE 822\n//*                                                                 *   FILE 822\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ABENDER": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1f\\x00\\t\\x01\\x06\\x12\\x8f\\x01\\x10\\x03\\x7f\\x10Y\\x00\\x90\\x00@\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.31", "flags": 0, "createdate": "2006-05-08T00:00:00", "modifydate": "2010-02-06T10:59:09", "lines": 144, "newlines": 64, "modlines": 0, "user": "TKMILLE"}, "text": "* ------------------------------------------------------------------- *\n*                                                                     *\n*  THIS SUBROUTINE INPUTS A PARM TO BE USED TO ISSUE A USER ABEND.    *\n*  THE USER ABEND CODE IS PASSED TO THIS PROGRAM IN THE EXECUTION     *\n*  PARAMETER.   IF THE EXECUTION PARAMETER IS INVALID, THE PROGRAM    *\n*  WILL USE '1116' AS THE USER ABEND CODE.                            *\n*                                                                     *\n*  THE SUBROUTINE MAY BE INVOKED IN EITHER 24-BIT OR 31-BIT MODE,     *\n*  EITHER ABOVE OR BELOW THE 16-MEG LINE.                             *\n*                                                                     *\n*  THE SUBROUTINE IS RE-ENTRANT.                                      *\n*                                                                     *\n*  THIS SUBROUTINE IS DESIGNED TO BE CALLED FROM JCL OR FROM ANOTHER  *\n*  PROGRAM (THE LINKAGE WORKS EITHER WAY):                            *\n*                                                                     *\n*  PARAMETER LIST ON ENTRY TO \"ABENDER\":                              *\n*     R1    => ADDRESS OF PARAMETER LIST                              *\n*            1 ... A 2-BYTE LENGTH VALUE (LENGTH OF PARM) S/B=4       *\n*            2 ... A 4-BYTE USER ABEND CODE IN EBCDIC (0000-4095)     *\n*                                                                     *\n*  EXAMPLE CALL FROM ASSEMBLER (DYNAMIC CALL):                        *\n*                                                                     *\n*     LOAD  EP=ABENDER           Load program \"ABENDER\"               *\n*     LR    R15,R0               Load  the entry addr                 *\n*     LA    R1,PARMLENG          Get Parm List Address                *\n*     ST    R1,PARMADDR                                               *\n*     LA    R1,PARMADDR          Point to parameter list              *\n*     BASSM R14,R15                                                   *\n*     DELETE EP=ABENDER          Delete program \"ABENDER\"             *\n*                                                                     *\n*     PARMADDR    DS    F                                             *\n*     PARMLENG    DC    H'4'                                          *\n*     ABENDCOD    DC    ZL4'1024'    (Must be between 0000 and 4095)  *\n*                                                                     *\n*  EXAMPLE CALL FROM COBOL (DYNAMIC CALL):                            *\n*                                                                     *\n*     CALL ABENDER-PROGAM   USING  AP-PARMS.                          *\n*                                                                     *\n*     01  ABENDER-PROGRAM     PIC X(8)  VALUE 'ABENDER '.             *\n*     01  AP-PARMS.                                                   *\n*         03  AP-PARM-LENGTH  PIC S9(4) COMP  VALUE +4.               *\n*         03  AP-ABEND-CODE   PIC 9(4)        VALUE 1024.             *\n*                                                                     *\n*  PROGRAM RESTRICTIONS:                                              *\n*                                                                     *\n*     THE ABEND CODE PASSED TO THIS PROGRAM MUST HAVE VALUES BETWEEN  *\n*     0000 AND 4095.                                                  *\n*                                                                     *\n*  PROGRAM DEFAULTS:                                                  *\n*                                                                     *\n*     IF THE ABEND CODE PASSED TO THIS PROGRAM IS INVALID FOR ANY     *\n*     REASON, THE PROGRAM WIlL USE CODE '1116' AS THE USER ABEND CODE.*\n*                                                                     *\n*  REGISTER USAGE:                                                    *\n*            R2   WORK REGISTER                                       *\n*            R3   WORK REGISTER                                       *\n*            R4   WORK REGISTER                                       *\n*            R5   UNUSED                                              *\n*            R6   SAVE AREA BACKWARD LINK                             *\n*            R7   PARAMETER LIST ADDRESS                              *\n*         R8-R10  UNUSED                                              *\n*            R11  UNUSED                                              *\n*            R12  BASE REGISTER                                       *\n*            R13  SAVE AREA                                           *\n*                                                                     *\n* ------------------------------------------------------------------- *\nABENDER  CSECT\nABENDER  AMODE ANY\nABENDER  RMODE ANY\n         SAVE  (14,12),,ABENDER_ASSEMBLED_ON_&SYSDATE._&SYSTIME\n         LR    R12,R15              Load entry address\n         USING ABENDER,R12          Declare entry base\n         LR    R7,R1                Preserve passed parmlist address\n         LR    R6,R13               Store SAVEAREA Backward link\n         L     R3,=A(STORSIZE)      Size of storage to get and clear\n         STORAGE OBTAIN,LENGTH=(R3),LOC=(RES)\n         ST    R1,8(,R13)           Set SAVEAREA Forward link\n         LR    R13,R1               Address of obtained area\n         USING STORAREA,R13         Addressability to obtained area\n         ST    R6,4(,R13)           Set SAVEAREA Backward link\nINITOBTN DS    0H                  Initialize the obtained storage area\n         LR    R0,R13               Address of target of move (obtnd)\n         L     R3,=A(STORSIZE)      Length of the target of move\n         XR    R14,R14             From address (irrelevant with len=0)\n         XR    R15,R15              Pad/Length to propagate in odd reg\n         MVCL  R0,R14          Propagate binary zeroes in obtained area\n**********************************************************************\n*   Pick up the passed Abend Code - 4 bytes EBCDIC Zoned Decimal\n*   This program can be called from a Rexx exec (or via jcl\n*   directly) or from another program as a subroutine call.\n*   Determine the caller's method of calling ABENDER.\n*   Macro HOWCALLD will determine how this program was called.\n**********************************************************************\n         L     R4,0(,R7)\n         LR    R1,R7               Restore R1\n         HOWCALLD PARMCALL=PARMCALL , How was I called? Subr or Exec?\n         B     PACKCODE             I was called as a subroutine\nPARMCALL DS    0H\n         CLC   0(2,R4),=H'4'       Abend Code must be 4 bytes EBCDIC\n         BNE   INVLPARM            Invalid abend code passed\n         CLC   2(4,R4),=CL4'0000'  Abend Code must be between 0000-4095\n         BL    INVLPARM            Invalid abend code passed\n         CLC   2(4,R4),=CL4'4095'  Abend Code must be between 0000-4095\n         BNH   SKIPLL              Valid abend code passed\nINVLPARM DS    0H\n         L     R4,F1116            Load Default User Abend Code\n         B     ABENDIT\nSKIPLL   DS    0H\n         LA    R4,2(,R4)           Point to the Abend Code (past ll)\nPACKCODE DS    0H\n         PACK  DOUBLE,0(4,R4)      Pack the Abend Code\n         CVB   R4,DOUBLE           Convert Abend Code to binary\nABENDIT  DS    0H\n         O     R4,X80              Initialize User Abend Code\n         LR    R2,R13              Pointer to storage area\n         LA    R3,STORSIZE         Work area size\n*\n         ABEND (R4)                ABEND with UXXX (passed as parm)\n*\n* If you think you will get to this point, you are sadly mistaken ...\n*\nRETURN   DS    0H\n         L     R13,4(,R13)          Restore Caller's SAVEAREA address\n         STORAGE RELEASE,LENGTH=(R3),ADDR=(R2)\n         L     R14,12(,R13)         Restore Return Address with Amode\n         LM    R0,R12,20(R13)       Restore caller's registers\n         BSM   0,R14                Return to caller in caller's Amode\n*\n**********************************************************************\n*    STATIC STORAGE FOLLOWS\n**********************************************************************\n            DS    0F\nF1116       DC    F'1116'           Default user abend code\nX80         DC    X'80000000'       Indicate User Abend\n            LTORG\n**********************************************************************\n*    DYNAMIC STORAGE FOLLOWS  (GETMAINED AREA)\n**********************************************************************\nSTORAREA    DSECT ,                  Reentrant storage\nSAVEAREA    DS    20F\nDOUBLE      DS    D                  CVD/CVB Work Area\nSTORSIZE    EQU   *-STORAREA\n            YREGS ,\n            END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASSEM": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x15\\x01\\x10\\x03?\\x01\\x10\\x05o\\x16F\\x00e\\x01m\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2010-02-02T00:00:00", "modifydate": "2010-02-25T16:46:15", "lines": 101, "newlines": 365, "modlines": 0, "user": "TKMILLE"}, "text": "//ASSEM    JOB 'ASSEMBLE AND LINK PROGRAM SOFTCAPI              ',\n// TIME=1440,MSGCLASS=Z,MSGLEVEL=1,NOTIFY=&SYSUID,REGION=0M\n//*******************************************************************\n//* ASSEMBLE AND LINK PROGRAMS SOFTCAPI, JUL2GREG, DYBACKUP AND\n//* ABENDER.\n//*******************************************************************\n//ASSEMBLE EXEC PGM=ASMA90,\n//         PARM='DECK,NOOBJECT,LINECOUNT(55)'\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SMPE.SOFTCAPI     <= INCLUDED MACRO\n//SYSPUNCH DD DSN=&&LOADSET,DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//         SPACE=(3200,(400,050),RLSE),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSIN    DD DISP=SHR,DSN=SMPE.SOFTCAPI(SOFTCAPI) <= INCLUDED SOURCE\n//*\n//LINKEDIT EXEC PGM=IEWL,COND=(5,LT,ASSEMBLE),\n//         PARM='LIST,LET,MAP,XREF,RENT,REUS'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DISP=(OLD,DELETE),DSN=&&LOADSET\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DISP=SHR,DSN=MY.LINK.LISTED.LIBRARY    <= CHANGE THIS\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSIN    DD *\n ENTRY SOFTCAPI\n MODE  AMODE(31),RMODE(24)\n NAME  SOFTCAPI(R)\n/*\n//ASSEMBL2 EXEC PGM=ASMA90,\n//         PARM='DECK,NOOBJECT,LINECOUNT(55)'\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SMPE.SOFTCAPI     <= INCLUDED MACRO\n//SYSPUNCH DD DSN=&&LOADSET2,DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//         SPACE=(3200,(400,050),RLSE),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSIN    DD DISP=SHR,DSN=SMPE.SOFTCAPI(JUL2GREG) <= INCLUDED SOURCE\n//*\n//LINKEDI2 EXEC PGM=IEWL,COND=(5,LT,ASSEMBL2),\n//         PARM='LIST,LET,MAP,XREF,RENT,REUS'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DISP=(OLD,DELETE),DSN=&&LOADSET2\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DISP=SHR,DSN=MY.LINK.LISTED.LIBRARY    <= CHANGE THIS\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSIN    DD *\n ENTRY JUL2GREG\n MODE  AMODE(31),RMODE(ANY)\n NAME  JUL2GREG(R)\n/*\n//ASSEMBL3 EXEC PGM=ASMA90,\n//         PARM='DECK,NOOBJECT,LINECOUNT(55)'\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SMPE.SOFTCAPI     <= INCLUDED MACRO\n//SYSPUNCH DD DSN=&&LOADSET3,DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//         SPACE=(3200,(400,050),RLSE),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSIN    DD DISP=SHR,DSN=SMPE.SOFTCAPI(DYBACKUP) <= INCLUDED SOURCE\n//*\n//LINKEDI3 EXEC PGM=IEWL,COND=(5,LT,ASSEMBL3),\n//         PARM='LIST,LET,MAP,XREF,RENT,REUS'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DISP=(OLD,DELETE),DSN=&&LOADSET3\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DISP=SHR,DSN=MY.LINK.LISTED.LIBRARY    <= CHANGE THIS\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSIN    DD *\n ENTRY DYBACKUP\n MODE  AMODE(31),RMODE(24)\n NAME  DYBACKUP(R)\n/*\n//ASSEMBL4 EXEC PGM=ASMA90,\n//         PARM='DECK,NOOBJECT,LINECOUNT(55)'\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SMPE.SOFTCAPI     <= INCLUDED MACRO\n//SYSPUNCH DD DSN=&&LOADSET3,DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//         SPACE=(3200,(400,050),RLSE),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSIN    DD DISP=SHR,DSN=SMPE.SOFTCAPI(ABENDER) <= INCLUDED SOURCE\n//*\n//LINKEDI4 EXEC PGM=IEWL,COND=(5,LT,ASSEMBL4),\n//         PARM='LIST,LET,MAP,XREF,RENT,REUS'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DISP=(OLD,DELETE),DSN=&&LOADSET4\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DISP=SHR,DSN=MY.LINK.LISTED.LIBRARY    <= CHANGE THIS\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSIN    DD *\n ENTRY ABENDER\n NAME  ABENDER(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CPULOG": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x16\\x01\\t2O\\x01\\x10\\x03O\\x15\\x15\\x00G\\x00\\x11\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2009-11-20T00:00:00", "modifydate": "2010-02-03T15:15:16", "lines": 71, "newlines": 17, "modlines": 0, "user": "TKMILLE"}, "text": "//CPULOG   JOB 'CREATE CSV FILE FOR GRAPHING                   ',\n// TIME=1440,MSGCLASS=Z,MSGLEVEL=1,REGION=0M\n//OUT1      OUTPUT JESDS=ALL,COPIES=0\n//*********************************************************************\n//* RUN THIS JOB ONCE PER DAY.\n//* BUILD A DAILY GDG FILE OF TODAY'S SOFTCAPI MESSAGES.\n//*********************************************************************\n//STEP01    EXEC PGM=IEBGENER\n//SYSIN     DD DUMMY\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=CPU.MESSAGES,DISP=SHR      <= FROM PGM SOFTCAPI\n//SYSUT2    DD DSN=CPU.MESSAGES.HIST(+1),     <= DAY'S ACCUMULATION\n//          UNIT=SYSDA,\n//          SPACE=(TRK,(100),RLSE),DISP=(NEW,CATLG),\n//          DCB=(M.GNS.P1161.MDLDSCB,RECFM=FB,LRECL=150,BLKSIZE=0)\n//*\n//*********************************************************************\n//* EMPTY THE SOFTCAPI CAPTURE FILE FOR NEXT DAY\n//*********************************************************************\n//STEP02    EXEC PGM=IEBGENER\n//SYSIN     DD DUMMY\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DUMMY,DCB=(CPU.MESSAGES)\n//SYSUT2    DD DSN=CPU.MESSAGES,DISP=SHR     <= EMPTY FILE FOR NEXT DAY\n//*\n//*********************************************************************\n//* USE SAS TO CREATE A CSV FILE FOR GRAPHING.\n//*********************************************************************\n//CPUUTIL   EXEC SAS\n//CPUUTIL   DD DISP=SHR,DSN=CPU.MESSAGES.HIST(+1)    <= DAY'S ACCUMULAT\n//OUTPUT    DD DSN=&&CPUUTIL,                        <= OUTPUT FROM SAS\n//          DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//          DCB=(RECFM=FB,LRECL=080,BLKSIZE=0,DSORG=PS),\n//          SPACE=(1,(002,002),RLSE),AVGREC=M\n//SYSIN     DD DISP=SHR,DSN=SMPE.SOFTCAPI(CPUUTIL1)  <= SAS CODE\n//*********************************************************************\n//* SEND TO EMAIL DISTRIBUTION LIST OF USERS USING LIONEL DYCK'S\n//*      XMITIP UTILITY (www.cbttape.org FILE #314 or LIONEL'S\n//*      WEB SITE http://www.lbdsoftware.com/tcpip.html)\n//*********************************************************************\n//XMITIP    EXEC PGM=XMITIP               <= LIONEL DYCK XMITIP UTILITY\n//STEPLIB   DD DISP=SHR,DSN=XMITIP.LOADLIB     <= CHANGE THIS OR REMOVE\n//          DD DISP=SHR,DSN=TXT2PDF.LOADLIB    <= CHANGE THIS OR REMOVE\n//SYSEXEC   DD DISP=SHR,DSN=XMITIP.EXEC        <= CHANGE THIS EXEC LIB\n//          DD DISP=SHR,DSN=TXT2PDF.EXEC       <= CHANGE THIS EXEC LIB\n//SYSUDUMP  DD SYSOUT=*\n//SYSTSPRT  DD SYSOUT=*\n//ATTACH1   DD DISP=(OLD,DELETE),DSN=&&CPUUTIL <= REPORT ATTACHMENT\n//ADDRESS1  DD *\nTo myemail1@domain.org\nTo myemail2@domain.org\n//MESSAGE1  DD *\n\nRe: Attached is a WLM cpu utilization/softcapping report from Lpar\n    xxxxxxxx in csv format...\n\nRegards,\n\nJohn Doe\nPhone:    xxx-xxx-xxxx\n//SYSIN     DD *\n%XMITIP  *                                                      -\n ADDRESSFILEDD    ADDRESS1                                      -\n MSGDD            MESSAGE1                                      -\n FROM             myemail@domain.org                            -\n FILEDD           (ATTACH1)                                     -\n FILENAME         (CPU_Report_Lpar_xxxxxxxx.csv)                -\n FILEDESC         (WLM-CPU-Utilization-Report-xxxxxxxx)         -\n FORMAT           (csv)                                         -\n SUBJECT 'WLM CPU Utilization/Softcapping Report for Lpar xxxxxxxx'\n//*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CPUUTIL1": {"ttr": 785, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\"\\x00\\x00\\x01\\x10\\x03O\\x01\\x10\\x03O\"Y\\x00\\x98\\x00\\x9a\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.34", "flags": 0, "createdate": "2010-02-03T00:00:00", "modifydate": "2010-02-03T22:59:00", "lines": 152, "newlines": 154, "modlines": 0, "user": "TKMILLE"}, "text": "  OPTIONS LS=076 PS=60 NOCENTER ;\n  DATA CPUUTIL ;\nINFILE CPUUTIL ;\n  INPUT @1     RECORD     $CHAR150.\n        @1     DATE       $CHAR8.\n        @1     MONTH      $CHAR2.\n        @4     DAY        $CHAR2.\n        @7     YEAR       $CHAR2.\n        @10    TIME       $CHAR8.\n        @10    TIME5      $CHAR5.\n        @10    HOURS      $CHAR2.\n        @13    MINS       $CHAR2.\n        @16    SECS       $CHAR2.\n        @19    SYSID      $CHAR3.\n        @23    MSGID      $CHAR8.\n        @32    LIT1       $CHAR20.\n    ;\n\n*********************************************************************;\n* CHANGE THE SIZE LIMITS FOR YOUR SHOP FOR THE LENGTH STATMENTS     *;\n* BELOW FOR THE FOLLOWING FIELDS (MAX SIZE):                        *;\n*   LPARNAME HARDWNME ROLLAVG CECCAPAC LPRCAPAC                     *;\n*********************************************************************;\n\n  LENGTH SORTKEY $40 DATE10 $10 ;\n  DATE10  = \"20\"||YEAR||\"/\"||MONTH||\"/\"||DAY ;\n  SORTKEY = SYSID||YEAR||MONTH||DAY||TIME5||REPEAT(\" \",26) ;\n\n  PROC SORT DATA=CPUUTIL  ;\n       BY SORTKEY ;\n\n  DATA UTILIZ ;\n    SET CPUUTIL ;\n\n  LENGTH LPARNAME $7 HARDWNME $3 ;\n  LENGTH ROLLAVG  $2 CECCAPAC $2 LPRCAPAC $2 ;\n\n  RETAIN LPARNAME HARDWNME ROLLAVG CECCAPAC LPRCAPAC \" \" ;\n\n  LENGTH PREVKEY $40 SOFTCAP LIMITED $1 STRING $15 ;\n  RETAIN PREVKEY SOFTCAP LIMITED \" \" ;\n\n  IF LIT1 =  :\"LPAR \" THEN DO ;    * HAVE UTILIZATION MESSAGE * ;\n     LPARNAME = SCAN(LIT1,2,\", \") ;\n     U1  = INDEX(RECORD,\"UTILIZATION IS\") ;\n     IF U1 > 0 THEN DO ;\n        STRING  = SUBSTR(RECORD,U1+15,15) ;\n        ROLLAVG = SCAN(STRING,1,\", \") ;\n        IF LENGTH(ROLLAVG) = 1      THEN\n           ROLLAVG = \"0\"||ROLLAVG ;\n     END ;\n     U2  = INDEX(RECORD,\"SOFTCAPPING IS CURRENTLY IMPOSED\") ;\n     SOFTCAP = \"N\"     ;\n     LIMITED = \"N\"     ;\n     IF U2 > 0 THEN DO ;\n        SOFTCAP = \"Y\"  ;\n        LIMITED = \"Y\"  ;\n     END ;\n     U3  = INDEX(RECORD,\"SOFTCAPPING IS ENABLED\") ;\n     IF U3 > 0 THEN\n        LIMITED = \"Y\"  ;\n  END ;\n\n  IF LIT1 =  :\"SY\" THEN DO ;    * HAVE CAPACITY MESSAGE * ;\n     HARDWNME = SCAN(LIT1,1,\", \") ;\n     C1  = INDEX(RECORD,\"CAPACITY IS\") ;\n     IF C1 > 0 THEN\n        STRING   = TRIM(SUBSTR(RECORD,C1+12,15)) ;\n        CECCAPAC = SCAN(STRING,1,\", \") ;\n        IF LENGTH(CECCAPAC) = 1       THEN\n           CECCAPAC = \"0\"||CECCAPAC ;\n     C2  = INDEX(RECORD,\"LPAR CAPACITY IS\") ;\n     IF C2 > 0 THEN\n        STRING   = TRIM(SUBSTR(RECORD,C2+17,15)) ;\n        LPRCAPAC = SCAN(STRING,1,\", \") ;\n        IF LENGTH(LPRCAPAC) = 1       THEN\n           LPRCAPAC = \"0\"||LPRCAPAC ;\n  END ;\n\n  IF SORTKEY = PREVKEY THEN DO ;\n     OUTPUT ;\n     LPARNAME = \" \" ;\n     ROLLAVG  = \" \" ;\n     SOFTCAP  = \" \" ;\n     LIMITED  = \" \" ;\n     HARDWNME = \" \" ;\n     CECCAPAC = \" \" ;\n     LPRCAPAC = \" \" ;\n     PREVKEY  = \" \" ;\n  END ;\n\n  PREVKEY = SORTKEY ;\n  DELETE ;\n\n  DATA ;\n   SET UTILIZ ;\n   FILE OUTPUT  NOPRINT ;\n\n   RETAIN TAB \",\" ;\n   LENGTH HEAD1 HEAD2 $80 ;\n\n   HEAD1 = \"    WLM     \"||TAB||\" WLM \"||TAB||\"SYS\"||TAB||\n           \" LPAR  \"||TAB||\"LPAR \"||TAB||\"ROLLING\"||TAB||\"CEC \"||\n           TAB||\" CEC \"||TAB||\"SOFTCAP \"||TAB||\"SOFTCAP \" ;\n\n   HEAD2 = \"    DATE    \"||TAB||\"TIME \"||TAB||\"ID \"||TAB||\n           \" NAME  \"||TAB||\"CAPAC\"||TAB||\" AVG.  \"||TAB||\"NAME\"||\n           TAB||\"CAPAC\"||TAB||\"ENABLED?\"||TAB||\"IMPOSED?\" ;\n\n   IF _N_ = 1 THEN DO ;\n      PUT @1   HEAD1        $80. ;\n      PUT @1   HEAD2        $80. ;\n   END ;\n\n    PUT @1     DATE10     $10.\n        @11    TAB        $1.\n        @12    TIME5      $5.\n        @17    TAB        $1.\n        @18    SYSID      $3.\n        @21    TAB        $1.\n        @22    LPARNAME   $7.\n        @29    TAB        $1.\n        @30    LPRCAPAC   $2.\n        @32    TAB        $1.\n        @33    ROLLAVG    $2.\n        @35    TAB        $1.\n        @36    HARDWNME   $3.\n        @39    TAB        $1.\n        @40    CECCAPAC   $2.\n        @42    TAB        $1.\n        @43    LIMITED    $1.\n        @44    TAB        $1.\n        @45    SOFTCAP    $1.\n     ;\n\n  PROC PRINT DATA=UTILIZ  U SPLIT=\"*\" ;\n    VAR DATE10 TIME5 SYSID LPARNAME LPRCAPAC ROLLAVG HARDWNME\n        CECCAPAC LIMITED SOFTCAP\n     ;\n  TITLE1 \" LISTING OF WLM CPU UTILIZATION BY TIME-OF-DAY INTERVALS  \" ;\n  TITLE2 \" SORTED BY DATE AND TIME                                  \" ;\n  LABEL DATE10     = \"WLM*DATE\"\n        TIME5      = \"WLM*TIME\"\n        SYSID      = \"SYS*ID\"\n        LPARNAME   = \"LPAR*NAME\"\n        LPRCAPAC   = \"LPAR*CAPAC\"\n        ROLLAVG    = \"ROLLING*AVG\"\n        HARDWNME   = \"CEC*NAME\"\n        CECCAPAC   = \"CEC*CAPAC\"\n        LIMITED    = \"SOFTCAP*ENABLED?\"\n        SOFTCAP    = \"SOFTCAP*IMPOSED?\"\n   ;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DYBACKUP": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x19\\x01\\x10\\x03_\\x01\\x10\\x06\\x8f\\x14\\x01\\x04\\xf4\\x02A\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2010-02-04T00:00:00", "modifydate": "2010-03-09T14:01:19", "lines": 1268, "newlines": 577, "modlines": 0, "user": "TKMILLE"}, "text": "         TITLE '**** COPY RECORDS WITH DYNAMIC ALLOCATION ON OUTPUT FIL+\n               E (SYSUT2) ****'\n***********************************************************************\n*                                                                     *\n*        DDDD  Y   Y BBBB    A    CCCC K  K  U   U PPPP               *\n*        D   D  Y Y  B   B  A A  C     K K   U   U P   P              *\n*        D   D   Y   BBBB  A   A C     KK    U   U PPPP               *\n*        D   D   Y   B   B AAAAA C     K K   U   U P                  *\n*        DDDD    Y   BBBB  A   A  CCCC K  K   UUU  P                  *\n*                                                                     *\n* DATE WRITTEN: 02/04/2010 TKMILLE                                    *\n* LAST UPDATED: 03/09/2010 TKMILLE                                    *\n*                                                                     *\n* GLORIFIED IEBGENER COPY PROGRAM WHICH INPUTS THE \"SYSUT1\" FILE      *\n* AND COPIES THE DATA IN THIS FILE TO THE OUTPUT \"SYSUT2\" FILE.       *\n*                                                                     *\n* HOWEVER, THE \"SYSUT2\" DATASET NAME IS PASSED AS A LINKAGE           *\n* EXECUTION PARAMETER AND IS DYNAMICALLY ALLOCATED.                   *\n*                                                                     *\n* THE DISPOSITION (STATUS) FOR THE DYNAMIC ALLOCATION FOR DDNAME      *\n* \"SYSUT2\" IS ALSO PASSED AS A LINKAGE EXECUTION PARAMETER TO THIS    *\n* PROGRAM.                                                            *\n*                                                                     *\n* ALSO, THE SYSIN FILE CAN BE USED TO PASS TWO PARAMETERS TO          *\n* OVERRIDE DYNALC PROGRAM DEFAULTS.                                   *\n* SYSIN PARAMETERS:                                                   *\n*     ALLOCAT=NNNNNN (NUMBER OF DYNALC ATTEMPTS - IF FILE IS BUSY)    *\n*     WAITINT=NNNNNN (NUMBER OF SECONDS TO WAIT BETWEEN ATTEMPTS)     *\n*                                                                     *\n* THESE SYSIN RECORD PARAMETERS WILL OVERRIDE THE FOLLOWING DEFAULTS: *\n*  NUMBER OF DYNALC ATTEMPTS => 60 ATTEMPTS   (ALLOCAT = 60)          *\n*  WAIT INTERVAL (IN SECONDS) BETWEEN DYNALC ATTEMPTS => 10 SECONDS   *\n*  (WAITINV = 10)                                                     *\n*                                                                     *\n* EXAMPLE:                                                            *\n*                                                                     *\n* //STEP1    EXEC PGM=DYBACKUP,                                       *\n* //         PARM='OLD MY.SYSUT2.DATASET.NAME'  <= SYSUT2 DSNAME      *\n* //SYSUT1   DD DISP=SHR,DSN=INPUT.DATASET      <= SYSUT1 DSNAME      *\n* //SYSPRINT DD SYSOUT=*                                              *\n* //SYSUDUMP DD SYSOUT=*                                              *\n* //SYSIN    DD *                                                     *\n*   ALLOCAT=000006  WAITINT=000005                                    *\n* /*                                                                  *\n*                                                                     *\n* INPUT FILES:                                                        *\n*       SYSIN   - PARAMETER OVERRIDE FILE  LRECL=80 RECFM=FB          *\n*       SYSUT1  - ANY FILE TO BE COPIED TO FILE SYSUT2.  THIS FILE    *\n*                     MUST BE ALLOCATED PRIOR TO THE CALL TO THIS     *\n*                     PROGRAM.                                        *\n*                                                                     *\n* OUTPUT FILES:                                                       *\n*     SYSPRINT  - REPORT OUTPUT FILE       LRECL=133 RECFM=FB         *\n*       SYSOUT  - WTO REPORT FILE          LRECL=121 RECFM=FB         *\n*       SYSUT2  - FILE TO COPY SYSUT1 DATA TO. THIS FILE IS           *\n*                    DYNAMICALLY ALLOCATED. DCB IS MAPPED TO THE      *\n*                    SYSUT1 DCB (EXCEPT BLKSIZE) IF THE DCB RECFM     *\n*                    AND LRECL ARE NOT PRESENT PRIOR TO OPEN.         *\n*                                                                     *\n* MACROS USED:                                                        *\n*       SAVE                                                          *\n*       STORAGE                                                       *\n*       WTO                                                           *\n*       LOAD                                                          *\n*       DELETE                                                        *\n*       EXTRACT                                                       *\n*       OPEN                                                          *\n*       CLOSE                                                         *\n*       GET                                                           *\n*       PUT                                                           *\n*       RDJFCB                                                        *\n*       DYNALLOC                                                      *\n*       STIMER                                                        *\n*       DEVTYPE                                                       *\n*                                                                     *\n* PROGRAMS CALLED:                                                    *\n*       JUL2GREG - CONVERTS JULIAN DATE FORMAT TO GREGORIAN DATE      *\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*                                                                     *\n* R0      - WORK REGISTER                                             *\n* R1      - POINTS TO THE EXECUTION PARAMETER ADDRESS ON ENTRY        *\n* R2      - WORK REGISTER & MAPS THE DD ENTRIES IN THE TIOT           *\n* R3      - MAPS SYSUT1 (INPUT) DCB                                   *\n* R4      - WORK REGISTER                                             *\n* R5      - MAPS SYSUT2 (OUTPUT) DCB                                  *\n* R6      - RETURN CODE SAVE REGISTER                                 *\n* R7      - WORK REGISTER                                             *\n* R8      - WORK REGISTER & MAPS DEVTYPE INFO=AMCAP RETURN AREA       *\n* R9      - MAPS DYNAMIC ALLOCATION REQUEST BLOCK                     *\n* R10     - MAPS 2ND SAVE AREA                                        *\n* R11     - 2ND PROGRAM BASE REGISTER                                 *\n* R12     - PROGRAM BASE REGISTER                                     *\n* R13     - MAPS SAVE AREA                                            *\n* R14     - BRANCHING REGISTER                                        *\n* R15     - WORK REGISTER AND RETURN CODE                             *\n*                                                                     *\n* RETURN CODES:                                                       *\n*                                                                     *\n*    0 - SUCCESSFUL EXECUTION OF PROGRAM DYBACKUP                     *\n*   12 - FAILED EXECUTION OF PROGRAM DYBACKUP                         *\n*                                                                     *\n*                                                                     *\n* ABENDS:   NONE                                                      *\n*                                                                     *\n* ATTRIBUTES: AMODE=31,RMODE=24,RENT,REUS                             *\n*                                                                     *\n***********************************************************************\nDYBACKUP CSECT\nDYBACKUP AMODE 31\nDYBACKUP RMODE 24\n         SAVE  (14,12),,DYBACKUP_ASSEMBLED_ON_&SYSDATC._&SYSTIME\n         LR    R12,R15              LOAD ENTRY ADDRESS\n         LA    R11,2048(,R12)       CHAIN R11 TO R12 BASE\n         LA    R11,2048(,R11)\n         USING DYBACKUP,R12,R11     DECLARE ENTRY BASE REGISTERS\n         LR    R5,R1                PRESERVE PASSED PARMLIST ADDRESS\n         LR    R6,R13               STORE SAVEAREA BACKWARD LINK\n         L     R3,=A(WKAREAL)       SIZE OF STORAGE TO OBTAIN\n         STORAGE OBTAIN,LENGTH=(R3),LOC=(RES)\n         ST    R1,8(,R13)           SET SAVEAREA FORWARD LINK\n         LR    R13,R1               ADDRESS OF OBTAINED AREA\n         USING WKAREA,R13           ADDRESSABILITY TO OBTAINED AREA\nINITOBTN DS    0H                   INITIALIZE OBTAINED STORAGE AREA\n         LR    R2,R13               ADDRESS OF TARGET OF MOVE (OBTND)\n         L     R3,=A(WKAREAL)       LENGTH OF THE TARGET OF MOVE\n         XR    R14,R14             FROM ADDRESS (IRRELEVANT WITH LEN=0)\n         XR    R15,R15              PAD/LENGTH TO PROPAGATE IN ODD REG\n         MVCL  R2,R14          PROPAGATE BINARY ZEROES IN OBTAINED AREA\n         ST    R6,4(,R13)           SET SAVEAREA BACKWARD LINK\n         XR    R6,R6                ZERO THE RETURN CODE SAVE REGISTER\n         ST    R5,PARMADDR\nOBTAIN2  DS    0H                   GET A SECOND STORAGE AREA\n         L     R3,=A(WKAREAL2)      SIZE OF STORAGE AREA2 BO OBTAIN\n         STORAGE OBTAIN,LENGTH=(R3),LOC=(31)\n         LR    R10,R1               ADDRESS OF OBTAINED AREA2\n         USING WKAREA2,R10          ADDRESSABILITY TO OBTAINED AREA2\n         B     HOUSKEEP             SKIP EYECATCHER\n***********************************************************************\nMOD_LEVEL  DC  CL9'V01.01.01'      PROGRAM VERSION RELEASE MOD. LEVEL\n***********************************************************************\nHOUSKEEP DS    0H\n         MVC   HEADING1(HEADING1L),BLANKLIN     INITIALIZE\n         MVC   H1LIT1,=CL11'DYBACKUP - '        INITIALIZE\n         MVC   H1LIT2(39),=CL39'  COPY PROGRAM WITH DYNAMIC ALLOCATION'\n         MVC   H1VERS,MOD_LEVEL          MAINTENANCE LEVEL VERS.REL.MOD\n         TIME  DEC ,                     GET CURRENT DATE AND TIME\n         STM   R0,R1,CURRTIME            STORE CURRENT TIME AND JULDATE\n         MVI   CURRDATE+0,X'20'\n         UNPK  JULIANDT(7),CURRDATE(4)   STORE THE JULIAN DATE\n         OI    JULIANDT+6,X'F0'          FIX THE SIGN\n         MVC   H1DATE(4),JULIANDT\n         MVI   H1DATE+4,C'.'\n         MVC   H1DATE+5(3),JULIANDT+4\n         MVC   STORTIME,CURRTIME\n         MVI   STORTMSG,X'0F'\n         UNPK  TIME9(9),STORTIME(5)      UNPACK THE TIME\n         MVC   DISPTMHH(2),TIME9\n         MVI   DISPTMC1,C':'\n         MVC   DISPTMMM(2),TIME9+2\n         MVI   DISPTMC2,C':'\n         MVC   DISPTMSS(2),TIME9+4\n         MVC   H1TIME(8),DISPTIME\n**********************************************************************\n*  CALL PROGRAM JUL2GREG TO CONVERT A JULIAN DATE TO GREGORIAN FORMAT.\n*  INPUT  PARM => JULIAN DATE    (YYYYDDD)  7 CHARACTERS\n*  OUTPUT PARM => GREGORIAN DATE (YYYYMMDD) 8 CHARACTERS\n**********************************************************************\n         LOAD  EP=JUL2GREG       LOAD PROGRAM \"JUL2GREG\"\n         ST    R0,JUL2GENT       STORE THE ENTRY ADDRESS\n         LA    R1,JUL2GRPL       PARMLIST FOR JUL2GREG\n         LA    R0,JULIANDT       INPUT PARM JULIAN DATE\n         ST    R0,0(,R1)         STORE ADDRESS OF JULIAN DATE PARM\n         LA    R0,GREGDATE       OUTPUT PARM GREGORIAN DATE\n         ST    R0,4(,R1)         STORE ADDRESS OF GREGORIAN DATE PARM\n         OI    4(R1),X'80'       INDICATE END OF PARM ADDRESSES\n         L     R15,JUL2GENT      LOAD JUL2GREG ENTRY POINT ADDRESS\n         BASSM R14,R15           CALL \"JUL2GREG\" TO CONVERT JULIAN DATE\n         LR    R7,R15            SAVE JUL2GREG RETURN CODE\n         DELETE EP=JUL2GENT\n         LTR   R7,R7             SUCCESSFUL CALL TO JUL2GREG ?\n         BNZ   INITALL           NO - DON'T HAVE A GOOD GREGORIAN DATE\n         MVC   H1DATE(2),GREGDTMO  OVERRIDE JULIAN WITH GREGORIAN DATE\n         MVI   H1DATE+2,C'/'\n         MVC   H1DATE+3(2),GREGDTDY\n         MVI   H1DATE+5,C'/'\n         MVC   H1DATE+6(4),GREGDTYR\nINITALL  DS     0H\n         MVI   MSGCC,C' '                    INITIALIZE\n         ZAP   RECCNT,=PL1'0'                INITIALIZE\n         MVC   ALCINTDS,DFLTWINT      SET DEFAULT DYNALC WAIT INTERVAL\n         OI    ALCINTDS+L'ALCINTDS-1,X'F0'\n         MVC   ALCATTDS,DFLTATT       SET DEFAULT # OF DYNALC ATTEMPTS\n         OI    ALCATTDS+L'ALCINTDS-1,X'F0'\n**********************************************************************\n* ESTABLISH ADDRESSABILITY FOR DYNALLOC ROUTINE\n**********************************************************************\n         LA    R9,ALORB               DYNALLOC REQUEST BLOCK\n         USING S99RB,R9               MAP DYNALLOC REQUEST BLOCK\n         ST    R9,ALOPARM             PARM POINTS TO REQUEST BLOCK\n         OI    ALOPARM,X'80'          FLAG END OF PARMLIST\n         MVI   S99RBLN,S99RBEND-S99RB INSERT RB LENGTH\n         LA    R0,S99VRBAL            ALLOCATE VERB\n         STC   R0,S99VERB             SET VERB TO 'ALLOCATE'\n         LA    R0,ALODD               FIRST TEXT UNIT\n         ST    R0,S99TXTPP            TEXT UNIT LIST POINTER\n         MVC   DAIRDDNP(IAIRDDNL),IAIRDDNP RELOCATE DAIR DDNAME POINTER\n         MVC   DAIRDSNP(IAIRDSNL),IAIRDSNP RELOCATE DAIR DSNAME POINTER\n         MVC   DAIRSTAP(IAIRSTAL),IAIRSTAP RELOCATE DAIR STATUS POINTER\n         MVC   DAIRCLOS(IAIRCLOL),IAIRCLOS RELOCATE DAIR CLOSE  POINTER\n         LA    R0,DALDDNAM\n         STH   R0,DAIRDDNP            STORE TEXT UNIT KEY # FOR DDNAME\n         LA    R0,DALDSNAM\n         STH   R0,DAIRDSNP            STORE TEXT UNIT KEY # FOR DSNAME\n         LA    R0,DALSTATS\n         STH   R0,DAIRSTAP            STORE TEXT UNIT KEY # FOR STATUS\n         LA    R0,DALCLOSE\n         STH   R0,DAIRCLOS            STORE TEXT UNIT KEY # FOR CLOSE\n*\n         LA    R0,DAIRDDNP\n         ST    R0,ALODD               LOAD DAIRDDN POINTER ADDRESS\n         LA    R0,DAIRDSNP\n         ST    R0,ALODSN              LOAD DAIRDSN POINTER ADDRESS\n         LA    R0,DAIRSTAP\n         ST    R0,ALOSTAT             LOAD DAIRSTAT POINTER ADDRESS\n         LA    R0,DAIRCLOS\n         ST    R0,ALOCLOSE            LOAD DAIRCLOS POINTER ADDRESS\n         OI    ALOCLOSE,X'80'         FLAG END OF TEXT UNIT PTR LIST\n**********************************************************************\n* RELOCATE DCBS AND MACRO PARMLISTS\n**********************************************************************\n         MVC   SYSIN(SYSINIL),SYSINI         RELOCATE SYSIN  DCB\n         MVC   SYSUT1(SYSUT1IL),SYSUT1I      RELOCATE SYSUT1 DCB\n         MVC   SYS1LIST(SYS1LISL),SYS1LISI   RELOCATE SYSUT1 EXIT LIST\n         LA    R0,SYS1LIST                   POINT TO SYSUT1 EXIT LIST\n         STCM  R0,7,SYSUT1+DCBEXLSA-IHADCB   SYSUT1 EXIT LIST ADDRESS\n         MVC   DCBEUT1(DCBEUT1L),DCBEUT1I    RELOCATE SYSUT1 DCBE\n         LA    R0,DCBEUT1\n         ST    R0,SYSUT1+DCBDCBE-IHADCB      RELOCATE SYSUT1 DCBE ADDR\n         OI    DCBEFLG2-DCBE(R1),DCBEULBI    REQUEST SAM LBI FOR SYSUT1\n         MVC   SYSUT2(SYSUT2IL),SYSUT2I      RELOCATE SYSUT2 DCB\n         MVC   SYS2LIST(SYS2LISL),SYS2LISI   RELOCATE SYSUT2 EXIT LIST\n         LA    R0,SYS2LIST                   POINT TO SYSUT2 EXIT LIST\n         STCM  R0,7,SYSUT2+DCBEXLSA-IHADCB   SYSUT2 EXIT LIST ADDRESS\n         MVC   DCBEUT2(DCBEUT1L),DCBEUT2I    RELOCATE SYSUT2 DCBE\n         LA    R0,DCBEUT2\n         ST    R0,SYSUT2+DCBDCBE-IHADCB      RELOCATE SYSUT2 DCBE ADDR\n         LA    R0,JFCBARB                    POINT TO JFCB WORKAREA\n         STCM  R0,7,SYS1LIST+SYS1RJFC-SYS1LISI LOAD JFCB WORKAREA ADDR\n         STCM  R0,7,SYS2LIST+SYS2RJFC-SYS2LISI LOAD JFCB WORKAREA ADDR\n         MVC   WKRDJFCB(RDJFCBIL),RDJFCBI    RELOCATE JFCB PARM LIST\n         MVC   WKOPENCL(OPENIL),OPENI        RELOCATE OPEN/CLOSE PMLST\n         MVC   SYSPRINT(SYSPRINL),SYSPRINI   RELOCATE SYSPRINT DCB\n***********************************************************************\n*    OPEN THE SYSPRINT DCB\n***********************************************************************\n         LA    R2,SYSPRINT                   ADDR OF SYSPRINT DCB\n         LA    R4,WKOPENCL                        OPEN/CLOSE WORK AREA\n         OPEN  ((R2),OUTPUT),MODE=31,MF=(E,(R4))   OPEN SYSPRINT FILE\n         TM    SYSPRINT+DCBOFLGS-IHADCB,DCBOFOPN  SYSPRINT FILE OPEN ?\n         BO    DHEADING                    YES - GOOD OPEN ON SYSPRINT\nBADSYPRT DS    0H                           NO - DCB ERROR ON SYSPRINT\n         USING WPL,EXECWTO                       MAP PARM LIST DSECT\n         MVC   EXECWTO(WTOIL),WTOI\n         MVC   WPLTXT(L'INVOPSYS),INVOPSYS       LOAD WTO MESSAGE\n         WTO   MF=(E,EXECWTO)                    EXEC WTO MACRO\n         LA    R6,12\n         B     RETURN\nDHEADING DS    0H\n         MVC   MSGAREA,HEADING1            FORMAT HEADING LINE\n         PUT   SYSPRINT,MSGLINE            OUTPUT HEADING LINE\n         PUT   SYSPRINT,BLANKLIN           OUTPUT A BLANK LINE\nGETPARMS DS    0H\n         L     R1,PARMADDR                 LOAD PARM POINTER ADDRESS\n         L     R4,0(,R1)              POINT TO THE LINKAGE PARM ADDRESS\n         MVC   LL,0(R4)                    SAVE THE LINKAGE PARM LENGTH\n         CLC   LL,=H'5'                    LINKAGE PARM < 5 BYTES?\n         BL    LINKERR                       NO - BAD LINKAGE PARM\n         MVC   ALOCDDNM,DDSYSUT2           GET THE DDNAME FOR DYNALLOC\n         MVC   ALOCDISP,2(R4)              GET THE DISP FOR DYNALLOC\n         MVC   ALOCDSN,BLANKLIN            INITIALIZE DATASET NAME\n         LH    R2,LL\n         S     R2,=F'4'                    SUBTRACT LENGTH OF DISP PARM\n         BCTR  R2,0                        DECREMENT 1 FOR MOVE DSNAME\n         EX    R2,MOVEDSN                  GET DSNAME FOR DYNALLOC\nMOVEDSN  DS    0H\n         MVC   ALOCDSN(0),6(R4)            MOVE SYSUT2 DATASET NAME\n         MVC   SYSUT2DS,ALOCDSN            SAVE SYSUT2 DATASET NAME\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'DISPEXPM),DISPEXPM   FORMAT DISPLAY MSG\n         LH    R2,LL\n         BCTR  R2,0                        DECREMENT 1 FOR MOVE DSNAME\n         EX    R2,MOVELNKP                 LOAD EXECUTION LINKAGE PARM\nMOVELNKP DS    0H\n         MVC   MSGAREA+29(0),2(R4)\n         PUT   SYSPRINT,MSGLINE               OUTPUT MSG\n         B     FINDSYSN                    OBTAIN SYSIN PARAMETERS\nLINKERR  DS    0H\n         PUT   SYSPRINT,BLANKLIN              OUTPUT A BLANK LINE\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'INVLINKA),INVLINKA   FORMAT ERROR MSG\n         PUT   SYSPRINT,MSGLINE               OUTPUT MSG\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'INVLINKB),INVLINKB   FORMAT ERROR MSG\n         PUT   SYSPRINT,MSGLINE               OUTPUT MSG\n         LA    R6,12\n         B     ENDDATA\nFINDSYSN DS    0H\n         LA    R2,TIOTADDR\n         MVC   EXTRACTW(EXTRACTL),EXTRACTI   RELOCATE EXTRACT PLIST\n         EXTRACT (R2),FIELDS=TIOT,MF=(E,EXTRACTW) GET ADDR OF TIOT AREA\n         L     R2,TIOTADDR         LOAD ADDRESS OF TIOT INTO R2\n         USING TIOT1,R2            MAP THE START OF THE TIOT\n         LA    R2,TIOENTRY         POINT TO FIRST DD ENTRY\n         DROP  R2                  DONE WITH TIOT BASE\n         USING TIOENTRY,R2         MAP THE DD ENTRIES IN THE TIOT\n         SR    R3,R3               CLEAR R3 (WILL HOLD TIOT DD ENT LEN)\nTIOTSCAN DS    0H\n         IC    R3,TIOELNGH         1 BYTE - LENTH OF THIS TIOT DD ENTRY\n         LTR   R3,R3               0 = END OF TIOT ?\n         BZ    READJFCB             YES - DID NOT FIND SYSIN DD IN TIOT\n         CLC   DDSYSIN,TIOEDDNM    TIOT DDNAME = SYSIN ?\n         LA    R2,TIOENTRY(R3)     ADDRESS OF NEXT TIOT ENTRY\n         BNE   TIOTSCAN              NO - CHECK NEXT TIOT DDNAME\n         DROP  R2\nOPENSYSN DS    0H                               YES - HAVE SYSIN DDNAME\n         LA    R2,SYSIN                           ADDR OF SYSIN DCB\n         LA    R4,WKOPENCL                        OPEN/CLOSE WORK AREA\n         OPEN  ((R2),INPUT),MODE=31,MF=(E,(R4))   OPEN SYSIN INPUT\n         TM    SYSIN+DCBOFLGS-IHADCB,DCBOFOPN     SYSIN FILE OPEN OK ?\n         BNO   READJFCB                             NO - BAD SYSIN OPEN\nGETSYSIN DS    0H\n         GET   SYSIN,SYSINREC\n         LA    R5,SYSINREC\n         CLC   SYSINREC(SYSINRCL),BLANKLIN  IS THIS A BLANK SYSIN LINE?\n         BE    GETSYSIN                        YES - IGNORE IT\n         PUT   SYSPRINT,BLANKLIN             OUTPUT A BLANK LINE\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'DISPSNPM),DISPSNPM  FORMAT SYSIN MESSAGE\n         MVC   MSGAREA+29(SYSINRCL),SYSINREC  LOAD SYSIN RECORD\n         PUT   SYSPRINT,MSGLINE              OUTPUT MSG\n         LA    R2,SYSINREC-1                PRIME SYSIN CHAR POINTER\n         MVI   HAVSYNPM,C'N'                INITIALIZE\n***********************************************************************\n** SYSIN PARM LOOP (GET SYSIN PARAMETERS)                             *\n** TWO PARAMETERS CAN BE INPUT ON THE SYSIN RECORD:                   *\n**     ALLOCAT=NNNNNN  (NUMBER OF DYNALC  ATTEMPTS)                   *\n**     WAITINT=NNNNNN  (NUMBER OF SECONDS TO WAIT BETWEEN ATTEMPTS)   *\n***********************************************************************\nSYSINPLP   DS  0H\n         LA    R2,1(,R2)               LOOK AT NEXT CHARACTER IN RECORD\n         LA    R1,SYSINRCL(,R5)        GET THE END OF RECORD ADDRESS\n         CR    R2,R1                   EXCEEDED SYSIN RECORD LENGTH ?\n         BH    GETSYSIN                   YES - REACHED END OF RECORD\n         CLI   0(R2),C' '              HAVE A BLANK DELIMITER ?\n         BE    CHKTOKEN                   YES - THEN VALIDATE THE TOKEN\n         CLI   0(R2),C','              HAVE A COMMA DELIMITER ?\n         BE    CHKTOKEN                   YES - THEN VALIDATE THE TOKEN\n         CLI   0(R2),X'00'             HAVE A NULL DELIMITER ?\n         BE    CHKTOKEN                   YES - THEN VALIDATE THE TOKEN\n         CLI   HAVSYNPM,C'Y'           HAVE A SYSIN PARAMETER IN HAND?\n         BE    SYSINPLP                   YES - GET NEXT CHARACTER\n         MVI   HAVSYNPM,C'Y'           I HAVE A SYSIN PARM IN HAND\n         LR    R3,R2                  R3 POINTS TO START OF INPUT TOKEN\n         B     SYSINPLP\nCHKTOKEN DS    0H                     HAVE A DELIMITER CHARACTER\n         CLI   HAVSYNPM,C'Y'\n         BNE   SYSINPLP               I DO NOT HAVE A PARAMETER IN HAND\n         LR    R4,R2\n         LR    R1,R3\n         SR    R4,R1                  GET LENGTH OF PARAMETER TOKEN\n         ST    R4,SYSINTKL            STORE LENGTH OF PARAMETER TOKEN\n         BCTR  R4,0                   SUBTRACT 1 FOR EX MOVE\n         MVC   SYSINTOK,BLANKLIN\n         EX    R4,MVTOKEN\n         CLC   SYSINTKL,=A(9)         IS LENGTH OF PARM TOKEN < 9 ?\n         BL    INVSYNPM                  YES TOKEN LENGTH ERROR LOW\n         CLC   SYSINTKL,=A(14)        IS LENGTH OF PARM TOKEN < 14?\n         BH    INVSYNPM                  YES TOKEN LENGTH ERROR HIGH\n         CLC   0(8,R3),=CL8'ALLOCAT=' HAVE ALLOCATE ATTEMPTS PARM ?\n         BE    HAVATTPM                  YES\n         CLC   0(8,R3),=CL8'WAITINT=' HAVE WAIT INTERVAL PARM ?\n         BE    HAVINTPM                  YES\n         B     INVSYNPM               INVALID SYSIN PARAMETER ERROR\nMVTOKEN  DS    0H\n         MVC   SYSINTOK(0),0(R3)\nINVSYNPM DS    0H\n         PUT   SYSPRINT,BLANKLIN             OUTPUT A BLANK LINE\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'INVSNPMA),INVSNPMA  FORMAT ERROR MESSAGE\n         MVC   MSGAREA+48(L'SYSINTOK),SYSINTOK  LOAD SYSIN TOKEN\n         PUT   SYSPRINT,MSGLINE              OUTPUT MSG\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'INVSNPMB),INVSNPMB  FORMAT ERROR MESSAGE\n         PUT   SYSPRINT,MSGLINE              OUTPUT MSG\n         B     SYSINPLP                      GO GET NEXT PARM\n***********************************************************************\n*    HAVE A \"ALLOCAT=\" (# OF DYNALC ATTEMPTS) SYSIN PARAMETER\n***********************************************************************\nHAVATTPM DS    0H\n         MVI   HAVSYNPM,C'N'                 INITIALIZE FOR NEXT PARM\n         MVC   HOLDATT,INITATT               INITIALIZE LEADING ZEROS\n         LA    R7,8(,R3)                     R7 IS START OF PARM ADDR\n         L     R1,SYSINTKL                   GET TOKEN LENGTH OF PARM\n         SH    R1,=H'8'                      R1 HAS LENGTH OF PARM\n         LR    R8,R7\n         AR    R8,R1                         R8 IS END OF PARM ADDR\n         LA    R4,HOLDATT                    POINT TO TARGET FIELD\n         LA    R3,ALCATTDL                   GET LENGTH OF TARGET FLD\n         SR    R3,R1\n         AR    R4,R3                         POINT TARGET CHAR TO START\n***********************************************************************\n*    EDIT THE \"ALLOCAT=\" PARAMETER FOR NUMERIC DIGITS\n*    OVERRIDE THE \"ACLATTDS\" PROGRAM DEFAULT VALUE\n***********************************************************************\nHAVATT1  DS    0H\n         BAS   R14,NUMEDIT                   BRANCH TO NUMERIC EDIT\n         MVC   0(1,R4),0(R7)                 MOVE 1 BYTE AT A TIME\n         LA    R4,1(,R4)                      FOR LENGTH OF PARM\n         LA    R7,1(,R7)                     POINT TO NEXT CHARACTER\n         CR    R7,R8                         FINISHED LOADING TARGET?\n         BL    HAVATT1                         NO - MOVE NEXT CHAR\n         MVC   ALCATTDS,HOLDATT               YES - OVERRIDE THE PARM\n         B     SYSINPLP                      GO GET NEXT PARM\n***********************************************************************\n*    HAVE A \"WAITINT=\" (WAIT INVERVAL IN SECONDS) SYSIN PARAMETER\n***********************************************************************\nHAVINTPM DS    0H\n         MVI   HAVSYNPM,C'N'                 INITIALIZE FOR NEXT PARM\n         MVC   HOLDINT,INITINT               INITIALIZE LEADING ZEROS\n         LA    R7,8(,R3)                     R7 IS START OF PARM ADDR\n         L     R1,SYSINTKL                   GET TOKEN LENGTH OF PARM\n         SH    R1,=H'8'                      R1 HAS LENGTH OF PARM\n         LR    R8,R7\n         AR    R8,R1                         R8 IS END OF PARM ADDR\n         LA    R4,HOLDINT                    POINT TO TARGET FIELD\n         LA    R3,ALCATTDL                   GET LENGTH OF TARGET FLD\n         SR    R3,R1\n         AR    R4,R3                         POINT TARGET CHAR TO START\n***********************************************************************\n*    EDIT THE \"WAITINT=\" PARAMETER FOR NUMERIC DIGITS\n*    OVERRIDE THE \"ACLINTDS\" PROGRAM DEFAULT VALUE\n***********************************************************************\nHAVINT1  DS    0H\n         BAS   R14,NUMEDIT                   BRANCH TO NUMERIC EDIT\n         MVC   0(1,R4),0(R7)                 MOVE 1 BYTE AT A TIME\n         LA    R4,1(,R4)                      FOR LENGTH OF PARM\n         LA    R7,1(,R7)                     POINT TO NEXT CHARACTER\n         CR    R7,R8                         FINISHED LOADING TARGET?\n         BL    HAVINT1                         NO - MOVE NEXT CHAR\n         MVC   ALCINTDS,HOLDINT               YES - OVERRIDE THE PARM\n         B     SYSINPLP                      GO GET NEXT PARM\n***********************************************************************\n*    NUMERIC EDIT UPON EBCDIC WHOLE NUMBER PARAMETER\n***********************************************************************\nNUMEDIT  DS    0H\n         CLC   =CL1'0',0(R7)                 PASS LOW NUMERIC CHECK ?\n         BH    INVSYNPM                        NO - INVALID NUMERIC\n         CLC   =CL1'9',0(R7)                 PASS HIGH NUMERIC CHECK ?\n         BL    INVSYNPM                        NO - INVALID NUMERIC\n         BR    R14                           RETURN FROM BAS\nENDSYSIN DS    0H\n         LA    R3,SYSIN                      DCB TO CLOSE\n         LA    R4,WKOPENCL                   OPEN/CLOSE WORK AREA\n         CLOSE ((R3)),MODE=31,MF=(E,(R4))    CLOSE SYSIN DCB\n***********************************************************************\n*  OBTAIN THE SYSUT1 DATASET NAME FOR DISPLAY USING THE RDJFCB MACRO\n***********************************************************************\nREADJFCB DS    0H\n         LA    R3,SYSUT1                     ADDR OF SYSUT1 DCB\n         LA    R5,SYSUT2                     ADDR OF SYSUT2 DCB\nINFILE   USING IHADCB,R3                     MAP SYSUT1 DCB (INFILE)\nOUTFILE  USING IHADCB,R5                     MAP SYSUT2 DCB (OUTFILE)\n*\n         XC    JFCBARB(JFCBLGTH),JFCBARB     INIT JFCB WORK AREA BUFFER\n*\n         RDJFCB ((R3)),MF=(E,WKRDJFCB)       READ JFCB FOR SYSUT1\n*\n         LTR   R15,R15                       GOOD JFCB READ ?\n         BZ    ENDJFCB1                        YES - HAVE SYSUT1 DSNAME\n*\n         CVD   R15,DOUBLE                 CONVERT RC TO PACKED DECIMAL4\n         UNPK  UNPACK15(15),DOUBLE(8)     UNPACK IT\n         OI    UNPACK15+14,X'F0'       CHANGE SIGN TO ABSOLUTE POSITIVE\n         MVC   DISPRC,UNPACK15+11      MOVE TO RETURN CODE DECIMAL DISP\n*\n         PUT   SYSPRINT,BLANKLIN             OUTPUT A BLANK LINE\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'JFCBRDER),JFCBRDER  FORMAT ERROR MESSAGE\n         MVC   MSGAREA+46(L'DDSYSUT1),DDSYSUT1   DDNAME\n         MVC   MSGAREA+73(L'DISPRC),DISPRC       RETURN CODE\n         PUT   SYSPRINT,MSGLINE              OUTPUT MSG\n         LA    R6,12\n         B     ENDDATA\nENDJFCB1 DS    0H\n         MVC   SYSUT1DS,JFCBDSNM      SAVE SYSUT1 DATASET NAME\n**********************************************************************\n* FIND THE STATUS DISPOSITION IN THE DISPOSTITION TABLE TO OBTAIN\n*    THE TEXT UNIT KEY VALUE FOR THE DAIR STATUS (DISPOSITION).\n**********************************************************************\n         LA    R2,DISPTBLE            PREPARE FOR DISP TABLE SEARCH\nLOOPDISP DS    0H\n         CLI   0(R2),X'FF'            HIT END OF DISPOSITION TABLE ?\n         BE    DISPERR                  YES - DISPOSITION NOT FOUND\n         CLC   0(3,R2),ALOCDISP       DISPOSITION FOUND IN TABLE ?\n         BE    DAIRPRMS                 YES - DISPLAY PARMS\n         LA    R2,4(,R2)              GET NEXT DISPOSITION ENTRY\n         B     LOOPDISP\nDISPERR  DS    0H\n         PUT   SYSPRINT,BLANKLIN           OUTPUT A BLANK LINE\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'INVLINKA),INVLINKA   FORMAT ERROR MSG\n         PUT   SYSPRINT,MSGLINE            OUTPUT MSG\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'INVLINKB),INVLINKB   FORMAT ERROR MSG\n         PUT   SYSPRINT,MSGLINE            OUTPUT MSG\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'INVDISPA),INVDISPA   FORMAT ERROR MSG\n         PUT   SYSPRINT,MSGLINE            OUTPUT MSG\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'INVDISPB),INVDISPB   FORMAT ERROR MSG\n         PUT   SYSPRINT,MSGLINE            OUTPUT MSG\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'INVDISPC),INVDISPC   FORMAT ERROR MSG\n         MVC   MSGAREA+36(L'ALOCDISP),ALOCDISP\n         PUT   SYSPRINT,MSGLINE            OUTPUT MSG\n         LA    R6,12\n         B     ENDDATA\nDAIRPRMS DS    0H                     LOAD DAIR PARM VALUES\n         MVC   DAIRDDN,ALOCDDNM       LOAD DDNAME TEXT UNIT VALUE\n         MVC   DAIRDSN,ALOCDSN        LOAD DSNAME TEXT UNIT VALUE\n         MVC   DAIRSTAT,3(R2)         LOAD STATUS TEXT UNIT VALUE\n*\nDISPDSNS DS    0H\n         PUT   SYSPRINT,BLANKLIN           OUTPUT A BLANK LINE\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'SYSUT1MS),SYSUT1MS    FORMAT DISPLAY MSG\n         MVC   MSGAREA+38(L'SYSUT1DS),SYSUT1DS\n         PUT   SYSPRINT,MSGLINE            OUTPUT MSG\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'SYSUT2MS),SYSUT2MS   FORMAT DISPLAY MSG\n         MVC   MSGAREA+38(L'SYSUT2DS),SYSUT2DS\n         PUT   SYSPRINT,MSGLINE            OUTPUT MSG\n*\n         PUT   SYSPRINT,BLANKLIN           OUTPUT A BLANK LINE\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'DYNALPMA),DYNALPMA   FORMAT DISPLAY MSG\n         PUT   SYSPRINT,MSGLINE            OUTPUT MSG\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'DYNALPMB),DYNALPMB   FORMAT DISPLAY MSG\n         MVC   MSGAREA+62(L'ALOCDISP),ALOCDISP\n         PUT   SYSPRINT,MSGLINE            OUTPUT MSG\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'DYNALATT),DYNALATT   FORMAT DISPLAY MSG\n         MVC   MSGAREA+62(L'ALCATTDS),ALCATTDS\n         PUT   SYSPRINT,MSGLINE            OUTPUT MSG\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'DYNALINT),DYNALINT   FORMAT DISPLAY MSG\n         MVC   MSGAREA+62(L'ALCINTDS),ALCINTDS\n         PUT   SYSPRINT,MSGLINE            OUTPUT MSG\n         PUT   SYSPRINT,BLANKLIN           OUTPUT A BLANK LINE\n*\nCNVTPRMS DS    0H\n         PACK  DOUBLE,ALCINTDS        CONVERT ZONED DECIMAL TO BINARY\n         CVB   R1,DOUBLE              CONVERT TO BINARY\n         MH    R1,=H'100'             MULTIPLY BY 100 FOR HUNDS OF SECS\n         ST    R1,ALOCWINT\n         PACK  DOUBLE,ALCATTDS        CONVERT ZONED DECIMAL TO BINARY\n         CVB   R8,DOUBLE              CONVERT TO BINARY\n         ST    R8,ALOCATTS            R8 HAS # DYNALC ATTEMPTS\n**********************************************************************\n*    CALL DYNALLOC (SVC99) TO ALLOCATE DDNAME SYSUT2.\n**********************************************************************\nGOALLOC  DS    0H                     DYNAMIC ALLOCATION LOOP\n         LA    R1,ALOPARM             ALLOCATION PARM LIST\n*\n         DYNALLOC ,                   ISSUE DYNAMIC ALLOCATION (SVC99)\n*\n         LTR   R15,15                 CHECK DYNAMIC ALLOCATION RC=0?\n         BZ    READJFC2                 YES\n*                                       NO\n         CLC   S99ERROR,X0210         ALLOCATED TO ANOTHER TASK?\n         BNE   DYNALERR                 NO  - DISPLAY ERROR CODES\n*                                       YES - DSN IN USE - RETRY\n         S     R8,F001                MINUS 1 FROM NUMBER OF ATTEMPTS\n         CL    R8,F000                NUMBER OF ATTEMPTS = ZERO?\n         BNH   TIMEOUT                  YES - EXHAUSTED WAIT ATTEMPTS\n*\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'DSNINUSE),DSNINUSE   FORMAT IN-USE MSG\n         MVC   MSGAREA+58(L'ALCINTDS),ALCINTDS\n         PUT   SYSPRINT,MSGLINE               OUTPUT MSG\n*\n         STIMER WAIT,BINTVL=ALOCWINT , WAIT BINTVL HUNDRED SECONDS\n*\n         B     GOALLOC                TRY THE ALLOCATION AGAIN\n**********************************************************************\n* COULD NOT ALLOCATE THE IN-USE FILE AFTER MAXIMUM NUMBER OF ATTEMPTS.\n**********************************************************************\nTIMEOUT  DS    0H\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'DSNINUSE),DSNINUSE   FORMAT IN-USE MSG\n         MVC   MSGAREA+48(85),BLANKLIN        BLANK END OF MESSAGE\n         PUT   SYSPRINT,MSGLINE               OUTPUT MSG\n*\n         PUT   SYSPRINT,BLANKLIN        TOO MANY IN-USE ATTEMPTS\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'WTTIMEOT),WTTIMEOT   FORMAT ERROR MSG\n         MVC   MSGAREA+91(L'ALCATTDS),ALCATTDS\n         PUT   SYSPRINT,MSGLINE            OUTPUT MSG\n         LA    R6,12\n         B     ENDDATA\nDYNALERR DS    0H\n**********************************************************************\n*    DISPLAY RETURN/ERROR/REASON CODES\n**********************************************************************\n         STH   R15,ALCRETCD           OBTAIN SVC99 RETURN CODE\n         UNPK  DOUBLE(5),ALCRETCD(3)  OBTAIN STATUS CODE (RETCD)\n         MVZ   DOUBLE+2(2),HEX0F0F    TURN OFF ZONES\n         TR    DOUBLE+2(2),HEXCHAR    TRANSLATE TO PRINTABLE\n         MVC   ALCRETCD,DOUBLE+2      MOVE TO RETURN CODE HEX2\n*\n         CVD   R15,DOUBLE             CONVERT RETCD TO PACKED DECIMAL\n         UNPK  UNPACK15(15),DOUBLE(8) UNPACK IT\n         OI    UNPACK15+14,X'F0'      CHANGE SIGN TO ABSOLUTE POSITIVE\n         MVC   ALCRETDC,UNPACK15+13   MOVE TO RETURN CODE DECIMAL2\n*\n         UNPK  DOUBLE(5),S99ERROR(3)  OBTAIN SVC99 ERROR CODE\n         MVZ   DOUBLE(4),HEX0F0F      TURN OFF ZONES\n         TR    DOUBLE(4),HEXCHAR      TRANSLATE TO PRINTABLE\n         MVC   ALCERRCD,DOUBLE        MOVE TO ERROR CODE HEX4\n*\n         LH    R1,S99ERROR            OBTAIN SVC99 ERROR CODE\n         CVD   R1,DOUBLE              CONVERT TO PACKED DECIMAL4\n         UNPK  UNPACK15(15),DOUBLE(8) UNPACK IT\n         OI    UNPACK15+14,X'F0'      CHANGE SIGN TO ABSOLUTE POSITIVE\n         MVC   ALCERRDC,UNPACK15+11   MOVE TO ERROR CODE DECIMAL\n*\n         UNPK  DOUBLE(5),S99INFO(3)   OBTAIN SVC99 REASON CODE\n         MVZ   DOUBLE(4),HEX0F0F      TURN OFF ZONES\n         TR    DOUBLE(4),HEXCHAR      TRANSLATE TO PRINTABLE\n         MVC   ALCRSNCD,DOUBLE        MOVE TO REASON CODE HEX4\n*\n         LH    R1,S99INFO             OBTAIN SVC99 REASON CODE\n         CVD   R1,DOUBLE              CONVERT TO PACKED DECIMAL\n         UNPK  UNPACK15(15),DOUBLE(8) UNPACK IT\n         OI    UNPACK15+14,X'F0'      CHANGE SIGN TO ABSOLUTE POSITIVE\n         MVC   ALCRSNDC,UNPACK15+11   MOVE TO REASON CODE DECIMAL4\n*\n         PUT   SYSPRINT,BLANKLIN      DISPLAY RETURN/ERROR CODES\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'DYNALCFL),DYNALCFL      FORMAT ERROR MSG\n         MVC   MSGAREA+52(L'ALCRETCD),ALCRETCD   FORMAT RETURN CODE\n         MVC   MSGAREA+56(L'ALCRETDC),ALCRETDC   FORMAT RETURN CODE\n         MVC   MSGAREA+73(L'ALCERRCD),ALCERRCD   FORMAT ERROR  CODE\n         MVC   MSGAREA+79(L'ALCERRDC),ALCERRDC   FORMAT ERROR  CODE\n         MVC   MSGAREA+99(L'ALCRSNCD),ALCRSNCD   FORMAT REASON CODE\n         MVC   MSGAREA+105(L'ALCRSNDC),ALCRSNDC  FORMAT REASON CODE\n         PUT   SYSPRINT,MSGLINE                  OUTPUT MSG\n         PUT   SYSPRINT,BLANKLIN\n         LA    R6,12\n         B     ENDDATA\nREADJFC2 DS    0H\n***********************************************************************\n*  OBTAIN THE SYSUT2 DCB INFORMATION USING THE RDJFCB MACRO\n*  OBTAIN THE DSORG, RECFM, AND LRECL FOR SYSUT2 PRIOR TO THE\n*  OPEN FOR FILE SYSUT2.\n***********************************************************************\n*\n         XC    JFCBARB(JFCBLGTH),JFCBARB     INIT JFCB WORK AREA BUFFER\n*\n         RDJFCB ((R5)),MF=(E,WKRDJFCB)       READ JFCB FOR SYSUT2\n*\n         LTR   R15,R15                       GOOD JFCB READ ?\n         BZ    ENDJFCB2                        YES - HAVE SYSUT1 DSNAME\n*\n         CVD   R15,DOUBLE                 CONVERT RC TO PACKED DECIMAL4\n         UNPK  UNPACK15(15),DOUBLE(8)     UNPACK IT\n         OI    UNPACK15+14,X'F0'       CHANGE SIGN TO ABSOLUTE POSITIVE\n         MVC   DISPRC,UNPACK15+11      MOVE TO RETURN CODE DECIMAL DISP\n*\n         PUT   SYSPRINT,BLANKLIN             OUTPUT A BLANK LINE\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'JFCBRDER),JFCBRDER  FORMAT ERROR MESSAGE\n         MVC   MSGAREA+46(L'DDSYSUT2),DDSYSUT2   DDNAME\n         MVC   MSGAREA+73(L'DISPRC),DISPRC       RETURN CODE\n         PUT   SYSPRINT,MSGLINE              OUTPUT MSG\n         LA    R6,12\n         B     ENDDATA\nENDJFCB2 DS    0H\n         MVC   S2DSORG,JFCDSORG              SAVE SYSUT2 JFCB DSORG\n         MVC   S2RECFM,JFCRECFM              SAVE SYSUT2 JFCB RECFM\n         MVC   S2LRECL,JFCLRECL              SAVE SYSUT2 JFCB LRECL\nOPENSYS1 DS    0H\n***********************************************************************\n*    OPEN THE SYSUT1 (INFILE) DCB\n***********************************************************************\n         LA    R4,WKOPENCL                        OPEN/CLOSE WORK AREA\n         OPEN  ((R3),INPUT),MODE=31,MF=(E,(R4))   OPEN SYSUT1 INPUT\n         TM    SYSUT1+DCBOFLGS-IHADCB,DCBOFOPN    SYSUT1 FILE OPEN OK ?\n         BNO   BADSYS1A                            NO - BAD SYSUT1 OPEN\n         LA    R2,DCBEUT1                  ADDR OF SYSUT1 DCBE (INFILE)\n         TM    DCBEFLG1-DCBE(R2),DCBEMD31      IS DCBE 31 Bit Mode on ?\n         BNO   BADSYS1A               31 BIT MODE DCBE IS NOT SUPPORTED\n         TM    DCBEFLG1-DCBE(R2),DCBEOPEN   WAS SYSUT1 DCBE OPENED OK ?\n         BO    GOODSYS1                       YES\nBADSYS1A DS    0H                         NO - DCB ERROR ON SYSUT1 OPEN\n         PUT   SYSPRINT,BLANKLIN           OUTPUT A BLANK LINE\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'INVOPSY1),INVOPSY1  FORMAT ERROR MESSAGE\n         PUT   SYSPRINT,MSGLINE              OUTPUT MSG\n         LA    R6,12\n         B     ENDDATA\nGOODSYS1 DS    0H\n*********************************************************************\n* OBTAIN THE MAXIMUM ALLOWABLE BLKSIZE FOR SYSUT2'S DEVICE TYPE\n* USING THE DEVTYPE MACRO.\n* (See IBM DFSMSdfp Advanced Services Manual SC26-7400-07)\n*********************************************************************\n         MVI   DEVAREA,C' '\n         MVC   DEVAREA+1(DEVTDL-1),DEVAREA\n         MVC   DEVTYPDD,DDSYSUT2           LOAD DDNAME FOR DEVTYPE\n         MVC   DEVTYP(DEVTYPEL),DEVTYPEI   RELOCATE DEVTYPE MACRO PL\n         DEVTYPE DEVTYPDD,(DEVAREA,DEVTDL),MF=(E,DEVTYP)\n         LTR   R15,R15                      CALL OK ?\n         BNZ   MAPDCBS                       - NO - GO ON ANYWAY\n         LA    R8,DEVAREA\n         USING DVAAMCAP,R8                 MAP DEVAREA FOR INFO=AMCAP\n*********************************************************************\n* IS SYSUT1 BLKSIZE GREATER THAN MAX. ALLOWABLE BLKSIZE FOR SYSUT2 ?\n* IF SO, ERROR.  CANNOT LOWER THE BLKSIZE ON THE COPY TO SYSUT2.\n* MAXIMUM ALLOWABLE BLKSIZE IS +8 OFF DEVTYPE RETURN WORK AREA FOR\n* 8 BYTES.\n*********************************************************************\n         LA    R2,DCBEUT1\n         LA    R2,DCBEBLKSI8-DCBE(,R2)       POINT TO SYSUT1 BLKSIZE\n         CLC   0(8,R2),DVAMAXBLK COMPARE SYSUT1 BLKSZ TO MAX ALLOWABLE\n         BNH   MAPDCBS                  BLKSIZE IS WITHIN DEVICE LIMIT\n         PUT   SYSPRINT,BLANKLIN           OUTPUT A BLANK LINE\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'INVBLS1A),INVBLS1A  FORMAT ERROR MESSAGE\n         PUT   SYSPRINT,MSGLINE              OUTPUT MSG\n         MVC   DOUBLE(8),0(R2)  PREPARE TO CONVERT BLKSIZE TO DECIMAL\n         BAS   R14,CVTODISP               BRANCH TO CONVERT TO DECIMAL\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'INVBLS1B),INVBLS1B  FORMAT ERROR MESSAGE\n         MVC   MSGAREA+54(L'DISPLY16),DISPLY16\n         PUT   SYSPRINT,MSGLINE              OUTPUT MSG\n         MVC   DOUBLE(8),DVAMAXBLK PREPARE TO CONVERT MAX ALLOW TO DEC\n         BAS   R14,CVTODISP               BRANCH TO CONVERT TO DECIMAL\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'INVBLS1C),INVBLS1C  FORMAT ERROR MESSAGE\n         MVC   MSGAREA+54(L'DISPLY16),DISPLY16\n         PUT   SYSPRINT,MSGLINE              OUTPUT MSG\n         LA    R6,12\n         B     ENDDATA\n         DROP  R8\nCVTODISP DS    0H\n         SAM64                  SWITCH TO 64 BIT MODE\n         LG    R1,DOUBLE        LOAD DOUBLE WORD\n         CVDG  R1,QUADWORD      CONVERT 64 BIT WORD TO DECIMAL\n         SAM31                  SWITCH BACK TO 31 BIT MODE\n         UNPK  UNPACK15(15),QUADWORD+8(8)  UNPACK 8 BYTES\n         OI    UNPACK15+14,X'F0'           FIX SIGN\n         MVC   DISPLY16+1(15),UNPACK15     MOVE LOW 15 DIGITS\n         UNPK  UNPACK15(15),QUADWORD(8)    UNPACK 8 BYTES\n         OI    UNPACK15+14,X'F0'           FIX SIGN\n         MVC   DISPLY16(1),UNPACK15+14     PICK UP HIGH DIGIT\n         BR    R14                         RETURN FROM BAS\n*\nMAPDCBS  DS    0H                    MAP SYSUT2 DCB FROM SYSUT1 DCB\n         CLC   S2DSORG,=AL2(0)       SYSUT2 JFCB DSORG PRESENT ?\n         BNE   MAPRECFM                  YES\n         MVC   OUTFILE.DCBDSORG,INFILE.DCBDSORG  MAP DSORG SYSUT1=>2\nMAPRECFM DS    0H\n         CLC   S2RECFM,=AL1(0)       SYSUT2 JFCB RECFM PRESENT ?\n         BNE   MAPLRECL                  YES\n         MVC   OUTFILE.DCBRECFM,INFILE.DCBRECFM  MAP RECFM SYSUT1=>2\nMAPLRECL DS    0H\n         CLC   S2LRECL,=AL2(0)       SYSUT2 JFCB LRECL PRESENT ?\n         BNE   ENDMAPDC                  YES\n         MVC   OUTFILE.DCBLRECL,INFILE.DCBLRECL  MAP LRECL SYSUT1=>2\nENDMAPDC DS    0H\n***********************************************************************\n* Your DCB OPEN exit can test bit DCBESLBI to learn if the access\n* method supports LBI. If your program did not request unlike\n* attributes processing (by turning on bit DCBOFPPC) before\n* issuing OPEN, then DCBESLBI being on means that all the data\n* sets in the concatenation support LBI . If your program\n* requested unlike attributes processing before OPEN, then\n* DCBESLBI being on each time that the system calls your DCB OPEN\n* exit or JFCBE exit means only that the next data set supports\n* LBI. After the exit, OPEN leaves DCBESLBI on ONLY if DCBEULBI\n* also is on.  Your exit routine can change DCBEULBI.\n* Never change DCBESLBI.\n***********************************************************************\n         LA    R2,DCBEUT1            ADDR OF SYSUT1 DCBE (INFILE)\n         LA    R4,DCBEUT2            ADDR OF SYSUT2 DCBE (OUTFILE)\n         TM    DCBEFLG1-DCBE(R2),DCBESLBI   IS SAM LBI SUPPORTED?\n         BNO   CHKDSORG                        NO - SAM LBI IS NOT ON\n***********************************************************************\n* DON'T MAP (OVERRIDE) THE BLKSIZE.  LEAVE COMMENTED OUT UNLESS YOU\n* WANT TO IMPOSE THE BLKSIZE VALUE FROM SYSUT1 UPON SYSUT2.\n***********************************************************************\n****     MVC   DCBEBLKSI8-DCBE(8,R4),DCBEBLKSI8-DCBE(R2)   MAP BLKSIZE\nCHKDSORG DS    0H\n         CLI   INFILE.DCBDSRG1,DCBDSGPS           IS DSORG = 'PS' ?\n         BE    OPENSYS2                              YES\n         MVC   DSORGSAV,INFILE.DCBDSORG    SAVE DSORG VALUE FOR DISPLAY\n         PUT   SYSPRINT,BLANKLIN           OUTPUT A BLANK LINE\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'INVDSORA),INVDSORA  FORMAT ERROR MESSAGE\n         PUT   SYSPRINT,MSGLINE              OUTPUT MSG\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'INVDSORB),INVDSORB  FORMAT ERROR MESSAGE\n         MVC   MSGAREA+28(L'DCBDSORG),INFILE.DCBDSORG\n         PUT   SYSPRINT,MSGLINE              OUTPUT MSG\n         LA    R6,12\n         B     ENDDATA\nOPENSYS2 DS    0H\n         TM    DCBEFLG1-DCBE(R2),DCBESLBI   IS SAM LBI SUPPORTED/UESED?\n         BNO   OSYSUT2                         NO - SAM LBI IS NOT ON\n         LA    R1,DCBEUT2                 ADDR OF SYSUT2 DCBE (OUTFILE)\n         OI    DCBEFLG2-DCBE(R1),DCBEULBI   REQUEST SAM LBI FOR SYSUT2\n***********************************************************************\n*    OPEN THE SYSUT2 (OUTFILE) DCB\n***********************************************************************\nOSYSUT2  DS    0H\n         LA    R4,WKOPENCL                OPEN/CLOSE WORK AREA\n         OPEN  ((R5),OUTPUT),MODE=31,MF=(E,(R4)) OPEN SYSUT2 OUTPUT\n         TM    SYSUT2+DCBOFLGS-IHADCB,DCBOFOPN   SYSUT2 FILE OPEN OK ?\n         BNO   BADSYS2A                           NO - BAD SYSUT2 OPEN\n         LA    R1,DCBEUT2                ADDR OF SYSUT2 DCBE (OUTFILE)\n         TM    DCBEFLG1-DCBE(R1),DCBEOPEN    WAS DCBE OPENED OK ?\n         BO    READLOOP                         YES - GOOD SYSUT2 OPEN\nBADSYS2A DS    0H                                BAD SYSUT2 OPEN\n         PUT   SYSPRINT,BLANKLIN           OUTPUT A BLANK LINE\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'INVOPSY2),INVOPSY2  FORMAT ERROR MESSAGE\n         PUT   SYSPRINT,MSGLINE              OUTPUT MSG\n         LA    R6,12\n         B     ENDDATA\n***********************************************************************\n* READ/WRITE DATA LOOP UNTIL SYSUT1-EOF.\n***********************************************************************\nREADLOOP DS    0H\n         GET   SYSUT1,INPAREA                    READ INPUT SYSUT1 FILE\n         CLI   INFILE.DCBRECFM,DCBRECU               IS RECFM = 'U' ?\n         BNE   NOTRECFU                                 NO NOT RECFM=U\n         MVC   OUTFILE.DCBLRECL,INFILE.DCBLRECL     REMAP FOR RECFM=U\nNOTRECFU DS    0H\n         PUT   SYSUT2,INPAREA        WRITE RECORD TO OUTPUT SYSUT2 FILE\n         AP    RECCNT,=PL1'1'                  INCREMENT RECORD COUNTER\n         B     READLOOP\n*\n***********************************************************************\n*    END OF INPUT=>OUTPUT (SYSUT1=>SYSUT2) LOOP\n***********************************************************************\nENDDATA  DS    0H\n         TM    SYSUT1+DCBOFLGS-IHADCB,DCBOFOPN        SYSUT1 FILE OPEN?\n         BNO   CLOSSYS2                                 NO - SKIP CLOSE\n***********************************************************************\n*    CLOSE THE SYSUT1 DCB\n***********************************************************************\n         LA    R4,WKOPENCL                         OPEN/CLOSE WORK AREA\n         CLOSE ((R3)),MODE=31,MF=(E,(R4))          CLOSE SYSUT1 FILE\nCLOSSYS2 DS    0H\n         TM    SYSUT2+DCBOFLGS-IHADCB,DCBOFOPN     SYSUT2 FILE OPEN?\n         BNO   CLOSSYSP                               NO - SKIP CLOSE\n***********************************************************************\n*    CLOSE THE SYSUT2 DCB (ALSO UNALLOCATES THE SYSUT2 FILE).\n***********************************************************************\n         LA    R4,WKOPENCL                         OPEN/CLOSE WORK AREA\n         CLOSE ((R5)),MODE=31,MF=(E,(R4))          CLOSE SYSUT2 FILE\nCLOSSYSP DS    0H\n         LA    R2,SYSPRINT\n         TM    SYSPRINT+DCBOFLGS-IHADCB,DCBOFOPN  SYSPRINT FILE OPEN?\n         BNO   RETURN                                NO - SKIP SUMMARY\n         UNPK  DISPCNT,RECCNT\n         OI    DISPCNT+10,X'F0'\n         PUT   SYSPRINT,BLANKLIN                   OUTPUT A BLANK LINE\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'SUMMARY),SUMMARY       FORMAT SUMMARY MESSAGE\n         MVC   MSGAREA+62(L'DISPCNT),DISPCNT    RECORD COUNT\n         PUT   SYSPRINT,MSGLINE                 OUTPUT MSG\n         PUT   SYSPRINT,BLANKLIN                OUTPUT A BLANK LINE\n*\n         CVD   R6,DOUBLE              CONVERT RC TO PACKED DECIMAL4\n         UNPK  UNPACK15(15),DOUBLE(8) UNPACK IT\n         OI    UNPACK15+14,X'F0'      CHANGE SIGN TO ABSOLUTE POSITIVE\n         MVC   DISPRC,UNPACK15+11     MOVE TO RETURN CODE DECIMAL DISP\n         MVC   MSGLINE,BLANKLIN\n         MVC   MSGAREA(L'SUMMRC),SUMMRC         FORMAT RETCODE MESSAGE\n         MVC   MSGAREA+26(L'DISPRC),DISPRC      DYBACKUP RETURN CODE\n         PUT   SYSPRINT,MSGLINE                 OUTPUT MSG\n         PUT   SYSPRINT,BLANKLIN                OUTPUT A BLANK LINE\n***********************************************************************\n*    CLOSE THE SYSPRINT DCB\n***********************************************************************\n         L     R2,SYSPRINT\n         LA    R4,WKOPENCL                      OPEN/CLOSE WORK AREA\n         CLOSE ((R2)),MODE=31,MF=(E,(R4))       CLOSE SYSPRINT FILE\nRETURN   DS    0H\n         DROP  INFILE,OUTFILE\n         LR    R2,R10                        POINTER TO STORAGE AREA\n         L     R4,=A(WKAREAL2)               SIZE OF STORAGE OBTAINED\n         STORAGE RELEASE,LENGTH=(R4),ADDR=(R2)\n         LR    R2,R13                        POINTER TO STORAGE AREA\n         L     R4,=A(WKAREAL)                SIZE OF STORAGE OBTAINED\n         L     R13,4(,R13)          RESTORE CALLER'S SAVEAREA ADDRESS\n         STORAGE RELEASE,LENGTH=(R4),ADDR=(R2)\n         L     R14,12(,R13)                  RESTORE R14\n         LR    R15,R6                        LOAD RETURN CODE\n         LM    R0,R12,20(R13)                RESTORE CALLER'S REGISTERS\n         BSM   0,R14                         RETURN TO PROGRAM CALLER\n*\n**********************************************************************\n*  STATIC STORAGE FOLLOWS\n**********************************************************************\n*  MACROS AND PARAMETER LISTS TO RELOCATE\n**********************************************************************\nOPENI     OPEN  (0,OUTPUT),MODE=31,MF=L\nOPENIL    EQU   *-OPENI\n*\nWTOI      DS    0F\n          WTO   '                                                      +\n                                                                       +\n                               ',MF=L,ROUTCDE=(11)\nWTOIL     EQU   *-WTOI\n*\nBLANKLIN  DC    CL133' '\nDDSYSIN   DC    CL8'SYSIN   '         SYSIN  DDNAME\nDDSYSUT1  DC    CL8'SYSUT1  '         INPUT  DDNAME\nDDSYSUT2  DC    CL8'SYSUT2  '         OUTPUT DDNAME (DYNAMIC ALLOCATED)\n*\n**********************************************************************\n*  MESSAGE LITERALS\n**********************************************************************\nDISPEXPM  DC   C'DYBACKUP - EXECUTION PARM =>                          +\n                                                                       +\n                                               '\nINVLINKA  DC   C'DYBACKUP - INVALID EXECUTION PARM PASSED TO DYBACKUP P+\n               ROGRAM !'\nINVLINKB  DC   C'DYBACKUP - EXECUTION PARMAMETER LIST SHOULD BE: DISPOS+\n               ITION (1:3) DATASET NAME (4:47)'\nINVOPSYS  DC   C'DYBACKUP - ERROR OPENING THE SYSPRINT FILE !!!       '\nDISPSNPM  DC   C'DYBACKUP - SYSIN RECORD   =>                          +\n                                                                       +\n                              '\nINVSNPMA  DC   C'DYBACKUP - SYSIN PARMAMETER INPUT IS INVALID => XXXXXX+\n               XXXXXXXXXXXXXXXXXXXXXXXX - USING PROGRAM DEFAULT.'\nINVSNPMB  DC   C'DYBACKUP - SYSIN PARMAMETERS SHOULD EITHER BE \"ALLOCAT+\n               =NNNNNN\" OR \"WAITINT=NNNNNN\" WHERE NNNNNN IS 1 TO 6 NUME+\n               RIC DIGITS IN LENGTH'\nINVDISPA  DC   C'DYBACKUP - INVALID DISPOSTION (STATUS) PARAMETER PASSE+\n               D AS EXECUTE PARAMETER FOR SYSUT2 ALLOCATION'\nINVDISPB  DC   C'DYBACKUP -   VALID VALUES ARE \"MOD\", \"OLD\", AND \"SHR\"'\nINVDISPC  DC   C'DYBACKUP -   DISPOSITION PASSED => ''   ''           '\nDSNINUSE  DC   C'DYBACKUP - DATASET IS ALLOCATED TO ANOTHER TASK - WAIT+\n               ING XXXXXX SECONDS AND WILL RETRY DYNAMIC ALLOCATION.'\nWTTIMEOT  DC   C'DYBACKUP - EXHAUSTED THE NUMBER OF ATTEMPTS TO DYNAMIC+\n               ALLY ALLOCATE THIS DATASET. LIMIT IS XXXXXX ATTEMPTS.'\nDYNALPMA  DC   C'DYBACKUP - SYSUT2 (OUTPUT) DATASET WILL BE DYNAMICALLY+\n                ALLOCATED'\nDYNALPMB  DC   C'DYNINPUT - DYNAMIC ALLOCATION DISPOSITION FOR SYSUT2  +\n                    => XXX      '\nDYNALATT  DC   C'DYNINPUT - MAXIMUM NUMBER OF DYNAMIC ALLOCATION ATTEMP+\n               TS   => XXXXXX   '\nDYNALINT  DC   C'DYNINPUT - NBR OF SECONDS TO WAIT BETWEEN DYNALOC ATTE+\n               MPTS => XXXXXX   '\nSYSUT1MS  DC   C'DYBACKUP - SYSUT1 (INPUT)  DATASET =>                 +\n                                            '\nSYSUT2MS  DC   C'DYBACKUP - SYSUT2 (OUTPUT) DATASET =>                 +\n                                            '\nDYNALCFL  DC   C'DYNALLOC - DYNAMIC ALLOCATION FAILED. RETURN CODE = XX+\n                (XX) ERROR CODE = XXXX (XXXX) REASON CODE = XXXX (XXXX)+\n                '\nJFCBRDER  DC   C'DYBACKUP - ERROR READING THE JFCB FOR DDNAME \"XXXXXXXX+\n               \". RDJFCB RETCD => XXXX  '\nINVLBIMG  DC   C'DYBACKUP - SAM LBI (LARGE BLKSIZE INTERFACE) IS NOT SU+\n               PPORTED !!!'\nINVBLS1A  DC   C'DYBACKUP - SYSUT1 BLKSIZE IS TOO LARGE - EXCEEDS MAXIM+\n               UM ALLOWABLE BLKSIZE FOR COPYING DATA TO SYSUT2'\nINVBLS1B  DC   C'DYBACKUP - SYSUT1 (INPUT) BLKSIZE IS ===============> +\n               XXXXXXXXXXXXXXXX'\nINVBLS1C  DC   C'DYBACKUP - MAXIMUM ALLOWABLE BLKSIZE FOR OUTPUT IS => +\n               XXXXXXXXXXXXXXXX'\nINVOPSY1  DC   C'DYBACKUP - ERROR OPENING THE SYSUT1 (INPUT) FILE !!! '\nINVOPSY2  DC   C'DYBACKUP - ERROR OPENING THE SYSUT2 (OUTPUT) FILE !!!'\nINVDSORA  DC   C'DYBACKUP - INVALID DSORG FOR SYSUT1 (INPUT) FILE !!! '\nINVDSORB  DC   C'DYBACKUP -    DSORG IS => X''  ''                    '\nSUMMARY   DC   C'DYNINPUT - NUMBER OF RECORDS COPIED FROM SYSUT1 TO SYS+\n               UT2  =>                '\nSUMMRC    DC   C'DYBACKUP - RETURN CODE =>                            '\n*\n**********************************************************************\n*  LIST OF DCBS AND PARAMETER LISTS TO RELOCATE.\n**********************************************************************\nSYSINI   DCB   DDNAME=SYSIN,MACRF=(GM),DSORG=PS,EODAD=ENDSYSIN,        +\n               LRECL=80,RECFM=FB\nSYSINIL  EQU   *-SYSINI\n*\nSYSUT1I  DCB   DDNAME=SYSUT1,MACRF=(GM),DSORG=PS,EODAD=ENDDATA,        +\n               EXLST=*,DCBE=*\nSYSUT1IL EQU   *-SYSUT1I\n*\nSYS1LISI DS    0F\n         DC    XL1'07'              JFCB EXIT\nSYS1RJFC DC    AL3(0)               JFCB WORK AREA BUFFER ADDRESS\n         DC    X'80'                END OF EXIT LIST\n         DC    AL3(0)\nSYS1LISL EQU   *-SYS1LISI\n*\nDCBEUT1I DCBE  BLKSIZE=0\nDCBEUT1L EQU   *-DCBEUT1I\n*\nSYSUT2I  DCB   DDNAME=SYSUT2,MACRF=(PM),DSORG=PS,                      +\n               EXLST=*,DCBE=*\nSYSUT2IL EQU   *-SYSUT2I\n*\nSYS2LISI DS    0F\n         DC    XL1'07'              JFCB EXIT\nSYS2RJFC DC    AL3(0)               JFCB WORK AREA BUFFER ADDRESS\n         DC    X'80'                END OF EXIT LIST\n         DC    AL3(0)\nSYS2LISL EQU   *-SYS2LISI\n*\nDCBEUT2I DCBE  BLKSIZE=0\nDCBEUT2L EQU   *-DCBEUT2I\n*\nRDJFCBI  DS    0F\n         RDJFCB *,MF=L              JFCB MACRO INIT AREA\nRDJFCBIL EQU   *-RDJFCBI\n*\nEXTRACTI DS    0F\n         EXTRACT MF=L               EXTRACT PARAMETER LIST\nEXTRACTL EQU   *-EXTRACTI\n*\nDEVTYPEI DEVTYPE *,(0,0),INFOLIST=DEVLIST1,MF=L\nDEVTYPEL EQU   *-DEVTYPEI\n*\nDEVLIST1 DEVTYPE INFO=AMCAP\nDEVLISTL EQU   *-DEVLIST1\n*\nSYSPRINI DCB   DDNAME=SYSPRINT,MACRF=(PM),DSORG=PS,LRECL=133,RECFM=FB\nSYSPRINL EQU  *-SYSPRINI\n*\n**********************************************************************\n*  PARAMETERS FOR DYNAMIC ALLOCATION (SVC99).\n**********************************************************************\nDFLTATT  DC    ZL6'60'         DEFAULT MAXIMUM NUMBER OF TIMES TO WAIT\nDFLTATTL EQU   *-DFLTATT\nDFLTWINT DC    ZL6'10'                DEFAULT WAIT INTERVAL IN SECONDS\nDFLTWINL EQU   *-DFLTWINT\nX0210    DC    X'0210'                DYNALC ERROR CODE X'0210'\nHEX0F0F  DC    16X'0F'\nHEXCHAR  DC    C'0123456789ABCDEF'\nF000     DC    F'0'\nF001     DC    F'1'\nINITATT  DC    ZL(DFLTATTL)'0'\nINITINT  DC    ZL(DFLTWINL)'0'\nDISPTBLE DS    0C                     DISPOSITION (STATUS) TABLE\n         DC    C'SHR',X'08'\n         DC    C'MOD',X'02'\n         DC    C'OLD',X'01'\n         DC    X'FF'                  END OF DISPOSITION TABLE\n*\nIAIRDDNP DC    AL2(0),AL2(1),AL2(8)   DAIR TEXT UNIT DDNAME POINTER\nIAIRDDNL EQU   *-IAIRDDNP\nIAIRDSNP DC    AL2(0),AL2(1),AL2(44)  DAIR TEXT UNIT DSNAME POINTER\nIAIRDSNL EQU   *-IAIRDSNP\nIAIRSTAP DC    AL2(0),AL2(1),AL2(1)   DAIR TEXT UNIT STATUS POINTER\nIAIRSTAL EQU   *-IAIRSTAP\nIAIRCLOS DC    AL2(0),AL2(0)          DAIR TEXT UNIT UNALC ON CLOSE\nIAIRCLOL EQU   *-IAIRCLOS\n*\n         LTORG\n*\n**********************************************************************\n*    DYNAMIC STORAGE FOLLOWS (ACQUIRED STORAGE AREA)\n**********************************************************************\nWKAREA      DSECT ,                   REENTRANT STORAGE\nWKSAVE      DS    20F                 SAVEAREA\nPARMADDR    DS    F                   SAVE EXECUTION PARM ADDRESS\nJUL2GENT    DS    F                   JUL2GREG ENTRY POINT ADDRESS\nJUL2GRPL    DS    D                   JUL2GREG PARMLIST\nLL          DS    H                   LINKAGE PARM LENGTH\nHOLDATT     DS    CL(DFLTATTL)        HOLD ALLOCAT= PARM FOR EDITTING\nHOLDINT     DS    CL(DFLTWINL)        HOLD WAITINT= PARM FOR EDITTING\nDOUBLE      DS    D                   DOUBLE WORD WORK AREA\nQUADWORD    DS    2D                  QAUD WORD WORK AREA\nUNPACK15    DS    XL15                QUAD UNPACK WORK FIELD\nDISPLY16    DS    CL16                DISPLAY BLOCKSIZE IN EBCDIC\nDSORGSAV    DS    XL2                 DISPLAY INVALID DSORG VALUE\n*\nSYSUT1DS    DS    CL44                SYSUT1 JFCB DATASET NAME\nSYSUT2DS    DS    CL44                SYSUT2 JFCB DATASET NAME\n*\nS2DSORG     DS    XL2                 SYSUT2 JFCB DSORG BEFORE OPEN\nS2RECFM     DS    XL1                 SYSUT2 JFCB RECFM BEFORE OPEN\nS2LRECL     DS    H                   SYSUT2 JFCB LRECL BEFORE OPEN\n*\n**********************************************************************\n* BASE SYSTEM RETURNED DATE AND TIME\n**********************************************************************\n            DS    0F\nCURRTIME    DS    F               CURRENT TIME OF DAY HHMMSSHH (BINARY)\nCURRDATE    DS    PL4                 CURRENT JULIAN DATE\n*\nDISPTIME    DS    0F                  CURRENT TIME IN DISPLAY FORMAT\nDISPTMHH    DS    CL2                 HOURS\nDISPTMC1    DS    CL1                 COLON\nDISPTMMM    DS    CL2                 MINUTES\nDISPTMC2    DS    CL1                 COLON\nDISPTMSS    DS    CL2                 SECONDS\nDISPTIML    EQU   *-DISPTIME          LENGTH OF DISPTIME\n*\nTIMEXXXX    DS    CL8                 CURRENT TIME HH:MM:SS\n*\nSTORTIME    DS    F                   USED TO CONVERT TO PACKED DECIMAL\nSTORTMSG    DS    XL1                 SIGN FOR PACKED DECIMAL\nTIME9       DS    CL9                 STORE PACKED-TO-ZONE CONVERSION\n*\nJULIANDT    DS    0F                  7 DIGIT JULIAN DATE\nJULCENTY    DS    CL2                 JULIAN DATE'S CENTURY\nJULIANYR    DS    CL2                 JULIAN DATE'S YEAR\nJULDAYS     DS    CL3                 JULIAN DATE'S DAYS\nJULDATEL    EQU   *-JULIANDT          LENGTH OF JULIANDT\n*\nGREGDATE    DS    0CL8                GREGORIAN DATE (YYYYMMDD)\nGREGDTYR    DS    CL4                 GREGORIAN YEAR\nGREGDTMO    DS    CL2                 GREGORIAN MONTH\nGREGDTDY    DS    CL2                 GREGORIAN DAY\nGREGDATL    EQU   *-GREGDATE\n*\nEXECWTO     DS    0F,CL(WTOIL)        WTO MESSAGE WORK AREA\nWKOPENCL    DS    0F,CL(OPENIL)       OPEN/CLOSE WORK AREA\nWKRDJFCB    DS    0F,CL(RDJFCBIL)     RDJFCB MACRO RELOCATE AREA\n*\nSYSIN       DS    0F,CL(SYSINIL)      SYSIN    DCB AREA\nSYSUT1      DS    0F,CL(SYSUT1IL)     SYSUT1   DCB AREA\nSYSUT2      DS    0F,CL(SYSUT2IL)     SYSUT2   DCB AREA\nDCBEUT1     DS    0F,CL(DCBEUT1L)     DCBE     FOR SYSUT1\nDCBEUT2     DS    0F,CL(DCBEUT2L)     DCBE     FOR SYSUT2\nSYS1LIST    DS    0F,CL(SYS1LISL)     SYSUT1 EXIT LIST\nSYS2LIST    DS    0F,CL(SYS2LISL)     SYSUT2 EXIT LIST\nSYSPRINT    DS    0F,CL(SYSPRINL)     SYSPRINT DCB AREA\n*\nJFCBARB     DS    CL(JFCBLGTH)        RDJFCB WORK AREA BUFFER\n            ORG   JFCBARB\n            IEFJFCBN LIST=YES         MAP RDJFCB WORK AREA\n*\nDEVTYPDD    DS    CL8\nDEVTYP      DS    0F,CL(DEVTYPEL)     DEVTYPE RELOCATION\nDEVAREA     DS    0F,CL(DEVTDL)       DEVTYPE WORK RETURN AREA\n*\nEXTRACTW    DS    0F,CL(EXTRACTL)     EXTRACT MACRO RELOCATE AREA\nTIOTADDR    DS    A                   ADDRESS OF TIOT\n*\nRECCNT      DS    PL6                 RECORDS COPIED\nDISPCNT     DS    ZL11                DISPLAY ZONED VALUE COUNTS\nDISPRC      DS    ZL4                 DISPLAY DYBACKUP RETURN CODE\n*\nMSGLINE     DS    0CL133\nMSGCC       DS    CL1\n            ORG   MSGLINE+L'MSGCC\nMSGAREA     DS    CL132               FORMAT MSGS IN THIS AREA\n*\nHEADING1    DS    0CL132              PROGRAM DYBACKUP HEADING LINE\nH1LIT1      DS    CL11\nH1VERS      DS    CL9                 MAINTENANCE LEVEL VERS.REL.MOD\n            DS    CL1\nH1DATE      DS    CL10                CURRENT JULIAN DATE\n            DS    CL1\nH1TIME      DS    CL8                 CURRENT TIME\nH1LIT2      DS    CL92\nHEADING1L   EQU   *-HEADING1\n*\nSYSINREC    DS    80CL1               SYSIN RECORD INPUT\nSYSINRCL    EQU   *-SYSINREC\n*\nHAVSYNPM    DS    CL1                 HAVE SYSIN PARM IN HAND FLAG\nSYSINTOK    DS    CL30                SYSIN PARAMETER TOKEN\nSYSINTKL    DS    F                   LENGTH OF SYSIN PARAMETER TOKEN\n*\n**********************************************************************\n*  DYNAMIC ALLOCATION AND STIMER ATTEMPTS AND WAIT PARAMETERS.\n**********************************************************************\nALCATTDS    DS    ZL6                 DYNALC WAIT INTERVAL IN SECONDS\nALCATTDL    EQU   *-ALCATTDS\nALCINTDS    DS    ZL6                 DYNALC ATTEMPTS FOR IN-USE FILE\nALCINTDL    EQU   *-ALCINTDS\nALOCWINT    DS    F                   WAIT INTERVAL (10 SECONDS=1000)\nALOCATTS    DS    F                   NUMBER OF ATTEMPTS FOR DYNALLOC\n*\n**********************************************************************\n*  DYNAMIC ALLOCATION REQUEST PARMLIST.\n**********************************************************************\n            DS    0D\nALOPARM     DS    A                   ALLOCATE REQUEST BLOCK POINTER\nALORB       DS    XL(S99RBEND-S99RB)  ALLOCATION REQUEST BLOCK\nALORBL      EQU   *-ALORB\n**********************************************************************\n*  DYNAMIC ALLOCATION TEXT UNIT POINTERS\n**********************************************************************\nALODD       DS    A                   DDNAME PARAMETER ADDRESS\nALODSN      DS    A                   DATA SET NAME PARAMETER ADDRESS\nALOSTAT     DS    A                   STATUS (DISP) PARAMETER ADDRESS\nALOCLOSE    DS    A                   UNALC UPON CLOSE PARM   ADDRESS\n*\n**********************************************************************\n*  DYNAMIC ALLOCATION TEXT UNIT KEYS AND KEY PARMS.\n**********************************************************************\nDAIRDDNP    DS    0F,XL6              DAIR TEXT UNIT DDNAME POINTER\nDAIRDDN     DS    CL8                 DDNAME TEXT UNIT KEY\n*\nDAIRDSNP    DS    0F,XL6              DAIR TEXT UNIT DSNAME POINTER\nDAIRDSN     DS    CL44                DATASET NAME TEXT UNIT KEY\n*\nDAIRSTAP    DS    0F,XL6              DAIR TEXT UNIT STATUS POINTER\nDAIRSTAT    DS    XL1                 STATUS (DISP) TEXT UNIT KEY\n*\nDAIRCLOS    DS    0F,XL4              DAIR TEXT UNIT UNALC ON CLOSE\n*\n**********************************************************************\n*  DYNAMIC ALLOCATION PARM WORK FIELDS.\n**********************************************************************\nALOCDDNM    DS    CL8                 DDNAME TO ALLOCATE\nALOCDSN     DS    CL44                DATA SET NAME TO ALLOCATE\nALOCDISP    DS    CL3                 STATUS (SHR, MOD, OR OLD)\n*\n**********************************************************************\n*  DYNAMIC ALLOCATION RETURN CODE, ERROR CODE, REASON CODE.\n*  FEEDBACK FROM DYNALLOC MACRO.\n**********************************************************************\n            DS    0D\nALCSTAT     DS    0CL20               SVC 99 STATUS RETURN AREA\nALCRETCD    DS    XL2                 SVC 99 RETURN CODE HEX (FROM R15)\nALCRETDC    DS    ZL2                 SVC 99 RETURN CODE DECIMAL\nALCERRCD    DS    XL4                 SVC 99 ERROR  CODE HEX\nALCERRDC    DS    ZL4                 SVC 99 ERROR  CODE DECIMAL\nALCRSNCD    DS    XL4                 SVC 99 REASON CODE HEX\nALCRSNDC    DS    ZL4                 SVC 99 REASON CODE DECIMAL\n*\nWKAREAL     EQU   *-WKAREA\n*\n**********************************************************************\n*  SECOND ACQUIRED STORAGE AREA FOR SYSUT1 - SYSUT2 I/O.\n**********************************************************************\nWKAREA2     DS    0F\nINPAREA     DS    (8*1024*1024)CL1    SYSUT1/SYSUT2 I/O AREA 8 MBs\nWKAREAL2    EQU   *-WKAREA2\n*\n**********************************************************************\n*    DSECTS\n**********************************************************************\n            YREGS    ,                REGISTER EQUATES\n            DCBD  DSORG=PS,DEVD=DA ,  DATA CONTROL BLOCK DEFINITION\n            IHADCBE  ,                DCBE MACRO DSECT\nDEVTD       DSECT    ,                MAP DEVTYPE AREA FOR INFO=AMCAP\n            IHADVA DSECT=NO,INFO=AMCAP ,\nDEVTDL      EQU   *-DEVTD\nTIOTD       DSECT    ,\n            IEFTIOT1 ,                TASK INPUT/OUTPUT TABLE DSECT\n            IEFZB4D0 ,\n            IEFZB4D2 ,\n            IEZWPL   ,                WTO PARAMETER LIST DSECT\n            END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HOWCALLD": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00F\\x01\\x06$\\x0f\\x01\\x06$\\x1f\\x07Y\\x00Y\\x00X\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-08-28T00:00:00", "modifydate": "2006-08-29T07:59:46", "lines": 89, "newlines": 88, "modlines": 0, "user": "TKMILLE"}, "text": "         MACRO ,\n&NAME    HOWCALLD &PARMCALL=\n.********************************************************************\n.*  Determine the caller's method of calling.  If called as a\n.*  subroutine then exit the macro.  If called as an Execute\n.*  Parameter, then branch to the Label &PARMCALL.\n.*\n.*  Reg 1 must contain the original address value that it contained\n.*  on entry to the program calling this macro. Reg 1 is not\n.*  modified by this macro.  This macro generates reentrant code.\n.*\n.*  Assumptions:\n.*    1) This macro will only be able to distinguish the calling\n.*       method if the first parameter's first two bytes are\n.*       EBCDIC characters.  If the first two characters are not\n.*       EBCDIC (i.e Binary or Packed Decimal or some other format),\n.*       this logic will not function properly and the resultant\n.*       branching will be subject to error.\n.*    2) This macro assumes that the user proper has R1 set to the\n.*       value that it contained on entry to the program issueing\n.*       this macro.  Otherwise, the resultant branching will be\n.*       subject to error.\n.*\n.*  Required Operands:\n.*    1) PARMCALL - The branch-to procedure label to branch to if\n.*                  the macro determines that the present program\n.*                  was called via an execution parameter linkage\n.*                  convention. This operand must not be omitted.\n.*\n.*  Example Call:\n.*         HOWCALLD PARMCALL=LABEL1\n.*\n.*  Registers Used:\n.*    R0       - Work register. It will be set to 0 on exit.\n.*    R1       - must have the same value as R1 on entry to the\n.*               present program. It is not altered by this macro.\n.*    R2-R14   - not used.\n.*    R15      - work register altered by this macro. It will be\n.*               set to 0 on exit.\n.*\n.********************************************************************\n.*\n         AIF   ('&PARMCALL' EQ '').MNOTE1\n.*\n         L     15,0(,1)             Load the address of the exec parm\n.*                                  exec parm or subroutine call ?\n         SR    0,0                  Zero Reg  0\n         ICM   0,B'0011',0(15)      Got Parameter or Ex parm Length ?\n         N     0,=X'FFFF7FFF'       Turn off the high order sign bit\n.*                                  since the first 2 bytes of the\n.*                                  EBCDIC parm would be a negative\n.*                                  number as viewed as a binary\n.*                                  number.  Make it a positive value.\n         CH    0,=H'1024'           If hw > 1024, then assume you are\n.*                                  called as a subroutine using\n.*                                  standard subroutine parm list.\n.*                                  If hw value is < 1024 then assume\n.*                                  that you are called using an\n.*                                  Execute parm (ll + parameters).\n         LA    0,0                  Zero Reg  0 w/o affecting cond code\n         LA    15,0                 Zero Reg 15 w/o affecting cond code\n         BNH   &PARMCALL            We have an Execute Parm Call\n.********************************************************************\n.*  I WAS WAS CALLED USING JCL-PARM STYLE LINKAGE\n.*  R1    => ADDRESS OF LINKAGE PARAMETER WHICH POINTS TO:\n.*         1 . A 2-BYTE HW LINKAGE LENGTH (LENGTH OF PARM)\n.*             Followed by the PARM DATA\n.*             EXEC PGM=XXXXXXXX,PARM=\n.*        |\n.*        ------> FullWord1 Address of the Linkage Parameter\n.*                    |\n.*                    ------->  Half-word_Len + PARM (1 - 100 bytes)\n.********************************************************************\n.*  OTHERWISE, I WAS CALLED USING STANDARD SUBROUTINE LINKAGE\n.*  R1    => ADDRESS OF PARM ADDRESS LIST WHICH POINTS TO\n.*           AN ARRAY OF PARM ADDRESSES:\n.*   |\n.*   -------> FullWord1 (PARM ADDRESS for Parameter 1)\n.*   ------->     FullWord2 (PARM ADDRESS for Parameter 2)\n.*                     |   | etc.\n.*                     |   |\n.*                     |   ---> Parameter 2\n.*                     ----> Parameter 1\n.*********************************************************************\n         MEXIT\n.MNOTE1  MNOTE 8,'PARMCALL BRANCH-TO PROCEDURE LABEL WAS OMITTED'\n         MEXIT\n.*\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JUL2GREG": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00W\\x01\\x06\\x15\\x0f\\x01\\x10\\x04\\x1f\\x15(\\x00\\xfb\\x04f\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2006-05-30T00:00:00", "modifydate": "2010-02-10T15:28:57", "lines": 251, "newlines": 1126, "modlines": 0, "user": "TKMILLE"}, "text": "         TITLE 'JUL2GREG - CONVERT JULIAN DATE TO GREGORIAN DATE'\n***********************************************************************\n*                                                                     *\n*  This program inputs a seven (7) digit Julian Date (YYYYDDD) and    *\n*  converts it to a Gregorian Date (YYYYMMDD) returned as a parm.     *\n*                                                                     *\n*  INPUT  PARM => JULIAN DATE    (YYYYDDD)  7 CHARACTERS              *\n*  OUTPUT PARM => GREGORIAN DATE (YYYYMMDD) 8 CHARACTERS              *\n*                                                                     *\n*  Leap Year Calculation Algorithm:                                   *\n*                                                                     *\n*  Rules:                                                             *\n*                                                                     *\n*    1) A year that is evenly divisible by 400 IS a Leap Year.        *\n*    2) A year that is evenly divisible by 100 IS NOT a Leap Year.    *\n*    3) A year that is evenly divisible by   4 IS a Leap Year.        *\n*                                                                     *\n*    (The rules are processed in this sequence.)                      *\n*                                                                     *\n*  Registers Used:                                                    *\n*                                                                     *\n*  R2     => Work Register                                            *\n*  R3     => Number of Days                                           *\n*  R4     => Work Register                                            *\n*  R5     => Branching Register                                       *\n*  R7     => Address of Julian Date Passed as Input                   *\n*  R8     => Address of Gregorian Date Returned as Output             *\n*  R13    => Save Area Pointer                                        *\n*                                                                     *\n*  Return Codes from JUL2GREG:                                        *\n*                                                                     *\n*  0      => Successful call to JUL2GREG                              *\n* 12      => Invalid Julian Date Passed as a parameter                *\n*                                                                     *\n*    Attributes:  REENTRANT, REUSEABLE, AMODE 31, RMODE ANY           *\n*                                                                     *\n***********************************************************************\n*        HOUSEKEEPING                                                 *\n***********************************************************************\nJUL2GREG CSECT\nJUL2GREG AMODE 31\nJUL2GREG RMODE ANY\n         SAVE  (14,12),,JUL2GREG_ASSEMBLED_ON_&SYSDATC._&SYSTIME\n         LR    R12,R15              Load entry address\n         USING JUL2GREG,R12         Declare entry base registers\n         LM    R7,R8,0(R1)          Preserve passed parmlist addresses\n         LR    R6,R13               Store SAVEAREA Backward link\n         LA    R3,STORSIZE          Size of storage to get and clear\n         STORAGE OBTAIN,LENGTH=(R3),LOC=(RES)\n         ST    R1,8(,R13)           Set SAVEAREA Forward link\n         LR    R13,R1               Address of obtained area\n         USING STORAREA,R13         Addressability to obtained area\n         LR    R2,R13               Address of target of move (obtnd)\n         LA    R3,STORSIZE          Length of the target of move\n         XR    R14,R14             From address (irrelevant with len=0)\n         XR    R15,R15              Pad/Length to propagate in odd reg\n         MVCL  R2,R14          Propagate binary zeroes in obtained area\n         ST    R6,4(,R13)           Set SAVEAREA Backward link\n**********************************************************************\n*        This routine edits the julian date passed\n**********************************************************************\n         MVC   0(8,R8),BLANK8       Initialize Gregorian Date Returned\n         MVC   FEBDAYS,F28          Indicate Not a Leap Year (Default)\n         SR    R0,R0\n         ST    R0,RETCODE           Load Default Return Code = 0\n         MVC   YEAR,0(R7)           Load the Gregorian Year\n         LA    R2,7                 Initialize Counter\n         LR    R4,R7                Point to Julian Date Parameter\n         BAS   R5,EDITJULN          Edit the Passed Julian Date\n         SR    R0,R0\n         PACK  DOUBLE,0(4,R7)       Pack the Julian Year\n         CVB   R1,DOUBLE            Convert Julian Year to binary\n         D     R0,F400              Divide Year by 400 (yr/400)\n         LTR   R0,R0                Check Remainder for Zero\n         BNZ   CKCENTRY             Check For Even Century Year\n         MVC   FEBDAYS,F29          Indicate Leap Year\n         B     GETMTHDY\nCKCENTRY DS    0H\n         CLC   2(2,R7),CENT00       Check Even Century Year (yr/100)\n         BE    GETMTHDY             Yes - Then not a Leap Year\n         PACK  DOUBLE,0(4,R7)       Pack the Julian Year\n         SR    R0,R0\n         CVB   R1,DOUBLE            Convert Julian Year to binary\n         D     R0,F4                Divide Year by 4 (yr/4)\n         LTR   R0,R0                Check Remainder for Zero\n         BNZ   GETMTHDY             Not a Leap Year\n         MVC   FEBDAYS,F29          Indicate Leap Year\nGETMTHDY DS    0H\n         PACK  DOUBLE,4(3,R7)       Pack the Julian Days\n         CVB   R3,DOUBLE            Convert Julian Days to binary\nCHKJAN   DS    0H\n         C     R3,F31               Does the Date Fall in January ?\n         BH    CHKFEB               No\n         MVC   MONTH,JAN            Load Gregorian Month January\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKFEB   DS    0H\n         S     R3,F31               Subtract Previous Month's Days\n         C     R3,FEBDAYS           Does the Date Fall in February ?\n         BH    CHKMAR               No\n         MVC   MONTH,FEB            Load Gregorian Month February\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKMAR   DS    0H\n         S     R3,FEBDAYS           Subtract Previous Month's Days\n         C     R3,F31               Does the Date Fall in March ?\n         BH    CHKAPR               No\n         MVC   MONTH,MAR            Load Gregorian Month March\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKAPR   DS    0H\n         S     R3,F31               Subtract Previous Month's Days\n         C     R3,F30               Does the Date Fall in April ?\n         BH    CHKMAY               No\n         MVC   MONTH,APR            Load Gregorian Month April\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKMAY   DS    0H\n         S     R3,F30               Subtract Previous Month's Days\n         C     R3,F31               Does the Date Fall in May ?\n         BH    CHKJUNE              No\n         MVC   MONTH,MAY            Load Gregorian Month May\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKJUNE  DS    0H\n         S     R3,F31               Subtract Previous Month's Days\n         C     R3,F30               Does the Date Fall in June ?\n         BH    CHKJULY              No\n         MVC   MONTH,JUNE           Load Gregorian Month June\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKJULY  DS    0H\n         S     R3,F30               Subtract Previous Month's Days\n         C     R3,F31               Does the Date Fall in July ?\n         BH    CHKAUG               No\n         MVC   MONTH,JULY           Load Gregorian Month July\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKAUG   DS    0H\n         S     R3,F31               Subtract Previous Month's Days\n         C     R3,F31               Does the Date Fall in August ?\n         BH    CHKSEPT              No\n         MVC   MONTH,AUG            Load Gregorian Month August\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKSEPT  DS    0H\n         S     R3,F31               Subtract Previous Month's Days\n         C     R3,F30               Does the Date Fall in September ?\n         BH    CHKOCT               No\n         MVC   MONTH,SEP            Load Gregorian Month September\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKOCT   DS    0H\n         S     R3,F30               Subtract Previous Month's Days\n         C     R3,F31               Does the Date Fall in October ?\n         BH    CHKNOV               No\n         MVC   MONTH,OCT            Load Gregorian Month October\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKNOV   DS    0H\n         S     R3,F31               Subtract Previous Month's Days\n         C     R3,F30               Does the Date Fall in November ?\n         BH    CHKDEC               No\n         MVC   MONTH,NOV            Load Gregorian Month November\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKDEC   DS    0H\n         S     R3,F30               Subtract Previous Month's Days\n         C     R3,F31               Does the Date Fall in December ?\n         BH    BADJULDT             No - Bad Julian Date Passed\n         MVC   MONTH,DEC            Load Gregorian Month December\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nEDITJULN DS    0H                   Edit Julian Date\n         CLI   0(R4),C'0'\n         BL    BADJULDT             Non-Numeric Julian Date Digit\n         CLI   0(R4),C'9'\n         BH    BADJULDT             Non-Numeric Julian Date Digit\n         LA    R4,1(R4)\n         BCT   R2,EDITJULN\n         CLC   4(3,R7),C366\n         BH    BADJULDT             Invalid Julian Date (Days > 366)\n         CLC   4(3,R7),C000\n         BNER  R5                   Have Valid Julian Date Passed\nBADJULDT DS    0H                   Invalid Julian Date Passed\n         LA    R1,12\n         ST    R1,RETCODE           Return with RC=12\n         B     RETURN\nGETGDAYS DS    0H\n         CVD   R3,DOUBLE\n         UNPK  DAYSWORK,DOUBLE+6(3)\n         MVC   DAY,DAYSWORK+1       Load Gregorian Days\n         BR    R5\nLOADGREG DS    0H\n         MVC   0(GREGL,R8),GREG_DATE  Load the Gregorian Date\nRETURN   DS    0H\n         L     R4,RETCODE           Pick up return code\n         LR    R2,R13               Pointer to storage area\n         LA    R3,STORSIZE          Size of storage to free\n         L     R13,4(,R13)          Restore Caller's SAVEAREA address\n         STORAGE RELEASE,LENGTH=(R3),ADDR=(R2)\n         L     R14,12(,R13)         Restore R14\n         LR    R15,R4               Load return code\n         LM    R0,R12,20(R13)       Restore caller's registers\n         BSM   0,R14                Return to caller in caller's Amode\n**********************************************************************\n*    STATIC STORAGE FOLLOWS\n**********************************************************************\nBLANK8      DC    CL8'        '\nCENT00      DC    CL2'00'           Check Year for Even Century Year\nF4          DC    F'4'\nF28         DC    F'28'\nF29         DC    F'29'\nF30         DC    F'30'\nF31         DC    F'31'\nF400        DC    F'400'\nC366        DC    CL3'366'\nC000        DC    CL3'000'\nJAN         DC    CL2'01'\nFEB         DC    CL2'02'\nMAR         DC    CL2'03'\nAPR         DC    CL2'04'\nMAY         DC    CL2'05'\nJUNE        DC    CL2'06'\nJULY        DC    CL2'07'\nAUG         DC    CL2'08'\nSEP         DC    CL2'09'\nOCT         DC    CL2'10'\nNOV         DC    CL2'11'\nDEC         DC    CL2'12'\n            LTORG\n**********************************************************************\n*    DYNAMIC STORAGE FOLLOWS  (GETMAINED AREA)\n**********************************************************************\nSTORAREA    DSECT ,                Reentrant Storage\nSAVEAREA    DS    20F\nFULL        DS    F                General workarea\nDOUBLE      DS    D                General workarea\nRETCODE     DS    F                Return code\nFEBDAYS     DS    F                Number of days in Feb for this year\nGREG_DATE   DS    0F               Gregorian Date to be Returned\nYEAR        DS    CL4              (YYYYMMDD)\nMONTH       DS    CL2\nDAY         DS    CL2\nGREGL       EQU   *-GREG_DATE      Length of Gregorian Date Returned\nDAYSWORK    DS    CL5\n*\nSTORSIZE    EQU   *-STORAREA\n*\n            YREGS ,                Register Equates\n            END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LINKEDIT": {"ttr": 1549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x19\\x01\\x10\\x03?\\x01\\x10\\x05o\\x16C\\x004\\x00 \\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2010-02-02T00:00:00", "modifydate": "2010-02-25T16:43:19", "lines": 52, "newlines": 32, "modlines": 0, "user": "TKMILLE"}, "text": "//LINKEDIT JOB ' LINKEDIT PROGRAM SOFTCAPI                      ',\n// TIME=1440,MSGCLASS=Z,MSGLEVEL=1,NOTIFY=&SYSUID,REGION=0M\n//*******************************************************************\n//* LINKEDIT PROGRAMS SOFTCAPI, JUL2GREG, DYBACKUP AND ABENDER.\n//*******************************************************************\n//LINKEDIT EXEC PGM=IEWL,\n//         PARM='LIST,LET,MAP,XREF,RENT,REUS'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DISP=SHR,DSN=SMPE.SOFTCAPI($OBJECT1)   <= OBJECT CODE\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DISP=SHR,DSN=MY.LINK.LISTED.LIBRARY    <= CHANGE THIS\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSIN    DD *\n ENTRY SOFTCAPI\n MODE  AMODE(31),RMODE(24)\n NAME  SOFTCAPI(R)\n/*\n//LINKEDI2 EXEC PGM=IEWL,\n//         PARM='LIST,LET,MAP,XREF,RENT,REUS'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DISP=SHR,DSN=SMPE.SOFTCAPI($OBJECT2)   <= OBJECT CODE\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DISP=SHR,DSN=MY.LINK.LISTED.LIBRARY    <= CHANGE THIS\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSIN    DD *\n ENTRY JUL2GREG\n MODE  AMODE(31),RMODE(ANY)\n NAME  JUL2GREG(R)\n/*\n//LINKEDI3 EXEC PGM=IEWL,\n//         PARM='LIST,LET,MAP,XREF,RENT,REUS'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DISP=SHR,DSN=SMPE.SOFTCAPI($OBJECT3)   <= OBJECT CODE\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DISP=SHR,DSN=MY.LINK.LISTED.LIBRARY    <= CHANGE THIS\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSIN    DD *\n ENTRY DYBACKUP\n MODE  AMODE(31),RMODE(24)\n NAME  DYBACKUP(R)\n/*\n//LINKEDI4 EXEC PGM=IEWL,\n//         PARM='LIST,LET,MAP,XREF,RENT,REUS'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DISP=SHR,DSN=SMPE.SOFTCAPI($OBJECT4)   <= OBJECT CODE\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DISP=SHR,DSN=MY.LINK.LISTED.LIBRARY    <= CHANGE THIS\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSIN    DD *\n ENTRY ABENDER\n NAME  ABENDER(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SOFTCAPI": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00\\x19\\x01\\x10\\x03O\\x01\\x10\\x05\\x7f\\x16)\\x01\\xe7\\x01\\xb2\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2010-02-03T00:00:00", "modifydate": "2010-02-26T16:29:19", "lines": 487, "newlines": 434, "modlines": 0, "user": "TKMILLE"}, "text": "**********************************************************************\n*\n*       SSSS OOOOO FFFFF TTTTT  CCCC   A   PPPP   III\n*      S     O   O F       T   C      A A  P   P   I\n*       SSS  O   O FFFF    T   C     A   A PPPP    I\n*          S O   O F       T   C     AAAAA P       I\n*      SSSS  OOOOO F       T    CCCC A   A P      III\n*\n*   WRITTEN     - 11/23/2009 - TKMILLE\n*   LAST UPDATE - 02/26/2010 - TKMILLE\n*\n*   ISSUES TWO WTO MESSAGES WHICH REVEAL SOFTCAPPING INFORMATION.\n*\n* 1) SOFTCAPI LPAR LPARX CURRENT ROLLING 4-HR AVG UTILIZATION IS 5 MSUS\n* 2) SOFTCAPI SY6 CAPACITY IS 27 MSUS, LPAR CAPACITY IS 15 MSUS\n*\n*   THESE TWO WTO MESSAGES ARE ALSO WRITTEN TO THE OUTPUT FILE\n*   ALLOCATED TO DDNAME 'OUTPUT'.\n*\n*   SOFTCAPPING CAN BE ENABLED AT THE LPAR LEVEL OR AT THE\n*   LPARGROUP LEVEL. THIS PROGRAM CANNOT TELL AT WHICH LEVEL THE\n*   SOFTCAPPING IS ENABLED.  IT CAN ONLY TELL THAT IS IS ENABLED.\n*\n*   IF SOFTCAPPING IS IMPOSED UPON THE LPAR (SOFTCAPPING IS ACTIVELY\n*   REDUCING LIMITING UTILIZATION ON THE LPAR), THEN THIS CLAUSE IS\n*   APPENDED TO THE END OF MSG 1 ABOVE:\n*\n*      \"SOFTCAPPING IS CURRENTLY IMPOSED ON LPAR.\"\n*\n*   IF SOFTCAPPING IS ENABLED BUT NOT ACTIVELY SOFTCAPPING THE LPAR\n*   THE FOLLOWING CLAUSE IS APPENDED TO THE END OF MSG 1 ABOVE:\n*\n*      \"SOFTCAPPING IS ENABLED AT SOME LEVEL.\"\n*\n*   RETURNS WLM 4-HOUR ROLLING AVERAGE CPU UTILIZATION IN MSUS IF\n*   CALLED AS A SUBROUTINE AS WELL AS THE FOLLOWING PARMS TO CALLER:\n*      LPARNAME  - LPARNAME OF THE RUNNING IMAGE (MUST BE LOADED WITH\n*                  SPACES (BLANKS) PRIOR TO CALL TO SOFTCAPI)\n*      HARDWNME  - HARDWARE (CEC) NAME\n*      CECCAPAC  - CEC CAPACITY IN MSUS\n*      LPRCAPAC  - LPAR CAPACITY IN MSUS\n*      ROLLAVG   - 4-HOUR ROLLING AVG FOR THE LPAR IN MSUS\n*      LIMITED   - SOFTCAPPING ENABLED INDICATOR FLAG (Y OR N)\n*      SOFTCAP   - SOFTCAPPING IMPOSED INDICATOR FLAG (Y OR N)\n*\n*   PARAMETER DEFINITIONS:\n*      LPARNAME     CL8      (LPARXXX) MUST BE PRIMED WITH BLANKS!\n*      HARDWNME     CL8\n*      CECCAPAC     F\n*      LPRCAPAC     F\n*      ROLLAVG      F\n*      LIMITED      CL1  (Y/N - SOFTCAPPING IS ENABLED)\n*      SOFTCAP      CL1  (Y/N - SOFTCAPPING IS IMPOSED (AFFECTING) THE\n*                               LPAR)\n*\n*   MVC   LPARNAME,=CL8'        '\n*   CALL SOFTCAPI,(LPARNAME,HARDWNME,CECCAPAC,LPRCAPAC,ROLLAVG,       +\n*               LIMITED,SOFTCAP),VL=1\n*\n* OUTPUT FILE: RECFM=FB LRECL=150\n*   MIRROR OF THE WTO MESSAGES ARE WRITTEN TO THIS OUTPUT FILE.\n*   WITH THE DATE, TIME, AND SYSID ADDED AS A 21 BYTE PREFIX TO\n*   THE MESSAGE (MM/DD/YY HH:MM:SS SYSID).\n*\n* REGISTER USAGE:\n*\n*   R1  - POINTS TO THE PARMLIST PASSED ON ENTRY TO SOFTCAPI\n*   R2  - MAPS THE CVT  AREA\n*   R3  - MAPS THE ECVT AREA\n*   R4  - MAPS THE RMCT AREA\n*   R5  - MAPS THE RCT  AREA\n*   R6  - MAPS THE WPL  AREA\n*   R7  - WORK REGISTER\n*   R8  - WORK REGISTER\n*   R9  - WORK REGISTER\n*   R10 - BRANCHING REGISTER\n*   R11 - STORES TO THE PARMLIST ADDRESS PASSED TO SOFTCAPI\n*   R12 - PROGRAM BASE REGISTER\n*   R13 - MAPS THE SAVEAREA\n*\n**********************************************************************\nSOFTCAPI CSECT\nSOFTCAPI AMODE 31\nSOFTCAPI RMODE 24\n         SAVE  (14,12),,SOFTCAPI_ASSEMBLED_ON_&SYSDATE._&SYSTIME\n         LR    R12,R15             LOAD ENTRY ADDRESS\n         USING SOFTCAPI,R12        DECLARE ENTRY BASE\n         LR    R11,R1              PRESERVE PASSED PARMLIST ADDRESS\n         LR    R6,R13              STORE SAVEAREA BACKWARD LINK\n         LA    R3,WKAREALN         SIZE OF STORAGE TO GET AND CLEAR\n         STORAGE OBTAIN,LENGTH=(R3),LOC=(RES)\n         ST    R1,8(,R13)          SET SAVEAREA FORWARD LINK\n         LR    R13,R1              ADDRESS OF OBTAINED AREA\n         USING WKAREA,R13          ADDRESSABILITY TO OBTAINED AREA\n         LR    R2,R13              ADDRESS OF TARGET OF MOVE (OBTND)\n         LA    R3,WKAREALN         LENGTH OF THE TARGET OF MOVE\n         XR    R14,R14             FROM ADDRESS (IRRELEVANT WITH LEN=0)\n         XR    R15,R15             PAD/LENGTH TO PROPAGATE IN ODD REG\n         MVCL  R2,R14          PROPAGATE BINARY ZEROES IN OBTAINED AREA\n         ST    R6,4(,R13)           SET SAVEAREA BACKWARD LINK\n*\n         MVI   PREFIX,C' '          INITIALIZE MESSAGE PREFIX\n         MVC   PREFIX+1(PREFIXL-1),PREFIX\n         TIME  DEC ,                GET CURRENT DATE AND TIME\n         STM   R0,R1,CURRTIME       STORE CURRENT TIME AND JULDATE\n         MVI   CURRDATE,X'20'       FORCE CENTURY OVER X'01'\n         MVC   STORTIME,CURRTIME\n         UNPK  TIME9(9),STORTIME(5) UNPACK THE TIME\n         MVC   PREFTMHH(2),TIME9    FORMAT TIME\n         MVI   PREFTMC1,C':'\n         MVC   PREFTMMM(2),TIME9+2\n         MVI   PREFTMC2,C':'\n         MVC   PREFTMSS(2),TIME9+4\n         UNPK  JULDATE7(7),CURRDATE(4)   STORE THE JULIAN DATE\n         OI    JULDATE7+6,X'F0'          FIX THE SIGN\n         MVC   PREFDATE(JULDATEL),JULDATE7 LOAD JULIAN DATE FOR NOW\n         MVI   PREFDATE+4,C'.'             IN CASE WE CANNOT OBTAIN A\n         MVC   PREFDATE+5(3),JULDATE7+4    GREGORIAN DATE.\n**********************************************************************\n*  CALL PROGRAM JUL2GREG TO CONVERT A JULIAN DATE TO GREGORIAN FORMAT.\n*  INPUT  PARM => JULIAN DATE    (YYYYDDD)  7 CHARACTERS\n*  OUTPUT PARM => GREGORIAN DATE (YYYYMMDD) 8 CHARACTERS\n**********************************************************************\n         LOAD  EP=JUL2GREG       LOAD PROGRAM \"JUL2GREG\"\n         ST    R0,JUL2GENT       STORE THE ENTRY ADDRESS\n         LA    R1,JUL2GRPL       PARMLIST FOR JUL2GREG\n         LA    R0,JULDATE7       INPUT PARM JULIAN DATE\n         ST    R0,0(,R1)         STORE ADDRESS OF JULIAN DATE PARM\n         LA    R0,GREGDATE       OUTPUT PARM GREGORIAN DATE\n         ST    R0,4(,R1)         STORE ADDRESS OF GREGORIAN DATE PARM\n         OI    4(R1),X'80'       INDICATE END OF PARM ADDRESSES\n         L     R15,JUL2GENT      LOAD JUL2GREG ENTRY POINT ADDRESS\n         BASSM R14,R15           CALL \"JUL2GREG\" TO CONVERT JULIAN DATE\n         LR    R7,R15            SAVE JUL2GREG RETURN CODE\n         DELETE EP=JUL2GENT\n         LTR   R7,R7             SUCCESSFUL CALL TO JUL2GREG ?\n         BNZ   INITFLGS          NO - DON'T HAVE A GOOD GREGORIAN DATE\n         MVC   PREFDTMO(2),GREGDTMO LOAD GREGORIAN DATE\n         MVI   PREFDTH1,C'/'\n         MVC   PREFDTDY(2),GREGDTDY\n         MVI   PREFDTH2,C'/'\n         MVC   PREFDTYR(2),GREGDTYR+2\nINITFLGS DS    0H\n         MVI   SUBRTN,C'N'          INITLIZE CALLED-BY-SUBROUTINE FLAG\n         MVI   SOFTCAP,C'N'         INITLIZE SOFTCAP INDICATOR FLAG\n         MVI   LIMITED,C'N'         INITLIZE LIMITED INDICATOR FLAG\n         MVI   OPENOUT,C'N'         INITLIZE OPEN    INDICATOR FLAG\n         LR    R1,R11               RESTORE R1\n         ST    R11,PARMADR1         STORE THE PARMLIST ADDRESS\n         HOWCALLD PARMCALL=GETMSUS  , HOW WAS I CALLED? SUBR OR EXEC?\n         MVI   SUBRTN,C'Y'          I WAS CALLED AS A SUBROUTINE\nGETMSUS  DS    0H\n         USING PSA,0                DEFINE PREFIXED SAVE AREA BASE\n         L     R2,FLCCVT            LOAD CVT ADDRESS FROM PSA\n         USING CVT,R2               MAP  CVT DSECT\n         MVC   SYSID,CVTSNAME       GET THE SYSTEM ID\n         L     R3,CVTECVT           POINT TO ECVT\n         USING ECVT,R3              MAP  ECVT DSECT\n         MVC   HARDWNME,ECVTHDNM    SAVE HARDWARE NAME\n         MVC   LPARNAME,ECVTLPNM    SAVE LPAR NAME\n         L     R4,CVTOPCTP          LOAD RMCT ADDRESS\n         USING RMCT,R4              MAP  RMCT DSECT\n         L     R5,RMCTRCT           LOAD RCT ADDRESS\n         USING RCT,R5               MAP  RCT DSECT\n***********************************************************************\n*  CHECK THE SOFTCAPPING METRICS.  AN LPAR CAN BE LIMITED BY TWO\n*  LEVELS OF SOFTCAPPING - 1) LPAR LEVEL 2)  LPARGROUP LEVEL.\n*  THE RCT AREA CAN ONLY INDICATE IF AN LPAR IS BEING SOFTCAPPED BY\n*  ONE OF THE TWO LEVELS ABOVE, BUT IT CANNOT TELL WHICH LEVLE IS\n*  DOING THE CAPPING.  IT CAN ONLY TELL IF SOFTCAPPING IS ENABLED AT\n*  SOME LEVEL OR THAT THE LPAR IS CURRENTLY BEING AFFECT BY ITS OWN\n*  4HRA VALUE (IT CANNOT SEE THE AGGREGATE 4HRA TO KNOW IF SOFTCAPPING\n*  IS BEING INVOKED DUE TO AGGREGATE GROUP CAPACITY UTILIZATION -\n*  AT LEAST I DO NOT PRESENTLY KNOW HOW TO OBTAIN THIS AGGREGATE\n*  LPARGROUP 4HRA VALUE).\n*  THEREFORE, IT IS POSSIBLE THAT THE AGGREGATE GROUP OF LPAR'S\n*  UTILIZATION IS INVOKING SOFTCAPPING, BUT THIS PROGRAM CAN ONLY TELL\n*  WHEN SOFTCAPPING IS BEING INVOKED SOLEY DUE TO THIS LPAR'S\n*  UTILIZATION.\n*  TWO INDICATORS (FLAGS) ARE USED TO INDICATE SOFTCAPPPING:\n*   1) SOFTCAP  - WHEN THE LPAR'S UTILIZATION EXCEEDS THE SOFTCAP LIMIT\n*                 AND SO SOFTCAPPING IS PRESENTLY BEING IMPOSED\n*                 (TRIGGERED) EITHER VIA A SOFTCAP LIMIT SET AT THE\n*                 LPAR LEVEL OR AT THE LPARGROUP LEVEL).\n*                 THE 'SOFTCAP' INDICATOR PRESUPPOSES THE FACT THAT\n*                 SOFTCAPPING IS ENABLED BUT SOFTCAPPING MAY NOT\n*                 PRESENTLY BE IMPOSED. ALSO, SOFTCAPPING MAY BE\n*                 PRESENTLY BE IMPOSED DUE TO THE AGGREGATE 4HRA OF\n*                 AN LPARGROUP, BUT THIS PROGRAM CANNOT DETECT IT.\n*   2) LIMITED  - WHEN THE CEC CAPACITY EXCEEDS THE LPAR CAPACITY LIMIT\n*                 BUT SOFTCAPPING IS NOT PRESENTLY BEING IMPOSED (AS\n*                 FAR AS THIS PROGRAM CAN DETECT DUE TO THIS LPAR'S\n*                 4HRA UTILIZATION SINCE IT CANNOT SEE THE AGGREGATE\n*                 4HRA UTILIZATION OF ALL OF THE LPARS IN AN LPARGROUP\n*                 SOFTCAPPING SCENARIO).\n*                 THIS INDICATES THAT SOFTCAPPING IS ENABLED AT SOME\n*                 LEVEL (EITHER LPAR LEVEL OR LPARGROUP LEVEL) BUT\n*                 THIS LPAR'S 4HRA UTILIZATION IS LESS THAN THE\n*                 SOFTCAP LIMIT.\n***********************************************************************\n         MVC   LPRCAPAC,RCTIMGWU    SAVE LPAR CAPACITY IN MSUS\n         MVC   CECCAPAC,RCTCECWU    SAVE CEC  CAPACITY IN MSUS\n         MVC   ROLLAVG,RCTLACS      SAVE 4-HR ROLLING AVG IN MSUS\n         CLC   CECCAPAC,LPRCAPAC    CEC CAPACITY = LPAR CAPACITY ?\n         BE    OUTMSGS                 YES - SOFTCAPPING IS NOT ENABLED\n         MVI   LIMITED,C'Y'         SOFTCAPPING IS ENABLED IN SOME WAY\n         CLC   ROLLAVG,LPRCAPAC     LPAR 4-HR ROLLAVG < LPAR CAPACITY?\n         BL    OUTMSGS                 SOFTCAPPING IS NOT IMPOSED\n         MVI   SOFTCAP,C'Y'            OSFTCAPPING IS BEING IMPOSED\nOUTMSGS  DS    0H\n         LA    R7,OUTPUT               DCB TO OPEN\n         MVC   OUTPUT(OUTPUTL),OUTPUTI RELOCATE\n         MVC   OPENCL(OPENIL),OPENI    RELOCATE\n         LA    R8,OPENCL               OPEN/CLOSE WORK AREA\n         OPEN  ((R7),OUTPUT),MODE=31,MF=(E,(R8))   OPEN OUTPUT FILE\n         LTR   R15,R15                 GOOD OPEN ?\n         BNZ   STARTMSG                  NO\n         MVI   OPENOUT,C'Y'            OUTPUT FILE SUCCESSFULLY OPENED?\nSTARTMSG DS    0H\n         LA    R6,EXECWTO              POINT TO WTO PARMLIST\n         USING WPL,R6                  MAP PARM LIST DSECT\n***********************************************************************\n*  ISSUE THE FIRST SOFTCAPI WTO MESSAGE (UTILIZATION MESSAGE)\n***********************************************************************\n         MVC   EXECWTO(EXECWTOL),WTOI       INIT. MESSAGE AREA\n         MVC   WPLTXT(WTOMSG1L),WTOMSG1     LOAD MESSAGE TEXT\n         MVC   DOUBLE,LPARNAME              MOVE TO WORK FIELD\n         TR    DOUBLE,TRTB                  CONVERT BLANKS TO EDIT PAD\n         MVC   WPLTXT+14(L'LPARNAME),DOUBLE LOAD LPARNAME WITH EDITCHAR\n         L     R1,ROLLAVG                   FORMAT ROLLAVG FOR WTO\n         BAS   R10,CONVEBCD                 CONVERT TO EBCDIC WITH PAD\n         MVC   WPLTXT+63(10),EDITMASK+2     LOAD ROLLING AVG IN MSUS\n         CLI   SOFTCAP,C'Y'                 LPAR 4HRA EXCEEEDS SOFTCAP?\n         BNE   CHKLIMIT                      NO-LPAR DOESN'T EXCEED CAP\n         MVC   WPLTXT+78(CAPISONL),CAPISON  LPAR IS AFFECTED BY CAP MSG\n         B     ISSUMSG1\nCHKLIMIT DS    0H\n         CLI   LIMITED,C'Y'                 SOFTCAPPING ENABLED?\n         BNE   ISSUMSG1                      NO-SOFTCAPPING NOT ENABLED\n         MVC   WPLTXT+78(LPARLMTL),LPARLMTD ADD SOFTCAPPING ENABLED MSG\nISSUMSG1 DS    0H\n         BAS   R10,REMNUMBK                 REMOVE ALL IMBEDDED PADCHAR\n         WTO   MF=(E,EXECWTO)               EXEC WTO MACRO\n         CLI   OPENOUT,C'Y'                 OUTPUT FILE OPEN ?\n         BNE   GOMSG2                         NO  - SKIP WRITE TO FILE\n         MVI   OUTREC,C' '                    YES - OUTPUT RECORD\n         MVC   OUTREC+1(OUTRECL-1),OUTREC    INITIALIZE OUTPUT RECORD\n         MVC   OUTREC(PREFIXL),PREFIX        MOVE PREFIX INTO OUTREC\n         MVC   OUTREC+PREFIXL(WPLLEN),WPLTXT MOVE WTO MSG TO RECORD\n         PUT   OUTPUT,OUTREC                 OUTPUT RECORD\nGOMSG2   DS    0H\n***********************************************************************\n*  ISSUE THE SECOND SOFTCAPI WTO MESSAGE (CAPACITY MESSAGE)\n***********************************************************************\n         MVC   EXECWTO(EXECWTOL),WTOI      INIT. MESSAGE AREA\n         MVC   WPLTXT(WTOMSG2L),WTOMSG2    LOAD MESSAGE TEXT\n         MVC   DOUBLE,HARDWNME             MOVE TO WORK FIELD\n         TR    DOUBLE,TRTB                 CONVERT BLANKS TO EDIT PAD\n         MVC   WPLTXT+9(L'HARDWNME),DOUBLE LOAD HARDWNME WITH EDITCHAR\n         L     R1,CECCAPAC                 FORMAT CECCAPAC FOR WTO\n         BAS   R10,CONVEBCD                CONVERT TO EBCDIC WITH PAD\n         MVC   WPLTXT+30(10),EDITMASK+2    LOAD CEC CAPACITY IN MSUS\n         L     R1,LPRCAPAC                 FORMAT LPRCAPAC FOR WTO\n         BAS   R10,CONVEBCD                CONVERT TO EBCDIC WITH PAD\n         MVC   WPLTXT+64(10),EDITMASK+2    LOAD CEC CAPACITY IN MSUS\n         BAS   R10,REMNUMBK                REMOVE ALL IMBEDDED PADCHAR\n         WTO   MF=(E,EXECWTO)              EXEC WTO MACRO\n         CLI   OPENOUT,C'Y'                OUTPUT FILE OPEN ?\n         BNE   RETNPRMS                       NO  - SKIP WRITE TO FILE\n         MVI   OUTREC,C' '                    YES - OUTPUT RECORD\n         MVC   OUTREC+1(OUTRECL-1),OUTREC  INITIALIZE OUTPUT RECORD\n         MVC   OUTREC(PREFIXL),PREFIX      MOVE PREFIX INTO OUTREC\n         MVC   OUTREC+PREFIXL(WPLLEN),WPLTXT MOVE WTO MSG TO RECORD\n         PUT   OUTPUT,OUTREC               OUTPUT RECORD\nRETNPRMS DS    0H\n         CLI   SUBRTN,C'Y'          WAS I CALLED AS A SUBROUTINE ?\n         BNE   CLOSOUPT               NO  - DON'T RETURN PARMS\n         L     R11,PARMADR1           YES - GET THE PARMLIST ADDRESS\n         L     R1,0(,R11)                   MOVE DATA TO RETURN PARMS\n         MVC   0(L'LPARNAME,R1),LPARNAME    LOAD RETURN PARM #1\n         L     R1,4(,R11)\n         MVC   0(L'HARDWNME,R1),HARDWNME    LOAD RETURN PARM #2\n         L     R1,8(,R11)\n         MVC   0(L'CECCAPAC,R1),CECCAPAC    LOAD RETURN PARM #3\n         L     R1,12(,R11)\n         MVC   0(L'LPRCAPAC,R1),LPRCAPAC    LOAD RETURN PARM #4\n         L     R1,16(,R11)\n         MVC   0(L'ROLLAVG,R1),ROLLAVG      LOAD RETURN PARM #5\n         L     R1,20(,R11)\n         MVC   0(L'LIMITED,R1),LIMITED      LOAD RETURN PARM #6\n         L     R1,24(,R11)\n         MVC   0(L'SOFTCAP,R1),SOFTCAP      LOAD RETURN PARM #7\nCLOSOUPT DS    0H\n         CLI   OPENOUT,C'Y'                 OUTPUT FILE OPEN ?\n         BNE   RETURN                         NO  - SKIP CLOSE\n         LA    R7,OUTPUT                    DCB TO CLOSE\n         LA    R8,OPENCL                    OPEN/CLOSE WORK AREA\n         CLOSE ((R7)),MODE=31,MF=(E,(R8))   CLOSE OUTPUT FILE\nRETURN   DS    0H\n         DROP  R2\n         LR    R2,R13               POINTER TO STORAGE AREA\n         LA    R3,WKAREALN          WORK AREA SIZE\n         L     R13,4(,R13)          RESTORE CALLER'S SAVEAREA ADDRESS\n         STORAGE RELEASE,LENGTH=(R3),ADDR=(R2)\n         L     R14,12(,R13)         RESTORE R14\n         XR    R15,R15              ZERO RETURN CODE\n         LM    R0,R12,20(R13)       RESTORE CALLER'S REGISTERS\n         BSM   0,R14                RETURN TO PROGRAM CALLER\n**********************************************************************\n* SUBROUTINES FOLLOW.\n**********************************************************************\n* CONVERT NUMERIC MSU FIELDS TO EBCDIC FOR DISPLAY AND ADD EDIT PAD\n* LEADING CHARACTERS TO BE SCRUNCHED OUT LATER ON.\n**********************************************************************\nCONVEBCD DS    0H\n         CVD   R1,DOUBLE                  CONVERT TO PACKED DECIMAL\n         MVC   EDITMASK,MASKDW            RELOCATE/REINIT EDIT MASK\n         ED    EDITMASK,DOUBLE+2          PERFORM EDIT TO ZONED DECIMAL\n         BR    R10                        RETURN TO SUBROUTINE CALLER\n***********************************************************************\n* REMOVE ALL EDIT PAD CHARS FROM THE TEXT LINE AND SHIFT END OF LINE\n* ONE CHARACTER TO THE LEFT TO REMOVE EACH EDIT PAD FILLER CHARACTER.\n* THE CHARACTER X'BA' IS USED AS AN EDIT PAD CHARACTER IN THE\n* NUMERIC MSU FIELDS, THE LPARNAME, AND THE HARDWARE NAME FIELDS.\n***********************************************************************\nREMNUMBK DS    0H                         PREPARE FOR PADCHAR SCRUNCH\n         L     R7,=A(WPLLEN)              STORE LENGTH WPL TEXT FOR BCT\n         LA    R9,WPLTXT-1                PRIME CHARACTER POINTER\nLOOPCHAR DS    0H\n         LR    R8,R7                      GET LENGTH OF ENDLINE REMAINS\n         LA    R9,1(,R9)                  INCREMENT CHARACTER POINTER\n         CLI   0(R9),X'BA'                FOUND EDIT PAD CHARACTER ?\n         BE    SHIFTLFT                     YES - SCRUNCH OUT PAD CHAR\n         B     CHKLOOP                      NO  - CHECK LOOP STATUS\nSHIFTLFT DS    0H                         SHIFT TEXT LEFT 1 BYTE\n         BCTR  R8,0                       DECREMENT 1 BYTE FOR EX MOVE\n         EX    R8,MOVENDLN                MOVE END OF LINE LEFT 1 BYTE\n         MVI   WPLTXTL,C' '               MOVE BLANK TO FINAL END BYTE\n         BCTR  R9,0                       DECREMENT CHAR POINTER BY 1\nCHKLOOP  DS    0H                         CHECK THE LOOP STATUS\n         BCT   R7,LOOPCHAR                HIT END OF PADCHAR LOOP CHK ?\n         BR    R10                           YES - RETURN TO CALLER\nMOVENDLN DS    0H\n         MVC   0(0,R9),1(R9)              SHIFT END OF LINE LEFT BY 1\n*\n**********************************************************************\n*    STATIC STORAGE FOLLOWS\n*---------------------------------------------------------------------*\nWTOMSG1  DS    0F\n         DC    CL(WPLLEN)'SOFTCAPI LPAR          CURRENT ROLLING 4-HR A+\n               VG UTILIZATION IS            MSUS                       +\n                                        '\nWTOMSG1L EQU   *-WTOMSG1\n*\nCAPISON  DS    0F\n         DC    C'. SOFTCAPPING IS CURRENTLY IMPOSED ON LPAR.'\nCAPISONL EQU   *-CAPISON\n*\nLPARLMTD DS    0F\n         DC    C'. SOFTCAPPING IS ENABLED AT SOME LEVEL.'\nLPARLMTL EQU   *-LPARLMTD\n*\nWTOMSG2  DS    0F\n         DC    CL(WPLLEN)'SOFTCAPI          CAPACITY IS            MSUS+\n               , LPAR CAPACITY IS            MSUS                      +\n                                        '\nWTOMSG2L EQU   *-WTOMSG2\n*\n*---------------------------------------------------------------------*\n* WTO INITIALIZE AREA                                                 *\n*---------------------------------------------------------------------*\nWTOI     DS    0F\n         WTO   '                                                       +\n                                                                       +\n                              ',MF=L,ROUTCDE=(11)\nWTOIL    EQU   *-WTOI\n*\nMASKDW   DS    0F\n         DC    X'BA2020202020202020202120'  EDIT MASK WITH PAD FOR MSUS\nMASKDWL  EQU   *-MASKDW\n*\nTRTB     DS    0F                 TRANSLATION TABLE WITH EDIT PAD CHAR\n         DC    256AL1(*-TRTB)\n         ORG   TRTB+X'00'\n         DC    XL1'BA'            CHANGE HEXZEROS TO EDIT PAD CHARACTER\n         ORG   TRTB+C' '\n         DC    XL1'BA'            CHANGE BLANKS   TO EDIT PAD CHARACTER\n         ORG\n*\nOUTPUTI  DS    0F\n         DCB   DDNAME=OUTPUT,MACRF=(PM),DSORG=PS,                      +\n               LRECL=150,RECFM=FB\nOUTPUTL  EQU   *-OUTPUTI\n*\nOPENI    DS    0F\n         OPEN  (*,OUTPUT),MODE=31,MF=L\nOPENIL   EQU   *-OPENI\n*\n         LTORG ,\n**********************************************************************\n*    DYNAMIC STORAGE FOLLOWS\n**********************************************************************\nWKAREA      DSECT ,\nSAVEAREA    DS    20F\nPARMADR1    DS    F\nJUL2GENT    DS    F                ENTRY ADDRESS FOR PROGRAM JUL2GREG\nJUL2GRPL    DS    D                JUL2GREG PARMLIST\nLPARNAME    DS    CL8              LPAR NAME\nHARDWNME    DS    CL8              HARDWARE NAME\nCECCAPAC    DS    F                CEC CAPACITY IN MSUS\nLPRCAPAC    DS    F                LPAR CAPACITY IN MSUS\nROLLAVG     DS    F                ROLLING 4-HOUR AVERAGE IN MSUS\nLIMITED     DS    CL1              LPAR CAPACITY IS LIMITED IN SOME WAY\nSOFTCAP     DS    CL1              LPAR SOFTCAP INDICATOR FLAG (Y OR N)\nDOUBLE      DS    D                DOUBLE WORD WORK AREA\nSUBRTN      DS    CL1              SUBROUTINE CALL FLAG\nOUTPUT      DS    0F,CL(OUTPUTL)   OUTPUT DCB RELOCATE AREA\nOPENCL      DS    0F,CL(OPENIL)    OPEN/CLOSE PARMLIST RELOCATE AREA\nOPENOUT     DS    CL1              OUTPUT DCB OPENED FLAG\n*\n*---------------------------------------------------------------------*\n* BASE SYSTEM RETURNED DATE AND TIME\n*---------------------------------------------------------------------*\nCURRTIME    DS    F                CURRENT TIME OF DAY HHMMSSHH(BINARY)\nCURRDATE    DS    PL4              CURRENT JULIAN DATE\n*\nSTORTIME    DS    F                USED TO CONVERT TO PACKED DECIMAL\nSTORTMSG    DS    XL1              SIGN FOR PACKED DECIMAL\nTIME9       DS    CL9              STORE PACKED-TO-ZONE CONVERSION\n*\nJULDATE7    DS    0CL7             7 DIGIT JULIAN DATE (YYYYDDD)\nJULCENTY    DS    CL2              JULIAN DATE'S CENTURY\nJULIANYR    DS    CL2              JULIAN DATE'S YEAR\nJULDAYS     DS    CL3              JULIAN DATE'S DAYS\nJULDATEL    EQU   *-JULDATE7\n*\nGREGDATE    DS    0CL8             GREGORIAN DATE (YYYYMMDD)\nGREGDTYR    DS    CL4              GREGORIAN YEAR\nGREGDTMO    DS    CL2              GREGORIAN MONTH\nGREGDTDY    DS    CL2              GREGORIAN DAY\nGREGDATL    EQU   *-GREGDATE\n*\n**********************************************************************\n*  ADD THIS PREFIX TO THE FRONT OF EACH WTO MESSAGE THAT IS WRITTEN\n*  TO FILE \"OUTPUT\".\n**********************************************************************\nPREFIX      DS    0F                    PREFIX TO \"OUTPUT\" RECORD\nPREFDATE    DS    0CL8                  CURRENT DATE\nPREFDTMO    DS    CL2                   MONTH\nPREFDTH1    DS    CL1                   FORWARD SLASH\nPREFDTDY    DS    CL2                   DAY\nPREFDTH2    DS    CL1                   FORWARD SLASH\nPREFDTYR    DS    CL2                   YEAR\n            DS    CL1                   BLANK\nPREFTIME    DS    0CL8                  CURRENT TIME\nPREFTMHH    DS    CL2                   HOURS\nPREFTMC1    DS    CL1                   COLON\nPREFTMMM    DS    CL2                   MINUTES\nPREFTMC2    DS    CL1                   COLON\nPREFTMSS    DS    CL2                   SECONDS\n            DS    CL1                   BLANK\nSYSID       DS    CL3                   SYSTEM ID\n            DS    CL1                   BLANK\nPREFIXL     EQU   *-PREFIX\n*\nEDITMASK    DS    CL(MASKDWL)           EDIT MASK WORK AREA\n*\nEXECWTO     DS    0F\n            DS    CL(WTOIL)             WTO MESSAGE AREA\nEXECWTOL    EQU   *-EXECWTO\n*\nWPLLEN      EQU   (WPLTXTL-WPLTXT+1)    LENGTH OF WPL TEXT AREA\n*\nOUTREC      DS    0F\n            DS    CL150                 OUTPUT RECORD BUFFER\nOUTRECL     EQU   *-OUTREC\n*\nWKAREALN    EQU   *-WKAREA              LENGTH OF WORKAREA\n*\n         YREGS ,                   REGISTER EQUATES\nDSECTPSA IHAPSA   LIST=YES ,\nDSECTCVT CVT      DSECT=YES,LIST=YES ,\n         IEZWPL   ,                WTO PARAMETER LIST DSECT\n         IHAECVT  LIST=YES ,       EXTENDED COMMUNICATIONS VECTOR TABLE\n         IRARMCT  ,                RESOURCES MANAGER CONTROL TABLE\n         IRARCT   ,                RESOURCE CONTROL TABLE\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STCJOB": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00)\\x01\\t2?\\x01\\x10\\x06\\x8f\\x14D\\x00:\\x00\\x01\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2009-11-19T00:00:00", "modifydate": "2010-03-09T14:44:29", "lines": 58, "newlines": 1, "modlines": 0, "user": "TKMILLE"}, "text": "//SOFTCAPI JOB MSGLEVEL=1,MSGCLASS=Z\n//OUT1     OUTPUT JESDS=ALL,COPIES=0\n//*******************************************************************\n//* STARTED JOB TO EXECUTE PROGRAM SOFTCAPI.\n//* RUN PROGRAM SOFTCAPI TO SIMULATE THE WLM WTO MSG SOFTCAPI.\n//* PRODUCES TWO WTO'S WITH MSGID SOFTCAPI. ALSO OUTPUTS THE TWO\n//* MESSAGES TO DDNAME //OUTPUT.\n//*   TKMILLE 02/02/2010\n//*******************************************************************\n//SOFTCAPI EXEC PGM=SOFTCAPI\n//*STEPLIB  DD DISP=SHR,DSN=MY.SOFTCAPI.LOADLIB  <= CHANGE THIS LIB\n//SYSOUT   DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//OUTPUT    DD DSN=&&SOFTCAPI,\n//          DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//          DCB=(RECFM=FB,LRECL=150,BLKSIZE=0,DSORG=PS),\n//          SPACE=(TRK,(001,001),RLSE)\n//*\n//*******************************************************************\n//* DYNAMICALLY ALLOCATE THE LOG FILE IN CASE IT IS BEING BROWSED\n//* OR EDITTED. ATTEMPT TO ALLOCATE THE FILE 60 TIMES WITH A WAIT\n//* INTERVAL OF 10 SECONDS BETWEEN ALLOCATION ATTEMPTS.\n//* SPECIFY THE BACKUP DATASET NAME AND ITS DISPOSITION IN THE\n//* EXECUTION PARAMETER.\n//*\n//* EXECUTION PARM:\n//*   BYTES 1-3  (DISPOSTIION (STATUS) FOR DYNAMIC ALLOCATION OF SYSUT2\n//*              ACCEPTABLE VALUES: SHR MOD OLD)\n//*   BYTES 5-47 (DATASET NAME FOR DYNAMIC ALLOCATION OF SYSUT2\n//*              DO NOT INCLUDE TICS. USE FULLY-QUALIFIED DSNAME)\n//*\n//* SYSIN PARAMETERS (DDNAME SYSIN IS OPTIONAL):\n//*   ALLOCAT=NNNNNN (NBR OF DYNALC ATTEMPTS - IF FILE IS BUSY)\n//*   WAITINT=NNNNNN (NBR OF SECONDS TO WAIT BETWEEN DYNALC ATTEMPTS)\n//*\n//* THE PROGRAM DEFAULTS TO THESE VALUES IF THE SYSIN OVERRIDE DDNAME\n//* IS NOT CODED:  ALLOCAT=000060  WAITINT=000010\n//*\n//* TKMILLE 02/13/2010\n//*******************************************************************\n//DYBACKUP  EXEC PGM=DYBACKUP,\n//          PARM='MOD CPU.MESSAGES'              <= DYNAMIC ALLOCATION\n//*STEPLIB   DD DISP=SHR,DSN=MY.SOFTCAPI.LOADLIB  <= CHANGE THIS LIB\n//SYSUT1    DD DISP=(OLD,DELETE),DSN=&&SOFTCAPI\n//SYSOUT    DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//SYSIN     DD *\nALLOCAT=180 WAITINT=10\n/*\n//CHKRC     IF ((SOFTCAPI.RUN=TRUE AND SOFTCAPI.RC GT 0) OR\n//             (DYBACKUP.RUN=TRUE AND DYBACKUP.RC GT 0)  OR\n//             (ABEND))                                         THEN\n//ABEND201  EXEC PGM=ABENDER,PARM='0201'\n//*STEPLIB   DD DISP=SHR,DSN=MY.SOFTCAPI.LOADLIB  <= CHANGE THIS LIB\n//SYSUDUMP  DD SYSOUT=*\n//          ENDIF\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT822/FILE822.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT822", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}