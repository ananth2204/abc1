{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012725000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 235144, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE754.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE754.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x05\\x06'", "DS1TRBAL": "b'\\xaf\\xfa'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\x1e\\x00\\x02\\x05\\x1e\\x00\\x07\\x00\\x06'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04J\\x00\\x00\\x01\\x07\\x06_\\x01\\x07\\x06_\\x10)\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf4@@@'", "ispf": {"version": "04.74", "flags": 0, "createdate": "2007-03-06T00:00:00", "modifydate": "2007-03-06T10:29:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-474"}, "text": "REGULAR CBT TAPE - VERSION 474    FILE:  754\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT474.FILE754\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 21 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,719 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   03/06/07    10:29:54    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CMDTABL": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x01\\x07\\x06_\\x01\\x07\\x06_\\x10#\\x00\\x07\\x00\\x07\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-03-06T00:00:00", "modifydate": "2007-03-06T10:23:40", "lines": 7, "newlines": 7, "modlines": 0, "user": "SBGOLOB"}, "text": "This is a possible command table entry to invoke the THSPROFS dialog.\n\n\nPROFSRCH  5  SELECT CMD(%THSPROFS &ZPARM) NEWAPPL(ISR) PASSLIB\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INSTALL": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x14\\x01\\x07\\x06O\\x01\\x07\\x06O\\x08A\\x00\\x17\\x00\\x11\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2007-03-05T00:00:00", "modifydate": "2007-03-05T08:41:14", "lines": 23, "newlines": 17, "modlines": 0, "user": "SBGOLOB"}, "text": "                   Installation Instructions\n                   ------------ ------------\n\nInstallation of this package is very simple.  There are 6 REXX execs\nand the rest of the members are ISPF panels.  Copy the REXX execs into\na pds in the SYSPROC or ISPEXEC concatenation for your TSO session,\nand copy the panel members into a pds in the ISPPLIB concatenation,\nas follows:\n\nREXXES:\n\nEFQDDN EFQPT EFQTAB EFQVAR EFQVAR1 THSPROFS\n\n\nPANELS:\n\nTHSAPPLG THSGVARS THSQTABC THSQTABD THSQTABT THSQTAB1\nTHSQTAB2 THSQTAB3 THSQTAB4 THSVARSM VI2\n\n\nAfter installation, just invoke the exec:  THSPROFS\nand you are on your way.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE754": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04J\\x00\\x00\\x01\\x07\\x06_\\x01\\x07\\x06_\\x10)\\x00\\x08\\x00\\x08\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf4@@@'", "ispf": {"version": "04.74", "flags": 0, "createdate": "2007-03-06T00:00:00", "modifydate": "2007-03-06T10:29:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "CBT-474"}, "text": "//***FILE 754 is from Henrik Salminen and contains a tool to        *   FILE 754\n//*           search the contents of ISPF profiles.  It is          *   FILE 754\n//*           mostly written in REXX, and it has supporting         *   FILE 754\n//*           ISPF panels.  This is a VERY useful tool, once        *   FILE 754\n//*           you get used to using it.  See member $INSTALL.       *   FILE 754\n//*                                                                 *   FILE 754\n//*           email:  henrik.salminen@swedbank.se                   *   FILE 754\n//*                                                                 *   FILE 754\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EFQDDN": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00Q\\x00\\x93\\x03o\\x01\\x04\\x13\\x9f\\x10\\t\\x00T\\x00D\\x00\\x00\\xe2\\xf0\\xf0\\xf0\\xe3\\xc8\\xe2@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1993-02-05T00:00:00", "modifydate": "2004-05-18T10:09:51", "lines": 84, "newlines": 68, "modlines": 0, "user": "S000THS"}, "text": "/* REXX ----------------------------------------------------------*\n *                                                                *\n * NAME: EFQDDN                                                   *\n * TYPE: REXX function                                            *\n *                                                                *\n * WRITTEN BY:  Henrik Salminen,                                  *\n *              Spadab, Box 593, S-101 26  STOCKHOLM  SWEDEN      *\n *              Date: 1993-02-05                                  *\n *                                                                *\n * DESCRIPTION: This rexx expects one parameters; a DDNAME.       *\n *              All allocated datasets are listed using the       *\n *              LISTALC command with parameter ST (STATUS).       *\n *              The result is sysouttrapped into SYSOUTLINE       *\n *              stem variables which are then scanned for the     *\n *              specified DDNAME.                                 *\n *                                                                *\n *              If hit, return code 0 is returned, followed by    *\n *              the number of datasets allocated, and finally     *\n *              by all the dataset names in the allocated order.  *\n *                                                                *\n *              If no hit, a return code of 8 is returned.        *\n *                                                                *\n *              Note: no ISPEXEC commands are used which makes    *\n *                    this function executable even in TSO        *\n *                    native mode.                                *\n *                                                                *\n * PARAMETERS:  DDNAME                                            *\n *                                                                *\n * EXAMPLE   :                                                    *\n *     set ddname to check\n       DDNAME = \"sysproc\"\n\n       X     = EFQDDN(DDNAME)\n       If X \u00ac= 8 then do\n        PARSE VAR X RETCODE NUMBER DATASETS\n        say \"Return code:\" retcode \"  Number of datasets:\" number\n        say datasets\n        end\n       Else say \"No files allocated to DD-name\" DDNAME\n *----------------------------------------------------------------*/\n\n  ARG PARMS\n  PARSE UPPER VAR PARMS DDNAME DUMMY\n\n  X = OUTTRAP('SYSOUTLINE.')\n  \"LISTALC ST\"\n  X = OUTTRAP('OFF')\n\n  BLANKS  = \"   \"\n  FOUND   = \"NO\"\n\n  i = 1\n  Do while FOUND = \"NO\" & SYSOUTLINE.0 >= i\n   XDSN = SYSOUTLINE.i\n   IF  LENGTH(XDSN) >= 9 then\n    If POS(\" \"DDNAME\" \",XDSN) > 0 then do\n     FOUND = \"YES\"\n     i = i-1\n     XDSN = SYSOUTLINE.i\n     CONCAT = \"'\"XDSN\"'\"\n     End\n    Else i = i+1\n   Else i = i+1\n   End\n\n  If FOUND = \"YES\" then do\n   Do while i+3 <= SYSOUTLINE.0\n    i = i+3\n    XDSN = SYSOUTLINE.i\n    If SUBSTR(XDSN,1,3) = BLANKS then do\n     i = i-1\n     XDSN   = SYSOUTLINE.i\n     CONCAT = CONCAT\" '\"XDSN\"'\"\n     End\n    Else i = SYSOUTLINE.0\n    End\n   End\n\n  If FOUND \u00ac= \"YES\"  then EXIT 8\n  If DUMMY = 'CLIST' then EXIT 0\n  NUMBER = WORDS(CONCAT)\n\n  EXIT 0 NUMBER CONCAT\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EFQPT": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x014\\x00W\\x00\\x92)\\x7f\\x01\\x07\\x05\\x1f\\x11T\\x01\\xf0\\x00:\\x00\\x00\\xe2\\xf0\\xf0\\xf0\\xe3\\xc8\\xe2@@@'", "ispf": {"version": "01.52", "flags": 0, "createdate": "1992-10-23T00:00:00", "modifydate": "2007-02-20T11:54:57", "lines": 496, "newlines": 58, "modlines": 0, "user": "S000THS"}, "text": "/* REXX ----------------------------------------------------------*\n *                                                                *\n * NAME: EFQPT                                                    *\n * TYPE: REXX function                                            *\n *                                                                *\n * WRITTEN BY:  Henrik Salminen,                                  *\n *              Spadab, Box 593, S-101 26  STOCKHOLM  SWEDEN      *\n *              Date: 1992-10-23                                  *\n *                                                                *\n * DESCRIPTION: This rexx expects one parameter; table name.      *\n *              It displays the table, generated by scanning      *\n *              the profile dataset for variables or variable     *\n *              names that contain a specified character string.  *\n *              There are a number of primary and line commands   *\n *              available in this dialog for manipulating the     *\n *              found variables.                                  *\n *                                                                *\n * PARAMETERS:  Table name.                                       *\n *----------------------------------------------------------------*/\n\ntrace n\n  Address ISPEXEC\n  \"CONTROL ERRORS RETURN\"\n\n  PARSE ARG PARMS\n\n  Call INITIAL_ROUTINE\n  Call MAIN_ROUTINE\n  EXIT\n\n/* ***************************************************************** */\nMAIN_ROUTINE :\n/* Start of main section        ************************************ */\n/* Display the table until hell freezes over, the dialog user        */\n/* hits END/RETURN-key, or uses the CANCEL-command.                  */\n\n  If DISPLAY = \"YES\" then do forever\n   \"TBDISPL \"v_tab\" PANEL(\"v_pan\") CSRROW(\"CRP\") AUTOSEL(\"AUTOSEL\")\"\n   RK = RC\n   If ZTDSELS = 0 & RK > 0 & v_tabf  = \"\" then leave\n   If ZTDSELS = 0 & RK > 0 & v_tabf \u00ac= \"\" then do\n    v_tabf = \"\"\n    v_tab  = yv_tab\n    \"TBTOP\"   v_tab\n    \"TBQUERY \"v_tab \"ROWNUM(AROW)\"\n    end\n\n   PARSE VAR ZCMD CMD PARM v_dummy\n   PARSE UPPER VAR CMD CMD .\n   ZCMD =\"\"\n\n   If CMD  =\"C\" | CMD = \"CANCEL\" then leave\n   IF CMD \u00ac= \"\" then Call SELECT_PRIMARY_CMD\n\n   Do while ZTDSELS > 0\n    IF SEL \u00ac= \"\" then Call SELECT_LINE_CMD\n    IF ZTDSELS = 1 THEN ZTDSELS = 0\n    IF ZTDSELS > 0 THEN \"TBDISPL\" v_tab\n    End\n\n   IF CMD  = \"\" & SEL = \"\" THEN CRP = 0\n   ELSE    \"TBQUERY \"v_tab \"ROWNUM(AROW) POSITION(CRP)\"\n   arow   = FORMAT(arow)\n   \"TBTOP \" v_tab\n   \"TBSKIP\" v_tab \"NUMBER(\"CRP\")\"\n   END\n\n  If DISPLAY \u00ac= \"YES\" then NOP\n\n  \"TBEND   \" v_tab\n  \"TBEND   \" v_tabx\n  \"TBEND   \" v_tabf\n\n  RETURN\n\n/* End of main section        ************************************** */\n/* ***************************************************************** */\n/*  Start of subroutines for primary commands:                       */\nSELECT_PRIMARY_CMD :\n  SELECT\n   When CMD = \"F\"     then Call CMD_FIND_STRING\n   When CMD = \"GC\"    then Call CMD_GLOBAL_CHANGE_IN_TEMPTAB\n   When CMD = \"GUP\"   then Call CMD_GLOBAL_UPDATE\n   When CMD = \"HCP\"   then Call CMD_HARDCOPY_PRINT\n   When CMD = \"Q\"     then Call CMD_Q\n   When CMD = \"RES\" | ,\n        CMD = \"RESET\" then Call CMD_RESET_PLC\n   When CMD = \"S0\" |  CMD = \"S1\"  |  CMD = \"S2\"  | ,\n        CMD = \"S3\" |  CMD = \"S1D\" |  CMD = \"S2D\" | ,\n        CMD = \"S3D\"   then Call CMD_SORT_TABLE\n   Otherwise NOP\n   END\n  RETURN\n/* ***************************************************************** */\nCMD_FIND_STRING :\n  If PARM \u00ac= '' then THSAPP1 = PARM\n  Call CREATE_TEMPORARY_FIND_TABLE\n  \"TBTOP \" v_tab\n  Do ixf = 1 to arow\n   \"TBSKIP\" v_tab\n   If THSAPP1 \u00ac= \"\" then do\n    If THSAPP1A = \"\" & POS(THSAPP1,VAR) > \"0\" then ,\n         \"TBADD\" v_tabf\n/*       Call PUT_AST_PLC     */\n    If THSAPP1A \u00ac= \"\"  then do\n       /* two variable fields to be searched  */\n     If SUBSTR(THSAPP1A,1,1) = \"A\" then do\n      If POS(THSAPP1,VAR) > \"0\" &  POS(THSAPP10,VAR) > \"0\" then ,\n         \"TBADD\" v_tabf\n/*       Call PUT_AST_PLC     */\n      end\n     If SUBSTR(THSAPP1A,1,1) = \"O\" then do\n      If POS(THSAPP1,VAR) > \"0\" |  POS(THSAPP10,VAR) > \"0\" then ,\n         \"TBADD\" v_tabf\n/*       Call PUT_AST_PLC     */\n      end\n     end\n    End\n   If THSAPP2 \u00ac= \"\"  &  POS(THSAPP2,VN)  > \"0\" then ,\n         \"TBADD\" v_tabf\n/*       Call PUT_AST_PLC     */\n   End\n  \"TBTOP \"  v_tab\n  \"TBTOP \"  v_tabf\n  \"TBQUERY\" v_tabf \"ROWNUM(AROWF) POSITION(CRP)\"\n  If AROWF > 0 then do\n   v_tab = v_tabf\n   arow   = FORMAT(arowf)\n   end\n  Else do\n   If THSAPP1A \u00ac= '' then do\n    If SUBSTR(THSAPP1A,1,1) = 'O' then ,\n     ZEDLMSG = ,\n      \"No variable contains any of the specified strings\"\n    If SUBSTR(THSAPP1A,1,1) = 'A' then ,\n     ZEDLMSG = ,\n      \"No variable contains both of the specified strings\"\n    end\n   Else do\n    ZEDLMSG = ,\n     \"No variable contains the specified string(s)\"\n    end\n   \"SETMSG MSG(ISRZ001)\"\n   v_tabf = \"\"\n   end\n  RETURN\n/* ***************************************************************** */\n/* Put an asterisk in the PLC field to indicate some event           */\nPUT_AST_PLC :\n  PLC = \"*\"\n  \"TBPUT\" v_tab\n  RETURN\n/* ***************************************************************** */\nCMD_Q :\n  v_display = \"YES\"\n  v_library = \"THSTABS\"\n  X = EFQTAB(v_display v_tab v_library)\n  RETURN\n/* ***************************************************************** */\nCMD_RESET_PLC :\n  \"TBTOP \" v_tab\n  If v_tab \u00ac= v_tabold then do\n     v_tab  = v_tabold\n   End\n  Else do\n   Do xi = 1 to arow\n    \"TBSKIP \" v_tab\n    PLC = \"\"\n    \"TBPUT \" v_tab\n    end\n   End\n  \"TBTOP \" v_tab\n  \"TBEND   \" v_tabx\n  \"TBCREATE\" v_tabx \"NAMES(VN,VAR,APPLID,PLC) NOWRITE\"\n  RETURN\n/* ***************************************************************** */\n/* PRINT THE TABLE USING EDIT-MACRO EMHCP                            */\nCMD_HARDCOPY_PRINT :\n  If PARM =\"\" then PARM = 1\n  Address TSO ,\n      \"ALLOC F(ISPFILE) SPACE(2,15) TRACKS RELEASE UNIT(SYSVIO)\" ,\n      \"DSORG(PS) BLKSIZE(23476) LRECL(99) RECFM(V B)  REUSE\"\n  \"LMINIT DATAID(DATAID) DDNAME(ISPFILE)\"\n  SHOW   = \"NO\"\n  BYRACF = \"YES\"   /* TO FORCE EMHCP TO PRINT \"ROTATED\" */\n  ANTEX  = PARM    /* NBR OF COPIES FOR EMHCP TO PRINT  */\n  TAB = v_tab\n  \"VPUT (DATAID,SHOW,BYRACF,ANTEX) SHARED\"\n  \"FTCLOSE\"\n  \"FTOPEN\"\n  \"FTINCL\" v_skel\n  \"FTCLOSE\"\n/*\n  \"EDIT   DATAID(\"DATAID\") MACRO(EMHCP)\"\n*/\n  \"SELECT CMD(%EMHCP DDNAME(ISPFILE) DATAID(\"DATAID\") VIO(YES)\" ,\n          \"LRECL(99) RECFM(VB))\"\n  \"LMFREE DATAID(\"DATAID\")\"\n  Address TSO \"FREE  F(ISPFILE)\"\n  RETURN\n\n/* ***************************************************************** */\n/* Update variables in the temporary table but NOT in the profile    */\n/* Updating the profile should still be done through the GUP command */\nCMD_GLOBAL_CHANGE_IN_TEMPTAB :\n\n  \"DISPLAY PANEL(THSQTABC)\"\n  If RC \u00ac= 0 then RETURN\n  If THENBR = 1 then CSIN = THSAPP1\n  Else               CSIN = THSAPP10\n\n  \"DISPLAY PANEL(THSQTABD)\"\n  If RC \u00ac= 0 then RETURN\n\n  \"TBTOP  \" v_tab\n  \"TBQUERY \"v_tab \"ROWNUM(AROW)\"\n  L = LENGTH(CSIN)\n  LP = ''\n  RP = ''\n\n  Do i = 1 to AROW\n   \"TBSKIP \"  v_tab\n   If POS(CSIN,VAR) > 0 then do\n    If POS(CSIN,VAR) = 1 then LP = ''\n    If POS(CSIN,VAR) > 1 then LP = SUBSTR(VAR,1,POS(CSIN,VAR)-1)\n    If POS(CSIN,VAR) = (LENGTH(VAR)-L+1) then RP = ''\n    If POS(CSIN,VAR) > 1 & POS(CSIN,VAR) < (LENGTH(VAR)-L+1) then ,\n       RP = SUBSTR(VAR,POS(CSIN,VAR)+L)\n    VAR = LP\"\"CSOUT\"\"RP\n    End\n   \"TBADD \" v_tabx\n   End\n\n  v_tab = v_tabx\n  \"TBTOP  \" v_tab\n\n  RETURN\n/* ***************************************************************** */\n/* Update variables in the PROFILE member in the profile dataset|    */\nCMD_GLOBAL_UPDATE :\n\n  \"TBTOP  \" v_tab\n  \"TBQUERY\" v_tab \"ROWNUM(AROW)\"\n  v_appl = \"\"\n\n  Do i = 1 to AROW\n   \"TBSKIP \"  v_tab\n   Call SEL_U\n   End\n\n  \"TBTOP  \" v_tab\n\n  Do i = 1 to AROW\n   \"TBSKIP \"  v_tab\n   If APPLID = \"ISR\" then do\n    If POS(\"'\",VAR) > 0 then  Interpret  VN '= \"'VAR'\"'\n    Else                      Interpret  VN \"= '\"VAR\"'\"\n    \"VPUT (\"VN\") PROFILE\"\n    \"VPUT (\"VN\") SHARED\"\n    end\n   Else do\n    If v_appl = APPLID then do     /* same applid   */\n     \"TBGET  \"  qtab \"SAVENAME(EXTVARS)\"\n     If POS(\"'\",VAR) > 0 then  Interpret  VN '= \"'VAR'\"'\n     Else                      Interpret  VN \"= '\"VAR\"'\"\n     end\n    Else do                       /* not same applid   */\n     If v_appl \u00ac= \"\" then do      /* not first applid  */\n      \"TBPUT  \"  qtab \"SAVE\"EXTVARS\n      \"TBSAVE \"  qtab \"LIBRARY(\"LIBRARY\") REPLCOPY\"\n      \"TBEND  \"  qtab\n      qtab   = APPLID\"PROF\"\n      v_appl = APPLID\n      \"TBOPEN \"  qtab \"WRITE LIBRARY(\"LIBRARY\") SHARE\"\n      \"TBTOP  \"  qtab\n      \"TBSKIP \"  qtab\n      \"TBGET  \"  qtab \"SAVENAME(EXTVARS)\"\n      If POS(\"'\",VAR) > 0 then  Interpret  VN '= \"'VAR'\"'\n      Else                      Interpret  VN \"= '\"VAR\"'\"\n      end\n     Else do                 /* this is the first applid  */\n      qtab   = APPLID\"PROF\"\n      v_appl = APPLID\n      \"TBOPEN \"  qtab \"WRITE LIBRARY(\"LIBRARY\") SHARE\"\n      \"TBTOP  \"  qtab\n      \"TBSKIP \"  qtab\n      \"TBGET  \"  qtab \"SAVENAME(EXTVARS)\"\n      If POS(\"'\",VAR) > 0 then  Interpret  VN '= \"'VAR'\"'\n      Else                      Interpret  VN \"= '\"VAR\"'\"\n      end\n     end\n    \"TBPUT  \"  qtab \"SAVE\"EXTVARS\n    \"TBSAVE \"  qtab \"LIBRARY(\"LIBRARY\") REPLCOPY\"\n    \"TBEND  \"  qtab\n    end\n   End\n\n  RETURN\n/* ***************************************************************** */\n/* ***************************************************************** */\nCMD_SORT_TABLE :\n  \"TBTOP \" v_tab\n  SELECT\n   When CMD = \"S0\"  then ,\n                   \"TBSORT  \" v_tab \"FIELDS(APPLID,C,A VN,C,A)\"\n   When CMD = \"S1\"  then ,\n                   \"TBSORT  \" v_tab \"FIELDS(APPLID,C,A VN,C,A)\"\n   When CMD = \"S1D\" then ,\n                   \"TBSORT  \" v_tab \"FIELDS(APPLID,C,D VN,C,A)\"\n   When CMD = \"S2\"  then ,\n                   \"TBSORT  \" v_tab \"FIELDS(VN,C,A APPLID,C,A)\"\n   When CMD = \"S2D\" then ,\n                   \"TBSORT  \" v_tab \"FIELDS(VN,C,D APPLID,C,A)\"\n   When CMD = \"S3\"  then ,\n                   \"TBSORT  \" v_tab ,\n                            \"FIELDS(VAR,C,A VN,C,A APPLID,C,A)\"\n   When CMD = \"S3D\" then ,\n                   \"TBSORT  \" v_tab ,\n                            \"FIELDS(VAR,C,D VN,C,A APPLID,C,A)\"\n   Otherwise NOP\n   End\n  RETURN\n\n/* ***************************************************************** */\nCREATE_TEMPORARY_FIND_TABLE :\n  tabfnbr = tabfnbr + 1\n  v_tabf = \"XZQ\"tabfnbr\n  \"TBEND   \" v_tabf\n  \"TBCREATE\" v_tabf \"NAMES(VN,VAR,APPLID,PLC) NOWRITE\"\n  RETURN\n/* ***************************************************************** */\n/* ***************************************************************** */\n/*  Start of subroutines for line commands                           */\n/* ***************************************************************** */\n/* ***************************************************************** */\nSELECT_LINE_CMD :\n  \"CONTROL DISPLAY SAVE\"\n  SELECT\n   When SEL = \"D\"     then  Call SEL_D\n   When SEL = \"DP\" |,\n        SEL = \"DS\"    then  Call SEL_DP_VERASE\n   When SEL = \"S\"     then  Call SEL_S\n   When SEL = \"U\"     then  Call SEL_U\n   When SEL = \"UU\"    then  Call SEL_UU\n   When SEL = \"V\"     then  Call SEL_V\n   Otherwise NOP\n   END\n  \"CONTROL DISPLAY RESTORE\"\n  RETURN\n/* ***************************************************************** */\n/* ***************************************************************** */\n/* Delete a variable entry from the table                            */\nSEL_D :\n  \"TBDELETE \" v_tab\n  RETURN\n/* ***************************************************************** */\n/* Select a variable for updating it in the table from a panel       */\nSEL_S :\n  If LENGTH(VAR) < 1001 then do\n   \"DISPLAY PANEL(THSGVARS)\"\n   If RC = 0 then do\n    PLC =SEL\n    \"TBPUT \" v_tab\n    end\n   End\n  Else do\n   Call VARIABLE_LGTH_GT_THOUSAND_BYTES_CREATE_TEMPTAB_INSTEAD\n   ZEDLMSG = ,\n    \"The length of variable \"VN\" in Applid\" APPLID \"is too long to\",\n    \"be displayed because it consists of \"LENGTH(VAR)\" characters.\"\n   \"SETMSG MSG(ISRZ001)\"\n   End\n  RETURN\n/* ***************************************************************** */\n/* Update a variable in the PROFILE member in the profile dataset|   */\n/* What on earth is this?|?  Looks like a future project, judging    */\n/* by the label name....                                             */\nVARIABLE_LGTH_GT_THOUSAND_BYTES_CREATE_TEMPTAB_INSTEAD :\n\n trace n\n  zx_tab = 'GT1000TB'\n  \"TBEND\"    zx_tab\n  yxvar = VAR\n  \"DISPLAY PANEL(THSVARSM)\"\n  If RC > 0 then RETURN\n  If VAR \u00ac= yxvar then say 'zappa dagga'\n trace n\n\n  RETURN\n/* ***************************************************************** */\n/* Update a variable in the PROFILE member in the profile dataset|   */\nSEL_U :\n\n  If APPLID = \"ISR\" then do\n   If POS(\"'\",VAR) > 0 then Interpret  VN '= \"'VAR'\"'\n   Else                     Interpret  VN \"= '\"VAR\"'\"\n   \"VPUT (\"VN\") PROFILE\"\n   \"VPUT (\"VN\") SHARED\"\n   PLC =SEL\n   \"TBPUT \" v_tab\n   end\n\n  Else do\n   qtab = APPLID\"PROF\"\n   If POS(\"'\",VAR) > 0 then Interpret  VN '= \"'VAR'\"'\n   Else                     Interpret  VN \"= '\"VAR\"'\"\n   V_PUT  = EFQVAR(APPLID \"PUT UNCOND\" VN VAR)\n   PLC =SEL\n   \"TBPUT \" v_tab\n   end\n\n  RETURN\n/* ***************************************************************** */\n/* Update a variable in the PROFILE member in the profile dataset|   */\nSEL_UU :\n  If APPLID = \"ISR\" then do\n   If POS(\"'\",VAR) > 0 then Interpret  VN '= \"'VAR'\"'\n   Else                     Interpret  VN \"= '\"VAR\"'\"\n   \"VPUT (\"VN\") PROFILE\"\n   \"VPUT (\"VN\") SHARED\"\n   PLC =SEL\n   \"TBPUT \" v_tab\n   end\n\n  Else do\n   qtab = APPLID\"PROF\"\n   \"TBOPEN \"  qtab \"WRITE LIBRARY(\"LIBRARY\") SHARE\"\n   \"TBTOP  \"  qtab\n   \"TBSKIP \"  qtab\n   \"TBGET  \"  qtab \"SAVENAME(EXTVARS)\"\n   If POS(\"'\",VAR) > 0 then  Interpret  VN '= \"'VAR'\"'\n   Else                      Interpret  VN \"= '\"VAR\"'\"\n   \"TBPUT  \"  qtab \"SAVE\"EXTVARS\n   \"TBSAVE \"  qtab \"LIBRARY(\"LIBRARY\") REPLCOPY\"\n   \"TBEND  \"  qtab\n   PLC =SEL\n   \"TBPUT \" v_tab\n   end\n\n  RETURN\n/* ***************************************************************** */\n/* Invoke IBM function 3.7 in current APPLID                         */\nSEL_V :\n  ZTRAIL = \"3\"\n  \"VPUT (ZTRAIL) SHARED\"\n  \"SELECT PGM(ISPYXDR) PARM(\"APPLID\") NOCHECK\"\n  RETURN\n/* ***************************************************************** */\n/* Delete a variable entry from the specified source                 */\nSEL_DP_VERASE :\n  If APPLID = \"ISR\" then do\n   If SEL = \"DP\" then \"VERASE (\"VN\") PROFILE\"\n   If SEL = \"DS\" then \"VERASE (\"VN\") SHARED\"\n   \"TBDELETE \" v_tab\n   End\n  Else do\n   CODE = \"ERASE\"\n   COND = \"UNCOND\"\n   NAME =  VN\n   y    = EFQVAR(APPLID CODE COND NAME YXXA)\n   End\n  RETURN\n/* ***************************************************************** */\nINITIAL_ROUTINE :\n\n  LIBRARY = \"ISPPROF\"\n  DISPLAY = \"YES\"\n  QTAB    = \"\"\n  DUMMY   = \"\"\n  SENDMSG = \"NO\"\n  v_pan   = \"THSQTAB1\"\n  v_skel  = \"THSQTAB1\"\n  AUTOSEL = \"NO\"\n\n  PARSE VAR PARMS v_tab DUMMY\n  v_tabold = v_tab\n  v_tabx = v_tab\"\"Q\n  \"TBEND   \" v_tabx\n  \"TBCREATE\" v_tabx \"NAMES(VN,VAR,APPLID,PLC) NOWRITE\"\n\n  \"TBQUERY \"v_tab \"ROWNUM(AROW) POSITION(CRP)\"\n  IF RC \u00ac= 0 then do\n   \"TBEND\"   v_tab\n   \"TBOPEN\"  v_tab \"LIBRARY(\"LIBRARY\") SHARE\"\n   \"TBQUERY \"v_tab \"ROWNUM(AROW) POSITION(CRP)\"\n   end\n  arow   = FORMAT(arow)\n  yv_tab = v_tab\n  v_tabf = \"\"\n  \"VGET (ZSCREEN) SHARED\"\n  tabfnbr = ZSCREEN||RANDOM(1,999)\n  v_tabf = \"XZQ\"tabfnbr\n\n  RETURN\n\n/* ***************************************************************** */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EFQTAB": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x07\\x05\\x1f\\x01\\x07\\x05\\x1f\\x13\\x04\\x00o\\x00o\\x00\\x00\\xe2\\xf0\\xf0\\xf0\\xe3\\xc8\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-02-20T00:00:00", "modifydate": "2007-02-20T13:04:58", "lines": 111, "newlines": 111, "modlines": 0, "user": "S000THS"}, "text": "/* REXX ----------------------------------------------------------*\n *                                                                *\n * NAME: EFQTAB                                                   *\n * TYPE: REXX function                                            *\n *                                                                *\n * WRITTEN BY:  Henrik Salminen,                                  *\n *              Spadab, Box 593, S-101 26  STOCKHOLM  SWEDEN      *\n *              Date: 1992-08-27                                  *\n *                                                                *\n * DESCRIPTION: This rexx expects three parameters; display,      *\n *              table name, and DD-name of table library.         *\n *                                                                *\n *              The table is investigated using the TBSTATS and   *\n *              TBQUERY ISPF service, and the result is presented *\n *              on a panel if that is specified at invocation.    *\n *              The function will always return following fields  *\n *              if successfully completed:                        *\n *                                                                *\n *      From TBQUERY:                                             *\n *      QKEY    :  the KEY names in parenthesis                   *\n *      QNAME   :  the NAME names in parenthesis                  *\n *      QROW    :  the number of rows (same as RCUR below)        *\n *      QKEYNBR :  the number of KEYs                             *\n *      QNAMNBR :  the number of NAMEs                            *\n *                                                                *\n *      From TBSTATS:                                             *\n *      CDAT    :  table creation date                            *\n *      CTIM    :  table creation time                            *\n *      UDAT    :  date the table was last updated                *\n *      UTIM    :  time the table was last updated                *\n *      USER    :  the userid of the  last update                 *\n *      RCRT    :  numbers of rows in the created table           *\n *      RCUR    :  current number of rows                         *\n *      RUPD    :  number of updated rows                         *\n *      TUPD    :  number of times the table is updated           *\n *      SERV    :  name of last table services command            *\n *      RETC    :  last return code for a table services command  *\n *      STA1    :  status of the table in the input library chain *\n *      STA2    :  status of the table for the logical screen     *\n *      STA3    :  status of the table for write mode             *\n *                                                                *\n * PARAMETERS:  Display,  tablename,  DD-name of table library.   *\n *              The function expects a parameter that specifies   *\n *              whether the result should be displayed on a panel.*\n *              The DD-name of the table library is only          *\n *              required if it differs from ISPTLIB               *\n *                                                                *\n * Example of invocation when DD-name not ISPTLIB:                *\n\n     display = \"YES\"\n     tabname = \"XYZ\"\n     DDNAME  = \"TABLEDDN\"\n     X = EFQTAB(DISPLAY TABNAME DDNAME)\n*\n*  Example of invocation when DD-name is ISPTLIB:\n     display = \"YES\"\n     tabname = \"XYZ\"\n     X = EFQTAB(DISPLAY TABNAME)\n*\n *----------------------------------------------------------------*/\n\n  Address ISPEXEC\n  \"CONTROL ERRORS RETURN\"\n  LIBRARY = \"\"\n  QTAB    = \"\"\n  DUMMY   = \"\"\n  DISPLAY = \"YES\"\n  PARSE ARG DISPLAY QTAB LIBRARY DUMMY\n\n  \"TBQUERY \"  qtab \"KEYS(QKEY) NAMES(QNAME) ROWNUM(QROW) ,\n                    KEYNUM(QKEYNBR) NAMENUM(QNAMNBR)\"\n  RK = RC\n  If RK = \"12\" then do\n   If LIBRARY = \"\" then LIBRARY = \"ISPTLIB\"\n   \"TBOPEN \"  qtab \"NOWRITE LIBRARY(\"LIBRARY\") SHARE\"\n   \"TBQUERY \" qtab \"KEYS(QKEY) NAMES(QNAME) ROWNUM(QROW) ,\n                    KEYNUM(QKEYNBR) NAMENUM(QNAMNBR)\"\n   \"TBEND  \"  qtab\n   end\n\n  \"TBSTATS\"  QTAB   \"CDATE(\"CDAT\") CTIME(\"CTIM\"),\n    UDATE(\"UDAT\") UTIME(\"UTIM\") USER(\"USER\"),\n    ROWCREAT(\"RCRT\") ROWCURR(\"RCUR\") ROWUPD(\"RUPD\"),\n    TABLEUPD(\"TUPD\") SERVICE(\"SERV\") RETCODE(\"RETC\"),\n    STATUS1(\"STA1\") STATUS2(\"STA2\") STATUS3(\"STA3\")\",\n    \"LIBRARY(\"LIBRARY\")\"\n\n  If   QROWNBR  >  0 then   QROWNBR  = STRIP(QROW,'L','0')\n  Else QROWNBR  = \"0\"\n  If   QKEYNBR  >  0 then   QKEYNBR  = STRIP(QKEYNBR,'L','0')\n  Else QKEYNBR  = \"0\"\n  If   QNAMNBR  >  0 then   QNAMNBR  = STRIP(QNAMNBR,'L','0')\n  Else QNAMNBR  = \"0\"\n  If   RCRT     >  0 then   RCRT     = STRIP(RCRT,'L','0')\n  Else RCRT     = \"0\"\n  If   RCUR     >  0 then   RCUR     = STRIP(RCUR,'L','0')\n  Else RCUR     = \"0\"\n  If   RUPD     >  0 then   RUPD     = STRIP(RUPD,'L','0')\n  Else RUPD     = \"0\"\n  If   TUPD     >  0 then   TUPD     = STRIP(TUPD,'L','0')\n  Else TUPD     = \"0\"\n\n  \"VGET (WRITE) SHARED\"\n  If DISPLAY = \"YES\" then  \"DISPLAY PANEL(THSQTAB)\"\n\n  If (QTAB \u00ac= \"NNNE\"    & DUMMY = \"\") & ,\n     (QTAB \u00ac= \"THSCMDS\" & DUMMY = \"\") & DUMMY \u00ac= \"NO\" then ,\n     RETURN QROWNBR QKEYNBR QKEY QNAMNBR QNAME\n\n  Else EXIT\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EFQVAR": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x17\\x01\\x07\\x05\\x1f\\x01\\x07\\x06_\\x10(\\x00\\xa0\\x00\\xa0\\x00\\x00\\xe2\\xf0\\xf0\\xf0\\xe3\\xc8\\xe2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-02-20T00:00:00", "modifydate": "2007-03-06T10:28:17", "lines": 160, "newlines": 160, "modlines": 0, "user": "S000THS"}, "text": "/* REXX ----------------------------------------------------------*\n *                                                                *\n * NAME: EFQVAR                                                   *\n * TYPE: REXX function                                            *\n *                                                                *\n * WRITTEN BY:  Henrik Salminen,                                  *\n *              Spadab, Box 593, S-101 26  STOCKHOLM  SWEDEN      *\n *              Date: 1992-11-09                                  *\n *                                                                *\n * DESCRIPTION: This REXX expects at least 4 parameters;          *\n *              1. Applid                                         *\n *              2. Code (GET, PUT, ERASE)                         *\n *              3. Condition (COND/UNCOND)                        *\n *              4. Variable name                                  *\n *              5. Variable value if Code (2) is PUT.             *\n *                                                                *\n *              The function will start an external REXX in the   *\n *              specified applid, where the specified variable    *\n *              is 'treated' according to 'Code'.                 *\n *              When Code is PUT, the variable value is also      *\n *              supplied in the external function call.           *\n *                                                                *\n *              Finally, the function will return the obtained    *\n *              return CODE from the external call's              *\n *              'Code'-function, and the result is returned to    *\n *              the caller.  When a successful GET has been       *\n *              executed, the value will also be returned in the  *\n *              RETURN clause.  The calling REXX will then have   *\n *              to parse the result.                              *\n *                                                                *\n * PARAMETERS:  See above                                         *\n *                                                                *\n * Some examples:                                                 *\n *                 applid code  condition name   value            *\n *                 ------ ----- --------- -----  ------\n    XX   = EFQVAR(\"ISR    GET   UNCOND    BJC1\")\n    XX   = EFQVAR(\"FAXXE  PUT     COND    BJC1\"  BJC1\")\"\n    XX   = EFQVAR(\"SMPE   ERASE UNCOND    BJC1\")\n *\n *   and finally check the result; RETCODE will contain the       *\n *   return code, and if Code was GET and the VGET was able       *\n *   to obtain the specified variable, VARVALUE will return       *\n *   the value of the variable.  RETCODE will contain return      *\n *   code according to what the functions (VGET, VPUT, VERASE)    *\n *   leave.  Se appropriate manual for documentation of the       *\n *   return codes that these ISPF services leave.                 *\n *\n    PARSE VAR XX RETCODE VARVALUE\n *\n *----------------------------------------------------------------*/\ntrace n\n  Address ISPEXEC\n  \"CONTROL ERRORS RETURN\"\n\n  PARSE ARG APPLID CODE CONDITION VARNAME VARVALUE\n/*----------------------------------------------------------------*/\n\n  UPPER CODE\n\n  \"VGET (ZAPPLID) ASIS\"\n\n  SELECT\n   When CODE  = \"GET\"    then Call CODE_GET\n   When CODE  = \"PUT\"    then Call CODE_PUT\n   When CODE  = \"ERASE\"  then Call CODE_ERASE\n   Otherwise NOP\n   End\n\n  EXIT\n\n/*----------------------------------------------------------------*/\nCODE_GET:\n  If ZAPPLID = \"ISR\" & ,\n      APPLID = \"ISR\" then do\n   VARVALUE = \"\"\n   \"VGET (\"VARNAME\") PROFILE\"\n   RK = RC\n   If RK = 0 then do\n    VARVALUE = VALUE(VARNAME)\n    end\n   End\n\n  Else do\n   v_tab = \"VARTAB69\"\n   RK = \"\"\n   VARVALUE = \"\"\n   \"TBEND   \"  v_tab\n   \"TBCREATE\"  v_tab \"KEYS(VARNAME) NAMES(VARVALUE,RK) NOWRITE SHARE\"\n   \"TBADD   \"  v_tab\n   \"SELECT CMD(%EFQVAR1\" APPLID CODE CONDITION VARNAME\")\" ,\n               \"NEWAPPL(\"APPLID\") PASSLIB\"\n   XRC = RC\n   \"TBTOP  \"  v_tab\n   \"TBSKIP \"  v_tab\n   \"TBEND  \"  v_tab\n   If RK = \"\" then RK = XRC\n   End\n\n  EXIT  RK VARVALUE\n  RETURN\n/*----------------------------------------------------------------*/\nCODE_PUT:\n  If ZAPPLID = \"ISR\" & ,\n      APPLID = \"ISR\" then do\n   If CONDITION = \"UNCOND\" then do\n    VNX     = VARNAME\n    INTERPRET VNX \"= VARVALUE\"\n    \"VPUT (\"VARNAME\") PROFILE\"\n    RK = RC\n    end\n   Else do\n    YXA = VARVALUE\n    \"VGET (\"VARNAME\") PROFILE\"\n    RK = RC\n    If RK = 0 then do\n     VNX     = VARNAME\n     INTERPRET VNX \"= YXA\"\n     \"VPUT (\"VARNAME\") PROFILE\"\n     RK = RC\n     end\n    Else NOP\n    end\n   End\n\n  Else do\n   \"SELECT CMD(%EFQVAR1\" APPLID CODE CONDITION VARNAME VARVALUE\")\" ,\n               \"NEWAPPL(\"APPLID\") PASSLIB\"\n   RK  = RC\n   End\n  EXIT  RK\n  RETURN\n/*----------------------------------------------------------------*/\nCODE_ERASE:\n  If ZAPPLID = \"ISR\" & ,\n      APPLID = \"ISR\" then do\n   If CONDITION = \"UNCOND\" then do\n    \"VERASE (\"VARNAME\") PROFILE\"\n    RK = RC\n    End\n\n   Else do\n    \"VGET (\"VARNAME\") PROFILE\"\n    RK = RC\n    If RK = 0 then do\n     \"VERASE (\"VARNAME\") PROFILE\"\n     RK = RC\n     end\n    Else NOP\n    End\n   End\n\n  Else do\n   \"SELECT CMD(%EFQVAR1\" APPLID CODE CONDITION VARNAME\")\" ,\n              \"NEWAPPL(\"APPLID\") PASSLIB\"\n   RK  = RC\n   End\n\n  EXIT  RK\n  RETURN\n/*----------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EFQVAR1": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x07\\x05\\x1f\\x01\\x07\\x05\\x1f\\x13\\x06\\x00g\\x00g\\x00\\x00\\xe2\\xf0\\xf0\\xf0\\xe3\\xc8\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-02-20T00:00:00", "modifydate": "2007-02-20T13:06:00", "lines": 103, "newlines": 103, "modlines": 0, "user": "S000THS"}, "text": "/* REXX ----------------------------------------------------------*\n *                                                                *\n * NAME: EFQVAR1                                                  *\n * TYPE: REXX function                                            *\n *                                                                *\n * WRITTEN BY:  Henrik Salminen,                                  *\n *              Spadab, Box 593, S-101 26  STOCKHOLM  SWEDEN      *\n *              Date: 1992-11-09                                  *\n *                                                                *\n * DESCRIPTION: This rexx expects at least 4 parameters;          *\n *              1. Applid                                         *\n *              2. Code (GET, PUT, ERASE)                         *\n *              3. Condition (COND/UNCOND)                        *\n *              4. Variable name                                  *\n *              5. Variable value if Code (2) is PUT.             *\n *                                                                *\n *              The function is started by EFQVAR, which supplies *\n *              the parameters.  This function does the actual    *\n *              variable handling in the specified Applid.        *\n *                                                                *\n *              Finally, the return code from the specified       *\n *              function (GET/PUT/ERASE) is returned.             *\n *              When a successful GET has been executed, the      *\n *              value will also be returned in the RETURN clause. *\n *              The calling REXX will then have to parse the      *\n *              result.                                           *\n *                                                                *\n * PARAMETERS:  See above                                         *\n *                                                                *\n *----------------------------------------------------------------*/\n  trace n\n  Address ISPEXEC\n  \"CONTROL ERRORS RETURN\"\n\n  PARSE ARG APPLID CODE CONDITION VARNAME VARVALUE\n/*----------------------------------------------------------------*/\n\n  SELECT\n   When CODE  = \"GET\"    then Call CODE_GET\n   When CODE  = \"PUT\"    then Call CODE_PUT\n   When CODE  = \"ERASE\"  then Call CODE_ERASE\n   Otherwise NOP\n   End\n\n  EXIT\n\n/*----------------------------------------------------------------*/\nCODE_GET :\n  v_tab = \"VARTAB69\"\n  RK = \"\"\n  VARVALUE = \"\"\n  \"VGET (\"VARNAME\") PROFILE\"\n  RK = RC\n  If RK = 0 then do\n   VARVALUE = VALUE(VARNAME)\n   end\n  \"TBPUT  \"  v_tab\n  EXIT  RK\n  RETURN\n/*----------------------------------------------------------------*/\nCODE_PUT :\n  If CONDITION = \"UNCOND\" then do\n   VNX     = VARNAME\n   INTERPRET VNX \"= VARVALUE\"\n   \"VPUT (\"VARNAME\") PROFILE\"\n   RK = RC\n   end\n\n  Else do\n   YXA = VARVALUE\n   \"VGET (\"VARNAME\") PROFILE\"\n   RK = RC\n   If RK = 0 then do\n    VNX     = VARNAME\n    INTERPRET VNX \"= YXA\"\n    \"VPUT (\"VARNAME\") PROFILE\"\n    RK = RC\n    end\n   Else NOP\n   End\n\n  EXIT  RK\n  RETURN\n/*----------------------------------------------------------------*/\nCODE_ERASE :\n  If CONDITION = \"UNCOND\" then do\n   \"VERASE (\"VARNAME\") PROFILE\"\n   RK = RC\n   End\n\n  Else do\n   \"VGET (\"VARNAME\") PROFILE\"\n   RK = RC\n   If RK = 0 then do\n    \"VERASE (\"VARNAME\") PROFILE\"\n    RK = RC\n    end\n   Else NOP\n   End\n\n  EXIT  RK\n  RETURN\n/*----------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "THSAPPLG": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00B\\x00\\x920\\x0f\\x01\\x07\\x06_\\x10$\\x003\\x00$\\x00\\x00\\xe2\\xf0\\xf0\\xf0\\xe3\\xc8\\xe2@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "1992-10-26T00:00:00", "modifydate": "2007-03-06T10:24:42", "lines": 51, "newlines": 36, "modlines": 0, "user": "S000THS"}, "text": ")ATTR\n _ TYPE(INPUT)  INTENS(HIGH) COLOR(RED)    CAPS(ON) JUST(ASIS)\n \u00a2 TYPE(INPUT)  INTENS(HIGH) COLOR(RED)    CAPS(OFF) JUST(LEFT)\n \\ TYPE(INPUT)  INTENS(HIGH) COLOR(PINK)   CAPS(OFF) JUST(ASIS)\n ? TYPE(OUTPUT) INTENS(LOW)\n ! TYPE(OUTPUT) INTENS(HIGH) COLOR(WHITE)  CAPS(OFF)\n ~ TYPE(OUTPUT) INTENS(HIGH) COLOR(PINK)   /* CAPS(ON) JUST(LEFT)\n \u00f8 TYPE(OUTPUT) INTENS(LOW)  COLOR(BLUE)   /* HILITE(REVERSE)\n \u00d1 TYPE(TEXT)   INTENS(HIGH) COLOR(WHITE)\n \u00ac TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n ` TYPE(TEXT)   INTENS(HIGH) COLOR(RED)\n % TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)\n)BODY\n+THSAPPLG  %Search your profile\n%COMMAND  ==>_ZCMD                                                       +\n+\n+ This dialog is used to search the profile members.  Hits are saved in\n+ a temporary ISPF-table.  Note: only members with names ending in 'PROF'\n+ are searched.  You can search for variable values or names.\n+ Note: you cannot specify %=+ because that is interpreted by ISPF as\n+ if you use the \"jump function\" and it can not be prevented.\n+ All searches are done as 'Boolean EQ', i.e. 'selection if equal'.\n+\n+                             Variable to search for.  Used \"as is\",\n+                             i.e. lower/UPPER case just as specified.\n+ Profile DSN    \u00d1==>_PROFDSN                                               +\n+ Variable%value \u00d1==>\\THSAPP1                                               +\n+ and/or         \u00d1==>_Z   +    A(AND) / O (OR)\n+ Variable%value \u00d1==>\\THSAPP10                                              +\n+\n+ \u00d1OR   +(if specified 'Boolean OR' is used for next field)\n+\n+ Variable%name \u00d1==>_THSAPP2 + You can search variable name or characters\n+                              contained in it (always 'upper case')\n+\n)INIT\n  .ZVARS  = '(THSAPP1A)'\n  &ZCMD   = ' '\n  &ZTRAIL = ' '\n  .HELP   = VI2   /* a dummy panel */\n  .CURSOR = THSAPP1\n)PROC\n  IF  (&THSAPP1A \u00ac= ' ')\n       VER (&THSAPP1A,LIST,A,AN,AND,O,OR)\n  IF  (&THSAPP10 \u00ac= ' ')\n       VER (&THSAPP1,NB)\n       VER (&THSAPP1A,NB)\n  VPUT (THSAPP1,THSAPP2,THSAPP1A,THSAPP10) PROFILE\n  VPUT (PROFDSN) SHARED\n)END\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "THSGVARS": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x008\\x00\\x92#/\\x01\\x07\\x05\\x1f\\x13\\x02\\x00*\\x00,\\x00\\x00\\xe2\\xf0\\xf0\\xf0\\xe3\\xc8\\xe2@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1992-08-19T00:00:00", "modifydate": "2007-02-20T13:02:38", "lines": 42, "newlines": 44, "modlines": 0, "user": "S000THS"}, "text": ")ATTR\n _ TYPE(INPUT)  INTENS(HIGH) COLOR(RED)    CAPS(ON) JUST(ASIS)\n \u00a2 TYPE(INPUT)  INTENS(HIGH) COLOR(RED)    CAPS(ON) JUST(LEFT) HILITE(USCORE)\n \\ TYPE(INPUT)  INTENS(HIGH) COLOR(PINK)   CAPS(OFF) JUST(ASIS)\n ? TYPE(OUTPUT) INTENS(LOW)\n ! TYPE(OUTPUT) INTENS(HIGH) COLOR(WHITE)\n ~ TYPE(OUTPUT) INTENS(HIGH) COLOR(PINK)   /* CAPS(ON) JUST(LEFT)\n \u00f8 TYPE(OUTPUT) INTENS(LOW)  COLOR(BLUE)   /* HILITE(REVERSE)\n \u00d1 TYPE(TEXT)   INTENS(HIGH) COLOR(WHITE)\n \u00ac TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n ` TYPE(TEXT)   INTENS(HIGH) COLOR(RED)\n % TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)\n)BODY\n+THSGVARS  %ISPF-variables                 +APPL:~Z   +CPU:~Z   +\n\u00acCOMMAND  ==>_ZCMD\n+\n+ Dialog to update a variable in your profile in current applid.\n+ Applid       %==>!APPLID   + 'ENTER' to re-write the variable to\n+ Variable name%==>!VN       + your profile, hit 'PF-end' to abort.\n+ Variable: (max 1000 chars displayed, longer variables are not displayed)\n+   0    1    1    2    2    3    3    4    4    5    5    6    6    7    7    8\n+---5----0----5----0----5----0----5----0----5----0----5----0----5----0----5----0\n\\VAR\n\n\n\n\n\n\n\n\n\n\n\n                                        +\n+\n)INIT\n  .ZVARS  = '(ZAPPLID CPUIID)'\n  .HELP   = VI2\n  .CURSOR = VAR\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "THSPROFS": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01%\\x00E\\x00\\x936?\\x01\\x07\\x05\\x1f\\x11Q\\x00\\xf9\\x00\\xb9\\x00\\x00\\xe2\\xf0\\xf0\\xf0\\xe3\\xc8\\xe2@@@'", "ispf": {"version": "01.37", "flags": 0, "createdate": "1993-12-29T00:00:00", "modifydate": "2007-02-20T11:51:45", "lines": 249, "newlines": 185, "modlines": 0, "user": "S000THS"}, "text": "/* REXX ----------------------------------------------------------*\n *                                                                *\n * NAME: THSPROFS (THS PROFile Search)                            *\n * TYPE: Dialog main driver                                       *\n *                                                                *\n * WRITTEN BY:  Henrik Salminen (THS)                             *\n *              Spadab, Box 593, S-101 26  Stockholm,  Sweden     *\n *              Date: 1993-12-29                                  *\n *                                                                *\n * DESCRIPTION:                                                   *\n *   This REXX reads the user profile dataset, searching only for *\n *   members with names ending with 'PROF'.  This is initiated    *\n *   from a data entry panel where search arguments are specified.*\n *   The members are opened as tables and scanned using standard  *\n *   ISPF table functions.  Hits are written into a temporary     *\n *   table which is finally displayed in a separate dialog        *\n *   (EFQPT).  There are several functions available from that    *\n *   table, both as primary and line commands, to conveniently    *\n *   change variables in the profiles of all APPLIDs.             *\n *                                                                *\n *   There is no practical problem to change even quite long      *\n *   variables through this dialog; up to 1000 characters(|) can  *\n *   be displayed and changed for EACH variable through functions *\n *   from the temporary table.                                    *\n *                                                                *\n *   Why has this REXX program (& dialog) been written?  Is there *\n *   really a need for it?  YES, certainly| One very common       *\n *   problem is to find and update all variables containing room  *\n *   number when a user moves which unfortunately is quite common *\n *   at our site at least|  And we are not alone...               *\n *                                                                *\n *   Many collegues from other companies use to complain about    *\n *   this problem every time we meet at, for instance, the TSO    *\n *   G.U.I.D.E. Conferences.  There is really a GREAT NEED for a  *\n *   tool to SEARCH & CHANGE VARIABLES|  The 7.3 option?  Forget  *\n *   it, it cannot SEARCH| We hope that IBM will eventually see   *\n *   the need and supply us with a tool for that purpose but      *\n *   until then we are not totally helpless at our installation   *\n *   at least cause we got THSPROFS|                              *\n *                                                                *\n *   As far as the creator of the dialog knows, this is the only  *\n *   existing tool to handle variables in all profile members for *\n *   all APPLIDs stored in the profile data set in a REASONABLY   *\n *   'user friendly' way|  The IBM alternative; 7.3, is frankly   *\n *   one of the least impressive IBM standard functions available *\n *   in ISPF|  It can only be used directly in the default APPLID *\n *   using the 7.3 option.  Other APPLIDs can be accessed if      *\n *   OPTION on the action bar on the primary option menu is used  *\n *   to change APPLID, a working solution but not a very          *\n *   convenient one since it requires the user to manually        *\n *   specify the APPLIDs and how many users are normally aware of *\n *   that information?|?  VERY FEW INDEED|  Further, the option   *\n *   7.3 can be really disastrous if used without the utmost      *\n *   care|  Why?  Well, let's look at one example:  if a          *\n *   truncated variable is changed via the 7.3 profile display,   *\n *   ONLY THE VISIBLE PART OF THE VARIABLE WILL BE WRITTEN BACK   *\n *   INTO THE PROFILE|| (See tutorial panel ISP7V010 in the IBM   *\n *   panellib.)  And the locate function is still rather basic    *\n *   even if it has been slightly improved in ISPF 4.1            *\n *                                                                *\n *                                                                *\n * PARAMETERS:  There are no parameters required.                 *\n *                                                                *\n *----------------------------------------------------------------*/\n\n  Address ISPEXEC\n  \"CONTROL ERRORS RETURN\"\n  \"VGET (ZAPPLID) ASIS\"\n\n  Call OBTAIN_THE_DSNAME_OF_THE_PROFILE_DATASET\n  Call OBTAIN_THE_MEMBER_NAMES_IN_THE_PROFILE_DATASET\n  Call MAIN_ROUTINE\n\n  EXIT\n\n/*----------------------------------------------------------------*/\nMAIN_ROUTINE :\n\n  Do FOREVER\n   \"DISPLAY PANEL(THSAPPLG)\"\n   If RC > 0 | ZCMD = \"END\" then LEAVE\n   Call PRIMARY_COMMAND_GLOBAL_SEARCH\n   End\n  \"TBEND\" v_tab\n  \"TBEND\" v_tabt\n\n  RETURN\n/*----------------------------------------------------------------*/\nOBTAIN_THE_DSNAME_OF_THE_PROFILE_DATASET :\n\n  PROFDSN = ''\n  Address ISPEXEC \"QBASELIB ISPPROF ID(PROFDSN)\"\n  If PROFDSN \u00ac= '' then NOP\n  DDNAME = \"ISPPROF \"     /* set ddname to check  */\n  X      = EFQDDN(DDNAME)\n  If X  \u00ac= 8 then PARSE VAR X RETCODE NUMBER PROFDSN DUMMY\n  Else do\n   Say \"No files allocated to DD-name\" DDNAME\n   EXIT 12\n   End\n\n  RETURN\n/*----------------------------------------------------------------*/\nOBTAIN_THE_MEMBER_NAMES_IN_THE_PROFILE_DATASET :\n\n  v_tab  = \"YXAZWQZ\"  /* choose any nonsence name|  */\n  \"TBEND   \" v_tab\n  \"TBCREATE\" v_tab  \"NAMES(MEMBER) WRITE\"\n  MEMVAR  = \"\"\n  \"LMINIT  DATAID(LMFILE)  DATASET(\"PROFDSN\") ENQ(SHR)\"\n  \"LMOPEN  DATAID(\"LMFILE\") OPTION(INPUT)\" ,\n                 \"LRECL(LRECL) RECFM(RECFM) ORG(ORGVAR)\"\n  LMRC = RC\n  DO while LMRC = 0\n   \"LMMLIST DATAID(\"LMFILE\") MEMBER(MEMVAR) STATS(NO)\"\n   LMRC = RC\n   IF LMRC  = 0 & POS('PROF',MEMVAR) > 0 then do\n    MEMBER = MEMVAR\n    \"TBADD\" v_tab\n    End\n   End\n  \"LMMLIST DATAID(\"LMFILE\")  OPTION(FREE)\"\n  \"LMCLOSE DATAID(\"LMFILE\")\"\n  \"TBTOP\" v_tab\n\n  RETURN\n/*----------------------------------------------------------------*/\nPRIMARY_COMMAND_GLOBAL_SEARCH :\n\n  Call CREATE_TEMPORARY_TABLE_NBR1\n  \"TBTOP\"   v_tab\n  \"TBQUERY\" v_tab \"ROWNUM(AROWG)\"\n\n  If AROWG > 0 then do i2 = 1 to AROWG\n   \"TBSKIP\"  v_tab\n   Call SCAN_THE_PROFILE\n   end\n\n  \"TBTOP\"   v_tabt\n  \"TBQUERY \"v_tabt \"ROWNUM(AROX)\"\n  If arox > 0 then  arox = FORMAT(arox)\n\n  If arox > 0 then do\n   \"CONTROL DISPLAY SAVE\"\n   Call EFQPT  v_tabt  /* separate dialog for variable maint. */\n   \"TBEND\"     v_tabt\n   \"CONTROL DISPLAY RESTORE\"\n   end\n  Else do\n   ZEDLMSG = ,\n     \"No variables found with specified value:  '\"THSAPP1\"'\"\n   \"SETMSG MSG(ISRZ001)\"\n   end\n\n  \"TBTOP\" v_tab\n\n  RETURN\n/*----------------------------------------------------------------*/\nCREATE_TEMPORARY_TABLE_NBR1 :\n\n  v_tabt = \"AXZWZQ\"\n  \"TBEND\"    v_tabt\n  \"TBCREATE\" v_tabt \"NAMES(VN,VAR,APPLID,PLC) WRITE\"\n  \"TBSORT\"   v_tabt \"FIELDS(APPLID,C,A VN,C,A)\"\n\n  RETURN\n/*----------------------------------------------------------------*/\n/* Scan the profile for specified character string                */\nSCAN_THE_PROFILE :\n\n  MEMBER = STRIP(MEMBER)\n  If MEMBER = \"ZQWXPROF\" then RETURN\n  APPLID = SUBSTR(MEMBER,1,POS('PROF',MEMBER)-1)\n  If APPLID = \"ZQWX\" then RETURN   /* not really needed */\n  qtab = MEMBER\n  PLC  = \"\"\n\n  If  MEMBER = \"ISRPROF\"  | ,\n      MEMBER = \"ISPPROF\"  | ,\n      MEMBER = \"ISPSPROF\" then do\n  /* Why this?  Well, these members are 'occupied' during the   */\n  /* session so the only way of accessing them is to do it in   */\n  /* a copy instead.                                            */\n   If MEMBER = \"ISPPROF\"  then ,\n    \"TBOPEN \"  MEMBER  \"WRITE LIBRARY(\"DDNAME\") SHARE\"\n   qtab = \"ZQWXPROF\"\n   \"TBSAVE\" MEMBER \"NAME(\"qtab\") REPLCOPY LIBRARY(\"DDNAME\") PAD(20)\"\n   If MEMBER = \"ISPPROF\" then  \"TBEND  \"  MEMBER\n   End\n\n  \"TBOPEN \" qtab \"NOWRITE LIBRARY(\"DDNAME\") SHARE\"\n  \"TBTOP  \" qtab\n  \"TBSKIP \" qtab\n  \"TBGET  \" qtab \"SAVENAME(EXTVARS)\"\n  EXTVARS = STRIP(STRIP(EXTVARS,'T',')'),'L','(')\n  \"VGET (THSAPP1,THSAPP2) PROFILE\"\n  Do ixix = 1 to words(EXTVARS)\n   VN  = STRIP(SUBWORD(EXTVARS,ixix,1),'T',X2C('00')) /* strip x'00'*/\n   /*                                                            */\n   /* NOTE: The previous instruction became necessary after IBM  */\n   /*       introduced variables ZGPCOLR and ZGHCOLR (ISPF 4.1)  */\n   /*       that have a DEFECTIVE(?) VARIABLE NAME LENGTH FIELD  */\n   /*       in the supplied version since it contains x'08' in   */\n   /*       spite of the names actually being 7 pos long|        */\n   /*                                                            */\n   /*       The REXX VALUE built in function can presently NOT   */\n   /*       be used for such strange variables, that is the      */\n   /*       reason for this extra STRIP.                         */\n   /* ********************************************************** */\n   /*                                                            */\n   /*       IBM might be of the opinion that the new variables   */\n   /*       mentioned above are for ISPF internal use and that   */\n   /*       they should be of no concern for the users and that  */\n   /*       might even be the case|  But I feel that an effort   */\n   /*       should be made by IBM to change the VALUE function   */\n   /*       so that it can handle ALL variables because I think  */\n   /*       that we users should be able to USE supplied         */\n   /*       functions, at least as long as there are no such     */\n   /*       restrictions described in the documentation of       */\n   /*       the functions (in this case the REXX VALUE function).*/\n   /*                                                            */\n   VAR = VALUE(VN)\n   If APPLID = \"ISR\" then \"VGET (\"VN\") PROFILE\"\n   If THSAPP1 \u00ac= \"\" then do\n    If THSAPP1 \u00ac= \"\" & THSAPP1A = \"\" & ,\n       VN  \u00ac= \"THSAPP1\" & POS(THSAPP1,VAR) > \"0\" then ,\n         \"TBADD \" v_tabt \"ORDER\"\n    If THSAPP1 \u00ac= \"\" & THSAPP1A \u00ac= \"\"  then do\n       /* two variable fields to be searched  */\n     If SUBSTR(THSAPP1A,1,1) = \"A\" then do\n      If (POS(THSAPP1,VAR)   > \"0\" & VN \u00ac= 'THSAPP1') & ,\n         (POS(THSAPP10,VAR)  > \"0\" & VN \u00ac= 'THSAPP10') then ,\n         \"TBADD \" v_tabt \"ORDER\"\n      end\n     If SUBSTR(THSAPP1A,1,1) = \"O\" then do\n      If (POS(THSAPP1,VAR)   > \"0\" & VN  \u00ac= 'THSAPP1') | ,\n         (POS(THSAPP10,VAR)  > \"0\" & VN  \u00ac= 'THSAPP10') then ,\n         \"TBADD \" v_tabt \"ORDER\"\n      end\n     end\n    end\n   If THSAPP2 \u00ac= \"\"  &  POS(THSAPP2,VN)  > \"0\" then ,\n         \"TBADD \" v_tabt \"ORDER\"\n   End\n\n  \"TBEND  \"  qtab\n\n  RETURN\n/*----------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "THSQTABC": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x14\\x00\\x933_\\x01\\x07\\x05\\x1f\\x11W\\x00.\\x00%\\x00\\x00\\xe2\\xf0\\xf0\\xf0\\xe3\\xc8\\xe2@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1993-12-01T00:00:00", "modifydate": "2007-02-20T11:57:14", "lines": 46, "newlines": 37, "modlines": 0, "user": "S000THS"}, "text": ")ATTR\n _ TYPE(INPUT)  INTENS(HIGH) COLOR(RED)    CAPS(ON) JUST(ASIS)\n \u00a2 TYPE(INPUT)  INTENS(HIGH) COLOR(RED)    CAPS(ON) JUST(LEFT) HILITE(USCORE)\n \\ TYPE(INPUT)  INTENS(HIGH) COLOR(PINK)   CAPS(OFF) JUST(ASIS)\n ? TYPE(OUTPUT) INTENS(LOW)\n ! TYPE(OUTPUT) INTENS(HIGH) COLOR(WHITE)  CAPS(OFF) JUST(ASIS)\n ~ TYPE(OUTPUT) INTENS(HIGH) COLOR(PINK)   CAPS(OFF) JUST(ASIS)\n \u00f8 TYPE(OUTPUT) INTENS(LOW)  COLOR(BLUE)   /* HILITE(REVERSE) */\n \u00d1 TYPE(TEXT)   INTENS(HIGH) COLOR(WHITE)\n \u00ac TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n ` TYPE(TEXT)   INTENS(HIGH) COLOR(RED)\n % TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)\n)BODY\n+THSQTABC  %Variables found in profiles    +APPL:~Z   +CPU:~Z   +\n\u00acCOMMAND  ==>_ZCMD                                                          +\n+\n+ Dialog to perform a 'global change' (GC) of specified char.string.\n+ The temporary table is searched and updated, but the profile is%NOT;  +\n+ that is performed using primary command%GUP.\n+\n+ You have specified some of these values on a previous panel. Now\n+ select the one to change (naturally only ONE variable value can be\n+ changed in each run, variable-NAME can not be changed)\n+\n+ Alternative: give%number+of the field to change.  The 'change to'\n+ string will be specified on a separate data entry panel.\n+\n+ Alternatives    \u00d1==>_Z+   specify%number+of field to change:\n+\n+ %1+ Search value ==>\\THSAPP1                                               +\n+     and/or       ==>_Z   +    A(AND) / O (OR)\n+ %2+ value        ==>\\THSAPP10                                              +\n+\n+\n+\n)INIT\n  .ZVARS  = '(ZAPPLID ZSYSID THENBR THSAPP1A)'\n  .HELP   = THSQTAB2\n  &AMT    = CSR\n)PROC\n  VER (&THENBR,NB,LIST,1,2)\n  If  (&THENBR = 1)\n      VER (&THSAPP1,NB)\n  If  (&THENBR = 2)\n      VER (&THSAPP10,NB)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "THSQTABD": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00$\\x00\\x933_\\x01\\x07\\x05\\x1f\\x11W\\x00.\\x003\\x00\\x00\\xe2\\xf0\\xf0\\xf0\\xe3\\xc8\\xe2@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1993-12-01T00:00:00", "modifydate": "2007-02-20T11:57:24", "lines": 46, "newlines": 51, "modlines": 0, "user": "S000THS"}, "text": ")ATTR\n _ TYPE(INPUT)  INTENS(HIGH) COLOR(RED)    CAPS(ON) JUST(ASIS)\n \u00a2 TYPE(INPUT)  INTENS(HIGH) COLOR(RED)    CAPS(ON) JUST(LEFT) HILITE(USCORE)\n \\ TYPE(INPUT)  INTENS(HIGH) COLOR(PINK)   CAPS(OFF) JUST(ASIS)\n ? TYPE(OUTPUT) INTENS(LOW)\n ! TYPE(OUTPUT) INTENS(HIGH) COLOR(WHITE)  CAPS(OFF) JUST(ASIS)\n ~ TYPE(OUTPUT) INTENS(HIGH) COLOR(PINK)   CAPS(OFF) JUST(ASIS)\n \u00f8 TYPE(OUTPUT) INTENS(LOW)  COLOR(BLUE)   /* HILITE(REVERSE) */\n \u00d1 TYPE(TEXT)   INTENS(HIGH) COLOR(WHITE)\n \u00ac TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n ` TYPE(TEXT)   INTENS(HIGH) COLOR(RED)\n % TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)\n)BODY\n+THSQTABD  %Variables found in profiles    +APPL:~Z   +CPU:~Z   +\n\u00acCOMMAND  ==>_ZCMD                                                          +\n+\n+\n+ You have specified variable value to change as follows:\n+\n+ Change from\u00d1==>~CSIN                                                       +\n+\n+\n+ Specify 'change to' value:\n+\n+            %Note: both 'change from' and 'change to' are \"as is\",+\n+            %      i.e. lower/UPPER case just as specified.+\n+\n+ Change to  \u00d1==>\\CSOUT                                                      +\n+\n+\n+\n+\n+\n+\n+\n+\n)INIT\n  .ZVARS  = '(ZAPPLID ZSYSID)'\n  .HELP   = THSQTAB2\n)PROC\n  IF (&CSIN    = &CSOUT)\n      &ZEDLMSG = 'Search value and new value are identical. Respecify'\n      .MSG    = ISRZ001\n      .CURSOR = CSOUT\n      .CSRPOS = 1\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "THSQTABT": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x002\\x00\\x92)O\\x01\\x07\\x05\\x1f\\x11W\\x00-\\x00(\\x00\\x00\\xe2\\xf0\\xf0\\xf0\\xe3\\xc8\\xe2@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1992-10-20T00:00:00", "modifydate": "2007-02-20T11:57:32", "lines": 45, "newlines": 40, "modlines": 0, "user": "S000THS"}, "text": ")ATTR\n _ TYPE(INPUT)  INTENS(HIGH) COLOR(RED)    CAPS(ON) JUST(ASIS)\n \u00a2 TYPE(INPUT)  INTENS(HIGH) COLOR(RED)    CAPS(ON) JUST(LEFT) HILITE(USCORE)\n \\ TYPE(INPUT)  INTENS(HIGH) COLOR(PINK)   CAPS(OFF) JUST(ASIS)\n ? TYPE(OUTPUT) INTENS(LOW)\n ! TYPE(OUTPUT) INTENS(HIGH) COLOR(WHITE)\n ~ TYPE(OUTPUT) INTENS(HIGH) COLOR(PINK)   /* CAPS(ON) JUST(LEFT)\n \u00f8 TYPE(OUTPUT) INTENS(LOW)  COLOR(BLUE)   /* HILITE(REVERSE)\n \u00d1 TYPE(TEXT)   INTENS(HIGH) COLOR(WHITE)\n \u00ac TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n ` TYPE(TEXT)   INTENS(HIGH) COLOR(RED)\n % TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)\n)BODY\n+THSQTABT  %Table contents tab &TAB        +APPL:~Z   +CPU:~Z   +\n\u00acCOMMAND  ==>_ZCMD                                           \u00acSCROLL ==>_AMT\n+\n+ CDAT    ==>\u00d1&CDAT    + table creation date             Time  %&ZDATE &ZTIME +\n+ CTIM    ==>\u00d1&CTIM    + table creation time\n+ UDAT    ==>\u00d1&UDAT    + date the table was last updated\n+ UTIM    ==>\u00d1&UTIM    + time the table was last updated\n+ USER    ==>%&USER    + the userid of the last update\n+ RCRT    ==>\u00d1&RCRT    + numbers of rows in the created table\n+ RCUR    ==>\u00d1&RCUR    + current number of rows\n+ RUPD    ==>\u00d1&RUPD    + number of updated rows\n+ TUPD    ==>\u00d1&TUPD    + number of times the table is updated\n+ SERV    ==>\u00d1&SERV    + name of last table services command\n+ RETC    ==>\u00d1&RETC    + last return code for a table services command\n+ STA1    ==>\u00d1&STA1    + status of the table in the input library chain\n+ STA2    ==>\u00d1&STA2    + status of the table for the logical screen\n+ STA3    ==>\u00d1&STA3    + status of the table for write mode\n+ Keynum  ==>\u00d1&QKEYNBR + total number of KEYS\n+ Keys    ==>\u00d1&QKEY                                                            +\n+ Namenum ==>\u00d1&QNAMNBR + total number of NAMES\n+  LC    Name\n+ ----  -------------\n)MODEL CLEAR(SEL)\n+ \u00a2Z  + !Z          +\n)INIT\n  .ZVARS  = '(ZAPPLID ZSYSID SEL KEY)'\n  .HELP   = VI2\n  &AMT    = CSR\n)REINIT\n  IF (.MSG = &Z)   &SEL = &Z   REFRESH(SEL)\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "THSQTAB1": {"ttr": 1038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00B\\x00\\x920\\x0f\\x01\\x07\\x05\\x1f\\x11W\\x00%\\x00&\\x00\\x00\\xe2\\xf0\\xf0\\xf0\\xe3\\xc8\\xe2@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "1992-10-26T00:00:00", "modifydate": "2007-02-20T11:57:42", "lines": 37, "newlines": 38, "modlines": 0, "user": "S000THS"}, "text": ")ATTR\n _ TYPE(INPUT)  INTENS(HIGH) COLOR(RED)    CAPS(ON) JUST(ASIS)\n \u00a2 TYPE(INPUT)  INTENS(HIGH) COLOR(RED)    CAPS(ON) JUST(LEFT) HILITE(USCORE)\n \\ TYPE(INPUT)  INTENS(HIGH) COLOR(PINK)   CAPS(OFF) JUST(ASIS)\n ? TYPE(OUTPUT) INTENS(LOW)\n ! TYPE(OUTPUT) INTENS(HIGH) COLOR(WHITE)  CAPS(OFF) JUST(ASIS)\n ~ TYPE(OUTPUT) INTENS(HIGH) COLOR(PINK)   CAPS(OFF) JUST(ASIS)\n \u00f8 TYPE(OUTPUT) INTENS(LOW)  COLOR(BLUE)   /* HILITE(REVERSE) */\n \u00d1 TYPE(TEXT)   INTENS(HIGH) COLOR(WHITE)\n \u00ac TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n ` TYPE(TEXT)   INTENS(HIGH) COLOR(RED)\n % TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)\n)BODY\n+THSQTAB1  %Variables found in profiles    +APPL:~Z   +CPU:~Z   +\n\u00acCOMMAND  ==>_ZCMD                                           \u00acSCROLL ==>_AMT\n+                                                       Timne%&ZDATE &ZTIME +\n+ Profile DSN    \u00d1==>!PROFDSN                                  +            +\n+ Searched for   \u00d1==>\\THSAPP1                                               +\n+ and/or         \u00d1==>_Z   +    A(AND) / O (OR)\n+ value          \u00d1==>\\THSAPP10                                              +\n+     or\n+ Variable name  \u00d1==>_THSAPP2 +\n+\n+  Use 'HELP' for info on available functions (primary and line commands)\n+\n+  LC  PLC  Applid Var.name   Var value (truncation may happen, S shows all)\n+ ---- ---- 1----- 2--------  3------------------------------------------------\n)MODEL CLEAR(SEL,PLC)\n+ \u00a2Z + !Z + !Z   + !Z       + !Z\n)INIT\n  .ZVARS  = '(ZAPPLID ZSYSID THSAPP1A SEL PLC APPLID VN VAR)'\n  .HELP   = THSQTAB2\n  &AMT    = CSR\n)REINIT\n  IF (.MSG = &Z)   &SEL = &Z   REFRESH(SEL)\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "THSQTAB2": {"ttr": 1040, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x10\\x00\\x920\\x9f\\x01\\x07\\x05\\x1f\\x13\\x01\\x00)\\x00,\\x00\\x00\\xe2\\xf0\\xf0\\xf0\\xe3\\xc8\\xe2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1992-11-04T00:00:00", "modifydate": "2007-02-20T13:01:10", "lines": 41, "newlines": 44, "modlines": 0, "user": "S000THS"}, "text": ")ATTR\n _ TYPE(INPUT)  INTENS(HIGH) COLOR(RED)    CAPS(ON) JUST(ASIS)\n \u00a2 TYPE(INPUT)  INTENS(HIGH) COLOR(RED)    CAPS(ON) JUST(LEFT) HILITE(USCORE)\n \\ TYPE(INPUT)  INTENS(HIGH) COLOR(PINK)   CAPS(OFF) JUST(ASIS)\n ? TYPE(OUTPUT) INTENS(LOW)\n ! TYPE(OUTPUT) INTENS(HIGH)\n ~ TYPE(OUTPUT) INTENS(HIGH) COLOR(YELLOW) CAPS(ON) JUST(LEFT)\n \u00f8 TYPE(OUTPUT) INTENS(LOW)  COLOR(BLUE)   /* HILITE(REVERSE)\n \u00d1 TYPE(TEXT)   INTENS(HIGH) COLOR(WHITE)\n \u00ac TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n ` TYPE(TEXT)   INTENS(HIGH) COLOR(RED)\n % TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)\n)BODY\n+THSQTAB2    %Information about the temporary ISPF-table:\n%Command \u00ac==>_ZCMD\n+\n+ The table shows the found variables. The applid for each variable\n+ is displayed.  Also its name and value which may be truncated.\n+ To display the complete value of a truncated variable, use line\n+ command S.\n+\n+ \u00acPrimary-commands:+  (basefunctions, for specials see next page)\n+\n+ %C      + exit the table (CANCEL)\n+\n+ %END    + go back one step.  If primary commando%F+has been used\n+           back out one step from the extracted table, otherwise the\n+           result is equal to primary command C (cancel) above.\n+ %RES(ET)+ clean PLC-field in current table.  If prim.cmd%GC+(see next\n+           page) was used a new table was created, but the original table\n+           is kept in memory. RESET will back to the original table.\n+\n+ %S1-S3  + sort the table in ascending  order by specified field number.\n+ %S1D-S3D+ sort the table in descending order by specified field number.\n+\n+ hit ENTER to scroll to next page in the tutorial.\n)INIT\n)PROC\n  &UP   = THSQTAB2\n  &CONT = THSQTAB3\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "THSQTAB3": {"ttr": 1042, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x15\\x00\\x920\\x9f\\x01\\x07\\x05\\x1f\\x12X\\x00(\\x00/\\x00\\x00\\xe2\\xf0\\xf0\\xf0\\xe3\\xc8\\xe2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1992-11-04T00:00:00", "modifydate": "2007-02-20T12:58:15", "lines": 40, "newlines": 47, "modlines": 0, "user": "S000THS"}, "text": ")ATTR\n _ TYPE(INPUT)  INTENS(HIGH) COLOR(RED)    CAPS(ON) JUST(ASIS)\n \u00a2 TYPE(INPUT)  INTENS(HIGH) COLOR(RED)    CAPS(ON) JUST(LEFT) HILITE(USCORE)\n \\ TYPE(INPUT)  INTENS(HIGH) COLOR(PINK)   CAPS(OFF) JUST(ASIS)\n ? TYPE(OUTPUT) INTENS(LOW)\n ! TYPE(OUTPUT) INTENS(HIGH)\n ~ TYPE(OUTPUT) INTENS(HIGH) COLOR(YELLOW) CAPS(ON) JUST(LEFT)\n \u00f8 TYPE(OUTPUT) INTENS(LOW)  COLOR(BLUE)   /* HILITE(REVERSE)\n \u00d1 TYPE(TEXT)   INTENS(HIGH) COLOR(WHITE)\n \u00ac TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n ` TYPE(TEXT)   INTENS(HIGH) COLOR(RED)\n % TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)\n)BODY\n+THSQTAB3    %Information about the temporary ISPF-table:\n%Command \u00ac==>_ZCMD\n+\n+ \u00acPRIMARY-commands:+  special functions\n+\n+ %F+xyz  + Find.  Search the table variable values for 'xyz'.\n+           This is an additional 'filtering' facility.\n+           Hits will be displayed in a separate table.\n+\n+ %GC     + Global change in the temporary table, %NOT+the real profile.\n+           Profiles can then be updated using GUP (see below).  This cautious\n+           method was selected because the profile is VERY 'sensitive', it\n+           is probably good to see the effect before the profile is changed.\n+\n+ %GUP    + Global Update, updates the variables in respective applid.\n+           All variables in the table are updated 'for real'.\n+           To update single variables use line command U.\n+\n+ %Q      + show internal table specification of table (probably uninteresting)\n+\n+ hit ENTER for a description of the \u00acLINECOMMANDS+\n+\n)INIT\n)PROC\n  &UP   = THSQTAB2\n  &CONT = THSQTAB4\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "THSQTAB4": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x06\\x00\\x920\\x9f\\x01\\x07\\x05\\x1f\\x11X\\x00(\\x00-\\x00\\x00\\xe2\\xf0\\xf0\\xf0\\xe3\\xc8\\xe2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1992-11-04T00:00:00", "modifydate": "2007-02-20T11:58:06", "lines": 40, "newlines": 45, "modlines": 0, "user": "S000THS"}, "text": ")ATTR\n _ TYPE(INPUT)  INTENS(HIGH) COLOR(RED)    CAPS(ON) JUST(ASIS)\n \u00a2 TYPE(INPUT)  INTENS(HIGH) COLOR(RED)    CAPS(ON) JUST(LEFT) HILITE(USCORE)\n \\ TYPE(INPUT)  INTENS(HIGH) COLOR(PINK)   CAPS(OFF) JUST(ASIS)\n ? TYPE(OUTPUT) INTENS(LOW)\n ! TYPE(OUTPUT) INTENS(HIGH)\n ~ TYPE(OUTPUT) INTENS(HIGH) COLOR(YELLOW) CAPS(ON) JUST(LEFT)\n \u00f8 TYPE(OUTPUT) INTENS(LOW)  COLOR(BLUE)   /* HILITE(REVERSE)\n \u00d1 TYPE(TEXT)   INTENS(HIGH) COLOR(WHITE)\n \u00ac TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n ` TYPE(TEXT)   INTENS(HIGH) COLOR(RED)\n % TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)\n)BODY\n+THSQTAB4    %Information about the temporary ISPF-table:\n%Command \u00ac==>_ZCMD\n+\n+ \u00acLINE-commands:+\n+\n+ %D      + remove the line from the table (variable is not changed)\n+\n+ %DP     + delete the variable from the%profile+data set.\n+\n+ %DS     + delete the variable from the%shared+pool.\n+\n+ %S      + display the variable on a separate panel where the value\n+           can be altered (normally before line command U is used,\n+           see below)\n+\n+ %U      + replace the variable in the profile data set.\n+\n+\n+\n+ \u00acEnd of description.\n+\n+\n)INIT\n)PROC\n  &UP   = THSQTAB3\n  &CONT = THSQTAB2\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "THSVARSM": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x17\\x01\\x07\\x05\\x1f\\x01\\x07\\x05\\x1f\\x11X\\x00B\\x00B\\x00\\x00\\xe2\\xf0\\xf0\\xf0\\xe3\\xc8\\xe2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-02-20T00:00:00", "modifydate": "2007-02-20T11:58:17", "lines": 66, "newlines": 66, "modlines": 0, "user": "S000THS"}, "text": ")ATTR\n ` TYPE(PT)                          /* panel title line             */\n ? TYPE(PIN)                         /* panel instruction line       */\n \u00c4 TYPE(CH)                          /* column heading               */\n # TYPE(DT)                          /* descriptive text             */\n + TYPE(NT)                          /* normal text                  */\n % TYPE(ET)                          /* emphasized text              */\n \u00a8 TYPE(WASL)                        /* work area separator line     */\n ! AREA(SCRL)  EXTEND(ON)            /* scrollable area attribute    */\n _ TYPE(INPUT)             JUST(LEFT)\n \u00f3 TYPE(INPUT)   CAPS(OFF) JUST(LEFT)\n \u00bd TYPE(VOI)     CAPS(ON)  JUST(RIGHT)  /* variable output */\n \u00e1 TYPE(VOI)     CAPS(OFF) JUST(LEFT)   /* variable output */\n \u00fa TYPE(VOI)     CAPS(OFF) JUST(RIGHT)  /* variable output */\n \u00a2 TYPE(OUTPUT)  CAPS(OFF) JUST(LEFT)\n \\ TYPE(OUTPUT)            JUST(LEFT)\n ~ TYPE(OUTPUT)            JUST(LEFT)\n)BODY\n+THSVARSM  %ISPF variable > 1000 ch. long +APPL:~Z   +CPU:~Z\n%COMMAND      ==>_ZCMD                                                         +\n+\n+ ISPF Variable greater than 1000 characters\n+\n+ Applid       %==>%&APPLID   +                             %&ZDATE &ZTIME +\n+ Variable name%==>%&VN       +\n+ Variable value\n+-------------------------------------------------------------------------------\n!AREA1                                                                         !\n)AREA AREA1\n\u00f3YXVAR\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n)INIT\n  .ZVARS = '(ZAPPLID ZSYSID)'\n  .HELP   = VI2\n  .CURSOR = ZCMD\n)PROC\n  .CURSOR = ZCMD\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VI2": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00V\\x01\\x07\\x05\\x1f\\x01\\x07\\x05\\x1f\\x11Y\\x00\\x0c\\x00\\x17\\x00\\x00\\xe2\\xf0\\xf0\\xf0\\xe3\\xc8\\xe2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2007-02-20T00:00:00", "modifydate": "2007-02-20T11:59:56", "lines": 12, "newlines": 23, "modlines": 0, "user": "S000THS"}, "text": "+VI2      +Description not available yet, sorry|\n%COMMAND  ==>_ZCMD                                                             +\n+\n+  There is no separate description available for the panel yet.\n+  The reason is that the description in the panel was seen as\n+  sufficient by the creator|  Or there was 'no time' to write one...\n+\n)INIT\n)PROC\n  &ZUP   = VI2\n  &ZCONT = VI2\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT754/FILE754.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT754", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}