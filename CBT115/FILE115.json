{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011247000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 764218, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 104, "INMBLKSZ": 6156, "INMRECFM": "VB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE115.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 764218, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 764218, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE115.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 6156, "DS1LRECL": 104, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\r\\x08'", "DS1TRBAL": "b')\\xf8'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x00\\xba\\x00\\x0e\\x00\\xbb\\x00\\x0c\\x00\\x0e'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"SCANDOC": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x00\\x87\\x02\\x8f\\x00\\x88\\x01/\\x11R\\x05\\xdf\\x05\\xdf\\x00\\x01\\xe3\\xe2\\xf1\\xf3\\xe3\\xd1\\xc1@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "1987-01-28T00:00:00", "modifydate": "1988-01-12T11:52:00", "lines": 1503, "newlines": 1503, "modlines": 1, "user": "TS13TJA"}, "text": "00010000*PROCESS     OPTIONS,SOURCE,LINECOUNT(60),NOMARGINI,MARGINS(010,100,009),NEST;\n00020000*PROCESS     FLAG(I),NOCOMPILE(E),LMESSAGE;\n00030000*PROCESS     AGGREGATE,ATTRIBUTES(SHORT),MAP,OFFSET,STORAGE,XREF(SHORT);\n00040000*PROCESS     GOSTMT,OPTIMIZE(TIME);\n00050000*PROCESS     COUNT,FLOW(25,10);\n00060000 SMPSCAN:  /*COMMERCIAL UNION SMP/E LIST ENTRY SELECTION UTILITY PROGRAM*/\n00070000 PROC(SYSPARM) OPTIONS(MAIN) REORDER;\n00080000    /*******************************************************************************/\n00090000    /*   NAME      .SMPSCAN   VERSION 02.00                                        */\n00100000    /*                                                                             */\n00110000    /*                                                                             */\n00120000    /*   TITLE     .COMMERCIAL UNION SMP/E LIST ENTRY SELECTION UTILITY.           */\n00130000    /*                                                                             */\n00140000    /*                                                                             */\n00150000    /*   PROGRAM OBJECTIVES                                                        */\n00160000    /*                                                                             */\n00170000    /*             .COMPENSATE FOR SOME OF THE LIMITATIONS OF THE SMP/E \"LIST\"     */\n00180000    /*              COMMAND, ESPECIALLY IN THE AREAS OF CROSS-ZONE ENTRY           */\n00190000    /*              MATCHING, DATE/TIME RANGE CONTROL OF LISTINGS, AND FMID        */\n00200000    /*              ASSOCIATION FOR ASSEMBLER AND LOAD MODULE ENTRIES.             */\n00210000    /*                                                                             */\n00220000    /*             .PROVIDE A UTILITY PROGRAM WRITTEN IN A HIGH LEVEL LANGUAGE     */\n00230000    /*              TO PROCESS THE \"SMPLIST\" OUTPUT FROM AN SMP/E                  */\n00240000    /*              \"SET_BDY(ZONENAME)./LIST.\" EXECUTION FOR ONE OR MORE ZONES     */\n00250000    /*              AND, USING A USER-SUPPLIED CONTROL VARIABLE INPUT FILE:        */\n00260000    /*                                                                             */\n00270000    /*                -PROVIDE CROSS-ZONE ENTRY MATCHING BASED ON SMP/E ENTRY      */\n00280000    /*                 TYPE, ENTRY NAME, AND ON CHARACTER STRING SCAN SELECTION.   */\n00290000    /*                                                                             */\n00300000    /*                -IDENTIFY ENTRIES SATISFYING SPECIFIED ENTRY TYPE/NAME       */\n00310000    /*                 MATCHING AND CHARACTER STRING SCAN SELECTION CRITERIA.      */\n00320000    /*                                                                             */\n00330000    /*                -GENERATE A RUN-TIME REPORT TO IDENTIFY EXECUTION CONTROL    */\n00340000    /*                 VALUES AND MATCH/SELECTION CRITERIA, PROVIDE A DIRECTORY    */\n00350000    /*                 TO MATCHING ENTRIES IN THE INPUT AND OUTPUT DATA SETS,      */\n00360000    /*                 AND REPORT FINAL PROCESSING TOTALS ONCE EXECUTION IS        */\n00370000    /*                 COMPLETE.                                                   */\n00380000    /*                                                                             */\n00390000    /*                -GENERATE LISTINGS OF THE MATCHING ENTRIES, BY FILE,         */\n00400000    /*                 SHOWING HOW CHARACTER STRING SELECTION CRITERIA HAVE BEEN   */\n00410000    /*                 APPLIED, AND IDENTIFYING WHERE THE SELECTION CRITERIA       */\n00420000    /*                 HAVE BEEN SATISFIED.                                        */\n00430000    /*                                                                             */\n00440000    /*                -GENERATE OUTPUT DATA SETS, ONE FOR EACH SMP/E LIST INPUT    */\n00450000    /*                 FILE, HAVING THE SAME FORMAT AND ATTRIBUTES AS THE          */\n00460000    /*                 \"SMPLIST\" INPUT DATA SET, TO ALLOW REPROCESSING OF THE      */\n00470000    /*                 MATCHING ENTRIES BY SMPSCAN WITH DIFFERENT SELECTION        */\n00480000    /*                 CRITERIA, OR TO PROVIDE INPUT TO ANY PROGRAM WHICH          */\n00490000    /*                 PROCESSES SMP/E LIST COMMAND OUTPUT AS INPUT.               */\n00500000    /*                                                                             */\n00510000    /*                -GENERATE 80-BYTE CARD-IMAGE OUTPUT DATA SETS, ONE FOR       */\n00520000    /*                 EACH SMP/E LIST INPUT DATA SET, CONTAINING DATA FROM THE    */\n00530000    /*                 MATCHING ENTRIES IN A FORMAT SUITABLE FOR USE IN AN SMP/E   */\n00540000    /*                 CONTROL STATEMENT, OR FOR FURTHER EDITING USING AN          */\n00550000    /*                 INTERACTIVE EDITOR.                                         */\n00560000    /*                                                                             */\n00570000    /*             .SUPPORT ALL OF THE ENTRY TYPES IN AN SMP/E GLOBAL, DLIB, OR    */\n00580000    /*              TARGET ZONE THAT CAN BE LISTED BY THE SMP/E \"LIST\" COMMAND,    */\n00590000    /*              WITH OR WITHOUT THE \"XREF\" OPTION.                             */\n00600000    /*                                                                             */\n00610000    /*             .USE CHARACTER STRING SELECTION AND ENTRY MATCHING TECHNIQUES   */\n00620000    /*              WHICH ARE GENERAL, AND RELATIVELY INSENSITIVE TO THE FORMAT    */\n00630000    /*              AND VALUES OF INDIVIDUAL DATA FIELDS WITHIN THE SMP/E          */\n00640000    /*              LISTING ENTRY LINES.  MOREOVER, IT WAS DEEMED IMPORTANT TO     */\n00650000    /*              REMAIN INDEPENDENT OF SMP/E INTERNALS OR KNOWLEDGE OF THOSE    */\n00660000    /*              INTERNALS.  THE CHARACTER STRING SCAN SELECTION TECHNIQUE IS   */\n00670000    /*              BASED ON PRESENCE OR ABSENCE OF SPECIFIED CHARACTER STRINGS    */\n00680000    /*              IN THE PRINT LINES DESCRIBING EACH INDIVIDUAL ENTRY.  THE      */\n00690000    /*              ENTRY MATCHING TECHNIQUE USED BY SMPSCAN IS BASED ON ENTRY     */\n00700000    /*              TYPE AND ON ENTRY NAME WITHIN TYPE.  THE ADVANTAGES OF USING   */\n00710000    /*              A CHARACTER STRING SCAN APPROACH ARE THAT ALTHOUGH CONTROL     */\n00720000    /*              FILES MAY REQUIRE CHANGE TO ACCOMMODATE NEW RELEASES OR        */\n00730000    /*              LEVELS OF SMP/E, THE PROGRAM ITSELF WILL NOT, IN GENERAL, BE   */\n00740000    /*              SENSITIVE TO CHANGES IN THE NAMES OF DATA FIELDS NOR WILL IT   */\n00750000    /*              BE HIGHLY SENSITIVE TO THE COLUMN LOCATIONS IN WHICH GIVEN     */\n00760000    /*              VALUES APPEAR.                                                 */\n00770000    /*                                                                             */\n00780000    /*             .THE MAJOR DISADVANTAGE FROM PROCESSING LISTINGS RATHER THAN    */\n00790000    /*              THE ZONE DATA BASES DIRECTLY IS THAT THE RESULTING             */\n00800000    /*              IMPLEMENTATION IS BATCH-ONLY.  THERE ARE ADDITIONAL RESOURCE   */\n00810000    /*              COSTS BOTH FOR LISTING THE ENIRE ZONE CONTENTS OF POSSIBLE     */\n00820000    /*              INTEREST TO DISK DATA SETS, AND FOR USING CHARACTER STRING     */\n00830000    /*              SCAN TECHNIQUES RATHER THAN INDEX SEARCHES TO TRACK DOWN THE   */\n00840000    /*              ENTRIES OF INTEREST.                                           */\n00850000    /*                                                                             */\n00860000    /*                                                                             */\n00870000    /*   SOURCE    .IBM PLI OPTIMIZING COMPILER AT VERSION 1 RELEASE 5.1 LEVEL.    */\n00880000    /*   LANGUAGE                                                                  */\n00890000    /*                                                                             */\n00900000    /*                                                                             */\n00910000    /*   MODULE    .NOT REENTRANT.  THE MODULE IS CODED REENTRANTLY WITHOUT        */\n00920000    /*   ATTRIBUTES     MODIFICATIONS TO STATIC STORAGE, BUT SEVERAL FILES ARE     */\n00930000    /*              OPENED AND USED BY THE PROGRAM.  ALSO, WITH PLI VERSION 1      */\n00940000    /*              RELEASE 5.1, THE RESULTING LOAD MODULE HAS AMODE=31,           */\n00950000    /*              RMODE=ANY.                                                     */\n00960000    /*                                                                             */\n00970000    /*             .THE COMPILE-TIME OPTIONS USED AT COMMERCIAL UNION FOR          */\n00980000    /*              COMPILING THIS PROGRAM WERE SPECIFIED USING \"*PROCESS\"         */\n00990000    /*              STATEMENTS.  THESE ARE INCLUDED AT THE BEGINNING OF THE        */\n01000000    /*              SOURCE PROGRAM.  EXECUTION TIME PERFORMANCE MAY BE IMPROVED    */\n01010000    /*              IF DESIRED BY DELETING THE \"*PROCESS\" STATEMENT REQUESTING     */\n01020000    /*              THE COUNT AND FLOW OPTIONS.                                    */\n01030000    /*                                                                             */\n01040000    /*             .THE EXECUTION-TIME PLI OPTIONS FOR THIS PROGRAM AT             */\n01050000    /*              COMMERCIAL UNION WERE INCORPORATED INTO THE PROGRAM VIA A      */\n01060000    /*              DECLARATION FOR THE STATIC VARIABLE \"PLIXOPT\".  AN ISASIZE     */\n01070000    /*              HAS BEEN SPECIFIED TO ELIMINATE THE NEED FOR USE OF THE        */\n01080000    /*              SYSTEM GETMAIN/FREEMAIN ROUTINES TO SATISFY STORAGE            */\n01090000    /*              REQUESTS, AND THE HEAP OPTION HAS BEEN SPECIFIED TO ALLOW      */\n01100000    /*              VIRTUAL STORAGE USE ABOVE THE 16 MEGABYTE LINE.                */\n01110000    /*                                                                             */\n01120000    /*                                                                             */\n01130000    /*   ENTRY     .THIS PROGRAM IS NAMED \"SMPSCAN\", ALTHOUGH                      */\n01140000    /*   POINT      PLI LOAD MODULES USE AN ENTRY POINT OF \"PLISTART\".             */\n01150000    /*                                                                             */\n01160000    /*                                                                             */\n01170000    /*   INPUT     .THE PARM FIELD OF THE EXEC STATEMENT IS NOT CURRENTLY USED     */\n01180000    /*              TO PASS EXECUTION-TIME VALUES TO SMPSCAN.  PRELIMINARY         */\n01190000    /*              SUPPORT HAS BEEN INCLUDED IN THE PROGRAM TO MAKE IT FAIRLY     */\n01200000    /*              EASY TO PROVIDE THIS SUPPORT LATER ON IF DESIRED.  VARIABLES   */\n01210000    /*              THAT MIGHT BE GOOD CANDIDATES FOR INCLUSION IN THIS TYPE OF    */\n01220000    /*              SUPPORT INCLUDE: DDIPFX, DDOPFX, IFILE_MAX, IPLANE_MAX,        */\n01230000    /*              IROW_MAX, ICOL_MAX, AND IMATCH_MAX.  THE \"SYSIN\" CONTROL       */\n01240000    /*              CARD DATA SET COULD ALSO BE ADAPTED TO USE A WIDER OR          */\n01250000    /*              VARIABLE RECORD SIZE.                                          */\n01260000    /*                                                                             */\n01270000    /*             .INPUT TO SMPSCAN IS PROVIDED BY THE FOLLOWING INPUT DATA       */\n01280000    /*              SETS:                                                          */\n01290000    /*                                                                             */\n01300000    /*                -THE CONTROL VARIABLE INPUT DATA SET, DDNAME=SYSIN           */\n01310000    /*                 (RECFM=FB, LRECL=80), CONTAINS VALUES TO DESIGNATE WHICH    */\n01320000    /*                 FILES ARE TO BE ACTIVE (UP TO 16 ARE SUPPORTED).  OTHER     */\n01330000    /*                 VARIABLES FROM THIS INPUT DATA SET CONTROL THE SCAN         */\n01340000    /*                 SELECTION AND MATCHING OF ENTRIES FROM EACH OF THE          */\n01350000    /*                 SMPLIST INPUT DATA SETS, AND VARY THE AMOUNT OF OUTPUT      */\n01360000    /*                 GENERATED TO EACH CORRESPONDING \"SMPDATA\" DATA SET.  FOR    */\n01370000    /*                 PROGRAMMING SIMPLICITY AND TO AVOID THIS PROGRAM'S          */\n01380000    /*                 BECOMMING A MAJOR DEVELOPMENT EFFORT, PLI GET DATA MODE     */\n01390000    /*                 WAS USED TO PROCESS EACH \"SYSIN\" INPUT RECORD.              */\n01400000    /*                 CONSEQUENTLY, ALL CHARACTER STRING VALUES MUST BE           */\n01410000    /*                 ENCLOSED IN QUOTES.  THE FOLLOWING PROGRAM CONTROL          */\n01420000    /*                 VARIABLES ARE READ FROM \"SYSIN\":                            */\n01430000    /*                                                                             */\n01440000    /*                    FILE_ACTIVE_OPTION(FILE#)                                */\n01450000    /*                    DATA_OUTPUT_OPTION(FILE#)                                */\n01460000    /*                                                                             */\n01470000    /*                    SCAN_ARRAY.SELECT(FILE#)                                 */\n01480000    /*                    SCAN_ARRAY.PLANE.SELECT(FILE#,PLANE#),                   */\n01490000    /*                    SCAN_ARRAY.PLANE.ROW.SELECT(FILE#,PLANE#,ROW#),          */\n01500000    /*                    SCAN_ARRAY.PLANE.ROW.COL.OP(FILE#,PLANE#,ROW#,COL#),     */\n01510000    /*                    SCAN_ARRAY.PLANE.ROW.COL.STRING(FILE#,PLANE#,ROW#,COL#)  */\n01520000    /*                    SCAN_ARRAY.PLANE.ROW.COL.BEG_POS(FILE#,PLANE#,ROW#,COL#) */\n01530000    /*                    SCAN_ARRAY.PLANE.ROW.COL.END_POS(FILE#,PLANE#,ROW#,COL#) */\n01540000    /*                    SCAN_ARRAY.PLANE.ROW.COL.POS_LEN(FILE#,PLANE#,ROW#,COL#) */\n01550000    /*                                                                             */\n01560000    /*                    MATCH_ARRAY.ENTRY.TYPE(MATCH#)                           */\n01570000    /*                    MATCH_ARRAY.ENTRY.COMPARE_TEST(MATCH#)                   */\n01580000    /*                    MATCH_ARRAY.ENTRY.FILE.COMPARE_OPTION(MATCH#,FILE#)      */\n01590000    /*                    MATCH_ARRAY.ENTRY.FILE.COMPARE_SELECT(MATCH#,FILE#)      */\n01600000    /*                    MATCH_ARRAY.ENTRY.FILE.WRITE_OPTION(MATCH#,FILE#)        */\n01610000    /*                    MATCH_ARRAY.ENTRY.FILE.WRITE_SELECT(MATCH#,FILE#)        */\n01620000    /*                                                                             */\n01630000    /*                 PLI DATA MODE DOES NOT ALLOW SUBSCRIPTS TO BE               */\n01640000    /*                 INTERLEAVED, AND CHARACTER STRING VALUES MUST BE ENCLOSED   */\n01650000    /*                 IN QUOTES.  A TERMINATING SEMICOLON IS NOT REQUIRED ON      */\n01660000    /*                 THE SYSIN CONTROL CARDS - IT IS SUPPLIED INTERNALLY FOR     */\n01670000    /*                 THE \"GET DATA\" STATEMENT BY SMPSCAN.  TO ALLOW THE INPUT    */\n01680000    /*                 DATA TO BE SELF-DOCUMENTING, A CONTROL CARD WITH AN \"*\"     */\n01690000    /*                 IN COLUMN 001 IS CONSIDERED TO BE A COMMENT RECORD, AND     */\n01700000    /*                 IT IS BYPASSED.  PLI GET DATA MODE DOES NOT ALLOW USE OF    */\n01710000    /*                 THE PLI-STYLE COMMENTS ON RECORDS PROCESSED BY \"GET         */\n01720000    /*                 DATA\".                                                      */\n01730000    /*                                                                             */\n01740000    /*                 THE MEANING OF THE ABOVE VARIABLES, AND THE ALLOWABLE       */\n01750000    /*                 VALUES FOR THEM ARE DESCRIBED IN THE FACILITIES/FEATURES    */\n01760000    /*                 SECTION BELOW.                                              */\n01770000    /*                                                                             */\n01780000    /*                -THE SMP/E LIST INPUT DATA SETS,                             */\n01790000    /*                 DDNAMES=(SMPLIST1-SMPLIST9, SMPLST10-SMPLST16)              */\n01800000    /*                 DCB=(RECFM=FBA,LRECL=121) CONTAIN THE OUTPUT WRITTEN TO     */\n01810000    /*                 THE \"SMPLIST\" DATA SET DURING AN SMP/E                      */\n01820000    /*                 \"SET_BDY(ZONENAME)./LIST.\"  RUN.  THIS DATA CAN COME        */\n01830000    /*                 DIRECTLY FROM EXECUTION OF SMP/E, OR FROM A DATA WRITTEN    */\n01840000    /*                 TO AN \"SMPSOUT\" DATA SET DURING A PREVIOUS EXECUTION OF     */\n01850000    /*                 SMPSCAN.  THE \"XREF\" OPTION CAN BE SPECIFIED ON THE SMP/E   */\n01860000    /*                 LIST COMMAND, IF IT IS SUPPORTED FOR THE ZONE BEING         */\n01870000    /*                 LISTED.  EACH SMP/E LIST DATA SET USED AS INPUT TO          */\n01880000    /*                 SMPSCAN MUST CONTAIN DATA FOR A SINGLE ZONE - \"LIST         */\n01890000    /*                 ALLZONES\" OUTPUT IS NOT SUPPORTED AS INPUT BY SMPSCAN.      */\n01900000    /*                 CROSS-ZONE MATCHING VIA SMPSCAN IS ACCOMPLISHED BY          */\n01910000    /*                 PROCESSING SEPARATE LIST DATA SETS, ONE FOR EACH ZONE OF    */\n01920000    /*                 INTEREST.                                                   */\n01930000    /*                                                                             */\n01940000    /*                                                                             */\n01950000    /*   WORK/     .SMPSCAN EXECUTION REQUIRES USE OF TEMPORARY WORK DATA SETS     */\n01960000    /*   SPILL      OR \"SPILL\" FILES FOR SAVING ENTRY LISTINGS WHOSE SIZE          */\n01970000    /*   FILES      EXCEEDS THE COMPILED CAPACITY OF SMPSCAN.  THERE ARE UP TO     */\n01980000    /*              16 OF THESE DATA SETS, ONE FOR EACH OF THE ACTIVE INPUT        */\n01990000    /*              LISTING FILES. THE DDNAMES ARE SMPUT1-9, SMPUT10-16, AND THE   */\n02000000    /*              DCB ATTRIBUTES ARE (RECFM=FB, LRECL=120).  PRINT CONTROL       */\n02010000    /*              CHARACTERS ARE NOT SAVED WITH THE LISTING LINES.  THE SPILL    */\n02020000    /*              FILE IS USED WHENEVER THE ENTRY MATCHING CRITERIA PROVIDED     */\n02030000    /*              IN \"MATCH_ARRAY\" INDICATE THAT THE ENTRY COULD POSSIBLY BE     */\n02040000    /*              WRITTEN TO AN OUTPUT DATA SET.                                 */\n02050000    /*                                                                             */\n02060000    /*              THE WORK/SPILL FILES CAN BE ALLOCATED TO ANY MEDIUM            */\n02070000    /*              SUPPORTING SEQUENTIAL INPUT AND OUTPUT TO THE SAME DATA SET    */\n02080000    /*              (E.G., DASD OR VIO).  AS EACH ENTRY LISTING LINE IS READ       */\n02090000    /*              FROM THE \"SMPLIST\" INPUT DATA SET AND AND PROCESSED AGAINST    */\n02100000    /*              THE FILE'S SCAN_ARRAY, THE LINE IS SAVED IN AN ARRAY IN        */\n02110000    /*              STORAGE.  IF THE NUMBER OF LINES IN AN ENTRY LISTING EXCEEDS   */\n02120000    /*              THE LIMIT SPECIFIED IN SMPSCAN PROGRAM VARIABLE                */\n02130000    /*              \"LINE_SAVE_LIMIT\" (CURRENTLY SET AT 100), THE WORK FILE IS     */\n02140000    /*              OPENED FOR OUTPUT, AND THE LINES BEYOND 100 (101, 102, ETC.)   */\n02150000    /*              ARE WRITTEN TO IT.  IF, ONCE THE ENTRY HAS BEEN FULLY READ,    */\n02160000    /*              IT IS DETERMINED THAT THE ENTRY SATISFIES THE SCAN SELECTION   */\n02170000    /*              AND FILE MATCHING CRITERIA SUPPLIED BY THE USER, THE WORK      */\n02180000    /*              FILE IS REOPENED FOR INPUT AND THE SAVED LINES ARE REREAD.     */\n02190000    /*              TOTALS OF THE NUMBER OF TIMES AN ENTRY WAS SAVED IN            */\n02200000    /*              ANTICIPATION OF ITS POSSIBLY BEING NEEDED, THE NUMBER OF       */\n02210000    /*              TIMES THE WORK FILE WAS OPENED FOR OUTPUT(WRITE OPEN/LINE      */\n02220000    /*              COUNTS) AND FOR INPUT(READ OPEN/LINE COUNTS) ARE DISPLAYED     */\n02230000    /*              IN THE FINAL TOTALS SECTION AT THE END OF THE \"SMPDCTRY\"       */\n02240000    /*              REPORT DATA SET.                                               */\n02250000    /*                                                                             */\n02260000    /*                                                                             */\n02270000    /*   OUTPUT    .SMPSCAN PRODUCES NO OPERATOR MESSAGES - THE PLI \"DISPLAY\"      */\n02280000    /*              STATEMENT IS NOT USED.                                         */\n02290000    /*                                                                             */\n02300000    /*             .SMPSCAN PRODUCES FOUR GROUPS OF OUTPUT DATA SETS:              */\n02310000    /*                                                                             */\n02320000    /*                -THE EXECUTION PROCESSING REPORT,                            */\n02330000    /*                 DDNAME=PTSDCTRY(RECFM=FBA,LRECL=133), CONTAINS MESSAGES     */\n02340000    /*                 AND COMMENTS DOCUMENTING THIS EXECUTION OF SMPSCAN.         */\n02350000    /*                 REGARDLESS OF THE NUMBER OF ACTIVE INPUT LISTING FILES,     */\n02360000    /*                 ONLY ONE SMPDCTRY DATA SET IS PRODUCED FOR AN EXECUTION     */\n02370000    /*                 OF SMPSCAN.  THE SMPDCTRY DATA SET REPORT CONTAINS FOUR     */\n02380000    /*                 SECTIONS:                                                   */\n02390000    /*                                                                             */\n02400000    /*                   1). INITIAL FILE INFORMATION AND SCAN_ARRAY CONTENTS.     */\n02410000    /*                   2). MATCH STATUS INFORMATION AND MATCH_ARRAY CONTENTS.    */\n02420000    /*                   3). DIRECTORY OF MATCHING ENTRIES (ONE SECTION FOR EACH   */\n02430000    /*                       DISTINCT TYPE OF ENTRY MATCHED).                      */\n02440000    /*                   4). FINAL PROCESSING TOTALS BY FILE, AND BY ENTRY TYPE    */\n02450000    /*                       WITHIN FILE.                                          */\n02460000    /*                                                                             */\n02470000    /*                 THE FIRST TWO SECTIONS ARE PRODUCED DURING SMPSCAN          */\n02480000    /*                 INITIALIZATION AND STARTUP, THE THIRD SECTION IS PRODUCED   */\n02490000    /*                 AS THE INPUT FILES ARE READ AND ENTRIES ARE MATCHED, AND    */\n02500000    /*                 THE LAST SECTION IS PRODUCED AFTER ALL INPUT FILES HAVE     */\n02510000    /*                 BEEN READ AND ALL MATCHING OUTPUT PRODUCED.                 */\n02520000    /*                                                                             */\n02530000    /*                -THE MATCHED ENTRY HIGHLIGHTED OUTPUT DATA SETS,             */\n02540000    /*                 DDNAMES=(SMPSCAN1-SMPSCAN9,SMPSCN10-SMPSCN16)               */\n02550000    /*                 DCB=(RECFM=FBA,LRECL=133), CONTAIN LISTINGS OF THE          */\n02560000    /*                 MATCHING ENTRIES.  THERE IS ONE OF THESE DATA SETS FOR      */\n02570000    /*                 EACH ACTIVE INPUT DATA SET.  THIS DATA SET, WHEN PRINTED,   */\n02580000    /*                 LOOKS LIKE THE SMPLIST OUTPUT FROM SMP/E, BUT THE DATA      */\n02590000    /*                 SETS ARE NOT COMPATIBLE.  PAGE TITLES AND LINE SPACING      */\n02600000    /*                 APPEAR THE SAME UPON PRINTING AND RECFM IS THE SAME, BUT    */\n02610000    /*                 THE LRECL IS LARGER (133 VS 121), AND THE TOP-OF-PAGE       */\n02620000    /*                 TITLE REFERENCES SMPSCAN RATHER THAN SMPLIST.  IN           */\n02630000    /*                 ADDITION, THOSE LINES SELECTED BY COMPARISON WITH THE       */\n02640000    /*                 FILE'S SCAN_ARRAY ARE FLAGGED ON THE RIGHT WITH             */\n02650000    /*                 \"**PPP,RRR**\" AND SELECTING CHARACTER STRINGS ARE           */\n02660000    /*                 UNDERSCORED.  THE FLAG ON THE RIGHT OF A HIGHLIGHTED LINE   */\n02670000    /*                 REFERENCES THE PLANE(\"PPP\") AND ROW(\"RRR\") OF THE FILE'S    */\n02680000    /*                 SCAN_ARRAY THAT RESULTED IN THE SUCCESSFUL COMPARISON.      */\n02690000    /*                 AN UNDERSCORE LINE IS PRODUCED ONLY FOR THE FIRST           */\n02700000    /*                 SUCCESSFUL ROW OF THE FILE'S SCAN_ARRAY.  NOTE: AN ENTRY    */\n02710000    /*                 THAT WAS CHOSEN BECAUSE AN EXCLUDE CRITERION WAS            */\n02720000    /*                 SATISFIED WILL NOT SHOW CORRESPONDING HIGHLIGHTED LINES     */\n02730000    /*                 BECAUSE THE CHARACTER STRING(S) DON'T APPEAR IN THE         */\n02740000    /*                 ENTRY.                                                      */\n02750000    /*                                                                             */\n02760000    /*                -THE MATCHED ENTRY SMPLIST OUTPUT DATA SETS,                 */\n02770000    /*                 DDNAMES=(SMPSOUT1-SMPSOUT9,SMPSOU10-SMPSOU16)               */\n02780000    /*                 DCB=(RECFM=FBA,LRECL=121), CONTAIN LISTINGS OF THE          */\n02790000    /*                 MATCHING ENTRIES.  THESE ARE THE SAME ENTRIES LISTED IN     */\n02800000    /*                 THE HIGHLIGHTED OUTPUT (\"SCAN\") DATA SETS, BUT WITHOUT      */\n02810000    /*                 HIGHLIGHTING INFORMATION.  THERE IS ONE OF THESE DATA       */\n02820000    /*                 SETS FOR EACH ACTIVE INPUT DATA SET. THIS OUTPUT DATA SET   */\n02830000    /*                 IS PRODUCED IN THE SAME FORMAT AND WITH THE SAME DCB        */\n02840000    /*                 ATTRIBUTES AS THE SMPLIST OUTPUT FROM SMP/E (RECFM,         */\n02850000    /*                 LRECL, PRINT CONTROL CHARACTERS, PAGE TITLES, AND LINE      */\n02860000    /*                 SPACINGS ARE THE SAME).  THE DATA SET CAN BE PRINTED, BUT   */\n02870000    /*                 IT IS NORMALLY USED TO PROVIDE INPUT (VIA SMPLIST           */\n02880000    /*                 DDNAMES) TO A FOLLOW-ON EXECUTION OF SMPSCAN USING          */\n02890000    /*                 DIFFERENT SELECTION CRITERIA.  IT CAN ALSO BE PASSED TO     */\n02900000    /*                 OTHER PROGRAMS WHICH PROCESS SMP/E SMPLIST OUTPUT SUCH AS   */\n02910000    /*                 THOSE FOUND ON SHARE OR GUIDE MODS TAPES.                   */\n02920000    /*                                                                             */\n02930000    /*                -THE MATCHED ENTRY CARD-IMAGE OUTPUT DATA SET,               */\n02940000    /*                 DDNAMES=(SMPDATA1-SMPDATA9,SMPDAT10-SMPDAT16)               */\n02950000    /*                 DCB=(RECFM=FB,LRECL=080), CONTAINS LISTING LINES FROM THE   */\n02960000    /*                 SELECTED ENTRIES MAPPED FROM A 120 CHARACTER PRINT LINE     */\n02970000    /*                 ONTO ONE OR MORE 80 BYTE CARD IMAGE RECORDS.  THERE IS      */\n02980000    /*                 ONE OF THESE DATA SETS FOR EACH ACTIVE INPUT DATA SET.      */\n02990000    /*                 DATA FROM EACH PRINT LINE IS MAPPED WITH ENCLOSING          */\n03000000    /*                 COMMENT CHARACTERS SO THAT ONLY THE ENTRY NAME, SMP         */\n03010000    /*                 M.C.S.  CONTROL STATEMENTS, ASSEM ENTRY ASSEMBLER SOURCE    */\n03020000    /*                 STATEMENTS, AND LMOD ENTRY LINKAGE EDITOR CONTROL           */\n03030000    /*                 STATEMENTS ARE MAPPED OUTSIDE COMMENT CHARACTERS.  THE      */\n03040000    /*                 DATA SET IS THUS USUALLY SUITABLE FOR DIRECT USE IN AN      */\n03050000    /*                 SMP CONTROL STATEMENT (SUCH AS \"APPLY\").  IT CAN ALSO BE    */\n03060000    /*                 PROCESSED BY ANY AVAILABLE INTERACTIVE EDITOR TO PRODUCE    */\n03070000    /*                 FURTHER RESULTS.  THE AMOUNT OF DATA WRITTEN TO THIS DATA   */\n03080000    /*                 SET DEPENDS ON THE SETTING OF THE \"DATA_OUTPUT_OPTION\"      */\n03090000    /*                 VARIABLE FOR THAT FILE.  THE ALLOWABLE VALUES AND           */\n03100000    /*                 ASSOCIATED OUTPUT ARE DESCRIBED IN THE                      */\n03110000    /*                 FEATURES/FACILITIES SECTION BELOW.                          */\n03120000    /*                                                                             */\n03130000    /*             .IN ADDITION TO THE DATA SETS PRODUCED BY SMPSCAN, THE          */\n03140000    /*              FOLLOWING ADDITIONAL DATA SETS MAY BE REQUIRED BECAUSE THE     */\n03150000    /*              PROGRAM IS WRITTEN IN PLI.  BOTH OF THESE DATA SETS SHOULD     */\n03160000    /*              BE ASSIGNED TO SYSOUT, OR DUMMIED OUT:                         */\n03170000    /*                                                                             */\n03180000    /*                -DDNAME=SYSPRINT IS REQUIRED IF AN ERROR IN PROGRAM          */\n03190000    /*                 EXECUTION OCCURS.                                           */\n03200000    /*                                                                             */\n03210000    /*                -DDNAME=PLIDUMP IS REQUIRED WHEN THE PROGRAM HAS BEEN        */\n03220000    /*                 COMPILED WITH WITH THE \"COUNT\" OR \"FLOW\" ATTRIBUTES, OR     */\n03230000    /*                 WHEN THE \"REPORT\" OPTION IS USED DURING PROGRAM EXECUTION   */\n03240000    /*                 TO MONITOR ISA AND HEAP STORAGE USE.                        */\n03250000    /*                                                                             */\n03260000    /*                                                                             */\n03270000    /*   RESTRICTIONS/LIMITATIONS                                                  */\n03280000    /*                                                                             */\n03290000    /*             .SMPSCAN HAS BEEN COMPILED UNDER IBM'S PLI OPTIMIZING           */\n03300000    /*              COMPILER VERSION 1 RELEASE 5.1 AND SUCCESSFULLY EXECUTED ON    */\n03310000    /*              MVS/SP LEVEL 2.1.3.  NO OTHER EXECUTION ENVIRONMENTS HAVE      */\n03320000    /*              BEEN TESTED WITH THIS PROGRAM SINCE THE SITE AT WHICH THIS     */\n03330000    /*              PROGRAM WAS DEVELOPED IS EXCLUSIVELY MVS/XA AND VM/SP.         */\n03340000    /*                                                                             */\n03350000    /*             .COMPILATION AND EXECUTION USING THE PLI OPTIMIZING COMPLIER    */\n03360000    /*              AND LIBRARIES AT VERSION 1 RELEASE 4.0 LEVEL PRODUCED A LOAD   */\n03370000    /*              MODULE WHICH FAILED TO EXECUTE.  WE TURNED OFF THE             */\n03380000    /*              \"OPTIMIZE(TIME)\" OPTION AT COMPILATION AND MADE TEMPORARY      */\n03390000    /*              PROGRAM CHANGES TO CIRCUMVENT THE PROBLEM UNTIL THE RELEASE    */\n03400000    /*              5.1 LEVEL OF THE COMPILER WAS INSTALLED.  WHILE WE SUSPECT     */\n03410000    /*              THESE PROBLEMS WERE RELATED TO THE MAINTENANCE LEVEL OF OUR    */\n03420000    /*              4.0 COMPILER, WE DID NOT RESEARCH THE PROBLEM IN DEPTH.  IT    */\n03430000    /*              MADE MORE SENSE TO US TO GET THE 5.1 LEVEL OF THE COMPILER     */\n03440000    /*              AND LIBRARIES UP AND OPERATIONAL SINCE WE HAD OTHER            */\n03450000    /*              REQUIREMENTS FOR THEM AS WELL.  IF THE PLI OPTIMIZING          */\n03460000    /*              COMPILER AT VERSION 1 RELEASE 5.1 OR LATER LEVEL IS NOT        */\n03470000    /*              AVAILABLE AT YOUR INSTALLATION, CONTACT THE AUTHOR FOR         */\n03480000    /*              FUTHER DETAILS.                                                */\n03490000    /*                                                                             */\n03500000    /*             .THE PROGRAM SUPPORTS SMPLIST OUTPUT FROM THE SMP/E \"LIST\"      */\n03510000    /*              COMMAND.  THERE ARE NO ENTRY TYPE PROCESSING RESTRICTIONS AS   */\n03520000    /*              THERE WERE IN PTSSCAN.  ALL ENTRY TYPES THAT ARE DEFINED IN    */\n03530000    /*              ZONES AND THAT CAN BE LISTED BY SMP/E RELEASE 3 ARE            */\n03540000    /*              SUPPORTED BY SMPSCAN.  MOREOVER, SMPSCAN HAS BEEN STRUCTURED   */\n03550000    /*              TO MAKE SUPPORT FOR NEW ENTRY TYPES FAIRLY EASY TO ADD.        */\n03560000    /*                                                                             */\n03570000    /*             .LISTING OF BACKUP ENTRIES FROM THE SCDS, MTSMAC ENTRIES FROM   */\n03580000    /*              SMPMTS, AND STSSRC ENTRIES FROM SMPSTS ARE NOT SUPPORTED BY    */\n03590000    /*              SMPSCAN AT THIS TIME.                                          */\n03600000    /*                                                                             */\n03610000    /*             .THIS VERSION OF SMPSCAN HAS BEEN RUN WITH SMPLIST OUTPUT       */\n03620000    /*              FROM SMP/E LVL 13.05.                                          */\n03630000    /*                                                                             */\n03640000    /*             .AT PRESENT, CONCURRENT PROCESSING IS SUPPORTED FOR A MAXIMUM   */\n03650000    /*              OF 16 INPUT LISTINGS ALONG WITH ASSOCIATED OUTPUT DATA SETS.   */\n03660000    /*                                                                             */\n03670000    /*             .ERROR ROUTINES TO ALLOW FOR RECOVERY FROM MISSING DD           */\n03680000    /*              STATEMENTS ARE NOT CODED INTO SMPSCAN AT THIS TIME.  THUS,     */\n03690000    /*              IF AN OUTPUT DATA SET IS NOT WANTED, A \"DD DUMMY\" JCL          */\n03700000    /*              STATEMENT SHOULD BE SUPPLIED FOR THE UNWANTED OUTPUT DATA      */\n03710000    /*              SET, OR THE PROGRAM WILL END IN ERROR WITHOUT PROCESSING ANY   */\n03720000    /*              DATA.                                                          */\n03730000    /*                                                                             */\n03740000    /*                                                                             */\n03750000    /*   FACILITIES/FEATURES                                                       */\n03760000    /*                                                                             */\n03770000    /*            THIS PROGRAM READS SMP/E \"SET_BDY(ZONENAME)./LIST.\"  OUTPUT      */\n03780000    /*      LISTINGS FROM DDNAME=SMPLIST THAT HAVE BEEN WRITTEN TO DISK OR TAPE    */\n03790000    /*      DATA SETS RATHER THAN SYSOUT.  UP TO 16 LISTING DATA SETS CAN BE       */\n03800000    /*      SCANNED AND MATCHED CONCURRENTLY.  ALL ENTRY TYPES ARE SUPPORTED.      */\n03810000    /*      AS ENTRY LISTINGS ARE READ, SMPSCAN SCANS EACH ENTRY FOR CHARACTER     */\n03820000    /*      STRINGS AS SPECIFIED BY THE FILE'S \"SCAN_ARRAY\".  BASED ON THE         */\n03830000    /*      RESULTS OF THESE SCANS AND ON THE FILE MATCHING INSTRUCTIONS FROM      */\n03840000    /*      THE \"MATCH_ARRAY\", SMPSCAN PRODUCES OUTPUT DATA SETS CONTAINING DATA   */\n03850000    /*      FROM THOSE ENTRIES SATISFYING THE COMBINATION OF SCAN SELECTION AND    */\n03860000    /*      MATCH CRITERIA SPECIFIED.                                              */\n03870000    /*                                                                             */\n03880000    /*            PROGRAM EXECUTION IS CONTROLLED BY VALUES SPECIFIED FOR          */\n03890000    /*      PROGRAM VARIABLES IN THE \"SYSIN\" DATA SET.  THE \"SYSIN\" DATA SET IS    */\n03900000    /*      DEFINED AS A \"RECORD\" DATA SET.  PLI \"GET STRING DATA\" IS USED TO      */\n03910000    /*      EXTRACT VALUES FROM EACH \"SYSIN\" INPUT RECORD ONCE IT HAS BEEN READ.   */\n03920000    /*      THIS TECHNIQUE WAS USED TO ALLOW COMMENT RECORDS TO BE INCLUDED WITH   */\n03930000    /*      THE VARIABLES AND THEIR VALUES.  IF AN \"*\" APPEARS IN BYTE 1 OF A      */\n03940000    /*      SYSIN INPUT RECORD, THE RECORD IS CONSIDERED A COMMENT.  SMPSCAN       */\n03950000    /*      BYPASSES COMMENT RECORDS.  WHEN A RECORD IS NOT A COMMENT, BYTES       */\n03960000    /*      01-72 OF THE INPUT RECORD ARE PROCESSED AS DATA - BYTES 73-80 ARE      */\n03970000    /*      IGNORED AND CAN CONTAIN SEQUENCE NUMBERS IF DESIRED.  IT IS NOT        */\n03980000    /*      NECESSARY TO INCLUDE A SEMI-COLON IN \"SYSIN\" INPUT RECORDS FOR GET     */\n03990000    /*      DATA MODE PROCESSING.  SMPSCAN APPENDS A SEMI-COLON TO THE END OF      */\n04000000    /*      THE DATA PORTION OF THE RECORD BEFORE DOING THE \"GET STRING DATA\"      */\n04010000    /*      FUNCTION.  BECAUSE PLI \"GET DATA\" IS USED TO READ THE INPUT            */\n04020000    /*      SPECIFICATIONS, THE SPECIFICATIONS MUST HAVE ONE OF THE FOLLOWING      */\n04030000    /*      FORMS:                                                                 */\n04040000    /*                                                                             */\n04050000    /*                 VARIABLE_NAME(SUBSCRIPTS) = NUMBER                          */\n04060000    /*            OR   VARIABLE_NAME(SUBSCRIPTS) = 'VALUE'                         */\n04070000    /*                                                                             */\n04080000    /*      THE VALUE SPECIFICATION FOR CHARACTER STRINGS MUST BE ENCLOSED IN      */\n04090000    /*      QUOTES BECAUSE THE CONTROL VARIABLES ARE DECLARED AS PLI CHARACTER     */\n04100000    /*      STRINGS. FURTHERMORE, SUBSCRIPTS MUST BE SPECIFIED TOGETHER            */\n04110000    /*      FOLLOWING THE VARIABLE NAME AND ALL QUALIFICATIONS.  UNLIKE THE PLI    */\n04120000    /*      COMPILER, PLI GET DATA MODE DOES NOT SUPPORT INTERLEAVED SUBSCRIPTS.   */\n04130000    /*      PROGRAM CONTROL VARIABLES THAT CAN BE SPECIFIED IN THE CONTROL         */\n04140000    /*      VARIABLE INPUT DATA SET WERE LISTED IN THE \"INPUT\" SECTION ABOVE.      */\n04150000    /*      THE MEANING OF THESE VARIABLES, THEIR EFFECTS ON PROGRAM EXECUTION,    */\n04160000    /*      AND THEIR VALID RANGES OF VALUES, WILL NOW BE DESCRIBED.               */\n04170000    /*                                                                             */\n04180000    /*            >>>>>FILE_ACTIVE_OPTION(FILE#).<<<<<                             */\n04190000    /*            THIS VARIABLE SPECIFIES WHICH FILES ARE TO BE ACTIVE DURING      */\n04200000    /*      THIS EXECUTION OF SMPSCAN.  IT IS DECLARED WITHIN SMPSCAN AS A         */\n04210000    /*      ONE-DIMENSIONAL ARRAY OF VARYING LENGTH CHARACTER STRINGS WITH THE     */\n04220000    /*      SINGLE SUBSCRIPT CORRESPONDING TO THE FILE NUMBER: 01-16.  THE         */\n04230000    /*      VALUES THAT CAN BE SPECIFIED ARE:                                      */\n04240000    /*                                                                             */\n04250000    /*                 'ACTIVE'                                                    */\n04260000    /*                 'INACTIVE'                                                  */\n04270000    /*                                                                             */\n04280000    /*      THE DEFAULT SPECIFICATION IS \"INACTIVE\" TO INSURE THAT FILES ARE       */\n04290000    /*      EXPLICITLY ACTIVATED.  IF A FILE IS \"ACTIVATED\", THE CORRESPONDING     */\n04300000    /*      \"LIST\", \"SCAN\" AND \"SOUT\" DD STATEMENTS MUST BE SUPPLIED.  THE         */\n04310000    /*      CORRESPONDING \"DATA\" DD STATEMENT IS ALSO REQUIRED UNLESS              */\n04320000    /*      DATA_OUTPUT_OPTION FOR THE FILE IS SET TO \"NONE\" (SEE BELOW).          */\n04330000    /*                                                                             */\n04340001    /*            >>>>>DATA_OUTPUT_OPTION(FILE#).<<<<<                             */\n04350000    /*            THIS VARIABLE CONTROLS THE AMOUNT OF OUTPUT WRITTEN TO EACH      */\n04360000    /*      ACTIVE CARD-IMAGE (SMPDATA1-SMPDATA9, SMPDAT10-SMPDAT16) OUTPUT DATA   */\n04370000    /*      SET FOR MATCHING ENTRIES.  THE SELECTION OF ENTRIES TO BE WRITTEN IS   */\n04380000    /*      CONTROLLED BY THE FILE'S SCAN_ARRAY CONTENTS, AND BY THE               */\n04390000    /*      MATCH_ARRAY.  THE DATA_OUTPUT_OPTION VARIABLE IS DECLARED WITHIN       */\n04400000    /*      SMPSCAN AS A ONE-DIMENSIONAL ARRAY OF VARYING LENGTH CHARACTER         */\n04410000    /*      STRINGS WITH THE SINGLE SUBSCRIPT CORRESPONDING TO THE FILE NUMBER:    */\n04420000    /*      01-16.  THE VALUES THAT CAN BE SPECIFIED ARE:                          */\n04430000    /*                                                                             */\n04440000    /*                 'NONE'                                                      */\n04450000    /*                 'ID1'                                                       */\n04460000    /*                 'ID'                                                        */\n04470000    /*                 'SELECT'                                                    */\n04480000    /*                 'ALL'                                                       */\n04490000    /*                                                                             */\n04500000    /*      THE DEFAULT SPECIFICATION IS \"NONE\".  CONSEQUENTLY, THE \"DATA\" DD      */\n04510000    /*      STATEMENT IS OPTIONAL AND IS REQUIRED AND USED ONLY IF EXPLICITLY      */\n04520000    /*      REQUESTED, AND IF THE MATCH_ARRAY INDICATES THAT THE DATA SET MAY BE   */\n04530000    /*      REQUIRED FOR OUTPUT.  THE OTHER SPECIFICATIONS CONTROL THE AMOUNT OF   */\n04540000    /*      DATA THAT WILL BE WRITTEN TO THIS DATA SET BY DESIGNATING WHICH OF A   */\n04550000    /*      MATCHING ENTRY'S LINES WILL BE MAPPED FROM 120-CHARACTER PRINT LINES   */\n04560000    /*      ONTO 80-BYTE CARD IMAGE RECORDS.  A VALUE OF \"ID1\" CAUSES THE FIRST    */\n04570000    /*      PART OF THE FIRST LISTING LINE FOR AN ENTRY TO BE MAPPED TO A SINGLE   */\n04580000    /*      80-BYTE CARD IMAGE.  THE RESULT IS A SINGLE CARD IMAGE FOR EACH        */\n04590000    /*      MATCHING ENTRY THAT IS SYNTACTICALLY CORRECT FOR USE WITH              */\n04600000    /*      SELECT/EXCLUDE OPERANDS ON SMP/E COMMANDS.  A VALUE OF \"ID\" CAUSES     */\n04610000    /*      THE FIRST LISTING LINE FOR AN ENTRY TO BE MAPPED TO ONE OR MORE CARD   */\n04620000    /*      IMAGE RECORDS.  SOME ENTRIES, E.G., M.C.S.  ENTRIES, MAY GENERATE      */\n04630000    /*      MORE THAN ONE CARD IMAGE WITH THE \"ID\" OPTION.  A VALUE OF \"SELECT\"    */\n04640000    /*      CAUSES THE FIRST LISTING LINE OF AN ENTRY, AND ANY LISTING LINE        */\n04650000    /*      WHICH WAS SELECTED BY COMPARISON WITH THE FILE'S SCAN_ARRAY TO BE      */\n04660000    /*      MAPPED TO CARD IMAGE RECORDS.  LASTLY, A VALUE OF \"ALL\" CAUSES ALL     */\n04670000    /*      LISTING LINES FOR A MATCHING ENTRY TO BE MAPPED ONTO CARD IMAGE        */\n04680000    /*      RECORDS, WHETHER SELECTED BY THE FILE'S SCAN_ARRAY, OR NOT.            */\n04690000    /*                                                                             */\n04700000    /*            >>>>>SCAN_ARRAY.<<<<<                                            */\n04710000    /*            SCAN_ARRAY PROVIDES SMPSCAN WITH THE INFORMATION IT NEEDS TO     */\n04720000    /*      SEARCH ENTRY LISTING LINES.  TITLE LINES ASIDE, THE FORMAT OF SMP/E    */\n04730000    /*      LIST OUTPUT LINES IS QUITE STRAIGHTFORWARD.  WITHOUT RECOURSE TO ANY   */\n04740000    /*      INTERNAL INFORMATION ON SMP/E, ONE CAN SEE THAT LISTING LINES ARE      */\n04750000    /*      FORMATTED IN FOUR AREAS, THREE OF WHICH ARE SIGNIFICANT:               */\n04760000    /*                                                                             */\n04770000    /*             .ENTRY NAME:       POSITIONS: 001-008     LENGTH: 008           */\n04780000    /*             .LINE TYPE:        POSITIONS: 011-025     LENGTH: 015           */\n04790000    /*             .EQUALS SIGN:      POSITION:    027       LENGTH: 001           */\n04800000    /*             .LINE DATA:        POSITIONS: 029-120     LENGTH: 092           */\n04810000    /*                                                                             */\n04820000    /*      THE TYPE OF ENTRY IS DETERMINED FROM THE SECOND TITLE LINE OF THE      */\n04830000    /*      PAGE ON WHICH THE ENTRY LISTING BEGINS.  A COMPLETELY BLANK LINE IS    */\n04840000    /*      NOT PART OF AN ENTRY LISTING, AND IS DISCARDED.  ON NON-BLANK LINES,   */\n04850000    /*      THE ENTRY NAME, LINE TYPE, AND LINE DATA AREAS HAVE A MAJOR TO MINOR   */\n04860000    /*      RELATIONSHIP WITHIN AN ENTRY LISTING.  THE ENTRY NAME FIELD CONTAINS   */\n04870000    /*      THE NAME OF THE ENTRY.  IF THE ENTRY NAME FIELD IS NON-BLANK, IT       */\n04880000    /*      SIGNALS THE START OF A NEW ENTRY LISTING.  IF BLANK, THE LINE IS A     */\n04890000    /*      CONTINUATION OF THE CURRENT ENTRY LISTING.  THE LINE TYPE FIELD        */\n04900000    /*      CATEGORIZES THE INFORMATION BEING LISTED ABOUT THE ENTRY.  WHEN THIS   */\n04910000    /*      AREA IS BLANK THE INFORMATION IN THE LINE DATA AREA IS IN THE SAME     */\n04920000    /*      CATEGORY AS THAT ON THE PRECEEDING LINE.  SOMETIMES SMP/E WILL PLACE   */\n04930000    /*      CHARACTERS IN THE ENDING POSITIONS OF THE LINE TYPE FIELD, LEAVING     */\n04940000    /*      THE BEGINNING BLANK.  IN THESE SITUATIONS IT MADE SENSE TO PROPAGATE   */\n04950000    /*      THE NON-BLANK DATA FROM THE PRECEEDING LINE TYPE VALUE.  AN EXAMPLE    */\n04960000    /*      OF THIS SITUATION OCCURS WITH \"DATA/TIME\" LINES.  APPLIED SYSMODS IN   */\n04970000    /*      A TARGET ZONE WILL HAVE A \"DATA/TIME REC\" LINE FOLLOWED BY AN          */\n04980000    /*      \"__________INS\" LINE.  SMPSCAN LOGIC SIMPLY CARRIES FORWARD THE        */\n04990000    /*      LEADING VALUE SO THAT THE LINE TYPE BECOMES \"DATE/TIME INS\".  THE      */\n05000000    /*      EQUALS SIGN AREA VISUALLY SEPARATES THE LINE TYPE AREA FROM THE LINE   */\n05010000    /*      DATA AREA, BUT OTHERWISE ISN'T SIGNIFICANT.  THE LINE DATA AREA        */\n05020000    /*      GENERALLY CONTAINS THE ELEMENTS WITHIN THE LINE TYPE CATEGORY.         */\n05030000    /*      EXAMPLES INCLUDE THE LISTS OF ELEMENTS AFFECTED BY A SYSMOD (MACROS,   */\n05040000    /*      MODULES), THE DATE AND TIME A SYSMOD WAS RECEIVED OR INSTALLED,        */\n05050000    /*      HOLDDATA INFORMATION, AND ASSEMBLER INPUT FOR ASSEMBLER ENTRIES.       */\n05060000    /*      SOMETIMES THE LINE TYPE AREA WILL IMPLY A SPECIAL TYPE OF LAYOUT FOR   */\n05070000    /*      THE INFORMATION PRINTED IN THE LINE DATA AREA.                         */\n05080000    /*                                                                             */\n05090000    /*            TO PROVIDE THE FACILITIES NEEDED FOR EFFECTIVE SEARCHING OF      */\n05100000    /*      LISTING LINES, FOUR GROUPS OF COMPARE AND SCAN OPERATIONS ARE          */\n05110000    /*      DEFINED:                                                               */\n05120000    /*                                                                             */\n05130000    /*             .ENTRY TYPE COMPARES.  THESE OPERATIONS TEST THE TYPE OF        */\n05140000    /*              ENTRY LISTED.  ENTRY TYPE IS DETERMINED FROM THE SECOND        */\n05150000    /*              TITLE LINE AND IS NOT PART OF THE ENTRY'S LISTING.             */\n05160000    /*                                                                             */\n05170000    /*             .LINE TYPE COMPARES.  THESE OPERATIONS TEST THE CONTENTS OF     */\n05180000    /*              THE SMPSCAN-CALCULATED LINE TYPE FIELD STORED SEPARATELY FOR   */\n05190000    /*              THE LINE.  SMPSCAN LOGICALLY CARRIES FORWARD LINE TYPE         */\n05200000    /*              INFORMATION FROM A PREVIOUS LINE IF THIS AREA OF THE CURRENT   */\n05210000    /*              LINE IS BLANK.  THE CONTENTS OF THE CURRENT LINE ARE NOT       */\n05220000    /*              CHANGED.  BECAUSE SMP/E USES A CARRY-FORWARD LOGIC FOR         */\n05230000    /*              FORMATTING THIS VALUE (ALL-BLANKS AND LEADING BLANKS), THESE   */\n05240000    /*              OPERATIONS ARE PROCESSED AS \"PREFIX\" COMPARES.     THE LINE    */\n05250000    /*              TYPE FIELD IS COMPARED ONLY UP TO THE LENGTH OF THE            */\n05260000    /*              SCAN_ARRAY \"STRING\", AND \"STRING\" IS NOT EXTENDED ON THE       */\n05270000    /*              RIGHT WITH BLANKS.  BOTH NORMAL (CHARACTER-BY-CHARACTER) AND   */\n05280000    /*              GENERIC COMPARE OPERATIONS ARE PROVIDED.                       */\n05290000    /*                                                                             */\n05300000    /*             .LINE DATA COMPARES.  THESE OPERATIONS EXAMINE DATA ON THE      */\n05310000    /*              LISTING LINE.  PROGRAM DEFAULTS ARE SET TO COMPARE AT THE      */\n05320000    /*              BEGINNING OF THE LINE DATA AREA (029), BUT LOCATIONS           */\n05330000    /*              ANYWHERE ON THE LINE CAN BE COMPARED, INCLUDING THE ENTRY      */\n05340000    /*              NAME AND LINE TYPE AREAS.  THE COMPARISON IS DONE ONCE, AT     */\n05350000    /*              THE LINE POSITION DESIGNATED IN SCAN_ARRAY VARIABLE            */\n05360000    /*              \"BEG_POS\" (SEE BELOW).  LINE DATA COMPARES DIFFER FROM LINE    */\n05370000    /*              TYPE COMPARES IN TWO WAYS:  LINE DATA COMPARES ARE NOT         */\n05380000    /*              PREFIX COMPARES, A FIELD LENGTH LONGER THAN THE STRING         */\n05390000    /*              LENGTH IS NOT IMPLIED, AND LINE DATA COMPARES ARE NOT          */\n05400000    /*              LIMITED TO THE LINE DATA FIELD, DATA ANYWHERE ON THE LINE      */\n05410000    /*              CAN BE COMPARED.  BOTH NORMAL AND GENERIC COMPARE OPERATIONS   */\n05420000    /*              ARE PROVIDED.                                                  */\n05430000    /*                                                                             */\n05440000    /*             .LINE DATA SCANS.  THESE OPERATIONS EXAMINE THE DATA ON THE     */\n05450000    /*              LISTING LINE FOR ONE OR MORE OCCURRENCES OF A CHARACTER        */\n05460000    /*              STRING.  PROGRAM DEFAULTS ARE SET TO SCAN THE BOUNDS OF THE    */\n05470000    /*              LINE DATA AREA (029-120), BUT DATA ANYWHERE ON THE LINE CAN    */\n05480000    /*              BE SCANNED.  TO REDUCE EXECUTION OVERHEAD, THE FIRST           */\n05490000    /*              OCCURRENCE OF A STRING STOPS THE SCAN WHEN TESTING LINES,      */\n05500000    /*              BUT ALL OCCURRENCES WILL BE UNDERSCORED IF THE ENTRY IS        */\n05510000    /*              WRITTEN WITH HIGHLIGHTED OUTPUT.  SCAN OPERATIONS RESEMBLE     */\n05520000    /*              EDIT PROCESSOR \"FIND\" COMMANDS, EXCEPT THAT THE SCAN           */\n05530000    /*              OPERATION IS RESTRICTED TO A SINGLE LINE.  BOTH NORMAL AND     */\n05540000    /*              GENERIC SCAN OPERATIONS ARE SUPPORTED.                         */\n05550000    /*                                                                             */\n05560000    /*            SCAN_ARRAY IS DECLARED WITHIN SMPSCAN AS A FOUR DIMENSIONAL      */\n05570000    /*      ARRAY OF STRUCTURES, WITH EACH FILE HAVING A CORRESPONDING             */\n05580000    /*      CROSS-SECTION.  THE FIRST SCAN_ARRAY SUBSCRIPT CORRESPONDS TO THE      */\n05590000    /*      FILE NUMBER (FILE#) WITHIN SMPSCAN, AND THE REMAINING SUBSCRIPTS       */\n05600000    /*      DESIGNATE THE PLANE, ROW, AND COLUMN NUMBERS WITHIN SCAN_ARRAY FOR     */\n05610000    /*      THAT FILE.  EACH FILE'S CROSS SECTION OF SCAN_ARRAY CAN BE THOUGHT     */\n05620000    /*      OF AS A CUBE.  A CUBE IS MADE UP OF PLANES WHICH IN TURN ARE MADE UP   */\n05630000    /*      OF LINES (ROWS) WHICH ARE MADE UP OF POINTS (COLUMNS).  THE            */\n05640000    /*      SCAN_ARRAY WAS DESIGNED AS AN ALTERNATIVE TO TRYING TO DESIGN A        */\n05650000    /*      BOOLEAN ALGEBRA SYNTAX FOR SEARCHING THE LISTING LINES OF AN ENTRY     */\n05660000    /*      FOR CHARACTER STRINGS.  THE PLANE AND ROW DIMENSIONS WERE SET UP TO    */\n05670000    /*      PROVIDE \"LOGICAL OR(PLANE)\" AND \"LOGICAL AND(ROW)\" CAPABILITY, WHILE   */\n05680000    /*      THE COLUMN DIMENSION PROVIDES FOR MULTIPLE CHARACTER STRING TESTS      */\n05690000    /*      AGAINST THE SAME LINE.  NEGATION CAPABILITY IS ALSO PROVIDED AT EACH   */\n05700000    /*      LEVEL WITHIN A FILE'S CROSS-SECTION SO THAT DE_MORGAN'S RULES          */\n05710000    /*      RELATING \"LOGICAL AND\" AND \"LOGICAL OR\":                               */\n05720000    /*                                                                             */\n05730000    /*           \u00ac(A & B) = \u00acA | \u00acB      (\"|\" IS THE PLI SYMBOL FOR \"OR\")          */\n05740000    /*           \u00ac(A | B) = \u00acA & \u00acB      (\"&\" IS THE PLI SYMBOL FOR \"AND\")         */\n05750000    /*                                                                             */\n05760000    /*      ALONG WITH SOME OF THEIR USEFUL CONSEQUENCES USING DOUBLE NEGATION     */\n05770000    /*      TO EXCHANGE THE ROLES OF \"AND\" AND \"OR\":                               */\n05780000    /*                                                                             */\n05790000    /*            (A & B) = \u00ac(\u00acA | \u00acB)                                             */\n05800000    /*            (A | B) = \u00ac(\u00acA & \u00acB)                                             */\n05810000    /*                                                                             */\n05820000    /*           (\u00acA & B) = \u00ac( A | \u00acB)                                             */\n05830000    /*           (\u00acA | B) = \u00ac( A & \u00acB)                                             */\n05840000    /*                                                                             */\n05850000    /*      AND THE IDENTITY:                                                      */\n05860000    /*                                                                             */\n05870000    /*               A    =   \u00ac(\u00acA)                                                */\n05880000    /*                                                                             */\n05890000    /*      CAN BE USED TO USED TO ADVANTAGE.  NEGATION CAPABILITY ALSO ALLOWS     */\n05900000    /*      ENTRIES TO BE SELECTED BASED ON CONDITIONS THAT AREN'T SATISFIED       */\n05910000    /*      (E.G., TO FIND A SYSMOD THAT DOES CONTAIN JCLIN OR REFERENCES A        */\n05920000    /*      SYSGEN MACRO, BUT THAT DOESN'T BELONG TO A PARTICULAR FMID).           */\n05930000    /*                                                                             */\n05940000    /*            THE STRUCTURAL DECLARATION OF SCAN_ARRAY IS AS FOLLOWS:          */\n05950000    /*                                                                             */\n05960000    /*            01 SCAN_ARRAY                           CONTROLLED,              */\n05970000    /*               05 FILE(IFILE_MIN:IFILE_MAX),       -ONE CUBE FOR EACH FILE-  */\n05980000    /*                  09 SELECT_OPTION                  CHAR(008) VARYING,       */\n05990000    /*                  09 PLANE(IPLANE_MIN:IPLANE_MAX),                           */\n06000000    /*                     13 SELECT_OPTION               CHAR(008) VARYING,       */\n06010000    /*                     13 ROW(IROW_MIN:IROW_MAX),                              */\n06020000    /*                        17 SELECT_OPTION            CHAR(008) VARYING,       */\n06030000    /*                        17 COL(ICOL_MIN:ICOL_MAX),                           */\n06040000    /*                           21 BEG_POS               FIXED BINARY(15,0),      */\n06050000    /*                           21 END_POS               FIXED BINARY(15,0),      */\n06060000    /*                           21 POS_LEN               FIXED BINARY(15,0),      */\n06070000    /*                           21 OP                    CHAR(008) VARYING,       */\n06080000    /*                           21 OP_OIX                FIXED BINARY(15,0),      */\n06090000    /*                           21 STRING                CHAR(032) VARYING,       */\n06100000    /*                           21 STR_LEN               FIXED BINARY(15,0),      */\n06110000    /*                           21 STR_NIX               FIXED BINARY(15,0),      */\n06120000    /*                                                                             */\n06130000    /*      IF SCAN_ARRAY VARIABLES ARE SPECIFIED FOR A FILE, A \"SCAN_RESULT\"      */\n06140000    /*      IS CALCULATED FOR EACH ENTRY PROCESSED (SEE THE DESCRIPTION OF         */\n06150000    /*      MATCH_ARRAY FOR AN EXPLANATION OF WHEN ENTRIES ARE PROCESSED).         */\n06160000    /*      THREE RESULTS ARE RECOGNIZED IN SMPDCTRY OUTPUT:  SCANNED AND          */\n06170000    /*      SELECTED, SCANNED AND NOT SELECTED, AND NOT SCANNED.  FOR THE          */\n06180000    /*      PURPOSES OF ENTRY MATCHING, HOWEVER, SCANNED AND NOT SELECTED IS       */\n06190000    /*      EQUIVALENT TO NOT SCANNED.  THE \"SCAN_RESULT\" CALCULATION IS A THREE   */\n06200000    /*      STEP PROCESS:                                                          */\n06210000    /*                                                                             */\n06220000    /*           1. WHEN THE FIRST LINE OF A NEW ENTRY IS RECOGNIZED, ALL OF THE   */\n06230000    /*              SCAN_ARRAY ROW RESULTS ARE SET TO '0'B ('0'B = FALSE OR        */\n06240000    /*              NOT SELECTED, '1'B = TRUE OR SELECTED).                        */\n06250000    /*                                                                             */\n06260000    /*           2. A SCAN_ARRAY PLANE OR ROW IS CONSIDERED ACTIVE IF ANY COLUMN   */\n06270000    /*              SUBSTRUCTURE CONTAINS A \"STRING\" VALUE.  AS ENTRY LINES ARE    */\n06280000    /*              READ, EACH ACTIVE ROW IN EACH ACTIVE PLANE IS REVIEWED.  IF    */\n06290000    /*              THE ROW RESULT IS ALREADY SET TO '1'B, TESTS FOR THAT ROW      */\n06300000    /*              ARE SKIPPED (FOR SCANNING BUT NOT FOR HIGHLIGHTING) TO         */\n06310000    /*              REDUCE EXECUTION OVERHEAD.  WHEN THE RESULT FOR AN ACTIVE      */\n06320000    /*              ROW IS NOT YET SET TO '1'B, THE COLUMN SUBSTRUCTURES ARE       */\n06330000    /*              PROCESSED AGAINST THE CURRENT LINE, AND A ROW RESULT IS        */\n06340000    /*              CALCULATED.                                                    */\n06350000    /*                                                                             */\n06360000    /*              THE ROW-COLUMN STRUCTURING IS DESIGNED TO PROVIDE A WAY TO     */\n06370000    /*              DESCRIBE SEPARATE MULTIPLE TESTS AGAINST THE SAME LINE.  THE   */\n06380000    /*              TESTS FOR ALL ACTIVE COLUMNS IN A ROW MUST BE SATISFIED        */\n06390000    /*              AGAINST THE SAME LINE IN ORDER FOR A POSITIVE ROW RESULT TO    */\n06400000    /*              OCCUR.                                                         */\n06410000    /*                                                                             */\n06420000    /*           3. ONCE ALL LINES FOR AN ENTRY HAVE BEEN READ AND ROW RESULTS     */\n06430000    /*              HAVE BEEN DETERMINED, CALCULATION OF THE FINAL SCAN_RESULT     */\n06440000    /*              FOR THE ENTRY BEGINS.  A ROW'S RESULT IS FIRST COMPARED WITH   */\n06450000    /*              ITS SELECT_OPTION.  IF EACH ACTIVE ROW'S RESULT IS THE SAME    */\n06460000    /*              AS ITS SELECT_OPTION, THE PLANE'S RESULT IS SET TO '1'B.       */\n06470000    /*              OTHERWISE, THE PLANE'S SCAN_RESULT IS SET TO '0'B.  A          */\n06480000    /*              SCAN_RESULT MATCHES ITS CORRESPONDING SELECT_OPTION IF         */\n06490000    /*              EITHER THE RESULT IS '1'B AND THE OPTION IS \"SELECT\", OR THE   */\n06500000    /*              RESULT IS '0'B AND THE OPTION IS \"EXCLUDE\".  IN EFFECT, THE    */\n06510000    /*              FINAL RESULTS FOR THE ACTIVE ROWS ARE \"ANDED\" TOGETHER.        */\n06520000    /*                                                                             */\n06530000    /*              ONCE THE PLANE RESULTS HAVE BEEN DETERMINED, THE FILE (CUBE)   */\n06540000    /*              RESULT IS CALCULATED.  EACH ACTIVE PLANE'S RESULT IS           */\n06550000    /*              COMPARED WITH ITS CORRESPONDING SELECT_OPTION.  IF ANY         */\n06560000    /*              ACTIVE PLANE'S RESULT MATCHES ITS SELECT_OPTION, THE ENTRY'S   */\n06570000    /*              FILE (CUBE) SCAN_RESULT IS SET TO '1'B.  OTHERWISE IT IS SET   */\n06580000    /*              TO '0'B.  IN EFFECT, THE FINAL PLANE RESULTS ARE \"ORED\"        */\n06590000    /*              TOGETHER.                                                      */\n06600000    /*                                                                             */\n06610000    /*              THE FILE SCAN_RESULT IS THE NEXT-TO-LAST STEP IN CALCULATING   */\n06620000    /*              THE ENTRY'S SCAN_RESULT.  THE FILE RESULT IS COMPARED WITH     */\n06630000    /*              THE SELECT_OPTION AT THE FILE LEVEL.  IF THEY AGREE, THE       */\n06640000    /*              FINAL SCAN_RESULT FOR THE ENTRY IS SET TO '1'B, OTHERWISE      */\n06650000    /*              '0'B.                                                          */\n06660000    /*                                                                             */\n06670000    /*              THE FILE-PLANE-ROW STRUCTURE IS DESIGNED TO PROVIDE A WAY TO   */\n06680000    /*              DESCRIBE NOT/OR/AND OPERATIONS TO BE APPLIED TO THE ROW        */\n06690000    /*              RESULTS OBTAINED FROM EXAMINING AN ENTRY'S LISTING LINES.  A   */\n06700000    /*              FULL BOOLEAN EXPRESIION CAN BE CONSTRUCTED, ALTHOUGH SOME      */\n06710000    /*              DUPLICATION MAY BE REQUIRED.  SELECT OPTIONS CORRESPOND TO     */\n06720000    /*              \"NOT\", PLANES TO \"OR\", AND ROWS TO \"AND\".                      */\n06730000    /*                                                                             */\n06740000    /*      AN ENTRY'S FINAL SCAN_RESULT IS PART OF THE INFORMATION USED BY        */\n06750000    /*      MATCH_ARRAY PROCESSING TO DECIDE WHICH ENTRIES SHOULD BE WRITTEN TO    */\n06760000    /*      OUTPUT DATA SETS.                                                      */\n06770000    /*                                                                             */\n06780000    /*            THE SCAN_ARRAY VARIABLES THAT CAN BE SUPPLIED IN THE \"SYSIN\"     */\n06790000    /*      DATA STREAM ARE LISTED ABOVE IN THE INPUT SECTION.  IF USED, THEY      */\n06800000    /*      SHOULD BE SPECIFIED WITH REQUIRED LEVELS OF QUALIFICATION AND          */\n06810000    /*      SUBSCRIPTS AS SHOWN THERE.  NOT ALL SCAN_ARRAY VARIABLES CAN BE        */\n06820000    /*      SPECIFIED:  SOME, SUCH AS STR_LEN, AND STR_NIX ARE CALCULATED AFTER    */\n06830000    /*      ALL VARIABLES HAVE BEEN READ, AND POS_LEN IS USUALLY ALLOWED TO        */\n06840000    /*      DEFAULT.  THE VARIABLES THAT CAN BE SUPPLIED, ALONG WITH THEIR         */\n06850000    /*      DEFAULT VALUES ARE:                                                    */\n06860000    /*                                                                             */\n06870000    /*             .SELECT_OPTION.  THE SELECT OPTIONS CAN BE SPECIFIED AT THE     */\n06880000    /*              FILE, PLANE AND ROW LEVELS AND INDICATE NEGATION IF            */\n06890000    /*              REQUESTED.  THE VALUES THAT CAN BE SPECIFIED ARE:              */\n06900000    /*                                                                             */\n06910000    /*                 'SELECT'                                                    */\n06920000    /*                 'EXCLUDE'                                                   */\n06930000    /*                                                                             */\n06940000    /*              THE DEFAULT SPECIFICATION IS \"SELECT\".  A VALUE OF \"EXCLUDE\"   */\n06950000    /*              REQUESTS NEGATION.  THE EFFECTS OF THESE VARIABLES IN          */\n06960000    /*              COMPUTING THE LINE SCAN RESULTS FOR AN INDIVIDUAL ENTRY        */\n06970000    /*              ARE DESCRIBED BELOW.                                           */\n06980000    /*                                                                             */\n06990000    /*             .BEG_POS.  THE BEG_POS VARIABLE IS A NUMBER INDICATING THE      */\n07000000    /*              STARTING POSITION WITHIN THE LISTING LINE AT WHICH             */\n07010000    /*              COMPARISON IS TO BE PERFORMED OR SCANNING IS TO BEGIN.  THIS   */\n07020000    /*              NUMBER IS ASSIGNED EXCLUSIVE OF THE PRINT CONTROL CHARACTER,   */\n07030000    /*              WITH THE LEFTMOST PRINTED CHARACTER BEING 001.  THE DEFAULT    */\n07040000    /*              VALUE DEPENDS ON THE TYPE OF OPERATION (SEE \"OP\") AS           */\n07050000    /*              FOLLOWS:                                                       */\n07060000    /*                                                                             */\n07070000    /*                -ENTRY TYPE COMPARE:   IGNORED IF PROVIDED.  NOT USED.       */\n07080000    /*                                                                             */\n07090000    /*                -LINE  TYPE COMPARE:   IGNORED IF PROVIDED.  SET TO 011.     */\n07100000    /*                                                                             */\n07110000    /*                -LINE  DATA COMPARE:   029.                                  */\n07120000    /*                                                                             */\n07130000    /*                -LINE  DATA    SCAN:   029.                                  */\n07140000    /*                                                                             */\n07150000    /*              BEG_POS CAN DESIGNATE ANY POSITION ON THE LINE: 001 - 120,     */\n07160000    /*              BUT SHOULD BE LESS THAN OR EQUAL IN VALUE TO END_POS.          */\n07170000    /*                                                                             */\n07180000    /*             .END_POS.  THE END_POS VARIABLE IS A NUMBER INDICATING THE      */\n07190000    /*              ENDING POSITION WITHIN THE LISTING LINE AT WHICH COMPARISON    */\n07200000    /*              IS TO BE PERFORMED OR SCANNING IS TO BEGIN.  THIS NUMBER IS    */\n07210000    /*              ASSIGNED EXCLUSIVE OF THE PRINT CONTROL CHARACTER, WITH THE    */\n07220000    /*              LEFTMOST PRINTED CHARACTER BEING 001.  THE DEFAULT VALUE       */\n07230000    /*              DEPENDS ON THE TYPE OF OPERATION (SEE \"OP\") AS FOLLOWS:        */\n07240000    /*                                                                             */\n07250000    /*                -ENTRY TYPE COMPARE:   IGNORED IF PROVIDED. NOT USED.        */\n07260000    /*                                                                             */\n07270000    /*                -LINE  TYPE COMPARE:   IGNORED IF PROVIDED.  SET TO          */\n07280000    /*                                       BEG_POS+STR_LEN-1 OR 025,             */\n07290000    /*                                       WHICHEVER IS LESS.                    */\n07300000    /*                                                                             */\n07310000    /*                -LINE  DATA COMPARE:   BEG_POS+STR_LEN-1 OR 120,             */\n07320000    /*                                       WHICHEVER IS LESS.                    */\n07330000    /*                                                                             */\n07340000    /*                -LINE  DATA    SCAN:   120.                                  */\n07350000    /*                                                                             */\n07360000    /*              END_POS CAN DESIGNATE ANY POSITION ON THE LINE: 001 - 120,     */\n07370000    /*              BUT SHOULD BE GREATER THAN OR EQUAL IN VALUE TO BEG_POS.       */\n07380000    /*                                                                             */\n07390000    /*             .POS_LEN.  THE POS_LEN VARIABLE IS A NUMBER INDICATING THE      */\n07400000    /*              NUMBER OF PRINT POSTITONS BETWEEN BEG_POS AND END_POS.         */\n07410000    /*              POS_LEN CAN BE SPECIFIED IN LIEU OF END_POS, BUT IT IS         */\n07420000    /*              USUALLY ALLOWED TO DEFAULT.  IF POS_LEN IS PROVIDED RATHER     */\n07430000    /*              THAN END_POS, END_POS IS CALCULATED.  THE CALCULATED VALUE     */\n07440000    /*              FOR POS_LEN DEPENDS ON THE TYPE OF OPERATION (SEE \"OP\") AS     */\n07450000    /*              FOLLOWS:                                                       */\n07460000    /*                                                                             */\n07470000    /*                -ENTRY TYPE COMPARE:   IGNORED IF PROVIDED. NOT USED.        */\n07480000    /*                                                                             */\n07490000    /*                -LINE  TYPE COMPARE:   IGNORED IF PROVIDED.  SET TO          */\n07500000    /*                                       END_POS-BEG_POS+1 OR 015,             */\n07510000    /*                                       WHICHEVER IS LESS.                    */\n07520000    /*                                                                             */\n07530000    /*                -LINE  DATA COMPARE:   END_POS-BEG_POS+1 OR STR_LEN,         */\n07540000    /*                                       WHICHEVER IS LESS.                    */\n07550000    /*                                                                             */\n07560000    /*                -LINE  DATA    SCAN:   END_POS-BEG_POS+1 OR 120,             */\n07570000    /*                                       WHICHEVER IS LESS.                    */\n07580000    /*                                                                             */\n07590000    /*              POS_LEN IS RECALCULATED AFTER THE FINAL VALUES FOR             */\n07600000    /*              BEG_POS AND END_POS HAVE BEEN DETERMINED.                      */\n07610000    /*                                                                             */\n07620000    /*             .OP.  THIS VARIABLE GOVERNS HOW THE \"STRING\" IS COMPARED WITH   */\n07630000    /*              THE ENTRY'S LISTING LINE WITHIN THE BOUNDS DEFINED BY          */\n07640000    /*              BEG_POS AND END_POS.  IN EACH GROUP OF COMPARE/SCAN            */\n07650000    /*              OPERATIONS, SEVERAL COMPARISON OPERATORS ARE DEFINED.  FOR     */\n07660000    /*              THREE OF THE FOUR, GENERIC COMPARISONS CAN ALSO BE             */\n07670000    /*              PERFORMED.  THE OPERATIONS SUPPORTED WITHIN EACH GROUP ARE     */\n07680000    /*              AS FOLLOWS:                                                    */\n07690000    /*                                                                             */\n07700000    /*                -ENTRY TYPE COMPARE:                                         */\n07710000    /*                            EQENTRY:   THE ENTRY TYPE MUST BE THE SAME AS    */\n07720000    /*                                       THAT SPECIFIED IN \"STRING\".           */\n07730000    /*                            NEENTRY:   THE ENTRY TYPE MUST NOT BE THE SAME   */\n07740000    /*                                       AS THAT SPECIFIED IN \"STRING\".        */\n07750000    /*                   EQENTRY SYNONYMS:   EQNTRY,     EQN.                      */\n07760000    /*                   NEENTRY SYNONYMS:   NENTRY,     NEN,                      */\n07770000    /*                                      \u00acEQENTRY,   \u00acEQNTRY,  \u00acEQN.            */\n07780000    /*                                                                             */\n07790000    /*                -LINE  TYPE COMPARE:                                         */\n07800000    /*                             EQLINE:   THE LINE TYPE, FOR THE NUMBER OF      */\n07810000    /*                                       CHARACTERS IN \"STRING\" (I.E., A       */\n07820000    /*                                       PREFIX COMPARISON IS DONE) MUST BE    */\n07830000    /*                                       THE SAME AS THAT SPECIFIED IN         */\n07840000    /*                                       \"STRING\".                             */\n07850000    /*                             NELINE:   THE LINE TYPE, FOR THE NUMBER OF      */\n07860000    /*                                       CHARACTERS IN \"STRING\" (I.E., A       */\n07870000    /*                                       PREFIX COMPARISON IS DONE) MUST NOT   */\n07880000    /*                                       BE THE SAME AS THAT SPECIFIED IN      */\n07890000    /*                                       \"STRING\".                             */\n07900000    /*                            EQGLINE:   THE LINE TYPE, FOR THE NUMBER OF      */\n07910000    /*                                       CHARACTERS IN \"STRING\" (I.E., A       */\n07920000    /*                                       PREFIX COMPARISON IS DONE) MUST       */\n07930000    /*                                       GENERICALLY COMPARE EQUAL TO THE      */\n07940000    /*                                       VALUE SPECIFIED IN \"STRING\".          */\n07950000    /*                            NEGLINE:   THE LINE TYPE, FOR THE NUMBER OF      */\n07960000    /*                                       CHARACTERS IN \"STRING\" (I.E., A       */\n07970000    /*                                       PREFIX COMPARISON IS DONE) MUST       */\n07980000    /*                                       GENERICALLY COMPARE NOT EQUAL TO      */\n07990000    /*                                       THE VALUE SPECIFIED IN \"STRING\".      */\n08000000    /*                    EQLINE SYNONYMS:    EQLIN,    EQL.                       */\n08010000    /*                    NELINE SYNONYMS:    NELIN,    NEL,                       */\n08020000    /*                                       \u00acEQLINE,  \u00acEQLIN,    \u00acEQL.            */\n08030000    /*                   EQGLINE SYNONYMS:    EQGLIN,   EQGL.                      */\n08040000    /*                   NEGLINE SYNONYMS:    NEGLIN,   NEGL,                      */\n08050000    /*                                       \u00acEQGLINE, \u00acEQGLIN,   \u00acEQGL.           */\n08060000    /*                                                                             */\n08070000    /*                -LINE  DATA COMPARE:                                         */\n08080000    /*                             LTCMPR:   THE CHARACTER STRING IN THE ENTRY     */\n08090000    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */\n08100000    /*                                       LESS THAN THE VALUE  SPECIFIED IN     */\n08110000    /*                                       \"STRING\".                             */\n08120000    /*                             LECMPR:   THE CHARACTER STRING IN THE ENTRY     */\n08130000    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */\n08140000    /*                                       LESS THAN OR EQUAL TO THE VALUE       */\n08150000    /*                                       SPECIFIED IN \"STRING\".                */\n08160000    /*                             EQCMPR:   THE CHARACTER STRING IN THE ENTRY     */\n08170000    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */\n08180000    /*                                       EQUAL TO THE VALUE SPECIFIED IN       */\n08190000    /*                                       \"STRING\".                             */\n08200000    /*                             NECMPR:   THE CHARACTER STRING IN THE ENTRY     */\n08210000    /*                                       LINE, STARTING AT BEG_POS, MUST NOT   */\n08220000    /*                                       BE EQUAL TO THE VALUE SPECIFIED IN    */\n08230000    /*                                       \"STRING\".                             */\n08240000    /*                             GECMPR:   THE CHARACTER STRING IN THE ENTRY     */\n08250000    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */\n08260000    /*                                       GREATER THAN OR EQUAL TO THE VALUE    */\n08270000    /*                                       SPECIFIED IN \"STRING\".                */\n08280000    /*                             GTCMPR:   THE CHARACTER STRING IN THE ENTRY     */\n08290000    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */\n08300000    /*                                       GREATER THAN THE VALUE SPECIFIED IN   */\n08310000    /*                                       \"STRING\".                             */\n08320000    /*                            EQGCMPR:   THE CHARACTER STRING IN THE ENTRY     */\n08330000    /*                                       LINE, STARTING AT BEG_POS, MUST       */\n08340000    /*                                       GENERICALLY COMPARE EQUAL TO THE      */\n08350000    /*                                       VALUE SPECIFIED IN \"STRING\".          */\n08360000    /*                            NEGCMPR:   THE CHARACTER STRING IN THE ENTRY     */\n08370000    /*                                       LINE, STARTING AT BEG_POS, MUST       */\n08380000    /*                                       GENERICALLY COMPARE NOT EQUAL TO      */\n08390000    /*                                       THE VALUE SPECIFIED IN \"STRING\".      */\n08400000    /*                    LTCMPR SYNONYMS:   LTCPR,    LTC,      LT,               */\n08410000    /*                                      \u00acGECMPR,  \u00acGECPR,   \u00acGEC,    \u00acGE.      */\n08420000    /*                    LECMPR SYNONYMS:   LECPR,    LEC,      LE,               */\n08430000    /*                                      \u00acGTCMPR,  \u00acGTCPR,   \u00acGTC,    \u00acGT.      */\n08440000    /*                    EQCMPR SYNONYMS:   EQCPR,    EQC,      EQ.               */\n08450000    /*                    NECMPR SYNONYMS:   NECPR,    NEC,      NE,               */\n08460000    /*                                      \u00acEQCMPR,  \u00acEQCPR,   \u00acEQC,    \u00acEQ.      */\n08470000    /*                    GECMPR SYNONYMS:   GECPR,    GEC,      GE,               */\n08480000    /*                                      \u00acLTCMPR,  \u00acLTCPR,   \u00acLTC,    \u00acLT.      */\n08490000    /*                    GTCMPR SYNONYMS:   GTCPR,    GTC,      GT,               */\n08500000    /*                                      \u00acLECMPR,  \u00acLECPR,   \u00acLEC,    \u00acLE.      */\n08510000    /*                   EQGCMPR SYNONYMS:   EQGCPR,   EQGC,     EQG.              */\n08520000    /*                   NEGCMPR SYNONYMS:   NEGCPR,   NEGC,     NEG,              */\n08530000    /*                                      \u00acEQGCPR,  \u00acEQGC,     \u00acEQG.             */\n08540000    /*                                                                             */\n08550000    /*                -LINE  DATA    SCAN:                                         */\n08560000    /*                             EQSCAN:   THE CHARACTERS IN THE ENTRY LINE      */\n08570000    /*                                       BETWEEN BEG_POS AND END_POS MUST      */\n08580000    /*                                       CONTAIN AT LEAST ONE SUBSTRING        */\n08590000    /*                                       EQUAL TO THE VALUE SPECIFIED IN       */\n08600000    /*                                       \"STRING\".  SUBSTRINGS ARE EXAMINED    */\n08610000    /*                                       STARTING AT BEG_POS AND STOPPING AT   */\n08620000    /*                                       (END_POS-STR_LEN+1).                  */\n08630000    /*                             NESCAN:   THE CHARACTERS IN THE ENTRY LINE      */\n08640000    /*                                       BETWEEN BEG_POS AND END_POS MUST      */\n08650000    /*                                       NOT CONTAIN ANY SUBSTRING EQUAL TO    */\n08660000    /*                                       THE VALUE SPECIFIED IN \"STRING\".      */\n08670000    /*                                       SUBSTRINGS ARE EXAMINED STARTING AT   */\n08680000    /*                                       BEG_POS AND STOPPING AT               */\n08690000    /*                                       (END_POS-STR_LEN+1).                  */\n08700000    /*                            EQGSCAN:   THE CHARACTERS IN THE ENTRY LINE      */\n08710000    /*                                       BETWEEN BEG_POS AND END_POS MUST      */\n08720000    /*                                       CONTAIN AT LEAST ONE SUBSTRING        */\n08730000    /*                                       GENERICALLY EQUAL TO THE VALUE        */\n08740000    /*                                       SPECIFIED IN \"STRING\".  SUBSTRINGS    */\n08750000    /*                                       ARE EXAMINED STARTING AT BEG_POS      */\n08760000    /*                                       AND STOPPING AT                       */\n08770000    /*                                       (END_POS-STR_LEN+1).                  */\n08780000    /*                            NEGSCAN:   THE CHARACTERS IN THE ENTRY LINE      */\n08790000    /*                                       BETWEEN BEG_POS AND END_POS MUST      */\n08800000    /*                                       NOT CONTAIN ANY SUBSTRING             */\n08810000    /*                                       GENERICALLY EQUAL TO THE VALUE        */\n08820000    /*                                       SPECIFIED IN \"STRING\".  SUBSTRINGS    */\n08830000    /*                                       ARE EXAMINED STARTING AT BEG_POS      */\n08840000    /*                                       AND STOPPING AT                       */\n08850000    /*                                       (END_POS-STR_LEN+1).                  */\n08860000    /*                    EQSCAN SYNONYMS:    EQSCN,    EQS.                       */\n08870000    /*                    NESCAN SYNONYMS:    NESCN,    NES,                       */\n08880000    /*                                       \u00acEQSCAN,  \u00acEQSCN,     \u00acEQS.           */\n08890000    /*                   EQGSCAN SYNONYMS:    EQGSCN,   EQGS.                      */\n08900000    /*                   NEGSCAN SYNONYMS:    NEGSCN,   NEGS,                      */\n08910000    /*                                       \u00acEQGSCAN, \u00acEQGSCN,    \u00acEQGS.          */\n08920000    /*                                                                             */\n08930000    /*              THE DEFAULT SPECIFICATION FOR \"OP\" IS \"EQSCAN\".                */\n08940000    /*                                                                             */\n08950000    /*             .STRING.  THIS IS THE CHARACTER STRING DATA WHOSE PRESENCE OR   */\n08960000    /*              ABSENCE IS BEING SOUGHT.  IT CAN HAVE A MAXIMUM LENGTH OF 32   */\n08970000    /*              BYTES.  A SCAN_ARRAY ELEMENT IS CONSIDERED ACTIVE ONLY IF A    */\n08980000    /*              CHARACTER STRING VALUE OF LENGTH GREATER THAN ZERO HAS BEEN    */\n08990000    /*              SPECIFIED (THE STRING CAN BE BLANK).  THE DATA PROVIDED FOR    */\n09000000    /*              \"STRING\" WILL DEPEND ON THE TYPE OF OPERATION (SEE \"OP\") AS    */\n09010000    /*              FOLLOWS:                                                       */\n09020000    /*                                                                             */\n09030000    /*                -ENTRY TYPE COMPARE:   NAMES A TYPE OF ENTRY (E.G.,          */\n09040000    /*                                       \"DDDEF\", \"ASSEM\", \"LMOD\", \"MOD\",      */\n09050000    /*                                       \"SYSMOD\").  A FULL LIST OF VALUES     */\n09060000    /*                                       APPEARS BELOW IN THE DESCRIPTION OF   */\n09070000    /*                                       \"TYPE\" FOR MATCH_ARRAY.  WITHIN       */\n09080000    /*                                       REASON, ABBREVIATIONS ARE             */\n09090000    /*                                       SUPPORTED.  TO REDUCE EXECUTION       */\n09100000    /*                                       OVERHEAD, THE ENTRY TYPE NAME IS      */\n09110000    /*                                       CONVERTED TO AN INTERNAL INDEX        */\n09120000    /*                                       VALUE (AND SAVED IN STR_NIX).  THE    */\n09130000    /*                                       INDEX VALUE IS USED FOR THE ACTUAL    */\n09140000    /*                                       TEST AGAINST THE LINE.                */\n09150000    /*                                                                             */\n09160000    /*                -LINE  TYPE COMPARE:   IDENTIFIES A TYPE OF LISTING LINE.    */\n09170000    /*                                       THE BEST WAY TO DETERMINE VALUES TO   */\n09180000    /*                                       USE IS TO EXAMINE AN ACTUAL SMP/E     */\n09190000    /*                                       LIST OUTPUT.                          */\n09200000    /*                                                                             */\n09210000    /*                -LINE  DATA COMPARE:   THE COMPARE ARGUMENT STRING FOR       */\n09220000    /*                                       REGULAR COMPARE OPERATIONS, OR THE    */\n09230000    /*                                       PATTERN STRING FOR GENERIC            */\n09240000    /*                                       COMPARES.                             */\n09250000    /*                                                                             */\n09260000    /*                -LINE  DATA    SCAN:   THE SCAN ARGUMENT STRING OR THE       */\n09270000    /*                                       PATTERN STRING, DEPENDING ON          */\n09280000    /*                                       WHETHER THE SCAN OPERATION IS OF      */\n09290000    /*                                       THE NORMAL VARIETY, OR GENERIC.       */\n09300000    /*                                                                             */\n09310000    /*              \"STRING\" HAS NO DEFAULT.  IF A STRING VALUE IS NOT PROVIDED,   */\n09320000    /*              THE SCAN_ARRAY COLUMN SUBSTRUCTURE IS NOT USED DURING ENTRY    */\n09330000    /*              PROCESSING.  IF A VALUE IS PROVIDED, ITS LENGTH DETERMINED     */\n09340000    /*              AND THEN SAVED IS SCAN_ARRAY VARIABLE STR_LEN.                 */\n09350000    /*                                                                             */\n09360000    /*            THE DISTINCTION BETWEEN THE \"NE\" COLUMN OPERATIONS AND A ROW     */\n09370000    /*      LEVEL SELECT_OPTION OF \"EXCLUDE\" NEEDS TO BE CLARIFIED.  COLUMN        */\n09380000    /*      OPERATIONS ARE USED TO TEST WHETHER A CONDITION OCCURS OR DOESN'T      */\n09390000    /*      OCCUR ON A GIVEN LINE.  ONCE A ROW TEST HAS BEEN SATISFIED FOR ANY     */\n09400000    /*      LINE OF AN ENTRY, HOWEVER, THE TEST IS SATISFIED FOR THE ENTRY.        */\n09410000    /*      CONSEQUENTLY, AN \"NE\" OPERATION MAY NOT RESULT IN ALL PERTINENT        */\n09420000    /*      LINES BEING TESTED.  TO VERIFY THAT A PARTICULAR VALUE DOES NOT        */\n09430000    /*      APPEAR ON ANY ENTRY LINE (I.E., THAT ALL PERTINENT LINES FAIL THE      */\n09440000    /*      TEST), USE A POSITIVE TEST SUCH AS \"EQ\" COMBINED WITH A ROW            */\n09450000    /*      SELECT_OPTION OF \"EXCLUDE\".  NEGATIVELY-EXPRESSED OPERATIONS ARE       */\n09460000    /*      GENERALLY USED IN COMBINATION WITH OTHER TESTS, OR WHEN THE DATA OF    */\n09470000    /*      INTEREST APPEAR ON ONLY ONE LISTING LINE.                              */\n09480000    /*                                                                             */\n09490000    /*            WHILE GENERIC SEARCH AND COMPARE FACILITIES ARE AVAILABLE IN A   */\n09500000    /*      VARIETY OF PROGRAMS AND PRODUCTS, THE GENERIC OPERATIONS PROVIDED IN   */\n09510000    /*      THE SCAN_ARRAY ARE MOST SIMILAR TO THE PICTURE STRING FEATURE OF THE   */\n09520000    /*      ISPF BROWSE AND EDIT COMMANDS.  A NOTE FOR THE LAWYERS - ISPF IS A     */\n09530000    /*      PROGRAM PRODUCT OF IBM.  WHEN GENERIC COMPARISON OR GENERIC SCANNING   */\n09540000    /*      IS REQUESTED, THE SCAN_ARRAY SEARCH STRING IS TREATED AS A MASK OR     */\n09550000    /*      PATTERN.  THE CHARACTER STRING FROM THE LISTING LINE BEING EXAMINED    */\n09560000    /*      IS COMPARED CHARACTER BY CHARACTER WITH THE PATTERN STRING FROM        */\n09570000    /*      SCAN_ARRAY, PROCESSING FROM LEFT TO RIGHT.  THE FIRST CHARACTER        */\n09580000    /*      STRING CHARACTER NOT SATISFYING THE REQUIREMENTS OF ITS PATTERN        */\n09590000    /*      STRING CHARACTER STOPS THE COMPARE AND GIVES A NOT-EQUAL RESULT.       */\n09600000    /*      WHEN ALL CORRESPONDING CHARACTERS ARE EQUAL, A CHARACTER STRING        */\n09610000    /*      LONGER THAN THE PATTERN STRING IS CHECKED TO VERIFY THAT BYTES         */\n09620000    /*      EXTENDING ON THE RIGHT BEYOND THE LENGTH OF THE PATTERN STRING ARE     */\n09630000    /*      BLANK.  LIKEWISE, A PATTERN STRING LONGER THAN THE CHARACTER STRING    */\n09640000    /*      IS ALSO CHECKED TO VERIFY THAT ALL BYTES EXTENDING ON THE RIGHT        */\n09650000    /*      BEYOND THE LENGTH OF THE CHARACTER STRING ARE EITHER BLANK, OR THE     */\n09660000    /*      \"ANY\" SELECTION BYTE(\"*\").                                             */\n09670000    /*                                                                             */\n09680000    /*            A GENERIC COMPARISON PATTERN CHARACTER REPRESENTS EITHER A       */\n09690000    /*      GROUP OF CHARACTERS, OR ITSELF.  BECAUSE CHARACTERS WITHIN A GROUP     */\n09700000    /*      WILL NOT, IN GENERAL, BE CONSECUTIVE WITHOUT GAPS IN THE COLLATING     */\n09710000    /*      SEQUENCE, A GENERIC COMPARISON ORDER IN TERMS OF HIGH, LOW, AND        */\n09720000    /*      EQUAL CANNOT BE DEFINED.  THE BEST THAT CAN BE DETERMINED IS EQUAL     */\n09730000    /*      OR NOT EQUAL.  THE FOLLOWING CHARACTERS HAVE SPECIAL SIGNIFICANCE IN   */\n09740000    /*      PATTERN STRINGS, AND ARE USED TO SELECT GROUPS OF CHARACTERS:          */\n09750000    /*                                                                             */\n09760000    /*            \"*\" - THE CORRESPONDING CHARACTER STRING CHARACTER CAN BE        */\n09770000    /*                  ANY CHARACTER.                                             */\n09780000    /*                                                                             */\n09790000    /*            \"#\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n09800000    /*                  NUMERIC AND CAN BE EITHER UPPER OR LOWER CASE.             */\n09810000    /*                                                                             */\n09820000    /*            \"@\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n09830000    /*                  ALPHABETIC AND CAN BE EITHER UPPER OR LOWER CASE.          */\n09840000    /*                                                                             */\n09850000    /*            \"\u00a2\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n09860000    /*                  ONE OF THE NATIONAL CHARACTERS: \"$\", \"#\", OR \"@\".          */\n09870000    /*                  BECAUSE OF THEIR BIT REPRESENTATIONS, NATIONAL             */\n09880000    /*                  CHARACTERS ARE UPPERCASE.                                  */\n09890000    /*                                                                             */\n09900000    /*            \"%\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n09910000    /*                  ALPHABETIC OR ONE OF THE NATIONAL CHARACTERS.              */\n09920000    /*                                                                             */\n09930000    /*            \"_\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n09940000    /*                  ALPHABETIC, NUMERIC,  OR ONE OF THE NATIONAL CHARACTERS.   */\n09950000    /*                                                                             */\n09960000    /*            \">\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n09970000    /*                  ONE OF THE NATIONAL CHARACTERS, OR AN UPPERCASE            */\n09980000    /*                  ALPHABETIC OR NUMERIC CHARACTER.                           */\n09990000    /*                                                                             */\n10000000    /*            \"<\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n10010000    /*                  A LOWERCASE ALPHABETIC OR NUMERIC CHARACTER.               */\n10020000    /*                                                                             */\n10030000    /*            \"!\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n10040000    /*                  ONE OF THE SPECIAL CHARACTERS.                             */\n10050000    /*                                                                             */\n10060000    /*            \"-\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n10070000    /*                  NON-NUMERIC.                                               */\n10080000    /*                                                                             */\n10090000    /*            \"\u00ac\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n10100000    /*                  NON-BLANK.                                                 */\n10110000    /*                                                                             */\n10120000    /*            \"?\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n10130000    /*                  ONE OF THE INVALID CHARACTERS.                             */\n10140000    /*                                                                             */\n10150000    /*      ALL OTHER CHARACTERS IN A PATTERN STRING (BLANKS, ALPHABETICS,         */\n10160000    /*      NUMERIC DIGITS, AND ESPECIALLY THE CHARACTERS \"=\" \".\" \",\" \":\" \"$\"      */\n10170000    /*      \"(\" AND \")\" REPRESENT THEMSELVES.  WHEN A PATTERN STRING CHARACTER     */\n10180000    /*      REPRESENTS ITSELF, THE CHARACTER STRING CHARACTER MUST BE THE SAME     */\n10190000    /*      AS THE PATTERN CHARACTER.  FOR EXAMPLE, IN THE PATTERN STRING          */\n10200000    /*      \"%RM####\" USED TO SEARCH FOR RMF FMID'S, THE CHARACTERS \"R\" AND \"M\"    */\n10210000    /*      REPRESENT THEMSELVES.  EVERY ATTEMPT WAS MADE TO CHOOSE GENERIC        */\n10220000    /*      SELECTION CHARACTERS THAT WOULD BE UNLIKELY TO APPEAR IN THE DATA      */\n10230000    /*      EXCEPT WHERE TRADITION STRONGLY DICTATED OTHERWISE (E.G., THE CHOICE   */\n10240000    /*      OF \"#\" TO SELECT NUMERIC CHARACTERS).                                  */\n10250000    /*                                                                             */\n10260000    /*            >>>>>MATCH_ARRAY.<<<<<                                           */\n10270000    /*            MATCH_ARRAY PROVIDES SMPSCAN WITH THE INFORMATION IT NEEDS TO    */\n10280000    /*      DETERMINE WHICH ENTRIES SHOULD BE WRITTEN TO OUTPUT DATA SETS.  THE    */\n10290000    /*      MATCH_ARRAY CONTENTS SPECIFY ENTRY MATCH CRITERIA WHICH CAN APPLY TO   */\n10300000    /*      A SINGLE INPUT LISTING, OR TO MULTIPLE LISTINGS (CROSS-ZONES)          */\n10310000    /*      CONCURRENTLY.  MATCH CRITERIA ARE BASED ON A COMBINATION OF ENTRY      */\n10320000    /*      TYPE (SYSMOD, MAC, MOD, LMOD, OR WHATEVER), ON THE PRESENCE OR         */\n10330000    /*      ABSENCE OF AN ENTRY IN A PARTICULAR INPUT LISTING, AND ON AN ENTRY'S   */\n10340000    /*      SCAN_RESULT IF SCAN_ARRAY VARIABLES WERE PROVIDED FOR THAT FILE.       */\n10350000    /*      THE OUTPUT DECISION IS BASED ON WHETHER THE MATCH CRITERIA WERE        */\n10360000    /*      SATISFIED AND, IF SCAN RESULTS ARE DEEMED RELEVANT, ON WHETHER SCAN    */\n10370000    /*      RESULTS WERE POSITIVE.                                                 */\n10380000    /*                                                                             */\n10390000    /*            MATCH_ARRAY IS DECLARED AS A TWO DIMENSIONAL ARRAY OF            */\n10400000    /*      STRUCTURES.  THE FIRST SUBSCRIPT IS THE MATCH_ARRAY ENTRY NUMBER AND   */\n10410000    /*      THE SECOND, WHEN REQUIRED, IS THE FILE NUMBER.  THE STRUCTURAL         */\n10420000    /*      DECLARATION OF MATCH_ARRAY IS:                                         */\n10430000    /*                                                                             */\n10440000    /*            01 MATCH_ARRAY                          CONTROLLED,              */\n10450000    /*               05 ENTRY(IMATCH_MIN:IMATCH_MAX),                              */\n10460000    /*                  09 TYPE                           CHAR(016) VARYING,       */\n10470000    /*                  09 COMPARE_TEST                   CHAR(008) VARYING,       */\n10480000    /*                  09 FILE(IFILE_MIN:IFILE_MAX),                              */\n10490000    /*                     13 COMPARE_OPTION              CHAR(012) VARYING,       */\n10500000    /*                     13 COMPARE_SELECT              CHAR(012) VARYING,       */\n10510000    /*                     13 WRITE_OPTION                CHAR(012) VARYING,       */\n10520000    /*                     13 WRITE_SELECT                CHAR(012) VARYING,       */\n10530000    /*                                                                             */\n10540000    /*            AS ENTRIES ARE READ, SMPSCAN FORMS A COMPARE KEY FROM THE        */\n10550000    /*      ENTRY TYPE, AND ENTRY NAME WITHIN TYPE.  FOR COMPARE KEY PURPOSES      */\n10560000    /*      THE ENTRY TYPE IS CONVERTED TO A TWO DIGIT INDEX WHOSE VALUES ARE IN   */\n10570000    /*      THE SAME ORDER AS ENTRY TYPES APPEAR IN SMP/E LISTINGS.  THIS IS THE   */\n10580000    /*      SAME INDEX VALUE MENTIONED IN REGARD TO ENTRY TYPE COMPARE             */\n10590000    /*      OPERATIONS IN THE DESCRIPTION OF THE SCAN_ARRAY \"STRING\" VARIABLE      */\n10600000    /*      ABOVE.  THE COMPARE KEY IS USED TO SYNCHRONIZE THE PROCESSING OF       */\n10610000    /*      MULTIPLE LISTING INPUTS BECAUSE IT DEFINES AN ORDER FOR THE INPUT      */\n10620000    /*      AND ALLOWS ENTRIES WITH THE SAME NAME TO BE IDENTIFIED ACROSS ZONES.   */\n10630000    /*      THIS KEY TECHNIQUE WORKS BECAUSE SMP/E LISTS ENTRIES WITHIN TYPE IN    */\n10640000    /*      ASCENDING ORDER BY NAME, AND ENTRY TYPES ALWAYS APPEAR IN THE SAME     */\n10650000    /*      ORDER IN OUTPUT LISTINGS.  THIS CONSISTENCY PROBABLY REFLECTS          */\n10660000    /*      SMP/E'S ZONE KEY CONSTRUCTION TECHNIQUE.                               */\n10670000    /*                                                                             */\n10680000    /*            ONCE THE FIRST ENTRY HAS BEEN READ FROM EACH ACTIVE INPUT        */\n10690000    /*      FILE, SMPSCAN CHECKS THE COMPARE KEYS, AND IDENTIFIES THOSE WITH THE   */\n10700000    /*      LOWEST COMPARE KEY.  THERE WILL ALWAYS BE AT LEAST ONE SUCH ENTRY,     */\n10710000    /*      AND THERE MAY SEVERAL IF THE ENTRY APPEARS IN MORE THAT ONE INPUT      */\n10720000    /*      LISTING.  THESE ENTRIES ARE THEN PROCESSED AS A GROUP.  PROCESSING     */\n10730000    /*      CONSISTS OF TESTING EACH ACTIVE ENTRY OF MATCH_ARRAY TO SEE IF THIS    */\n10740000    /*      GROUP OF ENTRIES IS A \"MATCH\", AND THEN APPLYING EACH \"MATCHING\"       */\n10750000    /*      ARRAY ENTRY'S OUTPUT INSTRUCTIONS TO EACH GROUP MEMBER.  A \"MATCH\"     */\n10760000    /*      IS DEFINED IN TERMS OF THE VARIABLES TYPE, COMPARE_TEST,               */\n10770000    /*      COMPARE_OPTION, AND COMPARE_SELECT:                                    */\n10780000    /*                                                                             */\n10790000    /*            1. MATCH_ARRAY TYPE MUST BE \"ALL\", OR MUST BE THE SAME AS THE    */\n10800000    /*               ENTRY TYPE FOR THE GROUP (ENTRIES OF DIFFERENT TYPES WILL     */\n10810000    /*               NOT BE IN THE SAME GROUP).                                    */\n10820000    /*                                                                             */\n10830000    /*            2. FOR EACH ACTIVE FILE, COMPARE_OPTION AND COMPARE_SELECT ARE   */\n10840000    /*               CHECKED AGAINST THE FILE'S CONTRIBUTION TO THE GROUP.  EACH   */\n10850000    /*               ACTIVE FILE EITHER HAS OR DOESN'T HAVE AN ENTRY IN THE        */\n10860000    /*               GROUP, AND EACH ENTRY IN THE GROUP HAS EITHER A POSITIVE      */\n10870000    /*               ('1'B) OR NEGATIVE ('0'B) SCAN_RESULT.  COMPARE_OPTION        */\n10880000    /*               INDICATES WHETHER THE FILE MUST OR MUST NOT HAVE AN ENTRY     */\n10890000    /*               IN THE GROUP, OR WHETHER MEMBERSHIP IN THE GROUP IS           */\n10900000    /*               OPTIONAL.  COMPARE_SELECT IS CHECKED IF AN ENTRY APPEARS IN   */\n10910000    /*               THE GROUP (WHETHER MANDATORY OR OPTIONAL).  AN ABSENT ENTRY   */\n10920000    /*               DOESN'T HAVE A SCAN_RESULT.  COMPARE_SELECT INDICATES         */\n10930000    /*               WHETHER AN ENTRY MUST HAVE A POSITIVE OR NEGATIVE             */\n10940000    /*               SCAN_RESULT, OR THE SCAN_RESULT IS TO BE DISREGARDED FOR      */\n10950000    /*               MATCHING PURPOSES (COMPARE_SELECT AND WRITE_SELECT ARE        */\n10960000    /*               INDEPENDENT OF EACH OTHER).                                   */\n10970000    /*                                                                             */\n10980000    /*            3. COMPARE_TEST AFFECTS THE WAY THE COMPARE_OPTION AND           */\n10990000    /*               COMPARE_SELECT TESTS ARE ASSESED TO DETERMINE A \"MATCH\".      */\n11000000    /*               IF COMPARE_TEST IS \"ALL\", THE COMPARE_OPTION/COMPARE_SELECT   */\n11010000    /*               TESTS MUST BE TRUE FOR ALL ACTIVE FILES.  IF COMPARE_TEST     */\n11020000    /*               IS \"ANY\", AT LEAST ONE OF THE COMPARE_OPTION/COMPARE_SELECT   */\n11030000    /*               TESTS MUST BE TRUE FOR AN ACTIVE FILE.                        */\n11040000    /*                                                                             */\n11050000    /*      IF A MATCH_ARRAY ENTRY'S COMPARE INSTRUCTION YIELD A \"MATCH\", THE      */\n11060000    /*      ARRAY ENTRY'S OUTPUT INSTRUCTIONS ARE APPLIED TO EACH ENTRY IN THE     */\n11070000    /*      GROUP.  AN ABSENT ENTRY CAN'T BE WRITTEN.  THE OUTPUT INSTRUCTIONS     */\n11080000    /*      ARE GIVEN BY THE VARIABLES WRITE_OPTION AND WRITE_SELECT:              */\n11090000    /*                                                                             */\n11100000    /*            1. FOR EACH ACTIVE FILE, WRITE_OPTION INDICATES WHETHER THE      */\n11110000    /*               ENTRY IS TO BE WRITTEN IF THE GROUP IS A \"MATCH\".             */\n11120000    /*               WRITE_OPTION IS INDEPENDENT OF COMPARE_OPTION, ESPECIALLY     */\n11130000    /*               WHEN COMPARE_TEST IS \"ANY\".  FOR EXAMPLE, FOR MULTIPLE        */\n11140000    /*               INPUTS, COMPARE_TEST='ANY' ALONG WITH                         */\n11150000    /*               COMPARE_OPTION='NOCOMPARE' AND WRITE_OPTION='WRITE' IS A      */\n11160000    /*               VALID COMBINATION.  THIS COMBINATION INSTRUCTS SMPSCAN TO     */\n11170000    /*               IDENTIFY AND WRITE THOSE GROUPS OF ENTRIES THAT DON'T         */\n11180000    /*               APPEAR IN ALL INPUT LISTINGS.                                 */\n11190000    /*                                                                             */\n11200000    /*            2. IF WRITE_OPTION IS \"WRITE\" AND AN ENTRY FROM THIS FILE        */\n11210000    /*               APPEARED IN THE GROUP, WRITE_SELECT INDICATES WHETHER THE     */\n11220000    /*               FILE ENTRY'S SCAN_RESULT HAS ANY BEARING ON THE OUTPUT        */\n11230000    /*               DECISION.  LIKE WRITE_OPTION, WRITE_SELECT IS INDEPENDENT     */\n11240000    /*               OF BOTH COMPARE_OPTION AND COMPARE_SELECT.  ONE ADVANTAGE     */\n11250000    /*               OF THIS INDEPENDENCE IS THAT ONE CAN \"MATCH\" OR IDENTIFY      */\n11260000    /*               ENTRIES INDEPENDENT OF SCAN RESULTS AND THEN WRITE A SUBSET   */\n11270000    /*               OF THE \"MATCHING\" ENTRIES BASED ON SCAN RESULTS.  A CAUTION   */\n11280000    /*               IS THAT IMPOSSIBLE COMBINATIONS PRODUCING NO OUTPUT CAN       */\n11290000    /*               ALSO BE DESCRIBED.                                            */\n11300000    /*                                                                             */\n11310000    /*      ONCE A MATCH_ARRAY ENTRY HAS PRODUCED A \"MATCH\", PROCESSING            */\n11320000    /*      CONTINUES.  THE FIRST ARRAY ENTRY YIELDING A MATCH DOES NOT            */\n11330000    /*      TERMINATE THE PROCESSING OF MATCH_ARRAY FOR THIS ENTRY GROUP.  AFTER   */\n11340000    /*      APPLYING OUTPUT INSTRUCTIONS, SMPSCAN GOES ON TO THE NEXT ACTIVE       */\n11350000    /*      MATCH_ARRAY ENTRY.  THIS ALLOWS THE OUTPUT FROM MULTIPLE CONDITIONS    */\n11360000    /*      TO BE MERGED IN A SINGLE EXECUTION (SMPSCAN HAS EXTRACT AND            */\n11370000    /*      MULTI-PASS CAPABILITIES).  \"MATCHED\" ARRAY ENTRY OUTPUT INSTRUCTIONS   */\n11380000    /*      ARE APPLIED ADDITIVELY.  ALTHOUGH THE WRITE_OPTION DEFAULT IS          */\n11390000    /*      \"WRITE\", AN ENTRY FROM THE GROUP WILL NOT BE WRITTEN UNLESS ITS        */\n11400000    /*      CORRESPONDING WRITE_OPTION FROM A \"MATCHED\" ARRAY ENTRY SPECIFIES      */\n11410000    /*      \"WRITE\".  FURTHER, AN ENTRY WILL BE WRITTEN IF ANY \"MATCHED\" ARRAY     */\n11420000    /*      ENTRY SPECIFIES \"WRITE\".  \"NOWRITE\" DOES NOT OVERRIDE \"WRITE\".         */\n11430000    /*                                                                             */\n11440000    /*            AFTER THE ABOVE PROCESSING HAS COMPLETED FOR THE FIRST SET       */\n11450000    /*      ENTRIES READ FROM EACH ACTIVE FILE, THE NEXT ENTRY IS READ FROM EACH   */\n11460000    /*      ACTIVE INPUT FILE THAT HAD AN ENTRY IN THE GROUP, AND THE MATCHING     */\n11470000    /*      PROCESS IS REPEATED, STARTING WITH THE IDENTIFICATION OF A NEW GROUP   */\n11480000    /*      OF LOW-KEY ENTRIES.  READING, SCANNING, AND MATCHING OF ENTRIES        */\n11490000    /*      CONTINUES UNTIL THE ENTRIES FROM ALL INPUT FILES HAVE BEEN READ.       */\n11500000    /*      LINES ARE SCANNED AS ENTRIES ARE READ, SO THAT THE SCAN_RESULT IS      */\n11510000    /*      AVAILABLE WHEN THE THE NEXT LOW-KEY GROUP IS IDENTIFIED.               */\n11520000    /*                                                                             */\n11530000    /*            MATCH_ARRAY VARIABLES ARE SUPPLIED IN THE \"SYSIN\" DATA STREAM,   */\n11540000    /*      AND ARE DOCUMENTED IN THE INPUT SECTION ABOVE.  IF USED, THEY SHOULD   */\n11550000    /*      BE SPECIFIED WITH THE REQUIRED LEVELS OF QUALIFICATION AND             */\n11560000    /*      SUBSCRIPTS AS SHOWN THERE.  UNLIKE SCAN_ARRAY, MATCH_ARRAY             */\n11570000    /*      (CURRENTLY) DOES NOT CONTAIN SMPSCAN-CALCULATED VARIABLES.  ALL        */\n11580000    /*      MATCH_ARRAY VARIABLES CAN BE SPECIFIED BY THE USER.  THE VARIABLES,    */\n11590000    /*      ALONG WITH THEIR DEFAULTS ARE:                                         */\n11600000    /*                                                                             */\n11610000    /*             .TYPE.  THIS VARIABLE SPECIFIES THE SMP/E ENTRY TYPE TO WHICH   */\n11620000    /*              THE MATCH_ARRAY ENTRY APPLIES.  IT CAN REFERENCE A SPECIFIC    */\n11630000    /*              ENTRY TYPE (LIKE THE SCAN_ARRAY STRING VALUE FOR ENTRY TYPE    */\n11640000    /*              OPERATIONS).  THE SPECIAL VALUES \"NONE\" AND \"ALL\" ARE ALSO     */\n11650000    /*              RECOGNIZED.  \"ALL\" INDICATES THAT THE MATCH_ARRAY ENTRY        */\n11660000    /*              APPLIES TO ALL ENTRY TYPES, AND \"NONE\" THAT THE ENTRY IS       */\n11670000    /*              INACTIVE.  FOR SOME ENTRY TYPES, REASONABLE ABBREVIATIONS      */\n11680000    /*              ARE SUPPORTED.  A FULL LIST OF THE CURRENTLY SUPPORTED ENTRY   */\n11690000    /*              TYPES IN ORDER OF APPEARANCE IN LISTINGS IS:                   */\n11700000    /*                                                                             */\n11710000    /*                 'ZONE'                                                      */\n11720000    /*                 'OPTIONS'                                                   */\n11730000    /*                 'UTILITY'                                                   */\n11740000    /*                 'FMIDSET'                                                   */\n11750000    /*                 'DDDEF'                                                     */\n11760000    /*                 'ZONESET'                                                   */\n11770000    /*                 'ASSEMBLER'                                                 */\n11780000    /*                 'LOAD MODULE'                                               */\n11790000    /*                 'MACRO'                                                     */\n11800000    /*                 'MODULE'                                                    */\n11810000    /*                 'SOURCE'                                                    */\n11820000    /*                 'DLIB'                                                      */\n11830000    /*                 'SYSMOD'                                                    */\n11840000    /*                 'M.C.S.'                                                    */\n11850000    /*                                                                             */\n11860000    /*             NOTE THAT A VALUE OF \"ALL\" WILL INCREASE SMPSCAN EXECUTION      */\n11870000    /*             TIME, BECAUSE ONLY THOSE ENTRY TYPES REFERENCED IN              */\n11880000    /*             MATCH_ARRAY ARE POTENTIAL OUTPUT CANDIDATES.  SMPSCAN           */\n11890000    /*             BYPASSES NON-ESSENTIAL PROCESSING FOR THOSE TYPES OMITTED       */\n11900000    /*             FROM MATCH_ARRAY.  IN PARTICULAR, LINE SCANNING IS SKIPPED.     */\n11910000    /*             NOT USING MATCH_ARRAY HAS THE SAME EFFECT AS \"ALL\" SINCE        */\n11920000    /*             ENTRY MATCHING IS GOVERNED BY SCAN RESULTS.                     */\n11930000    /*                                                                             */\n11940000    /*             .COMPARE_TEST.  THIS VARIABLE CONTROLS WHETHER THE FILE         */\n11950000    /*              SUB-ENTRIES WITHIN THIS MATCH_ARRAY ENTRY ARE TO BE PROCESSED  */\n11960000    /*              IN AN ALL (AND) OR ANY (OR) MANNER.  VALID VALUES ARE:         */\n11970000    /*                                                                             */\n11980000    /*                 'ALL'                                                       */\n11990000    /*                 'ANY'                                                       */\n12000000    /*                                                                             */\n12010000    /*              THE DEFAULT IS \"ALL\".  \"ALL\" INDICATES THAT ALL CONDITIONS     */\n12020000    /*              REPRESENTED BY THE COMPARE_OPTION AND COMPARE_SELECT           */\n12030000    /*              VARIABLES FOR EACH ACTIVE FILE MUST BE MET IN ORDER FOR A      */\n12040000    /*              MATCH_ARRAY ENTRY TO YIELD A MATCH WITH THE CURRENT GROUP OF   */\n12050000    /*              LISTING ENTRIES.  \"ALL\" WAS CHOSEN AS DEFAULT TO COMPLEMENT    */\n12060000    /*              THE FACT THAT ALL ACTIVE MATCH_ARRAY ENTRIES ARE PROCESSED     */\n12070000    /*              FOR EACH GROUP OF LISTING ENTRIES, AND ANY MATCH_ARRAY ENTRY   */\n12080000    /*              RESULTING IN A MATCH CAUSES TH ENTRY'S OUTPUT INSTRUCTIONS     */\n12090000    /*              TO BE APPLIED TO THE GROUP.  IN OTHER WORDS, \"ALL\" (AND) WAS   */\n12100000    /*              CHOSEN TO COMPLEMENT THE \"ANY\" (OR) LOGIC USED WITH THE        */\n12110000    /*              ARRAY.  A VALUE OF \"ANY\" CAN ALSO BE SPECIFIED FOR             */\n12120000    /*              COMPARE_TEST.  A VALUE OF \"ANY\" DOESN'T CHANGE THE WAY         */\n12130000    /*              MATCH_ARRAY IS INTERPRETED, BUT IT DOES SIMPLIFY THE           */\n12140000    /*              SPECIFICATION OF CERTAIN TESTS.  THAT'S WHY IT'S PROVIDED.     */\n12150000    /*              FOR EXAMPLE, WITH FOUR INPUT ZONE LISTINGS, TESTING FOR        */\n12160000    /*              ENTRIES OF A CERTAIN TYPE THAT ARE DEFINED IN SOME BUT NOT     */\n12170000    /*              ALL INPUT LISTINGS WILL REQUIRE 1 MATCH_ARRAY ENTRY WITH       */\n12180000    /*              COMPARE_TEST='ANY', BUT WILL REQUIRE 14 MATCH_ARRAY ENTRIES    */\n12190000    /*              WITH COMPARE_TEST='ALL'.                                       */\n12200000    /*                                                                             */\n12210000    /*             .COMPARE_OPTION.  THIS VARIABLE SPECIFIES, FOR THE CURRENT      */\n12220000    /*              GROUP OF LISTING ENTRIES, WHETHER AN ENTRY IS EXPECTED TO      */\n12230000    /*              BE PRESENT FROM THAT FILE.  A COMPARE_OPTION VALUE             */\n12240000    /*              PERTAINS TO EACH ACTIVE FILE.  VALID VALUES ARE:               */\n12250000    /*                                                                             */\n12260000    /*                 'COMPARE'       (AND REASONABLE ABBREVIATIONS)              */\n12270000    /*                 'NOCOMPARE'     (AND REASONABLE ABBREVIATIONS)              */\n12280000    /*                 'IGNORE' OR 'IGCOMPARE'    (AND ABBREVIATIONS)              */\n12290000    /*                                                                             */\n12300000    /*             THE DEFAULT IS \"IGNORE\".  \"COMPARE\" INDICATES THAT A LISTING    */\n12310000    /*             ENTRY IS EXPECTED FROM THIS FILE.  \"NOCOMPARE\" INDICATES THAT   */\n12320000    /*             A LISTING ENTRY IS EXPECTED TO BE ABSENT FROM THIS FILE.        */\n12330000    /*             \"IGNORE\" AND ITS SYNONYM \"IGCOMPARE\" INDICATE THAT AN ENTRY     */\n12340000    /*             LISTING MAY OR MAY NOT APPEAR - IT WILL BE PROCESSED IF         */\n12350000    /*             PRESENT, BUT ITS PRESENCE OR ABSENCE ISN'T DEMANDED.  BOTH      */\n12360000    /*             \"COMPARE\" AND \"IGNORE\" ARE INTERPRETED IN CONJUNCTION WITH      */\n12370000    /*             THE COMPARE_SELECT VARIABLE AS DESCRIBED BELOW.  \"NOCOMPARE\"    */\n12380000    /*             DOESN'T INTERACT WITH COMPARE_SELECT BECAUSE AN ENTRY THAT      */\n12390000    /*             ISN'T PRESENT CAN'T BE SCANNED.                                 */\n12400000    /*                                                                             */\n12410000    /*             .COMPARE_SELECT.  THIS VARIABLE SPECIFIES, WHEN AN ENTRY FROM   */\n12420000    /*              THIS FILE IS PRESENT IN THE CURRENT GROUP OF LISTING           */\n12430000    /*              ENTRIES, HOW THE ENTRY'S SCAN_RESULT IS TO BE WEIGHED.  A      */\n12440000    /*              COMPARE_TEST VALUE CORRESPONDING TO THE COMPARE_OPTION         */\n12450000    /*              PERTAINS TO EACH ACTIVE FILE.  VALID VALUES ARE:               */\n12460000    /*                                                                             */\n12470000    /*                 'SELECT'        (AND REASONABLE ABBREVIATIONS)              */\n12480000    /*                 'NOSELECT'      (AND REASONABLE ABBREVIATIONS)              */\n12490000    /*                 'IGNORE' OR 'IGSELECT'     (AND ABBREVIATIONS)              */\n12500000    /*                                                                             */\n12510000    /*             THE DEFAULT IS \"IGNORE\".  \"SELECT\" INDICATES THAT THE ENTRY     */\n12520000    /*             MUST HAVE BEEN SELECTED BY THE SCAN PROCESS (RESULT IS '1'B).   */\n12530000    /*             \"NOSELECT\" INDICATES THAT THE ENTRY MUST BE NOT SELECTED BY     */\n12540000    /*             THE SCAN PRECESS (RESULT IS '0'B).  \"IGNORE\" AND ITS SYNONYM    */\n12550000    /*             \"IGSELECT\" INDICATE THAT THE SCAN RESULT IS TO BE DISREGARDED   */\n12560000    /*             IN DETERMINING WHETHER THE CURRENT GROUP OF ENTRIES IS A        */\n12570000    /*             \"MATCH\" ACCORDING TO THIS MATCH_ARRAY ENTRY.  IF                */\n12580000    /*             COMPARE_OPTION IS \"COMPARE\" OR \"IGNORE\" AND COMPARE_SELECT IS   */\n12590000    /*             \"SELECT\" OR \"NOSELECT\", THE VARIABLES ACT TOGETHER.  FOR        */\n12600000    /*             INSTANCE, ONE CAN SPECIFY THAT AN ENTRY NEED NOT BE PRESENT     */\n12610000    /*             ISN A LISTING, BUT IF IT IS PRESENT, ITS SCAN_RESULT MUST BE    */\n12620000    /*             POSITIVE BY SPECIFYING COMPARE_OPTION='IGNORE' AND              */\n12630000    /*             'COMPARE_SELECT='SELECT'.                                       */\n12640000    /*                                                                             */\n12650000    /*             .WRITE_OPTION.  IF THIS MATCH_ARRAY ENTRY RESULTS IN A MATCH    */\n12660000    /*              FOR THE CURRENT GROUP OF LISTING ENTRIES, THIS VARIABLE        */\n12670000    /*              INDICATES THE OUTPUT REQUIREMENT FOR THE ENTRY FROM THIS       */\n12680000    /*              FILE.  VALID VALUES ARE:                                       */\n12690000    /*                                                                             */\n12700000    /*                 'WRITE'         (AND REASONABLE ABBREVIATIONS)              */\n12710000    /*                 'NOWRITE'       (AND REASONABLE ABBREVIATIONS)              */\n12720000    /*                                                                             */\n12730000    /*              THE DEFAULT IS \"WRITE\", AND THEIR MEANINGS ARE APPARENT.       */\n12740000    /*              FOR \"WRITE\", THE DECISION TO WRITE DEPENDS ON THE VALUE IN     */\n12750000    /*              WRITE_SELECT, DESCRIBED NEXT.                                  */\n12760000    /*                                                                             */\n12770000    /*             .WRITE_SELECT.  IF THIS MATCH_ARRAY ENTRY RESULTS IN A MATCH    */\n12780000    /*              FOR THE CURRENT GROUP OF LISTING ENTRIES AND WRITE_OPTION IS   */\n12790000    /*              \"WRITE\", THIS VARIABLE INDICATES WHETHER THE LISTING ENTRY'S   */\n12800000    /*              SCAN RESULT HAS ANY BEARING ON WHETHER THE ENTRY IS WRITTEN.   */\n12810000    /*              VALID VALUES ARE THE SAME AS THOSE FOR COMPARE_SELECT:         */\n12820000    /*                                                                             */\n12830000    /*                 'SELECT'        (AND REASONABLE ABBREVIATIONS)              */\n12840000    /*                 'NOSELECT'      (AND REASONABLE ABBREVIATIONS)              */\n12850000    /*                 'IGNORE' OR 'IGSELECT'     (AND ABBREVIATIONS)              */\n12860000    /*                                                                             */\n12870000    /*              THE DEFAULT IS \"IGNORE\".  \"SELECT\" INDICATES THAT THE ENTRY    */\n12880000    /*              MUST HAVE BEEN SELECTED BY THE SCAN PROCESS (RESULT IS         */\n12890000    /*              '1'B).  \"NOSELECT\" INDICATES THAT THE ENTRY MUST HAVE BEEN     */\n12900000    /*              NOT SELECTED (RESULT IS '0'B).  \"IGNORE\" AND ITS SYNONYM       */\n12910000    /*              \"IGSELECT\" INDICATE THAT THE SCAN_RESULT IS TO BE              */\n12920000    /*              DISREGARDED FOR THE PURPOSE OF DECIDING WHETHER TO WRITE THE   */\n12930000    /*              ENTRY - IT IS WRITTEN EITHER WAY.  A WRITE_SELECT VALUE OF     */\n12940000    /*              \"IGNORE\" HAS NO EFFECT ON THE PRESENCE OR ABSENCE OF           */\n12950000    /*              UNDERSCORES IN HIGHLIGHTED OUTPUT FOR THIS FILE.               */\n12960000    /*                                                                             */\n12970000    /*      IF MATCH_ARRAY VARIABLES ARE OMITTED FROM THE INPUT DATA SET, IT IS    */\n12980000    /*      AS IF A SINGLE MATCH_ARRAY ENTRY HAD BEEN SPECIFIED, WITH THE          */\n12990000    /*      FOLLOWING VALUES:                                                      */\n13000000    /*                                                                             */\n13010000    /*             .TYPE          ='ALL'.                                          */\n13020000    /*             .COMPARE_TEST  ='ANY'.                                          */\n13030000    /*             .COMPARE_OPTION='IGNORE'  FOR EACH ACTIVE FILE.                 */\n13040000    /*             .COMPARE_SELECT='SELECT'  FOR EACH ACTIVE FILE.                 */\n13050000    /*             .WRITE_OPTION  ='WRITE'   FOR EACH ACTIVE FILE.                 */\n13060000    /*             .WRITE_SELECT  ='SELECT'  FOR EACH ACTIVE FILE.                 */\n13070000    /*                                                                             */\n13080000    /*                                                                             */\n13090000    /*   USES AND EXAMPLES                                                         */\n13100000    /*                                                                             */\n13110000    /*            SMPSCAN'S USES CORRESPOND TO ITS FOUR MAIN FUNCTIONAL            */\n13120000    /*      CAPABILITIES:  PROVIDING A DIRECTORY OF MATCHING ENTRIES AND ENTRY     */\n13130000    /*      TYPE TOTALS FOR ONE OR MORE SMP/E LIST COMMAND OUTPUT LISTINGS,        */\n13140000    /*      IDENTIFYING AND MATCHING ENTRIES WHICH SATISY CERTAIN CONDITIONS,      */\n13150000    /*      PROVIDING PRE-SELECTED INPUT TO OTHER LIST COMMAND OUTPUT PROCESSING   */\n13160000    /*      PROGRAMS, AND GENERATING CARD-IMAGE FILES THAT CAN BE EDITED AND       */\n13170000    /*      TAILORED FOR OTHER USES.  SOME SPECIFIC INSTANCES ARE TO:              */\n13180000    /*                                                                             */\n13190000    /*             .IDENTIFY DDDEF ENTRIES:                                        */\n13200000    /*                                                                             */\n13210000    /*                -REFERENCING VOLUME SERIAL NUMBERS NO LONGER DEFINED, OR     */\n13220000    /*                 DEVICE TYPES NO LONGER INSTALLED.                           */\n13230000    /*                                                                             */\n13240000    /*                -THAT SHOULD BE DEFINED IN ALL (SAY) TARGET ZONES, BUT       */\n13250000    /*                 AREN'T.                                                     */\n13260000    /*                                                                             */\n13270000    /*                -REFERENCING VOLUME SERIAL NUMBERS INAPPROPRIATE TO A        */\n13280000    /*                 ZONE.                                                       */\n13290000    /*                                                                             */\n13300000    /*             .IDENTIFY LOAD MODULES:                                         */\n13310000    /*                                                                             */\n13320000    /*                -CROSS-SYSTEM THAT ARE DEFINED IN SOME BUT NOT ALL OF THE    */\n13330000    /*                 LISTED TARGET ZONES.                                        */\n13340000    /*                                                                             */\n13350000    /*                -CONTAINING MODULES FOR A PARTICULAR FMID OR GROUP OF        */\n13360000    /*                 FMID'S TO ASSIST IN THE INSTALLATION OF A NEW FMID.         */\n13370000    /*                                                                             */\n13380000    /*                -APPEARING IN MORE THAN ONE SYSTEM LIBRARY FOR A GIVEN       */\n13390000    /*                 ZONE, OR IN MORE THAN ONE LIBRARY FOR SOME TARGET ZONES     */\n13400000    /*                 BUT NOT FOR ALL.                                            */\n13410000    /*                                                                             */\n13420000    /*             .ALLOW IDENTIFICATION OF SYSMODS:                               */\n13430000    /*                                                                             */\n13440000    /*                -CONTAINING JCLIN, AND EITHER UPDATING OR REPLACING A        */\n13450000    /*                 SYSGEN MACRO.                                               */\n13460000    /*                                                                             */\n13470000    /*                -RECEIVED ON A PARTICULAR DATE, DATE AND TIME, OR BETWEEN    */\n13480000    /*                 ONE OR MORE RANGES OF DATES (AND TIMES).                    */\n13490000    /*                                                                             */\n13500000    /*                -REFERENCING A GIVEN MACRO, MODULE, APAR, FUNCTION, OR       */\n13510000    /*                 PTF, WHETHER APPLIED, ACCEPTED, OR ONLY JUST RECEIVED.      */\n13520000    /*                                                                             */\n13530000    /*                -APPLIED TO A TARGET ZONE BETWEEN TWO DATES AND EITHER       */\n13540000    /*                 ACCEPTED AFTER A CERTAIN DATE, OR NOT ACCEPTED AT ALL.      */\n13550000    /*                 MOREOVER, THESE TYPES OF TESTS CAN INVOLVE MORE THAN ONE    */\n13560000    /*                 TARGET ZONE, WITH DIFFERENT RANGES OF DATES FOR EACH        */\n13570000    /*                 ZONE.                                                       */\n13580000    /*                                                                             */\n13590000    /*             .PROVIDE A CONTROL CARD OUTPUT FILE OF THE SELECTED ENTRIES     */\n13600000    /*              THAT CAN BE EDITED:                                            */\n13610000    /*                                                                             */\n13620000    /*                -AND USED AS INPUT TO SMP/E TO INSTALL SPECIAL-PURPOSE       */\n13630000    /*                 MAINTENANCE, OR SELECT CERTAIN SYSMODS FOR APPLY, ACCEPT,   */\n13640000    /*                 OR RESTORE PROCESSING.                                      */\n13650000    /*                                                                             */\n13660000    /*                                                                             */\n13670000    /*   PROGRAMMING NOTES                                                         */\n13680000    /*                                                                             */\n13690000    /*            THIS SECTION DESCRIBES SOME OF THE MORE IMPORTANT                */\n13700000    /*      CONSIDERATIONS UNDERLYING THE STRUCTURE AND CODING OF SMPSCAN, IN      */\n13710000    /*      CASE CORRECTIONS, CHANGES, OR ENHANCEMENTS ARE NEEDED:                 */\n13720000    /*                                                                             */\n13730000    /*             .AFTER ANY PROGRAM CHANGES ARE MADE, THE VALUE IN VARIABLE      */\n13740000    /*              SMPSCAN_LVL SHOULD REFLECT THE VERSION AND NEW LEVEL OF        */\n13750000    /*              SMPSCAN.  THIS VALUE APPEARS IN THE SMPDCTRY OUTPUT IN TITLE   */\n13760000    /*              LINE NUMBER 1.                                                 */\n13770000    /*                                                                             */\n13780000    /*             .THE MAJOR DATA STRUCTURES WITHIN SMPSCAN WERE DECLARED         */\n13790000    /*              \"CONTROLLED\" WITH VARIABLE DIMENSIONS IN ORDER TO MAKE ARRAY   */\n13800000    /*              SIZES EASY TO EXPAND.  THESE DIMENSION VARIABLES WERE          */\n13810000    /*              REFERENCED BOTH IN STRUCTURAL DECLARATIONS AND DO GROUPS.      */\n13820000    /*              THE MORE IMPORTANT OF THESE DIMENSION VARIABLES ARE:           */\n13830000    /*                                                                             */\n13840000    /*                -IMATCH_MAX:  DETERMINES THE NUMBER OF ENTRIES IN            */\n13850000    /*                              MATCH_ARRAY, CURRENTLY SET AT 032.             */\n13860000    /*                                                                             */\n13870000    /*                -IFILE_MAX:   DEFINES THE MAXIMUM NUMBER OF INPUT LISTING    */\n13880000    /*                              FILES SUPPORTED, CURRENTLY SET AT 016.  IF     */\n13890000    /*                              SUPPORT FOR MORE THAN 016 FILES IS DESIRED,    */\n13900000    /*                              PROGRAM VARIABLES BEGINNING WITH \"DTF\", THE    */\n13910000    /*                              FILE VARIABLES AND ASSOCIATED LISTS MUST       */\n13920000    /*                              ALSO BE UPDATED ACCORDINGLY.  OTHERWISE, THE   */\n13930000    /*                              SOLE DEPENDENCY IS ON THE VALUE IN             */\n13940000    /*                              IFILE_MAX, SINCE THE FILE MANAGEMENT           */\n13950000    /*                              STRUCTURES ARE \"CONTROLLED\" WITH VARIABLE      */\n13960000    /*                              SUBSCRIPTS.                                    */\n13970000    /*                                                                             */\n13980000    /*                -IPLANE_MAX:  DETERMINES THE NUMBER OF PLANES IN EACH        */\n13990000    /*                              SCAN_ARRAY FILE CROSS-SECTION, CURRENTLY SET   */\n14000000    /*                              AT 012.                                        */\n14010000    /*                                                                             */\n14020000    /*                -IROW_MAX:    DETERMINES THE NUMBER OF ROWS IN EACH          */\n14030000    /*                              SCAN_ARRAY PLANE, CURRENTLY SET AT 012.        */\n14040000    /*                                                                             */\n14050000    /*                -ICOL_MAX:    DETERMINES THE NUMBER OF COLUMNS IN EACH       */\n14060000    /*                              SCAN_ARRAY ROW, CURRENTLY SET AT 012.          */\n14070000    /*                                                                             */\n14080000    /*                -PLIXOPT:     AFTER ANY PROGRAM CHANGES THAT INCREASE        */\n14090000    /*                              SMPSCAN'S VIRTUAL STORAGE REQUIREMENTS, THE    */\n14100000    /*                              ISASIZE AND HEAP OPTIONS IN PLIXOPT MAY NEED   */\n14110000    /*                              TO BE REVISED.                                 */\n14120000    /*                                                                             */\n14130000    /*             .IF IT BECOMES NECESSARY TO ADD SUPPORT FOR NEW SMP/E ENTRY     */\n14140000    /*              TYPES IN THE FUTURE, THE FOLLOWING PROGRAM AREAS SHOULD BE     */\n14150000    /*              REVIEWED:                                                      */\n14160000    /*                                                                             */\n14170000    /*                -NTRYINDX_MAX:  THIS VARIABLE DEFINES AN ARBITRARY UPPER     */\n14180000    /*                              LIMIT TO THE NUMBER OF DISTINCT ENTRY TYPES.   */\n14190000    /*                              ITS VALUE IS CURRENTLY SET AT 024, WITH        */\n14200000    /*                              14 VALUES IN ACTUAL USE.                       */\n14210000    /*                                                                             */\n14220000    /*                -ENTRY_TYPE:  THIS SUBROUTINE MAPS AN ENTRY TYPE NAME TO     */\n14230000    /*                              AN SMPSCAN INTERNAL INDEX VALUE.  NEW ENTRY    */\n14240000    /*                              TYPE NAMES AND ABBREVIATIONS FOR NEW OR        */\n14250000    /*                              EXISTING TYPES SHOULD BE ADDED HERE.           */\n14260000    /*                                                                             */\n14270000    /*                -ENTRY_INDEX: THIS SUBROUTINE MAPS AN SMPSCAN ENTRY TYPE     */\n14280000    /*                              INTERNAL INDEX VALUE BACK TO AN ENTRY TYPE     */\n14290000    /*                              NAME.  NAMES OF NEW ENTRY TYPES, BUT NOT       */\n14300000    /*                              ABBREVIATIONS, SHOULD BE ADDED HERE.           */\n14310000    /*                                                                             */\n14320000    /*                -SMPDATA_ENTRY_LINE_WRITE:  THIS SUBROUTINE AND ITS          */\n14330000    /*                              SUBORDINATE SUBROUTINES                        */\n14340000    /*                              WRITE_DATA_FORMAT1_LINE THROUGH                */\n14350000    /*                              WRITE_DATA_FORMAT5_LINE SHOULD BE REVIEWED     */\n14360000    /*                              AND FORMATTING ROUTINES FOR ANY NEW LINE       */\n14370000    /*                              TYPES SHOULD BE ADDED AS NEEDED.               */\n14380000    /*                                                                             */\n14390000    /*                -SMPDCTRY_ENTRY_FILE_STYPE_INFO:  IF SPECIAL ENTRY           */\n14400000    /*                              INFORMATION IS DESIRED IN SMPDCTRY ENTRY       */\n14410000    /*                              LINE LOCATIONS 026-040 THIS SUBROUTINE, THE    */\n14420000    /*                              CORRESPONDING DATA COLLECTION LOGIC IN         */\n14430000    /*                              SMPLIST_ENTRY_LINE_EVAL, AND ANY NEW           */\n14440000    /*                              VARIABLE DEFINITIONS NEEDED IN                 */\n14450000    /*                              SMPLIST.CURR_PAGE AND SMPLIST.CURR_NTRY WILL   */\n14460000    /*                              NEED TO BE CONSIDERED.                         */\n14470000    /*                                                                             */\n14480000    /*                -SCANDOC:     FINALLY, THIS DOCUMENTATION SHOULD BE          */\n14490000    /*                              REVIEWED, AND THE NEW ENTRY TYPE MENTIONED     */\n14500000    /*                              AT LEAST IN CONJUNCTION WITH THE MATCH_ARRAY   */\n14510000    /*                              \"TYPE\" VARIABLE.                               */\n14520000    /*                                                                             */\n14530000    /*                                                                             */\n14540000    /*   UPDATE HISTORY                                                            */\n14550000    /*                                                                             */\n14560000    /*             .MODULE UPGRADED FROM \"PTSSCAN\" TO SUPPORT SMP/E,               */\n14570000    /*              RENAMED TO \"SMPSCAN\", TESTED, AND DOCUMENTED.      12/31/86 TJA*/\n14580000    /*                                                                             */\n14590000    /*******************************************************************************/\n14600000    /*                                                                             */\n14610000    /*>>>>>>>>>>>>>>>>>>>>>>>>C U I C   D I S C L A I M E R<<<<<<<<<<<<<<<<<<<<<<<<*/\n14620000    /*                                                                             */\n14630000    /*******************************************************************************/\n14640000    /*            THE INFORMATION OR MATERIAL BEING PROVIDED BY COMMERCIAL UNION   */\n14650000    /*      INSURANCE COMPANY (CUIC), WHETHER IN HARD COPY OR MACHINE READABLE     */\n14660000    /*      FORM, HAS BEEN DEVELOPED BY CUIC FOR ITS OWN PURPOSE AND FOR USE ON    */\n14670000    /*      ITS OWN EQUIPMENT AND WITHIN ITS OWN DATA PROCESSING SYSTEM.  CUIC     */\n14680000    /*      MAKES NO REPRESENTATIONS OR WARRANTIES WHATSOEVER WITH RESPECT TO      */\n14690000    /*      THE INFORMATION OR MATERIAL FURNISHED HEREUNDER, EXPRESSED OR          */\n14700000    /*      IMPLIED, INCLUDING BUT NOT LIMITED TO ANY REPRESENTATION OR WARRANTY   */\n14710000    /*      OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR USE OR PURPOSE OR     */\n14720000    /*      THAT THE USE OF THE INFORMATION OR MATERIAL WILL NOT INFRINGE ANY      */\n14730000    /*      PATENT, COPYRIGHT, TRADEMARK, OR OTHER PROPRIETARY INTEREST.  YOU      */\n14740000    /*      ARE, THEREFORE, ACCEPTING THIS INFORMATION OR MATERIAL ON AN \"AS IS\"   */\n14750000    /*      BASIS AND WILL BE USING IT AT YOUR OWN RISK.  NEITHER CUIC NOR ANY     */\n14760000    /*      OF ITS AFFILIATES SHALL BE LIABLE WITH RESPECT TO ANY CLAIM, ACTION,   */\n14770000    /*      OR DEMAND BY ANY USER OR OTHER PARTY (INCLUDING ANY CLAIM, ACTION,     */\n14780000    /*      OR DEMAND FOR CONSEQUENTIAL DAMAGES EVEN IF CUIC HAS BEEN ADVISED OF   */\n14790000    /*      THE POSSIBILITY OF SUCH DAMAGES) ARISING FROM THE USE OF THE           */\n14800000    /*      INFORMATION OR THE MATERIALS AND CONCEPTS RELATED THERETO.             */\n14810000    /*      FURTHERMORE, CUIC WILL NOT MAINTAIN, CORRECT, OR UPDATE THIS           */\n14820000    /*      INFORMATION OR MATERIAL IN THE FUTURE.                                 */\n14830000    /*                                                                  01/26/83   */\n14840000    /*******************************************************************************/\n14850000    /*                                                                             */\n14860000    /*             DIRECT COMMENTS, QUESTIONS, AND SUGGESTIONS FOR ENHANCEMENTS    */\n14870000    /*      TO THE AUTHOR.........                                                 */\n14880000    /*                                                                             */\n14890000    /*             THOMAS J. AUBREY                                                */\n14900000    /*             INFORMATION SYSTEMS AND SERVICES - DATA PROCESSING DIVISION     */\n14910000    /*             COMMERCIAL UNION INSURANCE COMPANIES                            */\n14920000    /*             ONE BEACON STREET - THIRTEENTH FLOOR                            */\n14930000    /*             BOSTON, MASSACHUSETTS  02108                                    */\n14940000    /*             TELEPHONE: (617) 725-6208                                       */\n14950000    /*                                                                             */\n14960000    /*******************************************************************************/;\n14970000    %SKIP(3);\n14980000    DECLARE                    /*SPECIFY GLOBAL PROGRAM VALUES*/\n14990000         SMPSCAN_LVL             CHAR(005) INIT('02.00'),    /*PROGRAM VERSION & LEVEL   */\n15000000         SYSPARM                 CHAR(100) VARYING,          /*EXEC PARAMETER DATA       */\n15010000         PLIXOPT                 CHAR(128) VARYING           /*EXEC-TIME RUN OPTIONS     */\n15020000                                 STATIC EXTERNAL\n15030000                INIT('ISASIZE(0064K),HEAP(2048K,512K),STAE,COUNT,FLOW(256,064),REPORT');\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMPSCAN": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x00\\x87\\x02\\x8f\\x00\\x87\\x18\\x9f\\x17S\\x16+\\x16+\\x00\\x01\\xe3\\xe2\\xf1\\xf3\\xe3\\xf2\\xc1@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "1987-01-28T00:00:00", "modifydate": "1987-07-08T17:53:00", "lines": 5675, "newlines": 5675, "modlines": 1, "user": "TS13T2A"}, "text": "00010000*PROCESS     OPTIONS,SOURCE,LINECOUNT(60),NOMARGINI,MARGINS(010,100,009),NEST;\n00020000*PROCESS     FLAG(I),NOCOMPILE(E),LMESSAGE;\n00030000*PROCESS     AGGREGATE,ATTRIBUTES(SHORT),MAP,OFFSET,STORAGE,XREF(SHORT);\n00040000*PROCESS     GOSTMT,OPTIMIZE(TIME);\n00050000*PROCESS     COUNT,FLOW(25,10);\n00060000 SMPSCAN:  /*COMMERCIAL UNION SMP/E LIST ENTRY SELECTION UTILITY PROGRAM*/\n00070000 PROC(SYSPARM) OPTIONS(MAIN) REORDER;\n00080000    /*******************************************************************************/\n00090000    /*   NAME      .SMPSCAN   VERSION 02.00                                        */\n00100000    /*                                                                             */\n00110000    /*                                                                             */\n00120000    /*   TITLE     .COMMERCIAL UNION SMP/E LIST ENTRY SELECTION UTILITY.           */\n00130000    /*                                                                             */\n00140000    /*                                                                             */\n00150000    /*   PROGRAM OBJECTIVES                                                        */\n00160000    /*                                                                             */\n00170000    /*             .COMPENSATE FOR SOME OF THE LIMITATIONS OF THE SMP/E \"LIST\"     */\n00180000    /*              COMMAND, ESPECIALLY IN THE AREAS OF CROSS-ZONE ENTRY           */\n00190000    /*              MATCHING, DATE/TIME RANGE CONTROL OF LISTINGS, AND FMID        */\n00200000    /*              ASSOCIATION FOR ASSEMBLER AND LOAD MODULE ENTRIES.             */\n00210000    /*                                                                             */\n00220000    /*             .PROVIDE A UTILITY PROGRAM WRITTEN IN A HIGH LEVEL LANGUAGE     */\n00230000    /*              TO PROCESS THE \"SMPLIST\" OUTPUT FROM AN SMP/E                  */\n00240000    /*              \"SET_BDY(ZONENAME)./LIST.\" EXECUTION FOR ONE OR MORE ZONES     */\n00250000    /*              AND, USING A USER-SUPPLIED CONTROL VARIABLE INPUT FILE:        */\n00260000    /*                                                                             */\n00270000    /*                -PROVIDE CROSS-ZONE ENTRY MATCHING BASED ON SMP/E ENTRY      */\n00280000    /*                 TYPE, ENTRY NAME, AND ON CHARACTER STRING SCAN SELECTION.   */\n00290000    /*                                                                             */\n00300000    /*                -IDENTIFY ENTRIES SATISFYING SPECIFIED ENTRY TYPE/NAME       */\n00310000    /*                 MATCHING AND CHARACTER STRING SCAN SELECTION CRITERIA.      */\n00320000    /*                                                                             */\n00330000    /*                -GENERATE A RUN-TIME REPORT TO IDENTIFY EXECUTION CONTROL    */\n00340000    /*                 VALUES AND MATCH/SELECTION CRITERIA, PROVIDE A DIRECTORY    */\n00350000    /*                 TO MATCHING ENTRIES IN THE INPUT AND OUTPUT DATA SETS,      */\n00360000    /*                 AND REPORT FINAL PROCESSING TOTALS ONCE EXECUTION IS        */\n00370000    /*                 COMPLETE.                                                   */\n00380000    /*                                                                             */\n00390000    /*                -GENERATE LISTINGS OF THE MATCHING ENTRIES, BY FILE,         */\n00400000    /*                 SHOWING HOW CHARACTER STRING SELECTION CRITERIA HAVE BEEN   */\n00410000    /*                 APPLIED, AND IDENTIFYING WHERE THE SELECTION CRITERIA       */\n00420000    /*                 HAVE BEEN SATISFIED.                                        */\n00430000    /*                                                                             */\n00440000    /*                -GENERATE OUTPUT DATA SETS, ONE FOR EACH SMP/E LIST INPUT    */\n00450000    /*                 FILE, HAVING THE SAME FORMAT AND ATTRIBUTES AS THE          */\n00460000    /*                 \"SMPLIST\" INPUT DATA SET, TO ALLOW REPROCESSING OF THE      */\n00470000    /*                 MATCHING ENTRIES BY SMPSCAN WITH DIFFERENT SELECTION        */\n00480000    /*                 CRITERIA, OR TO PROVIDE INPUT TO ANY PROGRAM WHICH          */\n00490000    /*                 PROCESSES SMP/E LIST COMMAND OUTPUT AS INPUT.               */\n00500000    /*                                                                             */\n00510000    /*                -GENERATE 80-BYTE CARD-IMAGE OUTPUT DATA SETS, ONE FOR       */\n00520000    /*                 EACH SMP/E LIST INPUT DATA SET, CONTAINING DATA FROM THE    */\n00530000    /*                 MATCHING ENTRIES IN A FORMAT SUITABLE FOR USE IN AN SMP/E   */\n00540000    /*                 CONTROL STATEMENT, OR FOR FURTHER EDITING USING AN          */\n00550000    /*                 INTERACTIVE EDITOR.                                         */\n00560000    /*                                                                             */\n00570000    /*             .SUPPORT ALL OF THE ENTRY TYPES IN AN SMP/E GLOBAL, DLIB, OR    */\n00580000    /*              TARGET ZONE THAT CAN BE LISTED BY THE SMP/E \"LIST\" COMMAND,    */\n00590000    /*              WITH OR WITHOUT THE \"XREF\" OPTION.                             */\n00600000    /*                                                                             */\n00610000    /*             .USE CHARACTER STRING SELECTION AND ENTRY MATCHING TECHNIQUES   */\n00620000    /*              WHICH ARE GENERAL, AND RELATIVELY INSENSITIVE TO THE FORMAT    */\n00630000    /*              AND VALUES OF INDIVIDUAL DATA FIELDS WITHIN THE SMP/E          */\n00640000    /*              LISTING ENTRY LINES.  MOREOVER, IT WAS DEEMED IMPORTANT TO     */\n00650000    /*              REMAIN INDEPENDENT OF SMP/E INTERNALS OR KNOWLEDGE OF THOSE    */\n00660000    /*              INTERNALS.  THE CHARACTER STRING SCAN SELECTION TECHNIQUE IS   */\n00670000    /*              BASED ON PRESENCE OR ABSENCE OF SPECIFIED CHARACTER STRINGS    */\n00680000    /*              IN THE PRINT LINES DESCRIBING EACH INDIVIDUAL ENTRY.  THE      */\n00690000    /*              ENTRY MATCHING TECHNIQUE USED BY SMPSCAN IS BASED ON ENTRY     */\n00700000    /*              TYPE AND ON ENTRY NAME WITHIN TYPE.  THE ADVANTAGES OF USING   */\n00710000    /*              A CHARACTER STRING SCAN APPROACH ARE THAT ALTHOUGH CONTROL     */\n00720000    /*              FILES MAY REQUIRE CHANGE TO ACCOMMODATE NEW RELEASES OR        */\n00730000    /*              LEVELS OF SMP/E, THE PROGRAM ITSELF WILL NOT, IN GENERAL, BE   */\n00740000    /*              SENSITIVE TO CHANGES IN THE NAMES OF DATA FIELDS NOR WILL IT   */\n00750000    /*              BE HIGHLY SENSITIVE TO THE COLUMN LOCATIONS IN WHICH GIVEN     */\n00760000    /*              VALUES APPEAR.                                                 */\n00770000    /*                                                                             */\n00780000    /*             .THE MAJOR DISADVANTAGE FROM PROCESSING LISTINGS RATHER THAN    */\n00790000    /*              THE ZONE DATA BASES DIRECTLY IS THAT THE RESULTING             */\n00800000    /*              IMPLEMENTATION IS BATCH-ONLY.  THERE ARE ADDITIONAL RESOURCE   */\n00810000    /*              COSTS BOTH FOR LISTING THE ENIRE ZONE CONTENTS OF POSSIBLE     */\n00820000    /*              INTEREST TO DISK DATA SETS, AND FOR USING CHARACTER STRING     */\n00830000    /*              SCAN TECHNIQUES RATHER THAN INDEX SEARCHES TO TRACK DOWN THE   */\n00840000    /*              ENTRIES OF INTEREST.                                           */\n00850000    /*                                                                             */\n00860000    /*                                                                             */\n00870000    /*   SOURCE    .IBM PLI OPTIMIZING COMPILER AT VERSION 1 RELEASE 5.1 LEVEL.    */\n00880000    /*   LANGUAGE                                                                  */\n00890000    /*                                                                             */\n00900000    /*                                                                             */\n00910000    /*   MODULE    .NOT REENTRANT.  THE MODULE IS CODED REENTRANTLY WITHOUT        */\n00920000    /*   ATTRIBUTES     MODIFICATIONS TO STATIC STORAGE, BUT SEVERAL FILES ARE     */\n00930000    /*              OPENED AND USED BY THE PROGRAM.  ALSO, WITH PLI VERSION 1      */\n00940000    /*              RELEASE 5.1, THE RESULTING LOAD MODULE HAS AMODE=31,           */\n00950000    /*              RMODE=ANY.                                                     */\n00960000    /*                                                                             */\n00970000    /*             .THE COMPILE-TIME OPTIONS USED AT COMMERCIAL UNION FOR          */\n00980000    /*              COMPILING THIS PROGRAM WERE SPECIFIED USING \"*PROCESS\"         */\n00990000    /*              STATEMENTS.  THESE ARE INCLUDED AT THE BEGINNING OF THE        */\n01000000    /*              SOURCE PROGRAM.  EXECUTION TIME PERFORMANCE MAY BE IMPROVED    */\n01010000    /*              IF DESIRED BY DELETING THE \"*PROCESS\" STATEMENT REQUESTING     */\n01020000    /*              THE COUNT AND FLOW OPTIONS.                                    */\n01030000    /*                                                                             */\n01040000    /*             .THE EXECUTION-TIME PLI OPTIONS FOR THIS PROGRAM AT             */\n01050000    /*              COMMERCIAL UNION WERE INCORPORATED INTO THE PROGRAM VIA A      */\n01060000    /*              DECLARATION FOR THE STATIC VARIABLE \"PLIXOPT\".  AN ISASIZE     */\n01070000    /*              HAS BEEN SPECIFIED TO ELIMINATE THE NEED FOR USE OF THE        */\n01080000    /*              SYSTEM GETMAIN/FREEMAIN ROUTINES TO SATISFY STORAGE            */\n01090000    /*              REQUESTS, AND THE HEAP OPTION HAS BEEN SPECIFIED TO ALLOW      */\n01100000    /*              VIRTUAL STORAGE USE ABOVE THE 16 MEGABYTE LINE.                */\n01110000    /*                                                                             */\n01120000    /*                                                                             */\n01130000    /*   ENTRY     .THIS PROGRAM IS NAMED \"SMPSCAN\", ALTHOUGH                      */\n01140000    /*   POINT      PLI LOAD MODULES USE AN ENTRY POINT OF \"PLISTART\".             */\n01150000    /*                                                                             */\n01160000    /*                                                                             */\n01170000    /*   INPUT     .THE PARM FIELD OF THE EXEC STATEMENT IS NOT CURRENTLY USED     */\n01180000    /*              TO PASS EXECUTION-TIME VALUES TO SMPSCAN.  PRELIMINARY         */\n01190000    /*              SUPPORT HAS BEEN INCLUDED IN THE PROGRAM TO MAKE IT FAIRLY     */\n01200000    /*              EASY TO PROVIDE THIS SUPPORT LATER ON IF DESIRED.  VARIABLES   */\n01210000    /*              THAT MIGHT BE GOOD CANDIDATES FOR INCLUSION IN THIS TYPE OF    */\n01220000    /*              SUPPORT INCLUDE: DDIPFX, DDOPFX, IFILE_MAX, IPLANE_MAX,        */\n01230000    /*              IROW_MAX, ICOL_MAX, AND IMATCH_MAX.  THE \"SYSIN\" CONTROL       */\n01240000    /*              CARD DATA SET COULD ALSO BE ADAPTED TO USE A WIDER OR          */\n01250000    /*              VARIABLE RECORD SIZE.                                          */\n01260000    /*                                                                             */\n01270000    /*             .INPUT TO SMPSCAN IS PROVIDED BY THE FOLLOWING INPUT DATA       */\n01280000    /*              SETS:                                                          */\n01290000    /*                                                                             */\n01300000    /*                -THE CONTROL VARIABLE INPUT DATA SET, DDNAME=SYSIN           */\n01310000    /*                 (RECFM=FB, LRECL=80), CONTAINS VALUES TO DESIGNATE WHICH    */\n01320000    /*                 FILES ARE TO BE ACTIVE (UP TO 16 ARE SUPPORTED).  OTHER     */\n01330000    /*                 VARIABLES FROM THIS INPUT DATA SET CONTROL THE SCAN         */\n01340000    /*                 SELECTION AND MATCHING OF ENTRIES FROM EACH OF THE          */\n01350000    /*                 SMPLIST INPUT DATA SETS, AND VARY THE AMOUNT OF OUTPUT      */\n01360000    /*                 GENERATED TO EACH CORRESPONDING \"SMPDATA\" DATA SET.  FOR    */\n01370000    /*                 PROGRAMMING SIMPLICITY AND TO AVOID THIS PROGRAM'S          */\n01380000    /*                 BECOMMING A MAJOR DEVELOPMENT EFFORT, PLI GET DATA MODE     */\n01390000    /*                 WAS USED TO PROCESS EACH \"SYSIN\" INPUT RECORD.              */\n01400000    /*                 CONSEQUENTLY, ALL CHARACTER STRING VALUES MUST BE           */\n01410000    /*                 ENCLOSED IN QUOTES.  THE FOLLOWING PROGRAM CONTROL          */\n01420000    /*                 VARIABLES ARE READ FROM \"SYSIN\":                            */\n01430000    /*                                                                             */\n01440000    /*                    FILE_ACTIVE_OPTION(FILE#)                                */\n01450000    /*                    DATA_OUTPUT_OPTION(FILE#)                                */\n01460000    /*                                                                             */\n01470000    /*                    SCAN_ARRAY.SELECT(FILE#)                                 */\n01480000    /*                    SCAN_ARRAY.PLANE.SELECT(FILE#,PLANE#),                   */\n01490000    /*                    SCAN_ARRAY.PLANE.ROW.SELECT(FILE#,PLANE#,ROW#),          */\n01500000    /*                    SCAN_ARRAY.PLANE.ROW.COL.OP(FILE#,PLANE#,ROW#,COL#),     */\n01510000    /*                    SCAN_ARRAY.PLANE.ROW.COL.STRING(FILE#,PLANE#,ROW#,COL#)  */\n01520000    /*                    SCAN_ARRAY.PLANE.ROW.COL.BEG_POS(FILE#,PLANE#,ROW#,COL#) */\n01530000    /*                    SCAN_ARRAY.PLANE.ROW.COL.END_POS(FILE#,PLANE#,ROW#,COL#) */\n01540000    /*                    SCAN_ARRAY.PLANE.ROW.COL.POS_LEN(FILE#,PLANE#,ROW#,COL#) */\n01550000    /*                                                                             */\n01560000    /*                    MATCH_ARRAY.ENTRY.TYPE(MATCH#)                           */\n01570000    /*                    MATCH_ARRAY.ENTRY.COMPARE_TEST(MATCH#)                   */\n01580000    /*                    MATCH_ARRAY.ENTRY.FILE.COMPARE_OPTION(MATCH#,FILE#)      */\n01590000    /*                    MATCH_ARRAY.ENTRY.FILE.COMPARE_SELECT(MATCH#,FILE#)      */\n01600000    /*                    MATCH_ARRAY.ENTRY.FILE.WRITE_OPTION(MATCH#,FILE#)        */\n01610000    /*                    MATCH_ARRAY.ENTRY.FILE.WRITE_SELECT(MATCH#,FILE#)        */\n01620000    /*                                                                             */\n01630000    /*                 PLI DATA MODE DOES NOT ALLOW SUBSCRIPTS TO BE               */\n01640000    /*                 INTERLEAVED, AND CHARACTER STRING VALUES MUST BE ENCLOSED   */\n01650000    /*                 IN QUOTES.  A TERMINATING SEMICOLON IS NOT REQUIRED ON      */\n01660000    /*                 THE SYSIN CONTROL CARDS - IT IS SUPPLIED INTERNALLY FOR     */\n01670000    /*                 THE \"GET DATA\" STATEMENT BY SMPSCAN.  TO ALLOW THE INPUT    */\n01680000    /*                 DATA TO BE SELF-DOCUMENTING, A CONTROL CARD WITH AN \"*\"     */\n01690000    /*                 IN COLUMN 001 IS CONSIDERED TO BE A COMMENT RECORD, AND     */\n01700000    /*                 IT IS BYPASSED.  PLI GET DATA MODE DOES NOT ALLOW USE OF    */\n01710000    /*                 THE PLI-STYLE COMMENTS ON RECORDS PROCESSED BY \"GET         */\n01720000    /*                 DATA\".                                                      */\n01730000    /*                                                                             */\n01740000    /*                 THE MEANING OF THE ABOVE VARIABLES, AND THE ALLOWABLE       */\n01750000    /*                 VALUES FOR THEM ARE DESCRIBED IN THE FACILITIES/FEATURES    */\n01760000    /*                 SECTION BELOW.                                              */\n01770000    /*                                                                             */\n01780000    /*                -THE SMP/E LIST INPUT DATA SETS,                             */\n01790000    /*                 DDNAMES=(SMPLIST1-SMPLIST9, SMPLST10-SMPLST16)              */\n01800000    /*                 DCB=(RECFM=FBA,LRECL=121) CONTAIN THE OUTPUT WRITTEN TO     */\n01810000    /*                 THE \"SMPLIST\" DATA SET DURING AN SMP/E                      */\n01820000    /*                 \"SET_BDY(ZONENAME)./LIST.\"  RUN.  THIS DATA CAN COME        */\n01830000    /*                 DIRECTLY FROM EXECUTION OF SMP/E, OR FROM A DATA WRITTEN    */\n01840000    /*                 TO AN \"SMPSOUT\" DATA SET DURING A PREVIOUS EXECUTION OF     */\n01850000    /*                 SMPSCAN.  THE \"XREF\" OPTION CAN BE SPECIFIED ON THE SMP/E   */\n01860000    /*                 LIST COMMAND, IF IT IS SUPPORTED FOR THE ZONE BEING         */\n01870000    /*                 LISTED.  EACH SMP/E LIST DATA SET USED AS INPUT TO          */\n01880000    /*                 SMPSCAN MUST CONTAIN DATA FOR A SINGLE ZONE - \"LIST         */\n01890000    /*                 ALLZONES\" OUTPUT IS NOT SUPPORTED AS INPUT BY SMPSCAN.      */\n01900000    /*                 CROSS-ZONE MATCHING VIA SMPSCAN IS ACCOMPLISHED BY          */\n01910000    /*                 PROCESSING SEPARATE LIST DATA SETS, ONE FOR EACH ZONE OF    */\n01920000    /*                 INTEREST.                                                   */\n01930000    /*                                                                             */\n01940000    /*                                                                             */\n01950000    /*   WORK/     .SMPSCAN EXECUTION REQUIRES USE OF TEMPORARY WORK DATA SETS     */\n01960000    /*   SPILL      OR \"SPILL\" FILES FOR SAVING ENTRY LISTINGS WHOSE SIZE          */\n01970000    /*   FILES      EXCEEDS THE COMPILED CAPACITY OF SMPSCAN.  THERE ARE UP TO     */\n01980000    /*              16 OF THESE DATA SETS, ONE FOR EACH OF THE ACTIVE INPUT        */\n01990000    /*              LISTING FILES. THE DDNAMES ARE SMPUT1-9, SMPUT10-16, AND THE   */\n02000000    /*              DCB ATTRIBUTES ARE (RECFM=FB, LRECL=120).  PRINT CONTROL       */\n02010000    /*              CHARACTERS ARE NOT SAVED WITH THE LISTING LINES.  THE SPILL    */\n02020000    /*              FILE IS USED WHENEVER THE ENTRY MATCHING CRITERIA PROVIDED     */\n02030000    /*              IN \"MATCH_ARRAY\" INDICATE THAT THE ENTRY COULD POSSIBLY BE     */\n02040000    /*              WRITTEN TO AN OUTPUT DATA SET.                                 */\n02050000    /*                                                                             */\n02060000    /*              THE WORK/SPILL FILES CAN BE ALLOCATED TO ANY MEDIUM            */\n02070000    /*              SUPPORTING SEQUENTIAL INPUT AND OUTPUT TO THE SAME DATA SET    */\n02080000    /*              (E.G., DASD OR VIO).  AS EACH ENTRY LISTING LINE IS READ       */\n02090000    /*              FROM THE \"SMPLIST\" INPUT DATA SET AND AND PROCESSED AGAINST    */\n02100000    /*              THE FILE'S SCAN_ARRAY, THE LINE IS SAVED IN AN ARRAY IN        */\n02110000    /*              STORAGE.  IF THE NUMBER OF LINES IN AN ENTRY LISTING EXCEEDS   */\n02120000    /*              THE LIMIT SPECIFIED IN SMPSCAN PROGRAM VARIABLE                */\n02130000    /*              \"LINE_SAVE_LIMIT\" (CURRENTLY SET AT 100), THE WORK FILE IS     */\n02140000    /*              OPENED FOR OUTPUT, AND THE LINES BEYOND 100 (101, 102, ETC.)   */\n02150000    /*              ARE WRITTEN TO IT.  IF, ONCE THE ENTRY HAS BEEN FULLY READ,    */\n02160000    /*              IT IS DETERMINED THAT THE ENTRY SATISFIES THE SCAN SELECTION   */\n02170000    /*              AND FILE MATCHING CRITERIA SUPPLIED BY THE USER, THE WORK      */\n02180000    /*              FILE IS REOPENED FOR INPUT AND THE SAVED LINES ARE REREAD.     */\n02190000    /*              TOTALS OF THE NUMBER OF TIMES AN ENTRY WAS SAVED IN            */\n02200000    /*              ANTICIPATION OF ITS POSSIBLY BEING NEEDED, THE NUMBER OF       */\n02210000    /*              TIMES THE WORK FILE WAS OPENED FOR OUTPUT(WRITE OPEN/LINE      */\n02220000    /*              COUNTS) AND FOR INPUT(READ OPEN/LINE COUNTS) ARE DISPLAYED     */\n02230000    /*              IN THE FINAL TOTALS SECTION AT THE END OF THE \"SMPDCTRY\"       */\n02240000    /*              REPORT DATA SET.                                               */\n02250000    /*                                                                             */\n02260000    /*                                                                             */\n02270000    /*   OUTPUT    .SMPSCAN PRODUCES NO OPERATOR MESSAGES - THE PLI \"DISPLAY\"      */\n02280000    /*              STATEMENT IS NOT USED.                                         */\n02290000    /*                                                                             */\n02300000    /*             .SMPSCAN PRODUCES FOUR GROUPS OF OUTPUT DATA SETS:              */\n02310000    /*                                                                             */\n02320000    /*                -THE EXECUTION PROCESSING REPORT,                            */\n02330000    /*                 DDNAME=PTSDCTRY(RECFM=FBA,LRECL=133), CONTAINS MESSAGES     */\n02340000    /*                 AND COMMENTS DOCUMENTING THIS EXECUTION OF SMPSCAN.         */\n02350000    /*                 REGARDLESS OF THE NUMBER OF ACTIVE INPUT LISTING FILES,     */\n02360000    /*                 ONLY ONE SMPDCTRY DATA SET IS PRODUCED FOR AN EXECUTION     */\n02370000    /*                 OF SMPSCAN.  THE SMPDCTRY DATA SET REPORT CONTAINS FOUR     */\n02380000    /*                 SECTIONS:                                                   */\n02390000    /*                                                                             */\n02400000    /*                   1). INITIAL FILE INFORMATION AND SCAN_ARRAY CONTENTS.     */\n02410000    /*                   2). MATCH STATUS INFORMATION AND MATCH_ARRAY CONTENTS.    */\n02420000    /*                   3). DIRECTORY OF MATCHING ENTRIES (ONE SECTION FOR EACH   */\n02430000    /*                       DISTINCT TYPE OF ENTRY MATCHED).                      */\n02440000    /*                   4). FINAL PROCESSING TOTALS BY FILE, AND BY ENTRY TYPE    */\n02450000    /*                       WITHIN FILE.                                          */\n02460000    /*                                                                             */\n02470000    /*                 THE FIRST TWO SECTIONS ARE PRODUCED DURING SMPSCAN          */\n02480000    /*                 INITIALIZATION AND STARTUP, THE THIRD SECTION IS PRODUCED   */\n02490000    /*                 AS THE INPUT FILES ARE READ AND ENTRIES ARE MATCHED, AND    */\n02500000    /*                 THE LAST SECTION IS PRODUCED AFTER ALL INPUT FILES HAVE     */\n02510000    /*                 BEEN READ AND ALL MATCHING OUTPUT PRODUCED.                 */\n02520000    /*                                                                             */\n02530000    /*                -THE MATCHED ENTRY HIGHLIGHTED OUTPUT DATA SETS,             */\n02540000    /*                 DDNAMES=(SMPSCAN1-SMPSCAN9,SMPSCN10-SMPSCN16)               */\n02550000    /*                 DCB=(RECFM=FBA,LRECL=133), CONTAIN LISTINGS OF THE          */\n02560000    /*                 MATCHING ENTRIES.  THERE IS ONE OF THESE DATA SETS FOR      */\n02570000    /*                 EACH ACTIVE INPUT DATA SET.  THIS DATA SET, WHEN PRINTED,   */\n02580000    /*                 LOOKS LIKE THE SMPLIST OUTPUT FROM SMP/E, BUT THE DATA      */\n02590000    /*                 SETS ARE NOT COMPATIBLE.  PAGE TITLES AND LINE SPACING      */\n02600000    /*                 APPEAR THE SAME UPON PRINTING AND RECFM IS THE SAME, BUT    */\n02610000    /*                 THE LRECL IS LARGER (133 VS 121), AND THE TOP-OF-PAGE       */\n02620000    /*                 TITLE REFERENCES SMPSCAN RATHER THAN SMPLIST.  IN           */\n02630000    /*                 ADDITION, THOSE LINES SELECTED BY COMPARISON WITH THE       */\n02640000    /*                 FILE'S SCAN_ARRAY ARE FLAGGED ON THE RIGHT WITH             */\n02650000    /*                 \"**PPP,RRR**\" AND SELECTING CHARACTER STRINGS ARE           */\n02660000    /*                 UNDERSCORED.  THE FLAG ON THE RIGHT OF A HIGHLIGHTED LINE   */\n02670000    /*                 REFERENCES THE PLANE(\"PPP\") AND ROW(\"RRR\") OF THE FILE'S    */\n02680000    /*                 SCAN_ARRAY THAT RESULTED IN THE SUCCESSFUL COMPARISON.      */\n02690000    /*                 AN UNDERSCORE LINE IS PRODUCED ONLY FOR THE FIRST           */\n02700000    /*                 SUCCESSFUL ROW OF THE FILE'S SCAN_ARRAY.  NOTE: AN ENTRY    */\n02710000    /*                 THAT WAS CHOSEN BECAUSE AN EXCLUDE CRITERION WAS            */\n02720000    /*                 SATISFIED WILL NOT SHOW CORRESPONDING HIGHLIGHTED LINES     */\n02730000    /*                 BECAUSE THE CHARACTER STRING(S) DON'T APPEAR IN THE         */\n02740000    /*                 ENTRY.                                                      */\n02750000    /*                                                                             */\n02760000    /*                -THE MATCHED ENTRY SMPLIST OUTPUT DATA SETS,                 */\n02770000    /*                 DDNAMES=(SMPSOUT1-SMPSOUT9,SMPSOU10-SMPSOU16)               */\n02780000    /*                 DCB=(RECFM=FBA,LRECL=121), CONTAIN LISTINGS OF THE          */\n02790000    /*                 MATCHING ENTRIES.  THESE ARE THE SAME ENTRIES LISTED IN     */\n02800000    /*                 THE HIGHLIGHTED OUTPUT (\"SCAN\") DATA SETS, BUT WITHOUT      */\n02810000    /*                 HIGHLIGHTING INFORMATION.  THERE IS ONE OF THESE DATA       */\n02820000    /*                 SETS FOR EACH ACTIVE INPUT DATA SET. THIS OUTPUT DATA SET   */\n02830000    /*                 IS PRODUCED IN THE SAME FORMAT AND WITH THE SAME DCB        */\n02840000    /*                 ATTRIBUTES AS THE SMPLIST OUTPUT FROM SMP/E (RECFM,         */\n02850000    /*                 LRECL, PRINT CONTROL CHARACTERS, PAGE TITLES, AND LINE      */\n02860000    /*                 SPACINGS ARE THE SAME).  THE DATA SET CAN BE PRINTED, BUT   */\n02870000    /*                 IT IS NORMALLY USED TO PROVIDE INPUT (VIA SMPLIST           */\n02880000    /*                 DDNAMES) TO A FOLLOW-ON EXECUTION OF SMPSCAN USING          */\n02890000    /*                 DIFFERENT SELECTION CRITERIA.  IT CAN ALSO BE PASSED TO     */\n02900000    /*                 OTHER PROGRAMS WHICH PROCESS SMP/E SMPLIST OUTPUT SUCH AS   */\n02910000    /*                 THOSE FOUND ON SHARE OR GUIDE MODS TAPES.                   */\n02920000    /*                                                                             */\n02930000    /*                -THE MATCHED ENTRY CARD-IMAGE OUTPUT DATA SET,               */\n02940000    /*                 DDNAMES=(SMPDATA1-SMPDATA9,SMPDAT10-SMPDAT16)               */\n02950000    /*                 DCB=(RECFM=FB,LRECL=080), CONTAINS LISTING LINES FROM THE   */\n02960000    /*                 SELECTED ENTRIES MAPPED FROM A 120 CHARACTER PRINT LINE     */\n02970000    /*                 ONTO ONE OR MORE 80 BYTE CARD IMAGE RECORDS.  THERE IS      */\n02980000    /*                 ONE OF THESE DATA SETS FOR EACH ACTIVE INPUT DATA SET.      */\n02990000    /*                 DATA FROM EACH PRINT LINE IS MAPPED WITH ENCLOSING          */\n03000000    /*                 COMMENT CHARACTERS SO THAT ONLY THE ENTRY NAME, SMP         */\n03010000    /*                 M.C.S.  CONTROL STATEMENTS, ASSEM ENTRY ASSEMBLER SOURCE    */\n03020000    /*                 STATEMENTS, AND LMOD ENTRY LINKAGE EDITOR CONTROL           */\n03030000    /*                 STATEMENTS ARE MAPPED OUTSIDE COMMENT CHARACTERS.  THE      */\n03040000    /*                 DATA SET IS THUS USUALLY SUITABLE FOR DIRECT USE IN AN      */\n03050000    /*                 SMP CONTROL STATEMENT (SUCH AS \"APPLY\").  IT CAN ALSO BE    */\n03060000    /*                 PROCESSED BY ANY AVAILABLE INTERACTIVE EDITOR TO PRODUCE    */\n03070000    /*                 FURTHER RESULTS.  THE AMOUNT OF DATA WRITTEN TO THIS DATA   */\n03080000    /*                 SET DEPENDS ON THE SETTING OF THE \"DATA_OUTPUT_OPTION\"      */\n03090000    /*                 VARIABLE FOR THAT FILE.  THE ALLOWABLE VALUES AND           */\n03100000    /*                 ASSOCIATED OUTPUT ARE DESCRIBED IN THE                      */\n03110000    /*                 FEATURES/FACILITIES SECTION BELOW.                          */\n03120000    /*                                                                             */\n03130000    /*             .IN ADDITION TO THE DATA SETS PRODUCED BY SMPSCAN, THE          */\n03140000    /*              FOLLOWING ADDITIONAL DATA SETS MAY BE REQUIRED BECAUSE THE     */\n03150000    /*              PROGRAM IS WRITTEN IN PLI.  BOTH OF THESE DATA SETS SHOULD     */\n03160000    /*              BE ASSIGNED TO SYSOUT, OR DUMMIED OUT:                         */\n03170000    /*                                                                             */\n03180000    /*                -DDNAME=SYSPRINT IS REQUIRED IF AN ERROR IN PROGRAM          */\n03190000    /*                 EXECUTION OCCURS.                                           */\n03200000    /*                                                                             */\n03210000    /*                -DDNAME=PLIDUMP IS REQUIRED WHEN THE PROGRAM HAS BEEN        */\n03220000    /*                 COMPILED WITH WITH THE \"COUNT\" OR \"FLOW\" ATTRIBUTES, OR     */\n03230000    /*                 WHEN THE \"REPORT\" OPTION IS USED DURING PROGRAM EXECUTION   */\n03240000    /*                 TO MONITOR ISA AND HEAP STORAGE USE.                        */\n03250000    /*                                                                             */\n03260000    /*                                                                             */\n03270000    /*   RESTRICTIONS/LIMITATIONS                                                  */\n03280000    /*                                                                             */\n03290000    /*             .SMPSCAN HAS BEEN COMPILED UNDER IBM'S PLI OPTIMIZING           */\n03300000    /*              COMPILER VERSION 1 RELEASE 5.1 AND SUCCESSFULLY EXECUTED ON    */\n03310000    /*              MVS/SP LEVEL 2.1.3.  NO OTHER EXECUTION ENVIRONMENTS HAVE      */\n03320000    /*              BEEN TESTED WITH THIS PROGRAM SINCE THE SITE AT WHICH THIS     */\n03330000    /*              PROGRAM WAS DEVELOPED IS EXCLUSIVELY MVS/XA AND VM/SP.         */\n03340000    /*                                                                             */\n03350000    /*             .COMPILATION AND EXECUTION USING THE PLI OPTIMIZING COMPLIER    */\n03360000    /*              AND LIBRARIES AT VERSION 1 RELEASE 4.0 LEVEL PRODUCED A LOAD   */\n03370000    /*              MODULE WHICH FAILED TO EXECUTE.  WE TURNED OFF THE             */\n03380000    /*              \"OPTIMIZE(TIME)\" OPTION AT COMPILATION AND MADE TEMPORARY      */\n03390000    /*              PROGRAM CHANGES TO CIRCUMVENT THE PROBLEM UNTIL THE RELEASE    */\n03400000    /*              5.1 LEVEL OF THE COMPILER WAS INSTALLED.  WHILE WE SUSPECT     */\n03410000    /*              THESE PROBLEMS WERE RELATED TO THE MAINTENANCE LEVEL OF OUR    */\n03420000    /*              4.0 COMPILER, WE DID NOT RESEARCH THE PROBLEM IN DEPTH.  IT    */\n03430000    /*              MADE MORE SENSE TO US TO GET THE 5.1 LEVEL OF THE COMPILER     */\n03440000    /*              AND LIBRARIES UP AND OPERATIONAL SINCE WE HAD OTHER            */\n03450000    /*              REQUIREMENTS FOR THEM AS WELL.  IF THE PLI OPTIMIZING          */\n03460000    /*              COMPILER AT VERSION 1 RELEASE 5.1 OR LATER LEVEL IS NOT        */\n03470000    /*              AVAILABLE AT YOUR INSTALLATION, CONTACT THE AUTHOR FOR         */\n03480000    /*              FUTHER DETAILS.                                                */\n03490000    /*                                                                             */\n03500000    /*             .THE PROGRAM SUPPORTS SMPLIST OUTPUT FROM THE SMP/E \"LIST\"      */\n03510000    /*              COMMAND.  THERE ARE NO ENTRY TYPE PROCESSING RESTRICTIONS AS   */\n03520000    /*              THERE WERE IN PTSSCAN.  ALL ENTRY TYPES THAT ARE DEFINED IN    */\n03530000    /*              ZONES AND THAT CAN BE LISTED BY SMP/E RELEASE 3 ARE            */\n03540000    /*              SUPPORTED BY SMPSCAN.  MOREOVER, SMPSCAN HAS BEEN STRUCTURED   */\n03550000    /*              TO MAKE SUPPORT FOR NEW ENTRY TYPES FAIRLY EASY TO ADD.        */\n03560000    /*                                                                             */\n03570000    /*             .LISTING OF BACKUP ENTRIES FROM THE SCDS, MTSMAC ENTRIES FROM   */\n03580000    /*              SMPMTS, AND STSSRC ENTRIES FROM SMPSTS ARE NOT SUPPORTED BY    */\n03590000    /*              SMPSCAN AT THIS TIME.                                          */\n03600000    /*                                                                             */\n03610000    /*             .THIS VERSION OF SMPSCAN HAS BEEN RUN WITH SMPLIST OUTPUT       */\n03620000    /*              FROM SMP/E LVL 13.05.                                          */\n03630000    /*                                                                             */\n03640000    /*             .AT PRESENT, CONCURRENT PROCESSING IS SUPPORTED FOR A MAXIMUM   */\n03650000    /*              OF 16 INPUT LISTINGS ALONG WITH ASSOCIATED OUTPUT DATA SETS.   */\n03660000    /*                                                                             */\n03670000    /*             .ERROR ROUTINES TO ALLOW FOR RECOVERY FROM MISSING DD           */\n03680000    /*              STATEMENTS ARE NOT CODED INTO SMPSCAN AT THIS TIME.  THUS,     */\n03690000    /*              IF AN OUTPUT DATA SET IS NOT WANTED, A \"DD DUMMY\" JCL          */\n03700000    /*              STATEMENT SHOULD BE SUPPLIED FOR THE UNWANTED OUTPUT DATA      */\n03710000    /*              SET, OR THE PROGRAM WILL END IN ERROR WITHOUT PROCESSING ANY   */\n03720000    /*              DATA.                                                          */\n03730000    /*                                                                             */\n03740000    /*                                                                             */\n03750000    /*   FACILITIES/FEATURES                                                       */\n03760000    /*                                                                             */\n03770000    /*            THIS PROGRAM READS SMP/E \"SET_BDY(ZONENAME)./LIST.\"  OUTPUT      */\n03780000    /*      LISTINGS FROM DDNAME=SMPLIST THAT HAVE BEEN WRITTEN TO DISK OR TAPE    */\n03790000    /*      DATA SETS RATHER THAN SYSOUT.  UP TO 16 LISTING DATA SETS CAN BE       */\n03800000    /*      SCANNED AND MATCHED CONCURRENTLY.  ALL ENTRY TYPES ARE SUPPORTED.      */\n03810000    /*      AS ENTRY LISTINGS ARE READ, SMPSCAN SCANS EACH ENTRY FOR CHARACTER     */\n03820000    /*      STRINGS AS SPECIFIED BY THE FILE'S \"SCAN_ARRAY\".  BASED ON THE         */\n03830000    /*      RESULTS OF THESE SCANS AND ON THE FILE MATCHING INSTRUCTIONS FROM      */\n03840000    /*      THE \"MATCH_ARRAY\", SMPSCAN PRODUCES OUTPUT DATA SETS CONTAINING DATA   */\n03850000    /*      FROM THOSE ENTRIES SATISFYING THE COMBINATION OF SCAN SELECTION AND    */\n03860000    /*      MATCH CRITERIA SPECIFIED.                                              */\n03870000    /*                                                                             */\n03880000    /*            PROGRAM EXECUTION IS CONTROLLED BY VALUES SPECIFIED FOR          */\n03890000    /*      PROGRAM VARIABLES IN THE \"SYSIN\" DATA SET.  THE \"SYSIN\" DATA SET IS    */\n03900000    /*      DEFINED AS A \"RECORD\" DATA SET.  PLI \"GET STRING DATA\" IS USED TO      */\n03910000    /*      EXTRACT VALUES FROM EACH \"SYSIN\" INPUT RECORD ONCE IT HAS BEEN READ.   */\n03920000    /*      THIS TECHNIQUE WAS USED TO ALLOW COMMENT RECORDS TO BE INCLUDED WITH   */\n03930000    /*      THE VARIABLES AND THEIR VALUES.  IF AN \"*\" APPEARS IN BYTE 1 OF A      */\n03940000    /*      SYSIN INPUT RECORD, THE RECORD IS CONSIDERED A COMMENT.  SMPSCAN       */\n03950000    /*      BYPASSES COMMENT RECORDS.  WHEN A RECORD IS NOT A COMMENT, BYTES       */\n03960000    /*      01-72 OF THE INPUT RECORD ARE PROCESSED AS DATA - BYTES 73-80 ARE      */\n03970000    /*      IGNORED AND CAN CONTAIN SEQUENCE NUMBERS IF DESIRED.  IT IS NOT        */\n03980000    /*      NECESSARY TO INCLUDE A SEMI-COLON IN \"SYSIN\" INPUT RECORDS FOR GET     */\n03990000    /*      DATA MODE PROCESSING.  SMPSCAN APPENDS A SEMI-COLON TO THE END OF      */\n04000000    /*      THE DATA PORTION OF THE RECORD BEFORE DOING THE \"GET STRING DATA\"      */\n04010000    /*      FUNCTION.  BECAUSE PLI \"GET DATA\" IS USED TO READ THE INPUT            */\n04020000    /*      SPECIFICATIONS, THE SPECIFICATIONS MUST HAVE ONE OF THE FOLLOWING      */\n04030000    /*      FORMS:                                                                 */\n04040000    /*                                                                             */\n04050000    /*                 VARIABLE_NAME(SUBSCRIPTS) = NUMBER                          */\n04060000    /*            OR   VARIABLE_NAME(SUBSCRIPTS) = 'VALUE'                         */\n04070000    /*                                                                             */\n04080000    /*      THE VALUE SPECIFICATION FOR CHARACTER STRINGS MUST BE ENCLOSED IN      */\n04090000    /*      QUOTES BECAUSE THE CONTROL VARIABLES ARE DECLARED AS PLI CHARACTER     */\n04100000    /*      STRINGS. FURTHERMORE, SUBSCRIPTS MUST BE SPECIFIED TOGETHER            */\n04110000    /*      FOLLOWING THE VARIABLE NAME AND ALL QUALIFICATIONS.  UNLIKE THE PLI    */\n04120000    /*      COMPILER, PLI GET DATA MODE DOES NOT SUPPORT INTERLEAVED SUBSCRIPTS.   */\n04130000    /*      PROGRAM CONTROL VARIABLES THAT CAN BE SPECIFIED IN THE CONTROL         */\n04140000    /*      VARIABLE INPUT DATA SET WERE LISTED IN THE \"INPUT\" SECTION ABOVE.      */\n04150000    /*      THE MEANING OF THESE VARIABLES, THEIR EFFECTS ON PROGRAM EXECUTION,    */\n04160000    /*      AND THEIR VALID RANGES OF VALUES, WILL NOW BE DESCRIBED.               */\n04170000    /*                                                                             */\n04180000    /*            >>>>>FILE_ACTIVE_OPTION(FILE#).<<<<<                             */\n04190000    /*            THIS VARIABLE SPECIFIES WHICH FILES ARE TO BE ACTIVE DURING      */\n04200000    /*      THIS EXECUTION OF SMPSCAN.  IT IS DECLARED WITHIN SMPSCAN AS A         */\n04210000    /*      ONE-DIMENSIONAL ARRAY OF VARYING LENGTH CHARACTER STRINGS WITH THE     */\n04220000    /*      SINGLE SUBSCRIPT CORRESPONDING TO THE FILE NUMBER: 01-16.  THE         */\n04230000    /*      VALUES THAT CAN BE SPECIFIED ARE:                                      */\n04240000    /*                                                                             */\n04250000    /*                 'ACTIVE'                                                    */\n04260000    /*                 'INACTIVE'                                                  */\n04270000    /*                                                                             */\n04280000    /*      THE DEFAULT SPECIFICATION IS \"INACTIVE\" TO INSURE THAT FILES ARE       */\n04290000    /*      EXPLICITLY ACTIVATED.  IF A FILE IS \"ACTIVATED\", THE CORRESPONDING     */\n04300000    /*      \"LIST\", \"SCAN\" AND \"SOUT\" DD STATEMENTS MUST BE SUPPLIED.  THE         */\n04310000    /*      CORRESPONDING \"DATA\" DD STATEMENT IS ALSO REQUIRED UNLESS              */\n04320000    /*      DATA_OUTPUT_OPTION FOR THE FILE IS SET TO \"NONE\" (SEE BELOW).          */\n04330000    /*                                                                             */\n04340001    /*            >>>>>DATA_OUTPUT_OPTION(FILE#).<<<<<                             */\n04350000    /*            THIS VARIABLE CONTROLS THE AMOUNT OF OUTPUT WRITTEN TO EACH      */\n04360000    /*      ACTIVE CARD-IMAGE (SMPDATA1-SMPDATA9, SMPDAT10-SMPDAT16) OUTPUT DATA   */\n04370000    /*      SET FOR MATCHING ENTRIES.  THE SELECTION OF ENTRIES TO BE WRITTEN IS   */\n04380000    /*      CONTROLLED BY THE FILE'S SCAN_ARRAY CONTENTS, AND BY THE               */\n04390000    /*      MATCH_ARRAY.  THE DATA_OUTPUT_OPTION VARIABLE IS DECLARED WITHIN       */\n04400000    /*      SMPSCAN AS A ONE-DIMENSIONAL ARRAY OF VARYING LENGTH CHARACTER         */\n04410000    /*      STRINGS WITH THE SINGLE SUBSCRIPT CORRESPONDING TO THE FILE NUMBER:    */\n04420000    /*      01-16.  THE VALUES THAT CAN BE SPECIFIED ARE:                          */\n04430000    /*                                                                             */\n04440000    /*                 'NONE'                                                      */\n04450000    /*                 'ID1'                                                       */\n04460000    /*                 'ID'                                                        */\n04470000    /*                 'SELECT'                                                    */\n04480000    /*                 'ALL'                                                       */\n04490000    /*                                                                             */\n04500000    /*      THE DEFAULT SPECIFICATION IS \"NONE\".  CONSEQUENTLY, THE \"DATA\" DD      */\n04510000    /*      STATEMENT IS OPTIONAL AND IS REQUIRED AND USED ONLY IF EXPLICITLY      */\n04520000    /*      REQUESTED, AND IF THE MATCH_ARRAY INDICATES THAT THE DATA SET MAY BE   */\n04530000    /*      REQUIRED FOR OUTPUT.  THE OTHER SPECIFICATIONS CONTROL THE AMOUNT OF   */\n04540000    /*      DATA THAT WILL BE WRITTEN TO THIS DATA SET BY DESIGNATING WHICH OF A   */\n04550000    /*      MATCHING ENTRY'S LINES WILL BE MAPPED FROM 120-CHARACTER PRINT LINES   */\n04560000    /*      ONTO 80-BYTE CARD IMAGE RECORDS.  A VALUE OF \"ID1\" CAUSES THE FIRST    */\n04570000    /*      PART OF THE FIRST LISTING LINE FOR AN ENTRY TO BE MAPPED TO A SINGLE   */\n04580000    /*      80-BYTE CARD IMAGE.  THE RESULT IS A SINGLE CARD IMAGE FOR EACH        */\n04590000    /*      MATCHING ENTRY THAT IS SYNTACTICALLY CORRECT FOR USE WITH              */\n04600000    /*      SELECT/EXCLUDE OPERANDS ON SMP/E COMMANDS.  A VALUE OF \"ID\" CAUSES     */\n04610000    /*      THE FIRST LISTING LINE FOR AN ENTRY TO BE MAPPED TO ONE OR MORE CARD   */\n04620000    /*      IMAGE RECORDS.  SOME ENTRIES, E.G., M.C.S.  ENTRIES, MAY GENERATE      */\n04630000    /*      MORE THAN ONE CARD IMAGE WITH THE \"ID\" OPTION.  A VALUE OF \"SELECT\"    */\n04640000    /*      CAUSES THE FIRST LISTING LINE OF AN ENTRY, AND ANY LISTING LINE        */\n04650000    /*      WHICH WAS SELECTED BY COMPARISON WITH THE FILE'S SCAN_ARRAY TO BE      */\n04660000    /*      MAPPED TO CARD IMAGE RECORDS.  LASTLY, A VALUE OF \"ALL\" CAUSES ALL     */\n04670000    /*      LISTING LINES FOR A MATCHING ENTRY TO BE MAPPED ONTO CARD IMAGE        */\n04680000    /*      RECORDS, WHETHER SELECTED BY THE FILE'S SCAN_ARRAY, OR NOT.            */\n04690000    /*                                                                             */\n04700000    /*            >>>>>SCAN_ARRAY.<<<<<                                            */\n04710000    /*            SCAN_ARRAY PROVIDES SMPSCAN WITH THE INFORMATION IT NEEDS TO     */\n04720000    /*      SEARCH ENTRY LISTING LINES.  TITLE LINES ASIDE, THE FORMAT OF SMP/E    */\n04730000    /*      LIST OUTPUT LINES IS QUITE STRAIGHTFORWARD.  WITHOUT RECOURSE TO ANY   */\n04740000    /*      INTERNAL INFORMATION ON SMP/E, ONE CAN SEE THAT LISTING LINES ARE      */\n04750000    /*      FORMATTED IN FOUR AREAS, THREE OF WHICH ARE SIGNIFICANT:               */\n04760000    /*                                                                             */\n04770000    /*             .ENTRY NAME:       POSITIONS: 001-008     LENGTH: 008           */\n04780000    /*             .LINE TYPE:        POSITIONS: 011-025     LENGTH: 015           */\n04790000    /*             .EQUALS SIGN:      POSITION:    027       LENGTH: 001           */\n04800000    /*             .LINE DATA:        POSITIONS: 029-120     LENGTH: 092           */\n04810000    /*                                                                             */\n04820000    /*      THE TYPE OF ENTRY IS DETERMINED FROM THE SECOND TITLE LINE OF THE      */\n04830000    /*      PAGE ON WHICH THE ENTRY LISTING BEGINS.  A COMPLETELY BLANK LINE IS    */\n04840000    /*      NOT PART OF AN ENTRY LISTING, AND IS DISCARDED.  ON NON-BLANK LINES,   */\n04850000    /*      THE ENTRY NAME, LINE TYPE, AND LINE DATA AREAS HAVE A MAJOR TO MINOR   */\n04860000    /*      RELATIONSHIP WITHIN AN ENTRY LISTING.  THE ENTRY NAME FIELD CONTAINS   */\n04870000    /*      THE NAME OF THE ENTRY.  IF THE ENTRY NAME FIELD IS NON-BLANK, IT       */\n04880000    /*      SIGNALS THE START OF A NEW ENTRY LISTING.  IF BLANK, THE LINE IS A     */\n04890000    /*      CONTINUATION OF THE CURRENT ENTRY LISTING.  THE LINE TYPE FIELD        */\n04900000    /*      CATEGORIZES THE INFORMATION BEING LISTED ABOUT THE ENTRY.  WHEN THIS   */\n04910000    /*      AREA IS BLANK THE INFORMATION IN THE LINE DATA AREA IS IN THE SAME     */\n04920000    /*      CATEGORY AS THAT ON THE PRECEEDING LINE.  SOMETIMES SMP/E WILL PLACE   */\n04930000    /*      CHARACTERS IN THE ENDING POSITIONS OF THE LINE TYPE FIELD, LEAVING     */\n04940000    /*      THE BEGINNING BLANK.  IN THESE SITUATIONS IT MADE SENSE TO PROPAGATE   */\n04950000    /*      THE NON-BLANK DATA FROM THE PRECEEDING LINE TYPE VALUE.  AN EXAMPLE    */\n04960000    /*      OF THIS SITUATION OCCURS WITH \"DATA/TIME\" LINES.  APPLIED SYSMODS IN   */\n04970000    /*      A TARGET ZONE WILL HAVE A \"DATA/TIME REC\" LINE FOLLOWED BY AN          */\n04980000    /*      \"__________INS\" LINE.  SMPSCAN LOGIC SIMPLY CARRIES FORWARD THE        */\n04990000    /*      LEADING VALUE SO THAT THE LINE TYPE BECOMES \"DATE/TIME INS\".  THE      */\n05000000    /*      EQUALS SIGN AREA VISUALLY SEPARATES THE LINE TYPE AREA FROM THE LINE   */\n05010000    /*      DATA AREA, BUT OTHERWISE ISN'T SIGNIFICANT.  THE LINE DATA AREA        */\n05020000    /*      GENERALLY CONTAINS THE ELEMENTS WITHIN THE LINE TYPE CATEGORY.         */\n05030000    /*      EXAMPLES INCLUDE THE LISTS OF ELEMENTS AFFECTED BY A SYSMOD (MACROS,   */\n05040000    /*      MODULES), THE DATE AND TIME A SYSMOD WAS RECEIVED OR INSTALLED,        */\n05050000    /*      HOLDDATA INFORMATION, AND ASSEMBLER INPUT FOR ASSEMBLER ENTRIES.       */\n05060000    /*      SOMETIMES THE LINE TYPE AREA WILL IMPLY A SPECIAL TYPE OF LAYOUT FOR   */\n05070000    /*      THE INFORMATION PRINTED IN THE LINE DATA AREA.                         */\n05080000    /*                                                                             */\n05090000    /*            TO PROVIDE THE FACILITIES NEEDED FOR EFFECTIVE SEARCHING OF      */\n05100000    /*      LISTING LINES, FOUR GROUPS OF COMPARE AND SCAN OPERATIONS ARE          */\n05110000    /*      DEFINED:                                                               */\n05120000    /*                                                                             */\n05130000    /*             .ENTRY TYPE COMPARES.  THESE OPERATIONS TEST THE TYPE OF        */\n05140000    /*              ENTRY LISTED.  ENTRY TYPE IS DETERMINED FROM THE SECOND        */\n05150000    /*              TITLE LINE AND IS NOT PART OF THE ENTRY'S LISTING.             */\n05160000    /*                                                                             */\n05170000    /*             .LINE TYPE COMPARES.  THESE OPERATIONS TEST THE CONTENTS OF     */\n05180000    /*              THE SMPSCAN-CALCULATED LINE TYPE FIELD STORED SEPARATELY FOR   */\n05190000    /*              THE LINE.  SMPSCAN LOGICALLY CARRIES FORWARD LINE TYPE         */\n05200000    /*              INFORMATION FROM A PREVIOUS LINE IF THIS AREA OF THE CURRENT   */\n05210000    /*              LINE IS BLANK.  THE CONTENTS OF THE CURRENT LINE ARE NOT       */\n05220000    /*              CHANGED.  BECAUSE SMP/E USES A CARRY-FORWARD LOGIC FOR         */\n05230000    /*              FORMATTING THIS VALUE (ALL-BLANKS AND LEADING BLANKS), THESE   */\n05240000    /*              OPERATIONS ARE PROCESSED AS \"PREFIX\" COMPARES.     THE LINE    */\n05250000    /*              TYPE FIELD IS COMPARED ONLY UP TO THE LENGTH OF THE            */\n05260000    /*              SCAN_ARRAY \"STRING\", AND \"STRING\" IS NOT EXTENDED ON THE       */\n05270000    /*              RIGHT WITH BLANKS.  BOTH NORMAL (CHARACTER-BY-CHARACTER) AND   */\n05280000    /*              GENERIC COMPARE OPERATIONS ARE PROVIDED.                       */\n05290000    /*                                                                             */\n05300000    /*             .LINE DATA COMPARES.  THESE OPERATIONS EXAMINE DATA ON THE      */\n05310000    /*              LISTING LINE.  PROGRAM DEFAULTS ARE SET TO COMPARE AT THE      */\n05320000    /*              BEGINNING OF THE LINE DATA AREA (029), BUT LOCATIONS           */\n05330000    /*              ANYWHERE ON THE LINE CAN BE COMPARED, INCLUDING THE ENTRY      */\n05340000    /*              NAME AND LINE TYPE AREAS.  THE COMPARISON IS DONE ONCE, AT     */\n05350000    /*              THE LINE POSITION DESIGNATED IN SCAN_ARRAY VARIABLE            */\n05360000    /*              \"BEG_POS\" (SEE BELOW).  LINE DATA COMPARES DIFFER FROM LINE    */\n05370000    /*              TYPE COMPARES IN TWO WAYS:  LINE DATA COMPARES ARE NOT         */\n05380000    /*              PREFIX COMPARES, A FIELD LENGTH LONGER THAN THE STRING         */\n05390000    /*              LENGTH IS NOT IMPLIED, AND LINE DATA COMPARES ARE NOT          */\n05400000    /*              LIMITED TO THE LINE DATA FIELD, DATA ANYWHERE ON THE LINE      */\n05410000    /*              CAN BE COMPARED.  BOTH NORMAL AND GENERIC COMPARE OPERATIONS   */\n05420000    /*              ARE PROVIDED.                                                  */\n05430000    /*                                                                             */\n05440000    /*             .LINE DATA SCANS.  THESE OPERATIONS EXAMINE THE DATA ON THE     */\n05450000    /*              LISTING LINE FOR ONE OR MORE OCCURRENCES OF A CHARACTER        */\n05460000    /*              STRING.  PROGRAM DEFAULTS ARE SET TO SCAN THE BOUNDS OF THE    */\n05470000    /*              LINE DATA AREA (029-120), BUT DATA ANYWHERE ON THE LINE CAN    */\n05480000    /*              BE SCANNED.  TO REDUCE EXECUTION OVERHEAD, THE FIRST           */\n05490000    /*              OCCURRENCE OF A STRING STOPS THE SCAN WHEN TESTING LINES,      */\n05500000    /*              BUT ALL OCCURRENCES WILL BE UNDERSCORED IF THE ENTRY IS        */\n05510000    /*              WRITTEN WITH HIGHLIGHTED OUTPUT.  SCAN OPERATIONS RESEMBLE     */\n05520000    /*              EDIT PROCESSOR \"FIND\" COMMANDS, EXCEPT THAT THE SCAN           */\n05530000    /*              OPERATION IS RESTRICTED TO A SINGLE LINE.  BOTH NORMAL AND     */\n05540000    /*              GENERIC SCAN OPERATIONS ARE SUPPORTED.                         */\n05550000    /*                                                                             */\n05560000    /*            SCAN_ARRAY IS DECLARED WITHIN SMPSCAN AS A FOUR DIMENSIONAL      */\n05570000    /*      ARRAY OF STRUCTURES, WITH EACH FILE HAVING A CORRESPONDING             */\n05580000    /*      CROSS-SECTION.  THE FIRST SCAN_ARRAY SUBSCRIPT CORRESPONDS TO THE      */\n05590000    /*      FILE NUMBER (FILE#) WITHIN SMPSCAN, AND THE REMAINING SUBSCRIPTS       */\n05600000    /*      DESIGNATE THE PLANE, ROW, AND COLUMN NUMBERS WITHIN SCAN_ARRAY FOR     */\n05610000    /*      THAT FILE.  EACH FILE'S CROSS SECTION OF SCAN_ARRAY CAN BE THOUGHT     */\n05620000    /*      OF AS A CUBE.  A CUBE IS MADE UP OF PLANES WHICH IN TURN ARE MADE UP   */\n05630000    /*      OF LINES (ROWS) WHICH ARE MADE UP OF POINTS (COLUMNS).  THE            */\n05640000    /*      SCAN_ARRAY WAS DESIGNED AS AN ALTERNATIVE TO TRYING TO DESIGN A        */\n05650000    /*      BOOLEAN ALGEBRA SYNTAX FOR SEARCHING THE LISTING LINES OF AN ENTRY     */\n05660000    /*      FOR CHARACTER STRINGS.  THE PLANE AND ROW DIMENSIONS WERE SET UP TO    */\n05670000    /*      PROVIDE \"LOGICAL OR(PLANE)\" AND \"LOGICAL AND(ROW)\" CAPABILITY, WHILE   */\n05680000    /*      THE COLUMN DIMENSION PROVIDES FOR MULTIPLE CHARACTER STRING TESTS      */\n05690000    /*      AGAINST THE SAME LINE.  NEGATION CAPABILITY IS ALSO PROVIDED AT EACH   */\n05700000    /*      LEVEL WITHIN A FILE'S CROSS-SECTION SO THAT DE_MORGAN'S RULES          */\n05710000    /*      RELATING \"LOGICAL AND\" AND \"LOGICAL OR\":                               */\n05720000    /*                                                                             */\n05730000    /*           \u00ac(A & B) = \u00acA | \u00acB      (\"|\" IS THE PLI SYMBOL FOR \"OR\")          */\n05740000    /*           \u00ac(A | B) = \u00acA & \u00acB      (\"&\" IS THE PLI SYMBOL FOR \"AND\")         */\n05750000    /*                                                                             */\n05760000    /*      ALONG WITH SOME OF THEIR USEFUL CONSEQUENCES USING DOUBLE NEGATION     */\n05770000    /*      TO EXCHANGE THE ROLES OF \"AND\" AND \"OR\":                               */\n05780000    /*                                                                             */\n05790000    /*            (A & B) = \u00ac(\u00acA | \u00acB)                                             */\n05800000    /*            (A | B) = \u00ac(\u00acA & \u00acB)                                             */\n05810000    /*                                                                             */\n05820000    /*           (\u00acA & B) = \u00ac( A | \u00acB)                                             */\n05830000    /*           (\u00acA | B) = \u00ac( A & \u00acB)                                             */\n05840000    /*                                                                             */\n05850000    /*      AND THE IDENTITY:                                                      */\n05860000    /*                                                                             */\n05870000    /*               A    =   \u00ac(\u00acA)                                                */\n05880000    /*                                                                             */\n05890000    /*      CAN BE USED TO USED TO ADVANTAGE.  NEGATION CAPABILITY ALSO ALLOWS     */\n05900000    /*      ENTRIES TO BE SELECTED BASED ON CONDITIONS THAT AREN'T SATISFIED       */\n05910000    /*      (E.G., TO FIND A SYSMOD THAT DOES CONTAIN JCLIN OR REFERENCES A        */\n05920000    /*      SYSGEN MACRO, BUT THAT DOESN'T BELONG TO A PARTICULAR FMID).           */\n05930000    /*                                                                             */\n05940000    /*            THE STRUCTURAL DECLARATION OF SCAN_ARRAY IS AS FOLLOWS:          */\n05950000    /*                                                                             */\n05960000    /*            01 SCAN_ARRAY                           CONTROLLED,              */\n05970000    /*               05 FILE(IFILE_MIN:IFILE_MAX),       -ONE CUBE FOR EACH FILE-  */\n05980000    /*                  09 SELECT_OPTION                  CHAR(008) VARYING,       */\n05990000    /*                  09 PLANE(IPLANE_MIN:IPLANE_MAX),                           */\n06000000    /*                     13 SELECT_OPTION               CHAR(008) VARYING,       */\n06010000    /*                     13 ROW(IROW_MIN:IROW_MAX),                              */\n06020000    /*                        17 SELECT_OPTION            CHAR(008) VARYING,       */\n06030000    /*                        17 COL(ICOL_MIN:ICOL_MAX),                           */\n06040000    /*                           21 BEG_POS               FIXED BINARY(15,0),      */\n06050000    /*                           21 END_POS               FIXED BINARY(15,0),      */\n06060000    /*                           21 POS_LEN               FIXED BINARY(15,0),      */\n06070000    /*                           21 OP                    CHAR(008) VARYING,       */\n06080000    /*                           21 OP_OIX                FIXED BINARY(15,0),      */\n06090000    /*                           21 STRING                CHAR(032) VARYING,       */\n06100000    /*                           21 STR_LEN               FIXED BINARY(15,0),      */\n06110000    /*                           21 STR_NIX               FIXED BINARY(15,0),      */\n06120000    /*                                                                             */\n06130000    /*      IF SCAN_ARRAY VARIABLES ARE SPECIFIED FOR A FILE, A \"SCAN_RESULT\"      */\n06140000    /*      IS CALCULATED FOR EACH ENTRY PROCESSED (SEE THE DESCRIPTION OF         */\n06150000    /*      MATCH_ARRAY FOR AN EXPLANATION OF WHEN ENTRIES ARE PROCESSED).         */\n06160000    /*      THREE RESULTS ARE RECOGNIZED IN SMPDCTRY OUTPUT:  SCANNED AND          */\n06170000    /*      SELECTED, SCANNED AND NOT SELECTED, AND NOT SCANNED.  FOR THE          */\n06180000    /*      PURPOSES OF ENTRY MATCHING, HOWEVER, SCANNED AND NOT SELECTED IS       */\n06190000    /*      EQUIVALENT TO NOT SCANNED.  THE \"SCAN_RESULT\" CALCULATION IS A THREE   */\n06200000    /*      STEP PROCESS:                                                          */\n06210000    /*                                                                             */\n06220000    /*           1. WHEN THE FIRST LINE OF A NEW ENTRY IS RECOGNIZED, ALL OF THE   */\n06230000    /*              SCAN_ARRAY ROW RESULTS ARE SET TO '0'B ('0'B = FALSE OR        */\n06240000    /*              NOT SELECTED, '1'B = TRUE OR SELECTED).                        */\n06250000    /*                                                                             */\n06260000    /*           2. A SCAN_ARRAY PLANE OR ROW IS CONSIDERED ACTIVE IF ANY COLUMN   */\n06270000    /*              SUBSTRUCTURE CONTAINS A \"STRING\" VALUE.  AS ENTRY LINES ARE    */\n06280000    /*              READ, EACH ACTIVE ROW IN EACH ACTIVE PLANE IS REVIEWED.  IF    */\n06290000    /*              THE ROW RESULT IS ALREADY SET TO '1'B, TESTS FOR THAT ROW      */\n06300000    /*              ARE SKIPPED (FOR SCANNING BUT NOT FOR HIGHLIGHTING) TO         */\n06310000    /*              REDUCE EXECUTION OVERHEAD.  WHEN THE RESULT FOR AN ACTIVE      */\n06320000    /*              ROW IS NOT YET SET TO '1'B, THE COLUMN SUBSTRUCTURES ARE       */\n06330000    /*              PROCESSED AGAINST THE CURRENT LINE, AND A ROW RESULT IS        */\n06340000    /*              CALCULATED.                                                    */\n06350000    /*                                                                             */\n06360000    /*              THE ROW-COLUMN STRUCTURING IS DESIGNED TO PROVIDE A WAY TO     */\n06370000    /*              DESCRIBE SEPARATE MULTIPLE TESTS AGAINST THE SAME LINE.  THE   */\n06380000    /*              TESTS FOR ALL ACTIVE COLUMNS IN A ROW MUST BE SATISFIED        */\n06390000    /*              AGAINST THE SAME LINE IN ORDER FOR A POSITIVE ROW RESULT TO    */\n06400000    /*              OCCUR.                                                         */\n06410000    /*                                                                             */\n06420000    /*           3. ONCE ALL LINES FOR AN ENTRY HAVE BEEN READ AND ROW RESULTS     */\n06430000    /*              HAVE BEEN DETERMINED, CALCULATION OF THE FINAL SCAN_RESULT     */\n06440000    /*              FOR THE ENTRY BEGINS.  A ROW'S RESULT IS FIRST COMPARED WITH   */\n06450000    /*              ITS SELECT_OPTION.  IF EACH ACTIVE ROW'S RESULT IS THE SAME    */\n06460000    /*              AS ITS SELECT_OPTION, THE PLANE'S RESULT IS SET TO '1'B.       */\n06470000    /*              OTHERWISE, THE PLANE'S SCAN_RESULT IS SET TO '0'B.  A          */\n06480000    /*              SCAN_RESULT MATCHES ITS CORRESPONDING SELECT_OPTION IF         */\n06490000    /*              EITHER THE RESULT IS '1'B AND THE OPTION IS \"SELECT\", OR THE   */\n06500000    /*              RESULT IS '0'B AND THE OPTION IS \"EXCLUDE\".  IN EFFECT, THE    */\n06510000    /*              FINAL RESULTS FOR THE ACTIVE ROWS ARE \"ANDED\" TOGETHER.        */\n06520000    /*                                                                             */\n06530000    /*              ONCE THE PLANE RESULTS HAVE BEEN DETERMINED, THE FILE (CUBE)   */\n06540000    /*              RESULT IS CALCULATED.  EACH ACTIVE PLANE'S RESULT IS           */\n06550000    /*              COMPARED WITH ITS CORRESPONDING SELECT_OPTION.  IF ANY         */\n06560000    /*              ACTIVE PLANE'S RESULT MATCHES ITS SELECT_OPTION, THE ENTRY'S   */\n06570000    /*              FILE (CUBE) SCAN_RESULT IS SET TO '1'B.  OTHERWISE IT IS SET   */\n06580000    /*              TO '0'B.  IN EFFECT, THE FINAL PLANE RESULTS ARE \"ORED\"        */\n06590000    /*              TOGETHER.                                                      */\n06600000    /*                                                                             */\n06610000    /*              THE FILE SCAN_RESULT IS THE NEXT-TO-LAST STEP IN CALCULATING   */\n06620000    /*              THE ENTRY'S SCAN_RESULT.  THE FILE RESULT IS COMPARED WITH     */\n06630000    /*              THE SELECT_OPTION AT THE FILE LEVEL.  IF THEY AGREE, THE       */\n06640000    /*              FINAL SCAN_RESULT FOR THE ENTRY IS SET TO '1'B, OTHERWISE      */\n06650000    /*              '0'B.                                                          */\n06660000    /*                                                                             */\n06670000    /*              THE FILE-PLANE-ROW STRUCTURE IS DESIGNED TO PROVIDE A WAY TO   */\n06680000    /*              DESCRIBE NOT/OR/AND OPERATIONS TO BE APPLIED TO THE ROW        */\n06690000    /*              RESULTS OBTAINED FROM EXAMINING AN ENTRY'S LISTING LINES.  A   */\n06700000    /*              FULL BOOLEAN EXPRESIION CAN BE CONSTRUCTED, ALTHOUGH SOME      */\n06710000    /*              DUPLICATION MAY BE REQUIRED.  SELECT OPTIONS CORRESPOND TO     */\n06720000    /*              \"NOT\", PLANES TO \"OR\", AND ROWS TO \"AND\".                      */\n06730000    /*                                                                             */\n06740000    /*      AN ENTRY'S FINAL SCAN_RESULT IS PART OF THE INFORMATION USED BY        */\n06750000    /*      MATCH_ARRAY PROCESSING TO DECIDE WHICH ENTRIES SHOULD BE WRITTEN TO    */\n06760000    /*      OUTPUT DATA SETS.                                                      */\n06770000    /*                                                                             */\n06780000    /*            THE SCAN_ARRAY VARIABLES THAT CAN BE SUPPLIED IN THE \"SYSIN\"     */\n06790000    /*      DATA STREAM ARE LISTED ABOVE IN THE INPUT SECTION.  IF USED, THEY      */\n06800000    /*      SHOULD BE SPECIFIED WITH REQUIRED LEVELS OF QUALIFICATION AND          */\n06810000    /*      SUBSCRIPTS AS SHOWN THERE.  NOT ALL SCAN_ARRAY VARIABLES CAN BE        */\n06820000    /*      SPECIFIED:  SOME, SUCH AS STR_LEN, AND STR_NIX ARE CALCULATED AFTER    */\n06830000    /*      ALL VARIABLES HAVE BEEN READ, AND POS_LEN IS USUALLY ALLOWED TO        */\n06840000    /*      DEFAULT.  THE VARIABLES THAT CAN BE SUPPLIED, ALONG WITH THEIR         */\n06850000    /*      DEFAULT VALUES ARE:                                                    */\n06860000    /*                                                                             */\n06870000    /*             .SELECT_OPTION.  THE SELECT OPTIONS CAN BE SPECIFIED AT THE     */\n06880000    /*              FILE, PLANE AND ROW LEVELS AND INDICATE NEGATION IF            */\n06890000    /*              REQUESTED.  THE VALUES THAT CAN BE SPECIFIED ARE:              */\n06900000    /*                                                                             */\n06910000    /*                 'SELECT'                                                    */\n06920000    /*                 'EXCLUDE'                                                   */\n06930000    /*                                                                             */\n06940000    /*              THE DEFAULT SPECIFICATION IS \"SELECT\".  A VALUE OF \"EXCLUDE\"   */\n06950000    /*              REQUESTS NEGATION.  THE EFFECTS OF THESE VARIABLES IN          */\n06960000    /*              COMPUTING THE LINE SCAN RESULTS FOR AN INDIVIDUAL ENTRY        */\n06970000    /*              ARE DESCRIBED BELOW.                                           */\n06980000    /*                                                                             */\n06990000    /*             .BEG_POS.  THE BEG_POS VARIABLE IS A NUMBER INDICATING THE      */\n07000000    /*              STARTING POSITION WITHIN THE LISTING LINE AT WHICH             */\n07010000    /*              COMPARISON IS TO BE PERFORMED OR SCANNING IS TO BEGIN.  THIS   */\n07020000    /*              NUMBER IS ASSIGNED EXCLUSIVE OF THE PRINT CONTROL CHARACTER,   */\n07030000    /*              WITH THE LEFTMOST PRINTED CHARACTER BEING 001.  THE DEFAULT    */\n07040000    /*              VALUE DEPENDS ON THE TYPE OF OPERATION (SEE \"OP\") AS           */\n07050000    /*              FOLLOWS:                                                       */\n07060000    /*                                                                             */\n07070000    /*                -ENTRY TYPE COMPARE:   IGNORED IF PROVIDED.  NOT USED.       */\n07080000    /*                                                                             */\n07090000    /*                -LINE  TYPE COMPARE:   IGNORED IF PROVIDED.  SET TO 011.     */\n07100000    /*                                                                             */\n07110000    /*                -LINE  DATA COMPARE:   029.                                  */\n07120000    /*                                                                             */\n07130000    /*                -LINE  DATA    SCAN:   029.                                  */\n07140000    /*                                                                             */\n07150000    /*              BEG_POS CAN DESIGNATE ANY POSITION ON THE LINE: 001 - 120,     */\n07160000    /*              BUT SHOULD BE LESS THAN OR EQUAL IN VALUE TO END_POS.          */\n07170000    /*                                                                             */\n07180000    /*             .END_POS.  THE END_POS VARIABLE IS A NUMBER INDICATING THE      */\n07190000    /*              ENDING POSITION WITHIN THE LISTING LINE AT WHICH COMPARISON    */\n07200000    /*              IS TO BE PERFORMED OR SCANNING IS TO BEGIN.  THIS NUMBER IS    */\n07210000    /*              ASSIGNED EXCLUSIVE OF THE PRINT CONTROL CHARACTER, WITH THE    */\n07220000    /*              LEFTMOST PRINTED CHARACTER BEING 001.  THE DEFAULT VALUE       */\n07230000    /*              DEPENDS ON THE TYPE OF OPERATION (SEE \"OP\") AS FOLLOWS:        */\n07240000    /*                                                                             */\n07250000    /*                -ENTRY TYPE COMPARE:   IGNORED IF PROVIDED. NOT USED.        */\n07260000    /*                                                                             */\n07270000    /*                -LINE  TYPE COMPARE:   IGNORED IF PROVIDED.  SET TO          */\n07280000    /*                                       BEG_POS+STR_LEN-1 OR 025,             */\n07290000    /*                                       WHICHEVER IS LESS.                    */\n07300000    /*                                                                             */\n07310000    /*                -LINE  DATA COMPARE:   BEG_POS+STR_LEN-1 OR 120,             */\n07320000    /*                                       WHICHEVER IS LESS.                    */\n07330000    /*                                                                             */\n07340000    /*                -LINE  DATA    SCAN:   120.                                  */\n07350000    /*                                                                             */\n07360000    /*              END_POS CAN DESIGNATE ANY POSITION ON THE LINE: 001 - 120,     */\n07370000    /*              BUT SHOULD BE GREATER THAN OR EQUAL IN VALUE TO BEG_POS.       */\n07380000    /*                                                                             */\n07390000    /*             .POS_LEN.  THE POS_LEN VARIABLE IS A NUMBER INDICATING THE      */\n07400000    /*              NUMBER OF PRINT POSTITONS BETWEEN BEG_POS AND END_POS.         */\n07410000    /*              POS_LEN CAN BE SPECIFIED IN LIEU OF END_POS, BUT IT IS         */\n07420000    /*              USUALLY ALLOWED TO DEFAULT.  IF POS_LEN IS PROVIDED RATHER     */\n07430000    /*              THAN END_POS, END_POS IS CALCULATED.  THE CALCULATED VALUE     */\n07440000    /*              FOR POS_LEN DEPENDS ON THE TYPE OF OPERATION (SEE \"OP\") AS     */\n07450000    /*              FOLLOWS:                                                       */\n07460000    /*                                                                             */\n07470000    /*                -ENTRY TYPE COMPARE:   IGNORED IF PROVIDED. NOT USED.        */\n07480000    /*                                                                             */\n07490000    /*                -LINE  TYPE COMPARE:   IGNORED IF PROVIDED.  SET TO          */\n07500000    /*                                       END_POS-BEG_POS+1 OR 015,             */\n07510000    /*                                       WHICHEVER IS LESS.                    */\n07520000    /*                                                                             */\n07530000    /*                -LINE  DATA COMPARE:   END_POS-BEG_POS+1 OR STR_LEN,         */\n07540000    /*                                       WHICHEVER IS LESS.                    */\n07550000    /*                                                                             */\n07560000    /*                -LINE  DATA    SCAN:   END_POS-BEG_POS+1 OR 120,             */\n07570000    /*                                       WHICHEVER IS LESS.                    */\n07580000    /*                                                                             */\n07590000    /*              POS_LEN IS RECALCULATED AFTER THE FINAL VALUES FOR             */\n07600000    /*              BEG_POS AND END_POS HAVE BEEN DETERMINED.                      */\n07610000    /*                                                                             */\n07620000    /*             .OP.  THIS VARIABLE GOVERNS HOW THE \"STRING\" IS COMPARED WITH   */\n07630000    /*              THE ENTRY'S LISTING LINE WITHIN THE BOUNDS DEFINED BY          */\n07640000    /*              BEG_POS AND END_POS.  IN EACH GROUP OF COMPARE/SCAN            */\n07650000    /*              OPERATIONS, SEVERAL COMPARISON OPERATORS ARE DEFINED.  FOR     */\n07660000    /*              THREE OF THE FOUR, GENERIC COMPARISONS CAN ALSO BE             */\n07670000    /*              PERFORMED.  THE OPERATIONS SUPPORTED WITHIN EACH GROUP ARE     */\n07680000    /*              AS FOLLOWS:                                                    */\n07690000    /*                                                                             */\n07700000    /*                -ENTRY TYPE COMPARE:                                         */\n07710000    /*                            EQENTRY:   THE ENTRY TYPE MUST BE THE SAME AS    */\n07720000    /*                                       THAT SPECIFIED IN \"STRING\".           */\n07730000    /*                            NEENTRY:   THE ENTRY TYPE MUST NOT BE THE SAME   */\n07740000    /*                                       AS THAT SPECIFIED IN \"STRING\".        */\n07750000    /*                   EQENTRY SYNONYMS:   EQNTRY,     EQN.                      */\n07760000    /*                   NEENTRY SYNONYMS:   NENTRY,     NEN,                      */\n07770000    /*                                      \u00acEQENTRY,   \u00acEQNTRY,  \u00acEQN.            */\n07780000    /*                                                                             */\n07790000    /*                -LINE  TYPE COMPARE:                                         */\n07800000    /*                             EQLINE:   THE LINE TYPE, FOR THE NUMBER OF      */\n07810000    /*                                       CHARACTERS IN \"STRING\" (I.E., A       */\n07820000    /*                                       PREFIX COMPARISON IS DONE) MUST BE    */\n07830000    /*                                       THE SAME AS THAT SPECIFIED IN         */\n07840000    /*                                       \"STRING\".                             */\n07850000    /*                             NELINE:   THE LINE TYPE, FOR THE NUMBER OF      */\n07860000    /*                                       CHARACTERS IN \"STRING\" (I.E., A       */\n07870000    /*                                       PREFIX COMPARISON IS DONE) MUST NOT   */\n07880000    /*                                       BE THE SAME AS THAT SPECIFIED IN      */\n07890000    /*                                       \"STRING\".                             */\n07900000    /*                            EQGLINE:   THE LINE TYPE, FOR THE NUMBER OF      */\n07910000    /*                                       CHARACTERS IN \"STRING\" (I.E., A       */\n07920000    /*                                       PREFIX COMPARISON IS DONE) MUST       */\n07930000    /*                                       GENERICALLY COMPARE EQUAL TO THE      */\n07940000    /*                                       VALUE SPECIFIED IN \"STRING\".          */\n07950000    /*                            NEGLINE:   THE LINE TYPE, FOR THE NUMBER OF      */\n07960000    /*                                       CHARACTERS IN \"STRING\" (I.E., A       */\n07970000    /*                                       PREFIX COMPARISON IS DONE) MUST       */\n07980000    /*                                       GENERICALLY COMPARE NOT EQUAL TO      */\n07990000    /*                                       THE VALUE SPECIFIED IN \"STRING\".      */\n08000000    /*                    EQLINE SYNONYMS:    EQLIN,    EQL.                       */\n08010000    /*                    NELINE SYNONYMS:    NELIN,    NEL,                       */\n08020000    /*                                       \u00acEQLINE,  \u00acEQLIN,    \u00acEQL.            */\n08030000    /*                   EQGLINE SYNONYMS:    EQGLIN,   EQGL.                      */\n08040000    /*                   NEGLINE SYNONYMS:    NEGLIN,   NEGL,                      */\n08050000    /*                                       \u00acEQGLINE, \u00acEQGLIN,   \u00acEQGL.           */\n08060000    /*                                                                             */\n08070000    /*                -LINE  DATA COMPARE:                                         */\n08080000    /*                             LTCMPR:   THE CHARACTER STRING IN THE ENTRY     */\n08090000    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */\n08100000    /*                                       LESS THAN THE VALUE  SPECIFIED IN     */\n08110000    /*                                       \"STRING\".                             */\n08120000    /*                             LECMPR:   THE CHARACTER STRING IN THE ENTRY     */\n08130000    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */\n08140000    /*                                       LESS THAN OR EQUAL TO THE VALUE       */\n08150000    /*                                       SPECIFIED IN \"STRING\".                */\n08160000    /*                             EQCMPR:   THE CHARACTER STRING IN THE ENTRY     */\n08170000    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */\n08180000    /*                                       EQUAL TO THE VALUE SPECIFIED IN       */\n08190000    /*                                       \"STRING\".                             */\n08200000    /*                             NECMPR:   THE CHARACTER STRING IN THE ENTRY     */\n08210000    /*                                       LINE, STARTING AT BEG_POS, MUST NOT   */\n08220000    /*                                       BE EQUAL TO THE VALUE SPECIFIED IN    */\n08230000    /*                                       \"STRING\".                             */\n08240000    /*                             GECMPR:   THE CHARACTER STRING IN THE ENTRY     */\n08250000    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */\n08260000    /*                                       GREATER THAN OR EQUAL TO THE VALUE    */\n08270000    /*                                       SPECIFIED IN \"STRING\".                */\n08280000    /*                             GTCMPR:   THE CHARACTER STRING IN THE ENTRY     */\n08290000    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */\n08300000    /*                                       GREATER THAN THE VALUE SPECIFIED IN   */\n08310000    /*                                       \"STRING\".                             */\n08320000    /*                            EQGCMPR:   THE CHARACTER STRING IN THE ENTRY     */\n08330000    /*                                       LINE, STARTING AT BEG_POS, MUST       */\n08340000    /*                                       GENERICALLY COMPARE EQUAL TO THE      */\n08350000    /*                                       VALUE SPECIFIED IN \"STRING\".          */\n08360000    /*                            NEGCMPR:   THE CHARACTER STRING IN THE ENTRY     */\n08370000    /*                                       LINE, STARTING AT BEG_POS, MUST       */\n08380000    /*                                       GENERICALLY COMPARE NOT EQUAL TO      */\n08390000    /*                                       THE VALUE SPECIFIED IN \"STRING\".      */\n08400000    /*                    LTCMPR SYNONYMS:   LTCPR,    LTC,      LT,               */\n08410000    /*                                      \u00acGECMPR,  \u00acGECPR,   \u00acGEC,    \u00acGE.      */\n08420000    /*                    LECMPR SYNONYMS:   LECPR,    LEC,      LE,               */\n08430000    /*                                      \u00acGTCMPR,  \u00acGTCPR,   \u00acGTC,    \u00acGT.      */\n08440000    /*                    EQCMPR SYNONYMS:   EQCPR,    EQC,      EQ.               */\n08450000    /*                    NECMPR SYNONYMS:   NECPR,    NEC,      NE,               */\n08460000    /*                                      \u00acEQCMPR,  \u00acEQCPR,   \u00acEQC,    \u00acEQ.      */\n08470000    /*                    GECMPR SYNONYMS:   GECPR,    GEC,      GE,               */\n08480000    /*                                      \u00acLTCMPR,  \u00acLTCPR,   \u00acLTC,    \u00acLT.      */\n08490000    /*                    GTCMPR SYNONYMS:   GTCPR,    GTC,      GT,               */\n08500000    /*                                      \u00acLECMPR,  \u00acLECPR,   \u00acLEC,    \u00acLE.      */\n08510000    /*                   EQGCMPR SYNONYMS:   EQGCPR,   EQGC,     EQG.              */\n08520000    /*                   NEGCMPR SYNONYMS:   NEGCPR,   NEGC,     NEG,              */\n08530000    /*                                      \u00acEQGCPR,  \u00acEQGC,     \u00acEQG.             */\n08540000    /*                                                                             */\n08550000    /*                -LINE  DATA    SCAN:                                         */\n08560000    /*                             EQSCAN:   THE CHARACTERS IN THE ENTRY LINE      */\n08570000    /*                                       BETWEEN BEG_POS AND END_POS MUST      */\n08580000    /*                                       CONTAIN AT LEAST ONE SUBSTRING        */\n08590000    /*                                       EQUAL TO THE VALUE SPECIFIED IN       */\n08600000    /*                                       \"STRING\".  SUBSTRINGS ARE EXAMINED    */\n08610000    /*                                       STARTING AT BEG_POS AND STOPPING AT   */\n08620000    /*                                       (END_POS-STR_LEN+1).                  */\n08630000    /*                             NESCAN:   THE CHARACTERS IN THE ENTRY LINE      */\n08640000    /*                                       BETWEEN BEG_POS AND END_POS MUST      */\n08650000    /*                                       NOT CONTAIN ANY SUBSTRING EQUAL TO    */\n08660000    /*                                       THE VALUE SPECIFIED IN \"STRING\".      */\n08670000    /*                                       SUBSTRINGS ARE EXAMINED STARTING AT   */\n08680000    /*                                       BEG_POS AND STOPPING AT               */\n08690000    /*                                       (END_POS-STR_LEN+1).                  */\n08700000    /*                            EQGSCAN:   THE CHARACTERS IN THE ENTRY LINE      */\n08710000    /*                                       BETWEEN BEG_POS AND END_POS MUST      */\n08720000    /*                                       CONTAIN AT LEAST ONE SUBSTRING        */\n08730000    /*                                       GENERICALLY EQUAL TO THE VALUE        */\n08740000    /*                                       SPECIFIED IN \"STRING\".  SUBSTRINGS    */\n08750000    /*                                       ARE EXAMINED STARTING AT BEG_POS      */\n08760000    /*                                       AND STOPPING AT                       */\n08770000    /*                                       (END_POS-STR_LEN+1).                  */\n08780000    /*                            NEGSCAN:   THE CHARACTERS IN THE ENTRY LINE      */\n08790000    /*                                       BETWEEN BEG_POS AND END_POS MUST      */\n08800000    /*                                       NOT CONTAIN ANY SUBSTRING             */\n08810000    /*                                       GENERICALLY EQUAL TO THE VALUE        */\n08820000    /*                                       SPECIFIED IN \"STRING\".  SUBSTRINGS    */\n08830000    /*                                       ARE EXAMINED STARTING AT BEG_POS      */\n08840000    /*                                       AND STOPPING AT                       */\n08850000    /*                                       (END_POS-STR_LEN+1).                  */\n08860000    /*                    EQSCAN SYNONYMS:    EQSCN,    EQS.                       */\n08870000    /*                    NESCAN SYNONYMS:    NESCN,    NES,                       */\n08880000    /*                                       \u00acEQSCAN,  \u00acEQSCN,     \u00acEQS.           */\n08890000    /*                   EQGSCAN SYNONYMS:    EQGSCN,   EQGS.                      */\n08900000    /*                   NEGSCAN SYNONYMS:    NEGSCN,   NEGS,                      */\n08910000    /*                                       \u00acEQGSCAN, \u00acEQGSCN,    \u00acEQGS.          */\n08920000    /*                                                                             */\n08930000    /*              THE DEFAULT SPECIFICATION FOR \"OP\" IS \"EQSCAN\".                */\n08940000    /*                                                                             */\n08950000    /*             .STRING.  THIS IS THE CHARACTER STRING DATA WHOSE PRESENCE OR   */\n08960000    /*              ABSENCE IS BEING SOUGHT.  IT CAN HAVE A MAXIMUM LENGTH OF 32   */\n08970000    /*              BYTES.  A SCAN_ARRAY ELEMENT IS CONSIDERED ACTIVE ONLY IF A    */\n08980000    /*              CHARACTER STRING VALUE OF LENGTH GREATER THAN ZERO HAS BEEN    */\n08990000    /*              SPECIFIED (THE STRING CAN BE BLANK).  THE DATA PROVIDED FOR    */\n09000000    /*              \"STRING\" WILL DEPEND ON THE TYPE OF OPERATION (SEE \"OP\") AS    */\n09010000    /*              FOLLOWS:                                                       */\n09020000    /*                                                                             */\n09030000    /*                -ENTRY TYPE COMPARE:   NAMES A TYPE OF ENTRY (E.G.,          */\n09040000    /*                                       \"DDDEF\", \"ASSEM\", \"LMOD\", \"MOD\",      */\n09050000    /*                                       \"SYSMOD\").  A FULL LIST OF VALUES     */\n09060000    /*                                       APPEARS BELOW IN THE DESCRIPTION OF   */\n09070000    /*                                       \"TYPE\" FOR MATCH_ARRAY.  WITHIN       */\n09080000    /*                                       REASON, ABBREVIATIONS ARE             */\n09090000    /*                                       SUPPORTED.  TO REDUCE EXECUTION       */\n09100000    /*                                       OVERHEAD, THE ENTRY TYPE NAME IS      */\n09110000    /*                                       CONVERTED TO AN INTERNAL INDEX        */\n09120000    /*                                       VALUE (AND SAVED IN STR_NIX).  THE    */\n09130000    /*                                       INDEX VALUE IS USED FOR THE ACTUAL    */\n09140000    /*                                       TEST AGAINST THE LINE.                */\n09150000    /*                                                                             */\n09160000    /*                -LINE  TYPE COMPARE:   IDENTIFIES A TYPE OF LISTING LINE.    */\n09170000    /*                                       THE BEST WAY TO DETERMINE VALUES TO   */\n09180000    /*                                       USE IS TO EXAMINE AN ACTUAL SMP/E     */\n09190000    /*                                       LIST OUTPUT.                          */\n09200000    /*                                                                             */\n09210000    /*                -LINE  DATA COMPARE:   THE COMPARE ARGUMENT STRING FOR       */\n09220000    /*                                       REGULAR COMPARE OPERATIONS, OR THE    */\n09230000    /*                                       PATTERN STRING FOR GENERIC            */\n09240000    /*                                       COMPARES.                             */\n09250000    /*                                                                             */\n09260000    /*                -LINE  DATA    SCAN:   THE SCAN ARGUMENT STRING OR THE       */\n09270000    /*                                       PATTERN STRING, DEPENDING ON          */\n09280000    /*                                       WHETHER THE SCAN OPERATION IS OF      */\n09290000    /*                                       THE NORMAL VARIETY, OR GENERIC.       */\n09300000    /*                                                                             */\n09310000    /*              \"STRING\" HAS NO DEFAULT.  IF A STRING VALUE IS NOT PROVIDED,   */\n09320000    /*              THE SCAN_ARRAY COLUMN SUBSTRUCTURE IS NOT USED DURING ENTRY    */\n09330000    /*              PROCESSING.  IF A VALUE IS PROVIDED, ITS LENGTH DETERMINED     */\n09340000    /*              AND THEN SAVED IS SCAN_ARRAY VARIABLE STR_LEN.                 */\n09350000    /*                                                                             */\n09360000    /*            THE DISTINCTION BETWEEN THE \"NE\" COLUMN OPERATIONS AND A ROW     */\n09370000    /*      LEVEL SELECT_OPTION OF \"EXCLUDE\" NEEDS TO BE CLARIFIED.  COLUMN        */\n09380000    /*      OPERATIONS ARE USED TO TEST WHETHER A CONDITION OCCURS OR DOESN'T      */\n09390000    /*      OCCUR ON A GIVEN LINE.  ONCE A ROW TEST HAS BEEN SATISFIED FOR ANY     */\n09400000    /*      LINE OF AN ENTRY, HOWEVER, THE TEST IS SATISFIED FOR THE ENTRY.        */\n09410000    /*      CONSEQUENTLY, AN \"NE\" OPERATION MAY NOT RESULT IN ALL PERTINENT        */\n09420000    /*      LINES BEING TESTED.  TO VERIFY THAT A PARTICULAR VALUE DOES NOT        */\n09430000    /*      APPEAR ON ANY ENTRY LINE (I.E., THAT ALL PERTINENT LINES FAIL THE      */\n09440000    /*      TEST), USE A POSITIVE TEST SUCH AS \"EQ\" COMBINED WITH A ROW            */\n09450000    /*      SELECT_OPTION OF \"EXCLUDE\".  NEGATIVELY-EXPRESSED OPERATIONS ARE       */\n09460000    /*      GENERALLY USED IN COMBINATION WITH OTHER TESTS, OR WHEN THE DATA OF    */\n09470000    /*      INTEREST APPEAR ON ONLY ONE LISTING LINE.                              */\n09480000    /*                                                                             */\n09490000    /*            WHILE GENERIC SEARCH AND COMPARE FACILITIES ARE AVAILABLE IN A   */\n09500000    /*      VARIETY OF PROGRAMS AND PRODUCTS, THE GENERIC OPERATIONS PROVIDED IN   */\n09510000    /*      THE SCAN_ARRAY ARE MOST SIMILAR TO THE PICTURE STRING FEATURE OF THE   */\n09520000    /*      ISPF BROWSE AND EDIT COMMANDS.  A NOTE FOR THE LAWYERS - ISPF IS A     */\n09530000    /*      PROGRAM PRODUCT OF IBM.  WHEN GENERIC COMPARISON OR GENERIC SCANNING   */\n09540000    /*      IS REQUESTED, THE SCAN_ARRAY SEARCH STRING IS TREATED AS A MASK OR     */\n09550000    /*      PATTERN.  THE CHARACTER STRING FROM THE LISTING LINE BEING EXAMINED    */\n09560000    /*      IS COMPARED CHARACTER BY CHARACTER WITH THE PATTERN STRING FROM        */\n09570000    /*      SCAN_ARRAY, PROCESSING FROM LEFT TO RIGHT.  THE FIRST CHARACTER        */\n09580000    /*      STRING CHARACTER NOT SATISFYING THE REQUIREMENTS OF ITS PATTERN        */\n09590000    /*      STRING CHARACTER STOPS THE COMPARE AND GIVES A NOT-EQUAL RESULT.       */\n09600000    /*      WHEN ALL CORRESPONDING CHARACTERS ARE EQUAL, A CHARACTER STRING        */\n09610000    /*      LONGER THAN THE PATTERN STRING IS CHECKED TO VERIFY THAT BYTES         */\n09620000    /*      EXTENDING ON THE RIGHT BEYOND THE LENGTH OF THE PATTERN STRING ARE     */\n09630000    /*      BLANK.  LIKEWISE, A PATTERN STRING LONGER THAN THE CHARACTER STRING    */\n09640000    /*      IS ALSO CHECKED TO VERIFY THAT ALL BYTES EXTENDING ON THE RIGHT        */\n09650000    /*      BEYOND THE LENGTH OF THE CHARACTER STRING ARE EITHER BLANK, OR THE     */\n09660000    /*      \"ANY\" SELECTION BYTE(\"*\").                                             */\n09670000    /*                                                                             */\n09680000    /*            A GENERIC COMPARISON PATTERN CHARACTER REPRESENTS EITHER A       */\n09690000    /*      GROUP OF CHARACTERS, OR ITSELF.  BECAUSE CHARACTERS WITHIN A GROUP     */\n09700000    /*      WILL NOT, IN GENERAL, BE CONSECUTIVE WITHOUT GAPS IN THE COLLATING     */\n09710000    /*      SEQUENCE, A GENERIC COMPARISON ORDER IN TERMS OF HIGH, LOW, AND        */\n09720000    /*      EQUAL CANNOT BE DEFINED.  THE BEST THAT CAN BE DETERMINED IS EQUAL     */\n09730000    /*      OR NOT EQUAL.  THE FOLLOWING CHARACTERS HAVE SPECIAL SIGNIFICANCE IN   */\n09740000    /*      PATTERN STRINGS, AND ARE USED TO SELECT GROUPS OF CHARACTERS:          */\n09750000    /*                                                                             */\n09760000    /*            \"*\" - THE CORRESPONDING CHARACTER STRING CHARACTER CAN BE        */\n09770000    /*                  ANY CHARACTER.                                             */\n09780000    /*                                                                             */\n09790000    /*            \"#\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n09800000    /*                  NUMERIC AND CAN BE EITHER UPPER OR LOWER CASE.             */\n09810000    /*                                                                             */\n09820000    /*            \"@\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n09830000    /*                  ALPHABETIC AND CAN BE EITHER UPPER OR LOWER CASE.          */\n09840000    /*                                                                             */\n09850000    /*            \"\u00a2\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n09860000    /*                  ONE OF THE NATIONAL CHARACTERS: \"$\", \"#\", OR \"@\".          */\n09870000    /*                  BECAUSE OF THEIR BIT REPRESENTATIONS, NATIONAL             */\n09880000    /*                  CHARACTERS ARE UPPERCASE.                                  */\n09890000    /*                                                                             */\n09900000    /*            \"%\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n09910000    /*                  ALPHABETIC OR ONE OF THE NATIONAL CHARACTERS.              */\n09920000    /*                                                                             */\n09930000    /*            \"_\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n09940000    /*                  ALPHABETIC, NUMERIC,  OR ONE OF THE NATIONAL CHARACTERS.   */\n09950000    /*                                                                             */\n09960000    /*            \">\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n09970000    /*                  ONE OF THE NATIONAL CHARACTERS, OR AN UPPERCASE            */\n09980000    /*                  ALPHABETIC OR NUMERIC CHARACTER.                           */\n09990000    /*                                                                             */\n10000000    /*            \"<\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n10010000    /*                  A LOWERCASE ALPHABETIC OR NUMERIC CHARACTER.               */\n10020000    /*                                                                             */\n10030000    /*            \"!\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n10040000    /*                  ONE OF THE SPECIAL CHARACTERS.                             */\n10050000    /*                                                                             */\n10060000    /*            \"-\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n10070000    /*                  NON-NUMERIC.                                               */\n10080000    /*                                                                             */\n10090000    /*            \"\u00ac\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n10100000    /*                  NON-BLANK.                                                 */\n10110000    /*                                                                             */\n10120000    /*            \"?\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */\n10130000    /*                  ONE OF THE INVALID CHARACTERS.                             */\n10140000    /*                                                                             */\n10150000    /*      ALL OTHER CHARACTERS IN A PATTERN STRING (BLANKS, ALPHABETICS,         */\n10160000    /*      NUMERIC DIGITS, AND ESPECIALLY THE CHARACTERS \"=\" \".\" \",\" \":\" \"$\"      */\n10170000    /*      \"(\" AND \")\" REPRESENT THEMSELVES.  WHEN A PATTERN STRING CHARACTER     */\n10180000    /*      REPRESENTS ITSELF, THE CHARACTER STRING CHARACTER MUST BE THE SAME     */\n10190000    /*      AS THE PATTERN CHARACTER.  FOR EXAMPLE, IN THE PATTERN STRING          */\n10200000    /*      \"%RM####\" USED TO SEARCH FOR RMF FMID'S, THE CHARACTERS \"R\" AND \"M\"    */\n10210000    /*      REPRESENT THEMSELVES.  EVERY ATTEMPT WAS MADE TO CHOOSE GENERIC        */\n10220000    /*      SELECTION CHARACTERS THAT WOULD BE UNLIKELY TO APPEAR IN THE DATA      */\n10230000    /*      EXCEPT WHERE TRADITION STRONGLY DICTATED OTHERWISE (E.G., THE CHOICE   */\n10240000    /*      OF \"#\" TO SELECT NUMERIC CHARACTERS).                                  */\n10250000    /*                                                                             */\n10260000    /*            >>>>>MATCH_ARRAY.<<<<<                                           */\n10270000    /*            MATCH_ARRAY PROVIDES SMPSCAN WITH THE INFORMATION IT NEEDS TO    */\n10280000    /*      DETERMINE WHICH ENTRIES SHOULD BE WRITTEN TO OUTPUT DATA SETS.  THE    */\n10290000    /*      MATCH_ARRAY CONTENTS SPECIFY ENTRY MATCH CRITERIA WHICH CAN APPLY TO   */\n10300000    /*      A SINGLE INPUT LISTING, OR TO MULTIPLE LISTINGS (CROSS-ZONES)          */\n10310000    /*      CONCURRENTLY.  MATCH CRITERIA ARE BASED ON A COMBINATION OF ENTRY      */\n10320000    /*      TYPE (SYSMOD, MAC, MOD, LMOD, OR WHATEVER), ON THE PRESENCE OR         */\n10330000    /*      ABSENCE OF AN ENTRY IN A PARTICULAR INPUT LISTING, AND ON AN ENTRY'S   */\n10340000    /*      SCAN_RESULT IF SCAN_ARRAY VARIABLES WERE PROVIDED FOR THAT FILE.       */\n10350000    /*      THE OUTPUT DECISION IS BASED ON WHETHER THE MATCH CRITERIA WERE        */\n10360000    /*      SATISFIED AND, IF SCAN RESULTS ARE DEEMED RELEVANT, ON WHETHER SCAN    */\n10370000    /*      RESULTS WERE POSITIVE.                                                 */\n10380000    /*                                                                             */\n10390000    /*            MATCH_ARRAY IS DECLARED AS A TWO DIMENSIONAL ARRAY OF            */\n10400000    /*      STRUCTURES.  THE FIRST SUBSCRIPT IS THE MATCH_ARRAY ENTRY NUMBER AND   */\n10410000    /*      THE SECOND, WHEN REQUIRED, IS THE FILE NUMBER.  THE STRUCTURAL         */\n10420000    /*      DECLARATION OF MATCH_ARRAY IS:                                         */\n10430000    /*                                                                             */\n10440000    /*            01 MATCH_ARRAY                          CONTROLLED,              */\n10450000    /*               05 ENTRY(IMATCH_MIN:IMATCH_MAX),                              */\n10460000    /*                  09 TYPE                           CHAR(016) VARYING,       */\n10470000    /*                  09 COMPARE_TEST                   CHAR(008) VARYING,       */\n10480000    /*                  09 FILE(IFILE_MIN:IFILE_MAX),                              */\n10490000    /*                     13 COMPARE_OPTION              CHAR(012) VARYING,       */\n10500000    /*                     13 COMPARE_SELECT              CHAR(012) VARYING,       */\n10510000    /*                     13 WRITE_OPTION                CHAR(012) VARYING,       */\n10520000    /*                     13 WRITE_SELECT                CHAR(012) VARYING,       */\n10530000    /*                                                                             */\n10540000    /*            AS ENTRIES ARE READ, SMPSCAN FORMS A COMPARE KEY FROM THE        */\n10550000    /*      ENTRY TYPE, AND ENTRY NAME WITHIN TYPE.  FOR COMPARE KEY PURPOSES      */\n10560000    /*      THE ENTRY TYPE IS CONVERTED TO A TWO DIGIT INDEX WHOSE VALUES ARE IN   */\n10570000    /*      THE SAME ORDER AS ENTRY TYPES APPEAR IN SMP/E LISTINGS.  THIS IS THE   */\n10580000    /*      SAME INDEX VALUE MENTIONED IN REGARD TO ENTRY TYPE COMPARE             */\n10590000    /*      OPERATIONS IN THE DESCRIPTION OF THE SCAN_ARRAY \"STRING\" VARIABLE      */\n10600000    /*      ABOVE.  THE COMPARE KEY IS USED TO SYNCHRONIZE THE PROCESSING OF       */\n10610000    /*      MULTIPLE LISTING INPUTS BECAUSE IT DEFINES AN ORDER FOR THE INPUT      */\n10620000    /*      AND ALLOWS ENTRIES WITH THE SAME NAME TO BE IDENTIFIED ACROSS ZONES.   */\n10630000    /*      THIS KEY TECHNIQUE WORKS BECAUSE SMP/E LISTS ENTRIES WITHIN TYPE IN    */\n10640000    /*      ASCENDING ORDER BY NAME, AND ENTRY TYPES ALWAYS APPEAR IN THE SAME     */\n10650000    /*      ORDER IN OUTPUT LISTINGS.  THIS CONSISTENCY PROBABLY REFLECTS          */\n10660000    /*      SMP/E'S ZONE KEY CONSTRUCTION TECHNIQUE.                               */\n10670000    /*                                                                             */\n10680000    /*            ONCE THE FIRST ENTRY HAS BEEN READ FROM EACH ACTIVE INPUT        */\n10690000    /*      FILE, SMPSCAN CHECKS THE COMPARE KEYS, AND IDENTIFIES THOSE WITH THE   */\n10700000    /*      LOWEST COMPARE KEY.  THERE WILL ALWAYS BE AT LEAST ONE SUCH ENTRY,     */\n10710000    /*      AND THERE MAY SEVERAL IF THE ENTRY APPEARS IN MORE THAT ONE INPUT      */\n10720000    /*      LISTING.  THESE ENTRIES ARE THEN PROCESSED AS A GROUP.  PROCESSING     */\n10730000    /*      CONSISTS OF TESTING EACH ACTIVE ENTRY OF MATCH_ARRAY TO SEE IF THIS    */\n10740000    /*      GROUP OF ENTRIES IS A \"MATCH\", AND THEN APPLYING EACH \"MATCHING\"       */\n10750000    /*      ARRAY ENTRY'S OUTPUT INSTRUCTIONS TO EACH GROUP MEMBER.  A \"MATCH\"     */\n10760000    /*      IS DEFINED IN TERMS OF THE VARIABLES TYPE, COMPARE_TEST,               */\n10770000    /*      COMPARE_OPTION, AND COMPARE_SELECT:                                    */\n10780000    /*                                                                             */\n10790000    /*            1. MATCH_ARRAY TYPE MUST BE \"ALL\", OR MUST BE THE SAME AS THE    */\n10800000    /*               ENTRY TYPE FOR THE GROUP (ENTRIES OF DIFFERENT TYPES WILL     */\n10810000    /*               NOT BE IN THE SAME GROUP).                                    */\n10820000    /*                                                                             */\n10830000    /*            2. FOR EACH ACTIVE FILE, COMPARE_OPTION AND COMPARE_SELECT ARE   */\n10840000    /*               CHECKED AGAINST THE FILE'S CONTRIBUTION TO THE GROUP.  EACH   */\n10850000    /*               ACTIVE FILE EITHER HAS OR DOESN'T HAVE AN ENTRY IN THE        */\n10860000    /*               GROUP, AND EACH ENTRY IN THE GROUP HAS EITHER A POSITIVE      */\n10870000    /*               ('1'B) OR NEGATIVE ('0'B) SCAN_RESULT.  COMPARE_OPTION        */\n10880000    /*               INDICATES WHETHER THE FILE MUST OR MUST NOT HAVE AN ENTRY     */\n10890000    /*               IN THE GROUP, OR WHETHER MEMBERSHIP IN THE GROUP IS           */\n10900000    /*               OPTIONAL.  COMPARE_SELECT IS CHECKED IF AN ENTRY APPEARS IN   */\n10910000    /*               THE GROUP (WHETHER MANDATORY OR OPTIONAL).  AN ABSENT ENTRY   */\n10920000    /*               DOESN'T HAVE A SCAN_RESULT.  COMPARE_SELECT INDICATES         */\n10930000    /*               WHETHER AN ENTRY MUST HAVE A POSITIVE OR NEGATIVE             */\n10940000    /*               SCAN_RESULT, OR THE SCAN_RESULT IS TO BE DISREGARDED FOR      */\n10950000    /*               MATCHING PURPOSES (COMPARE_SELECT AND WRITE_SELECT ARE        */\n10960000    /*               INDEPENDENT OF EACH OTHER).                                   */\n10970000    /*                                                                             */\n10980000    /*            3. COMPARE_TEST AFFECTS THE WAY THE COMPARE_OPTION AND           */\n10990000    /*               COMPARE_SELECT TESTS ARE ASSESED TO DETERMINE A \"MATCH\".      */\n11000000    /*               IF COMPARE_TEST IS \"ALL\", THE COMPARE_OPTION/COMPARE_SELECT   */\n11010000    /*               TESTS MUST BE TRUE FOR ALL ACTIVE FILES.  IF COMPARE_TEST     */\n11020000    /*               IS \"ANY\", AT LEAST ONE OF THE COMPARE_OPTION/COMPARE_SELECT   */\n11030000    /*               TESTS MUST BE TRUE FOR AN ACTIVE FILE.                        */\n11040000    /*                                                                             */\n11050000    /*      IF A MATCH_ARRAY ENTRY'S COMPARE INSTRUCTION YIELD A \"MATCH\", THE      */\n11060000    /*      ARRAY ENTRY'S OUTPUT INSTRUCTIONS ARE APPLIED TO EACH ENTRY IN THE     */\n11070000    /*      GROUP.  AN ABSENT ENTRY CAN'T BE WRITTEN.  THE OUTPUT INSTRUCTIONS     */\n11080000    /*      ARE GIVEN BY THE VARIABLES WRITE_OPTION AND WRITE_SELECT:              */\n11090000    /*                                                                             */\n11100000    /*            1. FOR EACH ACTIVE FILE, WRITE_OPTION INDICATES WHETHER THE      */\n11110000    /*               ENTRY IS TO BE WRITTEN IF THE GROUP IS A \"MATCH\".             */\n11120000    /*               WRITE_OPTION IS INDEPENDENT OF COMPARE_OPTION, ESPECIALLY     */\n11130000    /*               WHEN COMPARE_TEST IS \"ANY\".  FOR EXAMPLE, FOR MULTIPLE        */\n11140000    /*               INPUTS, COMPARE_TEST='ANY' ALONG WITH                         */\n11150000    /*               COMPARE_OPTION='NOCOMPARE' AND WRITE_OPTION='WRITE' IS A      */\n11160000    /*               VALID COMBINATION.  THIS COMBINATION INSTRUCTS SMPSCAN TO     */\n11170000    /*               IDENTIFY AND WRITE THOSE GROUPS OF ENTRIES THAT DON'T         */\n11180000    /*               APPEAR IN ALL INPUT LISTINGS.                                 */\n11190000    /*                                                                             */\n11200000    /*            2. IF WRITE_OPTION IS \"WRITE\" AND AN ENTRY FROM THIS FILE        */\n11210000    /*               APPEARED IN THE GROUP, WRITE_SELECT INDICATES WHETHER THE     */\n11220000    /*               FILE ENTRY'S SCAN_RESULT HAS ANY BEARING ON THE OUTPUT        */\n11230000    /*               DECISION.  LIKE WRITE_OPTION, WRITE_SELECT IS INDEPENDENT     */\n11240000    /*               OF BOTH COMPARE_OPTION AND COMPARE_SELECT.  ONE ADVANTAGE     */\n11250000    /*               OF THIS INDEPENDENCE IS THAT ONE CAN \"MATCH\" OR IDENTIFY      */\n11260000    /*               ENTRIES INDEPENDENT OF SCAN RESULTS AND THEN WRITE A SUBSET   */\n11270000    /*               OF THE \"MATCHING\" ENTRIES BASED ON SCAN RESULTS.  A CAUTION   */\n11280000    /*               IS THAT IMPOSSIBLE COMBINATIONS PRODUCING NO OUTPUT CAN       */\n11290000    /*               ALSO BE DESCRIBED.                                            */\n11300000    /*                                                                             */\n11310000    /*      ONCE A MATCH_ARRAY ENTRY HAS PRODUCED A \"MATCH\", PROCESSING            */\n11320000    /*      CONTINUES.  THE FIRST ARRAY ENTRY YIELDING A MATCH DOES NOT            */\n11330000    /*      TERMINATE THE PROCESSING OF MATCH_ARRAY FOR THIS ENTRY GROUP.  AFTER   */\n11340000    /*      APPLYING OUTPUT INSTRUCTIONS, SMPSCAN GOES ON TO THE NEXT ACTIVE       */\n11350000    /*      MATCH_ARRAY ENTRY.  THIS ALLOWS THE OUTPUT FROM MULTIPLE CONDITIONS    */\n11360000    /*      TO BE MERGED IN A SINGLE EXECUTION (SMPSCAN HAS EXTRACT AND            */\n11370000    /*      MULTI-PASS CAPABILITIES).  \"MATCHED\" ARRAY ENTRY OUTPUT INSTRUCTIONS   */\n11380000    /*      ARE APPLIED ADDITIVELY.  ALTHOUGH THE WRITE_OPTION DEFAULT IS          */\n11390000    /*      \"WRITE\", AN ENTRY FROM THE GROUP WILL NOT BE WRITTEN UNLESS ITS        */\n11400000    /*      CORRESPONDING WRITE_OPTION FROM A \"MATCHED\" ARRAY ENTRY SPECIFIES      */\n11410000    /*      \"WRITE\".  FURTHER, AN ENTRY WILL BE WRITTEN IF ANY \"MATCHED\" ARRAY     */\n11420000    /*      ENTRY SPECIFIES \"WRITE\".  \"NOWRITE\" DOES NOT OVERRIDE \"WRITE\".         */\n11430000    /*                                                                             */\n11440000    /*            AFTER THE ABOVE PROCESSING HAS COMPLETED FOR THE FIRST SET       */\n11450000    /*      ENTRIES READ FROM EACH ACTIVE FILE, THE NEXT ENTRY IS READ FROM EACH   */\n11460000    /*      ACTIVE INPUT FILE THAT HAD AN ENTRY IN THE GROUP, AND THE MATCHING     */\n11470000    /*      PROCESS IS REPEATED, STARTING WITH THE IDENTIFICATION OF A NEW GROUP   */\n11480000    /*      OF LOW-KEY ENTRIES.  READING, SCANNING, AND MATCHING OF ENTRIES        */\n11490000    /*      CONTINUES UNTIL THE ENTRIES FROM ALL INPUT FILES HAVE BEEN READ.       */\n11500000    /*      LINES ARE SCANNED AS ENTRIES ARE READ, SO THAT THE SCAN_RESULT IS      */\n11510000    /*      AVAILABLE WHEN THE THE NEXT LOW-KEY GROUP IS IDENTIFIED.               */\n11520000    /*                                                                             */\n11530000    /*            MATCH_ARRAY VARIABLES ARE SUPPLIED IN THE \"SYSIN\" DATA STREAM,   */\n11540000    /*      AND ARE DOCUMENTED IN THE INPUT SECTION ABOVE.  IF USED, THEY SHOULD   */\n11550000    /*      BE SPECIFIED WITH THE REQUIRED LEVELS OF QUALIFICATION AND             */\n11560000    /*      SUBSCRIPTS AS SHOWN THERE.  UNLIKE SCAN_ARRAY, MATCH_ARRAY             */\n11570000    /*      (CURRENTLY) DOES NOT CONTAIN SMPSCAN-CALCULATED VARIABLES.  ALL        */\n11580000    /*      MATCH_ARRAY VARIABLES CAN BE SPECIFIED BY THE USER.  THE VARIABLES,    */\n11590000    /*      ALONG WITH THEIR DEFAULTS ARE:                                         */\n11600000    /*                                                                             */\n11610000    /*             .TYPE.  THIS VARIABLE SPECIFIES THE SMP/E ENTRY TYPE TO WHICH   */\n11620000    /*              THE MATCH_ARRAY ENTRY APPLIES.  IT CAN REFERENCE A SPECIFIC    */\n11630000    /*              ENTRY TYPE (LIKE THE SCAN_ARRAY STRING VALUE FOR ENTRY TYPE    */\n11640000    /*              OPERATIONS).  THE SPECIAL VALUES \"NONE\" AND \"ALL\" ARE ALSO     */\n11650000    /*              RECOGNIZED.  \"ALL\" INDICATES THAT THE MATCH_ARRAY ENTRY        */\n11660000    /*              APPLIES TO ALL ENTRY TYPES, AND \"NONE\" THAT THE ENTRY IS       */\n11670000    /*              INACTIVE.  FOR SOME ENTRY TYPES, REASONABLE ABBREVIATIONS      */\n11680000    /*              ARE SUPPORTED.  A FULL LIST OF THE CURRENTLY SUPPORTED ENTRY   */\n11690000    /*              TYPES IN ORDER OF APPEARANCE IN LISTINGS IS:                   */\n11700000    /*                                                                             */\n11710000    /*                 'ZONE'                                                      */\n11720000    /*                 'OPTIONS'                                                   */\n11730000    /*                 'UTILITY'                                                   */\n11740000    /*                 'FMIDSET'                                                   */\n11750000    /*                 'DDDEF'                                                     */\n11760000    /*                 'ZONESET'                                                   */\n11770000    /*                 'ASSEMBLER'                                                 */\n11780000    /*                 'LOAD MODULE'                                               */\n11790000    /*                 'MACRO'                                                     */\n11800000    /*                 'MODULE'                                                    */\n11810000    /*                 'SOURCE'                                                    */\n11820000    /*                 'DLIB'                                                      */\n11830000    /*                 'SYSMOD'                                                    */\n11840000    /*                 'M.C.S.'                                                    */\n11850000    /*                                                                             */\n11860000    /*             NOTE THAT A VALUE OF \"ALL\" WILL INCREASE SMPSCAN EXECUTION      */\n11870000    /*             TIME, BECAUSE ONLY THOSE ENTRY TYPES REFERENCED IN              */\n11880000    /*             MATCH_ARRAY ARE POTENTIAL OUTPUT CANDIDATES.  SMPSCAN           */\n11890000    /*             BYPASSES NON-ESSENTIAL PROCESSING FOR THOSE TYPES OMITTED       */\n11900000    /*             FROM MATCH_ARRAY.  IN PARTICULAR, LINE SCANNING IS SKIPPED.     */\n11910000    /*             NOT USING MATCH_ARRAY HAS THE SAME EFFECT AS \"ALL\" SINCE        */\n11920000    /*             ENTRY MATCHING IS GOVERNED BY SCAN RESULTS.                     */\n11930000    /*                                                                             */\n11940000    /*             .COMPARE_TEST.  THIS VARIABLE CONTROLS WHETHER THE FILE         */\n11950000    /*              SUB-ENTRIES WITHIN THIS MATCH_ARRAY ENTRY ARE TO BE PROCESSED  */\n11960000    /*              IN AN ALL (AND) OR ANY (OR) MANNER.  VALID VALUES ARE:         */\n11970000    /*                                                                             */\n11980000    /*                 'ALL'                                                       */\n11990000    /*                 'ANY'                                                       */\n12000000    /*                                                                             */\n12010000    /*              THE DEFAULT IS \"ALL\".  \"ALL\" INDICATES THAT ALL CONDITIONS     */\n12020000    /*              REPRESENTED BY THE COMPARE_OPTION AND COMPARE_SELECT           */\n12030000    /*              VARIABLES FOR EACH ACTIVE FILE MUST BE MET IN ORDER FOR A      */\n12040000    /*              MATCH_ARRAY ENTRY TO YIELD A MATCH WITH THE CURRENT GROUP OF   */\n12050000    /*              LISTING ENTRIES.  \"ALL\" WAS CHOSEN AS DEFAULT TO COMPLEMENT    */\n12060000    /*              THE FACT THAT ALL ACTIVE MATCH_ARRAY ENTRIES ARE PROCESSED     */\n12070000    /*              FOR EACH GROUP OF LISTING ENTRIES, AND ANY MATCH_ARRAY ENTRY   */\n12080000    /*              RESULTING IN A MATCH CAUSES TH ENTRY'S OUTPUT INSTRUCTIONS     */\n12090000    /*              TO BE APPLIED TO THE GROUP.  IN OTHER WORDS, \"ALL\" (AND) WAS   */\n12100000    /*              CHOSEN TO COMPLEMENT THE \"ANY\" (OR) LOGIC USED WITH THE        */\n12110000    /*              ARRAY.  A VALUE OF \"ANY\" CAN ALSO BE SPECIFIED FOR             */\n12120000    /*              COMPARE_TEST.  A VALUE OF \"ANY\" DOESN'T CHANGE THE WAY         */\n12130000    /*              MATCH_ARRAY IS INTERPRETED, BUT IT DOES SIMPLIFY THE           */\n12140000    /*              SPECIFICATION OF CERTAIN TESTS.  THAT'S WHY IT'S PROVIDED.     */\n12150000    /*              FOR EXAMPLE, WITH FOUR INPUT ZONE LISTINGS, TESTING FOR        */\n12160000    /*              ENTRIES OF A CERTAIN TYPE THAT ARE DEFINED IN SOME BUT NOT     */\n12170000    /*              ALL INPUT LISTINGS WILL REQUIRE 1 MATCH_ARRAY ENTRY WITH       */\n12180000    /*              COMPARE_TEST='ANY', BUT WILL REQUIRE 14 MATCH_ARRAY ENTRIES    */\n12190000    /*              WITH COMPARE_TEST='ALL'.                                       */\n12200000    /*                                                                             */\n12210000    /*             .COMPARE_OPTION.  THIS VARIABLE SPECIFIES, FOR THE CURRENT      */\n12220000    /*              GROUP OF LISTING ENTRIES, WHETHER AN ENTRY IS EXPECTED TO      */\n12230000    /*              BE PRESENT FROM THAT FILE.  A COMPARE_OPTION VALUE             */\n12240000    /*              PERTAINS TO EACH ACTIVE FILE.  VALID VALUES ARE:               */\n12250000    /*                                                                             */\n12260000    /*                 'COMPARE'       (AND REASONABLE ABBREVIATIONS)              */\n12270000    /*                 'NOCOMPARE'     (AND REASONABLE ABBREVIATIONS)              */\n12280000    /*                 'IGNORE' OR 'IGCOMPARE'    (AND ABBREVIATIONS)              */\n12290000    /*                                                                             */\n12300000    /*             THE DEFAULT IS \"IGNORE\".  \"COMPARE\" INDICATES THAT A LISTING    */\n12310000    /*             ENTRY IS EXPECTED FROM THIS FILE.  \"NOCOMPARE\" INDICATES THAT   */\n12320000    /*             A LISTING ENTRY IS EXPECTED TO BE ABSENT FROM THIS FILE.        */\n12330000    /*             \"IGNORE\" AND ITS SYNONYM \"IGCOMPARE\" INDICATE THAT AN ENTRY     */\n12340000    /*             LISTING MAY OR MAY NOT APPEAR - IT WILL BE PROCESSED IF         */\n12350000    /*             PRESENT, BUT ITS PRESENCE OR ABSENCE ISN'T DEMANDED.  BOTH      */\n12360000    /*             \"COMPARE\" AND \"IGNORE\" ARE INTERPRETED IN CONJUNCTION WITH      */\n12370000    /*             THE COMPARE_SELECT VARIABLE AS DESCRIBED BELOW.  \"NOCOMPARE\"    */\n12380000    /*             DOESN'T INTERACT WITH COMPARE_SELECT BECAUSE AN ENTRY THAT      */\n12390000    /*             ISN'T PRESENT CAN'T BE SCANNED.                                 */\n12400000    /*                                                                             */\n12410000    /*             .COMPARE_SELECT.  THIS VARIABLE SPECIFIES, WHEN AN ENTRY FROM   */\n12420000    /*              THIS FILE IS PRESENT IN THE CURRENT GROUP OF LISTING           */\n12430000    /*              ENTRIES, HOW THE ENTRY'S SCAN_RESULT IS TO BE WEIGHED.  A      */\n12440000    /*              COMPARE_TEST VALUE CORRESPONDING TO THE COMPARE_OPTION         */\n12450000    /*              PERTAINS TO EACH ACTIVE FILE.  VALID VALUES ARE:               */\n12460000    /*                                                                             */\n12470000    /*                 'SELECT'        (AND REASONABLE ABBREVIATIONS)              */\n12480000    /*                 'NOSELECT'      (AND REASONABLE ABBREVIATIONS)              */\n12490000    /*                 'IGNORE' OR 'IGSELECT'     (AND ABBREVIATIONS)              */\n12500000    /*                                                                             */\n12510000    /*             THE DEFAULT IS \"IGNORE\".  \"SELECT\" INDICATES THAT THE ENTRY     */\n12520000    /*             MUST HAVE BEEN SELECTED BY THE SCAN PROCESS (RESULT IS '1'B).   */\n12530000    /*             \"NOSELECT\" INDICATES THAT THE ENTRY MUST BE NOT SELECTED BY     */\n12540000    /*             THE SCAN PRECESS (RESULT IS '0'B).  \"IGNORE\" AND ITS SYNONYM    */\n12550000    /*             \"IGSELECT\" INDICATE THAT THE SCAN RESULT IS TO BE DISREGARDED   */\n12560000    /*             IN DETERMINING WHETHER THE CURRENT GROUP OF ENTRIES IS A        */\n12570000    /*             \"MATCH\" ACCORDING TO THIS MATCH_ARRAY ENTRY.  IF                */\n12580000    /*             COMPARE_OPTION IS \"COMPARE\" OR \"IGNORE\" AND COMPARE_SELECT IS   */\n12590000    /*             \"SELECT\" OR \"NOSELECT\", THE VARIABLES ACT TOGETHER.  FOR        */\n12600000    /*             INSTANCE, ONE CAN SPECIFY THAT AN ENTRY NEED NOT BE PRESENT     */\n12610000    /*             ISN A LISTING, BUT IF IT IS PRESENT, ITS SCAN_RESULT MUST BE    */\n12620000    /*             POSITIVE BY SPECIFYING COMPARE_OPTION='IGNORE' AND              */\n12630000    /*             'COMPARE_SELECT='SELECT'.                                       */\n12640000    /*                                                                             */\n12650000    /*             .WRITE_OPTION.  IF THIS MATCH_ARRAY ENTRY RESULTS IN A MATCH    */\n12660000    /*              FOR THE CURRENT GROUP OF LISTING ENTRIES, THIS VARIABLE        */\n12670000    /*              INDICATES THE OUTPUT REQUIREMENT FOR THE ENTRY FROM THIS       */\n12680000    /*              FILE.  VALID VALUES ARE:                                       */\n12690000    /*                                                                             */\n12700000    /*                 'WRITE'         (AND REASONABLE ABBREVIATIONS)              */\n12710000    /*                 'NOWRITE'       (AND REASONABLE ABBREVIATIONS)              */\n12720000    /*                                                                             */\n12730000    /*              THE DEFAULT IS \"WRITE\", AND THEIR MEANINGS ARE APPARENT.       */\n12740000    /*              FOR \"WRITE\", THE DECISION TO WRITE DEPENDS ON THE VALUE IN     */\n12750000    /*              WRITE_SELECT, DESCRIBED NEXT.                                  */\n12760000    /*                                                                             */\n12770000    /*             .WRITE_SELECT.  IF THIS MATCH_ARRAY ENTRY RESULTS IN A MATCH    */\n12780000    /*              FOR THE CURRENT GROUP OF LISTING ENTRIES AND WRITE_OPTION IS   */\n12790000    /*              \"WRITE\", THIS VARIABLE INDICATES WHETHER THE LISTING ENTRY'S   */\n12800000    /*              SCAN RESULT HAS ANY BEARING ON WHETHER THE ENTRY IS WRITTEN.   */\n12810000    /*              VALID VALUES ARE THE SAME AS THOSE FOR COMPARE_SELECT:         */\n12820000    /*                                                                             */\n12830000    /*                 'SELECT'        (AND REASONABLE ABBREVIATIONS)              */\n12840000    /*                 'NOSELECT'      (AND REASONABLE ABBREVIATIONS)              */\n12850000    /*                 'IGNORE' OR 'IGSELECT'     (AND ABBREVIATIONS)              */\n12860000    /*                                                                             */\n12870000    /*              THE DEFAULT IS \"IGNORE\".  \"SELECT\" INDICATES THAT THE ENTRY    */\n12880000    /*              MUST HAVE BEEN SELECTED BY THE SCAN PROCESS (RESULT IS         */\n12890000    /*              '1'B).  \"NOSELECT\" INDICATES THAT THE ENTRY MUST HAVE BEEN     */\n12900000    /*              NOT SELECTED (RESULT IS '0'B).  \"IGNORE\" AND ITS SYNONYM       */\n12910000    /*              \"IGSELECT\" INDICATE THAT THE SCAN_RESULT IS TO BE              */\n12920000    /*              DISREGARDED FOR THE PURPOSE OF DECIDING WHETHER TO WRITE THE   */\n12930000    /*              ENTRY - IT IS WRITTEN EITHER WAY.  A WRITE_SELECT VALUE OF     */\n12940000    /*              \"IGNORE\" HAS NO EFFECT ON THE PRESENCE OR ABSENCE OF           */\n12950000    /*              UNDERSCORES IN HIGHLIGHTED OUTPUT FOR THIS FILE.               */\n12960000    /*                                                                             */\n12970000    /*      IF MATCH_ARRAY VARIABLES ARE OMITTED FROM THE INPUT DATA SET, IT IS    */\n12980000    /*      AS IF A SINGLE MATCH_ARRAY ENTRY HAD BEEN SPECIFIED, WITH THE          */\n12990000    /*      FOLLOWING VALUES:                                                      */\n13000000    /*                                                                             */\n13010000    /*             .TYPE          ='ALL'.                                          */\n13020000    /*             .COMPARE_TEST  ='ANY'.                                          */\n13030000    /*             .COMPARE_OPTION='IGNORE'  FOR EACH ACTIVE FILE.                 */\n13040000    /*             .COMPARE_SELECT='SELECT'  FOR EACH ACTIVE FILE.                 */\n13050000    /*             .WRITE_OPTION  ='WRITE'   FOR EACH ACTIVE FILE.                 */\n13060000    /*             .WRITE_SELECT  ='SELECT'  FOR EACH ACTIVE FILE.                 */\n13070000    /*                                                                             */\n13080000    /*                                                                             */\n13090000    /*   USES AND EXAMPLES                                                         */\n13100000    /*                                                                             */\n13110000    /*            SMPSCAN'S USES CORRESPOND TO ITS FOUR MAIN FUNCTIONAL            */\n13120000    /*      CAPABILITIES:  PROVIDING A DIRECTORY OF MATCHING ENTRIES AND ENTRY     */\n13130000    /*      TYPE TOTALS FOR ONE OR MORE SMP/E LIST COMMAND OUTPUT LISTINGS,        */\n13140000    /*      IDENTIFYING AND MATCHING ENTRIES WHICH SATISY CERTAIN CONDITIONS,      */\n13150000    /*      PROVIDING PRE-SELECTED INPUT TO OTHER LIST COMMAND OUTPUT PROCESSING   */\n13160000    /*      PROGRAMS, AND GENERATING CARD-IMAGE FILES THAT CAN BE EDITED AND       */\n13170000    /*      TAILORED FOR OTHER USES.  SOME SPECIFIC INSTANCES ARE TO:              */\n13180000    /*                                                                             */\n13190000    /*             .IDENTIFY DDDEF ENTRIES:                                        */\n13200000    /*                                                                             */\n13210000    /*                -REFERENCING VOLUME SERIAL NUMBERS NO LONGER DEFINED, OR     */\n13220000    /*                 DEVICE TYPES NO LONGER INSTALLED.                           */\n13230000    /*                                                                             */\n13240000    /*                -THAT SHOULD BE DEFINED IN ALL (SAY) TARGET ZONES, BUT       */\n13250000    /*                 AREN'T.                                                     */\n13260000    /*                                                                             */\n13270000    /*                -REFERENCING VOLUME SERIAL NUMBERS INAPPROPRIATE TO A        */\n13280000    /*                 ZONE.                                                       */\n13290000    /*                                                                             */\n13300000    /*             .IDENTIFY LOAD MODULES:                                         */\n13310000    /*                                                                             */\n13320000    /*                -CROSS-SYSTEM THAT ARE DEFINED IN SOME BUT NOT ALL OF THE    */\n13330000    /*                 LISTED TARGET ZONES.                                        */\n13340000    /*                                                                             */\n13350000    /*                -CONTAINING MODULES FOR A PARTICULAR FMID OR GROUP OF        */\n13360000    /*                 FMID'S TO ASSIST IN THE INSTALLATION OF A NEW FMID.         */\n13370000    /*                                                                             */\n13380000    /*                -APPEARING IN MORE THAN ONE SYSTEM LIBRARY FOR A GIVEN       */\n13390000    /*                 ZONE, OR IN MORE THAN ONE LIBRARY FOR SOME TARGET ZONES     */\n13400000    /*                 BUT NOT FOR ALL.                                            */\n13410000    /*                                                                             */\n13420000    /*             .ALLOW IDENTIFICATION OF SYSMODS:                               */\n13430000    /*                                                                             */\n13440000    /*                -CONTAINING JCLIN, AND EITHER UPDATING OR REPLACING A        */\n13450000    /*                 SYSGEN MACRO.                                               */\n13460000    /*                                                                             */\n13470000    /*                -RECEIVED ON A PARTICULAR DATE, DATE AND TIME, OR BETWEEN    */\n13480000    /*                 ONE OR MORE RANGES OF DATES (AND TIMES).                    */\n13490000    /*                                                                             */\n13500000    /*                -REFERENCING A GIVEN MACRO, MODULE, APAR, FUNCTION, OR       */\n13510000    /*                 PTF, WHETHER APPLIED, ACCEPTED, OR ONLY JUST RECEIVED.      */\n13520000    /*                                                                             */\n13530000    /*                -APPLIED TO A TARGET ZONE BETWEEN TWO DATES AND EITHER       */\n13540000    /*                 ACCEPTED AFTER A CERTAIN DATE, OR NOT ACCEPTED AT ALL.      */\n13550000    /*                 MOREOVER, THESE TYPES OF TESTS CAN INVOLVE MORE THAN ONE    */\n13560000    /*                 TARGET ZONE, WITH DIFFERENT RANGES OF DATES FOR EACH        */\n13570000    /*                 ZONE.                                                       */\n13580000    /*                                                                             */\n13590000    /*             .PROVIDE A CONTROL CARD OUTPUT FILE OF THE SELECTED ENTRIES     */\n13600000    /*              THAT CAN BE EDITED:                                            */\n13610000    /*                                                                             */\n13620000    /*                -AND USED AS INPUT TO SMP/E TO INSTALL SPECIAL-PURPOSE       */\n13630000    /*                 MAINTENANCE, OR SELECT CERTAIN SYSMODS FOR APPLY, ACCEPT,   */\n13640000    /*                 OR RESTORE PROCESSING.                                      */\n13650000    /*                                                                             */\n13660000    /*                                                                             */\n13670000    /*   PROGRAMMING NOTES                                                         */\n13680000    /*                                                                             */\n13690000    /*            THIS SECTION DESCRIBES SOME OF THE MORE IMPORTANT                */\n13700000    /*      CONSIDERATIONS UNDERLYING THE STRUCTURE AND CODING OF SMPSCAN, IN      */\n13710000    /*      CASE CORRECTIONS, CHANGES, OR ENHANCEMENTS ARE NEEDED:                 */\n13720000    /*                                                                             */\n13730000    /*             .AFTER ANY PROGRAM CHANGES ARE MADE, THE VALUE IN VARIABLE      */\n13740000    /*              SMPSCAN_LVL SHOULD REFLECT THE VERSION AND NEW LEVEL OF        */\n13750000    /*              SMPSCAN.  THIS VALUE APPEARS IN THE SMPDCTRY OUTPUT IN TITLE   */\n13760000    /*              LINE NUMBER 1.                                                 */\n13770000    /*                                                                             */\n13780000    /*             .THE MAJOR DATA STRUCTURES WITHIN SMPSCAN WERE DECLARED         */\n13790000    /*              \"CONTROLLED\" WITH VARIABLE DIMENSIONS IN ORDER TO MAKE ARRAY   */\n13800000    /*              SIZES EASY TO EXPAND.  THESE DIMENSION VARIABLES WERE          */\n13810000    /*              REFERENCED BOTH IN STRUCTURAL DECLARATIONS AND DO GROUPS.      */\n13820000    /*              THE MORE IMPORTANT OF THESE DIMENSION VARIABLES ARE:           */\n13830000    /*                                                                             */\n13840000    /*                -IMATCH_MAX:  DETERMINES THE NUMBER OF ENTRIES IN            */\n13850000    /*                              MATCH_ARRAY, CURRENTLY SET AT 032.             */\n13860000    /*                                                                             */\n13870000    /*                -IFILE_MAX:   DEFINES THE MAXIMUM NUMBER OF INPUT LISTING    */\n13880000    /*                              FILES SUPPORTED, CURRENTLY SET AT 016.  IF     */\n13890000    /*                              SUPPORT FOR MORE THAN 016 FILES IS DESIRED,    */\n13900000    /*                              PROGRAM VARIABLES BEGINNING WITH \"DTF\", THE    */\n13910000    /*                              FILE VARIABLES AND ASSOCIATED LISTS MUST       */\n13920000    /*                              ALSO BE UPDATED ACCORDINGLY.  OTHERWISE, THE   */\n13930000    /*                              SOLE DEPENDENCY IS ON THE VALUE IN             */\n13940000    /*                              IFILE_MAX, SINCE THE FILE MANAGEMENT           */\n13950000    /*                              STRUCTURES ARE \"CONTROLLED\" WITH VARIABLE      */\n13960000    /*                              SUBSCRIPTS.                                    */\n13970000    /*                                                                             */\n13980000    /*                -IPLANE_MAX:  DETERMINES THE NUMBER OF PLANES IN EACH        */\n13990000    /*                              SCAN_ARRAY FILE CROSS-SECTION, CURRENTLY SET   */\n14000000    /*                              AT 012.                                        */\n14010000    /*                                                                             */\n14020000    /*                -IROW_MAX:    DETERMINES THE NUMBER OF ROWS IN EACH          */\n14030000    /*                              SCAN_ARRAY PLANE, CURRENTLY SET AT 012.        */\n14040000    /*                                                                             */\n14050000    /*                -ICOL_MAX:    DETERMINES THE NUMBER OF COLUMNS IN EACH       */\n14060000    /*                              SCAN_ARRAY ROW, CURRENTLY SET AT 012.          */\n14070000    /*                                                                             */\n14080000    /*                -PLIXOPT:     AFTER ANY PROGRAM CHANGES THAT INCREASE        */\n14090000    /*                              SMPSCAN'S VIRTUAL STORAGE REQUIREMENTS, THE    */\n14100000    /*                              ISASIZE AND HEAP OPTIONS IN PLIXOPT MAY NEED   */\n14110000    /*                              TO BE REVISED.                                 */\n14120000    /*                                                                             */\n14130000    /*             .IF IT BECOMES NECESSARY TO ADD SUPPORT FOR NEW SMP/E ENTRY     */\n14140000    /*              TYPES IN THE FUTURE, THE FOLLOWING PROGRAM AREAS SHOULD BE     */\n14150000    /*              REVIEWED:                                                      */\n14160000    /*                                                                             */\n14170000    /*                -NTRYINDX_MAX:  THIS VARIABLE DEFINES AN ARBITRARY UPPER     */\n14180000    /*                              LIMIT TO THE NUMBER OF DISTINCT ENTRY TYPES.   */\n14190000    /*                              ITS VALUE IS CURRENTLY SET AT 024, WITH        */\n14200000    /*                              14 VALUES IN ACTUAL USE.                       */\n14210000    /*                                                                             */\n14220000    /*                -ENTRY_TYPE:  THIS SUBROUTINE MAPS AN ENTRY TYPE NAME TO     */\n14230000    /*                              AN SMPSCAN INTERNAL INDEX VALUE.  NEW ENTRY    */\n14240000    /*                              TYPE NAMES AND ABBREVIATIONS FOR NEW OR        */\n14250000    /*                              EXISTING TYPES SHOULD BE ADDED HERE.           */\n14260000    /*                                                                             */\n14270000    /*                -ENTRY_INDEX: THIS SUBROUTINE MAPS AN SMPSCAN ENTRY TYPE     */\n14280000    /*                              INTERNAL INDEX VALUE BACK TO AN ENTRY TYPE     */\n14290000    /*                              NAME.  NAMES OF NEW ENTRY TYPES, BUT NOT       */\n14300000    /*                              ABBREVIATIONS, SHOULD BE ADDED HERE.           */\n14310000    /*                                                                             */\n14320000    /*                -SMPDATA_ENTRY_LINE_WRITE:  THIS SUBROUTINE AND ITS          */\n14330000    /*                              SUBORDINATE SUBROUTINES                        */\n14340000    /*                              WRITE_DATA_FORMAT1_LINE THROUGH                */\n14350000    /*                              WRITE_DATA_FORMAT5_LINE SHOULD BE REVIEWED     */\n14360000    /*                              AND FORMATTING ROUTINES FOR ANY NEW LINE       */\n14370000    /*                              TYPES SHOULD BE ADDED AS NEEDED.               */\n14380000    /*                                                                             */\n14390000    /*                -SMPDCTRY_ENTRY_FILE_STYPE_INFO:  IF SPECIAL ENTRY           */\n14400000    /*                              INFORMATION IS DESIRED IN SMPDCTRY ENTRY       */\n14410000    /*                              LINE LOCATIONS 026-040 THIS SUBROUTINE, THE    */\n14420000    /*                              CORRESPONDING DATA COLLECTION LOGIC IN         */\n14430000    /*                              SMPLIST_ENTRY_LINE_EVAL, AND ANY NEW           */\n14440000    /*                              VARIABLE DEFINITIONS NEEDED IN                 */\n14450000    /*                              SMPLIST.CURR_PAGE AND SMPLIST.CURR_NTRY WILL   */\n14460000    /*                              NEED TO BE CONSIDERED.                         */\n14470000    /*                                                                             */\n14480000    /*                -SCANDOC:     FINALLY, THIS DOCUMENTATION SHOULD BE          */\n14490000    /*                              REVIEWED, AND THE NEW ENTRY TYPE MENTIONED     */\n14500000    /*                              AT LEAST IN CONJUNCTION WITH THE MATCH_ARRAY   */\n14510000    /*                              \"TYPE\" VARIABLE.                               */\n14520000    /*                                                                             */\n14530000    /*                                                                             */\n14540000    /*   UPDATE HISTORY                                                            */\n14550000    /*                                                                             */\n14560000    /*             .MODULE UPGRADED FROM \"PTSSCAN\" TO SUPPORT SMP/E,               */\n14570000    /*              RENAMED TO \"SMPSCAN\", TESTED, AND DOCUMENTED.      12/31/86 TJA*/\n14580000    /*                                                                             */\n14590000    /*******************************************************************************/\n14600000    /*                                                                             */\n14610000    /*>>>>>>>>>>>>>>>>>>>>>>>>C U I C   D I S C L A I M E R<<<<<<<<<<<<<<<<<<<<<<<<*/\n14620000    /*                                                                             */\n14630000    /*******************************************************************************/\n14640000    /*            THE INFORMATION OR MATERIAL BEING PROVIDED BY COMMERCIAL UNION   */\n14650000    /*      INSURANCE COMPANY (CUIC), WHETHER IN HARD COPY OR MACHINE READABLE     */\n14660000    /*      FORM, HAS BEEN DEVELOPED BY CUIC FOR ITS OWN PURPOSE AND FOR USE ON    */\n14670000    /*      ITS OWN EQUIPMENT AND WITHIN ITS OWN DATA PROCESSING SYSTEM.  CUIC     */\n14680000    /*      MAKES NO REPRESENTATIONS OR WARRANTIES WHATSOEVER WITH RESPECT TO      */\n14690000    /*      THE INFORMATION OR MATERIAL FURNISHED HEREUNDER, EXPRESSED OR          */\n14700000    /*      IMPLIED, INCLUDING BUT NOT LIMITED TO ANY REPRESENTATION OR WARRANTY   */\n14710000    /*      OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR USE OR PURPOSE OR     */\n14720000    /*      THAT THE USE OF THE INFORMATION OR MATERIAL WILL NOT INFRINGE ANY      */\n14730000    /*      PATENT, COPYRIGHT, TRADEMARK, OR OTHER PROPRIETARY INTEREST.  YOU      */\n14740000    /*      ARE, THEREFORE, ACCEPTING THIS INFORMATION OR MATERIAL ON AN \"AS IS\"   */\n14750000    /*      BASIS AND WILL BE USING IT AT YOUR OWN RISK.  NEITHER CUIC NOR ANY     */\n14760000    /*      OF ITS AFFILIATES SHALL BE LIABLE WITH RESPECT TO ANY CLAIM, ACTION,   */\n14770000    /*      OR DEMAND BY ANY USER OR OTHER PARTY (INCLUDING ANY CLAIM, ACTION,     */\n14780000    /*      OR DEMAND FOR CONSEQUENTIAL DAMAGES EVEN IF CUIC HAS BEEN ADVISED OF   */\n14790000    /*      THE POSSIBILITY OF SUCH DAMAGES) ARISING FROM THE USE OF THE           */\n14800000    /*      INFORMATION OR THE MATERIALS AND CONCEPTS RELATED THERETO.             */\n14810000    /*      FURTHERMORE, CUIC WILL NOT MAINTAIN, CORRECT, OR UPDATE THIS           */\n14820000    /*      INFORMATION OR MATERIAL IN THE FUTURE.                                 */\n14830000    /*                                                                  01/26/83   */\n14840000    /*******************************************************************************/\n14850000    /*                                                                             */\n14860000    /*             DIRECT COMMENTS, QUESTIONS, AND SUGGESTIONS FOR ENHANCEMENTS    */\n14870000    /*      TO THE AUTHOR.........                                                 */\n14880000    /*                                                                             */\n14890000    /*             THOMAS J. AUBREY                                                */\n14900000    /*             INFORMATION SYSTEMS AND SERVICES - DATA PROCESSING DIVISION     */\n14910000    /*             COMMERCIAL UNION INSURANCE COMPANIES                            */\n14920000    /*             ONE BEACON STREET - THIRTEENTH FLOOR                            */\n14930000    /*             BOSTON, MASSACHUSETTS  02108                                    */\n14940000    /*             TELEPHONE: (617) 725-6208                                       */\n14950000    /*                                                                             */\n14960000    /*******************************************************************************/;\n14970000    %SKIP(3);\n14980000    DECLARE                    /*SPECIFY GLOBAL PROGRAM VALUES*/\n14990000         SMPSCAN_LVL             CHAR(005) INIT('02.00'),    /*PROGRAM VERSION & LEVEL   */\n15000000         SYSPARM                 CHAR(100) VARYING,          /*EXEC PARAMETER DATA       */\n15010000         PLIXOPT                 CHAR(128) VARYING           /*EXEC-TIME RUN OPTIONS     */\n15020000                                 STATIC EXTERNAL\n15030000                INIT('ISASIZE(0064K),HEAP(2048K,512K),STAE,COUNT,FLOW(256,064),REPORT');\n15040000    %PAGE;\n15050000    DECLARE                    /*LIST THE BUILT-IN FUNCTIONS USED */\n15060000        (ADDR,\n15070000         ALL,\n15080000         ANY,\n15090000         BOOL,\n15100000         CEIL,\n15110000         DATE,\n15120000         DIM,\n15130000         FLOOR,\n15140000         HIGH,\n15150000         INDEX,\n15160000         LENGTH,\n15170000         LINENO,\n15180000         LOG,LOG2,LOG10,\n15190000         LOW,\n15200000         MAX,\n15210000         MIN,\n15220000         PLIDUMP,\n15230000         REPEAT,\n15240000         SIGN,\n15250000         STRING,\n15260000         SUBSTR,\n15270000         TIME,\n15280000         UNSPEC,\n15290000         VERIFY)                 BUILTIN;\n15300000    %SKIP(2);\n15310000    DECLARE                    /*DEFINE FREQUENTLY_USED PROGRAM CONSTANTS*/\n15320000         SEMI_C                  CHAR(001) INIT(';');\n15330000    %PAGE;\n15340000    DECLARE                    /*DECLARE DO LOOP INDEX VARIABLES*/\n15350000         IMATCH                  FIXED BIN(15,0),\n15360000         IMATCH_MIN              FIXED BIN(15,0) INIT(001),\n15370000         IMATCH_MAX              FIXED BIN(15,0) INIT(032),\n15380000\n15390000         IFILE                   FIXED BIN(15,0),\n15400000         IFILE_MIN               FIXED BIN(15,0) INIT(001),\n15410000         IFILE_MAX               FIXED BIN(15,0) INIT(016),\n15420000\n15430000         ILINE                   FIXED BIN(15,0),\n15440000         LINE_SAVE_LIMIT   FIXED BIN(31,0) STATIC INTERNAL INIT(0100),\n15450000         LIST_LINE_SIZE    FIXED BIN(31,0) STATIC INTERNAL INIT(120),\n15460000         LIST_LINE_RCZC    FIXED BIN(31,0) STATIC INTERNAL INIT(133), /*SMPDCTRY LINE SIZE*/\n15470000         LIST_LINE_RCZD    FIXED BIN(31,0) STATIC INTERNAL INIT(080), /*SMPDATA  LINE SIZE*/\n15480000         LIST_LINE_RCZL    FIXED BIN(31,0) STATIC INTERNAL INIT(121), /*SMPLIST  LINE SIZE*/\n15490000         LIST_LINE_RCZN    FIXED BIN(31,0) STATIC INTERNAL INIT(133), /*SMPSCAN  LINE SIZE*/\n15500000         LIST_LINE_DBGN    FIXED BIN(15,0) STATIC INTERNAL INIT(001),\n15510000         LIST_LINE_NBGN    FIXED BIN(15,0) STATIC INTERNAL INIT(001),\n15520000         LIST_LINE_NWID    FIXED BIN(15,0) STATIC INTERNAL INIT(008),\n15530000         LIST_LINE_LBGN    FIXED BIN(15,0) STATIC INTERNAL INIT(011),\n15540000         LIST_LINE_LEND    FIXED BIN(15,0) STATIC INTERNAL INIT(025),\n15550000         LIST_LINE_LWID    FIXED BIN(15,0) STATIC INTERNAL INIT(015),\n15560000         LIST_LINE_SBGN    FIXED BIN(15,0) STATIC INTERNAL INIT(029),\n15570000         LIST_LINE_DEND    FIXED BIN(15,0) STATIC INTERNAL INIT(120),\n15580000\n15590000         IPLANE                  FIXED BIN(15,0),\n15600000         IPLANE_MIN              FIXED BIN(15,0) INIT(001),\n15610000         IPLANE_MAX              FIXED BIN(15,0) INIT(012),\n15620000         IROW                    FIXED BIN(15,0),\n15630000         IROW_MIN                FIXED BIN(15,0) INIT(001),\n15640000         IROW_MAX                FIXED BIN(15,0) INIT(012),\n15650000         ICOL                    FIXED BIN(15,0),\n15660000         ICOL_MIN                FIXED BIN(15,0) INIT(001),\n15670000         ICOL_MAX                FIXED BIN(15,0) INIT(012),\n15680000         SCAN_ARRAY_ELEMENT_ADDR       POINTER,\n15690000\n15700000         NTRYINDX_IX             FIXED BIN(15,0),\n15710000         NTRYINDX_MIN            FIXED BIN(15,0) INIT(000),\n15720000         NTRYINDX_MAX            FIXED BIN(15,0) INIT(024);\n15730000    %PAGE;\n15740000    DECLARE                    /*USER-PROVIDED EXECUTION CONTROL VARIABLES: */\n15750000         DDIPFX                               CHAR(003) INIT('SMP'),\n15760000         DDOPFX                               CHAR(003) INIT('SMP');\n15770000\n15780000    DECLARE                    /*USER-PROVIDED EXECUTION CONTROL VARIABLES: */\n15790000         FILE_ACTIVE_OPTION(IFILE_MIN:IFILE_MAX)        CONTROLLED\n15800000                                              CHAR(008) VARYING;   /*ACTIVE | INACTIVE */\n15810000\n15820000    DECLARE                                 /*USER-PROVIDED FILE MATCH CONTROL ARRAY: */\n15830000      01 MATCH_ARRAY                                    CONTROLLED,\n15840000         05 ENTRY(IMATCH_MIN:IMATCH_MAX),\n15850000            09 TYPE                           CHAR(016) VARYING,  /* ALL | NONE | E_TYPE */\n15860000            09 COMPARE_TEST                   CHAR(008) VARYING,  /* ALL | ANY */\n15870000            09 FILE(IFILE_MIN:IFILE_MAX),\n15880000               13 COMPARE_OPTION          /* COMPARE | NOCOMPARE | IGCOMPARE | IGNORE */\n15890000                                              CHAR(012) VARYING,\n15900000\n15910000               13 COMPARE_SELECT          /* SELECT | NOSELECT | IGSELECT | IGNORE */\n15920000                                              CHAR(012) VARYING,\n15930000\n15940000               13 WRITE_OPTION                       /* WRITE  | NOWRITE */\n15950000                                              CHAR(012) VARYING,\n15960000\n15970000               13 WRITE_SELECT            /* SELECT | NOSELECT | IGSELECT | IGNORE */\n15980000                                              CHAR(012) VARYING;\n15990000\n16000000    DECLARE                         /*USER-PROVIDED SMPLIST ENTRY SCAN CONTROL ARRAY: */\n16010000      01 SCAN_ARRAY                                     CONTROLLED,\n16020000         05 FILE(IFILE_MIN:IFILE_MAX),         /*ONE SCAN CUBE FOR EACH SUPPORTED FILE*/\n16030000            09 SELECT_OPTION                  CHAR(008) VARYING,  /* SELECT | EXCLUDE */\n16040000            09 PLANE(IPLANE_MIN:IPLANE_MAX),\n16050000               13 SELECT_OPTION               CHAR(008) VARYING,  /* SELECT | EXCLUDE */\n16060000               13 ROW(IROW_MIN:IROW_MAX),\n16070000                  17 SELECT_OPTION            CHAR(008) VARYING,  /* SELECT | EXCLUDE */\n16080000                  17 COL(ICOL_MIN:ICOL_MAX),\n16090000                     21 BEG_POS               FIXED BINARY(15,0),\n16100000                     21 END_POS               FIXED BINARY(15,0),\n16110000                     21 POS_LEN               FIXED BINARY(15,0),\n16120000                     21 OP                    CHAR(008) VARYING,\n16130000                     21 OP_OIX                FIXED BINARY(15,0),\n16140000                     21 STRING                CHAR(032) VARYING,\n16150000                     21 STR_LEN               FIXED BINARY(15,0),\n16160000                     21 STR_NIX               FIXED BINARY(15,0);\n16170000\n16180000    DECLARE                    /*USER-PROVIDED OUTPUT CONTROL OPTIONS:   */\n16190000         DATA_OUTPUT_OPTION(IFILE_MIN:IFILE_MAX)        CONTROLLED\n16200000                                              CHAR(008) VARYING;   /*ALL | ID */\n16210000    %PAGE;\n16220000    DECLARE\n16230000         SYSIN                 /*CONTROL VARIABLE INPUT FILE*/\n16240000                                 FILE RECORD SEQUENTIAL INPUT\n16250000                                 ENV(FB   RECSIZE(080)),\n16260000         SYSIN_CONTROL_CARD      CHAR(080),\n16270000         SYSIN_EOF               BIT(1),\n16280000\n16290000         SYSPRINT              /*PL/I LISTING OUTPUT FILE*/\n16300000                                 FILE STREAM OUTPUT PRINT\n16310000                                 ENV(VB   RECSIZE(155));\n16320000    %SKIP(5);\n16330000    DECLARE                      /*SMPSCAN DIRECTORY OUTPUT */\n16340000         DTFDCTRY                FILE STREAM OUTPUT PRINT INTERNAL\n16350000                                 ENV(FB  RECSIZE(LIST_LINE_RCZC));\n16360000\n16370000    DECLARE                      /*SMPSCAN DIRECTORY OUTPUT */\n16380000      01 SMPDCTRY                      CONTROLLED,\n16390000         05 FILEREF              FILE  VARIABLE,\n16400000         05 DDNAME               CHAR(008),\n16410000         05 OPEN                 BIT(01),                       /*IF THE FILE IS OPEN   */\n16420000         05 PAGE_SZ              FIXED BIN(15,0),               /*OUTPUT PAGE SIZE      */\n16430000         05 LINE_SZ              FIXED BIN(15,0),               /*OUTPUT LINE SIZE      */\n16440000         05 CURR_PAGE,\n16450000            09 PAGE_NO           FIXED BIN(31,0),               /*CURRENT PAGE NUMBER   */\n16460000            09 INFO_1STLINE      FIXED BIN(15,0),         /*# OF 1ST LINE AFTER HEADINGS*/\n16470000            09 NTRYINDX          FIXED BIN(15,0),\n16480000            09 TITLE1_DATE       CHAR(008),                     /*TITLE_1 MM/DD/YY      */\n16490000            09 TITLE1_TIME       CHAR(012),                     /*TITLE_1 HH:MM:SS.XCM  */\n16500000            09 TITLE2_DATA       CHAR(LIST_LINE_SIZE-010),      /*TITLE LINE FOR LISTING*/\n16510000            09 TITLE3_DATA       CHAR(LIST_LINE_SIZE);          /*TITLE LINE FOR LISTING*/\n16520000    %PAGE;\n16530000    DECLARE                    /*SMP/E \"SMPLIST\" ELEMENT LISTING INPUT FILE(S)*/\n16540000        (DTFLIST1,DTFLIST2,DTFLIST3,DTFLIST4,DTFLIST5,DTFLIST6,DTFLIST7,DTFLIST8,\n16550000         DTFLIST9,DTFLST10,DTFLST11,DTFLST12,DTFLST13,DTFLST14,DTFLST15,DTFLST16)\n16560000                                 FILE RECORD SEQUENTIAL INPUT INTERNAL\n16570000                                      ENV(FB   RECSIZE(LIST_LINE_RCZL)),\n16580000\n16590000         DTFLIST_LIST(001:016)   FILE  VARIABLE  INIT(DTFLIST1,DTFLIST2,DTFLIST3,DTFLIST4,\n16600000                                                      DTFLIST5,DTFLIST6,DTFLIST7,DTFLIST8,\n16610000                                                      DTFLIST9,DTFLST10,DTFLST11,DTFLST12,\n16620000                                                      DTFLST13,DTFLST14,DTFLST15,DTFLST16);\n16630000    %SKIP(2);\n16640000    DECLARE\n16650000      01 SMPLIST_CNTL            CONTROLLED,    /*SMP/E \"SMPLIST\" FILE CONTROL STRUCTURE*/\n16660000         05 A_STAT,            /*GENERAL INFORMATION ON THE SMPLIST INPUT/OUTPUT FILES  */\n16670000            09 #_F_ACTIVE        FIXED BIN(15,0),             /*# OF ACTIVE INPUT FILES */\n16680000         05 HIGH_PAGE,         /*RESET   INFORMATION FOR CURRENT PAGE AT END-OF-FILE    */\n16690000            09 NTRYNAME          CHAR(008),\n16700000            09 NTRYINDX          FIXED BIN(15,0),\n16710000            09 PAGEKEY           CHAR(011),\n16720000            09 NTRYKEY           CHAR(019),\n16730000            09 CMPRKEY           CHAR(011),\n16740000         05 HIGH_CMPR,         /*RESET   INFORMATION FOR CURRENT SMPLIST ENTRIES*/\n16750000            09 RESULT            BIT(01),\n16760000            09 NTRYNAME          CHAR(008),\n16770000            09 NTRYINDX          FIXED BIN(15,0),         /*NTRYINDX FOR CURRENT CMPRKEY*/\n16780000            09 CMPRKEY           CHAR(011),                            /*CURRENT CMPRKEY*/\n16790000         05 E_CMPR,            /*COMPARE INFORMATION FOR CURRENT SMPLIST ENTRIES*/\n16800000            09 RESULT            BIT(01),\n16810000            09 NTRYNAME          CHAR(008),\n16820000            09 NTRYINDX          FIXED BIN(15,0),         /*NTRYINDX FOR CURRENT CMPRKEY*/\n16830000            09 CMPRKEY           CHAR(011),                            /*CURRENT CMPRKEY*/\n16840000         05 A_MATCH,\n16850000            09 ACTIVE            BIT(01),                      /*ANY E_MATCH ROWS ACTIVE*/\n16860000            09 RESULT            BIT(01),\n16870000            09 M_E_TYPE(NTRYINDX_MIN:NTRYINDX_MAX)         /*ENTRY TYPE(S) BEING MATCHED*/\n16880000                                 BIT(01),\n16890000            09 F_OUTPUT(IFILE_MIN:IFILE_MAX)\n16900000                                 BIT(01),                      /*OUTPUT CANDIDATE FILES */\n16910000            09 E_MATCH(IMATCH_MIN:IMATCH_MAX),\n16920000               13 NTRYINDX       FIXED BIN(15,0),             /*NTRYINDX FOR ENTRY MATCH*/\n16930000               13 ACTIVE         BIT(01),                      /*THIS MATCH ENTRY ACTIVE*/\n16940000               13 C_TST          BIT(01),             /*COMPARE TEST: ANY='0'B, ALL='1'B*/\n16950000               13 F_MATCH(IFILE_MIN:IFILE_MAX),\n16960000                  17 M_CMPR      BIT(01),                  /*IF THE ENTRY MUST    BE FOUND*/\n16970000                  17 M_NOCMPR    BIT(01),                  /*IF THE ENTRY MUSTN'T BE FOUND*/\n16980000                  17 M_IGCMPR    BIT(01),                  /*IF THE ENTRY MAY     BE FOUND*/\n16990000                  17 M_SEL       BIT(01),                 /*FOUND ENTRY MUST   BE SELECTED*/\n17000000                  17 M_NOSEL     BIT(01),                 /*FOUND ENTRY MUSN'T BE SELECTED*/\n17010000                  17 M_IGSEL     BIT(01),                 /*FOUND ENTRY IGNORE    SELECT  */\n17020000                  17 W_OUT       BIT(01),                 /*WRITE BASED ON WRITE_SELECT   */\n17030000                  17 W_SEL       BIT(01),                 /*WRITE MATCH IF SELECTED       */\n17040000                  17 W_NOSEL     BIT(01),                 /*WRITE MATCH IF NOT SELECTED   */\n17050000                  17 W_IGSEL     BIT(01);                 /*WRITE MATCH REGARDLESS OF SEL */\n17060000    %PAGE;\n17070000    DECLARE\n17080000      01 SMPLIST(IFILE_MIN:IFILE_MAX)  CONTROLLED,           /*LIST FILE MANAGEMENT ARRAY*/\n17090000         05 FILEREF              FILE  VARIABLE,\n17100000         05 DDNAME               CHAR(008),\n17110000         05 ACTIVE               BIT(01),                         /*IF THE FILE IS ACTIVE*/\n17120000         05 EOF                  BIT(01),\n17130000         05 LINE_SZ              FIXED BIN(15,0),                /*INPUT  LINE SIZE      */\n17140000         05 CURR_PAGE,\n17150000            09 PAGE_BS           FIXED BIN(31,0),           /*BASE FOR 4-DIGIT PAGE NUMBR*/\n17160000            09 PAGE_NO           FIXED BIN(31,0),           /*CURRENT PAGE NUMBER        */\n17170000            09 PAGE_HI           FIXED BIN(31,0),           /*TO INIT CURR_NTRY.PAGE_HI  */\n17180000            09 LINE_NO           FIXED BIN(31,0),           /*LINE # ON CURRENT PAGE     */\n17190000            09 FLUSH             BIT(01),                   /*SET TO '1'B TO BYPASS PAGE */\n17200000            09 LINE_CT           FIXED BIN(31,0),           /*TO INIT CURR_NTRY.LINE_CT  */\n17210000            09 WRITE_OUT         BIT(01),                   /*TO INIT CURR_NTRY.WRITE_OUT*/\n17220000            09 CMPR_RESULT       BIT(01),                   /*TO INIT CURR_NTRY.CMPR_RSLT*/\n17230000            09 SCAN_RESULT       BIT(01),                   /*TO INIT CURR_NTRY.SCAN_RSLT*/\n17240000            09 ZONENAME          CHAR(007),\n17250000            09 ZONEINDX          FIXED BIN(15,0),\n17260000            09 ZONETYPE          CHAR(007)  VAR,\n17270000            09 ZONETYPE_C        CHAR(001),\n17280000            09 NTRYNAME          CHAR(008),\n17290000            09 NTRYINDX          FIXED BIN(15,0),\n17300000            09 NTRYTYPE          CHAR(016)  VAR,\n17310000            09 FMID              CHAR(007),                 /*TO INIT CURR_NTRY.FMID     */\n17320000            09 SOURCEID          CHAR(008),                 /*TO INIT CURR_NTRY.SOURCEID */\n17330000            09 SYSLIB1           CHAR(008),                 /*TO INIT CURR_NTRY.SYSLIB1  */\n17340000            09 SYSLIB2           CHAR(008),                 /*TO INIT CURR_NTRY.SYSLIB2  */\n17350000            09 PAGEKEY           CHAR(011),\n17360000            09 NTRYKEY           CHAR(019),\n17370000            09 CMPRKEY           CHAR(011),\n17380000            09 TITLE1_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/\n17390000            09 TITLE2_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/\n17400000            09 TITLE3_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/\n17410000         05 CURR_LINE,\n17420000            09 LINETYPE          CHAR(LIST_LINE_LWID),\n17430000            09 IN,\n17440000               13 PRTCTL         CHAR(001),\n17450000               13 DATA           CHAR(LIST_LINE_SIZE),\n17460000         05 CURR_NTRY,\n17470000            09 PAGE_NO           FIXED BIN(31,0),            /*1ST LISTING PAGE OF ENTRY*/\n17480000            09 PAGE_HI           FIXED BIN(31,0),        /*HIGHEST PAGE NUMBER FOR ENTRY*/\n17490000            09 LINE_CT           FIXED BIN(31,0),            /*CURRENT LINE COUNT OF ENTRY*/\n17500000            09 WRITE_OUT         BIT(01),                    /*TO WRITE THIS ENTRY       */\n17510000            09 CMPR_RESULT       BIT(01),                    /*TO READ NEXT ENTRY        */\n17520000            09 SCAN_RESULT       BIT(01),                    /*IF ENTRY SELECTED FOR PROC*/\n17530000            09 ZONENAME          CHAR(007),\n17540000            09 ZONEINDX          FIXED BIN(15,0),\n17550000            09 ZONETYPE          CHAR(007)  VAR,\n17560000            09 ZONETYPE_C        CHAR(001),\n17570000            09 NTRYNAME          CHAR(008),\n17580000            09 NTRYINDX          FIXED BIN(15,0),\n17590000            09 NTRYTYPE          CHAR(016)  VAR,\n17600000            09 FMID              CHAR(007),\n17610000            09 SOURCEID          CHAR(008),\n17620000            09 SYSLIB1           CHAR(008),\n17630000            09 SYSLIB2           CHAR(008),\n17640000            09 PAGEKEY           CHAR(011),\n17650000            09 NTRYKEY           CHAR(019),\n17660000            09 CMPRKEY           CHAR(011),\n17670000            09 TITLE1_DATA       CHAR(LIST_LINE_SIZE),    /*SAVE TITLE LINE FROM LISTING*/\n17680000            09 TITLE2_DATA       CHAR(LIST_LINE_SIZE),    /*SAVE TITLE LINE FROM LISTING*/\n17690000            09 TITLE3_DATA       CHAR(LIST_LINE_SIZE),    /*SAVE TITLE LINE FROM LISTING*/\n17700000         05 M_E_TYPE(NTRYINDX_MIN:NTRYINDX_MAX)   /*ENTRY TYPE(S) BEING MATCHED FOR FILE*/\n17710000                                 BIT(01),\n17720000         05 SCAN_CUBE,\n17730000            09 RESULT            BIT(01),\n17740000            09 SELECT            BIT(01),\n17750000            09 ACTIVE            BIT(01),                        /*ANY SCAN_ARRAY PLANES*/\n17760000            09 PLANE(IPLANE_MIN:IPLANE_MAX),\n17770000               13 RESULT         BIT(01),\n17780000               13 SELECT         BIT(01),\n17790000               13 ACTIVE         BIT(01),                          /*ANY SCAN_ARRAY ROWS*/\n17800000               13 ROW(IROW_MIN:IROW_MAX),\n17810000                  17 RESULT      BIT(01),\n17820000                  17 SELECT      BIT(01),\n17830000                  17 ACTIVE      BIT(01),                          /*ANY SCAN_ARRAY COLS*/\n17840000         05 FILE_TOTALS,\n17850000            09 #_S_ACTIVE        FIXED BIN(15,0),    /*# OF ACTIVE SCAN PLANES/ROWS/COLS*/\n17860000            09 #_F_OUTPUT        FIXED BIN(15,0),    /*# OF ACTIVE OUTPUT FILES         */\n17870000            09 #_E_T_FOUND       FIXED BIN(15,0),    /*# OF DISTINCT ENTRY TYPES FOUND  */\n17880000            09 RCRD_CT           FIXED BIN(31,0),           /*TOTAL NUMBER OF LINES READ*/\n17890000         05 ENTRY_TOTALS(NTRYINDX_MIN:NTRYINDX_MAX+1),  /*ONE SUBSTRUCTURE FOR EACH TYPE*/\n17900000                                                        /*PLUS ONE(MAX+1) FOR ALL TYPES */\n17910000            09 ENTRY_CT          FIXED BIN(31,0),           /*NUMBER OF ENTRIES         */\n17920000            09 LIST_PAGELO       FIXED BIN(31,0),           /*PAGE # OF FIRST INPUT PAGE*/\n17930000            09 LIST_PAGEHI       FIXED BIN(31,0),           /*PAGE # OF HIGH  INPUT PAGE*/\n17940000            09 LINE_CT           FIXED BIN(31,0),           /*NUMBER OF LINES IN ENTRIES*/\n17950000            09 MAXNAME           CHAR(008),                 /*ENTRY WITH MOST LINES     */\n17960000            09 MAXLINE           FIXED BIN(31,0),           /*NUMBER OF LINES IN ENTRY  */\n17970000            09 MAXPAGE           FIXED BIN(31,0),           /*PAGE ON WHICH ENTRY STARTS*/\n17980000            09 SELECT_CT         FIXED BIN(31,0),           /*# OF ENTRIES SELECTED/SCAN*/\n17990000            09 MATCH_CT          FIXED BIN(31,0),           /*# OF ENTRIES MATCHED /CMPR*/\n18000000            09 WRITE_CT          FIXED BIN(31,0);           /*# OF ENTRIES WRITTEN      */\n18010000    %SKIP(8);\n18020000    DECLARE                    /*SMP/E \"SMPLIST\" TITLE LINE MAPPING POINTERS  */\n18030000        (SMPLIST_TITLE1_MAP_ADDR,\n18040000         SMPLIST_TITLE2_MAP_ADDR,\n18050000         SMPLIST_TITLE3_MAP_ADDR)              POINTER;\n18060000    %PAGE;\n18070000    DECLARE                    /*SMP/E \"SMPLIST\" TITLE LINE MAPPINGS          */\n18080000      01 SMPLIST_TITLE1_MAP      BASED(SMPLIST_TITLE1_MAP_ADDR),\n18090000         05 EDATE                CHAR(004),    /*DATE*/\n18100000         05 FILL02               CHAR(001),\n18110000         05 LDATE                ,\n18120000            09 YY                PIC'99',      /*YY*/\n18130000            09 P                 CHAR(001),    /*.*/\n18140000            09 DDD               PIC'999',     /*DDD*/\n18150000         05 FILL03               CHAR(002),\n18160000         05 ETIME                CHAR(004),    /*TIME*/\n18170000         05 FILL04               CHAR(001),\n18180000         05 LTIME                ,\n18190000            09 HH                PIC'99',      /*HH*/\n18200000            09 C1                CHAR(001),    /*:*/\n18210000            09 MM                PIC'99',      /*MM*/\n18220000            09 C2                CHAR(001),    /*:*/\n18230000            09 SS                PIC'99',      /*SS*/\n18240000         05 FILL05               CHAR(006),\n18250000         05 EGIMSMP              CHAR(006),    /*GIMSMP*/\n18260000         05 FILL06               CHAR(001),\n18270000         05 ELVL                 CHAR(003),    /*LVL*/\n18280000         05 FILL07               CHAR(001),\n18290000         05 LVL                  ,\n18300000            09 VV                PIC'99',      /*VV*/\n18310000            09 P                 CHAR(001),    /*.*/\n18320000            09 LL                PIC'99',      /*LL*/\n18330000         05 FILL08               CHAR(001),\n18340000         05 ESMPLIST             CHAR(007),    /*SMPLIST*/\n18350000         05 FILL09               CHAR(002),\n18360000         05 EOUTPUT              CHAR(006),    /*OUTPUT*/\n18370000         05 FILL10               CHAR(005),\n18380000         05 EDASH                CHAR(001),    /*-*/\n18390000         05 FILL11               CHAR(001),\n18400000         05 ENOWSET              CHAR(010),    /*NOW SET TO*/\n18410000         05 FILL12               CHAR(001),\n18420000         05 ZONETYPE             CHAR(006),    /*TYPE OF ZONE*/\n18430000         05 FILL13               CHAR(001),\n18440000         05 EZONE                CHAR(004),    /*ZONE*/\n18450000         05 FILL14               CHAR(001),\n18460000         05 ZONENAME             CHAR(007),    /*NAME OF ZONE*/\n18470000         05 FILL15               CHAR(008),\n18480000         05 EPAGE                CHAR(004),    /*PAGE*/\n18490000         05 FILL16               CHAR(001),\n18500000         05 PAGE_NO              PICTURE'9999',/*NNNN*/\n18510000         05 FILL17               CHAR(002),\n18520000      01 SMPLIST_TITLE2_MAP      BASED(SMPLIST_TITLE2_MAP_ADDR),\n18530000         05 ZONENAME             CHAR(007),    /*NAME OF ZONE  BEING LISTED*/\n18540000         05 FILL01               CHAR(001),\n18550000         05 NTRYTYPE             CHAR(112),    /*TYPE OF ENTRY BEING LISTED*/\n18560000      01 SMPLIST_TITLE3_MAP      BASED(SMPLIST_TITLE3_MAP_ADDR),\n18570000         05 FILL01               CHAR(002),\n18580000         05 ENAME                CHAR(004),    /*NAME*/\n18590000         05 FILL02               CHAR(114);\n18600000    %PAGE;\n18610000    DECLARE                    /*SMP/E \"SMPLIST\" ELEMENT LISTING SPILL FILE(S)*/\n18620000        (DTFUT1,DTFUT2, DTFUT3, DTFUT4, DTFUT5, DTFUT6, DTFUT7, DTFUT8,\n18630000         DTFUT9,DTFUT10,DTFUT11,DTFUT12,DTFUT13,DTFUT14,DTFUT15,DTFUT16)\n18640000                                 FILE RECORD SEQUENTIAL INTERNAL     /*INPUT AND OUTPUT*/\n18650000                                 ENV(FB   RECSIZE(LIST_LINE_SIZE)),\n18660000\n18670000         DTFUT_LIST(001:016)     FILE  VARIABLE  INIT(DTFUT1, DTFUT2, DTFUT3, DTFUT4,\n18680000                                                      DTFUT5, DTFUT6, DTFUT7, DTFUT8,\n18690000                                                      DTFUT9, DTFUT10,DTFUT11,DTFUT12,\n18700000                                                      DTFUT13,DTFUT14,DTFUT15,DTFUT16);\n18710000    %SKIP(5);\n18720000    DECLARE                    /*SMP/E \"SMPLIST\" ELEMENT LISTING SPILL FILE(S)*/\n18730000      01 SMPUT(IFILE_MIN:IFILE_MAX)    CONTROLLED,  /*SPILL FILE MANAGEMENT ARRAY*/\n18740000         05 FILEREF              FILE  VARIABLE,\n18750000         05 DDNAME               CHAR(008),\n18760000         05 LINE_SAVE(LINE_SAVE_LIMIT) CHAR(LIST_LINE_SIZE),  /*RESERVE SAVE_LIMIT LINES*/\n18770000         05 WRITE,\n18780000            09 SAVE_CT           FIXED BIN(31,0),\n18790000            09 OPEN_CT           FIXED BIN(31,0),\n18800000            09 LINE_CT           FIXED BIN(31,0),\n18810000         05 READ,\n18820000            09 OPEN_CT           FIXED BIN(31,0),\n18830000            09 LINE_CT           FIXED BIN(31,0);\n18840000    %PAGE;\n18850000    DECLARE                      /*SMPSCAN SMPLIST SCAN HIGHLIGHTED OUTPUT*/\n18860000        (DTFSCAN1,DTFSCAN2,DTFSCAN3,DTFSCAN4,DTFSCAN5,DTFSCAN6,DTFSCAN7,DTFSCAN8,\n18870000         DTFSCAN9,DTFSCN10,DTFSCN11,DTFSCN12,DTFSCN13,DTFSCN14,DTFSCN15,DTFSCN16)\n18880000                                 FILE STREAM OUTPUT PRINT INTERNAL\n18890000                                 ENV(FB  RECSIZE(LIST_LINE_RCZN)),\n18900000\n18910000         DTFSCAN_LIST(001:016)   FILE  VARIABLE  INIT(DTFSCAN1,DTFSCAN2,DTFSCAN3,DTFSCAN4,\n18920000                                                      DTFSCAN5,DTFSCAN6,DTFSCAN7,DTFSCAN8,\n18930000                                                      DTFSCAN9,DTFSCN10,DTFSCN11,DTFSCN12,\n18940000                                                      DTFSCN13,DTFSCN14,DTFSCN15,DTFSCN16);\n18950000    %SKIP(5);\n18960000    DECLARE                      /*SMPSCAN SMPLIST SCAN HIGHLIGHTED OUTPUT*/\n18970000      01 SMPSCAN(IFILE_MIN:IFILE_MAX)  CONTROLLED,\n18980000         05 FILEREF              FILE  VARIABLE,\n18990000         05 DDNAME               CHAR(008),\n19000000         05 ACTIVE               BIT(01),                  /*IF THE FILE IS ACTIVE       */\n19010000         05 OPEN                 BIT(01),                  /*IF THE FILE IS OPEN         */\n19020000         05 PAGE_SZ              FIXED BIN(15,0),          /*OUTPUT PAGE SIZE            */\n19030000         05 LINE_SZ              FIXED BIN(15,0),          /*OUTPUT LINE SIZE            */\n19040000         05 CURR_PAGE,\n19050000            09 PAGE_NO           FIXED BIN(31,0),          /*CURRENT PAGE NUMBER         */\n19060000            09 PAGEKEY           CHAR(011),\n19070000            09 TITLE1_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/\n19080000            09 TITLE2_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/\n19090000            09 TITLE3_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/\n19100000         05 CURR_NTRY,\n19110000            09 PAGE_NO           FIXED BIN(31,0),          /*FIRST LISTING PAGE OF ENTRY */\n19120000            09 PAGEKEY           CHAR(011);\n19130000\n19140000    DECLARE                      /*SMPSCAN DIRECTORY OUTPUT */\n19150000         SMPSCAN_TITLE1_MAP_ADDR                 POINTER,\n19160000      01 SMPSCAN_TITLE1_MAP      BASED(SMPSCAN_TITLE1_MAP_ADDR)\n19170000                                 LIKE  SMPLIST_TITLE1_MAP;\n19180000    %PAGE;\n19190000    DECLARE                      /*SMPSCAN SMPLIST RELIST OUTPUT*/\n19200000        (DTFSOUT1,DTFSOUT2,DTFSOUT3,DTFSOUT4,DTFSOUT5,DTFSOUT6,DTFSOUT7,DTFSOUT8,\n19210000         DTFSOUT9,DTFSOU10,DTFSOU11,DTFSOU12,DTFSOU13,DTFSOU14,DTFSOU15,DTFSOU16)\n19220000                                 FILE STREAM OUTPUT PRINT INTERNAL\n19230000                                 ENV(FB  RECSIZE(LIST_LINE_RCZL)),\n19240000\n19250000         DTFSOUT_LIST(001:016)   FILE  VARIABLE  INIT(DTFSOUT1,DTFSOUT2,DTFSOUT3,DTFSOUT4,\n19260000                                                      DTFSOUT5,DTFSOUT6,DTFSOUT7,DTFSOUT8,\n19270000                                                      DTFSOUT9,DTFSOU10,DTFSOU11,DTFSOU12,\n19280000                                                      DTFSOU13,DTFSOU14,DTFSOU15,DTFSOU16);\n19290000    %SKIP(5);\n19300000    DECLARE\n19310000      01 SMPSOUT(IFILE_MIN:IFILE_MAX)  CONTROLLED,\n19320000         05 FILEREF              FILE  VARIABLE,\n19330000         05 DDNAME               CHAR(008),\n19340000         05 ACTIVE               BIT(01),                  /*IF THE FILE IS ACTIVE       */\n19350000         05 OPEN                 BIT(01),                  /*IF THE FILE IS OPEN         */\n19360000         05 PAGE_SZ              FIXED BIN(15,0),          /*OUTPUT PAGE SIZE            */\n19370000         05 LINE_SZ              FIXED BIN(15,0),          /*OUTPUT LINE SIZE            */\n19380000         05 CURR_PAGE,\n19390000            09 PAGE_NO           FIXED BIN(31,0),          /*CURRENT PAGE NUMBER         */\n19400000            09 PAGEKEY           CHAR(011),\n19410000            09 TITLE1_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/\n19420000            09 TITLE2_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/\n19430000            09 TITLE3_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/\n19440000         05 CURR_NTRY,\n19450000            09 PAGE_NO           FIXED BIN(31,0),          /*FIRST LISTING PAGE OF ENTRY */\n19460000            09 PAGEKEY           CHAR(011);\n19470000\n19480000    DECLARE\n19490000         SMPSOUT_TITLE1_MAP_ADDR                 POINTER,\n19500000      01 SMPSOUT_TITLE1_MAP      BASED(SMPSOUT_TITLE1_MAP_ADDR)\n19510000                                 LIKE  SMPLIST_TITLE1_MAP;\n19520000\n19530000    %PAGE;\n19540000    DECLARE                      /*SMPSCAN SMPLIST CARD IMAGE OUTPUT*/\n19550000        (DTFDATA1,DTFDATA2,DTFDATA3,DTFDATA4,DTFDATA5,DTFDATA6,DTFDATA7,DTFDATA8,\n19560000         DTFDATA9,DTFDAT10,DTFDAT11,DTFDAT12,DTFDAT13,DTFDAT14,DTFDAT15,DTFDAT16)\n19570000                                 FILE STREAM OUTPUT INTERNAL\n19580000                                 ENV(FB  RECSIZE(LIST_LINE_RCZD)),\n19590000\n19600000         DTFDATA_LIST(001:016)   FILE  VARIABLE  INIT(DTFDATA1,DTFDATA2,DTFDATA3,DTFDATA4,\n19610000                                                      DTFDATA5,DTFDATA6,DTFDATA7,DTFDATA8,\n19620000                                                      DTFDATA9,DTFDAT10,DTFDAT11,DTFDAT12,\n19630000                                                      DTFDAT13,DTFDAT14,DTFDAT15,DTFDAT16);\n19640000    %SKIP(5);\n19650000    DECLARE\n19660000      01 SMPDATA(IFILE_MIN:IFILE_MAX)  CONTROLLED,\n19670000         05 FILEREF              FILE  VARIABLE,\n19680000         05 DDNAME               CHAR(008),\n19690000         05 ACTIVE               BIT(01),                  /*IF THE FILE IS ACTIVE       */\n19700000         05 OPEN                 BIT(01),                  /*IF THE FILE IS OPEN         */\n19710000         05 LINE_SZ              FIXED BIN(15,0),          /*OUTPUT LINE SIZE            */\n19720000         05 CURR_CARD,\n19730000            09 DATA              CHAR(072),\n19740000            09 SEQ_NO            FIXED BIN(31,0),\n19750000         05 CURR_NTRY,\n19760000            09 SEQ_NO            FIXED BIN(31,0);      /*SEQ # OF FIRST LINE OF ENTRY*/\n19770000    %PAGE;\n19780000 SMPSCAN_MAINLINE:\n19790000    /******************************************************************/\n19800000    /*   SMPSCAN MAINLINE ROUTINE                                     */\n19810000    /******************************************************************/\n19820000\n19830000    ON ERROR\n19840000       BEGIN;\n19850000            ON ERROR SYSTEM;\n19860000            PUT DATA;                                                           /*DEBUG*/\n19870000            CALL PLIDUMP;\n19880000       END;\n19890000    %SKIP(03);\n19900000    CALL SMPDCTRY_OPEN;             /*OPEN THE DIAGNOSTIC MSG/DIRECTORY DATA SET        */\n19910000    CALL CONTROL_VALUE_INPUT;  /*INIT/READ/VALIDATE THE PROGRAM EXECUTION CONTROL VALUES*/\n19920000    CALL SMPLIST_OPEN;              /*OPEN INPUT AND OUTPUT DATA SETS,                  */\n19930000                                    /*AND READ THE FIRST LINES OF INPUT                 */\n19940000    CALL SMPDCTRY_INITIAL_INFO;     /*DOCUMENT FILE STATUS AND CONTROL VALUES           */\n19950000    CALL SMPLIST_ENTRY_READ;        /*READ THE FIRST SET OF ENTRIES, DETERMINE SCAN     */\n19960000                                    /*RESULTS, COMPARE FILES FOR LOWEST KEYS, AND       */\n19970000                                    /*DETERMINE IF THIS IS A MATCH.                     */\n19980000\n19990000    DO   WHILE(SMPLIST_CNTL.E_CMPR.RESULT);           /*WHILE ENTRIES REMAIN TO PROCESS */\n20000000\n20010000         IF       (SMPLIST_CNTL.A_MATCH.RESULT)       /*IF THIS IS A SUCCESSFUL MATCH   */\n20020000             & ANY(SMPLIST.CURR_NTRY.WRITE_OUT)       /*AND ANY ARE TO BE WRITTEN,      */\n20030000           THEN CALL  SMPLIST_ENTRY_WRITE;            /*WRITE OUT THE SELECTED ENTRIES. */\n20040000\n20050000         IF       (SMPLIST_CNTL.A_MATCH.RESULT)       /*IF THIS IS A SUCCESSFUL MATCH,  */\n20060000           THEN CALL  SMPDCTRY_ENTRY_INFO;            /*WRITE ENTRY LOCATOR INFORMATION.*/\n20070000\n20080000         CALL  SMPLIST_ENTRY_READ;                    /*READ THE NEXT SET OF ENTRIES,   */\n20090000                                                      /*DETERMINE SCAN RESULTS,         */\n20100000                                                      /*COMPARE FILES FOR LOWEST KEYS,  */\n20110000                                                      /*AND DETERMINE IF THIS IS A MATCH*/\n20120000    END;\n20130000\n20140000    CALL SMPLIST_WRAPUP;            /*CALCULATE FINAL VALUES                            */\n20150000    CALL SMPDCTRY_FINAL_INFO;       /*WRITE OUT FINAL PROCESSING TOTALS                 */\n20160000    CALL SMPLIST_CLOSE;             /*CLOSE THE INPUT AND OUTPUT DATA SET(S)            */\n20170000    CALL SMPDCTRY_CLOSE;            /*CLOSE THE DIAGNOSTIC MSG/DIRECTORY DATA SET       */\n20180000\n20190000    RETURN;                         /*RETURN TO CALLER OF SMPSCAN                       */\n20200000 %PAGE;\n20210000 SMPDCTRY_OPEN:\n20220000   PROC;\n20230000      ALLOCATE SMPDCTRY;                            /*ALLOCATE FILE MANAGEMENT STRUCTURE*/\n20240000      SMPDCTRY.FILEREF                =   DTFDCTRY; /*INITIALIZE FILE VARIABLE REFERENCE*/\n20250000      PUT STRING(SMPDCTRY.DDNAME)         EDIT(DDIPFX,'DCTRY')             (A,A);  /*DDN*/\n20260000      SMPDCTRY.OPEN                   =  '0'B;              /*INITIALIZE OPEN INDICATOR */\n20270000      SMPDCTRY.PAGE_SZ                =   060;              /*INITIALIZE PAGE SIZE      */\n20280000      SMPDCTRY.LINE_SZ                =   LIST_LINE_SIZE + 012; /*INITIALIZE LINE SIZE  */\n20290000      SMPDCTRY.CURR_PAGE.PAGE_NO      =   0000;             /*INITIALIZE PAGE NUMBER    */\n20300000      SMPDCTRY.CURR_PAGE.INFO_1STLINE =   000;              /*INITIALIZE 1ST INFO LINE #*/\n20310000      SMPDCTRY.CURR_PAGE.NTRYINDX     = NTRYINDX_MIN - 1;   /*INITIALIZE ENTRY INDEX    */\n20320000      SMPDCTRY.CURR_PAGE.TITLE2_DATA  = ' ';                /*INITIALIZE TITLE LINES    */\n20330000      SMPDCTRY.CURR_PAGE.TITLE3_DATA  = ' ';                /*INITIALIZE TITLE LINES    */\n20340000\n20350000      OPEN  FILE(SMPDCTRY.FILEREF) OUTPUT\n20360000            PAGESIZE(SMPDCTRY.PAGE_SZ) LINESIZE(SMPDCTRY.LINE_SZ)\n20370000            TITLE(SMPDCTRY.DDNAME);\n20380000\n20390000      SMPDCTRY.OPEN          =   '1'B;           /*INDICATE FILE IS OPEN*/\n20400000\n20410000   END SMPDCTRY_OPEN;\n20420000 %SKIP(3);\n20430000 SMPDCTRY_CLOSE: /*SUBROUTINE TO CLOSE THE \"SMPDCTRY\" DATA SET */\n20440000    PROC;\n20450000       CLOSE FILE(SMPDCTRY.FILEREF) ENV(LEAVE);\n20460000\n20470000      SMPDCTRY.OPEN          =   '0'B;           /*INDICATE FILE IS NO LONGER OPEN*/\n20480000    END SMPDCTRY_CLOSE;      /*END OF \"SMPDCTRY_CLOSE\" SUBROUTINE*/\n20490000 %PAGE;\n20500000 SMPDCTRY_NEWPAGE:\n20510000   PROC;\n20520000      DCL  NEWPAGE_DATE               CHAR(006), /*STORE DATE FROM \"DATE\" FUNCTION*/\n20530000           NEWPAGE_TIME               CHAR(009); /*STORE TIME FROM \"TIME\" FUNCTION*/\n20540000\n20550000      IF LINENO(SMPDCTRY.FILEREF) > 1 THEN PUT FILE(SMPDCTRY.FILEREF) PAGE;\n20560000      SMPDCTRY.CURR_PAGE.PAGE_NO      =   SMPDCTRY.CURR_PAGE.PAGE_NO + 1;\n20570000      NEWPAGE_DATE                    =   DATE();\n20580000      NEWPAGE_TIME                    =   TIME();\n20590000      SMPDCTRY.CURR_PAGE.TITLE1_DATE  =   SUBSTR(NEWPAGE_DATE,03,02)  /*MM*/\n20600000                                       || '/'\n20610000                                       || SUBSTR(NEWPAGE_DATE,05,02)  /*DD*/\n20620000                                       || '/'\n20630000                                       || SUBSTR(NEWPAGE_DATE,01,02); /*YY*/\n20640000\n20650000      SMPDCTRY.CURR_PAGE.TITLE1_TIME  =   SUBSTR(NEWPAGE_TIME,01,02)  /*HH*/\n20660000                                       || ':'\n20670000                                       || SUBSTR(NEWPAGE_TIME,03,02)  /*MM*/\n20680000                                       || ':'\n20690000                                       || SUBSTR(NEWPAGE_TIME,05,02)  /*SS*/\n20700000                                       || '.'\n20710000                                       || SUBSTR(NEWPAGE_TIME,07,03); /*XCM*/\n20720000      PUT    FILE(SMPDCTRY.FILEREF)              /*TITLE1 LINE*/\n20730000             EDIT('DATE:',SMPDCTRY.CURR_PAGE.TITLE1_DATE)  (COL(001),A,X(1),A)\n20740000                 ('TIME:',SMPDCTRY.CURR_PAGE.TITLE1_TIME)  (X(2),A,X(1),A(012))\n20750000                 ('SMPSCAN  LVL',SMPSCAN_LVL)              (X(2),A,X(1),A)\n20760000                 ('C.U. SMP/E LIST ENTRY SELECTION')       (X(3),A)\n20770000                 ('--','SMPDCTRY OUTPUT')                  (X(1),A,X(1),A)\n20780000                 ('PAGE', SMPDCTRY.CURR_PAGE.PAGE_NO)      (COL(110),A,X(1),P'9999');\n20790000\n20800000      CALL   SMPDCTRY_NEWTITLE_2_3;              /*WRITE TITLE LINES 2 & 3*/\n20810000      SMPDCTRY.CURR_PAGE.INFO_1STLINE = LINENO(SMPDCTRY.FILEREF) + 1;\n20820000   END SMPDCTRY_NEWPAGE;\n20830000 %SKIP(2);\n20840000 SMPDCTRY_NEWTITLE_2_3:                          /*WRITE TITLE LINES 2 & 3*/\n20850000   PROC;\n20860000      PUT    FILE(SMPDCTRY.FILEREF)              /*TITLE2 LINE*/\n20870000             EDIT(' ')                                     (SKIP(1),A)\n20880000                 ('SMPSCAN')                               (SKIP(1),COL(001),A)\n20890000                 (SMPDCTRY.CURR_PAGE.TITLE2_DATA)          (COL(011),A(110))\n20900000                 (' ')                                     (SKIP(1),A);\n20910000      IF  SMPDCTRY.CURR_PAGE.TITLE3_DATA \u00ac= ' '  /*IF A TITLE3 LINE IS PRESENT*/\n20920000        THEN\n20930000         PUT FILE(SMPDCTRY.FILEREF)\n20940000             EDIT(' ')                                     (SKIP(1),A)\n20950000                 (SMPDCTRY.CURR_PAGE.TITLE3_DATA)          (SKIP(1),A)\n20960000                 (' ')                                     (SKIP(1),A);\n20970000   END SMPDCTRY_NEWTITLE_2_3;\n20980000 %PAGE;\n20990000 SMPDCTRY_INITIAL_INFO:\n21000000   PROC;\n21010000\n21020000            /*-------------------------------------------------------------------------*/\n21030000            /* ASSEMBLE TITLE2 LINE AND SET UP END-OF-PAGE CONTROL:                    */\n21040000            /*-------------------------------------------------------------------------*/\n21050000\n21060000      SMPDCTRY.CURR_PAGE.NTRYINDX     = NTRYINDX_MIN - 1;\n21070000      SMPDCTRY.CURR_PAGE.TITLE2_DATA  =\n21080000              'DIAGNOSTIC MESSAGES AND EXECUTION CONTROL VALUES:';\n21090000\n21100000      ON ENDPAGE(SMPDCTRY.FILEREF) CALL SMPDCTRY_NEWPAGE;\n21110000\n21120000            /*-------------------------------------------------------------------------*/\n21130000            /* PRINT FILE STATUS INFORMATION AND SCAN_ARRAY CONTENTS FOR ALL           */\n21140000            /* SUPPORTED FILES:                                                        */\n21150000            /*-------------------------------------------------------------------------*/\n21160000      CALL     SMPDCTRY_INITIAL_FILE_INFO;\n21170000\n21180000            /*-------------------------------------------------------------------------*/\n21190000            /* PRINT MATCH_ARRAY CONTROL INFORMATION IF VALUES HAVE BEEN PROVIDED:     */\n21200000            /*-------------------------------------------------------------------------*/\n21210000      CALL     SMPDCTRY_INITIAL_MATCH_INFO;\n21220000\n21230000      RETURN;                    /*TO THE CALLER OF SMPDCTRY_INITIAL_INFO*/\n21240000 %PAGE;\n21250000 SMPDCTRY_INITIAL_FILE_INFO: /*THIS SUBROUTINE IS INTERNAL TO SMPDCTRY_INITIAL_INFO    */\n21260000   PROC;\n21270000\n21280000      DCL  FILE_LIST_LINE_CT       FIXED BINARY(15,0);\n21290000\n21300000            /*-------------------------------------------------------------------------*/\n21310000            /* ASSEMBLE TITLE3 LINE AND BEGIN A NEW PAGE:                              */\n21320000            /*-------------------------------------------------------------------------*/\n21330000      SMPDCTRY.CURR_PAGE.TITLE3_DATA  =  '  FILE  ';\n21340000      SUBSTR(SMPDCTRY.CURR_PAGE.TITLE3_DATA,026)\n21350000                                      =  'STATUS INFORMATION AND SCAN ARRAY CONTENTS:';\n21360000\n21370000      SIGNAL ENDPAGE(SMPDCTRY.FILEREF)/**/;                          /*START A NEW PAGE*/\n21380000\n21390000            /*-------------------------------------------------------------------------*/\n21400000            /* WRITE OUT STATUS AND CONTROL INFORMATION FOR EACH FILE:                 */\n21410000            /*-------------------------------------------------------------------------*/\n21420000\n21430000      DO  IFILE = IFILE_MIN TO IFILE_MAX;                     /*FOR EACH SUPPORTED FILE*/\n21440000\n21450000        IF   (SMPLIST(IFILE).ACTIVE)                            /*IF THE FILE IS ACTIVE*/\n21460000          THEN     CALL SMPDCTRY_INITIAL_FILE_F_INFO        /*WHEN THE FILE IS   ACTIVE*/;\n21470000          ELSE  /* CALL SMPDCTRY_INITIAL_FILE_F_INFO        /*WHEN THE FILE IS INACTIVE*/;\n21480000\n21490000      END;                       /*END OF IFILE DO GROUP*/\n21500000\n21510000      RETURN;                    /*TO THE CALLER OF SMPDCTRY_INITIAL_FILE_INFO*/\n21520000     %PAGE;\n21530000 SMPDCTRY_INITIAL_FILE_F_INFO:     /*SUBROUTINE INTERNAL TO SMPDCTRY_INITIAL_FILE_INFO*/\n21540000   PROC;                        /*IFILE IS SET ON ENTRY  TO SMPDCTRY_INITIAL_FILE_F_INFO*/\n21550000            /*-------------------------------------------------------------------------*/\n21560000            /* WRITE OUT STATUS AND CONTROL INFORMATION FOR EACH FILE:                 */\n21570000            /*-------------------------------------------------------------------------*/\n21580000      IF   (SMPLIST(IFILE).ACTIVE)                              /*IF THE FILE IS ACTIVE*/\n21590000        THEN  FILE_LIST_LINE_CT = 01 + SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT\n21600000                                     + SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE;\n21610000        ELSE  FILE_LIST_LINE_CT = 01;\n21620000\n21630000      IF         (LINENO(SMPDCTRY.FILEREF) <= (SMPDCTRY.PAGE_SZ -(FILE_LIST_LINE_CT+02)))\n21640000          THEN                                   /*IF LISTING WILL FIT ON CURRENT PAGE*/\n21650000              IF (LINENO(SMPDCTRY.FILEREF) >=  SMPDCTRY.CURR_PAGE.INFO_1STLINE)\n21660000               THEN PUT FILE(SMPDCTRY.FILEREF)  SKIP(2);     /*CONTINUE ON CURRENT PAGE*/\n21670000               ELSE PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);     /*CONTINUE ON CURRENT PAGE*/\n21680000          ELSE                                   /*IF LISTING WON'T FIT ON CURRENT PAGE*/\n21690000              IF (LINENO(SMPDCTRY.FILEREF) >=  SMPDCTRY.CURR_PAGE.INFO_1STLINE)\n21700000               THEN SIGNAL ENDPAGE(SMPDCTRY.FILEREF);        /*START ON A NEW PAGE     */\n21710000               ELSE PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);     /*CONTINUE ON CURRENT PAGE*/\n21720000\n21730000      PUT FILE(SMPDCTRY.FILEREF)\n21740000          EDIT('FILE(',IFILE,') IS:')                               (COL(001),A,P'999',A);\n21750000\n21760000      IF   (SMPLIST(IFILE).ACTIVE)                /*ONE LINE FOR EACH ACTIVE INPUT FILE*/\n21770000        THEN                                                    /*IF THE FILE IS ACTIVE*/\n21780000          DO;\n21790000            PUT FILE(SMPDCTRY.FILEREF) EDIT('ACTIVE')                        (COL(016),A)\n21800000                    ('LIST DDNAME=')                                         (COL(026),A)\n21810000                    ( SMPLIST(IFILE).DDNAME)                                          (A)\n21820000                    ('SCAN SELECTION IS:')                                   (COL(051),A);\n21830000            IF (SMPLIST(IFILE).SCAN_CUBE.ACTIVE)\n21840000              THEN  PUT FILE(SMPDCTRY.FILEREF) EDIT('ACTIVE')                (COL(071),A);\n21850000              ELSE  PUT FILE(SMPDCTRY.FILEREF) EDIT('INACTIVE')              (COL(071),A);\n21860000            IF (SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE))\n21870000              THEN  PUT FILE(SMPDCTRY.FILEREF)           /*IF ENTRIES ARE BEING WRITTEN*/\n21880000                        EDIT('SCAN DDNAME=',SMPSCAN(IFILE).DDNAME) (SKIP(1),COL(026),A,A)\n21890000                            ('SOUT DDNAME=',SMPSOUT(IFILE).DDNAME) (SKIP(1),COL(026),A,A)\n21900000                            ('DATA DDNAME=',SMPDATA(IFILE).DDNAME) (SKIP(1),COL(026),A,A)\n21910000                            ('OUTPUT OPTION IS:')                            (COL(052),A)\n21920000                            ( DATA_OUTPUT_OPTION(IFILE))                     (COL(071),A);\n21930000              ELSE  PUT FILE(SMPDCTRY.FILEREF)       /*IF ENTRIES ARE NOT BEING WRITTEN*/\n21940000                        EDIT('**ENTRIES ARE NOT BEING WRITTEN**')    (SKIP(1),COL(026),A);\n21950000            IF (SMPLIST(IFILE).SCAN_CUBE.ACTIVE)             /*SCAN ARRAY INFO FOR FILE*/\n21960000              THEN  CALL     SMPDCTRY_INITIAL_FILE_FS_INFO;\n21970000          END;                   /*END OF ACTIVE IFILE DO GROUP*/\n21980000        ELSE                                                  /*IF THE FILE IS INACTIVE*/\n21990000          DO;\n22000000            PUT FILE(SMPDCTRY.FILEREF) EDIT('INACTIVE')                      (COL(016),A);\n22010000          END;                   /*END OF INACTIVE IFILE DO GROUP*/\n22020000\n22030000      RETURN;                    /*TO THE CALLER OF SMPDCTRY_INITIAL_FILE_F_INFO*/\n22040000 %PAGE;\n22050000 SMPDCTRY_INITIAL_FILE_FS_INFO:    /*SUBROUTINE INTERNAL TO SMPDCTRY_INITIAL_FILE_F_INFO*/\n22060000   PROC;                        /*IFILE IS SET ON ENTRY  TO SMPDCTRY_INITIAL_FILE_FS_INFO*/\n22070000            /*-------------------------------------------------------------------------*/\n22080000            /* IF SCAN SELECTION IS BEING USED WITH A FILE, PRINT THE SCAN_ARRAY:      */\n22090000            /*-------------------------------------------------------------------------*/\n22100000      PUT FILE(SMPDCTRY.FILEREF)\n22110000          EDIT('SCAN_ARRAY:')                                       (SKIP(1),COL(011),A)\n22120000              ('FILE SELECT OPTION IS:')                                    (COL(047),A)\n22130000              (SCAN_ARRAY.FILE(IFILE).SELECT_OPTION)                        (COL(071),A);\n22140000      DO  IPLANE = IPLANE_MIN TO IPLANE_MAX;\n22150000        IF   (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE)       /*IF PLANE IS ACTIVE*/\n22160000          THEN\n22170000            DO;\n22180000              PUT FILE(SMPDCTRY.FILEREF)\n22190000                  EDIT('PLANE(',IPLANE,'):')               (SKIP(1),COL(016),A,P'999',A)\n22200000                      ('PLANE SELECT OPTION IS:')                           (COL(046),A)\n22210000                      (SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).SELECT_OPTION)  (COL(071),A);\n22220000              DO  IROW = IROW_MIN TO IROW_MAX;\n22230000                IF   (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE)\n22240000                 THEN\n22250000                   DO;\n22260000                     PUT FILE(SMPDCTRY.FILEREF)\n22270000                         EDIT('ROW(',IROW,'):')            (SKIP(1),COL(022),A,P'999',A)\n22280000                             ('ROW SELECT OPTION IS:')                      (COL(048),A)\n22290000                             (SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).SELECT_OPTION)\n22300000                                                                            (COL(071),A);\n22310000                     DO  ICOL = ICOL_MIN TO ICOL_MAX;\n22320000                       IF  (SCAN_ARRAY(IFILE).STR_LEN(IPLANE,IROW,ICOL) > 0)  /*IF STRING*/\n22330000                         THEN  CALL  SMPDCTRY_INITIAL_FILE_FSE_INFO;\n22340000\n22350000                     END;          /*END OF ICOL          DO GROUP*/\n22360000                   END;            /*END OF ACTIVE IROW   DO GROUP*/\n22370000              END;                 /*END OF IROW          DO GROUP*/\n22380000            END;                   /*END OF ACTIVE IPLANE DO GROUP*/\n22390000      END;                         /*END OF IPLANE        DO GROUP*/\n22400000      RETURN;                      /*TO THE CALLER OF SMPDCTRY_INITIAL_FILE_FS_INFO*/\n22410000 %PAGE;\n22420000 SMPDCTRY_INITIAL_FILE_FSE_INFO:   /*SUBROUTINE INTERNAL TO SMPDCTRY_INITIAL_FILE_FS_INFO*/\n22430000   PROC;                            /*IFILE, IPLANE, IROW, AND ICOL ARE SET ON ENTRY   */\n22440000      PUT FILE(SMPDCTRY.FILEREF)\n22450000          EDIT('COL(',ICOL,'):')                           (SKIP(1),COL(026),A,P'999',A);\n22460000\n22470000      PUT FILE(SMPDCTRY.FILEREF)\n22480000          EDIT('OP=',\n22490000                SCAN_ARRAY(IFILE).OP(IPLANE,IROW,ICOL))              (COL(037),A,A(008));\n22500000\n22510000      IF   (SCAN_ARRAY(IFILE).STR_NIX(IPLANE,IROW,ICOL) <  NTRYINDX_MIN)\n22520000        THEN\n22530000          DO;\n22540000            PUT FILE(SMPDCTRY.FILEREF)\n22550000                EDIT('BEGIN POS=',\n22560000                      SCAN_ARRAY(IFILE).BEG_POS(IPLANE,IROW,ICOL))   (COL(049),A,P'999');\n22570000            PUT FILE(SMPDCTRY.FILEREF)\n22580000                EDIT('END POS=',\n22590000                      SCAN_ARRAY(IFILE).END_POS(IPLANE,IROW,ICOL))   (COL(064),A,P'999');\n22600000          END;\n22610000        ELSE\n22620000          DO;\n22630000            PUT FILE(SMPDCTRY.FILEREF)\n22640000                EDIT('ENTRY INDEX=',\n22650000                      SCAN_ARRAY(IFILE).STR_NIX(IPLANE,IROW,ICOL))   (COL(060),A,P'999');\n22660000          END;\n22670000\n22680000      PUT FILE(SMPDCTRY.FILEREF)\n22690000          EDIT('STR LEN=',\n22700000                SCAN_ARRAY(IFILE).STR_LEN(IPLANE,IROW,ICOL))         (COL(077),A,P'999');\n22710000\n22720000      PUT FILE(SMPDCTRY.FILEREF)\n22730000          EDIT('STRING=',\n22740000               '\"',SCAN_ARRAY(IFILE).STRING(IPLANE,IROW,ICOL),'\"')    (COL(090),A,A,A,A);\n22750000\n22760000   END SMPDCTRY_INITIAL_FILE_FSE_INFO;\n22770000  %SKIP(2);\n22780000   END SMPDCTRY_INITIAL_FILE_FS_INFO;\n22790000  %SKIP(2);\n22800000   END SMPDCTRY_INITIAL_FILE_F_INFO;\n22810000  %SKIP(2);\n22820000   END SMPDCTRY_INITIAL_FILE_INFO;\n22830000 %PAGE;\n22840000 SMPDCTRY_INITIAL_MATCH_INFO: /*THIS SUBROUTINE IS INTERNAL TO SMPDCTRY_INITIAL_INFO   */\n22850000   PROC;\n22860000      DCL  MATCH_LIST_LINE_CT      FIXED BINARY(15,0);\n22870000            /*-------------------------------------------------------------------------*/\n22880000            /* ASSEMBLE TITLE3 LINE AND BEGIN A NEW PAGE:                              */\n22890000            /*-------------------------------------------------------------------------*/\n22900000      SMPDCTRY.CURR_PAGE.TITLE3_DATA  =  ' MATCH  ';\n22910000      SUBSTR(SMPDCTRY.CURR_PAGE.TITLE3_DATA,026)\n22920000                                      =  'STATUS INFORMATION AND MATCH ARRAY CONTENTS:';\n22930000\n22940000      SIGNAL ENDPAGE(SMPDCTRY.FILEREF)/**/;                          /*START A NEW PAGE*/\n22950000\n22960000            /*-------------------------------------------------------------------------*/\n22970000            /* PRINT MATCH_ARRAY CONTENTS AND STATUS INFORMATION:                      */\n22980000            /*-------------------------------------------------------------------------*/\n22990000      IF  (SMPLIST_CNTL.A_MATCH.ACTIVE)           /*TEST FOR ENTRY MATCH TESTS PROVIDED*/\n23000000        THEN                              /*IF ANY ENTRY MATCH TESTS HAVE BEEN PROVIDED*/\n23010000          DO    IMATCH = IMATCH_MIN TO IMATCH_MAX;\n23020000            IF    SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE    /*IF MATCH ENTRY ACTIVE*/\n23030000              THEN                                  /*WHEN MATCH ARRAY ENTRY IS   ACTIVE*/\n23040000                  CALL  SMPDCTRY_INITIAL_MATCH_E_INFO;\n23050000              ELSE                                  /*WHEN MATCH ARRAY ENTRY IS INACTIVE*/\n23060000               /* CALL  SMPDCTRY_INITIAL_MATCH_E_INFO/**/;\n23070000          END;                    /*END OF IMATCH DO GROUP*/\n23080000\n23090000        ELSE                      /*IF NO  ENTRY MATCH TESTS HAVE BEEN PROVIDED*/\n23100000            PUT FILE(SMPDCTRY.FILEREF)\n23110000                EDIT('***MATCH ARRAY IS NOT ACTIVE -- ')             (SKIP(3),COL(016),A)\n23120000                    ('FILE MATCHING WILL BE BASED ON SCAN RESULTS***')                (A);\n23130000\n23140000      RETURN;                    /*TO THE CALLER OF SMPDCTRY_INITIAL_MATCH_INFO*/\n23150000 %PAGE;\n23160000 SMPDCTRY_INITIAL_MATCH_E_INFO:\n23170000                             /*THIS SUBROUTINE IS INTERNAL TO SMPDCTRY_INITIAL_MATCH_INFO*/\n23180000   PROC;\n23190000            /*-------------------------------------------------------------------------*/\n23200000            /* PRINT MATCH_ARRAY ENTRY CONTENTS AND STATUS INFORMATION:                */\n23210000            /*-------------------------------------------------------------------------*/\n23220000      IF    SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE         /*IF MATCH ENTRY ACTIVE*/\n23230000        THEN  MATCH_LIST_LINE_CT  =  01 + SMPLIST_CNTL.A_STAT.#_F_ACTIVE;\n23240000        ELSE  MATCH_LIST_LINE_CT  =  01;\n23250000\n23260000      IF (LINENO(SMPDCTRY.FILEREF) <= (SMPDCTRY.PAGE_SZ - (MATCH_LIST_LINE_CT + 02)))\n23270000        THEN                                      /*IF LISTING WILL FIT ON CURRENT PAGE*/\n23280000            IF (LINENO(SMPDCTRY.FILEREF) >= SMPDCTRY.CURR_PAGE.INFO_1STLINE)\n23290000              THEN PUT FILE(SMPDCTRY.FILEREF)  SKIP(2);      /*CONTINUE ON CURRENT PAGE*/\n23300000              ELSE PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);      /*CONTINUE ON CURRENT PAGE*/\n23310000        ELSE                                     /*IF LISTING WON'T FIT ON CURRENT PAGE*/\n23320000            IF (LINENO(SMPDCTRY.FILEREF) >= SMPDCTRY.CURR_PAGE.INFO_1STLINE)\n23330000              THEN SIGNAL ENDPAGE(SMPDCTRY.FILEREF);         /*START ON A NEW PAGE     */\n23340000              ELSE PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);      /*CONTINUE ON CURRENT PAGE*/\n23350000\n23360000      PUT FILE(SMPDCTRY.FILEREF)\n23370000          EDIT('ENTRY(',IMATCH,'):')                                (COL(001),A,P'999',A)\n23380000              ('ENTRY   TYPE=')                                              (COL(015),A)\n23390000              ( MATCH_ARRAY.ENTRY(IMATCH).TYPE)                                       (A);\n23400000\n23410000      IF    SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE         /*IF MATCH ENTRY ACTIVE*/\n23420000        THEN                                         /*WHEN MATCH ARRAY ENTRY IS ACTIVE*/\n23430000            CALL  SMPDCTRY_INITIAL_MATCH_F_INFO;\n23440000        ELSE                                     /*WHEN MATCH ARRAY ENTRY IS NOT ACTIVE*/\n23450000            PUT FILE(SMPDCTRY.FILEREF)\n23460000                EDIT('***ENTRY IS NOT ACTIVE***')                            (COL(036),A);\n23470000\n23480000      RETURN;                    /*TO THE CALLER OF SMPDCTRY_INITIAL_MATCH_E_INFO*/\n23490000 %PAGE;\n23500000 SMPDCTRY_INITIAL_MATCH_F_INFO:\n23510000                           /*THIS SUBROUTINE IS INTERNAL TO SMPDCTRY_INITIAL_MATCH_E_INFO*/\n23520000   PROC;\n23530000      DCL  MATCH_FILE_LINE_NO      FIXED BINARY(15,0);\n23540000            /*-------------------------------------------------------------------------*/\n23550000            /* PRINT FILE MATCH INFORMATION FOR THE MATCH_ARRAY ENTRY:                 */\n23560000            /*-------------------------------------------------------------------------*/\n23570000      MATCH_FILE_LINE_NO = 0;                           /*PRESET FOR IFILE DO GROUP*/\n23580000      DO   IFILE = IFILE_MIN TO IFILE_MAX;\n23590000        IF (SMPLIST(IFILE).ACTIVE)                /*ONE LINE FOR EACH ACTIVE INPUT FILE*/\n23600000          THEN                                                  /*IF THE FILE IS ACTIVE*/\n23610000            DO;\n23620000              MATCH_FILE_LINE_NO = MATCH_FILE_LINE_NO + 1;\n23630000\n23640000              IF    (MATCH_FILE_LINE_NO = 1)\n23650000                THEN PUT FILE(SMPDCTRY.FILEREF)     SKIP(1)\n23660000                         EDIT('COMPARE TEST=')                               (COL(015),A)\n23670000                             ( MATCH_ARRAY.ENTRY(IMATCH).COMPARE_TEST)                (A);\n23680000                ELSE PUT FILE(SMPDCTRY.FILEREF)     SKIP(1);\n23690000\n23700000              PUT FILE(SMPDCTRY.FILEREF)\n23710000                  EDIT('FILE(',IFILE,'):')                          (COL(036),A,P'999',A)\n23720000                      ('COMPARE: OPTION=')                                   (COL(048),A)\n23730000                      ( MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION)    (A(009));\n23740000              IF       (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION \u00ac= 'NOCOMPARE')\n23750000                THEN PUT FILE(SMPDCTRY.FILEREF)\n23760000                         EDIT('SELECT=')                                         (X(2),A)\n23770000                             ( MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_SELECT)\n23780000                                                                                 (A(008));\n23790000              PUT FILE(SMPDCTRY.FILEREF)\n23800000                  EDIT('WRITE: OPTION=')                                     (COL(094),A)\n23810000                      ( MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_OPTION)      (A(007));\n23820000              IF       (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_OPTION \u00ac= 'NOWRITE')\n23830000                THEN PUT FILE(SMPDCTRY.FILEREF)\n23840000                         EDIT('SELECT=')                                         (X(2),A)\n23850000                             ( MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_SELECT)\n23860000                                                                                 (A(008));\n23870000            END;                  /*END OF ACTIVE IFILE DO GROUP*/\n23880000      END;                        /*END OF IFILE DO GROUP*/\n23890000\n23900000   END SMPDCTRY_INITIAL_MATCH_F_INFO;\n23910000  %SKIP(1);\n23920000   END SMPDCTRY_INITIAL_MATCH_E_INFO;\n23930000  %SKIP(1);\n23940000   END SMPDCTRY_INITIAL_MATCH_INFO;\n23950000  %SKIP(2);\n23960000   END SMPDCTRY_INITIAL_INFO;\n23970000 %PAGE;\n23980000 SMPDCTRY_ENTRY_INFO:            /********************************************************/\n23990000                                 /*                                                      */\n24000000                                 /*                                                      */\n24010000                                 /********************************************************/\n24020000   PROC;\n24030000      DCL  ENTRY_INFO_LINE_NO      FIXED BINARY(15,0);\n24040000\n24050000      ON ENDPAGE(SMPDCTRY.FILEREF) CALL SMPDCTRY_NEWPAGE;\n24060000\n24070000            /*-------------------------------------------------------------------------*/\n24080000            /* IF THIS IS THE FIRST ENTRY BEING REPORTED, OR IF THE ENTRY TYPE IS      */\n24090000            /* CHANGING, ASSEMBLE NEW TITLE2 AND TITLE3 LINES:                         */\n24100000            /*-------------------------------------------------------------------------*/\n24110000      IF     (SMPDCTRY.CURR_PAGE.NTRYINDX  <  NTRYINDX_MIN)   /*IF FIRST ENTRY TO WRITE*/\n24120000          |                                                   /*OR NEW ENTRY TYPE      */\n24130000             (SMPDCTRY.CURR_PAGE.NTRYINDX  \u00ac= SMPLIST_CNTL.E_CMPR.NTRYINDX)\n24140000        THEN\n24150000          DO;                                /*ASSEMBLE TITLES 2 & 3 FOR NEW ENTRY TYPE*/\n24160000            SMPDCTRY.CURR_PAGE.TITLE2_DATA  =    'DIRECTORY OF MATCHING'\n24170000                                              ||  ' '\n24180000                                              ||  ENTRY_TYPE(SMPLIST_CNTL.E_CMPR.NTRYINDX)\n24190000                                              ||  ' '\n24200000                                              ||  'ENTRIES:';\n24210000            SMPDCTRY.CURR_PAGE.TITLE3_DATA  =     '  NAME  ';\n24220000            SUBSTR(SMPDCTRY.CURR_PAGE.TITLE3_DATA,026)  =  'STATUS';\n24230000            SUBSTR(SMPDCTRY.CURR_PAGE.TITLE3_DATA,066)  =  'LOCATOR INFORMATION';\n24240000          END;\n24250000     %PAGE;\n24260000            /*-------------------------------------------------------------------------*/\n24270000            /* DETERMINE WHETHER TO START A NEW PAGE, REPRINT TITLES 2 & 3 OF THE      */\n24280000            /* CURRENT PAGE, OR MERELY SPACE ONE LINE BEFORE STARTING TO PRINT THE     */\n24290000            /* ENTRY INFORMATION FOR THE CURRENT MATCHING ENTRY:                       */\n24300000            /*-------------------------------------------------------------------------*/\n24310000      IF     (SMPDCTRY.CURR_PAGE.NTRYINDX  <  NTRYINDX_MIN)   /*IF FIRST ENTRY TO WRITE*/\n24320000\n24330000        |    (SMPDCTRY.CURR_PAGE.NTRYINDX  \u00ac= SMPLIST_CNTL.E_CMPR.NTRYINDX\n24340000           & (LINENO(SMPDCTRY.FILEREF)                     /*IF NOT ENOUGH ROOM ON PAGE*/\n24350000                 >  (SMPDCTRY.PAGE_SZ - (SMPLIST_CNTL.A_STAT.#_F_ACTIVE + 01 + 05))))\n24360000\n24370000        |    (SMPDCTRY.CURR_PAGE.NTRYINDX   = SMPLIST_CNTL.E_CMPR.NTRYINDX\n24380000           & (LINENO(SMPDCTRY.FILEREF)                     /*IF NOT ENOUGH ROOM ON PAGE*/\n24390000                 >  (SMPDCTRY.PAGE_SZ - (SMPLIST_CNTL.A_STAT.#_F_ACTIVE + 01))))\n24400000\n24410000        THEN      SIGNAL ENDPAGE(SMPDCTRY.FILEREF);      /*START ON A NEW PAGE         */\n24420000        ELSE                                             /*CONTINUE ON THE CURRENT PAGE*/\n24430000          IF (SMPDCTRY.CURR_PAGE.NTRYINDX  \u00ac= SMPLIST_CNTL.E_CMPR.NTRYINDX)\n24440000\n24450000          /*THEN    CALL SMPDCTRY_NEWTITLE_2_3           /*REWRITE TITLE LINES 2 & 3   */\n24460000            THEN  SIGNAL ENDPAGE(SMPDCTRY.FILEREF)       /*START ON A NEW PAGE ANYWAYS */;\n24470000            ELSE    PUT  FILE(SMPDCTRY.FILEREF)  SKIP(1);  /*SPACE ONE LINE            */\n24480000     %SKIP(3);\n24490000            /*-------------------------------------------------------------------------*/\n24500000            /* PRINT THE ENTRY INFORMATION REPORT LINES FOR THE CURRENT MATCHING       */\n24510000            /* ENTRY:                                                                  */\n24520000            /*-------------------------------------------------------------------------*/\n24530000\n24540000      SMPDCTRY.CURR_PAGE.NTRYINDX  = SMPLIST_CNTL.E_CMPR.NTRYINDX;\n24550000      ENTRY_INFO_LINE_NO           = 0;          /*RESET ENTRY INFORMATION LINE COUNTER*/\n24560000\n24570000      DO  IFILE = IFILE_MIN TO IFILE_MAX;         /*WRITE LOCATOR INFORMATION FOR ENTRY*/\n24580000        IF   (SMPLIST(IFILE).ACTIVE)              /*ONE LINE FOR EACH ACTIVE INPUT FILE*/\n24590000          THEN                                                  /*IF THE FILE IS ACTIVE*/\n24600000               CALL SMPDCTRY_ENTRY_FILE_INFO;\n24610000      END;                               /*END OF IFILE DO GROUP*/\n24620000\n24630000      RETURN;                                    /*TO THE CALLER OF SMPDCTRY_ENTRY_INFO*/\n24640000 %PAGE;\n24650000 SMPDCTRY_ENTRY_FILE_INFO:\n24660000   PROC;                       /*IFILE IS SET ON ENTRY TO SMPDCTRY_ENTRY_FILE_INFO     */\n24670000            /*-------------------------------------------------------------------------*/\n24680000            /* PRINT THE ENTRY INFORMATION REPORT LINE FOR THIS SMPLIST DATA SET:      */\n24690000            /*-------------------------------------------------------------------------*/\n24700000\n24710000      ENTRY_INFO_LINE_NO  =  ENTRY_INFO_LINE_NO  +  1;            /*UPDATE LINE COUNTER*/\n24720000\n24730000      IF    ENTRY_INFO_LINE_NO <= 01\n24740000        THEN  PUT FILE(SMPDCTRY.FILEREF)  SKIP(1)                 /*  ENTRY NAME       */\n24750000                  EDIT(SMPLIST_CNTL.E_CMPR.NTRYNAME)                       (COL(001),A);\n24760000        ELSE  PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);                /*SPACE ONE LINE     */\n24770000\n24780000      PUT FILE(SMPDCTRY.FILEREF)\n24790000          EDIT('ZONE=',SMPLIST(IFILE).CURR_NTRY.ZONENAME)                (COL(011),A,A)\n24800000                  ('/',SMPLIST(IFILE).CURR_NTRY.ZONETYPE_C)                       (A,A);\n24810000     %PAGE;\n24820000      IF    SMPLIST(IFILE).ENTRY_TOTALS(SMPLIST_CNTL.E_CMPR.NTRYINDX).ENTRY_CT > 0\n24830000        THEN                                     /*IF ENTRIES OF THIS TYPE WERE LISTED*/\n24840000          DO;\n24850000            IF   (SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT)\n24860000              THEN                           /*IF ENTRY WAS FOUND IN THIS LISTING FILE*/\n24870000                DO;\n24880000                  CALL SMPDCTRY_ENTRY_FILE_STYPE_INFO;          /*FILL IN COLS 026-040*/\n24890000                  PUT FILE(SMPDCTRY.FILEREF)                              /*LINE COUNT*/\n24900000                      EDIT('LNCT=',SMPLIST(IFILE).CURR_NTRY.LINE_CT) (COL(041),A,P'9999');\n24910000                  IF  SMPLIST(IFILE).CURR_NTRY.LINE_CT >  LINE_SAVE_LIMIT /*SPILL FILE*/\n24920000                    THEN     PUT FILE(SMPDCTRY.FILEREF) EDIT('>UT<')            (X(1),A);\n24930000                    ELSE     PUT FILE(SMPDCTRY.FILEREF) EDIT('    ')            (X(1),A);\n24940000\n24950000                  IF      SMPLIST(IFILE).SCAN_CUBE.ACTIVE               /*SCAN ACTIVE?*/\n24960000                    THEN\n24970000                      IF  SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT          /*SCAN RESULTS*/\n24980000                        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT('SCAN=','SEL') (COL(056),A,A);\n24990000                        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('SCAN=','XCL') (COL(056),A,A);\n25000000                    ELSE     PUT FILE(SMPDCTRY.FILEREF) EDIT('SCAN=','NOT') (COL(056),A,A);\n25010000\n25020000                  PUT FILE(SMPDCTRY.FILEREF)               /*INPUT LISTING PAGE NUMBER*/\n25030000                      EDIT(SUBSTR(SMPLIST(IFILE).DDNAME,004),'PG=',\n25040000                           SMPLIST(IFILE).CURR_NTRY.PAGE_NO)    (X(2),A,X(1),A,P'Z9999');\n25050000\n25060000                  IF (SMPLIST(IFILE).CURR_NTRY.WRITE_OUT)\n25070000                    THEN                /*IF ENTRY WAS WRITTEN TO OUTPUT DATA SETS*/\n25080000                        CALL SMPDCTRY_ENTRY_FILE_WRT_INFO;\n25090000                    ELSE                /*IF ENTRY WAS NOT WRITTEN TO OUTPUT DATA SETS*/\n25100000                        PUT FILE(SMPDCTRY.FILEREF) EDIT('**ENTRY NOT WRITTEN**') (X(2),A);\n25110000                END;                       /*END OF SUCCESSFUL CMPR_RESULT DO GROUP*/\n25120000\n25130000              ELSE                      /*IF ENTRY WAS NOT FOUND IN THIS LISTING FILE*/\n25140000                    PUT FILE(SMPDCTRY.FILEREF)  EDIT('**ENTRY NOT FOUND**')  (COL(056),A);\n25150000          END;                          /*END OF POSITIVE ENTRY_CT DO GROUP*/\n25160000        ELSE                            /*IF ENTRIES OF THIS TYPE WERE NOT LISTED*/\n25170000            PUT FILE(SMPDCTRY.FILEREF)\n25180000                EDIT('***',ENTRY_TYPE(SMPLIST_CNTL.E_CMPR.NTRYINDX),\n25190000                     'ENTRIES NOT FOUND***')                        (COL(056),A,A,X(1),A);\n25200000      RETURN;                           /*TO THE CALLER OF SMPDCTRY_ENTRY_FILE_INFO*/\n25210000 %PAGE;\n25220000 SMPDCTRY_ENTRY_FILE_STYPE_INFO:\n25230000   PROC;                     /*IFILE IS SET ON ENTRY TO SMPDCTRY_ENTRY_FILE_STYPE_INFO */\n25240000      SELECT;\n25250000        WHEN((SMPLIST(IFILE).CURR_NTRY.FMID        \u00ac=  ' ')         /*FMID*/\n25260000           & (SMPLIST(IFILE).CURR_NTRY.ZONETYPE_C  \u00ac=  'G'))\n25270000          PUT FILE(SMPDCTRY.FILEREF)\n25280000              EDIT(' FMID=',SMPLIST(IFILE).CURR_NTRY.FMID)    (COL(026),A,A);\n25290000\n25300000        WHEN((SMPLIST(IFILE).CURR_NTRY.SOURCEID    \u00ac=  ' '))       /*SRCID*/\n25310000          PUT FILE(SMPDCTRY.FILEREF)\n25320000              EDIT('SRCID=',SMPLIST(IFILE).CURR_NTRY.SOURCEID) (COL(026),A,A);\n25330000\n25340000        WHEN((SMPLIST(IFILE).CURR_NTRY.SYSLIB1     \u00ac=  ' ')      /*SYSLIB1*/\n25350000           & (SMPLIST(IFILE).CURR_NTRY.SYSLIB2      =  ' '))     /*SYSLIB2*/\n25360000          PUT FILE(SMPDCTRY.FILEREF)\n25370000              EDIT(' SLIB=',SMPLIST(IFILE).CURR_NTRY.SYSLIB1)  (COL(026),A,A);\n25380000\n25390000        WHEN((SMPLIST(IFILE).CURR_NTRY.SYSLIB1     \u00ac=  ' ')      /*SYSLIB1*/\n25400000           & (SMPLIST(IFILE).CURR_NTRY.SYSLIB2     \u00ac=  ' '))     /*SYSLIB2*/\n25410000          PUT FILE(SMPDCTRY.FILEREF)\n25420000              EDIT('SLIB1=',SMPLIST(IFILE).CURR_NTRY.SYSLIB1)  (COL(026),A,A);\n25430000\n25440000        OTHERWISE;\n25450000      END;\n25460000   END SMPDCTRY_ENTRY_FILE_STYPE_INFO;\n25470000 %PAGE;\n25480000 SMPDCTRY_ENTRY_FILE_WRT_INFO:\n25490000   PROC;                       /*IFILE IS SET ON ENTRY TO SMPDCTRY_ENTRY_FILE_WRT_INFO */\n25500000      PUT FILE(SMPDCTRY.FILEREF)\n25510000          EDIT(SUBSTR(SMPSCAN(IFILE).DDNAME,004),'PG=')                  (X(2),A,X(1),A);\n25520000      IF (SMPSCAN(IFILE).ACTIVE  & SMPSCAN(IFILE).OPEN)\n25530000        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT(SMPSCAN(IFILE).CURR_NTRY.PAGE_NO) (P'Z9999');\n25540000        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('-----')                                 (A);\n25550000\n25560000      PUT FILE(SMPDCTRY.FILEREF)\n25570000          EDIT(SUBSTR(SMPSOUT(IFILE).DDNAME,004),'PG=')                  (X(2),A,X(1),A);\n25580000      IF (SMPSOUT(IFILE).ACTIVE  & SMPSOUT(IFILE).OPEN)\n25590000        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT(SMPSOUT(IFILE).CURR_NTRY.PAGE_NO) (P'Z9999');\n25600000        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('-----')                                 (A);\n25610000\n25620000      PUT FILE(SMPDCTRY.FILEREF)\n25630000          EDIT(SUBSTR(SMPDATA(IFILE).DDNAME,004),'SQ=')                  (X(2),A,X(1),A);\n25640000      IF (SMPDATA(IFILE).ACTIVE  & SMPDATA(IFILE).OPEN)\n25650000        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT(SMPDATA(IFILE).CURR_NTRY.SEQ_NO)\n25660000                                                                           (P'99999999');\n25670000        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('--------')                             (A);\n25680000\n25690000   END SMPDCTRY_ENTRY_FILE_WRT_INFO;\n25700000  %SKIP(3);\n25710000   END SMPDCTRY_ENTRY_FILE_INFO;\n25720000  %SKIP(3);\n25730000   END SMPDCTRY_ENTRY_INFO;\n25740000 %PAGE;\n25750000 SMPDCTRY_FINAL_INFO:\n25760000   PROC;\n25770000\n25780000            /*-------------------------------------------------------------------------*/\n25790000            /* ASSEMBLE TITLE2/3 LINES AND SET UP END-OF-PAGE CONTROL:                 */\n25800000            /*-------------------------------------------------------------------------*/\n25810000\n25820000      SMPDCTRY.CURR_PAGE.NTRYINDX     =  NTRYINDX_MAX + 1;\n25830000      SMPDCTRY.CURR_PAGE.TITLE2_DATA  = 'FINAL PROCESSING TOTALS:';\n25840000      SMPDCTRY.CURR_PAGE.TITLE3_DATA  =  '  FILE  ';\n25850000      SUBSTR(SMPDCTRY.CURR_PAGE.TITLE3_DATA,035)\n25860000                                      =  'FINAL TOTALS BY FILE AND ENTRY TYPE:';\n25870000\n25880000      ON ENDPAGE(SMPDCTRY.FILEREF)        CALL SMPDCTRY_NEWPAGE;\n25890000      SIGNAL ENDPAGE(SMPDCTRY.FILEREF);              /*START FINAL TOTALS ON A NEW PAGE*/\n25900000\n25910000            /*-------------------------------------------------------------------------*/\n25920000            /* PRINT FINAL TOTALS AND OTHER INFORMATION FOR SUPPORTED, ACTIVE FILES:   */\n25930000            /*-------------------------------------------------------------------------*/\n25940000\n25950000      DO        IFILE = IFILE_MIN TO IFILE_MAX;               /*FOR EACH SUPPORTED FILE*/\n25960000        IF     (SMPLIST(IFILE).ACTIVE)      /*PRODUCE TOTALS FOR EACH ACTIVE INPUT FILE*/\n25970000          THEN  CALL  SMPDCTRY_FINAL_FILE_F_T_INFO;\n25980000      END;\n25990000\n26000000      RETURN;                    /*TO THE CALLER OF SMPDCTRY_FINAL_INFO*/\n26010000 %PAGE;\n26020000 SMPDCTRY_FINAL_FILE_F_T_INFO:   /*THIS SUBROUTINE IS INTERNAL TO SMPDCTRY_FINAL_INFO  */\n26030000   PROC;                         /*IFILE IS SET ON ENTRY TO SMPDCTRY_FINAL_FILE_INFO   */\n26040000\n26050000      DCL  FILE_LIST_LINE_CT       FIXED BINARY(15,0);\n26060000\n26070000            /*-------------------------------------------------------------------------*/\n26080000            /* BEGIN A NEW PAGE FOR THIS FILE'S TOTALS IF NECESSARY:                   */\n26090000            /*-------------------------------------------------------------------------*/\n26100000        FILE_LIST_LINE_CT =        01                      /*FIRST FILE LINE*/\n26110000                              +    01                      /*SPILL FILE LINE*/\n26120000                              +    SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT\n26130000                              + 3*(SMPLIST(IFILE).FILE_TOTALS.#_E_T_FOUND+01);\n26140000\n26150000        IF         (LINENO(SMPDCTRY.FILEREF) <= (SMPDCTRY.PAGE_SZ -(FILE_LIST_LINE_CT+02)))\n26160000            THEN                                 /*IF LISTING WILL FIT ON CURRENT PAGE*/\n26170000                IF (LINENO(SMPDCTRY.FILEREF) >  SMPDCTRY.CURR_PAGE.INFO_1STLINE)\n26180000                 THEN PUT FILE(SMPDCTRY.FILEREF)  SKIP(2);   /*CONTINUE ON CURRENT PAGE*/\n26190000                 ELSE PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);   /*CONTINUE ON CURRENT PAGE*/\n26200000            ELSE                                 /*IF LISTING WON'T FIT ON CURRENT PAGE*/\n26210000                IF (LINENO(SMPDCTRY.FILEREF) >  SMPDCTRY.CURR_PAGE.INFO_1STLINE)\n26220000                 THEN SIGNAL ENDPAGE(SMPDCTRY.FILEREF);      /*START ON A NEW PAGE     */\n26230000                 ELSE PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);   /*CONTINUE ON CURRENT PAGE*/\n26240000     %PAGE;\n26250000            /*-------------------------------------------------------------------------*/\n26260000            /* WRITE OUT STATUS AND CONTROL INFORMATION FOR EACH FILE:                 */\n26270000            /*-------------------------------------------------------------------------*/\n26280000      PUT FILE(SMPDCTRY.FILEREF)\n26290000          EDIT('FILE(',IFILE,'):')                                 (COL(001),A,P'999',A);\n26300000      PUT FILE(SMPDCTRY.FILEREF)\n26310000          EDIT('LIST  DDNAME=',SMPLIST(IFILE).DDNAME)                     (COL(012),A,A)\n26320000              ('HIGHEST PAGE=',SMPLIST(IFILE).CURR_PAGE.PAGE_NO)\n26330000                                                              (COL(035),A,X(3),P'Z9999')\n26340000              ('TOTAL LINES READ=',SMPLIST(IFILE).FILE_TOTALS.RCRD_CT)\n26350000                                                         (COL(058),A,X(2),P'ZZ,ZZZ,ZZ9')\n26360000              ('ENTRY LINES READ=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LINE_CT)\n26370000                                                              (COL(103),A,P'ZZ,ZZZ,ZZ9');\n26380000\n26390000      PUT FILE(SMPDCTRY.FILEREF)                      SKIP(1)\n26400000          EDIT('SPILL DDNAME=',SMPUT(IFILE).DDNAME)                       (COL(012),A,A)\n26410000              ('WRITE:')                                                    (COL(035),A)\n26420000              ('SAVECT=',SMPUT(IFILE).WRITE.SAVE_CT)                  (X(2),A,P'ZZ,ZZ9')\n26430000              ('OPENCT=',SMPUT(IFILE).WRITE.OPEN_CT)                  (X(2),A,P'ZZ,ZZ9')\n26440000              ('LINECT=',SMPUT(IFILE).WRITE.LINE_CT)                 (X(2),A,P'ZZZ,ZZ9')\n26450000              ('READ:')                                                     (COL(094),A)\n26460000              ('OPENCT=',SMPUT(IFILE).READ.OPEN_CT)                   (X(2),A,P'ZZ,ZZ9')\n26470000              ('LINECT=',SMPUT(IFILE).READ.LINE_CT)                  (X(2),A,P'ZZZ,ZZ9');\n26480000\n26490000      IF  (SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE))          /*IF FILE COULD HAVE HAD OUTPUT*/\n26500000        THEN   CALL SMPDCTRY_FINAL_FILE_F_W_INFO;\n26510000\n26520000\n26530000      DO  NTRYINDX_IX = NTRYINDX_MIN TO NTRYINDX_MAX+1;\n26540000        IF    (SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).ENTRY_CT >  0)\n26550000            | (NTRYINDX_IX  =  NTRYINDX_MAX+1)\n26560000          THEN CALL SMPDCTRY_FINAL_FILE_E_T_INFO;\n26570000      END;\n26580000\n26590000      RETURN;                    /*TO THE CALLER OF SMPDCTRY_FINAL_FILE_F_T_INFO*/\n26600000 %PAGE;\n26610000 SMPDCTRY_FINAL_FILE_F_W_INFO:          /*THIS SUBROUTINE IS INTERNAL TO                 */\n26620000                                        /*SMPDCTRY_FINAL_FILE_F_W_INFO.                  */\n26630000   PROC;                                /*IFILE IS SET ON ENTRY.                         */\n26640000\n26650000      PUT FILE(SMPDCTRY.FILEREF)                      SKIP(1)\n26660000          EDIT('SCAN  DDNAME=',SMPSCAN(IFILE).DDNAME)                     (COL(012),A,A)\n26670000              ('HIGHEST PAGE=')                                             (COL(035),A);\n26680000      IF (SMPSCAN(IFILE).ACTIVE  & SMPSCAN(IFILE).OPEN)\n26690000        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT(SMPSCAN(IFILE).CURR_PAGE.PAGE_NO)\n26700000                                                                          (X(3),P'Z9999');\n26710000        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('-----')                            (X(3),A);\n26720000\n26730000      PUT FILE(SMPDCTRY.FILEREF)                      SKIP(1)\n26740000          EDIT('SOUT  DDNAME=',SMPSOUT(IFILE).DDNAME)                     (COL(012),A,A)\n26750000              ('HIGHEST PAGE=')                                             (COL(035),A);\n26760000      IF (SMPSOUT(IFILE).ACTIVE  & SMPSOUT(IFILE).OPEN)\n26770000        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT(SMPSOUT(IFILE).CURR_PAGE.PAGE_NO)\n26780000                                                                          (X(3),P'Z9999');\n26790000        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('-----')                            (X(3),A);\n26800000\n26810000      PUT FILE(SMPDCTRY.FILEREF)                      SKIP(1)\n26820000          EDIT('DATA  DDNAME=',SMPSCAN(IFILE).DDNAME)                     (COL(012),A,A)\n26830000              ('HIGHEST SEQ#=')                                             (COL(035),A);\n26840000      IF (SMPDATA(IFILE).ACTIVE  & SMPDATA(IFILE).OPEN)\n26850000        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT(SMPDATA(IFILE).CURR_CARD.SEQ_NO)  (P'(8)9');\n26860000        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('--------')                             (A);\n26870000\n26880000   END SMPDCTRY_FINAL_FILE_F_W_INFO;\n26890000 %PAGE;\n26900000 SMPDCTRY_FINAL_FILE_E_T_INFO:          /*THIS SUBROUTINE IS INTERNAL TO                 */\n26910000                                        /*SMPDCTRY_FINAL_FILE_F_T_INFO.                  */\n26920000   PROC;                                /*IFILE AND NTRYINDX_IX ARE SET ON ENTRY.        */\n26930000\n26940000      SELECT;                   /*SELECT LINE HEADING FOR ENTRY_INDEX*/\n26950000         WHEN(NTRYINDX_IX <= NTRYINDX_MAX)\n26960000             PUT FILE(SMPDCTRY.FILEREF)               SKIP(1)\n26970000                 EDIT(ENTRY_TYPE(NTRYINDX_IX),'ENTRIES:')            (COL(012),A,X(1),A);\n26980000         WHEN(NTRYINDX_IX  = NTRYINDX_MAX+1)\n26990000             PUT FILE(SMPDCTRY.FILEREF)               SKIP(1)\n27000000                 EDIT('ALL ENTRY TYPES:')                                   (COL(012),A);\n27010000         OTHERWISE;\n27020000      END;\n27030000\n27040000      PUT FILE(SMPDCTRY.FILEREF)\n27050000          EDIT('INPUT TOTALS:')                                            (COL(035),A)\n27060000              ('FIRST PAGE=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LIST_PAGELO)\n27070000                                                             (COL(058),A,X(2),P'Z9999')\n27080000              ('LAST PAGE=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LIST_PAGEHI)\n27090000                                                             (COL(081),A,X(2),P'Z9999')\n27100000              ('ENTRY LINES READ=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LINE_CT)\n27110000                                                             (COL(103),A,P'ZZ,ZZZ,ZZ9');\n27120000\n27130000      PUT FILE(SMPDCTRY.FILEREF)                       SKIP(1)\n27140000          EDIT('ENTRY TOTALS:')                                             (COL(035),A)\n27150000              ('READ=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).ENTRY_CT)\n27160000                                                                 (COL(058),A,P'ZZZ,ZZ9')\n27170000              ('SELECTED=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).SELECT_CT)\n27180000                                                                 (COL(075),A,P'ZZZ,ZZ9')\n27190000              ('MATCHED=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MATCH_CT)\n27200000                                                                 (COL(096),A,P'ZZZ,ZZ9')\n27210000              ('WRITTEN=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).WRITE_CT)\n27220000                                                                 (COL(115),A,P'ZZZ,ZZ9');\n27230000      PUT FILE(SMPDCTRY.FILEREF)                      SKIP(1)\n27240000          EDIT('LARGEST ENTRY:')                                            (COL(035),A)\n27250000              ('NAME=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXNAME)  (COL(058),A,A)\n27260000              ('LINECT=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXLINE)\n27270000                                                                 (COL(077),A,P'ZZZ,ZZ9')\n27280000              ('PAGE=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXPAGE)\n27290000                                                              (COL(099),A,X(2),P'Z9999');\n27300000   END SMPDCTRY_FINAL_FILE_E_T_INFO;\n27310000  %SKIP(1);\n27320000   END SMPDCTRY_FINAL_FILE_F_T_INFO;\n27330000  %SKIP(2);\n27340000   END SMPDCTRY_FINAL_INFO;\n27350000 %PAGE;\n27360000 CONTROL_VALUE_INPUT:\n27370000   PROC;\n27380000    /******************************************************************/\n27390000    /*   ALLOCATE EXECUTION CONTROL VARIABLE STRUCTURES               */\n27400000    /******************************************************************/\n27410000      ALLOCATE   FILE_ACTIVE_OPTION;\n27420000      ALLOCATE   MATCH_ARRAY;\n27430000      ALLOCATE   SCAN_ARRAY;\n27440000      ALLOCATE   DATA_OUTPUT_OPTION;\n27450000    /******************************************************************/\n27460000    /*   INITIALIZE EXECUTION CONTROL VARIABLE VALUES                 */\n27470000    /******************************************************************/\n27480000      DO IFILE = IFILE_MIN TO IFILE_MAX;\n27490000              FILE_ACTIVE_OPTION(IFILE)              = '';\n27500000              DATA_OUTPUT_OPTION(IFILE)              = '';\n27510000              SCAN_ARRAY.FILE(IFILE).SELECT_OPTION   = '';\n27520000\n27530000        DO IPLANE = IPLANE_MIN TO IPLANE_MAX;\n27540000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).SELECT_OPTION   = '';\n27550000\n27560000          DO IROW = IROW_MIN TO IROW_MAX;\n27570000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).SELECT_OPTION   = '';\n27580000\n27590000            DO ICOL = ICOL_MIN TO ICOL_MAX;\n27600000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).BEG_POS  =\n27610000                                                                  LIST_LINE_DBGN - 001;\n27620000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).END_POS  =\n27630000                                                                  LIST_LINE_DEND + 001;\n27640000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).POS_LEN  =  000;\n27650000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).OP       = '';\n27660000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).OP_OIX   =  000;\n27670000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).STRING   = '';\n27680000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).STR_LEN  =  000;\n27690000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).STR_NIX  =\n27700000                                                                        NTRYINDX_MIN-1;\n27710000            END;           /*END OF ICOL   DO GROUP*/\n27720000\n27730000          END;             /*END OF IROW   DO GROUP*/\n27740000        END;               /*END OF IPLANE DO GROUP*/\n27750000      END;                 /*END OF IFILE  DO GROUP*/\n27760000\n27770000      DO IMATCH = IMATCH_MIN TO IMATCH_MAX;\n27780000              MATCH_ARRAY.ENTRY(IMATCH).TYPE         = '';\n27790000              MATCH_ARRAY.ENTRY(IMATCH).COMPARE_TEST = '';\n27800000        DO IFILE = IFILE_MIN TO IFILE_MAX;\n27810000              MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION = '';\n27820000              MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_SELECT = '';\n27830000              MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_OPTION   = '';\n27840000              MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_SELECT   = '';\n27850000        END;               /*END OF IFILE  DO GROUP*/\n27860000      END;                 /*END OF IMATCH DO GROUP*/\n27870000   %PAGE;\n27880000    /******************************************************************/\n27890000    /*   READ EXECUTION CONTROL VARIABLE VALUES                       */\n27900000    /******************************************************************/\n27910000      OPEN  FILE(SYSIN);                                  /*READ THE SEARCH ARGUMENTS */\n27920000      SYSIN_EOF = '0'B;\n27930000      ON ENDFILE(SYSIN)\n27940000         BEGIN;\n27950000              SYSIN_EOF = '1'B;     /*SIGNAL END OF FILE ON INPUT*/\n27960000              SYSIN_CONTROL_CARD = REPEAT(SEMI_C,079);\n27970000         END;\n27980000\n27990000         /*READ THE EXECUTION CONTROL VARIABLES FROM \"SYSIN\"*/\n28000000      READ FILE(SYSIN) INTO(SYSIN_CONTROL_CARD);      /*READ THE FIRST CONTOL CARD IMAGE*/\n28010000      DO WHILE(\u00ac(SYSIN_EOF));\n28020000         IF SUBSTR(SYSIN_CONTROL_CARD,001,001) \u00ac= '*'  /*COMMENT RECORD  */\n28030000           THEN\n28040000                GET STRING(SUBSTR(SYSIN_CONTROL_CARD,001,072) || SEMI_C)\n28050000                    DATA(\n28060000                         FILE_ACTIVE_OPTION,\n28070000\n28080000                         MATCH_ARRAY,\n28090000\n28100000                         SCAN_ARRAY.FILE.SELECT_OPTION,\n28110000                         SCAN_ARRAY.FILE.PLANE.SELECT_OPTION,\n28120000                         SCAN_ARRAY.FILE.PLANE.ROW.SELECT_OPTION,\n28130000                         SCAN_ARRAY.FILE.PLANE.ROW.COL.BEG_POS,\n28140000                         SCAN_ARRAY.FILE.PLANE.ROW.COL.END_POS,\n28150000                         SCAN_ARRAY.FILE.PLANE.ROW.COL.POS_LEN,\n28160000                         SCAN_ARRAY.FILE.PLANE.ROW.COL.OP,\n28170000                         SCAN_ARRAY.FILE.PLANE.ROW.COL.STRING,\n28180000\n28190000                         DATA_OUTPUT_OPTION\n28200000                        );\n28210000         READ FILE(SYSIN) INTO(SYSIN_CONTROL_CARD);   /*READ THE NEXT CONTROL CARD IMAGE*/\n28220000      END;\n28230000      CLOSE FILE(SYSIN);\n28240000   %SKIP(2);\n28250000    /******************************************************************/\n28260000    /*   VALIDATE EXECUTION CONTROL VARIABLE VALUES                   */\n28270000    /******************************************************************/\n28280000      DO IFILE = IFILE_MIN TO IFILE_MAX;\n28290000        FILE_ACTIVE_OPTION(IFILE)\n28300000               = VALIDATE_FILE_ACTIVE_OPTION(FILE_ACTIVE_OPTION(IFILE));\n28310000        DATA_OUTPUT_OPTION(IFILE) = VALIDATE_DATA_OUTPUT_OPTION(DATA_OUTPUT_OPTION(IFILE));\n28320000        CALL VALIDATE_SCAN_ARRAY;\n28330000      END;\n28340000      CALL VALIDATE_MATCH_ARRAY;\n28350000      RETURN;          /*TO THE CALLER OF CONTROL_VALUE_INPUT*/\n28360000 %PAGE;\n28370000  VALIDATE_MATCH_ARRAY:\n28380000  /**************************************************/\n28390000  /*VALIDATE THE MATCH_ARRAY INPUT VALUES           */\n28400000  /**************************************************/\n28410000  PROC;\n28420000\n28430000     DO IMATCH = IMATCH_MIN TO IMATCH_MAX;\n28440000\n28450000       MATCH_ARRAY.ENTRY(IMATCH).TYPE\n28460000               = VALIDATE_MATCH_TYPE_OPTION(MATCH_ARRAY.ENTRY(IMATCH).TYPE);\n28470000\n28480000       MATCH_ARRAY.ENTRY(IMATCH).COMPARE_TEST\n28490000               = VALIDATE_MATCH_TEST_OPTION(MATCH_ARRAY.ENTRY(IMATCH).COMPARE_TEST);\n28500000\n28510000       DO IFILE = IFILE_MIN TO IFILE_MAX;\n28520000         MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION\n28530000                = VALIDATE_MATCH_COMPARE_OPTION\n28540000                         (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION);\n28550000         MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_SELECT\n28560000                = VALIDATE_MATCH_SELECT_OPTION\n28570000                         (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_SELECT);\n28580000         MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_OPTION\n28590000                = VALIDATE_MATCH_WRITE_OPTION\n28600000                         (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_OPTION);\n28610000         MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_SELECT\n28620000                = VALIDATE_MATCH_SELECT_OPTION\n28630000                         (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_SELECT);\n28640000       END;             /*END OF IFILE  DO GROUP*/\n28650000\n28660000     END;               /*END OF IMATCH DO GROUP*/\n28670000  END   VALIDATE_MATCH_ARRAY;\n28680000 %PAGE;\n28690000  VALIDATE_SCAN_ARRAY:           /**************************************************/\n28700000                                 /*VALIDATE THE SCAN_ARRAY INPUT VALUES            */\n28710000                                 /**************************************************/\n28720000  PROC;                              /*IFILE IS SET ON ENTRY TO VALIDATE_SCAN_ARRAY*/\n28730000\n28740000     DCL 01 SCAN_ARRAY_ELEMENT      BASED(SCAN_ARRAY_ELEMENT_ADDR)\n28750000                                     LIKE SCAN_ARRAY.PLANE.ROW.COL;\n28760000\n28770000     SCAN_ARRAY.FILE(IFILE).SELECT_OPTION\n28780000               = VALIDATE_SCAN_SELECT_OPTION\n28790000                         (SCAN_ARRAY.FILE(IFILE).SELECT_OPTION);\n28800000\n28810000     DO IPLANE = IPLANE_MIN TO IPLANE_MAX;\n28820000       SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).SELECT_OPTION\n28830000               = VALIDATE_SCAN_SELECT_OPTION\n28840000                         (SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).SELECT_OPTION);\n28850000\n28860000       DO IROW = IROW_MIN TO IROW_MAX;\n28870000         SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).SELECT_OPTION\n28880000               = VALIDATE_SCAN_SELECT_OPTION\n28890000                         (SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).SELECT_OPTION);\n28900000\n28910000         DO ICOL = ICOL_MIN TO ICOL_MAX;\n28920000           SCAN_ARRAY_ELEMENT_ADDR\n28930000                 =  ADDR(SCAN_ARRAY(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL));\n28940000           IF  LENGTH(SCAN_ARRAY_ELEMENT.STRING) <= 0\n28950000             THEN   CALL RESET_ARRAY_ELEMENT;  /*RESET ELEMENT IF NO STRING*/\n28960000             ELSE DO;               /*A STRING VALUE HAS BEEN SPECIFIED*/\n28970000                    CALL VALIDATE_POSITION_BOUNDS;\n28980000                    CALL SET_OP_POSITION_BOUNDS;\n28990000                    CALL RESET_STRING_SIZE;\n29000000                  END;     /*END OF ICOL ACTIVE ELEMENT DO GROUP*/\n29010000         END;              /*END OF ICOL   DO GROUP*/\n29020000\n29030000       END;                /*END OF IROW   DO GROUP*/\n29040000     END;                  /*END OF IPLANE DO GROUP*/\n29050000  RETURN;           /*TO THE CALLER OF VALIDATE_SCAN_ARRAY*/\n29060000 %PAGE;\n29070000  VALIDATE_POSITION_BOUNDS: /*INTERNAL SUBROUTINE OF \"VALIDATE_SCAN_ARRAY\"        */\n29080000                            /*TO INITIALIZE ANY UNSUPPLIED FIELDS,                */\n29090000                            /*VALIDATE THE BEGINNING AND ENDING COLUMN            */\n29100000                            /*SPECIFICATIONS, AND FORCE THE BEGIN COLUMN VALUE    */\n29110000                            /*TO BE <= THE ENDING COLUMN VALUE:                   */\n29120000    PROC;\n29130000       DCL  SAVE_POS                   FIXED BIN(15,0);\n29140000       SCAN_ARRAY_ELEMENT.STR_LEN\n29150000                   =  LENGTH(SCAN_ARRAY_ELEMENT.STRING);\n29160000\n29170000       IF     SCAN_ARRAY_ELEMENT.BEG_POS\n29180000           >  SCAN_ARRAY_ELEMENT.END_POS\n29190000         THEN CALL SWAP_POSITION_BOUNDS;\n29200000\n29210000       IF    (SCAN_ARRAY_ELEMENT.POS_LEN > 000)                             /*IF SUPPLIED*/\n29220000           & (SCAN_ARRAY_ELEMENT.BEG_POS >= LIST_LINE_DBGN)                 /*IF SUPPLIED*/\n29230000           & (SCAN_ARRAY_ELEMENT.BEG_POS <= LIST_LINE_DEND)                  /*AND VALID */\n29240000           & (SCAN_ARRAY_ELEMENT.END_POS > LIST_LINE_DEND)               /*IF NOTSUPPLIED*/\n29250000         THEN SCAN_ARRAY_ELEMENT.END_POS\n29260000                         =    SCAN_ARRAY_ELEMENT.BEG_POS\n29270000                            + SCAN_ARRAY_ELEMENT.POS_LEN - 1;\n29280000\n29290000       IF     SCAN_ARRAY_ELEMENT.BEG_POS\n29300000           >  SCAN_ARRAY_ELEMENT.END_POS\n29310000         THEN CALL SWAP_POSITION_BOUNDS;\n29320000\n29330000       RETURN;\n29340000      %SKIP(3);\n29350000       SWAP_POSITION_BOUNDS: /*INTERNAL SUBROUTINE OF \"VALIDATE_POSITION_BOUNDS\"   */\n29360000                             /*TO SWAP THE BEGINNING AND ENDING COLUMN             */\n29370000         PROC;               /*SPECIFICATIONS:                                     */\n29380000            DCL  SAVE_POS                   FIXED BIN(15,0);\n29390000            SAVE_POS                    =  SCAN_ARRAY_ELEMENT.BEG_POS;\n29400000            SCAN_ARRAY_ELEMENT.BEG_POS  =  SCAN_ARRAY_ELEMENT.END_POS;\n29410000            SCAN_ARRAY_ELEMENT.END_POS  =  SAVE_POS;\n29420000         END SWAP_POSITION_BOUNDS;\n29430000    END VALIDATE_POSITION_BOUNDS;\n29440000 %PAGE;\n29450000  SET_OP_POSITION_BOUNDS:   /*INTERNAL SUBROUTINE OF \"VALIDATE_SCAN_ARRAY\"        */\n29460000                            /*TO VALIDATE AND SET THE ENDING POSITION             */\n29470000                            /*IN SCAN_ARRAY BASED ON THE TYPE OF SCAN OPERATION:  */\n29480000    PROC;\n29490000       SCAN_ARRAY_ELEMENT.OP = TRIM(SCAN_ARRAY_ELEMENT.OP);\n29500000       SELECT(SCAN_ARRAY_ELEMENT.OP);\n29510000         WHEN('EQENTRY','EQNTRY','EQN')              CALL SET_NTRY_POSITION_BOUNDS(12);\n29520000         WHEN('NEENTRY','NENTRY','NEN')              CALL SET_NTRY_POSITION_BOUNDS(13);\n29530000         WHEN('\u00acEQENTRY','\u00acEQNTRY','\u00acEQN')           CALL SET_NTRY_POSITION_BOUNDS(13);\n29540000\n29550000         WHEN('EQLINE','EQLIN','EQL')                CALL SET_LINE_POSITION_BOUNDS(22);\n29560000         WHEN('NELINE','NELIN','NEL')                CALL SET_LINE_POSITION_BOUNDS(23);\n29570000         WHEN('\u00acEQLINE','\u00acEQLIN','\u00acEQL')             CALL SET_LINE_POSITION_BOUNDS(23);\n29580000\n29590000         WHEN('EQGLINE','EQGLIN','EQGL')             CALL SET_GLIN_POSITION_BOUNDS(32);\n29600000         WHEN('NEGLINE','NEGLIN','NEGL')             CALL SET_GLIN_POSITION_BOUNDS(33);\n29610000         WHEN('\u00acEQGLINE','\u00acEQGLIN','\u00acEQGL')          CALL SET_GLIN_POSITION_BOUNDS(33);\n29620000\n29630000         WHEN('EQSCAN','EQSCN','EQS')                CALL SET_SCAN_POSITION_BOUNDS(42);\n29640000         WHEN('NESCAN','NESCN','NES')                CALL SET_SCAN_POSITION_BOUNDS(43);\n29650000         WHEN('\u00acEQSCAN','\u00acEQSCN','\u00acEQS')             CALL SET_SCAN_POSITION_BOUNDS(43);\n29660000\n29670000         WHEN('EQGSCAN','EQGSCN','EQGS')             CALL SET_GSCN_POSITION_BOUNDS(52);\n29680000         WHEN('NEGSCAN','NEGSCN','NEGS')             CALL SET_GSCN_POSITION_BOUNDS(53);\n29690000         WHEN('\u00acEQGSCAN','\u00acEQGSCN','\u00acEQGS')          CALL SET_GSCN_POSITION_BOUNDS(53);\n29700000\n29710000         WHEN('LTCMPR','LTCPR','LTC','LT')           CALL SET_CMPR_POSITION_BOUNDS(60);\n29720000         WHEN('\u00acGECMPR','\u00acGECPR','\u00acGEC','\u00acGE')       CALL SET_CMPR_POSITION_BOUNDS(60);\n29730000         WHEN('LECMPR','LECPR','LEC','LE')           CALL SET_CMPR_POSITION_BOUNDS(61);\n29740000         WHEN('\u00acGTCMPR','\u00acGTCPR','\u00acGTC','\u00acGT')       CALL SET_CMPR_POSITION_BOUNDS(61);\n29750000         WHEN('EQCMPR','EQCPR','EQC','EQ')           CALL SET_CMPR_POSITION_BOUNDS(62);\n29760000         WHEN('NECMPR','NECPR','NEC','NE')           CALL SET_CMPR_POSITION_BOUNDS(63);\n29770000         WHEN('\u00acEQCMPR','\u00acEQCPR','\u00acEQC','\u00acEQ')       CALL SET_CMPR_POSITION_BOUNDS(63);\n29780000         WHEN('GECMPR','GECPR','GEC','GE')           CALL SET_CMPR_POSITION_BOUNDS(64);\n29790000         WHEN('\u00acLTCMPR','\u00acLTCPR','\u00acLTC','\u00acLT')       CALL SET_CMPR_POSITION_BOUNDS(64);\n29800000         WHEN('GTCMPR','GTCPR','GTC','GT')           CALL SET_CMPR_POSITION_BOUNDS(65);\n29810000         WHEN('\u00acLECMPR','\u00acLTCPR','\u00acLTC','\u00acLT')       CALL SET_CMPR_POSITION_BOUNDS(65);\n29820000\n29830000         WHEN('EQGCMPR','EQGCPR','EQGC','EQG')       CALL SET_GCPR_POSITION_BOUNDS(72);\n29840000         WHEN('NEGCMPR','NEGCPR','NEGC','NEG')       CALL SET_GCPR_POSITION_BOUNDS(73);\n29850000         WHEN('\u00acEQGCMPR','\u00acEQGCPR','\u00acEQGC','\u00acEQG')   CALL SET_GCPR_POSITION_BOUNDS(73);\n29860000\n29870000         OTHERWISE\n29880000           DO;\n29890000               SCAN_ARRAY_ELEMENT.OP = 'EQSCAN';\n29900000               CALL                              SET_SCAN_POSITION_BOUNDS(42);\n29910000           END;\n29920000       END;   /*END OF SCAN_ARRAY.OP   SELECT GROUP*/\n29930000\n29940000       RETURN;\n29950000 %PAGE;\n29960000  SET_NTRY_POSITION_BOUNDS: /*INTERNAL SUBROUTINE OF \"VALIDATE_SCAN_ARRAY\"        */\n29970000                            /*TO VALIDATE AND SET THE ENDING POSITION             */\n29980000                            /*IN SCAN_ARRAY FOR ENTRY TYPE COMPARE OPERATIONS:    */\n29990000    PROC(OIX);\n30000000       DCL  OIX                       FIXED BIN(15,0);\n30010000       SCAN_ARRAY_ELEMENT.OP_OIX   =  OIX;\n30020000       SCAN_ARRAY_ELEMENT.BEG_POS  =  LIST_LINE_DBGN;\n30030000       SCAN_ARRAY_ELEMENT.END_POS  =  LIST_LINE_DEND;\n30040000       SCAN_ARRAY_ELEMENT.STR_NIX  =  ENTRY_INDEX(SCAN_ARRAY_ELEMENT.STRING);\n30050000    END SET_NTRY_POSITION_BOUNDS;\n30060000 %SKIP(3);\n30070000  SET_LINE_POSITION_BOUNDS: /*INTERNAL SUBROUTINE OF \"VALIDATE_SCAN_ARRAY\"        */\n30080000  SET_GLIN_POSITION_BOUNDS: /*TO VALIDATE AND SET THE ENDING POSITION             */\n30090000                            /*IN SCAN_ARRAY FOR LINE TYPE COMPARE OPERATIONS:     */\n30100000    PROC(OIX);\n30110000       DCL  OIX                       FIXED BIN(15,0);\n30120000       SCAN_ARRAY_ELEMENT.OP_OIX   =  OIX;\n30130000       SCAN_ARRAY_ELEMENT.BEG_POS  =  LIST_LINE_LBGN;\n30140000       SCAN_ARRAY_ELEMENT.END_POS  =  LIST_LINE_LEND;\n30150000    END SET_LINE_POSITION_BOUNDS;\n30160000 %PAGE;\n30170000  SET_SCAN_POSITION_BOUNDS: /*INTERNAL SUBROUTINE OF \"VALIDATE_SCAN_ARRAY\"        */\n30180000  SET_GSCN_POSITION_BOUNDS: /*TO VALIDATE AND SET THE ENDING COLUMN               */\n30190000                            /*IN SCAN_ARRAY FOR LINE CONTENTS SCAN OPERATIONS:    */\n30200000    PROC(OIX);\n30210000       DCL  OIX                       FIXED BIN(15,0);\n30220000       SCAN_ARRAY_ELEMENT.OP_OIX   =  OIX;\n30230000       IF     SCAN_ARRAY_ELEMENT.BEG_POS < LIST_LINE_DBGN\n30240000           &  SCAN_ARRAY_ELEMENT.END_POS > LIST_LINE_DEND\n30250000         THEN\n30260000           DO;\n30270000              SCAN_ARRAY_ELEMENT.BEG_POS = LIST_LINE_SBGN;\n30280000              SCAN_ARRAY_ELEMENT.END_POS = LIST_LINE_DEND;\n30290000           END;\n30300000       SCAN_ARRAY_ELEMENT.END_POS\n30310000           = MIN(LIST_LINE_DEND,\n30320000                 MAX( SCAN_ARRAY_ELEMENT.END_POS,\n30330000                     (SCAN_ARRAY_ELEMENT.BEG_POS +\n30340000                      SCAN_ARRAY_ELEMENT.STR_LEN - 1)));\n30350000    END SET_SCAN_POSITION_BOUNDS;\n30360000 %SKIP(3);\n30370000  SET_CMPR_POSITION_BOUNDS: /*INTERNAL SUBROUTINE OF \"VALIDATE_SCAN_ARRAY\"        */\n30380000  SET_GCPR_POSITION_BOUNDS: /*TO VALIDATE AND SET THE ENDING POSITION             */\n30390000                            /*IN SCAN_ARRAY FOR LINE CONTENTS COMPARE OPERATIONS: */\n30400000    PROC(OIX);\n30410000       DCL  OIX                       FIXED BIN(15,0);\n30420000       SCAN_ARRAY_ELEMENT.OP_OIX   =  OIX;\n30430000       IF     SCAN_ARRAY_ELEMENT.BEG_POS < LIST_LINE_DBGN\n30440000           &  SCAN_ARRAY_ELEMENT.END_POS > LIST_LINE_DEND\n30450000         THEN\n30460000           DO;\n30470000              SCAN_ARRAY_ELEMENT.BEG_POS = LIST_LINE_SBGN;\n30480000              SCAN_ARRAY_ELEMENT.END_POS = LIST_LINE_DEND;\n30490000           END;\n30500000       SCAN_ARRAY_ELEMENT.END_POS\n30510000         = MIN(LIST_LINE_DEND,\n30520000               (SCAN_ARRAY_ELEMENT.BEG_POS +\n30530000                SCAN_ARRAY_ELEMENT.STR_LEN - 1));\n30540000    END SET_CMPR_POSITION_BOUNDS;\n30550000   %SKIP(2);\n30560000    END SET_OP_POSITION_BOUNDS;\n30570000 %PAGE;\n30580000  RESET_STRING_SIZE:        /*INTERNAL SUBROUTINE OF \"VALIDATE_SCAN_ARRAY\"        */\n30590000                      /*TO LIMIT THE SIZE OF THE SEARCH STRING TO                 */\n30600000                      /*THE EXTENT OF THE  BEGIN AND END LINE POSTITIONS:         */\n30610000    PROC;\n30620000       IF     SCAN_ARRAY_ELEMENT.BEG_POS < LIST_LINE_DBGN\n30630000           |  SCAN_ARRAY_ELEMENT.BEG_POS > LIST_LINE_DEND\n30640000         THEN SCAN_ARRAY_ELEMENT.BEG_POS = LIST_LINE_DBGN;\n30650000\n30660000       IF     SCAN_ARRAY_ELEMENT.END_POS < LIST_LINE_DBGN\n30670000           |  SCAN_ARRAY_ELEMENT.END_POS > LIST_LINE_DEND\n30680000         THEN SCAN_ARRAY_ELEMENT.END_POS = LIST_LINE_DEND;\n30690000\n30700000       SCAN_ARRAY_ELEMENT.POS_LEN        =    SCAN_ARRAY_ELEMENT.END_POS\n30710000                                            - SCAN_ARRAY_ELEMENT.BEG_POS + 1;\n30720000\n30730000       IF         SCAN_ARRAY_ELEMENT.POS_LEN\n30740000               <  SCAN_ARRAY_ELEMENT.STR_LEN\n30750000\n30760000         THEN     SCAN_ARRAY_ELEMENT.STRING\n30770000               =\n30780000           SUBSTR(SCAN_ARRAY_ELEMENT.STRING,\n30790000                  1,\n30800000                  SCAN_ARRAY_ELEMENT.POS_LEN);\n30810000\n30820000       SCAN_ARRAY_ELEMENT.STR_LEN        =  LENGTH(SCAN_ARRAY_ELEMENT.STRING);\n30830000\n30840000    END RESET_STRING_SIZE;\n30850000 %SKIP(3);\n30860000  RESET_ARRAY_ELEMENT:      /*INTERNAL SUBROUTINE OF \"VALIDATE_SCAN_ARRAY\"        */\n30870000                            /*TO RESET THE VALUES IN A SCAN_ARRAY ELEMENT         */\n30880000                            /*WHEN THE STRING PROVIDED IS EMPTY OR NULL:          */\n30890000    PROC;\n30900000       SCAN_ARRAY_ELEMENT.BEG_POS  =  000;\n30910000       SCAN_ARRAY_ELEMENT.END_POS  =  000;\n30920000       SCAN_ARRAY_ELEMENT.POS_LEN  =  000;\n30930000       SCAN_ARRAY_ELEMENT.OP       =  '';\n30940000       SCAN_ARRAY_ELEMENT.OP_OIX   =  000;\n30950000       SCAN_ARRAY_ELEMENT.STRING   =  '';\n30960000       SCAN_ARRAY_ELEMENT.STR_LEN  =  000;\n30970000       SCAN_ARRAY_ELEMENT.STR_NIX  =  NTRYINDX_MIN-1;\n30980000    END RESET_ARRAY_ELEMENT;\n30990000 %SKIP(3);\n31000000  END VALIDATE_SCAN_ARRAY;\n31010000 %PAGE;\n31020000  VALIDATE_MATCH_TYPE_OPTION:\n31030000  PROC(ENT_TYP)                   RETURNS(CHAR(016) VARYING);\n31040000     DCL    ENT_TYP               CHAR(*) VARYING;\n31050000     SELECT(TRIM(ENT_TYP));     /*EVALUATE OPTION AND STANDARDIZE IT*/\n31060000        WHEN('')                                      RETURN('NONE');\n31070000        WHEN('ALL','A')                               RETURN('ALL');\n31080000        WHEN('NONE','NO','N')                         RETURN('NONE');\n31090000        OTHERWISE           RETURN(ENTRY_TYPE(ENTRY_INDEX(ENT_TYP)));\n31100000     END;\n31110000  END VALIDATE_MATCH_TYPE_OPTION; /*IN CONTROL_VALUE_INPUT*/\n31120000 %SKIP(2);\n31130000  VALIDATE_MATCH_TEST_OPTION:\n31140000  PROC(TST_TYP)                   RETURNS(CHAR(008) VARYING);\n31150000     DCL    TST_TYP               CHAR(*) VARYING;\n31160000     SELECT(TRIM(TST_TYP));     /*EVALUATE OPTION AND STANDARDIZE IT*/\n31170000        WHEN('')                                      RETURN('ALL');\n31180000        WHEN('ALL','AND','A','N')                     RETURN('ALL');\n31190000        WHEN('ANY','OR','O')                          RETURN('ANY');\n31200000        OTHERWISE                                     RETURN('ALL');\n31210000     END;\n31220000  END VALIDATE_MATCH_TEST_OPTION; /*IN CONTROL_VALUE_INPUT*/\n31230000 %PAGE;\n31240000  VALIDATE_MATCH_COMPARE_OPTION:\n31250000  PROC(CPR_OPT)                   RETURNS(CHAR(012) VARYING);\n31260000     DCL    CPR_OPT               CHAR(*) VARYING;\n31270000     SELECT(TRIM(CPR_OPT));     /*EVALUATE OPTION AND STANDARDIZE IT*/\n31280000        WHEN('')                                      RETURN('IFCOMPARE');\n31290000        WHEN('NOCOMPARE','NOCMPR','NOCPR','NOC')      RETURN('NOCOMPARE');\n31300000        WHEN('COMPARE','CMPR','CPR','C')              RETURN('COMPARE');\n31310000        WHEN('IFCOMPARE','IFCMPR','IFCPR','IFC')      RETURN('IFCOMPARE');\n31320000        WHEN('IGCOMPARE','IGCMPR','IGCPR','IGC')      RETURN('IFCOMPARE');\n31330000        WHEN('IGNORE','IGNR','IG')                    RETURN('IFCOMPARE');\n31340000        OTHERWISE                                     RETURN('IFCOMPARE');\n31350000     END;\n31360000  END VALIDATE_MATCH_COMPARE_OPTION; /*IN CONTROL_VALUE_INPUT*/\n31370000 %SKIP(2);\n31380000  VALIDATE_MATCH_SELECT_OPTION:\n31390000  PROC(SEL_OPT)                   RETURNS(CHAR(012) VARYING);\n31400000     DCL    SEL_OPT               CHAR(*) VARYING;\n31410000     SELECT(TRIM(SEL_OPT));     /*EVALUATE OPTION AND STANDARDIZE IT*/\n31420000        WHEN('')                                      RETURN('IGNORE');\n31430000        WHEN('NOSELECT','NOSEL','NOS')                RETURN('NOSELECT');\n31440000        WHEN('EXCLUDE','EXCL','EXC','EX','E','X')     RETURN('NOSELECT');\n31450000        WHEN('SELECT','SEL','S')                      RETURN('SELECT');\n31460000        WHEN('IFSELECT','IFSEL','IFS')                RETURN('IGNORE');\n31470000        WHEN('IGSELECT','IGSEL','IGS')                RETURN('IGNORE');\n31480000        WHEN('IGNORE','IGNR','IG')                    RETURN('IGNORE');\n31490000        OTHERWISE                                     RETURN('IGNORE');\n31500000     END;\n31510000  END VALIDATE_MATCH_SELECT_OPTION; /*IN CONTROL_VALUE_INPUT*/\n31520000 %SKIP(2);\n31530000  VALIDATE_MATCH_WRITE_OPTION:\n31540000  PROC(WRT_OPT)                   RETURNS(CHAR(012) VARYING);\n31550000     DCL    WRT_OPT               CHAR(*) VARYING;\n31560000     SELECT(TRIM(WRT_OPT));     /*EVALUATE OPTION AND STANDARDIZE IT*/\n31570000        WHEN('')                                      RETURN('WRITE');\n31580000        WHEN('NOWRITE','NOWRT','NOWR','NOW')          RETURN('NOWRITE');\n31590000        WHEN('WRITE','WRT','WR','W')                  RETURN('WRITE');\n31600000        OTHERWISE                                     RETURN('WRITE');\n31610000     END;\n31620000  END VALIDATE_MATCH_WRITE_OPTION; /*IN CONTROL_VALUE_INPUT*/\n31630000 %PAGE;\n31640000  VALIDATE_FILE_ACTIVE_OPTION:\n31650000  PROC(ACT_OPT)                   RETURNS(CHAR(008) VARYING);\n31660000     DCL    ACT_OPT               CHAR(*) VARYING;\n31670000     SELECT(TRIM(ACT_OPT));     /*EVALUATE OPTION AND STANDARDIZE IT*/\n31680000        WHEN('')                                      RETURN('INACTIVE');\n31690000        WHEN('INACTIVE','INACT','NO','N','OFF')       RETURN('INACTIVE');\n31700000        WHEN('ACTIVE','ACT','A','YES','Y','ON')       RETURN('ACTIVE');\n31710000        OTHERWISE                                     RETURN('INACTIVE');\n31720000     END;\n31730000  END VALIDATE_FILE_ACTIVE_OPTION; /*IN CONTROL_VALUE_INPUT*/\n31740000 %SKIP(2);\n31750000  VALIDATE_SCAN_SELECT_OPTION:\n31760000  PROC(SEL_OPT)                   RETURNS(CHAR(008) VARYING);\n31770000     DCL    SEL_OPT               CHAR(*) VARYING;\n31780000     SELECT(TRIM(SEL_OPT));     /*EVALUATE OPTION AND STANDARDIZE IT*/\n31790000        WHEN('')                                      RETURN('SELECT');\n31800000        WHEN('EXCLUDE','EXCL','EXC','EX','E','X')     RETURN('EXCLUDE');\n31810000        WHEN('SELECT','SEL','S')                      RETURN('SELECT');\n31820000        OTHERWISE                                     RETURN('SELECT');\n31830000     END;\n31840000  END VALIDATE_SCAN_SELECT_OPTION; /*IN CONTROL_VALUE_INPUT*/\n31850000 %SKIP(2);\n31860000  VALIDATE_DATA_OUTPUT_OPTION:\n31870000  PROC(OUT_OPT)                   RETURNS(CHAR(008) VARYING);\n31880000     DCL    OUT_OPT               CHAR(*) VARYING;\n31890000     SELECT(TRIM(OUT_OPT));     /*EVALUATE OPTION AND STANDARDIZE IT*/\n31900000        WHEN('')                                      RETURN('NONE');\n31910000        WHEN('NONE')                                  RETURN('NONE');\n31920000        WHEN('ALL')                                   RETURN('ALL');\n31930000        WHEN('ID')                                    RETURN('ID');\n31940000        WHEN('ID1')                                   RETURN('ID1');\n31950000        WHEN('SELECT','SEL','S')                      RETURN('SELECT');\n31960000        OTHERWISE                                     RETURN('ID1');\n31970000     END;\n31980000  END VALIDATE_DATA_OUTPUT_OPTION; /*IN CONTROL_VALUE_INPUT*/\n31990000 %SKIP(3);\n32000000  END CONTROL_VALUE_INPUT;\n32010000 %PAGE;\n32020000 SMPLIST_OPEN:             /*************************************************************/\n32030000                           /*                                                           */\n32040000                           /*   INITIALIZE THE SMPLIST FILE MANAGEMENT ARRAY,           */\n32050000                           /*   AND OPEN THE SMPLIST DATA SET(S).                       */\n32060000                           /*                                                           */\n32070000  PROC;                    /*************************************************************/\n32080000     ALLOCATE     SMPLIST_CNTL,SMPLIST;            /*ALLOCATE INPUT  FILE STRUCTURES*/\n32090000     ALLOCATE     SMPUT,SMPSCAN,SMPSOUT,SMPDATA;   /*ALLOCATE OUTPUT FILE STRUCTURES*/\n32100000\n32110000     CALL SMPLIST_CNTL_A_STAT_INIT;                /*INITIALIZE A_STAT  SUBSTRUCTURE*/\n32120000     CALL SMPLIST_CNTL_E_CMPR_INIT;                /*INITIALIZE E_CMPR  SUBSTRUCTURE*/\n32130000     CALL SMPLIST_CNTL_A_MATCH_INIT;               /*INITIALIZE A_MATCH SUBSTRUCTURE*/\n32140000\n32150000     DO    IFILE = IFILE_MIN TO IFILE_MAX;\n32160000       CALL  SMPLIST_INIT;                   /*INITIALIZE SMPLIST(IFILE) MAJOR STRUCTURE*/\n32170000       CALL  SMPUT_INIT;                     /*INITIALIZE SMPUT(IFILE)   MAJOR STRUCTURE*/\n32180000       CALL  SMPSCAN_INIT;                   /*INITIALIZE SMPSCAN(IFILE) MAJOR STRUCTURE*/\n32190000       CALL  SMPSOUT_INIT;                   /*INITIALIZE SMPSOUT(IFILE) MAJOR STRUCTURE*/\n32200000       CALL  SMPDATA_INIT;                   /*INITIALIZE SMPDATA(IFILE) MAJOR STRUCTURE*/\n32210000       IF FILE_ACTIVE_OPTION(IFILE) = 'ACTIVE'\n32220000         THEN DO;                            /*IF THE FILE IS TO BE PROCESSED*/\n32230000                 SMPLIST(IFILE).ACTIVE = '1'B;      /*INDICATE FILE ACTIVE*/\n32240000                 CALL SMPLIST_SCAN_CUBE_BUILD;\n32250000                 OPEN  FILE(SMPLIST(IFILE).FILEREF) INPUT\n32260000                       TITLE(SMPLIST(IFILE).DDNAME);\n32270000               END;\n32280000         ELSE DO;                            /*IF THE FILE IS NOT TO BE PROCESSED*/\n32290000                 CALL      SMPLIST_CURR_PAGE_EOF;   /*SIMULATE IMMEDIATE END-OF-FILE*/\n32300000                 SMPLIST(IFILE).CURR_NTRY  =  SMPLIST(IFILE).CURR_PAGE,  BY NAME;\n32310000              END;\n32320000     END;\n32330000\n32340000     CALL  SMPLIST_CNTL_A_MATCH_BUILD;          /*BUILD SMPLIST_CNTL.A_MATCH SUBSTRUCTURE*/\n32350000\n32360000     DO    IFILE = IFILE_MIN TO IFILE_MAX;    /*READ FIRST LINES FOR ACTIVE SMPLIST FILES*/\n32370000       IF (SMPLIST(IFILE).ACTIVE)                    /*IF FILE IS ACTIVE,                */\n32380000         THEN\n32390000           DO;\n32400000             CALL SMPLIST_ENTRY_LINE_READ;                   /*READ 1ST LINE OF 1ST ENTRY*/\n32410000             IF  (SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE))      /*IF A CANDIDATE FOR OUTPUT,*/\n32420000               THEN DO;\n32430000                       CALL SMPSCAN_ACTIVATE;                 /*ACTIVATE SCAN OUTPUT FILE*/\n32440000                       CALL SMPSOUT_ACTIVATE;                 /*ACTIVATE LIST OUTPUT FILE*/\n32450000                       CALL SMPDATA_ACTIVATE;                 /*ACTIVATE DATA OUTPUT FILE*/\n32460000                    END;\n32470000             SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT = SMPLIST(IFILE).ACTIVE;/*FLAG 1ST READ*/\n32480000           END;\n32490000     END;\n32500000\n32510000     CALL  SMPLIST_CNTL_A_STAT_BUILD;           /*BUILD SMPLIST_CNTL.A_STAT  SUBSTRUCTURE*/\n32520000\n32530000     RETURN;                      /*TO THE CALLER OF SMPLIST_OPEN*/\n32540000 %PAGE;\n32550000  SMPLIST_CNTL_A_STAT_INIT:       /**************************************************/\n32560000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */\n32570000                                  /*IT INITIALIZES VARIABLES IN THE A_STAT          */\n32580000                                  /*SUBSTRUCTURE OF THE SMPLIST_CNTL MAJOR STRUCTURE*/\n32590000  PROC;                           /**************************************************/\n32600000     SMPLIST_CNTL.A_STAT.#_F_ACTIVE = 0;\n32610000  END  SMPLIST_CNTL_A_STAT_INIT;\n32620000 %SKIP(3);\n32630000  SMPLIST_CNTL_A_STAT_BUILD:      /**************************************************/\n32640000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */\n32650000                                  /*IT CALCULATES VALUES TO BE PLACED IN THE A_STAT */\n32660000                                  /*SUBSTRUCTURE OF THE SMPLIST_CNTL MAJOR STRUCTURE*/\n32670000  PROC;                           /**************************************************/\n32680000     DO    IFILE = IFILE_MIN TO IFILE_MAX;\n32690000       IF    SMPLIST(IFILE).ACTIVE                           /*PROCESS ONLY ACTIVE FILES*/\n32700000         THEN\n32710000           DO;\n32720000             SMPLIST_CNTL.A_STAT.#_F_ACTIVE = SMPLIST_CNTL.A_STAT.#_F_ACTIVE + 1;\n32730000           END;\n32740000     END;\n32750000  END  SMPLIST_CNTL_A_STAT_BUILD;\n32760000 %SKIP(3);\n32770000  SMPLIST_CNTL_E_CMPR_INIT:       /**************************************************/\n32780000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */\n32790000                                  /*IT INITIALIZES VARIABLES IN THE E_CMPR          */\n32800000                                  /*SUBSTRUCTURE OF THE SMPLIST_CNTL MAJOR STRUCTURE*/\n32810000  PROC;                           /**************************************************/\n32820000     SMPLIST_CNTL.HIGH_PAGE.NTRYNAME  =    HIGH(LENGTH(SMPLIST_CNTL.HIGH_PAGE.NTRYNAME));\n32830000     SMPLIST_CNTL.HIGH_PAGE.NTRYINDX  =    NTRYINDX_MAX + 1;\n32840000     SMPLIST_CNTL.HIGH_PAGE.PAGEKEY   =    HIGH(LENGTH(SMPLIST_CNTL.HIGH_PAGE.PAGEKEY));\n32850000     SMPLIST_CNTL.HIGH_PAGE.NTRYKEY   =    HIGH(LENGTH(SMPLIST_CNTL.HIGH_PAGE.NTRYKEY));\n32860000     SMPLIST_CNTL.HIGH_PAGE.CMPRKEY   =    HIGH(LENGTH(SMPLIST_CNTL.HIGH_PAGE.CMPRKEY));\n32870000\n32880000     SMPLIST_CNTL.HIGH_CMPR          =     SMPLIST_CNTL.HIGH_PAGE,    BY NAME;\n32890000     SMPLIST_CNTL.HIGH_CMPR.RESULT   =     '0'B;\n32900000\n32910000     SMPLIST_CNTL.E_CMPR               =   SMPLIST_CNTL.HIGH_CMPR,    BY NAME;\n32920000  END  SMPLIST_CNTL_E_CMPR_INIT;\n32930000 %PAGE;\n32940000  SMPLIST_CNTL_A_MATCH_INIT:      /**************************************************/\n32950000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */\n32960000                                  /*IT INITIALIZES THE A_MATCH SUBSTRUCTURE         */\n32970000                                  /*IN THE SMPLIST FILE CONTROL STRUCTURE.          */\n32980000  PROC;                           /**************************************************/\n32990000          SMPLIST_CNTL.A_MATCH.ACTIVE   =  '0'B;\n33000000          SMPLIST_CNTL.A_MATCH.RESULT   =  '0'B;\n33010000\n33020000     DO     NTRYINDX_IX = NTRYINDX_MIN TO NTRYINDX_MAX;\n33030000          SMPLIST_CNTL.A_MATCH.M_E_TYPE(NTRYINDX_IX) = '0'B;\n33040000     END;           /*END OF NTRYINDX_IX DO GROUP*/\n33050000\n33060000     DO     IFILE   = IFILE_MIN  TO IFILE_MAX;\n33070000          SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE)  =  '0'B;\n33080000     END;           /*END OF IFILE  DO GROUP*/\n33090000\n33100000     DO     IMATCH  = IMATCH_MIN TO IMATCH_MAX;\n33110000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).NTRYINDX  =  NTRYINDX_MIN - 1;\n33120000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE    =  '0'B;\n33130000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).C_TST     =  '0'B;\n33140000       DO   IFILE   = IFILE_MIN  TO IFILE_MAX;\n33150000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR     =  '0'B;\n33160000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOCMPR   =  '0'B;\n33170000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR   =  '0'B;\n33180000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_SEL      =  '0'B;\n33190000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOSEL    =  '0'B;\n33200000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGSEL    =  '0'B;\n33210000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT      =  '0'B;\n33220000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_SEL      =  '0'B;\n33230000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_NOSEL    =  '0'B;\n33240000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_IGSEL    =  '0'B;\n33250000       END;         /*END OF IFILE  DO GROUP*/\n33260000     END;           /*END OF IMATCH DO GROUP*/\n33270000  END SMPLIST_CNTL_A_MATCH_INIT;\n33280000 %PAGE;\n33290000  SMPLIST_CNTL_A_MATCH_BUILD:     /**************************************************/\n33300000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */\n33310000                                  /*IT SETS UP THE A_MATCH SUBSTRUCTURE             */\n33320000                                  /*IN THE SMPLIST FILE CONTROL STRUCTURE.          */\n33330000  PROC;                           /**************************************************/\n33340000     DO     IMATCH  = IMATCH_MIN TO IMATCH_MAX;\n33350000       SELECT(MATCH_ARRAY.ENTRY(IMATCH).TYPE);\n33360000         WHEN('NONE')  NTRYINDX_IX  =  NTRYINDX_MIN - 1;\n33370000         WHEN('ALL')   NTRYINDX_IX  =  NTRYINDX_MAX + 1;\n33380000         OTHERWISE     NTRYINDX_IX  =  ENTRY_INDEX(MATCH_ARRAY.ENTRY(IMATCH).TYPE);\n33390000       END;\n33400000       SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).NTRYINDX = NTRYINDX_IX;\n33410000\n33420000       IF       (NTRYINDX_IX >= NTRYINDX_MIN)     /*IF A SPECIFIC ENTRY TYPE OR \"ALL\"*/\n33430000         THEN                                          /*IF THE MATCH ENTRY IS ACTIVE*/\n33440000           DO;\n33450000             IF (NTRYINDX_IX <= NTRYINDX_MAX)\n33460000               THEN                                  /*IF THE MATCH ENTRY TYPE IS ONE*/\n33470000                     SMPLIST_CNTL.A_MATCH.M_E_TYPE(NTRYINDX_IX) = '1'B;\n33480000               ELSE                                /*IF THE MATCH ENTRY TYPE IS \"ALL\"*/\n33490000                     SMPLIST_CNTL.A_MATCH.M_E_TYPE(*)           = '1'B;\n33500000\n33510000             SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE  = '1'B;             /*ACTIVE*/\n33520000\n33530000             SELECT(MATCH_ARRAY.ENTRY(IMATCH).COMPARE_TEST);\n33540000               WHEN('ANY') SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).C_TST  = '0'B;\n33550000               OTHERWISE   SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).C_TST  = '1'B;\n33560000             END;                        /*END OF COMPARE_TEST SELECT GROUP*/\n33570000\n33580000             DO      IFILE   = IFILE_MIN  TO IFILE_MAX;\n33590000               IF   (SMPLIST(IFILE).ACTIVE)                         /*IF FILE IS ACTIVE*/\n33600000                 THEN\n33610000                     CALL      SMPLIST_CNTL_A_MATCH_F_BUILD;\n33620000             END;                        /*END OF        IFILE  DO GROUP*/\n33630000           END;                          /*END OF ACTIVE IMATCH    DO GROUP*/\n33640000\n33650000         ELSE\n33660000             SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE  = '0'B;            /*INACTIVE*/\n33670000\n33680000       SMPLIST_CNTL.A_MATCH.ACTIVE   =     SMPLIST_CNTL.A_MATCH.ACTIVE\n33690000                                        |  SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE;\n33700000     END;                                /*END OF        IMATCH DO GROUP*/\n33710000    %PAGE;\n33720000     IF  (SMPLIST_CNTL.A_MATCH.ACTIVE)\n33730000       THEN                                        /*IF    MATCH ENTRIES WERE ACTIVE*/\n33740000         DO   IFILE   = IFILE_MIN  TO IFILE_MAX;  /*ACTIVE  FILES CAN PRODUCE OUTPUT*/\n33750000               SMPLIST(IFILE).M_E_TYPE(*)            =   (SMPLIST(IFILE).ACTIVE\n33760000                                                        & SMPLIST_CNTL.A_MATCH.M_E_TYPE(*));\n33770000         END;                         /*END OF        IFILE  DO GROUP*/\n33780000\n33790000       ELSE                                        /*IF NO MATCH ENTRIES WERE ACTIVE*/\n33800000         DO;\n33810000            SMPLIST_CNTL.A_MATCH.M_E_TYPE(*) = '1'B; /*CONSIDER ALL ENTRY TYPES ACTIVE */\n33820000            DO   IFILE   = IFILE_MIN  TO IFILE_MAX;  /*SCANNED FILES CAN PRODUCE OUTPUT*/\n33830000               SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE)  =   (SMPLIST(IFILE).ACTIVE\n33840000                                                        & SMPLIST(IFILE).SCAN_CUBE.ACTIVE);\n33850000               SMPLIST(IFILE).M_E_TYPE(*)            =   (SMPLIST(IFILE).ACTIVE\n33860000                                                        & SMPLIST(IFILE).SCAN_CUBE.ACTIVE\n33870000                                                        & SMPLIST_CNTL.A_MATCH.M_E_TYPE(*));\n33880000            END;                         /*END OF        IFILE  DO GROUP*/\n33890000         END;\n33900000     RETURN;                             /*TO THE CALLER OF SMPLIST_CNTL_A_MATCH_BUILD*/\n33910000 %PAGE;\n33920000  SMPLIST_CNTL_A_MATCH_F_BUILD:   /**************************************************/\n33930000                                  /*THIS SUBROUTINE IS INTERNAL TO                  */\n33940000                                  /*SMPLIST_CNTL_A_MATCH_BUILD IN SMPLIST_OPEN.     */\n33950000                                  /*IT SETS THE MATCH/SCAN/WRITE BITS FOR A FILE.   */\n33960000                                  /**************************************************/\n33970000  PROC;                           /*IMATCH & IFILE ARE SET ON ENTRY                 */\n33980000\n33990000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR\n34000000              =      (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION = 'COMPARE');\n34010000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOCMPR\n34020000              =      (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION = 'NOCOMPARE');\n34030000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR\n34040000              =    \u00ac (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR\n34050000                    | SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOCMPR);\n34060000\n34070000\n34080000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_SEL\n34090000              =      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR\n34100000                    | SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR)\n34110000                &    (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_SELECT = 'SELECT');\n34120000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOSEL\n34130000              =      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR\n34140000                    | SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR)\n34150000                &    (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_SELECT = 'NOSELECT');\n34160000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGSEL\n34170000              =      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR\n34180000                    | SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR)\n34190000                &  \u00ac (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_SEL\n34200000                    | SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOSEL);\n34210000\n34220000\n34230000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT\n34240000              =      (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_OPTION   = 'WRITE');\n34250000\n34260000\n34270000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_SEL\n34280000              =      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT)\n34290000                &    (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_SELECT   = 'SELECT');\n34300000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_NOSEL\n34310000              =      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT)\n34320000                &    (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_SELECT   = 'NOSELECT');\n34330000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_IGSEL\n34340000              =      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT)\n34350000                &  \u00ac (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_SEL\n34360000                    | SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_NOSEL);\n34370000    %PAGE;\n34380000     SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE)        /*IF FILE IS A CANDIDATE FOR OUTPUT*/\n34390000              =      (SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE))\n34400000\n34410000                |   ((SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).C_TST)              /*ALL*/\n34420000                 & (((SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR)\n34430000                   | (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR))\n34440000                   & (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT)))\n34450000\n34460000                |  ((\u00acSMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).C_TST)              /*ANY*/\n34470000                 &   (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT));\n34480000\n34490000\n34500000  END  SMPLIST_CNTL_A_MATCH_F_BUILD;\n34510000 %SKIP(2);\n34520000  END  SMPLIST_CNTL_A_MATCH_BUILD;\n34530000 %PAGE;\n34540000  SMPLIST_INIT:                   /**************************************************/\n34550000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */\n34560000                                  /*IT INITIALIZES VARIABLES IN THE SMPLIST         */\n34570000                                  /*MAJOR STRUCTURE.                                */\n34580000                                  /**************************************************/\n34590000  PROC;                           /*IFILE IS PRESET ON ENTRY TO SMPLIST_INIT        */\n34600000     SMPLIST(IFILE).FILEREF               =  DTFLIST_LIST(IFILE);   /*FILE REFERENCE*/\n34610000     SELECT(FLOOR(1+LOG10(IFILE)));     /*NUMBER OF SIGNIFICANT DECIMAL DIGITS IN \"IFILE\"*/\n34620000       WHEN(1)                          /*IF IN SINGLE DIGITS*/\n34630000           PUT STRING(SMPLIST(IFILE).DDNAME) EDIT(DDIPFX,'LIST',IFILE) (A,A,P'9'); /*DDN*/\n34640000       WHEN(2)                          /*IF IN DOUBLE DIGITS*/\n34650000           PUT STRING(SMPLIST(IFILE).DDNAME) EDIT(DDIPFX,'LST',IFILE) (A,A,P'99'); /*DDN*/\n34660000     END;\n34670000     SMPLIST(IFILE).ACTIVE                =  '0'B;      /*ASSUME FILE IS NOT ACTIVE */\n34680000     SMPLIST(IFILE).EOF                   =  '0'B;      /*ASSUME FILE NOT AT EOF    */\n34690000     SMPLIST(IFILE).LINE_SZ               =  LIST_LINE_SIZE; /*INITIALIZE LINE SIZE */\n34700000\n34710000     SMPLIST(IFILE).CURR_PAGE.PAGE_BS     =  00000;     /*INITIALIZE PAGE NMBR BASE */\n34720000     SMPLIST(IFILE).CURR_PAGE.PAGE_NO     =  0000;      /*INITIALIZE PAGE NUMBER    */\n34730000     SMPLIST(IFILE).CURR_PAGE.PAGE_HI     =  0000;      /*INITIALIZE PAGE NUMBER    */\n34740000     SMPLIST(IFILE).CURR_PAGE.LINE_NO     =  0000;      /*INITIALIZE LINE NUMBER    */\n34750000     SMPLIST(IFILE).CURR_PAGE.FLUSH       =  '0'B;      /*INITIALIZE PAGE FLUSH IND.*/\n34760000     SMPLIST(IFILE).CURR_PAGE.LINE_CT     =  0000;      /*INITIALIZE LINE COUNT     */\n34770000     SMPLIST(IFILE).CURR_PAGE.WRITE_OUT   = '0'B;       /*INITIALIZE WRITE_OUT  IND.*/\n34780000     SMPLIST(IFILE).CURR_PAGE.CMPR_RESULT = '0'B;       /*INITIALIZE CMPR_RESULTIND.*/\n34790000     SMPLIST(IFILE).CURR_PAGE.SCAN_RESULT = '0'B;       /*INITIALIZE CMPR_RESULTIND.*/\n34800000     SMPLIST(IFILE).CURR_PAGE.ZONENAME    = ' ';        /*INITIALIZE ZONE NAME      */\n34810000     SMPLIST(IFILE).CURR_PAGE.ZONEINDX    =  0;         /*INITIALIZE ZONE INDEX     */\n34820000     SMPLIST(IFILE).CURR_PAGE.ZONETYPE    = ' ';        /*INITIALIZE ZONE TYPE      */\n34830000     SMPLIST(IFILE).CURR_PAGE.ZONETYPE_C  = ' ';        /*INITIALIZE ZONE TYPE CHR  */\n34840000     SMPLIST(IFILE).CURR_PAGE.NTRYNAME    = ' ';        /*INITIALIZE ENTRY NAME     */\n34850000     SMPLIST(IFILE).CURR_PAGE.NTRYINDX    =  0;         /*INITIALIZE ENTRY INDEX    */\n34860000     SMPLIST(IFILE).CURR_PAGE.NTRYTYPE    = ' ';        /*INITIALIZE ENTRY TYPE     */\n34870000     SMPLIST(IFILE).CURR_PAGE.FMID        = ' ';        /*INITIALIZE ENTRY FMID     */\n34880000     SMPLIST(IFILE).CURR_PAGE.SOURCEID    = ' ';        /*INITIALIZE ENTRY SOURCE ID*/\n34890000     SMPLIST(IFILE).CURR_PAGE.SYSLIB1     = ' ';        /*INITIALIZE ENTRY SYSLIB1  */\n34900000     SMPLIST(IFILE).CURR_PAGE.SYSLIB2     = ' ';        /*INITIALIZE ENTRY SYSLIB2  */\n34910000     SMPLIST(IFILE).CURR_PAGE.PAGEKEY     = ' ';        /*INITIALIZE PAGE KEY FOR NEWPAGE*/\n34920000     SMPLIST(IFILE).CURR_PAGE.NTRYKEY     = ' ';        /*INITIALIZE ENTRY KEY FOR CMPR*/\n34930000     SMPLIST(IFILE).CURR_PAGE.CMPRKEY     = ' ';        /*INITIALIZE COMPARE KEY    */\n34940000     SMPLIST(IFILE).CURR_PAGE.TITLE1_DATA = ' ';        /*INITIALIZE TITLE LINES    */\n34950000     SMPLIST(IFILE).CURR_PAGE.TITLE2_DATA = ' ';        /*INITIALIZE TITLE LINES    */\n34960000     SMPLIST(IFILE).CURR_PAGE.TITLE3_DATA = ' ';        /*INITIALIZE TITLE LINES    */\n34970000\n34980000     STRING(SMPLIST(IFILE).CURR_LINE)     = ' ';        /*INITIALIZE LINE DATA      */\n34990000\n35000000     SMPLIST(IFILE).CURR_NTRY             =   SMPLIST(IFILE).CURR_PAGE,   BY NAME;\n35010000\n35020000     SMPLIST(IFILE).M_E_TYPE(*)           = '0'B;\n35030000\n35040000     CALL  SMPLIST_SCAN_CUBE_INIT;               /*INITIALIZE SCAN_CUBE SUBSTRUCTURE*/\n35050000    %PAGE;\n35060000     SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE                 = 0; /*INITIALIZE FILE TOTALS*/\n35070000     SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT                 = 0; /*INITIALIZE FILE TOTALS*/\n35080000     SMPLIST(IFILE).FILE_TOTALS.#_E_T_FOUND                = 0; /*INITIALIZE FILE TOTALS*/\n35090000     SMPLIST(IFILE).FILE_TOTALS.RCRD_CT                    = 0; /*INITIALIZE FILE TOTALS*/\n35100000\n35110000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).ENTRY_CT  = 0; /*INITIALIZE NTRY TOTALS*/\n35120000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LIST_PAGELO = 0;\n35130000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LIST_PAGEHI = 0;\n35140000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LINE_CT   = 0; /*INITIALIZE NTRY TOTALS*/\n35150000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXNAME   = ' ';\n35160000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXLINE   = 0; /*INITIALIZE NTRY TOTALS*/\n35170000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXPAGE   = 0; /*INITIALIZE NTRY TOTALS*/\n35180000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).SELECT_CT = 0; /*INITIALIZE NTRY TOTALS*/\n35190000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MATCH_CT  = 0; /*INITIALIZE NTRY TOTALS*/\n35200000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).WRITE_CT  = 0; /*INITIALIZE NTRY TOTALS*/\n35210000\n35220000     DO  NTRYINDX_IX = NTRYINDX_MIN TO NTRYINDX_MAX;\n35230000       SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX)            =\n35240000                                    SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1), BY NAME;\n35250000     END;                  /*END OF NTRYINDX_IX DO GROUP*/\n35260000\n35270000  END  SMPLIST_INIT;\n35280000 %PAGE;\n35290000  SMPLIST_SCAN_CUBE_INIT:         /**************************************************/\n35300000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */\n35310000                                  /*IT INITIALIZES THE SCAN_CUBE SUBSTRUCTURE       */\n35320000                                  /*IN THE SMPLIST FILE MANAGEMENT STRUCTURE.       */\n35330000                                  /**************************************************/\n35340000  PROC;                     /*IFILE IS SET PRIOR TO CALLING SMPLIST_SCAN_CUBE_INIT  */\n35350000         SMPLIST(IFILE).SCAN_CUBE.RESULT   = '0'B;\n35360000         SMPLIST(IFILE).SCAN_CUBE.SELECT   = '0'B;\n35370000         SMPLIST(IFILE).SCAN_CUBE.ACTIVE   = '0'B;\n35380000     DO  IPLANE = IPLANE_MIN TO IPLANE_MAX;\n35390000         SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT   = '0'B;\n35400000         SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).SELECT   = '0'B;\n35410000         SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE   = '0'B;\n35420000       DO  IROW = IROW_MIN   TO IROW_MAX;\n35430000         SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).RESULT   = '0'B;\n35440000         SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).SELECT   = '0'B;\n35450000         SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE   = '0'B;\n35460000       END;                /*END OF IROW DO GROUP*/\n35470000     END;                  /*END OF IPLANE DO GROUP*/\n35480000\n35490000  END  SMPLIST_SCAN_CUBE_INIT;\n35500000 %PAGE;\n35510000  SMPLIST_SCAN_CUBE_BUILD:        /**************************************************/\n35520000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */\n35530000                                  /*IT SETS UP THE SCAN_CUBE SUBSTRUCTURE           */\n35540000                                  /*IN THE SMPLIST FILE MANAGEMENT STRUCTURE.       */\n35550000                                  /**************************************************/\n35560000  PROC;                     /*IFILE IS SET PRIOR TO CALLING SMPLIST_SCAN_CUBE_BUILD */\n35570000     DO     IPLANE  = IPLANE_MIN TO IPLANE_MAX;\n35580000       DO     IROW  = IROW_MIN   TO IROW_MAX;\n35590000         DO   ICOL  = ICOL_MIN   TO ICOL_MAX;\n35600000\n35610000           IF SCAN_ARRAY(IFILE).STR_LEN(IPLANE,IROW,ICOL) > 0   /*IF STRING SUPPLIED*/\n35620000             THEN      /*IF ANY COLUMN IN THE ROW IS ACTIVE, SET THE ROW ACTIVE IND.*/\n35630000               DO;\n35640000                SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE = '1'B;\n35650000                SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  =\n35660000                               SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  + 1;\n35670000               END;\n35680000\n35690000         END;              /*END OF ICOL DO GROUP*/\n35700000\n35710000         IF    (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE)\n35720000           THEN       /*IF ANY COLUMN IN THE ROW IS ACTIVE, SET THE ROW SELECT OPTION*/\n35730000             DO;      /*AND THE PLANE ACTIVE OPTION                                  */\n35740000               SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE = '1'B;\n35750000               IF SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).SELECT_OPTION = 'SELECT'\n35760000                 THEN SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).SELECT  = '1'B;\n35770000               SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  =\n35780000                              SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  + 1;\n35790000             END;\n35800000\n35810000       END;                /*END OF IROW DO GROUP*/\n35820000\n35830000       IF    (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE)\n35840000         THEN         /*IF ANY ROW IN THE PLANE IS ACTIVE, SET THE PLANE SELECT OPTION*/\n35850000           DO;        /*AND THE CUBE  ACTIVE OPTION                                   */\n35860000             SMPLIST(IFILE).SCAN_CUBE.ACTIVE = '1'B;\n35870000             IF SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).SELECT_OPTION = 'SELECT'\n35880000               THEN SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).SELECT  = '1'B;\n35890000             SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  =\n35900000                            SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  + 1;\n35910000           END;\n35920000\n35930000     END;                  /*END OF IPLANE DO GROUP*/\n35940000\n35950000     IF    (SMPLIST(IFILE).SCAN_CUBE.ACTIVE)\n35960000       THEN           /*IF ANY PLANE IN THE CUBE IS ACTIVE, SET THE CUBE SELECT OPTION*/\n35970000         DO;\n35980000            IF SCAN_ARRAY.FILE(IFILE).SELECT_OPTION = 'SELECT'\n35990000              THEN SMPLIST(IFILE).SCAN_CUBE.SELECT  = '1'B;\n36000000            SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  =\n36010000                           SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  + 1;\n36020000           END;\n36030000\n36040000  END  SMPLIST_SCAN_CUBE_BUILD;\n36050000 %PAGE;\n36060000  SMPUT_INIT:                     /**************************************************/\n36070000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */\n36080000                                  /*IT INITIALIZES VARIABLES IN THE SMPUT MAJOR     */\n36090000                                  /*STRUCTURE.                                      */\n36100000                                  /**************************************************/\n36110000  PROC;                           /*IFILE IS PRESET ON ENTRY TO SMPUT_INIT          */\n36120000     SMPUT(IFILE).FILEREF             =  DTFUT_LIST(IFILE);         /*FILE REFERENCE*/\n36130000     SELECT(FLOOR(1+LOG10(IFILE)));     /*NUMBER OF SIGNIFICANT DECIMAL DIGITS IN \"IFILE\"*/\n36140000       WHEN(1)                          /*IF IN SINGLE DIGITS*/\n36150000           PUT STRING(SMPUT(IFILE).DDNAME) EDIT(DDIPFX,'UT',IFILE)     (A,A,P'9'); /*DDN*/\n36160000       WHEN(2)                          /*IF IN DOUBLE DIGITS*/\n36170000           PUT STRING(SMPUT(IFILE).DDNAME) EDIT(DDIPFX,'UT',IFILE)    (A,A,P'99'); /*DDN*/\n36180000     END;\n36190000     SMPUT(IFILE).WRITE.SAVE_CT       =  0000;         /*INITIALIZE WRITE SAVE COUNT*/\n36200000     SMPUT(IFILE).WRITE.OPEN_CT       =  0000;         /*INITIALIZE WRITE OPEN COUNT*/\n36210000     SMPUT(IFILE).WRITE.LINE_CT       =  0000;         /*INITIALIZE WRITE LINE COUNT*/\n36220000\n36230000     SMPUT(IFILE).READ                =  SMPUT(IFILE).WRITE,  BY NAME;\n36240000  END  SMPUT_INIT;\n36250000 %PAGE;\n36260000  SMPSCAN_INIT:                   /**************************************************/\n36270000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */\n36280000                                  /*IT INITIALIZES VARIABLES IN THE SMPSCAN MAJOR   */\n36290000                                  /*STRUCTURE.                                      */\n36300000                                  /**************************************************/\n36310000  PROC;                           /*IFILE IS PRESET ON ENTRY TO SMPSCAN_INIT        */\n36320000     SMPSCAN(IFILE).FILEREF           =  DTFSCAN_LIST(IFILE);       /*FILE REFERENCE*/\n36330000     SELECT(FLOOR(1+LOG10(IFILE)));     /*NUMBER OF SIGNIFICANT DECIMAL DIGITS IN \"IFILE\"*/\n36340000       WHEN(1)                          /*IF IN SINGLE DIGITS*/\n36350000           PUT STRING(SMPSCAN(IFILE).DDNAME) EDIT(DDOPFX,'SCAN',IFILE) (A,A,P'9'); /*DDN*/\n36360000       WHEN(2)                          /*IF IN DOUBLE DIGITS*/\n36370000           PUT STRING(SMPSCAN(IFILE).DDNAME) EDIT(DDOPFX,'SCN',IFILE) (A,A,P'99'); /*DDN*/\n36380000     END;\n36390000     SMPSCAN(IFILE).ACTIVE            =  '0'B;          /*FILE NOT YET ACTIVATED*/\n36400000     SMPSCAN(IFILE).OPEN              =  '0'B;          /*FILE NOT YET OPENED*/\n36410000     SMPSCAN(IFILE).PAGE_SZ           =  060;           /*INITIALIZE PAGE SIZE*/\n36420000     SMPSCAN(IFILE).LINE_SZ           =  LIST_LINE_SIZE + 012; /*INITIALIZE LINE SIZE*/\n36430000     SMPSCAN(IFILE).CURR_PAGE.PAGE_NO =  0000;          /*INITIALIZE PAGE NUMBER*/\n36440000     SMPSCAN(IFILE).CURR_PAGE.PAGEKEY = ' ';            /*INITIALIZE PAGE KEY FOR NEWPAGE*/\n36450000     SMPSCAN(IFILE).CURR_PAGE.TITLE1_DATA = ' ';        /*INITIALIZE TITLE LINES    */\n36460000     SMPSCAN(IFILE).CURR_PAGE.TITLE2_DATA = ' ';        /*INITIALIZE TITLE LINES    */\n36470000     SMPSCAN(IFILE).CURR_PAGE.TITLE3_DATA = ' ';        /*INITIALIZE TITLE LINES    */\n36480000\n36490000     SMPSCAN(IFILE).CURR_NTRY         =   SMPSCAN(IFILE).CURR_PAGE, BY NAME;\n36500000  END  SMPSCAN_INIT;\n36510000 %SKIP(3);\n36520000  SMPSOUT_INIT:                   /**************************************************/\n36530000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */\n36540000                                  /*IT INITIALIZES VARIABLES IN THE SMPSOUT MAJOR   */\n36550000                                  /*STRUCTURE.                                      */\n36560000                                  /**************************************************/\n36570000  PROC;                           /*IFILE IS PRESET ON ENTRY TO SMPSOUT_INIT        */\n36580000     SMPSOUT(IFILE).FILEREF           =  DTFSOUT_LIST(IFILE);       /*FILE REFERENCE*/\n36590000     SELECT(FLOOR(1+LOG10(IFILE)));     /*NUMBER OF SIGNIFICANT DECIMAL DIGITS IN \"IFILE\"*/\n36600000       WHEN(1)                          /*IF IN SINGLE DIGITS*/\n36610000           PUT STRING(SMPSOUT(IFILE).DDNAME) EDIT(DDOPFX,'SOUT',IFILE) (A,A,P'9'); /*DDN*/\n36620000       WHEN(2)                          /*IF IN DOUBLE DIGITS*/\n36630000           PUT STRING(SMPSOUT(IFILE).DDNAME) EDIT(DDOPFX,'SOU',IFILE) (A,A,P'99'); /*DDN*/\n36640000     END;\n36650000     SMPSOUT(IFILE).ACTIVE            =  '0'B;          /*FILE NOT YET ACTIVATED*/\n36660000     SMPSOUT(IFILE).OPEN              =  '0'B;          /*FILE NOT YET OPENED*/\n36670000     SMPSOUT(IFILE).PAGE_SZ           =  060;           /*INITIALIZE PAGE SIZE*/\n36680000     SMPSOUT(IFILE).LINE_SZ           =  LIST_LINE_SIZE; /*INITIALIZE LINE SIZE*/\n36690000     SMPSOUT(IFILE).CURR_PAGE.PAGE_NO =  0000;          /*INITIALIZE PAGE NUMBER*/\n36700000     SMPSOUT(IFILE).CURR_PAGE.PAGEKEY =  ' ';           /*INITIALIZE PAGE KEY FOR NEWPAGE*/\n36710000     SMPSOUT(IFILE).CURR_PAGE.TITLE1_DATA = ' ';        /*INITIALIZE TITLE LINES    */\n36720000     SMPSOUT(IFILE).CURR_PAGE.TITLE2_DATA = ' ';        /*INITIALIZE TITLE LINES    */\n36730000     SMPSOUT(IFILE).CURR_PAGE.TITLE3_DATA = ' ';        /*INITIALIZE TITLE LINES    */\n36740000\n36750000     SMPSOUT(IFILE).CURR_NTRY         =   SMPSOUT(IFILE).CURR_PAGE, BY NAME;\n36760000  END  SMPSOUT_INIT;\n36770000 %PAGE;\n36780000  SMPDATA_INIT:                   /**************************************************/\n36790000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */\n36800000                                  /*IT INITIALIZES VARIABLES IN THE SMPDATA MAJOR   */\n36810000                                  /*STRUCTURE.                                      */\n36820000                                  /**************************************************/\n36830000  PROC;                           /*IFILE IS PRESET ON ENTRY TO SMPDATA_INIT        */\n36840000     SMPDATA(IFILE).FILEREF           =  DTFDATA_LIST(IFILE);       /*FILE REFERENCE*/\n36850000     SELECT(FLOOR(1+LOG10(IFILE)));     /*NUMBER OF SIGNIFICANT DECIMAL DIGITS IN \"IFILE\"*/\n36860000       WHEN(1)                          /*IF IN SINGLE DIGITS*/\n36870000           PUT STRING(SMPDATA(IFILE).DDNAME) EDIT(DDOPFX,'DATA',IFILE) (A,A,P'9'); /*DDN*/\n36880000       WHEN(2)                          /*IF IN DOUBLE DIGITS*/\n36890000           PUT STRING(SMPDATA(IFILE).DDNAME) EDIT(DDOPFX,'DAT',IFILE) (A,A,P'99'); /*DDN*/\n36900000     END;\n36910000     SMPDATA(IFILE).ACTIVE            =  '0'B;          /*FILE NOT YET ACTIVATED*/\n36920000     SMPDATA(IFILE).OPEN              =  '0'B;          /*FILE NOT YET OPENED*/\n36930000     SMPDATA(IFILE).LINE_SZ           =  LIST_LINE_RCZD; /*INITIALIZE LINE(RECORD SIZE*/\n36940000     SMPDATA(IFILE).CURR_CARD.DATA    =  ' ';           /*CLEAR DATA OUTPUT AREA*/\n36950000     SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  000000000;     /*INITIALIZE SEQUENCE NUMBER*/\n36960000\n36970000     SMPDATA(IFILE).CURR_NTRY         =   SMPDATA(IFILE).CURR_CARD, BY NAME;\n36980000  END  SMPDATA_INIT;\n36990000 %PAGE;\n37000000     SMPSCAN_ACTIVATE:           /***************************************************/\n37010000                                 /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.     */\n37020000                                 /*IT ACTIVATES THE SMPSCAN DATA SET FOR THIS IFILE.*/\n37030000                                 /***************************************************/\n37040000       PROC;                     /*IFILE IS SET PRIOR TO CALLING SMPSCAN_ACTIVATE   */\n37050000\n37060000          SMPSCAN(IFILE).ACTIVE  =   '1'B;          /*INDICATE FILE IS ACTIVE*/\n37070000          SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT = SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT + 1;\n37080000\n37090000       END SMPSCAN_ACTIVATE;\n37100000     %SKIP(3);\n37110000     SMPSOUT_ACTIVATE:           /***************************************************/\n37120000                                 /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.     */\n37130000                                 /*IT ACTIVATES THE SMPSOUT DATA SET FOR THIS IFILE.*/\n37140000                                 /***************************************************/\n37150000       PROC;                     /*IFILE IS SET PRIOR TO CALLING SMPSOUT_ACTIVATE   */\n37160000\n37170000          SMPSOUT(IFILE).ACTIVE  =   '1'B;          /*INDICATE FILE IS ACTIVE*/\n37180000          SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT = SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT + 1;\n37190000\n37200000       END SMPSOUT_ACTIVATE;\n37210000     %SKIP(3);\n37220000     SMPDATA_ACTIVATE:           /***************************************************/\n37230000                                 /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.     */\n37240000                                 /*IT ACTIVATES THE SMPDATA DATA SET FOR THIS IFILE.*/\n37250000                                 /***************************************************/\n37260000       PROC;                     /*IFILE IS SET PRIOR TO CALLING SMPDATA_ACTIVATE   */\n37270000          IF  DATA_OUTPUT_OPTION(IFILE)  \u00ac=  'NONE'\n37280000            THEN           /*IF DATA_OUTPUT_OPTION = 'ID1' | 'ID' | 'SELECT' | 'ALL'*/\n37290000              DO;\n37300000                SMPDATA(IFILE).ACTIVE  =   '1'B;          /*INDICATE FILE IS ACTIVE*/\n37310000              END;\n37320000          SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT = SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT + 1;\n37330000       END SMPDATA_ACTIVATE;\n37340000 %SKIP(5);\n37350000  END SMPLIST_OPEN;\n37360000 %PAGE;\n37370000  SMPLIST_CURR_PAGE_EOF:    /********************************************************/\n37380000                            /*THE SMPLIST_CURR_PAGE_EOF SUBROUTINE IS CALLED BY     */\n37390000                            /*SMPLIST_OPEN FOR INACTIVE FILES, AND BY               */\n37400000                            /*SMPLIST_ENTRY_LINE_READ WHEN ATTEMPTING TO BEGIN A    */\n37410000                            /*NEW ENTRY AT END-OF-FILE.  THIS SUBROUTINE SETS HIGH  */\n37420000                            /*KEY VALUES AND OTHERWISE RESETS VALUES IN THE         */\n37430000                            /*CURR_PAGE SUBSTRUCTURE OF THE SMPLIST MAJOR STRUCTURE.*/\n37440000                            /********************************************************/\n37450000  PROC;                        /*IFILE IS SET PRIOR TO CALLING SMPLIST_CURR_PAGE_EOF*/\n37460000\n37470000     STRING(SMPLIST(IFILE).CURR_LINE)                 =  ' ';      /*CLEAR LINE DATA*/\n37480000     SUBSTR(SMPLIST(IFILE).CURR_LINE.IN.DATA,LIST_LINE_NBGN,LIST_LINE_NWID)\n37490000                                           = HIGH(LIST_LINE_NWID);/*ENTRY NAME FIELD*/\n37500000\n37510000     SMPLIST(IFILE).CURR_PAGE           =  SMPLIST_CNTL.HIGH_PAGE,  BY NAME;\n37520000\n37530000  END  SMPLIST_CURR_PAGE_EOF;\n37540000 %PAGE;\n37550000  SMPLIST_ENTRY_LINE_READ:\n37560000  /********************************************************/\n37570000  /*READ THE NEXT LINE FROM THE CURRENT SMPLIST DATA SET, */\n37580000  /********************************************************/\n37590000  PROC;     /*IFILE IS SET PRIOR TO CALLING SMPLIST_ENTRY_LINE_READ*/\n37600000     DCL    ENTRY_DATA_LINE         BIT(1);               /*ASSUME NOT A DATA LINE  */\n37610000\n37620000     ON ENDFILE(SMPLIST(IFILE).FILEREF)\n37630000        BEGIN;\n37640000           SMPLIST(IFILE).EOF = '1'B;                 /*SIGNAL END-OF-FILE ON INPUT */\n37650000        END;\n37660000\n37670000     SMPLIST_TITLE1_MAP_ADDR,\n37680000     SMPLIST_TITLE2_MAP_ADDR,\n37690000     SMPLIST_TITLE3_MAP_ADDR  = ADDR(SMPLIST(IFILE).CURR_LINE.IN.DATA);\n37700000    %PAGE;\n37710000     READ FILE(SMPLIST(IFILE).FILEREF) INTO(SMPLIST(IFILE).CURR_LINE.IN);\n37720000     ENTRY_DATA_LINE = '0'B;              /*ASSUME NOT A DATA LINE*/\n37730000\n37740000     DO WHILE(\u00ac(SMPLIST(IFILE).EOF))      /*IF EOF WAS NOT RECOGNIZED       */\n37750000                                          /*  (AN INPUT LINE WAS JUST READ),*/\n37760000                                          /*DETERMINE WHETHER THE LINE      */\n37770000        UNTIL(ENTRY_DATA_LINE);           /*IS PART OF AN ENTRY LISTING.    */\n37780000\n37790000        SMPLIST(IFILE).FILE_TOTALS.RCRD_CT = SMPLIST(IFILE).FILE_TOTALS.RCRD_CT + 1;\n37800000\n37810000        SELECT(SMPLIST(IFILE).CURR_LINE.IN.PRTCTL); /*UPDATE LINE NUMBER ON PAGE*/\n37820000          WHEN('1') SMPLIST(IFILE).CURR_PAGE.LINE_NO = 01;         /*TOP-OF-PAGE*/\n37830000          WHEN('+') SMPLIST(IFILE).CURR_PAGE.LINE_NO = SMPLIST(IFILE).CURR_PAGE.LINE_NO + 0;\n37840000          WHEN(' ') SMPLIST(IFILE).CURR_PAGE.LINE_NO = SMPLIST(IFILE).CURR_PAGE.LINE_NO + 1;\n37850000          WHEN('0') SMPLIST(IFILE).CURR_PAGE.LINE_NO = SMPLIST(IFILE).CURR_PAGE.LINE_NO + 2;\n37860000          WHEN('-') SMPLIST(IFILE).CURR_PAGE.LINE_NO = SMPLIST(IFILE).CURR_PAGE.LINE_NO + 3;\n37870000          OTHERWISE;\n37880000        END;\n37890000\n37900000        SELECT;            /*PROCESS THE LISTING LINE JUST READ FROM SMPLIST:*/\n37910000         WHEN(  SMPLIST(IFILE).CURR_PAGE.LINE_NO <= 01       /*IF TITLE1 LINE*/\n37920000              & SMPLIST_TITLE1_MAP.EDATE         =  'DATE'\n37930000              & SMPLIST_TITLE1_MAP.ETIME         =  'TIME'\n37940000              & SMPLIST_TITLE1_MAP.EGIMSMP       =  'GIMSMP'\n37950000              & SMPLIST_TITLE1_MAP.ESMPLIST      =  'SMPLIST'\n37960000              & SMPLIST_TITLE1_MAP.EOUTPUT       =  'OUTPUT' )\n37970000            DO;\n37980000                IF      SMPLIST_TITLE1_MAP.PAGE_NO   = '0000'    /*PAGE NUMBER RECYCLE?*/\n37990000                  THEN  SMPLIST(IFILE).CURR_PAGE.PAGE_BS\n38000000                                                     =  SMPLIST(IFILE).CURR_PAGE.PAGE_BS\n38010000                                                     +  10000;\n38020000                SMPLIST(IFILE).CURR_PAGE.PAGE_NO     =  SMPLIST(IFILE).CURR_PAGE.PAGE_BS\n38030000                                                     +  SMPLIST_TITLE1_MAP.PAGE_NO;\n38040000                SMPLIST(IFILE).CURR_PAGE.FLUSH       = '0'B;     /*SET TO PROCESS PAGE*/\n38050000                IF      SMPLIST_TITLE1_MAP.ZONETYPE  = 'GLOBAL'\n38060000                  THEN  SMPLIST(IFILE).CURR_PAGE.ZONENAME\n38070000                                                     = 'GLOBAL';\n38080000                  ELSE  SMPLIST(IFILE).CURR_PAGE.ZONENAME\n38090000                                                     =  TRIM(SMPLIST_TITLE1_MAP.ZONENAME);\n38100000                SMPLIST(IFILE).CURR_PAGE.ZONEINDX    =\n38110000                                                 ZONE_INDEX(SMPLIST_TITLE1_MAP.ZONETYPE);\n38120000                SMPLIST(IFILE).CURR_PAGE.ZONETYPE    =\n38130000                                            ZONE_TYPE(SMPLIST(IFILE).CURR_PAGE.ZONEINDX);\n38140000                SMPLIST(IFILE).CURR_PAGE.ZONETYPE_C  =\n38150000                                          ZONE_TYPE_C(SMPLIST(IFILE).CURR_PAGE.ZONEINDX);\n38160000                SMPLIST(IFILE).CURR_PAGE.TITLE1_DATA = SMPLIST(IFILE).CURR_LINE.IN.DATA;\n38170000                SMPLIST(IFILE).CURR_PAGE.TITLE2_DATA,\n38180000                SMPLIST(IFILE).CURR_PAGE.TITLE3_DATA = ' ';      /*CLEAR TITLE2 & 3*/\n38190000                READ FILE(SMPLIST(IFILE).FILEREF) INTO(SMPLIST(IFILE).CURR_LINE.IN);\n38200000            END;\n38210000    %PAGE;\n38220000         WHEN(  SMPLIST(IFILE).CURR_PAGE.LINE_NO <= 03       /*IF TITLE2 LINE*/\n38230000              & SMPLIST_TITLE2_MAP.ZONENAME      =  SMPLIST(IFILE).CURR_PAGE.ZONENAME\n38240000                                                             /*IF VALID ENTRY TYPE*/\n38250000              & ENTRY_INDEX(ENTRY_TYPE_TRIM(SUBSTR(SMPLIST_TITLE2_MAP.NTRYTYPE,001))) > 0)\n38260000            DO;\n38270000                SMPLIST(IFILE).CURR_PAGE.TITLE2_DATA = SMPLIST(IFILE).CURR_LINE.IN.DATA;\n38280000                SMPLIST(IFILE).CURR_PAGE.NTRYINDX    =\n38290000                   ENTRY_INDEX(ENTRY_TYPE_TRIM(SUBSTR(SMPLIST_TITLE2_MAP.NTRYTYPE,001)));\n38300000                SMPLIST(IFILE).CURR_PAGE.NTRYTYPE    =\n38310000                                           ENTRY_TYPE(SMPLIST(IFILE).CURR_PAGE.NTRYINDX);\n38320000                READ FILE(SMPLIST(IFILE).FILEREF) INTO(SMPLIST(IFILE).CURR_LINE.IN);\n38330000            END;\n38340000\n38350000         WHEN(  SMPLIST(IFILE).CURR_PAGE.LINE_NO <= 03       /*IF MASS SUMMARY REPORT   */\n38360000                                                             /*OR SELECT SUMMARY REPORT */\n38370000            & ( SMPLIST_TITLE2_MAP.ZONENAME      =  'LIST'   /*BYPASS THE PAGE ENTIRELY.*/\n38380000            &  (INDEX(SMPLIST_TITLE2_MAP.NTRYTYPE,'MASS SUMMARY REPORT') > 0\n38390000              | INDEX(SMPLIST_TITLE2_MAP.NTRYTYPE,'SELECT SUMMARY REPORT') > 0)) )\n38400000            DO;\n38410000                SMPLIST(IFILE).CURR_PAGE.FLUSH  =  '1'B;\n38420000                READ FILE(SMPLIST(IFILE).FILEREF) INTO(SMPLIST(IFILE).CURR_LINE.IN);\n38430000            END;\n38440000\n38450000         WHEN(  SMPLIST(IFILE).CURR_PAGE.LINE_NO <= 06       /*IF TITLE3 LINE*/\n38460000              & SMPLIST_TITLE3_MAP.FILL01        =  ' '\n38470000              & SMPLIST_TITLE3_MAP.ENAME         =  'NAME'\n38480000              & SMPLIST_TITLE3_MAP.FILL02        =  ' ' )\n38490000            DO;\n38500000                SMPLIST(IFILE).CURR_PAGE.TITLE3_DATA = SMPLIST(IFILE).CURR_LINE.IN.DATA;\n38510000                READ FILE(SMPLIST(IFILE).FILEREF) INTO(SMPLIST(IFILE).CURR_LINE.IN);\n38520000            END;\n38530000\n38540000         WHEN(  SMPLIST(IFILE).CURR_PAGE.FLUSH              /*IF PAGE IS BEING SKIPPED*/\n38550000              | SMPLIST(IFILE).CURR_LINE.IN.DATA = ' ')     /*OR THE LINE IS BLANK*/\n38560000            DO;                                             /*THEN SKIP PAST THE LINE*/\n38570000                READ FILE(SMPLIST(IFILE).FILEREF) INTO(SMPLIST(IFILE).CURR_LINE.IN);\n38580000            END;\n38590000\n38600000         OTHERWISE                 /*IF ALL OF THE PRECEEDING TESTS FAILED,          */\n38610000            DO;                    /*THE LINE JUST READ IS AN ENTRY LISTING LINE.    */\n38620000                ENTRY_DATA_LINE = '1'B;          /*INDICATE THAT A DATA LINE WAS READ*/\n38630000            END;\n38640000\n38650000        END;           /*END OF SELECT GROUP FOR IDENTIFYING THE TYPE OF LINE READ*/\n38660000\n38670000     END;              /*END OF DO WHILE(\u00acSMPLIST(IFILE).EOF) UNTIL(ENTRY_DATA_LINE) GROUP*/\n38680000    %PAGE;\n38690000                                     /*AN ENTRY LISTING LINE HAS JUST BEEN READ.    */\n38700000                                     /*CHECK FOR THE START OF A NEW ENTRY LISTING.  */\n38710000                                     /*WE HAVE REACHED THE END OF THE CURRENT ENTRY */\n38720000                                     /*IF THIS IS THE FIRST LINE OF A NEW ENTRY,    */\n38730000                                     /*OR IF END-OF-FILE WAS ENCOUNTERED.           */\n38740000                                     /*IN EITHER CASE, WE WRAP UP PROCESSING OF     */\n38750000                                     /*THE CURRENT ENTRY AND PREPARE TO BEGIN       */\n38760000                                     /*PROCESSING THE NEW ENTRY.                    */\n38770000\n38780000     IF ( \u00ac(SMPLIST(IFILE).EOF)      /*IF THE FIRST LINE OF A NEW ENTRY,            */\n38790000         & (SUBSTR(SMPLIST(IFILE).CURR_LINE.IN.DATA,LIST_LINE_NBGN,LIST_LINE_NWID) \u00ac= ' '))\n38800000      |    (SMPLIST(IFILE).EOF)      /*OR IF END-OF-FILE                            */\n38810000        THEN\n38820000          DO;          /*THE LINE JUST READ OR E-O-F ENDS THE PREVIOUS ENTRY LISTING*/\n38830000             /*---------------------------------------------*/\n38840000             /*PREPARE FOR PROCESSING A NEW ENTRY OR E-O-F  */\n38850000             /*---------------------------------------------*/\n38860000             IF  \u00ac(SMPLIST(IFILE).EOF)\n38870000               THEN                                         /*FIRST LINE OF A NEW ENTRY */\n38880000                 DO;\n38890000                   SMPLIST(IFILE).CURR_LINE.LINETYPE   = ' ';  /*INITIALIZE FOR NEW ENTRY*/\n38900000                   SMPLIST(IFILE).CURR_LINE.LINETYPE   =\n38910000                                    LINE_TYPE(SMPLIST(IFILE).CURR_LINE.LINETYPE,\n38920000                                              SMPLIST(IFILE).CURR_LINE.IN.DATA);\n38930000                   SMPLIST(IFILE).CURR_PAGE.NTRYNAME   =\n38940000                                              TRIM(SUBSTR(SMPLIST(IFILE).CURR_LINE.IN.DATA,\n38950000                                                          LIST_LINE_NBGN,LIST_LINE_NWID));\n38960000                   PUT STRING(SMPLIST(IFILE).CURR_PAGE.PAGEKEY)\n38970000                       EDIT('0')                                  (A(1))\n38980000                           (SMPLIST(IFILE).CURR_PAGE.ZONEINDX)    (P'9')\n38990000                           (SMPLIST(IFILE).CURR_PAGE.ZONENAME)    (A(007))\n39000000                           (SMPLIST(IFILE).CURR_PAGE.NTRYINDX)    (P'99');\n39010000                   SMPLIST(IFILE).CURR_PAGE.NTRYKEY  =   SMPLIST(IFILE).CURR_PAGE.PAGEKEY\n39020000                                                      || SMPLIST(IFILE).CURR_PAGE.NTRYNAME;\n39030000                   PUT STRING(SMPLIST(IFILE).CURR_PAGE.CMPRKEY)\n39040000                       EDIT('0')                                  (A(1))\n39050000                           (SMPLIST(IFILE).CURR_PAGE.NTRYINDX)    (P'99')\n39060000                           (SMPLIST(IFILE).CURR_PAGE.NTRYNAME)    (A(008));\n39070000                 END;\n39080000               ELSE                              /*IF ENTRY TERMINATED BY END-OF-FILE  */\n39090000                 DO;\n39100000                   CALL SMPLIST_CURR_PAGE_EOF;   /*SET CURR_PAGE VALUES FOR END-OF-FILE*/\n39110000                 END;\n39120000          END;\n39130000        ELSE\n39140000          DO;     /*THE LINE JUST READ IS A CONTINUATION OF THE CURRENT ENTRY LISTING*/\n39150000            SMPLIST(IFILE).CURR_LINE.LINETYPE  =      /*DETERMINE LINETYPE*/\n39160000                           LINE_TYPE(SMPLIST(IFILE).CURR_LINE.LINETYPE,\n39170000                                     SMPLIST(IFILE).CURR_LINE.IN.DATA);\n39180000          END;\n39190000     RETURN;\n39200000  END SMPLIST_ENTRY_LINE_READ;\n39210000 %PAGE;\n39220000  SMPLIST_ENTRY_READ:\n39230000  /********************************************************/\n39240000  /*READ THE NEXT ENTRY FROM THE ACTIVE SMPLIST DATA SETS */\n39250000  /********************************************************/\n39260000  PROC;\n39270000\n39280000      DO      IFILE = IFILE_MIN TO IFILE_MAX;\n39290000        IF   (SMPLIST(IFILE).ACTIVE)                     /*PROCESS ONLY THE ACTIVE FILES */\n39300000          &  (SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT)      /*THAT WERE PROCESSED LAST TIME.*/\n39310000          THEN\n39320000            DO;                                   /*UPDATE CURR_NTRY FOR NEW ENTRY OR EOF*/\n39330000              SMPLIST(IFILE).CURR_NTRY = SMPLIST(IFILE).CURR_PAGE   , BY NAME;\n39340000\n39350000              IF   (SMPLIST(IFILE).EOF)              /*IF THE FILE IS AT ITS END,        */\n39360000                THEN;                                /*THEN FILE PROCESSING IS COMPLETE  */\n39370000                ELSE CALL SMPLIST_ENTRY_FILE_READ;   /*OTHERWISE READ THE NEXT ENTRY.    */\n39380000\n39390000            END;            /*END OF ACTIVE IFILE/CMPR_RESULT DO GROUP*/\n39400000      END;                  /*END OF IFILE                    DO GROUP*/\n39410000\n39420000      CALL SMPLIST_ENTRY_COMPARE;   /*COMPARE KEYS FOR ENTRIES READ*/\n39430000\n39440000      CALL SMPLIST_ENTRY_MATCH;     /*SEE IF THESE ENTRIES SHOULD BE PROCESSED FURTHER*/\n39450000\n39460000      RETURN;                       /*TO THE CALLER OF SMPLIST_ENTRY_READ*/\n39470000 %PAGE;\n39480000  SMPLIST_ENTRY_FILE_READ:\n39490000                              /***********************************************************/\n39500000                              /*THIS PROCEDURE IS INTERNAL TO \"SMPLIST_ENTRY_READ\".      */\n39510000                              /*IT READS THE NEXT ENTRY FROM THE CURRENT SMPLIST         */\n39520000                              /*DATA SET:                                                */\n39530000                              /***********************************************************/\n39540000  PROC;                       /*IFILE IS SET ON ENTRY TO SMPLIST_ENTRY_FILE_READ         */\n39550000     IF      (SMPLIST(IFILE).M_E_TYPE(SMPLIST(IFILE).CURR_NTRY.NTRYINDX))\n39560000       THEN\n39570000         DO;\n39580000              IF  (SMPLIST(IFILE).SCAN_CUBE.ACTIVE)       /*IF ENTRIES ARE BEING SCANNED,*/\n39590000                THEN CALL  SMPLIST_ENTRY_SCAN_INIT;            /*INIT SCAN_CUBE FOR ENTRY*/\n39600000         END;\n39610000\n39620000     DO WHILE(SMPLIST(IFILE).CURR_PAGE.NTRYKEY = SMPLIST(IFILE).CURR_NTRY.NTRYKEY);\n39630000        CALL               SMPLIST_ENTRY_LINE_EVAL;       /*EVALUATE THE CURRENT LINE    */\n39640000        IF   (SMPLIST(IFILE).M_E_TYPE(SMPLIST(IFILE).CURR_NTRY.NTRYINDX))\n39650000          THEN\n39660000            DO;\n39670000              IF  (SMPLIST(IFILE).SCAN_CUBE.ACTIVE)       /*IF ENTRIES ARE BEING SCANNED,*/\n39680000                THEN CALL  SMPLIST_ENTRY_LINE_SCAN;       /*SCAN THE CURRENT LINE        */\n39690000              CALL         SMPLIST_ENTRY_LINE_SAVE;       /*SAVE THE CURRENT LINE        */\n39700000            END;\n39710000        CALL               SMPLIST_ENTRY_LINE_READ;       /*READ THE NEXT    LINE        */\n39720000     END;\n39730000     CALL                  SMPLIST_ENTRY_FILE_READ_WRAPUP;    /*CALC. CURR_NTRY FINAL VALS*/\n39740000\n39750000     IF      (SMPLIST(IFILE).M_E_TYPE(SMPLIST(IFILE).CURR_NTRY.NTRYINDX))\n39760000       THEN\n39770000         DO;\n39780000           IF (SMPLIST(IFILE).CURR_NTRY.LINE_CT > LINE_SAVE_LIMIT)/*IF SPILL FILE OPENED,*/\n39790000             THEN CLOSE FILE(SMPUT(IFILE).FILEREF) ENV(REREAD);   /*CLOSE IT.            */\n39800000\n39810000           IF (SMPLIST(IFILE).SCAN_CUBE.ACTIVE)            /*FINAL SCAN RESULTS FOR ENTRY*/\n39820000             THEN SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT = SMPLIST_ENTRY_SCAN_RESULT;\n39830000\n39840000           IF (SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT)\n39850000             THEN\n39860000               DO;        /*IF THE SCAN_RESULT IS POSITIVE, UPDATE SELECT_CT TOTALS*/\n39870000                 SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).SELECT_CT  =\n39880000                                 SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).SELECT_CT + 1;\n39890000                 SMPLIST(IFILE).ENTRY_TOTALS(SMPLIST(IFILE).CURR_NTRY.NTRYINDX).SELECT_CT =\n39900000                 SMPLIST(IFILE).ENTRY_TOTALS(SMPLIST(IFILE).CURR_NTRY.NTRYINDX).SELECT_CT\n39910000                                                                                    + 1;\n39920000               END;\n39930000         END;\n39940000\n39950000     RETURN;                       /*TO THE CALLER OF SMPLIST_ENTRY_FILE_READ*/\n39960000 %PAGE;\n39970000  SMPLIST_ENTRY_SCAN_INIT:    /********************************************************/\n39980000                              /*INITIALIZE THE SCAN_CUBE IN SMPLIST FOR SCANNING THE  */\n39990000                              /*ENTRY.                                                */\n40000000                              /********************************************************/\n40010000  PROC;                       /*IFILE IS SET PRIOR TO ENTRY.                          */\n40020000                              /*SMPLIST_ENTRY_SCAN_INIT IS CALLED ONLY IF             */\n40030000                              /*SMPLIST(IFILE).SCAN_CUBE.ACTIVE IS SET ON.            */\n40040000                              /*I.E., THERE IS AT LEAST ONE ACTIVE SCAN PLANE.        */\n40050000                   SMPLIST(IFILE).SCAN_CUBE.RESULT = '0'B;\n40060000     DO            IPLANE  = IPLANE_MIN TO IPLANE_MAX;\n40070000       IF          SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE /*IF PLANE ACTIVE*/\n40080000         THEN\n40090000           DO;\n40100000                   SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT = '1'B;\n40110000             DO    IROW  = IROW_MIN   TO IROW_MAX;\n40120000               IF  SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE\n40130000                 THEN\n40140000                   SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).RESULT = '0'B;\n40150000             END;                  /*END OF IROW          DO GROUP*/\n40160000           END;                    /*END OF ACTIVE IPLANE DO GROUP*/\n40170000     END;                          /*END OF IPLANE        DO GROUP*/\n40180000  END SMPLIST_ENTRY_SCAN_INIT;\n40190000 %SKIP(2);\n40200000  SMPLIST_ENTRY_LINE_SCAN:    /********************************************************/\n40210000                              /*SCAN THE CURRENT LINE AND SET ROW RESULTS.            */\n40220000                              /*PLANE AND CUBE SCAN RESULTS ARE CALCULATED LATER ON,  */\n40230000                              /*IN SMPLIST_ENTRY_SCAN_RESULT, AFTER ALL LINES         */\n40240000                              /*FOR AN ENTRY HAVE BEEN SCANNED.                       */\n40250000                              /********************************************************/\n40260000  PROC;                       /*IFILE IS SET PRIOR TO ENTRY.                          */\n40270000                              /*SMPLIST_ENTRY_LINE_SCAN IS CALLED ONLY IF             */\n40280000                              /*SMPLIST(IFILE).SCAN_CUBE.ACTIVE IS SET ON.            */\n40290000                              /*I.E., THERE IS AT LEAST ONE ACTIVE SCAN PLANE.        */\n40300000\n40310000     DO         IPLANE  = IPLANE_MIN TO IPLANE_MAX;\n40320000       IF       SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE /*IF PLANE IS ACTIVE*/\n40330000         THEN\n40340000           DO     IROW  = IROW_MIN   TO IROW_MAX;\n40350000             IF                           /*IF THE ROW IS ACTIVE AND STILL NO LINE HIT*/\n40360000                 (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE)\n40370000              & \u00ac(SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).RESULT)\n40380000\n40390000               THEN\n40400000                 SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).RESULT\n40410000                   =  SMPLIST_SCAN_LINE_DATA(SMPLIST(IFILE).CURR_NTRY.NTRYINDX,\n40420000                                             SMPLIST(IFILE).CURR_LINE.LINETYPE,\n40430000                                             SMPLIST(IFILE).CURR_LINE.IN.DATA);\n40440000\n40450000           END;                  /*END OF IROW   DO GROUP*/\n40460000     END;                       /*END OF IPLANE DO GROUP*/\n40470000\n40480000  END SMPLIST_ENTRY_LINE_SCAN;\n40490000 %PAGE;\n40500000  SMPLIST_ENTRY_LINE_EVAL:\n40510000  /***********************************************************/\n40520000  /*THIS PROCEDURE IS INTERNAL TO \"SMPLIST_ENTRY_FILE_READ\". */\n40530000  /*IT CALCULATES ANY CURR_NTRY VALUES THAT ARE BASED ON     */\n40540000  /*THE CURRENT LINE.                                        */\n40550000  /***********************************************************/\n40560000  PROC;     /*IFILE IS SET PRIOR TO CALLING SMPLIST_ENTRY_LINE_EVAL*/\n40570000\n40580000     NTRYINDX_IX  =  SMPLIST(IFILE).CURR_NTRY.NTRYINDX;\n40590000\n40600000     SMPLIST(IFILE).CURR_NTRY.LINE_CT = SMPLIST(IFILE).CURR_NTRY.LINE_CT + 1;\n40610000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LINE_CT     =\n40620000                    SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LINE_CT     + 1;\n40630000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LINE_CT  =\n40640000                    SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LINE_CT  + 1;\n40650000\n40660000     IF     (SMPLIST(IFILE).CURR_NTRY.LINE_CT = 0001)        /*FIRST LINE OF A NEW ENTRY*/\n40670000       THEN\n40680000         DO;\n40690000           SMPLIST(IFILE).CURR_NTRY.PAGE_NO =  SMPLIST(IFILE).CURR_PAGE.PAGE_NO;\n40700000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).ENTRY_CT    =\n40710000                                 SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).ENTRY_CT    + 1;\n40720000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).ENTRY_CT =\n40730000                                 SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).ENTRY_CT + 1;\n40740000\n40750000           IF    (SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).ENTRY_CT         = 0001)\n40760000             THEN SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LIST_PAGELO      =\n40770000                                 SMPLIST(IFILE).CURR_NTRY.PAGE_NO;\n40780000           IF    (SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).ENTRY_CT      = 0001)\n40790000             THEN SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LIST_PAGELO   =\n40800000                                 SMPLIST(IFILE).CURR_NTRY.PAGE_NO;\n40810000         END;\n40820000\n40830000     SMPLIST(IFILE).CURR_NTRY.PAGE_HI =  SMPLIST(IFILE).CURR_PAGE.PAGE_NO;\n40840000\n40850000     IF   (SMPLIST(IFILE).CURR_LINE.LINETYPE  = 'FMID')\n40860000       THEN\n40870000           SMPLIST(IFILE).CURR_NTRY.FMID      =\n40880000                              SUBSTR(SMPLIST(IFILE).CURR_LINE.DATA,LIST_LINE_SBGN,007);\n40890000     IF   (SMPLIST(IFILE).CURR_LINE.LINETYPE  = 'SOURCEID')\n40900000       THEN\n40910000           SMPLIST(IFILE).CURR_NTRY.SOURCEID  =\n40920000                              SUBSTR(SMPLIST(IFILE).CURR_LINE.DATA,LIST_LINE_SBGN,008);\n40930000     IF   (SMPLIST(IFILE).CURR_LINE.LINETYPE  = 'SYSTEM LIBRARY')\n40940000       THEN\n40950000         DO;\n40960000           SMPLIST(IFILE).CURR_NTRY.SYSLIB1   =\n40970000                              SUBSTR(SMPLIST(IFILE).CURR_LINE.DATA,LIST_LINE_SBGN,008);\n40980000           SMPLIST(IFILE).CURR_NTRY.SYSLIB2   =\n40990000                              SUBSTR(SMPLIST(IFILE).CURR_LINE.DATA,LIST_LINE_SBGN+010,008);\n41000000         END;\n41010000  END SMPLIST_ENTRY_LINE_EVAL;\n41020000 %PAGE;\n41030000  SMPLIST_ENTRY_LINE_SAVE:\n41040000  /***********************************************************/\n41050000  /*THIS PROCEDURE IS INTERNAL TO \"SMPLIST_ENTRY_READ\".      */\n41060000  /*IT SAVES THE CURRENT LINE OF THE CURRENT ENTRY FROM      */\n41070000  /*THE CURRENT SMPLIST DATA SET.  IF THE CAPACITY OF THE    */\n41080000  /*IN-STORAGE SAVE AREA HAS BEEN EXCEEDED, THE SPILL FILE   */\n41090000  /*(SMPUT?) IS OPENED, AND THE LINE IS WRITTEN TO THE       */\n41100000  /*SPILL FILE.                                              */\n41110000  /*                                                         */\n41120000  /***********************************************************/\n41130000  PROC;     /*IFILE IS SET PRIOR TO CALLING SMPLIST_ENTRY_LINE_SAVE*/\n41140000\n41150000     IF     (SMPLIST(IFILE).CURR_NTRY.LINE_CT  =  0001)\n41160000       THEN\n41170000         DO;\n41180000             SMPUT(IFILE).WRITE.SAVE_CT = SMPUT(IFILE).WRITE.SAVE_CT + 1;\n41190000         END;\n41200000\n41210000     IF     (SMPLIST(IFILE).CURR_NTRY.LINE_CT  =  LINE_SAVE_LIMIT+1)\n41220000       THEN\n41230000         DO;\n41240000             SMPUT(IFILE).WRITE.OPEN_CT = SMPUT(IFILE).WRITE.OPEN_CT + 1;\n41250000             OPEN  FILE(SMPUT(IFILE).FILEREF) OUTPUT TITLE(SMPUT(IFILE).DDNAME);\n41260000         END;\n41270000\n41280000     IF      SMPLIST(IFILE).CURR_NTRY.LINE_CT <=   LINE_SAVE_LIMIT\n41290000\n41300000       THEN  SMPUT(IFILE).LINE_SAVE(SMPLIST(IFILE).CURR_NTRY.LINE_CT)\n41310000               =  SMPLIST(IFILE).CURR_LINE.IN.DATA;\n41320000       ELSE\n41330000         DO;\n41340000             SMPUT(IFILE).WRITE.LINE_CT = SMPUT(IFILE).WRITE.LINE_CT + 1;\n41350000             WRITE FILE(SMPUT(IFILE).FILEREF)  FROM(SMPLIST(IFILE).CURR_LINE.IN.DATA);\n41360000         END;\n41370000\n41380000  END SMPLIST_ENTRY_LINE_SAVE;\n41390000 %PAGE;\n41400000  SMPLIST_ENTRY_FILE_READ_WRAPUP:\n41410000  /***********************************************************/\n41420000  /*THIS PROCEDURE IS INTERNAL TO \"SMPLIST_ENTRY_FILE_READ\". */\n41430000  /*IT CALCULATES ANY FINAL CURR_NTRY VALUES FOR THE CURRENT */\n41440000  /*ENTRY JUST ENDED.                                        */\n41450000  /***********************************************************/\n41460000  PROC;     /*IFILE IS SET PRIOR TO CALLING SMPLIST_ENTRY_FILE_READ_WRAPUP*/\n41470000\n41480000     NTRYINDX_IX  =  SMPLIST(IFILE).CURR_NTRY.NTRYINDX;\n41490000\n41500000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LIST_PAGEHI,\n41510000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LIST_PAGEHI\n41520000                                               = SMPLIST(IFILE).CURR_NTRY.PAGE_HI;\n41530000\n41540000     IF   (SMPLIST(IFILE).CURR_NTRY.LINE_CT    >\n41550000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXLINE)\n41560000       THEN\n41570000         DO;\n41580000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXLINE\n41590000                                               = SMPLIST(IFILE).CURR_NTRY.LINE_CT;\n41600000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXNAME\n41610000                                               = SMPLIST(IFILE).CURR_NTRY.NTRYNAME;\n41620000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXPAGE\n41630000                                               = SMPLIST(IFILE).CURR_NTRY.PAGE_NO;\n41640000         END;\n41650000\n41660000     IF   (SMPLIST(IFILE).CURR_NTRY.LINE_CT    >\n41670000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXLINE)\n41680000       THEN\n41690000         DO;\n41700000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXLINE\n41710000                                               = SMPLIST(IFILE).CURR_NTRY.LINE_CT;\n41720000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXNAME\n41730000                                               = SMPLIST(IFILE).CURR_NTRY.NTRYNAME;\n41740000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXPAGE\n41750000                                               = SMPLIST(IFILE).CURR_NTRY.PAGE_NO;\n41760000         END;\n41770000  END SMPLIST_ENTRY_FILE_READ_WRAPUP;\n41780000 %PAGE;\n41790000  SMPLIST_ENTRY_SCAN_RESULT:    /**************************************************/\n41800000                                /*CALCULATE THE FINAL SCAN RESULT FOR THE ENTRY   */\n41810000                                /**************************************************/\n41820000\n41830000  PROC   RETURNS(BIT(01));     /*IFILE IS SET PRIOR TO CALLING SMPLIST_ENTRY_SCAN_RESULT,*/\n41840000                               /*AND SMPLIST(IFILE).SCAN_CUBE.ACTIVE IS SET ON.   */\n41850000\n41860000              SMPLIST(IFILE).SCAN_CUBE.RESULT = '0'B;           /*PRESET TO '0'B*/\n41870000     DO      IPLANE = IPLANE_MIN TO IPLANE_MAX;\n41880000       IF   (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE)\n41890000         THEN\n41900000            DO;                /*ANY ACTIVE PLANE FOR THE FILE CAN MATCH*/\n41910000                               /*ALL ACTIVE ROWS IN A PLANE   MUST MATCH*/\n41920000\n41930000              SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT = '1'B;\n41940000              DO     IROW  = IROW_MIN   TO IROW_MAX\n41950000                WHILE(SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT);\n41960000\n41970000                IF   (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE)\n41980000                  THEN\n41990000                      SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT   /*ALL ACTIVE ROWS*/\n42000000                       =  SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT\n42010000                       & (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).SELECT =\n42020000                          SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).RESULT);\n42030000\n42040000              END;             /*END OF IROW DO GROUP*/\n42050000\n42060000              SMPLIST(IFILE).SCAN_CUBE.RESULT                       /*ANY ACTIVE PLANES*/\n42070000               =  SMPLIST(IFILE).SCAN_CUBE.RESULT\n42080000               | (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).SELECT =\n42090000                  SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT);\n42100000\n42110000            END;               /*END OF ACTIVE IPLANE DO GROUP*/\n42120000     END;                      /*END OF IPLANE DO GROUP*/\n42130000\n42140000     RETURN((SMPLIST(IFILE).SCAN_CUBE.SELECT = SMPLIST(IFILE).SCAN_CUBE.RESULT));\n42150000\n42160000  END SMPLIST_ENTRY_SCAN_RESULT;\n42170000 %SKIP(2);\n42180000  END SMPLIST_ENTRY_FILE_READ;\n42190000 %PAGE;\n42200000  SMPLIST_ENTRY_COMPARE:         /********************************************************/\n42210000                                 /*COMPARE THE ENTRY KEYS FOR ALL ACTIVE SMPLIST FILES,  */\n42220000                                 /*AND IDENTIFY THOSE THAT ARE LOWEST IN COLLATING SEQ:  */\n42230000                                 /********************************************************/\n42240000  PROC;\n42250000\n42260000      SMPLIST_CNTL.E_CMPR  =  SMPLIST_CNTL.HIGH_CMPR,    BY NAME;          /*RESET VALUES*/\n42270000\n42280000      DO    IFILE = IFILE_MIN TO IFILE_MAX; /*THE FIRST PASS FINDS THE LOWEST COMPARE KEY*/\n42290000        IF   (SMPLIST(IFILE).ACTIVE)                          /*PROCESS ONLY ACTIVE FILES*/\n42300000           & (SMPLIST(IFILE).CURR_NTRY.CMPRKEY < SMPLIST_CNTL.E_CMPR.CMPRKEY)\n42310000          THEN\n42320000            DO;\n42330000              SMPLIST_CNTL.E_CMPR         =  SMPLIST(IFILE).CURR_NTRY,  BY NAME;\n42340000              SMPLIST_CNTL.E_CMPR.RESULT  = '1'B;\n42350000            END;\n42360000      END;\n42370000\n42380000      IF     (SMPLIST_CNTL.E_CMPR.RESULT)             /*IF ALL FILES WERE NOT AT E-O-F,  */\n42390000        THEN                                          /*THE SECOND PASS IDENTIFIES       */\n42400000          DO    IFILE = IFILE_MIN TO IFILE_MAX;       /*ENTRIES MATCHING THE COMPARE KEY.*/\n42410000            IF   (SMPLIST(IFILE).ACTIVE)\n42420000               & (SMPLIST(IFILE).CURR_NTRY.CMPRKEY     =  SMPLIST_CNTL.E_CMPR.CMPRKEY)\n42430000              THEN\n42440000                  SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT = '1'B;   /*SET FOR MATCHING KEYS */\n42450000          END;\n42460000\n42470000  END SMPLIST_ENTRY_COMPARE;\n42480000 %PAGE;\n42490000  SMPLIST_ENTRY_MATCH:           /********************************************************/\n42500000                                 /*                                                      */\n42510000  PROC;                          /********************************************************/\n42520000     SMPLIST_CNTL.A_MATCH.RESULT  = '0'B;\n42530000     DO      IFILE = IFILE_MIN TO IFILE_MAX;\n42540000       SMPLIST(IFILE).CURR_NTRY.WRITE_OUT  =  '0'B;\n42550000     END;\n42560000\n42570000     IF    (SMPLIST_CNTL.E_CMPR.RESULT)            /*IF ANY FILES HAVE ENTRIES TO PROCESS*/\n42580000       THEN CALL SMPLIST_ENTRY_NTRY_MATCH;         /*MATCH THEM UP AND DETERMINE RESULTS */\n42590000\n42600000     IF    (SMPLIST_CNTL.A_MATCH.RESULT)\n42610000       THEN                 /*IF THE MATCH_RESULT IS POSITIVE, UPDATE MATCH_CT TOTALS*/\n42620000         DO IFILE = IFILE_MIN TO IFILE_MAX;\n42630000            IF  (SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT)\n42640000              THEN\n42650000                DO;\n42660000                  NTRYINDX_IX  =  SMPLIST(IFILE).CURR_NTRY.NTRYINDX;\n42670000                  SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MATCH_CT    =\n42680000                  SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MATCH_CT    + 1;\n42690000                  SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MATCH_CT =\n42700000                  SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MATCH_CT + 1;\n42710000                END;             /*END OF CMPR_RESULT IFILE DO GROUP*/\n42720000         END;                    /*END OF IFILE DO GROUP*/\n42730000     RETURN;                     /*TO THE CALLER OF SMPLIST_ENTRY_MATCH*/\n42740000 %PAGE;\n42750000  SMPLIST_ENTRY_NTRY_MATCH:      /********************************************************/\n42760000                                 /*                                                      */\n42770000                                 /********************************************************/\n42780000  PROC;\n42790000\n42800000     IF    (SMPLIST_CNTL.A_MATCH.ACTIVE)        /*TEST FOR ENTRY MATCH TESTS PROVIDED*/\n42810000       THEN                             /*IF ANY ENTRY MATCH TESTS HAVE BEEN PROVIDED*/\n42820000         DO IMATCH = IMATCH_MIN TO IMATCH_MAX;  /*APPLY ALL ACTIVE ONES FOR THIS TYPE*/\n42830000\n42840000           IF      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE)                 /*ACTIVE*/\n42850000\n42860000              &  (((SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).NTRYINDX  =\n42870000                                                  SMPLIST_CNTL.E_CMPR.NTRYINDX)\n42880000                 & (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).NTRYINDX >= NTRYINDX_MIN)\n42890000                 & (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).NTRYINDX <= NTRYINDX_MAX))\n42900000\n42910000                |  (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).NTRYINDX >  NTRYINDX_MAX)) /*ALL*/\n42920000\n42930000             THEN          /*SMPLIST_ENTRY_FILE_MATCH SETS SMPLIST(*).CURR_NTRY.WRITE_OUT*/\n42940000\n42950000                SMPLIST_CNTL.A_MATCH.RESULT  =    SMPLIST_CNTL.A_MATCH.RESULT\n42960000                                               |  SMPLIST_ENTRY_FILE_MATCH;\n42970000\n42980000         END;                    /*END OF IMATCH DO GROUP*/\n42990000\n43000000       ELSE                          /*IF NO MATCHING ENTRY TESTS HAVE BEEN PROVIDED,*/\n43010000         DO IFILE = IFILE_MIN TO IFILE_MAX;       /*SUCCESSFUL SCAN/CMPRS ARE MATCHES*/\n43020000            IF     (SMPLIST(IFILE).ACTIVE)\n43030000              THEN\n43040000                DO;\n43050000                    SMPLIST(IFILE).CURR_NTRY.WRITE_OUT\n43060000                                                  =  (SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT\n43070000                                                    & SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT);\n43080000                    SMPLIST_CNTL.A_MATCH.RESULT   =   SMPLIST_CNTL.A_MATCH.RESULT\n43090000                                                  |  (SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT\n43100000                                                    & SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT);\n43110000                END;\n43120000         END;                    /*END OF  NO-MATCHING-ENTRY-TESTS IFILE DO GROUP*/\n43130000\n43140000     RETURN;                     /*TO THE CALLER OF SMPLIST_ENTRY_NTRY_MATCH*/\n43150000 %PAGE;\n43160000  SMPLIST_ENTRY_FILE_MATCH:      /********************************************************/\n43170000                                 /*                                                      */\n43180000                                 /********************************************************/\n43190000  PROC RETURNS(BIT(1));          /*IMATCH IS SET ON ENTRY TO SMPLIST_ENTRY_FILE_MATCH    */\n43200000     DCL (FILE_MATCH_RESULT,C_TST_CNTL)          BIT(01);\n43210000\n43220000     FILE_MATCH_RESULT,C_TST_CNTL  =  SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).C_TST;\n43230000\n43240000     DO         IFILE = IFILE_MIN TO IFILE_MAX   WHILE(FILE_MATCH_RESULT = C_TST_CNTL);\n43250000        IF     (SMPLIST(IFILE).ACTIVE)\n43260000          THEN  FILE_MATCH_RESULT  =\n43270000\n43280000                  (((SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR\n43290000                                             &  SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT)\n43300000                  | (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR))\n43310000\n43320000                &  ((SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_SEL\n43330000                                             &  SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT)\n43340000                  | (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOSEL\n43350000                                             & \u00acSMPLIST(IFILE).CURR_NTRY.SCAN_RESULT)\n43360000                  | (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGSEL)))\n43370000\n43380000                |   (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOCMPR\n43390000                                             & \u00acSMPLIST(IFILE).CURR_NTRY.CMPR_RESULT);\n43400000\n43410000     END;        /*END OF IFILE DO GROUP*/\n43420000\n43430000     IF       (FILE_MATCH_RESULT)                    /*IF THE FILE MATCH CRITERIA       */\n43440000       THEN                                       /*WERE SATISFIED FOR THIS MATCH ENTRY,*/\n43450000         DO         IFILE = IFILE_MIN TO IFILE_MAX;  /*SET REQUIRED WRITE_OUT INDICATORS*/\n43460000           IF      (SMPLIST(IFILE).ACTIVE)\n43470000                 & (SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT)\n43480000             THEN\n43490000                SMPLIST(IFILE).CURR_NTRY.WRITE_OUT  =\n43500000                    (SMPLIST(IFILE).CURR_NTRY.WRITE_OUT)\n43510000                |\n43520000                   ((SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT)\n43530000                  & (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT)\n43540000                  &((SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_SEL\n43550000                                             &  SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT)\n43560000                  | (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_NOSEL\n43570000                                             & \u00acSMPLIST(IFILE).CURR_NTRY.SCAN_RESULT)\n43580000                  | (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_IGSEL)));\n43590000\n43600000         END;    /*END OF IFILE DO GROUP*/\n43610000\n43620000     RETURN(FILE_MATCH_RESULT);\n43630000  END SMPLIST_ENTRY_FILE_MATCH;\n43640000 %SKIP(1);\n43650000  END SMPLIST_ENTRY_NTRY_MATCH;\n43660000 %SKIP(1);\n43670000  END SMPLIST_ENTRY_MATCH;\n43680000 %SKIP(1);\n43690000  END SMPLIST_ENTRY_READ;\n43700000 %PAGE;\n43710000  SMPLIST_ENTRY_WRITE:          /********************************************************/\n43720000                                /*                                                      */\n43730000                                /*                                                      */\n43740000  PROC;                         /********************************************************/\n43750000     DCL   ENTRY_NTRYINDX_ADDR   POINTER,\n43760000           ENTRY_NTRYINDX        FIXED BIN(15,0) BASED(ENTRY_NTRYINDX_ADDR),\n43770000           ENTRY_LINE_LINETYPE   CHAR(015),\n43780000           ENTRY_LINE_DATA_ADDR  POINTER,\n43790000           ENTRY_LINE_DATA       CHAR(120) BASED(ENTRY_LINE_DATA_ADDR),\n43800000           ENTRY_LINE_SELECT     BIT(01),\n43810000        01 ENTRY_LINE_UNDR,              /*UNDERLINE LINE FOR LISTING LINE BEING WRITTEN*/\n43820000           05 PRTCTL             CHAR(001),                  /*SET TO \"+\" IF UNDERSCORES*/\n43830000           05 DATA,\n43840000              09 U_SCORE         CHAR(LIST_LINE_SIZE),       /*UNDERSCORES*/\n43850000              09 FILL01          CHAR(001),                  /*BLANKS*/\n43860000              09 A_FLAG          CHAR(011);                  /*ASTERISKS*/\n43870000    %PAGE;\n43880000     DO    IFILE = IFILE_MIN TO IFILE_MAX;\n43890000       IF  SMPLIST(IFILE).CURR_NTRY.WRITE_OUT    /*PROCESS ONLY THOSE FILES THAT */\n43900000                                                   /*HAVE DATA TO BE WRITTEN OUT.*/\n43910000         THEN                                    /*IF THE FILE IS TO BE PROCESSED*/\n43920000           DO;                                  /*WRITE THE CURRENT ENTRY LISTING*/\n43930000             ENTRY_LINE_SELECT      = '0'B;    /*ASSUME NO LINES WILL BE SELECTED*/\n43940000             STRING(ENTRY_LINE_UNDR) = ' ';    /*ASSUME UNDERLINES AREN'T PRESENT*/\n43950000             ENTRY_NTRYINDX_ADDR    = ADDR(SMPLIST(IFILE).CURR_NTRY.NTRYINDX);\n43960000             ENTRY_LINE_LINETYPE    = ' ';     /*INITIALIZE LINETYPE FOR ENTRY START*/\n43970000             SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).WRITE_CT =\n43980000             SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).WRITE_CT + 1;\n43990000             SMPLIST(IFILE).ENTRY_TOTALS(ENTRY_NTRYINDX).WRITE_CT =\n44000000             SMPLIST(IFILE).ENTRY_TOTALS(ENTRY_NTRYINDX).WRITE_CT + 1;\n44010000\n44020000             IF      SMPLIST(IFILE).CURR_NTRY.LINE_CT >  LINE_SAVE_LIMIT\n44030000               THEN                 /*IF THE SPILL FILE WILL BE NEEDED, OPEN IT FOR INPUT*/\n44040000                 DO;\n44050000                     SMPUT(IFILE).READ.OPEN_CT = SMPUT(IFILE).READ.OPEN_CT + 1;\n44060000                     OPEN  FILE(SMPUT(IFILE).FILEREF) INPUT TITLE(SMPUT(IFILE).DDNAME);\n44070000                 END;\n44080000\n44090000             DO        ILINE  =  001  TO   SMPLIST(IFILE).CURR_NTRY.LINE_CT;\n44100000\n44110000                IF     ILINE <=  LINE_SAVE_LIMIT    /*GET ADDRESS OF THE NEXT ENTRY LINE*/\n44120000                  THEN     ENTRY_LINE_DATA_ADDR = ADDR(SMPUT(IFILE).LINE_SAVE(ILINE));\n44130000                  ELSE DO;\n44140000                           SMPUT(IFILE).READ.LINE_CT = SMPUT(IFILE).READ.LINE_CT + 1;\n44150000                           READ FILE(SMPUT(IFILE).FILEREF) SET(ENTRY_LINE_DATA_ADDR);\n44160000                       END;\n44170000                ENTRY_LINE_LINETYPE = LINE_TYPE(ENTRY_LINE_LINETYPE,ENTRY_LINE_DATA);\n44180000\n44190000                IF SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT    /*IF THIS FILE'S ENTRIES ARE */\n44200000                                                            /*BEING SCANNED, AND THE SCAN*/\n44210000                                                            /*WAS SUCCESSFUL,            */\n44220000                                                            /*ASSEMBLE THE UNDERLINE LINE*/\n44230000                                           THEN CALL  SMPLIST_ENTRY_LINE_UNDRLINE;\n44240000                IF SMPSCAN(IFILE).ACTIVE   THEN CALL  SMPSCAN_ENTRY_LINE_WRITE;\n44250000                IF SMPSOUT(IFILE).ACTIVE   THEN CALL  SMPSOUT_ENTRY_LINE_WRITE;\n44260000                IF SMPDATA(IFILE).ACTIVE   THEN CALL  SMPDATA_ENTRY_LINE_WRITE;\n44270000             END;              /*END OF ILINE DO GROUP*/\n44280000\n44290000             IF        SMPLIST(IFILE).CURR_NTRY.LINE_CT >  LINE_SAVE_LIMIT\n44300000               THEN                   /*IF THE SPILL FILE WAS OPENED FOR INPUT, CLOSE IT*/\n44310000                       CLOSE FILE(SMPUT(IFILE).FILEREF) ENV(REREAD);\n44320000\n44330000           END;                /*END OF WRITE_OUT IFILE DO GROUP*/\n44340000     END;                      /*END OF IFILE DO GROUP*/\n44350000\n44360000     RETURN;                   /*TO THE CALLER OF SMPLIST_ENTRY_WRITE*/\n44370000 %PAGE;\n44380000  SMPLIST_ENTRY_LINE_UNDRLINE:   /********************************************************/\n44390000                                 /*                                                      */\n44400000                                 /*                                                      */\n44410000                                 /********************************************************/\n44420000  PROC;                          /*IFILE, ILINE, & ENTRY_LINE_DATA_ADDR ARE SET ON ENTRY */\n44430000\n44440000     DCL 01 SCAN_ARRAY_ELEMENT      BASED(SCAN_ARRAY_ELEMENT_ADDR)\n44450000                                     LIKE SCAN_ARRAY.PLANE.ROW.COL,\n44460000            STRING                  BUILTIN;\n44470000\n44480000     ENTRY_LINE_SELECT       = '0'B;                          /*RESET LINE SELECT CONTROL*/\n44490000     STRING(ENTRY_LINE_UNDR) = ' ';                                /*CLEAR UNDERLINE LINE*/\n44500000\n44510000     DO          IPLANE  = IPLANE_MIN TO IPLANE_MAX  WHILE(ENTRY_LINE_UNDR.PRTCTL \u00ac= '+');\n44520000       IF       (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE)/*IF PLANE ACTIVE, AND*/\n44530000            &   (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).SELECT /*PLANE RESULTS SUCCESSFUL*/\n44540000               = SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT)\n44550000         THEN\n44560000           DO     IROW  = IROW_MIN   TO IROW_MAX     WHILE(ENTRY_LINE_UNDR.PRTCTL \u00ac= '+');\n44570000            IF  SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE    /*IF ROW ACTIVE*/\n44580000             &  SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).RESULT    /*WITH RESULTS*/\n44590000             &  SMPLIST_SCAN_LINE_DATA(ENTRY_NTRYINDX,                   /*FROM THIS LINE*/\n44600000                                        ENTRY_LINE_LINETYPE,ENTRY_LINE_DATA)\n44610000               THEN\n44620000                 DO;\n44630000                   ENTRY_LINE_SELECT           = '1'B;     /*LINE IS SELECTED BY THIS ROW*/\n44640000                   ENTRY_LINE_UNDR.PRTCTL      = '+';               /*LINE IS HIGHLIGHTED*/\n44650000                   DO    ICOL  = ICOL_MIN   TO ICOL_MAX;             /*UNDERSCORE STRINGS*/\n44660000                     SCAN_ARRAY_ELEMENT_ADDR\n44670000                         = ADDR(SCAN_ARRAY(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL));\n44680000                     IF (SCAN_ARRAY_ELEMENT.STR_LEN > 0)                   /*IF STR SUPPL*/\n44690000                       THEN\n44700000                         CALL UNDERLINE_STRING_OP;\n44710000                   END;        /*END OF ICOL   DO GROUP*/\n44720000                   PUT STRING(ENTRY_LINE_UNDR.DATA.A_FLAG)\n44730000                         EDIT('**',IPLANE,',',IROW,'**')           (A,P'999',A,P'999',A);\n44740000                 END;          /*END OF ACTIVE/SELECTED IROW DO GROUP*/\n44750000           END;                /*END OF IROW   DO GROUP*/\n44760000     END;                      /*END OF IPLANE DO GROUP*/\n44770000\n44780000     RETURN;                   /*TO THE CALLER OF SMPLIST_ENTRY_LINE_UNDRLINE*/\n44790000    %PAGE;\n44800000     UNDERLINE_STRING_OP:\n44810000     PROC;  /*UNDERLINE THE MATCHING STRINGS BASED ON                           */\n44820000            /*THE TYPE OF SCAN OPERATION:                                       */\n44830000        SELECT(SCAN_ARRAY_ELEMENT.OP_OIX);\n44840000          WHEN(12,13);  /* EQENTRY | NEENTRY */          /*NO UNDERLINES*/\n44850000\n44860000          WHEN(22)      /* EQLINE  */       CALL UNDERLINE_STRING_OKLINE;\n44870000          WHEN(23)      /* NELINE  */       CALL UNDERLINE_STRING_OKLINE;\n44880000\n44890000          WHEN(32)      /* EQGLINE */       CALL UNDERLINE_STRING_OKGLIN;\n44900000          WHEN(33)      /* NEGLINE */       CALL UNDERLINE_STRING_OKGLIN;\n44910000\n44920000          WHEN(42)      /* EQSCAN  */       CALL UNDERLINE_STRING_EQSCAN;\n44930000          WHEN(43)      /* NESCAN  */       CALL UNDERLINE_STRING_NESCAN;\n44940000\n44950000          WHEN(52)      /* EQGSCAN */       CALL UNDERLINE_STRING_EQGSCN;\n44960000          WHEN(53)      /* NEGSCAN */       CALL UNDERLINE_STRING_NEGSCN;\n44970000\n44980000          WHEN(60)      /* LTCMPR  */       CALL UNDERLINE_STRING_OKCMPR;\n44990000          WHEN(61)      /* LECMPR  */       CALL UNDERLINE_STRING_OKCMPR;\n45000000          WHEN(62)      /* EQCMPR  */       CALL UNDERLINE_STRING_OKCMPR;\n45010000          WHEN(63)      /* NECMPR  */       CALL UNDERLINE_STRING_OKCMPR;\n45020000          WHEN(64)      /* GECMPR  */       CALL UNDERLINE_STRING_OKCMPR;\n45030000          WHEN(65)      /* GTCMPR  */       CALL UNDERLINE_STRING_OKCMPR;\n45040000\n45050000          WHEN(72)      /* EQGCMPR */       CALL UNDERLINE_STRING_OKGCPR;\n45060000          WHEN(73)      /* NEGCMPR */       CALL UNDERLINE_STRING_OKGCPR;\n45070000\n45080000        END;  /*END OF SELECT GROUP ON SCAN_ARRAY_ELEMENT.OP_OIX*/\n45090000        RETURN;\n45100000    %PAGE;\n45110000     UNDERLINE_STRING_EQSCAN:\n45120000     PROC;  /*SCAN THE INPUT LINE BETWEEN THE BEGIN AND END SCAN POSITIONS      */\n45130000            /*FOR THE SEARCH STRING.  WHEREVER THE SCAN STRING APPEARS,         */\n45140000            /*INSERT UNDERSCORE CHARACTERS INTO ENTRY_LINE_UNDR.DATA.U_SCORE    */\n45150000            /*A DO LOOP IS USED TO UNDERSCORE ALL OCCURRENCES OF THE SEARCH     */\n45160000            /*STRING WITHIN THE SCAN POSITIONS, AND NOT JUST THE FIRST.         */\n45170000\n45180000        DCL  US_IX               FIXED BIN(15,0),    /*UNDERSCORE POSITION INDEX*/\n45190000             US_LN               FIXED BIN(15,0);    /*UNDERSCORE STRING  LENGTH*/\n45200000\n45210000        US_LN      =  SCAN_ARRAY_ELEMENT.STR_LEN;\n45220000\n45230000        DO   US_IX =  SCAN_ARRAY_ELEMENT.BEG_POS\n45240000               TO    (SCAN_ARRAY_ELEMENT.END_POS - US_LN + 1);\n45250000          IF   SUBSTR(ENTRY_LINE_DATA,US_IX,US_LN)\n45260000                   =  SCAN_ARRAY_ELEMENT.STRING\n45270000            THEN\n45280000              DO;   /*INSERT UNDERSCORES AND ADJUST POSITION INDEX FOR NEXT ATTEMPT*/\n45290000                SUBSTR(ENTRY_LINE_UNDR.DATA.U_SCORE,US_IX,US_LN) = REPEAT( '_',US_LN - 1);\n45300000                US_IX = US_IX + US_LN - 1;\n45310000              END;\n45320000        END;\n45330000     END UNDERLINE_STRING_EQSCAN;\n45340000    %SKIP(3);\n45350000     UNDERLINE_STRING_EQGSCN:\n45360000     PROC;  /*SCAN THE INPUT LINE BETWEEN THE BEGIN AND END SCAN POSITIONS      */\n45370000            /*FOR THE SEARCH STRING.  WHEREVER THE SCAN STRING APPEARS,         */\n45380000            /*INSERT UNDERSCORE CHARACTERS INTO ENTRY_LINE_UNDR.DATA.U_SCORE    */\n45390000            /*A DO LOOP IS USED TO UNDERSCORE ALL OCCURRENCES OF THE SEARCH     */\n45400000            /*STRING WITHIN THE SCAN POSITIONS, AND NOT JUST THE FIRST.         */\n45410000\n45420000        DCL  US_IX               FIXED BIN(15,0),    /*UNDERSCORE POSITION INDEX*/\n45430000             US_LN               FIXED BIN(15,0);    /*UNDERSCORE STRING  LENGTH*/\n45440000\n45450000        US_LN      =  SCAN_ARRAY_ELEMENT.STR_LEN;\n45460000\n45470000        DO   US_IX =  SCAN_ARRAY_ELEMENT.BEG_POS\n45480000               TO    (SCAN_ARRAY_ELEMENT.END_POS - US_LN + 1);\n45490000          IF GCOMPARE(SUBSTR(ENTRY_LINE_DATA,US_IX,US_LN),\n45500000                      SCAN_ARRAY_ELEMENT.STRING)\n45510000            THEN\n45520000              DO;   /*INSERT UNDERSCORES AND ADJUST POSITION INDEX FOR NEXT ATTEMPT*/\n45530000                SUBSTR(ENTRY_LINE_UNDR.DATA.U_SCORE,US_IX,US_LN) = REPEAT( '_',US_LN - 1);\n45540000                US_IX = US_IX + US_LN - 1;\n45550000              END;\n45560000        END;\n45570000     END UNDERLINE_STRING_EQGSCN;\n45580000    %PAGE;\n45590000     UNDERLINE_STRING_NESCAN:\n45600000     UNDERLINE_STRING_NEGSCN:\n45610000     PROC;  /*FOR A SUCCESSFULL \"\u00acEQSCAN\" OR \"\u00acEQGSCN\" THAT SCANNED POSITIONS   */\n45620000            /*IN THE LISTING LINE WITHOUT FINDING THE SEARCH STRING, UNDERSCORE */\n45630000            /*THE SEARCH AREA UNLESS IT IS THE ENTIRE LINE.                     */\n45640000\n45650000        DCL  US_IX               FIXED BIN(15,0),    /*UNDERSCORE POSITION INDEX*/\n45660000             US_LN               FIXED BIN(15,0);    /*UNDERSCORE STRING  LENGTH*/\n45670000\n45680000        US_IX      =  SCAN_ARRAY_ELEMENT.BEG_POS;\n45690000        US_LN      =  SCAN_ARRAY_ELEMENT.STR_LEN;\n45700000\n45710000        IF (US_IX > LIST_LINE_DBGN) | (US_LN < LIST_LINE_SIZE) /*IF AREA NOT ENTIRE LINE*/\n45720000          THEN SUBSTR(ENTRY_LINE_UNDR.DATA.U_SCORE,US_IX,US_LN) = REPEAT( '_',US_LN - 1);\n45730000\n45740000     END UNDERLINE_STRING_NESCAN;\n45750000    %PAGE;\n45760000     UNDERLINE_STRING_OKCMPR:\n45770000     UNDERLINE_STRING_OKGCPR:\n45780000     PROC;  /*FOR A COMPARE THAT WAS SUCCESSFUL, UNDERLINE THE STRING           */\n45790000            /*THAT COMPARED SUCCESSFULLY.  ONLY THE ONE OCCURRENCE              */\n45800000            /*IS UNDERSCORED.                                                   */\n45810000\n45820000        DCL  US_IX               FIXED BIN(15,0),    /*UNDERSCORE POSITION INDEX*/\n45830000             US_LN               FIXED BIN(15,0);    /*UNDERSCORE STRING  LENGTH*/\n45840000\n45850000        US_IX      =  SCAN_ARRAY_ELEMENT.BEG_POS;\n45860000        US_LN      =  SCAN_ARRAY_ELEMENT.STR_LEN;\n45870000\n45880000        SUBSTR(ENTRY_LINE_UNDR.DATA.U_SCORE,US_IX,US_LN) = REPEAT( '_',US_LN - 1);\n45890000\n45900000     END UNDERLINE_STRING_OKCMPR;\n45910000    %SKIP(3);\n45920000     UNDERLINE_STRING_OKLINE:\n45930000     UNDERLINE_STRING_OKGLIN:\n45940000     PROC;  /*FOR A SUCCESSFULL LINE TYPE COMPARISON, UNDERLINE THE LINE TYPE   */\n45950000            /*FIELD IN THE LISTING LINE UNLESS THE FIELD IS ALL BLANK.          */\n45960000\n45970000        DCL  US_IX               FIXED BIN(15,0),   /*UNDERSCORE POSITION INDEX*/\n45980000             US_PS               FIXED BIN(15,0),   /*UNDERSCORE POSITION LENGTH*/\n45990000             US_LN               FIXED BIN(15,0);   /*UNDERSCORE STRING   LENGTH*/\n46000000\n46010000        US_IX      =  SCAN_ARRAY_ELEMENT.BEG_POS;\n46020000        US_PS      =  SCAN_ARRAY_ELEMENT.POS_LEN;\n46030000        US_LN      =  SCAN_ARRAY_ELEMENT.STR_LEN;\n46040000\n46050000        IF     SUBSTR(ENTRY_LINE_DATA,US_IX,US_PS) \u00ac= ' ' /*IF LINETYPE FIELD NON-BLANK*/\n46060000          THEN SUBSTR(ENTRY_LINE_UNDR.DATA.U_SCORE,US_IX,US_LN) = REPEAT( '_',US_LN - 1);\n46070000\n46080000     END UNDERLINE_STRING_OKLINE;\n46090000    %SKIP(1);\n46100000     END UNDERLINE_STRING_OP;\n46110000    %SKIP(2);\n46120000  END SMPLIST_ENTRY_LINE_UNDRLINE;\n46130000 %PAGE;\n46140000  SMPSCAN_ENTRY_LINE_WRITE:      /********************************************************/\n46150000                                 /*                                                      */\n46160000                                 /*                                                      */\n46170000                                 /********************************************************/\n46180000  PROC;                          /*IFILE, ILINE, & ENTRY_LINE_DATA_ADDR ARE SET ON ENTRY */\n46190000     DCL   SAVE_PAGE_NO          FIXED BINARY(31,0);\n46200000\n46210000     IF    \u00ac(SMPSCAN(IFILE).OPEN)     THEN CALL SMPSCAN_OPEN;\n46220000     ON    ENDPAGE(SMPSCAN(IFILE).FILEREF) CALL SMPSCAN_NEWPAGE;\n46230000\n46240000     IF       ILINE <= 001\n46250000\n46260000       THEN                            /*IF THIS IS THE FIRST LINE OF A NEW ENTRY*/\n46270000         IF   (SMPSCAN(IFILE).CURR_PAGE.PAGE_NO  <  0001)\n46280000           |  (SMPSCAN(IFILE).CURR_PAGE.PAGEKEY  \u00ac= SMPLIST(IFILE).CURR_NTRY.PAGEKEY)\n46290000\n46300000           THEN           /*IF FIRST PAGE OF OUTPUT, OR FIRST ENTRY OF A NEW TYPE*/\n46310000             DO;\n46320000               SAVE_PAGE_NO                      =  SMPSCAN(IFILE).CURR_PAGE.PAGE_NO;\n46330000               SMPSCAN(IFILE).CURR_PAGE          =  SMPLIST(IFILE).CURR_NTRY  ,  BY NAME;\n46340000               SMPSCAN(IFILE).CURR_PAGE.PAGE_NO  =  SAVE_PAGE_NO;\n46350000               SIGNAL  ENDPAGE(SMPSCAN(IFILE).FILEREF);\n46360000             END;\n46370000           ELSE         /*IF NOT FIRST PAGE OF OUTPUT, AND NOT FIRST ENTRY OF A NEW TYPE*/\n46380000             IF LINENO(SMPSCAN(IFILE).FILEREF)      <  (SMPSCAN(IFILE).PAGE_SZ - 1)\n46390000               THEN\n46400000                 PUT FILE(SMPSCAN(IFILE).FILEREF)\n46410000                     EDIT(' ')                        (SKIP(1),A);\n46420000\n46430000     PUT FILE(SMPSCAN(IFILE).FILEREF)                  SKIP(1)\n46440000         EDIT(ENTRY_LINE_DATA)                        (COL(001),A);\n46450000\n46460000     IF     ENTRY_LINE_UNDR.PRTCTL = '+'           /*IF A LINE OF UNDERSCORES IS PRESENT*/\n46470000       THEN  PUT FILE(SMPSCAN(IFILE).FILEREF)          SKIP(0)\n46480000             EDIT(STRING(ENTRY_LINE_UNDR.DATA))       (COL(001),A);\n46490000\n46500000     IF       ILINE <= 001             /*IF THIS IS THE FIRST LINE OF A NEW ENTRY,*/\n46510000       THEN                            /*SAVE LOCATOR INFORMATION FOR SMPDCTRY.   */\n46520000               SMPSCAN(IFILE).CURR_NTRY          =  SMPSCAN(IFILE).CURR_PAGE  ,  BY NAME;\n46530000\n46540000     RETURN;                           /*TO THE CALLER OF SMPSCAN_ENTRY_LINE_WRITE*/\n46550000     %PAGE;\n46560000     SMPSCAN_OPEN:       /***********************************************************/\n46570000                         /*THIS SUBROUTINE IS INTERNAL TO SMPSCAN_ENTRY_LINE_WRITE. */\n46580000                         /*IT OPENS THE SMPSCAN DATA SET FOR THIS IFILE.            */\n46590000                         /***********************************************************/\n46600000       PROC;             /*IFILE IS SET PRIOR TO CALLING SMPSCAN_OPEN               */\n46610000\n46620000          OPEN   FILE(SMPSCAN(IFILE).FILEREF) OUTPUT\n46630000                 PAGESIZE(SMPSCAN(IFILE).PAGE_SZ) LINESIZE(SMPSCAN(IFILE).LINE_SZ)\n46640000                 TITLE(SMPSCAN(IFILE).DDNAME);\n46650000\n46660000          SMPSCAN(IFILE).OPEN    =   '1'B;          /*INDICATE FILE IS OPEN*/\n46670000\n46680000       END SMPSCAN_OPEN;\n46690000     %SKIP(3);\n46700000     SMPSCAN_NEWPAGE:\n46710000       PROC;                      /*IFILE IS SET PRIOR TO CALLING SMPSCAN_NEWPAGE*/\n46720000\n46730000          SMPSCAN_TITLE1_MAP_ADDR = ADDR(SMPSCAN(IFILE).CURR_PAGE.TITLE1_DATA);\n46740000\n46750000          IF LINENO(SMPSCAN(IFILE).FILEREF) > 1 THEN PUT FILE(SMPSCAN(IFILE).FILEREF) PAGE;\n46760000          SMPSCAN(IFILE).CURR_PAGE.PAGE_NO = SMPSCAN(IFILE).CURR_PAGE.PAGE_NO + 1;\n46770000\n46780000          SMPSCAN_TITLE1_MAP.ESMPLIST =  'SMPSCAN';\n46790000          SMPSCAN_TITLE1_MAP.PAGE_NO  =  SMPSCAN(IFILE).CURR_PAGE.PAGE_NO;\n46800000\n46810000          PUT FILE(SMPSCAN(IFILE).FILEREF)\n46820000              EDIT(SMPSCAN(IFILE).CURR_PAGE.TITLE1_DATA)  (COL(001),A)\n46830000                  (' ')                                   (SKIP(1),A)\n46840000                  (SMPSCAN(IFILE).CURR_PAGE.TITLE2_DATA)  (SKIP(1),A)\n46850000                  (' ')                                   (SKIP(1),A)\n46860000                  (' ')                                   (SKIP(1),A)\n46870000                  (SMPSCAN(IFILE).CURR_PAGE.TITLE3_DATA)  (SKIP(1),A)\n46880000                  (' ')                                   (SKIP(1),A);\n46890000\n46900000       END SMPSCAN_NEWPAGE;\n46910000      %SKIP(3);\n46920000  END SMPSCAN_ENTRY_LINE_WRITE;\n46930000 %PAGE;\n46940000  SMPSOUT_ENTRY_LINE_WRITE:      /********************************************************/\n46950000                                 /*                                                      */\n46960000                                 /*                                                      */\n46970000                                 /********************************************************/\n46980000  PROC;                          /*IFILE, ILINE, & ENTRY_LINE_DATA_ADDR ARE SET ON ENTRY */\n46990000     DCL   SAVE_PAGE_NO          FIXED BINARY(31,0);\n47000000\n47010000     IF    \u00ac(SMPSOUT(IFILE).OPEN)     THEN CALL SMPSOUT_OPEN;\n47020000     ON    ENDPAGE(SMPSOUT(IFILE).FILEREF) CALL SMPSOUT_NEWPAGE;\n47030000\n47040000     IF       ILINE <= 001\n47050000\n47060000       THEN                            /*IF THIS IS THE FIRST LINE OF A NEW ENTRY*/\n47070000         IF   (SMPSOUT(IFILE).CURR_PAGE.PAGE_NO  <  0001)\n47080000           |  (SMPSOUT(IFILE).CURR_PAGE.PAGEKEY  \u00ac= SMPLIST(IFILE).CURR_NTRY.PAGEKEY)\n47090000\n47100000           THEN           /*IF FIRST PAGE OF OUTPUT, OR FIRST ENTRY OF A NEW TYPE*/\n47110000             DO;\n47120000               SAVE_PAGE_NO                      =  SMPSOUT(IFILE).CURR_PAGE.PAGE_NO;\n47130000               SMPSOUT(IFILE).CURR_PAGE          =  SMPLIST(IFILE).CURR_NTRY  ,  BY NAME;\n47140000               SMPSOUT(IFILE).CURR_PAGE.PAGE_NO  =  SAVE_PAGE_NO;\n47150000               SIGNAL  ENDPAGE(SMPSOUT(IFILE).FILEREF);\n47160000             END;\n47170000           ELSE         /*IF NOT FIRST PAGE OF OUTPUT, AND NOT FIRST ENTRY OF A NEW TYPE*/\n47180000             IF LINENO(SMPSOUT(IFILE).FILEREF)      <  (SMPSOUT(IFILE).PAGE_SZ - 1)\n47190000               THEN\n47200000                 PUT FILE(SMPSOUT(IFILE).FILEREF)\n47210000                     EDIT(' ')                        (SKIP(1),A);\n47220000\n47230000     PUT FILE(SMPSOUT(IFILE).FILEREF)                  SKIP(1)\n47240000         EDIT(ENTRY_LINE_DATA)                        (COL(001),A);\n47250000\n47260000     IF       ILINE <= 001             /*IF THIS IS THE FIRST LINE OF A NEW ENTRY,*/\n47270000       THEN                            /*SAVE LOCATOR INFORMATION FOR SMPDCTRY.   */\n47280000               SMPSOUT(IFILE).CURR_NTRY          =  SMPSOUT(IFILE).CURR_PAGE  ,  BY NAME;\n47290000\n47300000     RETURN;                           /*TO THE CALLER OF SMPSOUT_ENTRY_LINE_WRITE*/\n47310000     %PAGE;\n47320000     SMPSOUT_OPEN:       /***********************************************************/\n47330000                         /*THIS SUBROUTINE IS INTERNAL TO SMPSOUT_ENTRY_LINE_WRITE. */\n47340000                         /*IT OPENS THE SMPSOUT DATA SET FOR THIS IFILE.            */\n47350000                         /***********************************************************/\n47360000       PROC;             /*IFILE IS SET PRIOR TO CALLING SMPSOUT_OPEN               */\n47370000\n47380000          OPEN   FILE(SMPSOUT(IFILE).FILEREF) OUTPUT\n47390000                 PAGESIZE(SMPSOUT(IFILE).PAGE_SZ) LINESIZE(SMPSOUT(IFILE).LINE_SZ)\n47400000                 TITLE(SMPSOUT(IFILE).DDNAME);\n47410000\n47420000          SMPSOUT(IFILE).OPEN    =   '1'B;          /*INDICATE FILE IS OPEN*/\n47430000\n47440000       END SMPSOUT_OPEN;\n47450000     %SKIP(3);\n47460000     SMPSOUT_NEWPAGE:\n47470000       PROC;                      /*IFILE IS SET PRIOR TO CALLING SMPSOUT_NEWPAGE*/\n47480000\n47490000          SMPSOUT_TITLE1_MAP_ADDR = ADDR(SMPSOUT(IFILE).CURR_PAGE.TITLE1_DATA);\n47500000\n47510000          IF LINENO(SMPSOUT(IFILE).FILEREF) > 1 THEN PUT FILE(SMPSOUT(IFILE).FILEREF) PAGE;\n47520000          SMPSOUT(IFILE).CURR_PAGE.PAGE_NO = SMPSOUT(IFILE).CURR_PAGE.PAGE_NO + 1;\n47530000\n47540000          SMPSOUT_TITLE1_MAP.PAGE_NO  =  SMPSOUT(IFILE).CURR_PAGE.PAGE_NO;\n47550000\n47560000          PUT FILE(SMPSOUT(IFILE).FILEREF)\n47570000              EDIT(SMPSOUT(IFILE).CURR_PAGE.TITLE1_DATA)  (COL(001),A)\n47580000                  (' ')                                   (SKIP(1),A)\n47590000                  (SMPSOUT(IFILE).CURR_PAGE.TITLE2_DATA)  (SKIP(1),A)\n47600000                  (' ')                                   (SKIP(1),A)\n47610000                  (' ')                                   (SKIP(1),A)\n47620000                  (SMPSOUT(IFILE).CURR_PAGE.TITLE3_DATA)  (SKIP(1),A)\n47630000                  (' ')                                   (SKIP(1),A);\n47640000\n47650000       END SMPSOUT_NEWPAGE;\n47660000      %SKIP(3);\n47670000  END SMPSOUT_ENTRY_LINE_WRITE;\n47680000 %PAGE;\n47690000  SMPDATA_ENTRY_LINE_WRITE:      /********************************************************/\n47700000                                 /*                                                      */\n47710000                                 /*                                                      */\n47720000                                 /********************************************************/\n47730000  PROC;                          /*IFILE, ILINE, & ENTRY_LINE_DATA_ADDR ARE SET ON ENTRY */\n47740000\n47750000     IF    \u00ac(SMPDATA(IFILE).OPEN)     THEN CALL SMPDATA_OPEN;\n47760000\n47770000     IF   (DATA_OUTPUT_OPTION(IFILE) = 'ID1'    &  ILINE = 001)   /*IF LINE TO BE WRITTEN*/\n47780000        | (DATA_OUTPUT_OPTION(IFILE) = 'ID'     &  ILINE = 001)\n47790000        | (DATA_OUTPUT_OPTION(IFILE) = 'SELECT' & (ILINE = 001 | ENTRY_LINE_SELECT))\n47800000        | (DATA_OUTPUT_OPTION(IFILE) = 'ALL')\n47810000\n47820000       THEN           /*FORMAT THE LINE BASED ON TYPE OF ENTRY, AND LINETYPE WITHIN ENTRY*/\n47830000\n47840000         SELECT(ENTRY_NTRYINDX);     /*DETERMINE FORMATTING BY TYPE OF ENTRY AND LINETYPE*/\n47850000\n47860000           WHEN(ENTRY_INDEX('ASSEM'))             /*ENTRY TYPE = ASSEMBLER*/\n47870000             SELECT(SUBSTR(ENTRY_LINE_LINETYPE,001,015));\n47880000               WHEN('ASSEMBLER INPUT')        CALL WRITE_DATA_FORMAT2_LINE;\n47890000               OTHERWISE                      CALL WRITE_DATA_FORMAT1_LINE;\n47900000             END;               /*END OF ASSEM      ENTRY_LINE_LINETYPE SELECT GROUP*/\n47910000\n47920000           WHEN(ENTRY_INDEX('LMOD'))              /*ENTRY TYPE = LOAD MODULE*/\n47930000             SELECT(SUBSTR(ENTRY_LINE_LINETYPE,001,012));\n47940000               WHEN('LKED CONTROL')           CALL WRITE_DATA_FORMAT2_LINE;\n47950000               OTHERWISE                      CALL WRITE_DATA_FORMAT1_LINE;\n47960000             END;               /*END OF LMOD       ENTRY_LINE_LINETYPE SELECT GROUP*/\n47970000\n47980000           WHEN(ENTRY_INDEX('SYSMOD'))            /*ENTRY TYPE = SYSMOD*/\n47990000             SELECT(SUBSTR(ENTRY_LINE_LINETYPE,001,004));\n48000000               WHEN('HOLD')                   CALL WRITE_DATA_FORMAT3_LINE;\n48010000               OTHERWISE                      CALL WRITE_DATA_FORMAT1_LINE;\n48020000             END;               /*END OF SYSMOD     ENTRY_LINE_LINETYPE SELECT GROUP*/\n48030000\n48040000           WHEN(ENTRY_INDEX('M.C.S.'))            /*ENTRY TYPE = M.C.S.*/\n48050000                                              CALL WRITE_DATA_FORMAT2_LINE;\n48060000\n48070000           OTHERWISE                              /*ENTRY TYPE = ALL OTHERS*/\n48080000             SELECT(SUBSTR(ENTRY_LINE_LINETYPE,001,015));\n48090000               WHEN('SYSMOD HISTORY')         CALL WRITE_DATA_FORMAT4_LINE;\n48100000               OTHERWISE                      CALL WRITE_DATA_FORMAT1_LINE;\n48110000             END;               /*END OF OTHERWISE  ENTRY_LINE_LINETYPE SELECT GROUP*/\n48120000\n48130000         END;                   /*END OF ENTRY_NTRYINDX                 SELECT GROUP*/\n48140000     RETURN;\n48150000     %PAGE;\n48160000     SMPDATA_OPEN:       /***********************************************************/\n48170000                         /*THIS SUBROUTINE IS INTERNAL TO SMPDATA_ENTRY_LINE_WRITE. */\n48180000                         /*IT OPENS THE SMPSOUT DATA SET FOR THIS IFILE.            */\n48190000                         /***********************************************************/\n48200000       PROC;             /*IFILE IS SET PRIOR TO CALLING SMPDATA_OPEN               */\n48210000\n48220000          OPEN   FILE(SMPDATA(IFILE).FILEREF) OUTPUT\n48230000                 LINESIZE(SMPDATA(IFILE).LINE_SZ)\n48240000                 TITLE(SMPDATA(IFILE).DDNAME);\n48250000\n48260000          SMPDATA(IFILE).OPEN    =   '1'B;          /*INDICATE FILE IS OPEN*/\n48270000\n48280000       END SMPDATA_OPEN;\n48290000    %PAGE;\n48300000     WRITE_DATA_FORMAT1_LINE:\n48310000     PROC;\n48320000\n48330000        DCL  LDATA          FIXED BIN(15,0),         /*DATA RECORD # FOR CURRENT LINE*/\n48340000             LPOS(001:003)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,069,109),\n48350000             LGTH(001:003)  FIXED BIN(15,0) STATIC INTERNAL INIT(068,040,012),\n48360000             LCOL(001:003)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,029,029);\n48370000\n48380000        DO   LDATA = 001 TO 003;\n48390000          IF    (SUBSTR(ENTRY_LINE_DATA,LPOS(LDATA),LGTH(LDATA))  \u00ac= ' ')\n48400000            &  ((DATA_OUTPUT_OPTION(IFILE) \u00ac= 'ID1') | (LDATA = 001))\n48410000            THEN\n48420000              DO;\n48430000                SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/\n48440000                SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(LDATA),LGTH(LDATA)) =\n48450000                                          SUBSTR(ENTRY_LINE_DATA,LPOS(LDATA),LGTH(LDATA));\n48460000\n48470000                SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,009,002)  = '/*';\n48480000                SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,069,002)  = '*/';\n48490000\n48500000                SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;\n48510000\n48520000                PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)\n48530000                    EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)\n48540000                        (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');\n48550000\n48560000                IF   ((LDATA = 001) & (ILINE = 001))\n48570000                  THEN\n48580000                         SMPDATA(IFILE).CURR_NTRY = SMPDATA(IFILE).CURR_CARD, BY NAME;\n48590000\n48600000              END;\n48610000        END;                    /*END OF LDATA DO GROUP*/\n48620000\n48630000     END WRITE_DATA_FORMAT1_LINE;\n48640000    %PAGE;\n48650000     WRITE_DATA_FORMAT2_LINE:\n48660000     PROC;\n48670000\n48680000        DCL  LPOS(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,029),\n48690000             LGTH(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(028,072),\n48700000             LCOL(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,001);\n48710000\n48720000        IF      (SUBSTR(ENTRY_LINE_DATA,LPOS(001),LGTH(001))  \u00ac= ' ')\n48730000          THEN\n48740000            DO;\n48750000              SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/\n48760000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(001),LGTH(001)) =\n48770000                                        SUBSTR(ENTRY_LINE_DATA,LPOS(001),LGTH(001));\n48780000\n48790000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,009,002)  = '/*';\n48800000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,069,002)  = '*/';\n48810000\n48820000              SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;\n48830000\n48840000              PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)\n48850000                  EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)\n48860000                      (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');\n48870000\n48880000              IF      (ILINE = 001)\n48890000                THEN   SMPDATA(IFILE).CURR_NTRY = SMPDATA(IFILE).CURR_CARD, BY NAME;\n48900000\n48910000            END;\n48920000\n48930000        IF      (SUBSTR(ENTRY_LINE_DATA,LPOS(002),LGTH(002))  \u00ac= ' ')\n48940000            &   (DATA_OUTPUT_OPTION(IFILE) \u00ac= 'ID1')\n48950000          THEN\n48960000            DO;\n48970000              SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/\n48980000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(002),LGTH(002)) =\n48990000                                        SUBSTR(ENTRY_LINE_DATA,LPOS(002),LGTH(002));\n49000000\n49010000              SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;\n49020000\n49030000              PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)\n49040000                  EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)\n49050000                      (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');\n49060000\n49070000            END;\n49080000\n49090000     END WRITE_DATA_FORMAT2_LINE;\n49100000    %PAGE;\n49110000     WRITE_DATA_FORMAT3_LINE:\n49120000     PROC;\n49130000\n49140000        DCL  LPOS(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,039),\n49150000             LGTH(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(038,072),\n49160000             LCOL(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,001);\n49170000\n49180000        IF      (SUBSTR(ENTRY_LINE_DATA,LPOS(001),LGTH(001))  \u00ac= ' ')\n49190000          THEN\n49200000            DO;\n49210000              SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/\n49220000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(001),LGTH(001)) =\n49230000                                        SUBSTR(ENTRY_LINE_DATA,LPOS(001),LGTH(001));\n49240000\n49250000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,009,002)  = '/*';\n49260000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,069,002)  = '*/';\n49270000\n49280000              SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;\n49290000\n49300000              PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)\n49310000                  EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)\n49320000                      (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');\n49330000\n49340000              IF      (ILINE = 001)\n49350000                THEN   SMPDATA(IFILE).CURR_NTRY = SMPDATA(IFILE).CURR_CARD, BY NAME;\n49360000\n49370000            END;\n49380000\n49390000        IF      (SUBSTR(ENTRY_LINE_DATA,LPOS(002),LGTH(002))  \u00ac= ' ')\n49400000            &   (DATA_OUTPUT_OPTION(IFILE) \u00ac= 'ID1')\n49410000          THEN\n49420000            DO;\n49430000              SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/\n49440000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(002),LGTH(002)) =\n49450000                                        SUBSTR(ENTRY_LINE_DATA,LPOS(002),LGTH(002));\n49460000\n49470000              SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;\n49480000\n49490000              PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)\n49500000                  EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)\n49510000                      (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');\n49520000\n49530000            END;\n49540000\n49550000     END WRITE_DATA_FORMAT3_LINE;\n49560000    %PAGE;\n49570000     WRITE_DATA_FORMAT4_LINE:\n49580000     PROC;\n49590000\n49600000        DCL  LPOS(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,029),\n49610000             LGTH(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(028,065),\n49620000             LCOL(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,004);\n49630000\n49640000        IF      (SUBSTR(ENTRY_LINE_DATA,LPOS(001),LGTH(001))  \u00ac= ' ')\n49650000          THEN\n49660000            DO;\n49670000              SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/\n49680000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(001),LGTH(001)) =\n49690000                                        SUBSTR(ENTRY_LINE_DATA,LPOS(001),LGTH(001));\n49700000\n49710000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,009,002)  = '/*';\n49720000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,069,002)  = '*/';\n49730000\n49740000              SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;\n49750000\n49760000              PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)\n49770000                  EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)\n49780000                      (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');\n49790000\n49800000              IF      (ILINE = 001)\n49810000                THEN   SMPDATA(IFILE).CURR_NTRY = SMPDATA(IFILE).CURR_CARD, BY NAME;\n49820000\n49830000            END;\n49840000\n49850000        IF      (SUBSTR(ENTRY_LINE_DATA,LPOS(002),LGTH(002))  \u00ac= ' ')\n49860000            &   (DATA_OUTPUT_OPTION(IFILE) \u00ac= 'ID1')\n49870000          THEN\n49880000            DO;\n49890000              SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/\n49900000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(002),LGTH(002)) =\n49910000                                        SUBSTR(ENTRY_LINE_DATA,LPOS(002),LGTH(002));\n49920000\n49930000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,002,002)  = '/*';\n49940000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,069,002)  = '*/';\n49950000\n49960000              SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;\n49970000\n49980000              PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)\n49990000                  EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)\n50000000                      (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');\n50010000\n50020000            END;\n50030000\n50040000     END WRITE_DATA_FORMAT4_LINE;\n50050000    %SKIP (1);\n50060000  END SMPDATA_ENTRY_LINE_WRITE;\n50070000  %SKIP(2);\n50080000  END SMPLIST_ENTRY_WRITE;\n50090000 %PAGE;\n50100000  SMPLIST_SCAN_LINE_DATA:     /********************************************************/\n50110000                              /*SCAN THE CURRENT LINE AND RETURN ROW RESULTS.         */\n50120000                              /*THIS SUBROUTINE IS CALLED FROM BOTH                   */\n50130000                              /*SMPLIST_ENTRY_LINE_SCAN IN SMPLIST_ENTRY_READ, AND    */\n50140000                              /*SMPLIST_ENTRY_LINE_UNDRLINE IN SMPLIST_ENTRY_WRITE.   */\n50150000                              /********************************************************/\n50160000  PROC(ENTRY_NTRYINDX,            /*IFILE, IPLANE, IROW ARE SET PRIOR TO ENTRY.       */\n50170000       ENTRY_LINE_LINETYPE,\n50180000       ENTRY_LINE_DATA)             RETURNS(BIT(01));\n50190000     DCL    ENTRY_NTRYINDX          FIXED BIN(15,0),\n50200000            ENTRY_LINE_LINETYPE     CHAR(*),\n50210000            ENTRY_LINE_DATA         CHAR(*),\n50220000         01 SCAN_ARRAY_ELEMENT      BASED(SCAN_ARRAY_ELEMENT_ADDR)\n50230000                                     LIKE SCAN_ARRAY.PLANE.ROW.COL,\n50240000            LINE_SCAN_RESULT        BIT(1);\n50250000    %PAGE;\n50260000     IF   SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE\n50270000       THEN\n50280000         DO;                 /*ALL ACTIVE COLUMNS IN A ROW MUST MATCH ON THE SAME LINE*/\n50290000             LINE_SCAN_RESULT = '1'B;\n50300000             DO    ICOL  = ICOL_MIN   TO ICOL_MAX   WHILE(LINE_SCAN_RESULT);\n50310000               SCAN_ARRAY_ELEMENT_ADDR\n50320000                   = ADDR(SCAN_ARRAY(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL));\n50330000               IF (SCAN_ARRAY_ELEMENT.STR_LEN > 0)                 /*IF STRING SUPPLIED*/\n50340000                 THEN\n50350000                   SELECT(SCAN_ARRAY_ELEMENT.OP_OIX);\n50360000                     WHEN(12) /* EQENTRY */   LINE_SCAN_RESULT =  RESULT_STRING_NTRY;\n50370000                     WHEN(13) /* NEENTRY */   LINE_SCAN_RESULT = \u00acRESULT_STRING_NTRY;\n50380000\n50390000                     WHEN(22) /* EQLINE  */   LINE_SCAN_RESULT =  RESULT_STRING_LINE;\n50400000                     WHEN(23) /* NELINE  */   LINE_SCAN_RESULT = \u00acRESULT_STRING_LINE;\n50410000\n50420000                     WHEN(32) /* EQGLINE */   LINE_SCAN_RESULT =  RESULT_STRING_GLIN;\n50430000                     WHEN(33) /* NEGLINE */   LINE_SCAN_RESULT = \u00acRESULT_STRING_GLIN;\n50440000\n50450000                     WHEN(42) /* EQSCAN  */   LINE_SCAN_RESULT = (RESULT_STRING_SCAN >  0);\n50460000                     WHEN(43) /* NESCAN  */   LINE_SCAN_RESULT = (RESULT_STRING_SCAN <= 0);\n50470000\n50480000                     WHEN(52) /* EQGSCAN */   LINE_SCAN_RESULT = (RESULT_STRING_GSCN >  0);\n50490000                     WHEN(53) /* NEGSCAN */   LINE_SCAN_RESULT = (RESULT_STRING_GSCN <= 0);\n50500000\n50510000                     WHEN(60) /* LTCMPR  */   LINE_SCAN_RESULT = (RESULT_STRING_CMPR <  0);\n50520000                     WHEN(61) /* LECMPR  */   LINE_SCAN_RESULT = (RESULT_STRING_CMPR <= 0);\n50530000                     WHEN(62) /* EQCMPR  */   LINE_SCAN_RESULT = (RESULT_STRING_CMPR =  0);\n50540000                     WHEN(63) /* NECMPR  */   LINE_SCAN_RESULT = (RESULT_STRING_CMPR \u00ac= 0);\n50550000                     WHEN(64) /* GECMPR  */   LINE_SCAN_RESULT = (RESULT_STRING_CMPR >= 0);\n50560000                     WHEN(65) /* GTCMPR  */   LINE_SCAN_RESULT = (RESULT_STRING_CMPR >  0);\n50570000\n50580000                     WHEN(72) /* EQGCMPR */   LINE_SCAN_RESULT =  RESULT_STRING_GCPR;\n50590000                     WHEN(73) /* NEGCMPR */   LINE_SCAN_RESULT = \u00acRESULT_STRING_GCPR;\n50600000                   END;    /*END OF SELECT GROUP ON SCAN_ARRAY_ELEMENT.OP_OIX*/\n50610000             END;          /*END OF ICOL   DO GROUP*/\n50620000         END;            /*END OF ACTIVE IROW DO GROUP*/\n50630000       ELSE  LINE_SCAN_RESULT = '0'B;\n50640000     RETURN (LINE_SCAN_RESULT);               /*TO THE CALLER OF SCAN_ENTRY_LINE*/\n50650000    %PAGE;\n50660000     RESULT_STRING_NTRY:\n50670000     PROC RETURNS(BIT(1));\n50680000            /*COMPARE THE ENTRY TYPE FOR THE CURRENT ENTRY                      */\n50690000            /*AGAINST THE SCAN_ARRAY CHARACTER STRING AND RETURN A BIT VALUE    */\n50700000            /*INDICATING THE RESULT OF THE COMPARE:                             */\n50710000\n50720000        IF  (ENTRY_NTRYINDX = SCAN_ARRAY_ELEMENT.STR_NIX)\n50730000\n50740000          THEN RETURN('1'B);                /*SAME ENTRY TYPE*/\n50750000          ELSE RETURN('0'B);                /*DIFF ENTRY TYPE*/\n50760000\n50770000     END RESULT_STRING_NTRY;\n50780000    %SKIP(2);\n50790000     RESULT_STRING_LINE:\n50800000     PROC RETURNS(BIT(1));\n50810000            /*COMPARE THE LINE TYPE FOR THE CURRENT LINE                        */\n50820000            /*AGAINST THE SCAN_ARRAY CHARACTER STRING AND RETURN A BIT VALUE    */\n50830000            /*INDICATING THE RESULT OF THE COMPARE:                             */\n50840000\n50850000        IF     SUBSTR(ENTRY_LINE_LINETYPE,001,SCAN_ARRAY_ELEMENT.STR_LEN)\n50860000           =   SCAN_ARRAY_ELEMENT.STRING\n50870000\n50880000          THEN RETURN('1'B);                /*SAME LINE TYPE*/\n50890000          ELSE RETURN('0'B);                /*DIFF LINE TYPE*/\n50900000\n50910000     END RESULT_STRING_LINE;\n50920000    %SKIP(2);\n50930000     RESULT_STRING_GLIN:\n50940000     PROC RETURNS(BIT(1));\n50950000            /*COMPARE THE LINE TYPE FOR THE CURRENT LINE                        */\n50960000            /*AGAINST THE SCAN_ARRAY CHARACTER STRING AND RETURN A BIT VALUE    */\n50970000            /*INDICATING THE RESULT OF THE GENERIC COMPARE:                     */\n50980000            /*                      1: GENERIC COMPARE SUCCESSFUL               */\n50990000            /*                      0: GENERIC COMPARE UNSUCCESSFUL             */\n51000000\n51010000        RETURN(GCOMPARE(SUBSTR(ENTRY_LINE_LINETYPE,\n51020000                               001,\n51030000                               SCAN_ARRAY_ELEMENT.STR_LEN\n51040000                              ),\n51050000                        SCAN_ARRAY_ELEMENT.STRING\n51060000                       )\n51070000              );\n51080000\n51090000     END RESULT_STRING_GLIN;\n51100000    %PAGE;\n51110000     RESULT_STRING_SCAN:\n51120000     PROC RETURNS(FIXED BIN(15,0));\n51130000            /*SCAN THE INPUT LINE BETWEEN THE BEGIN AND END SCAN POSITIONS         */\n51140000            /*FOR THE SEARCH STRING AND RETURN THE STRING LOCATION (1ST OCCURRENCE)*/\n51150000            /*RELATIVE TO THE BEGINNING OF THE LINE:                               */\n51160000\n51170000        DCL STRING_INDEX            FIXED BIN(15,0);\n51180000\n51190000        STRING_INDEX = INDEX(SUBSTR(ENTRY_LINE_DATA,\n51200000                                    SCAN_ARRAY_ELEMENT.BEG_POS,\n51210000                                    SCAN_ARRAY_ELEMENT.POS_LEN\n51220000                                   ),\n51230000                             SCAN_ARRAY_ELEMENT.STRING\n51240000                            );\n51250000\n51260000        IF     STRING_INDEX > 0            /*ADJUST VALUE TO THE BEGINNING OF THE LINE*/\n51270000          THEN\n51280000               STRING_INDEX = STRING_INDEX + SCAN_ARRAY_ELEMENT.BEG_POS - 1;\n51290000        RETURN(STRING_INDEX);\n51300000\n51310000     END RESULT_STRING_SCAN;\n51320000    %SKIP(2);\n51330000     RESULT_STRING_GSCN:\n51340000     PROC RETURNS(FIXED BIN(15,0));\n51350000            /*SCAN THE INPUT LINE BETWEEN THE BEGIN AND END SCAN POSITIONS         */\n51360000            /*FOR THE SEARCH STRING AND RETURN THE STRING LOCATION (1ST OCCURRENCE)*/\n51370000            /*RELATIVE TO THE BEGINNING OF THE LINE:                               */\n51380000\n51390000        DCL STRING_INDEX         FIXED BIN(15,0),\n51400000            GS_IX                FIXED BIN(15,0),  /*GENERIC SCAN POSITION INDEX*/\n51410000            GS_LN                FIXED BIN(15,0);  /*GENERIC SCAN STRING  LENGTH*/\n51420000\n51430000        STRING_INDEX  = 0;\n51440000        GS_LN      =  SCAN_ARRAY_ELEMENT.STR_LEN;\n51450000\n51460000        DO   GS_IX =  SCAN_ARRAY_ELEMENT.BEG_POS\n51470000               TO    (SCAN_ARRAY_ELEMENT.END_POS - GS_LN + 1)\n51480000                WHILE(STRING_INDEX=0);\n51490000\n51500000          IF GCOMPARE(SUBSTR(ENTRY_LINE_DATA,GS_IX,GS_LN),\n51510000                      SCAN_ARRAY_ELEMENT.STRING)\n51520000\n51530000            THEN      STRING_INDEX  =  GS_IX;\n51540000        END;\n51550000\n51560000        RETURN(STRING_INDEX);\n51570000\n51580000     END RESULT_STRING_GSCN;\n51590000    %PAGE;\n51600000     RESULT_STRING_CMPR:\n51610000     PROC RETURNS(FIXED BIN(15,0));\n51620000            /*COMPARE THE INPUT LINE STARTING AT THE BEGIN POSITION             */\n51630000            /*AGAINST THE SCAN_ARRAY CHARACTER STRING AND RETURN A BINARY       */\n51640000            /*FIXED POINT VALUE INDICATING THE RESULT OF THE COMPARE:           */\n51650000            /*                     -1: INPUT LINE DATA < STRING                 */\n51660000            /*                      0: INPUT LINE DATA = STRING                 */\n51670000            /*                     +1: INPUT LINE DATA > STRING                 */\n51680000\n51690000        IF          SUBSTR(ENTRY_LINE_DATA,\n51700000                           SCAN_ARRAY_ELEMENT.BEG_POS,\n51710000                           SCAN_ARRAY_ELEMENT.STR_LEN\n51720000                          )\n51730000                 <  SCAN_ARRAY_ELEMENT.STRING\n51740000          THEN             RETURN(-1);                            /*LESS THAN*/\n51750000          ELSE IF   SUBSTR(ENTRY_LINE_DATA,\n51760000                           SCAN_ARRAY_ELEMENT.BEG_POS,\n51770000                           SCAN_ARRAY_ELEMENT.STR_LEN\n51780000                          )\n51790000                 =  SCAN_ARRAY_ELEMENT.STRING\n51800000                 THEN      RETURN(0);                             /*EQUAL TO*/\n51810000                 ELSE      RETURN(+1);                            /*GREATER THAN*/\n51820000\n51830000     END RESULT_STRING_CMPR;\n51840000    %SKIP(3);\n51850000     RESULT_STRING_GCPR:\n51860000     PROC RETURNS(BIT(1));\n51870000            /*COMPARE THE INPUT LINE STARTING AT THE BEGIN POSITION             */\n51880000            /*AGAINST THE SCAN_ARRAY CHARACTER STRING AND RETURN A BIT VALUE    */\n51890000            /*INDICATING THE RESULT OF THE GENERIC COMPARE:                     */\n51900000            /*                      1: GENERIC COMPARE SUCCESSFUL               */\n51910000            /*                      0: GENERIC COMPARE UNSUCCESSFUL             */\n51920000\n51930000        RETURN(GCOMPARE(SUBSTR(ENTRY_LINE_DATA,\n51940000                               SCAN_ARRAY_ELEMENT.BEG_POS,\n51950000                               SCAN_ARRAY_ELEMENT.STR_LEN\n51960000                              ),\n51970000                        SCAN_ARRAY_ELEMENT.STRING\n51980000                       )\n51990000              );\n52000000\n52010000     END RESULT_STRING_GCPR;\n52020000    %SKIP(3);\n52030000  END SMPLIST_SCAN_LINE_DATA;\n52040000 %PAGE;\n52050000 SMPLIST_WRAPUP:           /*************************************************************/\n52060000                           /*   PERFORM FINAL INPUT FILE PROCESSING,                    */\n52070000                           /*   AND CALCULATE VALUES FOR FINAL TOTALS.                  */\n52080000                           /*************************************************************/\n52090000  PROC;\n52100000     DO    IFILE = IFILE_MIN TO IFILE_MAX;\n52110000       IF (SMPLIST(IFILE).ACTIVE)             /*IF THE INPUT FILE WAS ACTIVE*/\n52120000         THEN\n52130000           DO;\n52140000             DO  NTRYINDX_IX = NTRYINDX_MIN TO NTRYINDX_MAX;\n52150000               IF (SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).ENTRY_CT >  0)\n52160000                 THEN  SMPLIST(IFILE).FILE_TOTALS.#_E_T_FOUND =\n52170000                                      SMPLIST(IFILE).FILE_TOTALS.#_E_T_FOUND + 1;\n52180000             END;     /*END OF NTRYINDX_IX DO GROUP*/\n52190000           END;       /*END OF IFILE       DO GROUP*/\n52200000     END;\n52210000     RETURN;                      /*TO THE CALLER OF SMPLIST_WRAPUP*/\n52220000  END SMPLIST_WRAPUP;\n52230000 %PAGE;\n52240000 SMPLIST_CLOSE:            /*************************************************************/\n52250000                           /*   PERFORM FINAL INPUT FILE PROCESSING,                    */\n52260000                           /*   AND CLOSE THE SMPLIST DATA SET(S).                      */\n52270000                           /*************************************************************/\n52280000  PROC;\n52290000     DO    IFILE = IFILE_MIN TO IFILE_MAX;\n52300000       IF (SMPLIST(IFILE).ACTIVE)             /*IF THE INPUT FILE WAS ACTIVE*/\n52310000         THEN\n52320000           DO;\n52330000             CLOSE FILE(SMPLIST(IFILE).FILEREF) ENV(LEAVE);\n52340000             IF  SMPSCAN(IFILE).OPEN THEN CALL SMPSCAN_CLOSE;\n52350000             IF  SMPSOUT(IFILE).OPEN THEN CALL SMPSOUT_CLOSE;\n52360000             IF  SMPDATA(IFILE).OPEN THEN CALL SMPDATA_CLOSE;\n52370000           END;\n52380000     END;\n52390000     RETURN;                      /*TO THE CALLER OF SMPLIST_CLOSE*/\n52400000     %SKIP(2);\n52410000     SMPSCAN_CLOSE:\n52420000       PROC;                      /*IFILE IS SET PRIOR TO CALLING SMPSCAN_CLOSE*/\n52430000          CLOSE  FILE(SMPSCAN(IFILE).FILEREF) ENV(LEAVE);\n52440000          SMPSCAN(IFILE).OPEN    =   '0'B;          /*INDICATE FILE IS NO LONGER OPEN*/\n52450000       END SMPSCAN_CLOSE;\n52460000     %SKIP(2);\n52470000     SMPSOUT_CLOSE:\n52480000       PROC;                      /*IFILE IS SET PRIOR TO CALLING SMPSOUT_CLOSE*/\n52490000          CLOSE  FILE(SMPSOUT(IFILE).FILEREF) ENV(LEAVE);\n52500000          SMPSOUT(IFILE).OPEN    =   '0'B;          /*INDICATE FILE IS NO LONGER OPEN*/\n52510000       END SMPSOUT_CLOSE;\n52520000     %SKIP(2);\n52530000     SMPDATA_CLOSE:\n52540000       PROC;                      /*IFILE IS SET PRIOR TO CALLING SMPDATA_CLOSE*/\n52550000          CLOSE  FILE(SMPDATA(IFILE).FILEREF) ENV(LEAVE);\n52560000          SMPDATA(IFILE).OPEN    =   '0'B;          /*INDICATE FILE IS NO LONGER OPEN*/\n52570000       END SMPDATA_CLOSE;\n52580000  %SKIP(5);\n52590000  END SMPLIST_CLOSE;\n52600000 %PAGE;\n52610000 ZONE_INDEX:  /*FUNCTION SUBROUTINE TO MAP THE TYPE OF ZONE TO                    */\n52620000              /*A BINARY SUBSCRIPT THAT CAN BE SORTED TO PRODUCE                  */\n52630000              /*THE ORDER:  GLOBAL < DLIB < TARGET.                               */\n52640000    PROC(ZONETYPE)                    /*RECEIVES THE ZONE TYPE IN EBCDIC          */\n52650000        RETURNS(FIXED BINARY(15,0));  /*RETURNS A BINARY NUMERIC VALUE:           */\n52660000        DCL  ZONETYPE CHAR(*);\n52670000        SELECT(TRIM(ZONETYPE));\n52680000           WHEN('GLOBAL')               RETURN(1);   /*GLOBAL  ZONE               */\n52690000           WHEN('DLIB')                 RETURN(2);   /*DLIB    ZONE               */\n52700000           WHEN('TARGET')               RETURN(3);   /*TARGET  ZONE               */\n52710000           OTHERWISE                    RETURN(0);   /*UNKNOWN ZONE TYPE          */\n52720000        END;\n52730000    END ZONE_INDEX;\n52740000 %SKIP(3);\n52750000 ZONE_TYPE:   /*FUNCTION SUBROUTINE TO REVERSE THE MAPPING OF THE                 */\n52760000              /*\"ZONE_INDEX\" FUNCTION AND RETURN THE ZONE TYPE NAME               */\n52770000              /*CORRESPONDING TO THE ZONE INDEX SUBSCRIPT.                        */\n52780000    PROC(ZONEINDX)                    /*RECEIVES THE ZONE INDEX IN BINARY         */\n52790000        RETURNS(CHAR(007) VAR);       /*RETURNS A CHARACTER STRING VALUE:         */\n52800000        DCL    ZONEINDX        FIXED BINARY(15,0);\n52810000        SELECT(ZONEINDX);\n52820000           WHEN(0)             RETURN('UNKNOWN');    /*UNKNOWN ZONE INDEX         */\n52830000           WHEN(1)             RETURN('GLOBAL');     /*GLOBAL  ZONE INDEX         */\n52840000           WHEN(2)             RETURN('DLIB');       /*DLIB    ZONE INDEX         */\n52850000           WHEN(3)             RETURN('TARGET');     /*TARGET  ZONE INDEX         */\n52860000           OTHERWISE           RETURN('INVALID');    /*INVALID ZONE INDEX         */\n52870000        END;\n52880000    END ZONE_TYPE;\n52890000 %SKIP(3);\n52900000 ZONE_TYPE_C: /*FUNCTION SUBROUTINE TO REVERSE THE MAPPING OF THE                 */\n52910000              /*\"ZONE_INDEX\" FUNCTION AND RETURN A ONE-CHARACTER ZONE TYPE        */\n52920000              /*CORRESPONDING TO THE ZONE INDEX SUBSCRIPT.                        */\n52930000    PROC(ZONEINDX)                    /*RECEIVES THE ZONE INDEX IN BINARY         */\n52940000        RETURNS(CHAR(001));           /*RETURNS A ONE_BYTE CHARACTER VALUE:       */\n52950000        DCL    ZONEINDX        FIXED BINARY(15,0);\n52960000        SELECT(ZONEINDX);\n52970000           WHEN(0)             RETURN('U');          /*UNKNOWN ZONE INDEX         */\n52980000           WHEN(1)             RETURN('G');          /*GLOBAL  ZONE INDEX         */\n52990000           WHEN(2)             RETURN('D');          /*DLIB    ZONE INDEX         */\n53000000           WHEN(3)             RETURN('T');          /*TARGET  ZONE INDEX         */\n53010000           OTHERWISE           RETURN('?');          /*INVALID ZONE INDEX         */\n53020000        END;\n53030000    END ZONE_TYPE_C;\n53040000 %PAGE;\n53050000 ENTRY_INDEX:  /*FUNCTION SUBROUTINE TO MAP THE LISTED ENTRY TYPE TO              */\n53060000               /*A BINARY SUBSCRIPT THAT IS IN ASCENDING ORDER                    */\n53070000               /*CORRESPONDING TO THE ORDER THAT ENTRIES ARE LISTED               */\n53080000               /*ON THE SMPLIST REPORT PRODUCED BY SMP/E.                         */\n53090000    PROC(NTRYTYPE)                    /*RECEIVES THE ENTRY TYPE IN EBCDIC         */\n53100000        RETURNS(FIXED BINARY(15,0));  /*RETURNS A BINARY NUMERIC VALUE:           */\n53110000\n53120000        DCL  NTRYTYPE          CHAR(*) VAR;\n53130000\n53140000        SELECT(ENTRY_TYPE_TRIM(NTRYTYPE));\n53150000           WHEN('ZONE','GZONE','DZONE','TZONE')  RETURN(01);  /*ZONE     ENTRY    */\n53160000           WHEN('OPTIONS')                       RETURN(02);  /*OPTIONS  ENTRY    */\n53170000           WHEN('UTILITY')                       RETURN(03);  /*UTILITY  ENTRY    */\n53180000           WHEN('FMIDSET')                       RETURN(04);  /*FMIDSET  ENTRY    */\n53190000           WHEN('DDDEF')                         RETURN(05);  /*DDDEF    ENTRY    */\n53200000           WHEN('ZONESET')                       RETURN(06);  /*ZONESET  ENTRY    */\n53210000           WHEN('ASSEM','ASSEMBLER')             RETURN(07);  /*ASSEM    ENTRY    */\n53220000           WHEN('LMOD','LOAD MODULE')            RETURN(08);  /*LMOD     ENTRY    */\n53230000           WHEN('MAC','MACRO')                   RETURN(09);  /*MACRO    ENTRY    */\n53240000           WHEN('MOD','MODULE')                  RETURN(10);  /*MODULE   ENTRY    */\n53250000           WHEN('SRC','SOURCE')                  RETURN(11);  /*SOURCE   ENTRY    */\n53260000           WHEN('DLIB')                          RETURN(12);  /*DLIB     ENTRY    */\n53270000           WHEN('SYSMOD','HOLDDATA')             RETURN(13);  /*SYSMOD / HOLDDATA */\n53280000           WHEN('M.C.S.')                        RETURN(14);  /*M.C.S.   ENTRY    */\n53290000           OTHERWISE                             RETURN(00);  /*UNKNOWN  ENTRY    */\n53300000        END;\n53310000    END ENTRY_INDEX;\n53320000 %PAGE;\n53330000 ENTRY_TYPE:   /*FUNCTION SUBROUTINE TO REVERSE THE MAPPING OF THE                */\n53340000               /*\"ENTRY_INDEX\" FUNCTION AND RETURN THE ENTRY TYPE NAME            */\n53350000               /*CORRESPONDING TO THE ENTRY INDEX SUBSCRIPT.                      */\n53360000    PROC(NTRYINDX)                    /*RECEIVES THE ENTRY INDEX IN BINARY        */\n53370000        RETURNS(CHAR(016) VAR);       /*RETURNS A CHARACTER STRING VALUE:         */\n53380000\n53390000        DCL    NTRYINDX         FIXED BINARY(15,0);\n53400000\n53410000        SELECT(NTRYINDX);\n53420000           WHEN(00)             RETURN('UNKNOWN');         /*UNKNOWN ENTRY INDEX  */\n53430000           WHEN(01)             RETURN('ZONE');            /*ZONE    ENTRY INDEX  */\n53440000           WHEN(02)             RETURN('OPTIONS');         /*OPTIONS ENTRY INDEX  */\n53450000           WHEN(03)             RETURN('UTILITY');         /*UTILITY ENTRY INDEX  */\n53460000           WHEN(04)             RETURN('FMIDSET');         /*FMIDSET ENTRY INDEX  */\n53470000           WHEN(05)             RETURN('DDDEF');           /*DDDEF   ENTRY INDEX  */\n53480000           WHEN(06)             RETURN('ZONESET');         /*ZONESET ENTRY INDEX  */\n53490000           WHEN(07)             RETURN('ASSEMBLER');       /*ASSEM   ENTRY INDEX  */\n53500000           WHEN(08)             RETURN('LOAD MODULE');     /*LMOD    ENTRY INDEX  */\n53510000           WHEN(09)             RETURN('MACRO');           /*MACRO   ENTRY INDEX  */\n53520000           WHEN(10)             RETURN('MODULE');          /*MODULE  ENTRY INDEX  */\n53530000           WHEN(11)             RETURN('SOURCE');          /*SOURCE  ENTRY INDEX  */\n53540000           WHEN(12)             RETURN('DLIB');            /*DLIB    ENTRY INDEX  */\n53550000           WHEN(13)             RETURN('SYSMOD');          /*SYSMOD  ENTRY INDEX  */\n53560000           WHEN(14)             RETURN('M.C.S.');          /*M.C.S.  ENTRY INDEX  */\n53570000           OTHERWISE            RETURN('INVALID');         /*INVALID ENTRY INDEX  */\n53580000        END;\n53590000    END ENTRY_TYPE;\n53600000 %PAGE;\n53610000 ENTRY_TYPE_TRIM:   /*FUNCTION SUBROUTINE TO REMOVE LEADING AND TRAILING BLANKS,  */\n53620000                    /*AND EXTRANEOUS WORDS FROM AN \"ENTRY_TYPE\" CHARACTER STRING. */\n53630000\n53640000    PROC(NTRYTYPE)                    /*RECEIVES THE ENTRY TYPE IN EBCDIC         */\n53650000         RECURSIVE                    /*RETURNS A CHARACTER STRING VALUE          */\n53660000         RETURNS(CHAR(064) VARYING);  /*WITH LEADING AND TRAILING BLANKS REMOVED. */\n53670000\n53680000       DCL  NTRYTYPE          CHAR(*)   VARYING,\n53690000            NTRYTYPE_TRIM     CHAR(064) VARYING;\n53700000\n53710000       NTRYTYPE_TRIM  = TRIM(NTRYTYPE);    /*ELIMINATE LEADING AND TRAILING BLANKS*/\n53720000\n53730000       IF               LENGTH(NTRYTYPE_TRIM) >  8\n53740000                     &  SUBSTR(NTRYTYPE_TRIM,LENGTH(NTRYTYPE_TRIM)-8+1) = ' ENTRIES'\n53750000         THEN           NTRYTYPE_TRIM\n53760000                      = ENTRY_TYPE_TRIM(SUBSTR(NTRYTYPE_TRIM,1,LENGTH(NTRYTYPE_TRIM)-8));\n53770000         ELSE\n53780000       IF               LENGTH(NTRYTYPE_TRIM) >  6\n53790000                     &  SUBSTR(NTRYTYPE_TRIM,LENGTH(NTRYTYPE_TRIM)-6+1) = ' ENTRY'\n53800000         THEN           NTRYTYPE_TRIM\n53810000                      = ENTRY_TYPE_TRIM(SUBSTR(NTRYTYPE_TRIM,1,LENGTH(NTRYTYPE_TRIM)-6));\n53820000         ELSE\n53830000       IF               LENGTH(NTRYTYPE_TRIM) >  1\n53840000                     &  SUBSTR(NTRYTYPE_TRIM,LENGTH(NTRYTYPE_TRIM)-1+1) = ':'\n53850000         THEN           NTRYTYPE_TRIM\n53860000                      = ENTRY_TYPE_TRIM(SUBSTR(NTRYTYPE_TRIM,1,LENGTH(NTRYTYPE_TRIM)-1));\n53870000\n53880000       RETURN(NTRYTYPE_TRIM);\n53890000\n53900000    END ENTRY_TYPE_TRIM;\n53910000 %PAGE;\n53920000 LINE_TYPE:    /*FUNCTION SUBROUTINE TO DETERMINE THE LINE TYPE CHARACTER STRING  */\n53930000               /*ASSOCIATED WITH THE CURRENT SMPLIST ENTRY LISTING LINE.          */\n53940000\n53950000    PROC(PREV_LINETYPE,                 /*STRING FOR PREVIOUS LINETYPE            */\n53960000         LINE_DATA)                     /*CURRENT ENTRY LISTING LINE              */\n53970000         RETURNS(CHAR(015));            /*RETURNS THE CURRENT LINE'S LINETYPE.    */\n53980000\n53990000        DCL (LENGTH,MAX,MIN,SUBSTR,VERIFY)        BUILTIN,\n54000000             PREV_LINETYPE           CHAR(*),\n54010000             LINE_DATA               CHAR(*),\n54020000             LINE_LINETYPE           CHAR(LIST_LINE_LWID),\n54030000             VF_IX                   FIXED BINARY(15,0);\n54040000\n54050000        LINE_LINETYPE  =  SUBSTR(LINE_DATA,LIST_LINE_LBGN,LIST_LINE_LWID);\n54060000\n54070000        VF_IX          =  MIN(VERIFY(LINE_LINETYPE,' '),      /*LOCATE FIRST NON_BLANK*/\n54080000                              LENGTH(PREV_LINETYPE) + 1);     /*AND TEST FOR ALL BLANK*/\n54090000\n54100000        SELECT;                             /*SELECT TO TEST THE VALUE OF VF_IX*/\n54110000          WHEN(VF_IX < 1) LINE_LINETYPE = PREV_LINETYPE; /*LINE_LINETYPE IS  ALL BLANKS*/\n54120000          WHEN(VF_IX = 1);                        /*LINE_LINETYPE HAS NO LEADING BLANKS*/\n54130000          WHEN(VF_IX > 1) LINE_LINETYPE =         /*LINE_LINETYPE HAS    LEADING BLANKS*/\n54140000                                   SUBSTR(PREV_LINETYPE,1,VF_IX-1)     /*MERGE PREVIOUS*/\n54150000                                || SUBSTR(LINE_LINETYPE,VF_IX);        /*WITH  CURRENT */\n54160000        END;                                /*END OF VF_IX SELECT GROUP*/\n54170000\n54180000        RETURN(LINE_LINETYPE);              /*NEW LINETYPE VALUE TO THE CALLER*/\n54190000\n54200000    END LINE_TYPE;\n54210000 %PAGE;\n54220000 GCOMPARE:    /****************************************************************************/\n54230000              /*FUNCTION SUBROUTINE TO GENERICALLY COMPARE A CHARACTER STRING AGAINST     */\n54240000              /*A PATTERN STRING AND RETURN THE RESULT AS A BIT STRING:                   */\n54250000              /*EQUAL('1'B) OR NOT-EQUAL('0'B).                                           */\n54260000              /*                                                                          */\n54270000              /*THE CHARACTER STRING IS COMPARED CHARACTER BY CHARACTER WITH THE PATTERN  */\n54280000              /*STRING, MOVING FROM LEFT TO RIGHT.  THE FIRST CHARACTER STRING CHARACTER  */\n54290000              /*NOT SATISFYING THE REQUIREMENTS OF ITS CORRESPONDING PATTERN STRING       */\n54300000              /*CHARACTER STOPS THE COMPARISON AND RESULTS IN A NOT-EQUAL RESULT BEING    */\n54310000              /*RETURNED.  A CHARACTER STRING LONGER THAN THE PATTERN STRING IS CHECKED   */\n54320000              /*TO VERIFY THAT ALL BYTES EXTENDING ON THE RIGHT BEYOND THE LENGTH OF THE  */\n54330000              /*PATTERN STRING ARE BLANK.  A PATTERN STRING LONGER THAN THE CHARACTER     */\n54340000              /*STRING IS ALSO CHECKED TO VERIFY THAT ALL BYTES EXTENDING ON THE RIGHT    */\n54350000              /*BEYOND THE LENGTH OF THE CHARACTER STRING ARE EITHER BLANK, OR THE \"ANY\"  */\n54360000              /*CHARACTER SELECTION BYTE(\"*\").                                            */\n54370000              /*                                                                          */\n54380000              /*THE FOLLOWING CHARACTERS HAVE SPECIAL SIGNIFICANCE IN PATTERN STRINGS,    */\n54390000              /*AND ARE USED TO SELECT CLASSES OF CHARACTERS:                             */\n54400000              /*            \"*\" - THE CORRESPONDING CHARACTER STRING CHARACTER CAN BE     */\n54410000              /*                  ANY CHARACTER.                                          */\n54420000              /*                                                                          */\n54430000              /*            \"#\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */\n54440000              /*                  NUMERIC AND CAN BE EITHER UPPER OR LOWER CASE.          */\n54450000              /*                                                                          */\n54460000              /*            \"@\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */\n54470000              /*                  ALPHABETIC AND CAN BE EITHER UPPER OR LOWER CASE.       */\n54480000              /*                                                                          */\n54490000              /*            \"\u00a2\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */\n54500000              /*                  ONE OF THE NATIONAL CHARACTERS: \"$\", \"#\", OR \"@\".       */\n54510000              /*                  BECAUSE OF THEIR BIT REPRESENTATIONS, NATIONAL          */\n54520000              /*                  CHARACTERS ARE UPPERCASE.                               */\n54530000              /*                                                                          */\n54540000              /*            \"%\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */\n54550000              /*                  ALPHABETIC OR ONE OF THE NATIONAL CHARACTERS.           */\n54560000              /*                                                                          */\n54570000              /*            \"_\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */\n54580000              /*                  ALPHABETIC, NUMERIC,  OR ONE OF THE NATIONAL CHARACTERS.*/\n54590000              /*                                                                          */\n54600000              /*            \">\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */\n54610000              /*                  ONE OF THE NATIONAL CHARACTERS, OR AN UPPERCASE         */\n54620000              /*                  ALPHABETIC OR NUMERIC CHARACTER.                        */\n54630000              /*                                                                          */\n54640000              /*            \"<\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */\n54650000              /*                  A LOWERCASE ALPHABETIC OR NUMERIC CHARACTER.            */\n54660000              /*                                                                          */\n54670000              /*            \"!\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */\n54680000              /*                  ONE OF THE SPECIAL CHARACTERS.                          */\n54690000              /*                                                                          */\n54700000              /*            \"-\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */\n54710000              /*                  NON-NUMERIC.                                            */\n54720000              /*                                                                          */\n54730000              /*            \"\u00ac\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */\n54740000              /*                  NON-BLANK.                                              */\n54750000              /*                                                                          */\n54760000              /*            \"?\" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */\n54770000              /*                  ONE OF THE INVALID CHARACTERS.                          */\n54780000              /*                                                                          */\n54790000              /*ALL OTHER CHARACTERS IN A PATTERN STRING (BLANKS, ALPHABETICS, NUMERIC    */\n54800000              /*DIGITS, AND ESPECIALLY THE CHARACTERS \"=\" \".\" \",\" \":\" \"$\" \"(\" AND \")\" )   */\n54810000              /*REPRESENT THEMSELVES.  THE CORRESPONDING CHARACTER STRING CHARACTER MUST  */\n54820000              /*BE THE SAME AS THE PATTERN CHARACTER.  EVERY ATTEMPT WAS MADE TO CHOOSE   */\n54830000              /*GENERIC SELECTION CHARACTERS THAT WOULD BE UNLIKELY TO APPEAR IN THE      */\n54840000              /*DATA EXCEPT WHERE TRADITION STRONGLY DICTATED OTHERWISE.                  */\n54850000              /****************************************************************************/\n54860000\n54870000    PROC(C_STRING,                  /*CHARACTER STRING TO BE COMPARED                     */\n54880000         P_STRING)                  /*PATTERN (GENERIC) CHARACTER STRING                  */\n54890000         RETURNS(BIT(01));          /*RETURNS EQUAL/NOT EQUAL INDICATOR                   */\n54900000\n54910000        DCL (LENGTH,MAX,MIN,SIGN,SUBSTR,VERIFY)     BUILTIN,\n54920000             C_STRING                  CHAR(*),            /*CHARACTER STRING PARAMETER   */\n54930000             CS_IX                     FIXED BINARY(15,0), /*CHARACTER STRING INDEX VALUE */\n54940000             CS_CH                     CHAR(001),          /*CHARACTER STRING CHARACTER   */\n54950000             CS_CX                     FIXED BINARY(15,0), /*CHAR STRING CHAR BINARY VALUE*/\n54960000             CS_LN                     FIXED BINARY(15,0), /*CHARACTER STRING LENGTH      */\n54970000\n54980000             P_STRING                  CHAR(*) VARYING,    /*PATTERN STRING PARAMETER     */\n54990000             PS_LN                     FIXED BINARY(15,0), /*PATTERN STRING LENGTH        */\n55000000\n55010000             G_RESULT                  BIT(01);\n55020000       %SKIP(2);\n55030000        DCL     CH_TYPE_ADDR           POINTER;   /*DEFINE CH_TABLE BIT MEANINGS*/\n55040000        DCL  01 CH_TYPE                BASED(CH_TYPE_ADDR),\n55050000                05 INVALID             UNALIGNED     BIT(01),   /*BIT 0*/\n55060000                05 UPCASE              UNALIGNED     BIT(01),   /*BIT 1*/\n55070000                05 BIT2  /*RESERVED*/  UNALIGNED     BIT(01),   /*BIT 2*/\n55080000                05 SPECIAL             UNALIGNED     BIT(01),   /*BIT 3*/\n55090000                05 NATIONAL            UNALIGNED     BIT(01),   /*BIT 4*/\n55100000                05 ALPHABETIC          UNALIGNED     BIT(01),   /*BIT 5*/\n55110000                05 Z_NUM               UNALIGNED     BIT(01),   /*BIT 6*/\n55120000                05 NUMERIC             UNALIGNED     BIT(01);   /*BIT 7*/\n55130000       %SKIP(2);\n55140000        CS_LN = LENGTH(C_STRING);\n55150000        PS_LN = LENGTH(P_STRING);\n55160000        G_RESULT = '1'B;                               /*INITIALIZE FOR ENTERING DO GROUP*/\n55170000       %PAGE;\n55180000        DO  CS_IX = 001 TO MIN(CS_LN,PS_LN) WHILE(G_RESULT);\n55190000\n55200000          CS_CH         =  SUBSTR(C_STRING,CS_IX,001);   /*SELECT CHARACTER FROM C_STRING*/\n55210000          UNSPEC(CS_CX) = '00000000'B || UNSPEC(CS_CH);  /*CONVERT CHARACTER TO AN INDEX */\n55220000          CH_TYPE_ADDR  =  ADDR(CH_TABLE(CS_CX));        /*-> ENTRY IN CHARACTER TYPE TBL*/\n55230000\n55240000          SELECT(SUBSTR(P_STRING,CS_IX,001));     /*CONTROL WITH PATTERN STRING CHARACTER*/\n55250000            WHEN('*');                                           /*ANY CHARACTER IS VALID*/\n55260000            WHEN('#') IF     \u00ac(CH_TYPE.NUMERIC)                  /*NUMERIC CHARACTER     */\n55270000                        THEN   G_RESULT = '0'B;\n55280000            WHEN('@') IF     \u00ac(CH_TYPE.ALPHABETIC)               /*ALPHABETIC CHARACTER  */\n55290000                        THEN   G_RESULT = '0'B;\n55300000            WHEN('\u00a2') IF     \u00ac(CH_TYPE.NATIONAL)                  /*NATIONAL CH ($#@)    */\n55310000                        THEN   G_RESULT = '0'B;\n55320000            WHEN('%') IF     \u00ac(CH_TYPE.NATIONAL | CH_TYPE.ALPHABETIC)\n55330000                        THEN   G_RESULT = '0'B;\n55340000            WHEN('_') IF     \u00ac(CH_TYPE.NATIONAL | CH_TYPE.ALPHABETIC | CH_TYPE.NUMERIC)\n55350000                        THEN   G_RESULT = '0'B;\n55360000            WHEN('>') IF     \u00ac(CH_TYPE.NATIONAL |\n55370000                              (CH_TYPE.UPCASE & (CH_TYPE.ALPHABETIC | CH_TYPE.NUMERIC)))\n55380000                        THEN   G_RESULT = '0'B;\n55390000            WHEN('<') IF    \u00ac(\u00acCH_TYPE.UPCASE & (CH_TYPE.ALPHABETIC | CH_TYPE.NUMERIC))\n55400000                        THEN   G_RESULT = '0'B;\n55410000            WHEN('!') IF     \u00ac(CH_TYPE.SPECIAL)                   /*SPECIAL CHARACTER    */\n55420000                        THEN   G_RESULT = '0'B;\n55430000            WHEN('-') IF      (CH_TYPE.NUMERIC)                   /*NON-NUMERIC CHARACTER*/\n55440000                        THEN   G_RESULT = '0'B;\n55450000            WHEN('\u00ac') IF      (CS_CH    = ' ')                    /*NON_BLANK CHARACTER  */\n55460000                        THEN   G_RESULT = '0'B;\n55470000            WHEN('?') IF     \u00ac(CH_TYPE.INVALID)                   /*INVALID CHARACTER    */\n55480000                        THEN   G_RESULT = '0'B;\n55490000            WHEN(CS_CH);           /*A PATTERN CHARACTER NOT APPEARING IN THE ABOVE LIST,*/\n55500000                                                                   /*REPRESENTS ITSELF.  */\n55510000            OTHERWISE          G_RESULT = '0'B; /*IF ALL TESTS FAILED, THE COMPARE FAILED*/\n55520000          END;                       /*END OF PATTERN CHARACTER SELECT GROUP*/\n55530000\n55540000        END;\n55550000\n55560000        IF          (G_RESULT) & (CS_LN \u00ac= PS_LN)        /*IF RESULT SO FAR IS SUCCESSFUL*/\n55570000          THEN\n55580000            IF                   (CS_LN < PS_LN)   /*BASE RESULT ON TAIL OF LONGER STRING*/\n55590000               THEN  G_RESULT = (VERIFY(SUBSTR(P_STRING,CS_LN+1),'* ')  <= 0);\n55600000               ELSE  G_RESULT = (VERIFY(SUBSTR(C_STRING,PS_LN+1),' ')   <= 0);\n55610000          ELSE;\n55620000\n55630000        RETURN(G_RESULT);            /*RETURN COMPARISON RESULTS*/\n55640000       %PAGE;\n55650000        DCL  CH_TABLE(000:255)         BIT(08) ALIGNED  STATIC  INTERNAL\n55660000                INIT((01)('10000000'B),                                      /*   X'00'   */\n55670000                     (63)('10000000'B),                                      /*X'01'-X'3F'*/\n55680000                     (01)('01000000'B),    /*BLANK*/                         /*   X'40'   */\n55690000                     (09)('11000000'B),                                      /*X'41'-X'49'*/\n55700000                     (01)('01010000'B),    /*  \u00a2  */                         /*   X'4A'   */\n55710000                     (01)('01010000'B),    /*  .  */                         /*   X'4B'   */\n55720000                     (01)('01010000'B),    /*  <  */                         /*   X'4C'   */\n55730000                     (01)('01010000'B),    /*  (  */                         /*   X'4D'   */\n55740000                     (01)('01010000'B),    /*  +  */                         /*   X'4E'   */\n55750000                     (01)('01010000'B),    /*  |  */                         /*   X'4F'   */\n55760000                     (01)('01010000'B),    /*  &  */                         /*   X'50'   */\n55770000                     (09)('11000000'B),                                      /*X'51'-X'59'*/\n55780000                     (01)('01010000'B),    /*  !  */                         /*   X'5A'   */\n55790000                     (01)('01001000'B),    /*  $  */                         /*   X'5B'   */\n55800000                     (01)('01010000'B),    /*  *  */                         /*   X'5C'   */\n55810000                     (01)('01010000'B),    /*  )  */                         /*   X'5D'   */\n55820000                     (01)('01010000'B),    /*SEMICOLON*/                     /*   X'5E'   */\n55830000                     (01)('01010000'B),    /*  \u00ac  */                         /*   X'5F'   */\n55840000                     (01)('01010000'B),    /*  -  */                         /*   X'60'   */\n55850000                     (01)('01010000'B),    /*  /  */                         /*   X'61'   */\n55860000                     (08)('11000000'B),                                      /*X'62'-X'69'*/\n55870000                     (01)('01010000'B),    /*  \u00a6  */                         /*   X'6A'   */\n55880000                     (01)('01010000'B),    /*  ,  */                         /*   X'6B'   */\n55890000                     (01)('01010000'B),    /*  %  */                         /*   X'6C'   */\n55900000                     (01)('01010000'B),    /*  _  */                         /*   X'6D'   */\n55910000                     (01)('01010000'B),    /*  >  */                         /*   X'6E'   */\n55920000                     (01)('01010000'B),    /*  ?  */                         /*   X'6F'   */\n55930000                     (09)('11000000'B),                                      /*X'70'-X'78'*/\n55940000                     (01)('01010000'B),    /*  `  */                         /*   X'79'   */\n55950000                     (01)('01010000'B),    /*  :  */                         /*   X'7A'   */\n55960000                     (01)('01001000'B),    /*  #  */                         /*   X'7B'   */\n55970000                     (01)('01001000'B),    /*  @  */                         /*   X'7C'   */\n55980000                     (01)('01010000'B),    /*  '  */                         /*   X'7D'   */\n55990000                     (01)('01010000'B),    /*  =  */                         /*   X'7E'   */\n56000000                     (01)('01010000'B),    /*  \"  */                         /*   X'7F'   */\n56010000                     (01)('00000010'B),                                      /*   X'80'   */\n56020000                     (09)('00000110'B),    /*LOWERCASE \"A\" - \"I\"*/           /*X'81'-X'89'*/\n56030000                     (06)('10000000'B),                                      /*X'8A'-X'8F'*/\n56040000                     (01)('00000010'B),                                      /*   X'90'   */\n56050000                     (09)('00000110'B),    /*LOWERCASE \"J\" - \"R\"*/           /*X'91'-X'99'*/\n56060000                     (06)('10000000'B),                                      /*X'9A'-X'9F'*/\n56070000                     (01)('00000010'B),                                      /*   X'A0'   */\n56080000                     (01)('00010010'B),    /*  ~  */                         /*   X'A1'   */\n56090000                     (08)('00000110'B),    /*LOWERCASE \"S\" - \"Z\"*/           /*X'A2'-X'A9'*/\n56100000                     (06)('10000000'B),                                      /*X'AA'-X'AF'*/\n56110000                     (10)('00000001'B),    /*LOWERCASE \"0\" - \"9\"*/           /*X'B0'-X'B9'*/\n56120000                     (06)('10000000'B),                                      /*X'BA'-X'BF'*/\n56130000                     (01)('01010010'B),    /*  {  */                         /*   X'C0'   */\n56140000                     (09)('01000110'B),    /*UPPERCASE \"A\" - \"I\"*/           /*X'C1'-X'C9'*/\n56150000                     (06)('11000000'B),                                      /*X'CA'-X'CF'*/\n56160000                     (01)('01010010'B),    /*  }  */                         /*   X'D0'   */\n56170000                     (09)('01000110'B),    /*UPPERCASE \"J\" - \"R\"*/           /*X'D1'-X'D9'*/\n56180000                     (06)('11000000'B),                                      /*X'DA'-X'DF'*/\n56190000                     (01)('01010010'B),    /*  \\  */                         /*   X'E0'   */\n56200000                     (01)('01000010'B),                                      /*   X'E1'   */\n56210000                     (08)('01000110'B),    /*UPPERCASE \"S\" - \"Z\"*/           /*X'E2'-X'E9'*/\n56220000                     (06)('11000000'B),                                      /*X'EA'-X'EF'*/\n56230000                     (10)('01000001'B),    /*UPPERCASE \"0\" - \"9\"*/           /*X'F0'-X'F9'*/\n56240000                     (06)('11000000'B));                                     /*X'FA'-X'FF'*/\n56250000       %SKIP(2);\n56260000    END GCOMPARE;\n56270000 %PAGE;\n56280000 DECLARE    /*ASSOCIATE SUBROUTINES AND ENTRY POINTS BASED ON PARAMETER ATTRIBUTES*/\n56290000\n56300000         TRIM          GENERIC(CV_TRIM   WHEN(CHARACTER VARYING),\n56310000                               CF_TRIM   WHEN(CHARACTER));\n56320000 %SKIP(2);\n56330000 CF_TRIM:     /*FUNCTION SUBROUTINE TO REMOVE LEADING AND TRAILING BLANKS         */\n56340000              /*FROM A FIXED LENGTH CHARACTER STRING.                             */\n56350000    PROC(CF_STRING)                 /*RECEIVES THE CHARACTER STRING               */\n56360000         RETURNS(CHAR(256) VAR);    /*RETURNS A VARYING LENGTH STRING             */\n56370000\n56380000        DCL  LENGTH            BUILTIN,\n56390000             CF_STRING         CHAR(*),\n56400000            (I,J,L)            FIXED BINARY(15,0);\n56410000\n56420000        L = LENGTH(CF_STRING);\n56430000        IF  L > 0\n56440000          THEN DO;\n56450000                 DO I = 1 TO L BY +1 WHILE(SUBSTR(CF_STRING,I,1) = ' '); END;\n56460000                 DO J = L TO I BY -1 WHILE(SUBSTR(CF_STRING,J,1) = ' '); END;\n56470000                 IF I <= J                /* I -> FIRST NON-BLANK, J -> LAST NON-BLANK */\n56480000                   THEN RETURN(SUBSTR(CF_STRING,I,J-I+1)); /*STRING CONTAINS NON-BLANKS*/\n56490000                   ELSE RETURN('');                        /*STRING IS COMPLETELY BLANK*/\n56500000               END;\n56510000          ELSE RETURN('');                                 /*STRING IS NULL (LENGTH 0) */\n56520000    END CF_TRIM;\n56530000 %SKIP(2);\n56540000 CV_TRIM:     /*FUNCTION SUBROUTINE TO REMOVE LEADING AND TRAILING BLANKS         */\n56550000              /*FROM A VARYING LENGTH CHARACTER STRING.                           */\n56560000    PROC(CV_STRING)                 /*RECEIVES THE CHARACTER STRING               */\n56570000         RETURNS(CHAR(256) VAR);    /*RETURNS A VARYING LENGTH STRING             */\n56580000\n56590000        DCL  LENGTH            BUILTIN,\n56600000             CV_STRING         CHAR(*) VARYING,\n56610000            (I,J,L)            FIXED BINARY(15,0);\n56620000\n56630000        L = LENGTH(CV_STRING);\n56640000        IF  L > 0\n56650000          THEN DO;\n56660000                 DO I = 1 TO L BY +1 WHILE(SUBSTR(CV_STRING,I,1) = ' '); END;\n56670000                 DO J = L TO I BY -1 WHILE(SUBSTR(CV_STRING,J,1) = ' '); END;\n56680000                 IF I <= J                /* I -> FIRST NON-BLANK, J -> LAST NON-BLANK */\n56690000                   THEN RETURN(SUBSTR(CV_STRING,I,J-I+1)); /*STRING CONTAINS NON-BLANKS*/\n56700000                   ELSE RETURN('');                        /*STRING IS COMPLETELY BLANK*/\n56710000               END;\n56720000          ELSE RETURN('');                                 /*STRING IS NULL (LENGTH 0) */\n56730000    END CV_TRIM;\n56740000    %SKIP(05);\n56750000 END SMPSCAN;              /*END OF THE MAIN PROCEDURE*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT115/FILE115.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT115", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}