{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012332000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 411502, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE555.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE555.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x07\\x0e'", "DS1TRBAL": "b'\\n\\xe4'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x13\\x00\\x04\\x04\\x13\\x00\\x0b\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04G\\x00\\x00\\x01\\x06\\x05\\x8f\\x01\\x06\\x05\\x8f\\tQ\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf1@@@'", "ispf": {"version": "04.71", "flags": 0, "createdate": "2006-02-27T00:00:00", "modifydate": "2006-02-27T09:51:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-471"}, "text": "REGULAR CBT TAPE - VERSION 471    FILE:  555\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT471.FILE555\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 23 MEMBERS COUNTED; CUMULATIVE SIZE IS 3,463 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   02/27/06    09:51:14    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$README": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00A\\x01\\x02\\x07\\x8f\\x01\\x02\\x07\\x9f\\x19U\\x00)\\x00\\x0c\\x00 \\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-03-19T00:00:00", "modifydate": "2002-03-20T19:55:41", "lines": 41, "newlines": 12, "modlines": 32, "user": "SPGSRS"}, "text": "THE MEMBERS OF THIS DATASET ARE ALL WRITTEN IN BAL. ORIGINALLY INTENDED\nFOR USE AS UTILITIES FOR COBOL PROGRAMS. THEY ALL USE THE ATTACHED\nMACLIB. SINCE MOST OF THE PROGRAMS HERE\nARE SUBROUTINES, THEY ARE USED BY MAIN PROGRAMS SUCH AS \"LIST\".\n\nALMOST ALL OF THE PROGRAMS HERE HAVE SOME DOCUMENTATION BEFORE THE\nSTART OF THE CODE THAT DESCRIBES THE PARAMETER LIST BUT\nALL OF THEM ARE DESCRIBED BY THE 'EPA' (ENTRY POINT ADDRESS) MACRO.\n\nFOR THE ROUTINES (LIKE SCAN AND PARSE) THAT DON'T HAVE A DOCUMENTATION\nHEADER, YOU COULD EASILY FIGURE OUT HOW TO USE IT BECAUSE THE LINKAGE\nSECTION IS DESCRIPTIVE ENOUGH I WOULD THINK.\n\nTHE CALENDAR PROGRAM HAS A BUG FOR THE MONTH OF FEBRUARY. I THINK IT\nDISPLAYS 28 DAYS EVEN IF IT'S A LEAP YEAR. BUT THE MONTH OF MARCH IS\nOK. I GUESS I'M JUST TOO LAZY TO FIX IT.\nIF YOU INVOKE CALENDAR W/O PARMS, IT WILL DISPLAY THE CURRENT DATE.\nIF YOU WANT A SPECIFIC DATE, INVOKE IT LIKE \"CALENDAR YYYYMMDD\"\n\nMOST OF THE SUBROUTINES HERE ARE Y2K COMPLIANT I BELIEVE. BUT SOME,\nLIKE GUS002 (CONVERT YYMMDD TO YYDDD) MAY NOT NEED TO BE... I HAVEN'T\nCHECKED.\n\nTHE PROGRAM FLPRT JUST PRINTS THE DATASET DEFINED IN SYSUT1. ONLY\nFLPRT AND CALENDAR ARE NON-REENTRANT; ALL THE REST ARE RE-ENTRANT\nPROGRAMS.\n\n\"LIST\" JUST DISPLAYS THE CONTENTS OF THE DATA PASSED ON THE COMMAND\nLINE. IT IS INCLUDED HERE AS AN EXAMPLE OF A PROGRAM THAT USES THE\nPARSE, PUTLINE AND DYNALLOC SUBROUTINES (GUS014,GUS016 AND GUS012).\nTST9 IS ANOTHER TEST PROGRAM THAT DEMONSTRATES HOW THE SCAN, GETLINE\nAND PUTLINE ROUTINES HELP MAKE WRITING COMMAND PROCESSORS EASY.\n\nBTW, GUS STANDS FOR GENERAL UTILITY SUBROUTINES.\n\nTHE MACLIB MEMBER SF IS TO CREATE 3270 ATTRIBUTES; BUT I HAVEN'T\nGOTTEN AROUND TO SUPPORT THE X'29' ORDER FOR EXTENDED ATTRIBUTES.\nIT DOES SUPPORT FUJITSU'S X'1B' ORDER FOR F9526 EXTENDED ATTRIBUTES.\n\nI HOPE YOU FIND THESE USEFUL.\nMON\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE555": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04G\\x00\\x00\\x01\\x06\\x05\\x8f\\x01\\x06\\x05\\x8f\\tP\\x00@\\x00@\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf1@@@'", "ispf": {"version": "04.71", "flags": 0, "createdate": "2006-02-27T00:00:00", "modifydate": "2006-02-27T09:50:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "CBT-471"}, "text": "//***FILE 555 is from Solomon Santos and contains a very            *   FILE 555\n//*           interesting set of his utilities and subroutines.     *   FILE 555\n//*                                                                 *   FILE 555\n//*           email:  \"Mon R. Santos\" <bugsie@tig.com.au>           *   FILE 555\n//*                   bugsie88@yahoo.com                            *   FILE 555\n//*                                                                 *   FILE 555\n//*      - - - - - - - - - - - - - - - - - - - - - - - - - - -      *   FILE 555\n//*                                                                 *   FILE 555\n//*      A new utility, an ISPF-ized front end to the TSO XMIT      *   FILE 555\n//*      commmand, is called ISPFXMI, and it consists of one        *   FILE 555\n//*      REXX exec and two panels.  It's an easy way to prepare     *   FILE 555\n//*      XMIT-format datasets, to send anywhere.  Try it!           *   FILE 555\n//*                                                                 *   FILE 555\n//*      - - - - - - - - - - - - - - - - - - - - - - - - - - -      *   FILE 555\n//*                                                                 *   FILE 555\n//*      The rest of the members of this dataset are all written    *   FILE 555\n//*      in BAL.  Originally, they were intended for use as         *   FILE 555\n//*      utilities for COBOL programs.  They all use the attached   *   FILE 555\n//*      MACLIB, here included as member MACLIB.  Since most of     *   FILE 555\n//*      the programs here are subroutines, they are used by main   *   FILE 555\n//*      programs such as \"LIST\".                                   *   FILE 555\n//*                                                                 *   FILE 555\n//*      Almost all of the programs here have some documentation    *   FILE 555\n//*      before the start of the code that describes the            *   FILE 555\n//*      parameter list, but all of them are described by the       *   FILE 555\n//*      'EPA' (entry point address) macro.                         *   FILE 555\n//*                                                                 *   FILE 555\n//*      For the routines (like SCAN (in GUS015) and PARSE (in      *   FILE 555\n//*      GUS014)) that don't have a documentation header, you       *   FILE 555\n//*      could easily figure out how to use it because the          *   FILE 555\n//*      linkage section is descriptive enough, I would think.      *   FILE 555\n//*                                                                 *   FILE 555\n//*      The calendar program has a bug for the month of February.  *   FILE 555\n//*      I think it displays 28 days even if it's a leap year.      *   FILE 555\n//*      But the month of March is OK.  I guess I'm just too lazy   *   FILE 555\n//*      to fix it.  If you invoke calendar w/o parms, it will      *   FILE 555\n//*      display the current date.  If you want a specific date,    *   FILE 555\n//*      invoke it like \"CALENDAR yyyymmdd\"                         *   FILE 555\n//*                                                                 *   FILE 555\n//*      Most of the subroutines here are Y2K compliant, I          *   FILE 555\n//*      believe.  But some, like GUS002 (convert yymmdd to         *   FILE 555\n//*      yyddd) may not need to be...  I haven't checked.           *   FILE 555\n//*                                                                 *   FILE 555\n//*      The program FLPRT just prints the dataset defined in       *   FILE 555\n//*      SYSUT1.  Only FLPRT and CALENDAR are non-reentrant; all    *   FILE 555\n//*      the rest are re-entrant programs.                          *   FILE 555\n//*                                                                 *   FILE 555\n//*      \"LIST\" just displays the contents of the data passed on    *   FILE 555\n//*      the command line.  It is included here as an example of    *   FILE 555\n//*      a program that uses the PARSE, PUTLINE and DYNALLOC        *   FILE 555\n//*      subroutines (GUS014,GUS016 and GUS012).  TST9 is           *   FILE 555\n//*      another test program that demonstrates how the SCAN,       *   FILE 555\n//*      GETLINE and PUTLINE routines help make writing command     *   FILE 555\n//*      processors easy.                                           *   FILE 555\n//*                                                                 *   FILE 555\n//*      BTW, GUS stands for General Utility Subroutines.           *   FILE 555\n//*                                                                 *   FILE 555\n//*      The MACLIB member SF is to create 3270 attributes; but     *   FILE 555\n//*      I haven't gotten around to support the X'29' order for     *   FILE 555\n//*      extended attributes.  It does support Fujitsu's X'1B'      *   FILE 555\n//*      order for F9526 extended attributes.                       *   FILE 555\n//*                                                                 *   FILE 555\n//*      I hope you find these useful.    Mon                       *   FILE 555\n//*                                                                 *   FILE 555\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CALENDAR": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x007\\x01\\x01\\x12\\x8f\\x01\\x02\\x07\\x8f\\x18\\x06\\x00\\xf4\\x00\\xe4\\x00H\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2001-05-08T00:00:00", "modifydate": "2002-03-19T18:06:37", "lines": 244, "newlines": 228, "modlines": 72, "user": "SPGSRS"}, "text": "CALENDAR EPA   'DISPLAYS A CALENDAR OF THE CURRENT MONTH'\n         BALR  12,0                12 IS BASE REGISTER\n         USING *,12                TELL ASSEMBLER\n         USING CMDLINE,11\n         USING PARMS,10\n         USING CPPL,1\n         L     11,CPPLCBUF         GET ADDRESS OF COMMAND LINE\n         ST    13,STACK+4          SAVE CALLER'S SVAREA ADDRESS\n         LA    10,STACK            LOAD SAVE AREA JUST IN CASE\n         ST    10,8(,13)           SET BACKWARD CHAIN\n         LR    13,10               SET FORWARD CHAIN\n*\n**** PROCESS PARAMETER ON COMMAND LINE\n*\n         LH    2,LINELEN\n         SH    2,CMDLEN\n         CH    2,=H'4'\n         BNH   NOPARMS             NO PARMS ON COMMAND LINE\n         LA    10,COMMAND\n         AH    10,CMDLEN           GO PAST COMMAND\n         PACK  DATAREA2(8),0(8,10) PACK THE DATE IN PARM LINE\n         MVC   DATAREA(4),DATAREA2+4\n         NI    DATAREA,X'0F'       CLEAR HIGH NIBBLE\n         B     GO                  PROCESS THE CALENDAR\n*\nNOPARMS  TIME  DEC,DATAREA0,DATETYPE=YYYYMMDD,LINKAGE=SYSTEM\n         L     5,DATAREA0+8        YYYYMMDD\n         XR    4,4                 00000000\n         SLDL  4,4                 0000000Y YYYMMDD0\n         STM   4,5,DATAREA2\n         MVC   DATAREA(4),DATAREA2+4\n         OI    DATAREA+3,X'0F'     PACK IT         CYYMMDDF\nGO       NC    DATAREA2+6,=X'F00F' SET DD TO 0\n         MVI   DATAREA2+7,X'1F'    SET DD TO 1\n         XR    4,4\n         ICM   4,7,DATAREA2+3      GET YY PART     000CCYYM\n         ST    4,WORK              PREPARE TO PACK\n         OI    WORK+3,X'0F'        PACK IT         000CCYYF'\n         UNPK  YEAR1(4),WORK(4)    PUT HEADING 1\n         UNPK  YEAR2(4),WORK(4)    PUT HEADING 2\n         XR    4,4                 00000000\n         ICM   4,3,DATAREA+1       GET MM PART     0000YMMD\n         SRDL  4,12                CLEAR BYTE 2    0000000Y MMD00000\n         XR    4,4                 CLEAR Y         00000000 MMD00000\n         SLDL  4,12                SHIFT MM PART   00000MMD 00000000\n         ZAP   WORK(8),=P'0'\n         ST    4,WORK+4            PREPARE TO PACK 00000000 00000MMD\n         OI    WORK+7,X'0F'        PACK IT         00000000 00000MMF\n         CVB   4,WORK\n         LR    8,4                 SAVE MM\n         MH    4,=H'9'             FIX OFFSET\n         LA    5,MONTHTAB-9(4)     GET ADDRESS OF CURRENT MONTH\n         MVC   MONTH(9),0(5)       PUT IN HEADING\n         ICM   4,3,DATAREA+2       GET DD PART     0000MDDF\n         STCM  4,3,CDAY            SAVE                MDDF\n         NI    CDAY,X'0F'          CLEAR HIGH NIBBLE   0DDF\n         UNPK  CYMDDATE(8),DATAREA2(8)\n         LA    1,GUS007            LOAD PARAMETER LIST ADDRESS\n         LINK  EP=GUS007,MF=(E,(1))\n         PACK  WORK(8),DAYNUM(1)\n         CP    WORK(8),=P'0'       0 IS USED AS A SATURDAY\n         BH    *+10                NOT SATURDAY\n         ZAP   WORK(8),=P'7'       SET TO SATURDAY\n         CVB   4,WORK\n         AR    4,4                 FIX OFFSET\n         XR    2,2\n         IC    2,LOOPCTR-1(8)      USE MM IN R8 AS POINTER\n         LA    3,NUMAREA-2(4)      GET ADDRESS OF LINE\n         LA    5,NUMAREA-4(4)      GET ADDRESS OF PREVIOUS CELL\nLOOP     AP    0(2,3),0(2,5)\n         AP    0(2,3),=P'1'        ADD 1 MORE\n         LR    5,3                 SAVE PREVIOUS CELL\n         LA    3,2(,3)             NEXT CELL\n         BCT   2,LOOP\n         LA    2,LINEADDR\n         LA    6,NUMAREA\n         LA    3,6                 6 LINES TO TRANSLATE\nOUTER    L     5,0(,2)             GET ADDRESS OF CURRENT LINE\n         LA    4,7                 7 CHARS/LINE\nINNER    MVC   EDTAREA(4),EDTCDE\n         ED    EDTAREA(4),0(6)\n         MVC   0(4,5),EDTAREA\n         CP    0(2,6),CDAY(2)\n         BNE   *+10\n         MVC   36(4,5),=C' ***'\n         LA    5,4(,5)\n         LA    6,2(,6)\n         BCT   4,INNER\n         LA    2,4(,2)\n         BCT   3,OUTER\n         TPUT  SCREEN,SCRLEN,FULLSCR\n         TGET  AREA,4\n         L     13,STACK+4\n         LM    14,12,12(13)        RESTORE AND\n         XR    15,15               SET RETURN CODE THEN\n         BR    14                  QUIT\nSTACK    DS    18F\nSCREEN   EQU   *\n         DC    C'     '\nR05C09   SBA   5,9\n         SF    (PROT,NUM)\n         DC    C'+'\n         DC    29C'-'\n         DC    C'+'\nR06C09   SBA   6,9\n         SF    (PROT,NUM)          YEAR1 = R06C09+7\n         DC    C'|'\n         DC    10C' '\nMONTH    DC    CL9' '\n         DC    10C' '              YEAR2 = MONTH+14\n         DC    C'|'\nR07C09   SBA   7,9\n         SF    (PROT,NUM)\n         DC    C'|'\n         DC    29C'-'\n         DC    C'|'\nR08C09   SBA   8,9\n         SF    (PROT,NUM)\n         DC    C'|'\n         DC    CL29' SUN MON TUE WED THU FRI SAT'\n         DC    C'|'\nR09C09   SBA   9,9\n         SF    (PROT,NUM)\n         DC    C'|'\n         DC    29C'-'\n         DC    C'|'\nR10C09   SBA   10,9\n         SF    (PROT,NUM)\n         DC    C'|'\nLINE1    DC    29C' '\n         DC    C'|'\nR11C09   SBA   11,9\n         SF    (PROT,NUM)\n         DC    C'|'\n         DC    29C' '\n         DC    C'|'\nR12C09   SBA   12,9\n         SF    (PROT,NUM)\n         DC    C'|'\nLINE2    DC    29C' '\n         DC    C'|'\nR13C09   SBA   13,9\n         SF    (PROT,NUM)\n         DC    C'|'\n         DC    29C' '\n         DC    C'|'\nR14C09   SBA   14,9\n         SF    (PROT,NUM)\n         DC    C'|'\nLINE3    DC    29C' '\n         DC    C'|'\nR15C09   SBA   15,9\n         SF    (PROT,NUM)\n         DC    C'|'\n         DC    29C' '\n         DC    C'|'\nR16C09   SBA   16,9\n         SF    (PROT,NUM)\n         DC    C'|'\nLINE4    DC    29C' '\n         DC    C'|'\nR17C09   SBA   17,9\n         SF    (PROT,NUM)\n         DC    C'|'\n         DC    29C' '\n         DC    C'|'\nR18C09   SBA   18,9\n         SF    (PROT,NUM)\n         DC    C'|'\nLINE5    DC    29C' '\n         DC    C'|'\nR19C09   SBA   19,9\n         SF    (PROT,NUM)\n         DC    C'|'\n         DC    29C' '\n         DC    C'|'\nR20C09   SBA   20,9\n         SF    (PROT,NUM)\n         DC    C'|'\nLINE6    DC    29C' '\n         DC    C'|'\nR21C09   SBA   21,9\n         SF    (PROT,NUM)\n         DC    C'+'\n         DC    29C'-'\n         DC    C'+'\nSCRLEN   EQU   *-SCREEN\nYEAR1    EQU   R06C09+7\nYEAR2    EQU   MONTH+14\nAREA     DC    CL4' '\nEDTAREA  DS    CL4\nEDTCDE   DC    X'40202020'\nCDAY     DS    PL2\n         DC    PL2'0'              DUMMY AREA FOR COUNTER\nNUMAREA  DC    42PL2'0'\nCYMDDATE DS    CL8\nDAY      DS    CL9\nDAYNUM   DS    CL1\nMONTHTAB DC    CL9' JANUARY'\n         DC    CL9'FEBRUARY'\n         DC    CL9'  MARCH'\n         DC    CL9'  APRIL'\n         DC    CL9'   MAY'\n         DC    CL9'  JUNE'\n         DC    CL9'  JULY'\n         DC    CL9' AUGUST'\n         DC    CL9'SEPTEMBER'\n         DC    CL9' OCTOBER'\n         DC    CL9'NOVEMBER'\n         DC    CL9'DECEMBER'\nLOOPCTR  DC    AL1(31)\n         DC    AL1(28)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\nLINEADDR DC    A(LINE1)\n         DC    A(LINE2)\n         DC    A(LINE3)\n         DC    A(LINE4)\n         DC    A(LINE5)\n         DC    A(LINE6)\nGUS007   CALL  ,(CYMDDATE,DAY,DAYNUM),VL,MF=L\n         DS    0D\nWORK     DS    1F\n         DS    1F\nDATAREA0 DS    CL12\nDATAREA  DS    PL4                 0Y YM MD DF\nDATAREA2 DS    PL8                 00 00 00 0C CY YM M0 1F\n         DS    1D\nCMDLINE  DSECT\nLINELEN  DS    1H\nCMDLEN   DS    1H\nCOMMAND  DS    C\nPARMS    DSECT\n         DS    C\n         IKJCPPL\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FLPRT": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\t\\x01\\x002\\x0f\\x01\\x05\\x11/\\x00\\x16\\x00\\xa6\\x00\\xa7\\x00\\x14\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2000-11-15T00:00:00", "modifydate": "2005-04-22T00:16:09", "lines": 166, "newlines": 167, "modlines": 20, "user": "SPGSRS"}, "text": "FLEPRT   EPA   'PRINTS A SEQUENTIAL DATASET'\n         BALR  12,0                12 IS BASE REGISTER\n         USING *,12                TELL ASSEMBLER\n         ST    13,STACK+4          SAVE CALLER'S SVAREA ADDRESS\n         LA    10,STACK            LOAD SAVE AREA JUST IN CASE\n         ST    10,8(,13)           SET BACKWARD CHAIN\n         LR    13,10               SET FORWARD CHAIN\n         RDJFCB SYSUT1             SET UP JFCB TO OBTAIN DSNAME\n         OPEN  (SYSUT1,,LPPRINT,OUTPUT)\n         MVC   HDSNAME(44),JFCBDSNM\n         CLI   JFCBELNM,C' '       ANY MEMBER NAME??\n         BE    GETRECFM            NONE SPECIFIED\n         LA    11,HDSNAME+43       LAST CHARACTER OF DSNAME\nNONSPC   CLI   0(11),C' '\n         BNE   MVMEM               FOUND ADDDRESS OF LAST CHAR\n         BCT   11,NONSPC           CHECK BACKWARDS FROM HERE\nMVMEM    MVC   1(10,11),=C'  MEMBER ='\n         MVC   12(8,11),JFCBELNM\nGETRECFM CLI   DCBRECFM,X'C0'      THIS ROUTINE\n         BNE   FMTRTN              WILL GET THE\n         MVI   PRECFM,C'U'         RECORD FORMAT\n         B     GETDCB\nFMTRTN   CLI   DCBRECFM,X'00'\n         BNE   *+14\n         MVC   PRECFM(2),=C'**'\n         B     GETDCB\n         LA    2,PRECFM\n         LA    3,TBL1              VALUES\n         XR    4,4\n         IC    4,=X'80'            BIT SWITCH\n         LA    5,7                 LOOP COUNTER\nLOOP     EX    4,TEST              TEST IF SWITCH IS ON\n         BNO   ITER                GET NEXT FORM\n         MVC   0(1,2),0(3)         SET RECFM DESC\n         LA    2,1(,2)             NEXT COL\nITER     LA    3,1(,3)             NEXT VALUE\n         SRL   4,1                 NEXT SWITCH\n         BCT   5,LOOP\nGETDCB   LH    2,DCBBLKSI\n         CVD   2,DWAL\n         MVC   EDTAREA(8),EDTCDE\n         ED    EDTAREA(8),DWAL+4\n         MVC   PBLKSI(6),EDTAREA+2\n         LH    2,DCBLRECL          HOW LONG ?\n         STH   2,RECLEN\n         CVD   2,DWAL\n         MVC   EDTAREA(8),EDTCDE\n         ED    EDTAREA(8),DWAL+4\n         MVC   PRECL(6),EDTAREA+2\n         LH    0,DCBLRECL\n         GETMAIN R,LV=(0)\n         USING RECAREA,10          TELL ASSEMBLER WHERE WORK AREA IS\n         LR    10,1                INITIALIZE BASE REGISTER\n         CH    2,=H'120'\n         BH    F1\n         STH   2,LINLEN\nF1       ZAP   LCTR(2),=P'66'\nNXTREC   GET   SYSUT1,RECAREA\n         AP    RCTR(4),=P'1'       COUNT THIS RECORD\n         MVC   PAREA+1(8),EDTCDE\n         ED    PAREA+1(8),RCTR\n         LR    8,10                GET BUFFER ADDRESS\n         LH    9,DCBLRECL          LOAD RECLEN\n         CH    9,LINLEN            RECORDS WITH NO CONTINUATIONS\n         BNH   PAD                 SHOULD BE SINGLE SPACED\n         MVI   PAREA,C'0'          SET CONTROL CHARACTER\nPAD      O     9,=X'40000000'      PUT PADDING CHARACTER\nNXTLIN   AP    LCTR(2),=P'1'       ALLOC FOR NEW LINE\n         CLI   PAREA,C'0'          DOUBLE SPACED ?\n         BNE   CONT                NO IF ITS A CONTINUATION LINE\n         AP    LCTR(2),=P'1'       TELL LINE COUNTER IT'S DOUBLE SPACED\nCONT     CP    LCTR(2),=P'60'      BE SURE IT FITS THE PAGE\n         BL    NOHEAD\n         BAL   14,$$HDG\n         MVC   PAREA+1(8),EDTCDE   RE-EDIT BECAUSE REC. NUM WAS\n         ED    PAREA+1(8),RCTR     WIPED OUT\nNOHEAD   LA    6,PAREA+10\n         LH    7,LINLEN\n         MVCL  6,8                 MOVE THE RECORD\n         BAL   14,$$PLN            & PRINT IT\n         MVI   PAREA,C' '          SINGLE SPACE CONTINUATION LINES\n         MVC   PAREA+1(9),PAREA    & CLEAR LINE NO. FIELD\n         C     9,=X'40000000'      MORE CHARACTERS ?\n         BNE   NXTLIN\n         B     NXTREC\nEOD      CLOSE (SYSUT1,,LPPRINT)\n         LH    0,RECLEN\n         FREEMAIN R,LV=(0),A=(10) FREE VS USED\n         L     13,STACK+4\n         LM    14,12,12(13)        RESTORE AND\n         XR    15,15               SET RC = 0\n         BR    14                  QUIT\n* SUBROUTINES\n$$HDG    EQU   *                   HEADING ROUTINE\n         ST    14,SVAREA\n         BAL   14,$$SPC\n         MVC   PAREA+10(H1LEN),HDG\n         MVI   PAREA,C'1'          SET PAGE EJECT\n         BAL   14,$$PLN\n         MVC   PAREA+10(LN2LEN),LIN2\n         MVI   PAREA,C'0'          SET CONTROL CHARACTER\n         BAL   14,$$PLN\n         BAL   14,$$SPC\n         STM   4,7,SVAREA2\n         LA    4,PAREA+1\n         LH    5,LINLEN\n         A     5,=F'9'             ADD OFFSET OF MARGIN\n         LA    6,RULER\n         LR    7,5\n         MVCL  4,6\n         LM    4,7,SVAREA2\n         BAL   14,$$PLN\n         ZAP   LCTR(2),=P'6'\n         MVI   PAREA,C' '\n         L     14,SVAREA\n         BR    14\n$$SPC    MVI   PAREA+1,X'40'\n         MVC   PAREA+2(131),PAREA+1\n         BR    14\n$$PLN    ST    14,SVAREA+4\n         PUT   LPPRINT,PAREA\n         L     14,SVAREA+4\n         BR    14\nSTACK    DS    18F\nSVAREA   DS    2F\nSVAREA2  DS    4F\nUT1EXIT  DC    X'87'\n         DC    AL3(INFMJFCB)\n         IEFJFCBN LIST=YES\nPAREA    DC    133C' '\nRECLEN   DS    1H\nLINLEN   DC    1H'100'\nRCTR     DC    PL4'0'\nLCTR     DS    PL2\nDWAL     DS    1D\nEDTAREA  DS    CL8\nHDG      DC    C'CARD IMAGE OF '\nHDSNAME  DC    44C' '\n         DS    C'  MEMBER = XXXXXXXX'\nH1LEN    EQU   *-HDG\nLIN2     DC    C'RECORD LENGTH ='\nPRECL    DS    CL6\n         DC    C'     BLOCK LENGTH ='\nPBLKSI   DS    CL6\n         DC    C'     RECORD FORMAT = '\nPRECFM   DC    CL5' '\nLN2LEN   EQU   *-LIN2\nEDTCDE   DC    X'4020202020202020'\nRULER    DC    C'  REC #  '\n         DC    C'....+....1....+....2....+....3'\n         DC    C'....+....4....+....5....+....6'\n         DC    C'....+....7....+....8....+....9'\n         DC    C'....+....0....+....1....+....2'\nTBL1     DC    C'FVTBSAM'\n         PRINT NOGEN\nTEST     TM    DCBRECFM,X'00'\nSYSUT1   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=GM,EXLST=UT1EXIT,          X\n               EODAD=EOD\nDCBBLKSI EQU   SYSUT1+62\nDCBLRECL EQU   SYSUT1+82\nDCBRECFM EQU   SYSUT1+X'24'\nLPPRINT  DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,                      X\n               BLKSIZE=133,LRECL=133,                                  X\n               RECFM=FA\nRECAREA  DSECT\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GETCPUID": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00U\\x01\\x04!\\x9f\\x01\\x06\\x02\\x1f\\x11\\x17\\x003\\x00 \\x003\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2004-08-06T00:00:00", "modifydate": "2006-01-21T11:17:55", "lines": 51, "newlines": 32, "modlines": 51, "user": "SPGSRS"}, "text": "*\n* THIS ROUTINE GETS THE CPUID OF A MACHINE THAT'S RUNNING MVS.\n*\n* CONTROL BLOCK CHAIN:                       MAP\n* CVTPTR -> CVT                             (CVT)\n*           CVTPCCAT-> PCCAVT               (IHAPCCAT)\n*                      PCCAT00P-> PCCA\n*                       ...        ...\n*                      PCCAT15P-> PCCA      (IHAPCCA)\n*                                 PCCACPID = CPU SERIAL NUMBER\n*\n*\n* USAGE:  CALL 'GETCPUID' USING CPU-SERIALS.\n*\n* WHERE:  01  CPU-SERIALS.\n*             02 CPU-ID    PIC X(12) OCCURS 16.\n*\n* FOR A POSSIBLE 16 CPU PER MACHINE\n*\n* CPU-ID (IX+1) WILL CONTAIN HIGH-VALUES IF CPU-ID (IX) IS THE\n* LAST AVAILABLE CPU FOR THIS MACHINE.\n*\n* AUTHOR: ST. MON.\n*\nGETCPUID EPA   'GET THE CPU ID FROM MVS',AMODE=ANY,RMODE=ANY\n         BALR  12,0\n         USING *,12\n*\n* WE'RE NOT CALLING ANYTHING SO NO NEED TO SET UP A REGISTER SAVEAREA\n*\n         L     2,0(,1)            GET ADDRESS OF PARM AREA\n         MVI   0(2),X'FF'\n         MVC   1(191,2),0(2)      INITIALIZE TO HIGH-VALUES\n         L     3,CVTPTR\n         L     3,CVTPCCAT-CVT(,3) GET ADDRESS OF CCA VECTOR TABLE\n         LA    5,16               POSSIBLE 16 CPUS FOR THIS MACHINE\nLOOP     EQU   *\n         ICM   4,B'1111',0(3)     ANY MORE CPUS?\n         BZ    RETURN             NO MORE CPUS AVAILABLE\n         MVC   0(12,2),PCCACPID-PCCA(4) MOVE CPUID TO PARAMETER AREA\n         LA    3,4(,3)            NEXT CCA\n         LA    2,12(,2)           NEXT CPUID SLOT\n         BCT   5,LOOP\n*\nRETURN   XR    15,15\n         RETURN (14,12),RC=(15)\n*\n         CVT   DSECT=YES\n         IHAPCCAT\n         IHAPCCA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GUS002": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x02\\x07\\x8f\\x01\\x02\\x07\\x8f\"X\\x00g\\x00g\\x00\\x00\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-19T00:00:00", "modifydate": "2002-03-19T22:58:21", "lines": 103, "newlines": 103, "modlines": 0, "user": "SPGSRS"}, "text": "***********************************************\n*                                             *\n*  PARMS:                                     *\n*       YYMMDD = PL4 PD    INPUT              *\n*       YYDDD  = PL4 PD    RETURNED           *\n*       RC     = 1F BINARY RETURNED OPTIONAL  *\n*  REGISTERS ON RETURN:                       *\n*     1 - 14   AS IS                          *\n*     15       RETURN CODE                    *\n*              0 NORMAL                       *\n*              8 INPUT DATE IS INVALID        *\n*                                             *\n***********************************************\nGUS002   EPA   'CONVERTS YYMMDD TO YYDDD FORMAT'\n         BALR  12,0                12 IS BASE REGISTER\n         USING *,12                TELL ASSEMBLER\n         USING WORKSTG,11\n         USING LINKAGE,10\n         LR    10,1\n         LA    0,WKLEN\n         GETMAIN R,LV=(0)          ALLOC VS FOR WS STORAGE\n         LR    11,1\n         ST    13,STACK+4          SAVE CALLER'S SVAREA ADDRESS\n         LA    9,STACK             LOAD SAVE AREA JUST IN CASE\n         ST    9,8(,13)            SET BACKWARD CHAIN\n         LR    13,9                SET FORWARD CHAIN\n         L     2,IEFIN\n         L     8,IEFOUT\n         MVC   F2(2),0(2)          GET YEAR FIELD\n         OI    F2+1,X'0F'          PACK IT\n         ZAP   WORK(8),F2(2)       CLEAR WORK FIELD\n         MP    WORK(8),=P'1000'    SET UP YY PART\n         MVC   0(4,8),WORK+4       FILL RESULT FIELD W/ YY PART\n         ZAP   WORK(4),F2(2)\n         DP    WORK(4),=P'4'       CHECK IF DIVISIBLE BY 4\n         MVI   LYI,C'0'            DEFAULT = NOT LEAP YEAR\n         CP    WORK+3(1),=P'0'     LEAP YEAR ?\n         BNE   *+8                 NO\n         MVI   LYI,C'1'\n         MVC   F2(2),1(2)          GET MONTH FIELD\n         NI    F2,X'0F'            EDIT IT\n         OI    F2+1,X'0F'          PACK IT\n         CP    F2(2),=P'1'         MM < 1\n         BL    INVALID\n         CP    F2(2),=P'12'        MM > 12\n         BH    INVALID\n         ZAP   SVMM(2),F2(2)       SAVE MM, PACKED UNSIGNED\n         ZAP   WORK(8),F2(2)\n         CVB   4,WORK              USE MM AS INDEX\n         AR    4,4                 FIX OFFSET\n         LA    3,TBL1-2(4)         LOCATE CELL\n         XR    5,5\n         ICM   5,3,0(3)            GET TBL1(MM) VALUE\n         CVD   5,WORK              & PACK IT\n         AP    0(4,8),WORK+4(4)    ADD MONTH OFFSET\n         MVC   F2(2),2(2)          GET DAY FIELD\n         NI    F2,X'0F'            EDIT IT\n         AP    0(4,8),F2(2)        ADD WHAT REMAINS\n         CLI   LYI,C'0'            WAS THAT A LEAP YEAR ?\n         BE    EXIT                NO, EXIT\n         CP    SVMM(2),=P'2'\n         BNH   EXIT\n         AP    0(4,8),=P'1'\nEXIT     OI    3(8),X'0F'          PACK RESULT UNSIGNED\n         LR    9,15                SAVE RETURN CODE\n         TM    IEFOUT,X'80'        LAST PARM ?\n         BO    *+12                YEAH\n         L     8,IEFRC             GET RC ADDRESS\n         ST    9,0(,8)             PASS RC IF REQUESTED\n         L     13,STACK+4\n         LA    0,WKLEN\n         FREEMAIN R,LV=(0),A=(11)\n         LR    15,9                SET RC\n         RETURN (14,12),,RC=(15)   RESTORE AND QUIT\nINVALID  LA    15,8\n         B     EXIT\nTBL1     DC    AL2(0)\n         DC    AL2(31)\n         DC    AL2(59)\n         DC    AL2(90)\n         DC    AL2(120)\n         DC    AL2(151)\n         DC    AL2(181)\n         DC    AL2(212)\n         DC    AL2(243)\n         DC    AL2(273)\n         DC    AL2(304)\n         DC    AL2(334)\n         LTORG\nWORKSTG  DSECT\nSTACK    DS    18F\n         DS    0D                  DOUBLE WORD ALIGN\nWORK     DS    1F\n         DS    1F\nF2       DS    CL2\nSVMM     DS    CL2\nLYI      DS    CL1                 LEAP YEAR INDICATOR\nWKLEN    EQU   *-WORKSTG\nLINKAGE  DSECT\nIEFIN    DS    A\nIEFOUT   DS    A\nIEFRC    DS    A\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GUS004": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x07\\x01\\x02\\x07\\x8f\\x01\\x02\\x07\\x8f#\\x00\\x00t\\x00t\\x00\\x00\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-19T00:00:00", "modifydate": "2002-03-19T23:00:07", "lines": 116, "newlines": 116, "modlines": 0, "user": "SPGSRS"}, "text": "***********************************************\n*                                             *\n*  PARMS:                                     *\n*       YYDDD  = PL4 PD    INPUT              *\n*       YYMMDD = PL4 PD    RETURNED           *\n*       RC     = 1F BINARY RETURNED OPTIONAL  *\n*  REGISTERS ON RETURN:                       *\n*     1 - 14   AS IS                          *\n*     15       RETURN CODE                    *\n*              0 NORMAL                       *\n*              8 INPUT DATE IS INVALID        *\n*                                             *\n***********************************************\nGUS004   EPA   'CONVERTS YYDDD TO YYMMDD FORMAT '\n         LR    12,15               12 IS BASE REGISTER\n         USING GUS004,12           TELL ASSEMBLER\n         USING WORKSTG,11\n         USING LINKAGE,10\n         LR    10,1\n         LA    0,WKLEN\n         GETMAIN R,LV=(0)          ALLOC VS FOR WS STORAGE\n         LR    11,1\n         ST    13,STACK+4          SAVE CALLER'S SVAREA ADDRESS\n         LA    9,STACK             LOAD SAVE AREA JUST IN CASE\n         ST    9,8(,13)            SET BACKWARD CHAIN\n         LR    13,9                SET FORWARD CHAIN\n         L     2,IEFIN\n         L     8,IEFOUT\n         XR    3,3\n         ICM   3,3,1(2)            GET YY FIELD\n         SRL   3,4                 SET TO PACK\n         STCM  3,3,F2              SAVE YEAR FIELD (YY0)\n         OI    F2+1,X'0F'          PACK IT         (YYF)\n         ZAP   WORK(8),F2(2)       CLEAR WORK FIELD\n         MP    WORK(8),=P'10000'   SET UP YY PART\n         MVC   0(4,8),WORK+4       FILL RESULT FIELD W/ YY PART\n         ZAP   WORK(4),F2(2)\n         DP    WORK(4),=P'4'       CHECK IF DIVISIBLE BY 4\n         MVI   LYI,C'0'            DEFAULT = NOT LEAP YEAR\n         CP    WORK+3(1),=P'0'     LEAP YEAR ?\n         BNE   GETDDD              NO\n         MVI   LYI,C'1'\nGETDDD   MVC   F2(2),2(2)          GET MONTH FIELD\n         CP    F2(2),=P'366'       INVALID DATE ?\n         BH    INVALID             REJECT\n         ZAP   WORK(8),F2(2)       GET MONTH & DAY\n         CVB   3,WORK\n         LA    2,12                LOOP COUNTER; 12 CHARS\n         LA    6,TBL1-2            DATE ARRAY\n         CLI   LYI,C'0'\n         BE    LOOP1\n         LA    6,TBL2-2            DATE ARRAY\nLOOP1    LR    4,2                 LOAD INDEX REGISTER\n         AR    4,4                 FIX OFFSET\n         LH    7,0(4,6)            GET MM(IX) WHERE IX=R4\n         CR    3,7\n         BH    SAVMM\n         BCT   2,LOOP1\n         B     INVALID\nSAVMM    CVD   2,WORK              CONVERT MONTH BINARY TO PACKED\n         MP    WORK(8),=P'100'     SET UP MM FIELD\n         AP    0(4,8),WORK+4(4)    SAVE IT IN RESULT FIELD\n         SR    3,7                 GET DAY\n         CVD   3,WORK              & PACK IT\n         AP    0(4,8),WORK+4(4)    ADD DAY\n         OI    3(8),X'0F'          PACK RESULT UNSIGNED\nEXIT     LR    9,15                SAVE RETURN CODE\n         TM    IEFOUT,X'80'        LAST PARM ?\n         BO    *+12                YEAH\n         L     8,IEFRC             GET RC ADDRESS\n         ST    9,0(8)              PASS RC IF REQUESTED\n         L     13,STACK+4\n         LA    0,WKLEN\n         FREEMAIN R,LV=(0),A=(11)\n         LR    15,9                SET RC\n         RETURN (14,12),,RC=(15)   RESTORE AND QUIT\nINVALID  LA    15,8\n         B     EXIT\nTBL1     DC    AL2(0)              DAYS TABLE FOR NON LEAP YEARS\n         DC    AL2(31)\n         DC    AL2(59)\n         DC    AL2(90)\n         DC    AL2(120)\n         DC    AL2(151)\n         DC    AL2(181)\n         DC    AL2(212)\n         DC    AL2(243)\n         DC    AL2(273)\n         DC    AL2(304)\n         DC    AL2(334)\nTBL2     DC    AL2(0)              DAYS TABLE FOR LEAP YEARS\n         DC    AL2(31)\n         DC    AL2(60)\n         DC    AL2(91)\n         DC    AL2(121)\n         DC    AL2(152)\n         DC    AL2(182)\n         DC    AL2(213)\n         DC    AL2(244)\n         DC    AL2(274)\n         DC    AL2(305)\n         DC    AL2(335)\n         LTORG\nWORKSTG  DSECT\nSTACK    DS    18F\n         DS    0D                  DOUBLE WORD ALIGN\nWORK     DS    1F\n         DS    1F\nF2       DS    CL2\nLYI      DS    CL1                 LEAP YEAR INDICATOR\nWKLEN    EQU   *-WORKSTG\nLINKAGE  DSECT\nIEFIN    DS    A\nIEFOUT   DS    A\nIEFRC    DS    A\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GUS005": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x02\\x07\\x8f\\x01\\x02\\x07\\x8f#\\x04\\x00\\xbe\\x00\\xbe\\x00\\x00\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-19T00:00:00", "modifydate": "2002-03-19T23:04:56", "lines": 190, "newlines": 190, "modlines": 0, "user": "SPGSRS"}, "text": "***********************************************\n*                                             *\n*  PARMS:                                     *\n*       AMOUNT = PIC 9(8)V99 INPUT            *\n*       TEXT   = PIC X(100)  RETURNED         *\n*       RC     = 1F BINARY RETURNED OPTIONAL  *\n*  REGISTERS ON RETURN:                       *\n*     1 - 14   AS IS                          *\n*     15       RETURN CODE                    *\n*                                             *\n***********************************************\n         MACRO\n&LABEL   TEENS &WORD\n         LCLA  &LEN\n&LEN     SETA  K'&WORD-1\n         DC    AL1(&LEN)           LENGTH LESS 1 FOR MVC INSTR\n         DC    CL9'&WORD'          AMOUNT IN WORDS\n         MEND\n         MACRO\n&LABEL   TENS  &WORD\n         LCLA  &LEN\n&LEN     SETA  K'&WORD-1\n         DC    AL1(&LEN)           LENGTH LESS 1 FOR MVC INSTR\n         DC    CL7'&WORD'          AMOUNT IN WORDS\n         MEND\nGUS005   EPA   'CONVERTS AMOUNTS TO WORDS '\n         BALR  12,0                12 IS BASE REGISTER\n         USING *,12                TELL ASSEMBLER\n         USING WORKSTG,11\n         USING LINKAGE,10\n         LR    10,1\n         LA    0,WKLEN\n         GETMAIN R,LV=(0)          ALLOC VS FOR WS STORAGE\n         LR    11,1\n         ST    13,STACK+4          SAVE CALLER'S SVAREA ADDRESS\n         LA    9,STACK             LOAD SAVE AREA JUST IN CASE\n         ST    9,8(,13)            SET BACKWARD CHAIN\n         LR    13,9                SET FORWARD CHAIN\n         L     2,IEFIN\n         L     8,IEFOUT\n         MVI   FLAG,C'0'\n         CLEAR (8),LEN=100         CLEAR OUTPUT FIELD\n         PACK  WORK(8),0(10,2)     PACK HIS NUMBER SO WE CAN WORK\n* MILLIONS ROUTINE\nM1       XR    7,7                 BIT BUCKET\n         XR    6,6                 WORK REGISTER\n         L     6,WORK\n         SRDL  6,4                 LEAVE TEN MILLIONS PART IN R6\n         LTR   6,6\n         BZ    HT1                 GO TO HUNDRED THOUSAND ROUTINE\n         CH    6,=H'32'\n         BL    M2\n         SRDL  6,4                 LEAVE TENS UNITS IN R6\n         BAL   14,TENSRTN\n         SLDL  6,4                 GET ONES UNITS IN R6\n         LTR   6,6\n         BZ    MILLEND\nM2       CH    6,=H'16'            10 BINARY = 16\n         BL    *+8\n         SH    6,=H'6'             CHANGE DECIMAL TO BINARY\n         BAL   14,TEENSRTN\nMILLEND  MVTXT (8),'MILLION '\n         LA    8,8(,8)\nHT1      SLDL  6,4                 GET ONES UNITS IN R6\n         LTR   6,6\n         BZ    HT2\n         MVI   FLAG,C'1'\n         BAL   14,TEENSRTN\n         MVTXT (8),'HUNDRED '\n         LA    8,8(,8)\nHT2      IC    6,WORK+4\n         LTR   6,6\n         BZ    HTEND1              GO TO ONE HUNDRED ROUTINE\n         CH    6,=H'32'\n         BL    HT3\n         SRDL  6,4                 LEAVE TENS UNITS IN R6\n         BAL   14,TENSRTN\n         SLDL  6,4                 GET ONES UNITS IN R6\n         LTR   6,6\n         BZ    HTEND\nHT3      CH    6,=H'16'            10 BINARY = 16\n         BL    *+8\n         SH    6,=H'6'             CHANGE DECIMAL TO BINARY\n         BAL   14,TEENSRTN\n         B     HTEND\nHTEND1   CLI   FLAG,C'0'\n         BE    H1\nHTEND    MVTXT (8),'THOUSAND '\n         LA    8,9(,8)\nH1       ICM   7,12,WORK+5\n         SLDL  6,4                 LEAVE ONE HUNDRED PART IN R6\n         LTR   6,6\n         BZ    T1                  GO TO TENS ROUTINE\n         BAL   14,TEENSRTN\n         MVTXT (8),'HUNDRED '\n         LA    8,8(,8)\nT1       SLDL  6,8                 GET TENS UNITS IN R6\n         LTR   6,6\n         BZ    TEND                GO TO END OF NUMERIC ROUTINE\n         CH    6,=H'32'\n         BL    T2\n         SRDL  6,4                 LEAVE TENS UNITS IN R6\n         BAL   14,TENSRTN\n         SLDL  6,4                 GET ONES UNITS IN R6\n         LTR   6,6\n         BZ    TEND\nT2       CH    6,=H'16'            10 BINARY = 16\n         BL    *+8\n         SH    6,=H'6'             CHANGE DECIMAL TO BINARY\n         BAL   14,TEENSRTN\nTEND     L     2,IEFIN\n         CLC   8(2,2),=C'00'       NO DECIMAL PART?\n         BE    EXIT\n         MVTXT (8),'AND '\n         MVC   4(2,8),8(2)\n         MVC   6(4,8),=C'/100'\nEXIT     LR    9,15                SAVE RETURN CODE\n         TM    IEFOUT,X'80'        LAST PARM ?\n         BO    *+12                YEAH\n         L     8,IEFRC             GET RC ADDRESS\n         ST    9,0(,8)             PASS RC IF REQUESTED\n         L     13,STACK+4\n         LA    0,WKLEN\n         FREEMAIN R,LV=(0),A=(11)\n         LR    15,9                SET RC\n         RETURN (14,12),,RC=(15)   RESTORE AND QUIT\nINVALID  LA    15,8\n         B     EXIT\nTEENSRTN EQU   *\n         LR    2,6\n         MH    2,=H'10'            OFFSET OF 10 BYTE WORD\n         LA    5,TEENS(2)\n         B     F001                BRANCH TO COMMON ROUTINE\nTENSRTN  EQU   *\n         LR    2,6\n         MH    2,=H'8'             OFFSET OF 8 BYTE WORD\n         LA    5,TENS(2)           GET CELL\nF001     XR    3,3\n         IC    3,0(5)              GET LENGTH OF THIS TEXT\n         EX    3,MOVETXT\n         AR    8,3\n         LA    8,2(,8)\n         XR    6,6\n         BR    14\nMOVETXT  MVC   0(1,8),1(5)\nTEENS    EQU   *\n         TEENS ZERO\n         TEENS ONE\n         TEENS TWO\n         TEENS THREE\n         TEENS FOUR\n         TEENS FIVE\n         TEENS SIX\n         TEENS SEVEN\n         TEENS EIGHT\n         TEENS NINE\n         TEENS TEN\n         TEENS ELEVEN\n         TEENS TWELVE\n         TEENS THIRTEEN\n         TEENS FOURTEEN\n         TEENS FIFTEEN\n         TEENS SIXTEEN\n         TEENS SEVENTEEN\n         TEENS EIGHTEEN\n         TEENS NINETEEN\nTENS     EQU   *\n         TENS  ZERO\n         TENS  TEN\n         TENS  TWENTY\n         TENS  THIRTY\n         TENS  FORTY\n         TENS  FIFTY\n         TENS  SIXTY\n         TENS  SEVENTY\n         TENS  EIGHTY\n         TENS  NINETY\n         LTORG\nWORKSTG  DSECT\nSTACK    DS    18F\n         DS    0D                  DOUBLE WORD ALIGN\nWORK     DS    1F\n         DS    1F\nFLAG     DS    CL1                 FLAG FOR HUNDRED THOUSAND\nWKLEN    EQU   *-WORKSTG\nLINKAGE  DSECT\nIEFIN    DS    A\nIEFOUT   DS    A\nIEFRC    DS    A\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GUS007": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x08\\x01\\x02\\x07\\x8f\\x01\\x05\\x11\\x1f (\\x00k\\x00\\x8a\\x00k\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-03-19T00:00:00", "modifydate": "2005-04-21T20:28:08", "lines": 107, "newlines": 138, "modlines": 107, "user": "SPGSRS"}, "text": "***********************************************\n*                                             *\n*  PARMS:                                     *\n*       YYYYMMDD = PIC 9(8)                   *\n*       DAY1     = PIC X(9)                   *\n*                  DAY OF THE WEEK IN WORDS   *\n*       DAY2     = PIC 9(1)                   *\n*                  DAY OF THE WEEK IN CODE    *\n*                  0-SAT 1-SUN 2-MON ETC.     *\n*       RC     = 1F BINARY RETURNED OPTIONAL  *\n*  REGISTERS ON RETURN:                       *\n*     1 - 14   AS IS                          *\n*     15       RETURN CODE                    *\n*              0 NORMAL                       *\n*              8 INPUT DATE IS INVALID        *\n*                                             *\n***********************************************\nGUS007   EPA   'RETURNS THE DAY OF THE WEEK '\n         LR    12,15               12 IS BASE REGISTER\n         USING GUS007,12           TELL ASSEMBLER\n         USING WORKSTG,13\n         USING LINKAGE,11\n         LR    11,1\n         LA    0,WKLEN\n         GETMAIN R,LV=(0)          ALLOC VS FOR WS STORAGE\n         ST    13,4(,1)            SAVE CALLER'S SVAREA ADDRESS\n         ST    1,8(,13)            SET BACKWARD CHAIN\n         LR    13,1                SET FORWARD CHAIN\n*-\n*- USING ZELLER'S CONGRUENCE\n*-\n*- R7 = DD + TRUNC(((M + 1) * 26) / 10) + Y + (Y % 4)\n*- R7 = R7 + TRUNC(C / 4) + 5 * C\n*- DAYNR = R7 // 7\n*-\n         L     2,IEFIN\n         PACK  WORK(8),0(4,2)      SETUP R5->YYYY\n         CVB   5,WORK\n         PACK  WORK(8),4(2,2)      SETUP R7->MM\n         CVB   7,WORK\n         PACK  WORK(8),6(2,2)      SETUP R8->DD\n         CVB   8,WORK\n         CHI   7,2                 IF MM < 3 THEN DO\n         BH    F001                   MM = MM + 12\n         LA    7,12(,7)               YY = YY-1\n         BCTR  5,0                 END\nF001     LA    7,1(,7)             R7=MM+1\n         M     6,=F'26'            R7=(R7 * 26)\n         D     6,=F'10'            R7=R7 / 10\n         AR    7,8                 R7=R7 + DD\n         XR    4,4\n         D     4,=F'100'           R4=YY,R5=CC\n         AR    7,4                 R7=R7 + YY\n         LR    3,4\n         XR    2,2\n         D     2,=F'4'             R3=YY % 4\n         AR    7,3                 R7=R7 + (Y % 4)\n         LR    3,5\n         XR    2,2                 DISCARD REMAINDER\n         D     2,=F'4'             R3=CC % 4\n         AR    7,3                 R7=R7 + C/4\n         MHI   5,5                 5 * C\n         AR    7,5                 ADD EM ALL UP!\n         XR    6,6\n         D     6,=F'7'             R6=R7 // 7\n         LR    3,6                 R6=DAYNR\n         L     8,IEFOUT1           GET OUTPUT ADDRESS\n         MHI   3,9                 FIX LENGTH\n         LA    4,DAYTAB(3)         GET ADDRESS OF DAY TEXT\n         MVC   0(9,8),0(4)         PUT IT IN RESULT FIELD\n         TM    IEFOUT1,X'80'       WAS DAY CODE REQUESTED ?\n         BO    EXIT                NO, GO TO EXIT\n         L     8,IEFOUT2           GET OUTPUT ADDRESS\n         STC   6,0(,8)             STORE IT IN RESULT FIELD\n         OI    0(8),X'F0'          AND UNPACK IT\nEXIT     LR    9,15                SAVE RETURN CODE\n         TM    IEFOUT1,X'80'       LAST PARM ?\n         BO    *+20                YEAH\n         TM    IEFOUT2,X'80'       LAST PARM ?\n         BO    *+12                YEAH\n         L     8,IEFRC             GET RC ADDRESS\n         ST    9,0(8)              PASS RC IF REQUESTED\n         LR    1,13\n         L     13,4(,1)\n         LA    0,WKLEN\n         FREEMAIN R,LV=(0),A=(1)\n         LR    15,9                SET RC\n         RETURN (14,12),,RC=(15)   RESTORE AND QUIT\nDAYTAB   DC    CL9'SATURDAY'\n         DC    CL9'SUNDAY'\n         DC    CL9'MONDAY'\n         DC    CL9'TUESDAY'\n         DC    CL9'WEDNESDAY'\n         DC    CL9'THURSDAY'\n         DC    CL9'FRIDAY'\n         LTORG\nWORKSTG  DSECT\n         DS    18F\nWORK     DS    D\nWKLEN    EQU   *-WORKSTG\n*\nLINKAGE  DSECT\nIEFIN    DS    A\nIEFOUT1  DS    A\nIEFOUT2  DS    A\nIEFRC    DS    A\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GUS008": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x000\\x01\\x02\\x07\\x8f\\x01\\x02\\x07\\x8f#\\x11\\x00\\x85\\x00\\x85\\x00\\x00\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-19T00:00:00", "modifydate": "2002-03-19T23:11:30", "lines": 133, "newlines": 133, "modlines": 0, "user": "SPGSRS"}, "text": "***********************************************\n*                                             *\n*  PARMS:                                     *\n*       YYYYMMDD1 = PIC 9(8)                  *\n*       YYYYMMDD2 = PIC 9(8)                  *\n*       # OF DAYS = PIC 9(6) COMP-3           *\n*           NO. OF DAYS BETWEEN PARM1 & PARM2 *\n*       RC     = 1F BINARY RETURNED OPTIONAL  *\n*  REGISTERS ON RETURN:                       *\n*     1 - 14   AS IS                          *\n*     15       RETURN CODE                    *\n*              0 NORMAL                       *\n*              8 INPUT DATE IS INVALID        *\n*                                             *\n***********************************************\nGUS008   EPA   'COMPUTES THE NO. OF DAYS BETWEEN 2 DATES'\n         LR    12,15               12 IS BASE REGISTER\n         USING GUS008,12           TELL ASSEMBLER\n         USING WORKSTG,11\n         USING LINKAGE,10\n         LR    10,1\n         LA    0,WKLEN\n         GETMAIN R,LV=(0)          ALLOC VS FOR WS STORAGE\n         LR    11,1\n         ST    13,STACK+4          SAVE CALLER'S SVAREA ADDRESS\n         LA    9,STACK             LOAD SAVE AREA JUST IN CASE\n         ST    9,8(,13)            SET BACKWARD CHAIN\n         LR    13,9                SET FORWARD CHAIN\n         L     2,IEFIN1\n         LA    3,DAYS1\n         BAL   9,DAYCALC\n         L     2,IEFIN2            GET NEXT PARM\n         LA    3,DAYS2\n         BAL   9,DAYCALC\n         L     8,IEFOUT            GET CALLERS RESULT FIELD\nGETDIFF  SP    DAYS1(8),DAYS2(8)   GET DIFFERENCE OF DATES\n         ZAP   0(4,8),DAYS1(8)     PUT IT IN RESULT FIELD\n         OI    3(8),X'0F'          PACK RESULT UNSIGNED\nEXIT     LR    9,15                SAVE RETURN CODE\n         TM    IEFOUT,X'80'        LAST PARM ?\n         BO    *+12                YEAH\n         L     8,IEFRC             GET RC ADDRESS\n         ST    9,0(,8)             PASS RC IF REQUESTED\n         L     13,STACK+4\n         LA    0,WKLEN\n         FREEMAIN R,LV=(0),A=(11)\n         LR    15,9                SET RC\n         RETURN (14,12),,RC=(15)   RESTORE AND QUIT\n*\n* REGISTERS TO BE USED ON THE DAYCALC SUBROUTINE:\n* R2---POINTER TO INPUT PARAMETER\n* R3---POINTER TO NO. OF DAYS IN PARM POINTED TO BY R2\n* R9---POINTER TO DAYCALC RETURN ADDRESS\n*\nDAYCALC  EQU   *                   DAYCALC SUBROUTINE\n         PACK  WORK(8),0(4,2)      SET UP YYYY PART\n         DP    WORK(8),=P'4'       CHECK IF DIVISIBLE BY 4\n         MVI   LYI,C'0'            DEFAULT = NOT LEAP YEAR\n         CP    WORK+7(1),=P'0'     LEAP YEAR ?\n         BNE   SETYY               NO\n         MVI   LYI,C'1'            SET TO LEAP YEAR\n         PACK  WORK(8),0(4,2)      SET UP YYYY PART\n         DP    WORK(8),=P'100'     CHECK IF DIVISIBLE BY 100\n         CP    WORK+6(2),=P'0'     CENTURY YEAR ?\n         BNE   SETYY               NO\n         MVI   LYI,C'0'            SET TO NOT LEAP YEAR\n         PACK  WORK(8),0(4,2)      SET UP YYYY PART\n         DP    WORK(8),=P'400'     CHECK IF DIVISIBLE BY 400\n         CP    WORK+6(2),=P'0'     CENTURY LEAP YEAR ?\n         BNE   SETYY               NO\n         MVI   LYI,C'1'            CENTURY IS A LEAP YEAR\nSETYY    PACK  WORK(8),0(4,2)      SET UP COUNTER PART\n         SP    WORK(8),=P'1'       MINUS 1 YEAR\n         MP    WORK(8),=P'36525'   GET JULIAN DAY\n         DP    WORK(8),=P'100'     DISCARD DECIMAL PART\n         ZAP   WORK2(8),WORK(6)\n         PACK  WORK(8),4(2,2)      GET MONTH\n         LA    6,TBL1-2            DATE ARRAY\n         CLI   LYI,C'0'\n         BE    F1\n         LA    6,TBL2-2            DATE ARRAY\nF1       CVB   4,WORK              LOAD INDEX REGISTER\n         AR    4,4                 FIX OFFSET\n         LH    7,0(4,6)            GET MM(IX) WHERE IX=R4\n         CVD   7,WORK\n         AP    WORK2(8),WORK(8)\n         PACK  WORK(8),6(2,2)      GET DAY FIELD\n         AP    WORK2(8),WORK(8)\n         ZAP   0(8,3),WORK2(8)     SAVE IT\n         BR    9                   RETURN TO CALLER\nTBL1     DS    0H                  HALFWORD ALIGN\n         DC    AL2(0)              DAYS TABLE FOR NON LEAP YEARS\n         DC    AL2(31)\n         DC    AL2(59)\n         DC    AL2(90)\n         DC    AL2(120)\n         DC    AL2(151)\n         DC    AL2(181)\n         DC    AL2(212)\n         DC    AL2(243)\n         DC    AL2(273)\n         DC    AL2(304)\n         DC    AL2(334)\nTBL2     DC    AL2(0)              DAYS TABLE FOR LEAP YEARS\n         DC    AL2(31)\n         DC    AL2(60)\n         DC    AL2(91)\n         DC    AL2(121)\n         DC    AL2(152)\n         DC    AL2(182)\n         DC    AL2(213)\n         DC    AL2(244)\n         DC    AL2(274)\n         DC    AL2(305)\n         DC    AL2(335)\n         LTORG\nWORKSTG  DSECT\nSTACK    DS    18F\n         DS    0D                  DOUBLE WORD ALIGN\nWORK     DS    1F                  /* WE NEED 2 8-BYTE WORK\n         DS    1F                  /* FIELDS SO THAT WE WILL NOT\nWORK2    DS    1F                  /* HAVE OVERFLOWS IN OUR MULTIPLY\n         DS    1F                  /* PACKED INSTRUCTIONS\nLYI      DS    CL1                 LEAP YEAR INDICATOR\nDAYS1    DS    PL8\nDAYS2    DS    PL8\nWKLEN    EQU   *-WORKSTG\nLINKAGE  DSECT\nIEFIN1   DS    A                   INPUT DATE1\nIEFIN2   DS    A                   INPUT DATE2\nIEFOUT   DS    A                   RESULT FIELD\nIEFRC    DS    A\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GUS009": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00B\\x01\\x02\\x07\\x8f\\x01\\x02\\x07\\x8f#\\x12\\x00b\\x00b\\x00\\x00\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-19T00:00:00", "modifydate": "2002-03-19T23:12:42", "lines": 98, "newlines": 98, "modlines": 0, "user": "SPGSRS"}, "text": "***********************************************\n*                                             *\n*  PARMS:                                     *\n*     YYYYMMDD = PIC 9(8)  INPUT              *\n*       RC     = 1F BINARY RETURNED OPTIONAL  *\n*  REGISTERS ON RETURN:                       *\n*     1 - 14   AS IS                          *\n*     15       RETURN CODE                    *\n*              0 NORMAL                       *\n*              8 INPUT DATE IS INVALID        *\n*                                             *\n***********************************************\nGUS009   EPA   'DATE VALIDATION ROUTINE'\n         BALR  12,0                12 IS BASE REGISTER\n         USING *,12                TELL ASSEMBLER\n         USING WORKSTG,11\n         USING LINKAGE,10\n         LR    10,1\n         LA    0,WKLEN\n         GETMAIN R,LV=(0)          ALLOC VS FOR WS STORAGE\n         LR    11,1\n         ST    13,STACK+4          SAVE CALLER'S SVAREA ADDRESS\n         LA    9,STACK             LOAD SAVE AREA JUST IN CASE\n         ST    9,8(,13)            SET BACKWARD CHAIN\n         LR    13,9                SET FORWARD CHAIN\n         L     2,IEFIN\n         XR    15,15\n         PACK  WORK(8),0(8,2)      GET YEAR FIELD\n         DP    WORK(8),=P'4'       CHECK IF DIVISIBLE BY 4\n         MVI   LYI,C'0'            DEFAULT = NOT LEAP YEAR\n         CP    WORK+7(1),=P'0'     LEAP YEAR ?\n         BNE   GETMM               NO\n         MVI   LYI,C'1'\n         PACK  WORK(8),0(8,2)      CHECK FOR CENTURY YEAR\n         DP    WORK(8),=P'100'     CHECK IF DIVISIBLE BY 100\n         CP    WORK+6(2),=P'0'     CENTURY YEAR ?\n         BNE   GETMM               NO\n         MVI   LYI,C'0'            DEFAULT = NOT LEAP YEAR\n         PACK  WORK(8),0(8,2)      CHECK FOR CENTURY YEAR\n         DP    WORK(8),=P'400'     CHECK IF DIVISIBLE BY 400\n         CP    WORK+6(2),=P'0'     LEAP YEAR ?\n         BNE   GETMM               NO\n         MVI   LYI,C'1'            SET TO LEAP YEAR\nGETMM    PACK  WORK(8),4(2,2)      GET MONTH FIELD\n         CP    WORK+4(4),=P'1'     MM < 1\n         BL    INVALID\n         CP    WORK+4(4),=P'12'    MM > 12\n         BH    INVALID\n         CVB   4,WORK              USE MM AS INDEX\n         XR    5,5\n         IC    5,TBL-1(4)          GET TBL1(MM) VALUE\n         CP    WORK+4(4),=P'2'     FEB ?\n         BNE   GETDD\n         CLI   LYI,C'1'            LEAP YEAR\n         BNE   GETDD\n         LA    5,1(,5)             ADD 1 DAY TO DAYS LIMIT\nGETDD    PACK  WORK(8),6(2,2)      GET DAY FIELD\n         CVB   6,WORK              CONVERT TO BINARY\n         LTR   6,6                 LESS THAN 1 DAY ?\n         BZ    INVALID\n         CR    5,6\n         BL    INVALID             UPPER LIMIT < GIVEN DAY\nEXIT     LR    9,15                SAVE RETURN CODE\n         TM    IEFIN,X'80'         LAST PARM ?\n         BO    *+12                YEAH\n         L     8,IEFRC             GET RC ADDRESS\n         ST    9,0(,8)             PASS RC IF REQUESTED\n         L     13,STACK+4\n         LA    0,WKLEN\n         FREEMAIN R,LV=(0),A=(11)\n         LR    15,9                SET RC\n         RETURN (14,12),,RC=(15)   RESTORE AND QUIT\nINVALID  LA    15,8\n         B     EXIT\nTBL      DC    AL1(31)\n         DC    AL1(28)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         LTORG\nWORKSTG  DSECT\nSTACK    DS    18F\n         DS    0D                  DOUBLE WORD ALIGN\nWORK     DS    1F\n         DS    1F\nLYI      DS    CL1                 LEAP YEAR INDICATOR\nWKLEN    EQU   *-WORKSTG\nLINKAGE  DSECT\nIEFIN    DS    A\nIEFRC    DS    A\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GUS012": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1b\\x00\\x19\\x01\\x01\\x08o\\x01\\x02\\x07\\x8f#\\x16\\x00\\xb1\\x00\\x9b\\x00K\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "01.27", "flags": 0, "createdate": "2001-03-27T00:00:00", "modifydate": "2002-03-19T23:16:19", "lines": 177, "newlines": 155, "modlines": 75, "user": "SPGSRS"}, "text": "*****************************************************************\n* GUS012 SUBROUTINE                                             *\n* PARAMETERS PASSED:                                            *\n*      FIELD      LENGTH         DESC                           *\n*     IOERRCD      1F           ERROR CODE; RETURNED            *\n*                                 CONSIST OF 2 HALF WORDS       *\n*                                 ERRCD AND INFO CODE           *\n*     IOFCODE      XL1          FUNCTION CODE;                  *\n*                                 X'01' - ALLOCATE              *\n*                                 X'02' - FREE                  *\n*     IODDNM       CL8          DDNAME                          *\n*     IODSNM       CL44         DSNAME                          *\n*     IOMEM        CL8          MEMBER NAME IF PO               *\n*     IOPASSW      CL8          PASSWORD IF PASSWORD PROTECTED  *\n*     IOVOLSER     CL6          VOLUME SERIAL IF NOT IN CATALOG *\n*                                                               *\n*****************************************************************\nGUS012   EPA   'ALLOCATES A PS DATASET'\n         BALR  12,0                12 IS BASE REGISTER\n         USING *,12                TELL ASSEMBLER\n         LR    9,1                 R9 WILL NOW HOLD PARMLIST ADDRS\n         USING PLIST,9             TELL ASSEMBLER\n         LA    0,WSLEN\n         GETMAIN R,LV=(0)          OBTAIN WORKING STORAGE AREA\n         ST    13,4(,1)            SAVE CALLER'S SVAREA ADDRESS\n         ST    1,8(,13)            LOAD SAVE AREA JUST IN CASE\n         LR    13,1\n         USING WKSTG,13\nGETVS    L     0,LVDATA\n         GETMAIN R,LV=(0)\n         LR    11,1                SET PARMAREA BASE ADDRESS\n         USING PARMAREA,11         TELL ASSEMBLER WHERE IT IS\n         MVI   RBLEN,X'14'\n         MVI   FCODE,X'01'         ALLOC\n         XR    0,0\n         STH   0,FLAG1\n         STH   0,ERROR\n         STH   0,INFO\n         ST    0,RSV01\n         ST    0,FLAG2\n* INITIALIZE PARAMETER LIST\n         MVC   DDNAMEP(6),=X'0001,0001,0008'\n         MVC   DSNAMEP(6),=X'0002,0001,002C'\n         MVC   MEMNAMEP(6),=X'0003,0001,0008'\n         MVC   PASSWRDP(6),=X'0050,0001,0008'\n         MVC   DISP(7),=X'0004,0001,0001,08'   DISP=SHR\n         MVC   FREE(4),=X'001C,0000'           FREE AFTER CLOSE\n         MVC   VOLSERP(6),=X'0010,0001,0006'\n         MVI   MEMNAME,C' '\n         MVI   PASSWORD,C' '\n         MVI   VOLSER,C' '\n         L     4,IOFCODE           GET FUNCTION CODE\n         CLI   0(4),X'02'          OPTION \"2\" ?\n         BNE   *+8\n         MVI   FCODE,X'02'         SET FUNCTION CODE\n         TM    IOFCODE,X'80'       LAST PARM ?\n         BO    ASM\n         L     4,IODDNM            GET INPUT DSNAME ADDRESS\n         CLC   0(8,4),=CL8' '      IF BLANK, DDNAME IS REQUESTED\n         BNE   SETDDNME\n         MVC   DDNAMEP(2),=X'0055' SET REQUEST DDNAME KEY\nSETDDNME MVC   DDNAME(8),0(4)      MOVE DDNAME TO PARM AREA\n         L     4,IODSNM            GET INPUT DSNAME ADDRESS\n         MVC   DSNAME(44),0(4)     MOVE DSNAME TO PARM AREA\n         TM    IODSNM,X'80'        LAST PARM ?\n         BO    ASM\n         L     4,IOMEM\n         CLI   0(4),C' '\n         BE    *+10                NO MEMBER NAME PASSED\n         MVC   MEMNAME(8),0(4)\n         TM    IOMEM,X'80'\n         BO    ASM\n         L     4,IOPASSW\n         CLI   0(4),C' '\n         BE    *+10                NO PASSWORD PASSED\n         MVC   PASSWORD(8),0(4)\n         TM    IOPASSW,X'80'\n         BO    ASM                 NO VOLSER PASSED\n         L     4,IOVOLSER\n         MVC   VOLSER(6),0(4)\nASM      LA    1,RB\n         ST    1,RBPTR\n         OI    RBPTR,X'80'         SET VL MODE\n         LA    1,TUPL\n         ST    1,TXTPP\n         LA    1,DDNAMEP\n         LA    2,DSNAMEP\n         LA    3,DISP\n         LA    4,FREE\n         STM   1,4,TUPL\n         CLI   FCODE,X'02'         FUNCTION 2 SET ?\n         BNE   *+12\n         OI    TUPL,X'80'          SET DDNAME AS LAST PARM FOR FREE\n         B     GO\n         LA    3,TUPL+12           FREE=CLOSE AS LAST PARM\n         CLI   VOLSER,C' '\n         BE    *+16\n         LA    2,VOLSERP\n         ST    2,4(,3)\n         LA    3,4(,3)\n         CLI   MEMNAME,C' '\n         BE    *+16\n         LA    2,MEMNAMEP\n         ST    2,4(,3)\n         LA    3,4(,3)\n         CLI   PASSWORD,C' '\n         BE    *+16\n         LA    2,PASSWRDP\n         ST    2,4(,3)\n         LA    3,4(,3)\n         OI    0(3),X'80'\nGO       LA    1,RBPTR\n         DYNALLOC\n         ST    15,RETCODE\n         L     3,IOERRCD\n         L     2,ERROR\n         ST    2,0(,3)\n         L     4,IODDNM            RETURN DDNAME\n         MVC   0(8,4),DDNAME\nFREE1    LR    1,11\n         L     0,LVDATA\n         FREEMAIN R,LV=(0),A=(1)\n         L     8,STACK+4           SAVE THESE AREAS, WE'LL LOOSE\n         L     9,RETCODE           THEM IN FREEMAIN\n         LR    1,13                PASS WORK AREA BASE REG\n         LA    0,WSLEN             LEN TO FREE\n         FREEMAIN R,LV=(0),A=(1)   FREE WORK AREA USED\n         LR    13,8                RESTORE &\n         LR    15,9                SET RETURN CODE THEN\n         RETURN (14,12),,RC=(15)   QUIT\n         DS    0F                  FULL WORD ALIGN\nLVDATA   DC    AL1(0),AL3(PARMEND-PARMAREA)\n*\nWKSTG    DSECT\nSTACK    DS    18F\nRETCODE  DS    1F\nRBPTR    DS    F\nWSLEN    EQU   *-WKSTG\n*\nPLIST    DSECT\nIOLIST   DS    0F\nIOERRCD  DS    A\nIOFCODE  DS    A\nIODDNM   DS    A\nIODSNM   DS    A\nIOMEM    DS    A\nIOPASSW  DS    A\nIOVOLSER DS    A\n*\nPARMAREA DSECT                     PARAMETER LIST FOR ALLOC\nRB       DS    0F\nRBLEN    DS    X'14'\nFCODE    DS    X'01'               ALLOC\nFLAG1    DS    X'0000'\nERROR    DS    X'0000'\nINFO     DS    X'0000'\nTXTPP    DS    AL4\nRSV01    DS    X'00000000'\nFLAG2    DS    X'00000000'\nDDNAMEP  DS    X'000100010008'\nDDNAME   DS    C'SYSUT1  '\nDSNAMEP  DS    X'00020001002C'\nDSNAME   DS    CL44' '\nMEMNAMEP DS    X'000300010008'\nMEMNAME  DS    CL8' '\nPASSWRDP DS    X'005000010008'\nPASSWORD DS    CL8' '\nDISP     DS    X'000400010001'\n         DS    X'08'               DISP=SHR\nFREE     DS    X'001C00000000'     FREE AFTER CLOSE\nVOLSERP  DS    X'001000010006'\nVOLSER   DS    CL6' '              VOL=SER=??????\nTUPL     DS    7F\nPARMEND  EQU   *\n*        IEFZB4D0\n*        IEFZB4D2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GUS014": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x10\\x01\\x004?\\x01\\x02\\x07\\x8f#\\x18\\x004\\x004\\x00\\x02\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-12-08T00:00:00", "modifydate": "2002-03-19T23:18:10", "lines": 52, "newlines": 52, "modlines": 2, "user": "SPGSRS"}, "text": "GUS014   EPA   'PARSE SERVICE ROUTINE'\n         BALR  12,0                12 IS BASE REGISTER\n         USING *,12                TELL ASSEMBLER\n         USING LINKAGE,11\n         USING WORKSTG,13\n         USING CPPL,10\n         USING PPL,1\n         LR    11,1\n         LA    0,WKLEN\n         GETMAIN R,LV=(0)\n         ST    13,4(,1)            SAVE CALLER'S SVAREA ADDRESS\n         ST    1,8(,13)            SET BACKWARD CHAIN\n         LR    13,1                SET FORWARD CHAIN\n*\n         LA    1,PARSELST          GET PARSELIST ADDRESS\n         L     10,CPPLADDR\n         L     3,CPPLUPT\n         L     4,CPPLECT\n         XC    ECB,ECB\n         LA    5,ECB\n         L     6,PCLADDR\n         L     7,PDLADDR\n         STM   3,7,PPL             ASSEMBLE PARSELIST\n         TM    PDLADDR,X'80'       IF COMMAND ADDR NOT SPEC, THEN\n         BO    PARSCPPL            COMMAND LINE IS TO BE PARSED\n         MVC   PPLCBUF,CMDADDR\n         B     GOPARSE\nPARSCPPL MVC   PPLCBUF,CPPLCBUF\nGOPARSE  ST    13,PPLUWA\n         CALLTSSR EP=IKJPARS,MF=(E,(1)) CALL PARSE ROUTINE\n         LR    9,15                SAVE PARSE RET CODE\n*\n         LR    1,13\n         L     13,STACK+4\n         LA    0,WKLEN\n         FREEMAIN R,LV=(0),A=(1)\n         LR    15,9                SET RETURN CODE\n         RETURN (14,12),,RC=(15)   RESTORE AND QUIT\nWORKSTG  DSECT\nSTACK    DS    18F\nPARSELST DS    7A                  PARSE PARAMETER LIST\nECB      DS    F\nWKLEN    EQU   *-WORKSTG\nLINKAGE  DSECT\nCPPLADDR DS    A\nPCLADDR  DS    A\nPDLADDR  DS    A\nCMDADDR  DS    A\n         IKJCPPL\n         IKJPPL\n         CVT   DSECT=YES,LIST=YES\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GUS015": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x003\\x01\\x004?\\x01\\x02\\x07\\x8f#\\x19\\x002\\x002\\x00\\x02\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-12-08T00:00:00", "modifydate": "2002-03-19T23:19:33", "lines": 50, "newlines": 50, "modlines": 2, "user": "SPGSRS"}, "text": "GUS015   EPA   'SCAN SERVICE ROUTINE'\n         BALR  12,0                12 IS BASE REGISTER\n         USING *,12                TELL ASSEMBLER\n         USING LINKAGE,11\n         USING WORKSTG,13\n         USING CPPL,10\n         USING CSPL,1\n         LR    11,1\n         LA    0,WKLEN\nGETMAIN  GETMAIN R,LV=(0)\n         ST    13,4(,1)            SAVE CALLER'S SVAREA ADDRESS\n         ST    1,8(,13)            SET BACKWARD CHAIN\n         LR    13,1                SET FORWARD CHAIN\n*\n         LA    1,SCANLST           GET SCANLIST ADDRESS\n         L     10,CPPLADDR\n         L     3,CPPLUPT\n         L     4,CPPLECT\n         XC    ECB(8),ECB          CLEAR ECB AND CSPLFLAG\n         LA    5,ECB\n         LA    6,FLG\n         L     7,CSOAADDR          CSPL0A\n         L     8,BUFFADDR\n         STM   3,8,CSPL            ASSEMBLE SCANLIST\n         TM    BUFFADDR,X'80'      IF NOT SET AS LAST PARM THEN\n         BNO   GOSCAN              STANDARD SYNTAX CHECK IS DONE\n         MVI   FLG,X'80'           SET TO NONSTANDARD SYNTAX CHECK\nGOSCAN   CALLTSSR EP=IKJSCAN,MF=(E,(1)) CALL SCAN ROUTINE\n         LR    9,15                SAVE SCAN RET CODE\n*\nEXIT     LR    1,13\n         L     13,STACK+4\n         LA    0,WKLEN\n         FREEMAIN R,LV=(0),A=(1)\n         LR    15,9                SET RETURN CODE\n         RETURN (14,12),,RC=(15)   RESTORE AND QUIT\nWORKSTG  DSECT\nSTACK    DS    18F\nSCANLST  DS    6A                  SCAN PARAMETER LIST\nECB      DS    F\nFLG      DS    F                   FLAG\nWKLEN    EQU   *-WORKSTG\nLINKAGE  DSECT\nCPPLADDR DS    A\nCSOAADDR DS    A\nBUFFADDR DS    A\n         IKJCPPL\n         IKJCSPL\n         CVT   DSECT=YES\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GUS016": {"ttr": 1039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x005\\x01\\x004?\\x01\\x02\\x07\\x8f#!\\x00n\\x00n\\x00\\x05\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-12-08T00:00:00", "modifydate": "2002-03-19T23:21:35", "lines": 110, "newlines": 110, "modlines": 5, "user": "SPGSRS"}, "text": "**********************************************************************\n*                                                                    *\n*  PARMS:                                                            *\n*       CCPLADDR = CPPL ADDRESS                                      *\n*       WORKADDR = ADDRESS SET BY THIS ROUTINE AS WORKAREA OBTAINED  *\n*                  BY GETMAIN. IF ZERO IS SET THEN THIS CALL IS      *\n*                  FIRST PASS. THIS IS DONE TO INITIALIZE THE        *\n*                  IOPL ONLY ONCE AND NOT DURING EVERY CALL.         *\n*                  IF SET AS LAST PARM, THEN THIS REQUEST IS TO FREE *\n*                  THE ADDRESS CONTAINED IN THIS FIELD.              *\n*       PARMADDR = IF EDITTING IS OR MULTI LINE DISPLAY IS REQ'RED   *\n*                  THIS FIELD CONTAINS A PTPB (PUTLINE PARM BLOCK)   *\n*                  ADDRESS. OTHERWISE THIS WOULD CONTAIN A DATA      *\n*                  LINE ADDRESS. IF BIT 0 IS TURNED ON; PARMADDR     *\n*                  CONTAINS A LINE ADDRESS. OTHERWISE A PTPB IS      *\n*                  CONTAINED IN PARMADDR. IF ZERO IS CONTAINED; THEN *\n*                  THIS REQUEST IS TO FREE THE ADDRESS CONTAINED IN  *\n*                  WORKADDR                                          *\n*                                                                    *\n*  REGISTERS ON RETURN:                                              *\n*     1 - 14   AS IS                                                 *\n*     15       RETURN CODE                                           *\n*                                                                    *\n**********************************************************************\nGUS016   EPA   'PUTLINE SERVICE ROUTINE'\n         BALR  12,0                12 IS BASE REGISTER\n         USING *,12                TELL ASSEMBLER\n         USING LINKAGE,11\n         USING WORKSTG,13\n         USING PTPB,9\n         USING CPPL,10\n         USING IOPL,1\n         LR    11,1\n         L     10,WORKADDR\n         LTR   10,10               FIRST PASS ?\n         BZ    GETMAIN\n         ST    13,4(,10)           SAVE CALLER'S SVAREA ADDRESS\n         LR    13,10               ESTABLISH WORK AREAS\n         TM    WORKADDR,X'80'      FREEMAIN REQUEST ?\n         BO    EXITF\n         LA    1,PUTLST            ESTABLISH IOPL ADDRESS\n         LA    9,WPTPB             ESTABLISH PTPB ADDRESS\n         B     MAIN\nGETMAIN  LA    0,WKLEN\n         GETMAIN R,LV=(0)\n         ST    13,4(,1)            SAVE CALLER'S SVAREA ADDRESS\n         ST    1,8(,13)            SET BACKWARD CHAIN\n         LR    13,1                SET FORWARD CHAIN\n         ST    1,WORKADDR          SET FOR NEXT CALL\n*\n         XC    ECB,ECB             CLEAR ECB\n         LA    1,PUTLST            ESTABLISH IOPL ADDRESS\n         LA    9,WPTPB             ESTABLISH PTPB ADDRESS\n         L     10,CPPLADDR         GET CPPLADDR\n         L     2,CPPLUPT\n         L     3,CPPLECT\n         LA    4,ECB\n         LR    5,9                 PUTLINE PARAMETER BLOCK\n         STM   2,5,IOPL            SET UP IOPL CONTROL BLOCK\nMAIN     L     2,PARMADDR\n         LTR   2,2                 FREEMAIN REQUEST ?\n         BZ    EXITF               EXIT W/ FREEMAIN IF YES\n         XC    FREEADDR,FREEADDR   CLEAR SAVED LINE ADDRESS\n         TM    PARMADDR,X'80'      DATA LINE WAS PASSED ?\n         BO    DATALINE\n         MVC   WPTPB(12),0(2)      MOVE PTPB TO PARM BLOCK\n         B     CALLTSSR            PUTLINE\nDATALINE MVC   WPTPB(12),TEMPLATE  SET UP DATALINE PTPB\n         ST    2,PTPBOPUT\nCALLTSSR CALLTSSR EP=IKJPUTL,MF=(E,(1)) CALL PUTLINE ROUTINE\n         LTR   8,15                SAVE PUTLINE RET CODE\n         BNZ   EXIT                NORMAL END ?\n         TM    PTPB+1,X'20'        EDIT REQUEST ?\n         BNO   CLEANUP             NO\n         L     2,PTPBFLN           GET FORMATTED LINE ADDRESS\n         ST    2,FREEADDR\n         B     DATALINE\n*\nCLEANUP  L     1,FREEADDR          ANY ADDRESS TO FREE ?\n         LTR   1,1\n         BZ    EXIT                NONE SO GET OUT\n         LH    0,0(,1)             GET LVLEN\n         ICM   0,8,=X'01'          SPECIFY SUBPOOL 1\n         FREEMAIN R,LV=(0),A=(1)\nEXIT     L     13,STACK+4\n         LR    15,8                SET RETURN CODE\n@EXIT    RETURN (14,12),,RC=(15)   RESTORE AND QUIT\nEXITF    LR    1,13\n         L     13,STACK+4\n         LA    0,WKLEN\n         FREEMAIN R,LV=(0),A=(1)\n         ST    15,WORKADDR         ZERO OUT GETMAIN ADDRESS\n         B     @EXIT\nTEMPLATE PUTLINE OUTPUT=(TEMPLATE,DATA),MF=L\nWORKSTG  DSECT\nSTACK    DS    18F\nPUTLST   DS    4A                  PUTLINE PARAMETER LIST\nECB      DS    F\nFREEADDR DS    F\nWPTPB    DS    3F\nWKLEN    EQU   *-WORKSTG\nLINKAGE  DSECT\nCPPLADDR DS    A\nWORKADDR DS    A\nPARMADDR DS    A\n         IKJCPPL\n         IKJIOPL\n         IKJPTPB\n         CVT   DSECT=YES\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GUS017": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x009\\x01\\x004?\\x01\\x02\\x07\\x8f#\"\\x00^\\x00^\\x00\\x03\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-12-08T00:00:00", "modifydate": "2002-03-19T23:22:39", "lines": 94, "newlines": 94, "modlines": 3, "user": "SPGSRS"}, "text": "**********************************************************************\n*                                                                    *\n*  PARMS:                                                            *\n*       CCPLADDR = CPPL ADDRESS                                      *\n*       WORKADDR = ADDRESS SET BY THIS ROUTINE AS WORKAREA OBTAINED  *\n*                  BY GETMAIN. IF ZERO IS SET THEN THIS CALL IS      *\n*                  FIRST PASS. THIS IS DONE TO INITIALIZE THE        *\n*                  IOPL ONLY ONCE AND NOT DURING EVERY CALL.         *\n*                  IF SET AS LAST PARM, THEN THE REQUEST IS TO FREE  *\n*                  THE AREA POINTED TO BY THIS ADDRESS.              *\n*       PARMADDR = A NON ZERO VALUE WILL CAUSE A FREEMAIN TO THE     *\n*                  ADDRESS CONTAINED BEFORE A NEW VALUE IS POSTED    *\n*                  TO THIS FIELD. ON RETURN, THIS FIELD POINTS TO    *\n*                  THE INPUT LINE BUFFER.                            *\n*                                                                    *\n*  REGISTERS ON RETURN:                                              *\n*     1 - 14   AS IS                                                 *\n*     15       RETURN CODE                                           *\n*                                                                    *\n**********************************************************************\nGUS017   EPA   'GETLINE SERVICE ROUTINE'\n         BALR  12,0                12 IS BASE REGISTER\n         USING *,12                TELL ASSEMBLER\n         USING LINKAGE,11\n         USING WORKSTG,13\n         USING GTPB,9\n         USING CPPL,10\n         USING IOPL,1\n         LR    11,1\n         L     10,WORKADDR\n         LTR   10,10               FIRST PASS ?\n         BZ    GETMAIN\n         ST    13,4(,10)           SAVE CALLER'S SVAREA ADDRESS\n         LR    13,10               ESTABLISH WORK AREAS\n         TM    WORKADDR,X'80'      FREEMAIN REQUEST ?\n         BO    EXITF\n         LA    1,GETLST            ESTABLISH IOPL ADDRESS\n         LA    9,WGTPB             ESTABLISH GTPB ADDRESS\n         B     MAIN\nGETMAIN  LA    0,WKLEN\n         GETMAIN R,LV=(0)\n         ST    13,4(,1)            SAVE CALLER'S SVAREA ADDRESS\n         ST    1,8(,13)            SET BACKWARD CHAIN\n         LR    13,1                SET FORWARD CHAIN\n         ST    1,WORKADDR          SET FOR NEXT CALL\n*\n         XC    ECB,ECB             CLEAR ECB\n         LA    1,GETLST            ESTABLISH IOPL ADDRESS\n         LA    9,WGTPB             ESTABLISH GTPB ADDRESS\n         L     10,CPPLADDR         GET CPPLADDR\n         L     2,CPPLUPT\n         L     3,CPPLECT\n         LA    4,ECB\n         LR    5,9                 GETLINE PARAMETER BLOCK\n         STM   2,5,IOPL            SET UP IOPL CONTROL BLOCK\nMAIN     MVC   WGTPB(8),TEMPLATE   SET UP GTPB\n         L     2,PARMADDR\n         LTR   2,2                 ANY ADDRESS TO FREE ?\n         BZ    CALLTSSR            IF NONE GETLINE\n         LH    0,0(,2)             GET LVLEN\n         ICM   0,8,=X'01'          SPECIFY SUBPOOL 1\n         FREEMAIN R,LV=(0),A=(2)\n         LA    1,GETLST            RE-ESTABLISH IOPL ADDRESS\nCALLTSSR CALLTSSR EP=IKJGETL,MF=(E,(1)) CALL PUTLINE ROUTINE\n         LTR   8,15                SAVE PUTLINE RET CODE\n         BNZ   EXIT                NORMAL END ?\n         L     2,GTPBIBUF          GET FORMATTED LINE ADDRESS\n         ST    2,PARMADDR          PASS IT\n*\nEXIT     L     13,STACK+4\n         LR    15,8                SET RETURN CODE\n         RETURN (14,12),,RC=(15)   RESTORE AND QUIT\nEXITF    LR    1,13\n         L     13,STACK+4\n         LA    0,WKLEN\n         FREEMAIN R,LV=(0),A=(1)\n         ST    15,WORKADDR         ZERO OUT GETMAIN ADDRESS\n         B     EXIT+4\nTEMPLATE GETLINE MF=L\nWORKSTG  DSECT\nSTACK    DS    18F\nGETLST   DS    4A                  GETLINE PARAMETER LIST\nECB      DS    F\nWGTPB    DS    2F\nWKLEN    EQU   *-WORKSTG\nLINKAGE  DSECT\nCPPLADDR DS    A\nWORKADDR DS    A\nPARMADDR DS    A\n         IKJCPPL\n         IKJIOPL\n         IKJGTPB\n         CVT   DSECT=YES\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISPFXMI": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03\\x02\\x00\\x00\\x01\\x02\\x18_\\x01\\x02\\x18_\\x10%\\x01N\\x01N\\x00\\x00\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "03.02", "flags": 0, "createdate": "2002-07-04T00:00:00", "modifydate": "2002-07-04T10:25:00", "lines": 334, "newlines": 334, "modlines": 0, "user": "SPGSRS"}, "text": "./ ADD NAME=PXMIT    0300-02151-02151-1513-00025-00025-00000-SPGSRS\n)ATTR\n  @ TYPE(OUTPUT) INTENS(LOW)\n  _ TYPE(inpuT)  INTENS(LOW) Caps(on)\n)BODY EXPAND(\\\\)\n%TRANSMIT DATASET+-\\-\\-\n%Command ===>_ZCMD                                            %Scroll ===>_AMT +\n+\n% Input Ds ==>@IDSN\n% XMIT  Ds ==>@ODSN\n+\n+ Member List        Press F3 to Select\n% Sel  member   VV.MM Created    Changed              Size  Init   Mod   ID\n)MODEL\n _Z+  @MEM     @Verm @Credate   @Chgdate            @SiZe @Init @Mdl  @Id\n)INIT\n .ZVARS = '(SEL)'\n &AMT  = CSR\n)REINIT\n IF (.MSG = ' ')\n    &SEL  = ' '\n    REFRESH (SEL)\n)PROC\n IF (&ZTDSELS \u00ac= 0000)\n    VER (&SEL, LIST, S)\n)END\n./ ADD NAME=PXMITM   0300-02151-02151-1513-00042-00042-00000-SPGSRS\n)ATTR\n  @ TYPE(OUTPUT) INTENS(LOW)\n)BODY EXPAND(\\\\)\n%-\\-\\- TRANSMIT DATASET -\\-\\-\n%Command ===>_ZCMD\n%\n+ Input Dataset Name%==>_IDSN                                       +\n+\n+ Transmit file     %==>_ODSN                                       +\n+\n+ Select members    %==>_Z+  * for all, blank to select\n+\n+ Add message text  %==>_Z+ %N+No %F+Enter full screen manually%D+MsgDsname\n+\n+ Message Dataset   %==>_MDSN                                       +\n+                        If%D+selected for message text\n+\n+ log this transmit?%==>_Z+ (Y/N)\n+\n+ log dataset       %==>_LDSN                                       +\n+                        If%Y+selected for log, Blank for default\n)INIT\n .ZVARS = '(MSEL,MTXT,MLOG)'\n &AMT   = CSR\n &MSEL  = '*'\n &Mtxt  = 'N'\n &Mlog  = 'Y'\n)REINIT\n IF (.MSG = ' ')\n    &MSEL  = '*'\n    REFRESH (MSEL)\n)PROC\n    VER (&MSEL, LIST, '*', ' ')\n    VER (&MTXT, LIST, 'N', 'F', 'D')\n    VER (&MLOG, LIST, 'Y', 'N')\n    VER (&IDSN, nb, dsname)\n    VER (&ODSN, nb, dsname)\n IF (&MTXT = 'D')\n    VER (&MDSN, nb, dsname)\n IF (&MLOG = 'Y')\n    VER (&LDSN, dsname)\n)END\n./ ADD NAME=RXMIT    0302-02157-02184-1514-00264-00264-00000-SPGSRS\n/* REXX *************************************************************/\n/*  Xmit     - Create an XMIT dataset from a PO Dataset             */\n/*  at the command line                                             */\n/*                                                                  */\n/*  Thanks to Gilbert Saint-flour for the Rexx logic of reading the */\n/*  directory of a PDS - From the VML Rexx in CBT File#183          */\n/********************************************************************/\nParse Arg IDsn\nSysuid  = userid()\n  /*-----------------------------------------------------------------*/\n  /*                 Display Initial Panel                           */\n  /*-----------------------------------------------------------------*/\nADDRESS Ispexec\n'Display panel(Pxmitm)'\n'VGET (ZVERB)'                              /* Retrieve Command      */\nIf zverb = 'END' then exit\nIf zcmd  = 'CAN' | zcmd = 'CANCEL' then exit\nMlist  = ''\nmsgtxt = ''\nlogopt = 'LOg'\nIf mtxt =  'F' then msgtxt = 'Message Fullscreen'\nIf mtxt =  'D' then msgtxt = 'MSGDSNAME('Mdsn')'\nIf mlog =  'N' then logopt = 'NoLog'\nIf Ldsn <> ' ' then logopt = 'LogDSName('Ldsn')'\nIf mSel =  '*' then signal xmitit\nispf=SYSVAR(SYSISPF)='ACTIVE'\nADDRESS TSO\n  /*-----------------------------------------------------------------*/\n  /*                 Process Input dataset                           */\n  /*-----------------------------------------------------------------*/\n\"ALLOCATE DD(VMLPDS) SHR DS(\"IDSN\") REUSE\" ,\n  \"RECF(F B) LRECL(256) BLKSIZE(256) DSORG(PS)\"\nIF RC>0 THEN EXIT(RC)\nX=LISTDSI(VMLPDS FILE)\nIF SYSDSORG\\='PO' THEN DO\n  ZEDSMSG = 'NOT A PDS'\n  ZEDLMSG = SYSDSNAME \"IS NOT A PDS OR A PDSE\"\n  EXIT 12\n  END\n\"EXECIO * DISKR VMLPDS (STEM DIR. FINIS\"       /* read PDS directory */\n\"FREE DD(VMLPDS)\"\n  /*-----------------------------------------------------------------*/\n  /*                 Process Directory Blocks                        */\n  /*-----------------------------------------------------------------*/\nn=0\n  DO blk = 1 to dir.0\n    usedbytes = C2D(LEFT(dir.blk,2))\n    index = 3                            /* skip past used bytes     */\n    DO WHILE index < usedbytes\n      pds2name = SUBSTR(dir.blk,index,8) /* member name              */\n      IF pds2name = 'FFFFFFFFFFFFFFFF'x THEN LEAVE blk\n      pds2indc = SUBSTR(dir.blk,index+11,1)\n      len = BITAND(pds2indc,'1F'x)       /* isolate user data length */\n      userdata = C2D(len) * 2            /* halfwords to bytes       */\n      n=n+1                              /* next n                   */\n      IF userdata=30 & sysrecfm\\='U' THEN DO /* SPF stats present    */\n        sde=SUBSTR(dir.blk,index+12,30)  /* extract SPF Dir Entry    */\n        ver=C2D(SUBSTR(sde,1,1))\n        mod=C2D(SUBSTR(sde,2,1))\n        idate=C2X(SUBSTR(sde,5,4))       /* 0092123F    */\n        idate=LEFT(idate,7)+1900000      /* 1992123     */\n        cdate=C2X(SUBSTR(sde,9,4))       /* 0092123F    */\n        cdate=LEFT(cdate,7)+1900000      /* 1992123     */\n        hh=C2X(SUBSTR(sde,13,1))\n        mm=C2X(SUBSTR(sde,14,1))\n        ss=C2X(SUBSTR(sde,4,1))\n        cline=C2D(SUBSTR(sde,15,2))\n        iline=C2D(SUBSTR(sde,17,2))\n        mline=C2D(SUBSTR(sde,19,2))\n        sclm=BITAND(SUBSTR(sde,3,1),'80'x) /* isolate SCLM flag      */\n        IF sclm='80'x THEN sclm='SCLM'\n        ELSE sclm=''\n        mbr.n=pds2name                   /* member name              */\n        vrm.n=RIGHT(ver,2,'0') || '.' || RIGHT(mod,2,'0')\n        crd.n=GREGORIAN(idate)           /* creation date            */\n        chg.n=GREGORIAN(cdate),          /* last-modified date       */\n              hh || '.' || mm || '.' || ss  /* HH.MM.SS              */\n        sZe.n=RIGHT(cline,5)             /* current lines            */\n        ini.n=RIGHT(iline,5)             /* initial lines            */\n        mdl.n=RIGHT(mline,5)             /* modified lines           */\n        uid.n=RIGHT(sde,10),             /* userID                   */\n              SCLM                       /* SCLM indicator           */\n        END\n      ELSE  Do                           /* no ISPF stats            */\n        mbr.n=pds2name                   /* store member name        */\n        vrm.n=' '                        /* No ISPF Stats            */\n        crd.n=' '\n        chg.n=' '\n        sZe.n=' '\n        ini.n=' '\n        mdl.n=' '\n        uid.n=' '\n      End\n      index = index + 12 + userdata      /* skip past user data      */\n    END\n  END\n  /*-----------------------------------------------------------------*/\n  /*                    Display the Member List                      */\n  /*-----------------------------------------------------------------*/\nIF n=0 THEN DO\n  SAY sysdsname is empty\n  EXIT 4\n  END\n\nSIGNAL DISPLAY\n\nSYNTAX:\n  error=rc\n  SAY 'REXX error' error 'in line' sigl':' errortext(error)\n  SAY sourceline(sigl)\n  SAY ''\nDISPLAY:\nADDRESS Ispexec\n'TBCREATE TB1 NAMES(SEL MEM verm credate chgdate size' ,\n                   'init mdl id) NOWRITE'\nIX = 0\nDO WHILE IX < n\nIX       = IX + 1\nSEL      = ' '\nMEM      = mbr.ix\nverm     = vrm.ix\ncredate  = crd.ix\nchgdate  = chg.ix\nsize     = sZe.ix\ninit     = ini.ix\nmdl      = mdl.ix\nid       = uid.ix\n'TBADD TB1'\nEND\nZtdtop   = 1\ncol      = 'mem'\nDo while Zverb <> 'END'\n   'TBTOP  tb1'                       /* Set CRP to TOP        */\n   'TBSKIP tb1   NUMBER('ZTDTOP')'    /* Set CRP to previous   */\n                                      /*  top row displayed    */\n   Select                             /* Determine Case        */\n    When ZVERB = 'UP' Then Do         /* - When scroll UP req  */\n     Zscrolln  = zscrolln * -1\n     'TBSKIP tb1 NUMBER('zscrolln')'  /*  skip back toward top */\n     End\n    When ZVERB = 'DOWN' Then          /* - When scroll DOWN req*/\n     'TBSKIP tb1 NUMBER('ZSCROLLN')'  /*  skip forward         */\n    Otherwise                         /* - Otherwise, not a    */\n   End                                /*  scroll request       */\n                                      /*                       */\n   'TBDISPL  TB1  PANEL('Pxmit')'     /* Disp the table and pnl*/\n   'VGET (ZVERB ZSCROLLN)'            /* Retrieve variables    */\n   'TBPut    TB1'\n   IX = ZTDSELS\n   If Ix > 1 then\n   DO ix - 1\n      'TBDispl  TB1'\n      'TBPut    TB1'\n   END\n   if zcmd <> ' ' then Do\n      parse value zcmd with cmd fld order\n      Select\n        when cmd = 'SORT'  then col=sorttab(fld order)\n        when cmd = 'CAN' | cmd='CANCEL' then Do\n                                               'TBEND    TB1'\n                                               Exit\n                                             End\n        when cmd = 'LOC' | cmd='LOCATE' | cmd='L' ,\n             then Ztdtop=Loctab(fld col)\n        otherwise Do\n             zedsmsg = 'Unsupported command'\n             zedlmsg = 'Command' cmd 'is currently not supported'\n             'SETMSG MSG(ISRZ001)'\n         End\n      End\n   End\nEnd\n'tbsort  TB1 fields(Sel,C,D)'\nDo N\n   'TBskip TB1'\n   'TBget  TB1'\n   if Sel = ' ' then Leave\n   Mlist = Mlist strip(Mem)\nEnd\nMLIST = 'members('||strip(MLIST)||')'\n'TBEND    TB1'\nIf mlist = 'members()' then Exit  /* none selected- changed his mind */\n  /*-----------------------------------------------------------------*/\n  /*                    Execute Transmit command                     */\n  /*-----------------------------------------------------------------*/\nxmitit:\nAddress TSO\n    'XMIT N1.'||SYSUID||' DSNAME('||IDSN||')' ,\n    'OUTDSN('||ODSN||') PDS' logopt mlist msgtxt\n  EXIT\n/*--------------------------------------------------------------------*/\n/*             JULIAN-TO-GREGORIAN CONVERSION ROUTINE                 */\n/*                   GDATE=GREGORIAN(1992134)                         */\n/*                      RETURNS \"YYYY/MM/DD\"                          */\n/*--------------------------------------------------------------------*/\nGREGORIAN: PROCEDURE\n  YYYY=LEFT(ARG(1),LENGTH(ARG(1))-3)\n  DDD=RIGHT(ARG(1),3)\n  T=(YYYY//4=0)\n  DD=DDD; IF DD>(59+T) THEN DD=DD+2-T\n  MM=((DD+91)*100)%3055\n  DD=DD+91-(MM*3055)%100\n  RETURN YYYY'/'RIGHT(MM-2,2,'0')'/'RIGHT(DD,2,'0')\n/*--------------------------------------------------------------------*/\n/* Sort the table according to requested field                        */\n/*--------------------------------------------------------------------*/\nSorttab: Procedure\narg fld order\no='D'\nif order='A' | order='D' then o=order\nfld= strip(fld)\nselect\n   when fld = 'MEMBER' | fld='MEM' then fl='mem'\n   when fld = 'VER'     then fl='verm'\n   when fld = 'CREATED' then fl='credate'\n   when fld = 'CHANGED' then fl='chgdate'\n   when fld = 'SIZE'    then fl='size'\n   when fld = 'INIT'    then fl='init'\n   when fld = 'MOD'     then fl='mdl'\n   when fld = 'ID'      then fl='id'\n   otherwise do\n             zedsmsg = 'Invalid Sort field'\n             zedlmsg = 'Valid sort fields are Mem,Ver,Created,'||,\n             'Changed,Size,Init,Mod and Id'\n             'SETMSG MSG(ISRZ001)'\n             Return fl\n             end\nend\n'tbsort  TB1 fields('fl ',C,' o')'\nreturn fl\n/*--------------------------------------------------------------------*/\n/* Locate a member in a given column                                  */\n/* Size,Init and mod fields only supported if sorted in Descending    */\n/* order... but then again, ISPF only sorts in descending order       */\n/*--------------------------------------------------------------------*/\nLoctab: Procedure\narg loc col\nIf col='SIZE' | col='INIT' | col='MDL' then signal numfld\nselect\n   when col = 'MEM'     then mem     = loc||'*'\n   when col = 'VERM'    then verm    = loc||'*'\n   when col = 'CREDATE' then credate = loc||'*'\n   when col = 'CHGDATE' then chgdate = loc||'*'\n   when col = 'ID'      then id      = loc||'*'\n   otherwise\nEnd\n'TBScan   TB1 arglist('||col||') position(ztdtop)'\nreturn Ztdtop\nnumfld:\n'TBTOP    TB1'\n'TBQuery  TB1 Rownum(rows)'\nZtdtop = 0\nDo Rows\n   'TBskip  TB1'\n   'TBget   TB1'\n   Ztdtop = Ztdtop + 1\n   select\n      when col = 'SIZE' then if loc \\< size then leave\n      when col = 'INIT' then if loc \\< init then leave\n      when col = 'MDL'  then if loc \\< mdl  then leave\n      otherwise\n   End\nEnd\nreturn Ztdtop\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIST": {"ttr": 1292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01(\\x00\\x18\\x01\\x01\\x07\\x8f\\x01\\x05\\x11\\x1f!'\\x00\\xc2\\x00\\x87\\x00\\xc2\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@\"", "ispf": {"version": "01.40", "flags": 0, "createdate": "2001-03-19T00:00:00", "modifydate": "2005-04-21T21:27:18", "lines": 194, "newlines": 135, "modlines": 194, "user": "SPGSRS"}, "text": "LIST     EPA   'DISPLAYS CONTENTS OF DATASET ENTERED FROM COMMAND LINE'\n         BALR  12,0\n         USING *,12\n         LR    6,1                      SAVE ADDR OF CPPL\n*\n         L     0,LVLEN\n         GETMAIN R,LV=(0)\n         ST    13,4(,1)\n         ST    1,8(,13)\n         LR    13,1\n         USING WORKAREA,13\n         LOAD  EPLOC=$$DAIR\n         ST    0,GUS012\n         LOAD  EPLOC=$$PUTL\n         ST    0,GUS016\n         LOAD  EPLOC=$$PARS\n         ST    0,GUS014\n         XR    15,15                    SET UP PUTLINE PARMLIST\n         ST    6,$GUS016                CPPL\n         ST    15,$GUS016+4             GETMAIN AREA\n*\n         L     0,=V(MAINPCL)\n         L     15,GUS014\n         LA    2,ANSAREA\n         CALL  (15),((6),(0),(2)),VL,   PARSE COMMAND LINE FOR DSNAME  X\n               MF=(E,$GUS014)\n         LTR   9,15\n         BNZ   PARSERR\n*\n         L     6,ANSAREA\n         USING MAINPDL,6\n*\n         TM    DSNAME+6,X'80'\n         BNO   ERRNAM\n*\nGETDSN   L     10,DSNAME                DSNAME FROM COMMAND LINE\n         LH    11,DSNAME+4              LENGTH OF DSNAME TEXT\n         BCTR  11,0                     1 LESS FOR EX INSTRUCTION\n*                                       DSNAME OBTAINED IS QUALIFIED\n         CLEAR IODDNM,LEN=60            BASED ON TSO RULES\n         EX    11,MVDSN                 MOVE TO PARAMETER AREA\n         L     10,DSNAME+8              GET MEMBER NAME IF SPECIFIED\n         LH    11,DSNAME+8+4            LENGTH OF MEMBER NAME TEXT\n         LTR   11,11                    WAS MEMBER NAME SPECIFIED?\n         BZ    ALLOC\n         BCTR  11,0                     1 LESS FOR EX INSTRUCTION\n         EX    11,MVMEM                 MOVE TO PARAMETER AREA\n*\nALLOC    MVI   IOFCODE,X'01'\n         L     15,GUS012                ALLOCATE IT!\n         CALL  (15),(IOERRCD,IOFCODE,IODDNM,IODSNM,IOMEMN),            +\n               VL,MF=(E,$GUS012)\n         LTR   9,15\n         BZ    OPENFILE\n         LA    11,ERROPEN               ALLOC FAILED\n         BAL   14,$PUTLINE              TELL USER\n         B     END                      R9 HAS RETCODE\n*                                       SET UP I-O PARAMETERS\nOPENFILE MVC   SYSDCB(DCBLEN),DCB1\n         MVI   $$OPEN,X'80'             SET UP OPENLIST\n         MVC   DCBDDNAM(8),IODDNM       DDNAME FROM DYNALLOC\n         OPEN  SYSDCB,MF=(E,$$OPEN)\n         LTR   9,15                     CHECK OPEN RETURN CODE\n         BNZ   ERROR1\n         LH    2,DCBLRECL\n         LA    2,4(,2)                  ADD HEADERS\n         STH   2,$LRECL                 SAVE IT\n         GETMAIN RC,LV=(2)              STORAGE FOR RECORD AREA\n         LR    10,1\n         USING RECAREA,10\n         XR    15,15\n         STH   15,DATAOFF               LINE OFFSET IS 0\n         LR    11,10                    PUTLINE IS R11\nREADIN   GET   SYSDCB,DATALINE\n         LH    2,DCBLRECL               GET LENGHT OF THIS LINE\n         LA    2,4(,2)                  ADD HEADERS\n         STH   2,DATALEN                TELL PUTLINE\n         BAL   14,$PUTLINE              PRINT THIS LINE\n         B     READIN                   NEXT RECORD\n*\nEOD      EQU   *                        EOF OCCURRED\n         CLOSE SYSDCB,MF=(E,$$OPEN)\nFREEDS   MVI   IOFCODE,X'02'\n         L     15,GUS012                FREE IT!\n         CALL  (15),MF=(E,$GUS012)\n         LH    0,$LRECL                 SAVE IT\n         FREEMAIN RC,LV=(0),A=(10)      FREE STORAGE FOR RECORD AREA\n         B     EXIT0\n*\nPARSERR  L     11,PARSEMSG(9)\n         BAL   14,$PUTLINE\n         B     END\n*\nERRNAM   LA    11,ERRNAMM\n         BAL   14,$PUTLINE\n         B     END\n*\nEXIT0    EQU   *                        LET'S FINISH OFF\n         XR    9,9                      SET RETURN CODE\n*\nEND      EQU   *                        LET'S FINISH OFF\n         L     6,ANSAREA\n         IKJRLSA (6)                    RELEASE PARSE DATAAREA\n         XR    14,14\n         L     15,GUS016\n         CALL  (15),(,,(14)),MF=(E,$GUS016) FREEMAIN PUTLINE\n         DELETE EPLOC=$$DAIR\n         DELETE EPLOC=$$PARS\n         DELETE EPLOC=$$PUTL\n         LR    1,13\n         L     13,4(,13)\n         LA    0,WORKLEN\n         FREEMAIN R,LV=(0),A=(1)\n*\n         LR    15,9\n         RETURN (14,12),RC=(15)\n*---------------------------------------------------------------\n$PUTLINE ST    14,R14SAVE\n         L     15,GUS016\n         CALL  (15),(,,(11)),VL,MF=(E,$GUS016)\n         L     14,R14SAVE\n         BR    14\n*---------------------------------------------------------------\nMVDSN    MVC   IODSNM(1),0(10)\nMVMEM    MVC   IOMEMN(1),0(10)\n*\nERROR1   LA    11,ERRINP\n         BAL   14,$PUTLINE\n         B     END\nERROR2   LH    2,0(1)\n         CH    2,=X'0130'\n         BNER  14\n         LA    11,ERRMEM\n         BAL   14,$PUTLINE\n         B     END\n         B     FREEDS                   FREE THE ALLOCATED DATASET\n*\n         TITLE 'D A T A   A R E A'\n*\n*        CONSTANTS\n*\nERRNAMM  MSGCP 'DATASET NAME NOT FOUND IN PARSE*******'\nERROPEN  MSGCP 'ERROR IN ALLOCATING DATASET ******'\nERRMEM   MSGCP 'MEMBER NOT FOUND'\nERRINP   MSGCP 'DATASET NOT FOUND'\n         PARSEMSG ,                     STANDARD PARSE ERROR MESSAGES\n*\nMAINPCL  IKJPARM DSECT=MAINPDL\nDSNAME   IKJPOSIT DSTHING,USID,LIST,PROMPT='DATASET NAME',             X\n               HELP='DSNAME WHOSE CONTENTS YOU WANT TO LIST'\n         IKJENDP\nLVLEN    DC    A(WORKLEN)\n$$DAIR   DC    CL8'GUS012'\n$$PARS   DC    CL8'GUS014'\n$$PUTL   DC    CL8'GUS016'\nDCB1     DCB   DDNAME=SYS00000,EODAD=EOD,MACRF=GM,DSORG=PS,EXLST=EXLST\nDCBLEN   EQU   *-DCB1\nEXLST    DC    XL4'09'\n         DC    X'11',AL3(ERROR2)\n         DC    X'80'\n*\n*        DATA AREA\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nGUS012   DS    V                 DYNALLOC\nGUS014   DS    V                 PARSE\nGUS016   DS    V                 PUTLINE\n$GUS012  DS    4A                DAIR PARMLIST\n$GUS014  DS    3A                PARSE\n$GUS016  DS    3A                PUTLINE PARMLIST\nIOERRCD  DS    1F\nIOFCODE  DS    XL1\nIODDNM   DS    CL8\nIODSNM   DS    CL44\nIOMEMN   DS    CL8\nANSAREA  DS    A\nR14SAVE  DS    A\n$$OPEN   OPEN  DCB1,MF=L\nSYSDCB   DS    CL(DCBLEN)\nDCBDDNAM EQU   SYSDCB+40         DDNAME\nDCBBLKSI EQU   SYSDCB+62         BLKSIZE\nDCBLRECL EQU   SYSDCB+82         RECLEN\nDCBRECFM EQU   SYSDCB+36         RECFM\n$LRECL   DS    H\nWORKLEN  EQU   *-WORKAREA\n*\nRECAREA  DSECT\nDATALEN  DS    H\nDATAOFF  DS    H\nDATALINE DS    0H\n         PRINT NOGEN\n         CVT   DSECT=YES\n         END   LIST\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MACLIB": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x06\\x05\\x8f\\x01\\x06\\x05\\x8f\\tF\\x03\\xa8\\x03\\xa8\\x00\\x00\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-02-27T00:00:00", "modifydate": "2006-02-27T09:46:00", "lines": 936, "newlines": 936, "modlines": 0, "user": "SPGSRS"}, "text": "./ ADD NAME=$$CHANGE 0101-06058-06058-0935-00002-00002-00000-SPGSRS\nChanges:   2002/06/13\nChange EPA macro in specifying AMODE and RMODE\n./ ADD NAME=$HEAD    0101-01362-01363-1116-00638-00638-00002-SPGSRS\n         MACRO\n        $HEAD  &STRING,           STRING IS EXPANDED                   *\n               &BLOCK=YES,        STRING IS TO BE BLOCKED              *\n               &TITLE=            (A,'B') -GEN TITLE STATEMENT WITH    *\n                                  NAME FIELD A, AND TITLE 'B'\n.*\n         GBLB  &HEADB\n         GBLC  &HEADC(497)\n         LCLA  &I\n         LCLA  &J\n         LCLA  &K\n         LCLA  &L\n         LCLA  &M\n         LCLA  &N\n         LCLC  &F(64)\n         LCLC  &STR(64)\n         LCLC  &B\n         LCLC  &W\n.*\n.*\n         AIF   (&HEADB).PROC\n&HEADB   SETB  (1)\n&HEADC(1)    SETC  ' '\n&HEADC(2)    SETC  '        '\n&HEADC(3)    SETC  '        '\n&HEADC(4)    SETC  '        '\n&HEADC(5)    SETC  '        '\n&HEADC(6)    SETC  '        '\n&HEADC(7)    SETC  '        '\n&HEADC(8)    SETC  '        '\n&HEADC(9)    SETC  '        '\n&HEADC(10)   SETC  'A'\n&HEADC(11)   SETC  '    A   '\n&HEADC(12)   SETC  '   AAA  '\n&HEADC(13)   SETC  '  AA AA '\n&HEADC(14)   SETC  ' AA   AA'\n&HEADC(15)   SETC  ' AA   AA'\n&HEADC(16)   SETC  ' AAAAAAA'\n&HEADC(17)   SETC  ' AA   AA'\n&HEADC(18)   SETC  ' AA   AA'\n&HEADC(19)   SETC  'B'\n&HEADC(20)   SETC  ' BBBBBB '\n&HEADC(21)   SETC  ' BB   BB'\n&HEADC(22)   SETC  ' BB   BB'\n&HEADC(23)   SETC  ' BBBBBB '\n&HEADC(24)   SETC  ' BB   BB'\n&HEADC(25)   SETC  ' BB   BB'\n&HEADC(26)   SETC  ' BB   BB'\n&HEADC(27)   SETC  ' BBBBBB '\n&HEADC(28)   SETC  'C'\n&HEADC(29)   SETC  '  CCCCC '\n&HEADC(30)   SETC  ' CC   CC'\n&HEADC(31)   SETC  ' CC   CC'\n&HEADC(32)   SETC  ' CC     '\n&HEADC(33)   SETC  ' CC     '\n&HEADC(34)   SETC  ' CC   CC'\n&HEADC(35)   SETC  ' CC   CC'\n&HEADC(36)   SETC  '  CCCCC '\n&HEADC(37)   SETC  'D'\n&HEADC(38)   SETC  ' DDDDDD '\n&HEADC(39)   SETC  ' DD   DD'\n&HEADC(40)   SETC  ' DD   DD'\n&HEADC(41)   SETC  ' DD   DD'\n&HEADC(42)   SETC  ' DD   DD'\n&HEADC(43)   SETC  ' DD   DD'\n&HEADC(44)   SETC  ' DD   DD'\n&HEADC(45)   SETC  ' DDDDDD '\n&HEADC(46)   SETC  'E'\n&HEADC(47)   SETC  ' EEEEEE '\n&HEADC(48)   SETC  ' EE     '\n&HEADC(49)   SETC  ' EE     '\n&HEADC(50)   SETC  ' EEEE   '\n&HEADC(51)   SETC  ' EE     '\n&HEADC(52)   SETC  ' EE     '\n&HEADC(53)   SETC  ' EE     '\n&HEADC(54)   SETC  ' EEEEEEE'\n&HEADC(55)   SETC  'F'\n&HEADC(56)   SETC  ' FFFFFFF'\n&HEADC(57)   SETC  ' FF     '\n&HEADC(58)   SETC  ' FF     '\n&HEADC(59)   SETC  ' FFFFF  '\n&HEADC(60)   SETC  ' FF     '\n&HEADC(61)   SETC  ' FF     '\n&HEADC(62)   SETC  ' FF     '\n&HEADC(63)   SETC  ' FF     '\n&HEADC(64)   SETC  'G'\n&HEADC(65)   SETC  '  GGGGG '\n&HEADC(66)   SETC  ' GG   GG'\n&HEADC(67)   SETC  ' GG   GG'\n&HEADC(68)   SETC  ' GG     '\n&HEADC(69)   SETC  ' GG  GGG'\n&HEADC(70)   SETC  ' GG   GG'\n&HEADC(71)   SETC  ' GG   GG'\n&HEADC(72)   SETC  '  GGGGG '\n&HEADC(73)   SETC  'H'\n&HEADC(74)   SETC  ' HH   HH'\n&HEADC(75)   SETC  ' HH   HH'\n&HEADC(76)   SETC  ' HH   HH'\n&HEADC(77)   SETC  ' HHHHHHH'\n&HEADC(78)   SETC  ' HH   HH'\n&HEADC(79)   SETC  ' HH   HH'\n&HEADC(80)   SETC  ' HH   HH'\n&HEADC(81)   SETC  ' HH   HH'\n&HEADC(82)   SETC  'I'\n&HEADC(83)   SETC  '  IIII  '\n&HEADC(84)   SETC  '   II   '\n&HEADC(85)   SETC  '   II   '\n&HEADC(86)   SETC  '   II   '\n&HEADC(87)   SETC  '   II   '\n&HEADC(88)   SETC  '   II   '\n&HEADC(89)   SETC  '   II   '\n&HEADC(90)   SETC  '  IIII  '\n&HEADC(91)   SETC  'J'\n&HEADC(92)   SETC  '      JJ'\n&HEADC(93)   SETC  '      JJ'\n&HEADC(94)   SETC  '      JJ'\n&HEADC(95)   SETC  '      JJ'\n&HEADC(96)   SETC  '      JJ'\n&HEADC(97)   SETC  ' JJ   JJ'\n&HEADC(98)   SETC  ' JJ   JJ'\n&HEADC(99)   SETC  '  JJJJJ '\n&HEADC(100)  SETC  'K'\n&HEADC(101)  SETC  ' KK   KK'\n&HEADC(102)  SETC  ' KK  KK '\n&HEADC(103)  SETC  ' KK KK  '\n&HEADC(104)  SETC  ' KKKK   '\n&HEADC(105)  SETC  ' KKKK   '\n&HEADC(106)  SETC  ' KK KK  '\n&HEADC(107)  SETC  ' KK  KK '\n&HEADC(108)  SETC  ' KK   KK'\n&HEADC(109)  SETC  'L'\n&HEADC(110)  SETC  ' LL     '\n&HEADC(111)  SETC  ' LL     '\n&HEADC(112)  SETC  ' LL     '\n&HEADC(113)  SETC  ' LL     '\n&HEADC(114)  SETC  ' LL     '\n&HEADC(115)  SETC  ' LL     '\n&HEADC(116)  SETC  ' LL     '\n&HEADC(117)  SETC  ' LLLLLLL'\n&HEADC(118)  SETC  'M'\n&HEADC(119)  SETC  ' M     M'\n&HEADC(120)  SETC  ' MM   MM'\n&HEADC(121)  SETC  ' MMM MMM'\n&HEADC(122)  SETC  ' MMMMMMM'\n&HEADC(123)  SETC  ' MM M MM'\n&HEADC(124)  SETC  ' MM   MM'\n&HEADC(125)  SETC  ' MM   MM'\n&HEADC(126)  SETC  ' MM   MM'\n&HEADC(127)  SETC  'N'\n&HEADC(128)  SETC  ' NN   NN'\n&HEADC(129)  SETC  ' NNN  NN'\n&HEADC(130)  SETC  ' NNN  NN'\n&HEADC(131)  SETC  ' NNNN NN'\n&HEADC(132)  SETC  ' NN NNNN'\n&HEADC(133)  SETC  ' NN  NNN'\n&HEADC(134)  SETC  ' NN  NNN'\n&HEADC(135)  SETC  ' NN   NN'\n&HEADC(136)  SETC  'O'\n&HEADC(137)  SETC  '  OOOOO '\n&HEADC(138)  SETC  ' OO   OO'\n&HEADC(139)  SETC  ' OO   OO'\n&HEADC(140)  SETC  ' OO   OO'\n&HEADC(141)  SETC  ' OO   OO'\n&HEADC(142)  SETC  ' OO   OO'\n&HEADC(143)  SETC  ' OO   OO'\n&HEADC(144)  SETC  '  OOOOO '\n&HEADC(145)  SETC  'P'\n&HEADC(146)  SETC  ' PPPPPP '\n&HEADC(147)  SETC  ' PP   PP'\n&HEADC(148)  SETC  ' PP   PP'\n&HEADC(149)  SETC  ' PP   PP'\n&HEADC(150)  SETC  ' PPPPPP '\n&HEADC(151)  SETC  ' PP     '\n&HEADC(152)  SETC  ' PP     '\n&HEADC(153)  SETC  ' PP     '\n&HEADC(154)  SETC  'Q'\n&HEADC(155)  SETC  '  QQQQQ '\n&HEADC(156)  SETC  ' QQ   QQ'\n&HEADC(157)  SETC  ' QQ   QQ'\n&HEADC(158)  SETC  ' QQ   QQ'\n&HEADC(159)  SETC  ' QQ Q QQ'\n&HEADC(160)  SETC  ' QQ  QQQ'\n&HEADC(161)  SETC  ' QQ   QQ'\n&HEADC(162)  SETC  '  QQQQQQ'\n&HEADC(163)  SETC  'R'\n&HEADC(164)  SETC  ' RRRRRR '\n&HEADC(165)  SETC  ' RR   RR'\n&HEADC(166)  SETC  ' RR   RR'\n&HEADC(167)  SETC  ' RR   RR'\n&HEADC(168)  SETC  ' RRRRRR '\n&HEADC(169)  SETC  ' RR RR  '\n&HEADC(170)  SETC  ' RR  RR '\n&HEADC(171)  SETC  ' RR   RR'\n&HEADC(172)  SETC  'S'\n&HEADC(173)  SETC  '  SSSSS '\n&HEADC(174)  SETC  ' SS   SS'\n&HEADC(175)  SETC  ' SS     '\n&HEADC(176)  SETC  '  SSSSS '\n&HEADC(177)  SETC  '      SS'\n&HEADC(178)  SETC  ' SS   SS'\n&HEADC(179)  SETC  ' SS   SS'\n&HEADC(180)  SETC  '  SSSSS '\n&HEADC(181)  SETC  'T'\n&HEADC(182)  SETC  'TTTTTTTT'\n&HEADC(183)  SETC  '   TT   '\n&HEADC(184)  SETC  '   TT   '\n&HEADC(185)  SETC  '   TT   '\n&HEADC(186)  SETC  '   TT   '\n&HEADC(187)  SETC  '   TT   '\n&HEADC(188)  SETC  '   TT   '\n&HEADC(189)  SETC  '   TT   '\n&HEADC(190)  SETC  'U'\n&HEADC(191)  SETC  ' UU   UU'\n&HEADC(192)  SETC  ' UU   UU'\n&HEADC(193)  SETC  ' UU   UU'\n&HEADC(194)  SETC  ' UU   UU'\n&HEADC(195)  SETC  ' UU   UU'\n&HEADC(196)  SETC  ' UU   UU'\n&HEADC(197)  SETC  ' UU   UU'\n&HEADC(198)  SETC  '  UUUUU '\n&HEADC(199)  SETC  'V'\n&HEADC(200)  SETC  ' VV   VV'\n&HEADC(201)  SETC  ' VV   VV'\n&HEADC(202)  SETC  ' VV   VV'\n&HEADC(203)  SETC  ' VV   VV'\n&HEADC(204)  SETC  ' VV   VV'\n&HEADC(205)  SETC  '  VV VV '\n&HEADC(206)  SETC  '   VVV  '\n&HEADC(207)  SETC  '    V   '\n&HEADC(208)  SETC  'W'\n&HEADC(209)  SETC  ' WW   WW'\n&HEADC(210)  SETC  ' WW   WW'\n&HEADC(211)  SETC  ' WW   WW'\n&HEADC(212)  SETC  ' WW   WW'\n&HEADC(213)  SETC  ' WW W WW'\n&HEADC(214)  SETC  ' WWWWWWW'\n&HEADC(215)  SETC  ' WWW WWW'\n&HEADC(216)  SETC  '  W   W '\n&HEADC(217)  SETC  'X'\n&HEADC(218)  SETC  ' XX   XX'\n&HEADC(219)  SETC  ' XX   XX'\n&HEADC(220)  SETC  '  XX XX '\n&HEADC(221)  SETC  '   XXX  '\n&HEADC(222)  SETC  '   XXX  '\n&HEADC(223)  SETC  '  XX XX '\n&HEADC(224)  SETC  ' XX   XX'\n&HEADC(225)  SETC  ' XX   XX'\n&HEADC(226)  SETC  'Y'\n&HEADC(227)  SETC  ' YY   YY'\n&HEADC(228)  SETC  ' YY   YY'\n&HEADC(229)  SETC  ' YY   YY'\n&HEADC(230)  SETC  '  YY YY '\n&HEADC(231)  SETC  '   YYY  '\n&HEADC(232)  SETC  '   YY   '\n&HEADC(233)  SETC  '   YY   '\n&HEADC(234)  SETC  '   YY   '\n&HEADC(235)  SETC  'Z'\n&HEADC(236)  SETC  ' ZZZZZZZ'\n&HEADC(237)  SETC  '      ZZ'\n&HEADC(238)  SETC  '     ZZ '\n&HEADC(239)  SETC  '    ZZ  '\n&HEADC(240)  SETC  '   ZZ   '\n&HEADC(241)  SETC  '  ZZ    '\n&HEADC(242)  SETC  ' ZZ     '\n&HEADC(243)  SETC  ' ZZZZZZZ'\n&HEADC(244)  SETC  '1'\n&HEADC(245)  SETC  '    11  '\n&HEADC(246)  SETC  '   111  '\n&HEADC(247)  SETC  '    11  '\n&HEADC(248)  SETC  '    11  '\n&HEADC(249)  SETC  '    11  '\n&HEADC(250)  SETC  '    11  '\n&HEADC(251)  SETC  '    11  '\n&HEADC(252)  SETC  '   1111 '\n&HEADC(253)  SETC  '2'\n&HEADC(254)  SETC  '   2222 '\n&HEADC(255)  SETC  '  22  22'\n&HEADC(256)  SETC  '      22'\n&HEADC(257)  SETC  '   2222 '\n&HEADC(258)  SETC  '  22    '\n&HEADC(259)  SETC  '  22    '\n&HEADC(260)  SETC  '  22    '\n&HEADC(261)  SETC  '  222222'\n&HEADC(262)  SETC  '3'\n&HEADC(263)  SETC  '   3333 '\n&HEADC(264)  SETC  '  33  33'\n&HEADC(265)  SETC  '      33'\n&HEADC(266)  SETC  '    33  '\n&HEADC(267)  SETC  '      33'\n&HEADC(268)  SETC  '  33  33'\n&HEADC(269)  SETC  '  33  33'\n&HEADC(270)  SETC  '   3333 '\n&HEADC(271)  SETC  '4'\n&HEADC(272)  SETC  '     44 '\n&HEADC(273)  SETC  '    444 '\n&HEADC(274)  SETC  '   4444 '\n&HEADC(275)  SETC  '  44 44 '\n&HEADC(276)  SETC  ' 4444444'\n&HEADC(277)  SETC  '     44 '\n&HEADC(278)  SETC  '     44 '\n&HEADC(279)  SETC  '     44 '\n&HEADC(280)  SETC  '5'\n&HEADC(281)  SETC  '  555555'\n&HEADC(282)  SETC  '  55    '\n&HEADC(283)  SETC  '  55    '\n&HEADC(284)  SETC  '  55555 '\n&HEADC(285)  SETC  '      55'\n&HEADC(286)  SETC  '  55  55'\n&HEADC(287)  SETC  '  55  55'\n&HEADC(288)  SETC  '   5555 '\n&HEADC(289)  SETC  '6'\n&HEADC(290)  SETC  '   6666 '\n&HEADC(291)  SETC  '  66  66'\n&HEADC(292)  SETC  '  66    '\n&HEADC(293)  SETC  '  66666 '\n&HEADC(294)  SETC  '  66  66'\n&HEADC(295)  SETC  '  66  66'\n&HEADC(296)  SETC  '  66  66'\n&HEADC(297)  SETC  '   6666 '\n&HEADC(298)  SETC  '7'\n&HEADC(299)  SETC  '  777777'\n&HEADC(300)  SETC  '      77'\n&HEADC(301)  SETC  '      77'\n&HEADC(302)  SETC  '     77 '\n&HEADC(303)  SETC  '    77  '\n&HEADC(304)  SETC  '   77   '\n&HEADC(305)  SETC  '   77   '\n&HEADC(306)  SETC  '   77   '\n&HEADC(307)  SETC  '8'\n&HEADC(308)  SETC  '   8888 '\n&HEADC(309)  SETC  '  88  88'\n&HEADC(310)  SETC  '  88  88'\n&HEADC(311)  SETC  '   8888 '\n&HEADC(312)  SETC  '  88  88'\n&HEADC(313)  SETC  '  88  88'\n&HEADC(314)  SETC  '  88  88'\n&HEADC(315)  SETC  '   8888 '\n&HEADC(316)  SETC  '9'\n&HEADC(317)  SETC  '   9999 '\n&HEADC(318)  SETC  '  99  99'\n&HEADC(319)  SETC  '  99  99'\n&HEADC(320)  SETC  '  99  99'\n&HEADC(321)  SETC  '   99999'\n&HEADC(322)  SETC  '      99'\n&HEADC(323)  SETC  '  99  99'\n&HEADC(324)  SETC  '   9999 '\n&HEADC(325)  SETC  '0'\n&HEADC(326)  SETC  '   0000 '\n&HEADC(327)  SETC  '  00  00'\n&HEADC(328)  SETC  '  00  00'\n&HEADC(329)  SETC  '  00 000'\n&HEADC(330)  SETC  '  000 00'\n&HEADC(331)  SETC  '  00  00'\n&HEADC(332)  SETC  '  00  00'\n&HEADC(333)  SETC  '   0000 '\n&HEADC(334)  SETC  '$'\n&HEADC(335)  SETC  '    $   '\n&HEADC(336)  SETC  '  $$$$$ '\n&HEADC(337)  SETC  ' $$ $ $$'\n&HEADC(338)  SETC  ' $$ $   '\n&HEADC(339)  SETC  '  $$$$$ '\n&HEADC(340)  SETC  '    $ $$'\n&HEADC(341)  SETC  ' $$ $ $$'\n&HEADC(342)  SETC  '  $$$$$ '\n&HEADC(343)  SETC  '#'\n&HEADC(344)  SETC  '  ## ## '\n&HEADC(345)  SETC  '  ## ## '\n&HEADC(346)  SETC  ' #######'\n&HEADC(347)  SETC  '  ## ## '\n&HEADC(348)  SETC  '  ## ## '\n&HEADC(349)  SETC  ' #######'\n&HEADC(350)  SETC  '  ## ## '\n&HEADC(351)  SETC  '  ## ## '\n&HEADC(352)  SETC  '@'\n&HEADC(353)  SETC  '  @@@@@ '\n&HEADC(354)  SETC  ' @     @'\n&HEADC(355)  SETC  ' @  @@ @'\n&HEADC(356)  SETC  ' @ @ @ @'\n&HEADC(357)  SETC  '  @  @ @'\n&HEADC(358)  SETC  ' @   @ @'\n&HEADC(359)  SETC  ' @   @ @'\n&HEADC(360)  SETC  '  @@@ @ '\n&HEADC(361)  SETC  ','\n&HEADC(362)  SETC  '        '\n&HEADC(363)  SETC  '        '\n&HEADC(364)  SETC  '        '\n&HEADC(365)  SETC  '        '\n&HEADC(366)  SETC  '   ,,   '\n&HEADC(367)  SETC  '   ,,   '\n&HEADC(368)  SETC  '    ,   '\n&HEADC(369)  SETC  '   ,    '\n&HEADC(370)  SETC  '.'\n&HEADC(371)  SETC  '        '\n&HEADC(372)  SETC  '        '\n&HEADC(373)  SETC  '        '\n&HEADC(374)  SETC  '        '\n&HEADC(375)  SETC  '        '\n&HEADC(376)  SETC  '   ..   '\n&HEADC(377)  SETC  '   ..   '\n&HEADC(378)  SETC  '        '\n&HEADC(379)  SETC  '('\n&HEADC(380)  SETC  '    ((  '\n&HEADC(381)  SETC  '   ((   '\n&HEADC(382)  SETC  '  ((    '\n&HEADC(383)  SETC  '  ((    '\n&HEADC(384)  SETC  '  ((    '\n&HEADC(385)  SETC  '  ((    '\n&HEADC(386)  SETC  '   ((   '\n&HEADC(387)  SETC  '    ((  '\n&HEADC(388)  SETC  ')'\n&HEADC(389)  SETC  '   ))   '\n&HEADC(390)  SETC  '    ))  '\n&HEADC(391)  SETC  '     )) '\n&HEADC(392)  SETC  '     )) '\n&HEADC(393)  SETC  '     )) '\n&HEADC(394)  SETC  '     )) '\n&HEADC(395)  SETC  '    ))  '\n&HEADC(396)  SETC  '   ))   '\n&HEADC(397)  SETC  '+'\n&HEADC(398)  SETC  '        '\n&HEADC(399)  SETC  '    +   '\n&HEADC(400)  SETC  '    +   '\n&HEADC(401)  SETC  '    +   '\n&HEADC(402)  SETC  ' +++++++'\n&HEADC(403)  SETC  '    +   '\n&HEADC(404)  SETC  '    +   '\n&HEADC(405)  SETC  '    +   '\n&HEADC(406)  SETC  '/'\n&HEADC(407)  SETC  '        '\n&HEADC(408)  SETC  '      //'\n&HEADC(409)  SETC  '     // '\n&HEADC(410)  SETC  '    //  '\n&HEADC(411)  SETC  '   //   '\n&HEADC(412)  SETC  '  //    '\n&HEADC(413)  SETC  ' //     '\n&HEADC(414)  SETC  '//      '\n&HEADC(415)  SETC  '\"'\n&HEADC(416)  SETC  '   \"\"   '\n&HEADC(417)  SETC  '   \"\"   '\n&HEADC(418)  SETC  '        '\n&HEADC(419)  SETC  '        '\n&HEADC(420)  SETC  '        '\n&HEADC(421)  SETC  '        '\n&HEADC(422)  SETC  '        '\n&HEADC(423)  SETC  '        '\n&HEADC(424)  SETC  '-'\n&HEADC(425)  SETC  '        '\n&HEADC(426)  SETC  '        '\n&HEADC(427)  SETC  '        '\n&HEADC(428)  SETC  '        '\n&HEADC(429)  SETC  ' -------'\n&HEADC(430)  SETC  ' -------'\n&HEADC(431)  SETC  '        '\n&HEADC(432)  SETC  '        '\n&HEADC(433)  SETC  '*'\n&HEADC(434)  SETC  '        '\n&HEADC(435)  SETC  '  *   * '\n&HEADC(436)  SETC  '   * *  '\n&HEADC(437)  SETC  ' *******'\n&HEADC(438)  SETC  '   * *  '\n&HEADC(439)  SETC  '  *   * '\n&HEADC(440)  SETC  '        '\n&HEADC(441)  SETC  '        '\n&HEADC(442)  SETC  'END'           MARKS END OF THE CHARACTER LIST\n.PROC    ANOP  ,\n.*\n.*\n         AIF   (K'&TITLE LE 0).NTITL\n.*\n         AIF   ('&TITLE' NE 'EJECT').NEJEC\n         EJECT\n         AGO   .NTITL\n.*\n.NEJEC   ANOP\n&TITLE(1) TITLE &TITLE(2)\n.*\n.*\n.NTITL   ANOP\n.*\n.*\n&K       SETA  K'&STRING\n         AIF   ((&K EQ 0) OR (&K GT 64)).DONE\n.*\n.*\n         AIF   ('&BLOCK' EQ 'NO').NBLK1\n MNOTE   '**************************************************************\n               **********'\n&B       SETC  '*'\n.NBLK1   ANOP  ,\n.*\n.*\n.*\n&M       SETA  1\n.COPY2   ANOP  ,\n&STR(&M) SETC  '&STRING'(&M,1)\n&M       SETA  &M+1\n         AIF   (&M LE &K).COPY2\n.*\n&J       SETA  0\n&M       SETA  0\n.*\n.*\n.EDIT    AIF   (&M EQ &K).AGIN\n&M       SETA  &M+1\n&I       SETA  &M\n         AIF   ('&STR(&M)' NE '''').EDIT\n.*\n         AIF   (&J GT 0).QTCK\n.*\n&J       SETA  1\n         AGO   .COMP\n.*\n.*\n.QTCK    AIF   ('&STR(&M+1)' NE '''').COMP\n.*\n&STR(&M) SETC  '\"'\n&J       SETA  0\n&M       SETA  &M+1\n&I       SETA  &M\n.*\n.*\n.COMP    ANOP\n&STR(&I) SETC  '&STR(&I+1)'\n&I       SETA  &I+1\n         AIF   (&I LT &K).COMP\n.*\n&STR(&K) SETC  ' '\n&K       SETA  &K-1\n&M       SETA  &M-1\n         AGO   .EDIT\n.*\n.*\n.AGIN    ANOP\n&I       SETA  1\n&L       SETA  &K-&N\n         AIF   (&L LE 0).ENDOFF\n.*\n         AIF   (&L LE 8).CK4\n.*\n&L       SETA  8\n.*\n.*\n.CK4     ANOP\n&J       SETA  (8-&L)/2*8\n.*\n.*\n.FILT    AIF   (&I GT &J).SETL\n.*\n&F(&I)   SETC  '        '\n&F(&I+1) SETC  '        '\n&F(&I+2) SETC  '        '\n&F(&I+3) SETC  '        '\n&F(&I+4) SETC  '        '\n&F(&I+5) SETC  '        '\n&F(&I+6) SETC  '        '\n&F(&I+7) SETC  '        '\n&I       SETA  &I+8\n         AGO   .FILT\n.*\n.*\n.SETL    ANOP\n&L       SETA  &L+&N\n.*\n.*\n.LOOP    AIF   (&N EQ &L).FINI\n.*\n&N       SETA  &N+1\n&J       SETA  1\n&W       SETC  '&STR(&N)'\n.*\n.*\n.MTCH    AIF   ('&W' EQ '&HEADC(&J)').GO\n.*\n&J       SETA  &J+9\n         AIF   ('&HEADC(&J)' NE 'END').MTCH\n&J       SETA  &J-9\n.*\n.*\n.GO      ANOP\n.*\n&F(&I)   SETC  '&HEADC(&J+1)'\n&F(&I+1) SETC  '&HEADC(&J+2)'\n&F(&I+2) SETC  '&HEADC(&J+3)'\n&F(&I+3) SETC  '&HEADC(&J+4)'\n&F(&I+4) SETC  '&HEADC(&J+5)'\n&F(&I+5) SETC  '&HEADC(&J+6)'\n&F(&I+6) SETC  '&HEADC(&J+7)'\n&F(&I+7) SETC  '&HEADC(&J+8)'\n&I       SETA  &I+8\n         AGO   .LOOP\n.*\n.*\n.FINI    AIF   (&I GT 64).DOIT\n.*\n&F(&I)   SETC  '        '\n&F(&I+1) SETC  '        '\n&F(&I+2) SETC  '        '\n&F(&I+3) SETC  '        '\n&F(&I+4) SETC  '        '\n&F(&I+5) SETC  '        '\n&F(&I+6) SETC  '        '\n&F(&I+7) SETC  '        '\n&I       SETA  &I+8\n         AGO   .FINI\n.*\n.*\n.DOIT    AIF   ('&BLOCK' EQ 'NO').SPACE\n MNOTE   '*                                                            *\n                        *'\n MNOTE   '*                                                            *\n                        *'\n         AGO   .DOIT2\n.SPACE   ANOP   ,\n         SPACE 2\n.DOIT2   ANOP  ,\n MNOTE   '&B  &F(1)&F(9)&F(17)&F(25)&F(33)&F(41)&F(49)&F(57)   &B'\n MNOTE   '&B  &F(2)&F(10)&F(18)&F(26)&F(34)&F(42)&F(50)&F(58)   &B'\n MNOTE   '&B  &F(3)&F(11)&F(19)&F(27)&F(35)&F(43)&F(51)&F(59)   &B'\n MNOTE   '&B  &F(4)&F(12)&F(20)&F(28)&F(36)&F(44)&F(52)&F(60)   &B'\n MNOTE   '&B  &F(5)&F(13)&F(21)&F(29)&F(37)&F(45)&F(53)&F(61)   &B'\n MNOTE   '&B  &F(6)&F(14)&F(22)&F(30)&F(38)&F(46)&F(54)&F(62)   &B'\n MNOTE   '&B  &F(7)&F(15)&F(23)&F(31)&F(39)&F(47)&F(55)&F(63)   &B'\n MNOTE   '&B  &F(8)&F(16)&F(24)&F(32)&F(40)&F(48)&F(56)&F(64)   &B'\n         AGO   .AGIN\n.*\n.*\n.ENDOFF  AIF   ('&BLOCK' EQ 'NO').DONE\n MNOTE   '*                                                            *\n                        *'\n MNOTE   '*                                                            *\n                        *'\n MNOTE   '**************************************************************\n               **********'\n.*\n.*\n.DONE    ANOP\n         SPACE 3\n         MEND\n./ ADD NAME=CLEAR    0101-00271-02078-2358-00044-00044-00001-SPGSRS\n         MACRO\n&LABEL   CLEAR &FIELD,&PAD=,&LEN=\n.*\n.*  CLEAR FIELD MACRO\n.*   NOTE : THE ASSEMBLER WILL VALIDATE IF THE SUPPLIED\n.*          PADDING CHARACTER IS VALID\n.*          DEFAULT PADDING CHARACTER IS SPACES\n.*\n         LCLA  &W,&F\n         LCLC  &L,&C,&R\n&L       SETC  'L'''\n&C       SETC  'C'' '''\n         AIF   (T'&PAD EQ 'O').GO\n&C       SETC  'C''&PAD'''\n         AIF   (K'&PAD EQ 1).GO\n&C       SETC  '&PAD'\n.GO      ANOP\n         AIF   ('&FIELD'(1,1) EQ '(').REGFORM\n&LABEL   MVI   &FIELD,&C      PUT PADDING CHARACTER\n         AIF   (T'&LEN NE 'O').WLEN\n&F       SETA  0              F = FIELD POSITION\n&W       SETA  K'&FIELD       W = LOOP COUNTER\n.LOOP1   ANOP                 FIND OUT IF FIELD HAS DISPLACEMENT\n&F       SETA  &F+1           NEXT POSITION\n         AIF   ('&FIELD'(&F,1) EQ '+').WDISP\n         AIF   ('&FIELD'(&F,1) EQ '-').WDISP\n&W       SETA  &W-1           REDUCE LOOP COUNTER\n         AIF   (&W GT 0).LOOP1\n         MVC   &FIELD+1(&L&FIELD-1),&FIELD      CLEAR REST OF FIELD\n         MEXIT\n.WDISP   AIF   (T'&LEN EQ 'O').ERROR\n.WLEN    ANOP\n&W       SETA  &LEN-1\n         MVC   &FIELD+1(&W),&FIELD              CLEAR REST OF FIELD\n         MEXIT\n.REGFORM AIF   (T'&LEN EQ 'O').ERROR\n&W       SETA  &LEN-1\n&LABEL   MVI   0&FIELD,&C     PUT PADDING CHARACTER\n&F       SETA  K'&FIELD-2     GET REGISTER LENGTH\n&R       SETC  '&FIELD'(2,&F) R = REGISTER NO.\n         MVC   1(&W,&R),0&FIELD                 CLEAR REST OF FIELD\n         MEXIT\n.ERROR   MNOTE 8,'**** LENGTH NOT SPECIFIED ****'\n         MEND\n./ ADD NAME=EPA      0100-02164-02164-1458-00031-00031-00000-SPGSRS\n         MACRO\n&NAME    EPA   &TEXT,&AMODE=,&RMODE=\n.*\n.*  ENTRY POINT ADDRESS (EPA) MACRO\n.*\n.*  THIS MACRO CREATES AN ENTRY POINT CSECT AND AN ENTRY POINT\n.*  IDENTIFIER. IF NO IDENTIFIER TEXT IS SUPPLIED, THE CSECT\n.*  NAME IS THE DEFAULT. THIS MACRO ALSO SAVES THE REGISTERS\n.*  USING THE SAVE MACRO INSTRUCTION.\n.*\n         LCLA  &L1\n         LCLC  &T1,&T2\n         AIF   (T'&NAME  EQ 'O').NOCSECT\n&T1      SETC  '&NAME'             SET DEFAULT VALUE\n&T2      SETC  '&NAME'\n         AIF   (T'&TEXT  EQ 'O').HEAD\n&L1      SETA  K'&TEXT-2           GET LENGTH OF TEXT W/O APOSTROPHE'S\n&T1      SETC  '&TEXT'(2,&L1)      EXTRACT TEXT INSIDE APOSTROPHE'S\n&T2      SETC  '&NAME - &T1'       ASSEMBLE TEXT\n.HEAD    ANOP\n         $HEAD &NAME,TITLE=(&NAME,' - &T1')\n&NAME    CSECT\n         AIF   (T'&AMODE EQ 'O').RMODE\n&NAME    AMODE &AMODE\n.RMODE   AIF   (T'&RMODE EQ 'O').SAVE\n&NAME    RMODE &RMODE\n.SAVE    ANOP\n         SAVE  (14,12),,&T2\n         MEXIT\n.NOCSECT MNOTE 12,'ENTRY ADDRESS OR CSECT NOT SPECIFIED'\n         MEND\n./ ADD NAME=MSG      0101-00271-02078-2358-00012-00012-00000-SPGSRS\n         MACRO\n&LABEL   MSG   &TEXT\n.*       GENERATES A MESSAGE TEXT\n.*  FORMAT:\n.*       BYTE 0 - AL2 - LENGTH OF TEXT + 2 (INCLUDES THESE BYTES)\n.*       BYTE 2 - C   - TEXT\n.*\n         LCLA  &A\n&A       SETA  K'&TEXT\n&LABEL   DC    AL2(&A)\n         DC    C&TEXT\n         MEND\n./ ADD NAME=MSGCP    0101-00271-02078-2359-00035-00035-00000-SPGSRS\n         MACRO\n&LABEL   MSGCP &TEXT,&OFFSET,&LAST\n.*       GENERATES A MESSAGE TEXT FOR COMMAND PROCESSORS\n.*  FORMAT:\n.*       WORD 0 - A   - ADDRESS OF NEXT SEGMENT (FOR MULTI LINE MSGS)\n.*       BYTE 0 - AL2 - LENGTH OF TEXT + 4 (INCLUDES THESE BYTES)\n.*       BYTE 2 - AL2 - OFFSET TO TEXT\n.*       BYTE 4 - C   - TEXT\n.*  -- ANY VALUE PLACED IN THE LAST OPERAND WILL MAKE THIS THE\n.*     LAST LINE IN A MULTI LINE MESSAGE\n.*\n         GBLC  &MSGCPL\n         LCLA  &A,&B\n&A       SETA  K'&TEXT+2\n&B       SETA  0\n         AIF   (T'&OFFSET EQ 'O').OK\n&B       SETA  &OFFSET\n.OK      ANOP\n         AIF   ('&MSGCPL' EQ '').SINGLE\n&MSGCPL  DS    0A\n         AIF   (T'&LAST EQ 'O').NOTLAST\n&MSGCPL  SETC  ''\n         DC    A(0)\n         AGO   .COMMON\n.NOTLAST ANOP\n&MSGCPL  SETC  '$MSG&SYSNDX'\n         DC    A(&MSGCPL)\n         AGO   .COMMON\n.SINGLE  ANOP\n&LABEL   DS    0A\n.COMMON  ANOP\n         DC    AL2(&A)\n         DC    AL2(&B)\n         DC    C&TEXT\n         MEND\n./ ADD NAME=MSGLIST  0101-00271-02078-2359-00007-00007-00000-SPGSRS\n         MACRO\n&LABEL   MSGLIST\n.*       GENERATES A MESSAGE LIST FOR COMMAND PROCESSORS\n         GBLC  &MSGCPL\n&LABEL   DS    0A\n&MSGCPL  SETC  '$MSG&SYSNDX'\n         MEND\n./ ADD NAME=MVTXT    0101-00271-02078-2359-00015-00015-00001-SPGSRS\n         MACRO\n&LABEL   MVTXT &FIELD,&TEXT\n.*\n.*  MOVES A CONSTANT TO A FIELD\n.*\n         LCLA  &TL\n         LCLC  &C\n&TL      SETA  K'&TEXT-2      REMOVE QUOTES\n&C       SETC  '&FIELD(1)'\n         AIF   ('&FIELD'(1,1) EQ '(').REGFORM\n&LABEL   MVC   &C.(&TL),=C&TEXT    MOVE CONSTANT\n         MEXIT\n.REGFORM ANOP\n&LABEL   MVC   0(&TL,&C),=C&TEXT   MOVE CONSTANT\n         MEND\n./ ADD NAME=PARSEMSG 0101-00271-02079-0000-00026-00026-00001-SPGSRS\n         MACRO\n         PARSEMSG\n         LCLC  &L1,&L2,&L3,&L4,&L5,&L6,&L7\n&L1      SETC  'PC04&SYSNDX'\n&L2      SETC  'PC08&SYSNDX'\n&L3      SETC  'PC0C&SYSNDX'\n&L4      SETC  'PC10&SYSNDX'\n&L5      SETC  'PC14&SYSNDX'\n&L6      SETC  'PC18&SYSNDX'\n&L7      SETC  'PC1C&SYSNDX'\n&L1      MSGCP 'SYNTAX ERROR - COMMAND CANNOT PROMPT'\n&L2      MSGCP 'ATTENTION INTERRUPT OCCURRED'\n&L3      MSGCP 'PCL ERROR'\n&L4      MSGCP 'NECESSARY AREA COULD NOT BE OBTAINED'\n&L5      MSGCP 'VALIDITY CHECK ROUTINE TERMINATED PROCESSING'\n&L6      MSGCP 'PCE ERROR'\n&L7      MSGCP 'TERMINAL WAS DISCONNECTED'\nPARSEMSG DC    A(0)\n         DC    A(&L1)\n         DC    A(&L2)\n         DC    A(&L3)\n         DC    A(&L4)\n         DC    A(&L5)\n         DC    A(&L6)\n         DC    A(&L7)\n         MEND\n./ ADD NAME=SBA      0107-01148-02079-0000-00035-00025-00035-SPGSRS\n.*       SET BUFFER ADDRESS MACRO FOR 3270 TERMINALS\n.*\n.*       USAGE:     SBA ROW,COL,LEN\n.*       WHERE LEN IS AN OPTIONAL VALUE (DEFAULT IS 80) OF THE\n.*             COLUMN WIDTH OF THE TERMINAL\n.*\n         MACRO\n&LABEL   SBA   &LN,&CL,&LL\n         LCLA  &VAL,&IX,&LINELEN\n         LCLC  &R,&C         ROW,COL\n         LCLC  &H,&L         HIGH & LOW NIBBLE\n.*             ----------------------\n.*             INITIALIZE BIT PATTERN\n.*             TABLE IS SET AS HIGH AND LOW NIBBLES TO AVOID\n.*             CODING PROBLEMS W/ THE '&' OR X'50' CHARACTER\n.*             ----------------------\n&H       SETC  '4CCCCCCCCC4444445DDDDDDDDD55555566EEEEEEEE666666'\n&L       SETC  '0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF'\n&H       SETC  '&H'.'FFFFFFFFFF777777'\n&L       SETC  '&L'.'0123456789ABCDEF'\n.*             ----------------------\n&LINELEN SETA  80\n         AIF   (T'&LL EQ 'O').VAL\n&LINELEN SETA  &LL\n.VAL     ANOP\n&VAL     SETA  &LINELEN*(&LN-1)+(&CL-1)\n.*                           CALCULATE ROW VALUE\n&IX      SETA  &VAL/64+1     SRL RX,6 -> 11XXXXXX -> 00000011 DROP X\n&R       SETC  '&H'(&IX,1).'&L'(&IX,1)  SET BYTE 1 HIGH & LOW NIBBLE\n.*                           CALCULATE COL VALUE\n&IX      SETA  &VAL-((&VAL/64)*64)+1\n&C       SETC  '&H'(&IX,1).'&L'(&IX,1)  SET BYTE 2 HIGH & LOW NIBBLE\n.SBAEND  ANOP\n&LABEL   DC    X'11&R&C'     SBA ORDER+BYTE1+BYTE2\n         MEND\n./ ADD NAME=SF       0107-00271-02079-0001-00080-00085-00000-SPGSRS\n         MACRO\n&LABEL   SF    &ATTR\n         LCLA  &IX,&VAL\n         LCLC  &B1,&B2,&BIT2\n         LCLB  &PROT,&NUM,&LU,&LD,&LDH,&NON,&MDT,&CUR\n         LCLB  &BLK,&RVS,&OVL,&UDL,&VTL\n         LCLC  &H,&L         HIGH & LOW NIBBLE BIT PATTERNS\n.*             ----------------------\n.*             INITIALIZE BIT PATTERN\n.*             TABLE IS SET AS HIGH AND LOW NIBBLES TO AVOID\n.*             CODING PROBLEMS W/ THE '&' OR X'50' CHARACTER\n.*             ----------------------\n&H       SETC  '4CCCCCCCCC4444445DDDDDDDDD55555566EEEEEEEE666666'\n&L       SETC  '0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF'\n&H       SETC  '&H'.'FFFFFFFFFF777777'\n&L       SETC  '&L'.'0123456789ABCDEF'\n.*             ----------------------\n&BIT2    SETC  '00'\n&PROT    SETB  0\n&NUM     SETB  0\n&LU      SETB  0\n&LD      SETB  0\n&LDH     SETB  0\n&NON     SETB  0\n&MDT     SETB  0\n&BLK     SETB  0\n&RVS     SETB  0\n&OVL     SETB  0\n&UDL     SETB  0\n&VTL     SETB  0\n&CUR     SETB  0\n&IX      SETA  N'&ATTR+1\n.LOOP    AIF   (&IX EQ 1).SETBIT\n&IX      SETA  &IX-1\n         AIF   ('&ATTR(&IX)' NE 'CUR').SKIP\n&CUR     SETB  1\n.SKIP    AIF   ('&ATTR(&IX)' NE 'SKIP').PROT\n&PROT    SETB  1\n&NUM     SETB  1\n.PROT    AIF   ('&ATTR(&IX)' NE 'PROT').NUM\n&PROT    SETB  1\n.NUM     AIF   ('&ATTR(&IX)' NE 'NUM').NON\n&NUM     SETB  1\n.NON     AIF   ('&ATTR(&IX)' NE 'NON').LD\n&BIT2    SETC  '11'\n         AGO   .MDT\n.LD      AIF   ('&ATTR(&IX)' NE 'LD').LDH\n&BIT2    SETC  '01'\n         AGO   .MDT\n.LDH     AIF   ('&ATTR(&IX)' NE 'LDH').MDT\n&BIT2    SETC  '10'\n.MDT     AIF   ('&ATTR(&IX)' NE 'MDT').BLK\n&MDT     SETB  1\n.BLK     AIF   ('&ATTR(&IX)' NE 'BLK').RVS\n&BLK     SETB  1\n.RVS     AIF   ('&ATTR(&IX)' NE 'RVS').OVL\n&RVS     SETB  1\n.OVL     AIF   ('&ATTR(&IX)' NE 'OVL').UDL\n&OVL     SETB  1\n.UDL     AIF   ('&ATTR(&IX)' NE 'UDL').VTL\n&UDL     SETB  1\n.VTL     AIF   ('&ATTR(&IX)' NE 'VTL').NEXT\n&VTL     SETB  1\n.NEXT    AGO   .LOOP\n.SETBIT  ANOP\n&B1      SETC  'B''&PROT&NUM&BIT2'.'0'.'&MDT'''\n&VAL     SETA  &B1+1         BINARY TO DECIMAL\n&B1      SETC  '&H'(&VAL,1).'&L'(&VAL,1)\n.SFTEST  AIF   (NOT(&BLK OR &RVS OR &OVL OR &UDL OR &VTL)).SF\n&B2      SETC  'B''&BLK&RVS&OVL&UDL&VTL'.'0'''\n&VAL     SETA  &B2+1         BINARY TO DECIMAL\n&B2      SETC  '&H'(&VAL,1).'&L'(&VAL,1)\n&LABEL   DC    X'1B&B1&B2'   SFE ORDER+BYTE1+BYTE2\n         AGO   .CURCHK\n.SF      ANOP\n&LABEL   DC    X'1D&B1'      SF ORDER+BYTE1\n.CURCHK  AIF   (NOT(&CUR)).MXIT\n         DC    X'13'         SET CURSOR TO THIS FIELD\n.MXIT    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MESSAGE": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00\\x11\\x01\\x02\\t\\x7f\\x01\\x02\\x10\\x0f!U\\x00(\\x00'\\x00\\x06\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-04-07T00:00:00", "modifydate": "2002-04-10T21:55:11", "lines": 40, "newlines": 39, "modlines": 6, "user": "SPGSRS"}, "text": "MESSAGE  EPA   'SENDS A MESSAGE TO THE OPERATOR FROM THE COMMAND LINE'\n         BALR  12,0                12 IS BASE REGISTER\n         USING *,12                TELL ASSEMBLER\n         USING CMDLINE,11\n         USING WORKSTG,13\n         L     11,0(,1)            GET ADDRESS OF PARM LINE\n         LA    0,WKLEN\n         GETMAIN R,LV=(0)\n         ST    13,4(,1)            SAVE CALLER'S SVAREA ADDRESS\n         ST    1,8(,13)            SET BACKWARD CHAIN\n         LR    13,1                SET FORWARD CHAIN\n         LH    2,CMDLEN\n         CHI   2,1                 ANY PARMS PASSED ?\n         BL    EXIT\nSENDMSG  LA    0,WTOLEN\n         GETMAIN R,LV=(0)\n         LR    3,1\n         MVC   0(WTOLEN,3),WTOPUT  CREATE WTO CONTROL BLOCK\n         WTO   TEXT=(11),MF=(E,(3)) SEND MESSAGE FROM PARM AREA\n         LA    0,WTOLEN\n         FREEMAIN R,LV=(0),A=(3)\nEXIT     LR    1,13\n         L     13,4(,13)\n         LA    0,WKLEN\n         FREEMAIN R,LV=(0),A=(1)\n         XR    15,15               SET RC=0\n         RETURN (14,12),,RC=(15)   RESTORE REGS AND QUIT\n*-------\nWTOPUT   WTO   TEXT=,MF=L\nWTOLEN   EQU   *-WTOPUT\n*-------\nWORKSTG  DSECT\nSTACK    DS    18F\n         DS    0F                  FULL WORD ALIGN PARMS\nWKLEN    EQU   *-WORKSTG\nCMDLINE  DSECT\nCMDLEN   DS    1H\nMSG      DS    C                   MESSAGE TO BE SENT\nWTOAREA  DSECT\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAUSE": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x000\\x01\\x02\\t\\x7f\\x01\\x02\\x10\\x0f!X\\x003\\x00?\\x003\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-07T00:00:00", "modifydate": "2002-04-10T21:58:30", "lines": 51, "newlines": 63, "modlines": 51, "user": "SPGSRS"}, "text": "PAUSE    EPA   'SENDS A MESSAGE TO THE OPERATOR AND WAITS'\n         BALR  12,0                12 IS BASE REGISTER\n         USING *,12                TELL ASSEMBLER\n         USING CMDLINE,11\n         USING WORKSTG,13\n         L     11,0(,1)            GET ADDRESS OF PARM LINE\n         LA    0,WKLEN\n         GETMAIN R,LV=(0)\n         ST    13,4(,1)            SAVE CALLER'S SVAREA ADDRESS\n         ST    1,8(,13)            SET BACKWARD CHAIN\n         LR    13,1                SET FORWARD CHAIN\n         LH    2,CMDLEN\n         LA    8,DEFLTMSG          USE DEFAULT MESSAGE IF NONE GIVEN\n         CHI   2,1                 ANY MESSAGE PASSED?\nNOPARMS  BL    SENDMSG             NO -- OTHERWISE\n         LR    8,11                USE MESSAGE FROM PARM LINE\nSENDMSG  LA    0,WTOLEN            INPUT --\n         GETMAIN R,LV=(0)             R8 -- ADDRESS OF MESSAGE\n         LR    3,1                    R3 -- WTO CONTROL BLOCK\n         MVC   0(WTOLEN,3),WTOPUT\n         WTO   TEXT=(8),MF=(E,(3)) SEND MESSAGE TO CONSOLE\nWAIT     LA    4,ECB               INPUT --\n         LA    2,RPLY                 R2 -- ADDRESS OF REPLY AREA\n         LA    8,WTOGET               R8 -- TEXT ADDRESS\n         OI    12(3),X'08'            SET REPLY\n         WTOR  TEXT=((8),(2),1,(4)),MF=(E,(3),EXTENDED)\n         WAIT  ECB=(4)                R4 -- ECB ADDRESS\n         LA    0,WTOLEN\n         FREEMAIN R,LV=(0),A=(3)\n         CLI   RPLY,C'X'\n         BNE   CODE0\n         ABEND 222                 ABEND THE JOB CODE=222\nCODE0    LR    1,13\n         L     13,4(,1)\n         LA    0,WKLEN\n         FREEMAIN R,LV=(0),A=(1)\n         XR    15,15               SET RC=0\n         RETURN (14,12),,RC=(15)   RESTORE REGS AND QUIT\nWTOPUT   WTO   TEXT=,MF=L\nWTOLEN   EQU   *-WTOPUT\nDEFLTMSG MSG   'JOB NOW IN PAUSE STATE, ENTER REPLY'\nWTOGET   MSG   'REPLY ANY KEY TO PROCEED, -X- TO END'\nWORKSTG  DSECT\n         DS    18F\nRPLY     DS    1F\nECB      DS    1F\nWKLEN    EQU   *-WORKSTG\nCMDLINE  DSECT\nCMDLEN   DS    1H\nMSG      DS    C                   MESSAGE TO BE SENT\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TST9": {"ttr": 1804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x005\\x01\\x02\\x07\\x9f\\x01\\x02\\x07\\x9f\\x18\\x10\\x00d\\x00d\\x00\\x00\\xe2\\xd7\\xc7\\xe2\\xd9\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-20T00:00:00", "modifydate": "2002-03-20T18:10:35", "lines": 100, "newlines": 100, "modlines": 0, "user": "SPGSRS"}, "text": "FMUX3    EPA   'PUTLINE GETLINE TEST PROGRAM'\n         BALR  12,0                12 IS BASE REGISTER\n         USING *,12                TELL ASSEMBLER\n         USING CPPL,11\n         USING WKSTG,10\n         USING CSOA,2\n         LR    11,1\n         LA    0,WKLEN\n         GETMAIN R,LV=(0)\n         LR    10,1\n         ST    13,STACK+4          SAVE CALLER'S SVAREA ADDRESS\n         LA    9,STACK             LOAD SAVE AREA JUST IN CASE\n         ST    9,8(,13)            SET BACKWARD CHAIN\n         LR    13,9                SET FORWARD CHAIN\n         MVC   WCPPL(16),0(11)     COPY CPPL\n         LOAD  EPLOC=GUS015E\n         ST    0,GUS015\n         LOAD  EPLOC=GUS016E\n         ST    0,GUS016\n         LOAD  EPLOC=GUS017E\n         ST    0,GUS017\n         XC    GUS015W,GUS015W\n         ST    11,GUS015W\n         MVC   GUS016W,GUS015W\n         MVC   GUS017W(12),GUS016W\n         LA    8,WCSOA\n         ST    8,GUS015W+4\n*\n         L     15,GUS016\n         CALL  (15),(,,MSG1),VL,MF=(E,GUS016W)\n         LA    5,10                DO 10 TIMES\nLOOP     L     15,GUS017\n         CALL  (15),MF=(E,GUS017W)\n         LTR   8,15                GET GETLINE RETCODE\n         BNZ   ENDER\n         L     7,GUS017BF          GET FORMATTED LINE ADDRESS\n         L     15,GUS015\n         CALL  (15),(,,(7)),MF=(E,GUS015W) SCAN GETLINE\n         LA    2,WCSOA\n         L     15,CSOACNM          GET EPLOC NAME ADDRESS\n         LTR   15,15\n         BZ    NEXTCMD             IGNORE IF NO COMMAND ENTERED\n         LH    14,CSOALNM\n         BCTR  14,0\n         CLEAR EPLOC\n$$$MV    MVC   EPLOC(1),0(15)      MOVE EPLOC NAME\n         EX    14,$$$MV\n         ST    7,WCPPL             STORE COMMAND LINE\n         LA    1,WCPPL\n         LA    14,EPLOC\n         LINK  EPLOC=(14),MF=(E,(1))\n         STFSMODE OFF\n         L     15,GUS016\n         CALL  (15),(,,MSG2),VL,MF=(E,GUS016W)\nNEXTCMD  BCT   5,LOOP\n*\n         ANOP  0,4\nENDER    L     15,GUS016\n         CALL  (15),(,,MSG3),VL,MF=(E,GUS016W)\n         L     15,GUS016\n         CALL  (15),(,),VL,MF=(E,GUS016W)\n         L     15,GUS017\n         CALL  (15),(,),VL,MF=(E,GUS017W)\n         L     1,GUS017W+8         GET FREEMAIN ADDRESS\n         LH    0,0(,1)\n         ICM   0,8,=X'01'          SUBPOOL 1\n         FREEMAIN R,LV=(0),A=(1)\n         DELETE EPLOC=GUS015E\n         DELETE EPLOC=GUS016E\n         DELETE EPLOC=GUS017E\n         L     13,STACK+4\n         LA    0,WKLEN\n         FREEMAIN R,LV=(0),A=(10)\n         LR    15,8                SET RETURN CODE\n         RETURN (14,12),,RC=(15)   RESTORE AND QUIT\nGUS015E  DC    CL8'GUS015'\nGUS016E  DC    CL8'GUS016'\nGUS017E  DC    CL8'GUS017'\nMSG1     MSGCP 'ENTER A COMMAND'\nMSG2     MSGCP 'ENTER NEXT COMMAND'\nMSG3     MSGCP 'ABOUT TO FREEMAIN'\nWKSTG    DSECT\nECB      DS    F\nSTACK    DS    18F\nGUS015W  DS    3A\nGUS016W  DS    3A\nGUS017W  DS    2A\nGUS017BF DS    A\nGUS015   DS    A\nGUS016   DS    A\nGUS017   DS    A\nWCSOA    DS    A\n         DS    A\nWCPPL    DS    4A\nEPLOC    DS    CL8\nRC       DS    F\nWKLEN    EQU   *-WKSTG\n         IKJCPPL\n         IKJCSOA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT555/FILE555.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT555", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}