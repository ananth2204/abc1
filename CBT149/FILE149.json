{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011341000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 3174444, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 21, "INMDSNAM": "CBT.V500.FILE149.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 3174444, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 3174444, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE149.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x002\\n'", "DS1TRBAL": "b'\\x04\\xa6'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\x10\\x00\\t\\x01\\x13\\x00\\x0e\\x003'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04Y\\x00\\x02\\x01\\x14\"\\x7f\\x01\\x14\"\\x7f\\x17\\x17\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf9@@@'", "ispf": {"version": "04.89", "flags": 0, "createdate": "2014-08-15T00:00:00", "modifydate": "2014-08-15T17:17:02", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-489"}, "text": "REGULAR CBT TAPE - VERSION 489    FILE:  149\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT489.FILE149\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 91 MEMBERS COUNTED; CUMULATIVE SIZE IS 29,291 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   08/15/14    17:17:02    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x8e\\x00\\x8e\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 142, "newlines": 142, "modlines": 0, "user": "FILE149"}, "text": "THIS MEMBER WAS ADDED AT CBT. WHAT I DID WAS MERGE THE PDS'S INTO\nONE BIG PDS.\nI RENAME NAME EACH DESCRIPTION MEMBER FROM *MEMBER TO $MEMBER\n\nI ALSO HAD TO CHANGE RENAME ONE SOURCE MODULE SO IT WOULD NOT\nCONFLICT WITH A MACRO OF THE SAME NAME\n   I RENAME OACFSORT TO OACFS0RT\n\n        ARNOLD CASINGHINO, CONNECTICUT BANK AND TRUST COMPANY\n\n*-----------------------------------------------------------------------\n*\nTHE FOLLOWING IS WHAT I RECEIVED FROM UCLA IN THEIR FILE 001\n*\n*-----------------------------------------------------------------------\n*\n*  UCLA/OAC MODS FOR CBT TAPE 08/04/82  SHARE INSTALLATION CODE (UR)\n*             (PREVIOUSLY UCLA/CCN)\n*\n* TAPE FORMAT:\n*\n*   FILE 1 - THIS DESCRIPTION FOLLOWED BY JCL USED TO CREATE TAPE\n*            CALLED $$DOC IN THIS PDS\n*\n*   FILE 2 - IEBCOPY UNLOAD PDS *** OAC LOCAL MACROS\n*            OVERLAYED A '$' IN THE FIRST POSITION OF THE MEMBER NAME\n*\n*   FILE 3 - IEBCOPY UNLOAD PDS *** OAC LOCAL MACRO DESCRIPTIONS\n*            AS RECEIVED\n*\n*   FILE 4 - IEBCOPY UNLOAD PDS *** MODULE INFO\n*            ADD A '$' AS THE FIRST POSITION OF THE MEMBER NAME\n*\n*   FILE 5 - IEBCOPY UNLOAD PDS *** MODULE SOURCE,\n*                                   SMP CNTL (@ PREFIX)\n*            AS RECEIVED EXECPT THAT OACFSORT WAS RENAME OACFS0RT\n*                                         -                   -\n*\n*-----------------------------------------------------------------------\n*\n* BRIEF DESCRIPTIONS:\n*\n*  CCNEDFSE/CCNEDFSH - FULL SCREEN TSO EDIT SUBCOMMAND FOR 3270'S.\n*       THIS INCLUDES MOVE/COPY/DELETE COMMANDS WHICH ALLOW LINE\n*       NUMBERS ON UNNUMBERED FILES.\n*       REQUIRES ZAP TO IKJEBEMA TO ADD TO EDIT COMMAND TABLE.\n*       (SEE INFO @CNEDFSE)\n*\n*  CMSLOAD - LOAD \"DISK DUMP\" FILE FROM VM.\n*\n*  COMPARE - LOAD MODULE / CSECT COMPARE PROGRAM.  *** REQUIRED ***\n*\n*  DUMPINFO - TSO CP TO DISPLAY SYS1.DUMP DATASET STATUS.  INCLUDES\n*             TITLE, DATE AND TIMES.\n*\n*  ENQ - SP1.3 ENQ DISPLAY TSO CP\n*\n*  ESDXREF - LOAD MODULE / CSECT XREF PGM\n*\n*  IEAVNP99 - SAMPLE USER NIP EXIT ROUTINE.\n*            SEE @EAVNP99 FOR SAMPLE SMP INSTALL.\n*\n*  IEFU83 - SMF 83 EXIT WITH CODE TO WTO OLD IEC209I TAPE STATISTICS\n*           MESSAGE.  (THE REST OF THE LOCAL CODE SHOULD BE DELETED).\n*\n*  IXTOFMT5 - SUBROUTINE USED TO UPGRADE PGMS TO WORK ON INDEXED VTOC'S.\n*           RETURNS \"FAKE\" FMT5'S FOR INDEXED PACKS.\n*           (USED BY LISTSPC AND VTOCLIST)\n*\n*  JOIN - VERY SIMPLE & POWERFUL GENERAL MATCH MERGE PGM.\n*\n*  LISTGRP - LISTS UNITS IN GENERIC'S, OR GENERICS.\n*\n*  LISTSPC - OLD LISTSPC CP FROM CBT TAPE UPDATED FOR INDEXED VTOCS.\n*            (USES IXTOFMT5 SUBROUTINE).\n*\n*  MOVEZAP - ZAP'S TO (COPY) OF IEHMOVE TO ALLOW RUNNING\n*            FASTER & NON-AUTHORIZED.\n*\n*  OACFSORT - ASM SUBROUTINE TO DO FIXED LEN QUICKSORTS.\n*            (FINAL ORDER CHECK COULD BE REMOVED FOR HIGH USAGE CASES)\n*\n*  OACMOVE - IEHMOVE PRELOAD PGM. (SEE ALSO MOVEZAP)\n*\n*  OACNSWAP - PGM TO RUN PROBLEM PROGRAMS NON-SWAPPABLE WITH ONLY\n*            ONE PPT ENTRY.  PGM IS NOT APF AUTHORIZED.\n*            (SEE @ACNSWAP FOR PPT ENTRY INFO).\n*\n*  PTFXREF - PE CHAIN RUNNER (PLIX).\n*\n*  SALVAGE - HDA / PACK CLEAN UP PGM (& CP).\n*\n*  SMPULCMP - SMP LMOD ENTRY (FROM SMP UNLOAD) COMPARE. USED IN\n*            SP1.0 TO SP1.3 CONVERSION (AND OTHER TIMES). (PLIX)\n*\n*  TAPEMAP - TAPE FILE LISTER PGM (KNOWS LENGTHS, IEBCOPY/IEBUPDTE ETC)\n*\n*  UNIQUE - VERY SIMPLE PGM TO SELECT ONE OF THINGS. (SEE ALSO JOIN)\n*\n*  USERS - TSO USERS CP (SELECTS USERS WITH WILDCARDS).\n*\n*  VTOCLIST - OLD VTOCLIST PGM UPDATE TO WORK ON INDEXED VTOCS.\n*            (USES IXTOFMT5 SUBROUTINE)\n*\n*-----------------------------------------------------------------------\n//CSYSMASA JOB ACCT,MSGCLASS=A,NOTIFY=CSYSMAS,TIME=2\n/*ROUTE PRINT WYLBUR\n//GENER EXEC PGM=IEBGENER\n//SYSPRINT   DD SYSOUT=*\n//SYSIN      DD DUMMY\n//SYSUT1     DD DISP=SHR,DSN=CSYSMAS.T.$DOC\n//           DD DISP=SHR,DSN=CSYSMAS.T.$TAPE\n//SYSUT2     DD DISP=(NEW,KEEP),DSN=TOCBT.TAPE,\n//  UNIT=3400-6,VOL=(,RETAIN,SER=GSM600),LABEL=(01,NL,,OUT),\n//  DCB=(LRECL=80,RECFM=FB,BLKSIZE=3120)\n//*\n//COPY EXEC PGM=IEBCOPY\n//SYSPRINT DD SYSOUT=*\n//I2       DD DISP=SHR,DSN=SYS5.MSSMAC   ** LOCAL MACROS **\n//O2       DD DISP=SHR,DSN=TOCBT.TAPE.F2,\n//  UNIT=3400-6,VOL=(,RETAIN,SER=GSM600),LABEL=(02,NL,,OUT),\n//  DCB=(RECFM=VBS,BLKSIZE=32000)\n//I3       DD DISP=SHR,DSN=SYS5.MSSMHELP ** LOCAL MACRO HELP **\n//O3       DD DISP=SHR,DSN=TOCBT.TAPE.F3,\n//  UNIT=3400-6,VOL=(,RETAIN,SER=GSM600),LABEL=(03,NL,,OUT),\n//  DCB=(RECFM=VBS,BLKSIZE=32000)\n//I4       DD DISP=SHR,DSN=CSYSMAS.T.INFO ** MODULE INFO **\n//O4       DD DISP=SHR,DSN=TOCBT.TAPE.F4,\n//  UNIT=3400-6,VOL=(,RETAIN,SER=GSM600),LABEL=(04,NL,,OUT),\n//  DCB=(RECFM=VBS,BLKSIZE=32000)\n//I5       DD DISP=SHR,DSN=CSYSMAS.T.SOURCE ** MODULE SOURCE **\n//O5       DD DISP=SHR,DSN=TOCBT.TAPE.F5,\n//  UNIT=3400-6,VOL=(,RETAIN,SER=GSM600),LABEL=(05,NL,,OUT),\n//  DCB=(RECFM=VBS,BLKSIZE=32000)\n//SYSIN    DD *\n  C I=I2,O=O2\n  C I=I3,O=O3\n  C I=I4,O=O4\n  C I=I5,O=O5\n//MAP EXEC TAPEMAP,VOLID=GSM600,UNIT='3400-6',PARM=NL,LABEL=NL\n//\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ACACTDA": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "FILE149"}, "text": "1                         DA SPACE ACCOUNTING RECORD\n\n NAME     OACACTDA  DSECT= YES,\n                    PREFIX= DA#\n\n          NAME      DSECT or data structure name\n\n          DSECT =   YES or NO\n                       YES - generate standard assembler dsect\n                       NO  - generate data structure prefixed with\n                             'NAME   equ   *'\n          PREFIX=   Prefix to be used for generated data names. The\n                    maximum allowable length of this field is three\n                    characters.\n\n-NOTES:\n\n          This macro also contains a PLI macro defining the da space\n          accounting record format. To use this macro, the following\n          PLI compile options must be coded:\n\n             MARGINS(2,72)\n             MACRO\n\n          Note that PLI currently will not allow use of a compile time\n          macro library with a BLKSIZE equal to that of SYS5.MSSMAC.\n          The error message returned implies that specification of a\n          larger run size will resolve the problem. Running in a region\n          of 7500K still yields the error message. Thus if this Pli\n          macro form is to be used with the PLI preprocessor, the macro\n          must be copied to a library with a smaller blksize (3120).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ACACTWK": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x17\\x00\\x17\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "FILE149"}, "text": "                           OAC accounting work area def\n\n name     OACACTWK  DSECT=,\n                    PREFIX=\n\n   The OACACTWK macro describes the accounting work area used\n internally by the initiator and related routines at OAC.\n\n-- DSECT=YES\n  If this keyword is specified as NO then no dsect card will be\n  generated, otherwise a dsect will be generated.\n\n-- PREFIX=ACT\n  This specifies the prefix to be used to generate labels\n  in the macro expansion. (This allows multiple expansions of this\n  area in one assembly.\n\n\n The use of this macro is restricted to system routines\n involved with the initiator or accouting.  A severity 21\n MNOTE will result if used in other than specific routines.\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ACBLDPL": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00B\\x00B\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "FILE149"}, "text": "                 OAC build TSO service parm lists macro\n\nlabel    OACBLDPL CPPL=,ECB=,RS=R0,RT=R15,                             x\n                  IOPL=,CSPL=,PPL=,DFPL=,DRFAIL=,gnrfail=\n\n     label  - The label which is to appear on the first generated\n              instruction\n\n     CPPL=  - The address of the CPPL passed to the command at\n              entry.\n\n     ECB=   - The address of a fullword to be used as an attention\n              ecb by the TSO service routines\n\n     RS=    - A register to be used as a work regiser in the macro\n\n     Rt=    - A register to be used as a work regiser in the macro\n\n     IOPL= (iopl,iopb)    - If not coded, the IOPL will not be built\n              iopl - The address of an IOPL to be filled in by the\n                     macro\n              iopb - The address of an IOPB which is to be stored in\n                     the IOPL. If not coded, no address is stored.\n\n     CSPL=(cspl,flags,csoa,cbuf) - If not coded no CSPL will be built\n              cspl - The address of a CSPL to be filled in by the\n                     macro.\n              flags- The address of the flag word which is to be\n                     stored in the CSPL. If not coded, is not stored.\n              csoa - The address of a CSOA which is to be stored in\n                     the CSPL. If not coded, is not stored.\n              cbuf - The address of a command buffer which is to be\n                     stored in the CSPL. If not coded, is not stored.\n\n     PPL=(ppl,pcl,ans,cbuf,uwa)  - If not coded no PPL will be built\n              ppl  - The address of a PPL to be filled in by the macro.\n              pcl  - The address of a PCL which is to be stored in the\n                     PPL. If not coded, is not stored.\n              ans  - The address of the \"answer place\" which is to be\n                     stored in the PPL. If not coded is not stored.\n              cbuf - The address of the command buffer which is to be\n                     stored in the PPL. If not coded is not stored.\n              uwa  - The address of a USER WORK AREA which is to be\n                     stored in the PPL.\n\n     DFPL=(dfpl,dfpb)            - If not coded no DFPL will be built\n              dfpl - The address of a DFPL to be filled in by the macro.\n              dfpb - The address of a DFPB which is to be stored in the\n                     DFPL. If not coded, is not stored.\n\n     DRFAIL=(dfparms,rbp,rcp,jeff02,idp,bufp)\n              dfparms - The address of the DAIRFAIL parm area to be\n                        filled in by this macro\n              rbp     - The address of the failing request block. If\n                        not coded, is not stored\n              rcp     - The address of the return code (r15) from\n                        SVC99. If not coded, is not stored.\n              jeff02  - The address of a fullword containing\n                        the address of IKJEFF02 or zero if\n                        unknown. If not coded, is not stored.\n              idp     - The address of a two byte flag field\n                        containing the caller ID and service options.\n                        If not coded, is not stored.\n              bufp    - The address of the DAIRFAIL optional buffers.\n                        If not coded, is not stored.\n     gnrfail=gfparms  - the address of the gnrlfail parms.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ACCALL": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00a\\x00a\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 97, "newlines": 97, "modlines": 0, "user": "FILE149"}, "text": "                           OAC CALL MACRO (REENTERENT)\n\n name     OACCALL   routine,\n                    parameter list in parenthesis,\n                    EXT,\n                    VL,\n                    MF=macro format options,\n                    ERROR=error parameters\n\n   The OACCALL macro is a reentrant version of the IBM call macro\n    plus some extensions.\n\n  The following operands are positional:\n\n -- routine\n   The routine positional operand specifies the entry point\n   symbol to call.  If this is specified in register notation\n   the value will be placed in R15 before the BALR.  This operand\n   is required for the execute form of the macro.\n\n -- parameter list in parenthesis\n   This operand specifies the parameters to be used to build the\n   parameter list.  For each sub-operand specified in this\n   list code will be generated to place the address of the\n   parameter into the parameter list.  If a sub-operand is\n   null (ommitted), then that relative position in the parameter\n   list will be left unchanged.  The high order bit of the\n   last word in the parameter list will be set if the VL option\n   is specified.  (even if the last sub-operand is omitted).\n\n  The following are pseudo-keyword operands.  These are positional\n  operands which may occur in any positional operand position\n  except the first.\n\n -- EXT\n  This specifies that the routine to be called is external.  This\n  will cause the address literal of the routine to be a VCON instead\n  of the default ACON.  This operand is only valid in the execute\n  form of the macro.\n\n -- VL\n  This specifies that the macro is to generate code to set the\n  high order bit of the last word of the parameter list to one.\n  The last parameter is found by counting the number of sub-parameters\n  specified for positional operand two, ommited sub-operands are\n  counted.\n\n-- MF=macro format options\n  This keyword specifies the macro format.  Two sub-operands are\n  required if this keyword is specified.  If this keyword is omitted\n  then only linkage instructions can be generated, no parameters\n  or parameter list can be constructed.\n\n  The first sub-operand must be:\n   E  - execute form\n        (build the parameter list and call the routine, this\n         is the default)\n\n   B  - build form\n        (just build the parameter list)\n\n  The second sub-operand is the address of the parameter list.\n  (the area to build the parameter list).  This address may\n  be specified as an expression or in register notation.\n\n-- ERROR=error parameters\n  This keyword specifies that an error branch should be generated\n  after this call.  See the 'OACINERR' macro description for the\n  format of the sub-operands for this keyword.\n\n\n  The following are samples of the use of this macro.\n\n    L1    OACCALL SUB1,(PARM1,PARM2),MF=(E,PARMLIST),ERROR=DIE\n   +L1    LA   R0,PARM1\n   +      ST   R0,PARMLIST+0\n   +      LA   R0,PARM2\n   +      ST   R0,PARMLIST+4\n   +      LA   R1,PARMLIST\n   +      L    R15,=A(SUB1)\n   +      BALR R14,R15\n   +      BNZ  DIE\n\n    L1    OACCALL SUB2,EXT,MF=(E,(R3)),ERROR=(OK,Z,R4)\n   +L1    LR   R1,R3\n   +      L    R15,=V(SUB2)\n   +      BALR R14,R15\n   +      LTR  R4,R15\n   +      BZ   OK\n\n    L1    OACCALL ,(PARM1,,PARM3,),VL,MF=(B,FURD+4)\n   +L1    LA   R0,PARM1\n   +      ST   R0,FURD+4+0\n   +      LA   R0,PARM3\n   +      ST   R0,FURD+4+8\n   +      OI   FURD+4+12,X'80'\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ACDC": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x13\\x00\\x13\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "FILE149"}, "text": "                  OAC DC MACRO\n\nPURPOSE: TO PROVIDE A CONVIENIENT METHOD OF GENERATING\n          PARAMETER LISTS WITHIN A MACRO FOR MF=L PROCESSING\n\nSYNTAX:\nLBL     OACDC ARG,TYPE=A,DEF=0,COM=\n\nLBL     A LABEL TO BE GENERATED ON THE DC\n\nARG     THE ARGUMENT WHICH IS TO APPEAR WITHIN THE SCOPE OF THE DC\n           IF THIS IS NULL, THE VALUE CODED AS DEF= WILL BE\n           SUBSTITUTED.\n\nTYPE=   THE TYPE OF DC DEFAULTS TO A. EXAMPLES: TYPE=AL2 , TYPE=F\n\nDEF=    THE DEFAULT VALUE TO BE SUBSTITUTED IF ARG IS NULL\n\nCOM=    A COMMENT TO BE PUT ON THE GENERATED STATEMENT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ACENTER": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\xe2\\x00\\xe2\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 226, "newlines": 226, "modlines": 0, "user": "FILE149"}, "text": "1                         EXTERNAL ENTRY MACRO\n\n NAME     OACENTER  REGEQU= YES,\n                    BASE= R10,\n                    PARM= (R9,LR)\n                    ENTRYS= ,\n                    ENTRYR= ,\n                    EXIT= ,\n                    DSECT= ,\n                    WORK=  ,\n                    STACK= ,\n                    ROUND= NO,\n                    SP= 1,\n                    PLIX= NO,\n                    ID= ,\n                    DATE= ,\n                    PRINT=\n\n          NAME      Major name, see CSECT= and ENTRY=\n\n          REGEQU = YES or no\n                     If YES is coded the standard register equates are\n                     generated as part of the macro expansion\n\n          BASE= register\n                     The register to be used as the base for this\n                     routine.  the default is R10 to allow for PLIX\n                     callable subroutines in which R12 must be preserved\n                     and for the OAC staking convention in which R12\n                     points to the base of the global work area.\n\n          PARM= (REGISTER,LR OR L,DSECT-NAME)\n                     The register into which the contents of R1 (if LR o\n                     if the second operand is ommited) or the contents o\n                     the word pointed to by R1(if L) on entry is to be\n                     placed.  If no register is coded R1 is ignored and\n                     may be destroyed. If a DSECT-NAME is coded, the\n                     macro will do an OACUSING DSECT-NAME,REGISTER.\n\n          ENTRYS= NAME or NAME LIST\n                     A list of alternate entry points.  An ID string and\n                     label will be generated for each name in the list.\n                     If ENTRY=YES was coded, an ENTRY statement will als\n                     be generated for each name.\n\n          ENTRYR= register\n                     The register which will contain an indication of\n                     which entry was used to call this routine:\n                    0 for main entry\n                    4 for first secondary entry\n                    8 for second secondary entry\n                    ETC.\n\n1         EXIT= (name,rc)\n                    name\n                     The name of the exit routine to be generated by thi\n                     macro.  If no name is given, no routine\n                         will be generated\n                    rc   (register) or address\n                     The register which will contain the return code on\n                     entry to the exit.  or the address of a fullword\n                     which will contain the return code on entry to the\n                     exit.\n\n          DSECT= name\n                     The name of the DSECT which will contain the\n                     workarea bought by this macro.  Unless DSECT=name i\n                     coded only the length operand of WORK= may be coded\n                     and STACK= may not be coded.  See the section at th\n                     end of this document for the format of the area\n                     bought by this macro.  If a DSECT is generated, the\n                     macro will do an OACUSING on R13 if no STACK= was\n                     coded and an OACUSING on R12 if a STACK= was coded.\n\n          WORK=(reserved-length,macro-parm,label-name)\n\n                    reserved-length\n                         The number of bytes to be reserved in the\n                         workarea obtained by this macro. See DSECT=\n                         for a discussion of its  position in the workar\n\n                    macro-parm\n                         If this argument is coded, the user defined\n                         macro OACWORK is expanded with this parm as\n                         part of the DSECT generated by OACENTER when\n                         DSECT= is coded. See the discussion of workarea\n                         format for its position in th workarea. If\n                         macro-parm is not coded, the macro is not\n                         expanded.\n\n                    label-name\n                         The name of a label to be generated immediatly\n                         preceeding the reserved area (if any) generated\n                         as part of the work DSECT.\n\n          ROUND= YES or NO\n                     If no ROUND=YES is coded, and STACK= is coded, the\n                     length of the stack obtained is increased to extend\n                     the resulting size of the work area obtained by thi\n                     macro to the nearest 4K boundary.\n\n          SP= subpool\n                     The subpool for the GETMAIN to obtain the workarea\n                     requested by this macro.  NOTE:  if PLIX=YES is\n                     coded The workarea will be obtained from the DSE an\n                     this keyword will be ignored.\n\n1         STACK= (length,name,error-routine-name,ABEND)\n\n                    length\n                        The number of bytes to be reserved in the\n                        workarea for an OAC internal stack. This\n                        length will allways be increased by 72 bytes\n                        and rounded to a multible of 8. See the\n                        discussion of OAC internal stacks at the end\n                        of this document.\n\n                    name\n                        The name to be used as a label on the\n                        DC 0d'0' that is the begining of the stack area\n                        in the generated dsect. If no name is coded,\n                        no routine will be generated.\n\n                    error-routine-name\n                         The name of the stack overflow routine to be\n                         generated by this macro.  This routine will\n                         generate a message:  \"OAC900 stack overflow in\n                         NAME\" and terminate as directed by the next\n                         parm.\n\n                     ABEND or return code\n                        ABEND\n                             The generated stack overflow routine\n                             will terminate with an OAC stack overflow\n                             abend U=900\n                        return code\n                             The generated stack overflow routine\n                             will return to caller with the specified\n                             return code.\n          PLIX= YES or NO\n                     If PLIX=YES is coded, The entry code and the exit\n                     routine will be generated in accordance with plix\n                     conventions.\n\n1         ID =\n                     Tne specified string will be generated as a DC C'&I\n                     ' at the begining of the generated entry code,\n                     followed immediatly by the date of assembly.  If no\n                     name is coded, the name of the entry point is used.\n\n          DATE =\n                     Overides the date of assembly in the DC C at the\n                     beginning of the generated entry code.  This keywor\n                     is intended only for use in generating modules to b\n                     run against compare.  If it is coded an MNOTE\n                     7,REMOVE DATE= BEFORE FINAL ASSEMBLY is generated.\n\n          PRINT=  ALL, or SHORT, or NONE, or empty\n                    ALL-     Full macro expansion (PRINT ON,GEN)\n                    SHORT-   Short form of macro. No comments and\n                             regequ suppressed.\n                    NONE-    Only code will be printed.\n                    EMPTY-   The value of &OACPRTG will determine action\n\n\n\n          OAC STACK CONVENTIONS:\n\n          R11 points to the \"current\" stack element.\n          R12 points to the base of the workarea obtained by this macro.\n          R13 points to the next available byte on the stack.\n\n          Overflow checks are done in such a way that R13 will point\n          to at least 72 bytes of workarea.\n\n          a stack element consists of:\n          DC 8D'0'    a register save area containing the results of a\n                      STM 0,15\n          user requested work area: See OACSUB macro.\n\n          The global C-symbol &OACSTMX is assumed to contain the address\n          of a universally addressable word containing the address of\n          the last valid byte of the stack area -71.\n\n          The global C-symbol &OACSTER is assumed to contain the\n          address of a universally addressable STACK overflow routine.\n\n1                    ORGANIZATION OF WORK AREA:\n\n   If no STACK= was coded the workarea will look like:\n\n   name      DSECT                   only if DSECT=name was coded\n             DC    9D'0'             standard OS save area\n             DC    AL1(&SP)          the subpool of this workarea\n             DC    AL3(length)       the length in bytes of this workare\n             &WMAC                   only if WORK=(,wmac,) was coded\n   wname     DC    0D'0'             only if WORK=(,,wname) was coded\n             DC    0D'0',&lenXl1'0'  only if WORK=(len,,) was coded\n\n             R13   will point to the base of the work area\n\n             If STACK= was coded the workarea will look like:\n\n   name     DSECT                    only if DSECT=name was coded\n            DC    AL1(&SP)           subpool of this workarea\n            DC    AL3(length)        the length in bytes of this workare\n            DC    A(0)               R13 back chain\n            DC    A(stackmax)        address of the end of the stack -71\n            DC    A(stackerr)        address of the stack overflow routi\n            L     R15,8(r12)         get address of stack overflow routi\n            BR    R15                go to stack overflow routine\n            &wmac                    only if WORK=(,wmac,) was coded\n   wname    DC    0D'0'              only if WORK=(,,wname) was coded\n            DC    0D'0',lenXL1'0'    only if WORK=(len,,) was coded\n   sname    DC    0D'0'              only if STACK=(,sname,,) was coded\n            DC    0D'0',lenXL1'0'    where len is calculated using the\n                                     values of STACK= and ROUND= accordi\n                                     to OAC internal stack conventions.\n\n            R13   will point to the next available byte of the stack\n            R12   will point to the base of the work area\n            R11   will point to the first byte of the stack\n\n            &OACSTMX  will contain  '8(R12)'  the address of stackmax\n            &OACSTER  will contain  '16(R12)' the address of the stack\n                                               overflow routine.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ACFSORT": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00,\\x00,\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "FILE149"}, "text": "                           OACFSORT MACRO\n\n   The OACFSORT macro generates a dsect of the parameter list for\n   OACFSORT, a fixed record length in storage sort routine.\n   The DSECT and PREFIX keywords are supported.\n\n   OACFSORT is reentrant and issues no system calls.  Thus it\n   requires that a workarea be provided for it's use.\n\n   Note that the work area size must be long enough to include\n        one record, the sort stack, and sort working storage.\n\n   record length + 100 bytes will be enough for most cases.\n\n   (OACFSORT currently uses partition exchange)\n\n.*---------------------------------------------------------------------\n.*\n.*  FSORT - FIXED LENGTH RECORD SORT (IN STORAGE)\n.*\n.* ENTRY: R1 = @ P# LIST\n.*\n.* EXIT: R15 = RETURN CODE (CC SET)\n.*              0 - RECORDS SORTED (INPLACE)\n.*              4 - WORK AREA TOO SMALL\n.*\n.* THE WORK AREA LENGTH IS:\n.*  W#L + LENGTH OF ONE RECORD + STACK SPACE\n.*\n.*    COMPARE ROUTINE CALLED WITH:  R15 - ENTRY POINT\n.*                                  R14 - RETURN ADDRESS\n.*                                  R13 - @ 72 BYTE SAVE AREA\n.*                                  R1  - @ ELEMENT\n.*                                  R2  - @ ELEMENT\n.*                                  R3  - COMPARE ROUTINE PARM\n.*\n.* CONDITION CODE RETURNED FROM COMPARE ROUTINE DETERMINES ORDER,\n.*   IF HIGH THEN ELEMENT (R1) WILL APPEAR AFTER (R2),\n.*   IF LOW  THEN ELEMENT (R1) WILL APPEAR BEFORE (R2),\n.*   ELSE ORDER OF RECORDS IS UNDEFINED.\n.*\n.*  THE COMPARE ROUTINE MUST RESTORE *ALL* THE REGISTERS R0-R15.\n.*\n.*---------------------------------------------------------------------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ACFSVC": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x07\\x00\\x07\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "FILE149"}, "text": "*\n*      THE OACFSVC IS INTENDED TO PROVIDE A CONVIENIENT PROBLEM\n*      PROGRAM INTERFACE TO ACF2 AND SMF FOR THOSE PROGRAMS\n*      WHICH HAVE TO SERVICE MORE THAN ONE SIMULTANEOUS USER.\n*\n*      SEE PETE NIELSEN FOR A COPY OF THE DOCUMENTATION\n*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ACGBLS": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00$\\x00$\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "FILE149"}, "text": "                        OAC GLOBAL VALUES MEMBER\n         OACGBLS\n\n         MEMBER INTENDED AS COPY CODE TO DECLARE THE STANDARD\n         OAC GLOBAL ASM SYMBOLS:\n\n         &OACPRTG GBLC '' OR 'ALL' OR 'SHORT' OR 'NONE'\n                  USED TO CONTROLE THE PRINT-EXPANSION OF\n                  OAC DEFINED MACROS. SEE OACPRTPM MACRO\n                  DOCUMENTATION FOR BEHAVIOR.\n\n         &OACPRT GBLC '' OR 'ALL' OR 'SHORT' OR 'NONE'\n                  THE SYMBOL SET BY OACPRTPM BASED ON THE\n                  VALUES OF &OACPRTG, &OACPRTF, AND THE\n                  PRINT= KEYWORD ON THE INDIVIDUAL MACRO.\n\n         &OACPRTS GBLA 1 OR 99\n                  SET TO 1 BY OACPRTM IF THE CALCULATED\n                  VALUE OF &OACPRT IS 'SHORT' ELSE SET TO 99.\n                  THE INTENDED USE OF THIS VARIABLE IS AS AN\n                  ARGUMENT TO SPACE TO CAUSE EITHER AN EJECT OR\n                  A SPACE 1.\n\n         &OACPRTF GBLB\n                  IF SET TO 1 THE VALUE OF &OACPRTG WILL\n                  OVERIDE THE VALUE OF THE PRINT= KEYWORD\n                  ON INDIVIDUAL MACROS.\n\n         &OACNAME GBLC\n                  This contains a name field to be generated\n                  by some OAC inner macro or nulls.  (If there\n                  was no name field on the outer macro or the\n                  name field has already been generated then\n                  this global will contain nulls.\n                  (See also: OACINNRB, OACCALL)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ACINERR": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x005\\x005\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "FILE149"}, "text": "              ERROR BRANCH INNER MACRO\n\nname     OACINERR addr\n\n  -- addr\n   This operand specifies the address for the error branch.  If\n   the address is specified as in a register, then a branch\n   register will be generated.\n\n   A second sub-operand may be specified as one of:\n\n   Z  -  branch on condition code zero\n         (This is the reverse of normal and results in\n          a branch on no-error to the specified address)\n\n   NZ -  branch on condition code not-zero\n         (This is the default if this sub-operand is omitted and\n          results in a branch on error to the specified address)\n\n   A third sub-operand may be specified.  This specifies that\n   the condition code is not already set, a LTR from R15 to\n   the register specified in the third sub-operand will be\n   generated before the conditional branch.  Note that\n   R15 may be specified, which will generate a LTR R15,R15.\n\n  The following are samples of the use of this macro.  A real\n  example of usage is contained in OACCALL.\n\n         MACRO\n&NAME    SAMPLE &DUMMY,&ERROR=\n&NAME    BAL   R14,MYSUB\n         OACINERR &ERROR\n         MEND\n\n  This might generate:\n\n    L1    SAMPLE ERROR=DIE\n   +L1    BAL  R14,MYSUB\n   +      BNZ  DIE\n\n    L1    SAMPLE ERROR=(ALLOK,Z)\n   +L1    BAL  R14,MYRTN\n   +      BZ   ALLOK\n\n    L1    SAMPLE ERROR=((R8),Z)\n   +L1    BAL  R14,MYRTN\n   +      BZR  R8\n\n    L1    SAMPLE ERROR=((R8),NZ,R6)\n   +L1    BAL   R14,MYRTN\n   +      LTR   R6,R15\n   +      BNZR  R8\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ACINNER": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00T\\x00T\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 84, "newlines": 84, "modlines": 0, "user": "FILE149"}, "text": "                            OAC inner macro\n\n    PURPOSE: To provide a consistent way of efficiently generating\n             instructions to manipulate parms passed to macros.\n\n             The OACINNER macro accepts addresses of the form:\n\n             (Rn)     - The specified register itself.\n\n             0(Rn)    - The address contained in the register\n\n             sym   or - The specified address\n             sym+off\n             sym-off\n             off(Rn)\n\n             (addr,i) - The contents of storage at location addr\n\n    SYNTAX:\n\n   label OACINNER F=,FO=+0,                                            x\n                  T=,TO=+0,                                            x\n                  L=4,                                                 x\n                  OP=MA,                                               x\n                  COM='',                                              x\n                  SETCC=NO,                                            x\n                  RS=R0,RT=R15\n\n         F=    The source for this operation. Usually a passed parm.\n         FO=   The offset from the passed parm to be used for this\n               operation.\n\n         T=    The target for this operation. Usually a passed parm.\n         TO=   The offset from the passed parm to be used for this\n               operation.\n\n         L=    The length to be used for this operation. Note that\n               MOVE ADDRESS has an implied length of four and that\n               some combinations of addresses, lengths, and operations\n               are illegal.\n\n         OP=   The operation to be performed:\n\n               MA  - Move Address. The address of the source is moved\n                     to the target. The implied length is four. The\n                     high order byte will be destroyed, but may not\n                     be zeroed.\n\n               MAC - Move Address and Clear high byte.\n\n               M   - Move. The contents of the source is moved to\n                     the target.\n\n               O   - Or. The contents of the source is or'd into\n                     the target.\n\n               X   - eXclusive or. The contents of the source is\n                     exclusive or'd into the target\n\n               N   - aNd. The contents of the source is and'd into\n                     the target.\n\n               CL  - Compare Logical. The contents of the source is\n                     compared with the target.\n\n               MVI - These operands are included for completeness.\n               CLI\n               TM\n               OI\n               NI\n               XI\n\n         COM=  A comment to be put in the comment field of the\n               first generated instruction. Note. the argument\n               to this keyword MUST be enclosed in quotes.\n\n         SETCC= Set condition code. If SETCC=YES is coded, and\n              the operation would not normally cause the condition\n              code to be set. The macro will turn a LR into a LTR,\n              or will generate a LTR or CLC to set the condition\n              code on the value of the target.\n\n         RS=R0,RT=R15 Work registers for the macro. Note that RT\n              will not be used unless an Indarect target was specified.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ACINNRB": {"ttr": 784, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00_\\x00_\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "FILE149"}, "text": "              LOAD ADDRESS/LOAD VALUE INNER MACRO\n\n         OACINNRB type, target base, target offset,\n                  target length, source,\n                  WX=work register\n\n  -- type\n   The type operand must be one of the following character strings\n   (or a variable symbol which is replaced by one of these):\n    A - Address type     (set target to address of source)\n    V - Value type       (set target to value in source)\n    NI  - Bit            (change bits in byte of flags)\n    OI  - Bit\n    XI  - Bit\n    MVI - Bit\n    TM  - Bit\n\n  -- target base\n    This operand specifies the target base address.  This may\n    be specified as in a register '(R3)' or as an expression\n    'FURD+5'.  If this operand is null then the target is\n    ???\n\n  -- target offset\n    This operand specifies the offset of the target from the\n    target base.  This can be specified as null if the offset\n    from the target base is zero.\n\n  -- target length\n    This operand specifies the length of the target.  This length\n    is used to decide which type of store to generate (ST, STLH, STC)\n    or what length to use for SS type instructions.  If the\n    type is specified as A then only 4 should be specified as\n    the target length.\n\n  -- source\n    This operand specifies the source.  If this is null then\n    no code will be generated.  This may be specified as\n    a register (in register notation) as in '(R5)',  as\n    an expresion, as a self-defining term, or as a literal.\n    Some self-defining terms are specially handled.  0 will\n    generate a SR if the target is a register, or an XC if\n    it is a storage location.  Self-defining terms less than\n    4095 will be generated with a LA.  Others will cause\n    a literal to be generated.  Expresions are assumed to\n    be less than 4095 from some base register and a LA will\n    generated.\n\n  -- WX=work register\n   This keyword specifies the work register to be used if required.\n   The default for this keyword is R0, any register may be\n   specified.\n\n\n  This macro uses the value in '&OACNAME' to generate\n  the name field of the first generated instruction.  Once\n  this name has been generated once, '&OACNAME' is set to\n  a null string.  Note that if this macro does not generate\n  any instructions the value of '&OACNAME' will be unchanged\n  from it's value at entry.\n\n  The following are samples of the use of this macro.  A more\n  complex example of usage is contained in OACCALL.\n\n         MACRO\n&NAME    SAMPLE &PARM,&MF=\n         COPY  OACGBLS\n&OACNAME SETC  '&NAME'\n         . . .\n         OACINNRB A,&MF(2),8,4,&PARM\n         OACINNRB A,(R1),,4,&MF(2)\n&OACNAME BAL  R14,MYRTN\n         MEND\n\n  This might generate:\n\n    L1    SAMPLE FURD,MF=(E,X)\n   +L1    LA  R0,FURD\n   +      ST  R0,X+8\n   +      LA  R1,X\n   +      BAL R14,MYRTN\n\n    L1    SAMPLE FURD,MF=(E,(R3))\n   +L1    LA  R0,FURD\n   +      ST  R0,8(R3)\n   +      LR  R1,R3\n   +      BAL R14,MYRTN\n\n    L1    SAMPLE ,MF=(E,(R3))\n   +L1    LR  R1,R3\n   +      BAL R14,MYRTN\n\n    L1    SAMPLE ,MF=(E,(R1))\n   +L1    BAL R14,MYRTN\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ACLIDCK": {"ttr": 787, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\t\\x00\\t\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "FILE149"}, "text": "*\n*    DSECT GENERATION FOR CALLING SEQUENCE FOR OACLIDCK\n*\n*    SEE MSSLHELP FOR THE DOCUMENTATION ON OACLIDCK\n*\n&LBL   OACLIDCK &DUMMY,&PFX=OAC,&DSECT=YES\n*\n*   YEP, THEY ALL MEAN WHAT YOU THINK THEY MEAN\n*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ACMAP": {"ttr": 789, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "FILE149"}, "text": "         DSECT GEN MACRO\n\n         OACMAP  DSECT=CB-NAME-LIST, PRINT=\n\n         GENERATES A DSECT FOR EACH OF THE NAMED CONTROL BLOCKS.\n         NOTE: SINCE THE \"APPROVED\" IBM MACROS ARE USED TO\n               GENERATE THE DSECTS, THE DSECT NAME MAY NOT\n               BE THE SAME AS THE CONTROL BLOCK NAME.\n\n         CB-NAME-LIST,\n                   THE \"COMMON\" NAME OF CONTROL BLOCKS FOR WHICH\n                   A DSECT IS TO BE GENERATED. EG: TCB, JSCB, ...\n                   NOTE: IF THE NAME IS NOT RECOGNIZED BY THE\n                         OACMAP MACRO IT IS USED AS A MACRO NAME\n                         TO GENERATE THE DESIRED DSECT. THIS IS\n                         A RELATIVELY PAINLESS WAY OF FOLLOWING\n                         THE OAC PRINT CONTROL CONVENTIONS.\n                   THE \"COMMON\" NAME FOR THE SVC99\n                   DSECTS ARE: SVC99 FOR EVERYTHING\n                               SVC99BLK FOR THE DATA AREAS\n                               SVC99EQU FOR THE EQU'S\n\n         PRINT=    ALL, OR SHORT, OR NONE, OR EMPTY\n                   ALL   - PRINT ON,GEN\n                   SHORT - SHORT FORM OF MACRO EXPANSION\n                   NONE  - PRINT OFF,NOGEN\n                   EMPTY - THE VALUE OF &OACPRTG CONTROLS THE\n                           PRINT BEHAVIOR.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ACMUS": {"ttr": 791, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\n\\x00\\n\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "FILE149"}, "text": "*\n*     THE PARMLIST MAPPING MACRO FOR THE OACMUS SUBROUTINE\n*\n*     OACMUS    OR\n*     OACMUS    DSECT=NO\n*\n*     THE LABEL OR DSECT GENERATED WILL HAVE THE NAME OACMUSDS\n*\n*     SEE MACRO ITSELF FOR ADDITIONAL COMMENTS\n*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ACPRTPM": {"ttr": 1026, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00)\\x00)\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "FILE149"}, "text": "                   PRINT CONTROL MACRO\n\n         OACPRTPM  PRINT=\n\n         THIS MACRO EXAMINS THE VALUES OF &OACPRTG, &OACPRTF, AND\n         THE SUPPLIED PRINT= KEYWORD AND GENERATES A PUSH PRINT,\n         A PRINT OFF,NOGEN(IF REQUIRED) AND SETS THE VALUES OF\n         &OACPRT AND &OACPRTS ACCORDING TO OAC CONVENTIONS:\n         THE PRINT ENVIRONMENT OF AN OAC GENERATED MACRO MAY\n         HAVE THREE VALUES:\n\n         ALL-   PRINT ON,GEN; ALL COMMENTS; EJECTS AS APPROPRIATE\n\n         SHORT- PRINT ON,GEN; NO COMMENTS; EJECTS REPLACED BY SPACE 1\n\n         NONE-  PRINT OFF,NOGEN\n         THIS ENVIRONMENT WILL BE DETERMINED BY THE VALUE OF THE\n         GLOBAL SYMBOL &OACPRTG, THIS VALUE MAY BE OVERRIDEN BY\n         THE PRINT= KEYWORD ON INDIVIDUAL MACROS UNLESS THE\n         GLOBAL &OACPRTF IS SET TO 1 IN WHICH CASE THE PRINT=\n         KEYWORD IS IGNORED.\n\n         IN GENERAL AN OAC MACRO SHOULD HAVE THE FOLLOWING SKELETON:\n\n         MACRO\n&LABEL   OACNAME .....,&PRINT=\n         COPY  OACGBLS\n         OACPRTPM PRINT=&PRINT\n         AIF   ('&OACPRT' EQ 'SHORT').NOCOMMS\n         . . .\n.NOCOMMS ANOP\n         . . .\n         POP   PRINT\n         MEND\n\n         WITHIN SUCH A MACRO, EJECTS SHOULD BE REPLACED BY:\n\n         SPACE &OACPRTS\n\n         WHICH WILL RESULT IN AN EJECT IF THE PRINT ENVIRONMENT IS\n         ALL AND A SPACE 1 IF THE PRINT ENVIRONMENT IS SHORT.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ACRET": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x10\\x00\\x10\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "FILE149"}, "text": "1                          Internal Return Macro\n\n NAME     OACRET    RC=\n\n          NAME      Name of generated exit routine\n\n          RC=       (register) or address\n                    The register which will contain the return code on\n                    entry to the exit, or the address of a fullword\n                    which will contain the return code on entry to the\n                    exit. If no RC is coded R0, R1, and R15 remain\n                    unchainged and the condition code is not set.\n\n          NOTE:     This macro is intended only for use with the\n                    OACSUB macro. The code generated is inapropriate\n                    for any other type of return.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ACSUB": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x84\\x00\\x84\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "FILE149"}, "text": "1                          Internal Entry Macro\n\n NAME     OACSUB    CSECT= NO,\n                    ENTRY= NO,\n                    BASE= R10,\n                    ENTRYS= ,\n                    ENTRYR= ,\n                    EXIT= ,\n                    DSECT= ,\n                    WORK=  ,\n                    INUSE= YES,\n                    ID= ,\n                    DATE= ,\n                    PRINT=\n\n          NAME      Major name, see CSECT= and ENTRY=\n\n          CSECT= YES or NO\n                    If YES, a CSECT will be generated for NAME.\n\n          ENTRY=  YES or NO\n                     If YES, an ENTRY statement will be generated for\n                     each entry.  If no a DC 0H'0' will be generated\n\n          BASE= (register,address)\n               register\n                     The regiser to be used as the base for this routine\n                     R15 is assumed to contain the base address on entry\n                     to the routine.\n               address\n                     If this value is coded it is assumed that the\n                     subroutine occures within the scope of a global bas\n                     and the macro generates an OACUSING for the\n                     specified register and address.\n\n          ENTRYS= NAME or NAME LIST\n                     A list of alternate entry points.  A label will be\n                     generated for each name in the list.  If ENTRY=YES\n                     was coded, an ENTRY statement will also be generate\n                     for each name.\n\n          ENTRYR= register\n                     The register which will contain an indication of\n                     which entry was used to call this routine:\n                    0 for main entry\n                    4 for first secondary entry\n                    8 for second secondary entry\n                    ETC.\n\n1         EXIT= (name,RC)\n                    name\n                         The name of the exit routine to be generated\n                         by this macro. If no name is given, no routine\n                         will be generated\n                    RC   (register) or address\n                         The register which will contain the return\n                         code on entry to the exit. or the address\n                         of a fullword which will contain the\n                         return code on entry to the exit.\n                         If no rc is coded R0, R1, R15 and the\n                         condition code are left unchanged.\n\n          DSECT= name\n                     If coded, the macro will generate a DSECT mapping\n                     the \"current\" stack element and will do an OACUSING\n                     on R11 for this DSECT.The DSECT will contain:\n                    an OAC STACK headder as its first element,\n                    followed by the work macro expansion if one was code\n                    followed by a label for the workname if one was code\n                    followed by the reserved area if one was requested;\n\n          WORK=(reserved-length,macro-parm,label-name)\n\n                    reserved-length\n                         The number of bytes to be reserved in the\n                         workarea obtained by this macro. See DSECT=\n                         for a disscussion of it's position in the worka\n\n                    macro-parm\n                         If this argument is coded, the user defined\n                         macro OACSUBWK is expanded with this parm as\n                         part of the DSECT generated by OACSUB whend.\n                         DSECT= is coded. If no macro-parm is coded,\n                         no macro is called.\n\n                    label-name\n                         The name of a label to be generated immediatly\n                         preceeding the reserved area (if any) generated\n                         as part of the work DSECT.\n\n          INUSE= YES or NO\n                     If YES is coded an OACINUSE is generated as the las\n                     statement of the macro.\n\n          ID =\n                    The specified string will be generated as a\n                    DC C'&ID ',C'&SYSDATE' immediatly before the first\n                    instruction of the generated entry code.\n                    If this keyword is not coded, no DC C is\n                    generated.\n\n          DATE =\n                     Overides the date of assembly in the DC C at the\n                     beginning of the generated entry code.\n\n          PRINT=  ALL, or SHORT, or NONE, or empty\n                    ALL-     Full macro expansion (PRINT ON,GEN)\n                    SHORT-   Short form of macro. No comments and\n                             inuse suppressed.\n                    NONE-    Only code will be printed.\n                    EMPTY-   The value of &OACPRTG will determine action\n\n1         OAC STACK CONVENTIONS:\n\n          R11 points to the \"current\" stack element.\n          R12 points to the base of the workarea obtained by this macro.\n          R13 points to the next available byte on the stack.\n\n          Overflow checks are done in such a way that R13 will point\n          to at least 72 bytes of workarea.\n\n          a stack element consists of:\n          DC 8D'0'    a register save area containing the results of a\n                      STM 0,15\n          user requested work area: See WORK= keyword\n\n          The global C-symbol &OACSTMX is assumed to contain the address\n          of a universally addressable word containing the address of\n          the last valid byte of the stack area -71.\n\n          The global C-symbol &OACSTER is assumed to contain the\n          address of a universally addressable STACK overflow routine.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ACTMP": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x8b\\x00\\x8b\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 139, "newlines": 139, "modlines": 0, "user": "FILE149"}, "text": "                      OACTMP\n\n     The OACTMP service provides a standard method of attaching\n TSO commands or command proceedures. The OACTMP service automatically\n takes care of the rather complicated bookkeeping neccessary to accompli\n acomplish this, and it supports the % and ACF2 command limiting\n features. Use of this service insures consistency, and the needless\n duplication of code in TSO. It should be used in all OAC written\n command proceedures which attach TSO commands as subcommands.\n\n     To invoke the OACTMP service, code the following assembly\n language macro:\n                              'pgm name' or\n                          PGM= pgm-name-addr\n\n label OACTMP         or  CBUF= buffer-addr\n\n                                'command string' or\n                          CMD = (cmd-addr,cmd-length)\n\n     optionally you may code the following operands:\n\n                                 'parm-string' or\n                          ,PARM=  parm-addr\n\n                                  0     (the default) or\n                           ,DCB=  addr\n\n                                  YES   (the default) or\n                        ,CMDLIB=  NO\n\n                                  0     (the default) or\n                       ,TASKLIB=  addr\n\n                                  YES   (the default) or\n                          ,EXEC=  NO\n\n                                  YES   (the default) or\n                         ,STACK=  NO\n\n                                  YES or\n                          ,SCMD=  NO    (the default)\n\n                                  YES   (the default) or\n                                  'herald string' or\n                          ,STAX=  herald-addr\n\n                                  MSG    (the default) or\n                       ,CMDFAIL=  NOMSG\n\n                                  I      (the default) or\n                                  L      or\n                                  (E,parm-list-addr) or\n                            ,MF=  (b,parm-list-addr)\n\n     NOTE: That the PGM= and PARM= operands support \"calling\"\n           programs with standard os batch calling conventions\n           instead of as a TSO command proceedure.\n\n   PGM=                the name of a program or the address of a\n                       cl8 program name to be \"called\" by the\n                       OACTMP service.\n\n   CBUF=               The address of a TSO command buffer in\n                       standard TSO format. The command line is\n                       assumed to start at the position indicated\n                       by the offset field.\n\n   CMD=                Either the commmand line to be executed\n                       exactly as it would be typed if entered from\n                       the terminal; or the address and length of\n                       such a command string.\n\n   PARM=               The parm to be passed in R1 to the program\n                       specified by PGM=, called by the OACTMP\n                       service.\n\n   DCB=                Either the address of an open DCB to be\n                       searched for the command given, or 0 to\n                       indicate that no specific library is to be\n                       searched except as specified by CMDLIB=\n\n   CMDLIB=             YES - The linklist is searched for the command\n                       NO  - The linklist is not searched.\n\n   TASKLIB=            Either the address of an open DCB to be\n                       used as a TASKLIB for the attached command;\n                       or 0 to indicate no TASKLIB.\n\n   EXEC=               YES - If the command is not found in the\n                             specified libraries, it is assumed\n                             to be a CLIST and is EXEC'd\n                       NO  - The command is not a CLIST.\n\n   STACK=              YES - Any command added to the TSO stack\n                             by a command executing under OACTMP\n                             will be executed by OACTMP before\n                             returning to it's caller.\n                       NO  - Exactly one command is to be executed\n                             by the OACTMP service.\n\n   SCMD=               YES - Conditions the ECT so that the HELP\n                             command will return information about\n                             the calling command.\n                       NO  - Conditions the ECT so that the HELP\n                             command will return information about\n                             the command being executed by OACTMP.\n\n   STAX=               YES - An attention exit will be established\n                             by the OACTMP service. or\n                       Either a string, or the address of a halfword\n                             length, followed by a string to be used\n                             as a prompt by the OACTMP when an attention\n                             is recieved. A pointer a halfword length\n                             followed by the reply is returned in the\n                             parameter list.\n\n   CMDFAIL=            MSG   - If appropriate, the following messages\n                               are generated:\n                               'COMMAND xxx NOT FOUND'\n                               'NO CORE TO EXECUTE xxx'\n                               'COMMAND xxx ABENDED SYSTEN nnn USER nnn'\n                       NOMSG - No messages are generated.\n\n   MF=                 I        - Inline parmlist, and call.\n                       L        - Inline parmlist only.\n                       (E,addr) - Remote parmist, and call.\n                       (B,addr) _ Remote parmlist only.\n\n   Return codes:       0  - Normal return\n                       4  - Command not found\n                       8  - Attention signaled\n                       12 - Not enough core\n                       16 - Command abended\n                       20 - Error while processing stack\n                       24 - OACTMP service abended.\n\n   For the format of the parmlist see the help for OACTMP in\n   'sys9.mssshelp'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ACTSOPL": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00^\\x00^\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 94, "newlines": 94, "modlines": 0, "user": "FILE149"}, "text": "            TSO PARAMETER LIST MACRO\n\n         OACTSOPL PL=PARM-LIST-NAMES,PRINT=\n\n         GENERATES A NON DSECT EXPANSION OF THE REQUESTED\n         PARAMETER LISTS.\n\n         PARM-LIST-NAMES MAY BE ANY OR ALL OF THE FOLLOWING:\n\n         ATRCB     ATTRIBUTE CONTROLE BLOCK. USED TO\n                   PROVIDE DCB PARMS TO DYNAM ALLOC\n\n         CPPL      COMMAND PROCESSOR PARAMETER LIST\n\n         CSOA      COMMAND SCAN OUTPUT AREA\n\n         CSPL      COMMAND SCAN PARAMETER LIST\n\n         DAIRACB   USED TO PROVIDE DCB PARMS TO THE DYNAM ALLOC\n                   INTERFACE ROUTINE.\n         DAPL      DAIR PARAMETER LIST\n\n         DAPB0C    CONCATENATE\n\n         DAPB04    SEARCH DSE FOR DSNAME\n\n         DAPB00    SEARCH DSE FOR DSNAME, REPORT IF TERMINAL\n\n         DAPB08    ALLOC A DS\n\n         DAPB1C    ALLOC DDN TO TERMINAL\n\n         DAPB10    DECONCATENATE\n\n         DAPB14    RETURN QUALIFYERS FOR GIVEN INDEX NAME\n\n         DAPB18    FREE DS OF DDNAME\n\n         DAPB2C    MARK FILES NOT IN USE\n\n         DAPB24    ALLOC DDNAME TO DS\n\n         DAPB28    PERFORM LIST OF DAIR REQUESTS\n\n         DAPB30    ALLOC A SYSOUT DS\n\n         DAPB34    ATRCB CHAIN MAINTENANCE\n\n         DFPL      DEFAULT SERVICE ROUTINE PARM LIST\n\n         DSE       TSO TIOT EXTENTION\n\n         ECT       ENVIRONMENT CONTROLE TABLE\n\n         GTPB      GETLINE PARM BLK\n\n         IOPL      IO SERVICE ROUTINE PARM BLK\n\n         LSD       LIST SOURCE DESCRIPTOR\n\n         PGPB      PUTGET PARM BLK\n\n         PPL       PARSE PARAMETER LIST\n\n         PSCB      PROTECTED STEP CONTROLE BLOCK\n\n         PTPB      PUTLINE PARM BLK\n\n         RLGB      RELOGON BUFFER\n\n         STPB      STACK PARM BLK\n\n         STPL      STACK PARM LIST\n\n         TAIE      TERMINAL ATTENTION INTERUPT ELEMENT\n\n         UPT       USER PROFILE TABLE\n\n         DAIRFAIL  DAIRFAIL PARAMETER LISTS\n\n         GENERFAIL GENERFAIL PARAMETER LISTS\n\n         SVC99     SVC99 PARAMETER LISTS\n\n         SVC99BLK  DATA AREAS FOR SVC99\n\n         SVC99EQU  SVC99 EQU'S\n\n         PRINT= ALL, SHORT, NONE, OR EMPTY\n                   ALL-    PRINT ON,GEN\n                   SHORT-  THE SHORT FORM OF THE MACRO\n                   NONE-   PRINT OFF,NOGEN\n                   EMPTY-  THE VALUE OF &OACPRTG WILL DETERMIN\n                           PRINT OPTIONS.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CMSLOAD": {"ttr": 1039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x14\\x00\\x14\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "FILE149"}, "text": "    CMSLOAD - re-load CMS \"DISK DUMP\" format files to MVS format\n\n  JCL to run:\n\n//CMSLOAD EXEC PGM=CMSLOAD,PARM=<number of records>\n//***PLIB  DD DISP=SHR,DSN=SYS5.MSSLOAD   <* note moved to oaclink *>\n//SYSUDUMP DD SYSOUT=*\n//IN       DD DISP=SHR,DSN=        * INPUT CARD IMAGES FROM DISK DUMP *\n//OUT      DD                      * OUTPUT FILE * (SYSOUT OR DATASET)\n//\n\n  Notes:  CMSLOAD requires the input lrecl be known.  This may be\n          supplied on the output dd card.  If no dcb attributes\n          are supplied CMSLOAD defaults the output to LRECL 80\n          if the input is fixed, LRECL 137 (RECFM VBM) if the\n          input is variable.\n\n          CMSLOAD adds 4 to any lrecl supplied on the output dd card\n          if the recfm is v.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$COMPARE": {"ttr": 1041, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x007\\x007\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "FILE149"}, "text": "***********************************************************************\n*                                                                     *\n*        PROGRAM: COMPARES TWO LOAD MODULES OR PARTS OF LOAD MODULES. *\n*                                                                     *\n*        METHOD:  ACTS AS A PSEUDO-LOADER.  BUYS AND CLEARS TWO CORE  *\n*                 AREAS INTO WHICH THE MODULES' TEXT BLOCKS ARE READ. *\n*                 RELOCATABLE REFERENCES ARE RESOLVED USING A COMMON  *\n*                 EXTERNAL SYMBOL TABLE TO SOLVE THE PROBLEMS OF      *\n*                 DIFFERENT CSECT ORDER AND DIFFERENT LOAD POINTS.    *\n*                                                                     *\n*        ATTRIB:  REENTRANT, REUSABLE.                                *\n*                                                                     *\n*        MISSING: CAN'T HANDLE OVERLAY MODULES.                       *\n*                                                                     *\n*        AUTHOR:  LOU P. RIVAS  -  UCLA/CCN.                JUNE 1977 *\n*                                                                     *\n*        PARM='NAME1(OFFSET1),NAME2(OFFSET2),COUNT'                   *\n*  (IF PARM IS OMMITED THEN ALL MODULES ON I1 WILL BE COMPARED        *\n*   WITH CORRESPONDING NAMED MODULES IN I2 AND WTO'S WILL BE DONE     *\n*   TO DDNAME 'WTO')                                                  *\n*                                                                     *\n* --> TTRL XCTL TABLES WILL BE MODIFIED SO DIFFERENT TTRL'S WILL      *\n*     MATCH. (MODULE IS DETERMINED TO HAVE TTRL'S BY MODULE NAME)     *\n*                                                                     *\n*        //I1       DD ...              PDS WITH LOAD MODULE NAME1.   *\n*        //I2       DD ...              PDS WITH LOAD MODULE NAME2.   *\n*        //SNAP     DD SYSOUT=A,...     OUTPUT FILE/MISMATCHES+SNAP.  *\n*        //SYSPRINT DD SYSOUT=A,...     OPTIONAL OUTPUT (NO SNAP).    *\n*        //WTO      DD SYSOUT=A,...     WTO FILE IF NO PARM (ALL)     *\n*                                                                     *\n*        (OFFSET#) IS OPTIONAL AND TAKES THE FORM:                    *\n*               (LABEL) WHERE 'LABEL' IS A CSECT OR ENTRY IN NAME#.   *\n*               (+NUMBER) WHERE 'NUMBER' IS AN OFFSET INTO THE NAME#; *\n*                   'NUMBER' IS ASSUMED HEX AND 'NUMBER.' IS DECIMAL. *\n*               (LABEL+NUMBER) WHICH IS THE OFFSET INTO THE LABEL.    *\n*                                                                     *\n*        COUNT IS OPTIONAL AND TAKES THE FORM 'NUMBER.' OR 'NUMBER'.  *\n*               IF COUNT IS NOT SPECIFIED, THE NUMBER OF BYTES THAT   *\n*               ARE COMPARED IS THE LARGER OF THE TWO MODULE LENGTHS  *\n*               OR THE LARGER OF THE TWO CSECT LENGTHS IF BOTH        *\n*               (OFFSET#) SPECIFY CSECTS, ADJUSTED BY THE LENGTH IN   *\n*               (OFFSET#) AS APPROPRIATE.  COUNT CAN ONLY BE USED TO  *\n*               REDUCE THE COMPARE LENGTH.                            *\n*                                                                     *\n*        IF ANY 'NUMBER' IS INVALID (E.G. OUTSIDE MODULE OR CSECT),   *\n*        IT IS IGNORED.  IF 'LABEL' IS NOT FOUND, IT IS IGNORED.      *\n*                                                                     *\n*        SYNTACTICAL ERRORS WILL CAUSE A 'PARM INVALID' ERROR         *\n*        MESSAGE.  WRONG PARAMETERS WILL CAUSE UNPREDICTABLE RESULTS. *\n*                                                                     *\n* RETURN CODES: 00 - COMPARE WORKED (COMPLETE LIBS IF 'ALL')          *\n*               04 - COMPARE FAILED (AT LEAST 1 IF 'ALL')             *\n*               08 - INITIALIZATION FAILED (LAST MODULE IF 'ALL')     *\n*                                                                     *\n***********************************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ESDXREF": {"ttr": 1043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00+\\x00+\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "FILE149"}, "text": "-FUNCTION\n0     Program 'ESDXREF' may be used to produce a cross reference\n      listing of all external symbol directory (ESD) entries within a\n      load module library or set of libraries. The program produces\n      both a list of all module names for each ESD name and all ESD\n      names for each module name.\n-PROCESSING\n0     The program first searches the TIOT and builts a list of all\n      DDNAMES beginning with 'XREF'. Then, for each load module library\n      associated with each DDNAME, all ESD entries for all members in\n      the library are read and the ESD data is mapped into an incore\n      table. After all ESD data has been read into core, the table is\n      first sorted in order by ESD name and a cross reference list of\n      modules by ESD name is printed. Next, the table is sorted in\n      order by module name and a cross reference list of ESD names by\n      module names is printed. The program then terminates.\n-EXEC CARD PARMS\n0     None.\n-DD CARDS\n0     STEPLIB  - library containing 'ESDXREF' (may be JOBLIB or in\n                 LINKLST)\n      SYSPRINT - output file\n      XREFkkkk - load module library reference\n      XREFllll - load module library reference 2 (optional)\n      XREFmmmm - load module library reference 3 (optional)\n-SAMPLE JCL\n      //CSYSJCJA JOB CSYSJCJ,MSGCLASS=X,NOTIFY=CSYSJCJ\n      /*JOBPARM ROOM=9917,LINES=999,TIME=999\n      //ESDXREF  EXEC PGM=ESDXREF,REGION=300K\n      //STEPLIB  DD DISP=SHR,DSN=SYS9.MSSLOAD\n      //SYSPRINT DD SYSOUT=*\n      //XREF1    DD DISP=SHR,DSN=SYS1.LINKLIB\n      //XREF2    DD DISP=SHR,DSN=SYS1.LPALIB\n-COMMENTS/CAUTIONS\n0     1 - The program requires 16 bytes per module/esd entry. The\n          region available to the program must be large enough to\n          contain all entries to complete successfully.\n      2 - note that all libraries associated with DDNAMES beginning\n          with 'XREF' are processed 'enmasse'. Thus if duplicate\n          module names exist in separate libraries, the ESD entries\n          for both modules will be 'logically' merged by the table\n          sort and the output cross reference listing will be\n          incorrect for both modules.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$IXTOFMT": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00.\\x00.\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "FILE149"}, "text": "***********************************************************************\n*\nIXTOFMT5 CSECT\n*\n*  THIS ROUTINE USES THE CVAF SERVICE ROUTINES TO CONVERT THE\n*  FREE SPACE BIT MAP OF AN INDEXED VTOC INTO PSUEDO FORMAT-5\n*  DSCBS.  THIS PROVIDES A COMPATIBILITY INTERFACE FUNCTION FOR\n*  PRE-DFDS ROUTINES WHICH EXAMINE FORMAT-5 DSCBS.\n*\n*  THIS ROUTINE IS CALLED ONCE FOR EACH FORMAT-5 WHICH MUST BE\n*  BUILT.  THE INDEX RECORD BUFFER RETURNED BY CVAF IS SAVED SO\n*  THAT NO ADDITIONAL I/O NEED BE DONE FOR SUCCEEDING CALLS.  THE\n*  BUFFERS ARE FREED WHEN THE LAST FORMAT-5 DSCB IS RETURNED.\n*  HENCE, THIS ROUTINE SHOULD BE CALLED UNTIL A FORMAT-5 DSCB WITH\n*  DS5PTRDS EQUAL TO ZERO IS RETURNED.  THE NON-ZERO VALUE IN\n*  DS5PTRDS WILL ALWAYS BE C'00001'.\n*\n*  INPUT:    R1 -->  (PARMLIST)\n*                    A(WORD) -- ADDR OF A FULLWORD USED BY THIS\n*                               ROUTINE.  MUST BE ZEROED FOR FIRST\n*                               CALL AND RETURNED UNALTERED THEREAFTER.\n*                    A(DCB)  -- ADDR OF A DCB OPENED TO THE DESIRED\n*                               VTOC.  NO I/O MAY BE OUTSTANDING TO\n*                               THIS DCB.\n*                    A(COUNT1)- ADDR OF FULLWORD WHERE COUNT OF THE\n*                               FREE (FMT 0) DSCBS WILL BE RETURNED.\n*                    A(COUNT2)- ADDR OF FULLWORD WHERE COUNT OF THE\n*                               FREE VIRS WILL BE RETURNED.\n*                    A(FMT5) -- ADDR OF 140-BYTE AREA FOR FORMAT-5\n*                               DSCB BUILT BY THIS ROUTINE.\n*\n*  RETURN CODES:\n*            R15  = 0   ALL OK.\n*            R15  = 4   VTOC IS NOT IN INDEXED FORMAT.\n*            R15  = 8   CVAFTST CALL FAILED (OTHER THAN NOT INDEXED\n*                       FORMAT VTOC).  CVAFTST RC IN REG 0.\n*            R15  = 12  CVAFDSM CALL FAILED (OTHER THAN NON INDEXED\n*                       FORMAT VTOC).  CVAFDSM RC IN HIGH ORDER BYTE\n*                       OF R0. CVSTAT IN LOW ORDER BYTE OF R0.\n*            R15  = 16  (UNUSED)\n*            R15  = 20  LOGIC ERROR IN THIS ROUTINE.  R0 = OFFSET.\n*\n*\n*  ATTRIBUTES -  REENTRANT, PROBLEM STATE, PROBLEM KEY\n*\n***********************************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$JOIN": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00-\\x00-\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "FILE149"}, "text": "          JOIN - match two files\n\n  JOIN matches two input files on a specified key and produces\nthree output files containing the result of the match.\n\n//JOIN     EXEC PGM=JOIN,\n//     PARM='<offset1>,<offset2>,<field len>,<order>,...'\n//STEPLIB DD DISP=SHR,DSN=SYS5.mssload\n//SYSPRINT DD SYSOUT=*                  * record counts *\n//SYSUDUMP DD SYSOUT=*\n//IN1      DD ---                       * input file 1  *\n//IN2      DD ---                       * input file 2  *\n//OUT1     DD ---                       * output file 1 *\n//OUT2     DD ---                       * output file 2 *\n//OUT3     DD ---                       * output file 3 *\n\n  IN1 records must each have a unique key\n  IN2 records are not required to have a unique key\n\n  Both of the input files must be in order by the specified fields\n  or the results are unpredictable.\n\n  If there is more than one record in IN2 with a matching key\n  of a record in IN1 then two output records will be output\n  to OUT3 each containing the same record from IN1 and\n  one of the records from IN2.\n\n  OUT1 will contain the records from IN1 not matched in IN2.\n  OUT2 will contain the records from IN2 not matched in IN1.\n  OUT3 will contain the records in both IN1 and IN2 concatenated\n    together with IN1 first. (hard to use if the IN1 records\n    are recfm=v as there is only 1 rdw in the resulting record)\n\n   the parameter field specifies the position(s) of the key.\n(more than one field may be specified).  Each field\nis specified as:\n     the offset of the field (origin 1, range 1 -> 4095) in IN1 records\n     the offset of the field (origin 1, range 1 -> 4095) in IN2 records\n     the length of the field (origin 0, range 1 -> 256)\n     the sort order of the field (a or d)\n\n  the output files can be any recfm/lrecl,\nRDW's will be build/destroyed and the resulting records\nwill be truncated or padded if required.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$RHEXFMT": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x11\\x00\\x11\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "FILE149"}, "text": "      URHEXFMT - dsect for URHEXFMT parameter area\n\n name     URHEXFMT  DSECT=,\n                    PREFIX=\n\n   The URHEXFMT macro describes the parameter list to be passed\n to URHEXFMT, the hex format subroutine.\n\n-- DSECT=YES\n  If this keyword is specified as NO then no dsect card will be\n  generated, otherwise a dsect will be generated.\n\n-- PREFIX=IPRM\n  This specifies the prefix to be used to generate labels\n  in the macro expansion. (This allows multiple expansions of this\n  area in one assembly.)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$UNIQUE": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x17\\x00\\x17\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "FILE149"}, "text": "          UNIQUE - select records with unique keys\n\n//UNIQUE   EXEC PGM=UNIQUE,PARM='<offset>,<field len>,<order>,...'\n//STEPLIB DD DISP=SHR,DSN=SYS5.mssload\n//SYSPRINT DD SYSOUT=*                  * record counts *\n//SYSUDUMP DD SYSOUT=*\n//IN       DD ---                       * input file    *\n//OUT      DD ---                       * output file   *\n\n   the parameter field specifies the position(s) of the key.\n(more than one field may be specified).  Each field\nis specified as:\n     the offset of the field (origin 1, range 1 -> 4095)\n     the length of the field (origin 0, range 1 -> 256)\n     the sort order of the field (a or d)\n\n  the input file must be in order by the specified fields\nor the results are unpredictable.\n\n  The output file will contain the first record found in the\ninput file for each unique input key.\nThe output file can be any recfm/lrecl, RDW's will be build/destroyed\nand the resulting records will be truncated or padded if required.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@ACNSWAP": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x11\\x00\\x11\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "FILE149"}, "text": "++ USERMOD (SM01379) .\n++ VER (Z038) FMID(JBB1326)\n   /*\n   ADD LOCAL ENTRIES TO PROGRAM PROPERTIES TABLE\n   NOTE: EACH ENTRY IS 16 BYTES LONG.\n         ENTRIES ADDED AFTER SEQ NUMBER 06000002 AND BEFORE 06050002 .\n   */ .\n++ MACUPD(SGIEF0PT) ASSEM(IEFSDPPT) DISTLIB(AMODGEN) .\n./  CHANGE NAME=SGIEF0PT              AFTER SEQ# 06000002\n********* UPDATE FOR OACNSWAP\n          DC    CL8'OACNSWAP'             PROGRAM NAME       1\n          DC    AL1(PPTNSWP)              PROPERTIES         2\n          DC    AL1(PPTKEY8)              KEY                3\n          DC    XL2'FFFF'                 AFFINITIES         4\n          DC    AL1(0)              FLAG BYTE\n          DC    XL3'00'             RESERVED FLAG BYTES\n./  ENDUP                           BEFORE SEQ# 06050002\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@CNEDFSE": {"ttr": 1291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00-\\x00-\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "FILE149"}, "text": "++USERMOD(SM01255) .\n++VER(Z038) PRE(UZ53532) FMID(EBB1102) .\n++ZAP(IKJEBEMA) DISTLIB(ACMDLIB) .\n*\n* THIS ZAP ADDS THE FOLLOWING TO IKJEBMA9 (EDIT USER SUBCOMMAND TABLE):\n*   D - ALIAS FOR DOWN\n*   T - ALIAS FOR TOP\n*   U - ALIAS FOR UP\n*   FULLSCR, FSE - CCNEDFSE\n*   MODIFY,  MOD - CCNEDMOD\n*   DO - CCNEDDO\n*\n NAME IKJEBEMA IKJEBMA9\n EXPAND  IKJEBMA9(84)\n IDRDATA SM01255\n*\nVER 0000 FF\n* FSE\nREP 0000 07C6E4D3D3E2C3D9      AL1(7),C'FULLSCR'\nREP 0008 03C6E2C5              AL1(3),C'FSE'\nREP 000C C3C3D5C5C4C6E2C5      CL8'CCNEDFSE'\n* MODIFY\nREP 0014 06D4D6C4C9C6E8        AL1(6),C'MODIFY'\nREP 001B 03D4D6C4              AL1(3),C'MOD'\nREP 001F C3C3D5C5C4D4D6C4      CL8'CCNEDMOD'\n* ALIAS FOR DOWN\nREP 0027 01C4                  AL1(1),C'D'\nREP 0029 00                    AL1(0)\nREP 002A C9D2D1C5C2C5C4D6      CL8'IKJEBEDO'\n* ALIAS FOR TOP\nREP 0032 01E3                  AL1(1),C'T'\nREP 0034 00                    AL1(0)\nREP 0035 C9D2D1C5C2C5E3D6      CL8'IKJEBETO'\n* ALIAS FOR UP\nREP 003D 01E4                  AL1(1),C'U'\nREP 003F 00                    AL1(0)\nREP 0040 C9D2D1C5C2C5E4D7      CL8'IKJEBEUP'\n* DO SUBCOMMAND\nREP 0048 02C4D6                AL1(2),C'DO'\nREP 004B 00                    AL1(0)\nREP 004C C3C3D5C5C4C4D640      CL8'CCNEDDO '\n*\nREP 0054 FF                    END OF TABLE\n*\n IDRDATA SM01255\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@EAVNP99": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "FILE149"}, "text": "++ USERMOD (SM01439)\n     /* ADD LINK TO OAC UVT BUILD ROUTINE DURING NIP RIM\n        PROCESSING.  CURRENTLY, THE ADDED ENTRY HAS THE\n        X'02' ATTRIBUTE SET.  THIS WILL CAUSE ONLY AN ERROR\n        MESSAGE IF IEAVNP99 CANNOT BE FOUND, RATHER THAN\n        TERMINATING THE IPL. (SEE ALSO SM01440) */.\n++ VER (Z038) FMID(JBB1326) PRE(UZ53664) .\n++ ZAP (IEAVNIPM) DISTLIB(AOSC5).\n  NAME IEAVNIPM\n  VER  2F70  F1F5,F0F1           IEAVNP15\n  VER  2F74  4040,F0F0           (UNUSED ENTRY)\n  REP  2F74  F9F9,F0F3           IEAVNP99  (X'02' = OPTIONAL ROUTINE)\n++ USERMOD (SM01440) .\n++ VER (Z038) FMID(JBB1326)\n /*---------------------------------------------------------------*/\n /*  OAC UVT BUILD RIM -- IEAVNP99                                */\n /*                                                               */\n /*  THIS ROUTINE IS INVOKED DURING NIP PROCESSING TO BUILD THE   */\n /*  OAC UVT AND CHAIN IT TO THE CVT.  SEE SM01439 FOR THE NEC-   */\n /*  ESSARY CHANGE TO IEAVNIPM TO CAUSE THIS INVOCATION.          */\n /*---------------------------------------------------------------*/ .\n++ JCLIN .\n// JOB\n//STEP1 EXEC PGM=IEBCOPY\n//SYSIN DD *\n  COPY INDD=AOSC5,OUTDD=NUCLEUS\n  SELECT MEMBER=IEAVNP99\n++ MOD (IEAVNP99) LKLIB(AOACDLIB) DISTLIB(AOSC5).\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE149": {"ttr": 1295, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04Y\\x00S\\x01\\x14\"\\x7f\\x01\\x14\"\\x7f\\x17\\x16\\x00Q\\x00Q\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf9@@@'", "ispf": {"version": "04.89", "flags": 0, "createdate": "2014-08-15T00:00:00", "modifydate": "2014-08-15T17:16:53", "lines": 81, "newlines": 81, "modlines": 0, "user": "CBT-489"}, "text": "//***FILE 149 CONTAINS SEVERAL UTILITIES FROM UCLA.  THIS FILE IS   *   FILE 149\n//*           IN IEBUPDTE SYSIN FORMAT - SEE THE MEMBER CALLED      *   FILE 149\n//*           $$DOC FOR ADDITIONAL INFORMATION. THE FOLLOWING IS    *   FILE 149\n//*           A BRIEF DESCRIPTION OF UTILITIES IN THIS FILE :       *   FILE 149\n//*                                                                 *   FILE 149\n//*         CCNEDFSE/CCNEDFSH - FULL SCREEN TSO EDIT SUBCOMMAND     *   FILE 149\n//*              FOR 3270'S.  THIS INCLUDES MOVE/COPY/DELETE        *   FILE 149\n//*              COMMANDS WHICH ALLOW LINE NUMBERS ON UNNUMBERED    *   FILE 149\n//*              FILES.  REQUIRES ZAP TO IKJEBEMA TO ADD TO EDIT    *   FILE 149\n//*              COMMAND TABLE.  (SEE INFO  CNEDFSE)                *   FILE 149\n//*                                                                 *   FILE 149\n//*         CMSLOAD  - LOAD \"DISK DUMP\" FILE FROM VM.               *   FILE 149\n//*                                                                 *   FILE 149\n//*         COMPARE  - LOAD MODULE / CSECT COMPARE PROGRAM.         *   FILE 149\n//*                    *** REQUIRED ***                             *   FILE 149\n//*                                                                 *   FILE 149\n//*         COMPLOAD - LOAD MODULE / CSECT COMPARE PROGRAM.         *   FILE 149\n//*                    *** REQUIRED ***                             *   FILE 149\n//*                    Renamed to make its function clearer.        *   FILE 149\n//*                    Same as COMPARE program, except that         *   FILE 149\n//*                    printable bytes are displayed in EBCDIC,     *   FILE 149\n//*                    next to the HEX bytes.                       *   FILE 149\n//*                                                                 *   FILE 149\n//*         DUMPINFO - TSO CP TO DISPLAY SYS1.DUMP DATASET          *   FILE 149\n//*                    STATUS.  INCLUDES TITLE, DATE AND TIMES.     *   FILE 149\n//*                                                                 *   FILE 149\n//*         ENQ      - SP 1.3 ENQ DISPLAY TSO CP                    *   FILE 149\n//*                                                                 *   FILE 149\n//*         ESDXREF  - LOAD MODULE / CSECT XREF PGM                 *   FILE 149\n//*                                                                 *   FILE 149\n//*         IEAVNP99 - SAMPLE USER NIP EXIT ROUTINE.                *   FILE 149\n//*                    SEE   EAVNP99 FOR SAMPLE SMP INSTALL.        *   FILE 149\n//*                                                                 *   FILE 149\n//*         IEFU83   - SMF 83 EXIT WITH CODE TO WTO OLD IEC209I     *   FILE 149\n//*                    TAPE STATISTICS MESSAGE.  (THE REST OF THE   *   FILE 149\n//*                    LOCAL CODE SHOULD BE DELETED).               *   FILE 149\n//*                                                                 *   FILE 149\n//*         IXTOFMT5 - SUBROUTINE USED TO UPGRADE PGMS TO WORK      *   FILE 149\n//*                    ON INDEXED VTOC'S.  RETURNS \"FAKE\" FMT5'S    *   FILE 149\n//*                    FOR INDEXED PACKS.  (USED BY LISTSPC AND     *   FILE 149\n//*                    VTOCLIST)                                    *   FILE 149\n//*                                                                 *   FILE 149\n//*         JOIN     - VERY SIMPLE & POWERFUL GENERAL MATCH MERGE   *   FILE 149\n//*                    PGM.                                         *   FILE 149\n//*                                                                 *   FILE 149\n//*         LISTGRP  - LISTS UNITS IN GENERICS, OR ESOTERICS.       *   FILE 149\n//*                                                                 *   FILE 149\n//*         LISTSPC  - OLD LISTSPC CP FROM CBT TAPE UPDATED FOR     *   FILE 149\n//*                    INDEXED VTOCS.  (USES IXTOFMT5               *   FILE 149\n//*                    SUBROUTINE).                                 *   FILE 149\n//*                                                                 *   FILE 149\n//*         MOVEZAP  - ZAPS TO (COPY) OF IEHMOVE TO ALLOW           *   FILE 149\n//*                    RUNNING FASTER & NON-AUTHORIZED.             *   FILE 149\n//*                                                                 *   FILE 149\n//*         OACFSORT - ASM SUBROUTINE TO DO FIXED LENGTH            *   FILE 149\n//*                    QUICKSORTS.  (FINAL ORDER CHECK COULD BE     *   FILE 149\n//*                    REMOVED FOR HIGH USAGE CASES)                *   FILE 149\n//*                                                                 *   FILE 149\n//*         OACMOVE  - IEHMOVE PRELOAD PGM. (SEE ALSO MOVEZAP)      *   FILE 149\n//*                                                                 *   FILE 149\n//*         OACNSWAP - PGM TO RUN PROBLEM PROGRAMS NON-SWAPPABLE    *   FILE 149\n//*                    WITH ONLY ONE PPT ENTRY.  PGM IS NOT APF     *   FILE 149\n//*                    AUTHORIZED.  (SEE  ACNSWAP FOR PPT ENTRY     *   FILE 149\n//*                    INFO).                                       *   FILE 149\n//*                                                                 *   FILE 149\n//*         PTFXREF  - PE CHAIN RUNNER (PLIX).                      *   FILE 149\n//*                                                                 *   FILE 149\n//*         SALVAGE  - HDA / PACK CLEAN UP PGM (& CP).              *   FILE 149\n//*                                                                 *   FILE 149\n//*         SMPULCMP - SMP LMOD ENTRY (FROM SMP UNLOAD) COMPARE.    *   FILE 149\n//*                    USED IN SP 1.0 TO SP 1.3 CONVERSION (AND     *   FILE 149\n//*                    OTHER TIMES). (PLIX)                         *   FILE 149\n//*                                                                 *   FILE 149\n//*         UNIQUE   - VERY SIMPLE PGM TO SELECT ONE OF THINGS.     *   FILE 149\n//*                    (SEE ALSO JOIN)                              *   FILE 149\n//*                                                                 *   FILE 149\n//*         USERS    - TSO USERS CP (SELECTS USERS WITH WILDCARDS). *   FILE 149\n//*                                                                 *   FILE 149\n//*         VTOCLIST - OLD VTOCLIST PGM UPDATE TO WORK ON           *   FILE 149\n//*                    INDEXED VTOCS.  (USES IXTOFMT5 SUBROUTINE)   *   FILE 149\n//*                                                                 *   FILE 149\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@IEFU83": {"ttr": 1298, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x08\\x00\\x08\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "FILE149"}, "text": "++USERMOD(SM01368) .\n++VER(Z038) FMID(JBB1126) SUP(SM01258)\n  /*******************************************************************\n   * 1.  UTILIZE SMF EXITS 83 TO FILTER TYPE 14 AND 15 CLOSE/EOV     *\n   * RECORDS FOR DASD/TAPE MOUNT CHARGING.                           *\n   * 2.  SUPPRESS ACF 222 SMF LOGGING RECS FOR CACPAPG#              *\n   ******************************************************************/.\n++MOD(IEFU83) DISTLIB(AOS00) LKLIB(AOACDLIB) .\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CCNEDFSE": {"ttr": 1300, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\tv\\tv\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 2422, "newlines": 2422, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMASA JOB  ACCNT,MSGCLASS=A\n/*ROUTE PRINT WYLBUR\n//    EXEC ASMHCL,\n//    PARM.LKED='RENT,REFR,LIST,XREF,SIZE=(168K,56K)'\n         MACRO\n&L       MSG   &P,&M\n         LCLA  &A\n&A       SETA  K'&M-2\n&L       DC    AL1(&A,&P),CL&A&M\n         MEND\n         SPACE 1\n*        COPY  EDIO\n         MACRO\n&LBL     EDIO  &OP,&OP1,&OP2,&ERRAD=,&MF=E\n         LCLA  &A\n         LCLB  &OW,&ORC,&ORN,&ORP,&ORF,&ORL,&ODLT\n         LCLC  &L,&TO\n&TO      SETC  ''\n&L       SETC  '&LBL'\n         AIF   ('&OP' NE '').HOP\n         MNOTE *,'OPERATION NOT SPECIFIED'\n         AGO   .DOOP1\n.HOP     ANOP\n&OW      SETB  ('&OP' EQ 'W')  WRITE\n&ORC     SETB  ('&OP' EQ 'RC') READ CURRENT\n&ORN     SETB  ('&OP' EQ 'RN') READ NEXT\n&ORP     SETB  ('&OP' EQ 'RP') READ PREVIOUS\n&ORF     SETB  ('&OP' EQ 'RF') READ FIRST\n&ORL     SETB  ('&OP' EQ 'RL') READ LAST\n&ODLT    SETB  ('&OP' EQ 'DLT') DELETE\n         AIF   (&OW+&ORC+&ORN+&ORP+&ORF+&ORL+&ODLT NE 1).ERR1\n&A       SETA  &OW*32+&ORC*0+&ORN*2+&ORP*1+&ORF*4+&ORL*5+&ODLT*16\n.GEN1    ANOP\n&L       MVI   IOLIST,&A       SET OPTION\n&L       SETC  ''\n.DOOP1   AIF   ('&OP1' NE '').HOP1\n         MNOTE *,'OPERAND 1 OMMITTED'\n&TO      SETC  '2'             CHANGE SUBROUTINE ENTRY\n         AGO   .OP1OK\n.HOP1    AIF   ('&OP1' EQ '(R1)').OP1OK\n         AIF   ('&OP1'(1,1) EQ '(').OP1R\n&L       LA    R1,&OP1         GET ADDR OF PARM 1\n&L       SETC  ''\n         AGO   .OP1OK\n.OP1R    ANOP\n&L       LR    R1,&OP1         GET PARM 1\n&L       SETC  ''\n.OP1OK   AIF   ('&OP2' NE '').HOP2\n         MNOTE *,'OPERAND 2 OMMITTED'\n         AGO   .OP2OK\n.HOP2    AIF   ('&OP2'(1,1) EQ '(').OP2R\n&L       LA    R14,&OP2        GET PARM 2\n&L       SETC  ''\n         ST    R14,IOLIST+8   SET PARM 2\n         AGO   .OP2OK\n.OP2R    ANOP\n&L       ST    &OP2,IOLIST+8  SET PARM 2\n&L       SETC  ''\n.OP2OK   AIF   ('&MF' EQ 'B').MEXIT\n&L       BAL   R14,UT$IO&TO    GO DO IO\n         AIF   ('&ERRAD' EQ '').MEXIT\n         BNZ   &ERRAD          BR IF ERROR\n.MEXIT   MEXIT\n.ERR1    MNOTE 12,'&OP IS NOT ONE OF W,RC,RN,RP,RF,RL,DLT'\n         AGO   .GEN1\n         MEND\n         TITLE 'CCNEDFSE - TSO EDIT ''FULLSCR'' SUBCOMMAND'\n***********************************************************************\n*                                                                     *\n*   F U L L S C R   --   EDIT SUBCOMMAND                              *\n*                                                                     *\n*                                                                     *\nCCNEDFSE CSECT                                                        *\n$        EQU   CCNEDFSE                                               *\n*                                                                     *\n*  FUNCTION --                                                        *\n*                                                                     *\n*  INPUT --                                                           *\n*     REGISTER 1 CONTAINS THE ADDRESS OF THE EDIT COMMUNICATIONS AREA.*\n*                                                                     *\n*  OUTPUT--                                                           *\n*     POSSIBLE RETURN CODES (IN REGISTER 15) ARE:                     *\n*     ZERO --       SUBCOMMAND COMPLETED NORMALLY                     *\n*     EIGHT --      RECOVERABLE ERROR OR ATTENTION OCCURRED.          *\n*     TWELVE --     I/O ERROR IN THE WORK FILE                        *\n*                                                                     *\n*  EXTERNAL REFERENCES --                                             *\n*     IKJEBELE --   EDIT LINE EDIT ROUTINE                            *\n*     IKJEBEMS --   EDIT MESSAGE ROUTINE                              *\n*     IKJEBEUT --   EDIT ACCESS METHOD INTERFACE                      *\n*     IKJPTGT --    PUTGET SERVICE ROUTINE                            *\n*     IKJPUTL --    PUTLINE SERVICE ROUTINE                           *\n*                                                                     *\n*  MACROS USED --                                                     *\n*     FREEMAIN --   FREE GOTTEN WORKAREA                              *\n*     GETMAIN --    GET CORE FOR WORKAREA                             *\n*     IKJEBECA --   EDIT COMMUNICATIONS AREA DSECT                    *\n*     IKJEBEMG --   CALLS EDIT MESSAGE ROUTINE (IKJEBEMS)             *\n*     IKJEBEMI --   EDIT MESSAGE INSERT BLOCK                         *\n*     IKJEBEML --   EDIT FIRST-LEVEL MESSAGE BLOCK                    *\n*     IKJEBERT --   EDIT EXIT MACRO                                   *\n*     IKJEBESH --   CALLS EDIT SERVICE ROUTINE IKJEBELE               *\n*     IKJEBESV --   EDIT ENTRY MACRO                                  *\n*     LINK --       LINKS TO FSE HELP ROUTINE                         *\n*     PUTGET --     BUILDS PARMLIST AND LINKS TO PUTGET SERVICE RTN   *\n*     PUTLINE --    BUILDS PARMLIST AND LINKS TO PUTLINE SERVICE RTN  *\n*                                                                     *\n*  EXITS --                                                           *\n*     CONTROL IS RETURNED TO IKJEBEMA (CONTROLLER) IN ALL CASES       *\n*                                                                     *\n*  ATTRIBUTES --                                                      *\n*     REENTRANT, REFRESHABLE, PROBLEM STATE, PROBLEM KEY.             *\n*                                                                     *\n*                                                                     *\n*  WRITTEN BY -- MICHAEL STEIN AND CHRIS THOMAS                       *\n*                OFFICE OF ACADEMIC COMPUTING                         *\n*                UNIVERSITY OF CALIFORNIA, LOS ANGELES                *\n*                PHONE:  213 - 825 - 7424                             *\n*                                                                     *\n*  COPYRIGHT --  THIS MODULE IS COPYRIGHTED BY THE REGENTS OF THE     *\n*                UNIVERSITY OF CALIFORNIA, 1978,1979.  ALL RIGHTS ARE *\n*                RESERVED.                                            *\n*                                                                     *\n*  WRITTEN --    07/03/78                                             *\n*  UPDATED --    03/08/79 - MAS - ADD REPLICATE, DESTROY HARD TABS.   *\n*                               - ADD FDELETE, RESTORE VERIFY FLAG    *\n*                                                                     *\n***********************************************************************\n         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - ENTRY CODE'\n***********************************************************************\n*                                                                     *\n*                            ENTRY CODE                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         IKJEBESV  (14,12),T,CCNEDFSE/COPYRIGHT.1978-1979.UCLA\n         USING  IKJEBECA,COMMREG        BASE REG FOR COMM AREA DSECT\n         SPACE 1\n         L     BASEREG,TRUEBASE         LOAD THE CORRECT BASE\n         USING CCNEDFSE,BASEREG\n*  ZERO OUT WORK AREA INCLUDING RETCDE\n         XC    CASCWKA(256),CASCWKA     ZERO OUT THE WORKAREA\n         XC    CASCWKA+256(80),CASCWKA+256   (CONTINUE)\n         TCLEARQ INPUT                  FLUSH ANY EXTRA INPUT\n         L     R14,=A(STAXEXIT)         POINT TO ATTN EXIT\n         STAX  (R14),REPLACE=NO,        SET UP MY ATTN EXIT            +\n               USADDR=(COMMREG),MF=(E,STAXPARM)\n         L     R12,CCNWORD              @ MY PERM AREA IF EXISTS\n         LTR   R12,R12                  DOES IT EXIST?\n         BNZ   INT$HWRK                 BR IF HAVE PERM AREA\n         SPACE 1\n         GTSIZE\n*  R15 - RC, R0 - LINES/SCREEN, R1 - COLUMNS / LINE\n         LTR   R15,R15                  GTSIZE PARMS OK?\n         BNZ   GTSZERR                  IF NOT, GIVE ERROR MSG\n         L     R8,=X'03000000'          ASSUME DO TPUT FULLSCR\n         LTR   R0,R0                    FULLSCR DEVICE?\n         BP    INT$FST                  BIF FULLSCR DEVICE\n         L     R8,=X'02000000'          DO TPUT CTL INSTEAD\n         L     R4,CAPTIBFR              @ COMMAND INPUT BUFFER\n         LA    R2,4                     CONSTANT OF 4\n         AH    R2,2(,R4)                + OFFSET -> OFFSET + 4\n         LA    R1,0(R2,R4)              @ OF INPUT\n         SH    R2,0(,R4)                OFFSET + 4 - BUFFER LEN\n         LCR   R2,R2                    TRUE LENGTH LEFT\n         BAL   R14,SCAN                 INIT SCAN PTRS\n         BAL   R14,SCANC                SCAN FOR OPERAND\n         BNP   BADTERM                  IF NONE INVALID TERMINAL\n         CLC   TEMPDW(4),=C'CRT '       WANT CRT MODE?\n         BNE   BADTERM                  INVALID TERMINAL IF NOT\n         LA    R0,24                    ASSUME 24 LINES\n         LA    R1,80                    EACH 80 COLUMNS LONG\nINT$FST  LR    R4,R0                    SAVE LINES\n         LR    R5,R1                    AND COLS\n         SPACE 1\n*  XT#WORK LENGTH = XT#PFXL             (PREFIX)\n*                 + LINES * COLS        (I/O SCREEN BUFFER)\n*                 + LINES * 5           (SBA,ADR1,ADR2,SF,ATR)\n*                 + LINES * 2 * 10      (SF,ATR * 10)\n*                 + LINES * 16          (LN#LINE ENTRIES)\n*  NOTE: XT#BUF MUST BE >= (IMC#WRKL) (USED AS WORK AREA)\n         LA    R1,5+2*10(,R1)           FACTOR OUT LINES AMOUNT\n         MR    R0,R1                    LINES * (COLS + FACTOR)\n         CH    R1,=Y(IMC#WRKL)          ENOUGTH WORK AREA?\n         BNL   *+8                      BIF LARGE ENOUGH\n         LH    R1,=Y(IMC#WRKL)          FORCE TO WORK AREA MINIMUM\n         LR    R7,R4                    LINES / SCREEN\n         SLL   R7,4                     * LN#LINEL -> LN#LINE AREA LEN\n         LA    R6,XT#PFXL(R7,R1)        TOTAL REQUIRED\n         GETMAIN EC,LV=(R6),A=XWORKADR,SP=1,MF=(E,GETMFL)    GET IT\n         BXH   R15,R15,NOCORE           BR IF NO CORE - ISSUE ERR MSG\n         L     R12,XWORKADR             ADDR CORE JUST BOUGHT\n         USING XT#WORK,R12\n         XC    XT#WORK(256),XT#WORK     INIT PREFIX TO ZERO\n         XC    XT#WORK+256(XT#PFXL-256),XT#WORK+256\n         AR    R6,R12                   GET ADDR PAST END\n         LA    R7,XT#BUF(R7)            POINT TO XT#BUF\n* SET LINES, COLS, END ADDR+1, XT#BUF, TPUT FLAG\n         STM   R4,R8,XT#SCRL            INIT XT#WORK FIELDS\n         MVI   XT#TABC,X'5A'            SET DEFAULT TAB CHAR\n         MVI   XT#TABTR+X'5A',1         SET TAB IN TRT TABLE\n         MVI   XT#OMSGP+1,255           NO OLD MESSAGE TO OVERLAY\n         MVI   XT#CUR+1,1               HOME CURSOR\n         MVC   XT#DFT(4),=AL1(15,15,40,40) U,D,L,R DEFAULT VALUES\n         OI    XT#CURSQ,X'80'           DON'T HAVE ROD1 POS CURSOR YET\n         ST    R12,CCNWORD              SAVE ADDR PERM AREA\n         MVI   XT#SEQL+3,7              ASSUME 6 DIGITS WILL WORK\n         EDIO  RL,,BUF1                 READ LAST RECORD\n         BNZ   INT$SEQ7                 BIF EMPTY FILE\n         CLC   BUF1(4),=F'1000000'      6 DIGITS ENOUGHT?\n         BL    INT$SEQ7                 BIF 6 DIGITS ENOUGTH\n         MVI   XT#SEQL+3,9              ELSE USE 8 DIGITS + ATTR\nINT$SEQ7 L     R8,=A(C$T)               @ OF TOP CODE\n         BALR  R10,R8                   GO DO TOP COMMAND\n         L     R1,=A(MSG#ENT)           @ ENTER MSG\n         BAL   R14,MSG                  GO SET IT\n         SPACE 1\nINT$HWRK TM    XT#FLAG,XT#FSCR          ALREADY IN FULLSCREEN MODE?\n         BO    INT$HW2                  BIF ALREADY IN FULLSCREEN MODE\n         STFSMODE ON,INITIAL=YES        SET VTAM FULL SCREEN MODE\n         BXH   R15,R15,INT$HW2          BIF NOT VTAM\n         OI    XT#FLAG,XT#FVTAM         SET IS VTAM FLAG\nINT$HW2  MVC   XT#SAVF,CACFLAG1         SAVE VERIFY FLAG\n         NI    XT#SAVF,CAVRFYSW         ONLY SAVE VERIFY FLAG\n         NI    CACFLAG1,255-CAVRFYSW    SET VERIFY = NO\n         NI    XT#OPT,255-XT#FTAB       OFF MY TAB FLAG\n         TM    CATABS,X'FF'             TABS ON?\n         BZ    *+8                      BIF TABS OFF\n         OI    XT#OPT,XT#FTAB           SET MY TABS FLAG\n         TM    XT#FLAG,XT#FSCN          USE MY POSITION?\n         BZ    INT$EPOS                 BIF NOT TO USE EDIT'S POS\n         MVC   CACURNUM,XT#CNUM         USE IT\n         NI    XT#FLAG,255-XT#FSCN      OFF USE MY POS FLAG\nINT$EPOS LA    R3,XT#LINS               POINT TO FIRST LINE CTL ENTRY\n         L     R4,XT#SCRL               NUMBER OF LINES\n         USING LN#LINE,R3\nINT$LIN  XC    LN#LINE(LN#LINEL),LN#LINE INIT TO ZERO\n         MVC   LN#RIN(4),=Y(R$ICMD-$,R$OCMD-$) ASSUME CMD LINE\n         CL    R4,XT#SCRL               LINES / SCREEN\n         BE    INT$LNXT                 BR IF CMD LINE\n         MVC   LN#RIN(4),=Y(R$IDAT1-$,R$ODAT1-$) DATA ROUTINES\n         MVI   LN#FLAG,LN#FDAT          SET DATA LINE\n         CH    R4,=H'1'                 LAST LINE? (STATUS LINE?)\n         BH    INT$LNXT                 BR IF DATA LINE\n         MVC   LN#RIN(4),=Y(R$IST-$,R$OST-$) STATUS ROUTINES\n         MVI   LN#FLAG,0                NOT DATA LINE\nINT$LNXT LA    R3,LN#LINEL(,R3)         TO NEXT ENTRY\n         BCT   R4,INT$LIN               BUILD ALL LINE CTL\n         OI    XT#FLAG,XT#FSS           FORCE SETSCRN CALL\n         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - FULLSCR CODE'\n*  SCREEN SIZE: MOD1 - 480,   (12 LINES OF 40 CHARACTERS)\n*               MOD2 - 1920,  (24 LINES OF 80 CHARACTERS)\n*               MOD3 - 2560,  (32 LINES OF 80 CHARACTERS)  (3278)\n*               MOD4 - 3440,  (43 LINES OF 80 CHARACTERS)  (3278)\n*  3270 WRITE SEQUENCE ---\n*    LOCAL  - WCC, (SBA, CUR1, CUR2, SF, ATTR, DATA)\n*             (ALWAYS USE LOCAL SEQUENCE FROM TSO)\n*    REMOTE - ESC, CMD, WCC, (SBA, CUR1, CUR2, SF, ATTR, DATA)\n*\n*  ESC - X'27'\n*  CMD - X'F1' - WRITE (DEFAULT)        (CCW X'01')\n*        X'F5' - ERASE/WRITE            (CCW X'05')\n* WCC -  X... ....  - SET TO MAKE VALID CHAR\n*        .1.. ....  - ALWAYS ONE\n*        ..XX ....  - PRINTOUT FORMAT\n*        .... 1...  - START PRINTER BIT\n*        .... .1..  - SOUND ALARM\n*        .... ..1.  - KEYBOARD RESTORE (RESET INPUT INHIBITED AND AID)\n*        .... ...1  - RESET MDT BITS\n* SBA - X'11' - SET BUFFER ADDRESS\n* ATTRIBUTE CHAR ----\n*        X... ....  - SET TO MAKE VALID CHAR\n*        .1.. ....  - ALWAYS ONE\n*        ..1. ....  - PROTECTED\n*        ..11 ....  - AUTO SKIP (PROTECTED NUMERIC)\n*        ...1 ....  - NUMERIC\n*        .... 00..  - DISPLAY/NOT SELECTOR-PEN DETECTABLE\n*        .... 01..  - DISPLAY/SELECTOR-PEN DETECTABLE\n*        .... 10..  - INTENSIFIED DISPLAY/SELECTOR-PEN DETECT.\n*        .... 11..  - NONDISPLAY,NONPRINT,NONDETECT.\n*        .... ..0.  - RESERVED MUST BE 0\n*        .... ...M  - 1 - FIELD MODIFIED/0 - NOT MODIFIED\n*\n* AID CODES: X'60' - UNSOLICITED READ   (READ MODIFIED)\n*            X'E8' - PRINTER            (READ MODIFIED)\n*            X'7D' - ENTER KEY          (READ MODIFIED)\n*   X'F1' TO X'F9' - PF1 TO PF9         (READ MODIFIED)\n*            X'7A' - PF10               (READ MODIFIED)\n*            X'7B' - PF11               (READ MODIFIED)\n*            X'7C' - PF12               (READ MODIFIED)\n*            X'E6' - OPER ID CARD RDR   (READ MODIFIED)\n*            X'7E' - SELECTOR-PEN       (READ MODIFIED)\n*            X'6C' - PA1                (SHORT READ) (TSO ATTN)\n*            X'6E' - PA2 (CNCL)         (SHORT READ)\n*            X'6B' - PA3                (SHORT READ) (SPF RESHOW)\n*            X'6D' - CLEAR KEY          (SHORT READ)\n* (NO AID)   X'F0' - TEST REQ           (TEST REQUEST READ) X'016C6102'\n*                                       FOLLOWED BY DATA (NO AID,CUR)\n*                    (USED BY VTAM)\n         EJECT ,\n*  TPUT/TGET ---\n*    R0 - TJID / LENGTH\n*    R1 - FLAGS / BUFFER ADDRESS\n*        1... ....  - TGET\n*        .XX. ....  - RESERVED\n*        ...1 ....  - NOWAIT\n*        .... 1...  - HOLD\n*        .... .1..  - BREAK\n*        .... ..00  - EDIT\n*        .... ..01  - ASIS\n*        .... ..10  - CONTROL\n*        .... ..11  - FULLSCR\n* RETURN CODES --- TGET\n* 00  - ALL OK, R1 = INPUT LENGTH\n* 04  - NOWAIT AND NO INPUT WAS AVAILABLE\n* 08  - ATTENTION INTERUPT OCCURED DURING TGET\n* 0C  - BUFFER NOT LARGE ENOUGTH (NEXT TGET WILL GET NEXT CHUNK)\n* 10  - INVALID PARMS\n* 14  - TERMINAL DISCONNECTED\n*              --- TPUT\n* 00  - ALL OK\n* 04  - NOWAIT AND NO BUFFERS AVAILABLE\n* 08  - ATTENTION INTERUPT OCCURED DURING TPUT\n* 0C  - TPUT WITH TJID REFUSED BY USER\n* 10  - INVALID PARMS\n* 14  - TERMINAL DISCONNECTED\n*\n*  EDIT UTILITY FILE ROUTINE PARMS:\n*    0     - OPERATION REQUESTED\n*       X'00' - READ SPECIFIED RECORD\n*       X'01' - READ PREVIOUS RECORD\n*       X'02' - READ NEXT RECORD\n*       X'04' - READ FIRST RECORD\n*       X'05' - READ LAST RECORD\n*       X'10' - DELETE RECORD\n*       X'20' - WRITE RECORD (OR ADD)\n*\n*    1 -  3 - UTILITY DCB ADDRESS\n*    4 -  7 - RECORD KEY FOR READ/DELETE\n*             RECORD ADDRESS FOR WRITE\n*    8 - 12 - RECORD ADDRESS FOR READ\n*\n* RETURN CODES:\n*    0 - OPERATION SUCCESSFUL\n*    4 - RECORD DOES NOT EXIST (READ/DELETE)\n*    8 - I/O ERROR (MESSAGE ALREADY ISSUED)\n*   12 - INVALID LINE NUMBER\n*\n         EJECT ,\nINFULL   TM    XT#FLAG,XT#FIMC          INSERT/MOVE/COPY PENDING?\n         BZ    INF$NIMC                 BIF IF NONE\n         L     R8,=A(IMCRTN)            @ INSERT/MOVE/COPY ROUTINE\n         BALR  R10,R8                   GO DO IT\nINF$NIMC CLC   XT#OMSGP,XT#SCRC+2       ANY MSG ON SCREEN?\n         BNE   INF$CHGM                 BIF MSG TO CHANGE IT\n         OC    XT@MSG,XT@MSG            ANY MESSAGE TO DISPLAY?\n         BZ    *+8                      BIF NO MSG TO DISPLAY\nINF$CHGM OI    LN#FLAG-LN#LINE+XT#LINS,LN#FCHG SET CHANGE FLAG\n         TM    XT#FLAG,XT#FSS           SETSCRN CALL REQUIRED?\n         BZ    INF$NSS                  BIF NO SETSCRN REQ\n         L     R15,CACURNUM             GET EDIT CURRENT POSITION\n         BAL   R10,SETSCRN              DO IT\n         NI    XT#FLAG,255-XT#FSS       DON'T NEED IT NOW\nINF$NSS  L     R2,XT@BUF\n         MVI   0(R2),X'C3'              SET WCC\n         LA    R2,1(,R2)                SKIP OVERT WCC\n         TM    XT#FLAG,XT#FVTAM         VTAM?\n         BO    INF$VTAM                 BIF VTAM\n         MVC   0(3,R2),=X'115D7F'       SET TCAM FULL SCREEN CODE\n         LA    R2,3(,R2)                SKIP OVERT TCAM PREFIX\nINF$VTAM TM    XT#SET,LN#FCHG           RESHOW?\n         BZ    INF$RS                   BR IF NOT RESHOW\n         MVC   0(7,R2),=X'1140403C404000' CLEAR SCREEN TO NULLS\n         LA    R2,7(,R2)                BUMP OUTPUT PTR\nINF$RS   LA    R3,XT#LINS               LINE CTL TABLE ADDR\n         USING LN#LINE,R3\n         L     R4,XT#SCRL               LINES / SCREEN\n         SPACE 1\nINF$LP   OC    LN#FLAG(1),XT#SET        SET FLAGS\n         OC    LN#FLAG(1),XT#CLR        AND CLEAR\n         XC    LN#FLAG(1),XT#CLR        SOME TOO\n         TM    LN#FLAG,LN#FCHG          LINE CHANGED?\n         BZ    INF$NEXT                 BR IF NO WRITE REQUIRED\n         NI    LN#FLAG,255-LN#FCHG      CLEAR CHANGED FLAG\n         LA    R0,25(,R2)               5+20\n         AL    R0,XT#SCRC               COLUMNS / LINE\n         CL    R2,XT@END                ROOM LEFT FOR STUFF?\n         BL    *+8                      BR IF ROOM LEFT\n         EX    0,*                      DIE - XT#WORK TOO SMALL\n         MVI   0(R2),X'11'              SET SBA\n         L     R0,XT#SCRL               LINES / SCREEN\n         SR    R0,R4                    GET CURRENT LINE NUMBER\n         MH    R0,XT#SCRC+2             GET POSITION ON SCREEN\n         BAL   R14,CV$POS               SET POSITION\n         MVI   3(R2),X'1D'              SET SF\n         MVI   4(R2),X'40'              AND DEFAULT ATTRIBUTE CHAR\n         LH    R8,LN#ROUT               GET ROUTINE OFFSET\n         AR    R8,BASEREG               GET ROUTINE ADDR\n         BALR  R10,R8                   CALL OUTPUT ROUTINE\nINF$NEXT LA    R3,LN#LINEL(,R3)         TO NEXT LINE CTL ENTRY\n         BCT   R4,INF$LP                PROCESS ALL LINES\n         DROP  R3                       (LN#LINE)\n         SPACE 1\n*---                SET CURSOR POSITION                            ---*\n         LH    R0,XT#CUR                GET CURSOR POSITION\n         OI    XT#CURSQ,X'80'           NO MORE SEQ NUM FOR CUR POS\n         MVI   0(R2),X'11'              SET SBA\n         BAL   R14,CV$POS               SET CURSOR POSITION CHARS\n         MVI   3(R2),X'13'              INSERT CURSOR CHAR\n         LA    R2,4(,R2)                SKIP OVER CURSOR POS\n         L     R1,XT@BUF                OUTPUT STRING POSITION\n         SR    R2,R1                    GET LENGTH TO TPUT\n         LR    R0,R2                    LENGTH TO R0\n         BAL   R14,SP$TPUT              TPUT FULLSCR IT\n         OI    XT#FLAG,XT#FSCR          IN FULLSCR MODE NOW\n*  NO EOF ON SCREEN YET, DON'T ERASE CMD LINE (SO FAR)\n         NI    XT#FLAG,255-XT#FEOF-XT#FECMD\n         XC    XT#SET(2),XT#SET         NO SET/CLEAR FLAGS LEFT\n         XC    XT#CMDL,XT#CMDL          NO CMD ENTERED YET\n         XC    XT@MSG,XT@MSG            NO MSG YET\n         L     R1,XT@BUF                POINT TO INPUT BUFFER\n         L     R0,XT@END                PAST INPUT BUFFER ADDR\n         SR    R0,R1                    GET INPUT BUFFER LENGTH\n         BAL   R14,SP$TGET              TGET ASIS\n         MVI   XT#AID,X'6E'             FAKE PA2 IF ATTENTION\n         CH    R15,=H'8'                ATTN DURING TGET?\n         BE    INF$NPF                  PROCESS AS PA2 (RESHOW)\n         BXH   R15,R15,FLUSH            GO FLUSH IF TGET ERROR\n         NI    CAATTN,255-CAATTNIS      NO ATTENTION YET\n         LTR   R5,R1                    CHECK INPUT LENGTH\n         BNP   INFULL                   BR IF NO INPUT\n         L     R15,XT@BUF               GET ADDR OF INPUT\n         MVC   TEMPDW(7),0(R15)         COPY TO WORK AREA\n         OC    TEMPDW(7),=CL8' '        TO UPPER CASE\n         CLC   TEMPDW(3),=C'END'        NON 3277 END?\n         BE    FLUSH                    BR TO LET HIM OUT\n         CLC   TEMPDW+3(3),=C'END'      NON FORMATED SCREEN END?\n         BE    FLUSH                    BR TO LET HIM OUT\n         MVC   XT#AID,0(R15)            SAVE AID CHAR\n         CLI   XT#AID,X'F1'             PFK 1 - 9?\n         BNL   INF$KOK                  BIF PFK 1 - 9\n         CLI   XT#AID,X'7A'             PFK 10 - 12 OR ENTER?\n         BL    INF$NPF                  BIF NOT PFK 10 - 12\n         CLI   XT#AID,X'7D'             PFK 10 - 12 OR ENTER?\n         BNH   INF$KOK                  BIF PFK 10 - 12 OR ENTER\nINF$NPF  OI    XT#SET,LN#FCHG           ALL OTHERS SET RESHOW\n         CLI   XT#AID,X'6E'             PA2?\n         BE    INFULL                   NO COMMAND OR INPUT IF RESHOW\n         CLI   XT#AID,X'6B'             PA3? (SPF INTERCEPT RESHOW)\n         BNE   INF$NFMT                 BIF NOT PA3, FORMAT ERROR\n         B     INFULL                   NO COMMAND OR INPUT IF PA3\nINF$KOK  CH    R5,=H'1'                 ONLY AID?\n         BE    INFULL                   GO PROCESS ONLY AID\n         CH    R5,=H'3'                 ONLY AID,CUR1,CUR2?\n         BL    INF$NFMT                 INVALID INPUT\n         L     R1,XT@BUF                POINT TO AID,CUR1,CUR2\n         BAL   R14,CV$POSC              CONVERT CURSOR POSITION\n         STH   R0,XT#CUR                SAVE CURSOR POSITION\n         SH    R5,=H'4'                 - SBA,CUR1,CUR2, - 1\n         BM    INF$CMD                  BIF NO INPUT BUT AID,CUR1,CUR2\n         LA    R4,3(,R1)                POINT TO 1ST SBA\n         STM   R4,R5,XT#IADR            SET ADR, LEN-1\nINF$LP3  BAL   R10,FISCAN               SCAN FOR NEXT FIELD\n         BZ    INF$CMD                  BR IF ALL INPUT DONE\n         LH    R8,LN#RIN-LN#LINE(,R3)   OFFSET OF INPUT ROUTINE\n         AR    R8,BASEREG               ADDR OF INPUT ROUTINE\n         BALR  R10,R8                   TO INPUT ROUTINE\n         B     INF$LP3                  AND CONTINUE\nINF$NFMT L     R1,=A(MSG#NFMT)          SCREEN FORMAT ERROR\n         BAL   R14,MSG                  GO SET MESSAGE\n         B     INFULL                   GO WRITE MSG/REDISPLAY SCREEN\n         EJECT ,\nINF$CMD  LM    R1,R2,XT#CMDA            GET CMD ADDR/LEN\n         CLC   XT#CUR,XT#SCRC+2         CURSOR ON 1ST LINE (CMD)\n         BH    *+10                     BIF CURSOR NOT ON CMD LINE\n         MVC   XT#CUR,=H'1'             HOME CURSOR IF ON CMD LINE\n         BAL   R14,SCAN                 INIT SCAN PTRS\n         CLI   XT#AID,X'7D'             ENTER KEY?\n         BNE   INF$PFK                  BIF NOT ENTER, TRY PFK\n         BAL   R14,SCANC                SCAN FOR CMD\n         BZ    INF$TAB                  BR IF NO CMD\n         BM    INF$ICMD                 BR IF INVALID CMD\n         LM    R5,R7,=A(CMD#T,CMD#TL,CMD#TE) @, LEN ENT, @ LAST ENT\n         BAL   R14,FIND                 GO FIND COMMAND ENTRY\n         BE    INF$CFD\n         L     R8,=A(STK#EDIT)          @ STACKING ROUTINE\n         BALR  R10,R8                   SEE IF HE'LL BUY CMD\nINF$ICMD L     R1,=A(MSG#ICMD)          @ INVALID COMMAND MSG\n         BAL   R14,MSG                  GO SET IT\n         B     INF$CCUR                 GO POSITION CURSOR\nINF$PFK  LM    R5,R7,=A(PFK#T,PFK#TL,PFK#TE) FIND BXLE REGS\n         MVC   TEMPDW(1),XT#AID         SET AID TO FIND\n         BAL   R14,FIND                 FIND AID CODE\n         BNE   INF$ICMD                 BIF AID NOT DEFINED\n         LH    R5,2(,R5)                GET CMD ENTRY OFFSET\n         AR    R5,BASEREG               POINT TO CMD ENTRY\nINF$CFD  MVC   XT#CUR,=H'1'             HOME CURSOR VAL CMD\n         CLI   9(R5),0                  NUMERIC OPERAND?\n         BE    INF$CFD2                 BIF NO NUMERIC OPERAND\n         BAL   R14,SCANN                GET NUMERIC OPERAND\n         BP    INF$CFD2                 BIF GOT OPERAND\n         SR    R15,R15                  CLEAR FOR IC(S)\n         IC    R15,9(,R5)               GET XT#DFT OFFSET\n         CH    R15,=H'128'              ANY DEFAULT?\n         BE    INF$MNO                  BIF MISSING NUMERIC OPERAND\n         IC    R15,XT#DFT-1(R15)        GET DEFAULT VALUE\nINF$CFD2 LH    R8,10(,R5)               GET CMD RTN OFFSET\n         AR    R8,BASEREG               @ CMD ROUTINE\n         BALR  R10,R8                   CALL CMD ROUTINE\n         OI    XT#FLAG,XT#FECMD         ERASE CMD SINCE IT WORKED\n         OI    LN#FLAG-LN#LINE+XT#LINS,LN#FCHG SET CMD LINE CHG FLG\n         B     INFULL\nINF$MNO  L     R1,=A(MSG#MNO)           MISSING NUMERIC OPERAND\n         BAL   R14,MSG                  SET IT\n         B     INF$CCUR                 GO POSITION CURSOR\nINF$MOPR L     R1,=A(MSG#MOPR)          MISSING OPERAND\n         BAL   R14,MSG                  SET IT\n         B     INF$CCUR                 GO POSITION CURSOR\nINF$IOPR L     R1,=A(MSG#IOPR)          INVALID OPERAND\n         BAL   R14,MSG                  SET IT\nINF$CCUR L     R1,SV#SCANP              GET PREV SCAN PTR VALUE\n         S     R1,XT#CMDA               GET OFFSET INTO CMD INPUT\n         BM    INFULL                   DON'T CURSOR POSITION IF BAD\n         LA    R1,1(,R1)                SKIP ATTR BYTE\n         STH   R1,XT#CUR                POSITION CURSOR\n         B     INFULL                   AND GO DO IT\n         SPACE 1\nINF$TAB  LH    R1,XT#CUR                GET CURSOR POSITION\n         LR    R15,R1                   SAVE CURSOR POSITION\n         SR    R0,R0                    CLEAR FOR DIVIDE\n         D     R0,XT#SCRC               GET LINE #\n         CL    R0,XT#SEQL               ON 1ST DATA ATTR BYTE?\n         BNE   INFULL                   BIF NOT ON 1ST DATA ATTR BYTE\n         CL    R1,XT#SCRL               VALID LINE NUMBER?\n         BNL   INFULL                   BIF INVALID LINE\n         SLL   R1,4                     OFFSET OF LN#LINE ENTRY\n         LA    R1,XT#LINS(R1)           @ LN#LINE ENTRY\n         USING LN#LINE,R1\n         TM    LN#FLAG,LN#FDAT          DATA LINE?\n         BZ    INFULL                   BIF NOT DATA LINE\n         OI    LN#FLAG,LN#FNTAB+LN#FCHG DESTROY TABS ON THIS LINE\n         LA    R15,1(,R15)              POSITION CURSOR PAST ATTR\n         STH   R15,XT#CUR               SET NEW CURSOR POSITION\n         B     INFULL                   AND CONTINUE\n         DROP  R1                       (LN#LINE)\n         EJECT ,\n*  FISCAN - SCAN ASIS INPUT STREAM\n*   'XT#IADR' - REMAINING INPUT STRING ADDRESS\n*   'XT#ILEN' - REMAINING INPUT STRING LENGTH -1\n*   'XT#LINS' - LINE CTL AREA (ONE LN#LNE ENTRY PER SCREEN LINE)\n*   R10 - RETURN ADDR\n*     ON EXIT:  R0  - CONVERTED FIELD POSITION\n*               R1  - ADDRESS OF FIELD (AFTER ATTRIBUTE CHAR)\n*               R2  - LENGTH OF FIELD  (ONLY DATA AFTER ATTRIBUTE)\n*               R3  - ADDR LINE CTL ENTRY       (0 IF ERROR, CC SET)\n*               R14 - OFFSET INTO LINE\n*               R15 - LINE NUMBER\n*   USES: R0, R1, R2, R3, R14, R15\n         SPACE 1\nFISCAN   LM    R15,R0,XT#IADR           INPUT ADDR, LENGTH LEFT - 1\n         LA    R1,1(,R15)               COPY INPUT ADDR (SKIP SBA)\n         LR    R2,R0                    COPY LEN -1\n         BCTR  R2,0                     GET LEN-1 WITHOUT SBA\n         LTR   R2,R2                    REALLY DATA THERE?\n         BNP   FI$ERR                   RETURN, NO MORE INPUT\n         CLI   0(R15),X'11'             START WITH SBA?\n         BNE   FI$ERR1                  ERROR IF NOT\n         LA    R14,255                  MAX TRT LENGTH -1\nFI$PARSG CR    R14,R2                   MAX LEN :: LEN LEFT\n         BL    *+6                      USE SMALLER (MAX)\n         LR    R14,R2                   USE SMALLER (LEFT)\n         EX    R14,FI$TRT               TRT 0(0,R1),FI#TRTAB\n         BNZ   FI$SBAFD                 BR IF SBA FOUND\n         LA    R1,1(R1,R14)             UPDATE SCAN PTR\n         BCTR  R2,0                     GENERATE LENGTH\n         SR    R2,R14                   SCANNED - 1\n         BNM   FI$PARSG                 IF MORE LEFT CONTINUE\n         SPACE 1\nFI$SBAFD SR    R1,R15                   GET LENGTH OF FIELD DATA\n         SR    R0,R1                    GET NEW LENGTH LEFT -1\n         LR    R2,R1                    RETURN FIELD LENGTH\n         LR    R1,R15                   RETURN FIELD ADDR\n         AR    R15,R2                   POINT PAST FIELD\n         SH    R2,=H'3'                 SBA,ADR,ADR?\n         BM    FI$ERR1                  BR IF BAD INPUT (ZERO IS OK)\n         STM   R15,R0,XT#IADR           SAVE UPDATED ADR, LEN-1\n         BAL   R14,CV$POSC              GET POSITION OF FIELD\n         LA    R1,3(,R1)                SKIP SBA,ADR1,ADR2\n         LR    R15,R0                   COPY FIELD POSITION\n         SR    R14,R14                  CLEAR FOR DIVIDE\n         D     R14,XT#SCRC              / COLUMNS ON LINE\n         LR    R3,R15                   COPY LINE NUMBER\n         SLL   R3,4                     GET LN#LINE OFFSET\n         LA    R3,XT#LINS(R3)           POINT TO LN#LINE ENTRY\n         CL    R15,XT#SCRL              VALID LINE NUMBER?\n         BLR   R10                      RETURN IF VALID\nFI$ERR1  OI    XT#SET,LN#FCHG           FORMAT ERROR - FORCE RESHOW\n         L     R1,=A(MSG#NFMT)          SCREEN FORMAT ERROR\n         BAL   R14,MSG                  SET MSG\nFI$ERR   SR    R3,R3                    SET CC, NO FIELD FOUND\n         BR    R10                      AND RETURN\nFI$TRT   TRT   0(0,R1),FI#TRTAB         * EXECUTED *\n         SPACE 1\nFI#TRTAB DC    0D'0',256X'00'\n         ORG   FI#TRTAB+X'11'           ONLY STOP ON SBA\n         DC    X'04'\n         ORG   ,\n         SPACE 2\n*  MSG: SET MESSAGE ROUTINE\n*    ENTRY:  R1 - @ OF AL1(MSG LEN, PRIORITY),C'MESSAGE'\n*            R14 - RETURN ADDR\n*            (USES 'TEMPDW2')\n*  NOTE: IF PRIORITY IS ODD DOES NOT RETURN IF NEW MESSAGE SET,\n*        INSTEAD GOES TO REBUILD SCREEN (AFTER SETTING MSG).\n*\nMSG      ST    R15,TEMPDW2              SAVE A REG\n         L     R15,XT@MSG               GET ADDR OF PREVIOUS MSG IF ANY\n         LTR   R15,R15                  ANY MESSAGE YET?\n         BZ    MSG1\n         CLC   1(1,R1),1(R15)           COMPARE PRIORITIES\n         L     R15,TEMPDW2              RESTORE WORK REG\n         BNHR  R14                      BIF NEW MSG NOT HIGHER PRTY\nMSG1     ST    R1,XT@MSG                SET NEW MSG ADDR\n         TM    1(R1),X'01'              REBUILD SCREEN REQUIRED?\n         BZR   R14                      RETURN IF NO REBUILD REQUIRED\n         B     INFULL                   GO REBUILD SCREEN\n         EJECT ,\n*  R0  - POSITION (0 -> 24*80)  (DESTROYED)\n*  R2  - ADDR-1 TO PLACE ADR1,ADR2 CHARACTERS\n*  R14 - RETURN ADDR\n         SPACE 1\nCV$POS   STC   R0,2(,R2)                SET SECOND CHAR\n         SRL   R0,6                     GET FIRST CHAR\n         STC   R0,1(,R2)                SET FIRST CHAR\n         NC    1(2,R2),=X'3F3F'         CLEAN UP CHARS\n         L     R15,=A(TAB3270)          @ FOLD TR TABLE\n         TR    1(2,R2),0(R15)           MAKE VALID 3270 CHARS\n         BR    R14                      AND RETURN\n         SPACE 2\n*  R0  - ON RETURN CONTAINS POSITION\n*  R1  - ADDR-1 OF ADR,ADR2 CHARS\n*  R14 - RETURN ADDR\n*  R15 - (DESTROYED)\n         SPACE 1\nCV$POSC  IC    R0,1(,R1)                GET FIRST CHAR\n         N     R0,=X'0000003F'          CLEAR GARBAGE\n         IC    R15,2(,R1)               GET SECOND CHAR\n         N     R15,=X'0000003F'         CLEAR GARBAGE\n         SLL   R0,6                     SHIFT TO COMBINE\n         OR    R0,R15                   COMBINE TO GET POSITION\n         BR    R14                      RETURN\n         SPACE 1\nSP$TPUT  O     R1,XT#TPUTF              ADD FULLSCR OPTION (OR CTL)\n         CL    R0,=F'2100'   *TEMP*   > TCAM BUFFER - FUDGE\n******** BNH   *+8           *TEMP*   BIF <= TCAM BUFFER\n         B     *+8           *TEMP*   (WAS BNH *+8 - CHECK NOT REQ\n********                               WITH VTAM ON MVS)\n         EX    0,*           *TEMP*   DIE IF > TCAM BUFFER\n         B     *+8\nSP$TGET  O     R1,=X'81000000'          MAKE IT A TGET ASIS\n         ST    R14,TEMPDW               SAVE RETURN ADDR\n         TPUT  (1),(0),R                DO TPUT OR TGET\n         L     R14,TEMPDW               RESTORE RETURN ADDR\n         BR    R14                      AND RETURN\n         SPACE 1\n         LTORG ,\n         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND -- UTIO CODE'\nUT$RD    ST    R14,TEMPDW               SAVE RETURN ADDR\n         EDIO  RC,(R3),BUF1             READ CURRENT RECORD\n         L     R14,TEMPDW               RESTORE RETRN ADDR\n         LA    R1,BUF1+8                POINT TO RECORD DATA\n         BNZR  R14                      RETURN IF ERROR\n         LH    R0,BUF1+4                GET LENGTH FROM RDW\n         TM    CACFLAG2,CARECFM         FIXED LENGTH RECORDS?\n         BO    UT$RDFX                  BIF FIXED LENGTH RECORD\n         LH    R0,CALRECL               MAX LENGTH (INCLUDING RDW)\n         LR    R15,R0                   COPY MAX LENGTH\n         SH    R15,BUF1+4               - THIS REC LENGTH\n         BNP   UT$RDAB\n         LA    R1,BUF1+4                @ BEGINING OF RECORD\n         AH    R1,BUF1+4                POINT TO AREA TO BLANK\n         MVI   0(R1),C' '               BLANK 1ST BYTE OF IT\n         SH    R15,=H'2'                GET EX LENGTH OF REST\n         BNP   UT$RDAB\n         EX    R15,UT$RDMV              MVC 1(0,R1),0(R1)\nUT$RDAB  LA    R1,BUF1+8                POINT TO RECORD ORIG\nUT$RDFX  SH    R0,=H'4'                 - RDW LENGTH\n         TM    CACFLAG1,CANONUM         LINE NUMBERED?\n         BO    UT$RDNN                  BIF NONUM DATA SET\n         SR    R15,R15                  CLEAR FOR IC\n         IC    R15,CALENGTH             NUM SEQ LENGTH\n         SR    R0,R15                   REAL DATA LENGTH\n         CLI   CALINE,1                 SEQ NUM AT COL 1 (ORIG 1)\n         BNE   *+6                      BIF SEQ NUM AT END OF REC\n         AR    R1,R15                   SKIP SEQ NUMBER AT BEGINING\nUT$RDNN  AL    R1,XT#XOFF               WINDOW OVER\n         S     R0,XT#XOFF               LENGTH PAST EDGE OF WINDOW\n         BP    *+6                      BR IF SOME IN WINDOW\n         SR    R0,R0                    NO DATA HERE\n         SR    R15,R15                  SET CC TO I/O RESULT\n         BR    R14                      AND RETURN\nUT$RDMV  MVC   1(0,R1),0(R1)            * EXECUTED *\n         SPACE 1\n*  R15 - FIRST KEY TO DISPLAY (TOP OF SCREEN)\nSETSCRN  OI    XT#SET,LN#FCHG          FORCE SCREEN REFRESH\n         LA    R3,XT#LINS              POINT TO FIRST LINE CTL\n         USING LN#LINE,R3\n         L     R4,XT#SCRL              NUMBER OF LINES\n         ST    R15,NEWKEY              SET KEY FOR EDIO\n         EDIO  RC,MF=B                 TRY READ CURRENT FIRST\nSCR$LP   TM    LN#FLAG,LN#FDAT         DATA LINE?\n         BZ    SCR$NXT                 SKIP IF NOT DATA LINE\n         OI    LN#FLAG,LN#FVAL         ASSUME EXISTS\nSCR$TRY2 EDIO  ,NEWKEY,BUF1            READ RECORD IF EXISTS\n         BZ    SCR$VAL                 BR IF EXISTS\n         CLI   IOLIST,0                WAS THAT READ CURENT?\n         BNE   SCR$NRC                 BIF NOT READ CURRENT\n         EDIO  RN,MF=B                 TRY READ NEXT THEN\n         B     SCR$TRY2                AND GO TRY IT\nSCR$NRC  NI    LN#FLAG,255-LN#FVAL     SET NON-EXISTANT\nSCR$VAL  L     R15,BUF1                GET REAL RECORD KEY\n         ST    R15,NEWKEY              SET FOR NEXT READ\n         ST    R15,LN#PARM             SET FOR OUTPUT RTN\n         EDIO  RN,MF=B                 SET TO READ NEXT\nSCR$NXT  LA    R3,LN#LINEL(,R3)        TO NEXT LINE\n         BCT   R4,SCR$LP               INIT ALL DATA LINES\n         BR    R10                     AND RETURN\n         DROP  R3                      (LN#LINE)\n         SPACE 1\n*  'UT$IO' AND 'UT$IO2' ARE CALLED BY THE EDIO MACRO\n*    (UT$IO2 USED WHEN OPERAND 2 NOT SUPPLIED)\nUT$IO    ST    R1,IOLIST+4             SET PARM 1 VALUE\nUT$IO2   ST    R14,TEMPDW+4            SAVE RETURN ADDR\n         MVC   IOLIST+1(3),CAPTCDCB+1  SET UTILITY DCB ADDR\n         LA    R1,IOLIST               @ PARM LIST FOR I/O RTN\n         LR    R0,COMMREG              COMM ADDR\n         L     R15,CAPTUT              @ UTILITY I/O ROUTINE\n         BALR  R14,R15                 GO TO THE I/O\n         CH    R15,=H'8'               REAL I/O ERROR?\n         BE    IOERROR                 BIF I/O ERROR\n         LTR   R15,R15                 SET CC\n         L     R14,TEMPDW+4            RESTORE RETURN ADDR\n         BR    R14                     AND RETURN\n         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND -- SCAN SUBROUTINES'\n***********************************************************************\n*                                                                     *\n*  ALL RETURN TO R14; SCANC AND SCANN SET CONDITION CODE;             *\n*  REGISTERS USED (MODIFIED): R0, R1, R2, R14, R15                    *\n*  HIGH  |  POSITIVE - OPERAND FOUND                                  *\n*  EQUAL |  ZERO     - OPERAND OMMITTED                               *\n*  LOW   |  MINUS    - INVALID OPERAND (FOR TYPE)                     *\n*                                                                     *\n*                                                                     *\n*   SCAN   - INIT SCAN BXH REGS, ON ENTRY R1 = ADDR, R2 = LEN         *\n*   SCANC  - PLACES CHAR STR < 8 LONG IN TEMPDW AND TR TO UC          *\n*   SCANN  - RETURNS NUMERIC VALUE IN R15                             *\n*                                                                     *\n* NOTE: SCAN/C ARE CALLED BEFORE XT#WORK EXISTS.                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         DROP  R12                      (XT#WORK)\nSCAN     LA    R0,1                     BXH ICR\n         XR    R2,R1                    SWAP R2 AND R1\n         XR    R1,R2                    TO GET ADDR TO\n         XR    R2,R1                    R2; LEN TO R1\n         AR    R1,R2                    GET BXH LIMIT + 1\n         BCTR  R1,0                     GET BXH LIMIT\n         STM   R0,R2,SV#SCAN            SAVE SCAN PTRS\n         BR    R14                      AND RETURN\n         SPACE 1\nSCANC    BAL   R15,SCANX                SKIP LEADING DELIM\n         MVI   TEMPDW,C' '              INIT TO BLANKS\n         MVC   TEMPDW+1(7),TEMPDW\n         LR    R15,R2                   SAVE START ADDR\n         BCTR  R2,0                     INIT FOR BXH\nSCANC$L  BXH   R2,R0,SCANC$C            TO NEXT CHAR\n         CLI   0(R2),C' '               DELIM? (BLANK)\n         BE    SCANC$C                  BR IF DELIM\n         CLI   0(R2),C'Z'               OR TOO HIGH?\n         BNH   SCANC$L                  CONTINUE IF OK\nSCANC$C  SR    R2,R15                   GET STRING LENGTH\n         BZ    SCAN$RZ                  RETURN OMMITED IF NULL\n         CH    R2,=H'8'                 STR TOO LONG?\n         BH    SCAN$RM                  RETURN BAD IF TOO LONG\n         BCTR  R2,0                     GET EX LEN\n         EX    R2,SCANC$MV              MVC TEMPDW(0),0(R15)\n         LA    R2,1(R2,R15)             NEW SCAN PTR\n         L     R15,=A(UC#TAB)           @ OF TR TABLE\n         TR    TEMPDW(8),0(R15)         TO UPPER CASE\n         B     SCAN$RP                  AND EXIT, ALL OK\nSCANC$MV MVC   TEMPDW(0),0(R15)         * EXECUTED *\n         SPACE 1\nSCANN    BAL   R15,SCANX                GO SKIP LEADING DELIM\n         SR    R15,R15                  INIT NUMBER TO ZERO\n         ST    R14,TEMPDW               SAVE RETURN ADDR\n         SR    R14,R14                  CLEAR FOR IC\n         BCTR  R2,0                     INIT FOR BXH\nSCANN$L  BXH   R2,R0,SCANN$E            TO NEXT CHAR\n         CLI   0(R2),C'0'               VALID DIGIT\n         BL    SCANN$EC                 BIF NOT DIGIT - GO CHECK DELIM\n         IC    R14,0(,R2)               GET DIGIT\n         N     R14,=X'0000000F'         GET JUST NUMBER\n         MH    R15,=H'10'               SCALE PREV SUM\n         AR    R15,R14                  NEW NUMBER SO FAR\n         B     SCANN$L                  AND CONTINUE\nSCANN$EC L     R14,TEMPDW               RESTORE RETURN ADDR\n         CLI   0(R2),C' '               VALID DELIM? (BLANK)\n         BNE   SCAN$RM                  ERROR IF NOT VALID DELIM\nSCANN$E  L     R14,TEMPDW               RESTORE RETURN ADDR\n         SPACE 1\nSCAN$RP  STM   R0,R2,SV#SCAN            SAVE NEW SCAN PTRS\n         LTR   R0,R0                    SET CC POS (CON 1)\n         BR    R14                      AND RETURN\n         SPACE 1\nSCAN$RZ  CR    R15,R15                  SET CC EQ = ZERO\n         BR    R14                      AND RETURN\n         SPACE 1\nSCAN$RM  CLI   *,X'FF'                  SET CC LOW = MINUS\n         BR    R14                      AND RETURN\n         SPACE 1\nSCANX    LM    R0,R2,SV#SCAN            GET SCAN VALUES\n         BCTR  R2,0                     INIT FOR BXH\nSCANX$L  BXH   R2,R0,SCAN$RZ            TO NXT CHAR / RET IF NONE\n         CLI   0(R2),C' '               SKIP OVER DELIM\n         BE    SCANX$L                  CONTINUE SKIPPING\n         STM   R0,R2,SV#SCAN            UPDATE SCAN PTRS\n         ST    R2,SV#SCANP              SAVE INCASE OF ERROR\n         BR    R15                      LOCAL RETURN WHEN DONE\n         SPACE 1\n* R5,R7 - @, LEN END, @ LAST ENT\nFIND     SR    R15,R15                  CLEAR FOR IC\nFIND$L   IC    R15,0(,R5)               GET CMD EX LEN\n         EX    R15,FIND$CLC             CLC TEMPDW(0),1(R5)\n         BER   R14                      RETURN IF FOUND\n         BXLE  R5,R6,FIND$L             CONTINUE SEARCH\n         BR    R14                      RETURN NOT FOUND\nFIND$CLC CLC   TEMPDW(0),1(R5)          * EXECUTED *\n         USING XT#WORK,R12\n         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND -- EXIT CODE'\n***********************************************************************\n*                                                                     *\n*                         CLEAN UP AND EXIT                           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nEXIT     L     R1,CCNWORD               ADDR TO BE FREED\n         LTR   R1,R1                    DOES XT#WORK EXIST?\n         B     SKIPFRE1  *TEMP* (NEVER FREE XT#WORK)\n         BZ    SKIPFRE1                 NO, SO SKIP FREEMAIN\n         L     R0,XT@END-XT#WORK(,R1)   GET ADDR PAST END OF XT#WORK\n         SR    R0,R1                    GET LENGTH OF XT#WORK\n         O     R0,SPONE                 INDICATE SP=1\n         XC    CCNWORD(4),CCNWORD       NO MORE XT#WORK\n         FREEMAIN  R,LV=(0),A=(1)       FREE GOTTEN CORE\n         SPACE 1\nSKIPFRE1 STAX  ,                        REMOVE MY ATTENTION EXIT\n         NI    CAATTN,255-CAATTNIS      OFF ATTEN FLAG\n         L     R15,RETCODE              LOAD RETURN CODE\n         IKJEBERT  (14,12),T,RC=(15)    STD TSO RETURN MACRO\n         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - MISC EXIT ROUTINES'\n***********************************************************************\n*                                                                     *\n*                         MISC EXIT ROUTINES                          *\n*                                                                     *\n*  NOTE: RETCDE IS ZEROED AT ENTRY TO CCNEDFSE                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nLVFULL   TM    XT#FLAG,XT#FSCR          IN FULLSCR MODE?\n         BZR   R10                      IF NOT, DO NOTHING\n         NI    XT#FLAG,255-XT#FSCR      RESET FULLSCR FLAG\n         OI    CACFLAG2,CAMODMSG        PROMPT 'EDIT' AFTER RETURN\n         TM    XT#FLAG,XT#FVTAM         VTAM FULLSCR MODE?\n         BZ    LVFULLT                  BIF NOT VTAM (TCAM)\n         STFSMODE OFF                   OFF VTAM FULLSCR MODE\n         BR    R10                      AND RETURN\nLVFULLT  LM    R0,R1,=A(LVF#CONL,LVF#CON)  ADR, LEN FOR TPUT\n         BAL   R14,SP$TPUT              TPUT TO LEAVE FULLSCR\n         BR    R10                      RETURN TO CALLER\n         SPACE 3\nIOERROR  LA    R15,12                   INDICATE 'DISASTER'\n         ST    R15,RETCODE\n         B     EXIT$ERR\n         SPACE 3\nNOCORE   BAL   R10,LVFULL               LEAVE FULLSCREEN MODE\n         IKJEBEML  MF=(E,M312LIST)      ISSUE MESSAGE\n*+++++   B     FLUSH\n         SPACE 1\nFLUSH    LA    R15,8                    INDICATE 'FLUSH STACK'\n         ST    R15,RETCODE\n         OC    CACFLAG1(1),XT#SAVF      RESTORE VERIFY FLAG\nEXIT$ERR BAL   R10,LVFULL               LEAVE FULLSCR MODE\n         B     EXIT                     AND EXIT\n         SPACE 3\nGTSZERR  LA    R14,GTSZINS              POINT TO NAME INSERT\n         B     SYSERROR                 GO BUILD MESSAGE\n         SPACE 3\nPUTLERR  LA    R14,PUTLINS              POINT TO NAME INSERT\n         B     SYSERROR                 GO BUILD MESSAGE\n         SPACE 3\nSTCKERR  LA    R14,STCKINS              POINT TO NAME INSERT\n         B     SYSERROR                 GO BUILD MESSAGE\n         SPACE 3\nPERROR   LA    R14,PARSINS              POINT TO NAME INSERT\nSYSERROR MVC   MSGWORK1(12),M313LIST    INITIALIZE MESSAGE\n         MVC   MSGWORK2(16),INS3131     INITIALIZE 1ST INSERT\n         MVC   MSGWORK3(10),INS3132     INITIALIZE 2ND INSTERT\n         MVC   MSGWORK2+5(1),0(R14)     MOVE LENGTH OF NAME INSERT\n         MVC   MSGWORK2+8(8),1(R14)     MOVE NAME TO MESSAGE SEG\n         LA    R1,MSGWORK2              ADDR OF 1ND INSERT  (M3131)\n         ST    R1,MSGWORK1+8            CHAIN MSG TO 1ST\n         LA    R1,MSGWORK3              ADDR OF 2ND INSERT  (M3132)\n         ST    R1,MSGWORK2              CHAIN 1ST TO 2ND\n         CVD   R15,TEMPDW               CONVERT RC TO DECIMAL\n         UNPK  MSGWORK3+8(2),TEMPDW(8)  PUT RC INTO INSERT (M3132)\n         OI    MSGWORK3+9,X'F0'         FIX UP ZONE BITS\n         BAL   R10,LVFULL               LEAVE FULL SCREEN MODE\n         IKJEBEML  M313,MF=(E,MSGWORK1) ISSUE MESSAGE\n         B     FLUSH\n         SPACE 3\nBADTERM  PUTLINE  PARM=PTPB,OUTPUT=MSG#1,MF=(E,CATMPLST)\n* CHECK ERRORS\n         B     FLUSH                    QUIT\n         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - CONSTANTS'\n***********************************************************************\n*                                                                     *\n*                          PROGRAM CONSTANTS                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nTRUEBASE DC    A(CCNEDFSE)              BASEADDR WITH ZERO OFFSET\nSPONE    DC    0F'0',X'01000000'        MASK TO INDICATE SUBPOOL ONE\nPARSINS  DC    AL1(9),CL8'PARSE'        RTN NAME FOR MSG INSERT\nPUTLINS  DC    AL1(11),CL8'PUTLINE'     RTN NAME FOR MSG INSERT\nSTCKINS  DC    AL1(9),CL8'STACK'        RTN NAME FOR MSG INSERT\nGTSZINS  DC    AL1(10),CL8'GTSIZE'      RTN NAME FOR MSG INSERT\nMSG#1    DC    F'1',A(*+4),AL2(L'MSG#1T+4,0)\nMSG#1T   DC    C'FSE001 TERMINAL TYPE NOT SUPPORTED'\n         SPACE 3\n         LTORG\n         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - MESSAGE MACROS'\n         SPACE 1\n         PRINT GEN\n         IKJEBEMI (312,313)\n         SPACE 4\nM312LIST IKJEBEML M312,,INS312,,MF=L\n         SPACE 1\nINS312   IKJEBEMG 0,M312IN1,'FULLSCR'\n         SPACE 3\nM313LIST IKJEBEML M313,M3131,,INS3131,MF=L\n         SPACE 1\nINS3131  IKJEBEMG INS3132,M3131IN1,'IKJ12345'\n         SPACE 1\nINS3132  IKJEBEMG 0,M3131IN2,'99'\n         PRINT GEN\n         EJECT\n         DC    0D'0'\n*  6 BIT CODE TO EBCDIC (3270 VALID CODES)\nTAB3270  DC    X'40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'  (00,40,80,C0)\n         DC    X'50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F'  (10,50,90,D0)\n         DC    X'6061E2E3E4E5E6E7E8E96A6B6C6D6E6F'  (20,60,A0,E0)\n         DC    X'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F'  (30,70,B0,F0)\n         SPACE 1\n*---   TRT TABLE FOR INVALID CHARACTERS (UC/LC)                    ---*\n*                   0 1 2 3 4 5 6 7 8 9 A B C D E F\nVAL#LC   DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       0\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       1\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       2\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       3\n         DC    XL16'00FFFFFFFFFFFFFFFFFF000000000000'       4\n         DC    XL16'00FFFFFFFFFFFFFFFFFF000000000000'       5\n         DC    XL16'0000FFFFFFFFFFFFFFFF000000000000'       6\n         DC    XL16'FFFFFFFFFFFFFFFFFF00000000000000'       7\n         DC    XL16'FF000000000000000000FFFFFFFFFFFF'       8\n         DC    XL16'FF000000000000000000FFFFFFFFFFFF'       9\n         DC    XL16'FFFF0000000000000000FFFFFFFFFFFF'       A\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       B\n         DC    XL16'00000000000000000000FFFFFFFFFFFF'       C\n         DC    XL16'00000000000000000000FFFFFFFFFFFF'       D\n         DC    XL16'FFFF0000000000000000FFFFFFFFFFFF'       E\n         DC    XL16'00000000000000000000FFFFFFFFFFFF'       F\n         SPACE 1\n*---   TRT TABLE FOR INVALID CHARACTERS (UC ONLY)                  ---*\n*                   0 1 2 3 4 5 6 7 8 9 A B C D E F\nVAL#UC   DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       0\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       1\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       2\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       3\n         DC    XL16'00FFFFFFFFFFFFFFFFFF000000000000'       4\n         DC    XL16'00FFFFFFFFFFFFFFFFFF000000000000'       5\n         DC    XL16'0000FFFFFFFFFFFFFFFF000000000000'       6\n         DC    XL16'FFFFFFFFFFFFFFFFFF00000000000000'       7\n         DC    XL16'FF010101010101010101FFFFFFFFFFFF'       8\n         DC    XL16'FF010101010101010101FFFFFFFFFFFF'       9\n         DC    XL16'FFFF0101010101010101FFFFFFFFFFFF'       A\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       B\n         DC    XL16'00000000000000000000FFFFFFFFFFFF'       C\n         DC    XL16'00000000000000000000FFFFFFFFFFFF'       D\n         DC    XL16'FFFF0000000000000000FFFFFFFFFFFF'       E\n         DC    XL16'00000000000000000000FFFFFFFFFFFF'       F\n         SPACE 1\n*---                TRANSLATE LOWER CASE TO UPPER CASE             ---*\n*                   0 1 2 3 4 5 6 7 8 9 A B C D E F\nUC#TAB   DC    XL16'6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F'       0\n         DC    XL16'6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F'       1\n         DC    XL16'6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F'       2\n         DC    XL16'6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F'       3\n         DC    XL16'406F6F6F6F6F6F6F6F6F4A4B4C4D4E4F'       4\n         DC    XL16'506F6F6F6F6F6F6F6F6F5A5B5C5D5E5F'       5\n         DC    XL16'60616F6F6F6F6F6F6F6F6A6B6C6D6E6F'       6\n         DC    XL16'6F6F6F6F6F6F6F6F6F797A7B7C7D7E7F'       7\n         DC    XL16'6FC1C2C3C4C5C6C7C8C96F6F6F6F6F6F'       8\n         DC    XL16'6FD1D2D3D4D5D6D7D8D96F6F6F6F6F6F'       9\n         DC    XL16'6F6FE2E3E4E5E6E7E8E96F6F6F6F6F6F'       A\n         DC    XL16'6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F'       B\n         DC    XL16'C0C1C2C3C4C5C6C7C8C96F6F6F6F6F6F'       C\n         DC    XL16'D0D1D2D3D4D5D6D7D8D96F6F6F6F6F6F'       D\n         DC    XL16'6F6FE2E3E4E5E6E7E8E96F6F6F6F6F6F'       E\n         DC    XL16'F0F1F2F3F4F5F6F7F8F96F6F6F6F6F6F'       F\n         SPACE 1\nST#LIN   DC    C'----+----1----+----2----+----3----+----4'\n         DC    C'----+----5----+----6----+----7----+----8'\n         DC    C'----+----9----+---10----+---11----+---12'\n         DC    C'----+---13----+---14----+---15----+---16'\n         DC    C'----+---17----+---18----+---19----+---20'\n         DC    C'----+---21----+---22----+---23----+---24'\n         DC    C'----+---25----+'\n         SPACE 1\n* AL1(EX COMPARE LENGTH),CL8'CMD',X'FLAGS',Y(RTN OFFSET)\n* FLAGS - OFFSET IN XT# OF VALUE IF ANY\nCMD#T    DC    0H'0'                   ALIGN CMD TABLE\nCMD#PF03 DC    AL1(07),CL8'END     ',X'00',Y(FLUSH-$)\nCMD#TL   EQU   *-CMD#T                  ENTRY LENGTH\nCMD#PF07 DC    AL1(07),CL8'UP      ',X'01',Y(C$U-$)\n         DC    AL1(07),CL8'U       ',X'01',Y(C$U-$)\nCMD#PF08 DC    AL1(07),CL8'DOWN    ',X'02',Y(C$D-$)\n         DC    AL1(07),CL8'D       ',X'02',Y(C$D-$)\nCMD#PF10 DC    AL1(07),CL8'LEFT    ',X'03',Y(C$L-$)\n         DC    AL1(07),CL8'L       ',X'03',Y(C$L-$)\nCMD#PF11 DC    AL1(07),CL8'RIGHT   ',X'04',Y(C$R-$)\n         DC    AL1(07),CL8'R       ',X'04',Y(C$R-$)\n         DC    AL1(07),CL8'POSITION',X'80',Y(C$P-$)\n         DC    AL1(07),CL8'P       ',X'80',Y(C$P-$)\n         DC    AL1(07),CL8'COL     ',X'80',Y(C$COL-$)\n         DC    AL1(07),CL8'SEQ     ',X'80',Y(C$SEQ-$)\n         DC    AL1(07),CL8'TOP     ',X'00',Y(C$T-$)\n         DC    AL1(07),CL8'T       ',X'00',Y(C$T-$)\n         DC    AL1(07),CL8'BOTTOM  ',X'00',Y(C$B-$)\n         DC    AL1(07),CL8'B       ',X'00',Y(C$B-$)\nCMD#PF01 DC    AL1(07),CL8'HELP    ',X'00',Y(C$HELP-$)\nCMD#PF12 DC    AL1(07),CL8'HOME    ',X'00',Y(C$HOME-$)\n         DC    AL1(07),CL8'TABC    ',X'00',Y(C$TABC-$)\n         DC    AL1(07),CL8'TABS    ',X'00',Y(C$TABS-$)\n         DC    AL1(07),CL8'TABH    ',X'00',Y(C$TABH-$)\n         DC    AL1(07),CL8'NULLS   ',X'00',Y(C$NULLS-$)\n         DC    AL1(07),CL8'FCOPY   ',X'00',Y(C$FCO-$)\n         DC    AL1(07),CL8'FCO     ',X'00',Y(C$FCO-$)\n         DC    AL1(07),CL8'FMOVE   ',X'00',Y(C$FMO-$)\n         DC    AL1(07),CL8'FMO     ',X'00',Y(C$FMO-$)\n         DC    AL1(07),CL8'FDELETE ',X'00',Y(C$FDEL-$)\n         DC    AL1(07),CL8'FDEL    ',X'00',Y(C$FDEL-$)\nCMD#TE   EQU   *-CMD#TL                 @ LAST TABLE ENTRY\n         SPACE 1\nPFK#T    DC    0H'0'\n         DC    AL1(00),X'F1',Y(CMD#PF01-$)\nPFK#TL   EQU   *-PFK#T\n         DC    AL1(00),X'F3',Y(CMD#PF03-$)\n         DC    AL1(00),X'F7',Y(CMD#PF07-$)\n         DC    AL1(00),X'F8',Y(CMD#PF08-$)\n         DC    AL1(00),X'7A',Y(CMD#PF10-$)\n         DC    AL1(00),X'7B',Y(CMD#PF11-$)\n         DC    AL1(00),X'7C',Y(CMD#PF12-$)\nPFK#TE   EQU   *-PFK#TL\n         SPACE 1\nSEQ#T    DC    AL1(00),CL3'I  ',Y(SEQ$I-$)   @ FIRST TABLE ENTRY\nSEQ#TL   EQU   *-SEQ#T                  LENGTH OF ONE ENTRY\n         DC    AL1(00),CL3'D  ',Y(SEQ$D-$) DELETE\n         DC    AL1(00),CL3'R  ',Y(SEQ$R-$) REPLICATE\nSEQ#TE   EQU   *-SEQ#TL                 @ LAST TABLE ENTRY\n         SPACE 1\nLVF#CON  DC    X'C3115D7E114040'        LEAVE FULLSCR MODE\n         DC    X'3C404000'                  ERASE SCREEN\n         DC    X'1D40'                      SF,ATTR\n         DC    X'1140C113'                  CURSOR TO FIRST FIELD DATA\nLVF#CONL EQU   *-LVF#CON                    LENGTH OF STRING\n         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND -- LINE ROUTINES'\n         USING LN#LINE,R3\n         USING R$ODAT1,R8               (LOCAL BASE)\n*  R4 = XT#SCRL - LINE NUMBER\nR$ODAT1  TM    LN#FLAG,LN#FVAL          VALID RECORD?\n         BZ    ROD1$NV                  BIF NOT VALID RECORD\n         CLC   LN#PARM,XT#CURSQ         CURSOR POSITION TO MY LINE?\n         BNE   ROD1$NC                  BIF NO CURSOR POS HERE\n         L     R1,XT#SCRL               GET LINES / SCREEN\n         SR    R1,R4                    GET MY LINE NUMBER\n         MH    R1,XT#SCRC+2             GET POS TO BEGINING OF LINE\n         A     R1,XT#SEQL               + SEQ FIELD LENGTH\n         LA    R1,1(,R1)                SKIP OVER DATA ATTR\n         STH   R1,XT#CUR                POSITION CURSOR THERE.....\n         SPACE 1\nROD1$NC  LA    R2,3(,R2)                SKIP SBA,ADR1,ADR2\n         L     R7,XT#SCRC               COLUMNS / LINE\n         L     R5,XT#SEQL               SEQUENCE FIELD LENGTH\n         LTR   R6,R5                    COPY AND TEST\n         BNP   ROD1$NS                  BR IF NO SEQ FIELD\n         BCTR  R5,0                     SEQ NUMBER LENGTH (NO ATTR)\n         BCTR  R5,0                     SEQ EX LEN\n         L     R15,LN#PARM              GET RECORD NUMBER\n         CVD   R15,TEMPDW               TO DEC\n         SLL   R5,4                     TO POSITION FOR EX\n         EX    R5,ROD1$UP               UNPK 2(0,R2),TEMPDW(8)\n         SR    R7,R6                    - LEN OF SEQ FIELD\n         AR    R2,R6                    + LEN OF SEQ FIELD\n         OI    0(R2),C'0'               FIX ZONE IN LAST DIGIT\n         LA    R2,1(,R2)                ACCOUNT FOR SF\n         SPACE 1\nROD1$NS  BAL   R14,UT$RD                READ RECORD\n         LA    R6,2                     TABS ORIG 1,ATTR BEFORE TAB POS\n         A     R6,XT#XOFF               GET MY POSITION ON LINE\n         LA    R5,=X'00'                ASSUME NO HARDWARE TABS\n         TM    XT#OPT,XT#FTABH+XT#FTAB  HARDWARE TABS ON?\n         BNO   ROD1$NT                  BIF TABS NOT ON\n         TM    LN#FLAG,LN#FNTAB         NO TABS THIS LINE?\n         BO    ROD1$NT                  BIF NO TABS THIS LINE\n         LA    R5,CATABS+1              INIT TAB PTR\nROD1$NT  XC    LN#HTABM,LN#HTABM        NO TABS ON SCREEN YET\n         NI    LN#FLAG,255-LN#FNTAB     CAN HAVE TABS NEXT TIME\n         SPACE 1\nROD1$LP  LTR   R7,R7                    ROOM FOR NEW FIELD?\n         BNPR  R10                      BR IF LINE ALREADY FULL\n         MVC   0(2,R2),=X'1D40'         SET SF,ATTR\n         BCTR  R7,0                     SPACE LEFT AFTER ATTR\n         LTR   R15,R0                   COPY/TEST DATA LENGTH LEFT\n         BNP   ROD1$ND                  BIF NO DATA LEFT\n*  FIND NEXT HARDWARE TAB POSITION\nROD1$TLP SR    R14,R14                  CLEAR FOR IC\n         IC    R14,0(,R5)               GET TAB POS ORIG 1\n         LTR   R14,R14                  ANY TAB POSITION?\n         BZ    ROD1$TNO                 BIF NO TAB POSITION\n         SR    R14,R6                   DATA LEN TO TAB POS (ATTR)\n         BNM   ROD1$THV                 BIF HAVE TAB POSITION\nROD1$TNX LA    R5,1(,R5)                TO NEXT TAB IN CATABS\n         B     ROD1$TLP                 CONTINUE TAB SEARCH\nROD1$THV CR    R14,R15                  TAB POS :: DATA LEN LEFT\n         BNL   ROD1$TNO                 BIF TAB PAST END OF RECORD\n         ST    R1,TEMPDW                SAVE R1 FOR TEST\n         AR    R1,R14                   POINT TO TAB POS IN DATA\n         CLI   0(R1),C' '               BLANK AT TAB POSITION?\n         L     R1,TEMPDW                RESTORE R1\n         BNE   ROD1$TNX                 BIF NOT BLANK TO TRY NEXT TAB\n         LR    R15,R14                  USE LENGTH TO TAB\n         LA    R14,CATABS+1             GET TAB NUMBER ORIG\n         SR    R14,R5                   GET - TAB NUMBER\n         LCR   R14,R14                  GET BIT NUMBER\n         ST    R5,TEMPDW                TEMP SAVE R5\n         L     R5,=X'00008000'          GET A BIT\n         SRL   R5,0(R14)                GENERATE THE BIT TO SET\n         LH    R14,LN#HTABM             GO SET THE\n         OR    R14,R5                   BIT\n         STH   R14,LN#HTABM             OF TABS FORMATED ON SCREEN\n         L     R5,TEMPDW                RESTORE R5\nROD1$TNO CR    R15,R7                   DATA SEG LEN :: LEN ON LINE\n         BL    *+6                      USE LOWEST\n         LR    R15,R7                   LEN LEFT ON LINE IS LOWEST\n         BCTR  R15,0                    GET EX LEN\n         LTR   R15,R15                  CHECK FOR ZERO LENGTH MOVE\n         BM    ROD1$NDT                 BIF NO DATA TO MOVE\n         EX    R15,ROD1$MV              MVC 2(0,R2),0(R1)\n*---    TRT FOR INVALID CHARACTERS (OR LC)                         ---*\n         STM   R1,R2,TEMPDW             SAVE REGS CLOBBERED BY TRT\nROD1$CCK L     R14,=A(VAL#UC)           ASSUME NOT ASIS MODE\n         TM    CACFLAG1,CACAPS          UPPER CASE ONLY?\n         BO    *+8                      BIF UPPER CASE ONLY\n         L     R14,=A(VAL#LC)           USE LOWER CASE TABLE\n         EX    R15,ROD1$TRT             TRT 2(0,R2),0(R14)\n* R1,R2 ONLY CLOBBERED IF CC NOT ZERO\n         BZ    ROD1$CKN                 BIF ALL VALID CHARS (NOW)\n         MVI   0(R1),C'?'               FIX INVALID CHAR\n         L     R1,=A(MSG#BADC)          ASSUME WAS BAD CHAR\n         N     R2,=X'000000FE'          ZERO IF WAS LC\n         BNZ   *+8                      BIF WAS BAD CHAR\n         L     R1,=A(MSG#LOWC)          WAS LOWER CASE CHAR\n         BAL   R14,MSG                  GO SET MSG\n         LM    R1,R2,TEMPDW             RESTORE TRT CLOBBERED REGS\n         MVI   1(R2),X'C8'              CHANGE TO HIGH INTENSITY\n         B     ROD1$CCK                 AND GO CHECK AGAIN\nROD1$CKN TM    XT#OPT,XT#FNULS          NULLS ON?\n         BZ    ROD1$NDT                 BIF NULLS OPTION OFF\n         STM   R15,R3,12+4(R13)         SAVE SOME REGS\n         L     R0,=F'-1'                BXH DCR\n         LA    R1,1(,R2)                BXH LIMIT (@ DATA - 1)\n         LA    R3,2(R15,R2)             BXH PTR (LEN-1+ADR-2+2)\n         LR    R14,R3                   SAVE INITIAL PTR VALUE\nROD1$NU1 CLI   0(R3),C' '               SCAN TRAILING BLANKS\n         BNE   *+8                      BIF NON BLANK FOUND\n         BXH   R3,R0,ROD1$NU1           BIF MORE TO SCAN\n         SR    R14,R3                   GET LENGTH OF TRAILING BLANKS\n         BZ    ROD1$NU2                 BIF NO TRAILING BLANKS\n         CH    R14,=H'5'                MANY TRAILING BLANKS?\n         BH    ROD1$NU3                 BIF MANY (USE RA)\n         BCTR  R14,0                    GET LENGTH - 1\n         EX    R14,ROD1$NUX             XC 1(0,R3),1(R3)\nROD1$NU2 LM    R15,R3,12+4(R13)         RESTORE REGS\nROD1$NDT LA    R2,2+1(R2,R15)           SKIP SF,ATTR,DATA (LEN -1)\nROD1$NUD LA    R15,1+1(,R15)            +1 EX LEN, +1 FOR ATTR TAB\n         SR    R0,R15                   GET NEW DATA LEN LEFT\n         AR    R1,R15                   NEW POSITION IN RECORD\n         LA    R7,1(,R7)                ALREADY COUNTED ATTR BYTE\n         SR    R7,R15                   NEW LEN LEFT ON LINE\n         AR    R6,R15                   NEW POSITION ON SCREEN\n         B     ROD1$LP                  AND RETURN\n         SPACE 1\nROD1$NU3 L     R0,XT#SCRL               LINES / SCREEN\n         SR    R0,R4                    GET MY LINE NUMBER\n         MH    R0,XT#SCRC+2             GET MY LINE POSITION\n         A     R0,XT#SCRC               POSITION PAST MY LINE\n         SR    R0,R7                    - SPACE LEFT ON LINE\n         AH    R15,=H'1'                SPACE ON LINE FOR DATA + NULLS\n         AR    R0,R15                   END POSITION FOR RA\n         SR    R15,R14                  LEN -1 OF DATA WITHOUT NULLS\n         LA    R2,2(R15,R2)             SKIP OVER DATA + ATTR BYTE\n         BAL   R14,CV$POS               SET ADR1,ADR2 FOR RA\n         MVI   0(R2),X'3C'              SET RA OPERATION\n         MVI   3(R2),0                  REPEAT NULLS\n         LA    R2,4(,R2)                SKIP OVER RA\n         LM    R15,R1,12+4(R13)         RESTORE R15 - R1\n         L     R3,12+8+4*R3(,R13)       AND R3\n         B     ROD1$NUD                 AND CONTINUE\n         SPACE 1\nROD1$ND  MVI   1(R2),X'E8'              PROT. HIGH INTENS. ATTR\n         BCTR  R7,0                     GET EX LEN\n         LTR   R7,R7                    LINE FULL AFTER ATTR?\n         BM    ROD1$LF                  BIF LINE FULL AFTER ATTR\n         EX    R7,ROD1$XC               XC 2(0,R2),2(R2) MAKE NULLS\n         MVI   2(R2),C'|'               MARK RIGHT MARGIN\nROD1$LF  LA    R2,1+2(R2,R7)            SKIP SF,ATTR,NULLS\n         BR    R10                      AND RETURN\nROD1$NV  TM    XT#FLAG,XT#FEOF          DISPLAYED EOF YET?\n         BOR   R10                      JUST RETURN IF HAVE\n         MVC   4(ROD1#EFL,R2),ROD1#EF   SET EOF MSG AFTER SBA,AD1,AD2\n         LA    R2,ROD1#EFL+4(,R2)       PAST SBA,AD1,AD2 AND MSG\n         MVI   0(R2),X'3C'              SET RA ORDER\n         L     R0,XT#SCRL               LINES / SCREEN\n         BCTR  R0,0                     LAST LINE\n         MH    R0,XT#SCRC+2             POSITION OF LAST LINE\n         BCTR  R0,0                     LAST CHAR BEFORE LAST LINE\n         BAL   R14,CV$POS               SET RA ADDR1,ADDR2\n         MVI   3(R2),0                  REPEAT NULLS\n         LA    R2,4(,R2)                SKIP OVER RA\n         OI    XT#FLAG,XT#FEOF          ONLY DO THIS ONCE PER SCREEN\n         BR    R10\nROD1$UP  UNPK  2(0,R2),TEMPDW(8)        * EXECUTED *\nROD1$XC  XC    2(0,R2),2(R2)            * EXECUTED *\nROD1$MV  MVC   2(0,R2),0(R1)            * EXECUTED *\nROD1$TRT TRT   2(0,R2),0(R14)           * EXECUTED *\nROD1$NUX XC    1(0,R3),1(R3)            * EXECUTED *\n         DROP  R3,R8                    (LN#LINE,R$ODAT1)\nROD1#EF  DC    X'E8'                    PROT. HIGH INTENS. ATTR\n         DC    C'  <<END OF FILE>>'     MSG\nROD1#EFL EQU   *-ROD1#EF                LENGTH OF STRING\n         EJECT ,\n*  R1 = ADDR, R2 = LEN, R14 = POSITION ON LINE\n         USING LN#LINE,R3\n         USING R$IDAT1,R8               (LOCAL BASE)\nR$IDAT1  OI    LN#FLAG,LN#FCHG          FORCE REWRITE OF LINE\n         BCTR  R14,0                    TO DATA ORIG 0\n         SL    R14,XT#SEQL              - SPACE USED BY SEQ FIELD\n         BNM   RID1$DAT                 BR IF IN DATA FIELD\n         BAL   R14,SCAN                 SCAN FOR COMMAND\n         BAL   R14,SCANC                GET CMD IF ANY\n         BNP   RID1$SN                  GO CHECK IF NUM\n         LM    R5,R7,=A(SEQ#T,SEQ#TL,SEQ#TE) FIND PARMS\n         BAL   R14,FIND                 FIND COMMAND\n         BNER  R10                      RETURN IF INVALID\n         LH    R5,4(,R5)                GET CMD OFFSET\n         B     $(R5)                    GO TO CMD RTN\nRID1$SN  BAL   R14,SCANN                GET NEW SEQ NUM\n         BNPR  R10                      RETURN IF NO NUM\n         L     R1,XT#SEQL               GET SEQ FIELD LENGTH\n         SLL   R1,2                     * 4 FOR INDEX\n         L     R1,RID1#SQ(R1)           GET 10**(SEQFL-1)\n         SR    R4,R4                    CLEAR FOR DIVIDE\n         L     R5,LN#PARM               GET CURRENT SEQ NUM\n         DR    R4,R1                    GET NUM/(10**(SEQFL-1))\n         MR    R4,R1                    GET INVISIBLE DIGITS ONLY\n         AR    R15,R5                   ADD IN INVISIBLE DIGITS\n         CL    R15,LN#PARM              JUST SAME SEQ NUM?\n         BER   R10                      RETURN IF SAME\n         ST    R15,NEWKEY               SAVE NEW KEY\n         EDIO  RC,NEWKEY,BUF1           DOES NEW EXIST?\n         BZR   R10                      RETURN IF EXISTS\n         EDIO  RC,(R3),BUF1             READ CURRENT REC\n         MVC   BUF1(4),NEWKEY           SET NEW KEY\n         EDIO  W,BUF1                   ADD NEW RECORD\n         EDIO  DLT,(R3)                 DELETE CUR RECORD\n         MVC   LN#PARM(4),NEWKEY        SET KEY FOR DATA INPUT\n         OI    XT#FLAG,XT#FSS           SET CALL SETSCRN FLAG\n         BR    R10                      AND RETURN\nSEQ$D    TM    LN#FLAG,LN#FVAL          VALID?\n         BZR   R10                      RETURN IF NOT VALID\n         EDIO  DLT,(R3)                 DELETE RECORD\n         OI    XT#FLAG,XT#FSS           FORCE SETSCRN CALL\n         BR    R10                      AND RETURN\nSEQ$I    SR    R6,R6                    IS INSERT NOT REPLICATE\nSEQ$IR   TM    LN#FLAG,LN#FVAL          VALID?\n         BZR   R10                      RETURN IF NOT VALID\n         BAL   R14,SCANN                GET NUM TO INSERT\n         BNP   SEQ$IR1                  BIF NOT SPECIFIED\n         LTR   R5,R15                   COPY / TEST NUMBER\n         BNP   SEQ$IR1                  BIF NOT POSITIVE NUM\n         C     R5,LN#PARM               INSERT NUM :: SEQ NUMBER\n         BE    SEQ$IR1                  BIF HE FORGOT A BLANK\n         L     R7,XT#SCRL               LINES / SCREEN\n         SH    R7,=H'3'                 MAX INSERT ALLOWED\n         CR    R5,R7                    VALID INSERT NUM?\n         BL    *+8                      BIF VALID\nSEQ$IR1  LA    R5,1                     ELSE INSERT ONLY 1\n         OI    XT#FLAG,XT#FIMC          SET INSERT/MOVE/COPY FLAG\n         STC   R5,LN#INNUM              SAVE NUMBER TO INSERT\n         IC    R0,LN#FLAG               GET FLAG\n         OR    R0,R6                    ADD REPLICATE IF REQUIRED\n         STC   R0,LN#FLAG               SAVE NEW FLAG VALUE\n         BR    R10                      AND RETURN\nSEQ$R    LA    R6,LN#FREP               IS REPLICATE\n         B     SEQ$IR\n         EJECT ,\n*   DATA INPUT ROUTINE:\n*    R1  - INPUT DATA ADDR\n*    R2  - INPUT DATA LENGTH\n*    R3  - LN#LINE BASE\n*    R8  - LOCAL BASE\n*    R10 - RETURN ADDR\n*    R14 - OFFSET ON DATA PART OF LINE\n*  WORK REGS: R0,R1,R2,R4,R5,R6,R7,R14,R15\n*\n*  INPUT LINE LENGTH IS XT#SCRC-XT#SEQL-1\n*\nRID1$DAT LR    R7,R14                   SAVE LINE OFFSET (ORIG 0)\n         OI    LN#FLAG,LN#FCHG          FORCE REWRITE OF LINE\n         LR    R6,R1                    SAVE INPUT ADDR\n         LR    R5,R2                    SAVE INPUT LENGTH\n         BAL   R14,UT$RD                GO READ RECORD\n         BNZR  R10                      IGNORE IF NO RECORD\n*  R1 -  @ RECORD, R0 - DATA LENGTH (WINDOWED XT#XOFF)\n         AR    R1,R7                    PT TO FIELD IN RECORD\n         SR    R0,R7                    LENGTH LEFT IN RECORD\n         BNPR  R10                      RETURN IF NOT IN RECORD\n         L     R4,XT#SCRC               COLS / LINE\n         S     R4,XT#SEQL               - SEQ FIELD LENGHT\n         BCTR  R4,0                     - ATTR BYTE LENGTH\n*  R4 - LENGTH OF INPUT DATA AREA\n* FIND LENGTH OF THIS FIELD ON SCREEN (NEXT HARD TAB POS)\n         ST    R5,TEMPDW                TEMP SAVE R5\n         LH    R15,LN#HTABM             GET TAB EXISTS BIT MASK\n         SLL   R15,16                   TO HIGH ORDER 16 BITS\n         LA    R5,CATABS+1              POINT TO FIRST TAB\nRID1$TLP ALR   R15,R15                  TEST TOP BIT/SHIFT LEFT 1\n         BC    4,RID1$TNX               BIF NO CARRY, NOT ZERO\n         BC    8,RID1$TNO               BIF NO CARRY, ZERO (NO TABS)\n         SR    R14,R14                  CLEAR FOR IC\n         IC    R14,0(,R5)               GET TAB POSITION (ORIG 1)\n         BCTR  R14,0                    GET ORIG 0\n         S     R14,XT#XOFF              WINDOW IT\n         CR    R14,R7                   AFTER INPUT POSITION?\n         BH    RID1$TFD                 BIF AFTER INPUT POSITION\nRID1$TNX LA    R5,1(,R5)                TO NEXT TAB\n         B     RID1$TLP                 CONTINUE TAB SEARCH\nRID1$TFD SR    R14,R7                   GET LENGTH OF INPUT FIELD\n         CR    R4,R14                   IS WINDOW SHORTER?\n         BNH   *+6                      BIF WINDOW SHORTER (OR EQ)\n         LR    R4,R14                   ELSE USE FIELD LENGTH\n*---  PRE-BLANK INPUT FIELD AREA IN RECORD                         ---*\nRID1$TNO MVI   0(R1),C' '               MAKE A BLANK\n         SH    R4,=H'2'                 GET LEN LEFT -1 FOR EX\n         BM    *+8                      BIF WAS ONLY ONE BLANK\n         EX    R4,RID1$MVB              MVC 1(0,R1),0(R1)\n*--- SCAN INPUT FOR SOFT TABS; MOVE DATA TO RECORD                 ---*\n         L     R5,TEMPDW                RESTORE R5\n         BCTR  R5,0                     GET EX LENGTH\n         LR    R15,R1                   COPY RECORD ADDR\nRID1$TSL LTR   R5,R5                    TEST INPUT LENGTH - 1 LEFT\n         BM    RID1$UP                  BIF NO INPUT LEFT\n         SR    R2,R2                    INIT FOR TRT\n         LA    R1,1(R5,R6)              PAST LAST BYTE OF INPUT\n*--- TRT MODIFIES R1 AND R2                                        ---*\n         TM    XT#OPT,XT#FTABS+XT#FTAB  SOFT TABS ON?\n         BNO   *+8                      DON'T TRT IF TABS NOT ON\n         EX    R5,RID1$TRT              TRT 0(0,R6),XT#TABTR\n         SR    R1,R6                    GET LENGTH SCANNED\n         BZ    RID1$TNS                 BIF NONE SCANNED\n         BCTR  R1,0                     GET EX LEN OF STUFF SCANNED\n         EX    R1,RID1$MV               MVC 0(0,R15),0(R6)\n         L     R14,=A(UC#TAB)           @ LC TO UC TR TABLE\n         TM    CACFLAG1,CACAPS          TRANSLATE TO UC?\n         BZ    *+8                      BR IF NO TRANS. REQUIRED\n         EX    R1,RID1$TR               TR 0(0,R15),0(R14)\n         LA    R1,1(,R1)                GET INPUT LENGTH BACK\nRID1$TNS AR    R1,R2                    + 1 IF WAS TAB CHAR\n         AR    R15,R1                   NEW POINTER INTO RECORD\n         AR    R7,R1                    NEW POSITION ON SCREEN\n         AR    R6,R1                    NEW POINTER INTO INPUT\n         SR    R5,R1                    NEW LEN INPUT LEFT - 1\n         LTR   R2,R2                    WAS THIS A TAB CHAR?\n         BZ    RID1$UP                  BIF TAB CHAR\n*---      SOFT TAB EXISTS IN INPUT                                 ---*\nRID1$TS  LA    R1,CATABS+1              POINT TO FIRST TAB\nRID1$TSS SR    R2,R2                    CLEAR FOR IC\n         IC    R2,0(,R1)                GET NEXT TAB POSITION ORIG 1\n         LTR   R2,R2                    ANY TAB?\n         BZ    RID1$UP                  BIF MORE NO MORE TABS ON LINE\n         BCTR  R2,0                     GET TAB ORIG 0\n         S     R2,XT#XOFF               WINDOW TAB\n         SR    R2,R7                    TAB POS :: CURRENT POS\n         BNM   RID1$TSF                 BIF FOUND TAB POSITION\n         LA    R1,1(,R1)                TO NEXT TAB POSITION\n         B     RID1$TSS                 CONTINUE SEARCH\nRID1$TSF AR    R7,R2                    TAB POSITION ON SCREEN\n         AR    R15,R2                   TAB POSITION IN RECORD\n         B     RID1$TSL                 AND CONTINUE\n         SPACE 1\n*---       ALL INPUT PROCESSED - UPDATE RECORD                     ---*\nRID1$UP  TM    CACFLAG2,CARECFM         FIXED LENGTH RECORDS?\n         BO    RID1$VFX                 BIF FIXED LENGTH\n         LH    R2,CALRECL               MAX LEN (INCLUDING RDW)\n         SH    R2,=H'4'                 - LENGTH OF RDW\n         L     R0,=F'-1'                BXH DCR\n         LA    R1,BUF1+7                BXH LIMIT (@ DATA - 1)\n         SR    R15,R15                  CLEAR FOR IC\n         TM    CACFLAG1,CANONUM         NONUM DATA SET?\n         BO    *+8                      SKIP NEXT INS IF NONUM\n         IC    R15,CALENGTH             GET SEQUENCE NUMBER LENGTH\n         AR    R1,R15                   REAL DATA START\n         SR    R2,R15                   REAL DATA LENGTH\n         AR    R2,R1                    BXH PTR (LAST BYTE OF DATA)\nRID1$VLP CLI   0(R2),C' '               SCAN OFF TRAILING BLANKS\n         BNE   RID1$VNB                 BIF NON-BLANK FOUND\n         BXH   R2,R0,RID1$VLP           CONTINUE BACK SCAN\n         BCTR  R1,0                     IF ALL BLANKS LENGTH = 1\nRID1$VNB SR    R2,R1                    GET LENGTH\n         AH    R2,=H'4'                 ADD IN RDW LENGTH\n         AR    R2,R15                   ADD IN SEQUENCE NUMBER LEN\n         STH   R2,BUF1+4                SET LENGTH INTO RDW\nRID1$VFX EDIO  W,BUF1                   UPDATE RECORD\n         BR    R10                      AND RETURN\nRID1$TRT TRT   0(0,R6),XT#TABTR         * EXECUTED *\nRID1$MV  MVC   0(0,R15),0(R6)           * EXECUTED *\nRID1$TR  TR    0(0,R15),0(R14)          * EXECUTED *\nRID1$MVB MVC   1(0,R1),0(R1)            * EXECUTED *\n         SPACE 1\n* INDEXED BY XT#SEQL*4 - IS 10**(SEQL-1)\nRID1#SQ  DC    F'1'          0 -> (NO SEQ FIELD)\n         DC    F'1'          1 -> (ONLY ATTR)\n         DC    F'10'         2 -> 10**1\n         DC    F'100'        3 -> 10**2\n         DC    F'1000'       4 -> 10**3\n         DC    F'10000'      5 -> 10**4\n         DC    F'100000'     6 -> 10**5\n         DC    F'1000000'    7 -> 10**6\n         DC    F'10000000'   8 -> 10**7\n         DC    F'100000000'  9 -> 10**8\n         DROP  R3,R8                    (LN#LINE,R$IDAT1)\n         EJECT ,\n         USING LN#LINE,R3\n         USING R$OST,R8                 (LOCAL BASE)\nR$OST    L     R7,XT#SCRC               COLUMNS\n         L     R5,XT#SEQL               SEQ FIELD LENGTH\n         L     R6,=A(ST#LIN)            LINE FORM ----+----1-----+---\n         TM    CACFLAG1,CANONUM         NUMBERED DATASET?\n         BO    ROST$NN                  BIF NOT NUMBERED\n         CLI   CALINE,1                 SEQ NUM AT BEGINING OF REC?\n         BNE   ROST$NN                  BIF SEQ FIELD AT END OF REC\n         SR    R15,R15                  CLEAR FOR IC\n         IC    R15,CALENGTH             GET NUM SEQ LENGTH\n         AR    R6,R15                   SKIP SEQ FIELD IN REC\nROST$NN  AL    R6,XT#XOFF               WINDOW IT\n         MVI   4(R2),X'F8'              SET AUTO SKIP ATTR INTENS\n         LA    R2,5(,R2)                SKIP SBA,ADR1,ADR2,SF,ATTR\n         BCTR  R5,0                     LEN OF SEQ FIELD -1\n         LTR   R5,R5                    ANY SEQ FIELD?\n         BM    *+8                      SKIP XC IF NONE\n         EX    R5,ROST$XC               XC 0(0,R2),0(R2) NULL SEQ FLD\n         LA    R2,1(R5,R2)              SKIP SEQ FIELD\n         BCTR  R7,0                     SPACE FOR DATA ATTR\n         BCTR  R7,0                     R5 HAS SEQ FLD LEN -1\n         SR    R7,R5                    GET LENGTH LEFT ON LINE\n         BNPR  R10                      RETURN IF LINE FULL\n         LR    R15,R7                   COPY LENGTH\n         LH    R0,CALRECL               GET MAX LRECL\n         SH    R0,=H'4'                 - RDW LENGTH FOR VAR LEN RECS\n         S     R0,XT#XOFF               - PART NOT DISPLAYED\n         SR    R14,R14                  CLEAR FOR IC\n         TM    CACFLAG1,CANONUM         LINE NUMBERED?\n         BO    *+8                      BIF NONUM\n         IC    R14,CALENGTH             GET LENGTH OF SEQ NUMBERS\n         SR    R0,R14                   GET DATA LENGTH TO USE\n         BNP   ROST$EZ                  GO ZERO,NONE LEFT (NO TABS TOO)\n         CR    R15,R0                   LENGTH ON LINE :: MAX DATA LEN\n         BNH   *+6                      BIF NOT OVER DATA LENGTH\n         LR    R15,R0                   USE DATA LENGTH THEN\n         BCTR  R15,0                    GET EX LEN LEFT\n         EX    R15,ROST$MV              MVC 0(0,R2),0(R6)\n         LA    R15,1(,R15)              GET REAL LENGTH BACK\n         TM    CATABS,X'FF'             TABS ON?\n         BZ    ROST$E                   GO EXIT IF TABS OFF\n         L     R6,XT#XOFF               GET OFFSET VALUE\n         LA    R14,CATABS+1             POINT TO FIRST TAB\nROST$TL  SR    R5,R5                    CLEAR FOR IC\n         IC    R5,0(,R14)               GET TAB\n         LTR   R5,R5                    ANY TAB HERE?\n         BZ    ROST$E                   BIF END OF TAB TABLE\n         BCTR  R5,0                     GET TAB ORIG 0\n         SR    R5,R6                    GET OFFSET INTO DISPLAY\n         BM    ROST$TN                  BIF BEFORE LEFT EDGE\n         CR    R5,R15                   PAST RIGHT EDGE?\n         BH    ROST$TN                  BIF PAST RIGHT EDGE\n         AR    R5,R2                    POINT TO TAB POSITION\n         MVC   0(1,R5),XT#TABC          SET TAB CHAR\nROST$TN  LA    R14,1(,R14)              TO NEXT TAB\n         B     ROST$TL                  CONTINE PLACING TABS\nROST$EZ  SR    R15,R15                  STATUS NOT IN WINDOW\nROST$E   AR    R2,R15                   PAST STATUS INFO\n         SR    R7,R15                   GET SPACE LEFT ON LINE\n         BNPR  R10                      RETURN IF LINE FULL\n         BCTR  R7,0                     GET EX LENGTH\n         EX    R7,ROST$XC               XC 0(0,R2),0(R2) NULL OUT LINE\n         LA    R2,1(R2,R7)              POINT PAST END OF LINE\n         BR    R10                      AND RETURN\nROST$XC  XC    0(0,R2),0(R2)            * EXECUTED *\nROST$MV  MVC   0(0,R2),0(R6)            * EXECUTED *\n         DROP  R3,R8                    (LN#LINE,R$OST)\n         EJECT ,\nR$IST    EX    0,0(,R8)    EX 0,*       NO INPUT ALLOWED\n         SPACE 1\nR$ICMD   STM   R1,R2,XT#CMDA            SAVE CMD ADDR/LEN\nRIC$C2   BR    R10                      AND RETURN\n         SPACE 2\n*  THERE ARE ASSUMPTIONS THAT THE COMMAND LINE IS THE FIRST\n*  LINE ON THE SCREEN (AND THERE IS ONLY ONE COMMAND LINE)\n*  AND THAT OTHER LINES EXIST AFTER IT.\n* POSSIBLE ACTIONS --\n*  CMD - SET ATTRIBUTE TO MODIFIED (AND LEAVE OLD INPUT),\n*        ERASE CMD AREA\n*  MSG - OLD MSG POSITION < NEW MSG POSITION,\n*        OLD MSG POSITION >= NEW MSG POSITION.\n         SPACE 1\n         USING LN#LINE,R3\n         USING R$OCMD,R8\nR$OCMD   TM    XT#SET,LN#FCHG           RESHOW SCREEN?\n         BZ    *+8                      SKIP NEXT INS IN NOT RESHOW\n         OI    XT#FLAG,XT#FECMD         FORCE ERASE CMD IF RESHOW\n         SR    R5,R5                    ASSUME DON'T ERASE CMD LINE\n         MVC   4(2,R2),=X'C111'     MODIFIED ATTR BYTE, NEXT OP SBA\n         TM    XT#FLAG,XT#FECMD         ERASE CMD LINE?\n         BZ    ROC$ER1                  BIF DON'T ERASE CMD LINE\n         MVC   4(2,R2),=X'403C'     NORMAL ATTR BYTE, NEXT OP RA\n         MVI   8(R2),0                  ERASE TO NULLS\n         LA    R5,1                     EXTRA BYTE FOR RA\nROC$ER1  LA    R2,5(,R2)                POINT TO SBA OR RA\n         L     R0,XT#SCRC               ASSUME NO NEW MSG (POS = SCRC)\n         L     R7,XT@MSG                GET MSG PTR\n         LTR   R7,R7                    ANY MSG TO WRITE?\n         BZ    ROC$NM1                  BIF NO NEW MSW\n         SR    R6,R6                    CLEAR FOR IC/CONSTANT\n         IC    R6,0(,R7)                GET MESSAGE LENGTH\n         LA    R15,1(,R6)               MSG LENGTH + ATTR LENGTH\n         SR    R0,R15                   SCREEN POS FOR NEW MSG\nROC$NM1  CH    R0,XT#OMSGP              NEW MSG POS :: OLD MSG POS\n         BNH   ROC$MNEW                 BIF NEW MSG OVERLAYS OLD MSG\n         STH   R0,TEMPDW                TEMP SAVE NEW POS\n         LH    R0,XT#OMSGP              GET OLD MSG POSITION\n         BAL   R14,CV$POS               SET ADDR TO POS OR ERASE TO\n         LA    R2,3(R5,R2)              SKIP RA OR SBA\n* I AM NOW POSITIONED TO OLD MSG POSITION - ERASE TO NEW MSG POSITION\n         MVI   0(R2),X'3C'              MAKE AN RA\n         MVI   3(R2),0\n         LA    R5,1                     ACCOUNT FOR EXTRA RA BYTE\n         LH    R0,TEMPDW                GET NEW POSITION BACK\nROC$MNEW STH   R0,XT#OMSGP              WILL BE OLD POSITION NEXT TIME\n         BAL   R14,CV$POS               SET RA OR SBA ADR1,ADR2\n         LA    R2,3(R5,R2)              SKIP RA OR SBA\n         LTR   R7,R7                    REALLY ANY NEW MSG?\n         BZR   R10                      RETURN IF NO NEW MSG\n         MVC   0(2,R2),=X'1DE8'         SET PROTECTED HIGH INTENS\n         BCTR  R6,0                     GET MSG EX LENGTH\n         EX    R6,ROC$MVC               MVC 2(0,R2),2(R7)\n         LA    R2,2+1(R6,R2)            SKIP SF, ATTR, MSG\n         BR    R10                      AND RETURN\nROC$MVC  MVC   2(0,R2),2(R7)            * EXECUTED *\n         SPACE 2\n         LTORG ,\n*  CATABS  - 1ST BYTE IS FLAG - X'00' TABS OFF, X'FF' TABS ON\n*         NEXT UP TO 10 TAB COLUMN NUMBERS (IN ORDER ORIG 1)\n*         X'00' ENDING BYTE\n*\n*  CALRECL - CONTAINS MAXIUM LRECL FOR RECORD (INCLUDING RDW)\n*            VALUE FOR TYPE ASM IS 84. (DEC)\n*\n*\n        TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - COMMANDS'\n         USING C$P,R8\nC$P      ST    R15,NEWKEY               SET KEY FOR EDIO\n         EDIO  RC,NEWKEY,BUF1           READ IT IF EXISTS\n         BZ    C$P$EX                   BIF EXISTS\n         EDIO  RN,NEWKEY,BUF1           ELSE READ NEXT\n         BZ    C$P$EX                   BIF EXISTS\n         EDIO  RP,NEWKEY,BUF1           ELSE USE PREVIOUS\nC$P$EX   MVC   CACURNUM,NEWKEY          SET CURRENT KEY\n         OI    XT#FLAG,XT#FSS           FORCE SETSCRN CALL\n         BR    R10                      AND RETURN\n         DROP  R8                       (C$P)\n         SPACE 1\nC$T      EDIO  RF,,BUF1                 READ FIRST\n         MVC   CACURNUM,BUF1            SET NEW KEY\n         OI    XT#FLAG,XT#FSS           SET CALL SETSCRN\n         BR    R10                      AND RETURN\nC$U      EDIO  RP,MF=B                  SET UP READ BACKWARDS\n         B     C$D$DOIT-C$U(,R8)        TO COMMON RTN\nC$D      EDIO  RN,MF=B                  SET UP READ FORWARDS\n         B     C$D$DOIT-C$D(,R8)        TO COMMON RTN\nC$D$DOIT BALR  R8,0                     GET COMMON BASE\n         USING *,R8\n         LTR   R5,R15                   TEST NUMBER TO BCT\n         BP    *+8                      SKIP NEXT IF GOOD\n         LA    R5,1                     USE 1 IF BAD\nC$D$LP   TM    CAATTN,CAATTNIS          ATTENTION?\n         BO    C$D$EX                   STOP LOOPING IF ATTEN\n         EDIO  ,CACURNUM,BUF1           READ NEXT RECORD\n         BNZ   C$D$CK                   BIF REC DOESN'T EXIST\n         MVC   CACURNUM,BUF1            SET NEW KEY\n         BCT   R5,C$D$LP                CONTINUE COUNTING\nC$D$EX   OI    XT#FLAG,XT#FSS           FORCE SETSCRN CALL\n         BR    R10                      AND RETURN\nC$D$CK   CLI   IOLIST,2                 WAS OPERATION RN?\n         BNE   C$D$EX                   DONE IF NOT\n*--- RAN OFF END OF DATA SET --- DISPLAY LAST SCREEN\nC$B      BALR  R8,0\n         USING *,R8\n         EDIO  RL,,BUF1                 READ LAST RECORD\n         BNZR  R10                      BIF NO RECORDS\n         MVC   CACURNUM,BUF1            SET START KEY\n         L     R15,XT#SCRL              LINES / SCREEN\n         SH    R15,=H'3'                DATA LINES / SCREEN\n         SH    R8,=Y(C$B+2-C$U)         FIX UP BASE\n         BR    R8                       AND GO UP\n         DROP  R8                       (* LOCAL BASE)\n         SPACE 1\nC$L      LCR   R15,R15                  GO LEFT\nC$R      BALR  R8,0                     GET COMMON BASE\n         USING *,R8\n         A     R15,XT#XOFF              GET NEW OFFSET VALUE\n         BNM   *+6                      SKIP NEXT IF < 0\n         SR    R15,R15                  USE ZERO IF TOO LOW\n         LA    R14,254                  CONSTANT OF 254\n         S     R14,XT#SCRC              - COLS / LINE\n         A     R14,XT#SEQL              + SEQ FIELD\n         CR    R15,R14                  NEW OFFSET :: MAX\n         BNH   *+6                      SKIP NEXT IF < MAX\n         LR    R15,R14                  USE MAX AS MAXIUM OFFSET\n         ST    R15,XT#XOFF              SAVE NEW X OFFSET VALUE\n         OI    XT#SET,LN#FCHG           SET REBUILD SCREEN\n         BR    R10                      AND RETURN\n         DROP  R8                       (C$L,C$R,*)\n         SPACE 1\n         USING C$COL,R8\nC$COL    LTR   R15,R15                 LOOK OK?\n         BNPR  R10                     IGNORE IF BAD\n         BCTR  R15,0                   GET ORIG 0\n         LA    R14,254                 MAX COL POSITION\n         S     R14,XT#SCRC             - COLS / LINE\n         A     R14,XT#SEQL             + SEQ FIELD LENGTH\n         CR    R15,R14\n         BHR   R10                      AND RETURN\n         ST    R15,XT#XOFF             SET OFFSET VALUE\n         OI    XT#SET,LN#FCHG          FORCE SCREEN REBUILD\n         BR    R10                     AND REBUILD SCREEN\n         DROP  R8                      (C$COL)\n         SPACE 1\n         USING C$SEQ,R8\nC$SEQ    LTR   R15,R15                 LOOK OK?\n         BMR   R10                     IGNORE IF BAD\n         CH    R15,=H'9'               TOO BIG?\n         BHR   R10                     IGNORE IF TOO BIG\n         ST    R15,XT#SEQL             SET SEQ FIELD LEN\n         OI    XT#SET,LN#FCHG          FORCE SCREEN REBUILD\n         BR    R10                      AND CONTINUE\n         DROP  R8                       (C$SEQ)\n         SPACE 1\n         USING C$HELP,R8\nC$HELP   L     R4,SV#SCAN+4             SAVE OPERAND END ADR -1\n         L     R3,SV#SCAN+8             AND OPERAND ADR\n         BAL   R14,SCANC                FIND HELP OPERAND\n         BNP   C$HELPF                  NO/INVALID OPERAND; TO FSE HELP\n         CLC   TEMPDW(4),=C'FSE '       FSE HELP REQUESTED?\n         BE    C$HELPF                  GO DO IT IF SO\n         CLC   TEMPDW(8),=C'FULLSCR '   FSE HELP BY FULL NAME?\n         BE    C$HELPF                  GO DO IT IF SO\n         LA    R5,EDCMD#H               IS A HELP CMD FOR EDIT\n         SR    R4,R3                    LEN -1 OF COMMAND LEFT\n         MVC   TBUF1(8),1(R5)           SET COMMAND\n         MVI   TBUF1+8,C' '             FOLLOWED BY BLANK\n         MVC   TBUF1+8+1(255),0(R3)     AND OPERANDS\n         LA    R3,TBUF1                 POINT TO COMMAND STRING\n         LA    R4,8+1+1(,R4)            LENGTH OF COMMAND STRING\n         L     R8,=A(STK#EDIT)          GET STACK ROUTINE ADDRESS\n         B     STK#EDH-STK#EDIT(,R8)    GO TO INTERNAL ENTRY\nC$HELPF  CLI   XT#BLDL+2+2+8+2,0        R OF TTR = 0?\n         BNE   C$HELPL                  GO LINK IF NOT\n         MVC   XT#BLDL(C#HELPBL),C#HELPB INIT BLDL LIST\n         BLDL  0,XT#BLDL                BLDL MODULE\n         BXH   R15,R15,0(R10)           RETURN IF NOT AVAILABLE\nC$HELPL  L     R1,XT@BUF                ADDR WORK AREA FOR HELP RTN\n         LA    R2,XT#BLDL+4             POINT TO NAME FOR LINK\n         LA    R15,XT#LINK              SF PARM FOR LINK\n         LINK  DE=(R2),SF=(E,(15))      GO DO IT\n         OI    XT#FLAG,XT#FSS           MUST REFORMAT SCREEN\nC$HOME   BR    R10                      AND RETURN\nC#HELPB  DC    H'1',H'58'               1 ENTRY IN LIST, 58 BYTES LONG\n         DC    CL8'CCNEDFSH'            HELP MODULE NAME\nC#HELPBL EQU   *-C#HELPB                LENGTH OF INFO\n         DROP  R8                       (C$HELP)\n         SPACE 1\n         USING C$TABC,R8\nC$TABC   BAL   R14,SCANC                SCAN FOR OPERAND\n         BZ    INF$MOPR                 BIF MISSING OPERAND\n         BM    INF$IOPR                 BIF INVALID OPERAND\n         CLI   TEMPDW+1,C' '            ONLY 1 CHAR LONG?\n         BNE   INF$IOPR                 BIF IF > 1 CHAR LONG\n         SR    R3,R3                    CLEAR FOR IC\n         IC    R3,TEMPDW                GET NEW TAB CHARACTER\n         STC   R3,XT#TABC               SAVE IT\n         XC    XT#TABTR(256),XT#TABTR   CLEAN OUT TAB TRT TABLE\n         LA    R3,XT#TABTR(R3)          POINT TO POSITION\n         MVI   0(R3),1                  SET TRT STOP\n         LA    R3,XT#LINS               @ FIRST LN#LINE\n         L     R4,XT#SCRL               NUMBER OF LINES\n         USING LN#LINE,R3\nCTABC$L2 CLC   LN#ROUT,=Y(R$OST-$)      STATUS LINE?\n         BNE   *+8\n         OI    LN#FLAG,LN#FCHG          SET TO REWRITE IT\n         LA    R3,LN#LINEL(,R3)         TO NEXT LN#LINE\n         BCT   R4,CTABC$L2\n         BR    R10                      AND RETURN\n         DROP  R8,R3                    (C$TABC,LN#LINE)\n         SPACE 1\nC$NULLS  LA    R7,XT#FNULS+256          BIT + SET SCREEN FLAG\n         B     CTABH$E-C$NULLS(,R8)     TO COMMON ROUTINE\nC$TABS   LA    R7,XT#FTABS              GET FLAG TO SET\n         B     CTABH$E-C$TABS(,R8)      TO COMMON ROUTINE\nC$TABH   LA    R7,XT#FTABH+256          BIT + SET SCREEN FLAG\nCTABH$E  BALR  R8,0                     GET COMMON BASE\n         USING *,R8\n         SR    R6,R6                    ASSUME YES OPERAND (SET)\n         BAL   R14,SCANC                FIND OPERAND\n         BNP   INF$MOPR                 BIF MISSING OPERAND\n         CLC   TEMPDW(3),=C'ON '        SET IT?\n         BE    CTABH$Y                  BIF ON (SET)\n         BCTR  R6,0                     CHANGE TO CLEAR OPTION\n         CLC   TEMPDW(4),=C'OFF '       OFF?\n         BNE   INF$IOPR                 BIF INVALID OPERAND\nCTABH$Y  IC    R0,XT#OPT                GET CURRENT OPTION\n         XR    R0,R6                    FLIP IF TO BE CLEARED\n         OR    R0,R7                    SET/CLEAR OPTION\n         XR    R0,R6                    FLIP IF WAS CLEARED\n         STC   R0,XT#OPT                SET NEW OPTION VALUES\n         SRA   R7,8                     GET ONLY SET SCREEN FLAG\n         BZR   R10                      RETURN IF NO SETSCREEN\n         OI    XT#SET,LN#FCHG           SET ALL REWRITE FLAGS\n         BR    R10                      AND RETURN\n         DROP  R8                       (CTABH$E COMMON BASE)\n        TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - STACK ROUTINE'\n***********************************************************************\n*                                                                     *\n*                                   STACK ROUTINE                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         USING STK#EDIT,R8\nSTK#EDIT LM    R5,R7,=A(EDCMD#T,EDCMD#TL,EDCMD#TE)  CMD TABLE STUFF\n         BAL   R14,FIND                 CHECK FOR VALID CMD\n         BNER  R10                      EXIT IF NOT VALID\n         SPACE 2\n         LM    R3,R4,XT#CMDA            R3=A CMD,  R4=L'CMD LINE\nSTK#EDH  LA    R2,16+4(,R4)             LEN OF CMD + RDW\n         LR    R6,R5                    SAVE CMD TABLE PTR\n         TM    EDCMD#FL(R6),EDCMD#EX    RETURN TO FSE OR EXIT?\n         BO    STK#GET                  DON'T RETURN\n         LA    R2,STK#NAML(,R2)         RETURN. ADD LEN RDW + \"FSE\"\nSTK#GET  GETMAIN  EC,LV=(R2),A=TEMPDW,SP=78,MF=(E,GETMFL)\n         BXH   R15,R15,NOCORE           QUIT W/MSG IF NO CORE\n         L     R5,TEMPDW                @ GOTTEN CORE (LSD+STACK)\n         LA    R14,16(,R5)              @ STACK\n         LR    R15,R2                   RECFM=V + TOTAL LENGTH\n         SH    R15,=H'16'               DON'T COUNT LSD LENGTH\n         LR    R0,R14                   @ CURRENT CMD TO EXECUTE\n         SR    R1,R1                    ZERO THE RESERVED WORD\n         LA    R2,4(,R4)                L'CMD LINE + RDW\n         SLL   R2,16                    MAKE LEN INTO RDW\n         STM   R14,R2,0(R5)             STORE LSD + FIRST RDW\n         BCTR  R4,0                     L'CMD LINE -1 FOR EX\n         EX    R4,STK#MVC               MOVE CMD LINE INTO STACK\n         LA    R15,1+4(R14,R4)          POINT PAST CMD/RDW\n         TM    EDCMD#FL(R6),EDCMD#EX    RETURN TO FSE OR EXIT?\n         BO    STK#STK1                 DON'T RETURN\n         MVC   0(STK#NAML,R15),STK#NAME MOVE IN RDW + \"FULLSCR\"\n         B     STK#STK2                 SKIP RESTORE OF VERIFY\nSTK#STK1 OC    CACFLAG1(1),XT#SAVF      RESTORE VERIFY FLAG\n         SPACE 1\nSTK#STK2 STACK PARM=STPB,STORAGE=((R5),SOURCE),MF=(E,CATMPLST)\n         LTR   R15,R15                  DID IT WORK?\n         BNZ   STCKERR                  NO.  QUIT W/MSG.\n         TM    EDCMD#FL(R6),EDCMD#SP    SAVE CACURNUM?\n         BZ    STK#NSV                  BIF DON'T SAVE CURNUM\n         MVC   XT#CNUM,CACURNUM         SAVE IT\n         OI    XT#FLAG,XT#FSCN          SET FLAG TO USE IT\nSTK#NSV  TM    EDCMD#FL(R6),EDCMD#FS    DON'T LEAVE FULLSCR MODE?\n         BO    EXIT                     BIF DON'T (STAY IN FULLSCR)\n         BAL   R10,LVFULL               LEAVE FULLSCR MODE\n         B     EXIT                     AND EXIT\n         SPACE 1\n         DROP  R8\n         SPACE 4\nSTK#MVC  MVC   4(0,R14),0(R3)\nSTK#NAME DC    AL2(11,0),C'FULLSCR'\nSTK#NAML EQU   *-STK#NAME\nEDCMD#T  DC    AL1(7),CL8'CHANGE',X'00'\nEDCMD#TL EQU   *-EDCMD#T\n         DC    AL1(7),CL8'C',X'00'\n         DC    AL1(7),CL8'DELETE',X'60'\n         DC    AL1(7),CL8'DEL',X'60'\n         DC    AL1(7),CL8'END',X'80'\n         DC    AL1(7),CL8'FORMAT',X'80'\n         DC    AL1(7),CL8'FOR',X'80'\nEDCMD#H  DC    AL1(7),CL8'HELP',X'80'\n         DC    AL1(7),CL8'H',X'80'\n         DC    AL1(7),CL8'INPUT',X'80'\n         DC    AL1(1),CL8'I',X'80'\n         DC    AL1(6),CL8'INSERT',X'80'\n         DC    AL1(2),CL8'IN',X'80'\n         DC    AL1(4),CL8'LIST',X'80'\n         DC    AL1(1),CL8'L',X'80'\n         DC    AL1(5),CL8'MERGE',X'00'\n         DC    AL1(3),CL8'MER',X'00'\n         DC    AL1(7),CL8'PROFILE',X'00'\n         DC    AL1(4),CL8'PROF',X'00'\n         DC    AL1(3),CL8'RUN',X'80'\n         DC    AL1(1),CL8'R',X'80'\n         DC    AL1(4),CL8'SAVE',X'00'\n         DC    AL1(1),CL8'S',X'00'\n         DC    AL1(4),CL8'SCAN',X'80'\n         DC    AL1(5),CL8'SC',X'80'\n         DC    AL1(6),CL8'TABSET',X'00'\n         DC    AL1(3),CL8'TAB',X'00'\n         DC    AL1(6),CL8'VERIFY',X'00'\n         DC    AL1(1),CL8'V',X'00'\n         DC    AL1(4),CL8'COPY',X'60'\n         DC    AL1(2),CL8'CY',X'60'\n         DC    AL1(2),CL8'DO',X'80'\n         DC    AL1(3),CL8'EXS',X'00'\n         DC    AL1(3),CL8'SEX',X'00'\n         DC    AL1(7),CL8'FASTNUM',X'00'\n         DC    AL1(4),CL8'FIND',X'00'\n         DC    AL1(1),CL8'F',X'00'\n         DC    AL1(6),CL8'MODIFY',X'00'\n         DC    AL1(3),CL8'MOD',X'00'\n         DC    AL1(1),CL8'M',X'00'\n         DC    AL1(4),CL8'MOVE',X'60'\n         DC    AL1(2),CL8'MV',X'60'\n         DC    AL1(5),CL8'RENUM',X'00'\n         DC    AL1(3),CL8'REN',X'00'\n         DC    AL1(5),CL8'TEMP1',X'00'\n         DC    AL1(2),CL8'T1',X'00'\n         DC    AL1(5),CL8'UNNUM',X'00'\nEDCMD#TE EQU   *-EDCMD#TL\nEDCMD#FL EQU   EDCMD#TL-1\nEDCMD#EX EQU   X'80'                    DON'T RETURN TO FSE (EXIT)\nEDCMD#SP EQU   X'40'                    SAVE POS. OVER EDIT SUBCMD\nEDCMD#FS EQU   X'20'                    DON'T LEAVE FULLSCR MODE\n         SPACE 1\nMSG#ENT  MSG   0,'FSE V1.3 04/12/79 (TEST)'\nMSG#NFMT MSG   254,'SCREEN FORMAT ERROR'\nMSG#ICMD MSG   0,'INVALID COMMAND'\nMSG#MOPR MSG   0,'MISSING OPERAND'\nMSG#IOPR MSG   0,'INVALID OPERAND'\nMSG#MNO  MSG   0,'MISSING NUMERIC OPERAND'\nMSG#BADC MSG   61,'INVALID CHARACTERS IN DATASET'\nMSG#LOWC MSG   63,'LOWER CASE IN DATASET'\n         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - FMOVE/FCOPY'\n*---------------------------------------------------------------------*\n*                                                                     *\n*  THE MOVE/COPY/DELETE COMMANDS JUST SAVE THE RECORD NUMBERS OF      *\n*  THEIR OPERANDS.  ALL ACTIONS ARE DONE BY 'IMCRTN'.                 *\n*   (INSERT/MOVE/COPY/DELETE)                                         *\n*                                                                     *\n*  NOTE:  THE SEQUENCE NUMBER MUST POINT TO RECORDS WHICH EXIST       *\n*         ELSE THE SEQUENCE FIX UP WILL NOT WORK IF INSERT HAS        *\n*         TO MOVE RECORDS AROUND.                                     *\n*                                                                     *\n*        R6 < 0 -> DELETE,  R6 = 0 -> MOVE, R6 > 0 -> COPY            *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nC$FDEL   LNR   R6,R8                    SET DELETE CMD\n         B     C$FMOE-C$FDEL(,R8)       B TO COMMON CODE\nC$FCO    LPR   R6,R8                    SET COPY CMD\n         B     C$FMOE-C$FCO(,R8)        B TO COMMON CODE\nC$FMO    SR    R6,R6                    SET MOVE CMD\nC$FMOE   BALR  R8,0                     GET COMMON LOCAL BASE\n         USING *,R8\n         BAL   R14,SCANN                SCAN FOR L1\n         BNP   INF$MNO                  BIF NO L1\n         ST    R15,BUF1+400             SAVE L1\n         EDIO  RC,BUF1+400,BUF1         TRY TO READ IT\n         BZ    C$FMOL1                  BIF L1 EXISTS\n         EDIO  RN                       ELSE READ NEXT (AND USE AS L1)\n         BNZ   INF$IOPR                 INVALID IF OFF END OF FILE\nC$FMOL1  L     R3,BUF1                  GET L1 VALUE\n         LR    R4,R3                    AND DEFAULT L2\n         L     R5,CACURNUM              AND DEFAULT L3\n         BAL   R14,SCANN                SCAN FOR L3 (OR L2)\nC$FMC1   BZ    C$FMCCK                  BIF NO L3 OR L2\n         BP    C$FMC2\n         LTR   R6,R6                    INVALID IF DELETE\n         BM    INF$IOPR                 BIF DELETE AND NOT NUMBER\n         BAL   R14,SCANC                SCAN FOR *\n         BNP   INF$IOPR                 BIF IF INVALID OPERAND\n         CLC   TEMPDW(2),=C'* '         ONLY * ?\n         BNE   INF$IOPR                 BIF IF INVALID OPERAND\n         B     C$FMCCK                  GO CHECK L1,L2,L3 VALUES\nC$FMC2   LR    R5,R15                   SET L3\n         LTR   R6,R6                    IS THIS DELETE?\n         BM    C$FMCDEL                 BIF DELETE, IS L2, NO L3\n         BAL   R14,SCANN                SCAN FOR L3 (PREV WAS L2)\n         BNP   C$FMC1                   BIF NO L2\nC$FMCDEL LR    R4,R5                    PREVIOUS WAS REALLY L2\n         LR    R5,R15                   SAVE L3 (REAL ONE)\n*  GET REAL RECORDS FOR L2 AND PERHAPS L3\nC$FMCCK  XC    SV#SCANP,SV#SCANP        NO CURSOR POS IF ERROR MSG\n         ST    R4,BUF1+400              SET KEY TO READ\n         EDIO  RC                       SEE IF L2 EXISTS\n         BZ    C$FML2                   BIF L2 EXISTS\n         EDIO  RP                       ELSE READ PREVIOUS\n         BNZ   INF$IOPR                 INVALID L2 IF BEFORE BEGINNING\nC$FML2   L     R4,BUF1                  GET KEY OF L2\n         LTR   R6,R6                    IS THIS DELETE?\n         BM    C$FDELS                  BIF DELETE, SAVE OPERANDS\n         ST    R5,BUF1+400              SET KEY TO READ\n         ST    R5,XT#SEQX3              SAVE ORIG L3 TOO\n         EDIO  RC                       TRY TO READ L3\n         BZ    C$FML3\n         SR    R5,R5                    ASSUME COPY TO\n         BCTR  R5,0                     TOP OF DATA SET\n         EDIO  RP                       ELSE READ PREVIOUS\n         BNZ   C$FML3T                  BIF USE TOP OF DATA SET\nC$FML3   L     R5,BUF1                  GET REAL VALUE OF L3\n         SPACE 1\n*  CHECK THAT L1 <= L2\nC$FML3T  CR    R3,R4                    L1 :: L2\n         BH    INF$IOPR                 BIF INVALID OPERANDS\n*  CHECK THAT L3 < L1 OR L3 >= L2\n         CR    R5,R3                    L3 :: L1\n         BL    C$FMC3                   BIF OK\n         CR    R5,R4                    L3 :: L2\n         BL    INF$IOPR                 BIF INVALID\nC$FMC3   STM   R3,R5,XT#SEQL1           SAVE L1,L2,L3\n         MVI   XT#FMC,C'C'              ASSUME COPY\n         LTR   R6,R6                    IS IT COPY?\n         BNZ   *+8                      BIF COPY\n         MVI   XT#FMC,C'M'              IT IS MOVE\nC$FMRET  OI    XT#FLAG,XT#FIMC          PROVOKE IMC ROUTINE\n         BR    R10                      AND RETURN\nC$FDELS  CR    R3,R4                    L1 <= L2?\n         BH    INF$IOPR                 BIF INVALID DELETE\n         STM   R3,R4,XT#SEQL1           SAVE DELETE OPERANDS\n         MVI   XT#FMC,C'D'              THIS IS DELETE...\n         B     C$FMRET                  SET FLAG, RETURN\n         DROP  R8                       (C$FMC LOCAL BASE)\n TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - INSERT/MOVE/COPY RTN - IMCRTN'\n*---------------------------------------------------------------------*\n*                                                                     *\n*  IMCRTN: INSERT/MOVE/COPY/DELETE ROUTINE                            *\n*                                                                     *\n*   RECEIVES CONTROL FROM FSE MAINLINE AFTER ALL INPUT DATA HAS       *\n*   BEEN EDITED.  (AT THIS POINT THE CONTENTS OF XT#BUF ARE NO        *\n*   LONGER REQUIRED)  INSERTS ARE DONE ONE AT A TIME FROM THE         *\n*   BOTTOM OF THE SCREEN TO THE TOP (TO AVOID RUNNING INTO            *\n*   EACH OTHER).  ANY RE-NUMBERING CAUSED BY THE INSERTIONS           *\n*   WILL NOT INTERFERE WITH OTHER INSERTIONS DUE TO THIS ORDER.       *\n*   THE OPERANDS OF THE MOVE/COPY OR DELETE COMMAND WHICH IS          *\n*   CURRENTLY PENDING (IF ANY) ARE ADJUSTED AS THE LOCAL RE-NUMBERING *\n*   IS DONE TO MAINTAIN THE INTENT OF THE MOVE/COPY OR DELETE.        *\n*                                                                     *\n*   NOTE: THIS ROUTINE CHECKS 'CAATTN','CAATTNIS' FOR ATTENTIONS      *\n*         AND WILL CLEAN UP QUICKLY AND RETURN IF POSTED.             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\n         USING IMCRTN,R8                IMCRTN LOCAL BASE\nIMCRTN   ST    R10,RET#SAVE             SAVE RETURN TO MAINLINE ADDR\n         L     R10,XT@BUF               GET ADDR OF XT#BUF (IMC#WRK)\n         USING IMC#WRK,R10              WORK AREA BASE\n         NI    XT#FLAG,255-XT#FIMC      OFF IMC CALL REQUIRED FLAG\n         LA    R0,10\n         CL    R0,CAINCRE               10 < INCREMENT?\n         BL    IMC$SET2\n         LA    R0,2                     ELSE TRY 2\n         CL    R0,CAINCRE\n         BL    IMC$SET2\n         LA    R0,1                     ELSE USE 1 AS IMC#INC2\nIMC$SET2 ST    R0,IMC#INC2\n         MVC   IMC#INC1,CAINCRE         INIT INCREMENT\n         SPACE 1\n*---             FIRST PROCESS ALL INSERT/REPLICATES               ---*\n         L     R4,XT#SCRL               LINES / SCREEN\n         LR    R3,R4                    COPY LINES / SCREEN\n         SLL   R3,4                     * LN#LINEL\n         LA    R3,XT#LINS-LN#LINEL(R3)  POINT TO LAST LN#LINE ENTRY\n         USING LN#LINE,R3\nIMC$ILP1 TM    LN#FLAG,LN#FDAT          DATA LINE?\n         BZ    IMC$INX                  BIF NOT DATA LINE\n         SR    R6,R6                    CLEAR FOR IC\n         IC    R6,LN#INNUM              NUM TO INSERT AFTER THIS LINE\n         LTR   R6,R6                    ANY TO INSERT?\n         BZ    IMC$INX                  BIF NONE TO INSERT HERE\n         SPACE 1\n*--- INSERT THE RECORDS; SPECIAL PROCESSING FOR CURSOR POSITION    ---*\n         MVI   LN#INNUM,0               INSERT WILL BE DONE\n         SR    R2,R2                    ASSUME DON'T SET CURSOR\n         TM    XT#CURSQ,X'80'           HAVE SEQ NUM FOR CUR POS?\n         BZ    IMC$IGO                  BIF IF DONE ALREADY\n         LR    R1,R3                    COPY MY LN#LINE ADDR\n         LA    R0,XT#LINS               @ 0TH LINE ENTRY\n         SR    R1,R0                    GET LN#LINE OFFSET\n         SRL   R1,4                     GET LINE NUMBER\n         MH    R1,XT#SCRC+2             * LENGTH OF LINE\n         CH    R1,XT#CUR                MY LINE BEFORE CURSOR?\n         BNL   IMC$IGO                  BIF CURSOR BEFORE MY LINE\n         AH    R1,XT#SCRC+2             TO NEXT LINE\n         CH    R1,XT#CUR                NEXT LINE BEFORE CURSOR?\n         BNH   IMC$IGO                  BIF CURSOR PAST MY LINE\n         LA    R2,1                     SET CURSOR FLAG\n* R5 - NUM TO INSERT; LN#PARM - SEQ NUM TO INSERT AFTER\n***** VARIABLE LENGTH CHECK (USE LEN 1 RECORDS??)\nIMC$IGO  EDIO  RC,(R3),IMC#BUF1         READ CURRENT RECORD\n         BNZ   IMC$ERR                  BIF RECORD VANISHED\n         TM    LN#FLAG,LN#FREP          REPLICATE?\n         BO    IMC$REP                  BIF REPLICATE\n         MVI   IMC#BUF1+8,C' '   BLANK OUT MAX LEN RECORD\n         MVC   IMC#BUF1+9(256),IMC#BUF1+8\nIMC$REP  NI    LN#FLAG,255-LN#FREP      OFF REPLICATE FLAG\n         L     R5,LN#PARM               USE CURRENT KEY AS SEQ1\n         MH    R6,IMC#INC1+2            GET N * INC1\n         AR    R6,R5                    + SEQ1 -> SEQ2\n         AH    R5,=H'1'                 USE LN#PARM + 1 AS SEQ1\n         BAL   R7,IMC$PUSH              GO MAKE ROOM FOR INSERT\n         BCTR  R5,0                     GET LN#PARM BACK\n         SR    R6,R5                    GET N * INC1 BACK\nIMC$ILP2 A     R5,IMC#INC1              PLACE FOR NEXT INSERT\n         BCT   R2,*+8                   SET CURSOR?\n         ST    R5,XT#CURSQ              SET SEQ NUMBER FOR CURSOR\n         ST    R5,IMC#BUF1              SET SEQ NUMBER FOR ADD\n         EDIO  W,IMC#BUF1               ADD NEW RECORD\n         S     R6,IMC#INC1              ANY MORE TO INSERT?\n         BP    IMC$ILP2                 BIF MORE TO INSERT\n         OI    XT#FLAG,XT#FSS           FORCE SETSCRN CALL\n         SPACE 1\nIMC$INX  SH    R3,=Y(LN#LINEL)          TO PREVIOUS LN#LINE ENTRY\n         BCT   R4,IMC$ILP1              DO INSERTS FOR EACH SCREENLINE\n         DROP  R3                       (LN#LINE)\n         SPACE 2\n*---             PROCESS MOVE/COPY OR DELETE                       ---*\n         CLI   XT#FMC,0                 ANY MOVE OR COPY PENDING?\n         BE    IMC$RET                  BIF NO MOVE/COPY/DELETE PEND.\n         OI    XT#FLAG,XT#FSS           FORCE SETSCRN CALL\n         CLI   XT#FMC,C'D'              DELETE REQUIRED?\n         BE    IMC$DEL                  BIF DELETE COMMAND\n         SPACE 1\n         L     R5,XT#SEQX3              GET ORIG L3 VALUE\n         C     R5,XT#SEQL3              SAME VALUE AS L3?\n         BE    IMC$MCX3                 BIF SAME, GO USE IT\n         EDIO  RP,XT#SEQX3,IMC#BUF1     READ PREVIOUS IF ANY\n         BZ    IMC$MCLC                 BIF PREV REC FOUND\n         CLC   XT#SEQL3,=F'-1'          WAS IT TOP BEFORE?\n         BE    IMC$MCX3                 BIF WAS TOP, USE X3\n         B     IMC$MCL3                 ELSE USE L3\nIMC$MCLC CLC   IMC#BUF1,XT#SEQL3        SAME RELATIVE POSITION?\n         BE    IMC$MCX3                 BIF SAME, USE X3\nIMC$MCL3 L     R5,XT#SEQL3              ELSE USE L3 AS INSERT POSITION\nIMC$MCX3 EQU   *\n         SPACE 1\n*---              COUNT RECORDS TO MOVE OR COPY                   ---*\n         MVC   NEWKEY,XT#SEQL1          SET STARTING SEQ NUMBER\n         SR    R6,R6                    NO RECORDS SO FAR\n         EDIO  RC,NEWKEY,IMC#BUF1       SEE IF FIRST RECORD EXISTS\n         BZ    IMC$MCR1                 BIF FIRST RECORD EXISTS\n         SPACE 1\nIMC$MCL4 EDIO  RN                       READ NEXT RECORD\n         BNZ   IMC$MCPH                 BIF NO NEXT RECORD\nIMC$MCR1 CLC   IMC#BUF1(4),XT#SEQL2     PAST LIMIT OF MOVE/COPY?\n         BH    IMC$MCPH                 BIF PAST MOVE/COPY LIMIT\n         MVC   NEWKEY,IMC#BUF1          SET KEY FOR READ NEXT\n         A     R6,IMC#INC1              SUM SPACE REQUIRED\n         TM    CAATTN,CAATTNIS          ATTENTION?\n         BZ    IMC$MCL4                 BIF NO ATTENTION\n         B     IMC$RET                  ABORT MOVE/COPY IF ATTENTION\n         SPACE 1\nIMC$MCPH ST    R5,NEWKEY                SET TARGET KEY\n         SR    R2,R2                    ASSUME NO RECORD AT TARGET LOC\n         S     R6,IMC#INC1              - INC1 -> SPACE REQUIRED\n         AR    R6,R5                    SPACE REQUIRED + SEQ1 -> SEQ2\n         EDIO  RC                       READ TARGET TO IMC#BUF1\n         BNZ   IMC$MCP2                 BIF NO RECORD THERE\n         L     R2,IMC#INC1              SET FLAG, TO AFTER TARGET LOC\n         AH    R5,=H'1'                 BUMP SEQ1 PAST TARGET\n         AR    R6,R2                    BUMP SEQ2 TO MAKE ROOM\nIMC$MCP2 BAL   R7,IMC$PUSH              PUSH RECORDS OUT OF WAY\n         LTR   R2,R2                    DID TARGET EXIST?\n         BZ    IMC$MCP3                 BIF TARGET DIDN'T EXIST\n         BCTR  R5,0                     GET L3 BACK\n         AR    R5,R2                    BUMP L3 PAST TARGET\nIMC$MCP3 SR    R6,R5                    GET SPACE REQUIRED BACK\n         A     R6,IMC#INC1              GET NUMBER * INC1 BACK\n         EJECT ,\n         EDIO  RC,XT#SEQL1,IMC#BUF1,ERRAD=IMC$ERR READ FIRST RECORD\n         B     IMC$MCLX\n         SPACE 1\nIMC$MCLP EDIO  RN,NEWKEY,IMC#BUF1,ERRAD=IMC$ERR   READ FROM RECORD\nIMC$MCLX MVC   NEWKEY,IMC#BUF1          SET KEY READ\n         CLI   XT#FMC,C'M'              IS THIS MOVE?\n         BNE   IMC$MNOT                 BIF NOT MOVE\n         EDIO  DLT,NEWKEY,ERRAD=IMC$ERR DELETE SOURCE IF MOVE\n         L     R0,NEWKEY                GET FROM SEQ NUMBER\n         LR    R1,R5                    AND TO SEQ NUMBER\n         BAL   R14,IMC$KCHG             NOTE KEY CHANGED R0 -> R1\n         SPACE 1\nIMC$MNOT ST    R5,IMC#BUF1              SET KEY FOR WRITE\n         EDIO  W,IMC#BUF1               ADD THE RECORD\n         A     R5,IMC#INC1              NEXT ADD SEQ NUMBER\n         S     R6,IMC#INC1              ANY MORE TO MOVE/COPY?\n         BP    IMC$MCLP                 BIF MORE TO DO\n         SPACE 1\nIMC$RET  MVI   XT#FMC,0                 NO MORE MOVE / COPY\n         L     R10,RET#SAVE             RESTORE RETURN ADDR\n         BR    R10                      AND RETURN TO MAIN LINE\n         SPACE 1\nIMC$DEL  MVC   NEWKEY,XT#SEQL1          INIT KEY TO START DEL AT\n         EDIO  RC,MF=B                  START AT CURRENT KEY\n         B     IMC$DEL2\n         SPACE 1\nIMC$DEL1 EDIO  RN,MF=B                  SET READ NEXT TYPE\nIMC$DEL2 EDIO  ,NEWKEY,IMC#BUF1         READ RECORD\n         BZ    IMC$DEL3                 BIF RECORD EXISTS\n         CLI   IOLIST,0                 WAS THAT READ CURRENT?\n         BE    IMC$DEL1                 BIF RC, TRY READ NEXT\n         B     IMC$RET                  ELSE EOF, DONE\nIMC$DEL3 CLC   IMC#BUF1,XT#SEQL2        RECORD <= L2?\n         BH    IMC$RET                  BIF DELETE DONE\n         MVC   NEWKEY,IMC#BUF1          SAVE KEY FOR READ NEXT\n         EDIO  DLT,NEWKEY,ERRAD=IMC$ERR DELETE RECORD\n         TM    CAATTN,CAATTNIS          ATTENTION?\n         BZ    IMC$DEL1                 CONTINUE IF NO ATTENTION\n         B     IMC$RET                  ABORT IF ATTENTION\n         EJECT ,\n*---------------------------------------------------------------------*\n*  IMC$PUSH:  INTERNAL SUBROUTINE OF IMCRTN                           *\n*   THIS ROUTINE PUSHES RECORDS DOWN IN THE FILE IF REQUIRED TO       *\n*   MAKE ROOM FOR NEW RECORDS 'IMC' IS TO INSERT/MOVE/COPY.           *\n*                                                                     *\n* AT ENTRY:  R5       - SEQ1  (LOWER LIMIT TO PUSH FROM)              *\n*                                                                     *\n*            R6       - SEQ2  (UPPER LIMIT TO PUSH FROM)              *\n*                                                                     *\n*            R7       - RETURN ADDRESS                                *\n*                                                                     *\n*      ALL RECORDS BETWEEN SEQ1 TO SEQ2 INCLUSIVE ARE RELOCATED       *\n*      TO SEQ2 + INC2 AND AFTER.  UPON RETURN THERE WILL BE NO        *\n*      RECORDS BETWEEN SEQ1 THROUGH SEQ2 INCLUSIVE.                   *\n*                                                                     *\n*                                                                     *\n*            IMC#INC2 - DISPLACED RECORD INCREMENT                    *\n*                                                                     *\n*                                                                     *\n*    NOTE: 0 < IMC#INC2 <= IMC#INC1 <= CAINCRE                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nIMC$PUSH STM   R0,R7,IMC#PSAV           SAVE R0 - R7\n*  R3 - REQUIRED SPACE\n*  R5 - SEQ1\n*  R6 - SEQ2\n         SPACE 1\n         SR    R3,R3                    INIT SPACE REQUIRED SO FAR\n         ST    R5,NEWKEY                SET INITIAL KEY = SEQ1\n         EDIO  RC,NEWKEY,BUF1           READ RECORD SEQ1 IF EXISTS\n         BZ    IMC$PS1                  BIF FOUND SEQ1 RECORD\n         SPACE 1\nIMC$PLP1 EDIO  RN                       READ NEXT RECORD\n         BNZ   IMC$PCK1                 BIF NO NEXT RECORD\nIMC$PS1  L     R0,BUF1                  GET RECORD READ KEY X\n         SR    R0,R6                    GET X - SEQ2\n         BCTR  R0,0                     DON'T COUNT RECORD X OR SEQ2\n         CR    R0,R3                    ENOUGH SPACE YET?\n         BH    IMC$PCK2                 BIF HAVE ENOUGH SPACE\n         A     R3,IMC#INC2              + SPACE FOR THIS RECORD\n         MVC   NEWKEY,BUF1              SET NEWKEY FOR NEXT READ\n         TM    CAATTN,CAATTNIS          ATTENTION?\n         BZ    IMC$PLP1                 CONTINUE IF NO ATTENTION\n         B     IMC$RET                  ABORT I/M/C IF ATTENTION\n         SPACE 1\nIMC$PCK1 EDIO  RC,MF=B                  WAS EOF, START AT LAST RECORD\n         B     IMC$PCKX\nIMC$PCK2 EDIO  RP,MF=B                  NOT EOF, START AT PREV RECORD\nIMC$PCKX LTR   R3,R3                    ANY RELOCATION REQUIRED?\n         BZ    IMC$PRET                 RETURN IF NONE REQUIRED\n         SPACE 1\nIMC$PLP2 MVC   NEWKEY,BUF1              SET KEY FOR EDIO\n         EDIO  ,NEWKEY,BUF1             READ PREV OR CUR RECORD\n         BNZ   IMC$PRET                 BIF NO PREVIOUS RECORD\n         CL    R5,BUF1                  SEQ1 :: X\n         BH    IMC$PRET                 BIF DONE\n         EDIO  DLT,BUF1                 DELETE RECORD BEING RELOCATED\n         L     R0,BUF1                  GET OLD KEY\n         LR    R1,R3                    N * INC2\n         AR    R1,R6                    + SEQ2\n         ST    R1,BUF1                  SET NEW KEY FOR RECORD\n         BAL   R14,IMC$KCHG             NOTE KEY CHANGE R0 -> R1\n         CR    R1,R0                    CHECK NEW KEY > OLD KEY\n         BH    *+8                      BIF ALL OK\n         EX    0,*       *** LOGIC ERROR ***\n         EDIO  W                        ADD RECORD WITH NEW KEY\n         EDIO  RP,MF=B                  WILL READ PREVIOUS\n         S     R3,IMC#INC2              GET PREV N * INC2\n         TM    CAATTN,CAATTNIS          ATTENTION?\n         BZ    IMC$PLP2                 CONTINUE IF NO ATTENTION\n         B     IMC$RET                  ABORT I/M/C IF ATTENTION\n         SPACE 1\nIMC$PRET LM    R0,R7,IMC#PSAV           RESTORE R0 - R7\n         BR    R7                       AND RETURN\n         SPACE 1\nIMC$ERR  EX    0,*          *** IMC LOGIC ERROR ***\n         SPACE 1\n*  IMC$KCHG - NOTE KEY CHANGE SUBROUTINE.\n*    NOTES KEY CHANGE FROM R0 -> R1; USES R2; R15;\n*    RETURNS TO R14.\n         SPACE 1\nIMC$KCHG LA    R15,XT#CNUM              ADDR OF FIRST SEQ NUMBER\n         LA    R2,(XT#SEQL3-XT#CNUM+4)/4 NUMBER OF SEQUENCE NUMBERS\nIMC$KCHL CL    R0,0(,R15)               IS THIS KEY CHANGING?\n         BE    IMC$KCH1                 BIF THIS KEY CHANGED\nIMC$KCHN LA    R15,4(,R15)              TO NEXT KEY\n         BCT   R2,IMC$KCHL              CHECK THEM ALL\n         BR    R14                      AND RETURN\nIMC$KCH1 ST    R1,0(,R15)               CHANGE THE KEY\n         B     IMC$KCHN                 AND CONTINUE SEARCH\n         DROP  R8                       (IMCRTN)\n         SPACE 2\nSTAXEXIT STM   R14,R12,12(R13)          SAVE REGS\n         L     COMMREG,8(,R1)           GET PTR TO IKJEBECA (WORK AREA)\n         POST  CAATTN,0                 POST ATTEN ECB\n         LM    R14,R12,12(R13)          RESTORE REGS\n         BR    R14                      AND RETURN\n         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - REGISTERS'\n***********************************************************************\n*                                                                     *\n*                          REGISTER EQUATES                           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*      REGISTER EQUATES\nR0       EQU   0                        WORK\nR1       EQU   1                        WORK\nR2       EQU   2                        WORK\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\n*R9      EQU   9                        COMMREG\nR10      EQU   10\n*R11     EQU   11                       BASEREG (MAIN PGM BASE)\nR12      EQU   12\nR13      EQU   13                       SAVE AREA PTR\nR14      EQU   14                       BALR, WORK\nR15      EQU   15                       BALR, RETCODE, WORK\n         SPACE 3\n*  IBM REGISTER EQUATES\nPARMREG0 EQU   0                        PARAMETER POINTER\nPARMREG1 EQU   1                        PARAMETER POINTER\nCOMMREG  EQU   9                        EDIT COMM AREA DSECT BASE\nBASEREG  EQU   11                       PROGRAM BASE\nSAVEREG  EQU   13                       SAVE AREA POINTER\nRETREG   EQU   14                       RETURN TO CALLER\nRETCDREG EQU   15                       RETURN CODE\n         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND -- EDIT COMM DSECT'\n         PRINT NOGEN                    SAVE SOME PAPER\n         IKJEBECA                       COMM AREA DSECT DEF\n         PRINT GEN\n         SPACE 2\nCCNWORD  EQU   CAINSAVE+16              * WORD VALID OVER SUBCOMMANDS *\n         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - WORKAREA DEF'\n***********************************************************************\n*                                                                     *\n*                      FULLSCR WORKAREA DEFINITION                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ORG   CASCWKA                  ORG AT EDIT-PROVIDED WORKAREA\n         SPACE\nTEMPDW   DC    D'0'                     TEMP DW FOR PACK/UNPACK\nTEMPDW2  DC    D'0'                     2ND WORD DOUBLE WORD\nIOLIST   DC    3F'0'                    IKJEBEUT PARM LIST (WORKDS I/O)\nMSGWORK1 DC    4F'0'                    MSG SEGMENT WORKAREA\nMSGWORK2 DC    4F'0'                    MSG SEGMENT WORKAREA\nMSGWORK3 DC    4F'0'                    MSG SEGMENT WORKAREA\nRETCODE  DC    F'0'\nXWORKADR DC    F'0'                     POINTER TO GOTTEN CORE\nGETMFL   GETMAIN EC,LV=256,A=XWORKADR,SP=1,MF=L\nPTPB     PUTLINE  MF=L\nSTPB     STACK MF=L\nSV#SCAN  DC    3A(0)                    SCAN BXH REGS SAVE AREA\nSV#SCANP DC    A(0)                     PREV SCAN PTR FOR CUR POS\nNEWKEY   DC    F'0'                     EDIO NEW KEY AREA\nRET#SAVE DC    F'0'                     IMC MAINLINE RETURN ADDR SAVE\nSTAXPARM STAX  0,USADDR=0,REPLACE=NO,MF=L STAX PARM LIST\n         SPACE 2\nLEFTOVER EQU   CABFRPL-*                BYTES LEFT IN WORKAREA\nLWORK    EQU   *-CASCWKA                LENGTH OF WORKAREA\n         SPACE 4\nBUF1     EQU   CABFRPL                  528 BYTES\nTBUF1    EQU   CATEMPBF                 528 BYTES (TEMPORARY)\n         EJECT\nLN#LINE  DSECT                          LINE CONTROL ENTRY\nLN#PARM  DC    F'0'                     RECORD NUMBER IF DATA LINE\nLN#RIN   DC    Y(0)                     OFFSET OF INPUT ROUTINE\nLN#ROUT  DC    Y(0)                     OFFSET OF OUTPUT ROUTINE\nLN#FLAG  DC    X'00'                    FLAGS\nLN#FCHG  EQU   X'80'                    CHANGE/FORCE WRITE LINE\nLN#FNTAB EQU   X'40'                    USE TABS ON LINE\nLN#FVAL  EQU   X'20'                    RECORD EXISTS\nLN#FDAT  EQU   X'10'                    DATA LINE\nLN#FREP  EQU   X'08'                    REPLICATE (NOT INSERT)\nLN#INNUM DC    X'00'                    NUM RECS TO INSERT AFTER THIS\nLN#HTABM DC    H'0'                     HARDWARE TAB BIT MASK\n         DC    F'0'                     <RESERVED>\nLN#LINEL EQU   *-LN#LINE                LENGTH OF ONE LINE ENTRY\n         SPACE 4\nXT#WORK  DSECT\nXT#FLAG  DC    X'00'                    FLAGS\nXT#FSS   EQU   X'80'                    CALL SETSCRN\nXT#FSCN  EQU   X'40'                    SAVE CURNUM OVER EDIT SUBCMD\nXT#FEOF  EQU   X'20'                    EOF MSG ALREADY ON SCREEN\nXT#FECMD EQU   X'10'                    ERASE CMD LINE\nXT#FIMC  EQU   X'08'                    INSERT/MOVE/COPY PENDING\nXT#FVTAM EQU   X'04'                    VTAM TERMINAL\nXT#FSCR  EQU   X'02'                    TERMINAL IN FULLSCR MODE\nXT#SAVF  DC    X'00'                    CONTENTS OF CACFLAG1 ON ENTRY\nXT#SET   DC    X'00'                    TO BE SET IN LN#FLAG\nXT#CLR   DC    X'00'                    TO BE CLEARED IN LN#FLAG\nXT#OPT   DC    X'00'                    OPTIONS\nXT#FNULS EQU   X'08'\nXT#FTABS EQU   X'04'                    USE SOFTWARE TABS IF XT#FTAB\nXT#FTABH EQU   X'02'                    USE HARDWARE TABS IF XT#FTAB\nXT#FTAB  EQU   X'01'                    TABS ON FLAG (SET FROM CATABS)\nXT#SCRL  DC    F'0'                     LINES / SCREEN\nXT#SCRC  DC    F'0'                     COLUMNS / LINE\nXT@END   DC    A(0)                     ADDR PAST END OF XT#WORK\nXT@BUF   DC    A(0)                     ADDR OF XT#BUF\nXT#TPUTF DC    F'0'                     FULLSCR OR CTL FLAGS FOR TPUT\nXT#XOFF  DC    F'0'                     X WINDOW OFFSET TO RIGHT\nXT#SEQL  DC    F'0'                     SEQ FIELD LEN (INCLUDING ATTR)\nXT#IADR  DC    A(0)                     ADDR INPUT LEFT\nXT#ILEN  DC    F'0'                     LEN -1 OF INPUT LEFT\nXT#CMDA  DC    A(0)                     ADDR OF CMD INPUT\nXT#CMDL  DC    F'0'                     LENGTH OF CMD INPUT\nXT@MSG   DC    A(0)                     @ MSG LEN-1, MSG TEXT\nXT#DFT   DC    F'0'                     DEFAULT U,D,L,R OPERANDS\nXT#CNUM  DC    F'0'                     SAVE AREA FOR CACURNUM\nXT#CURSQ DC    F'0'                     REC SEQ # FOR CURSOR POS\nXT#SEQL1 DC    F'0'                     IMC OPERANDS L1,L2,L3\nXT#SEQL2 DC    F'0'                     FOR PENDING MOVE/COPY/DELETE\nXT#SEQL3 DC    F'0'                     (-1 => BEGINING OF DATA SET)\nXT#SEQX3 DC    F'0'                     ORIG VALUE OF L3\nXT#CUR   DC    H'0'                     CURSOR POSITION\nXT#OMSGP DC    H'0'                     OLD MSG POSITION\nXT#AID   DC    X'00'                    AID FROM LAST TGET\nXT#TABC  DC    CL1' '                   TAB CHARACTER\nXT#FMC   DC    X'00'                    'M'|'C'|'D' MOVE/COPY/DELETE\nXT#LINK  LINK  SF=L                     SF=L FORM LINK MACRO\nXT#BLDL  DC    2H'0',CL8' ',XL50'00'    HELP BLDL ENTRY\nXT#BLDLL EQU   *-XT#BLDL                LENGTH OF BLDL ENTRY\nXT#TABTR DC    (256/8)D'0'              SOFT TAB TRT TABLE\n         DC    0D'0'                    END ON DWD BOUNDARY\nXT#PFXL  EQU   *-XT#WORK                FIXED LENGTH PREFIX LENGTH\n         SPACE 1\nXT#LINS  DC    0XL(LN#LINEL)'00'        ONE LINE FORMAT PER\n*                                       LINE ON SCREEN\nXT#BUF   DC    0X'00'                   TGET/TPUT BUFFER (FULLSCR)\n         SPACE 1\n*  NOTE: IMC#WRK IS OVERLAYED OVER XT#BUF.\nIMC#WRK  DSECT ,                        INSERT/MOVE/COPY WORK AREA\nIMC#PSAV DC    8F'0'                    IMC$OUT SAVE AREA R0 - R7\nIMC#INC1 DC    F'0'                     MAIN INCREMENT\nIMC#INC2 DC    F'0'                     DISPLACEMENT INCREMENT\nIMC#BUF1 DC    ((4+4+256)/4)F'0'        I/O BUFFER\nIMC#BUF2 DC    ((4+4+256)/4)F'0'        2ND I/O BUFFER\nIMC#WRKL EQU   *-IMC#WRK                LENGTH OF WORK AREA\n         SPACE 1\nCCNEDFSE CSECT\n         END\n//*KED.SYSLMOD DD DISP=OLD,DSN=SYS1.AOACLPA,SPACE=,UNIT=\n//LKED.SYSIN DD *\n IDENTIFY CCNEDFSE('CS01358')\n NAME     CCNEDFSE\n//*\n//C   EXEC PGM=COMPARE,\n//  PARM='CCNEDFSE,CCNEDFSE'\n//STEPLIB  DD DISP=SHR,DSN=SYS5.MSSLOAD\n//SYSPRINT DD SYSOUT=*\n//I1       DD DISP=(SHR,PASS),DSN=&&GOSET\n//I2       DD DISP=SHR,DSN=SYS1.LPALIB\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCNEDFSH": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x9b\\x00\\x9b\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 155, "newlines": 155, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMASA JOB ACCT,MSGCLASS=A,COND=(0,NE)\n/*ROUTE PRINT WYLBUR\n//ASM EXEC ASMHCL\n//ASM.SYSLIB DD\n//           DD\n//           DD DISP=SHR,DSN=SYS5.MSSMAC\n         MACRO\n&L       SBA3277  &ROW=,&COL=\n         LCLC &TAB\n         LCLA &R,&C\n         LCLA &P,&P1,&P2\n         LCLC &CHAR\n&TAB     SETC      '40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'\n&TAB     SETC '&TAB.50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F'\n&TAB     SETC '&TAB.6061E2E3E4E5E6E7E8E96A6B6C6D6E6F'\n&TAB     SETC '&TAB.F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F'\n&R       SETA &ROW\n&C       SETA &COL\n&POS     SETA ((&ROW-1)*80)+(&C-1)\n&P1      SETA &POS/64\n&P2      SETA &POS-(&P1*64)\n&CHAR    SETC '&TAB'(2*&P1+1,2).'&TAB'(2*&P2+1,2)\n         DC   X'11&CHAR'\n         MEND\n         TITLE 'F S E H E L P   --  HELP SUBSUBCOMMAND'\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  C C N E D F S H --                                                 *\n*  THIS MODULE PROVIDES THE HELP DISPLAY FOR THE TSO EDIT FULLSCREEN  *\n*  SUBCOMMAND (FSE).                                                  *\n*                                                                     *\n*   WRITTEN: AUGUST 4, 1978                                           *\n*   BY: CHRIS THOMAS / MICHAEL STEIN                                  *\n*       OFFICE OF ACADEMIC COMPUTING                                  *\n*       U C L A                                                       *\n*                                                                     *\n***********************************************************************\n         SPACE 4\nCCNEDFSH CSECT\n         USING CCNEDFSH,R15\n         B     START\n         DROP  R15\n         DC    AL1($CRL)\n$CR      DC    C'CCNEDFSH/COPYRIGHT.UCLA.1978,1979,1980'\n$CRL     EQU   *-$CR\nSTART    STM   R14,R12,12(R13)\n         LR    R12,R15                  BASEREG\n         USING CCNEDFSH,R12\n         LR    R14,R13                  SAVE CALLER'S WORKAREA\n         LR    R13,R1                   LOAD @(WORKAREA)\n         USING WORKAREA,R13\n         ST    R14,SAVEAREA+4           CHAIN\n         ST    R13,8(,R14)              CHAIN\n         SPACE 4\n         LA    R0,TPUT#L1               LENGTH\n         LA    R1,TPUT#B1               ADDRESS\n         O     R1,=X'03000000'          FULLSCR MODE\n         SVC   93                       TPUT\n         LTR   R15,R15                  DID IT WORK?\n         BZ    *+8                      YES\n         EX    R0,*                     NO\n         SPACE 4\n         LA    R0,L'TGET#B1             LENGTH\n         LA    R1,TGET#B1               ADDRESS\n         O     R1,=X'80000000'          EDIT MODE\n         SVC   93                       TGET (TO PAUSE)\n         TCLEARQ  INPUT                 THROW AWAY ANYTHING LEFT OVER\n         SPACE 4\n         L     R13,SAVEAREA+4           RELOAD CALLER'S SAVEPTR\n         RETURN (14,12),RC=0            EXIT\n         TITLE 'F S E H E L P   --  FIRST HELP SCREEN'\nTPUT#B1  DC    X'C3'                    WCC (PROTECT, AUTOSKIP)\n         DC    X'115D7F',X'114040'      SPF SIGNAL\n         DC    X'3C404000',X'114040'    ERASE, CURSOR TLC\n         DC    X'1DF8'                  START FIELD, PROTECT + INTEN\n         SBA3277 ROW=01,COL=20\n         DC    C'F U L L S C R E E N   S U B C O M M A N D'\n         SBA3277 ROW=02,COL=80\n         DC    X'1DF0'                  LOW INTENSITY\n         DC    C'FULLSCR (FSE) IS AN EXPERIMENTAL TSO EDIT SUBCOMMAND. *\n               LET THE USER BEWARE.'\n         SBA3277 ROW=05,COL=01\n         DC    C'WINDOW POSITIONING COMMANDS:'\n         SBA3277 ROW=06,COL=05\n         DC    X'1DF8'                  HIGH INTENSITY\n         DC    C'UP (U), DOWN (D), RIGHT (R), LEFT (L)'\n         SBA3277 ROW=07,COL=06\n         DC    C'TOP (T), BOTTOM (B)'\n         SBA3277 ROW=08,COL=06\n         DC    C'POSITION (P), COL, SEQ'\n         SBA3277 ROW=09,COL=80\n         DC    X'1DF0'                  LOW INTENSITY\n         DC    C'LINE MODIFICATION COMMANDS: (TYPE OVER SEQUENCE #)'\n         SBA3277 ROW=11,COL=05\n         DC    X'1DF8'                  HIGH INTENSITY\n         DC    C'I#  -- INSERTS BLANK LINES'\n         SBA3277 ROW=12,COL=06\n         DC    C'D   -- DELETES INDICATED LINE'\n         SBA3277 ROW=13,COL=06\n         DC    C'R#  -- REPLICATES INDICATED LINE'\n         SBA3277 ROW=14,COL=06\n         DC    C'CHANGING LINE NUMBER MOVES LINE'\n         SBA3277 ROW=15,COL=80\n         DC    X'1DF0'                 LOW INTENSITY\n         DC    C'RANGE MODIFICATION COMMANDS (TYPE ON COMMAND LINE)'\n         SBA3277 ROW=17,COL=05\n         DC    X'1DF8'\n         DC    C'FMOVE (FMO) -- MOVE RANGE OF LINES'\n         SBA3277 ROW=18,COL=06\n         DC    C'FCOPY (FCO) -- COPY RANGE OF LINES'\n         SBA3277 ROW=19,COL=06\n         DC    C'FDELETE (FDEL) -- DELETE RANGE OF LINES'\n         SBA3277 ROW=20,COL=80\n         DC    X'1DF0'                  LOW INTENSITY\n         DC    C'IN ADDITION, ANY'\n         DC    X'1DF8'                  HIGH INTENSITY\n         DC    C'EDIT'\n         DC    X'1DF0'                  LOW INTENSITY\n         DC    C'SUBCOMMAND MAY BE ENTERED.'\n*        SBA3277 ROW=20,COL=33\n*        DC    X'1DF0'                  LOW INTENSITY\n*        DC    C'PFK DEFINITIONS:'\n*        SBA3277 ROW=21,COL=12\n*        DC    X'1DF8'                  HIGH INTENSITY\n*        DC    C'ATTN     RESHOW        HELP     *        END'\n*        SBA3277 ROW=22,COL=18\n*        DC    C'                  *        *        *'\n*        SBA3277 ROW=23,COL=18\n*        DC    C'                  UP       DOWN     *'\n*        SBA3277 ROW=24,COL=18\n*        DC    C'                  RIGHT    LEFT     HOME'\n         SBA3277 ROW=24,COL=05\n         DC    C'PFKS: '\n         DC    X'1DF8',C'1',X'1DF0',C'(HELP),'\n         DC    X'1DF8',C'3',X'1DF0',C'(EXIT),'\n         DC    X'1DF8',C'7',X'1DF0',C'(UP),'\n         DC    X'1DF8',C'8',X'1DF0',C'(DOWN),'\n         DC    X'1DF8',C'10',X'1DF0',C'(LEFT),'\n         DC    X'1DF8',C'11',X'1DF0',C'(RIGHT)'\n         SBA3277 ROW=1,COL=1\n         DC    X'13'                    INSERT CURSOR\nTPUT#L1  EQU   *-TPUT#B1                LENGTH TO BE WRITTEN\n         TITLE 'F S E H E L P   --  DSECTS, ETC.'\n         LTORG\n         SPACE 1\n         OACREGS ,\n         SPACE 1\n         DSECT\nWORKAREA DS    0D\nSAVEAREA DS    9D\nTGET#B1  DS    XL80\n         END\n//*KED.SYSLMOD DD DISP=SHR,DSN=SYS1.OACLINK(CCNEDFSH),SPACE=\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CMSLOAD": {"ttr": 2315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x01\\x9a\\x01\\x9a\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 410, "newlines": 410, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMASC JOB CSYSMAS,MSGCLASS=A,COND=(0,NE)\n/*ROUTE PRINT WYLBUR\n//ASM EXEC ASMHCL\n//ASM.SYSLIB DD\n//           DD\n//           DD DISP=SHR,DSN=SYS5.MSSMAC\n*---------------------------------------------------------------------*\n*                                                                     *\n* CMSLOAD - RE-LOAD TO MVS FORMAT FILES DUMPED WITH CMS \"DISK DUMP\"   *\n*                                                                     *\n*  INPUT:  IN  - \"DISK DUMP\" FORMAT FILE FROM CMS                     *\n*                                                                     *\n*  OUTPUT: OUT  - MVS FORMAT OUTPUT FILE                              *\n*                                                                     *\n*   USES OUTPUT LRECL AS INPUT LRECL IF SUPPLIED;                     *\n*   ELSE DEFAULTS INPUT LRECL TO 80 IF RECFM F, 137 IF RECFM V.       *\n*                                                                     *\n*   UPDATED FOR 'SPARSE' SUPPORT, MARKED '*S*'.                       *\n*                                                                     *\n* 07/15/82 - JCJ1 - RECORD BUFFER AREA INCREASED TO 32K (AFTER FIX JCJ1\n*                   OF OACENTER MACRO.                             JCJ1\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         OACWORK &DUMMY\nW#CLR    DC    0D'0'              START OF ZEROED AREA\nW#FLAG   DC    F'0'               FLAGS\nWF#EOF    EQU   X'80'              EOF ON IN\nW#CNTIN  DC    F'0'               RECORDS READ\nW#CNTOUT DC    F'0'               RECORDS WRITTEN\nW#PARMN  DC    F'0'               PARM VALUE (NUMBER OF RECORDS)\nW#LRECL  DC    F'0'               OUTPUT RECORD LENGTH FOR F\nW#SEGPT  DC    A(0)               CURRENT SEGMENT POINTER\nW#SEGLN  DC    F'0'               CURRENT SEGMENT LENGTH LEFT\nW#WTO    DC    CL140' '           WTO WORK AREA\nW#LINE   DC    CL133' '           LINE WORK AREA\nW#FCARD  DC    CL80' '            FIRST INPUT CARD WITH CMS ID\nW#OUTESV DC    16F'0'             DCB EXIT REG SAVEAREA\nW#DWD    DC    D'0'\n         SPACE 1\nW#REC    DC    0D'0'              RECORD BUILD AREA\n         ORG   *+(32*1024)                                         JCJ1\nW#RECL   EQU   *-W#REC            MAX RECORD LENGTH\nW#CLRL   EQU   *-W#CLR            END OF ZEROED AREA\n         MEND\n         SPACE 1\nCMSLOAD  OACENTER EXIT=(EXIT,(R15)),PARM=(R9,LR),                      X\n               WORK=(0,MPARM),DSECT=W#,                                X\n               STACK=(2048,W#STACK,E$OFLOW,ABEND),ROUND=YES\n         SPACE 1\n         LA    R0,W#CLR\n         L     R1,=A(W#CLRL)\n         SR    R15,R15\n         MVCL  R0,R14\n         MVI   W#LINE,C' '\n         MVC   W#LINE+1(L'W#LINE-1),W#LINE\n         SPACE 1\n         L     R3,0(,R9)          @ PARM STRING\n         LH    R4,0(,R3)          LENGTH OF PARM STRING\n         LTR   R4,R4              ANY PARM?\n         BZ    IT$OPN             BIF NO PARM\n         TM    2(R3),X'F0'        LOOK LIKE NUMBER?\n         BNO   IT$OPN\n         BCTR  R4,0\n         EX    R4,IT$PACK         PACK W#DWD(8),2(0,R3)\n         OI    W#DWD+7,X'0F'\n         CVB   R0,W#DWD\n         ST    R0,W#PARMN         SAVE PARM NUMBER OF RECORDS\n         SPACE 1\nIT$OPN   OPEN  MF=(E,OPENIN)      OPEN ALL DATASETS\n         TM    DCBOFLGS-IHADCB+DCBIN,DCBOFOPN\n         BZ    ABND99\n         SPACE 1\n*---           INIT GETSEG / GET WITH A NULL CALL                  ---*\n         SR    R0,R0              OUTPUT ADDR ZERO\n         SR    R1,R1              REQUEST ZERO BYTES\n         OACCALL GETSEG           INIT GETSEG / GET\n         BNZ   I$INVINP           BIF EOF (THIS IS INVALID)\n         OPEN  MF=(E,OPENOUT)     NOW OPEN / SET DEFAULTS IF REQUIRED\n         TM    DCBOFLGS-IHADCB+DCBOUT,DCBOFOPN\n         BZ    ABND99\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*  BUILD UP RECORD FROM SEGMENTS ---                                  *\n*  - IF RECFM IS                                                      *\n*       V       - ASK FOR 2 BYTES                                     *\n*               - ASK FOR LENGTH SUPPLIED IN 1ST TWO BYTES            *\n*       F       - ASK FOR LRECL                                       *\n*       S       - ASK FOR LRECL                                   *S* *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nIV$FILE  CLI   CC#RECFM-CMSCARD+W#FCARD,C'F' RECFM F?\n         BE    IF$LOOP            BIF RECFM F\n         CLI   CC#RECFM-CMSCARD+W#FCARD,C'S' RECFM S (SPARSE F)?    *S*\n         BE    IF$LOOP            BIF RECFM S                       *S*\n         CLI   CC#RECFM-CMSCARD+W#FCARD,C'V' RECFM V?\n         BNE   I$INVRFM           BIF INVALID RECFM\n         SPACE 1\n*---                    RECFM V PROCESSING                         ---*\nIV$LOOP  LA    R0,W#REC           PLACE FOR RECORD LENGTH (RECFM V)\n         LA    R1,2               ASK FOR 2 BYTES (RECORD LENGTH)\n         OACCALL GETSEG,ERROR=DONE GET SEGMENT\n         LH    R2,W#REC           GET RECORD LENGTH\n         LTR   R2,R2              ANY RECORD (PADDING AT END?)\n         BZ    DONE\n         CL    R2,=A(W#RECL-16)   RECORD TOO LONG?\n         BNH   *+8                BIF RECORD TOO LONG\n         EX    0,*                * INVALID RECFM V RECORD\n         LR    R1,R2              RECORD LENGTH\n         LA    R0,W#REC           RECORD AREA\n         OACCALL GETSEG,ERROR=DONE GET RECORD\n         LA    R0,W#REC           ADDR OF RECORD FOR OUTPUT\n         LR    R1,R2              LENGTH OF RECORD FOR OUTPUT\n         OACCALL PUT              OUTPUT THE RECORD\n         B     IV$LOOP\n         SPACE 1\n*---                    RECFM F PROCESSING                         ---*\nIF$LOOP  LA    R0,W#REC           PLACE FOR RECORD LENGTH (RECFM V)\n         L     R2,W#LRECL         ASK FOR ONE RECORD\n         CL    R2,=A(W#RECL)\n         BNH   *+8\n         L     R2,=A(W#RECL)\n         LR    R1,R2\n         OACCALL GETSEG,ERROR=DONE GET RECORD\n         CLI   W#REC,0            HEX ZERO TYPE RECORD?\n         BNE   IF$PUT             BIF NOT GARBAGE AT END\n         CLC   W#CNTOUT,W#PARMN   HAVE REQUESTED RECORDS YET?\n         BE    DONE               BIF HAVE ALL RECORDS; DONE\nIF$PUT   LA    R0,W#REC           ADDR OF RECORD FOR OUTPUT\n         LR    R1,R2              LENGTH OF RECORD FOR OUTPUT\n         OACCALL PUT              OUTPUT THE RECORD\n         B     IF$LOOP\n         SPACE 1\nIT$PACK  PACK  W#DWD(8),2(0,R3)   * EXECUTED *\n         EJECT ,\nDONE     LA    R2,MSG1\n         LA    R3,W#CNTIN\n         LA    R4,2\nEOF1     L     R0,0(,R3)\n         CVD   R0,W#DWD\n         MVC   W#LINE+1(10),=X'40202020202020202120'\n         ED    W#LINE+1(10),W#DWD+3\n         MVC   W#LINE+15(30),0(R2)\n         OACCALL PRINT\n         LA    R2,30(,R2)\n         LA    R3,4(,R3)\n         BCT   R4,EOF1\n         SPACE 1\n         CLOSE MF=(E,OPENIN)\n         CLOSE MF=(E,OPENOUT)\n         SR    R15,R15\n         B     EXIT\n         SPACE 1\nABND99   ABEND 99,DUMP\n         SPACE 1\nI$INVINP MVC   W#LINE(40),=C'INVALID INPUT, NO CMS DISK RECORDS FOUND'\n         B     I$INVMSG\nI$INVRFM MVC   W#LINE(32),=C'INVALID RECFM IN CMS DISK RECORD'\n         MVC   W#LINE+34(1),CC#RECFM-CMSCARD+W#FCARD\nI$INVMSG OACCALL PRINT\n         CLOSE MF=(E,OPENIN)\n         CLOSE MF=(E,OPENOUT)\n         ABEND 97,DUMP\n         OACDROP R10\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*  GETSEG: GET NEXT LOGICAL INPUT INPUT DATA SEGMENT                  *\n*                                                                     *\n*   ENTRY: R0  - ADDR FOR SEGMENT REQUESTED                           *\n*          R1  - LENGTH OF SEGMENT REQUESTED                          *\n*          R14 - RETURN ADDRESS                                       *\n*          R15 - @ GET                                                *\n*                                                                     *\n*   EXIT:  R15 - RETURN CODE (0 - OK, 4 - EOF, 8 - ERROR)             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nGETSEG   OACSUB INUSE=NO\n         LR    R6,R0              SAVE ADDR TO PLACE SEGMENT\n         LR    R9,R1              SAVE MAXIMUM LENGTH REQUESTED\n         SPACE 1\nGS$LOOP  LM    R2,R3,W#SEGPT      ADDR, LENGTH OF SEGMENT LEFT\n         LTR   R3,R3              ANY SEGMENT LEFT?\n         BNZ   GS$MOV             BIF HAVE PREVOUS DATA, MOVE IT\nGS$GET   OACCALL GET,ERROR=GS$RET GET NEXT INPUT SEGMENT, RIF EOF\n         B     GS$LOOP            AND RETRY WITH NEW SEGMENT\n         SPACE 1\nGS$MOV   LR    R0,R2              FROM ADDR\n         LR    R1,R3              FROM LEN, ASSUME ENTIRE SEGMENT\n         CR    R1,R9              THIS MORE THAN REQUESTED?\n         BNH   *+6                BIF NOT MORE THAN REQUESTED\n         LR    R1,R9              ELSE ONLY RETURN REQUESTED LENGTH\n         AR    R2,R1              BUMP INPUT SEGMENT PTR\n         SR    R3,R1              DCR INPUT SEGMENT LENGTH LEFT\n         LR    R7,R1              SET TO LENGTH\n         SR    R9,R1              DCR REQUESTED LENGTH\n         MVCL  R6,R0              MOVE SEGMENT TO REQUESTERS BUFFER\n         LTR   R9,R9              ANY MORE REQUESTED?\n         BNZ   GS$GET             BIF MORE NEEDED, GET MORE\n         STM   R2,R3,W#SEGPT      SAVE SEGMENT LEFT ADDR,LEN\n         SR    R15,R15            RETURN CODE ZERO\nGS$RET   OACRET (R15)             AND RETURN\n         OACDROP R10\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*  GET: LOCATE NEXT INPUT CARD                                        *\n*                                                                     *\n*   ENTRY: R14 - RETURN ADDRESS                                       *\n*          R15 - @ GET                                                *\n*                                                                     *\n*   EXIT:  R1  - @ OF NEXT CARD                                       *\n*          R15 - RETURN CODE (0 - OK, 4 - EOF)                        *\n*     W#SEGPT, W#SEGLN SET IF INPUT CARD STARTS WITH X'02',C'CMS'.    *\n*     W#FCARD SET IF THIS IS FIRST X'02',C'CMS' CARD IN INPUT.        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nGET      OACSUB INUSE=NO\n         SR    R2,R2              NO SEGMENT YET\n         SR    R3,R3\n         L     R8,=A(DCBIN)       @ INPUT DCB\n         GET   (R8)               LOCATE NEXT INPUT RECORD (OR EOF)\n         LA    R0,1               COUNT RECORD\n         AL    R0,W#CNTIN\n         ST    R0,W#CNTIN\n         OACUSING CMSCARD,R1\n         CLI   CC#ID,X'02'        CMS DISK CARD?\n         BNE   G$NSAV\n         CLC   CC#CMS,=C'CMS'     REALLY DISK CARD?\n         BNE   G$NSAV\n         CLI   CC#RECFM,C'F'      ONLY HAS DATA IF\n         BE    G$SEG\n         CLI   CC#RECFM,C'S'      ONLY HAS DATA IF                  *S*\n         BE    G$SEG                                                *S*\n         CLI   CC#RECFM,C'V'       SAYS RECFM V OR F\n         BNE   G$CKEND            BIF NOT RECFM V OR F DATA CARD\nG$SEG    LA    R2,CC#DATA         ADDR OF DATA\n         LA    R3,L'CC#DATA       LENGTH OF DATA\n         STM   R2,R3,W#SEGPT      SAVE THIS SEGMENT INFO\n         CLI   W#FCARD,0          HAVE FIRST CARD ALREADY?\n         BNE   G$NSAV\n         MVC   W#FCARD,CMSCARD    SAVE CARD\nG$NSAV   SR    R15,R15            RETURN CODE ZERO\nG$RET    STM   R2,R3,W#SEGPT      RETURN SEGMENT IF ANY FOUND\n         OACRET RC=(R15)\n         SPACE 1\nG$CKEND  CLI   CC#RECFM,C'N'      END CARD?\n         BNE   G$NSAV             BIF UNKNOWN CARD, JUST SKIP\n         XC    W#FCARD,W#FCARD    NEW LOGICAL FILE, NO FIRST CARD LEFT\n         LA    R15,4              LOGICAL EOF\n         B     G$RET               AND RETURN\n         SPACE 1\nGET$EOF  OI    W#FLAG,WF#EOF      SET EOF FLAG\n         LA    R15,4              EOF\n         LCR   R15,R15            -4 FOR EOF\n         B     G$RET\n         OACDROP R10,R1\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*  RECPUT - PUT RECORD                                                *\n*                                                                     *\n*   ENTRY: R0  - ADDR OF RECORD                                       *\n*          R1  - LENGTH OF RECORD                                     *\n*                                                                     *\n*   (IGNORE CALL IF OUTPUT DCB NOT OPEN)                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nPUT      OACSUB INUSE=NO\n         LR    R2,R0              ADDR OF RECORD\n         LR    R3,R1              LENGTH OF RECORD\n         L     R8,=A(DCBOUT)      @ OUTPUT DCB\n         OACUSING IHADCB,R8\n         LA    R0,1               COUNT OUTPUT RECORD\n         AL    R0,W#CNTOUT\n         ST    R0,W#CNTOUT\n         LH    R5,DCBLRECL        ASSUME RECFM=F\n         TM    DCBRECFM,DCBRECV\n         BZ    P$PUT2             BIF RECFM=F\n         LA    R5,4(,R3)          ASSUME RECFM=V\n         TM    DCBRECFM,DCBRECF\n         BZ    P$PUT1             BIF RECFM=V\n         LR    R5,R3              ELSE RECFM=U\nP$PUT1   STH   R5,DCBLRECL        SET LRECL FOR PUT LOCATE\nP$PUT2   PUT   (R8)\n         LA    R4,0(,R1)          @ OUTPUT AREA\n         SPACE 1\n         TM    DCBRECFM,DCBRECF   RECFM=V?\n         BNZ   P$PUT3             BIF NOT RECFM=V\n         LA    R4,4(,R4)          BUMP OUTPUT PTR OVER RDW\n         SH    R5,=H'4'           DCR OUTPUT DATA LENGTH\n         SPACE 1\nP$PUT3   CR    R3,R5              INPUT LEN > OUTPUT LEN?\n         BNH   P$PUT4\n         LR    R3,R5              TRUNCATE LONG INPUT RECORD\nP$PUT4   TM    DCBRECFM,DCBRECF   RECFM=V?\n         BO    P$PUT5             BIF NOT RECFM=V\n         LA    R0,4(,R5)          LENGTH OF RECORD INCLUDING RDW\n         SLL   R0,16\n         ST    R0,0(,R13)\n         MVC   0(4,R1),0(R13)     INIT RDW\nP$PUT5   MVCL  R4,R2              MOVE RECORD DATA TO OUTPUT AREA\nP$RET    OACRET ,\n         OACDROP R10,R8\n         EJECT ,\nPRINT    OACSUB INUSE=NO\n         MVC   W#WTO(P#WTOL),P#WTO\n         MVC   W#WTO+P#MSG(P#WTOL-P#MSG-4),W#LINE\n         WTO   MF=(E,W#WTO)\n         MVI   W#LINE,C' '\n         MVC   W#LINE+1(L'W#LINE-1),W#LINE\n         OACRET ,\n         OACDROP R10\n         SPACE 1\nP#WTO    WTO   'OAC999I (CMSLOAD) -                                    X\n                                         ',MF=L,ROUTCDE=(11)\nP#WTOL   EQU   *-P#WTO\nP#MSG    EQU   4+20\n         SPACE 1\n         OACUSING OUTEXIT,R15\n         OACUSING IHADCB,R1\nOUTEXIT  STM   R0,R15,W#OUTESV    SAVE ALL REGS\n*S*      LA    R2,80              ASSUME 80 FOR RECFM F\n*S*      CLI   CC#RECFM-CMSCARD+W#FCARD,C'F' IS THIS F?\n*S*      BE    *+8\n         LA    R2,137             ASSUME 137 FOR V\n         CLI   CC#RECFM-CMSCARD+W#FCARD,C'V' IS THIS V?             *S*\n         BE    *+8                                                  *S*\n         LA    R2,80              ASSUME 80 FOR RECFM F/S           *S*\n         LH    R3,DCBLRECL        OUTPUT LRECL IF ANY SUPPLIED\n         LTR   R3,R3              ANY OUTPUT LRECL?\n         BZ    OE$LRECL           BIF NO OUTPUT LRECL, USE DEFAULT\n         LR    R2,R3              USE USER SUPPLIED LRECL IF F\n         CLI   CC#RECFM-CMSCARD+W#FCARD,C'V' IS THIS V?\n         BNE   OE$LRECL           BIF NOT RECFM V\n         LA    R2,4(,R3)          USE USER SUPPLIED LRECL + 4 IF V\nOE$LRECL STH   R2,DCBLRECL        SET LRECL IN OUTPUT DCB\n         ST    R2,W#LRECL         SET DEFAULT LRECL\n         TM    DCBRECFM,DCBRECU   RECFM F OR V ALREADY?\n         BM    OE$BLKSI           BIF RECFM F OR V\n         NI    DCBRECFM,255-DCBRECV ASSUME RECFM F\n*S*      CLI   CC#RECFM-CMSCARD+W#FCARD,C'F' IS THIS F?\n*S*      BE    OE$BLKSI           BIF IS RECFM F\n         CLI   CC#RECFM-CMSCARD+W#FCARD,C'V' IS THIS V?             *S*\n         BNE   OE$BLKSI           BIF NOT RECFM V                   *S*\n         OI    DCBRECFM,DCBRECV+DCBRECCM SET RECFM V + MACH CTL\n         NI    DCBRECFM,255-DCBRECF NOT RECFM F\nOE$BLKSI LH    R2,DCBLRECL        GET LRECL\n         LH    R5,DCBBLKSI        GET BLKSIZE\n         LTR   R5,R5              ANY BLKSIZE?\n         BNZ   OE$BLK1            BIF HAVE BLKSIZE, JUST ROUND IF RFM F\n         L     R5,=F'6160'        TRY 6160 FOR ALL CASES\n         OI    DCBRECFM,DCBRECBR  SET BLOCKED RECORDS\nOE$BLK1  TM    DCBRECFM,DCBRECV   RECFM F?\n         BO    OE$BLK2            BIF NOT RECFM F\n         SR    R4,R4              CLEAR FOR DIVIDE\n         DR    R4,R2              6160 / LRECL\n         MR    R4,R2              BLKSIZE WHICH IS MULTIPLE OF LRECL\nOE$BLK2  STH   R5,DCBBLKSI        SET BLKSIZE\n         SPACE 1\nOE$RET   LM    R0,R15,W#OUTESV    RESTORE REGS\n         BR    R14\n         OACDROP R15,R1\n         SPACE 1\nOPENIN   OPEN  (DCBIN,(INPUT)),MF=L\nOPENOUT  OPEN  (DCBOUT,(OUTPUT)),MF=L\n         SPACE 1\nMSG1     DC    CL30'RECORDS READ               '\n         DC    CL30'RECORDS WRITTEN           '\n         SPACE 1\n         PRINT NOGEN\nDCBIN    DCB   DDNAME=IN,DSORG=PS,MACRF=GL,EODAD=GET$EOF,              X\n               LRECL=80,RECFM=FB\nDCBOUT   DCB   DDNAME=OUT,DSORG=PS,MACRF=PL,EXLST=OUTEX\n         PRINT GEN\n         SPACE 1\nOUTEX    DC    0F'0',X'85',AL3(OUTEXIT)  OUTPUT FILE DCB EXIT\n         SPACE 1\nCMSCARD  DSECT ,\nCC#ID    DC    X'02'\nCC#CMS   DC    C'CMS'\nCC#RECFM DC    C'F'               'V', 'F', OR 'S'\nCC#DATA  DC    CL50' '            ACTUAL DATA\nCC#BLKNO DC    XL2'0000'\nCC#FN    DC    CL8' '             FILE NAME\nCC#FT    DC    CL8' '             FILE TYPE\nCC#FM    DC    CL3' '             FILE MODE\nCC#SEQNO DC    CL4' '\nCC#L     EQU   *-CMSCARD          LENGTH OF INPUT CARDS\n         SPACE 1\n         PRINT NOGEN\n         DCBD  DSORG=PS\n         END\n//**ED.SYSLMOD DD DISP=OLD,DSN=SYS1.OACLINK,SPACE=,UNIT=\n//LKED.SYSIN   DD *\n     ENTRY    CMSLOAD\n     IDENTIFY CMSLOAD('CS01464')\n     NAME     CMSLOAD$(R)\n//*\n//C   EXEC PGM=COMPARE,\n//  PARM='CMSLOAD$,CMSLOAD'\n//STEPLIB  DD DISP=SHR,DSN=SYS5.MSSLOAD\n//SYSPRINT DD SYSOUT=*\n//I1       DD DISP=(SHR,PASS),DSN=&&GOSET\n//I2       DD DISP=SHR,DSN=SYS1.OACLINK\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPARE": {"ttr": 2566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x06T\\x06T\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 1620, "newlines": 1620, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMASA JOB CSYSMAS,MSGCLASS=A,COND=(0,NE)\n/*ROUTE PRINT WYLBUR\n//COMPARE  EXEC ASMHCL,PARM.LKED='LET,LIST,NCAL,RENT,REUS,REFR'\n//ASM.SYSLIB DD DISP=SHR,DSN=SYS1.MACLIB\n//           DD DISP=SHR,DSN=SYS1.AMODGEN\n//           DD DISP=SHR,DSN=SYS5.MSSMAC\n//ASM.SYSIN DD *\nCOMP     TITLE 'COMPARE: PROGRAM TO COMPARE TWO LOAD MODULES'\n         MACRO\n&LABEL   GETDSA &CLEAR=,&LENGTH=0,&OPTIONS=,&SUBPOOL=1,&BASEREG=10\n         GBLA  &SP\n         GBLB  &LTORG,&PL1,&RECUR,&STMT,&USEDDSA\n         GBLC  &CSECT\n         LCLA  &A\n         LCLB  &B(8)\n         LCLC  &BNAME,&CNAME,&LNGTH\n.A       ANOP\n&A       SETA  &A+1\n&B(1)    SETB  (('&OPTIONS(&A)' EQ 'PL1') OR (&B(1)) OR (&B(2)))\n&B(2)    SETB  (('&OPTIONS(&A)' EQ 'TASK')  OR (&B(2)))\n&B(3)    SETB  (('&OPTIONS(&A)' EQ 'RECURSIVE') OR (&B(3)))\n&B(4)    SETB  (('&OPTIONS(&A)' EQ 'STMTNO') OR (&B(4)))\n&B(5)    SETB  (('&OPTIONS(&A)' EQ 'DIFF') OR (&B(5)))\n&B(6)    SETB  (('&OPTIONS(&A)' EQ 'ENTRY')  OR (&B(6)))\n&B(7)    SETB  (('&OPTIONS(&A)' EQ 'NOCSECT') OR (&B(7)))\n&B(8)    SETB  (('&OPTIONS(&A)' EQ 'NODSA') OR (&B(8)))\n.*\n.*   DEFAULT OPTIONS:\n.*      NOT 'PL1'       - NO SPECIAL PL1 CONVENTIONS\n.*      NOT 'TASK'      - NOT PL1 TASKING OPTION ('TASK' IMPLIES 'PL1')\n.*      NOT 'RECURSIVE' - NOT PL1 RECURSIVE (ONLY VALID IF 'PL1')\n.*      NO  'STMTNO'    - PL1 STATEMENT NUMBERS ALLOWED (ONLY IF 'PL1')\n.*      NOT 'DIFF'      - IGNORE 'LENGTH' AND PROVIDE STANDARD DSA\n.*      NO  'ENTRY'     - DO NOT GENERATE ENTRY STATEMENT FOR &LABEL\n.*          'CSECT'     - NEW CSECT (WITH LTORG IF NOT FIRST CSECT)\n.*          'DSA'       - GENERATE A DSA (DYNAMIC STORAGE AREA)\n.*\n         AIF   (&A LE N'&OPTIONS).A\n         AIF   ('&LABEL' NE '').B\n         MNOTE 16,'&&LABEL OMITTED -- MACRO TERMINATED'\n         MEXIT\n.B       ANOP\n&LNGTH   SETC  '72'\n         AIF   (NOT &B(1)).C\n.*       FALLS THRU IF 'PL1' SPECIFIED\n&PL1     SETB  1\n&LNGTH   SETC  '100'\n         AIF   (NOT &B(2)).C\n.*       FALLS THRU IF 'TASK' SPECIFIED\n&LNGTH   SETC  '108'\n.C       AIF   (NOT &B(5)).D\n.*       FALLS THRU IF 'DIFF' SPECIFIED\n&LNGTH   SETC  '&LENGTH'\n.D       ANOP\n&CSECT   SETC  '&LABEL'\n         AIF   (NOT &B(1)).F\n.*       FALLS THRU IF 'PL1' SPECIFIED\n         AIF   (K'&LABEL  LE 7).E\n         MNOTE 8,'EXTERNAL NAME &LABEL TRUNCATED TO 7 CHARACTERS'\n&CSECT   SETC  '&LABEL'(1,7)\n.E       ANOP\n&BNAME   SETC  '&CSECT'.'B'\n&BNAME   DXD   A                        ALLOCATE THE PSEUDO-REGISTER\n         AIF   (NOT &B(3)).F\n.*       FALLS THRU IF 'RECURSIVE' PL1\n&CNAME   SETC  '&CSECT'.'C'\n&CNAME   DXD   F                        ALLOCATE THE PSEUDO-REGISTER\n.F       AIF   (NOT &B(6)).G\n.*       FALLS THRU IF 'ENTRY' SPECIFIED\n         ENTRY &CSECT                   MARK &CSECT AS AN ENTRY POINT\n.G       AIF   (NOT &B(7)).H\n.*       FALLS THRU IF 'NOCSECT' SPECIFIED\n&CSECT   DS    0H                       ENTRY POINT\n         AGO   .J\n.H       AIF   (NOT &LTORG).I\n         LTORG\n         EJECT\n.I       ANOP\n&LTORG   SETB  1\n&CSECT   CSECT                          ENTRY POINT\n.J       USING &CSECT,15                ESTABLISH ADDRESSABILITY\n         SAVE  (14,12),,&CSECT          SAVE CALLER'S REGISTERS\n         AIF   (&B(7)).K\n.*       FALLS THRU IF 'CSECT' SPECIFIED\n         LR    &BASEREG,15              ESTABLISH BASE REGISTER\n         USING &CSECT,&BASEREG          ESTABLISH ADDRESSABILITY\n         AGO   .L\n.K       L     &BASEREG,=A(&SYSECT)     LOAD OLD BASE ADDRESS\n         USING &SYSECT,&BASEREG         ESTABLISH ADDRESSABILITY\n.L       DROP  15                       DROP ENTRY BASE\n         AIF   (&B(8)).R\n.*       FALLS THRU IF A 'DSA' IS TO BE PROVIDED\n         LR    2,13                     CALLER'S SAVE AREA ADDRESS\n         AIF   (&SUBPOOL GT 0).L1\n         L     0,=A(&LNGTH)             LOAD SUBPOOL AND NUMBER\n         AGO   .L2\n.L1      LA    0,&SUBPOOL.(0,0)         LOAD SUBPOOL NUMBER\n         SLL   0,24(0)                  SHIFT TO HIGH ORDER BYTE\n         O     0,=A(&LNGTH)             OR IN 'DSA' LENGTH\n.L2      GETMAIN R,LV=(0)               BUY A 'DSA'\n&USEDDSA SETB  1\n&SP      SETA  &SUBPOOL\n&A       SETA  108\n         AIF   (&B(2)).M\n.*       FALLS THRU IF 'TASK' NOT SPECIFIED\n&A       SETA  100\n         AIF   (&B(1)).M\n.*       FALLS THRU IF 'PL1' NOT SPECIFIED\n&A       SETA  72\n         AIF   ('&CLEAR' EQ '').M\n         AIF   (T'&CLEAR NE 'N').L3\n&A       SETA  &CLEAR\n         AIF   (&A LE 256).M\n&A       SETA  256\n         AGO   .M\n.L3      XC    0(&CLEAR,1),0(1)         CLEAR THE NEW 'DSA'\n         AGO   .M1\n.M       XC    0(&A,1),0(1)             CLEAR THE NEW 'DSA'\n.M1      ST    13,4(0,1)                STORE OLD ADDRESS IN NEW\n         ST    1,8(0,13)                STORE NEW ADDRESS IN OLD\n         LR    13,1                     PLACE NEW ADDRESS IN R13\n         MVC   0(4,13),=A(&LNGTH)       MOVE IN 'DSA' LENGTH\n         AIF   (NOT &B(1)).Q\n.*       FALLS THRU IF 'PL1' SPECIFIED\n&A       SETA  128\n         AIF   (NOT &B(3)).N\n.*       FALLS THRU IF 'RECURSIVE' PL1\n&A       SETA  &A+4\n&RECUR   SETB  1\n.N       AIF   (NOT &B(4)).O\n.*       FALLS THRU IF 'STMTNO' SPECIFIED\n&A       SETA  &A+64\n&STMT    SETB  1\n.O       MVI   0(13),&A                 SET 'DSA' FLAGS\n         LA    1,0(0,0)                 GET THE\n         ORG   *-2                        OFFSET OF\n         DC    QL2(&BNAME)                  THE PSEUDO-REGISTER\n         ST    1,88(0,13)               STORE PSEUDO-REGISTER OFFSET\n         AIF   (NOT &B(3)).P\n.*       FALLS THRU IF 'RECURSIVE' PL1 SPECIFIED\n         L     0,0(1,12)                LOAD OLD PSEUDO-REGISTER\n         ST    0,92(0,13)               SAVE OLD PSEUDO-REGISTER\n.P       ST    13,0(1,12)               STORE NEW PSEUDO-REGISTER\n         AIF   (NOT &B(3)).Q\n.*       FALLS THRU IF 'RECURSIVE' PL1 SPECIFIED\n         LA    1,0(0,0)                 GET THE OFFSET\n         ORG   *-2                        OF THE INVOCATION\n         DC    QL2(&CNAME)                  COUNT PSEUDO-REGISTER\n         STH   1,88(0,13)               SAVE PSEUDO-REGISTER OFFSET\n         L     15,0(1,12)               LOAD OLD INVOCATION COUNT\n         ST    15,84(0,13)              SAVE OLD INVOCATION COUNT\n         LA    15,1(0,15)               ADD 1 TO INVOCATION COUNT\n         ST    15,0(1,12)               STORE NEW PSEUDO-REGISTER\n.Q       LM    15,2,16(2)               RESTORE PASSED REGISTERS\n.R       OACREGS ,                      DEFINE SYMBOLIC REGISTERS\n         MEND\n         SPACE 4\n         MACRO\n&LABEL   FREEDSA &RC=0,&BRC=\n         GBLA  &SP,&STMTNO\n         GBLB  &BADSTMT,&PL1,&RECUR,&STMT,&USEDDSA\n         AIF   ('&RC'(1,1) NE '(').C\n         AIF   ((&RC(1) GE 0) AND (&RC(1) LE 15)).A\n.ERR     MNOTE 8,'RC=&RC INVALID -- MACRO TERMINATED'\n         MEXIT\n.A       AIF   (&RC(1) EQ 15).B\n&LABEL   LR    15,&RC(1)                LOAD THE RETURN CODE\n         AGO   .F\n.B       AIF   ('&LABEL' EQ '').F\n&LABEL   DS    0H                       EXIT PROCEDURE\n         AGO   .F\n.C       AIF   (T'&RC NE 'N').E\n         AIF   (&RC EQ 0).D\n&LABEL   LA    15,&RC.(0,0)             LOAD THE RETURN CODE\n         AGO   .F\n.D       ANOP\n&LABEL   SR    15,15                    CLEAR THE RETURN CODE TO ZERO\n         AGO   .F\n.E       AIF   ('&RC' EQ '').ERR\n&LABEL   L     15,&RC                   LOAD THE RETURN CODE\n.F       AIF   (NOT &USEDDSA).H\n         LR    2,13                     SAVE CURRENT SAVE AREA ADDRESS\n         L     13,4(0,13)               LOAD OLD SAVE AREA ADDRESS\n         STM   15,1,16(13)              SAVE RETURN REGISTERS\n         AIF   (NOT &PL1).G\n         LH    1,90(0,2)                PSEUDO-REGISTER OFFSET\n         L     0,92(0,2)                OLD PSEUDO-REGISTER\n         ST    0,0(1,12)                RESTORE OLD PSEUDO-REGISTER\n         AIF   (NOT &RECUR).G\n         LH    1,88(0,2)                INVOCATION COUNT P-R OFFSET\n         L     0,84(0,2)                OLD INVOCATION COUNT\n         ST    0,0(1,12)                RESTORE INVOCATION COUNT P-R\n.G       MVI   0(2),&SP                 MOVE SUBPOOL NUMBER WITH LENGTH\n         L     0,0(0,2)                 LOAD SUBPOOL AND LENGTH\n         LR    1,2                      WHERE TO FREE CORE\n         FREEMAIN R,LV=(0),A=(1)        FREE THE DSA CORE\n         AGO   .I\n.H       STM   15,1,16(13)              SAVE RETURN REGISTERS\n.I       LM    14,12,12(13)             RESTORE CALLER'S REGISTERS\n         MVI   12(13),X'FF'             SET COMPLETION INDICATOR\n         AIF   ('&BRC' EQ '').J\n         B     0(14,15)                 BRANCH TO RETURN CODE OFFSET\n         AGO   .K\n.J       BR    14                       RETURN TO CALLER\n.K       ANOP\n&STMTNO  SETA  0\n&BADSTMT SETB  0\n&PL1     SETB  0\n&RECUR   SETB  0\n&STMT    SETB  0\n&USEDDSA SETB  0\n         MEND\n         SPACE 4\n         MACRO\n         RCRD  &A,&B\n         ORG   TRTTABLE+X'&A'\n         DC    X'&B'\n         ORG   ,\n         MEND\n         MACRO\n         BLDLLIST\nBLDLLIST DSECT\nBLDLCNT  DC    H'1' .                   NUMBER OF ENTRIES\nBLDLLEN  DC    H'64' .                  LENGTH OF ENTRY\nBLDLNAME DC    CL8' ' .                 MODULE NAME\nBLDLTTRC DC    F'0' .                   TTRC OF MEMBER\nBLDLLIB  DC    X'00' .                  LIBRARY\nBLDLIND1 DC    X'00' .                  INDICATORS AND LENGTH\nBLDLTTRT DC    3X'00' .                 TTR OF TEXT RECORD\nBLDLZ1   DC    X'00' .                  ZEROS\nBLDLTTRN DC    3X'00' .                 TTR OF NOTE/SCTR LIST\nBLDLNL   DC    X'00' .                  # ENTRIES IN NOTE LIST\n         SPACE 1\nBLDLATR1 DC    X'00' .                  ATTRIBUTES\nBLDLRENT EQU   X'80' .                  REENTERABLE\nBLDLREUS EQU   X'40' .                  REUSABLE\nBLDLOVLY EQU   X'20' .                  OVERLAY\nBLDLTEST EQU   X'10' .                  TESTRAN\nBLDLOL   EQU   X'08' .                  ONLY LOADABLE\nBLDLSCTR EQU   X'04' .                  SCTR FORMAT\nBLDLEXEC EQU   X'02' .                  EXECUTABLE\n         SPACE 1\nBLDLATR2 DC    X'00' .                  ATTRIBUTES, 2ND BYTE\nBLDLSIZE DC    3X'00' .                 LENGTH OF MODULE\n         ORG   BLDLNAME+38\nBLDLIAS  DC    CL8' ' .                 ALIAS NAME FOR RENT MODULE\nBLDLTOT  EQU   68\n         MEND\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*        PROGRAM: COMPARES TWO LOAD MODULES OR PARTS OF LOAD MODULES. *\n*                                                                     *\n*        METHOD:  ACTS AS A PSEUDO-LOADER.  BUYS AND CLEARS TWO CORE  *\n*                 AREAS INTO WHICH THE MODULES' TEXT BLOCKS ARE READ. *\n*                 RELOCATABLE REFERENCES ARE RESOLVED USING A COMMON  *\n*                 EXTERNAL SYMBOL TABLE TO SOLVE THE PROBLEMS OF      *\n*                 DIFFERENT CSECT ORDER AND DIFFERENT LOAD POINTS.    *\n*                                                                     *\n*        ATTRIB:  REENTRANT, REUSABLE.                                *\n*                                                                     *\n*        MISSING: CAN'T HANDLE OVERLAY MODULES.                       *\n*                                                                     *\n*        AUTHOR:  LOU P. RIVAS  -  UCLA/CCN.                JUNE 1977 *\n*                                                                     *\n*        PARM='NAME1(OFFSET1),NAME2(OFFSET2),COUNT'                   *\n*  (IF PARM IS OMMITED THEN ALL MODULES ON I1 WILL BE COMPARED        *\n*   WITH CORRESPONDING NAMED MODULES IN I2 AND WTO'S WILL BE DONE     *\n*   TO DDNAME 'WTO')                                                  *\n*                                                                     *\n* --> TTRL XCTL TABLES WILL BE MODIFIED SO DIFFERENT TTRL'S WILL      *\n*     MATCH. (MODULE IS DETERMINED TO HAVE TTRL'S BY MODULE NAME)     *\n*                                                                     *\n*        //I1       DD ...              PDS WITH LOAD MODULE NAME1.   *\n*        //I2       DD ...              PDS WITH LOAD MODULE NAME2.   *\n*        //SNAP     DD SYSOUT=A,...     OUTPUT FILE/MISMATCHES+SNAP.  *\n*        //SYSPRINT DD SYSOUT=A,...     OPTIONAL OUTPUT (NO SNAP).    *\n*        //WTO      DD SYSOUT=A,...     WTO FILE IF NO PARM (ALL)     *\n*                                                                     *\n*        (OFFSET#) IS OPTIONAL AND TAKES THE FORM:                    *\n*               (LABEL) WHERE 'LABEL' IS A CSECT OR ENTRY IN NAME#.   *\n*               (+NUMBER) WHERE 'NUMBER' IS AN OFFSET INTO THE NAME#; *\n*                   'NUMBER' IS ASSUMED HEX AND 'NUMBER.' IS DECIMAL. *\n*               (LABEL+NUMBER) WHICH IS THE OFFSET INTO THE LABEL.    *\n*                                                                     *\n*        COUNT IS OPTIONAL AND TAKES THE FORM 'NUMBER.' OR 'NUMBER'.  *\n*               IF COUNT IS NOT SPECIFIED, THE NUMBER OF BYTES THAT   *\n*               ARE COMPARED IS THE LARGER OF THE TWO MODULE LENGTHS  *\n*               OR THE LARGER OF THE TWO CSECT LENGTHS IF BOTH        *\n*               (OFFSET#) SPECIFY CSECTS, ADJUSTED BY THE LENGTH IN   *\n*               (OFFSET#) AS APPROPRIATE.  COUNT CAN ONLY BE USED TO  *\n*               REDUCE THE COMPARE LENGTH.                            *\n*                                                                     *\n*        IF ANY 'NUMBER' IS INVALID (E.G. OUTSIDE MODULE OR CSECT),   *\n*        IT IS IGNORED.  IF 'LABEL' IS NOT FOUND, IT IS IGNORED.      *\n*                                                                     *\n*        SYNTACTICAL ERRORS WILL CAUSE A 'PARM INVALID' ERROR         *\n*        MESSAGE.  WRONG PARAMETERS WILL CAUSE UNPREDICTABLE RESULTS. *\n*                                                                     *\n* RETURN CODES: 00 - ALL MODULE(S) COMPARED SUCCESSFULLY              *\n*               04 - COMPARE FAILED (AT LEAST 1 IF 'ALL)              *\n*               08 - INITIALIZATION FAILED (LAST MODULE IF 'ALL')     *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*        FLOW OF CONTROL:                                             *\n*                                                                     *\n*          1) ENTER, BUY WORK AREA, AND CHAIN SAVE AREAS.             *\n*          2) PARSE PARM STRING.                                      *\n*          3) 'OPEN' FILES.                                           *\n*          4) 'BLDL', GET CORE FOR TEXT BLOCKS, AND 'FIND' MEMBER.    *\n*          5) CLEAR TEXT BUFFER AND 'READ' ALL MEMBER BLOCKS.         *\n*             A) CLEAR TEXT BUFFER; LENGTH IS FROM BLDLSIZE.          *\n*             B) SET FLAG INDICATING \"NOTE LIST\" PRESENT.             *\n*             C) IF FIRST RECORD IS TEXT, GO READ IT (AT III).        *\n*             D) READ NON-TEXT RECORD.                                *\n*                I) IF EOF THEN CLEAR LABEL IF NOT FOUND AND DONE.    *\n*               II) IF \"NOTE LIST\" RECORD THEN IGNORE IT.             *\n*              III) IF CONTROL THEN READ NEXT TEXT RECORD.            *\n*               IV) IF CESD THEN RESOLVE LABEL AND BUILD COMMON ESD.  *\n*                V) IF RLD THEN RESOLVE RELOCATABLE REFERENCES.       *\n*          6) USE OFFSET# AND COUNT TO INITIALIZE FOR COMPARE LOOP.   *\n*          7) COMPARE TEXT BUFFERS BYTE BY BYTE; OUTPUT EACH UNEQUAL. *\n*          8) 'SNAP' TEXT BUFFERS IF ANY UNEQUALITIES.                *\n*          9) FREE TEXT BUFFERS, 'CLOSE' FILES, AND EXIT.             *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n* UPDATES: 001 - 11/22/78 - 1) ALLOW DDNAME=SYSPRINT AS OPTIONAL      *\n*                              OUTPUT FILE (REPLACES DDNAME=SNAP).    *\n*                              IF SYSPRINT USED, THEN DO MISMATCH     *\n*                              LOGGING, BUT DON'T DO PSEODO-SNAP.     *\n*                           2) IF OUTPUT FILE (SNAP OR SYSPRINT) IS   *\n*                              ALLOCATED TO TSO AS TERMFILE: 1) DON'T *\n*                              OPEN FILE, AND 2) FAKE OUT WRITES TO   *\n*                              GO TO CODE THAT TPUTS THE RECORDS.     *\n*                           3) REMOVE MAIN STORAGE ADDRESSES FROM     *\n*                              MISMATCH LINE SINCE REAL SNAP NO       *\n*                              LONGER USED.                           *\n*          002 - 09/11/79 - 1) FIX 4MEG CONSTANT DEPENDENCY.          *\n*                           2) FIX XCTL TTR RESOLUTION CODE TO        *\n*                              HANDLE SUBLISTS.                       *\n*          003 - 04/23/80 - 1) CONVERT TO MVS.                        *\n*          004 - 12/31/80 - 1) FIX UNPK 0C4 BUG.                      *\n*                           2) ADD TWO NEW RETURN CODES:              *\n*                              04 - COMPARE FAILED.                   *\n*                              08 - INITIALIZATION FAILED.            *\n*          005 - 12/17/81 - 1) FIX UNFINDABLE CSECT BUG - (1 BIT CHG) *\n*                                                                     *\n***********************************************************************\n         EJECT\nCOMPARE  GETDSA SUBPOOL=0,LENGTH=WORKLEN,OPTIONS=DIFF,CLEAR=256\n         SPACE 2\n         USING WORKAREA,R13             ADDRESSABILITY\n         SPACE 2\n         XC    WORKAREA+1*256(256),WORKAREA+1*256 CLEAR\n         XC    WORKAREA+2*256(256),WORKAREA+2*256 CLEAR\n         XC    WORKAREA+3*256(BASELEN-3*256),WORKAREA+3*256 THE REST\n         SPACE 2\nSNAPBLKS EQU   1632                     BLKSIZE FOR 'SNAP' FILE\n         SPACE 2\nSTABCESD EQU   1000                     NUMBER OF CESD TABLE ENTRIES\n         EJECT\n         MVI   RETCODE+3,8              SET INIT FAILED RETCODE     004\n         MVC   DCBWTO(DCBPSQX),DCBPSQ   INITIALIZE WTO DCB\n         MVC   SNAP(DCBPSX),DCBPS       INITIALIZE SNAP DCB\n         MVC   I1(DCBPOX),DCBPO         INITIALIZE FIRST DCB\n         MVC   I2(DCBPOX),DCBPO         INITIALIZE SECOND DCB\n         MVI   I2+DCBDDNAM+1-IHADCB,C'2'  AND CORRECT THE DD NAME\n         MVC   DECB(DECBX),DECBRW       INITIALIZE DECB\n         XC    DCBLIST(16),DCBLIST      INIT OPEN LIST\n         MVI   DCBLIST+8,X'80'          ASSUME NOT 'ALL' OPTION\n         SPACE 2\n         N     R1,=XL4'00FFFFFF'        PARM POINTER WORD THERE ?   002\n         BZ    ERR1                     NO, GO TELL USER\n         L     R1,0(R1)                 LOAD PARM ADDRESS\n         N     R1,=XL4'00FFFFFF'        ANY PARM ?                  002\n         BZ    ERR1                     NO, GO TELL USER\n         LH    R2,0(R1)                 LOAD PARM LENGTH\n         LTR   R2,R2                    ANY PARM ?\n         BNZ   HAVEPARM                 YES, GO PROCESS IT\n         SPACE 1\n         MVI   DCBLIST+8,0\n         MVI   DCBLIST+12,X'80'         OPEN 'WTO' TOO\n         B     OPEN                     GO OPEN DATASETS\n         SPACE 1\nHAVEPARM CH    R2,=H'3'                 LONG ENOUGH ?\n         BL    ERR2                     NO, GO TELL USER\n         LA    R1,2(R1)                 POINT TO PARM PROPER\n         SPACE 1\n         LA    R3,NAME1                 WHERE TO PUT FIRST NAME\n         BAL   R14,NAME                 GO MOVE IT IN\n         SPACE 1\n         LTR   R2,R2                    BACK WITH NOTHING LEFT ?\n         BZ    ERR2                     YES, GO TELL USER\n         LA    R3,NAME2                 WHERE TO PUT SECOND NAME\n         BAL   R14,NAME                 GO MOVE IT IN\n         SPACE 1\n         LTR   R2,R2                    BACK WITH NOTHING LEFT ?\n         BZ    OPEN                     YES, NO COUNT FIELD\n         SPACE 1\n         BAL   R15,NUMBER               GO CONVERT THE COUNT\n         ST    R0,COUNT                 SAVE IT\n         SPACE 1\nOPEN     OPEN  (SNAP,OUTPUT,I1,,I2,,DCBWTO,OUTPUT),MF=(E,DCBLIST)\n         ORG   *-2                      EMBARASSING KLUDGE HERE     001\n         L     R15,=A(OPEN#CHK)         ADDR OF OPEN CHECK CODE     001\n         BALR  R14,R15                  GO DO PRE-OPEN CHECKS       001\n         EJECT\n         TM    SNAP+DCBOFLGS-IHADCB,DCBOFOPN OPEN ?\n         BZ    NOWTO                    NO\n         TM    I1+DCBOFLGS-IHADCB,DCBOFOPN OPEN ?\n         BZ    NOWTO                    NO\n         TM    I2+DCBOFLGS-IHADCB,DCBOFOPN OPEN ?\n         BZ    NOWTO                    NO\n         SPACE 1\n         TM    FLAGS,FG#ALL             PROCESSING ALL MEMBERS?     001\n         BZ    NOTALL                   NO - BRANCH                 001\nALLLOOP  L     R15,=A(GETENT)           @ GETENT ROUTINE\n         BALR  R14,R15                  GO GET MODULE NAME\n         SPACE 2\nNOTALL   LA    R2,NAME1                 DO FIRST ONE\n         LA    R3,ERR3                  ERROR EXIT\n         BAL   R4,BLDLFIND              GO GET CORE FOR MODULE\n         SPACE 1\n         LA    R2,NAME2                 DO SECOND ONE\n         LA    R3,ERR4                  ERROR EXIT\n         BAL   R4,BLDLFIND              GO GET CORE FOR MODULE\n         SPACE 2\n         LA    R2,NAME1                 DO FIRST ONE\n         BAL   R4,CLEAREAD              GO READ IN MODULE\n         SPACE 1\n         LA    R2,NAME2                 DO SECOND ONE\n         BAL   R4,CLEAREAD              GO READ IN MODULE\n         SPACE 1\n         L     R15,=A(SUP)              BASE FOR IOSUP ROUTINE\n         LA    R1,NAME1                 GO FIX TTRL'S MODULE 1\n         BALR  R14,R15\n         LA    R1,NAME2                 AND MODULE 2\n         BALR  R14,R15\n         SPACE 2\n         L     R5,COMPADR1              FIRST MODULE COMPARE START\n         L     R6,COMPADR2              SECOND MODULE COMPARE START\n         L     R7,COMPLEN1              FIRST MODULE COMPARE LENGTH\n         L     R8,COMPLEN2              SECOND MODULE COMPARE LENGTH\n         SPACE 1\n         A     R5,NUMBER1               ADJUST FIRST MODULE\n         A     R6,NUMBER2               ADJUST SECOND MODULE\n         S     R7,NUMBER1               ADJUST FIRST LENGTH\n         S     R8,NUMBER2               ADJUST SECOND LENGTH\n         SPACE 1\n         OC    COUNT,COUNT              COMPARE LENGTH SPECIFIED ?\n         BZ    NOCOUNT                  NO\n         C     R7,COUNT                 NEED TO ADJUST AGAIN ?\n         BNH   *+8                      NO, SKIP NEXT\n         L     R7,COUNT                 ADJUST IT\n         C     R8,COUNT                 NEED TO ADJUST AGAIN ?\n         BNH   *+8                      NO, SKIP NEXT\n         L     R8,COUNT                 ADJUST IT\n         SPACE 2\nNOCOUNT  XR    R2,R2                    INDICATE NO OUTPUT YET\n         SPACE 1\n         LTR   R7,R7                    IS FIRST LENGTH ZERO ?\n         BZ    DONECOMP                 YES, ALMOST FINISHED\n         LTR   R8,R8                    IS SECOND LENGTH ZERO ?\n         BZ    DONECOMP                 YES, ALMOST FINISHED\n         SPACE 2\n         LA    R4,1                     USEFUL CONSTANT\n         EJECT\nCOMPLOOP CLC   0(1,R5),0(R6)            ARE THESE TWO BYTES EQUAL ?\n         BE    NEXTCOMP                 YES, NO OUTPUT THIS TIME\n         SPACE 1\n         BAL   R3,OUTPUT                INDICATE WHERE IT FAILED\n         SPACE 1\nNEXTCOMP AR    R5,R4                    NEXT MODULE1\n         AR    R6,R4                    NEXT MODULE2\n         SPACE 1\n         BCT   R7,*+10                  SKIP NEXT TWO IF MORE MODULE1\n         BCTR  R8,0                     ALSO DECREMENT MODULE2\n         B     DONECOMP                 NEARLY DONE\n         BCT   R8,COMPLOOP              LOOP IF MORE MODULE2\n         SPACE 2\nDONECOMP CR    R7,R8                    LENGTH MISMATCH ?\n         BE    SNAPDUMP                 NO, ALL DONE\n         SPACE 1\n         XR    R4,R4                    INDICATE LENGTH CALL\n         BAL   R3,OUTPUT                INDICATE WHERE IT FAILED\n         SPACE 1\nSNAPDUMP CLI   RETCODE+3,4              PREVIOUS COMPARE BOMBED?    004\n         BE    *+8                      BIF YES - DON'T RESET CODE  004\n         MVI   RETCODE+3,0              SET COMPARE WORKED RETCODE  004\n         LTR   R2,R2                    ANY OUTPUT ?\n         LA    R1,WTO00                 ASSUME 'COMPARES' MESSAGE\n         BZ    WTOX                     NO, ALL DONE\n         SPACE 1\n         MVI   RETCODE+3,4              SET COMPARE FAILED RETCODE  004\n         L     R0,COMPADR1              MODULE1 STARTING ADDRESS\n         LR    R1,R0                    COPY FOR ENDING ADDRESS\n         A     R1,COMPLEN1              ADD LENGTH FOR ENDING ADDRESS\n         BCTR  R1,0                     IT IS INCLUSIVE\n         L     R2,COMPADR2              MODULE2 STARTING ADDRESS\n         LR    R3,R2                    COPY FOR ENDING ADDRESS\n         A     R3,COMPLEN2              ADD LENGTH FOR ENDING ADDRESS\n         BCTR  R3,0                     IT IS INCLUSIVE\n         SPACE 1\n         STM   R0,R3,WRKWRDS            SAVE LIST ADDRESSES\n         SPACE 1\n         LA    R2,2                     LOOP TWO TIMES\n         LA    R1,WRKWRDS               WHERE LISTS START\n         L     R15,=A(SNAPIT)           @ SNAP ROUTINE\nSNAPLOOP BALR  R14,R15                  DUMP IT\n         LA    R1,8(R1)                 NEXT LIST\n         BCT   R2,SNAPLOOP              GO AGAIN\n         SPACE 1\n         XR    R4,R4                    FLUSH LAST OUTPUT BUFFER\n         BCTR  R4,0                       INDICATOR\n         LA    R2,RECORD                SET ADR FOR WRITE IF ANY\n         BAL   R3,OUTPUT                INDICATE ALL DONE\n         EJECT ,\n         SPACE 1\n         LA    R1,WTO01                 'COMPARE FAIL' MESSAGE\n         SPACE 1\nWTOX     MVC   RECORD(256),0(R1)        MOVE THE WTO TO WORK AREA\n         MVC   RECORD+12(8),NAME1       FILL IN THE\n         MVC   RECORD+36(8),NAME2         MODULE NAMES\nWTOY     LA    R1,RECORD                FINISHED WTO\n         SPACE 2\nWTO      TM    FLAGS,FG#ALL             PROCESSING ALL MEMBERS?     001\n         BZ    WTO#                     NO - BRANCH                 001\n         LR    R0,R1                    SET RECORD OUTPUT\n         PUT   DCBWTO,(0)               PRINT THE MSG\n         B     NOWTO                    AND CONTINUE\n         SPACE 1\nWTO#     WTO   MF=(E,(R1))              DONE\n         SPACE 1\nNOWTO    LM    R0,R1,LENGTH1            FIRST MODULE LENGTH AND ADDRESS\n         LM    R2,R3,LENGTH2              AND SAME FOR SECOND MODULE\n         STM   R0,R3,WRKWRDS            SAVE LENGTH AND ADDRESS PAIRS\n         SPACE 1\n         LA    R2,2                     LOOP TWO TIMES\n         LA    R3,WRKWRDS               WHERE PAIRS START\n         SPACE 1\nFREELOOP LM    R0,R1,0(R3)              LOAD LENGTH AND ADDRESS PAIR\n         LTR   R1,R1                    ANYTHING THERE ?\n         BZ    NEXTFREE                 NO, NOTHING BOUGHT\n         SPACE 1\n         FREEMAIN R,LV=(0),A=(1)        FREE BOUGHT CORE\n         SPACE 1\nNEXTFREE LA    R3,8(R3)                 NEXT PAIR\n         BCT   R2,FREELOOP              GO AGAIN\n         SPACE 1\n         XC    FRSTTAB(NEXTTAB-FRSTTAB+L'NEXTTAB),FRSTTAB  CLEAN UP\n         XC    NAME1(BLDL1-NAME1),NAME1 CLEAN UP I1 STUFF\n         XC    NAME2(BLDL2-NAME2),NAME2 AND I2\n         MVI   FLAG,0                   AND ZERO FLAG\n         SPACE 1\n         TM    FLAGS,FG#ALL             PROCESSING ALL MEMBERS?     001\n         BO    ALLLOOP                  YES - GO GET NEXT           001\n         SPACE 1\nALLDONE  CLOSE MF=(E,DCBLIST)           CLOSE ALL FILES OPENED\n         EJECT ,\n         LA    R1,DCBWTO                GET @ DCB FOR FREEPOOL\n         TM    23(R1),1                 ANY BUFFER POOL?\n         BO    NOSWIM                   BRANCH IF NO POOL\n         FREEPOOL (1)                   FREE BUFFER POOL\n         SPACE 1\nNOSWIM   FREEDSA RC=RETCODE             FREE WORKAREA/SET RC/RETURN 004\n         SPACE 2\nERR1     LA    R1,WTO02                 ERROR MESSAGE\n         B     WTO                      DO IT\n         SPACE 1\nERR2     LA    R1,WTO03                 ERROR MESSAGE\n         B     WTO                      DO IT\n         SPACE 1\nERR3     LA    R3,C'1'                  INDICATE LIBRARY\n         B     *+8                      SKIP NEXT\nERR4     LA    R3,C'2'                  ERROR MESSAGE\n         MVC   RECORD(256),WTO04        MOVE THE WTO TO WORK AREA\n         MVC   RECORD+12(8),0(R2)       FILL IN THE\n         STC   R3,RECORD+35               NAME AND LIBRARY\n         MVI   RETCODE+3,4              SET COMPARE FAILED RETCODE  004\n         B     WTOY                     DO IT\n         SPACE 1\nERR5     L     R1,WRKWRDS               GET REQUESTED SIZE\n         LA    R1,1023(R1)              ROUND UP\n         SRL   R1,10                    AND MAKE IT K\n         CVD   R1,WRKWRDS               TO DECIMAL\n         OI    WRKWRDS+7,X'0F'          FIX SIGN\n         UNPK  WRKWRDS(5),WRKWRDS+5(3)  TO PRINTABLES\n         MVC   RECORD(256),WTO05        MOVE THE WTO TO WORK AREA\n         MVC   RECORD+26(5),WRKWRDS     FILL IN THE AMOUNT\n         MVI   RETCODE+3,4              SET COMPARE FAILED RETCODE  004\n         B     WTOY                     DO IT\n         SPACE 1\nERR6     LA    R1,WTO06                 ERROR MESSAGE\n         MVI   RETCODE+3,4              SET COMPARE FAILED RETCODE  004\n         B     WTO                      DO IT\n         EJECT\nNAME     MVI   0(R3),C' '               BLANK THE NAME AND\n         MVC   1(7+8,R3),0(R3)            LABEL RECEIVING FIELDS\n         LA    R4,8(R3)                 SAVE LABEL FIELD START\n         SPACE 1\n         CLI   0(R1),C','               NO NAME ?\n         BE    ERR2                     YES, GO TELL USER\n         CLI   0(R1),C'('               OTHER NO NAME ?\n         BE    ERR2                     YES, GO TELL USER\n         SPACE 1\n         BAL   R15,MOVENAME             COPY NAME\n         B     ERR2                     WRONG SEPARATOR, GO TELL USER\n         LA    R1,1(R1)                 STRIP SEPARATOR\n         BCT   R2,*+8                   DECREMENT REMAINDER\n         B     ERR2                     NOTHING LEFT, GO TELL USER\n         SPACE 1\n         LR    R5,R14                   SAVE RETURN ADDRESS\n         LA    R14,ERR2                 NEW RETURN ADDRESS\n         CLI   0(R1),C')'               ONLY '()' ?\n         BER   R14                      YES, GO TELL USER\n         CLI   0(R1),C'+'               NO LABEL ?\n         BE    NOCSECT                  YES, SKIP THIS THEN\n         SPACE 1\n         LR    R3,R4                    NEW OUTPUT LOCATION\n         BAL   R15,MOVENAME             COPY LABEL\n         B     *+8                      SKIP ERROR RETURN\n         B     ERR2                     WRONG SEPARATOR, GO TELL USER\n         SPACE 1\n         CLI   0(R1),C'+'               OFFSET ?\n         BNE   ENDNAME                  NO, SKIP THIS THEN\n         SPACE 1\nNOCSECT  LA    R1,1(R1)                 STRIP '+' SEPARATOR\n         BCT   R2,*+6                   DECREMENT REMAINDER\n         BR    R14                      NOTHING LEFT, GO TELL USER\n         SPACE 1\n         BAL   R15,NUMBER               GO CONVERT NUMBER\n         ST    R0,8(R4)                 SAVE THE NUMBER\n         LTR   R2,R2                    ANYTHING LEFT ?\n         BZR   R14                      NO, ERROR\n         SPACE 1\nENDNAME  LR    R14,R5                   RESTORE RETURN ADDRESS\n         LA    R1,1(R1)                 STRIP ')' SEPARATOR\n         BCT   R2,*+6                   DECREMENT REMAINDER\n         BR    R14                      NOTHING LEFT, RETURN\n         CLI   0(R1),C','               RIGHT SEPARATOR ?\n         BNE   ERR2                     NO, GO TELL USER\n         SPACE 1\nNAMEEND  LA    R1,1(R1)                 STRIP SEPARATOR\n         BCTR  R2,0                     DECREMENT REMAINDER\n         BR    R14                      RETURN ALL THE WAY\n         EJECT\nMOVENAME LA    R0,9                     LOOP PREVENTION\n         SPACE 1\nNAMELOOP MVC   0(1,R3),0(R1)            MOVE IN A CHARACTER\n         BCT   R2,*+6                   SKIP NEXT IF ANY LEFT\n         BR    R14                      RETURN ALL THE WAY\n         LA    R1,1(R1)                 NEXT INPUT CHARACTER\n         LA    R3,1(R3)                 NEXT OUTPUT LOCATION\n         CLI   0(R1),C','               SEPARATOR ?\n         BE    NAMEEND                  YES, GO STRIP IT OFF\n         CLI   0(R1),C'('               OTHER SEPARATOR ?\n         BE    4(R15)                   YES, RETURN FOR LABEL\n         CLI   0(R1),C'+'               OFFSET SEPARATOR ?\n         BER   R15                      YES, RETURN FOR OFFSET\n         CLI   0(R1),C')'               OFFSET TERMINATOR ?\n         BER   R15                      YES, RETURN AFTER OFFSET\n         BCT   R0,NAMELOOP              GO AGAIN ?\n         B     ERR2                     TELL USER OF PARM ERROR\n         SPACE 5\n         PRINT NOGEN\nWTO00    WTO   'COMP00I XXXXXXXX IS THE SAME AS YYYYYYYY',             *\n               ROUTCDE=11,MF=L\nWTO01    WTO   'COMP01I XXXXXXXX DOES NOT MATCH YYYYYYYY',             *\n               ROUTCDE=11,MF=L\nWTO02    WTO   'COMP02I PARM OMITTED',ROUTCDE=11,MF=L\nWTO03    WTO   'COMP03I PARM INVALID',ROUTCDE=11,MF=L\nWTO04    WTO   'COMP04I XXXXXXXX NOT FOUND IN IY',ROUTCDE=11,MF=L\nWTO05    WTO   'COMP05I NEED AT LEAST XXXXXK MORE CORE',ROUTCDE=11,MF=L\nWTO06    WTO   'COMP06I SYMBOL TABLE TOO SMALL',ROUTCDE=11,MF=L\n         PRINT GEN\n         EJECT\nNUMBER   CLI   0(R1),C'.'               NO NUMBER ?\n         BE    ERR2                     YES, GO TELL USER\n         CLI   0(R1),C')'               OTHER NO NUMBER ?\n         BE    ERR2                     YES, GO TELL USER\n         SPACE 1\n         LA    R3,WRKWRDS+8             NUMBER OUTPUT LOCATION\n         LA    R0,9                     LOOP PREVENTION\n         SPACE 1\nNUMLOOP  IC    R6,0(R1)                 INSERT CHARACTER\n         CLI   0(R1),C'0'               NUMERIC ?\n         BNL   *+8                      YES, NO CONVERT NEEDED\n         LA    R6,X'39'(R6)             CONVERT TO HEX\n         STC   R6,0(R3)                 TO OUTPUT LOCATION\n         LA    R1,1(R1)                 NEXT INPUT CHARACTER\n         LA    R3,1(R3)                 NEXT OUTPUT CHARACTER\n         BCT   R2,*+8                   DECREMENT COUNT\n         B     GOTNUM                   HAVE THE NUMBER\n         CLI   0(R1),C')'               END OF NUMBER ?\n         BE    GOTNUM                   YES, HAVE THE NUMBER\n         BCT   R0,NUMLOOP               GO AGAIN ?\n         B     ERR2                     TELL USER OF PARM ERROR\n         SPACE 1\nGOTNUM   LA    R6,WRKWRDS+8+1           START+1 SUBTRACTED FROM\n         SR    R3,R6                      END YIELDS EXECUTE LENGTH\n         LA    R6,WRKWRDS+8(R3)         LAST CHARACTER IN NUMBER\n         CLI   0(R6),C'.'+X'39'         DECIMAL ?\n         BE    DECIMAL                  YES, EASY CONVERT\n         SPACE 1\n         EX    R3,PACK                  PACK THE HEX\n         MVO   WRKWRDS+8(5),WRKWRDS+3(5) ALIGN THIS GARBAGE\n         L     R0,WRKWRDS+8             LOAD IT\n         BR    R15                      RETURN TO CALLER\n         SPACE 1\nDECIMAL  BCTR  R3,0                     DROP THE '.'\n         EX    R3,PACK                  PACK THE HEX\n         CVB   R0,WRKWRDS               TO BINARY AND LOAD\n         BR    R15                      RETURN TO CALLER\n         SPACE 2\nPACK     PACK  WRKWRDS(8),WRKWRDS+8(0)  << EXECUTED >>\n         EJECT\n         USING LIBWORK,R2               ADDRESSABILITY\n         USING BLDLLIST,R5              ADDRESSABILITY\n         SPACE 1\nBLDLFIND LA    R5,BLDL#                 BLDL LIST AREA\n         SPACE 1\n         MVI   BLDLCNT+1,1              NUMBER OF BLDL ENTRIES\n         MVI   BLDLLEN+1,64             LENGTH OF EACH ENTRY\n         MVC   BLDLNAME,NAME#           MOVE IN NAME\n         SPACE 1\n         BLDL  I#,(R5)                  DO THE BLDL\n         BXH   R15,R15,0(R3)            ERROR, TAKE EXIT\n         SPACE 1\n         CLI   BLDLLIB,0                IN SPECIFIED LIBRARY ?\n         BNER  R3                       NO, TAKE EXIT\n         TM    BLDLIND1,B'00011000'     ENTRY LONG ENOUGH ?\n         BZR   R3                       NO, TAKE EXIT\n         TM    BLDLATR1,BLDLOVLY        INVALID ATTRIBUTE ?\n         BNZR  R3                       YES, TAKE EXIT\n         SPACE 1\n         L     R15,BLDLSIZE             LOAD SIZE OF MODULE (OFFSET 8)\n         SRL   R15,8                    SHIFT TO LOW THREE BYTES\n         ST    R15,LENGTH#              SAVE GETMAIN LENGTH\n         ST    R15,COMPLEN#               AND AS COMPARE LENGTH\n         C     R15,NUMBER#              OFFSET OUTSIDE NUMBER ?\n         BH    *+10                     NO, SKIP NEXT\n         XC    NUMBER#,NUMBER#          IGNORE NUMBER\n         SPACE 1\n         GETMAIN EC,A=ADDRESS#,LV=(R15),SP=0,MF=(E,WRKWRDS) BUY IT\n         BXH   R15,R15,ERR5             EXIT IF ERROR\n         SPACE 1\n         MVC   COMPADR#,ADDRESS#        SAVE AS COMPARE ADDRESS\n         SPACE 2\n         FIND  I#,BLDLTTRC,C            PREPARE TO READ MODULE\n         SPACE 1\n         BR    R4                       RETURN\n         EJECT\nCLEAREAD LA    R5,BLDL#                 BLDL LIST AREA\n         SPACE 1\n         L     R1,LENGTH#               LOAD LENGTH\n         L     R3,ADDRESS#              WHERE TO CLEAR CORE\n         SPACE 1\n         LA    R0,256                   USEFUL CONSTANT\n         SPACE 1\nCLEARLP  CR    R1,R0                    MORE THAN ONE XC ?\n         BNH   CLEARLST                 NO, GO DO LAST XC\n         XC    0(256,R3),0(R3)          CLEAR A PORTION\n         SR    R1,R0                    LESS AMOUNT DONE\n         AR    R3,R0                    NEXT OUTPUT\n         B     CLEARLP                  GO AGAIN\n         SPACE 1\nXC       XC    0(0,R3),0(R3)            << EXECUTED >>\n         SPACE 1\nCLEARLST LTR   R1,R1                    ANYTHING AT ALL TO CLEAR ?\n         BNP   CLEARDN                  NO, ALL DONE\n         BCTR  R1,0                     -1 FOR EXECUTE\n         EX    R1,XC                    CLEAR LAST PORTION\n         SPACE 2\nCLEARDN  L     R3,ADDRESS#              START OF TEXT BUFFER\n         LR    R6,R3                    TEXT BUFFER ADDRESS\n         L     R7,LENGTH#                 AND LENGTH FOR 'FIRST' READ\n         SPACE 1\n         OC    BLDLTTRN(3),BLDLTTRN     ANY NOTE LIST ?\n         BZ    *+8                      NO, SKIP NEXT\n         OI    BLDL#,X'F0'              MARK NOTE LIST\n         SPACE 1\n         CLC   BLDLTTRC(3),BLDLTTRT     IS FIRST RECORD TEXT ?\n         BE    READTEXT                 YES, NO CONTROL RECORD\n         SPACE 2\nNEXTRCRD READ  DECB,SF,I#,RECORD,256,MF=E READ A RECORD\n         CHECK DECB                     WAIT FOR COMPLETION\n         EJECT\n         TM    BLDL#,X'F0'              HAVE NOTE LIST ?\n         BNO   RCRDTYPE                 NO, SKIP NOTE LIST CHECK\n         SPACE 1\n         NOTE  I#                       FIND TTR OF LAST BLOCK\n         ST    R1,WRKWRDS               STORE TTRZ\n         CLC   BLDLTTRN(3),WRKWRDS      THIS THE NOTE LIST ?\n         BE    NEXTRCRD                 YES, SKIP IT\n         SPACE 2\nRCRDTYPE XR    R1,R1                    CLEAR FOR INSERT\n         IC    R1,RECORD                INSERT RECORD TYPE\n         IC    R1,TRTTABLE(R1)          DETERMINE ACTION\n         B     *(R1)                    GO TO IT\n         B     NEXTRCRD   04            IGNORE THE RECORD\n         B     DOCESD     08            PROCESS CESD\n         B     DOCNTRL    0C            PROCESS CONTROL RECORD\n*        B     DORLD      10            PROCESS RLD OR CRLD\n         SPACE 2\nDORLD    LH    R1,RECORD+6              GET AMOUNT OF DATA\n         LA    R6,RECORD+16             POINT TO R & P\n         SH    R1,=H'4'                 DECREMENT COUNT\n         LA    R7,RECORD+20             POINT TO F & A\n         SPACE 1\nRLDLOOP  TM    0(R7),B'01100000'        DON'T RELOCATE ?\n         BNZ   NEXTRLD                  TRUE, SKIP IT\n         SPACE 1\n         LH    R8,0(R6)                 ESD ID OF EXTERNAL REFERENCE\n         BCTR  R8,0                     ORIGIN ZERO\n         MH    R8,=AL2(LTABCESD)        TIMES ENTRY LENGTH\n         LA    R8,CESDTAB(R8)           THE REFERENCED ENTRY\n         SPACE 1\n         L     R14,TABCOMM-TABCESD(R8)  LOAD COMMON ADDRESS\n         S     R14,TABADDR-TABCESD(R8)  LESS OFFSET IN CESD\n         TM    0(R7),B'00000010'        NEGATIVE RELOCATION ?\n         BNO   *+6                      NO, SKIP NEXT\n         LCR   R14,R14                  ADJUST FOR NEGATIVE RELOCATION\n         SPACE 1\n         L     R15,0(R7)                OFFSET OF RELOCATABLE REFERENCE\n         LA    R15,0(R3,R15)            NOW HAVE THE ADDRESS\n         SPACE 1\n         IC    R8,0(R7)                 GET FLAGS\n         N     R8,=F'12'                ONLY WANT LENGTH INDICATION\n         B     *(R8)                    GO RELOCATE ACCORDING TO LENGTH\n         B     RLDLEN2                  LENGTH IS TWO\n         B     RLDLEN3                  LENGTH IS THREE\n*        B     RLDLEN4                  LENGTH IS FOUR\n         EJECT\nRLDLEN4  MVC   WRKWRDS(4),0(R15)        ALIGN IT\n         AL    R14,WRKWRDS              RELOCATE\n         ST    R14,WRKWRDS+4            STORE FOR MOVE\n         MVC   0(4,R15),WRKWRDS+4       PUT IT BACK\n         B     NEXTRLD                  GO DO NEXT ENTRY\n         SPACE 1\nRLDLEN3  MVC   WRKWRDS(3),0(R15)        ALIGN IT\n         L     R8,WRKWRDS                 AND LOAD IT\n         SRA   R8,8                         AND SHIFT IT\n         ALR   R14,R8                   RELOCATE\n         ST    R14,WRKWRDS+4            STORE FOR MOVE\n         MVC   0(3,R15),WRKWRDS+5       PUT IT BACK\n         B     NEXTRLD                  GO DO NEXT ENTRY\n         SPACE 1\nRLDLEN2  MVC   WRKWRDS(2),0(R15)        ALIGN IT\n         LH    R8,WRKWRDS                 AND LOAD IT\n         ALR   R14,R8                   RELOCATE\n         STH   R14,WRKWRDS+4            STORE FOR MOVE\n         MVC   0(2,R15),WRKWRDS+4       PUT IT BACK\n         SPACE 1\nNEXTRLD  TM    0(R7),B'00000001'        USE SAME R & P ?\n         BO    *+14                     YES\n         LA    R6,4(R7)                 NEXT R & P\n         SH    R1,=H'4'                 ADJUST LENGTH\n         LR    R7,R6                    PRETEND IT WAS LAST F & A\n         SPACE 1\n         LA    R7,4(R7)                 NEXT F & A\n         SH    R1,=H'4'                 ADJUST LENGTH\n         BP    RLDLOOP                  MORE TO DO\n         SPACE 2\n         TM    RECORD,B'00000001'       RLD ALSO A CONTROL RECORD ?\n         BO    DOCNTRL                  YES, GO READ TEXT\n         TM    RECORD,B'00001000'       LAST RLD RECORD ?\n         BZ    NEXTRCRD                 NO, GO READ NEXT\n         SPACE 2\nEOM      TM    BLDL#,X'0F'              LABEL FOUND ?\n         BOR   R4                       YES, RETURN\n         MVI   LABEL#,C' '              CLEAR THE\n         MVC   LABEL#+1(7),LABEL#         LABEL FIELD\n         BR    R4                       RETURN\n         EJECT\nDOCNTRL  MVI   RECORD+8,0               CLEAR READ COMMAND FROM CCW\n         LR    R6,R3                    COPY ADDRESS START\n         A     R6,RECORD+8              ADD OFFSET TO DATA START\n         LH    R7,RECORD+12+2             AND LOAD RECORD LENGTH\n         SPACE 1\nREADTEXT READ  DECB,SF,I#,(R6),(R7),MF=E READ A TEXT RECORD\n         CHECK DECB                     WAIT FOR COMPLETION\n         SPACE 1\n         B     NEXTRCRD                 GO READ NEXT RECORD\n         SPACE 2\nDOCESD   IC    R1,RECORD+7              LOAD LENGTH OF ESD ENTRIES\n         SRL   R1,4                     DIVIDE BY LENGTH TO GET COUNT\n         LH    R6,RECORD+4              LOAD FIRST ESD ID\n         BCTR  R6,0                     ORIGIN ZERO\n         MH    R6,=AL2(LTABCESD)        TIMES ENTRY LENGTH\n         LA    R6,CESDTAB(R6)           NEXT AVAILABLE ENTRY\n         USING TABCESD,R6               ADDRESSABILITY\n         LA    R7,RECORD+8              START OF FIRST ENTRY\n         USING CESDENT,R7               ADDRESSABILITY\n         SPACE 1\nCESDLOOP XC    TABNAME(LTABCESD),TABNAME CLEAR THE ENTRY\n         TM    CESDTYPE,B'01011100'     UNWANTED TYPE ?             005\n         BNZ   CESDBCT                  YES, ON TO NEXT ENTRY\n         TM    CESDTYPE,B'00000011'     IS IT EXTERNAL REFERENCE ?\n         BNM   CESDLRSD                 NO, SKIP SETTING FLAG\n         OI    FLAG,X'F0'               MARK EXTERNAL REFERENCE FOUND\n         SPACE 1\nCESDLRSD MVC   TABNAME(TABCOMM-TABNAME),CESDNAME COPY NAME AND OFFSET\n         MVI   TABADDR,0                CLEAR FIRST OFFSET BYTE\n         L     R8,FRSTTAB               FIND FIRST ENTRY\n         LTR   R8,R8                    VERY FIRST CALL ?\n         BNZ   NOTFIRST                 NO, CONTINUE\n         SPACE 1\n         L     R8,=A(STABCESD*LTABCESD) LENGTH OF CESD TABLE\n         LA    R8,CESDTAB(R8)           END OF TABLE\n         ST    R8,FRSTTAB               FIRST ENTRY OF COMMON TABLE\n         B     ADDCOMM                  GO ADD FIRST COMMON ENTRY\n         EJECT\nNOTFIRST LA    R14,8                    BXLE INCREMENT\n         L     R15,NEXTTAB              LAST USED ENTRY\n         SPACE 1\nCOMMLOOP CLC   TABNAME,0(R8)            ALREADY IN TABLE ?\n         BE    CESDCHCK                 YES, NO NEED TO ADD AGAIN\n         BXLE  R8,R14,COMMLOOP          KEEP LOOKING\n         SPACE 1\nADDCOMM  MVC   0(8,R8),TABNAME          ADD THE NEW ENTRY\n         ST    R8,NEXTTAB                 AND AS LAST USED\n         SPACE 2\nCESDCHCK ST    R8,TABCOMM               SAVE ADDRESS FOR RELOCATION\n         SPACE 1\n         CLC   LABEL#,CESDNAME          HAVE A CANDIDATE ?\n         BNE   CESDBCT                  NO, ON TO NEXT ENTRY\n         L     R8,TABADDR               SAVE OFFSET\n         TM    CESDTYPE,B'00000011'     CSECT, ENTRY, OR EXTERNAL ?\n         BM    CESDBCT                  SKIP IF EXTERNAL REFERENCE\n         BO    ENTRY                    IT'S AN 'ENTRY' (LR) ENTRY\n         SPACE 1\n         A     R8,COMPADR#              ADD ADDRESS OF COMPARE\n         ST    R8,COMPADR#              SAVE NEW COMPARE START\n         MVC   COMPLEN#+1(3),CESDLEN+1    AND SAVE NEW COMPARE LENGTH\n         CLC   COMPLEN#,NUMBER#         OFFSET OUTSIDE CSECT ?\n         BH    CESDOI                   NO, GO INDICATE LABEL FOUND\n         XC    NUMBER#,NUMBER#          IGNORE NUMBER\n         B     CESDOI                   GO INDICATE LABEL FOUND\n         SPACE 1\nENTRY    L     R14,NUMBER#              LOAD NUMBER OFFSET\n         AR    R14,R8                   COMBINED OFFSET\n         C     R14,COMPLEN#             OUTSIDE MODULE ?\n         BNH   *+6                      NO, SKIP NEXT\n         LR    R14,R8                   IGNORE NUMBER, USE ENTRY\n         ST    R14,NUMBER#              STORE OFFSET\n         SPACE 1\nCESDOI   OI    BLDL#,X'0F'              MARK LABEL FOUND\n         SPACE 1\nCESDBCT  LA    R6,LTABCESD(R6)          NEXT ENTRY\n         L     R8,=A(STABCESD*LTABCESD) LENGTH OF CESD TABLE\n         LA    R8,CESDTAB(R8)           END OF TABLE\n         CR    R6,R8                    OVERRUN ?\n         BNL   ERR6                     YES, CAN'T CONTINUE\n         LA    R7,LCESDENT(R7)          NEXT ENTRY\n         BCT   R1,CESDLOOP              GO CHECK IT\n         B     NEXTRCRD                 GO READ NEXT RECORD\n         SPACE 1\n         DROP  R2,R5,R6,R7\n         EJECT\nOUTPUT   LTR   R2,R2                    FIRST CALL ?\n         BNZ   OUTCONT                  YES, CONTINUE\n         SPACE 1\n         MVC   RECORD(256),OUTREC1      MOVE IN HEADER DATA\n         MVC   RECORD+256(LOUTREC1-256),OUTREC1+256 AND THE REST\n         LA    R2,RECORD                ADDRESS OF OUTPUT AREA\n         USING OUTREC1,R2               ADDRESSABILITY\n         SPACE 1\n         MVC   REC1T+D1I1(8),NAME1      MOVE IN\n         MVC   REC1T+D1I2(8),NAME2        MEMBER NAMES\n         UNPK  WRKWRDS(9),LENGTH1(5)    UNPK THE LENGTH\n         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES\n         MVC   REC2T+D1I1(8),WRKWRDS    MOVE TO OUTPUT RECORD\n         UNPK  WRKWRDS(9),LENGTH2(5)    UNPK THE LENGTH\n         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES\n         MVC   REC2T+D1I2(8),WRKWRDS    MOVE TO OUTPUT RECORD\n         MVC   REC3T+D1I1(8),LABEL1     MOVE IN\n         MVC   REC3T+D1I2(8),LABEL2       LABEL  NAMES\n         TM    BLDL1,X'0F'              LABEL FOUND ?\n         BNO   *+14                     NO, CLEAR THE (C)\n         CLC   LENGTH1,COMPLEN1         WAS IT A CSECT ?\n         BNE   *+10                     YES, SKIP THE CLEAR\n         MVC   REC3T+D1I1+8(3),=C'   '  CLEAR THE 'C'\n         TM    BLDL2,X'0F'              LABEL FOUND ?\n         BNO   *+14                     NO, CLEAR THE (C)\n         CLC   LENGTH2,COMPLEN2         WAS IT A CSECT ?\n         BNE   *+10                     YES, SKIP THE CLEAR\n         MVC   REC3T+D1I2+8(3),=C'   '  CLEAR THE 'C'\n         UNPK  WRKWRDS(9),COMPLEN1(5)   UNPK THE COMPARE LENGTH\n         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES\n         MVC   REC6T+D1I1(8),WRKWRDS    MOVE TO OUTPUT RECORD\n         UNPK  WRKWRDS(9),COMPLEN2(5)   UNPK THE COMPARE LENGTH\n         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES\n         MVC   REC6T+D1I2(8),WRKWRDS    MOVE TO OUTPUT RECORD\n         UNPK  WRKWRDS(9),NUMBER1(5)    UNPK THE OFFSET\n         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES\n         MVC   REC4T+D1I1(8),WRKWRDS    MOVE TO OUTPUT RECORD\n         UNPK  WRKWRDS(9),NUMBER2(5)    UNPK THE OFFSET\n         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES\n         MVC   REC4T+D1I2(8),WRKWRDS    MOVE TO OUTPUT RECORD\n         UNPK  WRKWRDS(9),COUNT(5)      UNPK THE COUNT\n         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES\n         MVC   REC7T+D1I1(8),WRKWRDS    MOVE TO OUTPUT RECORD\n         SPACE 1\n         TM    FLAG,X'F0'               ANY UNRESOLVED REFERENCES ?\n         BO    OUTCONT                  YES, MESSAGE IS COMPLETE\n         MVI   REC5T-1,C'0'             CHANGE TO DOUBLE SPACE\n         SPACE 1\n         DROP  R2\n         SPACE 1\n         MVC   RECORD(2),=AL2(LOUTRECA) REDUCE RECORD LENGTH\n         EJECT\nOUTCONT  LTR   R4,R4                    WHAT IS WANTED ?\n         BP    OUTUNEQ                  ADD 'UNLIKE' OUTPUT LINE\n         BZ    OUTDIFF                  ADD 'LONGER' OUTPUT LINE\n*        BM    OUTBUFF                  DUMP THE BUFFER\n         SPACE 1\nOUTBUFF  CLC   =H'4',RECORD             NULL BUFFER ?\n         BER   R3                       YES RETURN\n         SPACE 1\n         WRITE DECB,SF,SNAP,(R2),'S',MF=E WRITE THE OUTPUT RECORD\n         CHECK DECB                     WAIT FOR COMPLETION\n         SPACE 1\n         MVC   RECORD(2),=H'4'          RESET BLOCK LENGTH\n         B     OUTCONT                  TRY AGAIN\n         SPACE 2\nOUTDIFF  LH    R1,RECORD                FIND CURRENT LENGTH\n         LR    R0,R1                      AND COPY IT\n         AH    R0,CEND                  ADD LENGTH OF NEXT RECORD\n         CH    R0,SNAP+DCBBLKSI-IHADCB  TOO LONG ?\n         BH    OUTBUFF                  YES, GO DUMP CURRENT RECORD\n         SPACE 1\n         STH   R0,RECORD                SAVE NEW RECORD LENGTH\n         AR    R1,R2                    ADD BUFFER START\n         MVC   0(LCEND,R1),CEND         MOVE IN RECORD\n         LTR   R7,R7                    IS FIRST MODULE EXHAUSTED ?\n         BNZ   *+10                     NO, SKIP NEXT\n         MVI   D3DDN(R1),C'2'           CHANGE 'I1' TO 'I2'\n         LR    R7,R8                    COPY EXCESS LENGTH\n         ST    R7,WRKWRDS+8             STORE IT\n         UNPK  WRKWRDS(7),WRKWRDS+9(4)  UNPK THE LENGTH\n         TR    WRKWRDS(6),TRTABLE-C'0'  TO PRINTABLES\n         MVC   D3LEN(6,R1),WRKWRDS      MOVE TO OUTPUT RECORD\n         SPACE 1\n         BR    R3                       RETURN\n         SPACE 2\nOUTUNEQ  LH    R1,RECORD                FIND CURRENT LENGTH\n         LR    R0,R1                      AND COPY IT\n         AH    R0,CREC                  ADD LENGTH OF NEXT RECORD\n         CH    R0,SNAP+DCBBLKSI-IHADCB  TOO LONG ?\n         BH    OUTBUFF                  YES, GO DUMP CURRENT RECORD\n         EJECT\n         STH   R0,RECORD                SAVE NEW RECORD LENGTH\n         AR    R1,R2                    ADD BUFFER START\n         MVC   0(LCREC,R1),CREC         MOVE IN RECORD\n         MVC   12(1,R13),0(R5)          MOVE BYTE TO A WORKAREA     004\n         UNPK  WRKWRDS(3),12(2,R13)     UNPK THE BYTE+GARBAGE BYTE  004\n         TR    WRKWRDS(2),TRTABLE-C'0'  TO PRINTABLES\n         MVC   D2I1B(2,R1),WRKWRDS      MOVE TO OUTPUT RECORD\n         MVC   12(1,R13),0(R6)          MOVE BYTE TO A WORKAREA     004\n         UNPK  WRKWRDS(3),12(2,R13)     UNPK THE BYTE+GARBAGE BYTE  004\n         TR    WRKWRDS(2),TRTABLE-C'0'  TO PRINTABLES\n         MVC   D2I2B(2,R1),WRKWRDS      MOVE TO OUTPUT RECORD\n         ST    R5,WRKWRDS+12            STORE COMPARE ADDRESS\n         LR    R0,R5                    COPY BYTE ADDRESS\n         S     R0,COMPADR1              LESS COMPARE START\n         ST    R0,WRKWRDS+8             STORE COMPARE OFFSET\n         UNPK  WRKWRDS(7),WRKWRDS+9(4)  UNPK THE OFFSET\n         TR    WRKWRDS(6),TRTABLE-C'0'  TO PRINTABLES\n         MVC   D2I1A(6,R1),WRKWRDS      MOVE TO OUTPUT RECORD\n*001     UNPK  WRKWRDS(7),WRKWRDS+13(4) UNPK THE ADDRESS\n*001     TR    WRKWRDS(6),TRTABLE-C'0'  TO PRINTABLES\n*001     MVC   D2I1A+8(6,R1),WRKWRDS    MOVE TO OUTPUT RECORD\n         ST    R6,WRKWRDS+12            STORE COMPARE ADDRESS\n         LR    R0,R6                    COPY BYTE ADDRESS\n         S     R0,COMPADR2              LESS COMPARE START\n         ST    R0,WRKWRDS+8             STORE COMPARE OFFSET\n         UNPK  WRKWRDS(7),WRKWRDS+9(4)  UNPK THE OFFSET\n         TR    WRKWRDS(6),TRTABLE-C'0'  TO PRINTABLES\n         MVC   D2I2A(6,R1),WRKWRDS      MOVE TO OUTPUT RECORD\n*001     UNPK  WRKWRDS(7),WRKWRDS+13(4) UNPK THE ADDRESS\n*001     TR    WRKWRDS(6),TRTABLE-C'0'  TO PRINTABLES\n*001     MVC   D2I2A+8(6,R1),WRKWRDS    MOVE TO OUTPUT RECORD\n         SPACE 1\n         BR    R3                       RETURN TO CALLER\n         SPACE 4\n         PRINT NOGEN\nTRTTABLE DC    256X'04'                 IGNORE EVERYTHING\n         SPACE 1\n         RCRD  80,04                    IDR      - IGNORE\n         RCRD  40,04                    SYM      - IGNORE\n         RCRD  20,08                    CESD     - PROCESS\n         RCRD  10,04                    SC/TR    - IGNORE\n         RCRD  01,0C                    CNTRL    - PROCESS\n         RCRD  05,04                    CNT-EOS  - IGNORE\n         RCRD  0D,0C                    CNT-EOM  - PROCESS\n         RCRD  02,10                    RLD      - PROCESS\n         RCRD  06,04                    RLD-EOS  - IGNORE\n         RCRD  0E,10                    RLD-EOM  - PROCESS\n         RCRD  03,10                    CRLD     - PROCESS\n         RCRD  07,04                    CRLD-EOS - IGNORE\n         RCRD  0F,10                    CRLD-EOM - PROCESS\n         EJECT\nTRTABLE  DC    C'0123456789ABCDEF'      GUESS WHAT THIS IS FOR\n         SPACE 3\nD1I1     EQU   9                        RECORD 1 DATA\nD1I2     EQU   21\n         SPACE 1\nOUTREC1  DC    AL2(LOUTREC1,0)          NOTE ALIGNMENT\nREC1     DC    AL2(LREC1,0),C'1'\nREC1T    DC    C'MODULES: NNNNNNNN-I1 MMMMMMMM-I2'\nLREC1    EQU   *-REC1\nREC2     DC    AL2(LREC2,0),C' '\nREC2T    DC    C'LENGTH:  HHHHHHHH    HHHHHHHH  (OF MODULES)'\nLREC2    EQU   *-REC2\nREC3     DC    AL2(LREC3,0),C' '\nREC3T    DC    C'LABEL:   11111111(C) 22222222(C)'\nLREC3    EQU   *-REC3\nREC6     DC    AL2(LREC6,0),C' '\nREC6T    DC    C'COMPLEN: HHHHHHHH    HHHHHHHH  (BASIC COMPARE LENGTH)'\nLREC6    EQU   *-REC6\nREC4     DC    AL2(LREC4,0),C' '\nREC4T    DC    C'OFFSET:  HHHHHHHH    HHHHHHHH  (IN MODULE OR CSECT)'\nLREC4    EQU   *-REC4\nREC7     DC    AL2(LREC7,0),C' '\nREC7T    DC    C'COUNT:   HHHHHHHH  (FORCED COMPARE LENGTH)'\nLREC7    EQU   *-REC7\nREC5     DC    AL2(LREC5,0),C' '\nREC5T    DC    C' '\nLREC5    EQU   *-REC5\nLOUTRECA EQU   *-OUTREC1\nREC8     DC    AL2(LREC8,0),C' '\nREC8T    DC    C'NOTE: SOME UNRESOLVED EXTERNAL REFERENCES RESOLVED'\nLREC8    EQU   *-REC8\nREC9     DC    AL2(LREC9,0),C'0'\nREC9T    DC    C' '\nLREC9    EQU   *-REC9\nLOUTREC1 EQU   *-OUTREC1\n         DC    (LOUTREC1-2*(LOUTREC1/2))AL1(0) ALIGNMENT\n         SPACE 1\nERROR1   EQU   SNAPBLKS-LOUTREC1        ERROR IF TOO SMALL\n         SPACE 2\nD2I1A    EQU   5+4                      RECORD 2 DATA\nD2I1B    EQU   5+11                     WAS 5+20                    001\nD2I2B    EQU   5+21                     WAS 5+30                    001\nD2I2A    EQU   5+28                     WAS 5+37                    001\n         SPACE 1\nCREC     DC    AL2(LCREC,0),C' '\nCRECT    DC    C'AT +HHHHHH XX UNLIKE XX AT +HHHHHH'\n*001 CRECT DC  C'AT +HHHHHH (HHHHHH) XX UNLIKE XX AT +HHHHHH (HHHHHH)'\nLCREC    EQU   *-CREC\n         DC    (LCREC-2*(LCREC/2))AL1(0) ALIGNMENT\n         EJECT\nD3DDN    EQU   5+11                     RECORD 3 DATA\nD3LEN    EQU   5+23\n         SPACE 1\nCEND     DC    AL2(LCEND,0),C'0'\nCENDT    DC    C'MODULE IN I1 LONGER BY HHHHHH BYTES'\nLCEND    EQU   *-CEND\n         SPACE 4\nDCBPSQ   DCB   BLKSIZE=400,DDNAME=WTO,DSORG=PS,LRECL=125,              X\n               BUFNO=1,MACRF=PM,RECFM=VB\nDCBPSQX  EQU   *-DCBPSQ\n         SPACE 1\nDCBPS    DCB   BLKSIZE=SNAPBLKS,DDNAME=SNAP,DSORG=PS,LRECL=125,        *\n               MACRF=W,RECFM=VBA\nDCBPSX   EQU   *-DCBPS                  LENGTH OF DCB\n         SPACE 1\nDCBPO    DCB   DDNAME=I1,DSORG=PO,EODAD=EOM,MACRF=R\nDCBPOX   EQU   *-DCBPO                  LENGTH OF DCB\n         SPACE 1\n         READ  DECBRW,SF,MF=L\nDECBX    EQU   *-DECBRW                 LENGTH OF DECB\n         SPACE 2\n         LTORG\n         EJECT ,\n*   SUP - CHECK IF MODULE CONTAINS TTRL'S OF OTHER MODULES,\n*         IF SO, SET THEM ALL TO C'TTRL'\n*     AT ENTRY R1 = @ NAME IN WORK OF MODULE TO TEST\n*\n         SPACE 1\nSUP      STM   R0,R15,SAVE2             SAVE REGS\n         LR    R9,R15                   GET BASE REG\n         USING SUP,R9\n         LR    R8,R1                    SAVE @ MODULE NAME ETC\n         LA    R7,SUP#TB8               SEE IF 1ST LOAD WITH TTRL'S\n         BAL   R14,SUP$SCN              GO SCAN TABLE\n         B     SUP$FND1                 BRANCH IF FOUND IN TABLE\n         LA    R7,SUP#TB6               SEE IF LATER LOAD\n         BAL   R14,SUP$SCN              GO SCAN TABLE\n         B     SUP$FND2\nSUP$EXIT LM    R0,R15,SAVE2             RESTORE REGS\n         BR    R14                      AND RETURN\n         SPACE 1\nSUP$FND2 TM    NAME1-NAME1+6(R8),X'F0'  NUMERIC 7TH CHAR?\n         BNO   SUP$EXIT                 NO TTRL'S IF NOT\nSUP$FND1 L     R1,ADDRESS1-NAME1(,R8)   GET BEGIN ADDR\n         L     R2,LENGTH1-NAME1(,R8)    GET LENGTH\n         CL    R2,=F'1024'              > 1024 LONG?\n         BH    SUP$EXIT                 YES, NO TTRL'S\n         LA    R3,0(R2,R1)              @ PAST END OF MODULE\n         SH    R3,=H'4'                 BACK UP 4 BYTES\n         SR    R4,R4                    CLEAR FOR IC\n         IC    R4,3(,R3)                GET OFFSET/8 OF TTRL TABLE\n         SLA   R4,3                     GET REAL OFFSET\n         BZ    SUP$EXIT                 I WON'T BUY OFFSET 0\n         ALR   R1,R4                    POINT TO TTRL TABLE\n         SPACE 1\nSUP$LOOP CR    R1,R3                    PAST END OF MODULE?\n         BNL   SUP$EXIT                 BRANCH IF PAST\n         OC    0(2,R1),0(R1)            END OF TABLE?\n         BZ    SUP$EXIT                 DONE IF SO\n         CLC   0(2,R1),=X'FFFF'         SUBLIST DELIMITER?          002\n         BE    SUP$FF                   YES - SKIP PAST IT          002\n         MVC   2(4,R1),=C'TTRL'         FIX UP TTRL\n         LA    R1,6(,R1)                TO NEXT ENTRY\n         B     SUP$LOOP\n         SPACE 1\nSUP$FF   LA    R1,2(,R1)                SKIP PAST SUBLIST DELIMITER 002\n         B     SUP$LOOP                 AND GO CHECK FOR END        002\n         SPACE 1\nSUP$SCN  LH    R0,0(,R7)                GET NUMBER OF ENTRIES IN TABLE\n         LH    R15,2(,R7)               GET LEN-1 OF EACH ENTRY\nSUP$SCNL EX    R15,SUP$SCNC             CLC 4(0,R7),NAME1-NAME1(R8)\n         BER   R14                      RETURN IF FOUND\n         LA    R7,1(R15,R7)             TO NEXT ENTRY\n         BCT   R0,SUP$SCNL              SCAN ALL ENTRIES\n         B     4(,R14)                  RETURN NOT FOUND\nSUP$SCNC CLC   4(0,R7),NAME1-NAME1(R8)  * EXECUTED *\n         SPACE 1\nSUP#TB8  DC    Y((SUP#TB8L-4)/8)        NUMBER OF ENTRIES\n         DC    Y(7)                     LENGTH -1 OF EACH ENTRY\n         DC    CL8'IGC0001I'            OPEN\n         DC    CL7'IGC0002',X'C0'       CLOSE\n         DC    CL8'IGC0002A'            STOW\n         DC    CL8'IGC0002B'            OPENJ\n         DC    CL8'IGC0002C'            TCLOSE\n         DC    CL8'IGC0002I'            SCRATCH\n         DC    CL8'IGC0003A'            FEOV\n         DC    CL8'IGC0003B'            ALLOCATE\n         DC    CL8'IGC0005E'            EOV\n         DC    CL8'IGC0008A'            SETPRT\n         DC    CL8'IGC0008F'            ATLAS\n         DC    CL8'IGC0009C'            TSO\n         DC    CL8'IGC0009D'            TSO\nSUP#TB8L EQU   *-SUP#TB8                LENGTH OF TABLE\n         SPACE 1\nSUP#TB6  DC    Y((SUP#TB6L-4)/6)        NUMBER OF ENTRIES\n         DC    Y(5)                     LENGTH OF ENTRY -1\n         DC    CL6'IFG019'              OPEN\n         DC    CL6'IFG020'              CLOSE\n         DC    CL6'IFG023'              TCLOSE\n         DC    CL6'IFG055'              EOV\n         DC    CL6'IFGASR'              ASR MODULE NAMES\n         DC    CL6'IGG019'              OPEN\n         DC    CL6'IGG020'              CLOSE\n         DC    CL6'IGG021'              STOW\n         DC    CL6'IGG023'              TCLOSE\n         DC    CL6'IGG029'              SCRATCH\n         DC    CL6'IGG032'              ALLOCATE\n         DC    CL6'IGG055'              EOV\n         DC    CL6'IGG081'              SETPRT\n         DC    CL6'IGG086'              ATLAS\n         DC    CL6'IGG093'              TSO\n         DC    CL6'IGG094'              TSO\nSUP#TB6L EQU   *-SUP#TB6                LENGTH OF TABLE\n         SPACE 1\n         DROP  R9\n         EJECT ,\n*   SNAPIT: SNAP ROUTINE\n*     R1 = @ (@ BEGIN, @ END)\n*\n         SPACE 1\nSNAPIT   TM    FLAGS,FG#NSNAP           DON'T DO SNAP?              001\n         BOR   R14                      YES - RETURN TO CALLER      001\n         SPACE 2\n         STM   R0,R15,SAVE2             SAVE REGS\n         LR    R9,R15                   LOCAL BASE\n         USING SNAPIT,R9\n         LM    R2,R3,0(R1)              GET @ BEGIN, @ END\n         LA    R4,4                     CONSTANT\n         SR    R5,R5                    START AT OFFSET 0\n         SPACE 1\nSN$LOOP1 MVC   LINERDW(5),SN#RDW        INIT RDW, CTL CHAR (' ')\n         MVC   LINE+1(L'LINE-1),LINE    BLANK REST OF LINE\n         LTR   R5,R5                    1ST LINE?\n         BNZ   *+8                      BRANCH IF NOT\n         MVI   LINE,C'1'                NEW PAGE ON FIRST\n         ST    R5,SN#WRK                OFFSET TO HEX\n         UNPK  LINE+1(7),SN#WRK+1(4)\n         TR    LINE+1(6),TRTABLE-C'0'\n         MVI   LINE+1+6,C' '\n         LA    R0,2                     DO TWO SETS OF 16 BYTES\n         LA    R7,LINE+1+6+1            @ OF FIRST WORD OF HEX\n         LA    R8,LINE+L'LINE-32-1      @ OF FIRST WORD OF CHAR\n         SPACE 1\nSN$LOOP2 MVC   0(3,R7),=CL3' '          ADD SOME BLANKS\n         LA    R7,3(,R7)\n         LR    R6,R4                    AND 4 SETS OF 4 IN EACH 16\n         SPACE 1\nSN$LOOP3 UNPK  0(9,R7),0(5,R2)          SET 4 BYTES HEX\n         TR    0(8,R7),TRTABLE-C'0'\n         MVI   8(R7),C' '               FIX GARBAGE BYTE\n         MVC   0(4,R8),0(R2)            MOVE IN CHAR STUFF\n         AR    R2,R4                    BUMP INPUT PTR\n         LA    R7,9(,R7)                BUMP HEX OUTPUT PTR\n         AR    R8,R4                    BUMP CHAR OUTPUT PTR\n         AR    R5,R4                    BUMP OFFSET TOO\n         CR    R2,R3                    NEXT WORD TO BE DUMPED?\n         BNL   SN$DONE                  NO, PRINT, DONE\n         BCT   R6,SN$LOOP3              DO 16 BYTES\n         BCT   R0,SN$LOOP2              DO ABOVE TWICE\n         SPACE 1\n         BAL   R8,SN$PUT                PRINT LINE\n         B     SN$LOOP1\n         SPACE 1\nSN$DONE  BAL   R8,SN$PUT                PRINT LAST LINE\n         LM    R0,R15,SAVE2             RESTORE REGS\n         BR    R14                      AND RETURN\n         SPACE 1\nSN$PUT   MVI   LINE+L'LINE-1,C'*'       STARS AROUND CHAR PART\n         MVI   LINE+L'LINE-1-32-1,C'*'\n         TR    LINE+L'LINE-1-32(32),SN#TR  CHANGE GARBAGE TO '.'\n         LH    R1,RECORD                CURRENT RECORD LENGTH\n         LR    R0,R1                    COPY IT\n         AH    R0,LINERDW               ADD IN LENGTH OF NEW LINE\n         CH    R0,SNAP+DCBBLKSI-IHADCB  OVER BLKSIZE?\n         BNH   SN$FITS                  BRANCH IF NOT\n         LA    R15,RECORD               @ RECORD TO WRITE\n         PRINT GEN\n         WRITE DECB,SF,SNAP,(R15),'S',MF=E WRITE BLOCK\n         CHECK DECB                     WAIT FOR I/O\n         PRINT NOGEN\n         LA    R1,4                     RE-SET RECORD RDW\nSN$FITS  LA    R15,RECORD(R1)           GET @ TO PLACE LINE\n         MVC   0(L'LINE+4,R15),LINERDW  PUT LINE IN OUTPUT BUFFER\n         AH    R1,LINERDW               GET NEW OUTPUT LENGTH\n         STH   R1,RECORD                SET NEW OUTPUT LENGTH\n         BR    R8                       AND RETURN\n         SPACE 1\nSN#RDW   DC    Y(L'LINE+4,0),C' '\nSN#TR    DC    256X'4B'\n         ORG   SN#TR+C' '\n         DC    C' '\n         ORG   SN#TR+X'4A'\n         DC    X'4A4B4C4D4E4F'\n         ORG   SN#TR+X'5A'\n         DC    X'5A5B5C5D5E5F'\n         ORG   SN#TR+C','\n         DC    C',%_>?'\n         ORG   SN#TR+X'7A'\n         DC    X'7A7B7C7D7E7F'\n         ORG   SN#TR+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   SN#TR+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   SN#TR+C'S'\n         DC    C'STUVWXYZ'\n         ORG   SN#TR+C'0'\n         DC    C'0123456789'\n         ORG   ,\n         SPACE 1\n         DROP  R9\n         EJECT ,\nGETENT   STM   R0,R15,SAVE2             SAVE CALLERS REGS\n         LR    R9,R15                   SET LOCAL BASE\n         USING GETENT,R9\n         L     R6,DIRLST                @ LAST DIR ENTRY\n         LTR   R6,R6                    FIRST TIME?\n         BZ    GE$FIRST                 YES, GO READ\n         SR    R5,R5                    CLEAR FOR IC\n         IC    R5,11(,R6)               GET LENGTH OF LAST ENTRY\n         N     R5,=X'0000001F'          GET LENGTH IN H-WORDS\n         LA    R5,12(R5,R5)             LENGTH IN BYTES\n         AR    R6,R5                    @ NEXT ENTRY IF ANY\n         LH    R1,DIRBUF                GET LENGTH OF DATA IN BLOCK\n         LA    R1,DIRBUF(R1)            @ PAST LAST ENTRY\n         CR    R6,R1                    IS THIS ENTRY OK?\n         BL    GE$OK                    BRANCH IF OK\nGE$FIRST MVI   DIRTTR+3,1               SET GET NEXT BLOCK\n         POINT I1,DIRTTR                POINT THERE\n         READ  DECB,SF,I1,DIRBUF,256,MF=E  READ NEXT DIR BLOCK\n         CHECK DECB                     WAIT FOR IT\n         NOTE  I1                       GET IT'S TTR\n         ST    R1,DIRTTR                SAVE FOR NEXT TIME\n         LA    R6,DIRBUF+2              GET @ 1ST ENTRY\nGE$OK    CLC   0(8,R6),=8X'FF'          LAST ENTRY?\n         BE    ALLDONE                  YES, JUST LEAVE\n         ST    R6,DIRLST                ELSE SAVE ENTRY ADDR\n         MVC   NAME1,0(R6)              SET 1ST NAME\n         MVC   NAME2,0(R6)              AND 2ND NAME\n         LM    R0,R15,SAVE2             RESTORE REGS\n         BR    R14                      AND RETURN\n         SPACE 2\n         DROP  R9\n         EJECT\n***********************************************************************\n*                                                                     *\n* DO PRE-OPEN CHECKS HERE. CHECK IF OUTPUT FILE IS SYSPRINT AND NOT   *\n* SNAP; FLAG NO SNAP DUMP IF YES. CHECK IF OUTPUT FILE IS ALLOCATED   *\n* TO TSO AS TERMFILE. SET UP WRITE INTERCEPT IF YES AND FAKE OUT OPEN *\n* DCB. GENERATE FINAL FORM OF OPEN LIST AND DO THE ACTUAL OPEN.       *\n*                                                                     *\n* INPUT: R1 - POINTER TO OPEN LIST.                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         USING OPEN#CHK,R9              SET ADDRESSIBILITY          001\n         PRINT GEN                                                  001\n         SPACE 2\nOPEN#CHK STM   R0,R15,SAVE2             SAVE CALLER'S REGS          001\n         LR    R9,R15                   SET BASE REG                001\n         TM    DCBLIST+8,X'80'          OPENING DCBWTO?             001\n         BO    *+8                      NO - CONTINUE               001\n         OI    FLAGS,FG#ALL             SAY PROCESS ALL MEMBERS     001\n         SPACE 2\n         L     R3,PSATOLD-PSA           CURRENT TCB                 003\n         LA    R0,24                    FIRST TIOT INCREMENT        001\n         XR    R2,R2                    CLEAR FLAG REG              001\n         L     R15,12(,R3)              TIOT ADDR                   001\n         BALR  R14,0                    LOOP RETURN ADDR            001\n         SPACE 2\n         ALR   R15,R0                   NEXT TIOT ENTRY             001\n         IC    R0,0(,R15)               LENGTH/THIS ENTRY           001\n         LTR   R0,R0                    END OF TIOT?                001\n         BZ    OP#END#T                 YES - SEE IF SYSPRINT FOUND 001\n         SPACE 2\n         CLC   4(8,R15),=CL8'SYSPRINT'  DDNAME=SYSPRINT?            001\n         BNE   OP#SNAP                  NO - GO CHECK SNAP DDNAME   001\n         LR    R2,R15                   SAVE ENTRY ADDR AS FLAG     001\n         BR    R14                      AND CHECK NEXT ENTRY        001\n         SPACE 2\nOP#SNAP  CLC   4(8,R15),SNAP+DCBDDNAM-IHADCB DDNAME=SNAP?           001\n         BNER  R14                      NO - LOOP                   001\n         ICM   R2,B'0111',17(R15)       UCB ADDR FOR BELOW          003\n         SPACE 2\n*  ----  HAVE SNAP OR SYSPRINT DD ENTRY HERE.                       001\n         SPACE 2\nOP#DD    L     R15,PSAAOLD-PSA          CURRENT ASCB                003\n         ICM   R15,B'1111',ASCBTSB-ASCB(R15) RUNNING AS A TSO TASK? 003\n         BZ    OP#RET                   NO - CAN'T BE TERMFILE      001\n         LTR   R2,R2                    NO UCB ADDR(THUS TERMFILE)? 001\n         BNZ   OP#RET                   NO - EXIT                   001\n         SPACE 2\n*  ----  HAVE TERMFILE HERE - INTERCEPT IT.                         001\n         SPACE 2\n         MVC   SNAP+DCBWRITE+1-IHADCB(3),=AL3(TPUT#TSO) TPUT CODE   001\n         MVC   SNAP+DCBCHECK+1-IHADCB(3),=AL3(TPUT#END) TPUT CODE   001\n         OI    SNAP+DCBOFLGS-IHADCB,DCBOFOPN TELL MAINLINE DCB OPEN 001\n         MVC   DCBLIST(12),DCBLIST+4    SQUISH OUT SNAP DCB ADDR    001\n         SPACE 2\nOP#RET   OPEN  MF=(E,(1))               NOW FINALLY DO THE OPEN     001\n         LM    R0,R15,SAVE2             RESTORE CALLER'S REGS       001\n         BR    R14                      AND RETURN\n         SPACE 2\n*  ----  GET HERE WITH END OF TIOT/SNAP NOT FOUND - CHECK SYSPRINT. 001\n         SPACE 2\nOP#END#T LTR   R2,R2                    SYSPRINT ENTRY FOUND?       001\n         BZ    OP#RET                   NO - LET MAINLINE DIAG. ERR 001\n         SPACE 2\n         OI    FLAGS,FG#NSNAP           SAY DON'T DO A SNAP         001\n         MVC   SNAP+DCBDDNAM-IHADCB(8),=CL8'SYSPRINT' RESET DDNAME  001\n         ICM   R2,B'0111',17(R2)        GET UCB ADDR/THIS FILE      003\n         B     OP#DD                    NOW CHECK FOR TERMFILE      001\n         SPACE 2\n         DROP  R9                                                   001\n         EJECT\n*  ----  THIS CODE GAINS CONTROL VIA A WRITE DECB,SF,...            001\n*  ----  INPUT R1-->XL4'ECB',XL2'FLAGS',AL2(LEN),A(DCB),A(BUF).     001\n         SPACE 2\n         USING TPUT#TSO,R5              ADDRESSIBILITY              001\n         SPACE 2\nTPUT#TSO STM   R14,R5,16(R13)           SAVE WORK REGS/NOTE OFFSET  001\n         LR    R5,R15                   SET BASE REGISTER           001\n         L     R3,12(,R1)               GET OUTPUT BUFFER ADDR      001\n         MVC   12(2,R13),0(R3)          GET BLOCK LENGTH            001\n         LA    R3,0(,R3)                INSURE HI BYTE CLEAR        001\n         LH    R4,12(,R13)              GET LENGTH/THIS BLOCK       001\n         LA    R2,4                     SET FIRST REC INCREMENT     001\n         ALR   R4,R3                    GEN END CHECK ADDR          001\n         B     TPUT#CHK                 AND GO CHECK FOR END        001\n         SPACE 2\nTPUT#LP  LH    R0,=H'-5'                BYTES IN REC WE SKIP        001\n         AR    R0,R2                    GEN TPUT LENGTH             001\n         LA    R1,5(,R3)                POINT TO START OF TEXT      001\n         BNP   TPUT#CHK                 SKIP TPUT IF FUNNY          001\n         TPUT  (1),(0),R                ELSE TPUT THE MSG TEXT      001\n         SPACE 2\nTPUT#CHK ALR   R3,R2                    POINT TO NEXT RECORD        001\n         CLR   R3,R4                    STILL WITHIN REC?           001\n         IC    R2,1(,R3)                GET LEN/THIS REC            001\n         BL    TPUT#LP                  YES - CONTINUE TPUT'ING     001\n         SPACE 2\n         LM    R14,R5,16(R13)           RESTORE WORK REGS           001\nTPUT#END BR    R14                      RETURN TO CALLER            001\n         SPACE 2\n         DROP  R5                                                   001\n         PRINT NOGEN                                                001\n         SPACE 2\n         LTORG\n         EJECT ,\nCESDENT  DSECT\nCESDNAME DS    CL8                      IDENTIFIER\nCESDTYPE DS    X                        TYPE OF ESD ENTRY\nCESDADR  DS    AL3                      OFFSET INTO MODULE\nCESDLEN  DS    F                        CSECT LENGTH\nLCESDENT EQU   *-CESDENT                LENGTH OF ENTRY\n         SPACE 2\nTABCESD  DSECT\nTABNAME  DS    CL8                      CESD IDENTIFIER\nTABADDR  DS    F                        OFFSET INTO MODULE\nTABCOMM  DS    A                        ADDRESS OF COMMON LABEL\nLTABCESD EQU   *-TABCESD                LENGTH OF ENTRY\n         SPACE 2\n         DCBD  DEVD=DA,DSORG=(PO,PS)\n         IHAPSA ,                                                   003\n         IHAASCB ,                                                  003\n         EJECT\nWORKAREA DSECT                          DYNAMIC STORAGE AREA\n         DS    18F                      SAVEAREA\n         SPACE 1\nWRKWRDS  DS    4F                       DOUBLEWORD ALIGNED WORK AREA\nDCBLIST  DS    4F                       OPEN/CLOSE PARM LIST\nSAVE2    DS    16F                      SUBROUTINE SAVE AREA\nSN#WRK   DS    F                        SNAP WORK AREA\nRETCODE  DS    F                        PROGRAM RETURN CODE         004\nFLAGS    DS    F                        FLAG AREA                   001\nFG#NSNAP EQU   X'80'                    DON'T DO A PSEUDO-SNAP DUMP 001\nFG#ALL   EQU   X'40'                    PROCESS ALL PDS MEMBERS     001\n         SPACE 1\nLINERDW  DS    2H                       RDW FOR LINE\nLINE     DS    CL121                    PRINT LINE\n         SPACE 1\nCOUNT    DS    A                        NUMBER OF BYTES TO COMPARE\n         SPACE 1\nDCBWTO   DCB   DDNAME=*,DSORG=PS,MACRF=PM\n         SPACE 1\nSNAP     DCB   DDNAME=*,DSORG=PS,MACRF=W\n         SPACE 1\nFRSTTAB  DS    F                        FIRST COMMON SYMBOL IN TABLE\nNEXTTAB  DS    F                        NEXT COMMON SYMBOL IN TABLE\n         SPACE 2\nNAME1    DS    CL8                      FIRST MODULE NAME\nLABEL1   DS    CL8                      LABEL IN MODULE\nNUMBER1  DS    A                        NUMBER (OFFSET) INTO NAME/LABEL\nLENGTH1  DS    A                        LENGTH OF MODULE\nADDRESS1 DS    A                        ADDRESS OF MODULE\nCOMPLEN1 DS    A                        LENGTH OF COMPARE\nCOMPADR1 DS    A                        ADDRESS OF COMPARE\nBLDL1    DS    17F                      BLDL LIST\n         SPACE 1\nI1       DCB   DDNAME=*,DSORG=PO,MACRF=R FIRST DCB\n         SPACE 2\nNAME2    DS    CL8                      SECOND MODULE NAME\nLABEL2   DS    CL8                      LABEL IN MODULE\nNUMBER2  DS    A                        NUMBER (OFFSET) INTO NAME/LABEL\nLENGTH2  DS    A                        LENGTH OF MODULE\nADDRESS2 DS    A                        ADDRESS OF MODULE\nCOMPLEN2 DS    A                        LENGTH OF COMPARE\nCOMPADR2 DS    A                        ADDRESS OF COMPARE\nBLDL2    DS    17F                      BLDL LIST\n         SPACE 1\nI2       DCB   DDNAME=*,DSORG=PO,MACRF=R SECOND DCB\n         SPACE 2\n         READ  DECB,SF,MF=L             DECB FOR PDS INPUT\n         SPACE 1\nFLAG     DS    X                        FLAG FOR EXTERNAL REFERENCE\n         SPACE 1\nBASELEN  EQU   *-WORKAREA               LENGTH TO CLEAR\n         SPACE 1\n         DS    0F                       ALIGNMENT\nRECORD   DS    (SNAPBLKS)X              INPUT AND OUTPUT BUFFER\n         SPACE 1\nDIRLST   DS    A\nDIRTTR   DS    F                        TTR OF LAST DIRECTORY  BLOCK\nDIRBUF   DS    0F,256X                  DIRECTORY BUFFER FOR 'ALL' OPT\n         SPACE 1\n         DS    0F                       ALIGNMENT\nCESDTAB  DS    (STABCESD)XL(LTABCESD)   CESD ENTRY TABLE\n         SPACE 1\nCOMMNAME DS    (2*STABCESD)CL8\n         SPACE 1\nWORKLEN  EQU   *-WORKAREA\n         EJECT\n         PRINT GEN\n         BLDLLIST\n         ORG   BLDLNAME+27\nBLDLFTBL DC    2X'00'                   FIRST TEXT BLOCK LENGTH\nBLDLEPA  DC    3X'00'                   ENTRY POINT ADDRESS\n         SPACE 2\nLIBWORK  DSECT\nNAME#    DS    CL8                      MODULE NAME\nLABEL#   DS    CL8                      LABEL IN MODULE\nNUMBER#  DS    A                        NUMBER (OFFSET) INTO NAME/LABEL\nLENGTH#  DS    A                        LENGTH OF MODULE\nADDRESS# DS    A                        ADDRESS OF MODULE\nCOMPLEN# DS    A                        LENGTH OF COMPARE\nCOMPADR# DS    A                        ADDRESS OF COMPARE\nBLDL#    DS    17F                      BLDL LIST\n         SPACE 1\nI#       EQU   *                        DCB\n         SPACE 2\n         END   COMPARE\n//*\n//*KED.SYSLMOD DD DISP=OLD,SPACE=,DSN=SYS5.MSSLOAD,UNIT=\n//LKED.SYSIN   DD *\n   IDENTIFY COMPARE('CS01395')\n   NAME COMPARE$(R)\n//*\n//C   EXEC PGM=COMPARE,\n//  PARM='COMPARE,COMPARE$'\n//STEPLIB  DD DISP=SHR,DSN=SYS5.MSSLOAD\n//SYSPRINT DD SYSOUT=*\n//I1       DD DISP=SHR,DSN=SYS5.MSSLOAD\n//I2       DD DISP=(SHR,PASS),DSN=&&GOSET\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPLOA$": {"ttr": 3331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x15\\x01\\t\\x00\\x1f\\x01\\x14\"o\\x107\\x00\\x19\\x00\\x0c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2009-01-01T00:00:00", "modifydate": "2014-08-14T10:37:15", "lines": 25, "newlines": 12, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD,RENT,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT489.FILE149(COMPLOAD)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,RENT,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//*YSLMOD  DD  DISP=SHR,DSN=SBGOLOB.COMPLOAD.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   COMPLOAD\n SETSSI  CB489149\n NAME COMPLOAD(R)\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COMPLOAD": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x18\\x00\\x03\\x01\\t\\x00\\x1f\\x01\\x14\"\\x7f\\x17\\x13\\x06\\xc2\\x06T\\x05\\x1c\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.24", "flags": 0, "createdate": "2009-01-01T00:00:00", "modifydate": "2014-08-15T17:13:03", "lines": 1730, "newlines": 1620, "modlines": 1308, "user": "SBGOLOB"}, "text": "COMP     TITLE 'COMPLOAD: PROGRAM TO COMPARE TWO LOAD MODULES'\n         MACRO\n         OACREGS &DUMMY,&PRINT=\n*        COPY  OACGBLS\n         GBLA  &OACPRTS\n         GBLB  &OACPRTF\n         GBLC  &OACPRT,&OACPRTG,&OACSTMX,&OACSTER\n         GBLC  &OACNAME\n         OACPRTPM PRINT=&PRINT\n         AIF   ('&OACPRT' NE 'SHORT').L1\n         PRINT OFF,GEN\n.L1      ANOP\n         SPACE &OACPRTS\n******************************************\nR0       EQU   0                   <-----|\nR1       EQU   1                   <-----|\nR2       EQU   2                   <-----|\nR3       EQU   3                   <-----|\nR4       EQU   4                   <-----|\nR5       EQU   5                   <-----|      =============\nR6       EQU   6                   <-----|      =  GENERAL  =\nR7       EQU   7                   <-----|      =  PURPOSE  =\nR8       EQU   8                   <-----|      = REGISTERS =\nR9       EQU   9                   <-----|      =============\nR10      EQU   10                  <-----|\nR11      EQU   11                  <-----|\nR12      EQU   12                  <-----|\nR13      EQU   13                  <-----|\nR14      EQU   14                  <-----|\nR15      EQU   15                  <-----|\n         SPACE\nF0       EQU   0                   <-----|    ==================\nF2       EQU   2                   <-----|    = FLOATING POINT =\nF4       EQU   4                   <-----|    =   REGISTERS    =\nF6       EQU   6                   <-----|    ==================\n         POP   PRINT\n         MEND\n         MACRO\n         OACPRTPM &DUMMY,&PRINT=\n.*\n.*       SETS  VALUES OF &OACPRT AND &OACPRTS DEPENDING ON\n.*       VALUES OF &OACPRTG, &OACPRTF, AND &PRINT\n.*\n.*       DOES  A PUSH PRINT AND A PRINT ON,GEN OR A\n.*       PRINT OFF,NOGEN DEPENDING ON THE CALCULATED VALUE\n.*       OF &OACPRT\n.*\n*        COPY  OACGBLS\n         GBLA  &OACPRTS\n         GBLB  &OACPRTF\n         GBLC  &OACPRT,&OACPRTG,&OACSTMX,&OACSTER\n         GBLC  &OACNAME\n&OACPRT  SETC  '&OACPRTG'\n         AIF   (&OACPRTF).L4\n         AIF   ('&PRINT' EQ '').L1DEF\n         AIF   ('&PRINT' NE 'ALL' ).L1\n&OACPRT  SETC  'ALL'\n         AGO   .L4\n.L1      AIF   ('&PRINT' NE 'SHORT').L2\n.L1DEF   ANOP                     DEFAULT PRINT VALUE\n&OACPRT  SETC  'SHORT'\n         AGO   .L4\n.L2      AIF   ('&PRINT' EQ 'NONE').L3\n         MNOTE 4,'UNRECOGNIZABLE PRINT VALUE ''NONE'' USED'\n.L3      ANOP\n&OACPRT  SETC  'NONE'\n.L4      ANOP\n         PUSH  PRINT\n         AIF   ('&OACPRT' NE 'ALL').L5\n&OACPRTS SETA  99\n         AGO   .L8\n.L5      AIF   ('&OACPRT' NE 'SHORT').L6\n&OACPRTS SETA  1\n         AGO   .L8\n.L6      AIF   ('&OACPRT' EQ 'NONE').L7\n         MNOTE 4,'UNRECOGNIZABLE VALUE OF &OACPRTG ''NONE'' SET'\n&OACPRTG SETC  'NONE'\n&OACPRT  SETC  '&OACPRTG'\n.L7      ANOP\n         PRINT OFF,GEN\n&OACPRTS SETA  1\n.L8      MEND\n         MACRO\n&LABEL   GETDSA &CLEAR=,&LENGTH=0,&OPTIONS=,&SUBPOOL=1,&BASEREG=10\n         GBLA  &SP\n         GBLB  &LTORG,&PL1,&RECUR,&STMT,&USEDDSA\n         GBLC  &CSECT\n         LCLA  &A\n         LCLB  &B(8)\n         LCLC  &BNAME,&CNAME,&LNGTH\n.A       ANOP\n&A       SETA  &A+1\n&B(1)    SETB  (('&OPTIONS(&A)' EQ 'PL1') OR (&B(1)) OR (&B(2)))\n&B(2)    SETB  (('&OPTIONS(&A)' EQ 'TASK')  OR (&B(2)))\n&B(3)    SETB  (('&OPTIONS(&A)' EQ 'RECURSIVE') OR (&B(3)))\n&B(4)    SETB  (('&OPTIONS(&A)' EQ 'STMTNO') OR (&B(4)))\n&B(5)    SETB  (('&OPTIONS(&A)' EQ 'DIFF') OR (&B(5)))\n&B(6)    SETB  (('&OPTIONS(&A)' EQ 'ENTRY')  OR (&B(6)))\n&B(7)    SETB  (('&OPTIONS(&A)' EQ 'NOCSECT') OR (&B(7)))\n&B(8)    SETB  (('&OPTIONS(&A)' EQ 'NODSA') OR (&B(8)))\n.*\n.*   DEFAULT OPTIONS:\n.*      NOT 'PL1'       - NO SPECIAL PL1 CONVENTIONS\n.*      NOT 'TASK'      - NOT PL1 TASKING OPTION ('TASK' IMPLIES 'PL1')\n.*      NOT 'RECURSIVE' - NOT PL1 RECURSIVE (ONLY VALID IF 'PL1')\n.*      NO  'STMTNO'    - PL1 STATEMENT NUMBERS ALLOWED (ONLY IF 'PL1')\n.*      NOT 'DIFF'      - IGNORE 'LENGTH' AND PROVIDE STANDARD DSA\n.*      NO  'ENTRY'     - DO NOT GENERATE ENTRY STATEMENT FOR &LABEL\n.*          'CSECT'     - NEW CSECT (WITH LTORG IF NOT FIRST CSECT)\n.*          'DSA'       - GENERATE A DSA (DYNAMIC STORAGE AREA)\n.*\n         AIF   (&A LE N'&OPTIONS).A\n         AIF   ('&LABEL' NE '').B\n         MNOTE 16,'&&LABEL OMITTED -- MACRO TERMINATED'\n         MEXIT\n.B       ANOP\n&LNGTH   SETC  '72'\n         AIF   (NOT &B(1)).C\n.*       FALLS THRU IF 'PL1' SPECIFIED\n&PL1     SETB  1\n&LNGTH   SETC  '100'\n         AIF   (NOT &B(2)).C\n.*       FALLS THRU IF 'TASK' SPECIFIED\n&LNGTH   SETC  '108'\n.C       AIF   (NOT &B(5)).D\n.*       FALLS THRU IF 'DIFF' SPECIFIED\n&LNGTH   SETC  '&LENGTH'\n.D       ANOP\n&CSECT   SETC  '&LABEL'\n         AIF   (NOT &B(1)).F\n.*       FALLS THRU IF 'PL1' SPECIFIED\n         AIF   (K'&LABEL  LE 7).E\n         MNOTE 8,'EXTERNAL NAME &LABEL TRUNCATED TO 7 CHARACTERS'\n&CSECT   SETC  '&LABEL'(1,7)\n.E       ANOP\n&BNAME   SETC  '&CSECT'.'B'\n&BNAME   DXD   A                        ALLOCATE THE PSEUDO-REGISTER\n         AIF   (NOT &B(3)).F\n.*       FALLS THRU IF 'RECURSIVE' PL1\n&CNAME   SETC  '&CSECT'.'C'\n&CNAME   DXD   F                        ALLOCATE THE PSEUDO-REGISTER\n.F       AIF   (NOT &B(6)).G\n.*       FALLS THRU IF 'ENTRY' SPECIFIED\n         ENTRY &CSECT                   MARK &CSECT AS AN ENTRY POINT\n.G       AIF   (NOT &B(7)).H\n.*       FALLS THRU IF 'NOCSECT' SPECIFIED\n&CSECT   DS    0H                       ENTRY POINT\n         AGO   .J\n.H       AIF   (NOT &LTORG).I\n         LTORG\n         EJECT\n.I       ANOP\n&LTORG   SETB  1\n&CSECT   CSECT                          ENTRY POINT\n.J       USING &CSECT,15                ESTABLISH ADDRESSABILITY\n         SAVE  (14,12),,&CSECT          SAVE CALLER'S REGISTERS\n         AIF   (&B(7)).K\n.*       FALLS THRU IF 'CSECT' SPECIFIED\n         LR    &BASEREG,15              ESTABLISH BASE REGISTER\n         USING &CSECT,&BASEREG          ESTABLISH ADDRESSABILITY\n         AGO   .L\n.K       L     &BASEREG,=A(&SYSECT)     LOAD OLD BASE ADDRESS\n         USING &SYSECT,&BASEREG         ESTABLISH ADDRESSABILITY\n.L       DROP  15                       DROP ENTRY BASE\n         AIF   (&B(8)).R\n.*       FALLS THRU IF A 'DSA' IS TO BE PROVIDED\n         LR    2,13                     CALLER'S SAVE AREA ADDRESS\n         AIF   (&SUBPOOL GT 0).L1\n         L     0,=A(&LNGTH)             LOAD SUBPOOL AND NUMBER\n         AGO   .L2\n.L1      LA    0,&SUBPOOL.(0,0)         LOAD SUBPOOL NUMBER\n         SLL   0,24(0)                  SHIFT TO HIGH ORDER BYTE\n         O     0,=A(&LNGTH)             OR IN 'DSA' LENGTH\n.L2      GETMAIN R,LV=(0)               BUY A 'DSA'\n&USEDDSA SETB  1\n&SP      SETA  &SUBPOOL\n&A       SETA  108\n         AIF   (&B(2)).M\n.*       FALLS THRU IF 'TASK' NOT SPECIFIED\n&A       SETA  100\n         AIF   (&B(1)).M\n.*       FALLS THRU IF 'PL1' NOT SPECIFIED\n&A       SETA  72\n         AIF   ('&CLEAR' EQ '').M\n         AIF   (T'&CLEAR NE 'N').L3\n&A       SETA  &CLEAR\n         AIF   (&A LE 256).M\n&A       SETA  256\n         AGO   .M\n.L3      XC    0(&CLEAR,1),0(1)         CLEAR THE NEW 'DSA'\n         AGO   .M1\n.M       XC    0(&A,1),0(1)             CLEAR THE NEW 'DSA'\n.M1      ST    13,4(0,1)                STORE OLD ADDRESS IN NEW\n         ST    1,8(0,13)                STORE NEW ADDRESS IN OLD\n         LR    13,1                     PLACE NEW ADDRESS IN R13\n         MVC   0(4,13),=A(&LNGTH)       MOVE IN 'DSA' LENGTH\n         AIF   (NOT &B(1)).Q\n.*       FALLS THRU IF 'PL1' SPECIFIED\n&A       SETA  128\n         AIF   (NOT &B(3)).N\n.*       FALLS THRU IF 'RECURSIVE' PL1\n&A       SETA  &A+4\n&RECUR   SETB  1\n.N       AIF   (NOT &B(4)).O\n.*       FALLS THRU IF 'STMTNO' SPECIFIED\n&A       SETA  &A+64\n&STMT    SETB  1\n.O       MVI   0(13),&A                 SET 'DSA' FLAGS\n         LA    1,0(0,0)                 GET THE\n         ORG   *-2                        OFFSET OF\n         DC    QL2(&BNAME)                  THE PSEUDO-REGISTER\n         ST    1,88(0,13)               STORE PSEUDO-REGISTER OFFSET\n         AIF   (NOT &B(3)).P\n.*       FALLS THRU IF 'RECURSIVE' PL1 SPECIFIED\n         L     0,0(1,12)                LOAD OLD PSEUDO-REGISTER\n         ST    0,92(0,13)               SAVE OLD PSEUDO-REGISTER\n.P       ST    13,0(1,12)               STORE NEW PSEUDO-REGISTER\n         AIF   (NOT &B(3)).Q\n.*       FALLS THRU IF 'RECURSIVE' PL1 SPECIFIED\n         LA    1,0(0,0)                 GET THE OFFSET\n         ORG   *-2                        OF THE INVOCATION\n         DC    QL2(&CNAME)                  COUNT PSEUDO-REGISTER\n         STH   1,88(0,13)               SAVE PSEUDO-REGISTER OFFSET\n         L     15,0(1,12)               LOAD OLD INVOCATION COUNT\n         ST    15,84(0,13)              SAVE OLD INVOCATION COUNT\n         LA    15,1(0,15)               ADD 1 TO INVOCATION COUNT\n         ST    15,0(1,12)               STORE NEW PSEUDO-REGISTER\n.Q       LM    15,2,16(2)               RESTORE PASSED REGISTERS\n.R       OACREGS ,                      DEFINE SYMBOLIC REGISTERS\n         MEND\n         SPACE 4\n         MACRO\n&LABEL   FREEDSA &RC=0,&BRC=\n         GBLA  &SP,&STMTNO\n         GBLB  &BADSTMT,&PL1,&RECUR,&STMT,&USEDDSA\n         AIF   ('&RC'(1,1) NE '(').C\n         AIF   ((&RC(1) GE 0) AND (&RC(1) LE 15)).A\n.ERR     MNOTE 8,'RC=&RC INVALID -- MACRO TERMINATED'\n         MEXIT\n.A       AIF   (&RC(1) EQ 15).B\n&LABEL   LR    15,&RC(1)                LOAD THE RETURN CODE\n         AGO   .F\n.B       AIF   ('&LABEL' EQ '').F\n&LABEL   DS    0H                       EXIT PROCEDURE\n         AGO   .F\n.C       AIF   (T'&RC NE 'N').E\n         AIF   (&RC EQ 0).D\n&LABEL   LA    15,&RC.(0,0)             LOAD THE RETURN CODE\n         AGO   .F\n.D       ANOP\n&LABEL   SR    15,15                    CLEAR THE RETURN CODE TO ZERO\n         AGO   .F\n.E       AIF   ('&RC' EQ '').ERR\n&LABEL   L     15,&RC                   LOAD THE RETURN CODE\n.F       AIF   (NOT &USEDDSA).H\n         LR    2,13                     SAVE CURRENT SAVE AREA ADDRESS\n         L     13,4(0,13)               LOAD OLD SAVE AREA ADDRESS\n         STM   15,1,16(13)              SAVE RETURN REGISTERS\n         AIF   (NOT &PL1).G\n         LH    1,90(0,2)                PSEUDO-REGISTER OFFSET\n         L     0,92(0,2)                OLD PSEUDO-REGISTER\n         ST    0,0(1,12)                RESTORE OLD PSEUDO-REGISTER\n         AIF   (NOT &RECUR).G\n         LH    1,88(0,2)                INVOCATION COUNT P-R OFFSET\n         L     0,84(0,2)                OLD INVOCATION COUNT\n         ST    0,0(1,12)                RESTORE INVOCATION COUNT P-R\n.G       MVI   0(2),&SP                 MOVE SUBPOOL NUMBER WITH LENGTH\n         L     0,0(0,2)                 LOAD SUBPOOL AND LENGTH\n         LR    1,2                      WHERE TO FREE CORE\n         FREEMAIN R,LV=(0),A=(1)        FREE THE DSA CORE\n         AGO   .I\n.H       STM   15,1,16(13)              SAVE RETURN REGISTERS\n.I       LM    14,12,12(13)             RESTORE CALLER'S REGISTERS\n         MVI   12(13),X'FF'             SET COMPLETION INDICATOR\n         AIF   ('&BRC' EQ '').J\n         B     0(14,15)                 BRANCH TO RETURN CODE OFFSET\n         AGO   .K\n.J       BR    14                       RETURN TO CALLER\n.K       ANOP\n&STMTNO  SETA  0\n&BADSTMT SETB  0\n&PL1     SETB  0\n&RECUR   SETB  0\n&STMT    SETB  0\n&USEDDSA SETB  0\n         MEND\n         SPACE 4\n         MACRO\n         RCRD  &A,&B\n         ORG   TRTTABLE+X'&A'\n         DC    X'&B'\n         ORG   ,\n         MEND\n         MACRO\n         BLDLLIST\nBLDLLIST DSECT\nBLDLCNT  DC    H'1' .                   NUMBER OF ENTRIES\nBLDLLEN  DC    H'64' .                  LENGTH OF ENTRY\nBLDLNAME DC    CL8' ' .                 MODULE NAME\nBLDLTTRC DC    F'0' .                   TTRC OF MEMBER\nBLDLLIB  DC    X'00' .                  LIBRARY\nBLDLIND1 DC    X'00' .                  INDICATORS AND LENGTH\nBLDLTTRT DC    3X'00' .                 TTR OF TEXT RECORD\nBLDLZ1   DC    X'00' .                  ZEROS\nBLDLTTRN DC    3X'00' .                 TTR OF NOTE/SCTR LIST\nBLDLNL   DC    X'00' .                  # ENTRIES IN NOTE LIST\n         SPACE 1\nBLDLATR1 DC    X'00' .                  ATTRIBUTES\nBLDLRENT EQU   X'80' .                  REENTERABLE\nBLDLREUS EQU   X'40' .                  REUSABLE\nBLDLOVLY EQU   X'20' .                  OVERLAY\nBLDLTEST EQU   X'10' .                  TESTRAN\nBLDLOL   EQU   X'08' .                  ONLY LOADABLE\nBLDLSCTR EQU   X'04' .                  SCTR FORMAT\nBLDLEXEC EQU   X'02' .                  EXECUTABLE\n         SPACE 1\nBLDLATR2 DC    X'00' .                  ATTRIBUTES, 2ND BYTE\nBLDLSIZE DC    3X'00' .                 LENGTH OF MODULE\n         ORG   BLDLNAME+38\nBLDLIAS  DC    CL8' ' .                 ALIAS NAME FOR RENT MODULE\nBLDLTOT  EQU   68\n         MEND\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*        PROGRAM: COMPARES TWO LOAD MODULES OR PARTS OF LOAD MODULES. *\n*                                                                     *\n*        METHOD:  ACTS AS A PSEUDO-LOADER.  BUYS AND CLEARS TWO CORE  *\n*                 AREAS INTO WHICH THE MODULES' TEXT BLOCKS ARE READ. *\n*                 RELOCATABLE REFERENCES ARE RESOLVED USING A COMMON  *\n*                 EXTERNAL SYMBOL TABLE TO SOLVE THE PROBLEMS OF      *\n*                 DIFFERENT CSECT ORDER AND DIFFERENT LOAD POINTS.    *\n*                                                                     *\n*        ATTRIB:  REENTRANT, REUSABLE.                                *\n*                                                                     *\n*        MISSING: CAN'T HANDLE OVERLAY MODULES.                       *\n*                                                                     *\n*        AUTHOR:  LOU P. RIVAS  -  UCLA/CCN.                JUNE 1977 *\n*                                                                     *\n*        PARM='NAME1(OFFSET1),NAME2(OFFSET2),COUNT'                   *\n*  (IF PARM IS OMMITED THEN ALL MODULES ON I1 WILL BE COMPARED        *\n*   WITH CORRESPONDING NAMED MODULES IN I2 AND WTO'S WILL BE DONE     *\n*   TO DDNAME 'WTO')                                                  *\n*                                                                     *\n* --> TTRL XCTL TABLES WILL BE MODIFIED SO DIFFERENT TTRL'S WILL      *\n*     MATCH. (MODULE IS DETERMINED TO HAVE TTRL'S BY MODULE NAME)     *\n*                                                                     *\n*        //I1       DD ...              PDS WITH LOAD MODULE NAME1.   *\n*        //I2       DD ...              PDS WITH LOAD MODULE NAME2.   *\n*        //SNAP     DD SYSOUT=A,...     OUTPUT FILE/MISMATCHES+SNAP.  *\n*        //SYSPRINT DD SYSOUT=A,...     OPTIONAL OUTPUT (NO SNAP).    *\n*        //WTO      DD SYSOUT=A,...     WTO FILE IF NO PARM (ALL)     *\n*                                                                     *\n*        (OFFSET#) IS OPTIONAL AND TAKES THE FORM:                    *\n*               (LABEL) WHERE 'LABEL' IS A CSECT OR ENTRY IN NAME#.   *\n*               (+NUMBER) WHERE 'NUMBER' IS AN OFFSET INTO THE NAME#; *\n*                   'NUMBER' IS ASSUMED HEX AND 'NUMBER.' IS DECIMAL. *\n*               (LABEL+NUMBER) WHICH IS THE OFFSET INTO THE LABEL.    *\n*                                                                     *\n*        COUNT IS OPTIONAL AND TAKES THE FORM 'NUMBER.' OR 'NUMBER'.  *\n*               IF COUNT IS NOT SPECIFIED, THE NUMBER OF BYTES THAT   *\n*               ARE COMPARED IS THE LARGER OF THE TWO MODULE LENGTHS  *\n*               OR THE LARGER OF THE TWO CSECT LENGTHS IF BOTH        *\n*               (OFFSET#) SPECIFY CSECTS, ADJUSTED BY THE LENGTH IN   *\n*               (OFFSET#) AS APPROPRIATE.  COUNT CAN ONLY BE USED TO  *\n*               REDUCE THE COMPARE LENGTH.                            *\n*                                                                     *\n*        IF ANY 'NUMBER' IS INVALID (E.G. OUTSIDE MODULE OR CSECT),   *\n*        IT IS IGNORED.  IF 'LABEL' IS NOT FOUND, IT IS IGNORED.      *\n*                                                                     *\n*        SYNTACTICAL ERRORS WILL CAUSE A 'PARM INVALID' ERROR         *\n*        MESSAGE.  WRONG PARAMETERS WILL CAUSE UNPREDICTABLE RESULTS. *\n*                                                                     *\n* RETURN CODES: 00 - ALL MODULE(S) COMPARED SUCCESSFULLY              *\n*               04 - COMPARE FAILED (AT LEAST 1 IF 'ALL)              *\n*               08 - INITIALIZATION FAILED (LAST MODULE IF 'ALL')     *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*        FLOW OF CONTROL:                                             *\n*                                                                     *\n*          1) ENTER, BUY WORK AREA, AND CHAIN SAVE AREAS.             *\n*          2) PARSE PARM STRING.                                      *\n*          3) 'OPEN' FILES.                                           *\n*          4) 'BLDL', GET CORE FOR TEXT BLOCKS, AND 'FIND' MEMBER.    *\n*          5) CLEAR TEXT BUFFER AND 'READ' ALL MEMBER BLOCKS.         *\n*             A) CLEAR TEXT BUFFER; LENGTH IS FROM BLDLSIZE.          *\n*             B) SET FLAG INDICATING \"NOTE LIST\" PRESENT.             *\n*             C) IF FIRST RECORD IS TEXT, GO READ IT (AT III).        *\n*             D) READ NON-TEXT RECORD.                                *\n*                I) IF EOF THEN CLEAR LABEL IF NOT FOUND AND DONE.    *\n*               II) IF \"NOTE LIST\" RECORD THEN IGNORE IT.             *\n*              III) IF CONTROL THEN READ NEXT TEXT RECORD.            *\n*               IV) IF CESD THEN RESOLVE LABEL AND BUILD COMMON ESD.  *\n*                V) IF RLD THEN RESOLVE RELOCATABLE REFERENCES.       *\n*          6) USE OFFSET# AND COUNT TO INITIALIZE FOR COMPARE LOOP.   *\n*          7) COMPARE TEXT BUFFERS BYTE BY BYTE; OUTPUT EACH UNEQUAL. *\n*          8) 'SNAP' TEXT BUFFERS IF ANY UNEQUALITIES.                *\n*          9) FREE TEXT BUFFERS, 'CLOSE' FILES, AND EXIT.             *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n* UPDATES: 001 - 11/22/78 - 1) ALLOW DDNAME=SYSPRINT AS OPTIONAL      *\n*                              OUTPUT FILE (REPLACES DDNAME=SNAP).    *\n*                              IF SYSPRINT USED, THEN DO MISMATCH     *\n*                              LOGGING, BUT DON'T DO PSEODO-SNAP.     *\n*                           2) IF OUTPUT FILE (SNAP OR SYSPRINT) IS   *\n*                              ALLOCATED TO TSO AS TERMFILE: 1) DON'T *\n*                              OPEN FILE, AND 2) FAKE OUT WRITES TO   *\n*                              GO TO CODE THAT TPUTS THE RECORDS.     *\n*                           3) REMOVE MAIN STORAGE ADDRESSES FROM     *\n*                              MISMATCH LINE SINCE REAL SNAP NO       *\n*                              LONGER USED.                           *\n*          002 - 09/11/79 - 1) FIX 4MEG CONSTANT DEPENDENCY.          *\n*                           2) FIX XCTL TTR RESOLUTION CODE TO        *\n*                              HANDLE SUBLISTS.                       *\n*          003 - 04/23/80 - 1) CONVERT TO MVS.                        *\n*          004 - 12/31/80 - 1) FIX UNPK 0C4 BUG.                      *\n*                           2) ADD TWO NEW RETURN CODES:              *\n*                              04 - COMPARE FAILED.                   *\n*                              08 - INITIALIZATION FAILED.            *\n*          005 - 12/17/81 - 1) FIX UNFINDABLE CSECT BUG - (1 BIT CHG) *\n*          SBG - 08/14/14 - 1) ADDED SECOND BASE REGISTER             *\n*                           2) EXPANDED DIFFERENCE REPORT TO INCLUDE  *\n*                              THE EBCDIC BIT (IF PRINTABLE) AFTER    *\n*                              THE HEX DISPLAY, FOR I1 AND I2.        *\n*      GP14226 - 08/15/14 - WATCH OUT FOR PAGE FAULT AFTER FULLWORD   *\n*                           BOUNDARY.                                 *\n*                                                                     *\n***********************************************************************\n         EJECT\nCOMPLOAD GETDSA SUBPOOL=0,LENGTH=WORKLEN,OPTIONS=DIFF,CLEAR=256\n         LA    R11,2048(,R10)           ADD SECOND BASE REGISTER    SBG\n         LA    R11,2048(,R11)                                       SBG\n         DROP  R10                                                  SBG\n         USING COMPLOAD,R10,R11                                     SBG\n         SPACE 2\n         USING WORKAREA,R13             ADDRESSABILITY\n         SPACE 2\n         XC    WORKAREA+1*256(256),WORKAREA+1*256 CLEAR\n         XC    WORKAREA+2*256(256),WORKAREA+2*256 CLEAR\n         XC    WORKAREA+3*256(BASELEN-3*256),WORKAREA+3*256 THE REST\n         SPACE 2\n         L     R0,=V(TRTCSECT)    SAVE HEX TRANSLATE TABLE POINTER  SBG\n         ST    R0,SAVETRT         AND STORE IT FOR LATER USE.       SBG\nSNAPBLKS EQU   1632                     BLKSIZE FOR 'SNAP' FILE\n         SPACE 2\nSTABCESD EQU   1000                     NUMBER OF CESD TABLE ENTRIES\n         EJECT\n         MVI   RETCODE+3,8              SET INIT FAILED RETCODE     004\n         MVC   DCBWTO(DCBPSQX),DCBPSQ   INITIALIZE WTO DCB\n         MVC   SNAP(DCBPSX),DCBPS       INITIALIZE SNAP DCB\n         MVC   I1(DCBPOX),DCBPO         INITIALIZE FIRST DCB\n         MVC   I2(DCBPOX),DCBPO         INITIALIZE SECOND DCB\n         MVI   I2+DCBDDNAM+1-IHADCB,C'2'  AND CORRECT THE DD NAME\n         MVC   DECB(DECBX),DECBRW       INITIALIZE DECB\n         XC    DCBLIST(16),DCBLIST      INIT OPEN LIST\n         MVI   DCBLIST+8,X'80'          ASSUME NOT 'ALL' OPTION\n         SPACE 2\n         N     R1,=XL4'00FFFFFF'        PARM POINTER WORD THERE ?   002\n         BZ    ERR1                     NO, GO TELL USER\n         L     R1,0(R1)                 LOAD PARM ADDRESS\n         N     R1,=XL4'00FFFFFF'        ANY PARM ?                  002\n         BZ    ERR1                     NO, GO TELL USER\n         LH    R2,0(R1)                 LOAD PARM LENGTH\n         LTR   R2,R2                    ANY PARM ?\n         BNZ   HAVEPARM                 YES, GO PROCESS IT\n         SPACE 1\n         MVI   DCBLIST+8,0\n         MVI   DCBLIST+12,X'80'         OPEN 'WTO' TOO\n         B     OPEN                     GO OPEN DATASETS\n         SPACE 1\nHAVEPARM CH    R2,=H'3'                 LONG ENOUGH ?\n         BL    ERR2                     NO, GO TELL USER\n         LA    R1,2(R1)                 POINT TO PARM PROPER\n         SPACE 1\n         LA    R3,NAME1                 WHERE TO PUT FIRST NAME\n         BAL   R14,NAME                 GO MOVE IT IN\n         SPACE 1\n         LTR   R2,R2                    BACK WITH NOTHING LEFT ?\n         BZ    ERR2                     YES, GO TELL USER\n         LA    R3,NAME2                 WHERE TO PUT SECOND NAME\n         BAL   R14,NAME                 GO MOVE IT IN\n         SPACE 1\n         LTR   R2,R2                    BACK WITH NOTHING LEFT ?\n         BZ    OPEN                     YES, NO COUNT FIELD\n         SPACE 1\n         BAL   R15,NUMBER               GO CONVERT THE COUNT\n         ST    R0,COUNT                 SAVE IT\n         SPACE 1\nOPEN     OPEN  (SNAP,OUTPUT,I1,,I2,,DCBWTO,OUTPUT),MF=(E,DCBLIST)\n         ORG   *-2                      EMBARASSING KLUDGE HERE     001\n         L     R15,=A(OPEN#CHK)         ADDR OF OPEN CHECK CODE     001\n         BALR  R14,R15                  GO DO PRE-OPEN CHECKS       001\n         EJECT\n         TM    SNAP+DCBOFLGS-IHADCB,DCBOFOPN OPEN ?\n         BZ    NOWTO                    NO\n         TM    I1+DCBOFLGS-IHADCB,DCBOFOPN OPEN ?\n         BZ    NOWTO                    NO\n         TM    I2+DCBOFLGS-IHADCB,DCBOFOPN OPEN ?\n         BZ    NOWTO                    NO\n         SPACE 1\n         TM    FLAGS,FG#ALL             PROCESSING ALL MEMBERS?     001\n         BZ    NOTALL                   NO - BRANCH                 001\nALLLOOP  L     R15,=A(GETENT)           @ GETENT ROUTINE\n         BALR  R14,R15                  GO GET MODULE NAME\n         SPACE 2\nNOTALL   LA    R2,NAME1                 DO FIRST ONE\n         LA    R3,ERR3                  ERROR EXIT\n         BAL   R4,BLDLFIND              GO GET CORE FOR MODULE\n         SPACE 1\n         LA    R2,NAME2                 DO SECOND ONE\n         LA    R3,ERR4                  ERROR EXIT\n         BAL   R4,BLDLFIND              GO GET CORE FOR MODULE\n         SPACE 2\n         LA    R2,NAME1                 DO FIRST ONE\n         BAL   R4,CLEAREAD              GO READ IN MODULE\n         SPACE 1\n         LA    R2,NAME2                 DO SECOND ONE\n         BAL   R4,CLEAREAD              GO READ IN MODULE\n         SPACE 1\n         L     R15,=A(SUP)              BASE FOR IOSUP ROUTINE\n         LA    R1,NAME1                 GO FIX TTRL'S MODULE 1\n         BALR  R14,R15\n         LA    R1,NAME2                 AND MODULE 2\n         BALR  R14,R15\n         SPACE 2\n         L     R5,COMPADR1              FIRST MODULE COMPARE START\n         L     R6,COMPADR2              SECOND MODULE COMPARE START\n         L     R7,COMPLEN1              FIRST MODULE COMPARE LENGTH\n         L     R8,COMPLEN2              SECOND MODULE COMPARE LENGTH\n         SPACE 1\n         A     R5,NUMBER1               ADJUST FIRST MODULE\n         A     R6,NUMBER2               ADJUST SECOND MODULE\n         S     R7,NUMBER1               ADJUST FIRST LENGTH\n         S     R8,NUMBER2               ADJUST SECOND LENGTH\n         SPACE 1\n         OC    COUNT,COUNT              COMPARE LENGTH SPECIFIED ?\n         BZ    NOCOUNT                  NO\n         C     R7,COUNT                 NEED TO ADJUST AGAIN ?\n         BNH   *+8                      NO, SKIP NEXT\n         L     R7,COUNT                 ADJUST IT\n         C     R8,COUNT                 NEED TO ADJUST AGAIN ?\n         BNH   *+8                      NO, SKIP NEXT\n         L     R8,COUNT                 ADJUST IT\n         SPACE 2\nNOCOUNT  XR    R2,R2                    INDICATE NO OUTPUT YET\n         SPACE 1\n         LTR   R7,R7                    IS FIRST LENGTH ZERO ?\n         BZ    DONECOMP                 YES, ALMOST FINISHED\n         LTR   R8,R8                    IS SECOND LENGTH ZERO ?\n         BZ    DONECOMP                 YES, ALMOST FINISHED\n         SPACE 2\n         LA    R4,1                     USEFUL CONSTANT\n         EJECT\nCOMPLOOP CLC   0(1,R5),0(R6)            ARE THESE TWO BYTES EQUAL ?\n         BE    NEXTCOMP                 YES, NO OUTPUT THIS TIME\n         SPACE 1\n         BAL   R3,OUTPUT                INDICATE WHERE IT FAILED\n         SPACE 1\nNEXTCOMP AR    R5,R4                    NEXT MODULE1\n         AR    R6,R4                    NEXT MODULE2\n         SPACE 1\n         BCT   R7,*+10                  SKIP NEXT TWO IF MORE MODULE1\n         BCTR  R8,0                     ALSO DECREMENT MODULE2\n         B     DONECOMP                 NEARLY DONE\n         BCT   R8,COMPLOOP              LOOP IF MORE MODULE2\n         SPACE 2\nDONECOMP CR    R7,R8                    LENGTH MISMATCH ?\n         BE    SNAPDUMP                 NO, ALL DONE\n         SPACE 1\n         XR    R4,R4                    INDICATE LENGTH CALL\n         BAL   R3,OUTPUT                INDICATE WHERE IT FAILED\n         SPACE 1\nSNAPDUMP CLI   RETCODE+3,4              PREVIOUS COMPARE BOMBED?    004\n         BE    *+8                      BIF YES - DON'T RESET CODE  004\n         MVI   RETCODE+3,0              SET COMPARE WORKED RETCODE  004\n         LTR   R2,R2                    ANY OUTPUT ?\n         LA    R1,WTO00                 ASSUME 'COMPARES' MESSAGE\n         BZ    WTOX                     NO, ALL DONE\n         SPACE 1\n         MVI   RETCODE+3,4              SET COMPARE FAILED RETCODE  004\n         L     R0,COMPADR1              MODULE1 STARTING ADDRESS\n         LR    R1,R0                    COPY FOR ENDING ADDRESS\n         A     R1,COMPLEN1              ADD LENGTH FOR ENDING ADDRESS\n         BCTR  R1,0                     IT IS INCLUSIVE\n         L     R2,COMPADR2              MODULE2 STARTING ADDRESS\n         LR    R3,R2                    COPY FOR ENDING ADDRESS\n         A     R3,COMPLEN2              ADD LENGTH FOR ENDING ADDRESS\n         BCTR  R3,0                     IT IS INCLUSIVE\n         SPACE 1\n         STM   R0,R3,WRKWRDS            SAVE LIST ADDRESSES\n         SPACE 1\n         LA    R2,2                     LOOP TWO TIMES\n         LA    R1,WRKWRDS               WHERE LISTS START\n         L     R15,=A(SNAPIT)           @ SNAP ROUTINE\nSNAPLOOP BALR  R14,R15                  DUMP IT\n         LA    R1,8(R1)                 NEXT LIST\n         BCT   R2,SNAPLOOP              GO AGAIN\n         SPACE 1\n         XR    R4,R4                    FLUSH LAST OUTPUT BUFFER\n         BCTR  R4,0                       INDICATOR\n         LA    R2,RECORD                SET ADR FOR WRITE IF ANY\n         BAL   R3,OUTPUT                INDICATE ALL DONE\n         EJECT ,\n         SPACE 1\n         LA    R1,WTO01                 'COMPARE FAIL' MESSAGE\n         SPACE 1\nWTOX     MVC   RECORD(256),0(R1)        MOVE THE WTO TO WORK AREA\n         MVC   RECORD+12(8),NAME1       FILL IN THE\n         MVC   RECORD+36(8),NAME2         MODULE NAMES\nWTOY     LA    R1,RECORD                FINISHED WTO\n         SPACE 2\nWTO      TM    FLAGS,FG#ALL             PROCESSING ALL MEMBERS?     001\n         BZ    WTO#                     NO - BRANCH                 001\n         LR    R0,R1                    SET RECORD OUTPUT\n         PUT   DCBWTO,(0)               PRINT THE MSG\n         B     NOWTO                    AND CONTINUE\n         SPACE 1\nWTO#     WTO   MF=(E,(R1))              DONE\n         SPACE 1\nNOWTO    LM    R0,R1,LENGTH1            FIRST MODULE LENGTH AND ADDRESS\n         LM    R2,R3,LENGTH2              AND SAME FOR SECOND MODULE\n         STM   R0,R3,WRKWRDS            SAVE LENGTH AND ADDRESS PAIRS\n         SPACE 1\n         LA    R2,2                     LOOP TWO TIMES\n         LA    R3,WRKWRDS               WHERE PAIRS START\n         SPACE 1\nFREELOOP LM    R0,R1,0(R3)              LOAD LENGTH AND ADDRESS PAIR\n         LTR   R1,R1                    ANYTHING THERE ?\n         BZ    NEXTFREE                 NO, NOTHING BOUGHT\n         SPACE 1\n         FREEMAIN R,LV=(0),A=(1)        FREE BOUGHT CORE\n         SPACE 1\nNEXTFREE LA    R3,8(R3)                 NEXT PAIR\n         BCT   R2,FREELOOP              GO AGAIN\n         SPACE 1\n         XC    FRSTTAB(NEXTTAB-FRSTTAB+L'NEXTTAB),FRSTTAB  CLEAN UP\n         XC    NAME1(BLDL1-NAME1),NAME1 CLEAN UP I1 STUFF\n         XC    NAME2(BLDL2-NAME2),NAME2 AND I2\n         MVI   FLAG,0                   AND ZERO FLAG\n         SPACE 1\n         TM    FLAGS,FG#ALL             PROCESSING ALL MEMBERS?     001\n         BO    ALLLOOP                  YES - GO GET NEXT           001\n         SPACE 1\nALLDONE  CLOSE MF=(E,DCBLIST)           CLOSE ALL FILES OPENED\n         EJECT ,\n         LA    R1,DCBWTO                GET @ DCB FOR FREEPOOL\n         TM    23(R1),1                 ANY BUFFER POOL?\n         BO    NOSWIM                   BRANCH IF NO POOL\n         FREEPOOL (1)                   FREE BUFFER POOL\n         SPACE 1\nNOSWIM   FREEDSA RC=RETCODE             FREE WORKAREA/SET RC/RETURN 004\n         SPACE 2\nERR1     LA    R1,WTO02                 ERROR MESSAGE\n         B     WTO                      DO IT\n         SPACE 1\nERR2     LA    R1,WTO03                 ERROR MESSAGE\n         B     WTO                      DO IT\n         SPACE 1\nERR3     LA    R3,C'1'                  INDICATE LIBRARY\n         B     *+8                      SKIP NEXT\nERR4     LA    R3,C'2'                  ERROR MESSAGE\n         MVC   RECORD(256),WTO04        MOVE THE WTO TO WORK AREA\n         MVC   RECORD+12(8),0(R2)       FILL IN THE\n         STC   R3,RECORD+35               NAME AND LIBRARY\n         MVI   RETCODE+3,4              SET COMPARE FAILED RETCODE  004\n         B     WTOY                     DO IT\n         SPACE 1\nERR5     L     R1,WRKWRDS               GET REQUESTED SIZE\n         LA    R1,1023(R1)              ROUND UP\n         SRL   R1,10                    AND MAKE IT K\n         CVD   R1,WRKWRDS               TO DECIMAL\n         OI    WRKWRDS+7,X'0F'          FIX SIGN\n         UNPK  WRKWRDS(5),WRKWRDS+5(3)  TO PRINTABLES\n         MVC   RECORD(256),WTO05        MOVE THE WTO TO WORK AREA\n         MVC   RECORD+26(5),WRKWRDS     FILL IN THE AMOUNT\n         MVI   RETCODE+3,4              SET COMPARE FAILED RETCODE  004\n         B     WTOY                     DO IT\n         SPACE 1\nERR6     LA    R1,WTO06                 ERROR MESSAGE\n         MVI   RETCODE+3,4              SET COMPARE FAILED RETCODE  004\n         B     WTO                      DO IT\n         EJECT\nNAME     MVI   0(R3),C' '               BLANK THE NAME AND\n         MVC   1(7+8,R3),0(R3)            LABEL RECEIVING FIELDS\n         LA    R4,8(R3)                 SAVE LABEL FIELD START\n         SPACE 1\n         CLI   0(R1),C','               NO NAME ?\n         BE    ERR2                     YES, GO TELL USER\n         CLI   0(R1),C'('               OTHER NO NAME ?\n         BE    ERR2                     YES, GO TELL USER\n         SPACE 1\n         BAL   R15,MOVENAME             COPY NAME\n         B     ERR2                     WRONG SEPARATOR, GO TELL USER\n         LA    R1,1(R1)                 STRIP SEPARATOR\n         BCT   R2,*+8                   DECREMENT REMAINDER\n         B     ERR2                     NOTHING LEFT, GO TELL USER\n         SPACE 1\n         LR    R5,R14                   SAVE RETURN ADDRESS\n         LA    R14,ERR2                 NEW RETURN ADDRESS\n         CLI   0(R1),C')'               ONLY '()' ?\n         BER   R14                      YES, GO TELL USER\n         CLI   0(R1),C'+'               NO LABEL ?\n         BE    NOCSECT                  YES, SKIP THIS THEN\n         SPACE 1\n         LR    R3,R4                    NEW OUTPUT LOCATION\n         BAL   R15,MOVENAME             COPY LABEL\n         B     *+8                      SKIP ERROR RETURN\n         B     ERR2                     WRONG SEPARATOR, GO TELL USER\n         SPACE 1\n         CLI   0(R1),C'+'               OFFSET ?\n         BNE   ENDNAME                  NO, SKIP THIS THEN\n         SPACE 1\nNOCSECT  LA    R1,1(R1)                 STRIP '+' SEPARATOR\n         BCT   R2,*+6                   DECREMENT REMAINDER\n         BR    R14                      NOTHING LEFT, GO TELL USER\n         SPACE 1\n         BAL   R15,NUMBER               GO CONVERT NUMBER\n         ST    R0,8(R4)                 SAVE THE NUMBER\n         LTR   R2,R2                    ANYTHING LEFT ?\n         BZR   R14                      NO, ERROR\n         SPACE 1\nENDNAME  LR    R14,R5                   RESTORE RETURN ADDRESS\n         LA    R1,1(R1)                 STRIP ')' SEPARATOR\n         BCT   R2,*+6                   DECREMENT REMAINDER\n         BR    R14                      NOTHING LEFT, RETURN\n         CLI   0(R1),C','               RIGHT SEPARATOR ?\n         BNE   ERR2                     NO, GO TELL USER\n         SPACE 1\nNAMEEND  LA    R1,1(R1)                 STRIP SEPARATOR\n         BCTR  R2,0                     DECREMENT REMAINDER\n         BR    R14                      RETURN ALL THE WAY\n         EJECT\nMOVENAME LA    R0,9                     LOOP PREVENTION\n         SPACE 1\nNAMELOOP MVC   0(1,R3),0(R1)            MOVE IN A CHARACTER\n         BCT   R2,*+6                   SKIP NEXT IF ANY LEFT\n         BR    R14                      RETURN ALL THE WAY\n         LA    R1,1(R1)                 NEXT INPUT CHARACTER\n         LA    R3,1(R3)                 NEXT OUTPUT LOCATION\n         CLI   0(R1),C','               SEPARATOR ?\n         BE    NAMEEND                  YES, GO STRIP IT OFF\n         CLI   0(R1),C'('               OTHER SEPARATOR ?\n         BE    4(R15)                   YES, RETURN FOR LABEL\n         CLI   0(R1),C'+'               OFFSET SEPARATOR ?\n         BER   R15                      YES, RETURN FOR OFFSET\n         CLI   0(R1),C')'               OFFSET TERMINATOR ?\n         BER   R15                      YES, RETURN AFTER OFFSET\n         BCT   R0,NAMELOOP              GO AGAIN ?\n         B     ERR2                     TELL USER OF PARM ERROR\n         SPACE 5\n         PRINT NOGEN\nWTO00    WTO   'COMP00I XXXXXXXX IS THE SAME AS YYYYYYYY',             *\n               ROUTCDE=11,MF=L\nWTO01    WTO   'COMP01I XXXXXXXX DOES NOT MATCH YYYYYYYY',             *\n               ROUTCDE=11,MF=L\nWTO02    WTO   'COMP02I PARM OMITTED',ROUTCDE=11,MF=L\nWTO03    WTO   'COMP03I PARM INVALID',ROUTCDE=11,MF=L\nWTO04    WTO   'COMP04I XXXXXXXX NOT FOUND IN IY',ROUTCDE=11,MF=L\nWTO05    WTO   'COMP05I NEED AT LEAST XXXXXK MORE CORE',ROUTCDE=11,MF=L\nWTO06    WTO   'COMP06I SYMBOL TABLE TOO SMALL',ROUTCDE=11,MF=L\n         PRINT GEN\n         EJECT\nNUMBER   CLI   0(R1),C'.'               NO NUMBER ?\n         BE    ERR2                     YES, GO TELL USER\n         CLI   0(R1),C')'               OTHER NO NUMBER ?\n         BE    ERR2                     YES, GO TELL USER\n         SPACE 1\n         LA    R3,WRKWRDS+8             NUMBER OUTPUT LOCATION\n         LA    R0,9                     LOOP PREVENTION\n         SPACE 1\nNUMLOOP  IC    R6,0(R1)                 INSERT CHARACTER\n         CLI   0(R1),C'0'               NUMERIC ?\n         BNL   *+8                      YES, NO CONVERT NEEDED\n         LA    R6,X'39'(R6)             CONVERT TO HEX\n         STC   R6,0(R3)                 TO OUTPUT LOCATION\n         LA    R1,1(R1)                 NEXT INPUT CHARACTER\n         LA    R3,1(R3)                 NEXT OUTPUT CHARACTER\n         BCT   R2,*+8                   DECREMENT COUNT\n         B     GOTNUM                   HAVE THE NUMBER\n         CLI   0(R1),C')'               END OF NUMBER ?\n         BE    GOTNUM                   YES, HAVE THE NUMBER\n         BCT   R0,NUMLOOP               GO AGAIN ?\n         B     ERR2                     TELL USER OF PARM ERROR\n         SPACE 1\nGOTNUM   LA    R6,WRKWRDS+8+1           START+1 SUBTRACTED FROM\n         SR    R3,R6                      END YIELDS EXECUTE LENGTH\n         LA    R6,WRKWRDS+8(R3)         LAST CHARACTER IN NUMBER\n         CLI   0(R6),C'.'+X'39'         DECIMAL ?\n         BE    DECIMAL                  YES, EASY CONVERT\n         SPACE 1\n         EX    R3,PACK                  PACK THE HEX\n         MVO   WRKWRDS+8(5),WRKWRDS+3(5) ALIGN THIS GARBAGE\n         L     R0,WRKWRDS+8             LOAD IT\n         BR    R15                      RETURN TO CALLER\n         SPACE 1\nDECIMAL  BCTR  R3,0                     DROP THE '.'\n         EX    R3,PACK                  PACK THE HEX\n         CVB   R0,WRKWRDS               TO BINARY AND LOAD\n         BR    R15                      RETURN TO CALLER\n         SPACE 2\nPACK     PACK  WRKWRDS(8),WRKWRDS+8(0)  << EXECUTED >>\n         EJECT\n         USING LIBWORK,R2               ADDRESSABILITY\n         USING BLDLLIST,R5              ADDRESSABILITY\n         SPACE 1\nBLDLFIND LA    R5,BLDL#                 BLDL LIST AREA\n         SPACE 1\n         MVI   BLDLCNT+1,1              NUMBER OF BLDL ENTRIES\n         MVI   BLDLLEN+1,64             LENGTH OF EACH ENTRY\n         MVC   BLDLNAME,NAME#           MOVE IN NAME\n         SPACE 1\n         BLDL  I#,(R5)                  DO THE BLDL\n         BXH   R15,R15,0(R3)            ERROR, TAKE EXIT\n         SPACE 1\n         CLI   BLDLLIB,0                IN SPECIFIED LIBRARY ?\n         BNER  R3                       NO, TAKE EXIT\n         TM    BLDLIND1,B'00011000'     ENTRY LONG ENOUGH ?\n         BZR   R3                       NO, TAKE EXIT\n         TM    BLDLATR1,BLDLOVLY        INVALID ATTRIBUTE ?\n         BNZR  R3                       YES, TAKE EXIT\n         SPACE 1\n         L     R15,BLDLSIZE             LOAD SIZE OF MODULE (OFFSET 8)\n         SRL   R15,8                    SHIFT TO LOW THREE BYTES\n         ST    R15,LENGTH#              SAVE GETMAIN LENGTH\n         ST    R15,COMPLEN#               AND AS COMPARE LENGTH\n         C     R15,NUMBER#              OFFSET OUTSIDE NUMBER ?\n         BH    *+10                     NO, SKIP NEXT\n         XC    NUMBER#,NUMBER#          IGNORE NUMBER\n         SPACE 1\n         GETMAIN EC,A=ADDRESS#,LV=(R15),SP=0,MF=(E,WRKWRDS) BUY IT\n         BXH   R15,R15,ERR5             EXIT IF ERROR\n         SPACE 1\n         MVC   COMPADR#,ADDRESS#        SAVE AS COMPARE ADDRESS\n         SPACE 2\n         FIND  I#,BLDLTTRC,C            PREPARE TO READ MODULE\n         SPACE 1\n         BR    R4                       RETURN\n         EJECT\nCLEAREAD LA    R5,BLDL#                 BLDL LIST AREA\n         SPACE 1\n         L     R1,LENGTH#               LOAD LENGTH\n         L     R3,ADDRESS#              WHERE TO CLEAR CORE\n         SPACE 1\n         LA    R0,256                   USEFUL CONSTANT\n         SPACE 1\nCLEARLP  CR    R1,R0                    MORE THAN ONE XC ?\n         BNH   CLEARLST                 NO, GO DO LAST XC\n         XC    0(256,R3),0(R3)          CLEAR A PORTION\n         SR    R1,R0                    LESS AMOUNT DONE\n         AR    R3,R0                    NEXT OUTPUT\n         B     CLEARLP                  GO AGAIN\n         SPACE 1\nXC       XC    0(0,R3),0(R3)            << EXECUTED >>\n         SPACE 1\nCLEARLST LTR   R1,R1                    ANYTHING AT ALL TO CLEAR ?\n         BNP   CLEARDN                  NO, ALL DONE\n         BCTR  R1,0                     -1 FOR EXECUTE\n         EX    R1,XC                    CLEAR LAST PORTION\n         SPACE 2\nCLEARDN  L     R3,ADDRESS#              START OF TEXT BUFFER\n         LR    R6,R3                    TEXT BUFFER ADDRESS\n         L     R7,LENGTH#                 AND LENGTH FOR 'FIRST' READ\n         SPACE 1\n         OC    BLDLTTRN(3),BLDLTTRN     ANY NOTE LIST ?\n         BZ    *+8                      NO, SKIP NEXT\n         OI    BLDL#,X'F0'              MARK NOTE LIST\n         SPACE 1\n         CLC   BLDLTTRC(3),BLDLTTRT     IS FIRST RECORD TEXT ?\n         BE    READTEXT                 YES, NO CONTROL RECORD\n         SPACE 2\nNEXTRCRD READ  DECB,SF,I#,RECORD,256,MF=E READ A RECORD\n         CHECK DECB                     WAIT FOR COMPLETION\n         EJECT\n         TM    BLDL#,X'F0'              HAVE NOTE LIST ?\n         BNO   RCRDTYPE                 NO, SKIP NOTE LIST CHECK\n         SPACE 1\n         NOTE  I#                       FIND TTR OF LAST BLOCK\n         ST    R1,WRKWRDS               STORE TTRZ\n         CLC   BLDLTTRN(3),WRKWRDS      THIS THE NOTE LIST ?\n         BE    NEXTRCRD                 YES, SKIP IT\n         SPACE 2\nRCRDTYPE XR    R1,R1                    CLEAR FOR INSERT\n         IC    R1,RECORD                INSERT RECORD TYPE\n         IC    R1,TRTTABLE(R1)          DETERMINE ACTION\n         B     *(R1)                    GO TO IT\n         B     NEXTRCRD   04            IGNORE THE RECORD\n         B     DOCESD     08            PROCESS CESD\n         B     DOCNTRL    0C            PROCESS CONTROL RECORD\n*        B     DORLD      10            PROCESS RLD OR CRLD\n         SPACE 2\nDORLD    LH    R1,RECORD+6              GET AMOUNT OF DATA\n         LA    R6,RECORD+16             POINT TO R & P\n         SH    R1,=H'4'                 DECREMENT COUNT\n         LA    R7,RECORD+20             POINT TO F & A\n         SPACE 1\nRLDLOOP  TM    0(R7),B'01100000'        DON'T RELOCATE ?\n         BNZ   NEXTRLD                  TRUE, SKIP IT\n         SPACE 1\n         LH    R8,0(R6)                 ESD ID OF EXTERNAL REFERENCE\n         BCTR  R8,0                     ORIGIN ZERO\n         MH    R8,=AL2(LTABCESD)        TIMES ENTRY LENGTH\n         LA    R8,CESDTAB(R8)           THE REFERENCED ENTRY\n         SPACE 1\n         L     R14,TABCOMM-TABCESD(R8)  LOAD COMMON ADDRESS\n         S     R14,TABADDR-TABCESD(R8)  LESS OFFSET IN CESD\n         TM    0(R7),B'00000010'        NEGATIVE RELOCATION ?\n         BNO   *+6                      NO, SKIP NEXT\n         LCR   R14,R14                  ADJUST FOR NEGATIVE RELOCATION\n         SPACE 1\n         L     R15,0(R7)                OFFSET OF RELOCATABLE REFERENCE\n         LA    R15,0(R3,R15)            NOW HAVE THE ADDRESS\n         SPACE 1\n         IC    R8,0(R7)                 GET FLAGS\n         N     R8,=F'12'                ONLY WANT LENGTH INDICATION\n         B     *(R8)                    GO RELOCATE ACCORDING TO LENGTH\n         B     RLDLEN2                  LENGTH IS TWO\n         B     RLDLEN3                  LENGTH IS THREE\n*        B     RLDLEN4                  LENGTH IS FOUR\n         EJECT\nRLDLEN4  MVC   WRKWRDS(4),0(R15)        ALIGN IT\n         AL    R14,WRKWRDS              RELOCATE\n         ST    R14,WRKWRDS+4            STORE FOR MOVE\n         MVC   0(4,R15),WRKWRDS+4       PUT IT BACK\n         B     NEXTRLD                  GO DO NEXT ENTRY\n         SPACE 1\nRLDLEN3  MVC   WRKWRDS(3),0(R15)        ALIGN IT\n         L     R8,WRKWRDS                 AND LOAD IT\n         SRA   R8,8                         AND SHIFT IT\n         ALR   R14,R8                   RELOCATE\n         ST    R14,WRKWRDS+4            STORE FOR MOVE\n         MVC   0(3,R15),WRKWRDS+5       PUT IT BACK\n         B     NEXTRLD                  GO DO NEXT ENTRY\n         SPACE 1\nRLDLEN2  MVC   WRKWRDS(2),0(R15)        ALIGN IT\n         LH    R8,WRKWRDS                 AND LOAD IT\n         ALR   R14,R8                   RELOCATE\n         STH   R14,WRKWRDS+4            STORE FOR MOVE\n         MVC   0(2,R15),WRKWRDS+4       PUT IT BACK\n         SPACE 1\nNEXTRLD  TM    0(R7),B'00000001'        USE SAME R & P ?\n         BO    *+14                     YES\n         LA    R6,4(R7)                 NEXT R & P\n         SH    R1,=H'4'                 ADJUST LENGTH\n         LR    R7,R6                    PRETEND IT WAS LAST F & A\n         SPACE 1\n         LA    R7,4(R7)                 NEXT F & A\n         SH    R1,=H'4'                 ADJUST LENGTH\n         BP    RLDLOOP                  MORE TO DO\n         SPACE 2\n         TM    RECORD,B'00000001'       RLD ALSO A CONTROL RECORD ?\n         BO    DOCNTRL                  YES, GO READ TEXT\n         TM    RECORD,B'00001000'       LAST RLD RECORD ?\n         BZ    NEXTRCRD                 NO, GO READ NEXT\n         SPACE 2\nEOM      TM    BLDL#,X'0F'              LABEL FOUND ?\n         BOR   R4                       YES, RETURN\n         MVI   LABEL#,C' '              CLEAR THE\n         MVC   LABEL#+1(7),LABEL#         LABEL FIELD\n         BR    R4                       RETURN\n         EJECT\nDOCNTRL  MVI   RECORD+8,0               CLEAR READ COMMAND FROM CCW\n         LR    R6,R3                    COPY ADDRESS START\n         A     R6,RECORD+8              ADD OFFSET TO DATA START\n         LH    R7,RECORD+12+2             AND LOAD RECORD LENGTH\n         SPACE 1\nREADTEXT READ  DECB,SF,I#,(R6),(R7),MF=E READ A TEXT RECORD\n         CHECK DECB                     WAIT FOR COMPLETION\n         SPACE 1\n         B     NEXTRCRD                 GO READ NEXT RECORD\n         SPACE 2\nDOCESD   IC    R1,RECORD+7              LOAD LENGTH OF ESD ENTRIES\n         SRL   R1,4                     DIVIDE BY LENGTH TO GET COUNT\n         LH    R6,RECORD+4              LOAD FIRST ESD ID\n         BCTR  R6,0                     ORIGIN ZERO\n         MH    R6,=AL2(LTABCESD)        TIMES ENTRY LENGTH\n         LA    R6,CESDTAB(R6)           NEXT AVAILABLE ENTRY\n         USING TABCESD,R6               ADDRESSABILITY\n         LA    R7,RECORD+8              START OF FIRST ENTRY\n         USING CESDENT,R7               ADDRESSABILITY\n         SPACE 1\nCESDLOOP XC    TABNAME(LTABCESD),TABNAME CLEAR THE ENTRY\n         TM    CESDTYPE,B'01011100'     UNWANTED TYPE ?             005\n         BNZ   CESDBCT                  YES, ON TO NEXT ENTRY\n         TM    CESDTYPE,B'00000011'     IS IT EXTERNAL REFERENCE ?\n         BNM   CESDLRSD                 NO, SKIP SETTING FLAG\n         OI    FLAG,X'F0'               MARK EXTERNAL REFERENCE FOUND\n         SPACE 1\nCESDLRSD MVC   TABNAME(TABCOMM-TABNAME),CESDNAME COPY NAME AND OFFSET\n         MVI   TABADDR,0                CLEAR FIRST OFFSET BYTE\n         L     R8,FRSTTAB               FIND FIRST ENTRY\n         LTR   R8,R8                    VERY FIRST CALL ?\n         BNZ   NOTFIRST                 NO, CONTINUE\n         SPACE 1\n         L     R8,=A(STABCESD*LTABCESD) LENGTH OF CESD TABLE\n         LA    R8,CESDTAB(R8)           END OF TABLE\n         ST    R8,FRSTTAB               FIRST ENTRY OF COMMON TABLE\n         B     ADDCOMM                  GO ADD FIRST COMMON ENTRY\n         EJECT\nNOTFIRST LA    R14,8                    BXLE INCREMENT\n         L     R15,NEXTTAB              LAST USED ENTRY\n         SPACE 1\nCOMMLOOP CLC   TABNAME,0(R8)            ALREADY IN TABLE ?\n         BE    CESDCHCK                 YES, NO NEED TO ADD AGAIN\n         BXLE  R8,R14,COMMLOOP          KEEP LOOKING\n         SPACE 1\nADDCOMM  MVC   0(8,R8),TABNAME          ADD THE NEW ENTRY\n         ST    R8,NEXTTAB                 AND AS LAST USED\n         SPACE 2\nCESDCHCK ST    R8,TABCOMM               SAVE ADDRESS FOR RELOCATION\n         SPACE 1\n         CLC   LABEL#,CESDNAME          HAVE A CANDIDATE ?\n         BNE   CESDBCT                  NO, ON TO NEXT ENTRY\n         L     R8,TABADDR               SAVE OFFSET\n         TM    CESDTYPE,B'00000011'     CSECT, ENTRY, OR EXTERNAL ?\n         BM    CESDBCT                  SKIP IF EXTERNAL REFERENCE\n         BO    ENTRY                    IT'S AN 'ENTRY' (LR) ENTRY\n         SPACE 1\n         A     R8,COMPADR#              ADD ADDRESS OF COMPARE\n         ST    R8,COMPADR#              SAVE NEW COMPARE START\n         MVC   COMPLEN#+1(3),CESDLEN+1    AND SAVE NEW COMPARE LENGTH\n         CLC   COMPLEN#,NUMBER#         OFFSET OUTSIDE CSECT ?\n         BH    CESDOI                   NO, GO INDICATE LABEL FOUND\n         XC    NUMBER#,NUMBER#          IGNORE NUMBER\n         B     CESDOI                   GO INDICATE LABEL FOUND\n         SPACE 1\nENTRY    L     R14,NUMBER#              LOAD NUMBER OFFSET\n         AR    R14,R8                   COMBINED OFFSET\n         C     R14,COMPLEN#             OUTSIDE MODULE ?\n         BNH   *+6                      NO, SKIP NEXT\n         LR    R14,R8                   IGNORE NUMBER, USE ENTRY\n         ST    R14,NUMBER#              STORE OFFSET\n         SPACE 1\nCESDOI   OI    BLDL#,X'0F'              MARK LABEL FOUND\n         SPACE 1\nCESDBCT  LA    R6,LTABCESD(R6)          NEXT ENTRY\n         L     R8,=A(STABCESD*LTABCESD) LENGTH OF CESD TABLE\n         LA    R8,CESDTAB(R8)           END OF TABLE\n         CR    R6,R8                    OVERRUN ?\n         BNL   ERR6                     YES, CAN'T CONTINUE\n         LA    R7,LCESDENT(R7)          NEXT ENTRY\n         BCT   R1,CESDLOOP              GO CHECK IT\n         B     NEXTRCRD                 GO READ NEXT RECORD\n         SPACE 1\n         DROP  R2,R5,R6,R7\n         EJECT\nOUTPUT   LTR   R2,R2                    FIRST CALL ?\n         BNZ   OUTCONT                  YES, CONTINUE\n         SPACE 1\n         MVC   RECORD(256),OUTREC1      MOVE IN HEADER DATA\n         MVC   RECORD+256(LOUTREC1-256),OUTREC1+256 AND THE REST\n         LA    R2,RECORD                ADDRESS OF OUTPUT AREA\n         USING OUTREC1,R2               ADDRESSABILITY\n         SPACE 1\n         MVC   REC1T+D1I1(8),NAME1      MOVE IN\n         MVC   REC1T+D1I2(8),NAME2        MEMBER NAMES\n         UNPK  WRKWRDS(9),LENGTH1(5)    UNPK THE LENGTH\n         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES\n         MVC   REC2T+D1I1(8),WRKWRDS    MOVE TO OUTPUT RECORD\n         UNPK  WRKWRDS(9),LENGTH2(5)    UNPK THE LENGTH\n         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES\n         MVC   REC2T+D1I2(8),WRKWRDS    MOVE TO OUTPUT RECORD\n         MVC   REC3T+D1I1(8),LABEL1     MOVE IN\n         MVC   REC3T+D1I2(8),LABEL2       LABEL  NAMES\n         TM    BLDL1,X'0F'              LABEL FOUND ?\n         BNO   *+14                     NO, CLEAR THE (C)\n         CLC   LENGTH1,COMPLEN1         WAS IT A CSECT ?\n         BNE   *+10                     YES, SKIP THE CLEAR\n         MVC   REC3T+D1I1+8(3),=C'   '  CLEAR THE 'C'\n         TM    BLDL2,X'0F'              LABEL FOUND ?\n         BNO   *+14                     NO, CLEAR THE (C)\n         CLC   LENGTH2,COMPLEN2         WAS IT A CSECT ?\n         BNE   *+10                     YES, SKIP THE CLEAR\n         MVC   REC3T+D1I2+8(3),=C'   '  CLEAR THE 'C'\n         UNPK  WRKWRDS(9),COMPLEN1(5)   UNPK THE COMPARE LENGTH\n         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES\n         MVC   REC6T+D1I1(8),WRKWRDS    MOVE TO OUTPUT RECORD\n         UNPK  WRKWRDS(9),COMPLEN2(5)   UNPK THE COMPARE LENGTH\n         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES\n         MVC   REC6T+D1I2(8),WRKWRDS    MOVE TO OUTPUT RECORD\n         UNPK  WRKWRDS(9),NUMBER1(5)    UNPK THE OFFSET\n         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES\n         MVC   REC4T+D1I1(8),WRKWRDS    MOVE TO OUTPUT RECORD\n         UNPK  WRKWRDS(9),NUMBER2(5)    UNPK THE OFFSET\n         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES\n         MVC   REC4T+D1I2(8),WRKWRDS    MOVE TO OUTPUT RECORD\n         UNPK  WRKWRDS(9),COUNT(5)      UNPK THE COUNT\n         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES\n         MVC   REC7T+D1I1(8),WRKWRDS    MOVE TO OUTPUT RECORD\n         SPACE 1\n         TM    FLAG,X'F0'               ANY UNRESOLVED REFERENCES ?\n         BO    OUTCONT                  YES, MESSAGE IS COMPLETE\n         MVI   REC5T-1,C'0'             CHANGE TO DOUBLE SPACE\n         SPACE 1\n         DROP  R2\n         SPACE 1\n         MVC   RECORD(2),=AL2(LOUTRECA) REDUCE RECORD LENGTH\n         EJECT\nOUTCONT  LTR   R4,R4                    WHAT IS WANTED ?\n         BP    OUTUNEQ                  ADD 'UNLIKE' OUTPUT LINE\n         BZ    OUTDIFF                  ADD 'LONGER' OUTPUT LINE\n*        BM    OUTBUFF                  DUMP THE BUFFER\n         SPACE 1\nOUTBUFF  CLC   =H'4',RECORD             NULL BUFFER ?\n         BER   R3                       YES RETURN\n         SPACE 1\n         WRITE DECB,SF,SNAP,(R2),'S',MF=E WRITE THE OUTPUT RECORD\n         CHECK DECB                     WAIT FOR COMPLETION\n         SPACE 1\n         MVC   RECORD(2),=H'4'          RESET BLOCK LENGTH\n         B     OUTCONT                  TRY AGAIN\n         SPACE 2\nOUTDIFF  LH    R1,RECORD                FIND CURRENT LENGTH\n         LR    R0,R1                      AND COPY IT\n         AH    R0,CEND                  ADD LENGTH OF NEXT RECORD\n         CH    R0,SNAP+DCBBLKSI-IHADCB  TOO LONG ?\n         BH    OUTBUFF                  YES, GO DUMP CURRENT RECORD\n         SPACE 1\n         STH   R0,RECORD                SAVE NEW RECORD LENGTH\n         AR    R1,R2                    ADD BUFFER START\n         MVC   0(LCEND,R1),CEND         MOVE IN RECORD\n         LTR   R7,R7                    IS FIRST MODULE EXHAUSTED ?\n         BNZ   *+10                     NO, SKIP NEXT\n         MVI   D3DDN(R1),C'2'           CHANGE 'I1' TO 'I2'\n         LR    R7,R8                    COPY EXCESS LENGTH\n         ST    R7,WRKWRDS+8             STORE IT\n         UNPK  WRKWRDS(7),WRKWRDS+9(4)  UNPK THE LENGTH\n         TR    WRKWRDS(6),TRTABLE-C'0'  TO PRINTABLES\n         MVC   D3LEN(6,R1),WRKWRDS      MOVE TO OUTPUT RECORD\n         SPACE 1\n         BR    R3                       RETURN\n         SPACE 2\nOUTUNEQ  LH    R1,RECORD                FIND CURRENT LENGTH\n         LR    R0,R1                      AND COPY IT\n         AH    R0,CREC                  ADD LENGTH OF NEXT RECORD\n         CH    R0,SNAP+DCBBLKSI-IHADCB  TOO LONG ?\n         BH    OUTBUFF                  YES, GO DUMP CURRENT RECORD\n         EJECT\n         STH   R0,RECORD                SAVE NEW RECORD LENGTH\n         AR    R1,R2                    ADD BUFFER START\n         MVC   0(LCREC,R1),CREC         MOVE IN RECORD\n         MVC   12(1,R13),0(R5)          MOVE BYTE TO A WORKAREA     004\n         UNPK  WRKWRDS(3),12(2,R13)     UNPK THE BYTE+GARBAGE BYTE  004\n         TR    WRKWRDS(2),TRTABLE-C'0'  TO PRINTABLES\n         MVC   D2I1B(2,R1),WRKWRDS      MOVE TO OUTPUT RECORD\n         MVC   WKBYTE(1),0(R5)          MOVE BYTE TO A WORKAREA     SBG\n         ST    R12,SAVER12A             PRESERVE R12                SBG\n         L     R12,SAVETRT              GET ADDRESS OF TRANS TABLE  SBG\n         USING TRTCSECT,R12             ADDRESSABILITY TO IT        SBG\n         TR    WKBYTE(1),TRTBL0         PRINTABLE?                  SBG\n         MVC   D2I1C(1,R1),WKBYTE       SHOVE INTO LINE             SBG\n         MVC   12(1,R13),0(R6)          MOVE BYTE TO A WORKAREA     004\n         UNPK  WRKWRDS(3),12(2,R13)     UNPK THE BYTE+GARBAGE BYTE  004\n         TR    WRKWRDS(2),TRTABLE-C'0'  TO PRINTABLES\n         MVC   D2I2B(2,R1),WRKWRDS      MOVE TO OUTPUT RECORD\n         MVC   WKBYTE(1),0(R6)          MOVE BYTE TO A WORKAREA     SBG\n         TR    WKBYTE(1),TRTBL0         PRINTABLE?                  SBG\n         L     R12,SAVER12A             RESTORE R12                 SBG\n         DROP  R12                                                  SBG\n         MVC   D2I2C(1,R1),WKBYTE       SHOVE INTO LINE             SBG\n         ST    R5,WRKWRDS+12            STORE COMPARE ADDRESS\n         LR    R0,R5                    COPY BYTE ADDRESS\n         S     R0,COMPADR1              LESS COMPARE START\n         ST    R0,WRKWRDS+8             STORE COMPARE OFFSET\n         UNPK  WRKWRDS(7),WRKWRDS+9(4)  UNPK THE OFFSET\n         TR    WRKWRDS(6),TRTABLE-C'0'  TO PRINTABLES\n         MVC   D2I1A(6,R1),WRKWRDS      MOVE TO OUTPUT RECORD\n*001     UNPK  WRKWRDS(7),WRKWRDS+13(4) UNPK THE ADDRESS\n*001     TR    WRKWRDS(6),TRTABLE-C'0'  TO PRINTABLES\n*001     MVC   D2I1A+8(6,R1),WRKWRDS    MOVE TO OUTPUT RECORD\n         ST    R6,WRKWRDS+12            STORE COMPARE ADDRESS\n         LR    R0,R6                    COPY BYTE ADDRESS\n         S     R0,COMPADR2              LESS COMPARE START\n         ST    R0,WRKWRDS+8             STORE COMPARE OFFSET\n         UNPK  WRKWRDS(7),WRKWRDS+9(4)  UNPK THE OFFSET\n         TR    WRKWRDS(6),TRTABLE-C'0'  TO PRINTABLES\n         MVC   D2I2A(6,R1),WRKWRDS      MOVE TO OUTPUT RECORD\n*001     UNPK  WRKWRDS(7),WRKWRDS+13(4) UNPK THE ADDRESS\n*001     TR    WRKWRDS(6),TRTABLE-C'0'  TO PRINTABLES\n*001     MVC   D2I2A+8(6,R1),WRKWRDS    MOVE TO OUTPUT RECORD\n         SPACE 1\n         BR    R3                       RETURN TO CALLER\n         SPACE 4\n         PRINT NOGEN\nTRTTABLE DC    256X'04'                 IGNORE EVERYTHING\n         SPACE 1\n         RCRD  80,04                    IDR      - IGNORE\n         RCRD  40,04                    SYM      - IGNORE\n         RCRD  20,08                    CESD     - PROCESS\n         RCRD  10,04                    SC/TR    - IGNORE\n         RCRD  01,0C                    CNTRL    - PROCESS\n         RCRD  05,04                    CNT-EOS  - IGNORE\n         RCRD  0D,0C                    CNT-EOM  - PROCESS\n         RCRD  02,10                    RLD      - PROCESS\n         RCRD  06,04                    RLD-EOS  - IGNORE\n         RCRD  0E,10                    RLD-EOM  - PROCESS\n         RCRD  03,10                    CRLD     - PROCESS\n         RCRD  07,04                    CRLD-EOS - IGNORE\n         RCRD  0F,10                    CRLD-EOM - PROCESS\n         EJECT\nTRTABLE  DC    C'0123456789ABCDEF'      GUESS WHAT THIS IS FOR\n         SPACE 3\nD1I1     EQU   9                        RECORD 1 DATA\nD1I2     EQU   21\n         SPACE 1\nOUTREC1  DC    AL2(LOUTREC1,0)          NOTE ALIGNMENT\nREC1     DC    AL2(LREC1,0),C'1'\nREC1T    DC    C'MODULES: NNNNNNNN-I1 MMMMMMMM-I2'\nLREC1    EQU   *-REC1\nREC2     DC    AL2(LREC2,0),C' '\nREC2T    DC    C'LENGTH:  HHHHHHHH    HHHHHHHH  (OF MODULES)'\nLREC2    EQU   *-REC2\nREC3     DC    AL2(LREC3,0),C' '\nREC3T    DC    C'LABEL:   11111111(C) 22222222(C)'\nLREC3    EQU   *-REC3\nREC6     DC    AL2(LREC6,0),C' '\nREC6T    DC    C'COMPLEN: HHHHHHHH    HHHHHHHH  (BASIC COMPARE LENGTH)'\nLREC6    EQU   *-REC6\nREC4     DC    AL2(LREC4,0),C' '\nREC4T    DC    C'OFFSET:  HHHHHHHH    HHHHHHHH  (IN MODULE OR CSECT)'\nLREC4    EQU   *-REC4\nREC7     DC    AL2(LREC7,0),C' '\nREC7T    DC    C'COUNT:   HHHHHHHH  (FORCED COMPARE LENGTH)'\nLREC7    EQU   *-REC7\nREC5     DC    AL2(LREC5,0),C' '\nREC5T    DC    C' '\nLREC5    EQU   *-REC5\nLOUTRECA EQU   *-OUTREC1\nREC8     DC    AL2(LREC8,0),C' '\nREC8T    DC    C'NOTE: SOME UNRESOLVED EXTERNAL REFERENCES RESOLVED'\nLREC8    EQU   *-REC8\nREC9     DC    AL2(LREC9,0),C'0'\nREC9T    DC    C' '\nLREC9    EQU   *-REC9\nLOUTREC1 EQU   *-OUTREC1\n         DC    (LOUTREC1-2*(LOUTREC1/2))AL1(0) ALIGNMENT\n         SPACE 1\nERROR1   EQU   SNAPBLKS-LOUTREC1        ERROR IF TOO SMALL\n         SPACE 2\nD2I1A    EQU   5+4                      RECORD 2 DATA\nD2I1B    EQU   5+11                     WAS 5+20                    001\nD2I1C    EQU   5+14                                                 SBG\nD2I2B    EQU   5+23                     WAS 5+30                    SBG\nD2I2C    EQU   5+26                                                 SBG\nD2I2A    EQU   5+32                     WAS 5+37                    SBG\n         SPACE 1\nCREC     DC    AL2(LCREC,0),C' '\nCRECT    DC    C'AT +HHHHHH XX Y UNLIKE XX Y AT +HHHHHH'            SBG\n*001 CRECT DC  C'AT +HHHHHH (HHHHHH) XX UNLIKE XX AT +HHHHHH (HHHHHH)'\nLCREC    EQU   *-CREC\n         DC    (LCREC-2*(LCREC/2))AL1(0) ALIGNMENT\n         EJECT\nD3DDN    EQU   5+11                     RECORD 3 DATA\nD3LEN    EQU   5+23\n         SPACE 1\nCEND     DC    AL2(LCEND,0),C'0'\nCENDT    DC    C'MODULE IN I1 LONGER BY HHHHHH BYTES'\nLCEND    EQU   *-CEND\n         SPACE 4\nDCBPSQ   DCB   BLKSIZE=400,DDNAME=WTO,DSORG=PS,LRECL=125,              X\n               BUFNO=1,MACRF=PM,RECFM=VB\nDCBPSQX  EQU   *-DCBPSQ\n         SPACE 1\nDCBPS    DCB   BLKSIZE=SNAPBLKS,DDNAME=SNAP,DSORG=PS,LRECL=125,        *\n               MACRF=W,RECFM=VBA\nDCBPSX   EQU   *-DCBPS                  LENGTH OF DCB\n         SPACE 1\nDCBPO    DCB   DDNAME=I1,DSORG=PO,EODAD=EOM,MACRF=R\nDCBPOX   EQU   *-DCBPO                  LENGTH OF DCB\n         SPACE 1\n         READ  DECBRW,SF,MF=L\nDECBX    EQU   *-DECBRW                 LENGTH OF DECB\n         SPACE 2\n         LTORG\n         EJECT ,\n*   SUP - CHECK IF MODULE CONTAINS TTRL'S OF OTHER MODULES,\n*         IF SO, SET THEM ALL TO C'TTRL'\n*     AT ENTRY R1 = @ NAME IN WORK OF MODULE TO TEST\n*\n         SPACE 1\nSUP      STM   R0,R15,SAVE2             SAVE REGS\n         LR    R9,R15                   GET BASE REG\n         USING SUP,R9\n         LR    R8,R1                    SAVE @ MODULE NAME ETC\n         LA    R7,SUP#TB8               SEE IF 1ST LOAD WITH TTRL'S\n         BAL   R14,SUP$SCN              GO SCAN TABLE\n         B     SUP$FND1                 BRANCH IF FOUND IN TABLE\n         LA    R7,SUP#TB6               SEE IF LATER LOAD\n         BAL   R14,SUP$SCN              GO SCAN TABLE\n         B     SUP$FND2\nSUP$EXIT LM    R0,R15,SAVE2             RESTORE REGS\n         BR    R14                      AND RETURN\n         SPACE 1\nSUP$FND2 TM    NAME1-NAME1+6(R8),X'F0'  NUMERIC 7TH CHAR?\n         BNO   SUP$EXIT                 NO TTRL'S IF NOT\nSUP$FND1 L     R1,ADDRESS1-NAME1(,R8)   GET BEGIN ADDR\n         L     R2,LENGTH1-NAME1(,R8)    GET LENGTH\n         CL    R2,=F'1024'              > 1024 LONG?\n         BH    SUP$EXIT                 YES, NO TTRL'S\n         LA    R3,0(R2,R1)              @ PAST END OF MODULE\n         SH    R3,=H'4'                 BACK UP 4 BYTES\n         SR    R4,R4                    CLEAR FOR IC\n         IC    R4,3(,R3)                GET OFFSET/8 OF TTRL TABLE\n         SLA   R4,3                     GET REAL OFFSET\n         BZ    SUP$EXIT                 I WON'T BUY OFFSET 0\n         ALR   R1,R4                    POINT TO TTRL TABLE\n         SPACE 1\nSUP$LOOP CR    R1,R3                    PAST END OF MODULE?\n         BNL   SUP$EXIT                 BRANCH IF PAST\n         OC    0(2,R1),0(R1)            END OF TABLE?\n         BZ    SUP$EXIT                 DONE IF SO\n         CLC   0(2,R1),=X'FFFF'         SUBLIST DELIMITER?          002\n         BE    SUP$FF                   YES - SKIP PAST IT          002\n         MVC   2(4,R1),=C'TTRL'         FIX UP TTRL\n         LA    R1,6(,R1)                TO NEXT ENTRY\n         B     SUP$LOOP\n         SPACE 1\nSUP$FF   LA    R1,2(,R1)                SKIP PAST SUBLIST DELIMITER 002\n         B     SUP$LOOP                 AND GO CHECK FOR END        002\n         SPACE 1\nSUP$SCN  LH    R0,0(,R7)                GET NUMBER OF ENTRIES IN TABLE\n         LH    R15,2(,R7)               GET LEN-1 OF EACH ENTRY\nSUP$SCNL EX    R15,SUP$SCNC             CLC 4(0,R7),NAME1-NAME1(R8)\n         BER   R14                      RETURN IF FOUND\n         LA    R7,1(R15,R7)             TO NEXT ENTRY\n         BCT   R0,SUP$SCNL              SCAN ALL ENTRIES\n         B     4(,R14)                  RETURN NOT FOUND\nSUP$SCNC CLC   4(0,R7),NAME1-NAME1(R8)  * EXECUTED *\n         SPACE 1\nSUP#TB8  DC    Y((SUP#TB8L-4)/8)        NUMBER OF ENTRIES\n         DC    Y(7)                     LENGTH -1 OF EACH ENTRY\n         DC    CL8'IGC0001I'            OPEN\n         DC    CL7'IGC0002',X'C0'       CLOSE\n         DC    CL8'IGC0002A'            STOW\n         DC    CL8'IGC0002B'            OPENJ\n         DC    CL8'IGC0002C'            TCLOSE\n         DC    CL8'IGC0002I'            SCRATCH\n         DC    CL8'IGC0003A'            FEOV\n         DC    CL8'IGC0003B'            ALLOCATE\n         DC    CL8'IGC0005E'            EOV\n         DC    CL8'IGC0008A'            SETPRT\n         DC    CL8'IGC0008F'            ATLAS\n         DC    CL8'IGC0009C'            TSO\n         DC    CL8'IGC0009D'            TSO\nSUP#TB8L EQU   *-SUP#TB8                LENGTH OF TABLE\n         SPACE 1\nSUP#TB6  DC    Y((SUP#TB6L-4)/6)        NUMBER OF ENTRIES\n         DC    Y(5)                     LENGTH OF ENTRY -1\n         DC    CL6'IFG019'              OPEN\n         DC    CL6'IFG020'              CLOSE\n         DC    CL6'IFG023'              TCLOSE\n         DC    CL6'IFG055'              EOV\n         DC    CL6'IFGASR'              ASR MODULE NAMES\n         DC    CL6'IGG019'              OPEN\n         DC    CL6'IGG020'              CLOSE\n         DC    CL6'IGG021'              STOW\n         DC    CL6'IGG023'              TCLOSE\n         DC    CL6'IGG029'              SCRATCH\n         DC    CL6'IGG032'              ALLOCATE\n         DC    CL6'IGG055'              EOV\n         DC    CL6'IGG081'              SETPRT\n         DC    CL6'IGG086'              ATLAS\n         DC    CL6'IGG093'              TSO\n         DC    CL6'IGG094'              TSO\nSUP#TB6L EQU   *-SUP#TB6                LENGTH OF TABLE\n         SPACE 1\n         DROP  R9\n         EJECT ,\n*   SNAPIT: SNAP ROUTINE\n*     R1 = @ (@ BEGIN, @ END)\n*\n         SPACE 1\nSNAPIT   TM    FLAGS,FG#NSNAP           DON'T DO SNAP?              001\n         BOR   R14                      YES - RETURN TO CALLER      001\n         SPACE 2\n         STM   R0,R15,SAVE2             SAVE REGS\n         LR    R9,R15                   LOCAL BASE\n         USING SNAPIT,R9\n         LM    R2,R3,0(R1)              GET @ BEGIN, @ END\n         LA    R4,4                     CONSTANT\n         SR    R5,R5                    START AT OFFSET 0\n         SPACE 1\nSN$LOOP1 MVC   LINERDW(5),SN#RDW        INIT RDW, CTL CHAR (' ')\n         MVC   LINE+1(L'LINE-1),LINE    BLANK REST OF LINE\n         LTR   R5,R5                    1ST LINE?\n         BNZ   *+8                      BRANCH IF NOT\n         MVI   LINE,C'1'                NEW PAGE ON FIRST\n         ST    R5,SN#WRK                OFFSET TO HEX\n         UNPK  LINE+1(7),SN#WRK+1(4)\n         TR    LINE+1(6),TRTABLE-C'0'\n         MVI   LINE+1+6,C' '\n         LA    R0,2                     DO TWO SETS OF 16 BYTES\n         LA    R7,LINE+1+6+1            @ OF FIRST WORD OF HEX\n         LA    R8,LINE+L'LINE-32-1      @ OF FIRST WORD OF CHAR\n         SPACE 1\nSN$LOOP2 MVC   0(3,R7),=CL3' '          ADD SOME BLANKS\n         LA    R7,3(,R7)\n         LR    R6,R4                    AND 4 SETS OF 4 IN EACH 16\n         SPACE 1\nSN$LOOP3 MVC   WRKWRDS(4),0(R2)         COPY TO SAFE LOCATION   GP14226\n         UNPK  0(9,R7),WRKWRDS(5)         AND UNPACK            GP14226\n         TR    0(8,R7),TRTABLE-C'0'\n         MVI   8(R7),C' '               FIX GARBAGE BYTE\n         MVC   0(4,R8),0(R2)            MOVE IN CHAR STUFF\n         AR    R2,R4                    BUMP INPUT PTR\n         LA    R7,9(,R7)                BUMP HEX OUTPUT PTR\n         AR    R8,R4                    BUMP CHAR OUTPUT PTR\n         AR    R5,R4                    BUMP OFFSET TOO\n         CR    R2,R3                    NEXT WORD TO BE DUMPED?\n         BNL   SN$DONE                  NO, PRINT, DONE\n         BCT   R6,SN$LOOP3              DO 16 BYTES\n         BCT   R0,SN$LOOP2              DO ABOVE TWICE\n         SPACE 1\n         BAL   R8,SN$PUT                PRINT LINE\n         B     SN$LOOP1\n         SPACE 1\nSN$DONE  BAL   R8,SN$PUT                PRINT LAST LINE\n         LM    R0,R15,SAVE2             RESTORE REGS\n         BR    R14                      AND RETURN\n         SPACE 1\nSN$PUT   MVI   LINE+L'LINE-1,C'*'       STARS AROUND CHAR PART\n         MVI   LINE+L'LINE-1-32-1,C'*'\n         TR    LINE+L'LINE-1-32(32),SN#TR  CHANGE GARBAGE TO '.'\n         LH    R1,RECORD                CURRENT RECORD LENGTH\n         LR    R0,R1                    COPY IT\n         AH    R0,LINERDW               ADD IN LENGTH OF NEW LINE\n         CH    R0,SNAP+DCBBLKSI-IHADCB  OVER BLKSIZE?\n         BNH   SN$FITS                  BRANCH IF NOT\n         LA    R15,RECORD               @ RECORD TO WRITE\n         PRINT GEN\n         WRITE DECB,SF,SNAP,(R15),'S',MF=E WRITE BLOCK\n         CHECK DECB                     WAIT FOR I/O\n         PRINT NOGEN\n         LA    R1,4                     RE-SET RECORD RDW\nSN$FITS  LA    R15,RECORD(R1)           GET @ TO PLACE LINE\n         MVC   0(L'LINE+4,R15),LINERDW  PUT LINE IN OUTPUT BUFFER\n         AH    R1,LINERDW               GET NEW OUTPUT LENGTH\n         STH   R1,RECORD                SET NEW OUTPUT LENGTH\n         BR    R8                       AND RETURN\n         SPACE 1\nSN#RDW   DC    Y(L'LINE+4,0),C' '\nSN#TR    DC    256X'4B'\n         ORG   SN#TR+C' '\n         DC    C' '\n         ORG   SN#TR+X'4A'\n         DC    X'4A4B4C4D4E4F'\n         ORG   SN#TR+X'5A'\n         DC    X'5A5B5C5D5E5F'\n         ORG   SN#TR+C','\n         DC    C',%_>?'\n         ORG   SN#TR+X'7A'\n         DC    X'7A7B7C7D7E7F'\n         ORG   SN#TR+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   SN#TR+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   SN#TR+C'S'\n         DC    C'STUVWXYZ'\n         ORG   SN#TR+C'0'\n         DC    C'0123456789'\n         ORG   ,\n         SPACE 1\n         DROP  R9\n         EJECT ,\nGETENT   STM   R0,R15,SAVE2             SAVE CALLERS REGS\n         LR    R9,R15                   SET LOCAL BASE\n         USING GETENT,R9\n         L     R6,DIRLST                @ LAST DIR ENTRY\n         LTR   R6,R6                    FIRST TIME?\n         BZ    GE$FIRST                 YES, GO READ\n         SR    R5,R5                    CLEAR FOR IC\n         IC    R5,11(,R6)               GET LENGTH OF LAST ENTRY\n         N     R5,=X'0000001F'          GET LENGTH IN H-WORDS\n         LA    R5,12(R5,R5)             LENGTH IN BYTES\n         AR    R6,R5                    @ NEXT ENTRY IF ANY\n         LH    R1,DIRBUF                GET LENGTH OF DATA IN BLOCK\n         LA    R1,DIRBUF(R1)            @ PAST LAST ENTRY\n         CR    R6,R1                    IS THIS ENTRY OK?\n         BL    GE$OK                    BRANCH IF OK\nGE$FIRST MVI   DIRTTR+3,1               SET GET NEXT BLOCK\n         POINT I1,DIRTTR                POINT THERE\n         READ  DECB,SF,I1,DIRBUF,256,MF=E  READ NEXT DIR BLOCK\n         CHECK DECB                     WAIT FOR IT\n         NOTE  I1                       GET IT'S TTR\n         ST    R1,DIRTTR                SAVE FOR NEXT TIME\n         LA    R6,DIRBUF+2              GET @ 1ST ENTRY\nGE$OK    CLC   0(8,R6),=8X'FF'          LAST ENTRY?\n         BE    ALLDONE                  YES, JUST LEAVE\n         ST    R6,DIRLST                ELSE SAVE ENTRY ADDR\n         MVC   NAME1,0(R6)              SET 1ST NAME\n         MVC   NAME2,0(R6)              AND 2ND NAME\n         LM    R0,R15,SAVE2             RESTORE REGS\n         BR    R14                      AND RETURN\n         SPACE 2\n         DROP  R9\n         EJECT\n***********************************************************************\n*                                                                     *\n* DO PRE-OPEN CHECKS HERE. CHECK IF OUTPUT FILE IS SYSPRINT AND NOT   *\n* SNAP; FLAG NO SNAP DUMP IF YES. CHECK IF OUTPUT FILE IS ALLOCATED   *\n* TO TSO AS TERMFILE. SET UP WRITE INTERCEPT IF YES AND FAKE OUT OPEN *\n* DCB. GENERATE FINAL FORM OF OPEN LIST AND DO THE ACTUAL OPEN.       *\n*                                                                     *\n* INPUT: R1 - POINTER TO OPEN LIST.                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         USING OPEN#CHK,R9              SET ADDRESSIBILITY          001\n         PRINT GEN                                                  001\n         SPACE 2\nOPEN#CHK STM   R0,R15,SAVE2             SAVE CALLER'S REGS          001\n         LR    R9,R15                   SET BASE REG                001\n         TM    DCBLIST+8,X'80'          OPENING DCBWTO?             001\n         BO    *+8                      NO - CONTINUE               001\n         OI    FLAGS,FG#ALL             SAY PROCESS ALL MEMBERS     001\n         SPACE 2\n         L     R3,PSATOLD-PSA           CURRENT TCB                 003\n         LA    R0,24                    FIRST TIOT INCREMENT        001\n         XR    R2,R2                    CLEAR FLAG REG              001\n         L     R15,12(,R3)              TIOT ADDR                   001\n         BALR  R14,0                    LOOP RETURN ADDR            001\n         SPACE 2\n         ALR   R15,R0                   NEXT TIOT ENTRY             001\n         IC    R0,0(,R15)               LENGTH/THIS ENTRY           001\n         LTR   R0,R0                    END OF TIOT?                001\n         BZ    OP#END#T                 YES - SEE IF SYSPRINT FOUND 001\n         SPACE 2\n         CLC   4(8,R15),=CL8'SYSPRINT'  DDNAME=SYSPRINT?            001\n         BNE   OP#SNAP                  NO - GO CHECK SNAP DDNAME   001\n         LR    R2,R15                   SAVE ENTRY ADDR AS FLAG     001\n         BR    R14                      AND CHECK NEXT ENTRY        001\n         SPACE 2\nOP#SNAP  CLC   4(8,R15),SNAP+DCBDDNAM-IHADCB DDNAME=SNAP?           001\n         BNER  R14                      NO - LOOP                   001\n         ICM   R2,B'0111',17(R15)       UCB ADDR FOR BELOW          003\n         SPACE 2\n*  ----  HAVE SNAP OR SYSPRINT DD ENTRY HERE.                       001\n         SPACE 2\nOP#DD    L     R15,PSAAOLD-PSA          CURRENT ASCB                003\n         ICM   R15,B'1111',ASCBTSB-ASCB(R15) RUNNING AS A TSO TASK? 003\n         BZ    OP#RET                   NO - CAN'T BE TERMFILE      001\n         LTR   R2,R2                    NO UCB ADDR(THUS TERMFILE)? 001\n         BNZ   OP#RET                   NO - EXIT                   001\n         SPACE 2\n*  ----  HAVE TERMFILE HERE - INTERCEPT IT.                         001\n         SPACE 2\n         MVC   SNAP+DCBWRITE+1-IHADCB(3),=AL3(TPUT#TSO) TPUT CODE   001\n         MVC   SNAP+DCBCHECK+1-IHADCB(3),=AL3(TPUT#END) TPUT CODE   001\n         OI    SNAP+DCBOFLGS-IHADCB,DCBOFOPN TELL MAINLINE DCB OPEN 001\n         MVC   DCBLIST(12),DCBLIST+4    SQUISH OUT SNAP DCB ADDR    001\n         SPACE 2\nOP#RET   OPEN  MF=(E,(1))               NOW FINALLY DO THE OPEN     001\n         LM    R0,R15,SAVE2             RESTORE CALLER'S REGS       001\n         BR    R14                      AND RETURN\n         SPACE 2\n*  ----  GET HERE WITH END OF TIOT/SNAP NOT FOUND - CHECK SYSPRINT. 001\n         SPACE 2\nOP#END#T LTR   R2,R2                    SYSPRINT ENTRY FOUND?       001\n         BZ    OP#RET                   NO - LET MAINLINE DIAG. ERR 001\n         SPACE 2\n         OI    FLAGS,FG#NSNAP           SAY DON'T DO A SNAP         001\n         MVC   SNAP+DCBDDNAM-IHADCB(8),=CL8'SYSPRINT' RESET DDNAME  001\n         ICM   R2,B'0111',17(R2)        GET UCB ADDR/THIS FILE      003\n         B     OP#DD                    NOW CHECK FOR TERMFILE      001\n         SPACE 2\n         DROP  R9                                                   001\n         EJECT\n*  ----  THIS CODE GAINS CONTROL VIA A WRITE DECB,SF,...            001\n*  ----  INPUT R1-->XL4'ECB',XL2'FLAGS',AL2(LEN),A(DCB),A(BUF).     001\n         SPACE 2\n         USING TPUT#TSO,R5              ADDRESSIBILITY              001\n         SPACE 2\nTPUT#TSO STM   R14,R5,16(R13)           SAVE WORK REGS/NOTE OFFSET  001\n         LR    R5,R15                   SET BASE REGISTER           001\n         L     R3,12(,R1)               GET OUTPUT BUFFER ADDR      001\n         MVC   12(2,R13),0(R3)          GET BLOCK LENGTH            001\n         LA    R3,0(,R3)                INSURE HI BYTE CLEAR        001\n         LH    R4,12(,R13)              GET LENGTH/THIS BLOCK       001\n         LA    R2,4                     SET FIRST REC INCREMENT     001\n         ALR   R4,R3                    GEN END CHECK ADDR          001\n         B     TPUT#CHK                 AND GO CHECK FOR END        001\n         SPACE 2\nTPUT#LP  LH    R0,=H'-5'                BYTES IN REC WE SKIP        001\n         AR    R0,R2                    GEN TPUT LENGTH             001\n         LA    R1,5(,R3)                POINT TO START OF TEXT      001\n         BNP   TPUT#CHK                 SKIP TPUT IF FUNNY          001\n         TPUT  (1),(0),R                ELSE TPUT THE MSG TEXT      001\n         SPACE 2\nTPUT#CHK ALR   R3,R2                    POINT TO NEXT RECORD        001\n         CLR   R3,R4                    STILL WITHIN REC?           001\n         IC    R2,1(,R3)                GET LEN/THIS REC            001\n         BL    TPUT#LP                  YES - CONTINUE TPUT'ING     001\n         SPACE 2\n         LM    R14,R5,16(R13)           RESTORE WORK REGS           001\nTPUT#END BR    R14                      RETURN TO CALLER            001\n         SPACE 2\n         DROP  R5                                                   SBG\n         PRINT NOGEN                                                001\n         SPACE 2\n         LTORG\n         EJECT ,\nCESDENT  DSECT\nCESDNAME DS    CL8                      IDENTIFIER\nCESDTYPE DS    X                        TYPE OF ESD ENTRY\nCESDADR  DS    AL3                      OFFSET INTO MODULE\nCESDLEN  DS    F                        CSECT LENGTH\nLCESDENT EQU   *-CESDENT                LENGTH OF ENTRY\n         SPACE 2\nTABCESD  DSECT\nTABNAME  DS    CL8                      CESD IDENTIFIER\nTABADDR  DS    F                        OFFSET INTO MODULE\nTABCOMM  DS    A                        ADDRESS OF COMMON LABEL\nLTABCESD EQU   *-TABCESD                LENGTH OF ENTRY\n         SPACE 2\n         DCBD  DEVD=DA,DSORG=(PO,PS)\n         IHAPSA ,                                                   003\n         IHAASCB ,                                                  003\n         EJECT\nWORKAREA DSECT                          DYNAMIC STORAGE AREA\n         DS    18F                      SAVEAREA\n         SPACE 1\nWRKWRDS  DS    4F                       DOUBLEWORD ALIGNED WORK AREA\nDCBLIST  DS    4F                       OPEN/CLOSE PARM LIST\nSAVE2    DS    16F                      SUBROUTINE SAVE AREA\nSN#WRK   DS    F                        SNAP WORK AREA\nRETCODE  DS    F                        PROGRAM RETURN CODE         004\nFLAGS    DS    F                        FLAG AREA                   001\nFG#NSNAP EQU   X'80'                    DON'T DO A PSEUDO-SNAP DUMP 001\nFG#ALL   EQU   X'40'                    PROCESS ALL PDS MEMBERS     001\n         SPACE 1\nLINERDW  DS    2H                       RDW FOR LINE\nLINE     DS    CL121                    PRINT LINE\n         SPACE 1\nWKBYTE   DS    CL1                      WORK BYTE                   SBG\nCOUNT    DS    A                        NUMBER OF BYTES TO COMPARE\n         SPACE 1\nDCBWTO   DCB   DDNAME=*,DSORG=PS,MACRF=PM\n         SPACE 1\nSNAP     DCB   DDNAME=*,DSORG=PS,MACRF=W\n         SPACE 1\nFRSTTAB  DS    F                        FIRST COMMON SYMBOL IN TABLE\nNEXTTAB  DS    F                        NEXT COMMON SYMBOL IN TABLE\n         SPACE 2\nNAME1    DS    CL8                      FIRST MODULE NAME\nLABEL1   DS    CL8                      LABEL IN MODULE\nNUMBER1  DS    A                        NUMBER (OFFSET) INTO NAME/LABEL\nLENGTH1  DS    A                        LENGTH OF MODULE\nADDRESS1 DS    A                        ADDRESS OF MODULE\nCOMPLEN1 DS    A                        LENGTH OF COMPARE\nCOMPADR1 DS    A                        ADDRESS OF COMPARE\nBLDL1    DS    17F                      BLDL LIST\n         SPACE 1\nI1       DCB   DDNAME=*,DSORG=PO,MACRF=R FIRST DCB\n         SPACE 2\nNAME2    DS    CL8                      SECOND MODULE NAME\nLABEL2   DS    CL8                      LABEL IN MODULE\nNUMBER2  DS    A                        NUMBER (OFFSET) INTO NAME/LABEL\nLENGTH2  DS    A                        LENGTH OF MODULE\nADDRESS2 DS    A                        ADDRESS OF MODULE\nCOMPLEN2 DS    A                        LENGTH OF COMPARE\nCOMPADR2 DS    A                        ADDRESS OF COMPARE\nBLDL2    DS    17F                      BLDL LIST\n         SPACE 1\nI2       DCB   DDNAME=*,DSORG=PO,MACRF=R SECOND DCB\n         SPACE 2\n         READ  DECB,SF,MF=L             DECB FOR PDS INPUT\n         SPACE 1\nFLAG     DS    X                        FLAG FOR EXTERNAL REFERENCE\n         SPACE 1\nBASELEN  EQU   *-WORKAREA               LENGTH TO CLEAR\n         SPACE 1\n         DS    0F                       ALIGNMENT\nRECORD   DS    (SNAPBLKS)X              INPUT AND OUTPUT BUFFER\n         SPACE 1\nDIRLST   DS    A\nDIRTTR   DS    F                        TTR OF LAST DIRECTORY  BLOCK\nDIRBUF   DS    0F,256X                  DIRECTORY BUFFER FOR 'ALL' OPT\n         SPACE 1\nSAVER12A DS    F                                                    SBG\nSAVETRT  DS    F                                                    SBG\n         DS    0F                       ALIGNMENT\nCESDTAB  DS    (STABCESD)XL(LTABCESD)   CESD ENTRY TABLE\n         SPACE 1\nCOMMNAME DS    (2*STABCESD)CL8\n         SPACE 1\nWORKLEN  EQU   *-WORKAREA\n         EJECT\n         PRINT GEN\n         BLDLLIST\n         ORG   BLDLNAME+27\nBLDLFTBL DC    2X'00'                   FIRST TEXT BLOCK LENGTH\nBLDLEPA  DC    3X'00'                   ENTRY POINT ADDRESS\n         SPACE 2\nLIBWORK  DSECT\nNAME#    DS    CL8                      MODULE NAME\nLABEL#   DS    CL8                      LABEL IN MODULE\nNUMBER#  DS    A                        NUMBER (OFFSET) INTO NAME/LABEL\nLENGTH#  DS    A                        LENGTH OF MODULE\nADDRESS# DS    A                        ADDRESS OF MODULE\nCOMPLEN# DS    A                        LENGTH OF COMPARE\nCOMPADR# DS    A                        ADDRESS OF COMPARE\nBLDL#    DS    17F                      BLDL LIST\n         SPACE 1\nI#       EQU   *                        DCB\n         SPACE 2\nTRTCSECT CSECT                                                      SBG\nTRTBL0   DS    0D                                                   SBG\n         DC    XL16'40404040404040404040404040404040'               SBG\n         DC    XL16'40404040404040404040404040404040'               SBG\n         DC    XL16'40404040404040404040404040404040'               SBG\n         DC    XL16'40404040404040404040404040404040'               SBG\n         DC    XL16'404040404040404040404A4B4C4D4E4F'               SBG\n         DC    XL16'504040404040404040405A5B5C5D5E5F'               SBG\n         DC    XL16'606140404040404040406A6B6C6D6E6F'               SBG\n         DC    XL16'404040404040404040407A7B7C7D7E7F'               SBG\n         DC    XL16'40818283848586878889404040404040'               SBG\n         DC    XL16'40919293949596979899404040404040'               SBG\n         DC    XL16'4040A2A3A4A5A6A7A8A9404040404040'               SBG\n         DC    XL16'40404040404040404040404040404040'               SBG\n         DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040'               SBG\n         DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040'               SBG\n         DC    XL16'E040E2E3E4E5E6E7E8E9404040404040'               SBG\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040'               SBG\n         SPACE 3                                                    SBG\n         END   COMPLOAD\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPINFO": {"ttr": 3850, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x037\\x037\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 823, "newlines": 823, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMASA JOB ACCT,MSGCLASS=A,COND=(0,NE)\n/*ROUTE PRINT WYLBUR\n//ASM EXEC ASMHCL\n//ASM.SYSLIB DD\n//           DD\n//           DD DISP=SHR,DSN=SYS5.MSSMAC\n******************************************************\n******************************************************\n***                                                ***\n**  TITLE: DUMPINFO                                 **\n**  TYPE: TSO CP                                    **\n**  FUNCTION: DISPLAY LAST IPL TIME AND STATUS OF   **\n**            SYS1.DUMP DATASETS                    **\n**  OPERANDS:  IPL  - LAST IPL TIME ONLY            **\n**             ALL  - FULL & EMPTY DUMP DATASETS    **\n**             FREE - EMPTY DUMP DATASETS           **\n**  DEFAULT: IPL TIME AND FULL DUMP DATASETS        **\n**                                                  **\n**  OUTPUT FORMAT:                                  **\n**    * TIME - DAY YY.DDD MM/DD/YY HH:MM            **\n**    * IPL  - DAY YY.DDD MM/DD/YY HH:MM            **\n**    DUMPNN - DAY YY.DDD MM/DD/YY HH:MM - TITLE    **\n**    DUMPNN - EMPTY                                **\n**    DUMPNN - DAIR ERROR - CODE=EEEE MSG           **\n**    DUMPNN - OBTAIN ERROR - CODE=CCCC MSG         **\n**    DUMPNN - I/O ERROR                            **\n**                                                  **\n**          DUMPNN => DUMP DATASET NAME             **\n**          DAY => DAY OF THE WEEK DUMP TAKEN       **\n**          YY.DDD => JULIAN DATE DUMP TAKEN        **\n**          HH:MM => HOURS:MINUTES TIME DUMP TAKEN  **\n**          TITLE => DUMP HEADER TITLE              **\n**          EMPTY => DUMP DATASET IS EMPTY          **\n**          EEEE => DAIR ERROR CODE RETURNED        **\n**                  FROM S99ERROR FIELD             **\n**          CCCC => OBTAIN ERROR RETURN CODE (R15)  **\n**          MSG => MESSAGE ASSOCIATED WITH THE      **\n**                 CORRESPONDING S99ERROR OR        **\n**                 OBTAIN ERROR CODE                **\n**          I/O ERROR => SYNAD EXIT TAKEN ON A GET  **\n**                       OPERATION. DATASET MAY     **\n**                       CONTAIN AN I/O ERROR       **\n***                                                ***\n******************************************************\n******************************************************\n         EJECT\n*****************************************\n*               WORK AREA               *\n*   DSECT NAME - WDSECT                 *\n*   BASE - R12                          *\n*   DSECT BUILT BY OACENTER             *\n*****************************************\n         MACRO\n         OACWORK &DUMMY\n**********************************\n*   BUILD PARM LIST FOR SVC99    *\n**********************************\n         DS    0F                               FULLWORD ALIGN\n$99RBPTR DC    F'0'                             RB POINTER\n$99RB    DS    XL(S99RBLEN)                     REQUEST BLOCK\n*****************************\n*  POINTERS TO TEXT UNITS   *\n*****************************\n$99ITUPL DC    0F'0'                            RB TEXT UNIT PTR LIST\n$99IDSNP DC    F'0'                             INPUT DSN POINTER\n$99IFREP DC    F'0'                             FREE ON CLOSE POINTER\n$99VOLP  DC    F'0'                             RETURN VOLID POINTER\n$99ISTP  DC    F'0'                             INPUT STATUS POINTER\n$99IDDNP DC    F'0'                             RETURN DDNAME POINTER\n*************************\n*     TEXT  UNITS       *\n*************************\n$99TEXT  DC    0F'0'                            TEXT LIST\n$99FREC  DC    F'0'                             FREE ON CLOSE\n$99VOLK  DC    XL12'0'                          RETURN VOLID KEY\n$99DDNK  DC    XL14'0'                          RETURN DDNAME KEY\n$99DSNK  DC    XL20'0'                          DSNAME KEY\n$99STK   DC    XL7'0'                           STATUS KEY\n$99TEXTL EQU   *-$99TEXT                        TEXT LIST LENGTH\n*************************************\n*   CONTROL BLOCKS AND CONSTANTS    *\n*************************************\nOPENX    OPEN  (IDCB),MF=L                      OPEN PARAMETER LIST\nCLOSEX   CLOSE (IDCB),MF=L                      CLOSE PARAMETER LIST\nIDCB     DCB   DDNAME=DDN,DEVD=DA,DSORG=PS,EODAD=IEOD,SYNAD=IOE,       X\n               MACRF=GL,LRECL=4104,BLKSIZE=4104,RECFM=F\nFLAG     DC    XL1'0'                           EOD FLAG\nEODFLG   EQU   X'80'                            EOD FLAG VALUE\nDDNAME   DC    CL8' '                           DDNAME\nDMPDSN   DC    CL44' '                          DUMP DS NAME FIELD\nDSNCNTR  DC    PL2'0'                           DSN COUNTER FIELD\n         DS    0D                               DOUBLE WORD ALIGN\nRCODE    DC    F'0'                             RETURN CODE\nTSOPL    DS    0F                               PARM LIST\n         OACTSOPL PL=(IOPL)                     DEFINE IOPL\nTSOECB   DC    F'0'                             DEF TSOECB\nPUTLST   PUTLINE MF=L                           PUTLINE LIST\nLINE     DC    H'144'                           LINE LENGTH FIELD\n         DC    H'0'                             OFFSET FIELD\nPUTBUF   DC    CL140' '                         OUTPUT BUFFER\nCVDFLD   DC    D'0'                             CVTOD WORK AREA\nOUT      DS    0F\nOUTDAY   DC    C' - DAY '                       DAY OF WEEK\nOUTJ     DC    C'YY.DDD '                       JULIAN DATE\nOUTDM    DC    C'MM/'                           MONTH\nOUTDD    DC    C'DD/'                           DAY\nOUTDY    DC    C'YY '                           YEAR\nOUTTH    DC    C'HH:'                           HOURS\nOUTTM    DC    C'MM -'                          MINUTES\nOUTLEN   EQU   *-OUT                            AREA LENGTH\nDWD      DC    D'0'                             DECIMAL CONVERSION AREA\nDSCBFLD  DC    XL140'0'                         DSCB AREA FOR OBTAIN\nOBLST    DC    X'C1000000'                      OBTAIN SEARCH FOR DSN\nDSNADR   DC    F'0'                             DSN ADDRESS\nVOLADR   DC    F'0'                             VOLSER ADDRESS\nFLDADR   DC    F'0'                             DSCB AREA ADDRESS\nVOLSER   DC    CL6'0'                           DASD VOLUME\nECBFW    DC    F'0'                             FW FOR ECB\nANSWER   DC    F'0'                             ANSWER PLACE\nKEY      DC    XL1'00'                          KEYWORD VALUE\nPFIELD   DC    XL6'20214B202020'                EDIT PATTERN FIELD\nTDATE    DC    X'904ED60F0D52400'               STCK BUFFER SPACE\n*************************\n*      PARSE PPL        *\n*************************\nPPLADS   DS    0F                               START ADDR OF PPL\nUPTADS   DC    F'0'                             ADDR OF UPT\nECTADS   DC    F'0'                             ADDR OF ECT\nECBADS   DC    F'0'                             ADDR OF ECB\nPCLADS   DC    F'0'                             ADDR OF PCL\nANSADS   DC    F'0'                             ADDR OF ANSWER AREA\nCBADS    DC    F'0'                             ADDR OF COMMAND BUFFER\nUWRKA    DC    F'0'                             ADDR OF USER WORK AREA\n         MEND                                   END OF MACRO\n         EJECT\n         PRINT  NOGEN\n********************************************************\n*                                                      *\n*    THE FOLLOWING DSECTS ARE IN USE:                  *\n*                                                      *\n*       IEFZB4D0 - SVC99 DYNAMIC ALLOCATION            *\n*                  PARAMETER LIST (NAME=S99RBP)        *\n*       IEFZB4D2 - SVC99 DYNAMIC ALLOCATION TEXT       *\n*                  UNIT KEYS (NAME=SVC99KYS)           *\n*       DCBD - DCB SYMBOLIC DEFINITION (NAME=IHADCB)   *\n*       CVT - COMMUNICATION VECTOR TABLE (NAME=CVT)    *\n*       IEESMCA - SMF CONTROL TABLE (NAME=SMCABASE)    *\n*       IKJCPPL - TSO COMMAND PROCESSOR PARAMETER      *\n*                 LIST (NAME=CPPL)                     *\n*                                                      *\n********************************************************\n         SPACE 1\n         IEFZB4D0\n         SPACE 1\n         IEFZB4D2\n         SPACE 1\n         DCBD  DSORG=PS,DEVD=DA\n         SPACE 1\n         CVT  DSECT=YES\n         SPACE 1\n         IEESMCA\n         SPACE 1\n         IKJCPPL\n         EJECT\n         PRINT  GEN\n*********************************************\n*  CSECT - DUMPINFO                         *\n*     DUMPINFO BASE - R10                   *\n*     WDSECT BASE - R12                     *\n*                                           *\n*********************************************\nDUMPINFO OACENTER EXIT=(EXIT,(R15)),DSECT=WDSECT,WORK=(,YES),          X\n               STACK=(1024,STACK,OVERFLOW,ABEND),ROUND=YES,            X\n               PARM=(R9,LR)\n         EJECT\n************************************\n*   PARSE COMMAND LINE             *\n************************************\n         OACCALL PARSE\n         L     R1,ANSADS                        ANSADS IN R1 - IKJRLSA\nRELEASE  IKJRLSA (R1)\n********************************\n*    INIT PUTLINE PTPB & IOPL  *\n********************************\n         OACCALL INITPUT\n****************************************************\n*  DISPLAY TODAYS TIME AND DATE                    *\n****************************************************\n         STCK  TDATE\n         LA    R1,TDATE                         ADDRESS OF STCK RESULT\n         OACCALL CVTOD                          CALL CONVERSION RE\n         MVC   PUTBUF(6),TMSG                   TIME MSG IN BUFFER\n         MVI   PUTBUF+35,C' '                   BLANK OUT - FROM CONV\n         PUTLINE PARM=PUTLST,OUTPUT=(LINE,TERM,,DATA),                 X\n               TERMPUT=(EDIT),MF=(E,IOPL)\n****************************************************\n*  RETRIEVE LAST IPL TIME FROM SMF CONTROL TABLE   *\n****************************************************\n         OACCALL IPLTIME\n         CLI   KEY,X'01'                        'IPL' KEYWORD USED?\n         BE    EXIT                             IF SO THEN EXIT.\n************************************\n*   INIT SVC99 REQUEST BLOCK       *\n************************************\n         OACCALL S99INIT\n********************************\n*    INIT OBTAIN PARM LIST     *\n********************************\n         OACCALL INITOLST\n**********************************\n*       INIT TEXT STRINGS        *\n**********************************\n         MVI   $99TEXT,C'0'                     INIT TEXT LIST\n         MVC   $99TEXT+1($99TEXTL),$99TEXT       - TO 0\n         MVC   $99FREC(4),=AL2(DALCLOSE,0)      SET FREE ON CLOSE\n         MVC   $99DSNK(6),=AL2(DALDSNAM,1,DSNLEN)  SET DSNAME KEY\n         MVC   $99VOLK(6),=AL2(DALRTVOL,1,6)    RETURN VOLID KEY\n         MVC   $99STK(7),$99STKDC               SET DISP=SHR\n***********************************************************\n*   MOVE  DSN INTO RB & OUTPUT BUFFER THEN DO ALLOCATE    *\n***********************************************************\n         MVC   DMPDSN(44),DSINIT                INIT DSNAME AREA\n         MVC   DMPDSN(DSNLEN),DSNDC             MVC IN DS NAME\n         MVC   DSNCNTR(2),CNTRDC                INIT DSN COUNTER\nALLOC    MVC   $99DSNK+6(DSNLEN),DMPDSN         MOVE DSNAME INTO RB\n         MVC   $99DDNK(6),=AL2(DALRTDDN,1,8)    INIT DDNAME KEY\n         MVI   PUTBUF,C' '                      0 OUTPUT BUFFER\n         MVC   PUTBUF+1(L'PUTBUF-1),PUTBUF\n         MVC   PUTBUF(DSNL),DMPDSN+(DSNLEN-DSNL) MVC DSNAME INTO BUFFER\n         LA    R1,$99RBPTR                      ADR OF RB POINTER IN R1\n         DYNALLOC\n         LTR   R15,R15                          ALLOCATE SUCCESSFUL?\n         BNZ   ERROR1                           BIF NOT TO ERROR1\n********************************************\n*   OBTAIN DSCB - TEST FOR CATALOG, VTOC   *\n*                 OR DSCB ERRORS           *\n********************************************\n         MVC   VOLSER(6),$99VOLK+6              MOVE IN VOLUME\n         OBTAIN OBLST                           DO OBTAIN\n         LTR   R15,R15                          TEST FOR 0 RC\n         BNZ   ERROR2                           BIF OBTAIN FAILS\n******************************************\n*     MOVE  IN DDNAME FROM SVC99 RB      *\n******************************************\n         MVC   DDNAME(8),=CL8' '                INIT DDNAME AREA\n         LH    R1,$99DDNK+S99TULNG-S99TUNIT     DDNAME LENGTH IN R1\n         BCTR  R1,0                             -1 FOR EXECUTE\nMOVDDN   MVC   DDNAME(1),$99DDNK+S99TUPAR-S99TUNIT  * EXECUTED *\n         EX    R1,MOVDDN                        MVC DDN INTO DDNAME\n***********************************\n*        INIT  DCB & OPEN         *\n***********************************\n         MVI   FLAG,0                           INIT EOD FLAG\n         MVC   IDCB(IDCBL),IDCBDC               INIT DCB\n         MVC   IDCB+(DCBDDNAM-IHADCB)(8),DDNAME MOVE IN DDNAME\n         MVC   OPENX(OPENL),OPENDC              INIT OPEN\n         OPEN  (IDCB,INPUT),MF=(E,OPENX)        DO OPEN\n         LA    R3,IDCB                          SET A BASE R3 TO\n         OACUSING IHADCB,R3                     DCB\n         TM    DCBOFLGS,DCBOFOPN                IS DCB OPEN?\n         OACDROP R3                             DROP BASE R3\n         BNO   ERROR3                           BIF NOT OPEN => ERROR3\n****************************************\n*   CALL SUBROUTINE TO GET HEADERMSG   *\n****************************************\n         OACCALL GETHDR                         CALL SUB GETHDR\n**************************************************************\n*   TEST FOR EMPTY DS OR IOE; NO-PRINT IF DS EMPTY & KEY=2   *\n**************************************************************\n         CLC   PUTBUF+DSNL(8),=C' - EMPTY'      IS DMPDS EMPTY?\n         BNE   IOTST                            BIF EMPTY => PUTMSG\n         CLI   KEY,X'02'                        'ALL' KEYWORD USED\n         BE    PUTMSG                           BIF SO TO PUTMSG\n         CLI   KEY,X'03'                        'FREE' KEYWORD USED?\n         BE    PUTMSG                           BIF SO TO PUTMSG\n         B     CLSDCB                           BRANCH TO CLOSE DCB\nIOTST    CLC   PUTBUF+DSNL(6),=C' - I/O'        DMPDS IOE?\n         BE    PUTMSG                           BIF IOE => PUTMSG\n         CLI   KEY,X'03'                        'FREE' KEYWORD?\n         BE    CLSDCB                           IF SO...CLOSE DCB\n*********************************************\n*   CALL SUBROUTINE TO DO STCK CONVERSION   *\n*********************************************\n         LA    R1,12(R1)                        R1 => STCK RESULT\n         OACCALL CVTOD                          ELSE CALL SUB CVTOD\n*********************************************************\n*   OUTPUT THE BUFFER  CLOSE DCB THEN GO TO NEXT DUMP   *\n*********************************************************\nPUTMSG   PUTLINE PARM=PUTLST,OUTPUT=(LINE,TERM,,DATA),                 X\n               TERMPUT=(EDIT),MF=(E,IOPL)\nCLSDCB   MVC   CLOSEX(CLOSEL),CLOSEDC           INIT CLOSE LIST\n         CLOSE (IDCB),MF=(E,CLOSEX)             CLOSE DCB\n         FREEPOOL IDCB                          FREE INPUT BUFFER POOL\n         SR    R15,R15                          CLEAR R15\n         CLI   DMPDSN+(DSNLEN-1),X'F9'          IS IT DUMP09?\n         BE    EXIT                             BIF DUMP09 => EXIT\nNEXTDS   AP    DSNCNTR(2),INCRMNT(2)            BUMP COUNTER BY 1\n         UNPK  DMPDSN+(DSNLEN-2)(2),DSNCNTR(2)  UNPK COUNTER INTO DSN\n         OI    DMPDSN+(DSNLEN-1),X'F0'          CORRECT ZONE\n         B     ALLOC                            B TO ALLOCATE NEXT DS\n*********************************\n*         ERROR ROUTINES        *\n*********************************\nERROR1   OACCALL DAIRERR\n         B     PUTMSG                           B TO PUTMSG\nERROR2   MVC   RCODE,RCODDC                     INIT RC AREA\n         STH   R15,RCODE                        SAVE RC FOR ERROR MSG\n         OACCALL OBTNERR                        CALL OBTNERR\n         OACCALL UNALOC                         DATASET UNALLOCATION\n         B     PUTMSG                           B TO PUTMSG\nERROR3   MVC   PUTBUF+DSNL(15),OPNERR           MVC MSG3 INTO BUFFER\n         B     PUTMSG                           B TO PUTMSG\n*********************************\n*   SET END OF DATA FLAGS       *\n*********************************\nIEOD     OI    FLAG,EODFLG                      AT EODAD SET EODFLG\n         BR    14                               BRANCH TO TM  EODFLG\n***********************************\n*  CONTROL BLOCKS AND CONSTANTS   *\n***********************************\nS99RBLEN EQU   S99RBEND-S99RB                   SVC99 RB LENGTH\nOPENDC   OPEN  IDCBDC,MF=L                      OPEN PARM LIST\nOPENL    EQU   *-OPENDC                         OPEN PARM LIST LENGTH\nCLOSEDC  CLOSE IDCBDC,MF=L                      CLOSE PARM LIST\nCLOSEL   EQU   *-CLOSEDC                        CLOSE PARM LIST LENGTH\nIDCBDC   DCB   DDNAME=DDN,DEVD=DA,DSORG=PS,EODAD=IEOD,SYNAD=IOE,       X\n               MACRF=GL,LRECL=4104,BLKSIZE=4104,RECFM=F\nIDCBL    EQU   *-IDCBDC                         INPUT A DCB LENGTH\nDSINIT   DC    CL44' '                          QUALIFY DS NAME FIELD\nDSNDC    DC    CL11'SYS1.DUMP00'                DUMP DATASET\nDSNLEN   EQU   *-DSNDC                          DUMP DS NAME LENGTH\nDSNL     EQU   DSNLEN-5                         LENGTH FOR PUTLINE\nRCODDC   DC    F'0'                             RETURN CODE DC\nINCRMNT  DC    PL2'1'                           DSN INCREMENT\nCNTRDC   DC    PL2'0'                           COUNTER FIELD DC\n$99STKDC DC    AL2(DALSTATS,1,1),XL1'08'        DISP=SHR RB KEY\nOPNERR   DC    CL14' - OPEN FAILED'             MSG FOR ERROR3\nTMSG     DC    CL6'* TIME'\n***********************************\n*  PARSE SERVICE ROUTINE MACROS   *\n***********************************\n         PRINT  NOGEN\nPCL      IKJPARM\nKEYWORD  IKJKEYWD\n         IKJNAME  'IPL'                       IPLTIME ONLY KEYWORD\n         IKJNAME  'ALL'                       DISLAY ALL KEYWORD\n         IKJNAME  'FREE'                      DISPLAY EMPTY DS KEYWORD\n         IKJENDP\n         OACDROP R10\n         PRINT  GEN\n         EJECT\n************************************\n************************************\n**  PARSE -                       **\n**       PARSE  COMMAND LINE      **\n**       R9 =  CPPL ADDR.         **\n************************************\n************************************\nPARSE    OACSUB\n         OACUSING CPPL,R9                       R9 = CPPL BASE\n         MVC   UPTADS,CPPLUPT                   MVC UPT ADDR INTO PPL\n         MVC   ECTADS,CPPLECT                   MVC ECT ADDR INTO PPL\n         MVC   CBADS,CPPLCBUF                   MVC CMDBUF ADDR IN PPL\n         OACDROP R9\n         LA    R2,ECBFW                         ADDR OF ECB\n         ST    R2,ECBADS                        STORE IN PPL\n         L     R2,=V(PCL)                       ADDR OF PCL\n         ST    R2,PCLADS                        STORE IN PPL\n         LA    R2,ANSWER                        ADDR OF ANSWER AREA\n         ST    R2,ANSADS                        STORE IN PPL\n         LA    R1,PPLADS                        ADDR OFF PPL IN R1\n         CALLTSSR EP=IKJPARS                    LINK TO IKJPARS\n         SR    R3,R3                            CLEAR R3\n         L     R3,ANSWER                        GET ANSWER ADDRESS\n         MVC   KEY(1),9(R3)                     MVC KEY VALUE INTO KEY\n         OACRET\n         OACDROP R10\n         EJECT\n************************************\n************************************\n**  S99INIT -                     **\n**      INITIALIZE SVC99 REQUEST  **\n**      BLOCK                     **\n************************************\n************************************\nS99INIT  OACSUB\n         LA    R1,$99RB                         ADDRESS OF RB IN R1\n         OACUSING S99RB,R1                      DESECT ADDRESSABLITY\n         ST    R1,$99RBPTR                      ADDR OF POINTER IN R1\n         OI    $99RBPTR,S99RBPND                RBPTR LAST IN PRM LST\n         XC    S99RB(S99RBLEN),S99RB            CLEAR LIST\n         MVI   S99RBLN,S99RBLEN                 MOVE IN LENGTH\n         MVI   S99VERB,S99VRBAL                 MOVE IN ALLOCATE VERB\n         LA    R0,$99ITUPL                      ADDR OF TEXT IN R0\n         ST    R0,S99TXTPP                      STORE IN TEXT POINTER\n         MVI   S99FLAG1,S99NOMNT                SET FLAG FOR NO MOUNTS\n         OACDROP R1                             DROP BASE R1\n***********************************\n*   INIT POINTERS TO TEXT UNITS   *\n***********************************\n         LA    R3,$99VOLK                       ADDR OF RETURN VOLUME\n         ST    R3,$99VOLP                       STORE IN POINTER LIST\n         LA    R3,$99FREC                       ADDR OF FREE ON CLOSE\n         ST    R3,$99IFREP                      STORE IN POINTER LIST\n         LA    R3,$99DSNK                       ADDR OF DSNAME KEY\n         ST    R3,$99IDSNP                      STORE IN POINTER LIST\n         LA    R3,$99DDNK                       ADDR OF DDNAME KEY\n         ST    R3,$99IDDNP                      STORE IN POINTER LIST\n         LA    R3,$99STK                        ADDR OF STATUS KEY\n         ST    R3,$99ISTP                       STORE IN POINTER LIST\n         OI    $99IDDNP,X'80'                   LAST ENTRY IN LIST\n         OACRET\n         OACDROP R10\n         EJECT\n**********************************************\n**********************************************\n**  INITOLST -                              **\n**   INITIALIZE PARAMETER LIST FOR OBTAIN   **\n**                                          **\n**********************************************\n**********************************************\nINITOLST OACSUB                                 SAVE REGS\n         MVC   OBLST(4),OBLSTDC                 SET SEARCH FOR DSN\n         LA    R3,DMPDSN                        ADDR OF DS NAME\n         ST    R3,DSNADR                        STORE IN PARM LIST\n         LA    R3,VOLSER                        ADDR OF VOLSER\n         ST    R3,VOLADR                        STORE IN PARM LIST\n         LA    R3,DSCBFLD                       ADDR OF DSCB AREA\n         ST    R3,FLDADR                        STORE IN PARM LIST\n         OACRET\nOBLSTDC  DC    X'C1000000'                      DSN SEARCH\n         OACDROP R10\n         EJECT\n**********************************************\n**********************************************\n**     INITPUT -                            **\n**           INITIALIZE PUTLINE             **\n**                                          **\n**********************************************\n**********************************************\nINITPUT  OACSUB                                 SAVE REGS\n         OACBLDPL CPPL=0(R9),ECB=TSOECB,IOPL=IOPL\n         MVC   LINE(2),LINEDC                   INIT OUTPUT LINE\n         MVC   LINE+2(2),OFFSET                 INIT LINE OFFSET\n         MVC   PUTBUF(140),PUTBUFDC             INIT OUTPUT BUFFER\n         MVC   PUTLST(PUTLEN),PUTLSTDC          INIT PUTLINE LIST\n         OACRET\nLINEDC   DC    H'144'                           LINE LENGTH FIELD\nOFFSET   DC    H'0'                             OFFSET\nPUTBUFDC DC    CL140' '                         OUTPUT BUFFER DC\nPUTLSTDC PUTLINE MF=L                           PUTLINE LIST\nPUTLEN   EQU   *-PUTLSTDC                       PUTLINE LIST LENGTH\n         OACDROP R10\n         EJECT\n***************************************************************\n***************************************************************\n**  IPLTIME -                                                **\n**  GET LAST IPL TIME FROM SMF CONTROL TABLE                 **\n**                                                           **\n**  OUTPUT FORMAT: * IPL  - DAY YY.DDD MM/DD/YY HH:MM        **\n**  MACROS USED:                                             **\n**              CVT                                          **\n**              IEESMCA                                      **\n***************************************************************\n***************************************************************\nIPLTIME  OACSUB\n         L     R1,CVTPTR                        GET CVT ADDR\n         L     R1,CVTSMCA-CVT(,R1)              ADDR OF SMF CTRL AREA\n         OACUSING SMCABASE,R1\n         N     R1,=X'00FFFFFF'                  IS IT AVAILABLE?\n         BNZ   GETIME                           BIF AVAILABLE TO GETIME\n         MVC   PUTBUF(17),NAMSG                 PUT N/A MSG\n         B     PUTTIME                          EXIT\nGETIME   SR    R2,R2                            CLEAR REGS R2 AND\n         SR    R3,R3                            R3 FOR DIVIDE\n         L     R3,SMCAITME                      IPL TIME IN R3\n         D     R2,=A(100*60*60)                 GET HOURS IN R3\n         CVD   R3,CVDFLD                        CVD HOURS\n         UNPK  PUTBUF+(MSGLEN+16)(2),CVDFLD+6(2) UNPK HOURS IN BUFFER\n         SRDL  R2,32                            SHIFT SECONDS INTO R3\n         D     R2,=A(100*60)                    GET MINUTES\n         CVD   R3,CVDFLD                        CVD MINUTES\n         UNPK  PUTBUF+(MSGLEN+19)(2),CVDFLD+6(2) UNPK MIN INTO BUFFER\n         MVI   PUTBUF+(MSGLEN+18),C':'          MVC : BETWEEN HRS:MIN\n         OI    PUTBUF+(MSGLEN+17),X'F0'         CORRECT ZONE FOR HRS\n         OI    PUTBUF+(MSGLEN+20),X'F0'         CORRECT ZONE FOR MIN\n         MVC   PFIELD(6),PTRN                   MVC PATTERN INTO PFIELD\n         ED    PFIELD(6),SMCAIDTE+1             EDIT DATE INTO PFIELD\n         MVC   PUTBUF+MSGLEN(6),PFIELD          DATE INTO BUFFER\n         MVC   PUTBUF(MSGLEN),IPLMSG            MVC IPLMSG INTO BUFFER\n         MVC   CVDFLD,=D'0'                     CLEAR DW CVDFLD\n         MVC   CVDFLD+6(2),SMCAIDTE+2           MOVE DAYS INTO CVDFLD\n         CVB   R2,CVDFLD                        DAYS INTO R2 FOR SUB\n         MVC   CVDFLD+4(4),SMCAIDTE             MOVE DATE INTO CVDFLD\n         SRP   CVDFLD+4(4),64-3,0               SHIFT OUT DAYS\n         UNPK  OUTDY(2),CVDFLD+6(2)             UNPK YEARS FOR OUTPUT\n         OI    OUTDY+1,X'F0'                    CORRECT ZONE\n         CVB   R3,CVDFLD                        YEAR INTO R3 FOR SUB\n         OACCALL IPLDAY\n         OACCALL GRDATE                         CALL GRDATE SUBROUTINE\n         MVC   PUTBUF+(MSGLEN+7)(8),OUTDM\nPUTTIME  PUTLINE PARM=PUTLST,OUTPUT=(LINE,TERM,,DATA),                 X\n               TERMPUT=(EDIT),MF=(E,IOPL)\n         OACRET\nPTRN     DC    XL6'20214B202020'                EDIT PATTERN DC\nNAMSG    DC    CL17'SMF NOT AVAILABLE'          NOT AVAIL MESSAGE\nIPLMSG   DC    CL13'* IPL  - DAY '              IPL TIME MESSAGE\nMSGLEN   EQU   *-IPLMSG                         IPL MSG LENGTH\n         OACDROP R10\n         OACDROP R1\n         EJECT\n**********************************************\n**********************************************\n**   IPLDAY -                               **\n**   CALC DAY OF WEEK FROM SMF RECORDS FOR  **\n**   IPL  TIME                              **\n**********************************************\n**********************************************\nIPLDAY   OACSUB\n         SR    R4,R4               CLEAR WORK REGS\n         SR    R5,R5\n         SR    R6,R6\n         SR    R7,R7\n         LR    R5,R3               YEAR IN R5\n         LR    R7,R3               YEAR IN R7\n         D     R6,=F'4'            CALC # OF DAYS FOR LEAP YEARS\n         M     R4,=F'365'          CALC DAYS IN # OF YEARS\n         AR    R5,R2               ADD IN # OF DAYS THIS YEAR\n         AR    R5,R7               ADD IN LEAP YEAR DAYS\n         D     R4,=F'7'            DIVIDE BY 7 FOR REMAINDER\n         LR    R5,R4               GET REMAINDER FOR MULTIPLY\n         M     R4,=F'7'            MULTIPLY REMAINDER FOR TABLE OFFSET\n         LA    R6,DATBL            ADDR OF DAY TABLE\n         AR    R6,R5               ADD ADDR OF TABLE WITH OFFSET\n         MVC   PUTBUF+6(7),0(R6)   MOVE DAY INTO OUTPUT BUFFER\n         OACRET\n*---            DAY TABLE\nDATBL    DC    CL7' - SUN '\n         DC    CL7' - MON '\n         DC    CL7' - TUE '\n         DC    CL7' - WED '\n         DC    CL7' - THR '\n         DC    CL7' - FRI '\n         DC    CL7' - SAT '\n         OACDROP R10\n         EJECT\n**********************************************\n**********************************************\n**   GETHDR -                               **\n**   GET HEADER RECORDS FROM DUMP DATASET   **\n**                                          **\n**********************************************\n**********************************************\nGETHDR   OACSUB                                 SAVE REGS\n         SR    R3,R3                            CLEAR R3 FOR INCREMENT\nGETBLK   GET   IDCB                             LOCATE A BLOCK\n         TM    FLAG,EODFLG                      IS IT EOD?\n         BO    EMPTYMSG                         BIF EOD TO EMPTYMSG\n         CLI   0(R1),X'FF'                      IS FIRST 2 BYTES FF?\n         BE    MOVTITLE                         BIF FF MOVTITLE\n         LA    R3,1(R3)                         INCREMENT R3+1\n         C     R3,=F'2'                         IS R3=2\n         BE    EMPTYMSG                         BIF R3=2 EMPTYMSG\n         B     GETBLK                           LOCATE NEXT BLOCK\nEMPTYMSG MVC   PUTBUF+DSNL(8),=CL8' - EMPTY'    MVC DS EMPTY MSG\n         B     EXITSUB                          B EXITSUB\nIOE      MVC   PUTBUF+DSNL(12),=CL12' - I/O ERROR'\n         B     EXITSUB\nMOVTITLE MVC   PUTBUF+(DSNL+31)(100),20(R1)     GET HEADERMSG FROM DS\nEXITSUB  OACRET                                 RESTORE REGS & EXITSUB\n         OACDROP R10\n         EJECT\n************************************************************\n************************************************************\n** CVTOD - CONVERT TOD TO INTERNAL/EXTERNAL FORMAT        **\n**   ENTRY:  R14 - RETURN ADDRESS                         **\n**           R13 - SAVE AREA ADDRESS                      **\n**           R1  - ADDR OF TOD TO CONVERT                 **\n**                                                        **\n**       SUBROUTINES USED: GRDATE                         **\n**                                                        **\n**   EXIT:   R15 - RETURN CODE                            **\n**                                                        **\n**    OUTPUT FORMAT: '- DAY YY.DDD MM/DD/YY HH:MM -'      **\n**                                                        **\n**     ASSUMES ZERO VALUE FOR TOD CLOCK IS ----           **\n**                   '01/01/00 (000) 00:00:00.000000'     **\n**                                                        **\n************************************************************\n************************************************************\n         SPACE 3\nCVTOD    OACSUB                         SAVE CALLERS REGS\n         MVI   OUT,C' '                 INIT OUTPUT AREA TO BLANK\n         MVC   OUT+1(OUTLEN-1),OUT\n         LM    R2,R3,0(R1)              GET ORIG TOD VALUE\n         SRDL  R2,12                    ALIGN MICROSECONDS\n         D     R2,=A(60*1000000)        MIN TO R3, USEC TO R2\n         CVD   R2,DWD                   USEC TO DECIMAL\n         SR    R2,R2                    CLEAR FOR DIVIDE\n         D     R2,=A(60)                HOUR TO R3, MIN TO R2\n         CVD   R2,DWD                   MINUTES TO DEC\n         UNPK  OUTTM(2),DWD+6(2)        MIN TO OUTPUT AREA\n         OI    OUTTM+1,C'0'             FIX ZONE\n         MVI   OUTTM+3,C'-'             MOVE - INTO BUFFER AFTER MIN\n         SR    R2,R2                    CLEAR FOR DIVIDE\n         D     R2,=A(24)                DAYS TO R3, HOURS TO R2\n*************************\n*   CALC DAY OF WEEK    *\n*************************\n         SR    R9,R9\n         LR    R9,R3                    TOTAL # DAYS IN R9\n         SR    R8,R8                    CLEAR R8 FOR DIVIDE\n         D     R8,=F'7'                 DIVIDE BY 7 TO GET REMAINDER\n         LA    R6,DAYTBL                ADDR OF DAY TABLE IN R6\n         LR    R9,R8                    MOVE REMAINDER FOR MULTIPLY\n         M     R8,=F'7'                 MULTIPLY REMAINDER BY 7\n         AR    R6,R9                    ADD TO TABLE ADDR\n         MVC   OUTDAY(7),0(R6)          MOVE DAY INTO OUTPUT\n**********************************\n*   CALC YEAR, HOURS & MINUTES   *\n**********************************\n         CVD   R2,DWD                   HOURS TO DEC\n         UNPK  OUTTH(2),DWD+6(2)         HOURS TO OUTPUT AREA\n         OI    OUTTH+1,C'0'              FIX ZONE\n         MVI   OUTTH+2,C':'             COLON BETWEEN HOUR:MIN\n         C     R3,=A(365)               AFTER 1900?\n         BNH   *+8                      BIF NOT AFTER 1900\n         A     R3,=A(1)                 ELSE PRETEND 1900 LEAP YEAR\n         SLL   R3,2                     DAYS * 4\n         SR    R2,R2                    CLEAR FOR DIVIDE\n         D     R2,=A((365*4)+1)         YEAR TO R3, DAY TO R2\n         CVD   R3,DWD                   YEAR TO DEC\n         UNPK  OUTJ(2),DWD+6(2)         YEAR TO JULIAN DATE OUTPUT\n         UNPK  OUTDY(2),DWD+6(2)        YEAR TO OUTPUT AREA\n         OI    OUTJ+1,C'0'              FIX ZONE\n         OI    OUTDY+1,X'F0'            FIX ZONE\n         SRL   R2,2                     DAYS * 4 TO DAYS\n         A     R2,=A(1)                 + 1 TO GET DAYS ORIG 1\n         CVD   R2,DWD                   JULIAN DAY TO DEC\n         UNPK  OUTJ+3(3),DWD+6(2)       JULIAN DAY TO OUTPUT AREA\n         OI    OUTJ+5,X'F0'             FIX ZONE\n         MVI   OUTJ+2,C'.'              . IN JULIAN DATE\n         OACCALL GRDATE\n         MVC   PUTBUF+DSNL(OUTLEN),OUT  MOVE TIME INTO PUTBUF\n         OACRET\n         SPACE 1\n*---            DAY TABLE\nDAYTBL   DC    CL7' - MON '\n         DC    CL7' - TUE '\n         DC    CL7' - WED '\n         DC    CL7' - THR '\n         DC    CL7' - FRI '\n         DC    CL7' - SAT '\n         DC    CL7' - SUN '\n         OACDROP R10\n         EJECT\n*****************************************************\n*****************************************************\n**       GRDATE -                                  **\n**                                                 **\n**       CONVERT JULIAN TO GREGORIAN DATE          **\n**       CALLED -  CVTOD                           **\n**                 IPLTIME                         **\n**       R2 - JULIAN DAY IN BIN                    **\n**       R3 - YEAR IN BIN                          **\n**                                                 **\n*****************************************************\n*****************************************************\nGRDATE   OACSUB\n         LA    R5,CVTOD#T1-2            ASSUME NON-LEAP YEAR\n         N     R3,=F'3'                 TEST FOR LEAP YEAR\n         BNZ   CVTOD$NL                 BIF NOT LEAP YEAR\n         LA    R5,CVTOD#T2-2            ELSE FEB HAS 29 DAYS\nCVTOD$NL LR    R4,R5                    COPY TABLE ADDR\nCVTOD$L1 LA    R4,2(,R4)                POINT TO NEXT ENTRY\n         SH    R2,0(,R4)                DAYS LEFT AFTER MONTH\n         BP    CVTOD$L1                 BIF AFTER THIS MONTH\n         AH    R2,0(,R4)                GET DAY IN MONTH\n         CVD   R2,DWD                   DAY IN MONTH TO DEC\n         UNPK  OUTDD(2),DWD+6(2)        DAY TO OUTPUT AREA\n         OI    OUTDD+1,C'0'             FIX ZONE\n         MVI   OUTDD+2,C'/'             SLASH AFTER DAY\n         SR    R4,R5                    GET 2*MONTH ORIG 0\n         SRL   R4,1                     GET MONTH\n         CVD   R4,DWD                   MONTH TO DEC\n         UNPK  OUTDM(2),DWD+6(2)        MONTH TO OUTPUT AREA\n         OI    OUTDM+1,C'0'             FIX ZONE\n         MVI   OUTDM+2,C'/'             SLASH AFTER MONTH\n         OACRET\n*---            NON - LEAP YEAR TABLE OF DAYS / MONTH\nCVTOD#T1 DC    H'31'       1 -          JAN\n         DC    H'28'       2 -          FEB\n         DC    H'31'       3 -          MARCH\n         DC    H'30'       4 -          APRIL\n         DC    H'31'       5 -          MAY\n         DC    H'30'       6 -          JUNE\n         DC    H'31'       7 -          JULY\n         DC    H'31'       8 -          AUG\n         DC    H'30'       9 -          SEPT\n         DC    H'31'      10 -          OCT\n         DC    H'30'      11 -          NOV\n         DC    H'31'      12 -          DEC\n         SPACE 1\n*---              LEAP YEAR TABLE OF DAYS / MONTH\nCVTOD#T2 DC    H'31'       1 -          JAN\n         DC    H'29'       2 -          FEB\n         DC    H'31'       3 -          MARCH\n         DC    H'30'       4 -          APRIL\n         DC    H'31'       5 -          MAY\n         DC    H'30'       6 -          JUNE\n         DC    H'31'       7 -          JULY\n         DC    H'31'       8 -          AUG\n         DC    H'30'       9 -          SEPT\n         DC    H'31'      10 -          OCT\n         DC    H'30'      11 -          NOV\n         DC    H'31'      12 -          DEC\n         DC    H'32767'   13 -          13TH MONTH (LARGE AND LAST)\n         SPACE 1\n         OACDROP R10\n         EJECT\n*****************************************************\n*****************************************************\n**       DAIRERR -                                 **\n**                                                 **\n**       ERROR ROUTINE 1                           **\n**       SVC99 FAILURE - ALLOCATE                  **\n**                                                 **\n*****************************************************\n*****************************************************\nDAIRERR  OACSUB                                 SAVE REGS\n         LA    R3,$99RB                         ESTABLISH ADDRESS\n         OACUSING S99RB,R3                      IN SVC99 RB\n         CLC   S99ERROR(2),=X'0218'             IS ERROR CODE = 0218?\n         BNE   GETCODE                          BIF NOT TO GET CODE\n         MVC   PUTBUF+DSNL(44),E1MSG1           MVC E1MSG2 INTO BUFFER\n         B     ESUB                             B EXIT SUBROUTINE\nGETCODE  MVC   RCODE,RCODC1                     INIT RC AREA\n         MVC   RCODE(2),S99ERROR                MVC RC INTI RC AREA\n         MVC   PUTBUF+DSNL(25),E1MSG2           MVC E1MSG3 INTO BUFFER\n         UNPK  PUTBUF+(DSNL+L'E1MSG2-4)(5),RCODE(3)\n         MVI   PUTBUF+(DSNL+L'E1MSG2),C' '      BLANK OUT BAD CHAR\n         TR    PUTBUF+(DSNL+L'E1MSG2-4)(4),TRTBL1\n         CLI   RCODE,X'17'                      IS RC '17' PREFIX?\n         BNE   ESUB                             BIF NOT EXIT SUBROUTINE\n         MVC   PUTBUF+(DSNL+L'E1MSG2)(13),E1MSG3\nESUB     OACRET                                 RETURN TO MAIN\nE1MSG1   DC    CL44' - DAIR ERROR - CODE=0218 VOLUME NOT MOUNTED'\nE1MSG2   DC    CL25' - DAIR ERROR - CODE=0000'  DAIR ERROR MSG\nE1MSG3   DC    CL13' LOCATE ERROR'              LOCATE ERROR MSG\nRCODC1   DC    F'0'                             RC DC\nTRTBL1   DC    256X'00'                         HEX TO CHAR\n         ORG   TRTBL1+C'0'                      TRANSLATE\n         DC    CL16'0123456789ABCDEF'           TABLE\n         ORG   ,\n         OACDROP R10\n         OACDROP R3\n         EJECT\n*****************************************************\n*****************************************************\n**       OBTNERR -                                 **\n**                                                 **\n**       ERROR ROUTINE 2                           **\n**       OBTAIN FAILURE                            **\n**                                                 **\n**       RCODE CONTAINS RETURN CODE                **\n*****************************************************\n*****************************************************\nOBTNERR  OACSUB                                 SAVE REGS\n         MVC   PUTBUF+DSNL(25),E2MSG1           MVC E2MSG1 INTO BUFFER\n         CLC   RCODE(2),=X'0008'                IS RC = '0008'?\n         BNE   COMPAR2                          BIF NOT COMPAR2\n         MVC   PUTBUF+(DSNL+MSGL)(25),E2MSG2    MVC E2MSG2 INTO BUFFER\n         B     EXITSB                           B EXIT SUBROUTINE\nCOMPAR2  CLC   RCODE(2),=X'0012'                IS RC = '0012'?\n         BNE   GETCDE                           BIF NOT GETCDE\n         MVC   PUTBUF+(DSNL+MSGL)(25),E2MSG3    MVC E2MSG3 INTO BUFFER\n         B     EXITSB                           B EXIT SUBROUTINE\nGETCDE   MVC   PUTBUF+(DSNL+MSGL)(10),E2MSG4    MVC E2MSG4 INTO BUFFER\n         UNPK  PUTBUF+(DSNL+23)(5),RCODE(3)     UNPK RC+1 INTO BUFFER\n         MVI   PUTBUF+(DSNL+27),C' '            BLANK OUT BAD CHAR\n         TR    PUTBUF+(DSNL+23)(4),TRTBL2       TR HEX TO CHAR\nEXITSB   OACRET                                 RETURN TO MAIN\nE2MSG1   DC    CL17' - OBTAIN ERROR -'\nMSGL     EQU   *-E2MSG1                         E2MSG1 LENGTH\nE2MSG2   DC    CL25' CODE=0008 DSCB NOT FOUND'\nE2MSG3   DC    CL25' CODE=0012 DSCB I/O ERROR'\nE2MSG4   DC    CL10' CODE=0000'\nTRTBL2   DC    256X'00'                         HEX TO CHAR\n         ORG   TRTBL2+C'0'                      TRANSLATE\n         DC    CL16'0123456789ABCDEF'           TABLE\n         ORG   ,\n         OACDROP R10\n         EJECT\n*****************************************************\n*****************************************************\n**       UNALOC  -                                 **\n**                                                 **\n**       SVC99 UNALLOCATION IF OBTAIN              **\n**       ERROR OCCURS                              **\n**                                                 **\n*****************************************************\n*****************************************************\nUNALOC   OACSUB\n         LA    R3,$99RB                         R3 BASE FOR\n         OACUSING S99RB,R3                      SVC99 REQUEST BLK\n         MVI   S99VERB,S99VRBUN                 MOVE IN UNALLOCATE\n         OI    $99IDSNP,X'80'                   SET DSN PTR LAST\n         LA    R1,$99RBPTR                      RB PTR ADDR IN R1\n         DYNALLOC\n         MVI   S99VERB,S99VRBAL                 MOVE IN ALLOCATE\n         NI    $99IDSNP,X'00'                   REMOVE 80 BIT\n         OACRET                                 EXIT SUBROUTINE\n         OACDROP R10\n         OACDROP R3\n         EJECT\n         END\n//*\n//C   EXEC PGM=COMPARE,\n//  PARM='GO,DUMPINFO'\n//STEPLIB  DD DISP=SHR,DSN=SYS5.MSSLOAD\n//SYSPRINT DD SYSOUT=*\n//I1       DD DISP=(SHR,PASS),DSN=&&GOSET\n//I2       DD DISP=SHR,DSN=SYS9.SYSCP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENQ": {"ttr": 4356, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x025\\x025\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 565, "newlines": 565, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMASA JOB ACCT,MSGCLASS=A,COND=(0,NE)\n/*ROUTE PRINT WYLBUR\n//ASM EXEC ASMHCL\n//ASM.SYSLIB DD\n//           DD\n//           DD DISP=SHR,DSN=SYS5.MSSMAC\n         MACRO\n         OACWORK &DUMMY\nAREAA    DS    F                  ADDRESS OF Q AREA\nAREAL    DS    F                  LENGTH OF AREA\nRIBL     DS    H                  LENGTH OF RIB\nRIBEL    DS    H                  LENGTH OF RIBE\nTOKEN    DS    F                  TOKEN FOR GQSCAN\nGQRC     DS    F                  RETURN CODE FROM GQSCAN\nNRIBS    DS    F                  NUMBER OF RIBS RETURNED\nNRIBES   DS    F                  NUMBER OF RIBES THIS RIB\nNCRIBES  DS    F                  NUMBER OF RIBES IN THIS AREA\nGQLIST   GQSCAN MF=L\nIOPLL    DS    4F\nTSOECB   DS    F\nGETADDR  DS    F                  ADDR OF BUFFER RETURNED BY PUTGET\nGETLEN   DS    F                  LENGTH OF BUFFER RETURNED BY PUTGET\nCURIN    DS    F                  POINTER TO CURRENT INPUT POSITION\nCUREND   DS    F                  POINTER PAST END OF CURRENT INPUT\nOLD      DS    2F                 OUTPUT LINE DESCRIPTOR\nPARMLSTS EQU   *\nPUTLL    PUTLINE MF=L             PUTLINE PARM BLOCK\n         ORG   PARMLSTS\nPUTGETL  PUTGET  MF=L             PUTGET PARM BLOCK\n         ORG   PARMLSTS\nGETMAINL GETMAIN VC,MF=L\n         ORG   PARMLSTS\nFREEML   FREEMAIN VU,MF=L\n         ORG\nQNL      DS    H                  QNAME LENGTH\nRNL      DS    H                  RNAME LENGTH\nJNL      DS    H                  JOBNAME LENGTH\nFLGS     DS    X\nCONTFLG  EQU   X'80'              RIB HAS BEEN FORMATTED\nCONFLG   EQU   X'40'              CONFLICT COMMAND IN EFFECT\nFINDFLG  EQU   X'20'              FIND COMMAND IN EFFECT\nGLOBFLG  EQU   X'10'              GLOBAL COMMAND IN EFFECT\nQNAME    DS    CL8                QUEUE NAME\nJNAME    DS    CL8                JOB NAME\nRNAME    DS    CL255              RNAME\nPRTLEN   DS    H                  PRINTLINE LENGTH\nPRTOFF   DS    H                  OFFSET\nPRTBUFF  DS    (300)CL1           OUTPUT BUFFER\n         MEND\n         MACRO\n&LBL     MSG   &PARM\n         LCLA  &A\n&A       SETA  2+K'&PARM\n&LBL     DC    0H'0',AL2(&A,0)\n         DC    C&PARM\n         MEND\nENQ      CSECT\nENQ      OACENTER DSECT=WDSECT,WORK=(,YES),EXIT=(EXIT,(R15)),          X\n               PARM=(R9,LR,CPPL),STACK=(144,STACK,OVERFLOW,ABEND),     X\n               ROUND=YES\n         TITLE 'ENQ - INITIALIZATION'\n*\n*        INITIALIZATION\n*\n         LA    R8,IOPLL           INITIALIZE THE IOPL\n         OACUSING IOPL,R8\n         MVC   IOPLUPT(4),CPPLUPT COPY UPT ADD FROM CPPL\n         MVC   IOPLECT(4),CPPLECT COPY ECT ADD FROM CPPL\n         LA    R1,TSOECB          GET TSO ECB ADDRESS\n         ST    R1,IOPLECB         STORE IN IOPL\n         OACDROP R8,R9\n         LA    R1,PRTLEN          INITIALIZE TO OLD\n         ST    R1,OLD+4           STORE OUTPUT BUF ADD IN OLD\n         LA    R1,1               GET NUMBER OF OUTPUT SEGMENTS\n         ST    R1,OLD             STORE IN OLD\n         XC    PRTOFF(2),PRTOFF   ZERO OFFSET OF FIRST SEGMENT\n         MVC   GETMAINL(GETMLEN),GETMDC BUY AN AREA FOR GQSCAN\nGETAREA  GETMAIN VC,LA=MEMLOW,A=AREAA,MF=(E,GETMAINL),SP=1,            X\n               RELATED=(FREEAREA)\n         LTR   R15,R15\n         BZ    CONFL1\n         LA    R1,NOMEM           COMPLAIN ABOUT LACK OF MEMORY\n         OACCALL PRINT\n         LA    R15,4\n         B     EXIT\n*\n*        ON ENTRY WE ASSUME THE CONFLICT COMMAND\n*\nCONFL1   MVI   FLGS,CONFLG        INIT THE FLAG\n         XC    QNL(6),QNL         ZERO LENGTHS\n         MVC   GQLIST(CONQL),CONQ INIT PARM LIST\n         TITLE 'ENQ - MAIN Q SCAN/FORM AT LOOP'\n*\n*        MAIN  Q SCAN/FORMAT LOOP  FOR ALL COMMANDS\n*\nENQLP    OACCALL SCAN             GO SCAN QUEUES\n         BNZ   GETCMD             NOTHING THERE\n         L     R9,AREAA           POINT TO FIRST RIB\n         OACUSING RIB,R9\n*\n*        LOOP  TO HERE AFTER RESCAN WHERE ALL RIBES FOR THE\n*              PREVIOUS RIB OCCURED  IN THE PREVIOUS AREA\n*\nENQLP1   MVC   NRIBES(4),RIBTRIBE TOTAL NUMBER OF RIBE'S FOR THIS RIB\n         NI    FLGS,X'FF'-CONTFLG MARK START OF RIB\n         MVC   NCRIBES(4),RIBNRIBE SAVE # RIBES THIS AREA\n         LR    R8,R9              COPY RIB ADDR\n         AH    R8,RIBL            ADD IN RIBLENGTH RETURN BY GQSCAN\n         AH    R8,RIBVLEN         ADD IN LENGTH OF VARIABLE PORTION\n         OACUSING RIBE,R8\n*\n*        LOOP  TO HERE TO PROCESS  A RIBE\n*\nENQLP3   OACCALL FINDCHK          SEE IF WE PRINT THIS ONE\n         BNZ   ENQ2               IF NOT NO PRINT\n         OACCALL FMTRIBE          FORMAT JOB INFO\n         OACCALL FMTRIB           FORMAT QNAME, RNAME INFO\n         OACCALL PRINT\n         BNZ   GETCMD             IF ATTN, QUIT\nENQ2     AH    R8,RIBEL           POINT TO NEXT RIBE\n         L     R1,NRIBES         GET # UNPROCESSED RIBES THIS RIB\n         BCT   R1,ENQ4            DECREMENT\n*\n*        FINISHED WITH THE RIBES IN THIS RIB\n*        ADJUST POINTER AND DECREMENT NUMBER OF RIBS\n*\nENQ2A    LR    R9,R8              ITS A RIB NOT A RIBE\n         NI    FLGS,X'FF'-CONTFLG MARK START OF RIB\n         L     R1,NRIBS           GET # UNPROCESSED RIBS\n         BCT   R1,ENQ3            DECREMENT\n*\n*        FINISHED WITH ALL THE RIBS IN THIS AREA\n*        CHECK RC TO SEE IF THAT  WAS THE LAST RIB\n*\n         ICM   R1,15,GQRC         CHECK FOR END OF LIST\n         BZ    GETCMD\n         OACCALL RESCAN           GET NEXT CHUNK OF STUFF\n         L     R9,AREAA           POINT TO FIRST RIB\n         BZ    ENQLP1\n         B     GETCMD             TOTAL NUMBER OF RIBE'S FOR THIS RIB\n*\n*        THERE IS AT LEAST ONE UNPROCESSED RIB IN THIS AREA\n*\nENQ3     ST    R1,NRIBS           STORE NEW #\n         B     ENQLP1             GO PROCESS THIS RIB\n*\n*        THERE IS AT LEAST ONE UNPROCESSED RIBE IN THIS RIB\n*\nENQ4     ST    R1,NRIBES          STORE NEW #\n         L     R1,NCRIBES         GET # UNPROCESSED RIBS THIS AREA\n         BCT   R1,ENQ5\n*\n*        THE RIBES FOR THIS RIB SPAN THIS AREA\n*        SO WE  WANT THE NEXT CHUNK, BUT WE DONT\n*        WANT  TO REDISPLAY THE QNAME, RNAME INFO\n*\n**       OACCALL RESCAN           GET NEXT CHUNK OF STUFF\n**       BNZ   GETCMD\n**       L     R9,AREAA           POINT TO FIRST RIB\n**       OI    FLGS,CONTFLG       MARK CONTINUATION\n**       B     ENQLP2\n*\n*        WELL  IT WAS A GOOD IDEA, BUT IT TURNS OUT THAT\n*        GQSCAN TRUNCATES SPANNED RIBES UNLESS THE SCOPE\n*        IS LOCAL OR GLOBAL, FOR WHICH YOU HAVE TO BE\n*        KEY ZERO SUPERVISOR, SO JUST PUT OUT A MSG OF (*MORE*)\n*        AND PROCESS THE NEXT RIB\n         LA    R1,MOREM           POINT TO MORE MESSAGE\n         ST    R1,OLD+4           STORE IN OLD\n         OACCALL PRINT\n         BZ    ENQ2A              PROCESS NEXT RIB\n         B     GETCMD             IF ATTN PROCESS NEXT CMD\n*\n*        THERE  IS AT LEAST ONE UNPROCESSED RIBE IN THIS AREA\n*\nENQ5     ST    R1,NCRIBES         STORE NEW #\n         B     ENQLP3             GO FORMAT THIS ONE\n         TITLE 'ENQ - COMMAND REQUESTOR'\n*\n*        COMMAND REQUESTOR\n*\nGETCMD   NI    FLGS,CONFLG+FINDFLG+GLOBFLG CLEANUP FLAGS\n         LA    R1,HERALD          POINT TO HERALD\n         ST    R1,OLD+4           STORE IN OLD\n         MVC   PUTGETL(PUTGTDCL),PUTGETDC INIT PARM BLOCK\n         XC    TSOECB(4),TSOECB   INIT ECB\n         PUTGET PARM=PUTGETL,OUTPUT=(OLD,SINGLE,MODE),                 X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     X\n               TERMGET=(EDIT,WAIT),MF=(E,IOPLL)\n         CH    R15,=H'5'          SEE IF OK RETURN\n         BL    GETCMD1\n         CH    R15,=H'8'          WAS IT ATTENTION?\n         BE    GETCMD             IF SO REPROMPT\n         CH    R15,=H'32'         DID THE USER HANG UP?\n         BE    CLEANUP            IF SO JUST EXIT\n         EX    R0,*               SHOULD NEVER HAPPEN\nGETCMD1  L     R9,PUTGETL+12      GET ADDR OF REPLY\n         ST    R9,GETADDR         SAVE AS ADDR OF INPUT BUFFER\n         LH    R8,0(R9)           GET LENGTH OF INPUT BUFFER\n         ST    R8,GETLEN          SAVE LENGTH\n         CH    R8,=H'4'           SEE IF EMPTY\n         BH    GETCMD2            NO SO PROCESS IT\nRECMD    TM    FLGS,CONFLG        DO LAST COMMAND AGAIN\n         BO    CONFLICT           IF CONFLICT, DO IT AGAIN\n         TM    FLGS,FINDFLG       IF FIND\n         BO    FINDAG             DO THAT AGAIN\n         TM    FLGS,GLOBFLG       IF GLOBAL\n         BO    GLOBAL             DO THAT AGAIN\nGETCMDAG OACCALL GETCMDFR         FREE THE INPUT BUFFER\n         B     GETCMD             AND ASK AGAIN\nGETCMD2  LA    R7,0(R8,R9)        POINT PAST END OF INPUT BUFFER\n         ST    R7,CUREND          SAVE THIS POSITION\n         LA    R6,4(R9)           POINT TO FIRST TEXT CHAR\n         ST    R6,CURIN           INITIALIZE CURRENT INPUT POSITION\n         OACCALL GETTOKEN\n         BZ    RECMD              IF EMPTY LINE, DO PREVIOUS CMD\n         CLI   0(R1),C'C'         SEE IF CONFLICT\n         BE    CONFLICT\n         CLI   0(R1),C'E'         SEE IF END\n         BE    END\n         CLI   0(R1),C'F'         SEE IF FIND\n         BE    FIND\n         CLI   0(R1),C'G'         SEE IF GLOBAL\n         BE    GLOBAL\n         LA    R1,CMDNF           POINT TO INVALID COMMAND MSG\n         ST    R1,OLD+4\n         OACCALL PRINT\n         BZ    GETCMDAG           IF NO ATTN, ASK AGAIN\n         B     END                IF ATTN, END\n         TITLE 'ENQ - COMMANDS'\nCONFLICT OACCALL GETCMDFR         CONFLICT\n         B     CONFL1\n*\nEND      OACCALL GETCMDFR         END\n         B     CLEANUP\n*\nGLOBAL   OACCALL GETCMDFR         GLOBAL\n         MVI   FLGS,GLOBFLG       CLEAR FLAGS\n         MVC   GQLIST(ALLQL),ALLQ INIT PARM BLOCK\n         B     ENQLP\n*\nFIND     XC    QNL(6),QNL         ZERO ALL LENGTHS\n         OACCALL GETTOKEN\n         BZ    FIND1              IF NONE LEAVE ALL EMPTY\n         CLI   0(R1),C'*'         * IS SAME AS EMPTY\n         BE    FIND1\n         CH    R15,=H'8'          CHECK LENGTH\n         BH    FINDPR\n         STH   R15,QNL            SAVE QNAME LENGTH\n         BCTR  R15,0              DECREMENT FOR  EXECUTE\n         MVC   QNAME(1),0(R1)     < EXECUTED >\n         EX    R15,*-6            MOVE INTO SAVE AREA\nFIND1    OACCALL GETTOKEN\n         BZ    FIND2              IF NONE LEAVE REST EMPTY\n         CLI   0(R1),C'*'         * IS SAME AS EMPTY\n         BE    FIND2\n         CH    R15,=H'255'\n         BH    FINDPR\n         STH   R15,RNL            SAVE RNAME LENGTH\n         BCTR  R15,0              DECREMENT FOR EXECUTE\n         MVC   RNAME(1),0(R1)     < EXECUTED >\n         EX    R15,*-6\nFIND2    OACCALL GETTOKEN\n         BZ    FINDAG             IF NONE LEAVE REST EMPTY\n         CLI   0(R1),C'*'         * IS SAME AS EMPTY\n         BE    FINDAG\n         CH    R15,=H'8'          CHECK FOR VALID LENGTH\n         BH    FINDPR\n         STH   R15,JNL            SAVE JOBNAME LENGTH\n         BCTR  R15,0              DECREMENT FOR EXECUTE\n         MVC   JNAME(1),0(R1)     < EXECUTED >\n         EX    R15,*-6\nFINDAG   OACCALL GETCMDFR\n         MVI   FLGS,FINDFLG       FIND\n         MVC   GQLIST(ALLQL),ALLQ INIT PARM BLOCK\n         B     ENQLP\nFINDPR   LA    R1,FINDPRM         POINT TO INVALID PARM MSG\n         ST    R1,OLD+4           STORE IN OLD\n         OACCALL PRINT\n         BZ    GETCMDAG           IF NO ATTN, ASK AGAIN\n         B     END                IF ATTN, QUIT\n*\nCLEANUP  MVC   FREEML(FREEMLEN),FREEMDC\nFREEAREA FREEMAIN VU,A=AREAA,MF=(E,FREEML),SP=1,RELATED=(GETAREA)\n         SR    R15,R15\n         B     EXIT\n         TITLE 'ENQ - CONSTANTS'\nMEMLOW   DC    X'00008000'        MEM LIMITS FOR GQ AREA\nMEMHIGH  DC    X'7FFFFFFF'\nGETMDC   GETMAIN VC,SP=1,MF=L\nGETMLEN  EQU   *-GETMDC\nFREEMDC  FREEMAIN VU,SP=1,MF=L\nFREEMLEN EQU   *-FREEMDC\nPUTGETDC PUTGET  OUTPUT=(0,,MODE),MF=L\nPUTGTDCL EQU   *-PUTGETDC\nALLQ     GQSCAN REQLIM=MAX,SCOPE=ALL,SYSNAME=0,REQCNT=1,MF=L\nALLQL    EQU   *-ALLQ\nCONQ     GQSCAN REQLIM=MAX,SCOPE=ALL,SYSNAME=0,WAITCNT=1,MF=L\nCONQL    EQU   *-CONQ\nNOMEM    MSG   ' NOT ENOUGH CORE TO PROCESS REQUEST'\nHERALD   MSG   ' ENQ'\nCMDNF    MSG   ' INVALID COMMAND'\nFINDPRM  MSG   ' INVALID PARAMETER'\nMOREM    MSG   ' (*MORE*)'\n         LTORG\n         OACDROP R10\n         TITLE 'ENQ - SUBROUTINES'\n*\n*        SUBROUTINE TO PARSE AND  UPPERCASE NEXT TOKEN FROM INPUT LINE\n*\n*     ON ENTRY ASSUMES:\n*        CURIN POINTS TO FIRST CHAR OF TEXT\n*        CUREND POINTS PAST END OF TEXT\n*\n*     ON RETURN:\n*        R1 POINTS TO FIRST CHAR OF TOKEN\n*        R15 CONTAINS LENGTH OF TOKEN\n*        CURIN POINTS TO NEXT POSITION IN INPUT STRING\n*\nGETTOKEN OACSUB\n         L     R6,CURIN           POINT TO CURRENT POS\n         L     R7,CUREND          POINT PAST END OF STRING\n         SR    R15,R15            ASSUME ZERO LENGTH TOKEN\n         CR    R6,R7              SEE IF AT END OF TEXT\n         BNL   GETTR1             IF SO RETURN WITH EMPTY TOKEN\n*\n*        FIND  FIRST NON BLANK, OR COMMA\n*\nGETT1    OI    0(R6),C' '         UPPERCASE THE CHARACTER\n         CLI   0(R6),C' '         SEE IF BLANK\n         BNE   GETT2              BRANCH IF NOT\n         LA    R6,1(R6)           POINT TO NEXT CHAR\n         CR    R6,R7              SEE IF OFF END OF TEXT\n         BL    GETT1              IF NOT OFF END CONTINUE\n         B     GETTR1             IF OFF END RETURN EMPTY TOKEN\nGETT2    CLI   0(R6),C','         IS IT A COMMA\n         BNE   GETT3              IF NOT THEN START OF TOKEN\n         B     GETTR              AND RETURN EMPTY TOKEN\n*\n*        NEXT  BLANK OR COMMA DELIMITS TOKEN\n*\nGETT3    LR    R1,R6              SAVE START OF TOKEN\nGETT4    OI    0(R6),C' '         UPPERCASE THE CHARACTER\n         CLI   0(R6),C' '         FIND NEXT BLANK\n         BE    GETTR              END OF TOKEN\n         CLI   0(R6),C','         COMMA IS ALSO A DELIMITER\n         BE    GETTR              END OF TOKEN\n         LA    R15,1(R15)         COUNT THIS CHAR\n         LA    R6,1(R6)           BUMP POINTER\n         CR    R6,R7              SEE IF OFF END OF TEXT\n         BL    GETT4              IF NOT, CONTINUE SCAN\nGETTR    LA    R6,1(R6)           POINT TO NEXT CHAR\nGETTR1   ST    R6,CURIN           SAVE NEW CURRENT POSSITION\n         OACRET RC=(R15)\n         LTORG\n         OACDROP R10\n         EJECT\n*\n*        SUBROUTINE TO FREE INPUT BUFFER FROM PUTGET\n*        ASSUMES ADDR IN R9, LENGTH IN R8\n*\nGETCMDFR OACSUB\n         L     R9,GETADDR         POINT TO AREA TO BE FREED\n         L     R8,GETLEN          GET LENGTH OF AREA TO BE FREED\n         FREEMAIN R,A=(R9),LV=(R8),SP=1\n         OACRET\n         LTORG\n         OACDROP R10\n         EJECT\nSCAN     OACSUB\n         XC    TOKEN(4),TOKEN     ZERO TOKEN\n         LM    R2,R3,AREAA        GET AREA ADDR AND LENGTH\n         GQSCAN AREA=((R2),(R3)),TOKEN=TOKEN,MF=(E,GQLIST)\n         ST    R15,GQRC           SAVE THE RC\n         CH    R15,=H'4'          EMPTY\n         BE    SCANRT             IF SO RETURN\n         CH    R15,=H'12'         ERROR\n         BL    SCAN1\n         EX    R0,*               SHOULD NEVER HAPPEN\nSCAN1    ST    R0,RIBL            SAVE LENGTHS OF RIB AND RIBE\n         ST    R1,NRIBS           SAVE # RIBS THIS AREA\n         SR    R15,R15\nSCANRT   OACRET RC=(R15)\n         LTORG\n         OACDROP R10\n         EJECT\n*\n*        CALL  TO GET NEXT CHUNK  OF DATA FROM GQSCAN\n*\nRESCAN   OACSUB\n         GQSCAN MF=(E,GQLIST)\nSCANCHK  ST    R15,GQRC           SAVE THE RC\n         CH    R15,=H'4'          EMPTY\n         BE    RESCANRT           IF SO RETURN\n         CH    R15,=H'12'         ERROR\n         BL    RESCAN1\n         EX    R0,*               SHOULD NEVER HAPPEN\nRESCAN1  ST    R0,RIBL            SAVE LENGTHS OF RIB AND RIBE\n         ST    R1,NRIBS           SAVE # RIBS THIS AREA\n         SR    R15,R15\nRESCANRT OACRET RC=(R15)\n         LTORG\n         OACDROP R10\n         EJECT\n*\n*        CHECK  TO SEE IF FIND IS  IN EFFECT\n*        IF NOT RETURN RC=0\n*\n*        IF SO CHECK THAT SPECIFIED INITIAL PORTIONS OF\n*        QNAME RNAME AND JOBNAME  MATCH\n*        RETURN ZERO IF SO, NONZERO IF NOT\n*\nFINDCHK  OACSUB\n         TM    FLGS,FINDFLG       IS FIND APPROPRIATE\n         BNO   FINDC00            NO, EVERYTHING IS FOUND\n         SR    R1,R1              CLEAR R1\n         ICM   R1,3,QNL           GET QNAME LENGTH\n         BZ    FINDC1\n         BCTR  R1,0               DECREMENT FOR EXECUTE\n         CLC   RIBQNAME(1),QNAME  < EXECUTED >\n         EX    R1,*-6\n         BNE   FINDNZ\nFINDC1   ICM   R1,3,JNL           GET JOBNAME LENGTH\n         BZ    FINDC2\n         BCTR  R1,0               DECREMENT FOR EXECUTE\n         CLC   RIBEJBNM(1),JNAME  < EXECUTED >\n         EX    R1,*-6\n         BNE   FINDNZ\nFINDC2   ICM   R1,3,RNL           GET RNAME LENGTH\n         BZ    FINDC00\n         BCTR  R1,0               DECREMENT FOR EXECUTE\n         LR    R15,R9             COPY RIB ADDR\n         AH    R15,RIBL           POINT TO VARIABLE PORTION\n         CLC   0(1,R15),RNAME     < EXECUTED >\n         EX    R1,*-6\n         BNE   FINDNZ\nFINDC00  SR    R15,R15\nFINDNZ   DS    0H                 R15 CONTAINS BASE AND IS NON-ZERO\nFINDRET  OACRET RC=(R15)\n         LTORG\n         OACDROP R10\n         EJECT\n*\n*        FORMAT THE REQUESTOR SPECIFIC INFO FROM THE RIB AND RIBE\n*\nFMTRIBE  OACSUB\n         MVI   PRTBUFF,C' '       START WITH A BLANK\n         MVI   PRTBUFF+1,C'J'     ASSUME SCOPE OF STEP\n         TM    RIBSCOPE,RIBSTEP   SEE IF NOT STEP\n         BO    FMTRIBE1\n         MVI   PRTBUFF+1,C'S'     IF NOT, ASSUME SYSTEM\nFMTRIBE1 MVI   PRTBUFF+2,C'S'     ASSUME SHARED\n         TM    RIBERFLG,RIBETYPE  SEE IF SHARED\n         BO    FMTRIBE2\n         MVI   PRTBUFF+2,C'E'     IF NOT, ITS EXCLUSIVE\nFMTRIBE2 MVI   PRTBUFF+3,C'G'     ASSUME OWNES THE RESOURCE\n         TM    RIBESFLG,RIBESTAT  SEE IF OWNES\n         BO    FMTRIBE3\n         MVI   PRTBUFF+3,C'W'     IF NOT, ITS WAITING\nFMTRIBE3 MVI   PRTBUFF+4,C'R'     ASSUME RESERVE\n         TM    RIBERFLG,RIBERESV                 CBT-AXC\n         BO    FMTRIBE4\n         MVI   PRTBUFF+4,C' '     IF NOT, LEAVE BLANK\nFMTRIBE4 MVI   PRTBUFF+5,C'M'     ASSUME MUST COMPLETE\n         TM    RIBERFLG,RIBEMC                   CBT-AXC\n         BO    FMTRIBE5\n         MVI   PRTBUFF+5,C' '     IF NOT, LEAVE BLANK\nFMTRIBE5 MVI   PRTBUFF+6,C' '     BLANK\n         MVC   PRTBUFF+7(8),RIBEJBNM COPY JOBNAME\n         MVC   PRTLEN(2),=H'19'   ASSUME NO VOL,UCB - LEN=15+4\n         TM    RIBERFLG,RIBERESV  TEST FOR RESERVE    CBT-AXC\n         BNO   FMTRIBE6\n         MVI   PRTBUFF+15,C' '\n         MVC   PRTLEN(2),=H'31'   LEN = 27+4\n         L     R2,RIBEUCB         GET UCB ADDRESS\n         MVC   PRTBUFF+16(6),UCBVOLI-UCBOB(R2)\n         MVI   PRTBUFF+22,C'-'\n         SLL   R2,4               SHIFT UCB ADDRESS LEFT 2\n         ST    R2,PARMLSTS        STORE IN WORK AREA\n         OI    PARMLSTS+3,X'0F'   OR IN SIGN\n         UNPK  PRTBUFF+23(4),PARMLSTS+1(3) UNPACK\n         L     R1,=A(FMTTRTBL)    BECAUSE OF ADDRESSABILITY\n         TR    PRTBUFF+23(4),0(R1) CONVERT TO CHARACTER\nFMTRIBE6 LA    R1,PRTLEN          POINT TO THE SEGMENT\n         ST    R1,OLD+4           STORE IN OLD\n         OACRET\nFMTTRTBL EQU   *-X'F0'\n         DC    C'0123456789ABCDEF' TRANSLATE TABLE\n         LTORG\n         OACDROP R10\n         EJECT\n*\n*        FORMAT THE RESOURCE SPECIFIC INFO FROM THE RIB\n*\n*        ALTHOUGH THIS SUBROUTINE IS CALLED FOR EACH RIBE,\n*        IT ONLY ADDS STUFF TO THE PRINT BUFFER ONCE FOR EACH\n*        RIB.  IT ASSUMES THAT FMTRIBE HAS ALREADY BEEN CALLED\n*\nFMTRIB   OACSUB\n         TM    FLGS,CONTFLG       SEE IF RIB ALREADY FORMATTED\n         BO    FMTRIB00\n         OI    FLGS,CONTFLG       MARK RIB AS FORMATTED\n         LA    R1,PRTLEN          POINT TO OUTPUT BUFFER\n         ST    R1,OLD+4           POINT OLD TO PRINT BUFFER\n         LH    R2,PRTLEN          GET LENGTH\n         LA    R1,0(R1,R2)        POINT PAST END OF BUFFER\n         MVI   0(R1),C' '         MOVE IN QNAME\n         MVC   1(8,R1),RIBQNAME\n         MVI   9(R1),C' '\n         AH    R2,=H'10'          ADDJUST LENGTH\n         SR    R3,R3              CLEAR R3\n         ICM   R3,1,RIBRNMLN      GET RNAME LENGTH\n         BNZ   FMTRIB1\n         STH   R2,PRTLEN          SAVE NEW LENGTH\n         B     FMTRIB00\nFMTRIB1  AR    R2,R3              ADD RNAME LENGTH TO PRINT LENGTH\n         STH   R2,PRTLEN          SAVE NEW LENGTH\n         LR    R4,R9              COPY RIB ADDR\n         AH    R4,RIBL            POINT TO VARIABLE PORTION\n         BCTR  R3,0               DECREMENT FOR EXECUTE\n         MVC   10(1,R1),0(R4)     < EXECUTED >\n         EX    R3,*-6             MOVE IN RNAME\nFMTRIB00 OACRET\nPRTSPACE MSG   '  '\n         LTORG\n         OACDROP R10\n         EJECT\n*\n*        PUTLINE SUBROUTINE, ASSUMES OLD POINTS TO SEGMENT TO BE\n*         PRINTED. RETURNS NON ZERO IF ATTENTION SIGNALLED\n*\nPRINT    OACSUB\n         XC    TSOECB(4),TSOECB\n         MVC   PUTLL(PUTLDCL),PUTLDC\n         PUTLINE PARM=PUTLL,OUTPUT=OLD,MF=(E,IOPLL)\n         LTR   R15,R15\n         BZ    PRINTRET\n         CH    R15,4              ATTENTION?\n         BE    PRINTNZ            IF SO RETURN NON ZERO RC\n         CH    R15,20             TERMINAL DISCONNECTED?\n         BE    PRINTRET           IGNORE IT\n         CH    R15,12             SEVERE ERROR\n         BL    PRINTRET           IGNORE ALL OTHERS\n         EX    R0,*               SHOULD NEVER HAPPEN\nPRINTRET SR    R15,R15            ZERO RETURN CODE\nPRINTNZ  OACRET  RC=(R15)\nPUTLDC   PUTLINE MF=L\nPUTLDCL  EQU   *-PUTLDC\n         LTORG\n         OACDROP R10\n         TITLE 'ENQ - DSECTS'\n         IKJCPPL\n         IKJIOPL\nUCB      DSECT\n         IEFUCBOB\n         EJECT\n         ISGRIB\n         END\n//*\n//C   EXEC PGM=COMPARE,\n//  PARM='GO,ENQ'\n//STEPLIB  DD DISP=SHR,DSN=SYS5.MSSLOAD\n//SYSPRINT DD SYSOUT=*\n//I1       DD DISP=(SHR,PASS),DSN=&&GOSET\n//I2       DD DISP=SHR,DSN=SYS1.OACLINK\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ESDXREF": {"ttr": 4612, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x07<\\x07<\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 1852, "newlines": 1852, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMASA JOB CSYSJCJ,MSGCLASS=J,NOTIFY=CSYSJCJ,COND=(0,NE)\n/*JOBPARM ROOM=9917,TIME=999,LINES=999\n// EXEC ASMHCL,PARM.ASM=BATCH,PARM.LKED='XREF,LET,LIST'\n//ASM.SYSLIB DD\n//           DD\n//           DD DISP=SHR,DSN=SYS5.MSSMAC\n//ASM.SYSIN  DD *\n         MACRO\n&NAME    MSG   &TEXT,&HAVELEN,&TYPE=CALL,&BALREG=,&MAXLEN=,&BALNAME=,  #\n               &MSGNAME=,&DDNAME=,&RECFM=,&DCBNAME=,&FACTOR=\n.*\n.*********************************************************************.\n.*                                                                   *.\n.*  GENERATE OR FIND A MESSAGE, AND PRINT IT OUT.  SUPPLIES BAL      *.\n.*  ROUTINE NECESSARY, AND MESSAGES.                                 *.\n.*                                                                   *.\n.*  TEXT            MSG TEXT - EITHER 'XXX' THE ACTUAL TEXT, OR      *.\n.*                  XXX, THE ADDRESS OF THE TEXT (WITH DC CLNN       *.\n.*                  IMPLICIT LENGTH)                                 *.\n.*  HAVELEN         (RECFM=V ONLY).  IF 'HAVE', RDW ASSUMED TO BE    *.\n.*                  ACCURATE.  IF OMMITTED, RDW FILLED IN BY         *.\n.*                  BACKSCAN FOR NON-BLANK.                          *.\n.*  TYPE            TYPE OF CALL:                                    *.\n.*                       CALL...GENERATE (OR FIND) TEXT AND LENGTH,  *.\n.*                              AND LINK TO PRINT ROUTINE (DEFAULT). *.\n.*                       DCB....GENERATE THE MESSAGE DCB             *.\n.*                       OPEN...OPEN THE PRINT FILE                  *.\n.*                       CLOSE..CLOSE THE PRINT FILE                 *.\n.*                       SET....VIEW GLOBALS                         *.\n.*                       GEN....GENERATE THE PRINT BAL ROUTINE.      *.\n.*                       TEXT...GENERATE THE MESSAGE WITH THE LENGTH *.\n.*                              IN FRONT, FOR THE BAL ROUTINE.       *.\n.*  BALREG          BAL AND RETURN REGISTER (DEFAULT = R10)          *.\n.*  MAXLEN          THE MAXIMUM SIZE OF THE MESSAGE (SIZE OF         *.\n.*                  THE BUFFER).  DEFAULT IS 133 BYTES.              *.\n.*  BALNAME         NAME OF THE BAL ROUTINE TO BE GENERATED.         *.\n.*                  DEFAULT IS 'MSG'.                                *.\n.*  MSGNAME         NAME OF THE MESSAGE BUFFER.  DEFAULT IS          *.\n.*                  'MSGBUF'                                         *.\n.*  DDNAME          DD NAME FOR THE MESSAGE FILE.  DEFAULT SYSPRINT  *.\n.*  RECFM           RECORD FORMAT.  DEFAULT FBA                      *.\n.*  FACTOR          BLOCKING FACTOR (FULLTRK OR HALFTRK).            *.\n.*  DCBNAME         NAME OF DCB      (DEFAULT MSGDCB)                *.\n.*                                                                   *.\n.*  VIC TOLOMEI - 4/74                                               *.\n.*                                                                   *.\n.*  UPDATES     - 6/77                                               *.\n.*                                                                   *.\n.*                                                                   *.\n.*********************************************************************.\n         GBLA  &GLKSIZE,&GAXLEN,&GAXEX,&NUMBER,&GRECL\n         GBLB  &MSGGLOB,&MSGSET     WHETHER GLOBS HAVE BEEN SET ETC\n         GBLC  &GBREG,&GMNAME,&GBNAME,&GBNAME#,&GBNAME$,&GBN,&GBNAME@\n         GBLC  &GDNAME,&GECFM,&GCBNAME,&GACTOR\n         LCLA  &LEN,&LIM,&COUNT\n         LCLC  &LABBO,&LENLEN,&TEMP1,&TEMP2,&TEMP3\n         AIF   (&MSGGLOB).NORESET       NO INIT GLOBALS\n&GBREG   SETC  'R10'\n&GBNAME  SETC  'MSG'\n&GBN     SETC  'MSG'\n&GBNAME# SETC  '&GBN'.'#'\n&GBNAME$ SETC  '&GBN'.'$'\n&GBNAME@ SETC  '&GBN'.'@'\n&GMNAME  SETC  'MSGBUF'\n&GDNAME  SETC  'SYSPRINT'\n&GECFM   SETC  'FBA'\n&GACTOR  SETC  'FULLTRK'\n&GAXLEN  SETA  133\n&GAXEX   SETA  &GAXLEN-1\n&GRECL   SETA  &GAXLEN                  ASSUME 'F'\n&GCBNAME SETC  'MSGDCB'\n&NUMBER  SETA  0\n.*\n.*  PROCESS PARMS\n.*\n.NORESET AIF   ('&BALREG' EQ '').NOREG\n&GBREG   SETC  '&BALREG'\n.NOREG   AIF   ('&BALNAME' EQ '').NONAME\n&GBNAME  SETC  '&BALNAME'\n&GBN     SETC  '&BALNAME'(1,3)\n&GBNAME# SETC  '&GBN'.'#'\n&GBNAME$ SETC  '&GBN'.'$'\n&GBNAME@ SETC  '&GBN'.'@'\n.NONAME  AIF   ('&MSGNAME' EQ '').NOMSG\n&GMNAME  SETC  '&MSGNAME'\n.NOMSG   AIF   ('&DDNAME' EQ '').NODDNA\n&GDNAME  SETC  '&DDNAME'\n.NODDNA  AIF   ('&RECFM' EQ '').NORECF\n&GECFM   SETC  '&RECFM'\n         AIF   (('&GECFM'(1,1) EQ 'F' OR '&GECFM'(1,1) EQ 'V') AND K'&G#\n               ECFM LE 3).NORECF        ITS OK\n         MNOTE 8,'INVALID RECFM - &GECFM'\n         MEXIT\n.NORECF  AIF   ('&DCBNAME' EQ '').NODCBN\n&GCBNAME SETC  '&DCBNAME'\n.NODCBN  AIF   ('&FACTOR' EQ '').NOFACT\n&GACTOR  SETC  '&FACTOR'\n.NOFACT  AIF   ('&MAXLEN'  EQ '').NOMAXL\n&GAXLEN  SETA  &MAXLEN\n&GAXEX   SETA  &GAXLEN-1\n&GRECL   SETA  &GAXLEN                  ASSUME 'F'\n.NOMAXL  AIF   ('&GECFM'(1,1) EQ 'F').NOMAXL2  OK\n&GRECL   SETA  &GAXLEN+4                RECFM=V\n.NOMAXL2 ANOP\n&GLKSIZE SETA  7294                     ASSUME FULLTRK\n         AIF   ('&GACTOR' EQ 'FULLTRK').FULL    RIGHT\n         AIF   ('&GACTOR' EQ 'HALFTRK').HALF       NO\n         AIF   ('&GACTOR' EQ 'UNBLKED').UNBL       NO BLOCKING\n         MNOTE 8,'INVALID BLOCKING FACTOR --- &GACTOR'\n         MEXIT\n.HALF    ANOP\n&GLKSIZE SETA  3520                     HALFTRK NOW\n         AGO   .FULL                    GET BLKSIZE NOW\n.UNBL    ANOP\n&GLKSIZE SETA  &GRECL                   UNBLOCKED, BLKSIZE=LRECL\n.FULL    ANOP\n&GLKSIZE SETA  (&GLKSIZE/&GRECL)*&GRECL   GET DCB=BLKSIZE MAYBE\n         AIF   ('&GECFM'(1,1) EQ 'F').BLKTRK OK, RECFM=F\n&GLKSIZE SETA &GLKSIZE+4                RECFM=V, BDW\n         AIF   (&GLKSIZE LE 7294).BLKTRK FIT ON TRACK\n&GLKSIZE SETA  &GLKSIZE-&GRECL          NO FIT, BACK UP 1 REC\n.BLKTRK  ANOP\n&MSGGLOB SETB  1                        NO MORE RESETTING\n         AIF   (('&TYPE' EQ 'TEXT') OR ('&TYPE' EQ 'DCB')).NONAME$\n         AIF   ('&NAME' EQ '').NONAME#\n&NAME    DS    0H\n.NONAME# AIF   ('&TYPE' EQ 'SET').SET   JUST SET AND VIEW\n.NONAME$ AIF   (&MSGSET).NOSET\n.SET     ANOP\n&MSGSET  SETB  1                        NO MORE DEFAULT VIEWING\n.*********************************************************************.\n.*  TYPE=SET (OR FIRST ENTRY)                                        *.\n.*********************************************************************.\n         SPACE 1\n         MNOTE *,'MSG MACRO GLOBAL PARAMETERS'\n         MNOTE *,'  *** BAL REG ----- &GBREG'\n         MNOTE *,'  *** BUFFER LEN -- &GAXLEN'\n         AIF   ('&GECFM'(1,1) EQ 'F').FNAMES\n         MNOTE *,'  *** BAL NAMES --- &GBNAME, &GBNAME#, &GBNAME$, &GBN#\n               AME@'\n         AGO   .GOON@\n.FNAMES  MNOTE *,'  *** BAL NAMES --- &GBNAME, &GBNAME#, &GBNAME$'\n.GOON@   MNOTE *,'  *** BUFFER NAME - &GMNAME'\n         MNOTE *,'MSG MACRO DCB PARAMETERS'\n         MNOTE *,'  *** DCBNAME ----- &GCBNAME'\n         MNOTE *,'  *** DDNAME ------ &GDNAME'\n         MNOTE *,'  *** RECFM ------- &GECFM'\n         MNOTE *,'  *** LRECL ------- &GRECL'\n         MNOTE *,'  *** BLKSIZE ----- &GLKSIZE'\n         MNOTE *,'  *** BLOCKING ---- &GACTOR'\n         SPACE 1\n.*\n.NOSET   AIF   ('&TYPE' EQ 'SET').MEND\n         AIF   ('&TYPE' EQ 'GEN').GEN\n         AIF   ('&TYPE' EQ 'DCB').DCB\n         AIF   ('&TYPE' EQ 'OPEN').OPEN\n         AIF   ('&TYPE' EQ 'CLOSE').CLOSE\n         AIF   ('&TYPE' EQ 'CALL'  OR  '&TYPE' EQ 'TEXT').OKTYPE\n         MNOTE 8,'INVALID MSG TYPE, &TYPE'\n         MEXIT\n.OKTYPE  AIF   ('&TYPE' NE 'CALL').GOON#\n         AIF   (('&TEXT' NE '') AND ('&TEXT' NE '&GMNAME')).GOON#\n         AIF   ('&HAVELEN' NE '' AND '&GECFM' EQ 'F').BADHAVE\n         AIF   ('&GECFM'(1,1) EQ 'F').NORMBAL\n         AIF   ('&HAVELEN' EQ '').VBAL\n.CHKH    AIF   ('&HAVELEN'(1,1) EQ 'H').NORMBAL\n.BADHAVE MNOTE 8,'INVALID LENGTH INDICATOR - &HAVELEN'\n         MEXIT\n.VBAL    BAL   &GBREG,&GBNAME@\n         MEXIT\n.NORMBAL BAL   &GBREG,&GBNAME#\n         MEXIT\n.GOON#   ANOP\n         AIF   (('&TYPE' EQ 'CALL') AND ('&TEXT'(1,1) NE '''')).CALLBAL\n         AIF   (('&TYPE' EQ 'TEXT') AND ('&TEXT'(1,1) NE '''')).BADTT\n&LEN     SETA  K'&TEXT-2                TRIAL LENGTH OF TEXT = COUNT\n&LIM     SETA  &LEN                     MAXIMUM LENGTH = MAX(&COUNT)\n&COUNT   SETA  2                        OFFSET INTO TEXT\n.*  ALLOW FOR DOUBLE QUOTES\n.LOOP    AIF   (&COUNT GT &LIM).OUT\n         AIF   ('&TEXT'(&COUNT,1) NE '''').GOON  NO QUOTE YET\n&LEN     SETA  &LEN-1                   DECREMENT 'REMAINING' COUNTER\n&COUNT   SETA  &COUNT+1                 INCREMENT POINTER FOR 1 QUOTE\n.GOON    ANOP\n&COUNT   SETA  &COUNT+1                 INCREMENT POINTER FOR THIS BYTE\n         AGO   .LOOP                    GO TILL DONE WITH ALL TEXT\n.OUT     ANOP                           ALL DONE\n&LEN     SETA  &LEN-1                   EXECUTE LENGTH\n         AIF   (&LEN LE &GAXEX).OKLEN   THE LENGTH IS OK\n&COUNT   SETA  &LEN+1                   BACK TO REAL LENGTH (SCRATCH)\n         MNOTE 8,'TEXT LENGTH (&COUNT) IS GREATER THAN MAX (&GAXLEN)'\n         MEXIT\n.OKLEN   AIF   ('&TYPE' EQ 'TEXT').TEXT# TYPE=TEXT\n.*********************************************************************.\n.*  TYPE=CALL ... CALL THE BAL ROUTINE WITH THE CORRECT MSG          *.\n.*********************************************************************.\n         AIF   ('&TEXT'(1,1) NE '''').CALLBAL\n         LA    R15,=C&TEXT\n         AIF   (&LEN NE 0).LA\n         XR    R1,R1\n         AGO   .BALL\n.LA      LA    R1,&LEN\n.BALL    BAL   &GBREG,&GBNAME$\n         MEXIT\n.CALLBAL ANOP\n         AIF   ('&TEXT'(1,1) NE '(').NOTREG\n         AIF   (('&TEXT(1)' EQ '15') OR ('&TEXT(1)' EQ 'R15')).BALBAL\n         LR    R15,&TEXT\n         AGO   .BALBAL                  AND PRINT\n.NOTREG  LA    R15,&TEXT\n.BALBAL  BAL   &GBREG,&GBNAME\n         MEXIT\n.*********************************************************************.\n.*  TYPE=DCB  ... GEN THE DCB                                        *.\n.*********************************************************************.\n.DCB     ANOP\n         SPACE 1\n*DCBNAME DCB   DDNAME=DDNAME,MACRF=PM,RECFM=RECFM,LRECL=LRECL\n*              BLKSIZE=BLKSIZE,DSORG=PS\n         SPACE 1\n&GCBNAME DCB   DDNAME=&GDNAME,MACRF=PM,RECFM=&GECFM,LRECL=&GRECL,      #\n               BLKSIZE=&GLKSIZE,DSORG=PS\n         MEXIT\n.*******************************************************************.\n.*  TYPE=OPEN                                                        *.\n.********************************************************************.\n.OPEN    ANOP\n*        OPEN  (DCB,OUTPUT)             OPEN THE PRINT FILE\n         OPEN  (&GCBNAME,OUTPUT)\n         TM    &GCBNAME+48,X'10'\n&NUMBER  SETA  &NUMBER+1\n&LABBO   SETC  '&NUMBER'(1,2)\n&LABBO   SETC  '&GBNAME$'.'&LABBO'\n         BO    &LABBO\n*        ABEND 1100 NO, ABEND NOW\n         LA    R1,1100\n*        ABEND (1)\n         ABEND (1)\n&LABBO   DS    0H\n         MEXIT\n.*********************************************************************.\n.*  TYPE=CLOSE                                                       *.\n.*********************************************************************.\n.CLOSE   ANOP\n         SPACE 1\n*        CLOSE DCBNAME CLOSE THE OUTPUT FILE\n         CLOSE &GCBNAME\n         MEXIT\n.*********************************************************************.\n.*  TYPE=TEXT ... MAKE THE MSG                                       *.\n.*********************************************************************.\n.TEXT#   ANOP\n         AIF   ('&NAME' NE '').OKTEXTN  NEED NAME\n         MNOTE 8,'NAME FIELD REQ WITH TYPE=TEXT'\n         MEXIT\n.OKTEXTN DC    AL1(&LEN)\n&NAME    DC    C&TEXT\n         MEXIT\n.BADTT   MNOTE 8,'WITH TYPE=TEXT, A QUOTED STRING MUST BE SUPPLIED'\n         MEXIT\n.*********************************************************************.\n.*  TYPE=GEN ... GENERATE THE BAL ROUTINE TO PROCESS THE MESSAGES    *.\n.*********************************************************************.\n.GEN     ANOP\n         SPACE 1\n         AIF   ('&GECFM'(1,1) EQ 'V').VBA  RECFM=V NEEDS MORE\n&GBNAME  BCTR  R15,0                    BACK UP TO GET LENGTH\n         IC    R1,0(,R15)               GET EXECUTE LENGTH\n         LA    R15,1(,R15)              FIX THE TEXT PTR\n&GBNAME$ EX    R1,&GBN.MVC              MOVE THE MESSAGE TO BUFFER\n*        PUT   DCB,BUFFER PRINT FIXED LENGTH MESSAGE\n&GBNAME# PUT   &GCBNAME,&GMNAME         PRINT THE MESSAGE\n         MVI   &GMNAME,C' '             CLEAR OUT THE MESSAGE BUFFER\n         MVC   &GMNAME+1(&GAXEX),&GMNAME\n         BR    &GBREG                   RETURN TO CALLER\n         SPACE 1\n&GBN.MVC MVC   &GMNAME.(0),0(R15)       <<< EXECUTED >>>\n         SPACE 1\n&GMNAME  DC    CL&GAXLEN' '             MESSAGE BUFFER\n.LENLEN# ANOP                           FROM V\n&LENLEN  SETC  '&GMNAME'(1,4)\n&LENLEN  SETC  '&LENLEN'.'L'\n&LENLEN  EQU   &GAXLEN                  LENGTH OF MSG BUFFER\n         MEXIT\n.*\n.*  RECFM=V, WORRY ABOUT RDW\n.*\n.VBA     ANOP\n&GBNAME  BCTR  R15,0                    BACK UP TO GET LENGTH\n         XR    R1,R1                    FOR IC\n         IC    R1,0(,R15)               GET EXECUTE LENGTH\n         LA    R15,1(,R15)              FIX THE TEXT PTR\n&GBNAME$ EX    R1,&GBN.MVC              MOVE THE MESSAGE TO BUFFER\n&GBN.LEN LA    R1,1+4(,R1)              RECFM=V, MAKE RDW ACTUAL LENGTH\n         STH   R1,&GBN.RDW              SAVE LENGTH IN RDW\n*        PUT   DCB,BUFFER PRINT OUT THE RECFM=V MESSAGE\n&GBNAME# PUT   &GCBNAME,&GBN.RDW        PRINT THE RECFM=V MESSAGE\n         MVI   &GMNAME,C' '             CLEAR OUT THE MESSAGE BUFFER\n         MVC   &GMNAME+1(&GAXEX),&GMNAME\n         BR    &GBREG                   RETURN TO CALLER\n         SPACE 1\n&GBNAME@ LA    R1,&GMNAME+&GAXEX-1      POINT TO END OF BUFFER\n         LA    R0,&GMNAME+2             WHERE TO STOP\n&GBN.LP  CR    R0,R1                    STOP LOOKING YET?\n         BE    &GBN.GOT                 YES, WE ARE DONE\n         CLI   0(R1),C' '               NON-BLANK HERE?\n         BNE   &GBN.GOT                 YES, WE HAVE LENGTH\n         BCT   R1,&GBN.LP               FIND END OF BUFFER\n         SPACE 1\n&GBN.GOT LA    R0,&GMNAME               POINT TO BUFFER\n         SR    R1,R0                    GET LENGTH OF RECFM V LINE\n         B     &GBN.LEN                 AND SAVE IT\n         SPACE 1\n&GBN.MVC MVC   &GMNAME.(0),0(R15)       <<< EXECUTED >>>\n         SPACE 1\n&GBN.RDW DC    0F'0',AL2(0),AL2(0)      RDW FOR RECFM=V\n&GMNAME  DC    CL&GAXLEN' '             MESSAGE BUFFER\n&LENLEN  SETC  '&GMNAME'(1,4)\n&LENLEN  SETC  '&LENLEN'.'L'\n&LENLEN  EQU   &GAXLEN                  LENGTH OF MSG BUFFER\n.MEND    MEND\nESDX TITLE 'E S D X R E F  --  FORM CROSS REFERENCE OF EXTERNAL NAMES'\n*\n*\nESDXREF  CSECT ,\n*\n*\n*  ESDXREF\n*\n*\n*\n*  VIC TOLOMEI      9/77       CCN\n*\n*\n*  GO THROUGH EVERY ESD OF ALL LOAD MODULES IN LIBRARY (LIBRARIES)\n*  FROM ANY DD AND FORM A CROSS-REFERENCE OF ALL EXTERNAL SYMBOLS\n*  BY MODULE NAME.\n*\n*  THIS ROUTINE USES SUBROUTINE \"ESDREAD\" TO READ IN ENTIRE TABLE\n*  OF ESD'S FOR THE LIBRARY (LIBRARIES) ON ALL DD'S FOUND.\n*\n*  TABLE ENTRIES RETURNED ARE OF THE FORM:\n*\n*        CL8'AN_EXTERNAL_NAME_IN_THAT_MODULE',CL8'MODULE_NAME'\n*\n*\n*  THE TABLE IS BUBBLE-SORTED, AND THE CROSS REFERENCE IS PRINTED\n*  ON A PAGE OF SIZE (LINES):\n*\nPAGESIZE EQU   60\n*\n*\n*  NOTE: THE TABLE IS PRINTED IN TWO WAYS -\n*        1) SORTED BY ESD NAME\n*        2) SORTED BY MODULE NAME (SIMILAR IN CONCEPT TO THE OUTPUT\n*           FROM IMBMDMAP)\n*\n*\n*  THE MAXIMUM NUMBER OF LIBRARY DD'S ALLOWED IN ONE RUN IS:\n*\nDDMAX    EQU   20\n*\n         TITLE 'E S D X R E F  --  INITIALIZE'\n*\n*  ESDXREF\n*\n         SPACE 2\nESDXREF  CSECT\n         SAVE  (14,12),,*               SAVE CALLER'S REGS\n         LR    R12,R15                  SET BASE REG\n         OACUSING ESDXREF,R12           TELL THE WORLD\n         LA    R15,SAVEAREA             POINT TO OUR SAVEAREA\n         ST    R15,8(,R13)              LSA TO HIS\n         ST    R13,4(,R15)              HSA TO MINE\n         LR    R13,R15                  SET SAVEAREA PNTR\n         OPEN  (MSGDCB,OUTPUT)          OPEN PRINT FILE\n         TM    MSGDCB+48,X'10'          OPEN?\n         LA    R1,100                   ABEND CODE IN CASE\n         BO    *+6                      BIF OPEN\n         SVC   13                       ELSE ABEND\n         SPACE 3\n*\n*  REGISTER USAGE:\n*\n         SPACE 1\nRTABE    EQU   R11                      TABLE ADDRESS       (BXLE)\nRTABI    EQU   R10                      TABLE ENTRY LENGTH  (BXLE)\nRTAB     EQU   R9                       TABLE END           (BXLE)\nRBAL     EQU   R8                       BAL REG\nRLEN     EQU   R8                       TABLE ENTRY LEN     (SORT TEMP)\nRTABE$   EQU   R7                       TABLE ADDRESS       (SORT ONLY)\nRTABI$   EQU   R6                       TABLE ENTRY LENGTH  (SORT ONLY)\nRTAB$    EQU   R5                       TABLE END           (SORT ONLY)\nRBUF     EQU   R7                       OUTPUT BUFFER PTR   (DUMP ONLY)\nRBUFE    EQU   R6                       OUTPUT BUFFER ENDH  (DUMP ONLY)\nRBALMSG  EQU   R4                       MSG BAL REG\nRPARM    EQU   R3                       RETURN PARM REG FROM ESDREAD\n         SPACE 6\n*\n*  SET UP OUTPUT FILE\n*\n         SPACE 1\n         MSG   TYPE=SET,FACTOR=HALFTRK,RECFM=VBA,BALREG=RBALMSG\n         TITLE 'E S D X R E F  --  BUILD THE DD TABLE'\n*\n*  BUILD THE DD (DSN) TABLE TO PASS TO ESDREAD\n*\n         SPACE 2\n         LA    R15,DDTAB                FIND TABLE\n         OACUSING PARMLIST,R15             TEMP BASE\n         L     R1,16                    GET CVT\n         L     R1,0(,R1)                GET NEW/OLD DISPATCHER DBLW\n         L     R1,4(,R1)                GET OLD = MY TCB\n         L     R1,12(,R1)               GET MY TIOT\n         LA    R14,24                   OFFSET TO NEXT DDNAME\n         SPACE 2\nDDBLOOP  AR    R1,R14                   POINT TO NEXT DDNAME\n         IC    R14,0(,R1)               GET ITS LENGTH\n         LTR   R14,R14                  END OF TIOT?\n         BZ    DDGOT                    YES, WE HAVE A TABLE\n         CLC   4(4,R1),=C'XREF'         XREF DDNAME?\n         BNE   DDBLOOP                  BIF NO - CHECK NEXT DDNAME\n         SPACE 1\n         C     R15,=A(DDTABE)           NO MORE ROOM IN DDNAME TABLE?\n         BE    DDOFLO                   RIGHT, ARG\n         MVC   PARMDD,4(R1)             NO, COPY TIOT DDNAME TO PARMLST\n         LA    R15,PARML(,R15)          NEXT PARMLIST ENTRY\n         B     DDBLOOP                  CONTINUE BUILDING PARMLIST\n         SPACE 2\n         OACDROP R15\n         SPACE 2\n         OACINUSE ,\n         EJECT\n*\n*  BUILD TABLE BY PASSING DDNAMES TO ESDREAD\n*\n         SPACE 2\nDDGOT    LA    R1,DDTAB                 GET PARMLIST\n         SR    R15,R1                   GET LENGTH OF PARMLIST, ANY?\n         BNP   BADDD                    NO, YICH\n         XR    R14,R14                  YES, FOR DIVIDE\n         D     R14,=A(PARML)            GET NUMBER OF PARM ENTRIES\n         STH   R15,DDNUM                SAVE AS LINES TO NOT PRINT\n         SPACE 2\n         L     R15,=V(ESDREAD)          GET ROUTINE NAME\n         BALR  R14,R15                  GO GET/BUILD THE TABLE\n         SPACE 2\n         LR    RPARM,R1                 SAVE RETURN PARM\n         SPACE 2\n         B     *+4(R15)                 WHAT HAPPENED\n         B     GOTTABLE                 0  - OK, SORT THE TABLE\n         B     BADDD                    4  - INVALID DD\n         B     OFLO                     8  - OFLO IN TABLE\n         B     IOERR                    12 - SYNAD\n         B     IOERR                    16 - GETENTRY ERROR\n         B     NOTFOUND                 20 - NOTHING FOUND\n         SPACE 2\nGOTTABLE LA    R0,TABLEENT              GET INCREMENT REG FOR BXLE\n         ST    R0,4(,RPARM)             SINCE NO FREE TAB CLOBBER TOTLN\n         TITLE 'E S D X R E F  --  SORT/PRINT THE TABLE BOTH WAYS'\n*\n*  SORT AND DUMP THE TABLE FIRST BY ESD NAME\n*\n         SPACE 2\n         BAL   RBAL,SORTPRNT            SORT/PRINT THE TABLE BY ESD\n         SPACE 5\n*\n*  REVERSE THE TABLE TO BE RESORTED BY MODULE NAME\n*\n         SPACE 2\n         LM    RTAB,RTABE,0(RPARM)      SET NEW BXLE REGS\n         SPACE 2\n         OACUSING TABLED,RTAB\n         OACINUSE ,\n         SPACE 2\n         SPACE 1\nREVLOOP  LM    R14,R15,TABLEESD         GET ESDNAME\n         LM    R0,R1,TABLEMOD           GET MODNAME\n         STM   R14,R15,TABLEMOD         SWITCH\n         STM   R0,R1,TABLEESD           ...\n         BXLE  RTAB,RTABI,REVLOOP       CONTINUE\n         SPACE 2\n*\n*  FORM AND DUMP THE TABLE FIRST BY MODULE NAME\n*\n         SPACE 2\n         MVI   LINE+1,1                 RESET LINE COUNT TO EJECT PAGE\n         MVC   WHICHOFF(11),=C'MODULE NAME'\n         MVC   ONEOFF,=C'MOD'           SET NEW HDR\n         MVC   TWOOFF,=C'ESD'           SET NEW HDR\n         SPACE 1\n         BAL   RBAL,SORTPRNT            SORT/PRINT THE TABLE BY MOD\n         TITLE 'E S D X R E F  --  EXITS'\n*\n*  EXITS\n*\n         SPACE 2\nDONE     MSG   '-=====   E S D X R E F   PROCESSING COMPLETED   ====='\n         SPACE 2\n******   STOP  CLOSE=MSGDCB,RC=0        BYE BYE, DON'T FREE TABLE\n         CLOSE (MSGDCB)                 CLOSE MSG FILE\n         L     R15,=V(PAR#SORT)         ADDR OF ESDSORT CNTL DATA\n         LM    R0,R1,12(R15)            SIZE/LEN OF POSSIBLE CNTL TABLE\n         LTR   R0,R0                    ANY WORKAREA?\n         BZ    BYEBYE                   BIF NO\n         FREEMAIN R,LV=(0),A=(1)        FREE SORT DATA TABLE\nBYEBYE   L     R13,4(,R13)              CALLER'S SAVEAREA\n         LM    R14,R12,12(R13)          RESTORE CALLER'S REGS\n         XR    R15,R15                  SET RETCODE\n         BR    R14                      RETURN TO CALLER\n         EJECT\n*\n*  ERROR EXITS\n*\n         SPACE 2\nBADDD    MSG   '-****  INVALID OR MISSING DD CARD(S)  ****'\n         B     DONE\n         SPACE 2\nOFLO     MSG   '-****  OVERFLOW IN NAME TABLE, NEED MORE REGION  ****'\n         B     GOTTABLE                 SORT WHAT WE HAVE\n         SPACE 2\nIOERR    MSG   '-****  I/O ERROR IN MEMBERS, OR I/O ERROR IN DIRECTORY #\n                ****'\n         B     DONE\n         SPACE 2\nNOTFOUND MSG   '-****  NO EXTERNAL NAMES FOUND  ****'\n         B     DONE\n         SPACE 2\nDDOFLO   MSG   '-****  TOO MANY DDNAMES SPECIFIED  ****'\n         B     DONE\n         TITLE 'E S D X R E F  --  BAL ROUTINES'\n***********************************************************************\n*                                                                     *\n*  SORTPRNT                                                           *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n*\n*  SORT THE TABLE\n*\n         SPACE 2\nSORTPRNT ST    RBAL,0(,R13)             SAVE BAL REG\n         L     R15,=V(ESDSORT)          ROUTINE EPA\n         L     R1,=V(PAR#SORT)          ROUTINE PARMLIST\n         BALR  R14,R15                  SORT TABLE\n         SPACE 2\n*\n*  PRINT THE TABLE\n*\n         SPACE 2\n         LM    RTAB,RTABE,0(RPARM)      SET TABLE BXLE REGS\n         LA    RBUFE,TEMPBUF+TEMPBL-8   LAST MODNAME SLOT IN TEMP BUF\n         B     DUMPNWST                 SET NEW NAME\n         SPACE 2\nDUMPLOOP CLC   TABLEESD,OLDNAME         IS THIS A NEW NAME NOW?\n         BE    DUMPADMD                 NO, OLD ONE, KEEP ADDING MODS\nDUMPBUF  BAL   RBAL,PRINT               YES, DUMP OLD PENDING BUFFER\nDUMPNWST MVC   TEMPBUF(8),TABLEESD      SET NEW NAME IN BUFFER\nDUMPCNTN LA    RBUF,TEMPBUF+INDENT      INDENT TO 1ST MODULE NAME\nDUMPADMD CR    RBUF,RBUFE               IS THERE ROOM FOR ADDED MOD?\n         BNH   DUMPCNCT                 YES, CONCATENATE ON END BUFFER\n         BAL   RBAL,PRINT               NO, DUMP FULL BUFFER\n         B     DUMPCNTN                 CONTINUE SAME ESD WITH NEW BUF\nDUMPCNCT MVC   OLDNAME,TABLEESD         NOW NAME IS OLD, REMEMBER IT\n         MVC   0(8,RBUF),TABLEMOD       SAVE THIS MODULE NAME\n         LA    RBUF,8+1(RBUF)           NEXT SLOT FOR MODULE\n         BXLE  RTAB,RTABI,DUMPLOOP      CONTINUE\n         SPACE 2\n         BAL   RBAL,PRINT               DUMP LAST BUFFER (MAYBE)\n         L     RBAL,0(,R13)             RESTORE BAL REG\n         BR    RBAL                     RETURN\n         SPACE 2\n         OACDROP RTAB\n         EJECT\n***********************************************************************\n*                                                                     *\n*  PRINT                                                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nPRINT    LH    R0,LINE                  GET LINE NO\n         BCT   R0,PRINTSAM              SAME PAGE\n         LA    R1,1                     GET A 1\n         AH    R1,PAGE                  GET NEW PAGE NO\n         STH   R1,PAGE                  RESET\n         CVD   R1,DBLW                  IN DEC\n         MVC   PAGEOFF,=X'2020202120'   MASK FOR PAGE\n         ED    PAGEOFF-1(6),DBLW+5      GET PAGE TO MSG\n         SPACE 1\n         MSG   PAGEMSG                  EJECT\n         MSG   '0'                      DBL SPACE\n         SPACE 1\n         LA    R2,DDTAB                 GET DD/DSN TABLE\n         OACUSING PARMLIST,R2              TEMP BASE\nPRINTLP  MVC   DSNOFF,PARMDSN           COPY A DSN TO MSG\n         MSG   DSNMSG                   SAY A DSN\n         LA    R2,PARML(,R2)            NEXT ONE\n         CLI   0(R2),0                  DONE?\n         BNE   PRINTLP                  NO, NEXT MSG FOR NEXT DSN\n         SPACE 1\n         OACDROP R2\n         SPACE 1\n         MSG   HDRMSG                   TITLE\n         MSG   UNLNMSG                  UNDERLINE\n         MVI   MSGBUF,C'0'              DOUBLE SPACE FIRST TIME\n         LA    R0,PAGESIZE-7            NEWPAGE, SET CTR (ALLOW HDR)\n         SH    R0,DDNUM                 AND ALLOW DSN'S HEADER\n         MVC   TEMPBUF(8),OLDNAME       NEW PAGE ALWAYS HAS A MODNAME\n         SPACE 1\nPRINTSAM STH   R0,LINE                  SAVE NEW LINE NO\n         MVC   MSGBUF+1(MSGBL-1),TEMPBUF  SET REAL LINE NOW\n         MSG   ,                        PRINT LINE\n         SPACE 1\n         MVC   TEMPBUF(TEMPBL),MSGBUF   BLANK TEMP BUFFER\n         BR    RBAL                     RETURN TO \"PRINT\" CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*  MSG                                                                *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         MSG   TYPE=GEN\n         SPACE 2\n         OACDROP R12\n         TITLE 'E S D X R E F  --  DATA'\n*\n*  DATA\n*\n         SPACE 2\nDBLW     DS    D                        TEMP\nSAVEAREA DC    9D'0'                    PGM SAVEAREA\n         SPACE 2\nLINE     DC    H'1'                     LINE NO (ON LAST, EJECT PAGE)\nPAGE     DC    H'0'                     PAGE NO (NONE YET)\n         SPACE 2\nOLDNAME  DC    CL8' '                   OLD ESD NAME FOR MATCHING\n         SPACE 2\n         PRINT NOGEN\n         MSG   TYPE=DCB\n         SPACE 2\nPAGEMSG  MSG   '1=====   E S D X R E F   =====   UCLA/OAC EXTERNAL NAME#\n                BY MODULE CROSS REFERENCE BY ESD NAME      =====   PAGE#\n                XXXXX   =====',TYPE=TEXT\nWHICHOFF EQU   PAGEMSG+85               OFFSET TO WHICH SORT THIS IS\nPAGEOFF  EQU   PAGEMSG+112,5            OFFSET TO PAGENO\n         SPACE 2\nDSNMSG   MSG   ' LIBRARY SCANNED: 1234567890123456789012345678901234567#\n               8901234',TYPE=TEXT\nDSNOFF   EQU   DSNMSG+18,44             OFFSET TO DSN\n         SPACE 2\nHDRMSG   MSG   '-ESDNAME   MODNAME(S)',TYPE=TEXT\nONEOFF   EQU   HDRMSG+1,3               OFFSET TO TITLE 1\nTWOOFF   EQU   HDRMSG+11,3              OFFSET TO TITLE 1\n         SPACE 2\nUNLNMSG  MSG   '+_______   __________',TYPE=TEXT\n         SPACE 2\nTEMPBL   EQU   MSGBL-1                  LEN TEMP BUFFER, NO CC\nTEMPBUF  DC    (TEMPBL)C' '             TEMP BUILD BUFFER, NO CC\nINDENT   EQU   10                       INDENT AFTER ESD NAME\n         SPACE 2\n         LTORG\n         TITLE 'E S D X R E F  --  DSECTS'\n*\n*  TABLE\n*\n         SPACE 2\nTABLED   DSECT ,                        TABLE ENTRY\nTABLEESD DS    CL8                      ESD FOR THIS MODULE\nTABLEMOD DS    CL8                      MODULE NAME\nTABLEENT EQU   *-TABLED                 LENGTH\nTABLELG2 EQU   4                        LOG 2 OF TABLE ENTRY LENGTH\n         SPACE 5\n*\n*  PARMLIST\n*\n         SPACE 2\nPARMLIST DSECT\nPARMDD   DS    CL8                      DDNAME\nPARMDSN  DS    CL44                     DSNAME\nPARML    EQU   *-PARMLIST               LENGTH ENTRY\n         SPACE 5\n*\n*  ACTUAL PARMLIST ALLOWING DDMAX DDNAMES/DSNAMES\n*\n         SPACE 2\nESDXREF  CSECT\n         SPACE 1\nDDTAB    DC    (DDMAX)XL(PARML)'00'     DDNAME/DSNAME TABLE\nDDTABE   DC    X'00'                    LAST SPOT\n         SPACE 1\nDDNUM    DC    H'0'                     NUMBER DDNAMES FOUND\n         SPACE 2\n         OACREGS ,\n         SPACE 2\n         END\n         MACRO\n&N       GETENTRY &D,&L,&XFER=LINK,&MF=I\n.*\n.*  D - DDNAME (ADDR, REG, 'DDNAME')\n.*  L - LIST (H'LEN',XL(LEN)) OR IF OMITTED LOCATE FORM ASSUMED\n.*      (ENTRY ADDRESS RETURNED IN R1)\n.*  XFER - LINK: LINK TO ROUTINE, BUILD LINK LIST\n.*         ELSE: ADDR OF WORD WHERE EPA OF GETENTRY IS\n.*               (EG: VCON, WORD WHERE LOAD (SVC6) EPA STORED, ETC).\n.*\n         LCLC  &NN\n&NN      SETC  '&N'\n         AIF   ('&XFER' NE '' OR '&MF' NE 'I').OKX\n         MNOTE 8,'XFER= REQUIRED FOR MF=I'\n         MEXIT\n.OKX     AIF   ('&MF(1)' EQ 'B' OR '&MF(1)' EQ 'E').MFBE\n         AIF   ('&MF' NE 'I').MFL\n         AIF   ('&D' NE '').OKD\n         MNOTE 8,'DDNAME OPERAND REQUIRED FOR MF=I'\n         MEXIT\n.OKD     CNOP  0,4\n         AIF   ('&XFER' EQ 'LINK').PLUS32\n&NN      BAL   1,*+16                   BRANCH AROUND LIST, TYPE=ADDR\n         AGO   .SETNN\n.PLUS32  ANOP\n&NN      BAL   1,*+32                   BRANCH AROUND LIST, TYPE=LINK\n.SETNN   ANOP\n&NN      SETC  ''                       NO MORE NAME\n         AGO   .INLINE                  OK, GO\n.MFL     AIF   ('&MF' EQ 'L').INLINE    OK\n.BADMF   MNOTE 8,'INVALID MF=&MF'\n         MEXIT\n.INLINE  ANOP\n&NN      DC    A(0)                     RESERVED\n         AIF   ('&D' NE '').D\n.NODD    DC    A(0)                     DDNAME ADDRESS\n         AGO   .L\n.D       AIF   ('&D'(1,1) NE '''' AND '&D'(1,1) NE '(').DDACON\n         AIF   ('&MF' EQ 'L').BADL\n         AGO   .NODD                    MF=L, 'DD' OR (DD), A(0)\n.DDACON  DC    A(&D)                    DDNAME ADDRESS\n.L       AIF   ('&L' NE '').AL\n         DC    A(0)                     INDICATE LOCATE LIST FORM\n         AGO   .DONELST\n.AL      AIF   ('&L'(1,1) NE '(').LA    LIST ADDR\n         AIF   ('&MF' EQ 'I').OK1\n.BADL    MNOTE 8,'INVALID OPERANDS WITH MF=L'\n         MEXIT\n.OK1     DC    A(0)                     LIST ADDRESS\n         AGO   .DONELST\n.LA      DC    A(&L)                    LIST ADDRESS\n.DONELST AIF   ('&XFER' NE 'LINK').DONEIL ADDR NEED NO LIST\n         DC    A(*+8)                   LINK EPLOC\n         DC    A(0)                     LINK DCB\n         DC    CL8'GETENTRY'            LINK EP\n.DONEIL  AIF   ('&MF' EQ 'L').MEXIT     DONE\n         AIF   ('&D' EQ '').DEND\n         AIF   ('&D'(1,1) EQ '''').DQ   QUOTED\n         AIF   ('&D'(1,1) NE '(').DEND  DONE DD\n         ST    &D(1),4(,1)              SAVE DDNAME ADDRESS IN PARMLIST\n         AGO   .DEND\n.DQ      LA    0,=CL8&D                 GET DDNAME ADDRESS\n         ST    0,4(,1)                  SAVE DDNAME ADDRESS IN LIST\n.DEND    AIF   ('&L' EQ '').BAL\n         AIF   ('&L'(1,1) NE '(').BAL   REG LIST\n         ST    &L(1),8(,1)              SAVE LIST ADDRESS IN PARMLIST\n.BAL     AIF   ('&MF(1)' NE 'E' OR '&XFER' NE 'LINK').GO\n         LA    0,20(,1)                 GET EPLOC\n         ST    0,12(,1)                 SAVE EPLOC IN LINK LIST\n.GO      AIF   ('&XFER' EQ 'LINK').LINK\n         AIF   ('&XFER'(1,1) EQ '(').REGXFER\n         L     15,&XFER                 GET ROUTINE EPA\n.BALR    BALR  14,15                    GO TO GETENTRY\n         MEXIT\n.REGXFER L     15,0&XFER                GET ROUTINE EPA\n         AGO   .BALR                    GO\n.LINK    LINK  MF=(E,(1)),SF=(E,12(,1))\n.MEXIT   MEXIT\n.MFBE    AIF   (N'&MF EQ 2).OKEB\n         MNOTE 8,'LIST ADDRESS MISSING OR INVALID'\n         MEXIT\n.OKEB    ANOP\n&NN      IHBINNRA &MF(2)\n         AIF   ('&D' EQ '').NOD\n         AIF   ('&D'(1,1) EQ '''').DQUOT\n         AIF   ('&D'(1,1) EQ '(').DREG  REG DD\n         LA    0,&D                     GET DDNAME ADDRESS\n.ST      ST    0,4(,1)                  SAVE DDNAME ADDRESS IN PARMLIST\n         AGO   .NOD\n.DREG    ST    &D(1),4(,1)              SAVE DDNAME ADDRESS IN PARMLIST\n         AGO   .NOD\n.DQUOT   LA    0,=CL8&D                 GET DDNAME ADDRESS\n         AGO   .ST\n.NOD     AIF   ('&L' EQ '').NOL\n         AIF   ('&L'(1,1) EQ '(').REGLEB\n         LA    0,&L                     GET LIST ADDRESS\n         ST    0,8(,1)                  SAVE LIST ADDRESS IN PARMLIST\n         AGO   .NOL\n.REGLEB  ST    &L(1),8(,1)              SAVE LIST ADDRESS IN PARMLIST\n.NOL     AIF   ('&MF(1)' EQ 'E').BAL    GO\n         MEND\n         MACRO\n&L       PDSLIST &TYPE=BLDL,&DSECT=YES\n         LCLC  &P\n         AIF   ('&L' NE '').OKLL\n         MNOTE 8,'LABEL REQUIRED'\n         MEXIT\n.OKLL    AIF   (K'&L GE 3).OKL\n&P       SETC  '&L'\n         AGO   .START\n.OKL     ANOP\n&P       SETC  '&L'(1,3)\n*\n.START   AIF   ('&TYPE' EQ 'BLDL').BLDL\n         AIF   ('&TYPE' EQ 'PDS').PDS\n         MNOTE 8,'TYPE=&TYPE INVALID'\n         MEXIT\n.BLDL    ANOP\n*  BLDL LIST, PDS DIRECTORY ENTRY AFTER BLDL\n         AGO   .GO0\n.PDS     ANOP\n*  PDS LIST, PDS DIRECTORY ENTRY\n.GO0     ANOP\n*\n         AIF   ('&DSECT' EQ 'YES').DSECT\n&L       DS    0F\n         AGO   .GO1\n.DSECT   ANOP\n&L       DSECT ,\n.GO1     AIF   ('&TYPE' EQ 'PDS').NOPRFX\n&P.COUNT DC    H'1' -                   NUMBER OF ENTRIES\n&P.LEN   DC    AL2(&P.MLEN) -           LENGTH OF ENTRY\n.NOPRFX  ANOP\n         SPACE 1\n&P.NAME  DC    CL8' ' -                 MODULE NAME\n&P.MTTR  DC    XL3'00' -                TTR  OF MEMBER\n         AIF   ('&TYPE' NE 'BLDL').NOBLDL\n         SPACE 1\n&P.CNCAT DC    X'00' -                  CONCATENATION NUMBER TTRC\n&P.LIB   DC    X'00' -                  LIBRARY\n&P.LINK  EQU   1 -                      MEMBER FOUND IN LINKLIB\n&P.JOB   EQU   2 -                      MEMBER FOUND IN JOBLIB\n.NOBLDL  SPACE 1\n&P.IND   DC    X'00' -                  INDICATORS AND LENGTH\n&P.INDA  EQU   X'80' -                  THIS MEMBER IS AN ALIAS\n&P.FLEN  EQU   *-&P.NAME -              FIXED LENGTH\n         SPACE 1\n&P.TTTR  DC    XL3'00' -                TTR OF TEXT RECORD\n         DC    X'00' -                  ZEROS\n&P.NTTR  DC    XL3'00' -                TTR OF NOTE/SCTR LIST\n&P.NOTEL DC    X'00' -                  # ENTRIES IN NOTE LIST\n         SPACE 1\n&P.ATTR1 DC    X'00' -                  ATTRIBUTES\n&P.RENT  EQU   X'80' -                  REENTERABLE\n&P.REUS  EQU   X'40' -                  REUSABLE\n&P.OVLY  EQU   X'20' -                  OVERLAY\n&P.TEST  EQU   X'10' -                  TESTRAN\n&P.OL    EQU   X'08' -                  ONLY LOADABLE\n&P.SCTR  EQU   X'04' -                  SCTR FORMAT\n&P.EXEC  EQU   X'02' -                  EXECUTABLE\n&P.NRLD  EQU   X'01' -                  NO RLD'S (1 TEXT BLK)\n         SPACE 1\n&P.ATTR2 DC    X'00' -                  ATTRIBUTES, 2ND BYTE\n&P.LKEDF EQU   X'80' -                  LKED F LEVEL\n&P.ORIG0 EQU   X'40' -                  ORIGIN IS 0\n&P.EPA0  EQU   X'20' -                  EPA IS 0\n&P.NRLD2 EQU   X'10' -                  NO RLD'S HERE\n&P.NOREP EQU   X'08' -                  NO REPROCESSING OF THIS MODULE\n&P.NOSYM EQU   X'04' -                  NO TESTRAN SYM RECORDS HERE\n&P.CRLKF EQU   X'02' -                  MODULE CREATED BY LKED F LEVEL\n&P.REFR  EQU   X'01' -                  MODULE IS REFRESHABLE\n         SPACE 1\n&P.SIZE  DC    AL3(0) -                 LENGTH OF MODULE\n&P.SIZET DC    AL2(0) -                 LENGTH OF FIRST TEXT BLOCK\n&P.EPA   DC    AL3(0) -                 ENTRY POINT ADDRESS\n&P.ORIG  DC    AL3(0) -                 ORIGIN OF FIRST TEXT BLOCK\n&P.BLEN  EQU   *-&P.NAME -              LENGTH OF BASIC SECTION\n         SPACE 1\n&P.MEPA  DC    AL3(0) -                 MODULE EPA\n&P.ALIAS DC    CL8' ' -                 MEMBER OF WHICH THIS IS ALIAS\n         SPACE 1\n&P.RLEN  EQU   64-(*-&P.NAME) -         REMAINING LENGTH\n         DC    (&P.RLEN)X'00' -         RESERVED\n&P.MLEN  EQU   *-&P.NAME -              MAXIMUM ENTRY LENGTH\n         MEND\nESDR     TITLE 'E S D R E A D  --  SUBROUTINE TO BUILD ESD TABLE'\n*\nESDREAD  CSECT ,\n*\n*\n*\n*  ESDREAD\n*\n*\n*\n*  VIC TOLOMEI      9/77       CCN\n*\n*\n*\n*  GO THROUGH EVERY ESD OF ALL LOAD MODULES IN LIBRARY (LIBRARIES)\n*  FIND ALL EXTERNAL SYMBOLS IN ALL PDS'S REPRESENTED BY PASSED DD'S.\n*\n*  THIS IS A SUBROUTINE BUYS AS MUCH OF A TABLE OF 16-BYTE ENTRIES\n*  AS THE REGION WILL ALLOW, AND FILLS THIS TABLE WITH\n*  EXTERNALNAME/MODULE MATCHES, IE:\n*\n*        CL8'AN_EXTERNAL_NAME_IN_THAT_MODULE',CL8'MODULE_NAME'\n*\n*  THIS TABLE IS RETURNED AS OUTPUT, AND THE CALLER IS\n*  RESPONSIBLE TO FREE THE TABLE.\n*\n*\n*  INPUT:      R1  => CL8'DD1',CL44,...,CL8'DDN',CL44,X'00'\n*  OUTPUT:     R1  => A(TAB_ADDR),A(TAB_LEN),A(TAB_LAST)\n*              DSNAMES FILLED IN EACH 44 BYTE INPUT AREA\n*              R15 => 0 - SUCCESS (R1 IS VALID)\n*                     4 - INVALID DDNAME\n*                     8 - TABLE OVERFLOW\n*                    12 - I/O ERROR ENCOUNTERED ON MEMBER INPUT\n*                    16 - ERROR ON DIRECTORY INPUT\n*                    20 - NO EXTERNAL NAMES FOUND\n*\n*\n*  OVERHEAD ALLOWED IN REGION FOR OPEN ETC, NOT TO BE USED IN TABLE:\n*\nOVERHEAD EQU   10*1024                  10K\n*\n*\n*  MACROS AND ROUTINES USED:\n*\n*        GETENTRY, GETMAIN, FREEMAIN, OPEN, CLOSE, RDJFCB, LOAD\n*        DELETE, BEGIN, RETURN, READ, CHECK, POINT\n*\n         TITLE 'E S D R E A D  --  INITIALIZE'\n*\n*  ESDREAD\n*\n         SPACE 2\nESDREAD  CSECT\n         SAVE  (14,12),,*               SAVE CALLER'S REGS\n         LR    R12,R15                  SET BASE REG\n         OACUSING ESDREAD,R12           ADDRESSIBILITY\n         LA    R15,SAVEAREA             PNT TO PROGRAM SAVEAREA\n         ST    R15,8(,R13)              LSA IN HIS\n         ST    R13,4(,R15)              HAS IN MINE\n         LR    R13,R15                  SET SAVEAREA PNTR\n         SPACE 1\nRTABE    EQU   R11                      TABLE END           (BXLE)\nRTABI    EQU   R10                      TABLE ENTRY LENGTH  (BXLE)\nRTAB     EQU   R9                       TABLE ADDRESS       (BXLE)\nRESD     EQU   R8                       ESD BLK PTR\nRLIST    EQU   R7                       GETENTRY LIST PTR\nRRC      EQU   R6                       RETURN CODE\nRDECB    EQU   R5                       MEMBER READ DECB\nRPDS     EQU   R4                       PDS DIRECTORY ENTRY\nRPARM    EQU   R3                       PARM PTR (CL8,CL44)\n         TITLE 'E S D R E A D  --  GET AS BIG A TABLE AS POSSIBLE'\n*\n*  ATTEMPT TO GET AS MUCH TABLE AS POSSIBLE\n*\n         SPACE 1\n         LR    RPARM,R1                 SAVE PARM PTR IN OK REG\n         SPACE 1\n         OACUSING PARMLIST,RPARM\n         GETMAIN VC,MF=(E,CORELIST)     BUY OUT THE REGION\n         SPACE 1\n         FREEMAIN V,MF=(E,CORELIST)     FREE IT BEFORE WE DIE\n         SPACE 1\n         L     R0,TABLELEN              GET MAX POSSIBLE TABLE LEN\n         SRL   R0,TABLELG2              ROUND DOWN TO NEAREST ENTRY\n         SLL   R0,TABLELG2              ...\n         SH    R0,=Y(OVERHEAD)          ALLOW OVERHEAD FOR OPEN ETC\n         ST    R0,TABLELEN              SAVE NEW LENGTH FOR RETURN\n         ST    R0,PAR#SORT+12           PASS WORKAREA SIZE TO ESDSORT\n         GETMAIN R,LV=(0)               GET THE REAL TABLE NOW\n         ST    R1,PAR#SORT+16           SAVE ADDR FOR FREE\n         LR    RTABE,R1                 GET START TABLE ADDR\n         XC    0(TABLEENT,R1),0(R1)     SET LOW SORT KEY TO ZEROS\n         LA    RTAB,TABLEENT(,R1)       GET STARTING TABLE ADDRESS\n         ST    RTAB,PAR#SORT            SET ADDR FOR ESDSORT\n         ST    RTAB,TABLEADR            SET ADDR FOR MAINLINE EXTRACT\n         SPACE 2\n         A     RTABE,TABLELEN           POINT PAST END OF TABLE TO STOP\n         LA    RTABI,TABLEENT           GET ENTRY LEN\n         SR    RTABE,RTABI              SUBTRACT FOR ESDSORT KEY SLOT\n         SR    RTABE,RTABI              GET BXLE END TABLE\n         OACUSING TABLED,RTAB\n         OACINUSE ,\n         SPACE 1\n         LA    RDECB,DECB               DECB FOREVER\n         LA    RLIST,GETLIST            PTR TO GETENTRY LIST FOREVER\n         CLI   0(RPARM),0               NULL PARM?\n         BE    NONEFND                  YES, NONE FOUND\n         TITLE 'E S D R E A D  --  OPEN A DD'\n*\n*  GET DDNAME AND OPEN FILE. FIND DSN.\n*\n         SPACE 2\nDDLOOP   MVC   DCB+DCBDDNAM(8),PARMDD   SAVE IN MEMBER DCB\n         SPACE 2\n         GETENTRY (RPARM),MF=(B,(RLIST))  SAVE IN GETENTRY LIST TOO\n         SPACE 2\n         OPEN  MF=(E,DCBLIST)           OPEN THE INPUT LIBRARY\n         SPACE 1\n         TM    DCB+DCBOFLGS,X'10'       DID IT OPEN?\n         BNO   BADDD                    NO, ARG\n         RDJFCB MF=(E,DCBLIST)          GET JFCB FOR DSN\n         SPACE 1\n         BXH   R15,R15,BADDD            ARG\n         SPACE 1\n         TM    JFCB+JFCDSORG,JFCORGPO   IS THIS A PO DATASET?\n         BNO   BADDD                    NO, ARG\n         MVC   PARMDSN,JFCB             RETURN DSN TO CALLER\n         TITLE 'E S D R E A D  --  GET A MEMBER'\n*\n*  GET A MEMBER FROM THE PDS\n*\n         SPACE 2\nMEMLOOP  GETENTRY XFER=GETEPA,MF=(E,(RLIST))  GET A PDS ENTRY\n         SPACE 1\n         B     *+4(R15)                 WHAT HAPPENED\n         B     POINT                    0 - ALL IS WELL\n         B     CLOSE                    4 - ALL DONE, END DIR, NEXT\n         B     GETERR                   8 - ERROR\n         SPACE 2\nPOINT    LR    RPDS,R1                  SAVE PDS ENTRY PTR\n         OACUSING PDSLIST,RPDS\n         OACINUSE ,\n         SPACE 2\n         CLC   PDSMTTR,PDSTTTR          JUST TEXT? SAME TTR'S?\n         BE    MEMLOOP                  YES, IGNORE THIS ENTRY\n         MVC   TTRZ(3),PDSMTTR          GET MODULE TTR\n         SPACE 2\n         POINT DCB,TTRZ                 POINT TO 1ST MEMBER BLK\n         TITLE 'E S D R E A D  --  FIND ESD''S'\n*\n*  FIND AN ESD\n*\n         SPACE 2\nBLKLOOP  READ  (RDECB),SF,MF=E          GET A BLK\n         SPACE 2\n         LH    R2,DECB+6                GET MAX READ LENGTH WHILE WAIT\n         SPACE 2\n         CHECK (RDECB)                  TWIDDLE TWIDDLE\n         SPACE 2\n         L     R1,DECB+16               GET IOB\n         SH    R2,14(,R1)               GET LENGTH READ\n         CH    R2,=Y(ESDBUFL)           TOO LONG FOR ESD?\n         BH    MEMLOOP                  YES, PAST ESD'S, NEXT MEMBER\n         SPACE 2\n*\n*  DETERMINE WHAT TYPE OF BLOCK THIS IS\n*\n         SPACE 1\n         XR    R1,R1                    FOR IC\n         NI    ESDBUF,255-(X'08'+X'04') THESE ARE SUBTYPES\n         IC    R1,ESDBUF                GET ID\n         LA    R15,8-1                  NUMBER OF BITS TO SHIFT\n         SPACE 1\nIDLOOP   SRA   R1,1                     SHIFT A BIT OFF\n         BZ    IDGOT                    WE HAVE IT\n         BCT   R15,IDLOOP               CONTINUE\n         SPACE 1\nIDGOT    SLL   R15,2                    *4 FOR BRANCH VECTOR OFFSET\n         B     *+4(R15)                 WHAT TYPE OF BLOCK\n         B     MEMLOOP                  00 - X'80' - IDR    PAST ESD'S\n         B     BLKLOOP                  04 - X'40' - SYM    IGNORE\n         B     GOTESD                   08 - X'20' - CESD   WE HAVE IT\n         B     MEMLOOP                  12 - X'10' - SC/XL  PAST ESD'S\n         EX    0,*                      16 - X'08' - SUBTYPE CAN'T BE\n         EX    0,*                      20 - X'04' - SUBTYPE CAN'T BE\n         B     MEMLOOP                  24 - X'02' - RLD/CTLRLD PAST\n         B     MEMLOOP                  28 - X'01' - CTL    PAST ESD'S\n         SPACE 1\n*  NOTE: THE 24 CASE INCLUDES BOTH X'03' (CONTROL RLD) AND X'02' (RLD)\n         TITLE 'E S D R E A D  --  PROCESS AN ESD BLK'\n*\n*  WE HAVE AN ESD.  PROCESS ITS ENTRIES.\n*\n         SPACE 2\nGOTESD   LA    RESD,ESDBUF+8            START OF ESD DATA\n         LR    R0,RESD                  RE-GET FOR END\n         AH    R0,ESDBUF+6              POINT PAST END OF BLK\n         OACUSING ESDDATA,RESD\n         OACINUSE ,\n         SPACE 1\nNAMELOOP CR    RESD,R0                  PAST END BLK?\n         BNL   BLKLOOP                  YES, GET NEXT BLK\n         NI    ESDDTYPE,255-X'F0'       NO, JUST WANT LOW NIBBLE\n         CLI   ESDDTYPE,X'00'           SECTION DEFINITION (SD)?\n         BE    NAMEGOT                  YES, WE HAVE A NAME\n         CLI   ESDDTYPE,X'03'           LABEL REFERENCE (LR)?\n         BE    NAMEGOT                  YES, WE HAVE A NAME\nNAMENEXT LA    RESD,ESDDL(,RESD)        NEXT ESD ENTRY\n         B     NAMELOOP                 CONTINUE THROUGH ESD BLK\n         SPACE 3\n*\n*  WE HAVE AN ESD ENTRY (SECTION DEFINITION OR LABEL REFERENCE)\n*\n         SPACE 1\nNAMEGOT  MVC   TABLEMOD,PDSNAME         SAVE MODULE NAME\n         MVC   TABLEESD,ESDDNAME        SAVE EXTERNAL NAME\n         BXLE  RTAB,RTABI,NAMENEXT      AND GET NEXT NAME\n         B     OFLO                     ARG, TOO MUCH IN TABLE, OFLO\n         SPACE 2\n         OACDROP RPDS\n         OACDROP RESD\n         OACINUSE ,\n         TITLE 'E S D R E A D  --  EXITS'\n*\n*  EXITS\n*\n         SPACE 2\nCLOSE    CLOSE MF=(E,DCBLIST)           CLOSE A DD\n         LA    RPARM,PARML(,RPARM)      NEXT DD/DSN\n         CLI   0(RPARM),0               END PARMLIST?\n         BNE   DDLOOP                   NO, CONTINUE\n         SPACE 2\nDONE     C     RTAB,PAR#SORT            DID WE FIND ANY EXTERNAL NAMES?\n         BNH   NONEFND                  NO, ARG\n         MVI   0(RTAB),X'FF'            SET LAST HIGH KEY...\n         MVC   1(TABLEENT-1,RTAB),0(RTAB) ... FOR ESDSORT\n         SR    RTAB,RTABI               YES, BACK UP TO RET BXLE END\n         ST    RTAB,TABLEEND            SAVE BXLE END TABLE FOR RET\n         ST    RTAB,PAR#SORT+8          LAST ENTRY TO ESDSORT\n         XR    RRC,RRC                  RC=0\n         SPACE 2\nRETURN   TM    DCB+DCBOFLGS,X'10'       FILE STILL OPEN?\n         BNO   DELETE                   NO, LEAVE\n         CLOSE MF=(E,DCBLIST)           CLOSE THE FILE\n         SPACE 2\nDELETE   MVI   EXLST,0                  CLEAR FLAGS IN DSNAME RETURN\n         SPACE 2\n         L     R13,4(,R13)              RESTORE SA\n         LA    R1,RETPARMS              SET RETURN PARMLIST\n         LR    R15,RRC                  GET RETURN CODE\n         L     R14,12(,R13)             RESTORE R14\n         RETURN (2,12)                  RESTORE REST AND RETURN\n         SPACE 2\n         OACDROP RTAB\n         OACINUSE ,\n         EJECT\n*\n*  INVALID DD\n*\n         SPACE 1\nBADDD    LA    RRC,4                    INVALID DD\n         B     RETURN                   AND LEAVE\n         SPACE 3\n*\n*  TABLE OFLO\n*\n         SPACE 1\nOFLO     LA    RRC,8                    TABLE OFLO\n         B     RETURN                   AND LEAVE\n         SPACE 3\n*\n*  I/O ERROR IN MEMBER\n*\n         SPACE 1\nSYNAD    LA    RRC,12                   SYNAD\n         B     RETURN                   AND LEAVE\n         SPACE 3\n*\n*  ERROR IN GETENTRY\n*\n         SPACE 1\nGETERR   LA    RRC,16                   ERROR IN GETENTRY\n         B     RETURN                   AND LEAVE\n         SPACE 3\n*\n*  NO EXTERNAL NAMES FOUND\n*\n         SPACE 1\nNONEFND  LA    RRC,20                   NONE FOUND\n         B     RETURN                   AND LEAVE\n         SPACE 2\n         OACDROP R12\n         OACINUSE ,\n         TITLE 'E S D R E A D  --  DATA AND CONSTANTS'\n*\n*  DATA\n*\n         SPACE 2\nDBLW     DS    D                        TEMP\nSAVEAREA DC    18F'0'                   PROGRAM SAVEAREA\n         SPACE 2\nCORELIST GETMAIN VC,LA=LENGTHS,A=ADDRS,MF=L    GETMAIN/FREEMAIN LIST\n         SPACE 1\nLENGTHS  DS    0F                       LENGTH FOR VC GETMAIN\nLENMIN   DC    X'00000008'              MIN LENGTH\nLENMAX   DC    X'00FFFFF8'              MAX LENGTH\n         SPACE 2\nGETLIST  GETENTRY MF=L,XFER=            GETENTRY LIST\nGETEPA   DC    V(GETENTRY)              GETENTRY EPA\n         SPACE 2\nESDBUFL  EQU   248                      MAX SIZE ESD BUFFER\nESDBUF   DS    0F,(ESDBUFL)X            ESD BUFFER\nJFCB     EQU   ESDBUF                   JFCB OVERLAY\nJFCDSORG EQU   98                       OFFSET TO DSORG\nJFCORGPO EQU   X'02'                    DSORG=PO\n         EJECT\n*\n*  MORE DATA\n*\n         SPACE 2\nDCBLIST  OPEN  DCB,MF=L                 OPEN/CLOSE LIST\n         SPACE 1\n         READ  DECB,SF,DCB,ESDBUF,ESDBUFL,MF=L DECB FOR RECFM=U READS\n         SPACE 1\n         PRINT NOGEN\nDCB      DCB   DDNAME=*,DSORG=PS,MACRF=RP,                             #\n               RECFM=U,SYNAD=SYNAD,EODAD=MEMLOOP,EXLST=EXLST\n         SPACE 1\nDCBDDNAM EQU   40                       OFFSET TO DD\nDCBOFLGS EQU   48                       OFFSET TO FLAGS\n         SPACE 2\nTTRZ     DC    F'0'                     TTRZ FOR POINTS\n         SPACE 2\nEXLST    DC    0F'0',X'87',AL3(JFCB)\n         SPACE 2\nRETPARMS DS    0F                       RETURN PARMS\nADDRS    DS    0F                       ADDRS FOR VC GETMAIN\nTABLEADR DC    A(0)                     +0  - START SORT ADDR\nTABLELEN DC    F'0'                     +4  - TABLE LENGTH\nTABLEEND DC    A(0)                     +8  - TABLE LAST\n         SPACE 2\n*  ----  PARMLIST TO ESDSORT + EXTRA WORD FOR TABLE FREE\n*  ----  NOTE THERE MUST BE AN ENTRY OF 16X'00' BEFORE THE FIRST\n*  ----  ADDRESS TO BE SORTED AND AN ENTRY OF 16X'FF' AFTER THE LAST\n*  ----  ADDRESS TO BE SORTED.\n         SPACE 2\n         ENTRY PAR#SORT                 TELL ESDXREF WHERE WE ARE\n         SPACE 2\nPAR#SORT DS    0F                       PARMLIST TO ESDSORT\n         DC    A(0)                     A(TABLE TO SORT)\n         DC    A(TABLEENT)              F'ENTRY LENGTH'\n         DC    A(0)                     A(LAST ENTRY)\n         DC    A(0)         **CONTIG**  A(TOTAL WORKAREA SIZE)\nPAR#ADDR DC    A(0)         **CONTIG**  REAL TABLE START ADDR\n         SPACE 2\n         LTORG\n         TITLE 'E S D R E A D  --  DSECTS'\n*\n*  TABLE\n*\n         SPACE 2\nTABLED   DSECT ,                        TABLE ENTRY\nTABLEESD DS    CL8                      ESD FOR THIS MODULE\nTABLEMOD DS    CL8                      MODULE NAME\nTABLEENT EQU   *-TABLED                 LENGTH\nTABLELG2 EQU   4                        LOG 2 OF TABLE ENTRY LENGTH\n         SPACE 5\n*\n*  ESD DATA ENTRY\n*\n         SPACE 2\nESDDATA  DSECT ,                        ESD DATA ENTRY DSECT\nESDDNAME DS    CL8                      EXTERNAL NAME OR X'00'\nESDDTYPE DS    X                        TYPE\nESDDADDR DS    AL3                      LKED ADDR OF ENTRY PT\nESDDSEG  DS    X                        SEGMENT NUMBER\nESDDLEN  DS    AL3                      LENGTH THIS ENTRY PT\nESDDL    EQU   *-ESDDATA                LENGTH ESD DATA ENTRY\n         SPACE 5\n*\n*  PARMLIST\n*\n         SPACE 2\nPARMLIST DSECT\nPARMDD   DS    CL8                      DDNAME\nPARMDSN  DS    CL44                     DSNAME\nPARML    EQU   *-PARMLIST               LENGTH ENTRY\n         EJECT\n         PRINT GEN\n         SPACE 1\nPDSLIST  PDSLIST TYPE=PDS\n         SPACE 2\n         OACREGS ,\n         SPACE 2\n         END\n         MACRO\n&L       PDSLIST &TYPE=BLDL,&DSECT=YES\n         LCLC  &P\n         AIF   ('&L' NE '').OKLL\n         MNOTE 8,'LABEL REQUIRED'\n         MEXIT\n.OKLL    AIF   (K'&L GE 3).OKL\n&P       SETC  '&L'\n         AGO   .START\n.OKL     ANOP\n&P       SETC  '&L'(1,3)\n*\n.START   AIF   ('&TYPE' EQ 'BLDL').BLDL\n         AIF   ('&TYPE' EQ 'PDS').PDS\n         MNOTE 8,'TYPE=&TYPE INVALID'\n         MEXIT\n.BLDL    ANOP\n*  BLDL LIST, PDS DIRECTORY ENTRY AFTER BLDL\n         AGO   .GO0\n.PDS     ANOP\n*  PDS LIST, PDS DIRECTORY ENTRY\n.GO0     ANOP\n*\n         AIF   ('&DSECT' EQ 'YES').DSECT\n&L       DS    0F\n         AGO   .GO1\n.DSECT   ANOP\n&L       DSECT ,\n.GO1     AIF   ('&TYPE' EQ 'PDS').NOPRFX\n&P.COUNT DC    H'1' -                   NUMBER OF ENTRIES\n&P.LEN   DC    AL2(&P.MLEN) -           LENGTH OF ENTRY\n.NOPRFX  ANOP\n         SPACE 1\n&P.NAME  DC    CL8' ' -                 MODULE NAME\n&P.MTTR  DC    XL3'00' -                TTR  OF MEMBER\n         AIF   ('&TYPE' NE 'BLDL').NOBLDL\n         SPACE 1\n&P.CNCAT DC    X'00' -                  CONCATENATION NUMBER TTRC\n&P.LIB   DC    X'00' -                  LIBRARY\n&P.LINK  EQU   1 -                      MEMBER FOUND IN LINKLIB\n&P.JOB   EQU   2 -                      MEMBER FOUND IN JOBLIB\n.NOBLDL  SPACE 1\n&P.IND   DC    X'00' -                  INDICATORS AND LENGTH\n&P.INDA  EQU   X'80' -                  THIS MEMBER IS AN ALIAS\n&P.FLEN  EQU   *-&P.NAME -              FIXED LENGTH\n         SPACE 1\n&P.TTTR  DC    XL3'00' -                TTR OF TEXT RECORD\n         DC    X'00' -                  ZEROS\n&P.NTTR  DC    XL3'00' -                TTR OF NOTE/SCTR LIST\n&P.NOTEL DC    X'00' -                  # ENTRIES IN NOTE LIST\n         SPACE 1\n&P.ATTR1 DC    X'00' -                  ATTRIBUTES\n&P.RENT  EQU   X'80' -                  REENTERABLE\n&P.REUS  EQU   X'40' -                  REUSABLE\n&P.OVLY  EQU   X'20' -                  OVERLAY\n&P.TEST  EQU   X'10' -                  TESTRAN\n&P.OL    EQU   X'08' -                  ONLY LOADABLE\n&P.SCTR  EQU   X'04' -                  SCTR FORMAT\n&P.EXEC  EQU   X'02' -                  EXECUTABLE\n&P.NRLD  EQU   X'01' -                  NO RLD'S (1 TEXT BLK)\n         SPACE 1\n&P.ATTR2 DC    X'00' -                  ATTRIBUTES, 2ND BYTE\n&P.LKEDF EQU   X'80' -                  LKED F LEVEL\n&P.ORIG0 EQU   X'40' -                  ORIGIN IS 0\n&P.EPA0  EQU   X'20' -                  EPA IS 0\n&P.NRLD2 EQU   X'10' -                  NO RLD'S HERE\n&P.NOREP EQU   X'08' -                  NO REPROCESSING OF THIS MODULE\n&P.NOSYM EQU   X'04' -                  NO TESTRAN SYM RECORDS HERE\n&P.CRLKF EQU   X'02' -                  MODULE CREATED BY LKED F LEVEL\n&P.REFR  EQU   X'01' -                  MODULE IS REFRESHABLE\n         SPACE 1\n&P.SIZE  DC    AL3(0) -                 LENGTH OF MODULE\n&P.SIZET DC    AL2(0) -                 LENGTH OF FIRST TEXT BLOCK\n&P.EPA   DC    AL3(0) -                 ENTRY POINT ADDRESS\n&P.ORIG  DC    AL3(0) -                 ORIGIN OF FIRST TEXT BLOCK\n&P.BLEN  EQU   *-&P.NAME -              LENGTH OF BASIC SECTION\n         SPACE 1\n&P.MEPA  DC    AL3(0) -                 MODULE EPA\n&P.ALIAS DC    CL8' ' -                 MEMBER OF WHICH THIS IS ALIAS\n         SPACE 1\n&P.RLEN  EQU   64-(*-&P.NAME) -         REMAINING LENGTH\n         DC    (&P.RLEN)X'00' -         RESERVED\n&P.MLEN  EQU   *-&P.NAME -              MAXIMUM ENTRY LENGTH\n         MEND\nGET      TITLE 'G E T E N T R Y  --  GET PDS DIRECTORY ENTRIES'\n*\nGETENTRY CSECT\n*\n*  VIC TOLOMEI   -   SEPTEMBER 1977\n*\n*\n*  THIS RE-ENTRANT SUBROUTINE IS TO GET DIRECTORY ENTRIES\n*  ONE AT A TIME FROM A PDS OR CONCATENATED PDS'S ON ONE DD CARD.\n*\n*  AS INPUT TO THE ROUTINE R1 MUST POINT TO A 12-BYTE PARMLIST,\n*  WHICH CAN BE SET UP BY THE \"GETENTRY\" MACRO:\n*\n*        +0    A(0)                     (WILL BE WORKAREA ADDRESS)\n*        +4    A(DDNAME)\n*        +8    A(PDSENTRY)\n*              'PDSENTRY' IS THE ADDRESS OF THE STORAGE\n*              WHERE THE DIRECTORY ENTRY IS TO BE COPIED.\n*              THIS CORE MUST HAVE THE FOLLOWING FORM:\n*              H'LENGTH OF ENTRY DESIRED',XL(LENGTH).\n*              IF THIS ADDRESS IS 0, THEN \"LOCATE MODE\" IS\n*              ASSUMED, AND THE ADDRESS OF THE DIRECTORY ENTRY\n*              WILL BE RETURNED IN R1.\n*\n*  OUTPUT IS AS FOLLOWS:\n*\n*        R15 = 0  -  SUCCESS\n*                    R1 = ADDR OF DIRECTORY ENTRY (LOCATE MODE) OR\n*                         LIST FILLED IN\n*                    R0 = LENGTH OF ENTRY RETURNED (R1 OR LIST)\n*              4  -  END OF PDS(S)\n*                    R1 = NUMBER OF DIRECTORY BLKS READ\n*              8  -  OPEN OR I/O ERROR\n*                    R1 = DIRECTORY BLK NUMBER AT TIME OF ERROR\n*\n*\n*  THIS ROUTINE IS FULLY REENTRANT, REUSABLE AND REFRESHABLE\n*\n         EJECT\n*\n*  REGISTER USAGE:\n*\n         SPACE 1\n         OACREGS ,\n         SPACE 1\nRWORK    EQU   R13                      REENTRANT WORKAREA\nRBASE    EQU   R12                      BASE\nRPARM    EQU   R11                      PARMLIST\nRDCB     EQU   R10                      QSAM DCB\nRLIST    EQU   R9                       RETURN LIST ADDRESS OR 0\nRDIREND  EQU   R8                       DIRECTORY BLK END PTR\nRDIR     EQU   R7                       DIRECTORY BLK PTR\nRONE     EQU   R6                       CONSTANT 1\n         TITLE 'G E T E N T R Y  --  INITIALIZE'\n*\n*  INITIALIZE\n*\n         SPACE 2\nGETENTRY CSECT\n         SAVE (14,12),,*\n         SPACE 2\n         LR    RBASE,R15                GET MY BASE\n         OACUSING GETENTRY,RBASE        SET IT UP\n         SPACE 1\n         LR    RPARM,R1                 SAVE PARMLIST\n         OACUSING PARM,RPARM            SET THAT UP\n         L     RLIST,PARMLIST           GET POSSIBLE RETURN LIST PTR\n         LA    RONE,1                   GET A 1\n         L     R2,PARMWORK              GET POSSIBLE OLD WORKAREA\n         LTR   R2,R2                    FIRST ENTRY, NO WORKAREA\n         BNZ   CHKOPEN                  NO, CHECK IF OPEN YET\n         SPACE 2\n*\n*  FIRST CALL, GET AND INITIALIZE WORKAREA\n*\n         SPACE 1\n         LA    R0,WORKLEN               GET LENGTH WORKAREA TO BUY\n         GETMAIN R,LV=(0)               GET IT\n         LR    R2,R1                    SAVE ADDR TEMPORARILY\n         OACUSING WORK,R2               TEMP\n         XC    WORK(WORKLEN),WORK       CLEAR OUT WORKAREA FIRST\n         ST    R2,PARMWORK              SAVE IN PARMLIST FOR NEXT CALL\n         SPACE 1\n         MVC   DCB(DCBL),DCBM           SET UP DCB\n         L     R1,PARMDD                GET DDNAME ADDR\n         MVC   DCB+DCBDDNAM(8),0(R1)    COPY REQUESTED DD OVER\n         OACDROP R2\n         EJECT\n*\n*  WITH A WORKAREA, CHAIN SA'S.  REOPEN DCB IF NECESSARY.\n*\n         SPACE 1\nCHKOPEN  ST    R13,4(,R2)               SAVE CALLER'S SA (HSA)\n         ST    R2,8(,R13)               LSA NOW\n         LR    RWORK,R2                 SET WORKAREA/SAVAREA PTR\n         OACUSING WORK,RWORK            BASE FOREVER\n         SPACE 2\n         LA    RDCB,DCB                 GET DCBADDR FOREVER\n         LM    RDIR,RDIREND,ADIR        GET A(BEGIN,END) DIR BLK MAYBE\n         TM    DCB+DCBOFLGS,X'10'       OPEN ALREADY?\n         BO    NEXTENT                  YES, JUST GET NEXT DIR ENTRY\n         ST    RDCB,DCBLIST             NO, SET UP DCB LIST  - DCB\n         MVC   DCBLIST(1),DCBLISTM                           - FLAGS\n         SPACE 1\n         OPEN  MF=(E,DCBLIST)           OPEN UP THE DIRECTORY\n         SPACE 1\n         TM    DCB+DCBOFLGS,X'10'       OPEN?\n         BNO   SYNAD                    NO, ARG, QUIT\n         SPACE 2\n         OACINUSE ,\n         TITLE 'G E T E N T R Y  --  GET A DIRECTORY BLOCK'\n*\n*  GET A DIRECTORY BLOCK\n*\n         SPACE 1\nGET      GET   (RDCB)                   GET A DIRECTORY BLK\n         LR    R0,RONE                  GET A ONE\n         A     R0,NUMBLKS               COUNT THIS BLOCK\n         ST    R0,NUMBLKS               SAVE IT\n         LA    RDIR,2(,R1)              SAVE PTR TO REAL BEGIN OF BLK\n         OACUSING PDSENTRY,RDIR         SET BASE\n         SPACE 2\n         OACINUSE ,\n         SPACE 2\n         LR    RDIREND,R1               RE-GET PTR TO BEGIN OF BLK\n         AH    RDIREND,0(,R1)           GET PTR TO END\n         ST    RDIREND,ADIREND          SAVE END OF DIRECTORY NEXT CALL\n TITLE 'G E T E N T R Y  --  RETURN CURRENT ENTRY AND SET UP FOR NEXT'\n*\n*  FIND THE CURRENT ENTRY. RETURN IT IN SPECIFIED MANNER.\n*  SET UP FOR NEXT ENTRY ALSO\n*\n         SPACE 2\nNEXTENT  CR    RDIR,RDIREND             AT END OF BLK?\n         BNL   GET                      YES, GET NEXT BLK\n         CLI   PDSNAME,X'FF'            END OF DIRECTORY?\n         BL    SETNEXT                  NO, SET UP NEXT ENTRY, LEAVE\n         SPACE 1\n         FEOV  (RDCB)                   YES, NEXT LIB IF ANY\n         B     GET                      IF HERE, GET 1ST BLK NEXT LIB\n         SPACE 2\nSETNEXT  LR    R1,RDIR                  ASSUME \"LOCATE\" MODE\n         IC    R2,PDSIND                GET INDICATORS\n         SLL   R2,32-5                  JUST LEN NOW\n         SRL   R2,32-6                  *2 FOR LEN IN BYTES\n         LA    R2,PDSFLEN(,R2)          GET TOTAL LENGTH OF ENTRY\n         LTR   RLIST,RLIST              RETURN LIST OR LOCATE?\n         BZ    EXIT                     LOCATE, WE HAVE R1 QUIT WITH R0\n         LH    R14,0(,RLIST)            GET REQUESTED LENGTH\n         SR    R14,RONE                 GET EXECUTE LENGTH\n         BM    SYNAD                    NO, SO WHAT CAN I DO?\n         EX    R14,XC                   CLEAR HIS AREA, NOT PREFIX\n         SR    R2,RONE                  GET EXECUTE LEN OF REAL ENTRY\n         CR    R2,R14                   WHICH IS BIGGER, REQ OR REAL?\n         BNH   *+6                      REQ, SO IT ALL CAN FIT\n         LR    R2,R14                   REAL, SO TRUNCATE TO REQ\n         EX    R2,MVC                   COPY ENTRY TO RETURN LIST\n         XR    R1,R1                    NO RETURN LOCATE REG\n         AR    R2,RONE                  RESTORE REAL LEN\n         SPACE 2\nEXIT     LR    R0,R2                    GET LENGTH OF ENTRY IN RET REG\n         AR    RDIR,R0                  POINT TO NEXT ENTRY (MAYBE)\n         ST    RDIR,ADIR                SAVE FOR NEXT CALL\n         SPACE 2\n         XR    R15,R15                  SUCCESS\n         L     R13,4(,R13)              RESTORE SA FOR NORMAL RETURN\n         SPACE 3\nRETURN   L     R14,12(,R13)             RESTORE R14\n         LM    R2,R12,28(R13)           RESTORE ALL BUT R15,R1 (R0)\n         BR    R14                      RETURN TO CALLER WITH GOODIES\n         TITLE 'G E T E N T R Y  --  EXITS'\n*\n*  EXITS\n*\n         SPACE 1\n*\n*  EODAD\n*\nEODAD    LA    R3,4                     END OF DATA, ALL DONE, RC=4\n         SPACE 2\nQUIT     TM    DCB+DCBOFLGS,X'10'       WAS DCB OPEN?\n         BNO   NOCLOSE                  NO, DON'T CLOSE/FREEPOOL\n         CLOSE MF=(E,DCBLIST)           CLOSE FILE\n         SPACE 1\n         FREEPOOL (RDCB)                FREE QSAM BUFFERS\n         SPACE 1\nNOCLOSE  LR    R1,RWORK                 GET WORKAREA\n         L     R2,NUMBLKS               GET NUMBER OF BLKS\n         L     R13,4(,R13)              RESTORE SA\n         LA    R0,WORKLEN               GET LENGTH\n         FREEMAIN R,LV=(0),A=(1)        FREE WORKAREA\n         XC    PARMWORK,PARMWORK        CLEAR PTR IN PARMLIST\n         LR    R1,R2                    RETURN NUMBER OF BLKS\n         XR    R0,R0                    IN CASE\n         LR    R15,R3                   RETURN CODE\n         B     RETURN                   BYE BYE\n         SPACE 3\n*\n*  SYNAD\n*\nSYNAD    LA    R3,8                     ERROR, RC=8\n         B     QUIT                     GET OUTA HERE FAST\n         TITLE 'G E T E N T R Y  --  DATA AND CONSTANTS'\n*\n*  EXECUTED INSTRUCTIONS\n*\n         SPACE 3\nXC       XC    2(0,RLIST),2(RLIST)      << EXECUTED >>\nMVC      MVC   2(0,RLIST),0(RDIR)       << EXECUTED >>\n         SPACE 2\n         OACDROP ,\n         SPACE 2\n         OACINUSE ,\n         SPACE 3\n*\n*  DATA\n*\n         SPACE 2\n         PRINT NOGEN\n         SPACE 2\nDCBM     DCB   DDNAME=*,MACRF=GL,DSORG=PS,EODAD=EODAD,                 #\n               RECFM=F,BLKSIZE=256,LRECL=256,SYNAD=SYNAD\nDCBL     EQU   *-DCBM                   LENGTH\n         SPACE 2\n         PRINT GEN\n         SPACE 2\nDCBLISTM OPEN  (0,INPUT),MF=L\n         SPACE 2\n         LTORG\n         TITLE 'G E T E N T R Y  --  DSECTS'\n*\n*  WORKAREA DSECT\n*\n         SPACE 2\nWORK     DSECT\nSAVEAREA DS    18F                      SAVEAREA\nADIR     DS    A                        CURRENT DIR BLK PTR    |CONTIG|\nADIREND  DS    A                        CURRENT DIR BLK END    |CONTIG|\n         SPACE 2\nENTLEN   DS    F                        LENGTH OF CURRENT ENT  |CONTIG|\nENTADDR  DS    A                        ADDR OF CURRENT ENTRY  |CONTIG|\n         SPACE 2\nDCB      DS    0F,(DCBL)X               REAL DCB\n         SPACE 1\nDCBDDNAM EQU   40                       OFFSET TO DDNAME (DCBD TOO BIG)\nDCBOFLGS EQU   48                       OFFSET TO OPEN BITS\n         SPACE 1\nDCBLIST  DS    F\n         SPACE 2\nNUMBLKS  DC    F'0'                     NUMBER DIRECTORY BLKS\n         SPACE 2\nWORKLEN  EQU   *-WORK                   LENGTH WORKAREA\n         SPACE 5\n*\n*  PARMLIST DSECT\n*\n         SPACE 2\nPARM     DSECT\nPARMWORK DS    A                        WORKAREA PTR (0 ON ENTRY)\nPARMDD   DS    A                        DDNAME ADDRESS\nPARMLIST DS    A                        ADDRESS OF RETURN LIST OR 0\n         EJECT\nPDSENTRY PDSLIST  TYPE=PDS\n         SPACE 2\n         END\n         TITLE 'E S D S O R T   ---   SORT ESD/MOD ENTRIES'\nESDSORT  CSECT\n***********************************************************************\n*                                                                     *\n*   SORT - SORT ESD/MOD ENTRIES (EACH 16 BYTES)                       *\n*                                                                     *\n* THIS ROUTINE USES A PARTITION EXCHANGE SORT,                        *\n* SEE KNUTH VOL3, P 114 - P 123                                       *\n*                                                                     *\n*  AT ENTRY: R1 =  ADDR FOLLOWING PARM LIST:                          *\n*     A(TABLE TO SORT) (NOTE @ TABLE - 1 ENTRY HAS KEY OF X'00')      *\n*     A(ENTRY LENGTH)   CONSTANT OF 16                                *\n*     A(LAST ENTRY)     (NOTE LAST ENTRY + 1 HAS KEY OF X'FF')        *\n*     A(ENTIRE AREA LENGTH) (INCLUDES DUMMY KEYS ABOVE PLUS           *\n*                            ANY EMPTY SPACE AT END OF TABLE)         *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT ,\n*   REGISTER USAGE\n*        EQU   R0                       (R0 - R3 USED TO SWAP RECORDS)\n*        EQU   R1\n*        EQU   R2\n*        EQU   R3\n         SPACE 1\nRR1      EQU   R4                       (RR1 - RR4 RECORD KEY/DATA)\nRR2      EQU   R5\nRR3      EQU   R6\nRR4      EQU   R7\n         SPACE 1\nRI       EQU   R8\nRJ       EQU   R9\nRICR     EQU   R10                      LENGTH OF ONE ENTRY\nRSTACK   EQU   R11                      CUR STACK PTR\n         SPACE 1\nRL       EQU   R14                      LEFT PTR\nRR       EQU   R15                      RIGHT PTR\n         SPACE 1\n         STM   R0,R15,REGSAVE-*(R15)    SAVE CALLERS REGS\n         LR    R12,R15                  SET MY BASE\n         USING ESDSORT,R12\n         SPACE 1\n         XC    CNTPART,CNTPART          NO PARTITIONS YET\n         LM    R0,R3,0(R1)              GET SORT PARMS\n         STM   R0,R3,SORTPARM           SAVE THEM\n         SR    R0,R1                    REAL BEGIN OF CORE AREA\n         ST    R0,@CORE                 SAVE @ CORE AREA\n         AR    R3,R0                    @ PAST END OF CORE\n         ST    R3,@STACKE               IS END OF STACK\n         SR    R0,R2                    REAL BEGIN - @ LAST ENT\n         LCR   R0,R0                    GET POSITIVE NUMBER\n         SRL   R0,4                     GET NUMBER ENTRIES TO SORT\n         CVD   R0,DWD                   TO DEC\n         MVC   L#NUM(10),=X'40202020202020202120'\n         ED    L#NUM(10),DWD+3          TO PRINT AREA\n         AR    R2,R1                    PAST LAST ENTRY\n         AR    R2,R1                    PAST DUMMY X'FF' AT END\n         ST    R2,@STACK                INIT TOP OF STACK\n         ST    R2,@STACKH               INIT HIGH WATER MARK\n         SR    R3,R2                    GET STACK LENGTH\n         SRL   R3,3                     NUMBER OF STACK ENTRIES\n         CVD   R3,DWD\n         MVC   L#STACK(10),=X'40202020202020202120'\n         ED    L#STACK(10),DWD+3\n         WTO   MF=(E,L#MSG1)            PRINT MSG1\n         SPACE 1\n         L     RSTACK,@STACK            INIT STACK PTR\n         L     RL,SORTPARM              INIT LEFT PTR\n         L     RR,SORTPARM+8            INIT RIGHT PTR\n         L     RICR,SORTPARM+4          INIT ENTRY LENGTH\n         EJECT ,\n*---                SORT SUBFILE BETWEEN (RL,RR) INCLUSIVE         ---*\n         SPACE 1\nQ2       CL    RSTACK,@STACKH           HAVE NEW HIGH WATER MARK?\n         BNH   *+8                      BR IF NOT\n         ST    RSTACK,@STACKH           SAVE NEW HIGH WATER MARK\n         CR    RL,RR                    ONLY ONE ENTRY?\n         BE    Q8                       BR IF ONLY ONE ENTRY\n         LR    R1,RR                    LOGIC SWAP OF R(L) AND\n         SR    R1,RL                    RECORD BETWEEN RL AND RR\n         SRL   R1,5                     KEEP ON RECORD BOUNDARY\n         SLL   R1,4                     BACK TO OFFSET FROM RL\n         AR    R1,RL                    POINT TO MID-REC\n         LM    RR1,RR4,0(R1)            SAVE MID RECORD\n         MVC   0(16,R1),0(RL)           SWAP RECORDS\n         STM   RR1,RR4,0(RL)\n         LR    RI,RL                    SET I = R FOR PARTITION\n         LR    RJ,RR                    SET J = L + 1\n         AR    RJ,RICR                  PLUS 1\n         B     Q3                       GO PARTITION....\n         EJECT ,\n*---                MAIN PARTITION LOOP                            ---*\n         SPACE 1\n         CNOP  0,8                      (NOTE: FITS IN PIPLINE)\nQ6       LM    R0,R3,0(RJ)              SWAP R(I) WITH R(J)\n         MVC   0(16,RJ),0(RI)\n         STM   R0,R3,0(RI)\n         SPACE 1\nQ3       AR    RI,RICR                  TO NEXT ENTRY\n         CLC   0(16,RI),0(RL)           LESS THAN K?\n         BL    Q3                       BR IF LESS\n         SPACE 1\nQ4       SR    RJ,RICR                  TO PREV ENTRY\n         CLC   0(16,RJ),0(RL)           GREATER THAN K?\n         BH    Q4                       BR IF GREATER\n         SPACE 1\n         CLR   RJ,RI                    RJ > RI\n         BH    Q6                       BR TO SWAP K(J) WITH K(I)\n         SPACE 1\n*---               (END OF PIPELINE CODE)                          ---*\n         EJECT ,\n         MVC   0(16,RL),0(RJ)           SWAP R(L) AND R(J)\n         STM   RR1,RR4,0(RJ)\n         SPACE 1\n*---                PUT ON STACK                                   ---*\n         SPACE 1\n         LA    R0,1                     COUNT PARTITION\n         AL    R0,CNTPART\n         ST    R0,CNTPART\n         CL    RSTACK,@STACKE           HAVE SPACE ON STACK?\n         BNL   SORTERR                  BR IF OUT OF STACK SPACE\n         LR    R0,RR                    COMPUTE R-J\n         SR    R0,RJ                    TO SEE WHICH PARTITION\n         BZ    Q7LJM1                   GO SORT (L,J-1)\n         LR    R1,RJ                    IS LARGER\n         SR    R1,RL                    COMPUTE J-L\n         BZ    Q7JP1R                   GO SORT (J+1,R)\n         CR    R0,R1                    R-J :: J-L\n         BL    Q7OTHER                  OTHER WAY\n         LR    R0,RJ                    GET J+1\n         AR    R0,RICR                  J+1\n         LR    R1,RR                    (J+1,R)\n         STM   R0,R1,0(RSTACK)          PLACE ON STACK\n         LA    RSTACK,8(,RSTACK)        BUMP STACK PTR\n         LR    RR,RJ                    SET R = J - 1\n         SR    RR,RICR                  - 1\n         B     Q2                       AND CONTINUE\nQ7OTHER  LR    R0,RL                    GET (L,J-1)\n         LR    R1,RJ                    J\n         SR    R1,RICR                  -1\n         STM   R0,R1,0(RSTACK)          PLACE (L,J-1) ON STACK\n         LA    RSTACK,8(,RSTACK)\n         LR    RL,RJ                    SET L = J + 1\n         AR    RL,RICR                  J+1\n         B     Q2                       AND CONTINUE\nQ7LJM1   LR    RR,RJ                    GET RR = RJ - 1\n         SR    RR,RICR\n         B     Q2                       GO SORT (L,J-1)\nQ7JP1R   LR    RL,RJ                    GET RL = RJ + 1\n         AR    RL,RICR\n         B     Q2                       GO SORT (J+1,R)\n         SPACE 1\n*---                TAKE OFF STACK                                 ---*\nQ8       CL    RSTACK,@STACK            STACK EMPTY?\n         BE    SORTDONE                 BR IF DONE\n         SH    RSTACK,=H'8'             BACK TO LAST ENTRY\n         LM    RL,RR,0(RSTACK)          GET PREV (L,R)\n         B     Q2                       AND CONTINUE\n         EJECT ,\nSORTDONE L     R0,CNTPART\n         CVD   R0,DWD\n         MVC   L#PART(10),=X'40202020202020202120'\n         ED    L#PART(10),DWD+3\n         L     R0,@STACKH               HWM\n         SL    R0,@STACK\n         SRL   R0,3                     / STACK ENTRY LENGTH\n         CVD   R0,DWD\n         MVC   L#USED(10),=X'40202020202020202120'\n         ED    L#USED(10),DWD+3\n         WTO   MF=(E,L#MSG2)\n         SPACE 1\n         LM    R1,R3,SORTPARM           @ FIRST,LEN,@ LAST\n         SR    R1,R2                    INCLUDE DUMMY X'00' ENT\nCKLOOP   CLC   0(16,R1),16(R1)          CHECK ORDER CORRECT?\n         BH    SORTBUG                  BRANCH IF BUG\n         BXLE  R1,R2,CKLOOP             CHECK THEM ALL\n         SPACE 1\n         LM    R0,R15,REGSAVE           RESTORE REGS\n         BR    R14                      AND RETURN\n         SPACE 1\nSORTBUG  LR    RR1,R1                   SAVE PTR TO SEQ ERROR\n         WTO   'MAS002I (ESDSORT) - SORT SEQUENCE ERROR',ROUTCDE=(11)\n         EX    0,*\n         SPACE 1\nSORTERR  WTO   'MAS001I (ESDSORT) - OUT OF STACK SPACE',ROUTCDE=(11)\n         EX    0,*\n         EJECT ,\nDWD      DC    D'0'\n         SPACE 1\nREGSAVE  DC    16F'0'                   SAVE FOR CALLERS REGS\n         SPACE 1\n@CORE    DC    A(0)                     REAL BEGINING OF AREA\n@STACK   DC    A(0)                     ADDR OF STACK\n@STACKE  DC    A(0)                     STACK END + 1 STACK ENTRY\n         SPACE 1\nSORTPARM DC    4A(0)\n         SPACE 1\n@STACKH  DC    A(0)                     STACK HIGH WATER MARK\nCNTPART  DC    F'0'                     PARTITION COUNT\nL#MSG1   WTO   'MAS000I (ESDSORT) -XXXXXXXXXX ENTRIES,XXXXXXXXXX STACK +\n               ENTRIES',ROUTCDE=(11),MF=L\nL#NUM    EQU   L#MSG1+23\nL#STACK  EQU   L#MSG1+42\n         SPACE 1\nL#MSG2   WTO   'MAS001I (ESDSORT) -XXXXXXXXXX PARTITIONS,XXXXXXXXXX STA+\n               CK ENTRIES USED',ROUTCDE=(11),MF=L\nL#PART   EQU   L#MSG2+23\nL#USED   EQU   L#MSG2+45\n         SPACE 1\n         OACREGS ,\n         SPACE 1\n         END\n//*KED.SYSLMOD DD DISP=OLD,SPACE=,DSN=SYS9.MSSLOAD\n ENTRY    ESDXREF\n IDENTIFY ESDXREF('CS01044')\n NAME     ESDXREF$\n//\n//ESDXREF  EXEC PGM=ESDXREF$\n//STEPLIB  DD DISP=SHR,DSN=SYS9.MSSLOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//XREF1    DD DISP=SHR,DSN=SYS9.MSSLOAD\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEAVNP99": {"ttr": 5380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\xb5\\x00\\xb5\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 181, "newlines": 181, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMAS1  JOB  MSGCLASS=A\n/*ROUTE  PRINT  WYLBUR\n//   EXEC  ASMHCL,PARM.LKED='RENT,REFR,XREF'\n//SYSLIB  DD   DISP=SHR,DSN=SYS5.MSSMAC\n//        DD   DISP=SHR,DSN=SYS1.MACLIB\n//        DD   DISP=SHR,DSN=SYS1.AMODGEN,UNIT=3350,VOL=SER=MVSRES\n//SYSIN   DD   *\n***********************************************************************\n*\nIEAVNP99 CSECT\n*\n*  ROUTINE -\n*       IEAVNP99\n*\n*  FUNCTION -\n*       THIS ROUTINE IS CALLED DURING NIP PROCESSING TO CREATE\n*       AND INITIALIZE A UVT (USER VECTOR TABLE).\n*\n*  LINKAGE -\n*       VIA BALR FROM IEAVNIPM.\n*\n*  ATTRIBUTES -\n*       NON-REENTRANT\n*       SUPERVISOR MODE\n*       PSW KEY ZERO\n*       UNLOCKED (THUS ENABLED)\n*       SINGLE THREADED (I THINK)\n*\n*  INPUT -\n*       STANDARD NIP INTERFACE:\n*       R2  - ADDRESS OF CVT\n*       R3  - ADDRESS OF NVT\n*       R13 - STD SAVEAREA\n*       R14 - RETURN ADDRESS\n*       R15 - ENTRY POINT ADDRESS\n*\n*  NOTES -\n*       STANDARD NIP CALLING SEQUENCES FOR NIP SERVICES ARE\n*       OBSERVED.  NIP MACROS ARE NOT USED DUE TO THE GENERAL\n*       UNAVAILABILITY OF THESE MACROS.\n*\n*       THE LENGTH AND FORMAT OF THE UVT IS DEFINED BY THE MAPPING\n*       MACRO OACUVT.\n*\n*       THE UVT IS ALLOCATED IN SQA (SP 245).  THIS STORAGE IS\n*       FIXED, KEY ZERO, NON-FETCH PROTECTED, NON-V=R. THE ADDRESS\n*       THE ADDRESS OF THE UVT IS STORED INTO THE CVT USER WORD\n*       (CVTUSER).  THE UVT IS NEVER FREED AND CVTUSER IS NEVER\n*       ALTERED.\n*\n*       A ZAP TO IEAVNIPM (THE NIP RIM SCHEDULER) IS REQUIRED TO\n*       CAUSE THAT ROUTINE TO INVOKE THIS ROUTINE.  THE ORDER IN\n*       WHICH THIS ROUTINE IS INTENDED TO BE INVOKED IS TOWARD THE\n*       END OF RIM PROCESSING; THE EXACT SEQUENCE IS UNIMPORTANT.\n*       THE UVT WILL BE INITIALIZED BEFORE THE MASTER SCHEDULER\n*       (IEEMB860) IS INVOKED.\n*\n*       CURRENTLY, THIS RIM IS OPTIONAL.  THAT IS, NIP PROCESSING WILL\n*       CONTINUE IF UNABLE TO LOAD THIS ROUTINE, AND THIS ROUTINE WILL\n*       NOT REQUEST A WAIT STATE IF UNABLE TO INITIALIZE THE UVT. USERS\n*       OF THE UVT ARE THEREFORE RESPONSIBLE FOR INSURING THAT THE\n*       UVT HAS BEEN INITIALIZED (CVTUSER NON-ZERO AND UVTID = 'UVT ')\n*       BEFORE PROCEEDING.  THE CALLER IS ALSO RESPONSIBLE FOR CHECKING\n*       THAT THE CURRENT LENGTH OF THE UVT IS SUFFICIENT.\n*\n*  WRITTEN -\n*       CHRIS THOMAS\n*       OFFICE OF ACADEMIC COMPUTING, UCLA\n*       3/1/82\n*\n***********************************************************************\n         EJECT\n*\n*  ENTRY PROLOG\n*\n         B     PROLOG-IEAVNP99(,R15)\n         DC    AL1(L'MODID)\nMODID    DC    C'IEAVNP99 UVT BUILD '\nPROLOG   STM   R14,R12,12(R13)    SAVE CALLER'S REGS\n         LR    R12,R15            LOAD BASE\n         USING IEAVNP99,R12\n         LR    R14,R13            CALLER'S SAVE\n         LA    R13,SAVEAREA       MY SAVE\n         ST    R14,SAVEAREA+4     CHAIN FWD\n         ST    R13,8(,R14)        CHAIN BACK\n*\n*  STANDARD NIP REGISTERS IN USE\n*\n         USING NVT,R2\n         USING CVT,R3\n*\n*  GET SQA (SP 245) FOR UVT\n*\n         LA    R0,UVTLEN          LENGTH OF UVT\n         GETMAIN  RC,SP=245,LV=(0)\n         LTR   R15,R15            WAS STORAGE AVAILABLE\n         BNZ   ERROR1             NO. EXIT WITH ERROR MSG.\n         LA    R11,0(,R1)         CLEAR HIGH ORDER BYTE\n*\n*  INITIALIZE UVT\n*\n         USING UVT,R11\n         XC    UVT(UVTLEN),UVT    INITIALIZE TO ZERO\n         MVC   UVTID,=C'UVT '     VALIDITY CHECK/EYE CATCHER\n         LA    R1,UVTLEN          SIZE GOTTEN FOR UVT\n         ST    R1,UVTSIZE         LENGTH OF UVT FOR VALIDITY CHECKING\n*\n*  CHAIN UVT FROM CVT\n*\n         SR    R10,R10            ASSUME CVTUSER NOT IN USE\n         CS    R10,R11,CVTUSER    SWAP IF CVTUSER WAS ZERO\n         BNZ   ERROR2             IF SWAP FAILS, EXIT WITH ERROR MSG\n*\n*  ISSUE 'UVT INITIALIZED' WTO\n*\n         ST    R11,WORK\n         UNPK  MSG1ADDR(7),WORK+1    ADDR OF UVT\n         TR    MSG1ADDR,HEXTAB-X'F0' TO PRINTABLE HEX\n         MVI   MSG1ADDR+6,C' '    REMOVE JUNK\n         LA    R1,MSG1            A(TEXT)\n         L     R15,NVTWTO         A(NIP WTO ROUTINE)\n         BALR  R14,R15            CALL IT\n*\n*  EXIT LINKAGE\n*\nEXIT     L     R13,4(,R13)        RESTORE CALLER'S SAVEPTR\n         LM    R14,R12,12(R13)    RESTORE CALLER'S REGS\n         BR    R14                RETURN\n         EJECT\n*\n*  ERROR - SQA GETMAIN FAILURE\n*\nERROR1   MVC   MSG2CODE,=C'01'    MOVE ID TO WTO TEXT\n         LA    R1,MSG2            A(WTO)\n         L     R15,NVTWTO         A(NIP WTO ROUTINE)\n         BALR  R14,R15            CALL IT\n         B     EXIT               GO EXIT\n         SPACE  4\n*\n*  ERROR - CVTUSER NOT ZERO\n*\nERROR2   MVC   MSG2CODE,=C'02'    MOVE ID TO WTO TEXT\n         LA    R1,MSG2            A(WTO)\n         L     R15,NVTWTO         A(NIP WTO ROUTINE)\n         BALR  R14,R15            CALL IT\n         LA    R0,UVTLEN          LENGTH OF UVT\n         FREEMAIN RC,SP=245,LV=(0),A=(R11)\n         B     EXIT               WTO EXIT\n         SPACE  4\n*\n*  WTO MESSAGES\n*\n         SPACE\nMSG1     DC    AL2(MSG1E-MSG1,0)\n         DC    C'OAC999I UVT INITIALIZED - ADDR = XXXXXX '\nMSG1E    EQU   *\nMSG1ADDR EQU   MSG1+37,6\n         SPACE 4\nMSG2     DC    AL2(MSG2E-MSG2,0)\n         DC    C'OAC999I UVT BUILD FAILED - CODE=XX. NOTIFY SYSTEM SUPP+\n               ORT.'\nMSG2E    EQU   *\nMSG2CODE EQU   MSG2+36,2\n         EJECT\nSAVEAREA DC    18F'0'\nWORK     DC    F'0'\nHEXTAB   DC    C'0123456789ABCDEF'\n         SPACE 4\n         LTORG\n         EJECT\n         OACREGS\n         SPACE  4\nNVT      DSECT\nNVTWTO   EQU   NVT+X'FC',4\n         SPACE  4\n         OACUVT\n         SPACE  4\n         CVT   DSECT=YES,LIST=NO\n         END\n//*KED.SYSLMOD DD DISP=OLD,DSN=SYS1.AOACDLIB(IEAVNP99),\n//* UNIT=\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEFU83": {"ttr": 5384, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x02l\\x02l\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 620, "newlines": 620, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMASA JOB PCN,MSGCLASS=A,COND=(0,NE),NOTIFY=CSYSPCN\n/*ROUTE PRINT WYLBUR\n//ASM83 EXEC ASMHCL,\n//  PARM.LKED='RENT,REUS,REFER,LIST,XREF'\n//ASM.SYSLIB DD UNIT=3350,VOL=SER=MVSRES\n//           DD UNIT=3350,VOL=SER=MVSRES\n//           DD DISP=SHR,DSN=SYS5.MSSMAC\n//           DD DISP=SHR,DSN=SYS1.ACFMAC,UNIT=3350,VOL=SER=MVSRES\n//ASM.SYSIN  DD *\n         TITLE 'I E F U 8 3 --- DESCRIPTION'\n         LCLB  &TEST\n&TEST    SETB  0\nIEFU83   CSECT ,\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* MODULE: IEFU83 - SMF RECORD EXIT (SVC ENTRY)                        *\n*                                                                     *\n* FUNCTION: PERFORM OAC FUCTIONS FOR SPECIFIC RECORD TYPES            *\n*      14 - CLOSE/EOV RECORD (MOUNT ACCOUNTING)                       *\n*      15 - CLOSE/EOV RECORD (MOUNT ACCOUNTING)                       *\n*      21 - TAPE VOLUME DEMOUNTED (VOLUME ERROR STATISTICS WTO)       *\n*                                                                     *\n* RELATED ROUTINES:  IEFACTRT (SMF JOB TERMINATION EXIT)              *\n*                    IEFUJI   (SMF JOB INITIATION EXIT)               *\n*                                                                     *\n* EXTERNAL ROUTINES: GETMAIN  (TEMP AREA FOR WTO)                     *\n*                    FREEMAIN (TEMP AREA FOR WTO)                     *\n*                    WTO      (ERROR MSGS, VOLUME STATISTICS MSGS)    *\n*                                                                     *\n* ENTRY:  THIS MODULE RECEIVES CONTROL FROM IEEMB830 (SVC83/IGC0008C) *\n*       BEFORE IT WRITES EACH SMF RECORD TO THE SMF DATASET.  NOTE    *\n*       THAT THIS ROUTINE DOES NOT RECEIVE CONTROL FOR RECORDS        *\n*       FOR WHICH WRITING HAS BEEN SUPPRESSED BY THE SYSTEM SMF       *\n*       OPTIONS OR RECORDS WHICH ARE WRITTEN VIA THE SMF BRANCH       *\n*       ENTRY.                                                        *\n*   REGISTERS AT ENTRY:                                               *\n*     R1  -  @ OF (@ OF SMF RECORD RDW)                               *\n*     R13 -  @ OF 72 BYTE SAVEAREA                                    *\n*     R14 -  RETURN ADDRESS (TO IEEMB830)                             *\n*     R15 -  @ OF IEFU83                                              *\n*                                                                     *\n* EXIT:  THIS MODULE MUST RESTORE ALL REGISTERS EXCEPT FOR R15        *\n*       AND RETURN A RETURN CODE IN R15.  IN SOME CASES THE           *\n*       SMF RECORD IS MODIFIED.                                       *\n*   RETURN CODES:                                                     *\n*     0   -  WRITE SMF RECORD                                         *\n*     4   -  SUPPRESS WRITE OF SMF RECORD                             *\n*                                                                     *\n* ATTRIBUTES:  REENTRANT, KEY 0, ENABLED                              *\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*  R0  -                                                              *\n*  R1  -                                                              *\n*  R2  -                                                              *\n*  R3  -                                                              *\n*  R4  -                                                              *\n*  R5  -                                                              *\n*  R6  - @ SMF RECORD (IF ANY)                                        *\n*  R7  - PRELIMINARY RETURN CODE (0 OR 4)                             *\n*  R8  -                                                              *\n*  R9  -                                                              *\n*  R10 - INTERNAL LINKAGE                                             *\n*  R11 - @ W# OR ZERO (IF NONE)                                       *\n*  R12 - @ IEFU83 (PROGRAM BASE)                                      *\n*  R13 - @ ORIG SAVEAREA OR @ W#SAVE                                  *\n*  R14 -                                                              *\n*  R15 -                                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         TITLE 'I E F U 8 3  ---  SMF TYPE 83 EXIT'\n         OACUSING PSA,R0\nIEFU83   CSECT\n         STM   R14,R12,12(R13)    SAVE CALLERS'S REGS\n         LR    R12,R15            SET BASE REGISTER\n         OACUSING IEFU83,R12\n         SR    R11,R11            NO W# AREA\n         SR    R7,R7              ASSUME WRITE RECORD\n         SPACE 1\n*  ----  EXTRACT/TEST SMF RECORD ADDRESS\n         SPACE 1\n         ICM   R6,B'1111',0(R1)   GET/TEST SMF RECORD RDW ADDR\n         BZ    EXIT               BIF NO ADDR - RETURN TO WRITE RECORD\n         OACUSING SMF,R6          (SMF RECORD)\n         SPACE 1\n*  ----  CHECK FOR AND PROCESS ONLY TYPE 14 AND TYPE 15 RECORDS.\n         SPACE 1\n         CLI   SMF14RTY,14        TYPE 14 RECORD?\n         BE    R14$               BIF TYPE 14 RECORD (MOUNT ACCOUNTING)\n         CLI   SMF14RTY,15        TYPE 15 RECORD?\n         BE    R15$               BIF TYPE 15 RECORD (MOUNT ACCOUNTING)\n         CLI   SMF14RTY,21        TYPE 21 RECORD?\n         BE    R21$               BIF TYPE 21 RECORD (TAPE ERR STATS)\n         CLI   SMF14RTY,222       TYPE 222 RECORD?\n         BE    R222$\nEXIT     LTR   R11,R11            ALREADY HAVE W# AREA?\n         BZ    EXIT1              RIF NO W# AREA TO FREE\n         L     R13,4(,R13)        UNCHAIN SAVE AREAS\n         LA    R0,W#L             LENGTH OF W# AREA\n         FREEMAIN R,LV=(0),A=(R11) FREE STORAGE FOR W#\nEXIT1    LR    R15,R7             RETURN CODE (0 OR 4)\n         L     R14,12(,R13)        RESTORE RETURN ADDRESS\n         LM    R0,R12,12+8(R13)     AND OTHER REGS\n         BR    R14                   RETURN TO WRITE/DISCARD RECORD\n         TITLE 'I E F U 8 3  ---  TYPE 14/15 - MOUNT ACCOUNTING'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   TYPE 14 / 15 RECORDS (CLOSE / EOV RECORDS)                        *\n*                                                                     *\n*    - MOUNT ACCOUNTING FOR TAPE                                      *\n*    - MOUNT ACCOUNTING FOR 3330 MOD1 (NON PERMANENTLY RESIDENT ONLY) *\n*                                                                     *\n* OPTIONS:   SUPPRESS VIO AND PERMANENTLY RESIDENT DASD RECORDS       *\n*            SUPPRESS NON-MOUNT CHARGED RECORDS                       *\n*            SUPPRESS ALL RECORDS (14 OR 15)                          *\n*                                                                     *\n*   IT IS ASSUMED THAT THE MOUNT COUNTS ARE WRITTEN IN SOME           *\n*   OTHER RECORD WHEN THE SUPPRESS ALL OPTIONS IS SELECTED.           *\n*                                                                     *\n*       FLAGS ARE SET/CLEARED IN THE HIGH BYTE OF 'SMF14NEX'          *\n*         (NUMBER OF EXTENTS IN EACH UCB ENTRY)                       *\n*         X'80' - PERMANENTLY RESIDENT DRIVE                          *\n*         X'40' - THIS UCB ENTRY COUNTED AS A MOUNT (BY IEFU83)       *\n*                                                                     *\n* 'SMF14UID' USED AS FOOTPRINT FOR ERRORS                             *\n*    - CLEARED TO ZEROS AT ENTRY                                      *\n*    - CODES/FLAGS SET TO TRACK PROGRAM PATHS                         *\n*     +0 - ERROR INDICATOR                                            *\n*          X'01' - NO UCB SEGMENTS IN RECORD                          *\n*          X'02' - UNABLE TO MAP CUU -> UCB ADDRESS                   *\n*          X'03' - UNABLE TO FIND MOUNT WORK AREA                     *\n*     +1 - FLAGS                                                      *\n*          X'80' - TABLE OVERFLOW                                     *\n*          X'01' - MOUNT EXISTS IN RECORD                             *\n*                                                                     *\n*         (SEP MOUNT COUNTS FOR TAPE/DISK - DIFFERENT CHARGES)        *\n*         (MOUNTS ARE ONLY OVER JOB -                                 *\n*            SAME VOLUME ON SAME DEVICE IS 1 MOUNT EVEN IN            *\n*            DIFFERENT STEPS)                                         *\n*                                                                     *\n*       FOLLOWING SEQUENCE:                                           *\n*         VOLUME A ON UNIT 1   (COUNTS AS 1 MOUNT)                    *\n*         VOLUME A ON UNIT 2   (COUNTS AS 1 MOUNT)                    *\n*         VOLUME A ON UNIT 1   (DOES THIS COUNT??? - YES)             *\n*         (WHEN VOLUME SEEN MUST SEARCH ALL UNITS AND                 *\n*          DELETE FROM ANY IT'S ON SO WILL BE MOUNT NEXT TIME)        *\n*         (UNLESS ON SAME UNIT AS LAST TIME...)                       *\n*                                                                     *\n*   ----- SERIALIZATION OF MOUNT WORK AREA:                           *\n*      BEFORE AND AFTER THE JOB-STEP STARTS, ONLY THE INITIATOR       *\n*      IS RUNNING.                                                    *\n*                                                                     *\n*      DURING THE JOB-STEP - ALWAYS USE CDS OR CS                     *\n*                                                                     *\n*                                                                     *\n*   ... DON'T SAVE DEVICE ADDRESSES (USE UCB ADDRESSES)               *\n*       - DEVICE ADDRESS IS LAST PATH STARTED...                      *\n*       - DEVICE ADDRESS WILL CHANGE IF DDR SWAP DONE...              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*  LOGIC                                                              *\n*   - RETURN CODE = SUPPRESS RECORD                                   *\n*   - SCAN EXENTS (FOR EACH UCB EXTENT)                               *\n*      - CLEAR X'C0' FLAGS IN SMF14NEX                                *\n*      - IF UNIT ADDRESS = X'0FFF' (VIO) THEN SKIP                    *\n*      - COMPUTE UCB ADDRESS FROM DEVICE ADDRESS                      *\n*          - (NOT FOUND? -> SET RETURN CODE = WRITE RECORD??)         *\n*      - IF DEVICE TYPE = DASD THEN                                   *\n*            SET X'80' FLAG IF PERM RES                               *\n*            TO NEXT SLOT (NON-MOUNT)                                 *\n*      - FIND MOUNT WORK AREA (OACJSUVT/OACACTWK)                     *\n*            (IF NOT FOUND SET RETURN CODE = WRITE RECORD, EXIT)      *\n*            (WTO ??? OR DEFINE NEW BITS ???)                         *\n*      - SCAN MOUNT TABLE FOR VOLUME MATCH                            *\n*         IF MATCH & UNIT MATCHES -> NO MOUNT.                        *\n*         ELSE CLEAR VOLUME                                           *\n*      - SCAN MOUNT TABLE FOR UNIT MATCH                              *\n*         IF MATCH REPLACE VOLUME;                                    *\n*            UPDATE MOUNT COUNT (TAPE/DASD);                          *\n*            SET UCB ENTRY FLAG FOR MOUNT (X'40');                    *\n*            TO NEXT ENTRY.                                           *\n*      - SCAN MOUNT TABLE FOR 0 UNIT                                  *\n*         IF MATCH SET UCB ADDRESS / VOLUME SER;                      *\n*            COUNT MOUNT;                                             *\n*            SET UCB ENTRY FLAG FOR MOUNT (X'40');                    *\n*            TO NEXT ENTRY;                                           *\n*      - SET OVERFLOW; NO MOUNT; (??)                                 *\n*      - IF MOUNT THEN SET X'40' FLAG IN ENTRY;                       *\n*        SET RETURN CODE = WRITE RECORD                               *\n*      - ON TO NEXT ENTRY                                             *\n*        (RETURN FROM IEFU83)                                         *\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*  R0  -                                                              *\n*  R1  -                                                              *\n*  R2  - CDS (1ST 4 CHARS OF VOLSER)                                  *\n*  R3  - CDS (LAST 2 CHARS OF VOLSER/UCB ADDRESS)                     *\n*  R4  - # OF UCB ENTRIES LEFT TO PROCESS                             *\n*  R5  - @ CURRENT UCB ENTRY IN SMF RECORD                            *\n*  R6  - @ SMF RECORD (IF ANY)                                        *\n*  R7  - PRELIMINARY RETURN CODE (0 OR 4) (OR ERROR CODE?)            *\n*  R8  -                                                              *\n*  R9  - @ MOUNT AREA IN OACACTWK (OR ZERO)                           *\n*  R10 - INTERNAL LINKAGE                                             *\n*  R11 - @ W# OR ZERO (IF NONE)                                       *\n*  R12 - @ IEFU83 (PROGRAM BASE)                                      *\n*  R13 - @ ORIG SAVEAREA OR @ W#SAVE                                  *\n*  R14 - WORK (CDS)                                                   *\n*  R15 - WORK (CDS)                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         OACINUSE ,\nR14$     DC    0H'0'\nR15$     DC    0H'0'\n         XC    SMF14UID,SMF14UID  CLEAR FOOTPRINT\n         SR    R9,R9              NO OACACTWK MOUNT AREA YET\n         LA    R7,4               ASSUME SUPPRESS RECORD\n         SR    R5,R5              CLEAR FOR IC\n         IC    R5,SMF14SDC        LENGTH OF DEB/DCB SECTION (CUR CONST)\n         LA    R5,SMFDCBDE(R5)    @ 1ST UCB ENTRY\n         SR    R0,R0              CLEAR FOR IC\n         IC    R0,SMF14SUC        GET UCB SEGMENT SIZE\n         SR    R4,R4              CLEAR FOR ICM\n         ICM   R4,B'0001',SMF14NUC NUMBER OF UCB SEGMENTS\n         BNZ   R14$ULP            BIF AT LEAST ONE UCB SEGMENT\n         MVI   SMF14UID,X'01'     SET SYMPTOM CODE\nR14$WRT  SR    R7,R7              FORCE RECORD WRITE\n         B     EXIT                AND EXIT IEFU83\n         SPACE 1\n         OACUSING SMF14UCB,R5\nR14$ULP  NI    SMF14NEX,255-X'C0' CLEAR RES, MOUNT FLAGS\n         CLC   SMFUCBCH(2),=X'0FFF'  VIO ADDRESS?\n         BE    R14$LNXT           BIF VIO, SKIP THIS UCB\n         CLI   SMFUCBTY+UCBTBYT3-UCBTYP,UCB3DACC DASD DEVICE?\n         BNE   R14$NDA            BIF NOT DASD\n         CLI   SMFUCBTY+UCBTBYT4-UCBTYP,X'09' 3330 MOD 1?\n         BNE   R14$LNXT           BIF NOT 3330 MOD1, SKIP THIS UCB\n         SPACE 1\n*---             CONVERT DEVICE ADDRESS INTO UCB ADDRESS           ---*\nR14$NDA  L     R14,CVTPTR         GET CVT PNTR\n         OACUSING CVTMAP,R14\n         L     R15,CVTIXAVL       @ IOS COMMUNICATIONS AREA\n         OACUSING IOCOM,R15\n         LH    R2,SMFUCBCH        CUU FOR DEVICE\n         L     R1,IOCOMEX         @ IOS COMMUNICATIONS EXTENSION\n         OACUSING IOX,R1\n         CLM   R2,B'0010',IOXHICH VALID CHANNEL?\n         BH    R14$UCBB           BIF INVALID CHANNEL, BAD DEV ADDR\n         OACDROP R1\n         SRDL  R2,3               LOW 3 BITS OF DEVICE ADDR\n         SRL   R3,29               TO LOW 3 BITS OF R3\n         A     R2,IOCUCBBM        + @ IOS UNIT BIT MAP\n         OACDROP R15\n         LA    R15,X'80'          BIT FOR TEST\n         SRL   R15,0(R3)          GET BIT TO TEST\n         IC    R3,0(,R2)          GET BYTE CONTAINING BIT TO TEST\n         NR    R15,R3             TEST IF VALID UNIT ADDRESS\n         BZ    R14$UCBB           BIF INVALID UNIT ADDRESS\n         XR    R2,R2              CLEAR FOR IC\n         XR    R3,R3              CLEAR FOR IC\n         L     R1,CVTILK1         CHAN/CNTL UNIT LOOKUP TABLE\n         IC    R2,SMFUCBCH        GET CHANNEL/THIS DEVICE\n         IC    R2,0(R2,R1)        GET CHANNEL INDEX PORTION\n         IC    R3,SMFUCBUA        GET CONTROL UNIT/DEVICE NIBBLES\n         SRL   R3,4               ISOLATE CONTROL UNIT\n         ALR   R2,R3              CHANNEL CONSTANT PLUS CONTROL UNIT\n         ALR   R2,R2              2 * (C.U. + CHANNEL CONSTANT)\n         ALR   R2,R1              POINT TO C.U. INDEX\n         ICM   R2,B'0011',0(R2)   GET CONTROL UNIT INDEX\n         IC    R3,SMFUCBUA        UNIT/DEVICE AGAIN\n         N     R3,=XL4'0000000F'  ISOLATE DEVICE ADDR\n         ALR   R2,R3              C.U. INDEX PLUS DEV. ADDR\n         ALR   R2,R2              NOW TIMES TWO\n         AL    R2,CVTILK2         PLUS HALFWORD TABLE ADDR\n         ICM   R3,B'0011',0(R2)   GET UCB ADDRESS\n         BZ    R14$UCBB            BIF CAN'T FIND UCB\n         CLM   R3,B'0011',=X'FFFF' NULL UCB PTR\n         BE    R14$UCBB            BIF CAN'T FIND UCB\n         CLI   UCBID-UCB(R3),X'FF' LOOK LIKE REAL UCB?\n         BE    R14$UCBG            BIF GOOD UCB\n         OACDROP R14\nR14$UCBB MVI   SMF14UID,X'02'      SYMPTOM CODE (BAD UCB)\n         B     R14$WRT              FORCE RECORD WRITE, EXIT\nR14$UCBG TM    UCBSTAT-UCB(R3),UCBPRES PERMANENTLY RESIDENT?\n         BZ    R14$MT             BIF NOT PERM RES, FIND MOUNT AREA\n         OI    SMF14NEX,X'80'     SET OAC FLAG/SAY PERM. RES. 3330\n         B     R14$LNXT             AND SKIP THIS UCB/ENTRY\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*   FIND THE MOUNT ACCOUNTING AREA --                                 *\n*     IF TCBUSER \u00ac= 0 (AND POINTS TO OACJSUVT)                        *\n*        IF OACJSUVT (MOUNT SLOT) \u00ac= 0 (AND POINTS TO OACMNTWK)       *\n*           THEN AREA FOUND, ELSE TRY NEXT HIGHER TASK. (TCBOTC)      *\n*                                                                     *\n*    SINCE THE MOUNT ACCOUNTING AREA IS BUILD FROM IEFUJI             *\n*    (JOB INITIATION SMF EXIT) THE INITIATOR TASK WILL BE             *\n*    THE ONLY TCB WITH A TCBUSER/OACJSUVT WHICH CONTAINS              *\n*    A MOUNT AREA.  IF NO MOUNT AREA IS FOUND AFTER ALL               *\n*    POSSIBLE TASKS HAVE BEEN SEARCHED THEN EXIT IEFU83.              *\n*    (SKIP MOUNT ACCOUNTING SINCE IEFUJI NEVER RAN FOR THIS           *\n*     JOB)                                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         OACINUSE ,\nR14$MT   LTR   R9,R9              ALREADY HAVE OACACTWK MOUNT AREA?\n         BNZ   R14$MTFD           BIF ALREADY HAVE AREA\n         L     R1,PSATOLD         @ CURRENT TCB\n         OACUSING TCB,R1\nR14$MTLP DC    0H'0'\n         AIF   (&TEST).A1\n         ICM   R9,15,TCBUSER      ANY OACJSUVT HERE?\n         AGO   .A2\n.A1      L     R9,TCBFSA          @ FSA FOR TESTING\n         ICM   R9,15,0(R9)        FAKE TCBUSER IN 1ST WORD OF FSA\n.A2      BZ    R14$MTNX           BIF NO OACJSUVT, TRY HIGHER TASK\n         OACUSING OACJSUVT,R9\n         CLC   JSUVTID,=CL8'OACJSUVT' REALLY OACJSUVT?\n         BNE   R14$MTNX           BIF NOT OACJSUVT, TRY HIGHER TASK\n         CLC   JSUVTLEN,=AL3(JSUVTACT+L'JSUVTACT-OACJSUVT) LENGTH OK?\n         BL    R14$MTNX           BIF FIELD MISSING, TRY HIGHER TASK\n         ICM   R9,15,JSUVTACT     @ OACACTWK\n         OACDROP R9\n         BZ    R14$MTNX           BIF NO OACACTWK, TRY HIGHER TASK\n         OACUSING OACACTWK,R9\n         CLC   ACTPID,=CL8'OACACTWK' REALLY OACACTWK?\n         BNE   R14$MTNX           BIF NOT OACACTWK, TRY HIGHER TASK\n         ICM   R0,15,ACTPMTL      ANY MOUNT AREA?\n         BZ    R14$MTNX           BIF NO MOUNT AREA, TRY HIGHER TASK\n         ICM   R9,15,ACTPMTA      @ MOUNT AREA\n         OACDROP R9\n         BNZ   R14$MTFD           BIF HAVE MOUNT AREA\nR14$MTNX ICM   R1,15,TCBOTC       @ PARENT TASK\n         BNZ   R14$MTLP           BIF PARENT EXISTS, CONTINUE SEARCH\n         MVI   SMF14UID,X'03'     SYMPTOM CODE (NO MOUNT AREA)\n         B     R14$WRT             FORCE RECORD WRITE, EXIT\n         OACDROP R1\n         OACUSING ACTMT,R9\nR14$MTFD DC    0H'0'\n         EJECT ,\n         OACINUSE ,\n*--- FORCE WRITE OF ALL RECORDS WHICH ARE TAPE OR NON-RES DASD     ---*\n         SR    R7,R7              FORCE WRITE\n         SPACE 1\n*---       SCAN MOUNT TABLE FOR THIS VOLUME                        ---*\nR14$SCVL ICM   R2,B'1111',SMFSRTEV   1ST 4 CHARS OF VOLSER\n         ICM   R3,B'1100',SMFSRTEV+4 LAST 2 CHARS (& HAVE UCB ADDR)\n         BAL   R10,R14$SCN        SCAN MOUNT TABLE\n         BNP   R14$SCUT           BIF VOLUME UNKNOWN, SEARCH FOR UNIT\n         OACUSING ACTMTE,R1\n         LM    R14,R15,ACTMTE     GET ENTRY FOR COMPARE\n         CLR   R2,R14             SAME VOLUME?\n         BNE   R14$SCNN           BIF NOT SAME VOLUME, CONTINUE SCAN\n         CLR   R3,R15             SAME VOLUME & UNIT?\n         BE    R14$LNXT           BIF BOTH SAME VOL & UNIT, NOT MOUNT\n         LR    R14,R15            COPY LAST PART OF VOL/UCB ADDR\n         XR    R14,R3             COMPARE LAST PARTS OF VOLUMES\n         N     R14,=X'FFFF0000'   JUST SAME VOLUME?\n         BNE   R14$SCNN           BIF NOT SAME VOLUME, CONTINUE SCAN\n         LR    R0,R3              SAVE MY UCB ADDR & PART OF VOLSER\n         SR    R14,R14            CLEAR TO CLEAR ENTRY EXCEPT FOR\n         N     R15,=X'0000FFFF'     UCB ADDRESS\n         N     R3,=X'FFFF0000'    ZERO OUT UCB ADDR HERE\n         OR    R3,R15             ADD HIS UCB ADDR TO COMPARAND\n         CDS   R2,R14,ACTMTE      DISMOUNT THIS VOLUME\n         LR    R3,R0              RESTORE UCB ADDR AND PART OF VOLSER\n         BNE   R14$SCVL           BIF CHANGED, RETRY SEARCH\n         OACDROP R1\n         SPACE 1\n*---       SCAN MOUNT TABLE FOR UNIT (UCB ADDRESS)                 ---*\nR14$SCUT BAL   R10,R14$SCN        SCAN MOUNT TABLE\n         BNP   R14$SCEE           BIF NEW UNIT, SCAN FOR EMPTY ENTRY\n         OACUSING ACTMTE,R1\n         CLM   R3,B'0011',ACTMTEUA SAME UNIT (UCB ADDRESS)?\n         BNE   R14$SCNN           BIF NOT SAME UNIT, CONTINUE SCAN\n         LM    R14,R15,ACTMTE     GET CURRENT CONTENTS\n         LR    R0,R3              COPY UCB ADDR\n         N     R0,=X'0000FFFF'     ONLY WANT UCB ADDRESS\n         N     R15,=X'FFFF0000'     AND LAST 2 CHARS OF VOLUME\n         OR    R15,R0             CURRENT VOLUME/MY UCB ADDRESS\n         CDS   R14,R2,ACTMTE      SET NEW VOLUME & OLD UNIT\n         BNE   R14$SCN            BIF CHANGED, RETRY SEARCH\n         OACDROP R1\n*---       COUNT THIS MOUNT (TAPE/DASD)                            ---*\nR14$MNT  LA    R1,ACTMTCTP        ASSUME TAPE\n         CLI   SMFUCBTY+UCBTBYT3-UCBTYP,UCB3DACC DASD DEVICE?\n         BNE   *+8\n         LA    R1,ACTMTCDA        ELSE DASD\n         L     R14,0(,R1)         GET CURRENT MOUNT COUNT\nR14$MTCT LA    R15,1              INCR COUNT BY 1\n         ALR   R15,R14            NEW COUNT\n         CS    R14,R15,0(R1)      SWAP NEW FOR OLD\n         BNE   R14$MTCT           BIF CHANGED, RETRY COUNT INCR\n         OI    SMF14NEX,X'40'     SET MOUNT CHARGED\n         OI    SMF14UID+1,X'01'   FLAG RECORD TOO\n         SR    R7,R7              FORCE RECORD WRITE\n         B     R14$LNXT            AND ON TO NEXT ENTRY\n         SPACE 1\n*---       FIND EMPTY MOUNT ENTRY (FOR NEW UNIT)                   ---*\nR14$SCEE SR    R14,R14            ZERO FOR UNIT COMPARE\n         SR    R15,R15             ZERO FOR CDS\n         BAL   R10,R14$SCN        SCAN MOUNT TABLE\n         BNP   R14$SOV\n         OACUSING ACTMTE,R1\n         CL    R14,ACTMTE         ZERO ENTRY? (EMPTY ENTRY?)\n         BNE   R14$SCNN           BIF NOT SAME UNIT, CONTINUE SCAN\n         CL    R15,ACTMTE+4       ZERO ENTRY? (EMPTY ENTRY?)\n         BNE   R14$SCNN           BIF NOT SAME UNIT, CONTINUE SCAN\n         CDS   R14,R2,ACTMTE      SET NEW VOLUME & OLD UNIT\n         BNE   R14$SCN            BIF CHANGED, RETRY SEARCH\n         B     R14$MNT            GO COUNT MOUNT\n         OACDROP R1\n         SPACE 1\n*---         TABLE OVERFLOW - SET OVERFLOW FLAG                    ---*\nR14$SOV  OI    SMF14UID+1,X'80'   FLAG OVERFLOW IN RECORD\n         SR    R7,R7              FORCE RECORD WRITE\n         L     R14,ACTMTF\nR14$SOV1 LR    R15,R14\n         O     R15,=AL1(ACTMTFO,0,0,0) SET OVERFLOW FLAG\n         CS    R14,R15,ACTMTF     SET FLAG\n         BNE   R14$SOV1           BIF CHANGED, RETRY\n         SPACE 1\n         OACDROP R5\nR14$LNXT SR    R0,R0\n         IC    R0,SMF14SUC        SIZE OF UCB SEGMENTS\n         ALR   R5,R0              @ NEXT UCB SEGMENT (IF MORE EXIST)\n         BCT   R4,R14$ULP         PROCESS ALL UCB SEGMENTS\n         B     EXIT                AND THEN EXIT\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* R14$SCN/R14$SCNN - SCAN MOUNT TABLE ROUTINE                         *\n*                                                                     *\n* ENTRY/EXIT:  R0   - COUNT OF SLOTS LEFT TO SCAN                     *\n*              R1   - @ OF SLOT                                       *\n*              R10  - RETURN ADDRESS                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nR14$SCN  LH    R0,ACTMTSLN        # OF SLOTS\n         LA    R1,ACTMTE-ACTMTEL  @ 1ST ENTRY - 1 ENTRY LENGTH\nR14$SCNN LTR   R0,R0              ANY SLOTS LEFT?\n         BZR   R10                RIF NO SLOTS LEFT, CC ZERO\n         BCTR  R0,0               DCR ENTRYS LEFT\n         LA    R1,ACTMTEL(,R1)    @ OF ENTRY\n         BR    R10                RETURN, CC POSITIVE\n         OACDROP R9\n         TITLE 'I E F U 8 3  ---  TYPE 21 - ERROR STATISTICS BY VOLUME'\n*---------------------------------------------------------------------*\n*                                                                     *\n*  RECORD TYPE 21 - ERROR STATISTICS BY VOLUME                        *\n*       TAPE ERROR STATISTICS (FROM TYPE 21 RECORD)                   *\n*   (OLD MVT IEC209I MSG)                                             *\n*   JJJJJJJ VVVVVV CUU TR=NNN,TW=NNN,EG=NNN,CL=NNN,N=000,SIO=00000    *\n*    . GETMAIN WORK AREA (SAVEAREA, WTO AREA)                         *\n*      (IF GETMAIN FAILS, EXIT -> WRITE RECORD)                       *\n*    . BUILD/ISSUE WTO                                                *\n*    . FREE WORK AREA                                                 *\n*    . EXIT FROM IEFU83, (WRITE RECORD FOR NOW)                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         OACINUSE ,\nR21$     BAL   R10,G$SAVE         GET W# AREA\n         BNZ   EXIT               BIF NO STORAGE, SKIP WTO\n         OACUSING W#,R11\n         XC    W#WTO(L'W#WTO),W#WTO INIT WTO TO ALL ZEROS\n         MVC   W#WTO+WTO#21V(6),SMF21VOL\n         UNPK  W#WTO+WTO#21CU(4),SMF21CA(3)\n         TR    W#WTO+WTO#21CU(3),HEX\n         MVI   W#WTO+WTO#21CU+3,C' '\n         SR    R0,R0\n         IC    R0,SMF21TR\n         CVD   R0,W#DWD\n         UNPK  W#WTO+WTO#21TR(3),W#DWD+6(2)\n         IC    R0,SMF21TW\n         CVD   R0,W#DWD\n         UNPK  W#WTO+WTO#21TW(3),W#DWD+6(2)\n         IC    R0,SMF21NB\n         CVD   R0,W#DWD\n         UNPK  W#WTO+WTO#21NB(3),W#DWD+5(3)\n         ICM   R0,B'0011',SMF21ERG\n         CVD   R0,W#DWD\n         UNPK  W#WTO+WTO#21EG(5),W#DWD+5(3)\n         ICM   R0,B'0011',SMF21CLN\n         CVD   R0,W#DWD\n         UNPK  W#WTO+WTO#21CL(5),W#DWD+5(3)\n         ICM   R0,B'0011',SMF21SIO\n         CVD   R0,W#DWD\n         UNPK  W#WTO+WTO#21IO(5),W#DWD+5(3)\n         OC    W#WTO(WTO#21L),WTO#21 REST OF WTO + FIX ZONES\n         WTO   MF=(E,W#WTO)       ISSUE WTO\n         LA    R7,0               WRITE SMF RECORD\n         B     EXIT\n         OACDROP R11\n         TITLE 'I E F U 8 3  ---  TYPE 222 - ACF LID ALTERATION LOG   '\n*---------------------------------------------------------------------*\n*                                                                     *\n*  RECORD TYPE 222 - ACF LID ALTERATION LOG                           *\n*       CHECK FOR JOBNAME CSYSPCNF                                    *\n*         IF NOT EQUAL EXIT WITH PREMISSION TO WRITE                  *\n*         IF FUNCTION IS NOT REPLACE, EXIT WITH PERMISSION TO WRITE   *\n*         IF = CHECK KEY TO SEE IF TRYING TO ALTER A CIS OR CSYS      *\n*             IF SO EXIT WITH PERMISSION TO WRITE                     *\n*             IF NOT, DENY PERMISSION TO WRITE                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         OACINUSE ,\nR222$    CLC   ACLMFJBN-ACFSMFL(8,R6),=CL8'CACPAPG#'\n         BNE   R222$WT\n         CLI   ACLMFCN-ACFSMFL(R6),ACLMFREP A REPLACE REQUEST?\n         BNE   R222$WT            IF NOT, GIVE PERMISSION TO WRITE\n         CLC   ACLMFKEY-ACFSMFL(3,R6),=CL3'CIS' IS IT CIS\n         BE    R222$WT            IF SO WRITE IT\n         CLC   ACLMFKEY-ACFSMFL(4,R6),=CL4'CSYS'\n         BE    R222$WT            IF SO WRITE IT\n         LA    R7,4               DENY PERMISSION TO WRITE\n         B     EXIT1\nR222$WT  SR    R7,R7              GIVE PERMISSION TO WRITE\n         B     EXIT1\n         TITLE 'I E F U 8 3  ---  G$SAVE - WORK AREA GETMAIN RTN'\n*---------------------------------------------------------------------*\n*                                                                     *\n* G$SAVE - GET SAVE / WORK AREA (IF DON'T ALREADY HAVE ONE)           *\n*                                                                     *\n* ENTRY:  R10 - RETURN ADDRESS                                        *\n*         R11 - @ W# OR ZERO IF NONE EXISTS                           *\n*         R12 - @ IEFUJI (PROGRAM BASE)                               *\n*         R13 - @ OS SAVE AREA (ORIG OR W#)                           *\n*                                                                     *\n* EXIT:   R15 - RETURN CODE                                           *\n*               0 - SUCCESS, \u00ac0 - FAILED (CONDITION CODE SET)         *\n*         R11 - @ W#                              (ONLY IF RC = 0)    *\n*         R13 - @ W#SAVE (AND SAVE AREAS CHAINED) (ONLY IF RC = 0)    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         OACINUSE ,\nG$SAVE   LTR   R11,R11            ALREADY HAVE W# AREA?\n         BNZ   G$SAVEZ            RIF HAVE W# AREA, RETURN CODE 0\n         LA    R0,W#L             LENGTH OF W# AREA\n         GETMAIN RC,LV=(0)        GET STORAGE FOR W#\n         LTR   R15,R15            TEST GETMAIN RETURN CODE\n         BNZR  R10                RIF GETMAIN FAILED, RETURN NO STORAGE\n         LA    R11,0(,R1)         CLEAR HIGH BYTE, SET R11 = @ W#\n         ST    R13,4(,R11)        LINK W#SAVE TO ORIG SAVEAREA\n         ST    R11,8(,R13)         AND ORIG TO W#SAVE\n         LR    R13,R11            USE W#SAVE AS SAVE AREA NOW\nG$SAVEZ  SR    R15,R15            RETURN CODE ZERO\n         BR    R10                 AND RETURN\n         TITLE 'I E F U 8 3  ---  CONSTANTS / MESSAGES / WORKAREA'\n*                       VVVVVV CUU\nWTO#21   WTO   'OAC209I            TR=000,TW=000,EG=00000,CL=00000,N=00X\n               0,SIO=00000',MF=L,ROUTCDE=(11)\nWTO#21L  EQU   *-WTO#21\nWTO#21V  EQU   4+8\nWTO#21CU EQU   4+15\nWTO#21TR EQU   4+22\nWTO#21TW EQU   4+29\nWTO#21EG EQU   4+36\nWTO#21CL EQU   4+45\nWTO#21NB EQU   4+53\nWTO#21IO EQU   4+61\n         SPACE 1\nHEX      EQU   *-C'0'\n         DC    C'0123456789ABCDEF'\n         SPACE 1\n         LTORG ,\n         SPACE 2\nW#       DSECT ,\nW#SAVE   DC    9D'0'\nW#DWD    DC    D'0'\nW#WTO    DC    CL133' '\n         DC    0D'0'\nW#L      EQU   *-W#\n         SPACE 2\n         TITLE 'I E F U 8 3  ---  OAC DSECTS'\n         OACJSUVT ,\nIEFU83   CSECT\n         OACACTWK ,\n         OACREGS ,\n         TITLE 'I E F U 8 3  ---  SYSTEM DSECTS'\n         PRINT NOGEN\n         IHAPSA ,\n         CVT   DSECT=YES\n         IKJTCB ,\nUCB      DSECT\n         IEFUCBOB ,\n         IECDIOCM ,\n         IECDIOCX ,\n         PRINT GEN\n         TITLE 'I E F U 8 3  ---  SMF RECORD DSECT'\nSMF      DSECT\n         IFASMFR 14\n         ORG   SMF\n         IFASMFR 21\n         TITLE 'I E F U 8 3  --- ACF2 DSECTS'\n         ACFSMFL\n         LIDREC\n         END\n//*KED.SYSLMOD DD DISP=SHR,DSN=SYS1.AOACDLIB,SPACE=,\n//* UNIT=3350,VOL=SER=MVSCAT\n//LKED.SYSIN   DD *\n    IDENTIFY IEFU83('SM01368')\n    ENTRY IEFU83\n    NAME IEFU83(R)\n//*\n//C   EXEC PGM=COMPARE,PARM='IEFU83$,IEFU83'\n//STEPLIB  DD DISP=SHR,DSN=SYS5.MSSLOAD\n//SYSPRINT DD SYSOUT=*\n//I1       DD DISP=(SHR,PASS),DSN=&&GOSET\n//I2       DD DISP=SHR,DSN=SYS1.AOACDLIB\n//*\n//C   EXEC PGM=COMPARE,PARM='IEFU83$(IEFU83),IEFU83(IEFU83)'\n//STEPLIB  DD DISP=SHR,DSN=SYS5.MSSLOAD\n//SYSPRINT DD SYSOUT=*\n//I1       DD DISP=(SHR,PASS),DSN=&&GOSET\n//I2       DD DISP=SHR,DSN=SYS1.LPALIB,UNIT=3350,VOL=SER=MVSRES\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IXTOFMT5": {"ttr": 5639, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x01R\\x01R\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 338, "newlines": 338, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMAS1  JOB  1,MSGCLASS=A\n/*ROUTE PRINT WYLBUR\n//  EXEC  ASMHCL,PARM.LKED='LIST,MAP'\n//SYSIN DD *\n         TITLE 'IXTOFMT5 -- INDEXED VTOC FORMAT-5 INTERFACE'\n***********************************************************************\n*\nIXTOFMT5 CSECT\n*\n*  THIS ROUTINE USES THE CVAF SERVICE ROUTINES TO CONVERT THE\n*  FREE SPACE BIT MAP OF AN INDEXED VTOC INTO PSUEDO FORMAT-5\n*  DSCBS.  THIS PROVIDES A COMPATIBILITY INTERFACE FUNCTION FOR\n*  PRE-DFDS ROUTINES WHICH EXAMINE FORMAT-5 DSCBS.\n*\n*  THIS ROUTINE IS CALLED ONCE FOR EACH FORMAT-5 WHICH MUST BE\n*  BUILT.  THE INDEX RECORD BUFFER RETURNED BY CVAF IS SAVED SO\n*  THAT NO ADDITIONAL I/O NEED BE DONE FOR SUCCEEDING CALLS.  THE\n*  BUFFERS ARE FREED WHEN THE LAST FORMAT-5 DSCB IS RETURNED.\n*  HENCE, THIS ROUTINE SHOULD BE CALLED UNTIL A FORMAT-5 DSCB WITH\n*  DS5PTRDS EQUAL TO ZERO IS RETURNED.  THE NON-ZERO VALUE IN\n*  DS5PTRDS WILL ALWAYS BE C'00001'.  NO ENQUEUE ON THE VTOC IS\n*  PERFORMED.\n*\n*  INPUT:    R1 -->  (PARMLIST)\n*                    A(WORD) -- ADDR OF A FULLWORD USED BY THIS\n*                               ROUTINE.  MUST BE ZEROED FOR FIRST\n*                               CALL AND RETURNED UNALTERED THEREAFTER.\n*                    A(DCB)  -- ADDR OF A DCB OPENED TO THE DESIRED\n*                               VTOC.  NO I/O MAY BE OUTSTANDING TO\n*                               THIS DCB.  AN APF-AUTHORIZED CALLER\n*                               MAY PASS A COMPLIMENTED UCB ADDRESS\n*                               INSTEAD.\n*                    A(COUNT1)- ADDR OF FULLWORD WHERE COUNT OF THE\n*                               FREE (FMT 0) DSCBS WILL BE RETURNED.\n*                    A(COUNT2)- ADDR OF FULLWORD WHERE COUNT OF THE\n*                               FREE VIRS WILL BE RETURNED.\n*                    A(FMT5) -- ADDR OF 140-BYTE AREA FOR FORMAT-5\n*                               DSCB BUILT BY THIS ROUTINE.\n*\n*  RETURN CODES:\n*            R15  = 0   ALL OK.\n*            R15  = 4   VTOC IS NOT IN INDEXED FORMAT.\n*            R15  = 8   CVAFTST CALL FAILED (OTHER THAN NOT INDEXED\n*                       FORMAT VTOC).  CVAFTST RC IN REG 0.\n*            R15  = 12  CVAFDSM CALL FAILED (OTHER THAN NON INDEXED\n*                       FORMAT VTOC).  CVAFDSM RC IN HIGH ORDER BYTE\n*                       OF R0. CVSTAT IN LOW ORDER BYTE OF R0.\n*            R15  = 16  (UNUSED)\n*            R15  = 20  LOGIC ERROR IN THIS ROUTINE.  R0 = OFFSET.\n*\n*\n*  ATTRIBUTES -  REENTRANT, PROBLEM STATE, PROBLEM KEY.\n*                THIS ROUTINE WILL WORK CORRECTLY ON A NON DFDS\n*                SYSTEM.  HOWEVER, DFDS MACROS ARE REQUIRED FOR\n*                ASSEMBLY.\n*\n*  WRITTEN BY: CHRIS THOMAS, UCLA/OAC SYSTEMS GROUP, 5/30/81\n*\n***********************************************************************\n         TITLE 'IXTOFMT5 -- MAINLINE ROUTINE'\n*\n*  INITIALIZATION\n*\n         SAVE  (14,12),,IXTOFMT5-VERSION_1.0   SAVE REGS\n         LR    R12,R15            ESTABLISH BASE\n         USING IXTOFMT5,R12\n         LR    R9,R13             SAVE CALLER'S R13\n         LR    R11,R1             SAVE CALLER'S PARM POINTER\n         USING PARMLIST,R11\n         L     R1,PARMWORD        POINT TO ANCHOR WORD\n         ICM   R13,B'1111',0(R1)  GET MY WORKAREA ANCHOR\n         BNZ   SKIPGET            IF NON-ZERO, CALL FOR NEXT FMT5\n*\n*  GET WORKAREA AT FIRST CALL\n*\n         GETMAIN  RU,LV=WORKLEN,SP=0\n         LR    R13,R1             ESTABLISH WORKAREA\n         USING WORKAREA,R13\n         L     R1,PARMWORD        ADDR OF ANCHOR\n         ST    R13,0(,R1)         SAVE FOR SUBSEQUENT CALLS\n         LR    R0,R13             ADDR FOR MVCL\n         LA    R1,WORKLEN         LENGTH FOR MVCL\n         SR    R3,R3              ZERO FILL BYTE\n         MVCL  R0,R2              ZERO WORKAREA\n*\n*  CHAIN SAVEAREAS\n*\nSKIPGET  ST    R9,SAVEAREA+4      SAVE CALLER'S R13\n         ST    R13,8(,R9)         FORWARD CHAIN\n         NC    SAVEEXT,SAVEEXT    CALL FOR FIRST FMT5?\n         BNZ   GETNEXT5           NO. RETURN NEXT FMT5\n*\n*  DETERMINE IF THIS IS A DCB FOR DASD WITH INDEXED VTOC\n*\nTST      L     R2,PARMDCB         POINT TO PASSED DCB\n         LCR   R3,R2              MAYBE UCB INSTEAD\n         BNM   UCBPASS            TREAT MINUS AS UCB\n         L     R2,DCBDEBAD-IHADCB(,R2)   GET DEB FROM DCB PASSED\n         ST    R2,DEBADDR         SAVE FOR LATER (ZERO IF UCB)\n         ICM   R3,B'0111',(DEBUCBA-DEBDASD)+(DEBBASND-DEBBASIC)(R2)    *\n                                  GET UCB ADDR FROM DEB\n         B     TESTIT             LEAVE UCB ZERO IF DEB PASSED\nUCBPASS  ST    R3,UCBADDR\nTESTIT   CVAFTST  UCB=(R3)\n         B     *+4(R15)\n         B     UNINDXD            RC = 0   DFDS NOT ON SYSTEM\n         B     UNINDXD            RC = 4   VOL IS NOT INDEXED\n         B     GOODIX             RC = 8   INDEXED. ALL OK.\n         B     TSTERROR           RC = 12  NO VOL MOUNTED, ETC.\n         B     TSTERROR           RC = 16  BAD UCB (NOT DASD, ETC)\n*\n*  CALL CVAFDSM FOR NUMBER OF FREE DSCBS\n*\nGOODIX   L     R2,DEBADDR\n         MVC   CVUCB,UCBADDR\n         MVC   CVPL(LENCVPL),CVPLMFL\n         CVAFDSM  MF=(E,CVPL),    GET COUNT1                           *\n               ACCESS=MAPDATA,                                         *\n               MAP=VTOC,                                               *\n               COUNT=YES,                                              *\n               MAPRCDS=YES,                                            *\n               DEB=(2),                                                *\n               CTAREA=COUNT1\n         B     *+4(R15)\n         B     GOODCT1            RC = 0   SUCCESSFUL\n         B     DSMERROR           RC = 4   END OF DATA, OR ERROR\n         B     DSMERROR           RC = 8   INVALID VTOC INDEX\n         B     DSMERROR           RC = 12  CVAF PARM LIST ERROR\n         B     DSMERROR           RC = 16  DASD I/O ERROR\n*\n*  RETURN COUNT OF FREE DSCBS\n*\nGOODCT1  L     R1,PARMCT1         @ COUNT1\n         MVC   0(4,R1),COUNT1     RETURN COUNT1\n*\n*  SAVE INDEX BUFFERS FOR SUCCEEDING FUNCTIONS\n*\n         L     R1,CVMRCDS               GET ADDR OF BUFFERS\n         ST    R1,BUFLIST               SAVE FOR LATER\n*\n*  CALL CVAFDSM FOR NUMBER OF FREE INDEX BLOCKS (VIRS)\n*\n         L     R2,DEBADDR\n         MVC   CVUCB,UCBADDR\n         L     R3,BUFLIST\n         MVC   CVPL(LENCVPL),CVPLMFL\n         CVAFDSM  MF=(E,CVPL),    GET COUNT1                           *\n               ACCESS=MAPDATA,                                         *\n               MAP=INDEX,                                              *\n               COUNT=YES,                                              *\n               MAPRCDS=(YES,(3)),                                      *\n               DEB=(2),                                                *\n               CTAREA=COUNT2\n         B     *+4(R15)\n         B     RETCT2             RC = 0   SUCCESSFUL\n         B     DSMERROR           RC = 4   END OF DATA, OR ERROR\n         B     DSMERROR           RC = 8   INVALID VTOC INDEX\n         B     DSMERROR           RC = 12  CVAF PARM LIST ERROR\n         B     DSMERROR           RC = 16  DASD I/O ERROR\n*\n*  RETURN COUNT OF FREE VIRS\n*\nRETCT2   L     R1,PARMCT2         @ COUNT2\n         MVC   0(4,R1),COUNT2     RETURN COUNT2\n         XC    SAVEEXT,SAVEEXT    BEGIN FMT5S AT THE BEGINNING\n*\n*  GET 26 FREE EXTENTS.  (ASK FOR 27 TO SIMPLIFY EOD LOGIC).\n*\nGETNEXT5 MVC   EXTS(L'DS5AVEXT),SAVEEXT  SET UP STARTING POINT\n         MVI   NUMEXTS,27\n         L     R2,DEBADDR\n         MVC   CVUCB,UCBADDR\n         L     R3,BUFLIST\n         MVC   CVPL(LENCVPL),CVPLMFL\n         CVAFDSM  MF=(E,CVPL),    GET EXTENTS                          *\n               ACCESS=MAPDATA,                                         *\n               MAP=VOLUME,                                             *\n               MAPRCDS=(YES,(3)),                                      *\n               DEB=(2),                                                *\n               EXTENTS=EXTABL\n         B     *+4(R15)\n         B     NOERROR            RC = 0   SUCCESSFUL\n         B     CHECKEOD           RC = 4   END OF DATA, OR ERROR\n         B     DSMERROR           RC = 8   INVALID VTOC INDEX\n         B     DSMERROR           RC = 12  CVAF PARM LIST ERROR\n         B     DSMERROR           RC = 16  DASD I/O ERROR\n*\n*  IF RC=4, SEE IF ERROR OR END OF EXTENTS\n*\nCHECKEOD CLI   CVSTAT,STAT032     END OF DATA?\n         BNE   DSMERROR           NO, OTHER ERROR\n*\n*  USE 26 (OR FEWER) EXTENTS RETURNED TO BUILD PSUEDO FORMT-5\n*\nNOERROR  L     R10,PARMFMT5       ADDR FOR GENERATED FMT5\n         USING IECSDSF5,R10\n         MVC   DS5KEYID,F5ID      SET KEY\n         MVC   DS5AVEXT(L'DS5AVEXT+L'DS5EXTAV),EXTS  MOVE IN EXTS\n         MVI   DS5FMTID,C'5'      SET DSCB ID\n         MVC   DS5MAVET,EXTS+L'DS5AVEXT+L'DS5EXTAV MOVE REMAINING\n         XC    DS5PTRDS,DS5PTRDS  ZERO CHAIN PTR\n         NC    EXT27,EXT27        IS 27TH EXT ZERO? (1ST IN NEXT FMT5)\n         BZ    CLEANUP            GO CLEANUP. ALL DONE.\n         MVC   DS5PTRDS,NZPTR     MAKE PUSEDO CHAIN POINTER\n         MVC   SAVEEXT(5),DS5MAVET+L'DS5MAVET-L'DS5AVEXT  SAVE THE     *\n                                  LAST EXTENT FOR NEXT FORMAT 5\n         B     RETURN\n         DROP  R10\n*\n*  RELEASE BUFFERS FOR INDEX RECORDS AFTER LAST USE\n*\nCLEANUP  L     R2,DEBADDR\n         L     R3,BUFLIST\n         MVC   CVPL(LENCVPL),CVPLMFL\n         CVAFDIR  MF=(E,CVPL),    FREEMAIN CVAF BUFFERS                *\n               ACCESS=RLSE,                                            *\n               DEB=(2),                                                *\n               MAPRCDS=(NO,(3))\n         LTR   R15,R15            ERROR?\n         BZ    FREEWORK           GOOD. SHOULD ALWAYS WORK.\n         BAL   R14,LOGICERR       BAD. DIE.\n*\n*  FREE GOTTEN  WORKAREA          OR DFDS NOT INSTALLED ON SYSTEM.\n*\nFREEWORK LR    R1,R13             ADDR OF WORKAREA TO BE FREED\n         L     R13,SAVEAREA+4     RELOAD CALLER'S SAVE PTR\n         FREEMAIN  RU,LV=WORKLEN,A=(1),SP=0\n         L     R1,PARMWORD        POINT TO WORKAREA ANCHOR\n         SR    R15,R15            ZERO RETCODE\n         SR    R0,R0              ZERO SUPLIMENTARY RETCODE\n         ST    R15,0(,R1)         ZERO ANCHOR WORD\n         B     EXIT2              GO LEAVE\n         TITLE 'IXTOFMT5 -- TERMINATION ROUTINES'\n*\n*  VTOC IS NOT IN INDEXED FORMAT, OR DFDS NOT INSTALLED ON SYSTEM.\n*\nUNINDXD  SR    R0,R0              ZERO SUPLEMENTRY RETURN CODE\n         LA    R15,4              INDICATE NOT INDEXED\n         B     EXIT               COMMON EXIT\n*\n*  CVAFTST COMPLETED WITH AN ERROR\n*\nTSTERROR LR    R0,R15             SAVE CVAFTST RETURN CODE\n         LA    R15,8              INDICATE FAILURE\n         B     EXIT               COMMON EXIT\n*\n*  CVAFDSM COMPLETED WITH AN ERROR\n*\nDSMERROR LR    R0,R15             PUT CVAFDSM RETURN CODE INTO\n         SLL   R0,24              ... HIGH ORDER BYTE OF R0\n         IC    R0,CVSTAT-CVPL(R1)  ADD CVSTAT VALUE\n         LA    R15,12             INDICATE FAILURE\n         B     EXIT               COMMON EXIT\n*\n*  INTERNAL LOGIC ERROR OR INCORRECT CALL\n*\nLOGICERR LA    R1,IXTOFMT5        ADDR OF ENTRY POINT\n         SLR   R14,R1             CONVERT TO OFFSET\n         LA    R0,0(,R14)         RETURN OFFSET IN R0\n         LA    R15,20             INDICATE FAILURE\n         B     EXIT               COMMON EXIT\n*\n*  NORMAL CONDITIONS\n*\nRETURN   SR    R0,R0              ZERO SUPLEMENTARY RETURN CODE\n         SR    R15,R15            ZERO PRIMARY RETURN CODE\n         B     EXIT               COMMON EXIT\n         SPACE 4\n*\n*  COMMON EXIT ROUTINE\n*\nEXIT     L     R13,SAVEAREA+4     RESTORE CALLER'S SAVE PRT\nEXIT2    L     R14,12(,R13)       RESTORE R14\n         LM    R1,R12,24(R13)     RESTORE R1 THRU R12 (R15,R0 SET)\n         BR    R14                RETURN\n         TITLE 'IXTOFMT5 -- CONSTANTS'\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 4\n*\n*  CONSTANTS\n*\nF5ID     DC    XL4'05050505'      FMT5 KEY\nNZPTR    DC    C'00001'           CHAR INSURES INVALID DASD ADDR\nCVPLMFL  CVAFDSM  MF=L\nLENCVPL  EQU   *-CVPLMFL\n         TITLE 'IXTOFMT5 -- WORKAREA DESCT'\nWORKAREA DSECT\nSAVEAREA DC    18F'0'             YE OLDE SAVEAREA\nCOUNT1   DC    F'0'               FORMAT 0 DSCBS\nCOUNT2   DC    F'0'               FREE INDEX RECORDS\nBUFLIST  DC    A(0)               ADDR VIX BFRS OBTAINED BY CVAF\nDEBADDR  DC    A(0)               ADDR OF DEB PASSED IN CALLER'S DCB\nUCBADDR  DC    A(0)               ADDR OF UCB PASSED (PRIV CALLER)\nSAVEEXT  DC    XL5'00'            BEGINNING OF NEXT FMT5\nEXTABL   DS    0CL(1+(27*5))      FANCY LENGTH\nNUMEXTS  DC    AL1(27)            NR OF EXTENTS REQUESTED\nEXTS     DC    CL(27*5)' '        27 5-BYTE FREE SPACE EXTENTS\n         ORG   *-5\nEXT27    DC    CL5' '             GIVE LAST ONE A NAME\n         ORG\n         SPACE 4\nCVPL     ICVAFPL  DSECT=NO\n         SPACE 4\nWORKLEN  EQU   *-WORKAREA\n         EJECT\n         DSECT\n         IECSDSL1  (5)\n         SPACE 4\nPARMLIST DSECT\nPARMWORD DS    A                  ANCHOR FOR GETMAINED AREA\nPARMDCB  DS    A                  ADDR OF DCB FOR VTOC\nPARMCT1  DS    A                  ADDR OF #FMT 0S\nPARMCT2  DS    A                  ADDR OF #FREE VIRS\nPARMFMT5 DS    A                  ADDR OF FMT5 WORKAREA\n         PRINT NOGEN\n         DCBD  DSORG=PS,DEVD=DA\n         IEZDEB LIST=NO\n         PRINT GEN\n         END\n//*KED.SYSLMOD DD DISP=SHR,DSN=SYS9.MSSLOAD\n//LKED.SYSIN DD *\n ENTRY IXTOFMT5\n NAME  IXTOFMT5(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JOIN": {"ttr": 5891, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x01h\\x01h\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 360, "newlines": 360, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMASA JOB ACCNT,MSGCLASS=A,COND=(0,NE)\n/*ROUTE PRINT WYLBUR\n//ASM EXEC ASMHCL\n//ASM.SYSLIB DD\n//           DD\n//           DD DISP=SHR,DSN=SYS5.MSSMAC\n*---------------------------------------------------------------------*\n*                                                                     *\n* JOIN - JOIN TWO FILES                                               *\n*                                                                     *\n*  PARM:  (SPECIFIES POSITION OF KEY IN BOTH INPUT FILES)             *\n*         (IF NO PARM THEN ALL RECORDS ASSUMED TO MATCH)              *\n*         SEQUENCE OF: OFFSET1,OFFSET2,LEN,ORDER                      *\n*                                                                     *\n*     OFFSETS ORIG 1 (RANGE 1 -> 4095)                                *\n*     LENGTH ORIG 0 (RANGE 1 -> 256)                                  *\n*                                                                     *\n*       OFFSET ORIG 1; LENGTH OF FIELD; SORT ORDER (A OR D)           *\n*                                                                     *\n*  INPUT:  IN1 - INPUT FILE 1 (EACH RECORD MUST HAVE UNIQUE KEY)      *\n*          IN2 - INPUT FILE 2 (MAY CONTAIN NON-UNIQUE KEY RECORDS)    *\n*       BOTH INPUT FILES MUST BE SORTED ON KEYS.                      *\n*                                                                     *\n*  OUTPUT: OUT1 - RECORDS ONLY IN INPUT FILE 1                        *\n*          OUT2 - RECORDS ONLY IN INPUT FILE 2                        *\n*          OUT3 - RECORDS IN BOTH INPUT FILES                         *\n*                 (CONCATIONATION OF RECORD FROM IN1 + IN2)           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         OACWORK &DUMMY\nW#DWD    DC    D'0'\nW#BUFPT  DC    A(0)\nW#FLAG   DC    F'0'\nW#FUSED   EQU   X'80'             RECORD FROM FILE 1 USED\nW#PARM   DC    CL101' '\nW#CODE   DC    50D'0'\n         MEND\n         SPACE 1\nJOIN     OACENTER EXIT=(EXIT,(R15)),                                   X\n               WORK=(0,MPARM),DSECT=W#,                                X\n               STACK=(2048,W#STACK,E$OFLOW,ABEND),ROUND=YES\n         SPACE 1\n         SR    R0,R0\n         ST    R0,W#BUFPT\n         ST    R0,W#FLAG\n         OPEN  MF=(E,OPENLIST)    OPEN ALL DATASETS\n         TM    DCBOFLGS-IHADCB+SYSPRINT,DCBOFOPN\n         BZ    ABND99\n         SPACE 1\n         TM    DCBOFLGS-IHADCB+DCBOUT3,DCBOFOPN OUT3 OPEN?\n         BZ    NOBUF              BIF NO BUFFER REQUIRED\n         LH    R2,DCBLRECL-IHADCB+DCBIN1  GET INPUT LRECL\n         AH    R2,DCBLRECL-IHADCB+DCBIN2  TOTAL SUM OF INPUT RECORDS\n         LA    R2,2048(,R2)       + SOME EXTRA SPACE\n         GETMAIN R,LV=(R2)        GET BUFFER AREA\n         ST    R1,W#BUFPT\n         SPACE 1\nNOBUF    L     R2,0(,R9)          @ PARM\n         LH    R3,0(,R2)          LENGTH OF PARM\n         LTR   R3,R3\n         BZ    NOPARM             BIF NO PARM\n         LA    R2,2(,R2)          @ PARM STRING\n         LA    R14,W#PARM\n         LA    R15,L'W#PARM\n         MVCL  R14,R2             COPY PARM, PAD WITH X'00'\n         SPACE 1\n         LA    R1,W#PARM\n         LA    R2,W#CODE-2        @ FOR COMPARE ROUTINE\n         SPACE 1\n** IF BOTH EOF THEN MUST RETURN EQUAL\n** ELSE EOF ALWAYS < ANY REAL RECORD\n         SPACE 1\nPARMLP   OACCALL NUMCNVT,ERROR=PARMER GET OFFSET1\n         LR    R5,R0              SAVE OFFSET\n         C     R5,=F'4096'\n         BH    PARMER\n         BCTR  R5,0                GET OFFSET ORIG 0\n         LA    R1,1(,R1)          SKIP COMMA\n         OACCALL NUMCNVT,ERROR=PARMER GET OFFSET2\n         LR    R6,R0              SAVE OFFSET\n         C     R6,=F'4096'\n         BH    PARMER\n         BCTR  R6,0                GET OFFSET ORIG 0\n         LA    R1,1(,R1)          SKIP COMMA\n         OACCALL NUMCNVT,ERROR=PARMER GET LENGTH\n         LTR   R0,R0\n         BNP   PARMER\n         C     R0,=F'256'\n         BH    PARMER\n         LA    R1,1(,R1)          SKIP COMMA\n         SPACE 1\n         MVC   2+0(8,R2),=X'D50020003000077E' PATTERN CODE\n         STH   R5,W#DWD\n         STH   R6,W#DWD+2\n         OC    2+2(2,R2),W#DWD    OFFSET TO IN1 FIELD\n         OC    2+4(2,R2),W#DWD+2  OFFSET TO IN2 FIELD\n         BCTR  R0,0               GET CLC TYPE LENGTH\n         STC   R0,2+1(,R2)        SET LENGTH IN CLC\n         CLI   0(R1),C'A'          ASCENDING ORDER?\n         BE    PARM1\n         CLI   0(R1),C'D'          DESCENDING ORDER?\n         BNE   NOPARM             BIF INVALID PARM\n*** REVERSE ORDER OF CLC FOR ASCENDING ORDER\n         XC    2+2(2,R2),2+4(R2)  SWAP ORDER OF COMPARE FOR\n         XC    2+4(2,R2),2+2(R2)     DESCENDING ORDER\n         XC    2+2(2,R2),2+4(R2)\nPARM1    LA    R2,8(,R2)          POINT PAST FIELD COMPARE\n         LA    R1,1(,R1)          SKIP OVER 'A' OR 'D'\n         CLI   0(R1),C','         COMMA?\n         LA    R1,1(,R1)          SKIP OVER 'A' OR 'D'\n         BE    PARMLP             BIF MORE INPUT\n         MVI   1(R2),X'FE'        CHANGE LAST BCR TO ALWAYS RETURN\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*  COMPARE INPUT RECORDS;                                             *\n*    INPUT FILES ARE ASSUMED IN ASCENDING ORDER                       *\n*     SINCE AN EOF IS HIGHER THAN ANYTHING                            *\n*     (EXCEPT ANOTHER EOF TO WHICH IT IS EQUAL)                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\n         OACCALL GET,MF=(E,IN1)         GET RECORD FROM IN1\n         NI    W#FLAG,255-W#FUSED        NOT USED, IS FRESH RECORD\n         OACCALL GET,MF=(E,IN2)         GET RECORD FROM IN2\n         SPACE 1\nCLC      L     R2,IN1+8                 @ RECORD FOR FILE 1 OR 0 IF EOF\n         L     R3,IN2+8                 @ RECORD FOR FILE 2 OR 0 IF EOF\n         LTR   R2,R2              EOF HERE?\n         BZ    CLC1                BIF EOF\n         LTR   R3,R3              EOF HERE?\n         BNZ   CLC2                BIF NOT EOF\nCLC1     CR    R3,R2              HIGHER EOF; EQUAL IF BOTH EOF\n         B     CLC3\nCLC2     LA    R15,W#CODE               @ COMPARE ROUTINE\n         BALR  R14,R15                  COMPARE RECORDS\nCLC3     BE    MATCH                    BIF SAME (OR BOTH EOF)\n         BH    READ2                    BIF FILE 2 < FILE 1\n*---     ELSE FILE 1 < FILE 2 - (FILE 1 REC MISSING FROM FILE 2)\n         TM    W#FLAG,W#FUSED           FILE 1 RECORD MATCHED BEFORE?\n         BO    READ1X\n         MVC   OUT1+8(8),IN1+8          COPY RECORD ADDR, LEN\n         OACCALL PUT,MF=(E,OUT1)         PUT OUT RECORD TO OUT1\nREAD1X   OACCALL GET,MF=(E,IN1)         GET NEW RECORD FROM IN1\n         NI    W#FLAG,255-W#FUSED        NOT USED, IS FRESH RECORD\n         B     CLC                      AND CONTINUE\n         SPACE 1\n*---     FILE 1 > FILE 2 - (FILE 2 MODULE MISSING FROM FILE 1)\nREAD2    MVC   OUT2+8(8),IN2+8          COPY RECORD ADDR, LEN\n         OACCALL PUT,MF=(E,OUT2)         PUT OUT RECORD TO OUT2\nREAD2X   OACCALL GET,MF=(E,IN2)         GET NEW RECORD FROM IN2\n         B     CLC                      AND CONTINUE\n         SPACE 1\n*---     MATCH: MODULE IN BOTH LIBRARYS.\nMATCH    LM    R2,R3,IN1+8              ADDR, LEN IN1 RECORD\n         LM    R4,R5,IN2+8              ADDR, LEN IN2 RECORD\n         LR    R0,R2\n         OR    R0,R4                    BOTH ADDRS ZERO (EOF?)\n         BZ    DONE               BIF BOTH ZERO, IS EOF\n         OI    W#FLAG,W#FUSED     SET REC1 USED (MATCHED SOMETHING)\n         L     R0,W#BUFPT\n         LTR   R0,R0              ANY BUFFER FOR JOIN?\n         BZ    READ2X              BIF NO BUFFER, FILE NOT OPEN\n         LR    R14,R0\n         LR    R15,R3\n         MVCL  R14,R2             COPY REC FROM IN1\n         LR    R15,R5\n         MVCL  R14,R4              FOLLOW WITH RECORD FROM IN2\n         LR    R1,R14             @ PAST END OF OUT3 REC\n         SR    R1,R0              GET OUT3 RECORD LENGTH\n         STM   R0,R1,OUT3+8       SET OUTPUT @ AND LENGTH\n         OACCALL PUT,MF=(E,OUT3)\n         B     READ2X\n         EJECT ,\nDONE     LA    R2,MSG1\n         LA    R3,IN1\n         LA    R4,5\nEOF1     L     R0,0(,R3)\n         CVD   R0,W#DWD\n         MVC   LINE+1(10),=X'40202020202020202120'\n         ED    LINE+1(10),W#DWD+3\n         MVC   LINE+15(30),0(R2)\n         PUT   SYSPRINT,LINE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         LA    R2,30(,R2)\n         LA    R3,4*4(,R3)\n         BCT   R4,EOF1\n         SPACE 1\n         CLOSE MF=(E,OPENLIST)\n         SR    R15,R15\n         B     EXIT\n         SPACE 1\nPARMER   WTO   'MAS000I (JOIN) - PARM ERROR',ROUTCDE=(11)\n         ABEND 97\n         SPACE 1\nNOPARM   WTO   'MAS000I (JOIN) - NO PARM: OFF,LEN,A/D...',ROUTCDE=(11)\n         ABEND 98\n         SPACE 1\nABND99   ABEND 99,DUMP\n         OACDROP R10\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*  GET - GET NEXT INPUT RECORD                                        *\n*                                                                     *\n*   ENTRY: R1  - PARM POINTER                                         *\n*                 + 0 - RECORD COUNT                                  *\n*                 + 4 - @ INPUT DCB                                   *\n*                 + 8 - @ INPUT RECORD (RETURN VALUE, 0 FOR EOF)      *\n*                 +12 - LENGTH OF INPUT RECORD (RETURN VALUE)         *\n*          R14 - RETURN ADDRESS                                       *\n*          R15 - @ GET                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nGET      OACSUB INUSE=NO\n         LR    R9,R1              @ PARM LIST\n         L     R0,8(,R9)          PREV EOF OCCUR?\n         LTR   R0,R0\n         BZ    GET$EOF            BIF PREV EOF\n         L     R8,4(,R9)          @ INPUT DCB\n         OACUSING IHADCB,R8\n         TM    DCBOFLGS,DCBOFOPN  IF NOT OPEN,\n         BZ    GET$EOF              LET IT BE EOF\n         GET   (R8)               LOCATE NEXT INPUT RECORD (OR EOF)\n         SR    R15,R15            RETURN CODE ZERO\n         LA    R2,0(,R1)          @ RECORD WITH CLEAR HIGH BYTE\n         LH    R3,DCBLRECL        LRECL (IF U OR F)\n         TM    DCBRECFM,DCBRECF\n         BNZ   G$SET1             BIF RECFM U OR F\n         MVC   0(2,R13),0(R2)     ALIGN LENGTH FROM RDW\n         LH    R3,0(,R13)\nG$SET1   LA    R0,1               COUNT RECORD\n         AL    R0,0(,R9)\n         ST    R0,0(,R9)\nG$SET2   STM   R2,R3,8(R9)\nG$RET    OACRET RC=(R15)\nGET$EOF  LA    R15,4              EOF\n         SR    R2,R2              NO RECORD ADDRESS\n         SR    R3,R3               RECORD LENGTH ZERO\n         B     G$SET2\n         OACDROP R10,R8\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*  RECPUT - PUT RECORD                                                *\n*                                                                     *\n*   ENTRY: R1  - @ PARMLIST                                           *\n*                  + 0 - RECORD COUNT                                 *\n*                  + 4 - @ OUTPUT DCB                                 *\n*                  + 8 - @ RECORD TO OUTPUT                           *\n*                  +12 - LENGTH OF RECORD TO OUTPUT                   *\n*                                                                     *\n*   (IGNORE CALL IF OUTPUT DCB NOT OPEN)                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nPUT      OACSUB INUSE=NO\n         LR    R9,R1              @ PARMLIST\n         L     R8,4(,R9)          @ OUTPUT DCB\n         OACUSING IHADCB,R8\n         LA    R0,1               COUNT OUTPUT RECORD\n         AL    R0,0(,R9)\n         ST    R0,0(,R9)\n         TM    DCBOFLGS,DCBOFOPN  OUTPUT DCB OPEN?\n         BZ    P$RET              RIF OUTPUT DCB NOT OPEN\n         LM    R2,R3,8(R9)        ADDR, LEN OF OUTPUT RECORD\n         LH    R5,DCBLRECL        ASSUME RECFM=F\n         TM    DCBRECFM,DCBRECV\n         BZ    P$PUT2             BIF RECFM=F\n         LA    R5,4(,R3)          ASSUME RECFM=V\n         TM    DCBRECFM,DCBRECF\n         BZ    P$PUT1             BIF RECFM=V\n         LR    R5,R3              ELSE RECFM=U\nP$PUT1   STH   R5,DCBLRECL        SET LRECL FOR PUT LOCATE\nP$PUT2   PUT   (R8)\n         LA    R4,0(,R1)          @ OUTPUT AREA\n         SPACE 1\n         TM    DCBRECFM,DCBRECF   RECFM=V?\n         BNZ   P$PUT3             BIF NOT RECFM=V\n         LA    R4,4(,R4)          BUMP OUTPUT PTR OVER RDW\n         SH    R5,=H'4'           DCR OUTPUT DATA LENGTH\n         SPACE 1\nP$PUT3   CR    R3,R5              INPUT LEN > OUTPUT LEN?\n         BNH   P$PUT4\n         LR    R3,R5              TRUNCATE LONG INPUT RECORD\nP$PUT4   TM    DCBRECFM,DCBRECF   RECFM=V?\n         BO    P$PUT5             BIF NOT RECFM=V\n         LA    R0,4(,R5)          LENGTH OF RECORD INCLUDING RDW\n         SLL   R0,16\n         ST    R0,0(,R13)\n         MVC   0(4,R1),0(R13)     INIT RDW\nP$PUT5   MVCL  R4,R2              MOVE RECORD DATA TO OUTPUT AREA\nP$RET    OACRET ,\n         OACDROP R10,R8\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n* NUMCNVT - CONVERT CHAR TO BINARY NUMBER                             *\n*                                                                     *\n*  ENTRY: R1 - @ OF INPUT STRING (UPDATED)                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nNUMCNVT  OACSUB INUSE=NO\n         SR    R0,R0              INIT RESULT TO ZERO\n         LA    R15,4              ASSUME RC 4; NO NUMBER EXISTS\nNC$LOOP  CLI   0(R1),C'0'\n         BL    NC$RET\n         CLI   0(R1),C'9'\n         BH    NC$RET\n         IC    R2,0(,R1)\n         N     R2,=X'0000000F'\n         MH    R0,=H'10'\n         AR    R0,R2\n         LA    R1,1(,R1)\n         SR    R15,R15            RETURN CODE 0; HAVE NUMBER\n         B     NC$LOOP\n         SPACE 1\nNC$RET   OACRET RC=(R15)\n         OACDROP R10\n         EJECT ,\n         SPACE 1\nOPENLIST OPEN  (SYSPRINT,(OUTPUT),                                     X\n               DCBIN1,(INPUT),DCBIN2,(INPUT),                          X\n               DCBOUT1,(OUTPUT),DCBOUT2,(OUTPUT),DCBOUT3,(OUTPUT)),MF=L\n         SPACE 1\n* RECORD COUNT; @ DCB; @ RECORD OR 0; LENGTH OF RECORD\nIN1      DC    F'0',A(DCBIN1,1,0)\nIN2      DC    F'0',A(DCBIN2,1,0)\nOUT1     DC    F'0',A(DCBOUT1,1,0)\nOUT2     DC    F'0',A(DCBOUT2,1,0)\nOUT3     DC    F'0',A(DCBOUT3,1,0)\n         SPACE 1\nMSG1     DC    CL30'IN1 RECORDS READ              '\n         DC    CL30'IN2 RECORDS READ              '\n         DC    CL30'OUT1 RECORDS WRITTEN          '\n         DC    CL30'OUT2 RECORDS WRITTEN          '\n         DC    CL30'OUT3 RECORDS WRITTEN          '\n         SPACE 1\nLINE     DC    CL133' '           PRINT LINE\n         PRINT NOGEN\nDCBIN1   DCB   DDNAME=IN1,DSORG=PS,MACRF=GL,EODAD=GET$EOF\nDCBIN2   DCB   DDNAME=IN2,DSORG=PS,MACRF=GL,EODAD=GET$EOF\nDCBOUT1  DCB   DDNAME=OUT1,DSORG=PS,MACRF=PL\nDCBOUT2  DCB   DDNAME=OUT2,DSORG=PS,MACRF=PL\nDCBOUT3  DCB   DDNAME=OUT3,DSORG=PS,MACRF=PL\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,                      X\n               LRECL=133,RECFM=FBA,BLKSIZE=1330\n         SPACE 1\n         DCBD  DSORG=PS\n         END\n//*KED.SYSLMOD DD DISP=SHR,DSN=SYS5.MSSLOAD,SPACE=,UNIT=\n//LKED.SYSIN   DD *\n   ENTRY JOIN\n   IDENTIFY JOIN('CS01325')\n   NAME JOIN(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTGRP": {"ttr": 5898, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\xdd\\x00\\xdd\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 221, "newlines": 221, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMASA JOB ACCT,MSGCLASS=A,COND=(0,NE)\n/*ROUTE PRINT WYLBUR\n//ASM EXEC ASMHCL\n//ASM.SYSLIB DD\n//           DD\n//           DD DISP=SHR,DSN=SYS5.MSSMAC\n         TITLE 'LISTGRP - GIVE DETAILS OF GENERIC GROUP COMPOSITION'\n         MACRO\n         OACWORK &DUMMY\nTSOPL    DS    0D                 BASE FOR XC\n         OACTSOPL PL=(IOPL,PPL)\nTSOECB   DS    F                  TSO SERVICE ECB\nPTPB     PUTLINE MF=L             PUTLINE PARM BLK\nPTPBL    EQU   *-PTPB\nPARANS   DS    F                  IKJPARS \"ANSWER PLACE\"\nTSOPLEN  EQU   *-TSOPL            LENGTH FOR XC\nBUFLEN   DS    H                  BUFFER LENGTH\nBUFOFF   DS    H                  BUFFER OFFSET\nBUF      DS    CL130              OUTPUT BUFFER\nBUFDAD   EQU   BUF+1              DEVICE ADDRESS\nBUFTYPE  EQU   BUFDAD+5           VOLID OR TYPE\nBUFVOL   EQU   BUFTYPE+9          DEVICE STATUS\nBUFSTAT  EQU   BUFVOL+8           VARIABLE STATUS PORTION\nBUFUCBLN EQU   BUFSTAT+4-BUF\nEGNPARM  DS    3F                 PARM LIST FOR OACEGNTU\nEGNLIST  DS    300F               LIST OF UCB'S\n         MEND\n         MACRO\n&LBL     CHK   &FLD,&MSK,&STR\n         LCLA  &A,&B\n&A       SETA  K'&STR\n&B       SETA  &A-2\n&LBL     TM    UCB&FLD,UCB&MSK\n         BZ    CHK&SYSNDX\n         MVC   0(&B,R3),=C&STR\n         LA    R3,&A.(R3)\n         LA    R4,&A.(R4)\nCHK&SYSNDX DS  0H\n         MEND\n         COPY  OACGBLS\n         SPACE 2\n         OACMAP DSECT=(CVT,UCB),PRINT=NONE\n         EJECT\nLISTGRP  OACENTER DSECT=WDSECT,WORK=(,YES),STACK=(256,,STKERR,ABEND),  X\n               EXIT=EXIT,PRINT=SHORT\n*\n*              INITIALIZE ALL THE SERVICE PARM LISTS\n*\n         XC    TSOPL(TSOPLEN),TSOPL ZERO PARM LSTS BEFOR BUILD\n         OACBLDPL CPPL=0(R9),ECB=TSOECB,                               X\n               IOPL=IOPL,                                              X\n               PPL=(PPL,(=V(PCL),I),PARANS,(0(R9),I))\n         XC    BUFOFF(2),BUFOFF   CLEAR BUFFER OFFSET\n         LA    R1,300             GET LENGTH OF LIST IN FULLWORDS\n         ST    R1,EGNPARM\n         LA    R1,EGNLIST\n         ST    R1,EGNPARM+4\n         LA    R1,BUF             POINT TO BUFFER\n         ST    R1,EGNPARM+8\n*\n*              CALL PARSE\n*\n         CALLTSSR EP=IKJPARS,MF=(E,PPL)\n         LTR   R15,R15            CHECK FOR ERROR\n         BZ    PROCESS\n         CH    R15,=H'8'          CHECK FOR ATTENTION\n         BE    RC0                RETURN QUIETLY\n         MVC   BUFLEN(PARSERRL),PARSERR\n         OACCALL PUTDATA          TELL THE USER\n         B     RC12               ERROR RETURN\nPARSERR  DC    H'23',H'0',C'LISTGRP - PARSE ERROR'\nPARSERRL EQU   *-PARSERR\nPROCESS  L     R9,PARANS          PT TO PDL\n         LA    R9,GRPNAME-PDL(R9) POINT TO FIRST GROUPNAME\n         TM    6(R9),X'80'        IS IT THERE?\n         BO    UCB1               IF NOT EMPTY PROCESS\n         LINK  EP=CLEAR           CLEAR THE SCREEN FOR HIM\n         LOAD  EP=DEVNAMET        HE'S ASKING FOR ALL THE NAMES\n         LR    R8,R0              SAVE PTR TO TABLE\n         L     R7,0(R8)           GET NUMBER OF ENTRIES IN TABLE\n         LA    R8,4(R8)           POINT TO FIRST ENTRY IN TABLE\n         LA    R6,10              NUMBER OF ENTRIES PER LINE\n         MVC   BUFLEN(2),=H'84'\n         MVI   BUF,C' '           CLEAR BUFFER\n         MVC   BUF+1(129),BUF\n         LA    R5,BUF             PT TO FIRST POSITION\nNAMELOOP MVC   0(6,R5),0(R8)      MOVE NAME TO BUFFER\n         LA    R5,8(R5)           POINT TO NEXT BUFFER POSITION\n         BCT   R6,NAME1           IF NOT OFF END OF NAME CONTINUE\n         OACCALL PUTDATA          PUT OUT THE BUFFER\n         MVI   BUF,C' '           CLEAR THE BUFFER\n         MVC   BUF+1(129),BUF\n         LA    R6,10              NUMBER OF ENTRIES PER LINE\n         LA    R5,BUF             RESET POINTER\nNAME1    LA    R8,12(R8)          POINT TO NEXT NAME ENTRY\n         BCT   R7,NAMELOOP\n         CH    R6,=H'10'          SEE IF WE ARE AT BEGINING OF LINE\n         BE    NAME2              IF SO DONT REPUT\n         OACCALL PUTDATA\nNAME2    DELETE EP=DEVNAMET\n         B     RC0\nUCB1     LOAD  EP=OACEGNTU        GET ADDRESS OF SERVICE ROUTINE\n         LR    R8,R0              SAVE FOR LATER USE\nLOOP     TM    6(R9),X'80'        SEE IF THERE IS A GRPNAME THERE\n         BNO   DONE               IF NOT THEN DONE\n         MVI   BUF,C' '           CLEAR BUFFER\n         MVC   BUF+1(129),BUF\n         LH    R1,4(R9)           GET LENGTH\n         BCTR  R1,0               DECREMENT FOR EXECUTE\n         L     R2,0(R9)           GET PTR TO GROUPNAME\n         MVC   BUF(1),0(R2)       <EXECUTED>\n         EX    R1,*-6             MOVE IN THE GROUPNAME\n         MVC   BUFLEN(2),=H'12'   MOVE IN LENGTH\n         LA    R1,EGNPARM         POINT TO PARM LIST\n         BALR  R14,R8             TRY TO FIND IT\n         CH    R15,=H'8'          SEE IF NOT FOUND\n         BNE   FOUND\n         MVC   BUF+10(9),=C'NOT FOUND'\n         MVC   BUFLEN(2),=H'24'\n         OACCALL PUTDATA\n         B     NEXT\nFOUND    OACCALL PUTDATA\n         LH    R7,EGNLIST         GET NUMBER OF UCB'S\n         LA    R6,EGNLIST+4       POINT TO FIRST UCB ADD\nNEXTUCB  L     R5,0(R6)           GET UCB ADDR\n         OACUSING UCB,R5\n         MVI   BUF,C' '           CLEAR BUFFER\n         MVC   BUF+1(129),BUF\n         MVC   BUFLEN(2),=AL2(BUFUCBLN)\n         MVC   BUFDAD(3),UCBNAME  MOVE IN DEVICE ADDRESS\n         TM    UCBJBNR,UCBVRDEV   SEE IF VIO\n         BNO   FND1\n         MVC   BUFTYPE(3),=C'VIO'\n         B     FND9\nFND1     CLI   UCBTBYT3,UCB3DACC\n         BNE   FND2\n         MVC   BUFTYPE(4),=C'DASD'\n         B     FND8\nFND2     CLI   UCBTBYT3,UCB3TAPE\n         BNE   FND3\n         MVC   BUFTYPE(4),=C'TAPE'\n         B     FND8\nFND3     CLI   UCBTBYT3,UCB3COMM\n         BNE   FND4\n         MVC   BUFTYPE(4),=C'COMM'\n         B     FND9\nFND4     CLI   UCBTBYT3,UCB3UREC\n         BNE   FND5\n         MVC   BUFTYPE(7),=C'UNT REC'\n         B     FND9\nFND5     CLI   UCBTBYT3,UCB3DISP\n         BNE   FND6\n         MVC   BUFTYPE(7),=C'DISPLAY'\n         B     FND9\nFND6     CLI   UCBTBYT3,UCB3CTC\n         BNE   FND7\n         MVC   BUFTYPE(7),=C'CH/CH'\n         B     FND9\nFND7     CLI   UCBTBYT3,UCB3CHAR\n         BNE   FND7\n         MVC   BUFTYPE(7),=C'CHR RDR'\n         B     FND9\nFND8     LA    R3,BUFSTAT         POINT TO VARIABLE PORTION OF BUF\n         LA    R4,BUFUCBLN        GET CURRENT LENGTH OF BUF\n         TM    UCBSTAT,UCBONLI    SEE IF ONLINE\n         BNO   OFFLINE            IF NOT VOLUME NAME NOT THERE\n         CLI   UCBVOLI,0          IS THERE A NAME?\n         BE    ONLINE             IF NOT CONTINUE\n         MVC   BUFVOL(6),UCBVOLI  MOVE IN VOL NAME\n         B     ONLINE\nFND9     LA    R3,BUFSTAT         POINT TO VARIABLE PORTION OF BUF\n         LA    R4,BUFUCBLN        GET CURRENT LENGTH OF BUF\n         TM    UCBSTAT,UCBONLI    SEE IF ONLINE\n         BO    ONLINE\nOFFLINE  MVC   0(7,R3),=C'OFFLINE'\n         LA    R3,9(R3)           BUMP BUFFER PTR\n         LA    R4,9(R4)           BUMP LENGTH\nONLINE   CHK   STAT,CHGS,'PENDING'\n         CHK   STAT,RESV,'RESERVED'\n         CHK   STAT,UNLD,'UNLOAD'\n         CHK   STAT,ALOC,'ALLOC'\n         CHK   STAT,PRES,'PERM RES'\n         CHK   FLC,IVRS+UCBIVRR,'INT REQ'\n         CHK   FLA,BSY,'BUSY'\n         CHK   FLA,NRY,'NOT READY'\n         CHK   FLA,CUB,'CU BUSY'\n         CHK   FLA,ACTV,'ACTIVE'\n         CHK   FLA,QISCE,'QUIESCED'\nUCBPRT   STH   R4,BUFLEN          STORE LENGTH\n         OACCALL PUTDATA\n         LA    R6,4(R6)           POINT TO NEXT UCB ADDRESS\n         BCT   R7,NEXTUCB\nNEXT     MVC   BUFLEN(SPMSGL),SPMSG     SPACE\n         OACCALL PUTDATA\n         L     R9,8(R9)           PT TO NEXT LIST ELEMENT\n         C     R9,=X'FF000000'    SEE IF END OF LIST\n         BNE   LOOP\n         OACDROP R5\nDONE     DELETE EP=OACEGNTU\nRC0      SR    R15,R15            RC 0\n         B     EXIT\n*\nRC12     LA    R15,12             ERROR RC\n         B     EXIT               RETURN TO CALLER\n*\nSPMSG    DC    H'5',H'0',C' '\nSPMSGL   EQU   *-SPMSG\n         LTORG\n         OACDROP R10\n         TITLE 'LISTGRP - SUBROUTINES'\nPUTDATA  OACSUB\n         XC    PTPB(PTPBL),PTPB   ZERO PARM BLK\n         PUTLINE PARM=PTPB,OUTPUT=(BUFLEN,,DATA),MF=(E,IOPL)\n         OACRET RC=(R15)\n         OACDROP R10\n         TITLE 'LISTGRP - PARSE CONTROLE LIST'\n         PRINT ON,NOGEN\nPCL      IKJPARM DSECT=PDL\nGRPNAME  IKJIDENT 'GROUPNAME-LIST',LIST,FIRST=ANY,OTHER=ANY,MAXLNTH=8\n         IKJENDP\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTSPC": {"ttr": 6148, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x04\\xc5\\x04\\xc5\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 1221, "newlines": 1221, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMAS1 JOB MSGCLASS=A,COND=(0,NE)\n/*ROUTE PRINT WYLBUR\n//  EXEC ASMHCL,PARM.LKED='LIST,XREF'\n//SYSLIB DD DISP=SHR,DSN=SYS1.MACLIB\n//       DD DISP=SHR,DSN=SYS1.AMODGEN\n//       DD DISP=SHR,DSN=SYS5.MSSMAC\n//SYSIN DD *\n*          DATA SET CBT501     AT LEVEL 002 AS OF 12/30/77\n*          DATA SET CBT501     AT LEVEL 002 AS OF 12/16/75\n         TITLE 'LISTSPC - DOCUMENTATION'\n*.....................................................................*\n*.                                                                   .*\n*.   LISTSPC                                                         .*\n*.                                                                   .*\n*.....................................................................*\n*.                                                                   .*\n*.   1.0  GENERAL DESCRIPTION                                        .*\n*.                                                                   .*\n*.   THIS TSO COMMAND IS A MULTI-PURPOSE PROGRAM FOR LISTING         .*\n*.   THE SPACE (IN TRACKS) USED BY DATASETS AND THE FREE SPACE       .*\n*.   ON DISK VOLUMES.  IT CAN ALSO LIST THE EXTENTS AND VOLSER       .*\n*.   OF DATASETS.                                                    .*\n*.                                                                   .*\n*.....................................................................*\n*.                                                                   .*\n*.....................................................................*\n*.                                                                   .*\n*.   2.0  COMMAND SYNTAX                                             .*\n*.                                                                   .*\n*.    LISTSPC  DATASET(DSNAME-LIST) LEVEL(INDEX-STRUCTURE)           .*\n*.             VOLUME(VOLUME-LIST) EXTENTS                           .*\n*.                                                                   .*\n*.       DATASET(DSNAME-LIST)                                        .*\n*.          -  SPECIFIES A DSNAME LIST FOR WHICH YOU DESIRE TO       .*\n*.             HAVE THE SPACE INFORMATION LISTED.  TSO DATASET       .*\n*.             NAMING CONVENTIONS APPLY FOR THE DSNAMES.             .*\n*.                                                                   .*\n*.       LEVEL(INDEX-STRUCTURE)                                      .*\n*.          -  SPECIFIES AN INDEX STRUCTURE FOR WHICH YOU DESIRE     .*\n*.             TO HAVE THE SPACE INFORMATION LISTED FOR EACH         .*\n*.             DATASET WITHIN THIS INDEX STRUCTURE.  THIS MAY        .*\n*.             BE A DSNAME CONTAINING ONE EMBEDDED ASTERISK NOT      .*\n*.             AS THE HIGH-LEVEL QUALIFIER OR IT MAY BE AN INDEX     .*\n*.             LEVEL.                                                .*\n*.                                                                   .*\n*.       VOLUME(VOLUME-LIST)                                         .*\n*.          -  IF USED WITH THE 'DATASET' PARAMETER, SPECIFIES THE   .*\n*.             VOLUME ON WHICH THE DATASET RESIDES.  NO CATALOG      .*\n*.             SEARCH WILL BE PERFORMED FOR THE DATASETS.            .*\n*.          -  IF USED AS THE ONLY PARAMETER, SPECIFIES A LIST OF    .*\n*.             VOLUMES FOR WHICH FREE SPACE INFORMATION WILL BE      .*\n*.             LISTED.                                               .*\n*.                                                                   .*\n*.       EXTENTS                                                     .*\n*.          -  SPECIFIES THAT THE VOLSER AND THE DATASET'S EXTENTS   .*\n*.             (IN A HEXADECIMAL FORMAT) WILL BE LISTED FOR EACH     .*\n*.             DATASET.                                              .*\n*.                                                                   .*\n*.     NOTE:  THE USE OF THE 'VOLUME' AND THE 'EXTENTS'              .*\n*.            PARAMETERS CAN BE RESTRICTED TO CERTAIN USERIDS        .*\n*.            THROUGH THE USE OF BIT 0 IN THE FIELD LABELED          .*\n*.            'FLAG'.                                                .*\n*.                                                                   .*\n*.....................................................................*\n*.                                                                   .*\n*.....................................................................*\n*.                                                                   .*\n*.   3.0  PROGRAM STRUCTURE                                          .*\n*.                                                                   .*\n*.                                                                   .*\n*.   3.0.1  INITIALIZATION                                           .*\n*.                                                                   .*\n*.   THIS SECTION BUILDS THE PARAMETER LISTS FOR PARSE AND           .*\n*.   LOCINDEX.  IT CAN, IF DESIRED, CHECK THE USERID FOR             .*\n*.   AUTHORIZATION AND SET BIT 0 OF THE FLAG FIELD IF THE USER       .*\n*.   IS AUTHORIZED.  IT THEN LINKS TO PARSE AND DETERMINES           .*\n*.   WHICH TYPE OF REQUEST IS BEING MADE.                            .*\n*.                                                                   .*\n*.                                                                   .*\n*.   3.0.2  DATASET ROUTINE                                          .*\n*.                                                                   .*\n*.   THIS ROUTINE IS ENTERED IF THE 'DATASET' PARAMETER IS           .*\n*.   SPECIFIED.  IF THE 'VOLUME' PARAMETER IS ALSO SPECIFIED,        .*\n*.   THE 'LOCATE' IS BYPASSED.  IT THEN LINKS TO THE OBTAIN AND      .*\n*.   PRINT ROUTINE.                                                  .*\n*.                                                                   .*\n*.                                                                   .*\n*.   3.0.3  LEVEL ROUTINE                                            .*\n*.                                                                   .*\n*.   THIS ROUTINE IS ENTERED IF THE 'LEVEL' PARAMETER IS SPECIFIED.  .*\n*.   IT LINKS TO LOCINDEX TO GET THE DSNAMES FOR THE INDEX           .*\n*.   STRUCTURE AND THEN LINKS TO THE OBTAIN AND PRINT ROUTINE.       .*\n*.                                                                   .*\n*.                                                                   .*\n*.   3.0.4  VOLUME ROUTINE                                           .*\n*.                                                                   .*\n*.   THIS ROUTINE IS ENTERED IF THE 'VOLUME' PARAMETER IS            .*\n*.   SPECIFIED AS THE ONLY PARAMETER.  IT 'OBTAIN'S THE FORMAT 4     .*\n*.   DSCB AND EXTRACTS CERTAIN FIELDS.  IT THEN 'OBTAIN'S ALL        .*\n*.   OF THE FORMAT 5 DSCB RECORDS AND ACCUMULATES THE FREE           .*\n*.   EXTENTS.                                                        .*\n*.                                                                   .*\n*.                                                                   .*\n*.   3.0.5  OBTAIN AND PRINT ROUTINE                                 .*\n*.                                                                   .*\n*.   THIS ROUTINE 'OBTAIN'S THE FORMAT 1 DSCB AND THE FORMAT 3       .*\n*.   DSCB (IF ONE EXISTS) FOR A DATASET AND ACCUMULATES THE          .*\n*.   EXTENTS.  IT THEN PRINTS THE DSORG, # OF ALLOCATED TRACKS,      .*\n*.   # OF UNUSED TRACKS, # OF EXTENTS, AND THE DSNAME.  IF THE       .*\n*.   'EXTENTS' KEYWORD WAS SPECIFIED, IT ALSO PRINTS THE VOLSER      .*\n*.   AND THE EXTENTS FOR THE DATASET.                                .*\n*.                                                                   .*\n*.....................................................................*\n         TITLE 'LISTSPC - LIST SPACE COMMAND'\nLISTSPC  START 0\n         STM   R14,R12,12(R13)\n         USING LISTSPC,R15\n         ST    R13,SAVE+4\n         LA    R13,SAVE\n         B     BEGIN\nSAVE     DC    18F'0'\n         DROP  R15\n         USING SAVE,R13\n         TITLE 'LISTSPC - GETMAIN AND PARSE'\nBEGIN    LR    R4,R1\n         USING CPPL,R4\n         LA    R0,LWORK            GET LENGTH OF WORK AREA\n         AH    R0,=H'4096'         GET EXTRA 4K FOR LOCINDEX WORK\n         ICM   R0,B'1000',=FL1'1'  SUBPOOL 1\n         GETMAIN R,LV=(0)\n         LR    R12,R1               SAVE ADDR OF WORK AREA\n         USING WORKAREA,R12\n         LA    R0,LOCINDXW          POINT TO LOCINDEX WORK AREA\n         ST    R0,PARM+12           SAVE ADDR IN PARM LIST\n         MVI   PARM+12,X'80'        INDICATE END OF PARM LIST\n         MVI   WXTNT+4,X'04'\n         LA    R3,WPPL             GET ADDR OF PPL\n         USING PPL,R3\n         L     R0,CPPLCBUF\n         ST    R0,PPLCBUF          SAVE ADDR OF COMMAND BUFFER\n         L     R0,CPPLUPT\n         ST    R0,PPLUPT           SAVE ADDR OF UPT\n         L     R0,CPPLPSCB\n         LR    R10,R0              GET ADDR OF USERID FROM PSCB\n         SR    R11,R11\n         IC    R11,7(R10)          GET LENGTH OF USERID\n         BCTR  R11,0\n         CLI   0(R10),C'C'         STAFF?                           CST\n         BNE   AUTHRZD                                              CST\n         OI    FLAG,X'40'                                           CST\nAUTHRZD  OI    FLAG,X'80'\nLECT     L     R0,CPPLECT\n         ST    R0,PPLECT           SAVE ADDR OF ECT\n         LA    R0,CPECB\n         ST    R0,PPLECB           SAVE ADDR OF ECB\n         XC    CPECB,CPECB         CLEAR ECB\n         L     R0,=A(PARSLIST)\n         ST    R0,PPLPCL           SAVE ADDR OF PCL\n         LA    R0,WPDL\n         ST    R0,PPLANS           SAVE ADDR OF PDL AREA\n         XC    PPLUWA,PPLUWA       CLEAR UWA\n         LR    R1,R3               PASS ADDR OF PPL TO PARSE\n         LINK  EP=IKJPARS          LINK TO PARSE SERVICE ROUTINE\n         LTR   R15,R15             PARSE ERROR\n         BNZ   RETC                 YES\n         TM    PPLANS,X'FF'        PARSE ERROR\n         BO    RETC                 YES\n         DROP  R3,R4\n         L     R3,WPDL             GET ADDR OF PDL\n         USING IKJPARMD,R3\n         TM    EXTENT+1,X'01'      EXTENT SPECIFIED?\n         BZ    *+8                  NO\n         OI    FLAG,X'20'           YES, SET FLAG BIT\n         TM    DSNLIST+6,X'80'      DSNAME SPECIFIED?\n         BO    DSNRTN                YES\n         TM    LEV+6,X'80'          INDEX LEVEL SPECIFIED?\n         BO    LEVEL                 YES\n         TM    VOL+6,X'80'          VOLUME SPECIFIED?\n         BO    FREEA                 YES\n         B     EUSLO                NO PARMS - LISTS FOR USERID\n         TITLE 'LISTSPC - DATASET NAME ROUTINE'\nDSNRTN   LA    R4,DSNLIST           POINT TO DSN LIST\n         LA    R0,L'MSG1\n         LA    R1,MSG1\n         SVC   93                  TPUT HEADING\nDSNAME   L     R5,0(R4)             POINT TO DSNAME\n         LH    R6,4(R4)             GET LENGTH OF DSNAME\n         BCTR  R6,0\n         MVI   DSN1,X'40'\n         MVC   DSN1+1(43),DSN1     BLANK DSN WORK AREA\n         LA    R8,DSN1              POINT TO DSN WORK AREA\n         TM    6(R4),X'40'          DSNAME CONTAINED IN QUOTES?\n         BO    MVCDSNAM               YES\n         EX    R11,USIDMVC         MOVE USERID TO WORK AREA\n         LA    R8,1(R11,R8)        BUMP PAST USERID\n         MVI   0(R8),C'.'          MOVE PERIOD TO WORK AREA\n         LA    R8,1(0,R8)          BUMP PAST\nMVCDSNAM EX    R6,DSNMVC           MOVE DSNAME TO WORK AREA\n         MVC   VOLS,BLANKS         MOVE BLANKS TO VOLSER WORK AREA\n         TM    FLAG,X'80'          AUTHORIZED USER?\n         BZ    LOCDSN               NO\n         TM    VOL+6,X'80'         VOLUME SPECIFIED?\n         BZ    LOCDSN               NO, LOCATE DSN\n         LA    R1,VOLS             POINT TO VOLSER WORK AREA\n         L     R5,VOL              POINT TO VOLUME PARAMETER\n         LH    R6,VOL+4            GET LENGTH OF VOL PARM\n         BCTR  R6,0\n         EX    R6,MVCVOLS          MOVE VOL PARM TO VOLSER WORK AREA\n         B     BALOBTN             BYPASS LOCATE\nLOCDSN   OI    FLAG,X'10'\n         LOCATE INDS\n         LTR   R15,R15              DID IT FIND VOL SER\n         BNZ   ERR03                 NO WRITE ERROR MSG\n         NI    FLAG,X'EF'\n         MVC   VOLS(6),BUF1+6      YES - MOVE IN VOL SER\n         SPACE 2\nBALOBTN  BAL   R9,OBTNRTN          LINK TO OBTAIN AND PRINT ROUTINE\nRETDSN   L     R4,24(R4)           GET DSN LINK POINTER\n         C     R4,ENDLIST          END OF LIST?\n         BE    RETC                 YES\n         B     DSNAME               NO, GET NEXT DSNAME\n         TITLE 'LISTSPC - LEVEL ROUTINE'\nEUSLO    EQU   *\n**     FOR ENTIRE USERID LOGGED ON\n         MVC   USERID(7),0(R10)        MOVE IN USERID\n         B     GOTUS               BRANCH TO GOT USERID\n         SPACE 3\nLEVEL    EQU   *\n         L     R5,LEV              POINT TO INDEX STRUCTURE\n         LH    R6,LEV+4            GET LENGTH OF INDEX STRUCT\n         BCTR  R6,0\n         LA    R8,USERID           POINT TO WORK AREA\n         EX    R6,DSNMVC           MOVE INDEX STRUCTURE TO WORK AREA\nGOTUS    EQU   *\n         LA    R0,L'MSG1\n         LA    R1,MSG1\n         SVC   93                  TPUT HEADING\n         OI    FLAG,X'40'          SET FLAG FOR DATA SETS FOR USERID\nLOOP     EQU   *                   LOOP FOR DATASET IN USERID\n         L     R15,=V(LOCINDEX)    POINT TO EP(LOCINDEX)\n         LA    R1,PARM             POINT TO PARM LIST\n         BALR  R14,R15             GO TO LOCINDEX\n         B     *+4(R15)            BRANCH , DEP ON RETURN CODE\n         B     OK                  0-GET INFOR FOR DSN & CONT\n         B     NOUSER              4-PRINT MSG & RETRUN TO SYS\n         B     NOTDISK             8-PRINT MSG&CONTINUE\n         B     MULTIVOL            12-PRINT MSG&CONTINUE\n         B     RETC                16-FINISHED-RETURN TO SYS\n         B     RDERR               20-PRINT MSG&RETRUN TO SUS\nOK       BAL   R9,OBTNRTN          LINK TO OBTAIN AND PRINT ROUTINE\n         B     LOOP                GET NEXT DSNAME FROM LOCINDEX\n         SPACE 3\n         TITLE 'LISTSPC - VOLUME ROUTINE'\nFREEA    EQU   *\n** TO GET AVAILABLE SPACE ON PARTICULAR VOLUME\n         LA    R0,L'MSG4\n         LA    R1,MSG4\n         TM    FLAG,X'40'          STAFF?                           CST\n         BZ    FREEHD              NO                               CST\n         LA    R1,MSG4A            YES. SHOW VIRS IN HEADING        CST\nFREEHD   SVC   93                  TPUT HEADING\n         SPACE 2\n         LA    R4,VOL              POINT TO VOLUME LIST\nVOLLOOP  ST    R4,OBTNSAVE         SAVE ADDRESS\n         MVI   MSG2,X'40'\n         MVC   MSG2+1(75),MSG2     BLANK MESSAGE AREA\n         XC    PEXCTR,PEXCTR       CLEAR EXTENT COUNTER\n         LA    R1,VOLS             POINT TO VOLSER WORK AREA\n         L     R5,0(R4)            POINT TO VOLUME PARM\n         LH    R6,4(R4)            GET LENGTH OF VOL PARM\n         BCTR  R6,0\n         EX    R6,MVCVOLS          MOVE VOL PARM TO VOLSER WORK AREA\n         LA    R1,MSG2             POINT TO MESSAGE AREA\n         EX    R6,MVCVOLS          MOVE VOLSER TO MESSAGE AREA\n         MVI   DSN1,X'04'          MOVE 'DSN' FOR F4 DSCB...\n         MVC   DSN1+1(43),DSN1     ...INTO DSN1\n         OBTAIN SERCHCAM\n         CLI   BUF1,X'F4'          DID IT READ OK?\n         BNE   ERRF4               NO\n         MVC   VOLTKCYL(2),BUF1+20 GET NUM OF TRKS/CYL\n         MVC   VOLDSCTK+1(1),BUF1+30   GET NUM OF DSCBS PER TRK\n         MVC   VOLF4CHR(4),BUF1+63 GET CCHH OF START OF VTOC\n         MVI   VOLF4CHR+4,X'01'    F4 DSCB IS FIRST REC\n         LH    RCC,VOLF4CHR        SETUP...\n         LH    RHH,VOLF4CHR+2         DISK...\n         SR    RR,RR                     ADDRESSING...\n         IC    RR,VOLF4CHR+4\n         SR    R9,R9\n         LH    R9,BUF1+6             MOVE IN NUMBER FREE DSCB\n         CVD   R9,WKD\n         MVC   MSG2+6(6),MASKED        MOVE IN MASK\n         ED    MSG2+6(6),WKD+5         EDIT FREE DSCB\n         LH    R1,VOLNO            GET NUM VOLS PROCESSED\n         LA    R1,1(R1)            BUMP\n         STH   R1,VOLNO            REPLACE\n***********************************************************************\n         BAL   R11,IXINIT\n***********************************************************************\n         LA    RR,1(RR)            BUMP RECORD PTR\n         CH    RR,VOLDSCTK         TEST FOR LAST REC ON TRK\n         BNH   VBSET               GO SET VTOCCHHR\n         LA    RR,1                RESET RR TO 1\n         LA    RHH,1(RHH)          BUMP TRK COUNTER\n         CH    RHH,VOLTKCYL        PAST END OF CYL?\n         BL    VBSET               GO SET VTOCCHHR\n         SR    RHH,RHH             ELSE SET RHH TO TRK 0\n         LA    RCC,1(RCC)          BUMP TO NEXT CYL\nVBSET    STH   RCC,VTOCCHHR        SET...\n         STH   RHH,VTOCCHHR+2         UP...\n         STC   RR,VTOCCHHR+4            VTOCCHHR\n         SR    R4,R4               ZERO COUNTER\n         SPACE 2\nPFOBT    EQU    *\n***********************************************************************\n         BAL   R11,IXFMT5\n         B     PFGOTIX\n***********************************************************************\n         OBTAIN SEEKCAM\nPFGOTIX  LA    R2,1                INDICATE FIRST EXTENT\n         LA    R3,BUF1+4           POINT TO FIRST EXTENT\nPFLOOP   CLC   0(5,R3),=D'0'       LAST EXTENT?\n         BE    PFGOT               EXIT IF SO\n         MVC   HWK1(2),2(R3)       MOVE NUM CYLS TO HWD\n         LH    R1,HWK1             LOAD\n         MH    R1,VOLTKCYL         CONVERT TO TRKS\n         SR    R0,R0               ZERO R0\n         IC    R0,4(R3)            LOAD NUM TRKS\n         AR    R1,R0               ADD TRKS\n         AR    R4,R1               ACCUMULATE\n         C     R1,MAXTRK          SEE IF WE HAVE NEW MAX\n         BNH   *+8                IF NOT LEAVE ALONE\n         ST    R1,MAXTRK          SAVE NEW MAX\n         LA    R2,1(R2)            BUMP CTR\n         CH    R2,=H'9'            NINTH EXTENT?\n         BE    PFXT9               BRANCH IF SO\n         CH    R2,=H'27'           27TH EXTNET?\n         BE    PFXT27              BRANCH IF SO\n         LA    R3,5(R3)            BUMP NORMALLY\n         B     PFLOOP              AND CONTINUE\nPFXT9    LA    R3,6(R3)            SKIP OVER F5 IF AT DSCH+44\n         B     PFLOOP              AND CONTINUE\nPFXT27   AH    R2,PEXCTR           ACCUM EXT TOTALS\n         BCTR  R2,0\n         STH   R2,PEXCTR           SAVE EXT TOTALS\n         CLC   BUF1+135(5),=D'0'   PTR TO NEXT F5?\n         BE    PFGOT               DONE. NO MORE F5\n         MVC   VTOCCHHR(5),BUF1+135\n         B     PFOBT               GO READ NEXT F5\nPFGOT    EQU   *\n         AH    R2,PEXCTR           ACCUM EXTENT TOTALS\n         BZ    *+6\n         BCTR  R2,0\n         CVD   R2,WKD              CONVERT NUM EXTENTS\n         MVC   MSG2+13(6),MASKED     MOVE IN MASK\n         ED    MSG2+13(6),WKD+5      EDIT NUM EXTENTS\n         CVD   R4,WKD              CONVERT NUM TRKS FREE\n         MVC   MSG2+21(6),MASKED     MOVE IN MASK\n         ED    MSG2+21(6),WKD+5      EDIT FREE TRKS\n         L     R4,MAXTRK           GET MAX FREE EXTENT\n         XC    MAXTRK(4),MAXTRK    CLEAR FOR NEXT USE\n         CVD   R4,WKD              CONVERT NUM TRKS FREE\n         MVC   MSG2+29(6),MASKED     MOVE IN MASK\n         ED    MSG2+29(6),WKD+5      EDIT FREE TRKS\n***********************************************************************\n         BAL   R11,IXPRINT\n***********************************************************************\n         TPUT  MSG2,76             WRITE FREE INFO\nVOLRET   EQU   *\n***********************************************************************\n         BAL   R11,IXTERM\n***********************************************************************\n         L     R4,OBTNSAVE         LOAD POINTER TO VOLUME LIST\n         L     R4,8(R4)            GET LINK POINTER\n         C     R4,ENDLIST          END OF LIST\n         BE    RETC                 YES\n         B     VOLLOOP              NO, GET NEXT VOLUME\nMAXTRK   DC    F'0'               MAX FREE EXTENT\n         TITLE 'LISTSPC - OBTAIN AND PRINT ROUTINES'\n*   READ DSCB1 AND GET SPACE\nOBTNRTN  STM   R2,R11,OBTNSAVE     SAVE CALLER'S REGISTERS\n         MVC   DSNSAVE(44),DSN1\n         MVI   DSN1,X'04'          MOVE 'DSN' FOR F4 DSCB...\n         MVC   DSN1+1(43),DSN1     ...INTO DSN1\n         OBTAIN SERCHCAM\n         CLI   BUF1,X'F4'          DID IT READ OK?\n         BNE   ERRF4               NO\n         MVC   VOLTKCYL(2),BUF1+20 GET NUM OF TRKS/CYL\n         MVC   DSN1(44),DSNSAVE\n         MVI   MSG2,X'40'\n         MVC   MSG2+1(75),MSG2     BLANK MESSAGE AREA\n         OBTAIN SERCHCAM\n         LTR   R15,R15             DID OBTAIN WORK\n         BNZ   ERR03               NO - WRITE ERROR MSG\n         SPACE 2\n         CLI   BUF1,C'1'            IS IT F1 DSCB?\n         BNE   ERR01                NOT F1\n         LA    R9,XTNTS            POINT TO EXTENTS SAVE AREA\n         LH    R6,BUF1+54          GET LAST RELATIVE TRK USED\n         CLI   BUF1+56,X'00'       IS TRK UNUSED?\n         BE    *+8                  YES\n         LA    R6,1(R6)             NO, ANOTHER TRACK\n         STH   R6,LASTTRK          SAVE LAST REL. TRK\n         MVC   DSORG,BUF1+38       SAVE DSORG\nAROUND   EQU   *\n* TEST FOR TYPE OF DSORG AND MOVE TO PRINT LINE\n         CLI   BUF1+38,X'80'        IS IT IS\n         BNE   NIS                  NO\n         MVC   MSG2+2(2),=C'IS'     YES - MOVE IN IS\n         B     GDSO                 BRANCH TO GOT DSORG\nNIS      CLI   BUF1+38,X'40'        IS IT PS\n         BNE   NPS                   NO\n         MVC   MSG2+2(2),=C'PS'      YES-MOVE IN PS\n         B     GDSO                 BRANCH TO GOT DSORG\nNPS      CLI   BUF1+38,X'20'        IS IT DA\n         BNE   NDA                   NO\n         MVC   MSG2+2(2),=C'DA'      YES - MOVE IN DA\n         B     GDSO                 BRANCH TO GOT DSORG\nNDA      CLI   BUF1+38,X'02'        IS IT PO\n         BNE   NPO                   NO\n         MVC   MSG2+2(2),=C'PO'      YES - MOVE IN PO\n         B     GDSO                 BRANCH TO DSORG\nNPO      CLI   BUF1+38,X'01'        IS IT UNMOVEABLE\n         MVC   MSG2+2(2),=C' U'      YES\nGDSO     SR    R2,R2                ZERO REG 2\n         IC    R2,BUF1+15           PICK UP NUMBER OF EXTENTS\n         LA    R3,1                 SET EXTENT COUNTER\n         SR    R4,R4                CLEAR R4 TO TRK ACCUMULATION\n         LTR   R2,R2               NO XTNTS? - GDG PATTERN. DSCB\n         BZ    VVALID               YES, BYPASS ACCUMULATE\n         LA    R5,BUF1+61           POINT TO FIRST EXTENT\nVXTLOOP  MVC   0(10,R9),0(R5)      MOVE EXTENT TO SAVE AREA\n         LA    R9,10(R9)           BUMP TO NEXT SAVE AREA\n         MVC   HWK1(2),6(R5)        MOVE HI-CYL TO HWD\n         LH    R0,HWK1              LOAD\n         MVC   HWK1(2),8(R5)        MOVE HI-TRK TO HWD\n         LH    R1,HWK1              LOAD\n         MVC   HWK1(2),2(R5)        MOVE LOW-CYL TO HWD\n         SH    R0,HWK1              SUBTRACT\n         MVC   HWK1(2),4(R5)        MOVE LOW-TRK TO HWD\n         SH    R1,HWK1              SUBTRACT\n         MH    R0,VOLTKCYL          CONVERT CYL TO TRK\n         AR    R1,R0                GET TOTAL MINUS1\n         LA    R4,1(R1,R4)          GET TOTAL AND ACCUMULATE\n         CR    R3,R2                DONE LAST EXTENT?\n         BE    VVALID               GO TO VVALID IF SO\n         LA    R3,1(R3)             BUMP TO EXTENT COUNTER\n         CH    R3,=H'4'             FOURTH EXTENT?\n         BE    VXT4                   BRANCH IF SO\n         CH    R3,=H'8'             EIGHTTH EXTENT?\n         BE   VXT8\n         LA    R5,10(R5)            ELSE BUMP EXTENT POINTER\n         B     VXTLOOP              AND GO TO NEXT EXTENT\nVXT4     MVC   VTOCCHHR(5),BUF1+91  POINT NEXT DSCH(F2 OR F3)\nVXT4OBT  OBTAIN SEEKCAM\n         CLI   BUF1+44,C'3'         IF IT F3 DSCB\n         BE    VXT4F3               BRANCH IF SO\n         MVC   VTOCCHHR(5),BUF1+135  ELSE ITS F2-POINT TO F3\n         B     VXT4OBT\nVXT4F3   LA    R5,BUF1+4            POINT TO FIRST EXTENT IN F3\n         B     VXTLOOP              CONTINUE LOOP FOR SIZE\nVXT8     LA    R5,BUF1+45           SKIP OVER F3 ID IN F3 DSCB\n         B     VXTLOOP              CONTINUE LOOP FOR SIZE\nVVALID   EQU   *\n* CONVERT SPACE ALLOC AND EDIT IN PRINT LINE\n         CVD   R4,WKD               CONVERT DEC. R4  #TRKS ALLOC\n         MVC   MSG2+5(6),MASKED      MOVE MASKED FIELD IN\n         ED    MSG2+5(6),WKD+5       EDIT  # TRKS MSG2+5\n         TM    DSORG,X'42'        IS IT PO OR PS\n         BNZ   CVDU                  YES - BRANCH\n         MVI   MSG2+17,C'*'\n         B     CVDX                 BRANCH TO EXTENT CONVERSION\nCVDU     LH    R6,LASTTRK            GET LAST RELATIVE TRACK\n         LR    R7,R4\n         SR    R7,R6                 R7 CONTAINS UNUSED SPACE\n         CVD   R7,WKD               CONVERT DEC R7\n         MVC   MSG2+12(6),MASKED      MOVE IN MASKED FIELD\n         ED    MSG2+12(6),WKD+5       EDIT # TRKD UNUSED\nCVDX     CVD   R2,WKD                   PICK UP # EXTENTS\n         MVC   MSG2+20(4),MASKED      MOVE IN MASKED FIELD\n         ED    MSG2+20(4),WKD+6      EDIT # EXTENTS USED\n         MVC   MSG2+27(44),DSN1     MOVE DSN TO PRINT LINE\n         TPUT  MSG2,76             WRITE OUT LINE\n         TM    FLAG,X'A0'          AUTHORIZED USER?\n         BNO   OBTNRET              NO\n         LA    R9,XTNTS            POINT TO EXTENT SAVE AREA\n         MVC   MSG2(6),VOLS        MOVE VOLSER TO MESSAGE AREA\nOUTLOOP  LA    R3,3                SET LOOP CONTROL\n         LA    R4,MSG2+8           POINT TO MESSAGE AREA\n         MVI   MSG2+6,X'40'\n         MVC   MSG2+7(69),MSG2+6   BLANK MESSAGE AREA\nINLOOP   MVC   WXTNT+3(1),1(R9)    MOVE EXTENT # TO WORK AREA\n         UNPK  0(2,R4),WXTNT+3(2)  UNPACK EXTENT #\n         TR    0(1,R4),TRTBL       TRANSLATE EXTENT #\n         MVC   WXTNT(4),2(R9)      MOVE BEGIN XTNT TO WORK AREA\n         UNPK  2(9,R4),WXTNT(5)    UNPACK XTNT\n         TR    2(8,R4),TRTBL       TRANSLATE EXTENT\n         MVC   WXTNT(4),6(R9)      MOVE END XTNT TO WORK AREA\n         UNPK  11(9,R4),WXTNT(5)   UNPACK XTNT\n         TR    11(8,R4),TRTBL      TRANSLATE EXTENT\n         LA    R9,10(R9)           BUMP TO NEXT EXTENT\n         LA    R4,22(R4)           BUMP MESSAGE AREA POINTER\n         BCTR  R2,0                DECREASE # EXTENTS\n         LTR   R2,R2               ANY MORE EXTENTS\n         BZ    *+8                  NO\n         BCT   R3,INLOOP           CONVERT NEXT EXTENT\n         LA    R0,L'MSG2\n         LA    R1,MSG2\n         SVC   93                  TPUT EXTENTS\n         MVC   MSG2(6),BLANKS      BLANK VOLSER\n         LTR   R2,R2               ANY MORE EXTENTS?\n         BNZ   OUTLOOP              YES\nOBTNRET  LM    R2,R11,OBTNSAVE     RELOAD CALLER'S REGISTERS\n         BR    R9                  RETURN TO CALLER\n         TITLE 'LISTSPC - EOJ AND ERROR ROUTINES'\nRETC     EQU   *\n         L     13,SAVE+4           LOAD R13 PREVIOUS SPACE AREA\n         LM    2,12,28(13)         RELOAD REGISTERS\n         L     14,12(13)           LOAD RETURN ADDRESS\n         MVI   12(13),X'FF'        INDICATE CONTROL RETURN CALLING PROG\n         BCR   15,14               RETURN TO CALLING PROGRAM\n         SPACE 3\nERR01    EQU   *\n* NO VALID COMMAND\n         TPUT  ERMSG1,18\n         B     RETC                BRANCH TO RETURN CODE\n* DATASET NAME NOT FOUND\nERR03    MVC   MSG2(L'ERMSG9),ERMSG9\n         MVC   MSG2+L'ERMSG9(44),DSN1\n         LA    R0,L'ERMSG9+44\n         LA    R1,MSG2\n         SVC   93\n         TM    FLAG,X'40'\n         BO    LOOP\n         TM    FLAG,X'10'\n         BO    RETDSN\n         B     OBTNRET\n         SPACE 3\nRDERR    MVC   MSG2(L'ERMSG8),ERMSG8\n         MVC   MSG2+L'ERMSG8(44),DSN1\n         LA    R0,L'ERMSG8+44\n         LA    R1,MSG2\n         SVC   93\n         B     LOOP                CONTINUE THRU LOOP\n         SPACE 3\nNOUSER   MVC   MSG2(L'ERMSG3),ERMSG3\n         MVC   MSG2+L'ERMSG3(44),USERID\n         LA    R0,L'ERMSG3+44\n         LA    R1,MSG2\n         SVC   93\n         B     RETC                RETURN TO SYSTEM\n         SPACE 3\nNOTDISK  MVC   MSG2(L'ERMSG6),ERMSG6\n         MVC   MSG2+L'ERMSG6(44),DSN1\n         LA    R0,L'ERMSG6+44\n         LA    R1,MSG2\n         SVC   93\n         B     LOOP                PICK UP NEXT DATASET\n         SPACE 3\nMULTIVOL MVC   MSG2(L'ERMSG7),ERMSG7\n         MVC   MSG2+L'ERMSG7(44),DSN1\n         LA    R0,L'ERMSG7+44\n         LA    R1,MSG2\n         SVC   93\n         B     LOOP                CONTINUE WITH NEXT DSN\n         SPACE 3\nERRF     EQU   *\n         TPUT  ERMSG10,20\n         B     RETC\nERRF4    EQU   *                   ERROR READING F4\n         TPUT  ERMSG11,21\n         B     VOLRET\nUSIDMVC  MVC   0(0,R8),0(R10)\nDSNMVC   MVC   0(0,R8),0(R5)\nMVCVOLS  MVC   0(0,R1),0(R5)\n         TITLE 'LISTSPC - DATA AREAS'\nENDLIST  DS    0F\n         DC    XL4'FF000000'\n* SETUP CONSTANTS\nVOLDSCTK DC    H'0'                NUM DSCH ON A TRK\nVOLF4CHR DC    XL5'00'             CCHHR OF DSCB\nVOLNO    DC    H'0'                NUM VOLUMES PROCESSED\nPEXCTR   DC    H'0'                CTR FOR TATAL NUM FREE SPACE\nLASTTRK  DC    H'0'\nDSN1     DC    CL44' '              DATASET NAME\nDSNSAVE  DC    CL44' '\nVOLS     DC    CL6' '                 VOLUME SER\nUSERID   DC    CL44' '              USERID\nFLAG     DC    X'00'\nDSORG    DC    X'00'\nBLANKS   DC    CL6' '\nBUF1     DS    0D\n         DS    265C\nTRTBL    EQU   *-240\n         DC    C'0123456789ABCDEF'\nMASKED   DC    XL6'402020202120'   MASK FIELD FOR EDIT\n         SPACE 3\n* MESSAGE TO BE PRINTED\nMSG1     DC    C'DSORG ALLOC UNUSED EXTENTS DSNAME'\nMSG2     DC    CL76' '\nMSG4     DC    C'VOLUME DSCBS EXTENTS TRACKS     MAX         '\nMSG4A    DC    C'VOLUME DSCBS EXTENTS TRACKS     MAX    INDEX'\n*                0----0----1----1----2----2----3----3----4----4\n*                0----5----0----5----0----5----0----5----0----5\n         SPACE 3\n* ERROR MESSAGES\nERMSG1   DC    C'NO VALID COMMAND'\nERMSG3   DC    C'INVALID LEVEL - '\nERMSG6   DC    C'DSN NOT ON DISK - '\nERMSG7   DC    C'DSN ON MULTIVOLUMES - '\nERMSG8   DC    C'ERROR READING CATALOG DSN - '\nERMSG9   DC    C'DSN NOT FOUND - '\nERMSG10  DC    C'UNSUPPORTED KEYWORD'\nERMSG11  DC    C'ERROR READING F4 DSCB'\n         SPACE 4\n         LTORG\n         EJECT\n********************************************************************CST\n*                                                                   CST\n*  ROUTINES ADDED TO INTERFACE WITH INDEXED VTOCS.  THE FOLLOWING   CST\n*  STEPS ARE NEEDED                                                 CST\n*     1.  FIND UCB ADDRESS IN ORDER TO PASS UNIT ADDRESS TO         CST\n*         DYNAMIC ALLOCATE.                                         CST\n*     2.  DYNAMICALLY ALLOCATE VTOC                                 CST\n*     3.  OPEN VTOC                                                 CST\n*     4.  CALL IXTOFMT5 TO RETURN PSUEDO FORMAT-5S                  CST\n*     5.  CLOSE VTOC                                                CST\n*     6.  DEALLOCATE VTOC                                           CST\n* ZZZZ                                                              CST\n********************************************************************CST\n         SPACE 4                                                    CST\n********************************************************************CST\n*                                                                   CST\n*  I X I N I T                                                      CST\n*                                                                   CST\n********************************************************************CST\n*                                                                   CST\n*  INITIALIZE FOR READING IX VTOC                                   CST\n*                                                                   CST\nIXINIT   XC    IXWORD,IXWORD           ZERO WORK WORD FOR 1ST CALL  CST\n         MVC   DS4VTOCI,BUF1+14        SAVE VTOC INDICATOR FLAG BYTECST\n         TM    DS4VTOCI,DS4IVTOC       THIS VTOC INDEXED?           CST\n         BZR   R11                     IF NO, QUIT                  CST\n*                                                                   CST\n*  FIND UCB FOR THIS VOLUME. (FROM MAS'S ROUTINE IN HASPXEQ.)       CST\n*                                                                   CST\nURX$UCBS L     R15,16                  @ CVT                        CST\n         L     R15,CVTILK2(,R15)       @ UCB LOOKUP LIST            CST\n         SLR   R1,R1                   CLEAR FOR ICM                CST\n         SPACE 1                                                    CST\nURX$UCBN ICM   R1,3,0(R15)             @ UCB                        CST\n         LA    R15,2(,R15)             @ NEXT UCB                   CST\n         BZ    URX$UCBN                SKIP IF NULL                 CST\n         C     R1,=X'0000FFFF'         END OF LIST?                 CST\n         BNE   *+8                     NO. NO ON.                   CST\n         EX    0,*                     YES. DIE.                    CST\n         CLI   UCBDVCLS(R1),UCB3DACC   DASD?                        CST\n         BNE   URX$UCBN                NO. SKIP AND GET NEXT.       CST\n         CLC   VOLS(6),=C'ALL   '                                   CST\n         BE    IXGOTUCB                                             CST\n         CLC   UCBVOLI(6,R1),VOLS      DESIRED VOLUME?              CST\n         BNE   URX$UCBN                GET NEXT                     CST\n*                                                                   CST\n*  DYNALOC VTOC                                                     CST\n*                                                                   CST\nIXGOTUCB MVC   IXKUNT+6(3),UCBNAME(R1) SET UP DYNALOC UNIT.         CST\n         MVC   IXKVOL+6(6),VOLS        SET UP DYNALOC VOL.          CST\n         LA    R1,AIX99RBA             POINT TO PARM LIST           CST\n         DYNALLOC                      CALL SVC99                   CST\n         LTR   R15,R15                 DID IT WORK?                 CST\n         BZ    *+8                     BIF YES                      CST\n         EX    0,*                     ELSE DIE                     CST\n*                                                                   CST\n* OPEN VTOC                                                         CST\n*                                                                   CST\n         MVC     IXDCB+DCBDDNAM(8),IXKDDN+6  MOVE DDNAME TO DCB     CST\n         RDJFCB  IXDCB                 READ IN JFCB                 CST\n         MVC   IXJFCB(44),=44XL1'04'   DSNAME FOR VTOC              CST\n         OPEN  (IXDCB,(INPUT)),TYPE=J  OPEN VTOC                    CST\n         TM    IXDCB+48,X'10'          DID IT WORK?                 CST\n         BOR   R11                     YES. ALL READY.              CST\n         EX    0,*                     NO. FAIL.                    CST\n         SPACE 4                                                    CST\n********************************************************************CST\n*                                                                   CST\n*  I X F M T 5                                                      CST\n*                                                                   CST\n********************************************************************CST\n*                                                                   CST\n*  GET A PSUEDO FORMAT-5 FROM AN IX VTOC                            CST\n*                                                                   CST\nIXFMT5   TM    DS4VTOCI,DS4IVTOC       VTOC IS INDEXED?             CST\n         BZ    4(,R11)                 IF NOT, SKIP                 CST\n         LA    R1,IXPARM               POINT TO PARMLIST            CST\n         L     R15,=V(IXTOFMT5)        POINT TO ROUTINE             CST\n         BALR  R14,R15                 CALL INTERFACE ROUTINE       CST\n         LTR   R15,R15                 DID IT WORK?                 CST\n         BZR   R11                     IF SO, CONTINUE              CST\n         EX    0,*                     ELSE DIE.                    CST\n         SPACE 4                                                    CST\n********************************************************************CST\n*                                                                   CST\n*  I X T E R M                                                      CST\n*                                                                   CST\n********************************************************************CST\n*                                                                   CST\n*  CLOSE VTOC DCB AND FREE ALLOCATION                               CST\n*                                                                   CST\nIXTERM   TM    DS4VTOCI,DS4IVTOC       VTOC IS INDEXED?             CST\n         BZR   R11                     IF NOT, SKIP                 CST\n         CLOSE IXDCB                   CLOSE THE VTOC               CST\n         MVC     IXKDDN2+6(8),IXKDDN+6 MOVE DDNAME TO DEALLOC LIST  CST\n         LA    R1,AIX99RBF             POINT TO PARMLIST            CST\n         DYNALLOC                      FREE VTOC                    CST\n         LTR   R15,R15                                              CST\n         BZR   R11                     RETURN                       CST\n         EX    0,*                     RETURN                       CST\n         SPACE 4                                                    CST\n********************************************************************CST\n*                                                                   CST\n*  I X P R I N T                                                    CST\n*                                                                   CST\n********************************************************************CST\n*                                                                   CST\n*  CORRECT DSCB COUNT AND SHO VIRS FOR STAFF                        CST\n*                                                                   CST\nIXPRINT  EQU   *                                                    CST\n         TM    DS4VTOCI,DS4IVTOC       VTOC IS INDEXED?             CST\n         BO    IXPRIN2                 IF SO,                       CST\n         TM    FLAG,X'40'              STAFF?                       CST\n         BZR   R11                     IF NOT, ALL DONE             CST\n         MVC   MSG2+38(6),=C'OS FMT'   TELL STAFF ABOUT FORMAT      CST\n         BR    R11                     DONE                         CST\nIXPRIN2  L     R1,IXCT1                USE DSCB 0 COUNT FROM IX     CST\n         CVD   R1,WKD                  CONVERT IT                   CST\n         MVC   MSG2+6(6),MASKED        MOVE IN MASK                 CST\n         ED    MSG2+6(6),WKD+5         EDIT FREE DSCB               CST\n         TM    FLAG,X'40'              STAFF?                       CST\n         BZR   R11                     IF NOT, ALL DONE             CST\n         L     R1,IXCT2                NUMBER OF FREE VIRS          CST\n         CVD   R1,WKD                  CONVERT IT                   CST\n         MVC   MSG2+38(6),MASKED       MOVE IN MASK                 CST\n         ED    MSG2+38(6),WKD+5        EDIT FREE DSCB               CST\n         BR    R11                     RETURN.                      CST\n         EJECT ,                                                    CST\n*                                                                   CST\n*  PARMLIST FOR INTERFACE ROUTINE                                   CST\n*                                                                   CST\nIXPARM   DC    A(IXWORD)               @ WORK WORD                  CST\n         DC    A(IXDCB)                @ VTOC DCB                   CST\n         DC    A(IXCT1)                @ CNT - FREE FMT 0S          CST\n         DC    A(IXCT2)                @ CNT - FREE VIRS            CST\n         DC    A(BUF1)                 @ BFR FOR FMT5               CST\nIXWORD   DC    F'0'                    WORK WORD                    CST\nIXCT1    DC    F'0'                    COUNT FREE FMT0              CST\nIXCT2    DC    F'0'                    COUNT FREE VIRS              CST\n         SPACE 2                                                    CST\n*                                                                   CST\n*  PARMLIST FOR VTOC ALLOCATE                                       CST\n*                                                                   CST\n         PRINT GEN,DATA                                             CST\nAIX99RBA DC    0F'0',X'80',AL3(IX99RBAL)                            CST\nIX99RBAL DC    AL1(20,1)               LENGTH, VERB                 CST\n         DC    X'4000'                 FLAG1 (DON'T USE EXISTING)   CST\n         DC    AL2(0,0)                ERROR CODE, INFO CODE        CST\n         DC    A(IX99TXT1)             @ TEXT UNITS                 CST\n         DC    2F'0'                   RSVD, FLAG2                  CST\nIX99TXT1 DC    A(IXKDDN,IXKVOL,IXKUNT,IXKOLD)                       CST\n         DC    X'80',AL3(IXKKEP)                                    CST\nIXKDDN   DC    AL2(85,1,8),C'SYS99999' DDNAME ASSIGNED              CST\nIXKVOL   DC    AL2(16,1,6),C'XXXXXX'   VOL=SER=                     CST\nIXKUNT   DC    AL2(21,1,3),C'000'      UNIT=                        CST\nIXKOLD   DC    AL2(4,1,1),X'01'        DISP=OLD                     CST\nIXKKEP   DC    AL2(5,1,1),X'08'        DISP=KEEP                    CST\n         SPACE 4                                                    CST\n*                                                                   CST\n*  PARMLIST FOR VTOC DEALLOCATE                                     CST\n*                                                                   CST\nAIX99RBF DC    0F'0',X'80',AL3(IX99RBFR)                            CST\nIX99RBFR DC    AL1(20,2)               LENGTH, VERB                 CST\n         DC    X'0000'                 FLAG1                        CST\n         DC    AL2(0,0)                ERROR CODE, INFO CODE        CST\n         DC    A(IX99TXT2)             @ TEXT UNITS                 CST\n         DC    2F'0'                   RSVD, FLAG2                  CST\n         SPACE 2                                                    CST\nIX99TXT2 DC    A(IXKDDN2),X'80',AL3(IXKKEP)                         CST\nIXKDDN2  DC    AL2(1,1,8),C'SYS99999'  DDNAME ASSIGNED              CST\n         PRINT GEN,NODATA                                           CST\n         SPACE 4                                                    CST\n*                                                                   CST\n*  MISC CONSTANTS AND EQUATES                                       CST\n*                                                                   CST\nDS4VTOCI DC    X'00'                   VTOC INDICATOR BYTE          CST\nDS4IVTOC EQU   X'01'                   FLAG FOR INDEXED FMT VTOC    CST\nCVTILK2  EQU   40                      OFFSET TO LOOKUP TABLE       CST\nUCBNAME  EQU   13                      OFFSET TO UNITNAME           CST\nUCBDVCLS EQU   18                      OFFSET TO DEVICE CLASS       CST\nUCB3DACC EQU   X'20'                   CLASS=DIRECT ACCESS          CST\nUCBVOLI  EQU   28  '                   OFFSET TO DASD VOLSER        CST\nDCBDDNAM EQU   40                      OFFSET TO DDNAME             CST\n         SPACE 2                                                    CST\n*                                                                   CST\n*  DCB AND JFCB FOR VTOC                                            CST\n*                                                                   CST\nIXLST    DC    0F'0',X'87',AL3(IXJFCB)                              CST\nIXJFCB   DC    XL176'00'                                            CST\n         PRINT NOGEN                                                CST\nIXDCB    DCB   DSORG=PS,MACRF=(E),EXLST=IXLST,DDNAME=NONE           CST\n         PRINT GEN                                                  CST\n         SPACE 4                                                    CST\n         LTORG                                                      CST\n         EJECT\n* CAMLST FOR DSCB3\nSEEKCAM  CAMLST SEEK,VTOCCHHR,VOLS,BUF1\n         SPACE 2\n* CAMLST LOCATE DSN OV VOL SER\nINDS     CAMLST NAME,DSN1,,BUF1\n         SPACE 2\n* CAMLST FOR DSCB 1\nSERCHCAM CAMLST SEARCH,DSN1,VOLS,BUF1\n         EJECT\n* CONSTANTS AND WORK AREAS\nHWK1     DC    H'0'                HALF WORD WORK AREA\nVOLTKCYL DC    H'19'               # TRKS/CYL\nVTOCCHHR DC    XL5'0'              TRACK ADDR WORK AREA\nWKD      DC    D'0'                DOUBLE WORK WORK AREA\n         SPACE 3\n* PARM SETUP FOR GETDSN\nPARM     DC    A(USERID)           USERID ADDRESS\n         DC    A(DSN1)             DSN ADDRESS\n         DC    A(VOLS)             VOL SER ADDRESS\n         DC    A(0)                ADDRESS FOR GETMAIN\n         LTORG\n         SPACE 3\n         OACREGS\nRCC      EQU   R8\nRHH      EQU   R7\nRR       EQU   R6\n         TITLE 'LISTSPC - PARSE PARAMETER LIST'\n         PRINT NOGEN\nPARSLIST IKJPARM\nDSNKYD   IKJKEYWD\n         IKJNAME 'DATASET',SUBFLD=DSNSUBF\nLEVL     IKJKEYWD\n         IKJNAME 'LEVEL',SUBFLD=LVL\nVOLUME   IKJKEYWD\n         IKJNAME 'VOLUME',SUBFLD=VLM\nEXTENT   IKJKEYWD\n         IKJNAME 'EXTENTS'\nDSNSUBF  IKJSUBF\nDSNLIST  IKJPOSIT DSNAME,LIST\nLVL      IKJSUBF\nLEV      IKJIDENT 'LEVEL',OTHER=ANY,MAXLNTH=44\nVLM      IKJSUBF\nVOL      IKJIDENT 'VOLUME',LIST,FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=6\n         IKJENDP\n         IKJPPL\n         IKJCPPL\n         PRINT GEN\n         TITLE 'LISTSPC - WORK AREA'\nWORKAREA DSECT\nWPPL     DS    7A\nCPECB    DS    F\nWPDL     DS    F\nOBTNSAVE DS    10F\nXTNTS    DS    16XL10\nWXTNT    DS    CL5\n         DS    0D\nLOCINDXW EQU   *\nLWORK    EQU   *-WORKAREA\n         DROP  R13\n         DROP  R12\n         DROP  R3\n         EJECT\n*          DATA SET CBT502     AT LEVEL 001 AS OF 12/15/75\n*        LOCINDEX SUBROUTINE REPLACEMENT FOR MVS\n*        THIS ROUTINE SUPPORTS 'LEVEL' OPTIONS OF THE 'LISTS' COMMAND\n*             AND IS USED BY OTHER YCC VARIATIONS OF THAT PROGRAM\n*        FOLLOWING IS ORIGINAL LOCINDEX DESCRIPTION:\n*.....................................................................*\n*.                                                                   .*\n*.   LOCINDEX                                                        .*\n*.                                                                   .*\n*.....................................................................*\n*.                                                                   .*\n*.   1.0  GENERAL DESCRIPTION                                        .*\n*.                                                                   .*\n*.   THIS SUBROUTINE IS USED TO RETURN DSNAMES AND THE VOLSER        .*\n*.   FOR A SPECIFIED INDEX STRUCTURE.  THE INDEX STRUCTURE CAN BE    .*\n*.   SPECIFIED AS SEVERAL HIGH-LEVEL QUALIFIERS OR IT CAN BE A       .*\n*.   DSNAME CONTAINING ONE EMBEDDED ASTERISK NOT AS THE HIGH-LEVEL   .*\n*.   QUALIFIER.                                                      .*\n*.                                                                   .*\n*.....................................................................*\n*.                                                                   .*\n*.....................................................................*\n*.                                                                   .*\n*.   2.0  PARAMETER LIST AND RETURN CODE DESCRIPTION                 .*\n*.                                                                   .*\n*.   THE PARAMETER LIST IS A FOUR OR FIVE WORD LIST CONTAINING THE   .*\n*.   FOLLOWING:                                                      .*\n*.                                                                   .*\n*.    WORD         DESCRIPTION                                       .*\n*.                                                                   .*\n*.      1          ADDRESS OF THE 44-BYTE FIELD CONTAINING THE       .*\n*.                 INDEX STRUCTURE.                                  .*\n*.      2          ADDRESS OF THE 44-BYTE FIELD INTO WHICH           .*\n*.                 LOCINDEX WILL PLACE THE DSNAME.                   .*\n*.      3          ADDRESS OF THE 6-BYTE FIELD INTO WHICH            .*\n*.                 LOCINDEX WILL PLACE THE VOLSER OF THE DATASET.    .*\n*.      4          ADDRESS OF A 4K WORK AREA TO BE USED BY           .*\n*.                 LOCINDEX FOR STORING CATALOG BLOCKS.              .*\n*.      5          OPTIONAL FIELD FOR THE ADDRESS OF A FULLWORD      .*\n*.                 OF STORAGE ON AN INTEGRAL BOUNDARY INTO WHICH     .*\n*.                 LOCINDEX WILL STORE THE RETURN CODE.              .*\n*.                                                                   .*\n*.   THE HIGH ORDER BIT OF THE LAST WORD OF THE PARAMETER LIST       .*\n*.   MUST BE SET ON.                                                 .*\n*.                                                                   .*\n*.    RETURN CODE  MEANING                                           .*\n*.                                                                   .*\n*.         0       A DSNAME WAS FOUND AND THE DATASET RESIDES ON     .*\n*.                 A DISK VOLUME.                                    .*\n*.         4       THE INDEX STRUCTURE WAS NOT FOUND.                .*\n*.         8       A DSNAME WAS FOUND AND THE DATASET RESIDES ON     .*\n*.                 A TAPE VOLUME.                                    .*\n*.        12       A DSNAME WAS FOUND BUT IT RESIDES ON MULTIPLE     .*\n*.                 VOLUMES.                                          .*\n*.        16       THERE ARE NO MORE DATASETS FOR THIS INDEX         .*\n*.                 STRUCTURE.                                        .*\n*.        20       AN I/O ERROR WAS DETECTED ON THE CATALOG.         .*\n*.                                                                   .*\n*.....................................................................*\n*\n*        THE PRIMARY DIFFERENCES BETWEEN THE MVS VERSION\n*        AND THE OS VERSION ARE:\n*              1) THE PART ABOVE THE ASTERISK IS PASSED TO VSAM\n*                 GENERIC LOCATE AND WORKS HOWEVER GENERIC LOCATE\n*                 LOCATE WORKS. ONLY NON-VSAM DATASETS ARE PASSED\n*                 BACK TO THE CALLER.\n*              2) THE CHARACTERS BELOW THE ASTERISK MUST APPEAR\n*                 IN THE DATASET NAME ANYWHERE AFTER THE SEARCH\n*                 KEY CHARACTERS. THEY MAY CONTAIN LEADING\n*                 AND TRAILING PARTIAL INDEX LEVELS.\n*              3) THE AMOUNT OF STORAGE REQUIRED FOR A VSAM GENERIC\n*                 LOCATE IS MUCH MORE THAN THE 4K AREA PROVIDED BY\n*                 THE OS CALLER. A 24K AREA IS GETMAINED AND ITS\n*                 ADDRESS IS STORED IN THE FIRST WORK OF THE 4K\n*                 CALLER WORK AREA. IT IS FREEMAINED WHEN THE\n*                 RETURN CODE OF 16 SIGNALS THE END OF DATASETS\n*                 UNDER THIS INDEX.\n*              5) THE 265 BYTE CAMLIST WORK AREA IS PUT IN THE\n*                 CALLER PROVIDED WORK AREA AT OFFSET 4. THIS\n*                 ALLOWS ACCESS TO THE COMPLETE VOLUME LIST.\n         EJECT\nLOCINDEX CSECT\n         USING *,15\n         SAVE  (14,12),,*\n         GETMAIN R,LV=LSECT\n         ST    R13,4(R1)\n         ST    R1,8(13)\n         LR    R12,R13\n         LR    R13,R1\n         L     R1,24(R12)\n         BALR  R12,0\n         USING *,12\n         USING DSASECT,R13\n         ST    R1,INPARM\n         L     R10,12(R1)\n         USING WORKSECT,R10\n         L     R2,0(R1)\n         CLC   OINDEX,0(R2)   SAME INDEX STRUCTURE AS LAST CALL?\n         BE    CAMLOC         GO GET NEXT DATASET\n         MVC   OINDEX,0(R2)\n         SPACE 10\nBLDKEY   DS    0H\n*        THIS BLOCK ANALIZES THE NEW INDEX STRUCTURE INTO COMPONENTS\n*        IT CONSTRUCTS A VSAM CATALOG GENERIC SEARCH KEY AND AN\n*        OPTIONAL LOWER LEVEL QUALIFIER VERIFICATION STRING\n*        ONE ASTERISK IS ALLOWED ANYWHERE BELOW THE USERID.\n*        IT MAY REPRESENT ALL OR PART OF AN 'INDEX LEVEL'\n*        EXITS: NORMAL TO 'GENLOC'\n*               TO 'ERROR4' IF A SYSTAX ERROR OCCURS IN INDEX STRUCTURE\n         SR    R1,R1\n         SR    R2,R2          CLEAR FOR TRT INSTRUCTION\n         MVI   TRTAB,0\n         MVC   TRTAB+1(255),TRTAB\n         MVI   TRTAB+C' ',4\n         MVI   TRTAB+C'*',8\n         MVI   TRTAB+C'.',12\n         MVC   KEY,OINDEX     COPY INDEX INPUT\n         TRT   KEY,TRTAB\n         BZ    ERROR4         MUST BE A BLANK IN 44 CHARS\n         B     *(R2)\n         B     USERIDXX       C' ' MUST BE A USERID\n         B     ERROR4         C'*' ASTERISK MUST FOLLOW PERIOD\n         B     COMPLEX        C'.' MUST DO FULL ANALYSIS OF STRUCTURE\n         SPACE 5\nUSERIDXX DS    0H\n*        THIS BLOCK BUILDS SEARCH KEY FOR USERID. MUST BE <9 CHARACTERS\n*        AND WE ADD A PERIOD TO IT TO INDICATE TO GENERIC LOCATE\n*        THAT WE ARE INTERESTED IN THE DATASETS UNDER THE NAME AND\n*        NOT THE ALIAS RECORD (CVOL POINTER) OF THE NAME ITSELF.\n         MVI   0(R1),C'.'\n         LA    R3,KEY\n         SR    R1,R3\n         CH    R1,=H'8'\n         BH    ERROR4\n         LA    R1,1(R1)\n         STC   R1,NAME        STORE KEY LENGTH\n         MVI   LREST,X'80'\n         B     GENLOC\n* END OF USERID\n         SPACE 5\nCOMPLEX  DS    0H\n*        NOW WE SEARCH FOR AN IMBEDDED ASTERISK IN INDEX STRUCTURE\n*        CHARACTERS ABOVE IT ARE USED AS THE GENERIC KEY.\n*        CHARACTERS AFTER IT ARE USED AS THE LOWER LEVEL QUALIFIERS.\n         MVI   TRTAB+C'.',0   NO LONGER INTERESTED IN PERIODS\n         TRT   KEY,TRTAB\n         BZ    ERROR4\n         B     *(R2)\n         B     ONEPART        NO ASTERISK\n         B     TWOPART\n         SPACE 5\nONEPART  MVI   LREST,X'80'\n         LA    R3,KEY\n         SR    R1,R3\n         STH   R1,LKEY\n         STC   R1,NAME\n         B     GENLOC\n         SPACE 5\nTWOPART  DS    0H\n*        THIS BLOCK HANDLES THE CASE WHERE THERE IS AN EMBEDDED\n*        ASTERISK IN THE INDEX LEVEL. THE CHARACTERS BELOW THE\n*        ASTERISK ARE MOVED TO 'REST'. THE CHARACTERS FROM THE\n*        ASTERISK ON ARE BLANKED IN 'KEY'. THE LENGTH OF THE\n*        NON BLANK PART OF 'REST' LESS ONE IS SAVED IN 'LREST'\n*        FOR USE IN THE LATER CLC INSTRUCTION. THE LENGTH OF\n*        THE KEY IS SAVED IN 'NAME' FOR THE GENERIC LOCATE AND\n*        IN 'LKEY' FOR AN INDICATION OF HOW MANY CHARS TO\n*        SKIP BEFORE LOOKING IN A DSN FOR A MATCH TO 'REST'.\n         LA    R3,KEY+42\n         SR    R3,R1         GET LENGTH OF KEY ABOVE ASTERISK\n         MVC   REST,=CL44' ' INITIALIZE REST\n         EX    R3,MOVREST    MOVE PART BELOW ASTERISK\n         LA    R3,1(R3)\n         EX    R3,BLNKEY     BLANK KEY FROM ASTERISK ON\n         SH    R3,=H'43'\n         LPR   R3,R3         GET CHARS ABOVE ASTERISK\n         STH   R3,LKEY\n         STC   R3,NAME\n         TRT   REST,TRTAB    FIND NON-BLANK LENGTH OF REST\n         B     *(R2)\n         B     LENRST\n         B     ERROR4        SORRY, ONLY ONE * PER CUSTOMER\nLENRST   LA    R3,REST+1     CALCULATE LENGTH FROM ADDRESS\n         SR    R1,R3            OF FIRST BLANK\n         STH   R1,LREST\n         B     GENLOC\nMOVREST  MVC   REST(0),1(R1)\nBLNKEY   MVC   0(0,R1),=CL44' '\n* END OF TWOPART\n* END OF COMPLEX\n* END OF BLDKEY\n         EJECT\nGENLOC   DS    0H\n*        THIS BLOCK ISSUES A VSAM GENERIC LOCATE TO BUILD AN IN-CORE\n*        LIST OF DATASETS THAT BEGIN WITH THE SEARCH KEY\n*        THERE IS NO GOOD DOCUMENTATION ON THE GENERIC\n*        LOCATE IN THE LITERATURE. SEE THE CATALOG PLM FOR\n*        WHAT LITTLE THERE IS. THE FORM BELOW WAS INFERRED\n*        FROM SOME FICHE AND BY INTERCEPTING SVC 26 WITH DSS.\n         MVC   GENFLAG,=X'05201100'\n         XC    GENX1,GENX1\n         XC    GENX2,GENX2\n         LA    R1,NAME\n         ST    R1,GENNAME\n         GETMAIN R,LV=X'7FF8'\n         ST    R1,GETADDR\n         ST    R1,GENWORK\n         MVC   0(4,R1),=X'7FF80004'\n         LA    R1,GENPARM\n         SVC   26\n         LTR   R15,R15\n         BNZ   ERROR4\n         L     R1,GETADDR    GET VSAM CATLG RETURN AREA\n         LA    R1,0(R1)       CLEAR HIGH BYTE\n         LH    R2,2(R1)       GET NUMBER BYTES USED\n         AR    R2,R1          ADD START ADDR\n         ST    R2,LAST        SAVE LAST BYTE ADDR\n         LA    R1,49(R1)      SKIP 4 BYTE PREFIX AND FIRST 45 BYTE ENTR\n         ST    R1,NEXT        SAVE ADDR OF FIRST DSN ENTRY\n* END OF GENLOC\n         SPACE 10\nCAMLOC   DS    0H\n*        NOW DO A REGULAR CAMLIST NAME LOCATE FOR THE NEXT NON-VSAM\n*        DATASET IN THE INCORE LIST\n         XC    CAMLST(16),CAMLST\n         LA    R1,KEY\n         ST    R1,CAMLST+4\n         LA    R1,VOLCNT\n         ST    R1,CAMLST+12\n         L     R1,NEXT\nTEST     C     R1,LAST\n         BNL   RET16          NO MORE DATASETS IN LIST\n         CLI   0(R1),C'A'     IS IT NON-VSAM\n         BE    S1\nNOGO     LA    R1,45(R1)\n         B     TEST\nS1       TM    LREST,X'80'    IS THERE A LOWER QUALIFIER\n         BO    S2             NO, SO GO LOCATE\n         SPACE 5\nTESTQUAL DS    0H\n*        THIS CODE LOOKS FOR THE CHARACTER STRING BELOW THE\n*        ASTERISK IN THE INDEX SEARCH KEY. THIS STRING MUST\n*        BE SOMEWHERE IN THE DATASET NAME BELOW THE KEY OR\n*        THE NAME IS REJECTED\n         LA    R2,1(R1)\n         AH    R2,LKEY        SKIP GENERIC KEY CHARS\n         LH    R3,LREST       GET # CHARS-1 IN REST\n         LA    R4,44\n         SR    R4,R3\n         SH    R4,LKEY        R4=# CHARS BELOW KEY + 1\nCOMP     EX    R3,COMPAR\n         BE    S2\n         LA    R2,1(R2)\n         BCT   R4,COMP\n         B     NOGO\nCOMPAR   CLC   REST(0),0(R2)\n* END OF TESTQUAL\n         SPACE 5\nS2       DS    0H\n*        NOW TO ISSUE NORMAL LOCATE BY NAME AND RETURN INFORMATION\n*        ACCORDING TO DESCRIPTION OF PARAMETERS IN LEADING DOCUMENT\n         MVC   KEY,1(R1)      COPY DSN\n         LA    R1,45(R1)      PT TO NXT DSN\n         ST    R1,NEXT        SAVE FOR NXT TIME\n         LA    R1,CAMLST\n         SVC   26             LOCATE BY NAME\n         L     R2,INPARM      NOW GET PASSED PARM LIST\n         LM    R2,R3,4(R2)    PICK UP 2ND & 3RD USER PARMS\n         MVC   0(44,R2),KEY   SAVE DSN\n         MVC   0(6,R3),SER    SAVE VOL\n         TM    DEVT+2,X'20'   IS THIS DISK\n         BZ    ERROR8         NO, PASS 8 RETURN CODE\n         CLI   VOLCNT+1,1     IS IT MULTI-VOL\n         BNE   ERROR12        YES, PASS 12 RETURN CODE\n* END OF CAMLOC\n         SPACE 10\n*VARIOUS RETURNS\nRETN     SR    R15,R15\n         B     RC\nERROR4   LA    R15,4\n         B     RC\nERROR8   LA    R15,8\n         B     RC\nERROR12  LA    R15,12\n         B     RC\nRET16    FREEMAIN R,LV=X'7FF8',A=GETADDR\n         LA    R15,16\n         B     RC\nERROR20  LA    R15,20\nRC       L     R1,INPARM\n         TM    12(R1),X'80'\n         BO    EXIT\n         L     R1,16(R1)\n         ST    R15,0(R1)\nEXIT     L     R13,4(R13)\n         ST    R15,16(R13)\n         L     R1,8(R13)\n         FREEMAIN R,LV=LSECT,A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         LTORG\n         EJECT\nDSASECT  DSECT\n         DS    18A\nGENPARM  DS    0F            GENERIC LOCATE PARM AREA\nGENFLAG  DS    F\nGENNAME  DS    A\nGENX1    DS    A\nGENWORK  DS    A\nGENX2    DS    3A\nKEYLEN   DS    0H\n         DS    X\nNAME     DS    X\nKEY      DS    CL44\nINPARM   DS    A             SAVE R1 UPON ENTRY TO LOCINDEX\nCAMLST   DS    4A\n         DS    0D\nLSECT    EQU   *-DSASECT\n         SPACE 10\nGETSECT  DSECT               GETMAINED VSAM WORK AREA\nGETLEN   DS    H             LENGT OF AREA\nGETUSED  DS    H             AMOUNT ALLOCATED CURRENTLY TO DATA\nGETENTY  DS    0CL45         FIRST ELEMENT OF DSN ARRAY\nGETTYPE  DS    C             TYPE FLAG ('A'=NONVSAM)\nGETNAME  DS    CL44          DSN\n         SPACE 10\nWORKSECT DSECT               WORK AREA PASSED AS PARM\nGETADDR  DS    A             ADDRESS OF GETMAINED VSAM WORK AREA\nTRTAB    DS    0CL256\nVOLCNT   DS    H\nDEVT     DS    XL4\nSER      DS    CL6\nSEQ      DS    H\n         DS    CL251\nOINDEX   DS    CL44          PREVIOUS VALUE OF FIRST PARM\nREST     DS    CL44          LOW QUALIFIER COMPARE STRING\nNEXT     DS    A             ADDRESS OF NEXT DSN IN INCORE TABLE\nLAST     DS    A             ADDRESS OF BYTE AFTER END OF DSNLIST\nLKEY     DS    H             LENGTH OF GENERIC KEY\nNOREST   DS    0B            FLAG IF 'REST' IS EMPTY\nLREST    DS    H             LENGTH OF REST\n         END\n//*KED.SYSLMOD DD DISP=OLD,DSN=SYS1.OACLINK\n//LKED.XXX     DD DISP=SHR,DSN=SYS9.MSSLOAD\n//LKED.SYSIN DD *\n  INCLUDE XXX(IXTOFMT5)\n  ENTRY LISTSPC\n  NAME LISTSPC(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MOVEZAP": {"ttr": 6660, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x91\\x00\\x91\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 145, "newlines": 145, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMASZ JOB  ACCNT,NOTIFY=CSYSMAS,MSGCLASS=A\n/*ROUTE PRINT WYLBUR\n//COPY EXEC PGM=IEBCOPY\n//SYSPRINT DD SYSOUT=*\n//I        DD DISP=SHR,DSN=SYS1.LINKLIB\n//O        DD DISP=(SHR,CATLG),DSN=CSYSMAS.TMP.LOAD,\n//  UNIT=3350,VOL=SER=SYSDA1,SPACE=(CYL,(5,1,50))\n//SYSIN    DD *\n  C I=O,O=O\n  C I=((I,R)),O=O\n    S M=IEHMOVE\n    S M=IEHMVERA\n    S M=IEHMVERD\n    S M=IEHMVESA\n    S M=IEHMVESC\n    S M=IEHMVESE\n    S M=IEHMVESH\n    S M=IEHMVESI\n    S M=IEHMVESJ\n    S M=IEHMVESK\n    S M=IEHMVESL\n    S M=IEHMVESM\n    S M=IEHMVESN\n    S M=IEHMVESO\n    S M=IEHMVESP\n    S M=IEHMVESQ\n    S M=IEHMVESR\n    S M=IEHMVESS\n    S M=IEHMVEST\n    S M=IEHMVESU\n    S M=IEHMVESV\n    S M=IEHMVESX\n    S M=IEHMVESY\n    S M=IEHMVESZ\n    S M=IEHMVETA\n    S M=IEHMVETG\n    S M=IEHMVETJ\n    S M=IEHMVETL\n    S M=IEHMVXSE\n    S M=IEHMVXSF\n  C I=O,O=O\n//ZAP EXEC PGM=AMASPZAP\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DISP=SHR,DSN=CSYSMAS.TMP.LOAD\n//SYSIN    DD *\n*\n*   ZAP IEHMOVE (A COPY, NOT THE REAL ONE...)\n*    DON'T ALLOCATE WORK FILES (SYSUT1,SYSUT2,SYSUT3)\n*    DON'T USE OPENJ ON WORK FILES\n*    DON'T SCRATCH WORK FILES\n*\n*  RESULT: 1. DOESN'T REQUIRE AUTHORIZATION TO ALLOCATE WORK FILES\n*          2. WORK FILES CAN BE VIO\n*             (WORK FILES SHOULD BE CONTIG & ON SAME DEVICETYPE)\n*             (A S047 WILL RESULT IF THE UNAUTHORIZED VERSION TRIES\n*              TO ALLOCATE A DATASET - ALL OUTPUT DATASETS MUST\n*              BE ON TAPE OR PRE-ALLOCATED).\n*\n*   IT IS SOMETIMES USEFUL TO USE JUST A FEW OF THESE ZAPS, IE:\n*\n*   ALLOW VIO WORK FILES, RUN IEHMOVE AUTHORIZED,\n*   USE OACMOVE FRONT END TO PRELOAD IEHMOVE MODULES,\n*   AND COPY 3330(-11) TO 3350'S.  IF YOU HAVE INDEXED\n*   VTOC'S AND SHORT DATASETS THIS CAN BE 4 TIMES FASTER THAN\n*   NORMAL IEHMOVE.\n*\n*   RUN NON-AUTHORIZED TO IEHMOVE DSGROUP.. (OR OTHER) TO TAPE\n*   FOR ARCHIVING.  (IEHMOVE IS *THE* DEFINITION OF HOW TO COPY\n*   THE STRANGE TYPES OF DATASETS).  MOST OTHER COPY ROUTINES\n*   HAVE PROBLEMS WITH VBS OR DA DATASETS, OR ELSE USE A TRACK\n*   IMAGE TYPE COPY - NOT OS UTILITY COMPATIBLE.\n*   (HOWEVER SOME ARE MUCH FASTER, AND SOME ARE NOT).\n*\n*\n   NAME IEHMVXSE IEHMVSSE\n*   FICHE: IEHMVXSE UZ33853 8103 7F06\n   VER  067C  4710            ALLOW VIO FOR WORK FILES\n   REP  067C  4700             SO NOP THIS CHECK\n   VER  07E2  0A20            DON'T ISSUE ALLOCATE SVC (REQ AUTH)\n   REP  07E2  1BFF             SINCE FILES ALREADY ALLOCATED\n   VER  0A30  0A16            DON'T USE OPENJ ON WORK FILES\n   REP  0A30  0A13             USE NORMAL OPEN\n   VER  0A44  0A16            DON'T USE OPENJ ON WORK FILES\n   REP  0A44  0A13             USE NORMAL OPEN\n   VER  0A58  0A16            DON'T USE OPENJ ON WORK FILES\n   REP  0A58  0A13             USE NORMAL OPEN\n   VER  0C08  E2E8,E2E4,E3F1,4040  'SYSUT1' DDNAME IN DCB4\n   REP  0C08  E2E8,E2E4,E3F2,4040  MAKE IT SYSUT2\n   VER  0C60  E2E8,E2E4,E3F1,4040  'SYSUT1' DDNAME IN DCB5\n   REP  0C60  E2E8,E2E4,E3F3,4040  MAKE IT SYSUT3\n   IDRDATA CS0XXXX\n   NAME IEHMVESK IEHMVSSK\n* FICHE: IEHMVESK UZ24329\n   VER  024E  0A1D            DON'T SCRATCH WORK FILES\n   REP  024E  1BFF             (SCRATCH FAILS ON VIO VOLUME)\n   IDRDATA CS0XXXX\n***\n***   FOLLOWING NOT 100% CORRECT -\n***     THIS REMOVES THE SCRATCH OF THE WORK FILES FROM\n***     THE STAE EXIT, BUT IT ALSO REMOVES THE SCRATCH\n***     OF A POSSIBLE '**TEMP' FILE (ABORTED COPY).\n***\n   NAME IEHMOVE  IEHMVSSD\n* FICHE: IEHMOVE  UZ33823\n   VER  0142  0A1D            DON'T SCRATCH WORK FILES (IF ABEND)\n   REP  0142  1BFF             (SCRATCH FAILS ON VIO VOLUME)\n*  VER  009C  0A3C            DON'T ISSUE STAE (FOR TESTING)\n*  REP  009C  1BFF             (THIS IS FOR TESTING ONLY)\n   IDRDATA CS0XXXX\n***\n* REMOVE POSSIBLE DD CARD CONFLICTS BY REQUIRING\n* IEHMOVE <ANYNAME> DD CARDS TO HAVE DDNAMES WHICH START WITH \"$\".\n*\n   NAME IEHMVXSF IEHVOLMT\n* FICHE: IEHMVSSF UZ33823 8103 7D27\n   VER  0512  D507,2004,A452  CHECK DD NAME FOR BLANK\n   VER  0518  4780,A0C6\n   REP  0512  0700,955B,2004  NOPR, CLI DD NAME STARTS WITH '$'?\n   REP  0518  4770            REVERSE BRANCH (ONLY ACCEPT $ DD'S)\n   IDRDATA CS0XXXX\n***\n***    ZAP FOR DSL ONLY TO ALLOW RESTORE OF DA DATASETS\n***    (IEHMOVE DOES NOT ALLOW PREALLOCATED DA DATASET FOR RESTORE)\n***\n*** THE FOLLOWING TWO ZAPS (CS0BDAM) ARE REQUIRED IF THE\n*** TO DEVICE IS DASD, THE DATASET IS BDAM AND A PREALLOCATED\n*** DATASET IS TO BE USED. (MUST BE PRE-ALLOCATED IF UNAUTHORIZED).\n***\n   NAME IEHMVESX IEHMVSRV\n* FICHE: IEHMVSRV UZ35492 8105 20B07\n   VER  07B6  47F0,4094      CHANGE END OF BDAM CHECKING TO\n   REP  07B6  47F0,47CE      BR TO CODE TO TRY OBTAIN ON \"TO\"\n   VER  07BE  4710,4094      DATASET.  THIS WILL CAUSE \"PREALLOCATED\"\n   REP  07BE  4710,47CE      FLAG TO BE SET IF \"TO\" DATASET\n   VER  07CA  47F0,4094      EXISTS.  (EVEN FOR BDAM)\n   REP  07CA  47F0,47CE      (CHANGE ALL BR'S TO IEHMVRTE TO IEHMVETE)\n   IDRDATA CS0BDAM\n   NAME IEHMVESV IEHMVSSX\n* FICHE: IEHMVSSX UZ52878 8111 115A06 (NOT IN 8205 INDEX)\n   VER  0882  47E0,B88E      ALLOW BDAM PREALLOCATED\n   REP  0882  4700             DATASETS\n   VER  097C  4710,B9DC      IF BDAM DON'T ALLOW PREALLOC\n   REP  097C  4710,BB14      ALLOW BDAM PREALLOC VIA BR TO \"PREALLO\"\n   IDRDATA CS0BDAM\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OACACTDA": {"ttr": 6664, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x006\\x006\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "FILE149"}, "text": "*        %GOTO ACCTBSL;                                              /*\n         MACRO\n&LABEL   OACACTDA &DSECT=YES,&PREFIX=DA#\n.*****   THIS MACRO DEFINES DA SPACE ACCOUNTING RECORDS.\n         LCLC  &LAB,&P\n&LAB     SETC  'OACACTDA'         SET DEFAULT LABEL\n&P       SETC  '&PREFIX'(1,3)     SET MAX PREFIX\n         AIF   (T'&LABEL EQ 'O').CK#DS BIF NO USER LABEL\n&LAB     SETC  '&LABEL'           SET USER'S LABEL\n.CK#DS   AIF   ('&DSECT' EQ 'YES').DSECT BIF DSECT GENERATION\n&LAB     EQU   *                  OAC DA SPACE ACCOUNTING RECORD\n         AGO   .GEN               BIF TO GENERATE DATA\n.DSECT   ANOP                     GENERATE DSECT HERE\n&LAB     DSECT ,                  OAC DA SPACE ACCOUNTING RECORD\n.GEN     ANOP\n&P.DSN   DC    CL44' '            DSNAME\n&P.VOL   DC    CL6' '             RESIDENCE VOLUME\n&P.ATYP  DC    AL1(0)             ALLOCATION TYPE\n&P.ATTRK EQU   1                  TRACKS\n&P.ATBYT EQU   2                  BYTES\n&P.DEVT  DC    XL1'00'            RESIDENCE DEVICE TYPE (FROM UCBTYPE)\n&P.ALOC  DC    XL4'0'             ALLOCATION QUANTITY\n&P.ADAT  DC    XL4'00'            CREATION DATE (YYDDDF)\n&P.USED  DC    XL4'00'            LAST USED DATE (YYDDDF)\n&P.RUN   DC    XL4'00'            DATE RECORD CREATED (YYDDDF)\n&P.RTYP  DC    AL1(0)             RECORD TYPE\n&P.RTVTO EQU   1                  VTOC READ PROGRAM RECORD TYPE\n&P.DTYP  DC    AL1(0)             DSN TYPE\n&P.DTDSN EQU   1                  OS DATASET\n&P.DTVSA EQU   2                  VSAM DATA SPACE\n         DC    XL10'00'           RESERVED\n&P.LEN   EQU   *-&LAB             RECORD LENGTH (80)\n         MEND  , */\n*%ACCTBSL :  ;\n*\n* /********************************************************************/\n* /*                                                                  */\n* /*           D A   A C C T   R E C O R D                            */\n* /*                                                                  */\n* /********************************************************************/\n*\n*DCL A#PNTR     POINTER,\n*    1 A#REC    BASED(A#PNTR),             /* FORMAT OF DA ACCT REC   */\n*      2 A#DSN  CHAR(44)       INIT(' '),  /* DSNAME                  */\n*      2 A#VOL  CHAR(6)        INIT(' '),  /* RESIDENCE VOLUME        */\n*      2 A#ATYP BIT(8)         INIT('0'B), /* ALLOC TYPE 1=TRK/2=BYTE */\n*      2 A#DEVT BIT(8)         INIT('0'B), /* DEVICE TYPE (UCBTYPE+3) */\n*      2 A#ALOC FIXED BIN(31)  INIT(0),    /* ALLOCATION QUANTITY     */\n*      2 A#ADAT FIXED DEC(7,3) INIT(0),    /* CREATION DATE           */\n*      2 A#USED FIXED DEC(7,3) INIT(0),    /* LAST USED DATE          */\n*      2 A#RUN  FIXED DEC(7,3) INIT(0),    /* RUN DATE                */\n*      2 A#RTYP BIT(8)         INIT('0'B), /* RECORD TYPE (VTOC=1)    */\n*      2 A#DTYP BIT(8)         INIT('0'B), /* DSN TYPE (1=OS/2=VSAM)  */\n*      2 A#RESV CHAR(10)       INIT(' ');  /* RESERVED                */\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACACTW@": {"ttr": 6666, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00k\\x00k\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 107, "newlines": 107, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&LBL     OACACTWK &DSECT=YES,&PREFIX=ACT,&PREONLY=NO\n         LCLC  &P,&L\n.**********************************************************************\n.*                                                                    *\n.*  OACACTWK - OAC ACCOUNTING WORK AREA                               *\n.*    - OBTAINED BY INITIATOR (IEFUJI)                                *\n.*    - SUBPOOL 230 KEY ZERO                                          *\n.*      (NOT FREED WHEN INITIATOR FREES REGION)                       *\n.*                                                                    *\n.*                                                                    *\n.*  SERIALIZATION:   DURING INITIATOR PROCESSING THIS AREA            *\n.*        IS ONLY MODIFIED FROM THE INITIATOR TASK.                   *\n.*        (IEFUJI, IEFACTRT)                                          *\n.*                                                                    *\n.*                                                                    *\n.*                   WHEN THE JOB IS RUNNING AND THIS AREA IS UPDATED *\n.*        BY IEFU83 COMPARE AND SWAP IS USED.                         *\n.*                                                                    *\n.*      (THIS AREA IS FORMATED BY ........)                           *\n.*                                                                    *\n.**********************************************************************\n.*\n.*\n.*  REQUIRE USAGE OF MACRO TO BE DOCUMENTED HERE....\n.*\n         AIF   ('&SYSECT' EQ 'IEFUJI').USEOK\n         AIF   ('&SYSECT' EQ 'IEFU83').USEOK\n         AIF   ('&SYSECT' EQ 'IEFACTRT').USEOK\n         AIF   ('&SYSECT' EQ 'PREACTRT').USEOK IEFACTRT TEST FRONTEND\n.*\n         MNOTE 21,' &SYSECT NOT AUTHORIZED TO USE OACACTWK,'\n         MNOTE 21,' UPDATE MACRO TO MAINTAIN LIST OF USERS,'\n         MNOTE 21,' RE-ASSEMBLY ALL USERS IF REQUIRED BY CHANGES'\n         MEXIT\n.*\n.USEOK   ANOP\n&P       SETC  '&PREFIX'\n&L       SETC  'OACACTWK'\n         AIF   ('&LBL' EQ '').L0\n&L       SETC  '&LBL'\n.L0      AIF   ('&DSECT' NE 'YES').L1\n&L       DSECT ,                  OACACTWK DSECT\n         AGO   .L2\n.L1      ANOP\n&L       DC    0D'0'              OACACTWK AREA\n.L2      ANOP\n*  OACACTWK PREFIX (BLOCK ID, POINTERS/LENGTHS OF OTHER SECTIONS)\n&P.PID   DC    CL8'OACACTWK'      CONTROL BLOCK ID\n&P.PSP   DC    AL1(230)           CONTROL BLOCK SUB-POOL\n&P.PLEN  DC    AL3(&P.L)          CONTROL BLOCK LENGTH\n&P.PASAA DC    A(&P.WK)           @ ACTWK AREA (STEP ACCOUNT FIELDS)\n&P.PASAL DC    A(&P.WKL)          LENGTH OF ACTWK AREA\n&P.PMTA  DC    A(&P.MT)           @ ACTMT AREA (MOUNT FIELDS)\n&P.PMTL  DC    A(&P.MTL)          LENGTH OF ACTMT AREA\n         AIF   ('&PREONLY' EQ 'YES').HDR1\n         SPACE 1\n*   STEP ACCOUNTING FIELDS (IEFUJI, IEFACTRT)\n&P.WK    DC    0D'0'\n&P.WKMUR DC    H'0'               MUS RATE USED FOR THIS JOB\n&P.WKRT  DC    H'0'               COST PER TAPE MOUNT\n&P.WKRD  DC    H'0'               COST PER DISK MOUNT\n&P.WKFLG DC    X'0'               FLAGS\n&P.WK1ST EQU   X'80'              FIRST STEP FLAG (SET BY IEFUJI)\n&P.WKRAN EQU   X'40'              AT LEAST ONE STEP WAS EXECUTED\n&P.WKSUB EQU   X'20'              JOB IS USERID MONITORED\n&P.WKACT EQU   X'10'              JOB IS USERID ACCOUNTED\n&P.WKST# DC    X'0'               STEP COUNT\n&P.WKDTE DC    F'0'               RESERVED\n&P.WKSTA DC    F'0'               ADDRESS OF CURRENT ACCT ENTRY\n*   THERE IS ONE ACTENT FOR EACH STEP IN JOB\n&P.WKRST EQU   *                  ACTENT SECTION START\n&P.WKENT EQU   *                  FIRST ACTENT START\n&P.WKSNM DC    CL8' '             STEP NAME\n&P.WKSRC DC    CL6' '             STEP RETURN CODE\n         DC    XL2'0'             (RESERVED)\n&P.WKCPU DC    F'0'               STEP CPU USED\n&P.WKIOR DC    F'0'               STEP I/O USED\n&P.WKEWS DC    F'0'               STEP ESTIMATED WORKING SET SIZE\n&P.WKVMF DC    F'0'               STEP VIRTUAL MEMORY FACTOR USED\n&P.WKMUS DC    F'0'               STEP MUS USED\n&P.WKCST DC    F'0'               STEP COST\n&P.WKAEL EQU   *-&P.WKRST         LENGTH OF EACH ACTENT\n         ORG   &P.WKRST\n         DC    (255)XL(&P.WKAEL)'00' ACTENT STEP TABLE\n&P.WKSTL EQU   *-&P.WKRST         LENGTH OF ACTENT TABLE\n&P.WKL   EQU   *-&P.WK            LENGTH OF ACTWK SECTION\n         SPACE 1\n*   MOUNT FIELDS (IEFUJI, IEFU83, IEFACTRT)\n&P.MT    DC    0D'0'\n&P.MTF   DC    F'0'      *CS*    MOUNT CONTROL FLAGS (USE CS)\n&P.MTFO   EQU   X'80'             MOUNT TABLE OVERFLOWED\n&P.MTSL# EQU   25                 # OF UNIT SLOTS GENERATED (EQU)\n&P.MTSLN DC    Y(&P.MTSL#)        NUMBER OF UNIT SLOTS\n         DC    H'0'               <RESERVED>\n&P.MTCDA DC    F'0'      *CS*     COUNT OF DISK MOUNTS\n&P.MTCTP DC    F'0'      *CS*     COUNT OF TAPE MOUNTS\n&P.MTE   DC    0D'0'     *CSD*    FIRST MOUNT UNIT ENTRY (FOR CSD)\n&P.MTEVS DC    XL6'00'   *CSD*    VOLUME SERIAL (LAST VOLUME OR ZERO)\n&P.MTEUA DC    Y(0)      *CSD*    @ UCB (OR ZERO) FOR THIS ENTRY\n&P.MTEL  EQU   *-&P.MTE  *CSD*    LENGTH OF MOUNT ENTRY\n         ORG   &P.MTE\n         DC    (&P.MTSL#)XL(&P.MTEL)'00' MOUNT UNIT TABLE ENTRIES\n&P.MTL   EQU   *-&P.MT            LENGTH OF MOUNT SECTION\n&P.L     EQU   *-&L               LENGTH OF OACACTWK\n.HDR1    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACACTWK": {"ttr": 6669, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00l\\x00l\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 108, "newlines": 108, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&LBL     OACACTWK &DSECT=YES,&PREFIX=ACT,&PREONLY=NO\n         LCLC  &P,&L\n.**********************************************************************\n.*                                                                    *\n.*  OACACTWK - OAC ACCOUNTING WORK AREA                               *\n.*    - OBTAINED BY INITIATOR (IEFUJI)                                *\n.*    - SUBPOOL 230 KEY ZERO                                          *\n.*      (NOT FREED WHEN INITIATOR FREES REGION)                       *\n.*                                                                    *\n.*                                                                    *\n.*  SERIALIZATION:   DURING INITIATOR PROCESSING THIS AREA            *\n.*        IS ONLY MODIFIED FROM THE INITIATOR TASK.                   *\n.*        (IEFUJI, IEFACTRT)                                          *\n.*                                                                    *\n.*                                                                    *\n.*                   WHEN THE JOB IS RUNNING AND THIS AREA IS UPDATED *\n.*        BY IEFU83 COMPARE AND SWAP IS USED.                         *\n.*                                                                    *\n.*      (THIS AREA IS FORMATED BY ........)                           *\n.*                                                                    *\n.**********************************************************************\n.*\n.*\n.*  REQUIRE USAGE OF MACRO TO BE DOCUMENTED HERE....\n.*\n         AIF   ('&SYSECT' EQ 'IEFUJI').USEOK\n         AIF   ('&SYSECT' EQ 'IEFU83').USEOK\n         AIF   ('&SYSECT' EQ 'IEFACTRT').USEOK\n         AIF   ('&SYSECT' EQ 'PREACTRT').USEOK IEFACTRT TEST FRONTEND\n.*\n         MNOTE 21,' &SYSECT NOT AUTHORIZED TO USE OACACTWK,'\n         MNOTE 21,' UPDATE MACRO TO MAINTAIN LIST OF USERS,'\n         MNOTE 21,' RE-ASSEMBLY ALL USERS IF REQUIRED BY CHANGES'\n         MEXIT\n.*\n.USEOK   ANOP\n&P       SETC  '&PREFIX'\n&L       SETC  'OACACTWK'\n         AIF   ('&LBL' EQ '').L0\n&L       SETC  '&LBL'\n.L0      AIF   ('&DSECT' NE 'YES').L1\n&L       DSECT ,                  OACACTWK DSECT\n         AGO   .L2\n.L1      ANOP\n&L       DC    0D'0'              OACACTWK AREA\n.L2      ANOP\n*  OACACTWK PREFIX (BLOCK ID, POINTERS/LENGTHS OF OTHER SECTIONS)\n&P.PID   DC    CL8'OACACTWK'      CONTROL BLOCK ID\n&P.PSP   DC    AL1(230)           CONTROL BLOCK SUB-POOL\n&P.PLEN  DC    AL3(&P.L)          CONTROL BLOCK LENGTH\n&P.PASAA DC    A(&P.WK)           @ ACTWK AREA (STEP ACCOUNT FIELDS)\n&P.PASAL DC    A(&P.WKL)          LENGTH OF ACTWK AREA\n&P.PMTA  DC    A(&P.MT)           @ ACTMT AREA (MOUNT FIELDS)\n&P.PMTL  DC    A(&P.MTL)          LENGTH OF ACTMT AREA\n         AIF   ('&PREONLY' EQ 'YES').HDR1\n         SPACE 1\n*   STEP ACCOUNTING FIELDS (IEFUJI, IEFACTRT)\n&P.WK    DC    0D'0'\n&P.WKMUR DC    H'0'               MUS RATE USED FOR THIS JOB\n&P.WKRT  DC    H'0'               COST PER TAPE MOUNT\n&P.WKRD  DC    H'0'               COST PER DISK MOUNT\n&P.WKFLG DC    X'0'               FLAGS\n&P.WK1ST EQU   X'80'              FIRST STEP FLAG (SET BY IEFUJI)\n&P.WKNWD EQU   X'40'              THIS IS HIS FIRST JOB RUN TODAY MAS--\n&P.WKRAN EQU   X'20'              AT LEAST ONE STEP WAS EXECUTED  MAS--\n&P.WKSUB EQU   X'10'              JOB IS USERID MONITORED         MAS--\n&P.WKACT EQU   X'08'              JOB IS USERID ACCOUNTED         MAS--\n&P.WKST# DC    X'0'               STEP COUNT\n&P.WKDTE DC    F'0'               RESERVED\n&P.WKSTA DC    F'0'               ADDRESS OF CURRENT ACCT ENTRY\n*   THERE IS ONE ACTENT FOR EACH STEP IN JOB\n&P.WKRST EQU   *                  ACTENT SECTION START\n&P.WKENT EQU   *                  FIRST ACTENT START\n&P.WKSNM DC    CL8' '             STEP NAME\n&P.WKSRC DC    CL6' '             STEP RETURN CODE\n         DC    XL2'0'             (RESERVED)\n&P.WKCPU DC    F'0'               STEP CPU USED\n&P.WKIOR DC    F'0'               STEP I/O USED\n&P.WKEWS DC    F'0'               STEP ESTIMATED WORKING SET SIZE\n&P.WKVMF DC    F'0'               STEP VIRTUAL MEMORY FACTOR USED\n&P.WKMUS DC    F'0'               STEP MUS USED\n&P.WKCST DC    F'0'               STEP COST\n&P.WKAEL EQU   *-&P.WKRST         LENGTH OF EACH ACTENT\n         ORG   &P.WKRST\n         DC    (255)XL(&P.WKAEL)'00' ACTENT STEP TABLE\n&P.WKSTL EQU   *-&P.WKRST         LENGTH OF ACTENT TABLE\n&P.WKL   EQU   *-&P.WK            LENGTH OF ACTWK SECTION\n         SPACE 1\n*   MOUNT FIELDS (IEFUJI, IEFU83, IEFACTRT)\n&P.MT    DC    0D'0'\n&P.MTF   DC    F'0'      *CS*    MOUNT CONTROL FLAGS (USE CS)\n&P.MTFO   EQU   X'80'             MOUNT TABLE OVERFLOWED\n&P.MTSL# EQU   25                 # OF UNIT SLOTS GENERATED (EQU)\n&P.MTSLN DC    Y(&P.MTSL#)        NUMBER OF UNIT SLOTS\n         DC    H'0'               <RESERVED>\n&P.MTCDA DC    F'0'      *CS*     COUNT OF DISK MOUNTS\n&P.MTCTP DC    F'0'      *CS*     COUNT OF TAPE MOUNTS\n&P.MTE   DC    0D'0'     *CSD*    FIRST MOUNT UNIT ENTRY (FOR CSD)\n&P.MTEVS DC    XL6'00'   *CSD*    VOLUME SERIAL (LAST VOLUME OR ZERO)\n&P.MTEUA DC    Y(0)      *CSD*    @ UCB (OR ZERO) FOR THIS ENTRY\n&P.MTEL  EQU   *-&P.MTE  *CSD*    LENGTH OF MOUNT ENTRY\n         ORG   &P.MTE\n         DC    (&P.MTSL#)XL(&P.MTEL)'00' MOUNT UNIT TABLE ENTRIES\n&P.MTL   EQU   *-&P.MT            LENGTH OF MOUNT SECTION\n&P.L     EQU   *-&L               LENGTH OF OACACTWK\n.HDR1    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACBLDPL": {"ttr": 6913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x86\\x00\\x86\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 134, "newlines": 134, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&LBL     OACBLDPL &DUMMY,&CPPL=,&ECB=,&RS=R0,&RT=R15,&IOPL=,&CSPL=,    X\n               &PPL=,&DFPL=,&DRFAIL=,&GNRFAIL=\n         LCLC  &B,&C,&LABEL\n&LABEL   SETC  '&LBL'\n         AIF   ('&CPPL' NE '').L1\n         MNOTE 12,'CPPL IS REQUIRED'\n.L1      AIF   ('&ECB' NE '').L2\n         MNOTE 12,'TSO SERVICE ECB IS REQUIRED'\n.L2      AIF   ('&GNRFAIL' EQ '').IOPL\n&LABEL   OACINNER T=&GNRFAIL,TO=+16,F=&CPPL,OP=MA,L=4,RS=&RS,RT=&RT,   X\n               COM='MOVE IN CPPL ADDR'\n&LABEL   SETC  ''\n         OACINNER T=&GNRFAIL,TO=+20,F=&ECB,OP=MA,L=4,RS=&RS,RT=&RT,    X\n               COM='MOVE IN ECB ADDR'\n.IOPL    AIF   ('&IOPL(1)' EQ '').CSPL\n&C       SETC  '&IOPL'\n         AIF   ('&IOPL(2)' EQ '').IOPL1\n&C       SETC  '&IOPL(1)'\n.IOPL1   ANOP\n&LABEL   OACINNER T=&C,F=&CPPL,FO=+4,OP=M,L=4,RS=&RS,RT=&RT,           X\n               COM='MOVE IN UPT ADDR'\n         OACINNER T=&C,TO=+4,F=&CPPL,FO=+12,OP=M,L=4,RS=&RS,RT=&RT,    X\n               COM='MOVE IN ECT ADDR'\n         OACINNER F=&ECB,T=&C,TO=+8,RS=&RS,RT=&RT,OP=MA,               X\n               COM='MOVE IN ECB ADDRESS'\n&B       SETC  '&C'\n         AIF   ('&IOPL(2)' EQ '').CSPL\n         OACINNER F=&IOPL(2),T=&C,TO=+12,RS=&RS,RT=&RT,OP=MA,          X\n               COM='MOVE IN IOPB ADDR'\n.CSPL    AIF   ('&CSPL(1)' EQ '').PPL\n         AIF   (1 EQ N'&CSPL).CSPL1\n&C       SETC  '&CSPL(1)'\n         AGO   .CSPL2\n.CSPL1   ANOP\n&C       SETC  '&CSPL'\n.CSPL2   AIF   ('&B' EQ '').CSPL3\n         OACINNER F=&B,T=&C,L=12,RS=&RS,RT=&RT,OP=M,                   X\n               COM='MOVE UPD,ECT,AND ECB ADDS'\n         AGO   .CSPL4\n.CSPL3   ANOP\n&LABEL   OACINNER T=&C,F=&CPPL,FO=+4,OP=M,L=4,RS=&RS,RT=&RT,           X\n               COM='MOVE IN UPT ADDR'\n         OACINNER T=&C,TO=+4,F=&CPPL,FO=+12,OP=M,L=4,RS=&RS,RT=&RT,    X\n               COM='MOVE IN ECT ADDR'\n         OACINNER F=&ECB,T=&C,TO=+8,RS=&RS,RT=&RT,OP=MA,               X\n               COM='MOVE IN ECB ADDRESS'\n&B       SETC  '&C'\n.CSPL4   AIF   ('&CSPL(2)' EQ '').CSPL5\n         OACINNER F=&CSPL(2),T=&C,TO=+12,OP=MA,RS=&RS,RT=&RT,          X\n               COM='MOVE IN FLAG ADDRESS'\n.CSPL5   AIF   ('&CSPL(3)' EQ '').CSPL6\n         OACINNER F=&CSPL(3),T=&C,TO=+16,OP=MA,RS=&RS,RT=&RT,          X\n               COM='MOVE IN CSOA ADDRESS'\n.CSPL6   AIF   ('&CSPL(4)' EQ '').PPL\n         OACINNER F=&CSPL(4),T=&C,TO=+20,OP=MA,RS=&RS,RT=&RT,          X\n               COM='MOVE IN CMD BUF ADDRESS'\n.PPL     AIF   ('&PPL(1)' EQ '').DFPL\n         AIF   (1 EQ N'&PPL).PPL1\n&C       SETC  '&PPL(1)'\n         AGO   .PPL2\n.PPL1    ANOP\n&C       SETC  '&PPL'\n.PPL2    AIF   ('&B' EQ '').PPL3\n         OACINNER F=&B,T=&C,L=12,RS=&RS,RT=&RT,OP=M,                   X\n               COM='MOVE UPD,ECT,AND ECB ADDS'\n         AGO   .PPL4\n.PPL3    ANOP\n&LABEL   OACINNER T=&C,F=&CPPL,FO=+4,OP=M,L=4,RS=&RS,RT=&RT,           X\n               COM='MOVE IN UPT ADDR'\n         OACINNER T=&C,TO=+4,F=&CPPL,FO=+12,OP=M,L=4,RS=&RS,RT=&RT,    X\n               COM='MOVE IN ECT ADDR'\n         OACINNER F=&ECB,T=&C,TO=+8,RS=&RS,RT=&RT,OP=MA,               X\n               COM='MOVE IN ECB ADDRESS'\n&B       SETC  '&C'\n.PPL4    AIF   ('&PPL(2)' EQ '').PPL5\n         OACINNER F=&PPL(2),T=&C,TO=+12,OP=MA,RS=&RS,RT=&RT,           X\n               COM='MOVE IN PCL ADDRESS'\n.PPL5    AIF   ('&PPL(3)' EQ '').PPL6\n         OACINNER F=&PPL(3),T=&C,TO=+16,OP=MA,RS=&RS,RT=&RT,           X\n               COM='MOVE IN ANSWER PLACE ADD'\n.PPL6    AIF   ('&PPL(4)' EQ '').PPL7\n         OACINNER F=&PPL(4),T=&C,TO=+20,OP=MA,RS=&RS,RT=&RT,           X\n               COM='MOVE IN PTR TO CMD BUF'\n.PPL7    AIF   ('&PPL(5)' EQ '').DFPL\n         OACINNER F=&PPL(5),T=&C,TO=+24,OP=MA,RS=&RS,RT=&RT,           X\n               COM='MOVE IN PTR TO USER WA'\n.DFPL    AIF   ('&DFPL(1)' EQ '').DRFAIL\n         AIF   (1 EQ N'&DFPL).DFPL1\n&C       SETC  '&DFPL(1)'\n         AGO   .DFPL2\n.DFPL1   ANOP\n&C       SETC  '&DFPL'\n.DFPL2   AIF   ('&B' EQ '').DFPL3\n         OACINNER F=&B,T=&C,L=12,RS=&RS,RT=&RT,OP=M,                   X\n               COM='MOVE UPD,ECT,AND ECB ADDS'\n         AGO   .DFPL4\n.DFPL3   ANOP\n&LABEL   OACINNER T=&C,F=&CPPL,FO=+4,OP=M,L=4,RS=&RS,RT=&RT,           X\n               COM='MOVE IN UPT ADDR'\n         OACINNER T=&C,TO=+4,F=&CPPL,FO=+12,OP=M,L=4,RS=&RS,RT=&RT,    X\n               COM='MOVE IN ECT ADDR'\n         OACINNER F=&ECB,T=&C,TO=+8,RS=&RS,RT=&RT,OP=MA,               X\n               COM='MOVE IN ECB ADDRESS'\n&B       SETC  '&C'\n.DFPL4   AIF   (1 EQ N'&DFPL).DRFAIL\n         OACINNER F=&DFPL(2),T=&C,TO=+12,OP=MA,RS=&RS,RT=&RT,          X\n               COM='MOVE IN DFPB ADDRESS'\n.DRFAIL  AIF   ('&DRFAIL(1)' EQ '').END\n         AIF   (1 EQ N'&DRFAIL).DRFAIL1\n&C       SETC  '&DRFAIL(1)'\n         AGO   .DRFAIL2\n.DRFAIL1 ANOP\n&C       SETC  '&DRFAIL'\n.DRFAIL2 ANOP\n         OACINNER F=&CPPL,T=&C,TO=+16,OP=MA,RS=&RS,RT=&RT,             X\n               COM='MOVE IN CPPL ADDRESS'\n         AIF   ('&DRFAIL(2)' EQ '').DRFAIL3\n         OACINNER F=&DRFAIL(2),T=&C,OP=MA,RS=&RS,RT=&RT,               X\n               COM='MOVE IN PTR TO RB'\n.DRFAIL3 AIF   ('&DRFAIL(3)' EQ '').DRFAIL4\n         OACINNER F=&DRFAIL(3),T=&C,TO=+4,OP=MA,RS=&RS,RT=&RT,         X\n               COM='MOVE IN PTR TO RC'\n.DRFAIL4 AIF   ('&DRFAIL(4)' EQ '').DRFAIL5\n         OACINNER F=&DRFAIL(4),T=&C,TO=+8,OP=MA,RS=&RS,RT=&RT,         X\n               COM='PTR TO ADDR OF IKJEFF02'\n.DRFAIL5 AIF   ('&DRFAIL(5)' EQ '').DRFAIL6\n         OACINNER F=&DRFAIL(5),T=&C,TO=+12,OP=MA,RS=&RS,RT=&RT,        X\n               COM='PTR TO FLAGS AND ID'\n.DRFAIL6 AIF   ('&DRFAIL(6)' EQ '').END\n         OACSTAD FROM=&DRFAIL(6),TO=(&C,+20),RS=&RS\n         OACINNER F=&DRFAIL(6),T=&C,TO=+20,OP=MA,RS=&RS,RT=&RT,        X\n               COM='PTR TO MSG BUFFERS'\n.END     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACCALL": {"ttr": 6916, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00J\\x00J\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 74, "newlines": 74, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&NAME    OACCALL &RTN,&OP,&MF=,&ERROR=\n         GBLC  &OACNAME\n.*  OAC CALL MACRO (INTERAL OR EXTERNAL) - REENTERENT\n.*   &RTN - ROUTINE TO CALL\n.*   &OP  - LIST OF OPERANDS (IN PARENTHESIS) OR KEYWORD OF EXT\n.*   &EXT - EXT KEYWORD OR VL KEYWORD (OR NULL)\n.*          (EXT WILL FORCE VCON INSTEAD OF ACON)\n.*   &VL  - VL KEYWORD (OR NULL)\n.*          (VL WILL CAUSE AN OI TO BE GENERATED TO SET\n.*           HIGH ORDER BIT OF LAST PARM TO 1)\n.*   &MF= - E OR B, PARMLIST ADDRESS\n.*          (IF OMITTED THEN R1 WILL BE LEFT UNCHANGED\n.*           WHICH IS SAME AS MF=(E,(R1)) HOWEVER\n.*           ONLY 'EXT' AND ERROR= MAY BE SPECIFIED)\n.*\n.*  NAME OACCALL FURD,(PARM1,PARM2),MF=(E,LIST)\n.*       OACCALL ,(,,,PARM4),MF=(B,LIST)\n.*       OACCALL WYLSEND,(PARM1,,PARM2),EXT,MF=(E,LIST)\n.*       OACCALL RTN3,(PARM1,,PARM3),EXT,VL,MF=(E,(R5))\n.*\n         LCLB  &MFB,&VLB\n         LCLA  &A,&O\n         LCLC  &EXT               A IF INTERNAL, V IF EXTERNAL\n&EXT     SETC  'A'                ASSUME INTERNAL, NOT EXTERNAL\n&OACNAME SETC  '&NAME'\n         AIF   ('&MF' EQ '').LIST\n         AIF   ('&MF(1)' EQ 'E').LIST\n         AIF   ('&MF(1)' EQ 'B').MFB\n         MNOTE 8,'INVALID MF=&MF - MF=E ASSUMED'\n         AGO   .LIST\n.MFB     ANOP\n&MFB     SETB  1\n.*  SCAN SYSLIST FOR EXT OR VL PSEUDO-KEYWORDS\n.LIST    ANOP\n&A       SETA  1                  START AFTER ROUTINE NAME\n.LIST1   ANOP\n&A       SETA  &A+1\n         AIF   (N'&SYSLIST LT &A).OP\n         AIF   ('&SYSLIST(&A)' EQ 'EXT').LISTEXT\n         AIF   ('&SYSLIST(&A)' EQ 'VL').LISTVL\n         AIF   ('&SYSLIST(&A)'(1,1) EQ '(' AND &A EQ 2).LIST1\n         MNOTE 8,'POSITIONAL OPERAND &A IS INVALID - &SYSLIST(&A)'\n         AGO   .LIST1\n.LISTEXT ANOP\n&EXT     SETC  'V'\n         ANOP  .LIST1\n.LISTVL  ANOP\n&VLB     SETB  1\n         AGO   .LIST1\n.OP      ANOP\n&A       SETA  0\n.OPLOOP  ANOP\n&A       SETA  &A+1\n&O       SETA  (&A-1)*4\n         AIF   (&A GT N'&OP).CALL                 06/03/81 - MAS\n         AIF   ('&OP(&A)' EQ '').OPLOOP           06/03/81 - MAS\n         OACINNRB A,&MF(2),&O,4,&OP(&A)\n         AGO   .OPLOOP\n.CALL    AIF   (NOT &VLB).CALL2\n&A       SETA  (N'&OP-1)*4        OFFSET OF LAST ADDRESS IN PARMLIST\n         OACINNRB OI,&MF(2),&A,1,X'80' SET END OF PARMLIST BIT\n.CALL2   AIF   (&MFB).MEND\n         OACINNRB A,,(R1),4,&MF(2)\n         AIF   ('&RTN'(1,1) EQ '(').CALLR\n&OACNAME L     R15,=&EXT.(&RTN)\n&OACNAME SETC  ''\n.CALL3   ANOP\n&OACNAME BALR  R14,R15\n         OACINERR &ERROR\n         MEXIT\n.CALLR   OACINNRB A,,(R15),4,&RTN     ENTRY POINT TO R15\n         AGO   .CALL3\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACDC": {"ttr": 6919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x18\\x00\\x18\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&LBL     OACDC &ARG,&TYPE=A,&DEF=0,&COM=\n         LCLA  &A\n         LCLC  &C,&B,&D\n         AIF   ('&COM' EQ '').LA\n&D       SETC  '&COM'(2,K'&COM-2)\n         AGO   .LB\n.LA      ANOP\n&D       SETC  ''\n.LB      ANOP\n&C       SETC  '&DEF'\n         AIF   ('&ARG' EQ '').L1\n&C       SETC  '&ARG'\n.L1      ANOP\n&B       SETC  '&TYPE.(&C)'\n&A       SETA  K'&B\n         AIF   (&A GT 18).L2\n&B       SETC  '&B                                           '\n&B       SETC  '&B'(1,19)\n&LBL     DC    &B.&D\n         AGO   .MEND\n.L2      ANOP\n&LBL     DC    &B &D\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACDROP": {"ttr": 6921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x002\\x002\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n         OACDROP &PARMS\n         GBLC  &USELAB(16)        SAVED PROGRAM LABELS\n         GBLC  &USEREG(16)        SAVED REGISTER TABLE\n         LCLA  &UNDX,&II          USE INDICES,TEMP USAGE\n         LCLA  &PNDX,&DNDX        INPUT PARM,DROP STRING INDICES\n         LCLB  &GOTREG,&DROPALL   HAVE REGS TO DROP,DROP ALL TO DO\n         LCLC  &R(4),&B(4)        REGS TO DROP,PREVIOUS BASES FOR REGS\n         LCLC  &BLANKS            BLANKS TO PAD DROP LINE TO COMMENTS\n&DROPALL SETB  ((N'&SYSLIST EQ 0) OR ('&PARMS' EQ '')) SET DROPALL FLAG\n.LP#SYS  AIF   (&DROPALL).LP#SAV  BIF DROP ALL IN PROGRESS\n         AIF   (&PNDX GE N'&SYSLIST).CK#DROP LOOP TIL DONE WITH REGS\n&PNDX    SETA  &PNDX+1            UP THE COMMA/REG INDEX\n&UNDX    SETA  0                  RE-INITIALIZE USE ARRAY INDEX\n.LP#SAV  ANOP                     VALID DROP REG CHECK LOOP\n&UNDX    SETA  &UNDX+1            UP THE USE ARRAY COUNT\n         AIF   (&DROPALL).CK#ALL  BIF DROP ALL IN PROGRESS\n         AIF   ('&USEREG(&UNDX)' EQ '&SYSLIST(&PNDX)').DROP#R BIF MATCH\n         AIF   (&UNDX LT 16).LP#SAV LOOP FOR ALL ENTRIES IF NEEDED\n         MNOTE 4,'REGISTER &SYSLIST(&PNDX) WAS NOT A USNGX OPERAND'\n         AGO   .LP#SYS            CONTINUE\n.CK#ALL  AIF   (&UNDX GT 16).CK#DROP BIF END OF SAVE TABLE/CHECK DROPS\n         AIF   ('&USEREG(&UNDX)'  EQ '').LP#SAV BIF EMPTY SLOT\n.DROP#R  AIF   (&DNDX EQ 0).DROP$R BIF NO PREVIOUS REGISTER/BASE\n&R(&DNDX) SETC '&R(&DNDX)'.','    APPEND COMMA AFTER PREVIOUS REG\n&B(&DNDX) SETC '&B(&DNDX)'.','    APPEND COMMA AFTER PREVIOUS BASE\n.DROP$R  ANOP\n&DNDX    SETA  &DNDX+1            UP THE DROP STRING INDEX\n&R(&DNDX) SETC '&USEREG(&UNDX)'   GET PREVIOUS REGISTER\n&B(&DNDX) SETC '&USELAB(&UNDX)'   GET PREVIOUS BASE\n&USEREG(&UNDX) SETC ''            BLANK THE SAVE TABLE REG FIELD\n&USELAB(&UNDX) SETC ''            BLANK THE SAVE TABLE BASE FIELD\n         AIF   (&DNDX GE 4).DO#DR BIF DROP LINE FULL\n&GOTREG  SETB  1                  SAY HAVE SOMETHING TO DROP\n         AGO   .LP#SYS            GO CHECK FOR &SYSLIST/TABLE END\n.CK#DROP AIF   (NOT &GOTREG).EXIT SKIP THE DROP IF NOTHING TO DO\n.* NOTE THAT THIS MACRO ASSUMES OPERAND/COMMENT COLUMNS 16 AND 35.\n.DO#DR   ANOP\n&BLANKS  SETC  ' '                SET ONE BLANK IN CASE TOO LONG\n&II      SETA  (35-16)-K'&R(1)-K'&R(2)-K'&R(3)-K'&R(4) BLANK COUNT\n         AIF   (&II LE 1).DO$DR   BIF ONE BLANK CORRECT\n&BLANKS  SETC  '                  '(1,&II) ELSE SET CORRECT NUMBER\n.DO$DR   DROP  &R(1)&R(2)&R(3)&R(4)&BLANKS&B(1)&B(2)&B(3)&B(4)\n&GOTREG  SETB  0                  NOTHING TO DROP\n.DROP#CL AIF   (&DNDX EQ 0).LP#SYS BIF CLEARING DONE\n&R(&DNDX) SETC ''                 BLANK REG FIELD\n&B(&DNDX) SETC ''                 BLANK BASE FIELD\n&DNDX    SETA  &DNDX-1            DECREMENT INDEX\n         AGO   .DROP#CL           CONTINUE\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACENTER": {"ttr": 6923, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x01,\\x01,\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 300, "newlines": 300, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&NAME    OACENTER &REGEQU=YES,&BASE=R10,&PARM=R9,&ENTRYS=,&ENTRYR=,    X\n               &EXIT=,&DSECT=,&WORK=,&STACK=,&ROUND=NO,&SP=1,&PLIX=NO, X\n               &ID=,&DATE=,&PRINT=\n         COPY  OACGBLS            GET OAC GLOBAL ASM SYSMS\n         LCLC  &C,&I,&D,&STK,&STKMX,&LEN,&BASEADD,&SPL,&NM\n         LCLA  &N,&X,&WL,&A\n         LCLB  &XZ,&NOSTACK\n&NOSTACK SETB  ('&STACK(1)' EQ ''  OR '&STACK(1)' EQ '0')\n&OACSTMX SETC  '8(R12)'           STACK MAX\n&OACSTER SETC  '16(R12)'          OVERFLOW ROUTINE\n&SPL     SETC  '0'\n&I       SETC  '&NAME'\n         AIF   ('&PLIX' NE 'YES').L0\n&I       SETC  'X&NAME'(1,8)\n.L0      ANOP\n&I       CSECT ,                  AVOID PRIVATE CODE\n         OACPRTPM PRINT=&PRINT\n         AIF   ('&REGEQU' NE 'YES').L1\n         OACREGS PRINT=&OACPRT\n.L1      AIF   ('&DSECT' EQ '').L11\n&DSECT   DSECT\n&LEN     SETC  'XL&SYSNDX'\n&STKMX   SETC  'XL&SYSNDX-71'\n         AIF   (&NOSTACK).L6\n         AIF   ('&PLIX' EQ 'NO').L2\n.PSERR   MNOTE 8,'PLIX=YES AND STACK= ARE MUTUALLY EXCLUSIVE'\n.L2      ANOP\n         DC    AL1(&SP),AL3(0)    SP AND LENGTH OF WORK AREA\n         DC    3A(0)              R13 CHAIN, STKMAX AND STACKERR\n         L     R15,12(R12)        GET ADD OF STK OVERFLOW RTN\n         BR    R15                CALL THE ROUTINE\n         AIF   ('&WORK(2)' EQ '').L3\n         OACWORK &WORK(2)\n.L3      ANOP\n&C       SETC  '&WORK(3)'\n         AIF   ('&WORK(1)' EQ ''  OR '&WORK(1)' EQ '0').L4\n&C       DC    0D'0',&WORK(1)XL1'0' RESERVED AREA\n         AGO   .L4A\n.L4      AIF   ('&C' EQ '').L4A\n&C       DC    0D                 ALIGNED WORK LABEL\n.L4A     ANOP\n&STK     SETC  '&STACK(2)'\n         AIF   ('&STK' NE '').L4B\n&STK     SETC  'XS&SYSNDX'\n.L4B     ANOP\n&A       SETA  ((&STACK(1)+79)/8)*8\n&STK     DC    0D'0',&A.XL1'0'    STACK AREA\n&STK     SETC  '&STK-&DSECT'\n         AIF   ('&ROUND' NE 'YES' ).L5\nXO&SYSNDX EQU 4096*(((*-&DSECT)+4095)/4096)\n         ORG   &DSECT+XO&SYSNDX\n.L5      ANOP\nXL&SYSNDX EQU  *-&DSECT\n         SPACE &OACPRTS\n         AGO   .L20\n.L6      AIF   ('&PLIX' EQ 'YES').L7\n         DC    9D'0'              OS SAVE AREA\n&SPL     SETC  '72'\n         AGO   .L8\n.L7      ANOP\n         DC    22F'0'             DSA HEADER\n&SPL     SETC  '88'\n.L8      ANOP\n&STK     SETC  '0'\n         DC    AL1(&SP),AL3(0)    SP AND LENGTH\n         AIF   ('&WORK(2)' EQ '').L9\n         OACWORK &WORK(2)\n.L9      ANOP\n&C       SETC  '&WORK(3)'\n&C       DC    0D'0'              FORCE ALIGNMENT OF RESERVED AREA\n         AIF   ('&WORK(1)' EQ ''  OR '&WORK(1)' EQ '0').L10\n         DC    &WORK(1)XL1'0'     RESERVED AREA\n.L10     ANOP\nXL&SYSNDX EQU  *-&DSECT\n         SPACE &OACPRTS\n         AGO   .L20\n.L11     AIF   ('&WORK(3)' EQ '').L12\n         MNOTE 4,'WORK LABEL REQUIRES CODING DSECT=NAME'\n.L12     AIF   ('&WORK(2)' EQ '').L13\n         MNOTE 4,'WORK MACRO REQUIRES CODING DSECT=NAME'\n.L13     AIF   ('&STACK(2)' EQ '' ).L14\n         MNOTE 4,'STACK LABEL REQUIRES CODING DSECT=NAME'\n.L14     AIF   (&NOSTACK).L16\n         AIF   ('&PLIX' EQ 'YES').PSERR\n&WL      SETA  24                 OS HEADER ROUNDED TO 8\n&LEN     SETC  '24'\n         AIF   ('&WORK(1)' EQ ''  OR '&WORK(1)' EQ '0').L15\n&WL      SETA  &WL+8*((&WORK(1)+7)/8)\n&LEN     SETC  '&WL'\n&STK     SETC  '&WL'\n.L15     ANOP\n&WL      SETA  &WL+8*((&STACK(1)+79)/8)\n&LEN     SETC  '&WL'\n&STKMX   SETC  '&WL-71'\n         AIF   ('&ROUND' NE 'YES' ).L20\n&WL      SETA  4096*((&WL+4095)/4096)\n&LEN     SETC  '&WL'\n&STLMX   SETC  '&WL-71(R12)'\n         AGO   .L20\n.L16     AIF   ('&PLIX' EQ 'YES').L17\n&SPL     SETC  '72'\n&WL      SETA  80                 OS SAVE +SP +LENGTH\n&LEN     SETC  '80'\n         AGO   .L18\n.L17     ANOP\n&WL      SETA  96                 DSA HEADER +SP+LENGTH\n&LEN     SETC  '96'\n.L18     ANOP\n&STK     SETC  '0'\n         AIF   ('&WORK(1)' EQ ''  OR '&WORK(1)' EQ '0').L20\n&WL      SETA  &WL+8*((&WORK(1)+7)/8)\n&LEN     SETC  '&WL'\n.L20     AIF   ('&BASE(2)' EQ '').L21\n         MNOTE 8,'ONLY ONE BASE REGISTER IS SUPPORTED'\n.L21     AIF   ('&OACPRT' NE 'NONE').L22\n         PRINT ON,GEN\n.L22     ANOP\n         SPACE &OACPRTS\n&I       SETC  '&NAME '\n&D       SETC  '&SYSDATE'\n         AIF   ('&ID' EQ '').L23\n&I       SETC  '&ID '\n.L23     AIF   ('&DATE' EQ '').L24\n&D       SETC  '&DATE'\n         MNOTE 7,'REMOVE DATE= BEFORE FINAL ASSEMBLY'\n.L24     ANOP\n&I       SETC  '&I&D'\n         AIF   ('&PLIX' NE 'YES').L26\n&C       SETC  'X&NAME'(1,8)\n&C       CSECT\n&A       SETA  2*(K'&I/2)\n         AIF   (K'&I NE &A).L25\n&I       SETC  '&I '\n.L25     ANOP\n         DC    C'&I'\n&A       SETA  K'&I\n         DC    AL1(&A)\n         ENTRY &NAME\n&NAME    STM   R14,R11,12(R13)    SAVE CALLERS REGS\n         BALR  &BASE,0            GET BASE\n         OACUSING &NAME+6,&BASE\n&BASEADD SETC  '&NAME+6'\n         AGO   .L27A\n.L26     ANOP\n&NAME    CSECT\n&A       SETA  (2*(K'&I/2))+1+5   FORCE ODD ID LENGTH + AL1 + BRANCH\n         B     &A.(R15)           BRANCH AROUND ID\n&A       SETA  &A-5\n         DC    AL1(&A),CL&A'&I'\n         STM   R14,R12,12(R13)    SAVE CALLERS REGS\n         LR    &BASE,R15          SAVE BASE\n         OACUSING &NAME,&BASE\n&BASEADD SETC  '&NAME'\n.L27A    ANOP\n&N       SETA  N'&ENTRYS\n&NM      SETC  ''\n         AIF   (&N EQ 0).L31\n         AIF   ('&ENTRYR' NE '').L28\n         MNOTE 12,'ENTRYR REQUIRED IF ENTRYS CODED'\n.L28     ANOP\n         SR    &ENTRYR,&ENTRYR    MARK AS MAIN ENTRY\n         B     XC&SYSNDX          GO TO COMMON CODE\n&NM      SETC  'XC&SYSNDX'\n&X       SETA  1\n.LOOP    ANOP\n         SPACE 1\n&C       SETC  '&ENTRYS(&X)'\n         ENTRY &C\n&C       STM   R14,R12,12(R13)    SAVE CALLERS REGS\n&A       SETA  4*&X\n         LA    &ENTRYR,&A         MARK AS ENTRY NO &X\n         L     &BASE,XB&SYSNDX-&C.(R15) GET BASE ADDRESS\n         B     XC&SYSNDX          GO TO COMMON CODE\n&X       SETA  &X+1\n         AIF   (&X LE &N).LOOP\nXB&SYSNDX DC   A(&BASEADD)        BASE ADDRESS\n.L31     AIF   ('&PARM' EQ '').L33\n         AIF ('&PARM(2)' EQ 'L').L32\n&NM      LR    &PARM(1),R1           SAVE PARM REG\n&NM      SETC  ''\n         AGO   .L32A\n.L32     ANOP\n&NM      L     &PARM(1),0(R1)        GET PARM ADDR\n.L32A    AIF   ('&PARM(3)' EQ '').L33\n         OACUSING &PARM(3),&PARM(1)\n&NM      SETC  ''\n.L33     AIF   ('&PLIX' NE 'YES').L36\n&NM      LA    R0,&LEN            LNGTH OF REQUIRED DSA IN R0\n&NM      SETC  ''\n         L     R1,76(R13)         LOAD ADD OF NXT AVAIL BYTE\n         ALR   R0,R1              ADD ADDRESSES\n         CL    R0,12(R12)         SEE IF STACK OVERFLOW\n         BNH   *+10               ENOUGH\n         L     R15,116(R12)       ADD OF PLI STORAGE OVERFLOW\n         BALR  R14,R15            GO TO IT\n         ST    R0,76(R1)          STORE ADD NXT AVAIL BYTE\n         ST    R13,4(R1)          CHAIN DSA'S\n         MVC   72(4,R1),72(R13)   COPY ADD OF LIBRARY\n         LR    R13,R1             PUSH STACK\n         MVI   0(R13),X'80'       SET DSA FLAGS FOR PLI\n         MVI   1(R13),X'00'\n         MVI   86(R13),X'91'\n         MVI   87(R13),X'C0'\n         LA    R0,&LEN            GET LENTH OF DSA\n         ST    R0,&SPL.(R13)      STORE INTO WORK AREA\n         AIF   ('&DSECT' EQ '').L34\n         OACUSING &DSECT,R13\n.L34     AIF   ('&EXIT' EQ '').INUSE\n         B     XZ&SYSNDX          BRANCH AROUND EXIT ROUTINE\n&XZ      SETB  1\n         SPACE &OACPRTS\n&EXIT(1) L     R13,4(R13)         RELEASE CURRENT DSA\n         LM    R14,R11,12(R13)    RESTORE CALLERS REGS\n         LTR   R15,R15            SET CC\n         BR    R14                RETURN TO CALLER\n         AGO   .INUSE\n.L36     ANOP\n&NM      GETMAIN R,LV=&LEN,SP=&SP\n&NM      SETC  ''\n         MVC   &SPL.(4,R1),*-10   COPY SP AND LENGTH\n         ST    R13,4(R1)          DO SAVE AREA CHAINING\n         ST    R1,8(R13)          ESTABLISH ADDRESSABILITY\n         AIF   (&NOSTACK).L38\n         LR    R12,R1             MOVE BASE OF WA\n         AIF   ('&DSECT' EQ '').L37\n         OACUSING &DSECT,R12\n.L37     ANOP\n         L     R13,=A(&STK)       GET OFFSET TO STACK\n         ALR   R13,R12            POINT TO START OF STACK\n         A     R1,=A(&STKMX)      GET ADD OF STACK MAX\n         ST    R1,&OACSTMX        SAVE INTO WORK AREA\n         MVC   16(6,R12),=XL6'58FC000C07FF'\n         AIF   ('&STACK(3)' EQ '' ).OSEXIT\n         LA    R1,&STACK(3)       GET OVERFLOW ROUTINE ADDRESS\n         ST    R1,12(R12)         STORE IN WORK AREA\n         B     XZ&SYSNDX\n&XZ      SETB  1\n         SPACE &OACPRTS\n&STACK(3) BALR R15,0              GET A BASE\n         USING *,R15\n         WTO  'OAC900 STACK OVERFLOW IN &NAME',ROUTCDE=11,DESC=7\n         DROP  R15\n         AIF   ('&STACK(4)' EQ '' OR '&STACK(4)' EQ 'ABEND').SO\n         LR    R1,R12             SAVE WORK BASE\n         L     R13,4(R12)         UNCHAIN BASE ADDR\n         L     R0,&SPL.(R1)       POINT TO SP AND LENGTH\n         FREEMAIN R,LV=(0),A=(1)  DO THE FREEMAIN\n         LA    R15,&STACK(4)      LOAD RETURN CODE\n         LTR   R15,R15            SET CC\n         BR    R14                RETURN TO CALLER\n         AGO   .OSEXIT\n.SO      ANOP\n         ABEND 900,DUMP           STACK OVERFLOW ABEND\n         AGO   .OSEXIT\n.L38     ANOP\n         LR    R13,R1             NEW WORK BASE\n         AIF   ('&DSECT' EQ '').OSEXIT\n         OACUSING &DSECT,R13\n.OSEXIT  AIF   ('&EXIT' EQ '').INUSE\n         AIF   (&XZ).OSEXIT1\n         B     XZ&SYSNDX\n&XZ      SETB  1\n.OSEXIT1 ANOP\n         SPACE &OACPRTS\n         AIF   (&NOSTACK).OSEXIT2\n&EXIT(1) LR    R1,R12             SAVE BASE ADDR\n         L     R13,4(R12)         UNCHAIN SAVE AREA\n         AGO   .OSEXIT3\n.OSEXIT2 ANOP\n&EXIT(1) LR    R1,R13             SAVE BASE ADDR\n         L     R13,4(R13)         UNCHAIN SAVE AREA\n.OSEXIT3 AIF   ('&EXIT(2)' NE '').L39\n         ST    R15,16(R13)        SAVE RC\n         AGO   .L41\n.L39     ANOP\n&C       SETC  '&EXIT(2)'(1,1)\n         AIF   ('&C' EQ '(').L40\n         MVC   16(4,R13),&EXIT(2) SAVE RC\n         AGO   .L41\n.L40     ANOP\n&C       SETC  '&EXIT(2)'(2,K'&EXIT(2)-1)\n&C       SETC  '&C'(1,K'&C-1)\n         ST    &C,16(R13)         SAVE RC\n.L41     ANOP\n         L     R0,&SPL.(R1)       GET SP AND LENGTH\n         FREEMAIN R,LV=(0),A=(1)  DO THE FREEMAIN\n         LM    R14,R12,12(R13)    RESTORE CALLERS REGS\n         LTR   R15,R15            SET CONDITION CODE\n         BR    R14                RETURN TO CALLER\n.INUSE   AIF   (&NOSTACK).L41A\n         DC    0D'0'              PAD TO LTORG FOR COMPARES\n         LTORG                    AS GOOD A PLACE AS ANY\n.L41A    ANOP\n         AIF   (NOT &XZ).L42\nXZ&SYSNDX DC   0H'0'\n.L42     ANOP\n         OACINUSE PRINT=&PRINT\n.MEND    POP   PRINT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACFSORT": {"ttr": 7169, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x007\\x007\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&LABEL   OACFSORT &DSECT=YES,&PREFIX=FS#\n.* OAC FIXED RECORD SORT ROUTINE PARAMETER LIST (INCORE SORT)\n.*\n.*  NOTE THAT THE WORK AREA MUST BE LONG ENOUGH TO INCLUDE\n.*       ONE RECORD PLUS SORT WORKING STORAGE. (STACK)\n.*\n.*---------------------------------------------------------------------\n.*\n.*  FSORT - FIXED LENGTH RECORD SORT (IN STORAGE)\n.*\n.* ENTRY: R1 = @ P# LIST\n.*\n.* EXIT: R15 = RETURN CODE (CC SET)\n.*              0 - RECORDS SORTED (INPLACE)\n.*              4 - WORK AREA TOO SMALL\n.*\n.* THE WORK AREA LENGTH IS:\n.*  W#L + LENGTH OF ONE RECORD + STACK SPACE\n.*\n.*    COMPARE ROUTINE CALLED WITH:  R15 - ENTRY POINT\n.*                                  R14 - RETURN ADDRESS\n.*                                  R13 - @ 72 BYTE SAVE AREA\n.*                                  R1  - @ ELEMENT\n.*                                  R2  - @ ELEMENT\n.*                                  R3  - COMPARE ROUTINE PARM\n.*\n.* CONDITION CODE RETURNED FROM COMPARE ROUTINE DETERMINES ORDER,\n.*   IF HIGH THEN ELEMENT (R1) WILL APPEAR AFTER (R2),\n.*   IF LOW  THEN ELEMENT (R1) WILL APPEAR BEFORE (R2),\n.*   ELSE ORDER OF RECORDS IS UNDEFINED.\n.*\n.*  THE COMPARE ROUTINE MUST RESTORE *ALL* THE REGISTERS R0-R15.\n.*\n.*---------------------------------------------------------------------\n         LCLC  &LAB,&P\n&P       SETC  '&PREFIX'(1,3)     SET MAX PREFIX\n&LAB     SETC  '&P'               SET DEFAULT LABEL\n         AIF   ('&LABEL' EQ '').CK#DS BIF NO USER LABEL\n&LAB     SETC  '&LABEL'           SET USER'S LABEL\n.CK#DS   AIF   ('&DSECT' EQ 'YES').DSECT BIF DSECT GENERATION\n&LAB     DC    0D'0'              OACFSORT PARAMETER LIST\n         AGO   .GEN               BIF TO GENERATE DATA\n.DSECT   ANOP                     GENERATE DSECT HERE\n&LAB     DSECT ,                  OACFSORT PARAMETER LIST\n.GEN     ANOP\n&P.RECPT DC    A(0)               @ OF RECORDS\n&P.RECLN DC    F'0'               LENGTH OF EACH RECORD  (> 0)\n&P.RECNM DC    F'0'               NUMBER OF RECORDS      (>= 0)\n&P.CMPEP DC    A(0)               @ OF COMPARE ROUTINE\n&P.CMPPM DC    A(0)               PARM FOR COMPARE ROUTINE\n&P.WRKPT DC    A(0)               @ OF WORK AREA\n&P.WRKLN DC    F'0'               LENGTH OF WORK AREA    (>= 256)\n&P.L     EQU   *-&LAB             LENGTH OF PARAMETER LIST\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACFSVC": {"ttr": 7171, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x01\\xa1\\x01\\xa1\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 417, "newlines": 417, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&LBL     OACFSVC &DMY,&TYPE=,&GEN=,&PFX=OACF,&MF=,&DSECT=,             X\n               &SRA=,&UID=,&PW=,&NPW=,&IRA=,&DSN=,&VOL=,               X\n               &ACCESS=,&NFIELDS=,&FNAMES=,&IRAL=,&AREBUFL=,           X\n               &AREBUF=,&SMFBUFL=,&SMFBUF=\n         LCLC  &P,&NAME,&C\n         LCLB  &SRAP,&UIDP,&PWP,&NPWP,&IRAP,&DSNP,&VOLP,&ACSP\n         LCLB  &NFP,&NMP,&IRALP,&ABLP,&ABP,&SBLP,&SBP,&BGEN\n         LCLB  &MFE,&MFI,&MFL,&MFB,&BMF\n&NAME    SETC  '&LBL'\n&P       SETC  '&PFX'\n         AIF   ('&SRA' EQ '').A1\n&SRAP    SETB  1\n.A1      AIF   ('&UID' EQ '').A2\n&UIDP    SETB  1\n.A2      AIF   ('&PW' EQ '').A3\n&PWP     SETB  1\n.A3      AIF   ('&NPW' EQ '').A4\n&NPWP    SETB  1\n.A4      AIF   ('&IRA' EQ '').A5\n&IRAP    SETB  1\n.A5      AIF   ('&DSN' EQ '').A6\n&DSNP    SETB  1\n.A6      AIF   ('&VOL' EQ '').A7\n&VOLP    SETB  1\n.A7      AIF   ('&ACCESS' EQ '').A8\n&ACSP    SETB  1\n.A8      AIF   ('&NFIELDS' EQ '').A9\n&NFP     SETB  1\n.A9      AIF   ('&FNAMES' EQ '').A10\n&NMP     SETB  1\n.A10     AIF   ('&IRAL' EQ '').A10A\n&IRALP   SETB  1\n.A10A    AIF   ('&AREBUFL' EQ '').A11\n&ABLP    SETB  1\n.A11     AIF   ('&AREBUF' EQ '').A12\n&ABP     SETB  1\n.A12     AIF   ('&SMFBUFL' EQ '').A13\n&SBLP    SETB  1\n.A13     AIF   ('&SMFBUF' EQ '').A14\n&SBP     SETB  1\n.A14     AIF   ('&GEN' EQ '').A15\n&BGEN    SETB  1\n.A15     AIF   ('&MF' EQ '').B\n&BMF     SETB  1\n         AIF   ('&MF(1)' NE 'E').A16\n&MFE     SETB  1\n         AGO   .B\n.A16     AIF   ('&MF(1)' NE 'I').A17\n&MFI     SETB  1\n         AGO   .B\n.A17     AIF   ('&MF(1)' NE 'L').A18\n&MFL     SETB  1\n         AGO   .B\n.A18     AIF   ('&MF(1)' NE 'B').MFERR\n&MFB     SETB  1\n         AGO   .B\n.MFERR   MNOTE 12,'UNRECOGNIZEABLE MF='\n         MEXIT\n.CONF    MNOTE 12,'CONFLICTING PARMS'\n         MEXIT\n.B       AIF   (&BGEN AND &BMF).CONF\n         AIF   (&BGEN OR &BMF).B1\n&BMF     SETB  1\n&MFI    SETB  1\n.B1      AIF   (&BMF).B2\n         AIF   ('&DSECT' EQ '').B2\n&DSECT   DSECT\n.B2      AIF   (NOT &MFI).B3\n         AIF   ('&TYPE' EQ 'SLGF').B3\n&NAME    B     B&SYSNDX\n&NAME    SETC  ''\n.B3      AIF   ('&GEN' EQ 'SRA').SRA\n         AIF   ('&TYPE' EQ 'SLGN').SLGN\n         AIF   ('&TYPE' EQ 'ULGN' ).ULGN\n         AIF   ('&TYPE' EQ 'DS'   ).DS\n         AIF   ('&TYPE' EQ 'INFO' ).INFO\n         AIF   ('&TYPE' EQ 'CHG'  ).CHG\n         AIF   ('&TYPE' EQ 'ULGF' ).ULGF\n         AIF   ('&TYPE' EQ 'SMF'  ).SMF\n         AIF   ('&TYPE' EQ 'SLGF' ).SLGF\n         AIF   ('&TYPE' NE 'ALL'  ).TYPERR\n         AIF   ('&GEN' EQ 'PARMS' OR NOT &BGEN).ALLP\n.GENERR  MNOTE 12,'UNRECOGNIZABLE GEN='\n         MEXIT\n.TYPERR  MNOTE 12,'UNRECOGNIZABLE TYPE'\n         MEXIT\n.SRA     AIF   ('&NAME' EQ '').SRA1\n&NAME    DS    0F\n&NAME    SETC  ''\n.SRA1    ANOP\n&P.SRC   DS    F                  SECONDARY RETURN CODE\n&P.MSG   DS    0H                 MESSAGE BUFFER\n&P.MLEN  DS    H                  MSG LENGTH INCLUDING HEADER\n         DS    H                  SET TO ZERO\n&P.MTXT  DS    CL124              MESSAGE TEXT\n&P.SRAL  EQU   132                LENGTH OF STANDARD RETURN AREA\n         MEXIT\n.ALLP    AIF   ('&NAME' EQ '').ALLP1\n&NAME    DS    0F\n&NAME    SETC  ''\n.ALLP1   ANOP\n&P.SRAP  DC    A(0)               PTR TO \"STANDARD RETURN AREA\"\n&P.UIDP  DC    A(0)               PTR TO CL7 UID\n&P.SBLP  EQU   &P.UIDP            PTR TO F LENGTH OF SMF INFO\n&P.PWP   DC    A(0)               PTR TO CL8 CURRENT PASSWORD\n&P.DSNP  EQU   &P.PWP             PTR TO CL44 DSNAME\n&P.NFP   EQU   &P.PWP             PTR TO F NUMBER OF FIELD NAMES\n&P.ABLP  EQU   &P.PWP             PTR TO F LENGTH OF ARE BUFFER\n&P.SBP   EQU   &P.PWP             PTR TO  SMF BUFFER\n&P.NPWP  DC    A(0)               PTR TO CL8 NEW PASSWORD\n&P.VOLP  EQU   &P.NPWP            PTR TO CL6 VOLUME\n&P.NMP   EQU   &P.NPWP            PTR TO LIST OF CL8 FIELD NAMES\n&P.ABP   EQU   &P.NPWP            PTR TO  ARE BUFFER\n&P.IRAP  DC    A(0)               PTR TO \"INFO RETURN AREA\"\n&P.ACSP  EQU   &P.IRAP            PTR TO XL1 ACCESSES\n&P.EXEC  EQU   X'80'              EXECUTE ONLY\n&P.READ  EQU   X'40'              READ ONLY\n&P.WRIT  EQU   X'20'              READ/WRITE\n&P.ALOC  EQU   X'10'              ALLOC/SCRATCH/RENAME\n&P.IRLP  DC    A(0)               PTR TO F IRA LENGTH\n         MEXIT\n.SLGN    AIF   (&UIDP OR &PWP OR &NPWP OR &IRAP OR &DSNP).CONF\n         AIF   (&VOLP OR &ACSP OR &NFP OR &NMP OR &ABLP).CONF\n         AIF   (&IRALP OR &ABP OR &SBLP OR &SBP).CONF\n         AIF   (&BMF).SLGNMF\n         AIF   ('&GEN' NE 'PARMS' AND &BGEN).GENERR\n         AIF   ('&NAME' EQ '').SLGN1\n&NAME    DS    F\n.SLGN1   ANOP\n&P.SRAP  DS    F                  POINTER TO \"STANDARD RETURN AREA\"\n         MEXIT\n.SLGNMF  AIF   (NOT &MFI).SLGN2\nA&SYSNDX DC A(0)\nB&SYSNDX LA    R1,A&SYSNDX\n         OACINNER F=&SRA,T=0(R1)\n         LA    R0,1               SERVICE LOGON CALL\n         AGO   .SVC209\n.SLGN2   AIF   (&MFL).SLGN3\n&NAME    OACINNER F=&MF(2),T=(R1),COM='GET ADD OF PARM LIST'\n         OACINNER F=&SRA,T=0(R1),COM='PTR TO \"STANDARD RETURN AREA\"'\n         LA    R0,1               SERVICE LOGON CALL\n         AGO   .SVC209\n.SLGN3   ANOP\n&NAME    OACDC &SRA,COM='PTR TO \"STANDARD RETURN AREA\"'\n         MEXIT\n.ULGN    AIF   (&DSN OR &VOLP OR &ACSP OR &NFP OR &NMP).CONF\n         AIF   (&IRALP OR &ABLP OR &ABP OR &SBLP OR &SBP).CONF\n         AIF   (&BMF).ULGNMF\n         AIF   ('&NAME' EQ '').ULGN1\n&NAME    DS    0F\n.ULGN1   AIF   ('&GEN' EQ 'PARMS' AND &BGEN).ULGNP\n         AIF   ('&GEN' NE 'IRA').GENERR\n&P.NAME  DC    CL20' '            USERS NAME\n&P.FONE  DC    CL12' '            PHONE NUMBER\n&P.PFX   DC    CL7' '             DEFAULT DSN PREFIX\n&P.UNIT  DC    CL8' '             GENERIC UNIT\n&P.BIN   DC    CL4' '             DEFAULT BIN\n&P.RMT   DC    CL8' '             DEFAULT REMOTE DEST\n&P.SHC   DC    CL1' '             DEFAULT SUBMIT HOLD CLASS\n&P.SJC   DC    CL1' '             DEFAULT SUBMIT JOB CLASS\n&P.SMC   DC    CL1' '             DEFAULT SUBMIT MSGCLASS\n&P.SSC   DC    CL1' '             DEFAULT SUBMIT SYSOUT CLASS\n&P.LDC   DC    AL1(&P.ATTN)       LINE DELETE CHAR\n&P.ATTN  EQU   X'37'              ATTN IS LINE DELETE\n&P.CTLX  EQU   X'18'              CTLX IS LINE DELETE\n&P.BSC   DC    AL1(&P.BS)         BACKSPACE CHARACTER\n&P.BS    EQU   X'16'              BS IS C D CHARACTER\n&P.MSGF  DC    AL1(0)             MESSAGE FLAGS\n&P.MAIL  EQU   X'80'              MAIL/NOMAIL\n&P.NTCS  EQU   X'40'              NOTICES/NONOTICES\n&P.PRMT  EQU   X'20'              PROMPT/NOPROMPT\n&P.INTR  EQU   X'10'              INTERCOM/NOINTERCOM\n&P.PAUS  EQU   X'08'              PAUSE/NOPAUSE\n&P.MID   EQU   X'04'              MSGID/NOMSGID\n&P.MODE  EQU   X'02'              MODE/NOMODE\n&P.WTP   EQU   X'01'              WTP/NOWTP\n&P.FACS  DC    AL1(0)             FACILITIES\n&P.BTCH  EQU   X'80'              BATCH WITH QUICKRUN\n&P.QCK   EQU   X'40'              QUICKRUN ONLY\n&P.BSIC  EQU   X'20'              BASIC ONLY\n&P.APL   EQU   X'10'              APL ONLY\n&P.TSO   EQU   X'08'              TSO WITH APL AND BASIC\n&P.WBR   EQU   X'04'              WYLBUR\n&P.ARPA  EQU   X'02'              ARPA\n&P.OTHR  EQU   X'01'              OTHER\n&P.RSVD  DC    AL1(0)             RESERVED\n&P.PRML  EQU   *-&P.NAME          LENGTH\n         MEXIT\n.ULGNP   ANOP\n&P.SRAP  DC    A(0)               PTR TO \"STANDARD RETURN AREA\"\n&P.UIDP  DC    A(0)               PTR TO CL7 UID\n&P.PWP   DC    A(0)               PTR TO CL8 \"CURRENT\" PASSWORD\n&P.NPWP  DC    A(0)               PTR TO CL8 NEW PASSWORD\n&P.IRAP  DC    A(0)               PTR TO XL68 \"INFO RETURN AREA\"\n         MEXIT\n.ULGNMF  AIF   (NOT &MFI).ULGN2\nA&SYSNDX DC 5A(0)                 PARM AREA\nB&SYSNDX LA     R1,A&SYSNDX       POINT TO PARM LIST\n         OACINNER F=&SRA,T=0(R1),COM='PTR TO \"STANDARD RETURN AREA\"'\n         OACINNER F=&UID,T=0(R1),TO=+4,COM='PTR TO CL7 UID'\n         OACINNER F=&PW,T=0(R1),TO=+8,COM='PTR TO CL8 PASSWORD'\n         OACINNER F=&NPW,T=0(R1),TO=+12,COM='PTR TO CL8 NEW PASSWORD'\n         OACINNER F=&IRA,T=0(R1),TO=+16,COM='PTR TO XL68 RETURN AREA'\n         LA    R0,2               USER LOGON CALL\n         AGO   .SVC209\n.ULGN2   AIF   (&MFL).ULGN3\n&NAME    OACINNER F=&MF(2),T=(R1),COM='GET ADD OF PARM LIST'\n         OACINNER F=&SRA,T=0(R1),COM='PTR TO \"STANDARD RETURN AREA\"'\n         OACINNER F=&UID,T=0(R1),TO=+4,COM='PTR TO CL7 UID'\n         OACINNER F=&PW,T=0(R1),TO=+8,COM='PTR TO CL8 PASSWORD'\n         OACINNER F=&NPW,T=0(R1),TO=+12,COM='PTR TO CL8 NEW PASSWORD'\n         OACINNER F=&IRA,T=0(R1),TO=+16,COM='PTR TO XL68 RETURN AREA'\n         LA    R0,2               USER LOGON CALL\n         AGO   .SVC209\n.ULGN3   ANOP\n&NAME    OACDC &SRA,COM='PTR TO \"STANDARD RETURN AREA\"'\n         OACDC &UID,COM='PTR TO CL7 UID'\n         OACDC &PW,COM='PTR TO CL8 PASSWORD'\n         OACDC &NPW,COM='PTR TO CL8 NEW PASSWORD'\n         OACDC &IRA,COM='PTR TO XL68 INFO RETURN AREA'\n         AGO   .MEND\n.DS      AIF   (&PWP OR &NPWP OR &IRAP OR &NFP OR &NMP).CONF\n         AIF   (&IRALP OR &ABLP OR &ABP OR &SBLP OR &SBP).CONF\n         AIF   (&BMF).DSMF\n         AIF   ('&GEN' NE 'PARMS' AND &BGEN).GENERR\n         AIF   ('&NAME' EQ '').DS1\n&NAME    DS    0F\n.DS1     ANOP\n&P.SRAP  DC    A(0)               PTR TO \"STANDARD RETURN AREA\"\n&P.UIDP  DC    A(0)               PTR TO CL7 UID\n&P.DSNP  DC    A(0)               PTR TO CL44 DSNAME\n&P.VOLP  DC    A(0)               PTR TO CL6 VOLUME\n&P.ACSP  DC    A(0)               PTR TO XL1 ACCESSES\n&P.EXEC  EQU   X'80'              EXEC ONLY\n&P.READ  EQU   X'40'              READ ONLY\n&P.WRIT  EQU   X'20'              READ/WRITE\n&P.ALOC  EQU   X'10'              ALLOC/RENAME/SCRATCH\n         MEXIT\n.DSMF    AIF   (NOT &MFI).DS2\nA&SYSNDX DC    5A(0)              PARM LIST\nB&SYSNDX LA    R1,A&SYSNDX\n         OACINNER F=&SRA,T=0(R1),COM='PTR TO \"STANDARD RETURN AREA\"'\n         OACINNER F=&UID,T=0(R1),TO=+4,COM='PTR TO CL7 UID'\n         OACINNER F=&DSN,T=0(R1),TO=+8,COM='PTR TO CL44 DSNAME'\n         OACINNER F=&VOL,T=0(R1),TO=+12,COM='PTR TO CL6 VOLUME'\n         OACINNER F=&ACCESS,T=0(R1),TO=+16,COM='PTR TO XL1 ACCESSES'\n         LA    R0,3               DATASET ACCESS VERIFICATION\n         AGO   .SVC209\n.DS2     AIF   (&MFL).DS3\n&NAME    OACINNER F=&MF(2),T=(R1),COM='GET ADD OF PARM LIST'\n         OACINNER F=&SRA,T=0(R1),COM='PTR TO \"STANDARD RETURN AREA\"'\n         OACINNER F=&UID,T=0(R1),TO=+4,COM='PTR TO CL7 UID'\n         OACINNER F=&DSN,T=0(R1),TO=+8,COM='PTR TO CL44 DSNAME'\n         OACINNER F=&VOL,T=0(R1),TO=+12,COM='PTR TO CL6 VOLUME'\n         OACINNER F=&ACCESS,T=0(R1),TO=+16,COM='PTR TO XL1 ACCESSES'\n         LA    R0,3               DATASET ACCESS VERIFICATION\n         AGO   .SVC209\n.DS3     ANOP\n&NAME    OACDC &SRA,COM='PTR TO \"STANDARD RETURN AREA\"'\n         OACDC &UID,COM='PTR TO CL7 UID'\n         OACDC &DSN,COM='PTR TO CL44 DSNAME'\n         OACDC &VOL,COM='PTR TO CL6 VOLUME'\n         OACDC &ACCESS,COM='PTR TO XL1 ACCESSES'\n         AGO   .MEND\n.INFO    AIF   (&PWP OR &NPWP OR &DSNP OR &VOLP OR &ACSP).CONF\n         AIF   (&ABP OR &ABLP OR &SBLP OR &SBP).CONF\n         AIF   (&BMF).INFOMF\n         AIF   ('&GEN' NE 'PARMS' AND &BGEN).GENERR\n         AIF   ('&NAME' EQ '').INFO1\n&NAME    DS    0F\n.INFO1   ANOP\n&P.SRAP  DC    A(0)               PTR TO \"STANDARD RETURN AREA\"\n&P.UIDP  DC    A(0)               PTR TO CL7 UID\n&P.NFP   DC    A(0)               PTR TO F NUMBER OF FIELD NAMES\n&P.NMP   DC    A(0)               PTR TO LIST OF CL8 FIELD NAMES\n&P.IRAP  DC    A(0)               PTR TO INFO RETURN AREA\n&P.IRLP  DC    A(0)               PTR TO F LENGTH OF IRA\n         MEXIT\n.INFOMF  AIF   (NOT &MFI).INFO2\nA&SYSNDX DC    6A(0)              PARM LIST\nB&SYSNDX LA    R1,A&SYSNDX        PT TO PARM LIST\n         OACINNER F=&SRA,T=0(R1),COM='PTR TO \"STANDARD RETURN AREA\"'\n         OACINNER F=&UID,T=0(R1),TO=+4,COM='PTR TO CL7 UID'\n         OACINNER F=&NFIELDS,T=0(R1),TO=+8,COM='PTR TO F NUM FIELDS'\n         OACINNER F=&FNAMES,T=0(R1),TO=+12,COM='PTR TO LST OF CL8 NMS'\n         OACINNER F=&IRA,T=0(R1),TO=+16,COM='PTR TO INFO RETURN AREA'\n         OACINNER F=&IRAL,T=0(R1),TO=+20,COM='PTR TO F LENGTH OF IRA'\n         LA    R0,4               INFO REQUEST\n         AGO   .SVC209\n.INFO2   AIF   (&MFL).INFO3\n&NAME    OACINNER F=&MF(2),T=(R1),COM='POINT TO PARM AREA'\n         OACINNER F=&SRA,T=0(R1),COM='PTR TO \"STANDARD RETURN AREA\"'\n         OACINNER F=&UID,T=0(R1),TO=+4,COM='PTR TO CL7 UID'\n         OACINNER F=&NFIELDS,T=0(R1),TO=+8,COM='PTR TO F NUM FIELDS'\n         OACINNER F=&FNAMES,T=0(R1),TO=+12,COM='PTR TO LST OF CL8 NMS'\n         OACINNER F=&IRA,T=0(R1),TO=+16,COM='PTR TO INFO RETURN AREA'\n         OACINNER F=&IRAL,T=0(R1),TO=+20,COM='PTR TO F LENGTH OF IRA'\n         LA    R0,4               INFO REQUEST\n         AGO   .SVC209\n.INFO3   ANOP\n&NAME    OACDC &SRA,COM='PTR TO \"STANDARD RETURN AREA\"'\n         OACDC &UID,COM='PTR TO CL7 UID'\n         OACDC &NFIELDS,COM='PTR TO F NUMBER OF FIELDS'\n         OACDC &FNAMES,COM='PTR TO LIST OF CL8 NAMES'\n         OACDC &IRA,COM='PTR TO INFO RETURN AREA'\n         OACDC &IRAL,COM='PTR TO F LENGTH OF IRA'\n         AGO   .MEND\n.CHG     AIF   (&PWP OR &NPWP OR  &IRAP OR &DSNP OR &VOLP).CONF\n         AIF   (&ACSP OR &NFP OR  &NMP OR &IRALP OR &SBLP).CONF\n         AIF   (&SBP).CONF\n         AIF   (&BMF).CHGMF\n         AIF   ('&GEN' NE 'PARMS' AND &BGEN).GENERR\n         AIF   ('&NAME' EQ '').CHG1\n&NAME    DS    0F\n.CHG1    ANOP\n&P.SRAP  DC    A(0)               PTR TO \"STANDARD RETURN AREA\"\n&P.UIDP  DC    A(0)               PTR TO CL7 UID\n&P.ABLP  DC    A(0)               PTR F LEN OF ARE BUFFER\n&P.ABP   DC    A(0)               PTR TO ARE BUFFER\n         MEXIT\n.CHGMF   AIF   (NOT &MFI).CHG2\nA&SYSNDX DC    4A(0)              PARM LIST\nB&SYSNDX LA    R1,A&SYSNDX        PT TO PARM LIST\n         OACINNER F=&SRA,T=0(R1),COM='PTR TO \"STANDARD RETURN AREA\"'\n         OACINNER F=&UID,T=0(R1),TO=+4,COM='PTR TO CL7 UID'\n         OACINNER F=&AREBUFL,T=0(R1),TO=+8,COM='PTR TO F BUF LEN'\n         OACINNER F=&AREBUF,T=0(R1),TO=+12,COM='PTR TO ARE BUFFER'\n         LA    R0,5               CHANGE REQUEST\n         AGO   .SVC209\n.CHG2    AIF   (&MFL).CHG3\n         OACINNER F=&MF(2),T=(R1),COM='PT TO PARM LIST'\n         OACINNER F=&SRA,T=0(R1),COM='PTR TO \"STANDARD RETURN AREA\"'\n         OACINNER F=&UID,T=0(R1),TO=+4,COM='PTR TO CL7 UID'\n         OACINNER F=&AREBUFL,T=0(R1),TO=+8,COM='PTR TO F BUF LEN'\n         OACINNER F=&AREBUF,T=0(R1),TO=+12,COM='PTR TO ARE BUFFER'\n         LA    R0,5               CHANGE REQUEST\n         AGO   .SVC209\n.CHG3    ANOP\n&NAME    OACDC &SRA,COM='PTR TO \"STANDARD RETURN AREA\"'\n         OACDC &UID,COM='PTR TO CL7 UID'\n         OACDC &AREBUFL,COM='PTR TO F BUFFER LENGTH'\n         OACDC &AREBUF,COM='PTR TO ARE BUFFER'\n         MEXIT\n.ULGF    AIF   (&PWP OR &NPWP OR &IRAP OR &DSNP OR &VOLP).CONF\n         AIF   (&ACSP OR &NFP OR &NMP OR &IRALP OR &ABLP).CONF\n         AIF   (&ABLP OR &ABP OR &SBLP OR &SBP).CONF\n         AIF   (&BMF).ULGFMF\n         AIF   ('&GEN' NE 'PARMS' AND &BGEN).GENERR\n         AIF   ('&NAME' EQ '').ULGF1\n&NAME    DS    0F\n.ULGF1   ANOP\n&P.SRAP  DC    A(0)               PTR TO \"STANDARD RETURN AREA\"\n&P.UIDP  DC    A(0)               PTR TO CL7 UID\n         MEXIT\n.ULGFMF  AIF   (NOT &MFI).ULGF2\nA&SYSNDX DC    2A(0)              PARM LIST\nB&SYSNDX LA    R1,A&SYSNDX\n         OACINNER F=&SRA,T=0(R1),COM='PTR TO \"STANDARD RETURN AREA\"'\n         OACINNER F=&UID,T=0(R1),TO=+4,COM='PTR TO CL7 UID'\n         LA    R0,6               USER LOGOFF REQUEST\n         AGO   .SVC209\n.ULGF2   AIF   (&MFL).ULGF3\n&NAME    OACINNER F=&MF(2),T=(R1),COM='PT TO PARM LIST'\n         OACINNER F=&SRA,T=0(R1),COM='PTR TO \"STANDARD RETURN AREA\"'\n         OACINNER F=&UID,T=0(R1),TO=+4,COM='PTR TO CL7 UID'\n         LA    R0,6               USER LOGOFF REQUEST\n         AGO   .SVC209\n.ULGF3   ANOP\n&NAME    OACDC &SRA,COM='PTR TO \"STANDARD RETURN AREA\"'\n         OACDC &UID,COM='PTR TO C L7 UID'\n         MEXIT\n.SMF     AIF   (&UID OR &PW OR &NPW OR &IRA OR &DSN OR &VOL).CONF\n         AIF   (&ACSP OR &NFP OR &NMP OR &IRALP OR &ABP).CONF\n         AIF   (&ABLP).CONF\n         AIF   (&BMF).SMFMF\n         AIF   ('&GEN' NE 'PARMS' AND &BGEN).GENERR\n         AIF   ('&NAME' EQ '').SMF1\n&NAME    DS    0F\n.SMF1    ANOP\n&P.SRAP  DC    A(0)               PTR TO \"STANDARD RETURN AREA\"\n&P.SBLP  DC    A(0)               PTR TO F LENGTH OF SMF BUFFER\n&P.SBP   DC    A(0)               PTR TO SMF BUFFER\n         MEXIT\n.SMFMF   AIF   (NOT &MFI).SMF2\nA&SYSNDX DC    3A(0)              PARM LIST\nB&SYSNDX LA    R1,A&SYSNDX        POINT TO PARM LIST\n         OACINNER F=&SRA,T=0(R1),COM='PTR TO \"STANDARD RETURN AREA\"'\n         OACINNER F=&SMFBUFL,T=0(R1),TO=+4,COM='PTR TO F BUFFER LEN'\n         OACINNER F=&SMFBUF,T=0(R1),TO=+8,COM='PTR TO SMF BUFFER'\n         LA    R0,7               SMF RECORD WRITE REQUEST\n         AGO   .SVC209\n.SMF2    AIF   (&MFL).SMF3\n&NAME    OACINNER F=&MF(2),T=(R1),COM='PT TO PARM LIST'\n         OACINNER F=&SRA,T=0(R1),COM='PTR TO \"STANDARD RETURN AREA\"'\n         OACINNER F=&SMFBUFL,T=0(R1),TO=+4,COM='PTR TO F BUFFER LEN'\n         OACINNER F=&SMFBUF,T=0(R1),TO=+8,COM='PTR TO SMF BUFFER'\n         LA    R0,7               SMF RECORD WRITE REQUEST\n         AGO   .SVC209\n.SMF3    ANOP\n&NAME    OACDC &SRA,COM='PTR TO \"STANDARD RETURN AREA\"'\n         OACDC &SMFBUFL,COM='PTR  TO F BUFFER LEN'\n         OACDC &SMFBUF,COM='PTR TO SMF BUFFER'\n         MEXIT\n.SLGF    AIF   (&UID OR &PW OR &NPW OR &IRA OR &DSN OR &VOL).CONF\n         AIF   (&ACSP OR &NFP OR &NMP OR &IRALP OR &ABP).CONF\n         AIF   (&ABLP OR &SBLP OR &SBP).CONF\n         AIF   ('&GEN' NE 'PARMS' AND &BGEN).GENERR\n         AIF   (&BMF AND NOT &MFI AND NOT &MFB).SLGFMF\n&NAME    LA    R1,0               NO PARMS\n         LA    R0,8               SERVICE LOGOFF CALL\n.SVC209  AIF   (&MFB).MEND\n         SVC   209\n         MEXIT\n.SLGFMF  MNOTE 8,'SLGF HAS NO PARMS, AND NO PARM LIST'\n.MEND    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OACFS0RT": {"ttr": 7178, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x01\\x17\\x01\\x17\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 279, "newlines": 279, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMASP JOB NAS,MSGCLASS=A,COND=(0,NE),TIME=(,5)\n/*ROUTE PRINT WYLBUR\n//*** I RENAMED THIS FROM OACFSORT TO OACFS0RT SO EVERYTHING WOULD\n//*** FIT INTO ONE PDS\n//ASM EXEC ASMHCL\n//ASM.SYSLIB DD\n//           DD\n//           DD DISP=SHR,DSN=SYS5.MSSMAC\n//ASM.SYSIN    DD *\nOACFSORT CSECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*   FSORT - FIXED LENGTH RECORD SORT (IN STORAGE)                     *\n*                                                                     *\n* ENTRY: R1 = @ P# LIST                                               *\n*                                                                     *\n* EXIT:  R15 = RETURN CODE (CC SET)                                   *\n*               0 - RECORDS SORTED (INPLACE)                          *\n*               4 - WORK AREA TOO SMALL                               *\n*                                                                     *\n*  THE WORK AREA LENGTH IS:                                           *\n*   W#L + LENGTH OF ONE RECORD + STACK SPACE                          *\n*                                                                     *\n*     COMPARE ROUTINE CALLED WITH:  R15 - ENTRY POINT                 *\n*                                   R14 - RETURN ADDRESS              *\n*                                   R13 - @ 72 BYTE SAVE AREA         *\n*                                   R1  - @ ELEMENT                   *\n*                                   R2  - @ ELEMENT                   *\n*                                   R3  - COMPARE ROUTINE PARM        *\n*                                                                     *\n*  CONDITION CODE RETURNED FROM COMPARE ROUTINE DETERMINES ORDER,     *\n*    IF HIGH THEN ELEMENT (R1) WILL APPEAR AFTER (R2),                *\n*    IF LOW  THEN ELEMENT (R1) WILL APPEAR BEFORE (R2),               *\n*    ELSE ORDER OF RECORDS IS UNDEFINED.                              *\n*                                                                     *\n*   THE COMPARE ROUTINE MUST RESTORE *ALL* THE REGISTERS R0-R15.      *\n*                                                                     *\n*   OACFSORT CURRENTLY USES PARTITION EXCHANGE.                       *\n*                                                                     *\n*   NOTE THAT THE RECORDS OUTSIDE OF THE AREA TO SORT ARE *NOT*       *\n*   REFERENCED AT ALL.                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\n         OACFSORT PREFIX=P#\n         SPACE 1\nW#       DSECT ,\nW#SAVE   DC    18F'0'\nW#STKPT  DC    A(0)               @ STACK\nW#STKLM  DC    A(0)               STACK LIMIT PTR\nW#RECLS  DC    A(0)               @ LAST RECORD IN RECORD AREA\nW#REC    DC    0D'0'              TEMP RECORD AREA\nW#L      EQU   *-W#               MINIMUM WORK LENGTH\n         EJECT ,\nOACFSORT CSECT ,\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         OACUSING OACFSORT,R12\n         LR    R11,R1\n         OACUSING P#,R11\n         SPACE 1\n         L     R8,P#RECLN         RECORD LENGTH\n         LM    R1,R2,P#WRKPT      ADDR, LENGTH OF WORK AREA\n         LA    R0,W#L+4*8(R8)     W# LEN + RECORD LEN + ALIGN/MIN STACK\n         CR    R2,R0              WORK AREA TOO SHORT?\n         BL    ERR1               BIF WORK AREA TOO SHORT\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         OACUSING W#,R13\n         LA    R0,0(R1,R2)        @ PAST END OF W# AREA SUPPLIED\n         SH    R0,=Y(8+7)         ALLOW 1 ENTRY + ALIGN FOR STACK\n         ST    R0,W#STKLM         INIT STACK LIMIT PTR\n         SPACE 1\n         L     R5,P#RECNM         NUMBER OF RECORDS\n         MR    R4,R8              # RECORDS * LENGTH RECORD\n         L     R2,P#RECPT         @ 1ST RECORD            (A)\n         LA    R5,0(R2,R5)        @ PAST LAST RECORD\n         SR    R5,R8              @ LAST RECORD           (B)\n         ST    R5,W#RECLS         SAVE @ LAST RECORD\n         SPACE 1\n         L     R3,P#CMPPM         PARM FOR COMPARE ROUTINE\n         L     R10,P#CMPEP        @ OF COMPARE ROUTINE\n         LA    R9,7(,R8)          RECORD LENGTH + 7\n         N     R9,=X'00FFFFF8'    RECORD LEN ROUNDED UP TO MUL OF 8\n         LA    R9,W#REC(R9)       @ OF START OF STACK\n         ST    R9,W#STKPT         SAVE @ OF STACK\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*  REGISTER USAGE --                                                  *\n* R0  - WORK                                                          *\n* R1  - @ RECORD (FOR COMPARE ROUTINE)  / WORK                        *\n* R2  - A   (@ LEFTMOST RECORD IN CURRENT GROUP)                      *\n* R3  - COMPARE ROUTINE PARM            / WORK                        *\n* R4  -                                                               *\n* R5  - B   (@ RIGHTMOST RECORD IN CURRENT GROUP)                     *\n* R6  - I   (LEFT TO RIGHT SCAN PTR)                                  *\n* R7  - J   (RIGHT TO LEFT SCAN PTR)                                  *\n* R8  - RECORD LENGTH                                                 *\n* R9  - STACK POINTER                                                 *\n* R10 - @ COMPARE ROUTINE                                             *\n* R11 - @ P#                                                          *\n* R12 - PGM BASE                                                      *\n* R13 - @ W#                                                          *\n* R14 - WORK                                                          *\n* R15 - WORK                                                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\n* CHECK FOR ONLY ONE RECORD TO SORT\nSORT     CR    R2,R5              A :: B\n         BNL   SORTUS             BIF A >= B (ONLY ONE RECORD)\n* I = A\n         LR    R6,R2              I = A\n* J = B + RECLN (@ PAST LAST RECORD IN GROUP)\n         LR    R7,R5              B\n         AR    R7,R8              + RECLN\n* PICK MEDIAN RECORD HERE AND SWAP WITH K(A)\n* SO THAT ORDERED INPUT IS NOT WORST CASE...\n*             (((B - A)/RECLN)/2)*RECLN\n         LR    R1,R5              B\n         SR    R1,R2              B - A\n         SR    R0,R0\n         DR    R0,R8              B-A/RECLN\n         SRL   R1,1               HALF THE RECORDS\n         CH    R1,=H'4'           < 4 RECORDS\n         BL    SORTL1             BIF < 4 RECORDS; SKIP MID SWAP\n         MR    R0,R8              OFFSET OF THE RECORD\n         AR    R1,R2              @ OF K(MID)\n         LR    R4,R1              SAVE @ K(MID)\n* SWAP K(A) & K(MID)\n         LR    R0,R4              @ K(MID)                (SOURCE)\n         LR    R1,R8              RECLN\n         LA    R14,W#REC          @ TEMP RECORD AREA      (TARGET)\n         LR    R15,R8             RECLN\n         MVCL  R14,R0             K(MID) TO TEMP AREA\n         LR    R0,R2              @ K(A)                  (SOURCE)\n         LR    R1,R8              RECLN\n         LR    R14,R4             @ K(MID)                (TARGET)\n         LR    R15,R8             RECLN\n         MVCL  R14,R0             K(A) TO K(MID)\n         LA    R0,W#REC           @ TEMP RECORD AREA      (SOURCE)\n         LR    R1,R8              RECLN\n         LR    R14,R2             @ K(A)                  (TARGET)\n         LR    R15,R8             RECLN\n         MVCL  R14,R0             K(MID) TO K(A) FROM TEMP AREA\n* FIND K(I) > K(A)\nSORTL1   AR    R6,R8              I = I + RECLN\n         CR    R6,R7              I :: J\n         BNL   SORTF              BIF I >= J\n         LR    R1,R6              K(I)\n         LR    R15,R10            @ COMPARE ROUTINE\n         BALR  R14,R15            COMPARE K(I) :: K(A)  <R2>\n         BNH   SORTL1             BIF K(I) <= K(A)\n         SPACE 1\n* FIND K(J) <= K(A)\nSORTL2   SR    R7,R8              J = J - RECLN\n         CR    R7,R6              J :: I\n         BNH   SORTF              BIF J <= I\n         LR    R1,R7              K(J)\n         LR    R15,R10            @ COMPARE ROUTINE\n         BALR  R14,R15            COMPARE K(J) :: K(A)  <R2>\n         BH    SORTL2             BIF K(J) > K(A)\n* HAVE K(I) > K(A) & K(J) <= K(A)\n* ALSO I < J SO ARE DIFFERENT RECORDS\n* SWAP K(I) AND K(J)\n         LR    R0,R6              @ K(I)                  (SOURCE)\n         LR    R1,R8              RECLN\n         LA    R14,W#REC          @ TEMP RECORD AREA      (TARGET)\n         LR    R15,R8             RECLN\n         MVCL  R14,R0             K(I) TO TEMP AREA\n         LR    R0,R7              @ K(J)                  (SOURCE)\n         LR    R1,R8              RECLN\n         LR    R14,R6             @ K(I)                  (TARGET)\n         LR    R15,R8             RECLN\n         MVCL  R14,R0             K(J) TO K(I)\n         LA    R0,W#REC           @ TEMP RECORD AREA      (SOURCE)\n         LR    R1,R8              RECLN\n         LR    R14,R7             @ K(J)                  (TARGET)\n         LR    R15,R8             RECLN\n         MVCL  R14,R0             K(I) TO K(J) FROM TEMP AREA\n         B     SORTL1              AND CONTINUE\n         SPACE 1\n* UNABLE TO FIND K(I) > K(A) AND K(J) <= K(A) FOR I < J\n*     (I = J HERE AND I = J MAY BE > B)\n* SO SWAP K(A) WITH K(J-1)\nSORTF    LR    R4,R7              @ K(J)\n         SR    R4,R8              @ K(J-1)\n         LR    R0,R4              @ K(J-1)                (SOURCE)\n         LR    R1,R8              RECLN\n         LA    R14,W#REC          @ TEMP RECORD AREA      (TARGET)\n         LR    R15,R8             RECLN\n         MVCL  R14,R0             K(J-1) TO TEMP AREA\n         LR    R0,R2              @ K(A)                  (SOURCE)\n         LR    R1,R8              RECLN\n         LR    R14,R4             @ K(J-1)                (TARGET)\n         LR    R15,R8             RECLN\n         MVCL  R14,R0             K(A) TO K(J-1)\n         LA    R0,W#REC           @ TEMP RECORD AREA      (SOURCE)\n         LR    R1,R8              RECLN\n         LR    R14,R2             @ K(A)                  (TARGET)\n         LR    R15,R8             RECLN\n         MVCL  R14,R0             K(J-1) TO K(A) FROM TEMP AREA\n* NOW SORT (A, J-2) AND (J, B)\n*          (R2, R4-R8) AND (R7, R5)\n*  (SOME MIGHT BE NULL - SORT SHORTEST FIRST, STACK OTHER)\n         SR    R4,R8              END ADDR OF GRP 1\n         LR    R0,R4\n         SR    R0,R2              LENGTH OF GRP 1\n         LR    R1,R5\n         SR    R1,R7              LENGTH OF GRP 2\n         CR    R0,R1              COMPARE GRP LENGTHS\n         BH    SORTGRP            BIF GRP 1 > GRP 2 (DO GRP 2 FIRST)\n         XR    R2,R7              SWAP GRP'S 1 AND 2\n         XR    R7,R2\n         XR    R2,R7\n         XR    R4,R5\n         XR    R5,R4\n         XR    R4,R5\n* STACK GROUP 1 TO BE SORTED LATER\nSORTGRP  C     R9,W#STKLM         ROOM FOR ANOTHER STACK ENTRY\n         BH    ERR2               BIF WORKAREA TOO SMALL\n         ST    R2,0(,R9)          @ 1ST RECORD IN GROUP\n         ST    R4,4(,R9)          @ LAST RECORD IN GROUP\n         LA    R9,8(,R9)          PUSH STACK\n* SET UP TO SORT GROUP 2 NOW\n         LR    R2,R7              @ 1ST REC IN GRP 2 (R5 ALREADY SET)\n         B     SORT\n         SPACE 1\n* REMOVE STACK ENTRY\nSORTUS   SH    R9,=H'8'\n         C     R9,W#STKPT\n         BL    SRTCK              BIF STACK EMPTY; DONE\n         L     R2,0(,R9)          @ 1ST RECORD OF GROUP\n         L     R5,4(,R9)            @ LAST RECORD IN GROUP\n         B     SORT\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*  SRTCK -- CHECK THAT RESULTS IS ACTUALLY SORTED.                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nSRTCK    L     R2,P#RECPT         @ 1ST RECORD\n         L     R5,W#RECLS         @ LAST RECORD\n         SR    R2,R8              @ RECORD - 1\nSRTCKL   AR    R2,R8              @ NEXT RECORD\n         LR    R1,R2\n         AR    R1,R8              @ NEXT RECORD (IF ANY)\n         CR    R1,R5              ANY NEXT RECORD?\n         BH    RET0               BIF NO NEXT; ALL DONE\n         LR    R15,R10            @ COMPARE ROUTINE\n         BALR  R14,R15            COMPARE TWO RECORDS; CHECK SEQ\n         BNL   SRTCKL             BIF NOT SEQ ERROR\n         EX    0,*      *** SORT LOGIC ERROR ***\n         SPACE 1\nRET0     SR    R15,R15            RETURN CODE ZERO\nRET      L     R13,4(,R13)\nRETX     L     R14,12(,R13)\n         LM    R0,R12,12+8(R13)\n         LTR   R15,R15\n         BR    R14\n         SPACE 1\nERR1     LA    R15,4              RETURN CODE 4; WRKAREA TOO SMALL\n         B     RETX\nERR2     LA    R15,4              RETURN CODE 4; WRKAREA TOO SMALL\n         B     RET\n         SPACE 1\n         DC    0D'0'\n         LTORG ,\n         OACREGS ,\n         END\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS5.MSSLOAD,UNIT=,SPACE=\n//LKED.SYSIN   DD *\n    ENTRY OACFSORT\n    IDENTIFY OACFSORT('CS01462')\n    NAME OACFSORT(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACGBLS": {"ttr": 7428, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x04\\x00\\x04\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "FILE149"}, "text": "         GBLA  &OACPRTS\n         GBLB  &OACPRTF\n         GBLC  &OACPRT,&OACPRTG,&OACSTMX,&OACSTER\n         GBLC  &OACNAME\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACINERR": {"ttr": 7430, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00.\\x00.\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&NAME    OACINERR &ADR\n         LCLC  &T,&R,&N\n.*\n.*   INNER MACRO TO GENERATE BRANCH BASED ON CONDITION CODE\n.*    (USED FOR ERROR KEYWORD ON OACCALL MACRO)\n.*   FORMAT OF SUB-OPERANDS IS:\n.*       OP1, OP2, OP3\n.*     OP1 - TARGET OF BRANCH (IF IN REGISTER NOTATION WILL GENERATE\n.*           A BRANCH REGISTER)\n.*     OP2 - CONDITION CODE FOR THE BRANCH.  THE DEFAULT IS NZ.\n.*           Z IS ALSO ALLOWED.\n.*     OP3 - REGISTER TO LTR R15 INTO (IF THIS OPERAND IS OMITTED\n.*       THEN THE CONDITION CODE IS ASSUMED ALREADY SET)\n.*\n.*\n.*\n.*\n&N       SETC  '&NAME'\n         AIF   ('&ADR' EQ '').END\n&T       SETC  '&ADR(2)'\n         AIF   ('&T' EQ '').SETDFL\n         AIF   ('&T' EQ 'Z' OR '&T' EQ 'NZ').TOK\n         MNOTE 4,'*** ERROR *** INVALID OPERAND  - NZ ASSUMED'\n.SETDFL  ANOP\n&T       SETC  'NZ'\n.TOK     AIF   ('&ADR(3)' EQ '').NLTR BIF CONDITION CODE ALREADY SET\n&R       SETC  '&ADR(3)'\n         AIF   ('&R'(1,1) NE '(').NPARN\n&R       SETC  '&R'(2,K'&R-2)   REMOVE PARENTHESIS\n.NPARN   ANOP\n&N       LTR   &ADR(3),R15      SET CONDITION CODE (SAVE RETURN CODE)\n&N       SETC  ''\n.NLTR    AIF   ('&ADR(1)'(1,1) EQ '(').REG\n         AIF   ('&T' EQ 'Z').AZ\n&N       BNZ   &ADR(1)          BRANCH ON NONZERO RETURN\n         MEXIT\n.AZ      ANOP\n&N       BZ    &ADR(1)          BRANCH IF RETURN CODE ZERO\n         MEXIT\n.REG     AIF   ('&T' EQ 'Z').RZ\n&N       BNZR  &ADR(1)          BRANCH ON NONZERO RETURN\n         MEXIT\n.RZ      ANOP\n&N       BZR   &ADR(1)          BRANCH IF RETURN CODE ZERO\n.END     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACINNE@": {"ttr": 7432, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x01\\xbd\\x01\\xbd\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 445, "newlines": 445, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&LABEL   OACINNER &DUMMY,&F=,&FO=+0,&T=,&TO=+0,&L=4,&OP=MA,            X\n               &SETCC=NO,&RS=R0,&RT=R15,&COM=''\n         GBLC  &OACNAME\n         LCLC  &S,&SRC,&SRC1,&SRCT\n         LCLB  &SRCI\n         LCLC  &G,&TGT,&TGT1,&TGTT\n         LCLB  &TGTI\n         LCLC  &C,&COMM,&ARGS,&OPR,&LEN\n         LCLA  &P\n         LCLB &CC\n         AIF   ('&F' EQ '').MEND\n&CC      SETB  ('&SETCC' EQ 'YES')\n&OACNAME SETC  '&LABEL'\n&LEN     SETC  '&L'\n&COMM    SETC  '&COM'(2,K'&COM-2) STRIP OFF QUOTES\n&G       SETC  '&T'\n.TGT     ANOP\n&C       SETC  '&G'(1,1)          GET FIRST CHAR OF SOURCE\n         AIF   ('&C' NE '(').TGTA MUST BE A FORM ADDRESS\n         AIF   (K'&G LT 5).TGTR   MUST BE R FORM ADDRESS\n&C       SETC  '&G'(K'&G-2,3)     GET LAST THREE CHARS\n         AIF   ('&C' NE ',I)').TGTR MUST BE R FORM ADDRESS\n&TGTI    SETB  1                  MARK AS INDIRECT\n&G       SETC  '&G'(2,K'&G-4)     EXTRACT ADDRESS\n         AGO   .TGT               GO PROCESS THAT\n.TGTR    ANOP                     ADDRESS IS R FORM\n         AIF   ('&TO' EQ '+0').TGTR1 CHECK FOR OFFSET\n         MNOTE 4,'ENCOUNTERED OFFSET FROM (R) FORM ADDRESS'\n         MNOTE 4,'WILL FORCE ADDRESS FORM'\n&G       SETC  '0&G'              FORCE ADDR FORM\n         AGO   .TGTA              IT IS ADDR FORM\n.TGTR1   AIF   (NOT &TGTI).TGTR2\n         MNOTE 4,'ENCOUNTERED INDIRECT FROM (R)'\n         MNOTE 4,'WILL FORCE INDIRECT FROM 0(R)'\n&G       SETC  '0&G'\n         AGO   .TGTA              DO ADDRESS SCAN\n.TGTR2   ANOP                     ITS REALLY (R) FORM\n&TGTT    SETC  'R'                MARK TYPE\n&TGT     SETC  '&G'(2,K'&G-2)     STRIP OFF PARENS\n         AGO   .TGTEND\n.TGTA    ANOP                     ADDRESS FORM\n&C       SETC  '&G'(K'&G,1)       LOOK AT LAST CHAR\n         AIF   ('&C' EQ ')').TGTAR IT IS A O(R) FORM ADDRESS\n&TGTT    SETC  'A'\n&TGT     SETC  '&G'\n         AIF   ('&TO' EQ '+0').TGTEND\n&TGT     SETC  '&G.&TO'\n         AGO   .TGTEND\n.TGTAR   ANOP                     ITS A 0(R) FORM ADDRESS\n&P       SETA  K'&G               SCAN FOR THE LEFT PAREN\n.TGTLP   AIF   (&P EQ 0).TGTSNTX\n&C       SETC  '&G'(&P,1)\n&P       SETA  &P-1\n         AIF   ('&C' NE '(').TGTLP\n&TGTT    SETC  'AR'\n&TGT1    SETC  '&G'(&P+2,K'&G-&P+1) SAVE REG AND RIGHT PAREN\n         AIF   ('&TO' NE '+0').TGTAR1\n&TGT     SETC  '&G'(1,&P+1)\n         AGO   .TGTEND\n.TGTAR1  ANOP  MUST ADD OFFSETS\n&TGT     SETC  '&G'(1,&P)\n&TGT     SETC  '&TGT.&TO.('\n         AGO   .TGTEND\n.TGTSNTX MNOTE 12,'ILLEGAL SYNTAX: &T'\n         MEXIT\n.TGTEND  ANOP\n&C       SETC  '&TGT  '(1,2)\n         AIF   ('&C' NE '0+').TGTEND1\n&TGT     SETC  '&TGT'(3,K'&TGT-2)\n.TGTEND1 ANOP\n&S       SETC  '&F'\n.SRC     ANOP\n&C       SETC  '&S'(1,1)          GET FIRST CHAR OF SOURCE\n         AIF   ('&C' NE '(').SRCA MUST BE A FORM ADDRESS\n         AIF   (K'&S LT 5).SRCR   MUST BE R FORM ADDRESS\n&C       SETC  '&S'(K'&S-2,3)     GET LAST THREE CHARS\n         AIF   ('&C' NE ',I)').SRCR MUST BE R FORM ADDRESS\n&SRCI    SETB  1                  MARK AS INDIRECT\n&S       SETC  '&S'(2,K'&S-4)     EXTRACT ADDRESS\n         AGO   .SRC               GO PROCESS THAT\n.SRCR    ANOP                     ADDRESS IS R FORM\n         AIF   ('&FO' EQ '+0').SRCR1 CHECK FOR OFFSET\n         MNOTE 4,'ENCOUNTERED OFFSET FROM (R) FORM ADDRESS'\n         MNOTE 4,'WILL FORCE ADDRESS FORM'\n&S       SETC  '0&S'              FORCE ADDR FORM\n         AGO   .SRCA              IT IS ADDR FORM\n.SRCR1   AIF   (NOT &SRCI).SRCR2\n         MNOTE 4,'ENCOUNTERED INDIRECT FROM (R)'\n         MNOTE 4,'WILL FORCE INDIRECT FROM 0(R)'\n&S       SETC  '0&S'\n         AGO   .SRCA              DO ADDRESS SCAN\n.SRCR2   ANOP                     ITS REALLY (R) FORM\n&SRCT    SETC  'R'                MARK TYPE\n&SRC     SETC  '&S'(2,K'&S-2)     STRIP OFF PARENS\n         AGO   .SRCEND\n.SRCA    ANOP                     ADDRESS FORM\n&C       SETC  '&S'(K'&S,1)       LOOK AT LAST CHAR\n         AIF   ('&C' EQ ')').SRCAR IT IS A O(R) FORM ADDRESS\n&SRCT    SETC  'A'\n&SRC     SETC  '&S'\n         AIF   ('&FO' EQ '+0').SRCEND\n&SRC     SETC  '&S.&FO'\n         AGO   .SRCEND\n.SRCAR   ANOP                     ITS A 0(R) FORM ADDRESS\n&P       SETA  K'&S               SCAN FOR THE LEFT PAREN\n.SRCLP   AIF   (&P EQ 0).SRCSNTX\n&C       SETC  '&S'(&P,1)\n&P       SETA  &P-1\n         AIF   ('&C' NE '(').SRCLP\n&SRCT    SETC  'A'\n&SRC1    SETC  '&S'(&P+2,K'&S-&P+1) SAVE REG AND RIGHT PAREN\n         AIF   ('&FO' NE '+0').SRCAR1\n&SRC     SETC  '&S'\n&SRC1    SETC  ''\n         AGO   .SRCEND\n.SRCAR1  ANOP  MUST ADD OFFSETS\n&SRC     SETC  '&S'(1,&P)\n&SRC     SETC  '&SRC.&FO.(&SRC1'\n&SRC1    SETC  ''\n         AGO   .SRCEND\n.SRCSNTX MNOTE 12,'ILLEGAL SYNTAX: &F'\n         MEXIT\n.SRCEND  ANOP\n&C       SETC  '&SRC  '(1,2)\n         AIF   ('&C' NE '0+').SRCEND1\n&SRC     SETC  '&SRC'(3,K'&SRC-2)\n.SRCEND1 AIF   (NOT &TGTI).SIN    CHECK FOR TARGET INDIRECT\n&ARGS    SETC  '&RT,&TGT.&TGT1'   BUILD OPERANDS AND COMMENT\n         AIF   (K'&ARGS GE 18).TI1\n&ARGS    SETC  '&ARGS                   '(1,18)\n.TI1     ANOP\n&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS\n         AIF   (K'&ARGS GT 55).TI2 CHECK FOR OVERFLOW\n&OACNAME L     &ARGS\n&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE\n         AGO   .TI3\n.TI2     ANOP                     NO ROOM FOR COMMENT\n&OACNAME L     &RT,&TGT.&TGT1\n.TI3     ANOP\n&OACNAME SETC  ''\n&TGT     SETC  '0('               NEW TARGET\n&TGT1    SETC  '&RT)'\n&TGTT    SETC  'AR'               NEW TARGET TYPE\n&TGTI    SETB  0\n.SIN     AIF   (NOT &SRCI).OP     CHECK FOR SOURCE INDARECT\n         AIF   ('&OP' EQ 'MA').SIMA SPECIAL CASE FOR MA, SRCI\n         AIF   ('&OP' NE 'MAC').SIN1 MAC MAY ALSO BE SPECIAL\n         AIF   ('&TGTT' EQ 'A' OR '&TGTT' EQ 'AR').SIMAC\n.SIN1    ANOP\n&ARGS    SETC  '&RS,&SRC'         BUILD OPERANDS AND COMMENT\n         AIF   (K'&ARGS GE 18).SIN2\n&ARGS    SETC  '&ARGS                   '(1,18)\n.SIN2    ANOP\n&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS\n         AIF   (K'&ARGS GT 55).SIN3 CHECK FOR OVERFLOW\n&OACNAME L     &ARGS\n&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE\n         AGO   .SIN4\n.SIN3    ANOP                     NO ROOM FOR COMMENT\n&OACNAME L     &RS,&SRC\n.SIN4    ANOP\n&OACNAME SETC  ''\n&SRC     SETC  '0(&RS)'           NEW SOURCE\n&SRCT    SETC  'A'                NEW SOURCE TYPE\n&SRCI    SETB  0\n         AGO   .OP\n.SIMA    ANOP\n&SRCI    SETB  0\n         AIF   ('&TGTT' EQ 'R').L GENERATE LOAD INSTRUCTION\n         AGO   .MVC               MA SRCI IS A MVC\n.SIMAC   ANOP                     MAC SRCI IS MVC AND MVI\n         AIF   ('&TGTT' EQ 'AR').SIMACAR\n&C       SETC  '&TGT.(4),&SRC'     A FORM TARGET\n         AGO   .SIMAC1\n.SIMACAR ANOP\n&C       SETC  '&TGT.4,&TGT1,&SRC' AR FROM TARGET\n.SIMAC1  ANOP\n&ARGS    SETC  '&C'               BUILD ARGS AND COMMENT\n         AIF   (K'&ARGS GE 18).SIMAC2\n&ARGS    SETC  '&ARGS                   '(1,18)\n.SIMAC2  ANOP\n&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS\n         AIF   (K'&ARGS GT 55).SIMAC3 CHECK FOR OVERFLOW\n&OACNAME MVC   &ARGS\n&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE\n         AGO   .SIMAC4\n.SIMAC3  ANOP                     NO ROOM FOR COMMENT\n&OACNAME MVC   &C\n.SIMAC4  ANOP\n&OACNAME SETC  ''\n         MVI   &TGT.&TGT1,0       CLEAR HIGH BYTE\n&SRC     SETC  '&TGT,&TGT1'\n         AIF   (&CC).OC\n         MEXIT\n.OP      ANOP\n&C       SETC  '&TGTT'(1,1)\n         AIF   ('&C' EQ 'R' AND '&SRCT' EQ 'R').OPRR   RR FORM INST\n         AIF   ('&C' EQ 'R' AND '&SRCT' EQ 'A').OPRA\n         AIF   ('&C' EQ 'A' AND '&SRCT' EQ 'R').OPAR\n         AIF   ('&OP' EQ 'MA').LAST AA FORM\n         AIF   ('&OP' EQ 'MAC').LAST LA ST\n         AIF   ('&OP' EQ 'M').MVC\n         AIF   ('&OP' EQ 'O').OC\n         AIF   ('&OP' EQ 'X').XC\n         AIF   ('&OP' EQ 'N').NC\n         AIF   ('&OP' EQ 'CL').CLC\n&LEN     SETC  '1'\n         AIF   ('&OP' EQ 'MVI').MVI\n         AIF   ('&OP' EQ 'OI').OI\n         AIF   ('&OP' EQ 'XI').XI\n         AIF   ('&OP' EQ 'NI').NI\n         AIF   ('&OP' EQ 'CLI').CLI\n         AIF   ('&OP' EQ 'TM').TM\n.BADOP   MNOTE 12,'&OP IS UNSUPORTED WITH SUPPLIED ARGS'\n         MEXIT\n.OPRR    AIF   ('&OP' EQ 'MA').LR\n         AIF   ('&OP' EQ 'MAC').LA\n         AIF   ('&LEN' EQ '4').OPRR1\n.RLENERR MNOTE 12,'INVALID LENGTH WITH R FORM ADDRESS'\n         MEXIT\n.OPRR1   AIF   ('&OP' EQ 'M').LR\n         AIF   ('&OP' EQ 'O').OR\n         AIF   ('&OP' EQ 'X').XR\n         AIF   ('&OP' EQ 'N').NR\n         AIF   ('&OP' EQ 'CL').CR\n         AGO   .BADOP\n.OPRA    AIF   ('&OP' EQ 'MA').LA\n         AIF   ('&OP' EQ 'MAC').LA\n         AIF   ('&OP' NE 'M').OPRA1\n         AIF   ('&LEN' EQ '1').IC\n         AIF   ('&LEN' EQ '2').LH\n         AIF   ('&LEN' EQ '4').L\n         AGO   .RLENERR\n.OPRA1   AIF   ('&LEN' EQ '4').OPRA4\n         AIF   ('&LEN' NE '2').RLENERR\n         AIF   ('&OP' EQ 'CL').CH\n         AGO   .BADOP\n.OPRA4   AIF   ('&OP' EQ 'O').O\n         AIF   ('&OP' EQ 'X').X\n         AIF   ('&OP' EQ 'N').N\n         AIF   ('&OP' EQ 'CL').C\n         AGO   .BADOP\n.OPAR    AIF   ('&OP' EQ 'MA').ST\n         AIF   ('&OP' EQ 'MAC').STMVI ST THEN MVI\n         AIF   ('&OP' NE 'M').BADOP\n         AIF   ('&LEN' EQ '1').STC\n         AIF   ('&LEN' EQ '2').STH\n         AIF   ('&LEN' EQ '4').ST\n         AGO   .RLENERR\n.LR      AIF   (&CC).LTR\n         AIF   ('&TGT.&TGT1' NE '&SRC').LR1\n         MEXIT\n.LR1     ANOP\n&OPR     SETC  'LR'\n         AGO   .RR\n.LTR     ANOP\n&OPR     SETC  'LTR'\n&CC      SETB  0\n         AGO   .RR\n.OR      ANOP\n&OPR     SETC  'OR'\n&CC      SETB  0\n         AGO   .RR\n.XR      ANOP\n&OPR     SETC  'XR'\n&CC      SETB  0\n         AGO   .RR\n.NR      ANOP\n&OPR     SETC  'NR'\n&CC      SETB  0\n         AGO   .RR\n.CR      ANOP\n&OPR     SETC  'CR'\n&CC      SETB  0\n         AGO   .RR\n.MVI     ANOP\n&OPR     SETC  'MVI'\n         AGO   .SI\n.NI      ANOP\n&OPR     SETC  'NI'\n&CC      SETB  0\n         AGO   .SI\n.OI      ANOP\n&OPR     SETC  'OI'\n&CC      SETB  0\n         AGO   .SI\n.XI      ANOP\n&OPR     SETC  'XI'\n&CC      SETB  0\n         AGO   .SI\n.CLI     ANOP\n&OPR     SETC  'CLI'\n&CC      SETB  0\n         AGO   .SI\n.TM      ANOP\n&OPR     SETC  'TM'\n&CC      SETB  0\n         AGO   .SI\n.IC      ANOP\n&OPR     SETC  'IC'\n         AGO   .SR\n.L       ANOP\n&OPR     SETC  'L'\n         AGO   .SR\n.LH      ANOP\n&OPR     SETC  'LH'\n         AGO   .SR\n.LA      ANOP\n&OPR     SETC  'LA'\n&CC      SETB  0\n&C       SETC  '&SRC'(1,2)\n         AIF   ('&C' NE '0(').SR\n         AIF   ('&OP' EQ 'MAC').SR\n&SRC     SETC  '&SRC'(3,K'&SRC-3)\n&SRCT    SETC  'R'\n         AGO   .LR\n.CH      ANOP\n&OPR     SETC  'CH'\n&CC      SETB  0\n         AGO   .SR\n.O       ANOP\n&OPR     SETC  'O'\n&CC      SETB  0\n         AGO   .SR\n.X       ANOP\n&OPR     SETC  'X'\n&CC      SETB  0\n         AGO   .SR\n.N       ANOP\n&OPR     SETC  'N'\n&CC      SETB  0\n         AGO   .SR\n.C       ANOP\n&OPR     SETC  'C'\n&CC      SETB  0\n         AGO   .SR\n.STC     ANOP\n&OPR     SETC  'STC'\n         AGO   .RS\n.STH     ANOP\n&OPR     SETC  'STH'\n         AGO   .RS\n.ST      ANOP\n&OPR     SETC  'ST'\n         AGO   .RS\n.MVC     ANOP\n&OPR     SETC  'MVC'\n         AGO   .SS\n.OC      ANOP\n&OPR     SETC  'OC'\n&CC      SETB  0\n         AGO   .SS\n.XC      ANOP\n&OPR     SETC  'XC'\n&CC      SETB  0\n         AGO   .SS\n.NC      ANOP\n&OPR     SETC  'NC'\n&CC      SETB  0\n         AGO   .SS\n.CLC     ANOP\n&OPR     SETC  'CLC'\n&CC      SETB  0\n         AGO   .SS\n.SI      ANOP\n.RR      ANOP\n.SR      ANOP\n&ARGS    SETC  '&TGT.&TGT1,&SRC'\n         AGO   .INSTGEN\n.RS      ANOP\n&ARGS    SETC  '&SRC,&TGT.&TGT1'\n         AGO   .INSTGEN\n.SS      AIF   ('&TGTT' EQ 'AR').SSAR\n&ARGS    SETC  '&TGT.(&LEN),&SRC'\n         AGO   .INSTGEN\n.SSAR    ANOP\n&ARGS    SETC  '&TGT.&LEN,&TGT1,&SRC'\n.INSTGEN ANOP\n&C       SETC  '&ARGS'            BUILD OPERANDS AND COMMENT\n         AIF   (K'&C GE 18).INSTGN1\n&C       SETC  '&C                   '(1,18)\n.INSTGN1 ANOP\n&C       SETC  '&C &COMM'         TACK ON THE COMMENTS\n         AIF   (K'&C GT 55).INSTGN2 CHECK FOR OVERFLOW\n&OACNAME &OPR  &C\n&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE\n         AGO   .INSTGN3\n.INSTGN2 ANOP                     NO ROOM FOR COMMENT\n&OACNAME &OPR  &ARGS\n.INSTGN3 ANOP\n&OACNAME SETC  ''\n         AIF   (&CC).INSTGN4      CHECK FOR SET CONDITION CODE\n         MEXIT\n.INSTGN4 AIF   ('&TGTT' EQ 'R').INSTGNR\n&ARGS    SETC  '&ARGS'(1,K'&ARGS-K'&SRC) STRIP OFF OLD SRC\n         CLC   &ARGS.&TGT.&TGT1\n         MEXIT\n.INSTGNR ANOP\n         LTR   &TGT,&TGT\n         MEXIT\n.LAST    AIF   ('&OP' EQ 'MAC').LAST0\n&C       SETC  '&SRC'(1,2)\n         AIF   ('&C' NE '0(').LAST0\n&SRC     SETC  '&SRC'(3,K'&SRC-3)\n&SRCT    SETC  'R'\n         AGO   .ST\n.LAST0   ANOP\n&ARGS    SETC  '&RS,&SRC'         BUILD OPERANDS AND COMMENT\n         AIF   (K'&ARGS GE 18).LAST1\n&ARGS    SETC  '&ARGS                   '(1,18)\n.LAST1   ANOP\n&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS\n         AIF   (K'&ARGS GT 55).LAST2 CHECK FOR OVERFLOW\n&OACNAME LA    &ARGS\n&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE\n         AGO   .LAST3\n.LAST2   ANOP                     NO ROOM FOR COMMENT\n&OACNAME LA    &RS,&SRC\n.LAST3   ANOP\n&OACNAME SETC  ''\n         ST    &RS,&TGT.&TGT1\n         MEXIT\n.STMVI   ANOP\n&ARGS    SETC  '&SRC,&TGT.&TGT1'  BUILD OPERANDS AND COMMENT\n         AIF   (K'&ARGS GE 18).STMVI1\n&ARGS    SETC  '&ARGS                   '(1,18)\n.STMVI1  ANOP\n&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS\n         AIF   (K'&ARGS GT 55).STMVI2 CHECK FOR OVERFLOW\n&OACNAME ST    &ARGS\n&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE\n         AGO   .STMVI3\n.STMVI2  ANOP                     NO ROOM FOR COMMENT\n&OACNAME ST    &SRC,&TGT.&TGT1\n.STMVI3  ANOP\n&OACNAME SETC  ''\n         MVI   &TGT.&TGT1,0       CLEAR HIGH BYTE\n         MEXIT\n         AIF   (NOT &CC).MEND\n&SRC     SETC  '&TGT.&TGT1'\n&SRCT    SETC  'A'\n&LEN     SETC  '4'\n         AGO   .CLC\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACINNER": {"ttr": 7683, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x01\\xbf\\x01\\xbf\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 447, "newlines": 447, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&LABEL   OACINNER &DUMMY,&F=,&FO=+0,&T=,&TO=+0,&L=4,&OP=MA,            X\n               &SETCC=NO,&RS=R0,&RT=R15,&COM=''\n         GBLC  &OACNAME\n         LCLC  &S,&SRC,&SRC1,&SRCT\n         LCLB  &SRCI\n         LCLC  &G,&TGT,&TGT1,&TGTT\n         LCLB  &TGTI\n         LCLC  &C,&COMM,&ARGS,&OPR,&LEN\n         LCLA  &P\n         LCLB &CC\n         AIF   ('&F' EQ '').MEND\n&CC      SETB  ('&SETCC' EQ 'YES')\n&OACNAME SETC  '&LABEL'\n&LEN     SETC  '&L'\n&COMM    SETC  '&COM'(2,K'&COM-2) STRIP OFF QUOTES\n&G       SETC  '&T'\n.TGT     ANOP\n&C       SETC  '&G'(1,1)          GET FIRST CHAR OF SOURCE\n         AIF   ('&C' NE '(').TGTA MUST BE A FORM ADDRESS\n         AIF   (K'&G LT 5).TGTR   MUST BE R FORM ADDRESS\n&C       SETC  '&G'(K'&G-2,3)     GET LAST THREE CHARS\n         AIF   ('&C' NE ',I)').TGTR MUST BE R FORM ADDRESS\n&TGTI    SETB  1                  MARK AS INDIRECT\n&G       SETC  '&G'(2,K'&G-4)     EXTRACT ADDRESS\n         AGO   .TGT               GO PROCESS THAT\n.TGTR    ANOP                     ADDRESS IS R FORM\n         AIF   ('&TO' EQ '+0').TGTR1 CHECK FOR OFFSET\n         MNOTE 4,'ENCOUNTERED OFFSET FROM (R) FORM ADDRESS'\n         MNOTE 4,'WILL FORCE ADDRESS FORM'\n&G       SETC  '0&G'              FORCE ADDR FORM\n         AGO   .TGTA              IT IS ADDR FORM\n.TGTR1   AIF   (NOT &TGTI).TGTR2\n         MNOTE 4,'ENCOUNTERED INDIRECT FROM (R)'\n         MNOTE 4,'WILL FORCE INDIRECT FROM 0(R)'\n&G       SETC  '0&G'\n         AGO   .TGTA              DO ADDRESS SCAN\n.TGTR2   ANOP                     ITS REALLY (R) FORM\n&TGTT    SETC  'R'                MARK TYPE\n&TGT     SETC  '&G'(2,K'&G-2)     STRIP OFF PARENS\n         AGO   .TGTEND\n.TGTA    ANOP                     ADDRESS FORM\n&C       SETC  '&G'(K'&G,1)       LOOK AT LAST CHAR\n         AIF   ('&C' EQ ')').TGTAR IT IS A O(R) FORM ADDRESS\n&TGTT    SETC  'A'\n&TGT     SETC  '&G'\n         AIF   ('&TO' EQ '+0').TGTEND\n&TGT     SETC  '&G.&TO'\n         AGO   .TGTEND\n.TGTAR   ANOP                     ITS A 0(R) FORM ADDRESS\n&P       SETA  K'&G               SCAN FOR THE LEFT PAREN\n.TGTLP   AIF   (&P EQ 0).TGTSNTX\n&C       SETC  '&G'(&P,1)\n&P       SETA  &P-1\n         AIF   ('&C' NE '(').TGTLP\n&TGTT    SETC  'AR'\n&TGT1    SETC  '&G'(&P+2,K'&G-&P+1) SAVE REG AND RIGHT PAREN\n         AIF   ('&TO' NE '+0').TGTAR1\n&TGT     SETC  '&G'(1,&P+1)\n         AGO   .TGTEND\n.TGTAR1  ANOP  MUST ADD OFFSETS\n&TGT     SETC  '&G'(1,&P)\n&TGT     SETC  '&TGT.&TO.('\n         AGO   .TGTEND\n.TGTSNTX MNOTE 12,'ILLEGAL SYNTAX: &T'\n         MEXIT\n.TGTEND  ANOP\n&C       SETC  '&TGT  '(1,2)\n         AIF   ('&C' NE '0+').TGTEND1\n&TGT     SETC  '&TGT'(3,K'&TGT-2)\n.TGTEND1 ANOP\n&S       SETC  '&F'\n.SRC     ANOP\n&C       SETC  '&S'(1,1)          GET FIRST CHAR OF SOURCE\n         AIF   ('&C' NE '(').SRCA MUST BE A FORM ADDRESS\n         AIF   (K'&S LT 5).SRCR   MUST BE R FORM ADDRESS\n&C       SETC  '&S'(K'&S-2,3)     GET LAST THREE CHARS\n         AIF   ('&C' NE ',I)').SRCR MUST BE R FORM ADDRESS\n&SRCI    SETB  1                  MARK AS INDIRECT\n&S       SETC  '&S'(2,K'&S-4)     EXTRACT ADDRESS\n         AGO   .SRC               GO PROCESS THAT\n.SRCR    ANOP                     ADDRESS IS R FORM\n         AIF   ('&FO' EQ '+0').SRCR1 CHECK FOR OFFSET\n         MNOTE 4,'ENCOUNTERED OFFSET FROM (R) FORM ADDRESS'\n         MNOTE 4,'WILL FORCE ADDRESS FORM'\n&S       SETC  '0&S'              FORCE ADDR FORM\n         AGO   .SRCA              IT IS ADDR FORM\n.SRCR1   AIF   (NOT &SRCI).SRCR2\n         MNOTE 4,'ENCOUNTERED INDIRECT FROM (R)'\n         MNOTE 4,'WILL FORCE INDIRECT FROM 0(R)'\n&S       SETC  '0&S'\n         AGO   .SRCA              DO ADDRESS SCAN\n.SRCR2   ANOP                     ITS REALLY (R) FORM\n&SRCT    SETC  'R'                MARK TYPE\n&SRC     SETC  '&S'(2,K'&S-2)     STRIP OFF PARENS\n         AGO   .SRCEND\n.SRCA    ANOP                     ADDRESS FORM\n&C       SETC  '&S'(K'&S,1)       LOOK AT LAST CHAR\n         AIF   ('&C' EQ ')').SRCAR IT IS A O(R) FORM ADDRESS\n&SRCT    SETC  'A'\n&SRC     SETC  '&S'\n         AIF   ('&FO' EQ '+0').SRCEND\n&SRC     SETC  '&S.&FO'\n         AGO   .SRCEND\n.SRCAR   ANOP                     ITS A 0(R) FORM ADDRESS\n&P       SETA  K'&S               SCAN FOR THE LEFT PAREN\n.SRCLP   AIF   (&P EQ 0).SRCSNTX\n&C       SETC  '&S'(&P,1)\n&P       SETA  &P-1\n         AIF   ('&C' NE '(').SRCLP\n&SRCT    SETC  'A'\n&SRC1    SETC  '&S'(&P+2,K'&S-&P+1) SAVE REG AND RIGHT PAREN\n         AIF   ('&FO' NE '+0').SRCAR1\n&SRC     SETC  '&S'\n&SRC1    SETC  ''\n         AGO   .SRCEND\n.SRCAR1  ANOP  MUST ADD OFFSETS\n&SRC     SETC  '&S'(1,&P)\n&SRC     SETC  '&SRC.&FO.(&SRC1'\n&SRC1    SETC  ''\n         AGO   .SRCEND\n.SRCSNTX MNOTE 12,'ILLEGAL SYNTAX: &F'\n         MEXIT\n.SRCEND  ANOP\n&C       SETC  '&SRC  '(1,2)\n         AIF   ('&C' NE '0+').SRCEND1\n&SRC     SETC  '&SRC'(3,K'&SRC-2)\n.SRCEND1 AIF   (NOT &TGTI).SIN    CHECK FOR TARGET INDIRECT\n&ARGS    SETC  '&RT,&TGT.&TGT1'   BUILD OPERANDS AND COMMENT\n         AIF   (K'&ARGS GE 18).TI1\n&ARGS    SETC  '&ARGS                   '(1,18)\n.TI1     ANOP\n&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS\n         AIF   (K'&ARGS GT 55).TI2 CHECK FOR OVERFLOW\n&OACNAME L     &ARGS\n&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE\n         AGO   .TI3\n.TI2     ANOP                     NO ROOM FOR COMMENT\n&OACNAME L     &RT,&TGT.&TGT1\n.TI3     ANOP\n&OACNAME SETC  ''\n&TGT     SETC  '0('               NEW TARGET\n&TGT1    SETC  '&RT)'\n&TGTT    SETC  'AR'               NEW TARGET TYPE\n&TGTI    SETB  0\n.SIN     AIF   (NOT &SRCI).OP     CHECK FOR SOURCE INDARECT\n         AIF   ('&OP' EQ 'MA').SIMA SPECIAL CASE FOR MA, SRCI\n         AIF   ('&OP' NE 'MAC').SIN1 MAC MAY ALSO BE SPECIAL\n         AIF   ('&TGTT' EQ 'A' OR '&TGTT' EQ 'AR').SIMAC\n.SIN1    ANOP\n&ARGS    SETC  '&RS,&SRC'         BUILD OPERANDS AND COMMENT\n         AIF   (K'&ARGS GE 18).SIN2\n&ARGS    SETC  '&ARGS                   '(1,18)\n.SIN2    ANOP\n&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS\n         AIF   (K'&ARGS GT 55).SIN3 CHECK FOR OVERFLOW\n&OACNAME L     &ARGS\n&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE\n         AGO   .SIN4\n.SIN3    ANOP                     NO ROOM FOR COMMENT\n&OACNAME L     &RS,&SRC\n.SIN4    ANOP\n&OACNAME SETC  ''\n&SRC     SETC  '0(&RS)'           NEW SOURCE\n&SRCT    SETC  'A'                NEW SOURCE TYPE\n&SRCI    SETB  0\n         AGO   .OP\n.SIMA    ANOP\n&SRCI    SETB  0\n         AIF   ('&TGTT' EQ 'R').L GENERATE LOAD INSTRUCTION\n         AGO   .MVC               MA SRCI IS A MVC\n.SIMAC   ANOP                     MAC SRCI IS MVC AND MVI\n         AIF   ('&TGTT' EQ 'AR').SIMACAR\n&C       SETC  '&TGT.(4),&SRC'     A FORM TARGET\n         AGO   .SIMAC1\n.SIMACAR ANOP\n&C       SETC  '&TGT.4,&TGT1,&SRC' AR FROM TARGET\n.SIMAC1  ANOP\n&ARGS    SETC  '&C'               BUILD ARGS AND COMMENT\n         AIF   (K'&ARGS GE 18).SIMAC2\n&ARGS    SETC  '&ARGS                   '(1,18)\n.SIMAC2  ANOP\n&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS\n         AIF   (K'&ARGS GT 55).SIMAC3 CHECK FOR OVERFLOW\n&OACNAME MVC   &ARGS\n&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE\n         AGO   .SIMAC4\n.SIMAC3  ANOP                     NO ROOM FOR COMMENT\n&OACNAME MVC   &C\n.SIMAC4  ANOP\n&OACNAME SETC  ''\n         MVI   &TGT.&TGT1,0       CLEAR HIGH BYTE\n&SRC     SETC  '&TGT,&TGT1'\n         AIF   (&CC).OC\n         MEXIT\n.OP      ANOP\n&C       SETC  '&TGTT'(1,1)\n         AIF   ('&C' EQ 'R' AND '&SRCT' EQ 'R').OPRR   RR FORM INST\n         AIF   ('&C' EQ 'R' AND '&SRCT' EQ 'A').OPRA\n         AIF   ('&C' EQ 'A' AND '&SRCT' EQ 'R').OPAR\n         AIF   ('&OP' EQ 'MA').LAST AA FORM\n         AIF   ('&OP' EQ 'MAC').LAST LA ST\n         AIF   ('&OP' EQ 'M').MVC\n         AIF   ('&OP' EQ 'O').OC\n         AIF   ('&OP' EQ 'X').XC\n         AIF   ('&OP' EQ 'N').NC\n         AIF   ('&OP' EQ 'CL').CLC\n&LEN     SETC  '1'\n         AIF   ('&OP' EQ 'MVI').MVI\n         AIF   ('&OP' EQ 'OI').OI\n         AIF   ('&OP' EQ 'XI').XI\n         AIF   ('&OP' EQ 'NI').NI\n         AIF   ('&OP' EQ 'CLI').CLI\n         AIF   ('&OP' EQ 'TM').TM\n.BADOP   MNOTE 12,'&OP IS UNSUPORTED WITH SUPPLIED ARGS'\n         MEXIT\n.OPRR    AIF   ('&OP' EQ 'MA').LR\n         AIF   ('&OP' EQ 'MAC').LA\n         AIF   ('&LEN' EQ '4').OPRR1\n.RLENERR MNOTE 12,'INVALID LENGTH WITH R FORM ADDRESS'\n         MEXIT\n.OPRR1   AIF   ('&OP' EQ 'M').LR\n         AIF   ('&OP' EQ 'O').OR\n         AIF   ('&OP' EQ 'X').XR\n         AIF   ('&OP' EQ 'N').NR\n         AIF   ('&OP' EQ 'CL').CR\n         AGO   .BADOP\n.OPRA    AIF   ('&OP' EQ 'MA').LA\n         AIF   ('&OP' EQ 'MAC').LA\n         AIF   ('&OP' NE 'M').OPRA1\n         AIF   ('&LEN' EQ '1').IC\n         AIF   ('&LEN' EQ '2').LH\n         AIF   ('&LEN' EQ '4').L\n         AGO   .RLENERR\n.OPRA1   AIF   ('&LEN' EQ '4').OPRA4\n         AIF   ('&LEN' NE '2').RLENERR\n         AIF   ('&OP' EQ 'CL').CH\n         AGO   .BADOP\n.OPRA4   AIF   ('&OP' EQ 'O').O\n         AIF   ('&OP' EQ 'X').X\n         AIF   ('&OP' EQ 'N').N\n         AIF   ('&OP' EQ 'CL').C\n         AGO   .BADOP\n.OPAR    AIF   ('&OP' EQ 'MA').ST\n         AIF   ('&OP' EQ 'MAC').STMVI ST THEN MVI\n         AIF   ('&OP' NE 'M').BADOP\n         AIF   ('&LEN' EQ '1').STC\n         AIF   ('&LEN' EQ '2').STH\n         AIF   ('&LEN' EQ '4').ST\n         AGO   .RLENERR\n.LR      AIF   (&CC).LTR\n         AIF   ('&TGT.&TGT1' NE '&SRC').LR1\n         AIF   ('&OACNAME' EQ '').LR0\n&OACNAME DC    0H'0'\n         MEXIT\n.LR1     ANOP\n&OPR     SETC  'LR'\n         AGO   .RR\n.LTR     ANOP\n&OPR     SETC  'LTR'\n&CC      SETB  0\n         AGO   .RR\n.OR      ANOP\n&OPR     SETC  'OR'\n&CC      SETB  0\n         AGO   .RR\n.XR      ANOP\n&OPR     SETC  'XR'\n&CC      SETB  0\n         AGO   .RR\n.NR      ANOP\n&OPR     SETC  'NR'\n&CC      SETB  0\n         AGO   .RR\n.CR      ANOP\n&OPR     SETC  'CR'\n&CC      SETB  0\n         AGO   .RR\n.MVI     ANOP\n&OPR     SETC  'MVI'\n         AGO   .SI\n.NI      ANOP\n&OPR     SETC  'NI'\n&CC      SETB  0\n         AGO   .SI\n.OI      ANOP\n&OPR     SETC  'OI'\n&CC      SETB  0\n         AGO   .SI\n.XI      ANOP\n&OPR     SETC  'XI'\n&CC      SETB  0\n         AGO   .SI\n.CLI     ANOP\n&OPR     SETC  'CLI'\n&CC      SETB  0\n         AGO   .SI\n.TM      ANOP\n&OPR     SETC  'TM'\n&CC      SETB  0\n         AGO   .SI\n.IC      ANOP\n&OPR     SETC  'IC'\n         AGO   .SR\n.L       ANOP\n&OPR     SETC  'L'\n         AGO   .SR\n.LH      ANOP\n&OPR     SETC  'LH'\n         AGO   .SR\n.LA      ANOP\n&OPR     SETC  'LA'\n&CC      SETB  0\n&C       SETC  '&SRC'(1,2)\n         AIF   ('&C' NE '0(').SR\n         AIF   ('&OP' EQ 'MAC').SR\n&SRC     SETC  '&SRC'(3,K'&SRC-3)\n&SRCT    SETC  'R'\n         AGO   .LR\n.CH      ANOP\n&OPR     SETC  'CH'\n&CC      SETB  0\n         AGO   .SR\n.O       ANOP\n&OPR     SETC  'O'\n&CC      SETB  0\n         AGO   .SR\n.X       ANOP\n&OPR     SETC  'X'\n&CC      SETB  0\n         AGO   .SR\n.N       ANOP\n&OPR     SETC  'N'\n&CC      SETB  0\n         AGO   .SR\n.C       ANOP\n&OPR     SETC  'C'\n&CC      SETB  0\n         AGO   .SR\n.STC     ANOP\n&OPR     SETC  'STC'\n         AGO   .RS\n.STH     ANOP\n&OPR     SETC  'STH'\n         AGO   .RS\n.ST      ANOP\n&OPR     SETC  'ST'\n         AGO   .RS\n.MVC     ANOP\n&OPR     SETC  'MVC'\n         AGO   .SS\n.OC      ANOP\n&OPR     SETC  'OC'\n&CC      SETB  0\n         AGO   .SS\n.XC      ANOP\n&OPR     SETC  'XC'\n&CC      SETB  0\n         AGO   .SS\n.NC      ANOP\n&OPR     SETC  'NC'\n&CC      SETB  0\n         AGO   .SS\n.CLC     ANOP\n&OPR     SETC  'CLC'\n&CC      SETB  0\n         AGO   .SS\n.SI      ANOP\n.RR      ANOP\n.SR      ANOP\n&ARGS    SETC  '&TGT.&TGT1,&SRC'\n         AGO   .INSTGEN\n.RS      ANOP\n&ARGS    SETC  '&SRC,&TGT.&TGT1'\n         AGO   .INSTGEN\n.SS      AIF   ('&TGTT' EQ 'AR').SSAR\n&ARGS    SETC  '&TGT.(&LEN),&SRC'\n         AGO   .INSTGEN\n.SSAR    ANOP\n&ARGS    SETC  '&TGT.&LEN,&TGT1,&SRC'\n.INSTGEN ANOP\n&C       SETC  '&ARGS'            BUILD OPERANDS AND COMMENT\n         AIF   (K'&C GE 18).INSTGN1\n&C       SETC  '&C                   '(1,18)\n.INSTGN1 ANOP\n&C       SETC  '&C &COMM'         TACK ON THE COMMENTS\n         AIF   (K'&C GT 55).INSTGN2 CHECK FOR OVERFLOW\n&OACNAME &OPR  &C\n&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE\n         AGO   .INSTGN3\n.INSTGN2 ANOP                     NO ROOM FOR COMMENT\n&OACNAME &OPR  &ARGS\n.INSTGN3 ANOP\n&OACNAME SETC  ''\n         AIF   (&CC).INSTGN4      CHECK FOR SET CONDITION CODE\n         MEXIT\n.INSTGN4 AIF   ('&TGTT' EQ 'R').INSTGNR\n&ARGS    SETC  '&ARGS'(1,K'&ARGS-K'&SRC) STRIP OFF OLD SRC\n         CLC   &ARGS.&TGT.&TGT1\n         MEXIT\n.INSTGNR ANOP\n         LTR   &TGT,&TGT\n         MEXIT\n.LAST    AIF   ('&OP' EQ 'MAC').LAST0\n&C       SETC  '&SRC'(1,2)\n         AIF   ('&C' NE '0(').LAST0\n&SRC     SETC  '&SRC'(3,K'&SRC-3)\n&SRCT    SETC  'R'\n         AGO   .ST\n.LAST0   ANOP\n&ARGS    SETC  '&RS,&SRC'         BUILD OPERANDS AND COMMENT\n         AIF   (K'&ARGS GE 18).LAST1\n&ARGS    SETC  '&ARGS                   '(1,18)\n.LAST1   ANOP\n&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS\n         AIF   (K'&ARGS GT 55).LAST2 CHECK FOR OVERFLOW\n&OACNAME LA    &ARGS\n&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE\n         AGO   .LAST3\n.LAST2   ANOP                     NO ROOM FOR COMMENT\n&OACNAME LA    &RS,&SRC\n.LAST3   ANOP\n&OACNAME SETC  ''\n         ST    &RS,&TGT.&TGT1\n         MEXIT\n.STMVI   ANOP\n&ARGS    SETC  '&SRC,&TGT.&TGT1'  BUILD OPERANDS AND COMMENT\n         AIF   (K'&ARGS GE 18).STMVI1\n&ARGS    SETC  '&ARGS                   '(1,18)\n.STMVI1  ANOP\n&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS\n         AIF   (K'&ARGS GT 55).STMVI2 CHECK FOR OVERFLOW\n&OACNAME ST    &ARGS\n&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE\n         AGO   .STMVI3\n.STMVI2  ANOP                     NO ROOM FOR COMMENT\n&OACNAME ST    &SRC,&TGT.&TGT1\n.STMVI3  ANOP\n&OACNAME SETC  ''\n         MVI   &TGT.&TGT1,0       CLEAR HIGH BYTE\n         MEXIT\n         AIF   (NOT &CC).MEND\n&SRC     SETC  '&TGT.&TGT1'\n&SRCT    SETC  'A'\n&LEN     SETC  '4'\n         AGO   .CLC\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACINNRB": {"ttr": 7691, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x8c\\x00\\x8c\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 140, "newlines": 140, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n         OACINNRB &C,&TB,&TO,&TL,&S,&WX=R0\n.*  OAC INNER MACRO FOR MF=B (AND E) PARAMETERS\n.* &C    - TYPE OF TARGET\n.*         A   - ADDRESS (PLACE ADDRESS AT TARGET)\n.*         V   - VALUE   (PLACE VALUE AT TARGET)\n.*         NI  - BIT     (CHANGE BITS IN BYTE OF FLAGS)\n.*         OI  - BIT\n.*         XI  - BIT\n.*         MVI - BIT\n.*         TM  - BIT\n.* &TB   - TARGET BASE (CAN BE REGISTER OR NULL)\n.* &TO   - TARGET OFFSET (NULL IF 0)\n.* &TL   - LENGTH OF TARGET (IN BYTES)\n.* &S    - SOURCE\n.* &WX   - WORK REGISTER IF REQUIRED\n         GBLC  &OACNAME           NAME FIELD ON ORIG MACRO GLOBAL\n.*\n         LCLB  &TR                TARGET IS REGISTER\n         LCLC  &TX                REGISTER OF TARGET\n         LCLB  &TBR               TARGET BASE IS REGISTER\n         LCLC  &TBX               REGISTER OF TARGET BASE\n         LCLC  &TP                '+' FOR TARGET OFFSET\n         LCLB  &SR                SOURCE IS REG\n         LCLC  &SX                REGISTER OF SOURCE\n         LCLC  &OP                GENERATED OP CODES\n         LCLC  &SREG              SOURCE REGISTER\n.*\n.*  SET COMMON VARIABLE SYMBOLS (FOR TARGET)\n         AIF   ('&TB' EQ '').NOTB BIF NO TARGET BASE\n         AIF   ('&TB'(1,1) NE '(').NOTB BIF TARGET NOT BASED ON REG\n&TBR     SETB  1                  TARGET IS BASED ON REGISTER\n&TBX     SETC  '&TB'(2,K'&TB-2)   REGISTER OF TARGET BASE\n.NOTB    ANOP\n&OP      SETC  '&C'               DEFAULT GENERATED OPCODE\n&TX      SETC  '&WX'              USE WORK REG IF TARGET NOT REGISTER\n         AIF   ('&TO' EQ '').NOTO BIF TARGET OFFSET NULL\n&TP      SETC  '+'                MAY NEED PLUS FOR OFFSET ADD\n&TR      SETB  ('&TO'(1,1) EQ '(') TARGET IS REGISTER\n         AIF   (NOT &TR).NOTO     BIF TARGET NOT REGISTER\n&TX      SETC  '&TO'(2,K'&TO-2)   REGISTER OF TARGET\n.*\n.*  SET COMMON VARIABLE SYMBOLS (FOR SOURCE)\n.NOTO    AIF   ('&S' EQ '').NOS   BIF NO SOURCE\n&SR      SETB  ('&S'(1,1) EQ '(') SOURCE IS REGISTER\n         AIF   (NOT &SR).NOS      BIF SOURCE NOT REGISTER\n&SX      SETC  '&S'(2,K'&S-2)     REGISTER OF SOURCE\n         AIF   (&TR).NOS          BIF TARGET IN REGISTER\n&TX      SETC  '&SX'              USE SOURCE REG IF TARGET NOT IN REG\n.*\n.*   DECIDE CALL TYPE\n.NOS     AIF   ('&C' NE 'A').CV   BIF NOT A CALL (ADDRESS)\n.*\n.*   ADDRESS TYPE\n.CA      AIF   ('&S' EQ '').DONE  BIF SOURCE NULL\n         AIF   (NOT &SR).CANR     BIF SOURCE NOT IN REGISTER\n         AIF   (NOT &TR).CASTOR2  BIF TARGET \u00acREG AND SOURCE IS REG\n.CARR    AIF   ('&SX' EQ '&TX').DONE BIF SOURCE AND TARGET SAME\n&OACNAME LR    &TX,&SX\n         AGO   .DONEL\n.CANR    AIF   ('&S' NE '0').CAN0 BIF SOURCE NOT ZERO\n&OACNAME SR    &TX,&TX\n         AGO   .CAN0GO\n.CAN0    ANOP\n&OACNAME LA    &TX,&S\n.CAN0GO  ANOP\n&OACNAME SETC  ''\n.CASTORE AIF   (&TR).DONE         BIF TARGET IN REQUIRED REG\n.CASTOR2 AIF   (&TL EQ 4).CAST4   BIF LENGTH 4\n         AIF   (&TL EQ 2).CAST2   BIF LENGTH 2\n         AIF   (&TL EQ 1).CAST1   BIF LENGTH 2\n         MNOTE 8,'(OACINNRB) - INVALID LENGTH &TL - &S'\n         MEXIT\n.CAST4   ANOP\n&OP      SETC  'ST'\n         AGO   .CASTIT\n.CAST2   ANOP\n&OP      SETC  'STH'\n         AGO   .CASTIT\n.CAST1   ANOP\n&OP      SETC  'STC'\n         AGO   .CASTIT\n.CASTIT  AIF   (&TBR).CATBR       BIF TARGET BASED ON REGISTER\n&OACNAME &OP   &TX,&TB&TP&TO\n         AGO   .DONEL\n.CATBR   ANOP\n&OACNAME &OP   &TX,&TO.(,&TBX)\n         AGO   .DONEL\n.*\n.*   VALUE TYPE (IF SOURCE IN REGISTER SAME AS ADDRESS TYPE)\n.CV      AIF   ('&C' NE 'V').CB\n         AIF   ('&S' EQ '').DONE  BIF SOURCE NULL\n         AIF   (&SR).CA           BIF SOURCE IN REGISTER\n         AIF   ('&S'(1,1) EQ '=').CVLIT BIF LITERAL\n         AIF   (T'&S NE 'N').CA   BIF NOT SELF DEFINING TERM, DO LA\n         AIF   (&S EQ 0 AND NOT &TR).CVXC BIF ZERO AND TARGET STORAGE\n         AIF   (&TL EQ 1).CVMVI\n         AIF   (&S GE 0 AND &S LT 4096).CA BIF LA WILL WORK\n&OACNAME L     &TX,=F'&S'\n&OACNAME SETC  ''\n         AGO   .CASTORE           GO STORE VALUE\n.CVMVI   AIF   (&S GE 0 AND &S LE 255).CVMVIX\n         MNOTE 8,'(OACINNRB) - NOT ONE BYTE VALUE &S'\n.CVMVIX  ANOP\n&OP      SETC  'MVI'              WILL GENERATE MVI\n         AGO   .CBINT             GO GENERATE MVI\n.CVLIT   AIF   (NOT &TR).CVSS     BIF STORAGE STORAGE, DO MVC / XC\n&OACNAME L     &TX,&S\n&OACNAME SETC  ''\n         AGO   .CASTORE           GO STORE VALUE\n.CVSS    AIF   (&TBR).CVSSBR      BIF TARGET BASED\n&OACNAME MVC   &TB&TP&TO.(&TL),&S\n         AGO   .DONEL\n.CVSSBR  MVC   &TO.(&TL,&TBX),&S\n         AGO   .DONEL\n.CVXC    AIF   (&TBR).CVXCBR      BIF TARGET BASED\n&OACNAME XC    &TB&TP&TO.(&TL),&TB&TP&TO\n         AGO   .DONEL\n.CVXCBR  XC    &TO.(&TL,&TBX),&TO.(&TBX)\n         AGO   .DONEL\n.*\n.*    BIT TYPE\n.CB      AIF   ('&C' NE 'OI' AND '&C' NE 'NI' AND '&C' NE 'MVI' AND    X\n               '&C' NE 'TM').CINV\n.CBINT   AIF   ('&S' EQ '').DONE  BIF ALL DONE\n         AIF   (&TBR).CBSBR       BIF TARGET BASED\n&OACNAME &OP   &TB&TP&TO,&S\n         AGO   .DONEL\n.CBSBR   ANOP\n&OACNAME &OP   &TO.(&TBX),&S\n         AGO   .DONEL\n.*\n.*\n.CINV    MNOTE 8,'INVALID TYPE (OACINNRB) - &C - &S'\n         MEXIT\n.*\n.*\n.DONEL   ANOP\n&OACNAME SETC ''\n.DONE    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACINUSE": {"ttr": 7938, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x19\\x00\\x19\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n         OACINUSE &DUMMY,&PRINT=\n         COPY  OACGBLS\n         GBLC  &USELAB(16),&USEREG(16)  PGM LABELS,REGISTERS USED\n         LCLA  &UCNT                    USE INDEX\n         LCLB  &GOTREG                  WHETHER WE FOUND REGS IN USE\n         AIF   ((T'&PRINT EQ 'O') AND                                  @\n               (NOT &OACPRTF)).GO#USE   SKIP PUSH IF NOT NEEDED\n         OACPRTPM PRINT=&PRINT\n.GO#USE  SPACE 1\n         MNOTE *,'THE FOLLOWING REGISTER(S) ARE IN USE:'\n         SPACE 1\n.USELOOP ANOP                           USED REGS LOOP\n&UCNT    SETA  &UCNT+1                  UP THE USE INDEX\n         AIF   ('&USEREG(&UCNT)' EQ '').CHKEND THIS ENTRY IN USE?\n         MNOTE *,'       &USELAB(&UCNT),&USEREG(&UCNT)'\n&GOTREG  SETB  1                        SAY WE FOUND SOMETHING\n.CHKEND  AIF   (&UCNT LT 16).USELOOP    CHECK FOR END OF ARRAY\n         AIF   (&GOTREG).FINI           LEAVE IF WE HAD REGS IN USE\n         MNOTE *,'       *** NONE ****'\n.FINI    SPACE 2\n         AIF   ((T'&PRINT EQ 'O') AND                                  @\n               (NOT &OACPRTF)).EXIT     SKIP POP IF NOT NEEDED\n         POP   PRINT\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACJSUVT": {"ttr": 7940, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&LBL     OACJSUVT &DUMMY,&DSECT=YES\n         LCLC  &NAME\n.**********************************************************************\n.*                                                                    *\n.*       THE JOB STEP UVT IS OBTAINED BY THE OACJSUVT SERVICE         *\n.*       IN SUBPOOL 234 ( FIXED, PK0, JOB-STEP-RELATED, SWAPPABLE,    *\n.*        ACCOUNTABLE, AND NOT FETCH PROTECTED.)                      *\n.*                                                                    *\n.*       NOTE: CHANGES IN THIS MACRO SHOULD BE REFLECTED IN THE       *\n.*             FMTJSUVT ROUTINE WHICH MAPS IT FOR PRDUMP.             *\n.*                                                                    *\n.**********************************************************************\n&NAME    SETC  '&LBL'\n         AIF   ('&NAME' NE '').L0\n&NAME    SETC  'OACJSUVT'\n.L0      AIF   ('&DSECT' NE 'YES').L1\n&NAME    DSECT\n         AGO   .L2\n.L1      ANOP\n&NAME    DS    0D\n.L2      ANOP\nJSUVTID  DC    CL8'OACJSUVT'      CB ID\nJSUVTSP  DC    AL1(234)           CB SUBPOOL\nJSUVTLEN DC    AL3(JSUVTLN)       CB LENGTH\nJSUVTACF DC    A(0)               ADDRESS OF OACF'S UVT\nJSUVTACT DC    A(0)               ADDRESS OF ACCOUNTING UVT\nJSUVTMNT DC    A(0)               ADDRESS OF MOUNT INFO UVT\n         DC    10A(0)             RESERVED\nJSUVTLN  EQU   *-&NAME\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACMAP": {"ttr": 7942, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x01\\xa2\\x01\\xa2\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 418, "newlines": 418, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n         OACMAP &DUMMY,&DSECT=,&PRINT=\n         COPY  OACGBLS\n         LCLC  &C,&D\n         LCLA  &N,&I\n         OACPRTPM PRINT=&PRINT\n&N       SETA  N'&DSECT\n&I       SETA  1\n.LOOP    ANOP\n&D       SETC  '&DSECT(&I)'\n&C       SETC  '&D'(1,1)\n         AIF   ('&C' EQ 'D').D\n         AIF   ('&C' EQ 'S').S\n         AIF   ('&C' EQ 'C').C\n         AIF   ('&C' EQ 'A').A\n         AIF   ('&C' EQ 'P').P\n         AIF   ('&C' EQ 'R').R\n         AIF   ('&C' EQ 'I').I\n         AIF   ('&C' EQ 'T').T\n         AIF   ('&C' EQ 'E').E\n         AIF   ('&C' EQ 'J').J\n         AIF   ('&C' EQ 'Q').Q\n         AIF   ('&C' EQ 'O').O\n         AIF   ('&C' EQ 'F').F\n         AIF   ('&C' EQ 'U').U\n         AIF   ('&C' EQ 'W').W\n         AIF   ('&C' EQ 'L').L\n         AIF   ('&C' EQ 'X').X\n         AIF   ('&C' EQ 'B').B\n         AIF   ('&C' EQ 'G').G\n         AIF   ('&C' EQ 'M').M\n         AIF   ('&C' EQ 'N').N\n         AIF   ('&C' EQ 'V').V\n         AIF   ('&C' EQ 'H').H\n         AIF   ('&C' EQ 'K').K\n.UNKNOWN ANOP\n         MNOTE *,'UNRECOGNIZED DSECT NAME CALLED DIRECTLY'\n         &DSECT(&I)\n         AGO   .L99\n.A       AIF   ('&D' NE 'ACB').A0\n         IFGACB ,                 VSAM ACCESS METH CNTL BLK\n         AGO   .L99\n.A0      AIF   ('&D' NE 'ACCVT').A1\n         ACCVT  ,                 ACF2 CVT\n         AGO   .L99\n.A1      AIF   ('&D' NE 'AMB').A2\n         IDAAMB ,                 VSAM ACCESS METHOD BLK\n         AGO   .L99\n.A2      AIF   ('&D' NE 'AMBL').A3\n         IDAAMBL ,                VSAM ACCESS METH BLK LIST\n         AGO   .L99\n.A3      AIF   ('&D' NE 'AMCBS').A4\n         AMCBS ,                  VSAM ACC METH CNTL BLK STRUCTURE\n         AGO   .L99\n.A4      AIF   ('&D' NE 'AMDSB').A5\n         IDAAMDSB ,               VSAM DATA STATISTICS BLK\n         AGO   .L99\n.A5      AIF   ('&D' NE 'ASCB').A6\n         IHAASCB ,                ADDRESS SPACE CNTL BLK\n         AGO   .L99\n.A6      AIF   ('&D' NE 'ASVT').A7\n         IHAASVT ,                ADDRESS SPACE VECTOR TBL\n         AGO   .L99\n.A7      AIF   ('&D' NE 'ASXB').A8\n         IHAASXB ,                ADDRESS SPACE EXTENTION BLOCK\n         AGO   .L99\n.A8      AIF   ('&D' NE 'ATRCB').UNKNOWN\n         IKJATRCB ,               ATTRIBUTE CONTROLE BLOCK\n         AGO   .L99\n.B       AIF   ('&D' NE 'BUFC').UNKNOWN\n         IDABUFC ,                VSAM BUFFER CNTL BLK\n         AGO   .L99\n.C       AIF   ('&D' NE 'CAXWA').C1\n         IGGCAXWA ,               CATALOG AUX WORK AREA\n         AGO   .L99\n.C1      AIF   ('&D' NE 'CCA').C2\n         IGGCCA   ,               VSAM CATALOG COMM AREA\n         AGO   .L99\n.C2      AIF   ('&D' NE 'CDE').C3\n         IHACDE   ,               CONTENTS DIR ENTRY\n         AGO   .L99\n.C3      AIF   ('&D' NE 'CIB').C4\nCIB      DSECT                    COMMAND INOUT BUFFER\n         IEZCIB   ,\n         AGO   .L99\n.C4      AIF   ('&D' NE 'CPAB').C5\n         IHACPAB  ,               CELL POOL ANCHOR BLOCK\n         AGO   .L99\n.C5      AIF   ('&D' NE 'CPPL').C6\n         IKJCPPL  ,               TSO CMD PROC PARAM LIST\n         AGO   .L99\n.C6      AIF   ('&D' NE 'CSCB').C7\nCSCB     DSECT                    COMM SCHED CNTL BLK\n         IEECHAIN  ,\n         AGO   .L99\n.C7      AIF   ('&D' NE 'CSD').C8\n         IHACSD ,                 COMMON SYSTEM DATA AREA\n         AGO   .L99\n.C8      AIF   ('&D' NE 'CSOA').C9\n         IKJCSOA ,                CMD SCAN OUTPUT AREA\n         AGO   .L99\n.C9      AIF   ('&D' NE 'CSPL').C10\n         IKJCSPL ,                CMD SCAN PARM LIST\n         AGO   .L99\n.C10     AIF   ('&D' NE 'CVT').UNKNOWN\n         CVT   DSECT=YES          COMM VECTOR TABLE\n         AGO   .L99\n.D       ANOP\n&C       SETC  '&D'(2,1)\n         AIF   ('&C' EQ 'A').DA\n         AIF   ('&D' NE 'DCB').D1\n         DCBD DSORG=(PS,PO,DA),DEVD=DA CONTROLE BLK\n         AGO   .L99\n.D1      AIF   ('&D' NE 'DCBD').D2\n         DCBD ,                   DATA CONTROLE BLK\n         AGO   .L99\n.D2      AIF   ('&D' NE 'DDT').D3\n         IECDDT ,                 DEVICE DEESCRIPTOR TBL\n         AGO   .L99\n.D3      AIF   ('&D' NE 'DEB').D4\n         IEZDEB ,                 DATA EXTENT BLK\n         AGO   .L99\n.D4      AIF   ('&D' NE 'DECB').D5\n         IHADECB ,                DATA EVENT CONTROLE BLK\n         AGO   .L99\n.D5      AIF   ('&D' NE 'DFPL').D6\n         IKJDFPL ,                DEFAULT SERV PARM BLK\n         AGO   .L99\n.D6      AIF   ('&D' NE 'DQE').D7\n         IHADQE ,                 DESCRIPTOR QUEUE ELEMENT\n         AGO   .L99\n.D7      AIF   ('&D' NE 'DSE').D8\n         IKJDSE ,                 TSO TIOT EXTENTION\n         AGO   .L99\n.D8      AIF   ('&D' NE 'DSAB').D9\n         IHADSAB ,                DATA SET ASSOCIATION BLK\n         AGO   .L99\n.D9      AIF   ('&D' NE 'DSCB').D10\nDSCB     DSECT                    DATA SET CONTROLE BLOCK\n         IECSDSL1 ,\n         AGO   .L99\n.D10     AIF   ('&D' NE 'DVCT').UNKNOWN\n         IHADVCT ,                DEVICE CHARACTERISTICS TABLE\n         AGO   .L99\n.DA      AIF   ('&D' NE 'DAIRFAIL').DA0\n         IKJEFFDF DFDSECT=YES,DFDSEC2=YES\n         AGO   .L99\n.DA0     AIF   ('&D' NE 'DAIRACB').DA1\n         IKJDACB ,                DAIR ACCESS CNTL BLK\n         AGO   .L99\n.DA1     AIF   ('&D' NE 'DAPB0C').DA2\n         IKJDAP0C ,               CONCATENATE\n         AGO   .L99\n.DA2     AIF   ('&D' NE 'DAPB04').DA3\n         IKJDAP04 ,               SEARCH DSE FOR DSN\n         AGO   .L99\n.DA3     AIF   ('&D' NE 'DAPB00').DA4\n         IKJDAP00                 SEARCH DSE FOR DSN, OR TERM\n         AGO   .L99\n.DA4     AIF   ('&D' NE 'DAPB08').DA5\n         IKJDAP08 ,               ALLOC A DS\n         AGO   .L99\n.DA5     AIF   ('&D' NE 'DAPB1C').DA6\n         IKJDAP1C ,               ALLOC DDN TO TERMINAL\n         AGO   .L99\n.DA6     AIF   ('&D' NE 'DAPB10').DA7\n         IKJDAP10 ,               DECONCATENATE\n         AGO   .L99\n.DA7     AIF   ('&D' NE 'DAPB14').DA8\n         IKJDAP14 ,               RETURN QUALIFIERS FOR INDEX\n         AGO   .L99\n.DA8     AIF   ('&D' NE 'DAPB18').DA9\n         IKJDAP18 ,               FREE DS OR DDNAME\n         AGO   .L99\n.DA9     AIF   ('&D' NE 'DAPB2C').DA10\n         IKJDAP2C ,               MARK FILES NOT IN USE\n         AGO   .L99\n.DA10    AIF   ('&D' NE 'DAPB24').DA11\n         IKJDAP24 ,               ALLOC DDNAME TO DS\n         AGO   .L99\n.DA11    AIF   ('&D' NE 'DAPB28').DA12\n         IKJDAP28 ,               PERFORM LIST OF DAIR RQSTS\n         AGO   .L99\n.DA12    AIF   ('&D' NE 'DAPB30').DA13\n         IKJDAP30 ,               ALLOC A SYSOUT DS\n         AGO   .L99\n.DA13    AIF   ('&D' NE 'DAPB34').DA14\n         IKJDAP34 ,               ATRCB CHAIN MAINTENANCE\n         AGO   .L99\n.DA14    AIF   ('&D' NE 'DAPL').UNKNOWN\n         IKJDAPL ,                DAIR PARM LIST\n         AGO   .L99\n.E       AIF   ('&D' NE 'ECB').E1\n         IHAECB ,                 EVENT CONTROLE BLOCK\n         AGO   .L99\n.E1      AIF   ('&D' NE 'ECT').E2\n         IKJECT ,                 TSO EVENT CNTL TBL\n         AGO   .L99\n.E2      AIF   ('&D' NE 'EED').E3\n         IHART1W ,                EXTENDED ERROR DESCRIPTOR       BLK\n         AGO   .L99\n.E3      AIF   ('&D' NE 'EVNT').UNKNOWN\n         IHAEVNT ,                EVENT TABLE\n         AGO   .L99\n.F       AIF   ('&D' NE 'FBQE').F1\n         IHAFBQE ,                FREE BLOCK QUEUE ELEMENT\n         AGO   .L99\n.F1      AIF   ('&D' NE 'FQE').F2\n         IHAFQE ,                 FREE QUEUE ELEMENT\n         AGO   .L99\n.F2      AIF   ('&D' NE 'FRRS').UNKNOWN\n         IHAFRRS ,                FRR STACK\n         AGO   .L99\n.G       AIF   ('&D' NE 'GENERFAIL').G1\n         IKJEFFGF GFDSECT=YES     GENERAL FAIL DSECTS\n         AGO   .L99\n.G1      AIF   ('&D' NE 'GDA').G2\n         IHAGDA ,                 GLOBAL DATA AREA\n         AGO   .L99\n.G2      AIF   ('&D' NE 'GTPB').UNKNOWN\n         IKJGTPB ,                GETLINE PARM BLK\n         AGO   .L99\n.H       AGO   .UNKNOWN\n.I       AIF   ('&D' NE 'IOB').I1\n         IEZIOB ,                 I/O BLOCK\n         AGO   .L99\n.I1      AIF   ('&D' NE 'IOMB').I2\n         IDAIOMB ,                VSAM IO MNGMT BLK\n         AGO   .L99\n.I2      AIF   ('&D' NE 'IOPL').I3\n         IKJIOPL ,                TSO IO SERV PARM BLK\n         AGO   .L99\n.I3      AIF   ('&D' NE 'IOQ').I4\n         IECDIOQ ,                IOS QUEUE ELEMENT\n         AGO   .L99\n.I4      AIF   ('&D' NE 'IORB').I5\n         ILRIORB ,                O REQUEST BLK\n         AGO   .L99\n.I5      AIF   ('&D' NE 'IOSB').I6\n         IECDIOSB ,               IOS BLK\n         AGO   .L99\n.I6      AIF   ('&D' NE 'IQE').UNKNOWN\n         IHAIQE ,                 INTERRUPT QUEUE ELEMENT\n         AGO   .L99\n.J       AIF   ('&D' NE 'JCT').J1\n         IEFAJCTB ,               ALSO IEFAACTB\n         AGO   .L99\n.J1      AIF   ('&D' NE 'JFCB').J2\nJFCB     DSECT                    JOB FILE CNTL BLK\n         IEFJFCBN ,\n         AGO   .L99\n.J2      AIF   ('&D' NE 'JFCBX').J3\n         IEFJFCBX ,               JFCB EXTENTION\n         AGO   .L99\n.J3      AIF   ('&D' NE 'JSCB').UNKNOWN\n         IEZJSCB ,                JOB STEP CONTROL BLK\n         AGO   .L99\n.K       AFO   .UNKNOWN\n.L       AIF   ('&D' NE 'LCT').L1\n         IEFALLCT ,               LINKAGE CONTROLE TABLE\n         AGO   .L99\n.L1      AIF   ('&D' NE 'LSD').UNKNOWN\n         IKJLSD ,                 LIST SOURCE DESCRIPTOR\n         AGO   .L99\n.M       AGO   .UNKNOWN\n.N       AGO   .UNKNOWN\n.O       AIF   ('&D' NE 'ORE').O1\n         IHAORE ,                 OPERATOR REPLY ELEMENT\n         AGO   .L99\n.O1      AIF   ('&D' NE 'OUCB').O2\n         IRAOUCB ,                SRM USER CNTL BLK\n         AGO   .L99\n.O2      AIF   ('&D' NE 'OUSB').O3\n         IHAOUSB ,                SRM USER SWAPPABLE BLK\n         AGO   .L99\n.O3      AIF   ('&D' NE 'OUXB').UNKNOWN\n         IHAOUXB ,                SRM USER EXTENTION BLK\n         AGO   .L99\n.P       AIF   ('&D' NE 'PGPB').P1\n         IKJPGPB ,                PUTGET PARM BLK\n         AGO   .L99\n.P1      AIF   ('&D' NE 'PICA').P2\n         IHAPICA ,                PGM INTERUPT CNTL AREA\n         AGO   .L99\n.P2      AIF   ('&D' NE 'PIE').P3\n         IHAPIE ,                 PGM INTERUPT ELEMENT\n         AGO   .L99\n.P3      AIF   ('&D' NE 'PPL').P4\n         IKJPPL ,                 PARSE PARM LIST\n         AGO   .L99\n.P4      AIF   ('&D' NE 'PSA').P5\n         IHAPSA ,                 PREFIXED SAVE AREA\n         AGO   .L99\n.P5      AIF   ('&D' NE 'PSCB').P6\n         IKJPSCB ,                TSO-PROTECTED STEP CB\n         AGO   .L99\n.P6      AIF   ('&D' NE 'PTPB').UNKNOWN\n         IKJPTPB ,                PUTLINE PARM BLK\n         AGO   .L99\n.Q       AIF   ('&D' NE 'QCB').Q1\n         IHAQCB ,                 QUEUE CNTL BLK\n         AGO   .L99\n.Q1      AIF   ('&D' NE 'QDB').Q2\n         IHAQDB ,                 QUEUE DESCRIPTOR BLK\n         AGO   .L99\n.Q2      AIF   ('&D' NE 'QEL').UNKNOWN\n         IHAQEL ,                 QUEUE ELEMENT\n         AGO   .L99\n.R       AIF   ('&D' NE 'RB').R1\n         IHARB ,                  REQUEST BLOCKS\n         AGO   .L99\n.R1      AIF   ('&D' NE 'RLGB').R2\n         IKJRLGB ,                RELOGON BUFFER\n         AGO   .L99\n.R2      AIF   ('&D' NE 'RPL').R3\n         IFGRPL ,                 REQUEST PARAMETER LIST\n         AGO   .L99\n.R3      AIF   ('&D' NE 'RQE').R4\n         IECDRQE ,                IOS REQUEST QUEUE ELEMENT\n         AGO   .L99\n.R4      AIF   ('&D' NE 'RTCT').R5\n         IHARTCT ,                RTM RECOVERY TERMINATION CB\n         AGO   .L99\n.R5      AIF   ('&D' NE 'RTM2WA').R6\n         IHARTM2A ,               RTM2 WORK AREA\n         AGO   .L99\n.R6      AIF   ('&D' NE 'RT1W').UNKNOWN\n         IHART1W ,                RTM RT1W WORK AREA\n         AGO   .L99\n.S       AIF   ('&D' NE 'SVC99' AND '&D' NE 'SVC99BLK').S0A\n         IEFZB4D0 ,               SVC 99 DSECTS\n         AIF   ('&D' EQ 'SVC99BLK').L99\n.S0A     AIF   ('&D' NE 'SVC99' AND '&D' NE 'SVC99EQU').S0\n         IEFZB4D2 ,               SVC 99 EQU'S\n         AGO   .L99\n.S0      AIF   ('&D' NE 'SCA').S1\n         IHASCA ,                 SPIE CONTROLE AREA\n         AGO   .L99\n.S1      AIF   ('&D' NE 'SCB').S2\n         IHASCB ,                 STAE CONTROLE BLOCK\n         AGO   .L99\n.S2      AIF   ('&D' NE 'SCVT').S3\n         IHASCVT ,                SECONDARY CVT\n         AGO   .L99\n.S3      AIF   ('&D' NE 'SDUMP').S4\n         IHASDUMP ,               SDUMP PARM LIST\n         AGO   .L99\n.S4      AIF   ('&D' NE 'SDWA').S5\n         IHASDWA ,                SYSTEM DIAGNOSTIC WORK AREA\n         AGO   .L99\n.S5      AIF   ('&D' NE 'SIOT').S6\n         IEFASIOT ,               SYSTEM I/O TABLE\n         AGO   .L99\n.S6      AIF   ('&D' NE 'SRB').S7\n         IHASRB ,                 SYSTEM REQUEST BLOCK\n         AGO   .L99\n.S7      AIF   ('&D' NE 'SSARB').S9\n         IEFSSARB ,               SUBSYS ALLOC REQUEST BLK\n         AGO   .L99\n.S9      AIF   ('&D' NE 'SSCVT').S10\n         IEFJSCVT ,               SUBSYS CVT\n         AGO   .L99\n.S10     AIF   ('&D' NE 'SSIB').S11\n         IEFJSSIB ,               SUB SYS IDENTIFICATION BLK\n         AGO   .L99\n.S11     AIF   ('&D' NE 'SSOB').S12\n         IEFJSSOB ,               SUB SYS OPTIONS BLK\n         AGO   .L99\n.S12     AIF   ('&D' NE 'SSVT').S13\n         IEFJSSVT ,               SUB SYS VECTOR TBL\n         AGO   .L99\n.S13     AIF   ('&D' NE 'SSWA').S14\n         IEFJSSWA ,               SUB SYS SCHEDULER WORK AREA\n         AGO   .L99\n.S14     AIF   ('&D' NE 'STPB').S15\n         IKJSTPB ,                STACK PARM BLK\n         AGO   .L99\n.S15     AIF   ('&D' NE 'STPL').UNKNOWN\n         IKJSTPL  ,               STACK PARM LIST\n         AGO   .L99\n.T       AIF   ('&D' NE 'TAIE').T1\n         IKJTAIE ,                TERM ATTN INTERUPT ELEMENT\n         AGO   .L99\n.T1      AIF   ('&D' NE 'TAXE').T2\n         IKJTAXE ,                TSO TERM ATTN EXIT ELEMENT\n         AGO   .L99\n.T2      AIF   ('&D' NE 'TCB').T3\n         IKJTCB ,                 TCB\n         AGO   .L99\n.T3      AIF   ('&D' NE 'TIOT').T4\nTIOT     DSECT                    TASK IO TBL\n         IEFTIOT1 ,\n         AGO   .L99\n.T4      AIF   ('&D' NE 'TSB').T5\n         IKJTSB ,                 TSO TERMINAL STATUS BLK\n         AGO   .L99\n.T5      AIF   ('&D' NE 'TSBX').UNKNOWN\n         IKTTSBX ,                TSO TSB EXTENTION\n         AGO   .L99\n.U       AIF   ('&D' NE 'UCB').U1\nUCB      DSECT\n         IEFUCBOB LIST=YES        UNIT CONTROLE BLOCK\n         AGO   .L99\n.U1      AIF   ('&D' NE 'UPT').UNKNOWN\n         IKJUPT ,                 TSO USER PROFILE TABLE\n         AGO   .L99\n.V       AGO   .UNKNOWN\n.W       AIF   ('&D' NE 'WQE').UNKNOWN\n         IHAWQE ,                 WTO QUEUE ELEMENT\n         AGO   .L99\n.X       AGO   .UNKNOWN\n.Y       AGO   .UNKNOWN\n.Z       AGO   .UNKNOWN\n.L99     ANOP\n&I       SETA  &I+1\n         AIF   (&I LE &N).LOOP\n         POP   PRINT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACMOVE": {"ttr": 7949, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\xe4\\x00\\xe4\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 228, "newlines": 228, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMASA JOB MAS,MSGCLASS=A,COND=(0,NE)\n/*ROUTE PRINT WYLBUR\n//ASM EXEC ASMHCL,\n//    PARM.LKED='NCAL,LIST,LET,XREF,RENT,REUS'\n//ASM.SYSLIB DD\n//           DD\n//           DD DISP=SHR,DSN=SYS5.MSSMAC\nOACMOVE  CSECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*   OACMOVE  - LOAD IEHMOVE MODULES & LINK TO IEHMOVE                 *\n*   OACMOVEL - LOAD/DELETE IEHMOVE MODULES                            *\n*                                                                     *\n*     ENTRY:  AS AT ENTRY TO IEHMOVE                                  *\n*                                                                     *\n*     EXIT:   AS AT EXIT TO IEHMOVE                                   *\n*                                                                     *\n* WHEN USING IEHMOVE ON SMALL DATASETS, IEHMOVE CAN DO AS MUCH        *\n* I/O LOADING IT'S MODULES AS COPYING DATA.  THIS PROGRAM             *\n* PRE-LOADS ALL RENT OR REUS IEHMOVE MODULES TO AVOID THE             *\n* PROGRAM LOAD I/O.                                                   *\n*                                                                     *\n* SINCE THE NORMAL IEHMOVE REQUIRES APF AUTHORIZATION TO RUN,         *\n* THIS MODULE WOULD HAVE TO BE LINKED AC=1 TO RUN IT.                 *\n*                                                                     *\n* (NOTE THAT THERE ARE ZAP'S WHICH ALLOW IEHMOVE TO RUN WITHOUT       *\n*  APF AUTHORIZATION FOR A MAJOR SUBSET OF FUNCTIONS.                 *\n*  THERE ARE ALSO ZAP'S WHICH ALLOW VIO WORK FILES FOR IEHMOVE).      *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nOACMOVE  CSECT\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         LR    R11,R13            SAVE @ ORIG SAVEAREA\n         USING OACMOVE,R12\n         GETMAIN R,LV=72\n         LR    R13,R1             @ NEW SAVEAREA\n         ST    R11,4(,R13)\n         ST    R13,8(,R11)\n         SPACE 1\n         LA    R1,PARML\n         L     R15,=A(OACMOVEL)\n         BALR  R14,R15            LOAD THE MODULES\n         SPACE 1\n         L     R1,12+8+4*R1(,R11) ORIG R1 VALUE\n         LINK  EPLOC=MODS          GO TO MODULE\n         ST    R15,8+4+4(,R11)    RETURN RETURN TO CALLERS R15 SLOT\n         SPACE 1\n         LA    R1,PARMD\n         L     R15,=A(OACMOVEL)\n         BALR  R14,R15            DELETE THE MODULES\n         SPACE 1\n         FREEMAIN R,LV=72,A=(R13) FREE MY SAVEAREA\n         LR    R13,R11            RESTORE CALLERS R13\n         LM    R14,R12,12(R13)    RESTORE CALLERS REGS\n         BR    R14                 AND RETURN\n         DROP  R12               OACMOVE\n         SPACE 1\nPARML    DC    A(*+4),Y(1),C'L'     LOAD PARM FOR OACMOVEL\nPARMD    DC    A(*+4),Y(1),C'D'     DELETE PARM FOR OACMOVEL\n         EJECT ,\nW#       DSECT\nW#SAVE   DC    18F'0'\nW#BXH    DC    3F'0'              @ FIRST-1, LEN, @ LAST BLDL ENTRIES\nW#MOD    DC    CL8' '\nW#WTO    DC    CL140' '\n         DC    0D'0'\nW#BLDL   DC    Y(MODS#,BLDLLEN)\nW#BLDL1  EQU   *\nW#L      EQU   *-W#\n         SPACE 1\n         ENTRY OACMOVEL\nOACMOVE  CSECT ,\nOACMOVEL STM   R14,R12,12(R13)    SAVE CALLERS REGS\n         LR    R12,R15\n         L     R11,0(,R1)         GET PARM ADDRESS\n         USING OACMOVEL,R12\n         L     R2,=A(W#L+(MODS#*BLDLLEN))\n         GETMAIN R,LV=(R2)\n         LA    R9,0(,R1)          @ W#\n         LR    R0,R9              @ W# FOR CLEAR\n         LR    R1,R2              LENGTH OF AREA\n         SR    R15,R15            CLEAR TO ZERO\n         MVCL  R0,R14\n         USING W#,R9\n         SPACE 1\n         ST    R13,W#SAVE+4\n         ST    R9,8(,R13)\n         LR    R13,R9\n         SPACE 1\n         CLI   2(R11),C'D'         DELETE REQUEST?\n         BE    DLT                 BIF DELETE REQUEST\n         SPACE 1\n         BAL   R10,MSGI           INIT WTO AREA\n         LA    R3,W#BLDL1         @ FIRST BLDL ENTRY\n         LA    R4,BLDLLEN         LENGTH OF EACH BLDL ENTRY\n         LA    R6,MODS#           NUMBER OF BLDL ENTRIES\n         STH   R6,W#BLDL           NUMBER OF BLDL ENTRIES TO BLDL PFX\n         STH   R4,W#BLDL+2          AND LENGTH OF EACH ENTRY\n         BCTR  R6,0               NUMBER OF ENTRIES - 1\n         MH    R6,W#BLDL+2        OFFSET OF LAST ENTRY\n         LA    R6,W#BLDL1(R6)     @ OF LAST ENTRY (BXH LIMIT)\n         SR    R3,R4              @ FIRST ENTRY - 1 FOR BXH\n         LR    R5,R3              INIT EMPTY BLDL LIST\n         STM   R3,R4,W#BXH         SAVE BXH REGS\n         ST    R6,W#BXH+8\n         SPACE 1\n         LA    R7,MODS            @ MODULE LIST\nADD1     MVC   W#MOD(8),0(R7)     NAME TO ADD TO BLDL LIST\n         L     R3,W#BXH           @ FIRST BLDL ENTRY - 1 ENTRY\nADD2     BXH   R3,R4,ADD3         BIF NO MORE PREV NAMES TO CHECK\n         CLC   0(8,R3),W#MOD      THIS MODULE GO HERE?\n         BL    ADD2\n         BE    ADD4               BIF DUPLICATE MODULE (SKIP?)\n         XC    W#MOD(8),0(R3)        TO BLDL LIST\n         XC    0(8,R3),W#MOD\n         XC    W#MOD(8),0(R3)        TO BLDL LIST\n         B     ADD2\n         SPACE 1\nADD3     AR    R5,R4              BUMP TO NEW ENTRY\n         CR    R5,R6              ROOM LEFT IN BLDL TABLE?\n         BNH   *+8                BIF NOT OUT OF ROOM\n         EX    0,*                ** LOGIC ERROR IF OUT OF ROOM **\n         MVC   0(8,R5),W#MOD      NAME TO BLDL LIST\n         SPACE 1\nADD4     LA    R7,8(,R7)          TO NEXT MODULE NAME\n         CL    R7,=A(MODSE)\n         BNH   ADD1\n         SPACE 1\n         BLDL  0,W#BLDL\n         CH    R15,=H'4'\n         BNH   *+8                BIF BLDL OK\n         EX    0,*\n         SPACE 1\n         LM    R3,R5,W#BXH        SCAN FOR BLDL STATS\nLOAD1    BXH   R3,R4,RET          BIF ALL MODULES PROCESSED\n         USING PDS2,R3\n         CLI   PDS2TTRP+2,0       RECORD NUMBER ZERO?\n         BE    LOADER1            BIF BLDL FAILED FOR MODULE\n         TM    PDS2ATR,PDS2REUS+PDS2RENT  RENT OR REUS\n         BZ    LOADER2            BIF NOT REUS OR RENT\n         LOAD  EPLOC=PDS2         LOAD THE MODULE\n         B     LOAD1               AND CONTINUE\nLOADER1  MVC   W#WTO+WTO#M+9(11),=C'BLDL FAILED'\n         B     LOADERR\nLOADER2  MVC   W#WTO+WTO#M+9(16),=C'NOT RENT OR REUS'\nLOADERR  MVC   W#WTO+WTO#M(8),PDS2    MODULE NAME TO MSG\n         BAL   R10,MSG\n         B     LOAD1\n         DROP  R3\n         SPACE 1\nRET      L     R13,4(,R13)        @ CALLERS SAVEAREA\n         L     R2,=A(W#L+(MODS#*BLDLLEN))\n         FREEMAIN R,LV=(R2),A=(R9) FREE W# AREA / BLDL LIST\n         LM    R14,R12,12(R13)    RESTORE CALLERS REGS\n         BR    R14\n         SPACE 1\nDLT      LA    R3,MODS            @ MODULE NAME LIST\nDLT1     DELETE EPLOC=(R3)         DELETE EACH MODULE\n         LA    R3,8(,R3)           @ NEXT MODULE\n         CL    R3,=A(MODSE)       ALL MODULES DELETED\n         BNH   DLT1               BIF MORE TO DO\n         B     RET\n         SPACE 1\nMSG      WTO   MF=(E,W#WTO)\nMSGI     MVC   W#WTO(WTOL),WTO\n         BR    R10\n         SPACE 1\n         DROP  R12                OACMOVEL\n         DROP  R9                 W#\n         EJECT ,\nBLDLLEN  EQU   80                 LENGTH OF EACH BLDL ENTRY\nWTO      WTO   'OAC9999I (OACMOVE) -                                   X\n                      ',ROUTCDE=(11),MF=L\nWTOL     EQU   *-WTO\nWTO#M    EQU   4+21\n         SPACE 1\nMODS     DC    CL8'IEHMOVE '\n         DC    CL8'IEHMVERA'\n         DC    CL8'IEHMVERD'\n         DC    CL8'IEHMVESA'\n         DC    CL8'IEHMVESC'\n         DC    CL8'IEHMVESE'\n         DC    CL8'IEHMVESH'\n         DC    CL8'IEHMVESI'\n         DC    CL8'IEHMVESJ'\n         DC    CL8'IEHMVESK'\n         DC    CL8'IEHMVESL'\n         DC    CL8'IEHMVESM'\n         DC    CL8'IEHMVESN'\n         DC    CL8'IEHMVESO'\n         DC    CL8'IEHMVESP'\n         DC    CL8'IEHMVESQ'\n         DC    CL8'IEHMVESR'\n         DC    CL8'IEHMVESS'\n         DC    CL8'IEHMVEST'\n         DC    CL8'IEHMVESU'\n         DC    CL8'IEHMVESV'\n         DC    CL8'IEHMVESX'\n         DC    CL8'IEHMVESY'\n         DC    CL8'IEHMVESZ'\n         DC    CL8'IEHMVETA'\n         DC    CL8'IEHMVETG'\n         DC    CL8'IEHMVETJ'\n         DC    CL8'IEHMVETL'\n         DC    CL8'IEHMVXSE'\nMODSE    DC    CL8'IEHMVXSF'\nMODS#    EQU   (*-MODS)/8\n         SPACE 1\n         OACREGS ,\n         SPACE 1\n         IHAPDS ,\n         END\n//*KED.SYSLMOD DD DISP=SHR,DSN=CSYSMAS.UTMAS.LOAD,SPACE=\n//LKED.SYSIN   DD *\n   ENTRY OACMOVE\n   ALIAS OACMOVEL\n   NAME OACMOVE(R)\n//*\n//C   EXEC PGM=COMPARE,\n//  PARM='OACMOVE,OACMOVE'\n//STEPLIB  DD DISP=SHR,DSN=SYS5.MSSLOAD\n//SYSPRINT DD SYSOUT=*\n//I1       DD DISP=(SHR,PASS),DSN=&&GOSET\n//I2       DD DISP=SHR,DSN=CSYSMAS.UTMAS.LOAD\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACMUS": {"ttr": 8197, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00H\\x00H\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 72, "newlines": 72, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n         OACMUS &DUMMY,&DSECT=YES\n.*\n.*       PARM  LIST MAPPING MACRO  FOR OACMUS\n.*\n         AIF   ('&DSECT' EQ 'YES').L1\nOACMUSDS DC    0D'0'\n         AGO   .L2\n.L1      ANOP\nOACMUSDS DSECT\n.L2      ANOP\n*        AT THE CALL OF OACMUS, R15 SHOULD POINT TO THE ENTRY POINT,\n*        R13 SHOULD POINT TO A SAVE AREA, R1,SHOULD POINT TO THIS\n*        PARM LIST, AND R0 SHOULD HAVE ONE OF THE FOLLOWING VALUES:\n*                                    0 = REGULAR BATCH\n*                                    4 = LOW PRIORITY BATCH\n*                                    8 = QUICKRUN\n*                                  124 = WYLBUR\n*                                  128 = TSO\n*                                  132 = ORION\n*                                  136 = TSO LARGE REGION\n*         NOTE: THE TSO LARGE REGION PARAMETERS ARE NOTICIBLY\n*                DIFFERENT THAN THE STANDARD, BUT THIS FUNCTION\n*                IS INCLUDED HERE, IN THE INTERESTS OF KEEPING\n*                ALL THE PRIME TIME CALCULATIONS IN ONE  PLACE\n*                PARAMETERS AND RETURN AREAS RELEVENT TO TSO LARGE\n*                REGION ARE MARKED WITH A *@\n*\n*        OACMUS ALSO SUPPORTS REQUESTS FOR CURRENT COST           01225\n*        CONSTANTS. CURRENTLY, JES2/HASPPRPU UTILIZES THIS        01225\n*        INTERFACE TO EXTRACT CURRENT UNIT RECORD CHARGES (PAGES, 01225\n*        LINES, ETC.). THE CURRENTLY DEFINED REQUEST CODES (IN    01225\n*        R0) ARE:                                                 01225\n*                                 1000 = PRINTED PAGES            01225\n*                                 1001 = PRINTED LINES            01225\n*                                 1002 = CARDS READ               01225\n*                                 1003 = CARDS PUNCHED            01225\n*                                 1004 = VERSATEC INCHES PLOTTED  01225\nMUSWORK  DS    0D'0',2F'0'        WORK AREA, MUST BE ZERO ON INITIAL\n*                                 CALL. IF NON ZERO ON RETURN. THE\n*                                 OACMUS ROUTINE MUST BE CALLED AGAIN\n*                                 WITH THE SAME, UNMODIFIED PARM BLOCK\n*                                 TO OBTAIN AN ADDITIONAL MESSAGE\n*                                 IF ZERO ON RETURN, MUSMSG CONTAINS\n*                                 THE LAST MESSAGE.\nMUSMSG   DC    CL80' '            MESSAGE RETURNED HERE\nMUSMSGLN EQU   80                 MESSAGE LENGTH\nMUSMUS   DC    A(0)               .01 MUS RETURNED HERE\nMUSCENTS DC    A(0)               MUS COST IN CENTS IS RETURNED HERE\nMUSCPU   DC    A(0)               CALLER SUPPLIED CPU TIME IN .01 SEC\nMUSIO    DC    A(0)               CALLER SUPPLIED NUMBER OF IO'S\nMUSEWSS  DC    A(0)               CALLER SUPPLIED ESTIMATED WORKING\n*                                 SET IN K BYTES. 0 FOR WYLBUR\nMUSVMF   DC    A(0)               VMF VALUE USED RETURNED HERE    01216\nMUSRTE   DC    A(0)               MUS RATE USED RETURNED HERE     01216\nMUSMNTRT DC    A(0)               MOUNT RATE FOR TAPES            01225\nMUSMNTRD DC    A(0)               MOUNT RATE FOR DISKS            01225\n*\n*        NOTE: THE REST OF THIS PARM LIST NEED NOT BE SUPPLIED\n*              IF THE CALLER IS NOT INTERACTIVE\n*\nMUSCSEC  DC    A(0)               CONNECT TIME IN SEC'S RETURNED HERE\n*@ TSO LARGE REGION RETURN THE NUMBER OF SECONDS UNTILL THE\n*@  START OF THE NEXT PRIME PERIOD IN THIS FIELD\nMUSCCENT DC    A(0)               CONNECT COST IN CENTS RETURNED HERE\nMUSSONTD DC    2A(0)              SIGNON TIME/DATE IN TIME BIN FORMAT\n*@ TSO LARGE REGION SUPPLIES THIS VALUE.\nMUSSOFTD DC    2A(0)              SIGNOFF TIME/DATE IN TIME BIN FORMAT\n*@ TSO LARGE REGION RETURNS THE START OF THE NEXT PRIME TIME\n*@ PERIOD IN THIS FIELD, OR SETS IT EQUAL TO MUSSONTD IF THAT IS\n*@ ALREADY IN A PRIME TIME PERIOD.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACNSWAP": {"ttr": 8200, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\xe1\\x00\\xe1\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 225, "newlines": 225, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMASA  JOB ACCT,MAS,NOTIFY=CSYSMAS,MSGCLASS=A,COND=(0,NE)\n/*ROUTE PRINT WYLBUR\n//ASM EXEC ASMHCL,PARM.LKED='NORENT,REUS,REFER,XREF,LIST,LET'\n//ASM.SYSLIB DD\n//           DD\n//           DD DISP=SHR,DSN=SYS5.MSSMAC\nOACNSWAP CSECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*   OACNSWAP -                                                        *\n*                                                                     *\n*    THIS PROGRAM ALLOWS RUNNING NON-SWAPPING PROBLEM PROGRAMS.       *\n*                                                                     *\n*    THIS PROGRAM IS IN 'SYS1.OACLINK' (AN AUTHORIZED LIBRARY)        *\n*    AND IN THE PPT AS NON-SWAPPABLE.  NOTE THAT THIS PROGRAM         *\n*    IS NOT MARKED AUTHORIZED ANYWHERE.                               *\n*                                                                     *\n*    PARM FIELD FORMAT:  'OMMMMMMMM/PPPP'                             *\n*      O - OPTION.  A - ATTACH WITH TASKLIB, X - XCTL                 *\n*      M - MODULE NAME (UP TO 8 CHARACTERS, VARIABLE LENGTH)          *\n*      / - SLASH (END OF OACNSWAP PARAMETERS)                         *\n*      P - REST OF PARAMETER PASSED TO TARGET PROGRAM                 *\n*                                                                     *\n*   - OBTAINS CONTROL WITH NON-SWAP ALREADY SET                       *\n*     WITH NO AUTHORIZATION.  (IS IN PPT AND AUTHORIZED LIBRARY)      *\n*   - PARSE PARAMETER STRING FOR TARGET PROGRAM NAME.                 *\n*   - CHECKS VALID CALLER (INTERNAL TABLE OF LOGON-IDS/PROGRAMS)      *\n*     (OLE, ARPA, ??)                                                 *\n*   - BUILDS DCB FOR DDNAME 'OACNSWAP'                                *\n*   - LOAD'S SPECIFIED MODULE                                         *\n*   - CLOSE DCB                                                       *\n*   - XCTL'S TO SPECIFIED MODULE                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nW#WORK   DSECT ,\nW#SAVE   DS    9D                 SAVE AREA\nW#PARMPT DS    A(0)               @ W#PARMLN\nW#ECB    DS    F                  ECB FOR SUBTASK\nW#TCBPT  DS    A(0)               @ SUBTASK TCB\nW#OPT    DS    C' '               OPTION (A - ATTACH, X - XCTL)\nW#MOD    DS    CL8' '             MODULE ID\nW#PARMLN DS    H'0'               PARAMETER LENGTH\nW#PARM   DS    CL256' '           PARAMETER STRING\nW#LIST   DS    0F                 LIST FORMS\nW#XCTL   XCTL  EPLOC=W#MOD,SF=L\nW#ATT    ATTACH EPLOC=W#MOD,TASKLIB=W#DCB,ECB=W#ECB,SF=L\nW#OPN    OPEN  (W#DCB),MF=L       DCB OPEN LIST\nW#DCB    DCB   DDNAME=OACNSWAP,DSORG=PO,MACRF=(R)\n         DS    0F\nW#LISTL  EQU   *-W#LIST            LENGTH OF LIST FORMS\nW#WORKL  EQU   *-W#WORK           LENGTH OF WORK AREA\n         EJECT ,\nOACNSWAP CSECT ,\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         OACUSING OACNSWAP,R12\n         LR    R11,R1             SAVE PARM POINTER\n         L     R3,=A(W#WORKL)     LENGTH OF WORK AREA\n         GETMAIN R,LV=(R3)        GET WORKAREA\n         LA    R2,0(,R1)          @ WORK AREA\n         SR    R15,R15            CLEAR FOR MVCL\n         MVCL  R2,R14             ZERO WORK AREA\n         ST    R13,4(,R1)         SAVE @ ORIG SAVE AREA\n         LR    R13,R1             USE NEW SAVE AREA\n         OACUSING W#WORK,R13\n         SPACE 1\n*---                FIND TARGET PROGRAM NAME                       ---*\n         L     R4,0(,R11)         @ PARAMETER\n         LH    R5,0(,R4)          LENGTH OF PARM FIELD\n         LA    R4,2(,R4)          CLEAR SIGN AND SKIP LENGTH FIELD\n         LTR   R5,R5              ANY PARM?\n         BZ    ERRPARM0           BIF NO PARM\n         LA    R1,1               CONSTANT\n         LA    R2,W#OPT           OUTPUT OPTION, MODULE NAME\n         LA    R0,W#MOD+L'W#MOD-1 @ FOR MODULE NAME LENGTH CHECK\n         MVC   W#OPT(9),=CL9' '   INIT OPT, MODULE NAME TO BLANKS\n         SPACE 1\nSCAN1L   LTR   R5,R5              ANY INPUT LEFT?\n         BZ    SCAN3\n         CLI   0(R4),C'/'         THIS DELIMITER?\n         BE    SCAN2\n         CR    R2,R0              MODULE NAME TOO LONG?\n         BH    ERRPARM1\n         MVC   0(1,R2),0(R4)      COPY THIS CHARACTER\n         AR    R2,R1              BUMP OUTPUT PTR\n         AR    R4,R1              BUMP INPUT PTR\n         SR    R5,R1              DCR INPUT LENGTH LEFT\n         B     SCAN1L             AND CONTINUE\n         SPACE 1\nSCAN2    AR    R4,R1              SKIP OVER SLASH\n         SR    R5,R1              DECR LENGTH LEFT\nSCAN3    CLI   W#MOD,C' '         MODULE NAME BLANK?\n         BE    ERRPARM2           BIF NO MODULE SPECIFIED\n         LA    R2,W#PARM          OUTPUT AREA ADDR\n         LR    R3,R5              OUTPUT AREA LENGTH\n         STH   R3,W#PARMLN        SAVE PARM LENGTH FOR PGM\n         MVCL  R2,R4              COPY PARM STRING\n         LA    R1,W#PARMLN\n         ST    R1,W#PARMPT        SET PARM POINTER\n         MVI   W#PARMPT,X'80'     SET HIGH BYTE\n         SPACE 1\n*---              LOCATE JOBNAME                                   ---*\n         OACUSING PSA,R0\n         L     R3,PSATOLD         @ MY TCB\n         OACDROP R0\n         OACUSING TCB,R3\n         L     R3,TCBTIO          @ MY TIOT\n         OACDROP R3\n         SPACE 1\n*---             VALIDITY CHECK JOBNAME/PROGRAM NAME               ---*\n         LM    R0,R2,=A(U#L,U#E,U#B-U#L) ENTRY LEN, @ END, @ BEGIN-LEN\nCKU$LP1  BXH   R2,R0,CKU$FAIL     BIF INVALID CALLER....\n         CLC   0(8,R2),0(R3)      THIS THE JOBNAME?\n         BNE   CKU$LP1\n         CLC   8(8,R2),=CL8'*'    ANY PROGRAM ALLOWED?\n         BE    CKU$OK\n         CLC   8(8,R2),W#MOD      CORRECT PROGRAM?\n         BNE   CKU$LP1\n         SPACE 1\n*---               OPEN 'OACNSWAP' LIBRARY FOR PROGRAM             ---*\nCKU$OK   MVC   W#LIST(W#LISTL),X#LIST LIST FORMS TO WORK AREA\n         OPEN  (W#DCB),MF=(E,W#OPN) OPEN LIBRARY\n         TM    DCBOFLG-IHADCB+W#DCB,DCBOFOPN OPEN OK?\n         BZ    ERROPN             BIF OPEN FAILED\n         SPACE 1\n*---           CHECK OPTION (ATTACH / XCTL)                        ---*\n         CLI   W#OPT,C'X'         XCTL?\n         BE    GOXCTL\n         CLI   W#OPT,C'A'         ATTACH? (WITH TASKLIB)\n         BNE   ERROPT             BIF INVALID OPTION\n         SPACE 1\n         LA    R1,W#PARMPT        @ PARM FOR SUB-TASK\n         ATTACH EPLOC=W#MOD,TASKLIB=W#DCB,ECB=W#ECB,SF=(E,W#ATT)\n         LTR   R15,R15            ATTACH OK?\n         BNZ   ERRATT             BIF ATTACH FAILED\n         ST    R1,W#TCBPT         SAVE TCB ADDR FOR DETACH\n         WAIT  ECB=W#ECB\n         DETACH W#TCBPT           DETACH TASK\n         CLOSE MF=(E,W#OPN)       CLOSE LIBRARY\n         MVI   W#ECB,0            CLEAR HIGH BYTE\n         L     R15,W#ECB          USE AS RETURN CODE\n         B     RETURN\n         SPACE 3\n*---               LOAD TARGET MODULE                              ---*\nGOXCTL   LOAD  EPLOC=W#MOD,DCB=W#DCB\n         SPACE 1\n*---              CLOSE LIBRARY, PREPARE FOR XCTL                  ---*\n         CLOSE MF=(E,W#OPN)       CLOSE LIBRARY\n         SPACE 1\n         LA    R1,W#PARMPT        @ PARM FOR PROGRAM\n         OACDROP R13\n         OACUSING W#PARMPT,R1\n         L     R13,4(,R13)        @ ORIG SAVE AREA\n         L     R14,12(,R13)        AND ORIG R14\n         LA    R15,W#XCTL         @ XCTL LIST\n         LM    R2,R12,12+8+4*R2(R13) AND R2 - R12\n         XCTL  (2,12),SF=(E,(15)),EPLOC=W#MOD\n         SPACE 1\nRETURN   L     R13,4(,R13)\n         L     R14,12(,R13)\n         LM    R0,R12,12+8(R13)   AND RETURN\n         BR    R14\n         SPACE 1\nCKU$FAIL WTO   '---- OACNSWAP - INVALID JOBNAME',ROUTCDE=(11)\n         B     ERRRET\nERROPN   WTO   '---- OACNSWAP - LIBRARY OPEN FAILED',ROUTCDE=(11)\n         ABEND 99,DUMP\nERROPT   WTO   '---- OACNSWAP - INVALID OPTION, NOT X OR A',           X\n               ROUTCDE=(11)\n         B     ERRRET\nERRATT   WTO   '---- OACNSWAP - ATTACH FAILED',ROUTCDE=(11)\n         ABEND 100,DUMP\nERRPARM0 WTO   '---- NO PARM FIELD SPECIFIED',ROUTCDE=(11)\n         B     ERRRET\nERRPARM1 WTO   '---- PARM FIELD TOO LONG',ROUTCDE=(11)\n         B     ERRRET\nERRPARM2 WTO   '---- NO MODULE NAME SPECIFIED',ROUTCDE=(11)\n         B     ERRRET\nERRRET   LA    R15,99\n         B     RETURN\n         EJECT ,\n         LTORG ,\n         SPACE 1\n*---    TABLE OF JOBNAME, PROGRAM NAME OF VALID USERS OF OACNSWAP  ---*\nU#B      DC    CL8'ECN3OLE#',CL8'OLEMAIN '    OLE PRODUCTION\nU#L      EQU   *-U#B              LENGTH OF ENTRY\n         DC    CL8'CSDCLPR ',CL8'ACCONFG '    ARPA TESTING\n         DC    CL8'CARPSYS#',CL8'ACCONFG '    ARPA PRODUCTION\n         DC    CL8'CSMSCLC1',CL8'INASIRMI'    DLS\n         DC    CL8'CSP3DDW#',CL8'CADMNVS2'    CADAM TEST\n         DC    CL8'OCADCAM#',CL8'CADMNVS2'    CADAM PRODUCTION\n         DC    CL8'CSDCKJH#',CL8'*       '    IMPOLT\n         DC    CL8'CSYSMAS#',CL8'*       '    OLE/SYS TESTING\n         DC    CL8'CSYSMAS ',CL8'*       '    OLE/SYS TESTING\n         DC    CL8'CSDCLPR#',CL8'*       '    ARPA/IMP TESTING\n         DC    CL8'CSYSJCJ#',CL8'*       '\n         DC    CL8'CSYSCST#',CL8'*       '\n         DC    CL8'DATALINK',CL8'INASIRMI'    DLS (AS STC)\n         DC    CL8'ZAP ZAP ',CL8'ZAP ZAP '\n         DC    CL8'ZAP ZAP ',CL8'ZAP ZAP '\n         DC    CL8'ZAP ZAP ',CL8'ZAP ZAP '\nU#E      EQU   *-U#L              @ LAST VALID ENTRY\n         SPACE 1\nX#LIST   DS    0F                 LIST FORMS\nX#XCTL   XCTL  EPLOC=1,SF=L\nX#ATT    ATTACH EPLOC=1,TASKLIB=1,ECB=1,SF=L\nX#OPN    OPEN  (1),MF=L           DCB OPEN LIST\nX#DCB    DCB   DDNAME=OACNSWAP,DSORG=PO,MACRF=(R)\n         DS    0F\nX#LISTL  EQU   *-X#LIST            LENGTH OF LIST FORMS\n         SPACE 1\n         OACMAP DSECT=(PSA,TCB,DCB),PRINT=NONE\n         OACREGS PRINT=NONE\n         END\n//*KED.SYSLMOD DD DISP=OLD,DSN=SYS1.OACLINK,SPACE=,UNIT=\n//LKED.SYSIN   DD *\n  NAME OACN$WAP\n//*\n//C  EXEC PGM=COMPARE,PARM='OACN$WAP,OACNSWAP'\n//STEPLIB  DD DISP=SHR,DSN=SYS5.MSSLOAD\n//SYSPRINT DD SYSOUT=*\n//I1       DD DISP=(SHR,PASS),DSN=&&GOSET\n//I2       DD DISP=SHR,DSN=SYS1.OACLINK\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACPRTPM": {"ttr": 8205, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00)\\x00)\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n         OACPRTPM &DUMMY,&PRINT=\n.*\n.*       SETS  VALUES OF &OACPRT AND &OACPRTS DEPENDING ON\n.*       VALUES OF &OACPRTG, &OACPRTF, AND &PRINT\n.*\n.*       DOES  A PUSH PRINT AND A PRINT ON,GEN OR A\n.*       PRINT OFF,NOGEN DEPENDING ON THE CALCULATED VALUE\n.*       OF &OACPRT\n.*\n         COPY  OACGBLS\n&OACPRT  SETC  '&OACPRTG'\n         AIF   (&OACPRTF).L4\n         AIF   ('&PRINT' EQ '').L1DEF\n         AIF   ('&PRINT' NE 'ALL' ).L1\n&OACPRT  SETC  'ALL'\n         AGO   .L4\n.L1      AIF   ('&PRINT' NE 'SHORT').L2\n.L1DEF   ANOP                     DEFAULT PRINT VALUE\n&OACPRT  SETC  'SHORT'\n         AGO   .L4\n.L2      AIF   ('&PRINT' EQ 'NONE').L3\n         MNOTE 4,'UNRECOGNIZABLE PRINT VALUE ''NONE'' USED'\n.L3      ANOP\n&OACPRT  SETC  'NONE'\n.L4      ANOP\n         PUSH  PRINT\n         AIF   ('&OACPRT' NE 'ALL').L5\n&OACPRTS SETA  99\n         AGO   .L8\n.L5      AIF   ('&OACPRT' NE 'SHORT').L6\n&OACPRTS SETA  1\n         AGO   .L8\n.L6      AIF   ('&OACPRT' EQ 'NONE').L7\n         MNOTE 4,'UNRECOGNIZABLE VALUE OF &OACPRTG ''NONE'' SET'\n&OACPRTG SETC  'NONE'\n&OACPRT  SETC  '&OACPRTG'\n.L7      ANOP\n         PRINT OFF,GEN\n&OACPRTS SETA  1\n.L8      MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACREGS": {"ttr": 8207, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00 \\x00 \\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n         OACREGS &DUMMY,&PRINT=\n         COPY  OACGBLS\n         OACPRTPM PRINT=&PRINT\n         AIF   ('&OACPRT' NE 'SHORT').L1\n         PRINT OFF,GEN\n.L1      ANOP\n         SPACE &OACPRTS\n******************************************\nR0       EQU   0                   <-----|\nR1       EQU   1                   <-----|\nR2       EQU   2                   <-----|\nR3       EQU   3                   <-----|\nR4       EQU   4                   <-----|\nR5       EQU   5                   <-----|      =============\nR6       EQU   6                   <-----|      =  GENERAL  =\nR7       EQU   7                   <-----|      =  PURPOSE  =\nR8       EQU   8                   <-----|      = REGISTERS =\nR9       EQU   9                   <-----|      =============\nR10      EQU   10                  <-----|\nR11      EQU   11                  <-----|\nR12      EQU   12                  <-----|\nR13      EQU   13                  <-----|\nR14      EQU   14                  <-----|\nR15      EQU   15                  <-----|\n         SPACE\nF0       EQU   0                   <-----|    ==================\nF2       EQU   2                   <-----|    = FLOATING POINT =\nF4       EQU   4                   <-----|    =   REGISTERS    =\nF6       EQU   6                   <-----|    ==================\n         POP   PRINT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACRET": {"ttr": 8209, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&NAME    OACRET &DUMMY,&RC=\n         GBLC   &OACNAME\n&OACNAME SETC  '&NAME'\n         AIF   ('&RC' EQ '').L1\n&OACNAME OACINNER F=&RC,T=(R15),OP=M,SETCC=YES,COM='GET RC'\n&OACNAME SETC  ''\n.L1      ANOP\n&OACNAME LM    R2,R14,8(R11)      RESTORE REGS AN POP STACK\n         BR    R14                RETURN TO CALLER\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACSUB": {"ttr": 8449, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00q\\x00q\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 113, "newlines": 113, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&NAME    OACSUB   &CSECT=NO,&ENTRY=NO,&BASE=R10,&ENTRYS=,&ENTRYR=,     X\n               &EXIT=,&DSECT=,&WORK=,&INUSE=YES,&ID=,&DATE=,&PRINT=\n         COPY  OACGBLS            GET OAC GLOBAL ASM SYSMS\n         LCLC  &C,&I,&D,&LEN,&NM\n         LCLA  &N,&X,&WL\n         LCLB  &XZ\n         OACPRTPM PRINT=&PRINT\n         AIF   ('&DSECT' EQ '').L3\n&DSECT   DSECT\n&LEN     SETC  'XL&SYSNDX'\n         DC    8D'0'              SPACE FOR STM R0,R1\n         AIF   ('&WORK(2)' EQ '').L1\n         OACSUBWK &WORK(2)\n.L1      ANOP\n         AIF   ('&WORK(1)' EQ ''  OR '&WORK(1)' EQ '0').L2\n&WORK(3) DC    0D'0',&WORK(1)XL1'0' RESERVED AREA\n.L2      ANOP\nXL&SYSNDX EQU  8*((7+*-&DSECT)/8) MAKE IT A MULTIPLE OF 8\n&SYSECT  CSECT\n         SPACE &OACPRTS\n         AGO   .L6\n.L3      AIF   ('&WORK(3)' EQ '').L4\n         MNOTE 4,'WORK LABEL REQUIRES CODING DSECT=NAME'\n.L4      AIF   ('&WORK(2)' EQ '').L5\n         MNOTE 12,'WORK MACRO REQUIRES CODING DSECT=NAME'\n.L5      ANOP\n&WL      SETA  64                 SPACE FOR STM R0,R15\n&LEN     SETC  '64'\n         AIF   ('&WORK(1)' EQ ''  OR '&WORK(1)' EQ '0').L6\n&WL      SETA  &WL+8*((&WORK(1)+7)/8)\n&LEN     SETC  '&WL'\n.L6      AIF   ('&OACPRT' NE 'NONE').L8\n         PRINT ON,GEN\n.L8      ANOP\n         AIF   ('&CSECT' NE 'YES').L9\n&NAME    CSECT\n&NM      SETC  ''\n         AGO   .L11\n.L9      AIF   ('&ENTRY' NE 'YES').L10\n         ENTRY &NAME\n.L10     ANOP\n&NM      SETC  '&NAME'\n.L11     AIF   ('&ID' EQ '').L14\n&D       SETC  '&SYSDATE'\n         AIF   ('&DATE' EQ '').L12\n&D       SETC  '&DATE'\n         MNOTE 7,'REMOVE DATE= BEFORE FINAL ASSEMBLY'\n.L12     ANOP\n&I       SETC  '&ID &D'\n&A       SETA  2*(K'&I/2)\n         AIF   (K'&I EQ &A).L13\n&I       SETC  '&I '\n.L13     ANOP\n&A       SETA  4+K'&I\n&NM      B     &A.(R15)           BRANCH AROUND ID\n&NM      SETC  ''\n         DC    C'&I'\n.L14     ANOP\n&NM      STM   R0,R15,0(R13)      SAVE CALLERS REGS\n         AIF   ('&BASE' EQ '').L15B\n         AIF   ('&BASE(2)' EQ '').L15\n         OACUSING &BASE(2),&BASE(1)\n         AGO   .L15B\n.L15     AIF   ('&BASE' EQ 'R15').L15A\n         LR    &BASE,R15          SAVE BASE\n.L15A    ANOP\n         OACUSING &NAME,&BASE\n.L15B    ANOP\n&N       SETA  N'&ENTRYS\n&NM      SETC  ''\n         AIF   (&N EQ 0).L18\n         AIF   ('&ENTRYR' NE '').L16\n         MNOTE 12,'ENTRYR REQUIRED IF ENTRYS CODED'\n.L16     ANOP\n         SR    &ENTRYR,&ENTRYR    MARK AS MAIN ENTRY\n         B     XC&SYSNDX          GO TO COMMON CODE\n&NM      SETC  'XC&SYSNDX'\n&X       SETA  1\n.LOOP    ANOP\n         SPACE 1\n&C       SETC  '&ENTRYS(&X)'\n         AIF   ('&ENTRY' NE 'YES').L17\n         ENTRY &C\n.L17     ANOP\n&C       STM   R0,R15,0(R13)      SAVE CALLERS REGS\n&A       SETA  4*&X\n         LA    &ENTRYR,&A         MARK AS ENTRY NO &X\n         L     &BASE,XB&SYSNDX-&C.(R15) GET BASE ADDRESS\n         B     XC&SYSNDX          GO TO COMMON CODE\n&X       SETA  &X+1\n         AIF   (&X LE &N).LOOP\nXB&SYSNDX DC   A(&NAME)           BASE ADDRESS\n.L18     ANOP\n&NM      LR    R11,R13            PUSH STACK\n         LA    R13,&LEN.(R13)     RESERVE THIS ELEMENT\n         C     R13,&OACSTMX       CHECK FOR OVERFLOW\n         BNL   &OACSTER           IF SO GOTO ERROR ROUTINE\n         AIF   ('&DSECT' EQ '').L19\n         OACUSING &DSECT,R11\n.L19     AIF   ('&EXIT' EQ '').L22\n         B     XZ&SYSNDX\n&XZ      SETB  1\n         SPACE 2\n&EXIT(1) OACRET RC=&EXIT(2)\n.L22     ANOP\n         SPACE 2\n         AIF   (NOT &XZ).L23\nXZ&SYSNDX DC   0H'0'\n.L23     AIF   ('&INUSE' NE 'YES').MEND\n         OACINUSE PRINT=&PRINT\n.MEND    POP   PRINT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACTMP": {"ttr": 8452, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\xfc\\x00\\xfc\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 252, "newlines": 252, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&LBL     OACTMP &CMD=(0,0),&CBUF=,&PGM=,&PARM=,                        X\n               &DCB=0,&TASKLIB=0,&CMDLIB=YES,                          X\n               &EXEC=YES,&STACK=YES,&SCMD=NO,&STAX=YES,&CMDFAIL=MSG,   X\n               &MF=I\n         LCLA  &F,&F1,&A\n         LCLC  &C\n         LCLB  &CBF,&CBR,&CS,&CR1,&CR2,&PGF,&PGS,&PGR\n         LCLB  &PRF,&PRS,&PRR,&HF,&HS,&HR\n         LCLB  &DCBR,&DCB0,&TSKR\n         LCLB  &STRS\n         LCLB  &MFL,&MFI,&MFB,&MFE\n         AIF   (('&LBL' EQ '') OR ('&MF' EQ 'L') ).L\n&LBL     DS    0H\n.L       AIF   ('&CBUF' EQ '').L1\n&CBF     SETB  1\n&F       SETA  X'80'\n&C       SETC  '&CBUF'(1,1)\n         AIF   ('&C' NE '(').L8\n&CBR     SETB  1\n         AGO   .L8\n.L1      ANOP\n&C       SETC  '&CMD(1)'(1,1)\n         AIF   ('&C' NE '''').L2\n&CS      SETB  1\n&STRS    SETB  1\n         AGO   .L4\n.L2      AIF   ('&C' NE '(').L3\n&CR1     SETB  1\n.L3      ANOP\n&C       SETC  '&CMD(2)'(1,1)\n         AIF   ('&C' NE '(').L4\n&CR2     SETB  1\n.L4      AIF   ('&PGM' EQ '').L7A\n&PGF     SETB  1\n&F1      SETA  X'80'\n&C       SETC  '&PGM'(1,1)\n         AIF   ('&C' NE '''').L5\n&PGS     SETB  1\n&STRS    SETB  1\n         AGO   .L6\n.L5      AIF   ('&C' NE '(').L6\n&PGR     SETB  1\n.L6      AIF   ('&PARM' EQ '').L8\n&PRF     SETB  1\n&C       SETC  '&PARM'(1,1)\n         AIF   ('&C' NE '''').L7\n&PRS     SETB  1\n&STRS    SETB  1\n         AGO   .L8\n.L7      AIF   ('&C' NE '(').L8\n&PRR     SETB  1\n         AGO   .L8\n.L7A     AIF   ('&CMD(1)' NE '0').L8\n         AIF   ('&MF(1)' EQ 'L').L8\n         MNOTE 8,'CMD, CBUF, OR PGM MUST BE SPECIFIED'\n         MEXIT\n.L8      AIF   ('&DCB' NE 'ENV').L8A\n&F       SETA  &F+X'40'\n&DCB0    SETB  1\n         AGO   .L9\n.L8A     AIF   ('&DCB' NE '0').L8B\n&DCB0    SETB  1\n         AGO   .L9\n.L8B     ANOP\n&C       SETC  '&DCB'(1,1)\n         AIF   ('&C' NE '(').L9\n&DCBR    SETB  1\n.L9      ANOP\n&C       SETC  '&TASKLIB'(1,1)\n         AIF   ('&C' NE '(').L10\n&TSKR    SETB  1\n.L10     AIF   ('&CMDLIB' NE 'NO').L11\n&F       SETA  &F+X'20'\n.L11     AIF   ('&EXEC'  NE 'NO').L12\n&F       SETA  &F+X'10'\n.L12     AIF   ('&STACK' NE 'NO').L13\n&F       SETA  &F+X'02'\n.L13     AIF   ('&SCMD' EQ 'NO').L14\n&F       SETA  &F+X'08'\n.L14     AIF   ('&STAX' NE 'NO').L15\n&F       SETA  &F+X'04'\n         AGO   .L17\n.L15     AIF   ('&STAX' EQ 'YES').L17\n&HF      SETB  1\n&C       SETC  '&STAX'(1,1)\n         AIF   ('&C' NE '''').L16\n&HS      SETB  1\n&STRS    SETB  1\n         AGO   .L17\n.L16     AIF   ('&C' NE '(').L17\n&HR      SETB  1\n.L17     AIF   ('&CMDFAIL' NE 'NOMSG').L18\n&F       SETA  &F+X'01'\n.L18     AIF   ('&MF' NE 'L').L19\n&MFL     SETB  1\n         AGO   .L23\n.L19     AIF   ('&MF' NE 'I').L20\n&MFI     SETB  1\n         AGO   .L23\n.L20     ANOP\n&C       SETC  '&MF(1)'\n         AIF   ('&C' NE 'B').L21\n&MFB     SETB  1\n         AGO   .L23\n.L21     AIF   ('&C' NE 'E').L22\n&MFE     SETB  1\n         AGO   .L23\n.L22     MNOTE 8,'UNRECOGNIZABE MF'\n         MEXIT\n.L23     AIF   (NOT &MFL).L37\n         AIF   (NOT (&CBR OR &CR1 OR &CR2 OR &PGR OR &PRR OR &DCBR OR  X\n               &TSKR)).L24\n         MNOTE 8,'R FORM NOT ALOWED WITH MF=L'\n         MEXIT\n.L24     ANOP\n&LBL     DS    0F                       FULLWORD ALIGNMENT\n         DC    AL1(&F)                  FLAGS\n         AIF   (NOT &DCB0).L25\n         DC    AL3(0)                   DCB ADDR\n         AGO   .L26\n.L25     DC    AL3(&DCB)                DCB ADDR\n.L26     AIF   (&PGF).L29\n         AIF   (&CBF).L28\n         AIF   (&CS).L27\n         DC    AL1(&CMD(2))             CMD LNTH\n         DC    AL3(&CMD(1))             CMD ADDR\n         AGO   .L31\n.L27     DC    AL1(L'TMPC&SYSNDX)       CMD LNTH\n         DC    AL3(TMPC&SYSNDX)         CMD ADDR\n         AGO   .L31\n.L28     DC    AL4(&CBUF)               PTR TO CBUF\n         AGO   .L31\n.L29     AIF   (&PGS).L30\n         DC    AL4(&PGM)                PGM NAME ADDR\n         AGO   .L31\n.L30     DC    AL4(TMPG&SYSNDX)         PGM NAME ADDR\n.L31     DC    AL1(&F1)                 FLAGS\n         DC    AL3(&TASKLIB)            TASKLIB\n         AIF   (&PRF).L32\n         DC    AL4(0)                   RETURN/COMPLETION CODE\n         AGO   .L34\n.L32     AIF   (&PRS).L33\n         DC    AL4(&PARM)               PARM PTR/RETURN-COMPLETION CODE\n         AGO   .L34\n.L33     DC    AL4(TMPR&SYSNDX)         PARM PTR/RETURN-COMPLETION CODE\n.L34     AIF   (&HF).L35\n         DC    AL4(0)                   UNUSED HERALD FIELD\n         AGO   .L38\n.L35     AIF   (&HS).L36\n         DC    AL4(&STAX)               HERALD/REPLY\n         AGO   .L38\n.L36     DC    AL4(TMPH&SYSNDX)         HERALD/REPLY\n.L37     AIF   (NOT (&STRS OR &MFI)).L38\n         B     TMPL&SYSNDX\n.L38     AIF   (NOT &CS).L39\nTMPC&SYSNDX DC C&CMD\n.L39     AIF   (NOT &PGS).L40\nTMPG&SYSNDX DC CL8&PGM                  PGM NAME\n.L40     AIF   (NOT &PRS).L41\n&A       SETA  K'&PARM\n&A       SETA  &A-2\nTMPR&SYSNDX DC 0F'0',XL1'80',AL3(TMPR&SYSNDX+6)\n         DC    F'&A'\n         DC    C&PARM\n.L41     AIF   (NOT &HS).L42\n&A       SETA  K'&STAX\n&A       SETA  &A-2\nTMPH&SYSNDX DC H'&A',C&STAX\n.L42     AIF   (NOT &MFL).L43\n         MEXIT\n.L43     AIF   (NOT &MFI).L44\nTMPT&SYSNDX DC 5F'0'                    CMD BLK FOR OACTMP\nTMPL&SYSNDX LA 1,TMPT&SYSNDX GET TBL ADDR\n         AGO   .L45A\n.L44     AIF   (NOT &STRS).L45\nTMPL&SYSNDX DS 0H\n.L45     AIF   ('&MF(2)' EQ '(1)').L45A\n         LA    1,&MF(2)                 GET TBL ADDR\n.L45A    ANOP\n         XC    0(20,1),0(1)             CLEAR TBL\n.L46     AIF   (&DCBR).L47\n         AIF   (&DCB0).L48\n         LA    0,&DCB                   GET DCB ADDR\n         ST    0,0(1)                   STORE IN TBL\n         AGO   .L48\n.L47     ST    &DCB(1),0(1)             STORE DCB ADDR\n.L48     AIF   ('&F' EQ '0').L49\n         MVI   0(1),&F                  MOVE IN FLAGS\n.L49     AIF   (&PGF).L54\n         AIF   (&CBF).L53A\n         AIF   (&CS).L53\n         AIF   (&CR1).L50\n         LA    0,&CMD(1)                GET CMD ADDR\n         ST    0,4(1)                   STORE IN LST\n         AGO   .L51\n.L50     ST    &CMD(1),4(1)\n.L51     AIF   (&CR2).L52\n         MVI   4(1),&CMD(2)             MOVE IN LNTH\n         AGO   .L57\n.L52     STC   &CMD(2),4(1)             STORE CMD LNTH\n         AGO   .L57\n.L53     LA    0,TMPC&SYSNDX            GET CMD ADDR\n         ST    0,4(1)                   STORE IN TBL\n         MVI   4(1),L'TMPC&SYSNDX       MOVE IN LNTH\n         AGO   .L57\n.L53A    AIF   (&CBR).L53B\n         LA    0,&CBUF                  GET CBUF ADDR\n         ST    0,4(1)                   STORE IN TBL\n         AGO   .L57\n.L53B    ST    &CBUF(1),4(1)            STORE CBUF ADDR\n         AGO   .L57\n.L54     AIF   (&PGS).L56\n         AIF   (&PGR).L55\n         LA    0,&PGM                   GET PGM NAME ADDR\n         ST    0,4(1)                   STORE IN TABLE\n         AGO   .L57\n.L55     ST    &PGM(1),4(1)             STORE PGM NAME ADDR\n         AGO   .L57\n.L56     LA    0,TMPG&SYSNDX            GET PGM NAME ADDR\n         ST    0,4(1)                   STORE IN TABLE\n.L57     AIF   ('&TASKLIB' EQ '0').L59\n         AIF   (&TSKR).L58\n         LA    0,&TASKLIB               GET ADDR OF TSK DCB\n         ST    0,8(1)                   STORE IN TAB\n         AGO   .L59\n.L58     ST    &TASKLIB(1),8(1)         STORE TSK DCB ADDR\n.L59     AIF   ('&F1' EQ '0').L60\n         MVI   8(1),&F1                 MOVE IN FLGS\n.L60     AIF   (NOT &PRF).L63\n         AIF   (&PRS).L62\n         AIF   (&PRR).L61\n         L     0,&PARM                  GET PARM ADDR\n         ST    0,12(1)                  STORE IN TABLE\n         AGO   .L63\n.L61     ST    &PARM(1),12(1)           ST PRM ADDR IN TABLE\n         AGO   .L63\n.L62     LA    0,TMPR&SYSNDX            GET PARM ADDR\n         ST    0,12(1)                  STORE IN TABLE\n.L63     AIF   (NOT &HF).L67\n         AIF   (&HS).L65\n         AIF   (&HR).L64\n         LA    0,&STAX                  GET HERALD ADDR\n         ST    0,16(1)                  STORE IN TABLE\n         AGO   .L67\n.L64     ST    &STAX(1),16(1)           STORE HERALD ADDR\n         AGO   .L67\n.L65     LA    0,TMPH&SYSNDX            GET HERALD ADDR\n         ST    0,16(1)                  STORE IN TBL\n.L67     AIF   (&MFB).L68\n         LINK  EP=OACTMP\n.L68     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACTSOPL": {"ttr": 8457, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x06\\xdf\\x06\\xdf\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 1759, "newlines": 1759, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n         OACTSOPL &DUMMY,&PL=,&PRINT=\n         COPY  OACGBLS\n         LCLA  &N,&I\n         OACPRTPM PRINT=&PRINT\n&N       SETA  N'&PL\n&I       SETA  1\n.LOOP    ANOP\n         AIF   ('&PL(&I)' NE 'ACB').L0\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR0\n***********************************************************************\n*  THE ACCESS METHOD CONTROLE BLOCK IS USED TO PROVIDE VSAM           *\n*  DCB INFO                                                           *\n***********************************************************************\n         SPACE 1\n.PR0     ANOP\nACB      DS    0D                              ACCESS METHOD CONTROL\n*                                              BLOCK\nACBID    DS    XL1                             ACB IDENTIFIER\nACBIDVAL EQU   X'A0'                           IDENTIFIER VALUE - X'A0'\nACBSTYP  DS    XL1                             ACB SUBTYPE\nACBSVSAM EQU   X'10'                           VSAM SUBTYPE     X04SVHS\nACBSVRP  EQU   X'11'                           VRP SUBTYPE      X04SVHS\nACBSVTAM EQU   X'20'                           VTAM SUBTYPE     X04SVHS\nACBS3540 EQU   X'40'                           3540 SUBTYPE     X04SVHS\nACBLENG  DS    0H                              ACB LENGTH IN BYTES\nACBLEN2  DS    0H                              ALTERNATE NAME FOR\n*                                              ACBLENG           X03004\nACBLENG2 DS    H                               ALTERNATE NAME FOR\n*                                              ACBLENG           X03004\nACBAMBL  DS    0A                              AMB LIST ADDRESS(VSAM)\nACBJWA   DS    0A                              JES WORK AREA ADDRESS\nACBIBCT  DS    0A                              INTERFACE BUFFER CONTROL\n*                                              TABLE (RTAM)    @G29ASRL\nACBAMWAP DS    A                               ACCESS METHOD WORKAREA\n*                                              POINTER         @G29ASRL\nACBINRTN DS    A                               DATA MANAGEMENT\n*                                              INTERFACE ROUTINE\n*                                              ADDRESS; VTAM REQUEST\n*                                              PROCESSOR ADDRESS X03004\nACBMACRF DS    0BL2                            MACRF PROCESSING OPTIONS\nACBMACR1 DS    BL1                             MACRF FIRST BYTE\nACBKEY   EQU   X'80'                           KEYED PROCESSING VIA\n*                                              INDEX\nACBADR   EQU   X'40'                           ADDRESSED PROCESSING\n*                                              WITHOUT INDEX\nACBADD   EQU   X'40'                           ALTERNATE NAME FOR\n*                                              ACBADR\nACBCNV   EQU   X'20'                           PROCESSING BY\n*                                              CONTROL INTERVAL\nACBBLK   EQU   X'20'                           ALTERNATE NAME FOR\n*                                              ACBCNV\nACBSEQ   EQU   X'10'                           SEQUENTIAL PROCESSING\nACBDIR   EQU   X'08'                           DIRECT PROCESSING\nACBIN    EQU   X'04'                           INPUT PROCESSING USING\n*                                              GET OR READ\nACBOUT   EQU   X'02'                           OUTPUT PROCESSING USING\n*                                              PUT OR WRITE\nACBUBF   EQU   X'01'                           USER CONTROLS BUFFERS -\n*                                              VALID ONLY WITH CONTROL\n*                                              INTERVAL PROCESSING\nACBMACR2 DS    BL1                             MACRF SECOND BYTE\nACBSKP   EQU   X'10'                           SKIP SEQUENTIAL\n*                                              PROCESSING\nACBLOGON EQU   X'08'                           LOGON REQUESTS TO AN\n*                                              APPLICATION WILL BE\n*                                              REJECTED(VTAM)    X03004\nACBRST   EQU   X'04'                           SET DATA SET TO  X04SVHS\n*                                              EMPTY STATE      X04SVHS\nACBDSN   EQU   X'02'                           BASIC SUBTASK SHARED\n*                                              CONTROL BLOCK CONNECTION\n*                                              ON COMMON DSNAMES\n*                                                               X04SVHS\nACBAIX   EQU   X'01'                           ENTITY TO BE PROCESSED\n*                                              IS AIX PATH SPECIFIED IN\n*                                              IN THE GIVEN DDNAME\n*                                                               X04SVHS\nACBBSTNO DS    FL1                             NUMBER OF CONCURRENT\n*                                              STRINGS FOR AIX  X04SVHS\n*                                              PATH             X04SVHS\nACBSTRNO DS    FL1                             NUMBER OF CONCURRENT\n*                                              REQUEST STRINGS  X04SVHS\nACBBUFND DS    H                               NUMBER OF DATA RECORD\n*                                              BUFFERS\nACBBUFNI DS    H                               NUMBER OF INDEX RECORD\n*                                              BUFFERS\nACBBUFPL DS    0A                              JES BUFFER POOL\nACBLFB   DS    0A                              RESERVED NAME\nACBMACR3 DS    XL1                             MACRF THIRD BYTE X04SVHS\nACBLSR   EQU   X'40'                           LOCAL SHARED RESOURCE\n*                                                               X04SVHS\nACBGSR   EQU   X'20'                           GLOBAL SHARED RESOURCE\n*                                                               X04SVHS\nACBICI   EQU   X'10'                           IMPROVED CONTROL\n*                                              INTERVAL PROCESSING\n*                                                               X04SVHS\nACBDFR   EQU   X'08'                           DEFER WRITES     X04SVHS\nACBSIS   EQU   X'04'                           SEQUENTIAL INSERT\n*                                              STRATEGY         X04SVHS\nACBNCFX  EQU   X'02'                           NFX=0/CFX=1      X04SVHS\nACBMACR4 DS    XL1                             RESERVED         X04SVHS\nACBJBUF  DS    H                               NUMBER OF JOURNAL\n*                                              BUFFERS(VSAM)\nACBRECFM DS    BL1                             RECORD FORMAT\nACBRECAF EQU   X'80'                           JES FORMAT\nACBCCTYP DS    BL1                             CONTROL CHARACTER TYPE\nACBTRCID EQU   X'C0'                           3800 TRANSLATE TABLE+8\n*                                                               Z40SVHS\nACBCCASA EQU   X'04'                           ASA CONTROL CHARACTERS\nACBCCMCH EQU   X'02'                           MACHINE CONTROL\n*                                              CHARACTERS\nACBOPT   DS    0BL2                            NON-USER OPTIONS\nACBDSORG DS    0BL2                            MATCH ACBDORGA WITH\n*                                              DCBDSORG\nACBDSOR1 DS    BL1                             DSORG FIRST BYTE\n*        CHECKPOINT/RESTART OPTIONS\nACBCRNCK EQU   X'80'                           NO CHECK BY RESTART\n*                                              FOR MODIFICATIONS SINCE\n*                                              LAST CHECKPOINT\nACBCRNRE EQU   X'40'                           DATA ADDED SINCE\n*                                              LAST CHECKPOINT NOT\n*                                              ERASED BY RESTART AND\n*                                              NO REPOSITION TO LAST\n*                                              CHECKPOINT TAKES PLACE\nACBDVIND EQU   X'20'                           DEVICE INDICATR @ZA26638\nACBOPTJ  EQU   X'20'                           3800 CONTROL    @ZA26638\n*                                              CHAR PRESENT    @ZA26638\nACBDSOR2 DS    BL1                             DSORG SECOND BYTE\nACBDORGA EQU   X'08'                           ACB INDICATOR\nACBMSGAR DS    A                               MSG AREA PTR     X04SVHS\nACBPASSW DS    A                               PASSWORD ADDRESS\nACBEXLST DS    0A                              USER EXIT LIST ADDRESS\nACBUEL   DS    A                               ALTERNATE NAME FOR\n*                                              ACBEXLST\n*              BEFORE ACB IS OPENED\n*              (FOR VTAM, ACBDDNM IS INITIALIZED TO\n*              X'FF00000000000000')                              X03004\nACBDDNM  DS    CL8                             DDNAME - MUST BE THE\n*                                              SAME AS THE NAME FIELD\n*                                              ON THE DD STATEMENT\n*                                              DEFINING THE DATA SET\n*                                              ASSOCIATED WITH THIS ACB\n*              AFTER ACB IS OPENED\n         ORG   ACBDDNM\nACBTIOT  DS    H                               OFFSET FROM TIOT ORIGIN\n*                                              TO THE TIOELNGH FIELD IN\n*                                              THE TIOT ENTRY FOR THE\n*                                              DD STATEMENT FOR THIS\n*                                              ACB\nACBINFL  DS    BL1                             CONTENTS AND MEANING\n*                                              ARE THE SAME AS\n*                                              ACBINFLG (BEFORE OPEN)\nACBAM    DS    0B                              ALTERNATE NAME FOR\n*                                              ACBAMETH          X03004\nACBAMETH DS    BL1                             ACCESS METHOD TYPE\nACBVTAM  EQU   X'60'                           VTAM              X03004\nACBSUBS  EQU   X'41'                           SUBSYSTEMS\nACBTCAM  EQU   X'31'                           TCAM\nACBRCI   EQU   X'23'                           JES/RCI\nACBRTAM  EQU   X'22'                           JES/RTAM\nACBJAM   EQU   X'21'                           JES/JAM\nACBVSAM  EQU   X'11'                           VSAM\nACBERFL  DS    BL1                             FOR JES, CONTENTS AND\n*                                              MEANING ARE THE SAME\n*                                              AS ACBERFLG (BEFORE\n*                                              OPEN) - NOT USED BY\n*                                              VSAM/VTAM\nACBDEB   DS    AL3                             DEB ADDRESS\n*              NOT MOVED BY OPEN\nACBOFLGS DS    BL1                             OPEN / CLOSE FLAGS\nACBEOV   EQU   X'20'                           EOV CONCATENATION\nACBOPEN  EQU   X'10'                           THE ACB IS OPEN\nACBDSERR EQU   X'08'                           NO FURTHER REQUESTS ARE\n*                                              POSSIBLE AGAINST THIS\n*                                              ACB\nACBEXFG  EQU   X'02'                           USER EXIT FLAG - SET TO\n*                                              0 BY AN I/O SUPPORT\n*                                              WHEN A USER EXIT TAKEN;\n*                                              SET TO 1 ON RETURN\nACBLOCK  EQU   X'02'                           ALTERNATE NAME FOR\n*                                              ACBEXFG          X03004\nACBIOSFG EQU   X'01'                           OPEN/CLOSE IN CONTROL -\n*                                              THE ACB IS BEING\n*                                              PROCESSED BY AN I/O\n*                                              SUPPORT FUNCTION\nACBBUSY  EQU   X'01'                           ALTERNATE NAME FOR\n*                                              ACBIOSFG         X03004\n*              BEFORE ACB IS OPENED\nACBERFLG DS    BL1                             ERROR FLAGS - FOR\n*                                              VSAM/VTAM THIS FIELD IS\n*                                              NOT MOVED BY OPEN AND\n*                                              ERROR FLAGS ARE\n*                                              RETURNED HERE; FOR JES\n*                                              THIS FIELD IS MOVED TO\n*                                              ACBERFL BY OPEN\n*              THE FOLLOWING CODES ARE COMMON TO ALL ACCESS      X03004\n*              METHODS.                                          X03004\nACBOALR  EQU   X'04'                           THE ACB IS ALREADY OPEN\nACBCALR  EQU   X'04'                           THE ACB IS NOT OPEN\n*                                                              @ZM30033\nACBINFLG DS    0BL2                            INDICATOR FLAGS @ZA16012\nACBINFL1 DS    BL1                             FIRST IND FLAGS @ZA16012\n.*             BIT 0 - X'80' MATCHES WITH BIT 0 OF THE DCBMACR FIELD,\n.*             INDICATING AN EXCP DCB.  THIS BIT IS USED TO\n.*             DIFFERENTIATE BETWEEN AN ACB AND A DCB AND MUST NEVER\n.*             BE ASSIGNED IN THE ACB.\nACBJEPS  EQU   X'40'                           JEPS IS USING THIS ACB\nACBIJRQE EQU   X'20'                           AN RQE IS HELD BY JAM\nACBCAT   EQU   X'10'                           ACB FOR VSAM CATALOG\nACBSCRA  EQU   X'08'                           CATALOG CONTROL BLOCK\n*                                              SYSTEM AREA      X04SVHS\nACBUCRA  EQU   X'04'                           CATALOG CONTROL BLOCK\n*                                              USER AREA        X04SVHS\nACBVVIC  EQU   X'02'                           DATA SET BEING OPENED\n*                                              IS SYS1.VVIC     X04SVHS\nACBSDS   EQU   X'02'                           OPEN AS SYSTEM DATA SET\n*                                                              @Z40SVUC\nACBBYPSS EQU   X'01'                           BYPASS SECURITY ON OPEN\n*                                              IF CALLER AUTH  @Z40RSUC\nACBINFL2 DS    BL1                             2ND IND FLAGS   @ZA16012\nACBCBIC  EQU   X'20'                           OPEN WITH CONTROL BLOCKS\n*                                              IN COMMON STORAGE AREA\n*                                                              @ZA16012\n*              NOT MOVED BY OPEN\nACBUJFCB DS    0A                              USER JFCB ADDRESS\nACBOPTN  DS    XL1                             JAM UCS INDICATORX04SVHS\n         DS    XL3                             RESERVED         X04SVHS\nACBBUFSP DS    F                               VIRTUAL CORE AVAILABLE\n*                                              FOR BUFFERS\nACBBLKSZ DS    0H                              BLOCKSIZE\nACBMSGLN DS    H                               LNG OF MSG AREA  X04SVHS\nACBLRECL DS    H                               LOGICAL RECORD LENGTH\nACBUAPTR DS    A                               USER WORKAREA ADDRESS;\n*                                              CAXWA ADDRESS FOR\n*                                              CATALOG OPEN\nACBCBMWA DS    A                               CONTROL BLOCK\n*                                              MANIPULATION WORKAREA\n*                                              ADDRESS\nACBAPID  DS    0A                              APPLICATION ID @G29ASRL\nACBAMAX  DS    A                               ACCESS METHOD ACB\n*                                              EXTENSION      @G29ASRL\n         AGO   .L99\n.L0      AIF   ('&PL(&I)' NE 'ATRCB').L1\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR1\n***********************************************************************\n*  THE ATTRIBUTE CONTROL BLOCK IS USED TO PROVIDE DCB PARAMETERS      *\n*  TO THE DYNAMIC ALLOCATION ROUTINE.                                 *\n***********************************************************************\n         SPACE 1\n.PR1     ANOP\nATRCB    DS    0D\nATRFORWD DS    AL4       ADDRESS OF NEXT ATRCB\nATRBCKWD DS    AL4       ADDRESS OF PREVIOUS ATRCB\n         DS    CL4       RESERVED\nATRNAME  DS    CL8       ATTR-LIST-NAME\nATRLNGH  DS    CL2       LENGTH OF ATRCB\nATRMASK  DS    CL8       INOUT-OUTIN OPTION\nATRLABEL EQU   ATRMASK+6 SPECIFY OUTIN OR INOUT                  YM1841\nATRINOUT EQU   X'80'     INOUT\nATROUTIN EQU   X'40'     OUTIN\n         DS    CL3       RESERVED\nATREXPDT DS    CL3       DATA SET EXPIRATION DATE\n         DS    CL2       RESERVED\nATRBUFNO DS    CL1       NO. OF BUFFERS REQUIRED\nATRBFTEK DS    CL1       BFTEK BFALN\nATRBFALN EQU   ATRBFTEK\nATRSIMPL EQU   X'40'     SIMPLE BUFFERING              \"S\"\nATRAUTO  EQU   X'60'     AUTOMATIC RECORD AREA CONS'T  \"A\"\nATRECRD  EQU   X'20'     RECORD BUFFERING              \"R\"\nATREXC   EQU   X'10'     EXCHANGE BUFFERING            \"E\"\nATRDOUBL EQU   X'02'     DOUBLE WORD BOUNDARY          \"D\"\nATRFULL  EQU   X'01'     FULL WORD BOUNDARY            \"F\"\nATRBUFL  DS    CL2       BUFFER LENGTH\nATREROPT DS    CL1       ERROR OPTION\nATRACEPT EQU   X'80'     ACCEPT\nATRSKIP  EQU   X'40'     SKIP\nATRABNOR EQU   X'20'     ABNORMAL END OF TASK\nATRKEYLE DS    CL1       KEY LENGTH\n         DS    CL6       RESERVED\nATRECFM  DS    CL1       RECORD FORMAT\nATRFIXED EQU   X'80'     FIXED                         \"F\"\nATRVARIB EQU   X'40'     VARIABLE                      \"V\"\nATRUNDEF EQU   X'C0'     UNDEFINED                     \"U\"\nATRTRKOV EQU   X'20'     TRACK OVERFLOW                \"T\"\nATRBLOCK EQU   X'10'     BLOCKED                       \"B\"\nATRSTAND EQU   X'08'     STANDARD BLOCKS               \"S\"\nATRASA   EQU   X'04'     ASA PRINTER CHARS.            \"A\"\nATRMACH  EQU   X'02'     MACH,CNTRL.CHAR               \"M\"\nATROPTCD DS    CL1       OPTION CODES\nATRWRTCK EQU   X'80'     WRITE VALIDITY CHECK          \"W\"\nATRSCHED EQU   X'20'     CHAINED SCHEDULING            \"C\"\nATRANSI  EQU   X'08'     ANSI TRANSLATE                \"Q\"\nATRUSERT EQU   X'02'     USER TOTALING                 \"T\"\nATRBLKSI DS    CL2       MAXIMUM BLOCK SIZE\nATRLRECL DS    CL2       LOGICAL RECORD LENGTH\nATRNCP   DS    CL1       MAX # OF READ/WRITE MACROS BEFORE CHECK\n         DS    CL4       RESERVED\n         AGO   .L99\n.L1      AIF   ('&PL(&I)' NE 'CPPL').L2\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR2\n***********************************************************************\n*    THE COMMAND PROCESSOR PARAMETER LIST (CPPL) IS A LIST OF         *\n*    ADDRESSES PASSED FROM THE TMP TO THE CP VIA REGISTER 1           *\n***********************************************************************\n         SPACE 1\n.PR2     ANOP\nCPPL     DS    0D\nCPPLCBUF DS    A        PTR TO COMMAND BUFFER\nCPPLUPT  DS    A        PTR TO UPT\nCPPLPSCB DS    A        PTR TO PSCB\nCPPLECT  DS    A        PTR TO ECT\n         AGO   .L99\n.L2      AIF   ('&PL(&I)' NE 'CSOA').L3\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR3\n***********************************************************************\n*    THE COMMAND SCAN OUTPUT AREA (CSOA) IS AN AREA POINTED TO        *\n*    BY THE CSPL.  IT IS USED BY COMMAND SCAN TO INDICATE ITS         *\n*    FINDINGS.  IT IS OBTAINED AND FREED BY THE INVOKER               *\n***********************************************************************\n         SPACE 1\n.PR3     ANOP\nCSOA     DS    0D\nCSOACNM  DS    A        PTR TO COMMAND NAME-IF 0 INVALID CMD NAME\nCSOALNM  DS    H        LENGTH OF CMD NAME\nCSOAFLG  DS    X        FLAGS\nCSOAVWP  EQU   X'80'    VALID WITH PARAMETERS\nCSOAVNP  EQU   X'40'    VALID NO   PARAMS\nCSOAQM   EQU   X'20'    QUESTION MARK\nCSOANOC  EQU   X'10'    NO COMMAND\nCSOABAD  EQU   X'08'    BAD CMD NAME\nCSOAEXEC EQU   X'04'    IMPLICIT EXEC COMMAND NAME              Y30PQJN\n         DS    CL1      RESERVED\n         AGO   .L99\n.L3      AIF   ('&PL(&I)' NE 'CSPL').L4\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR4\n***********************************************************************\n*    THE COMMAND SCAN PARAMETER LIST (CSPL) IS A LIST OF ADDRESSES    *\n*    PASSED FROM THE INVOKER TO COMMAND SCAN VIA REGISTER 1           *\n***********************************************************************\n         SPACE 1\n.PR4     ANOP\nCSPL     DS    0D\nCSPLUPT  DS    A        PTR TO  UPT\nCSPLECT  DS    A        PTR TO  ECT\nCSPLECB  DS    A        PTR TO  CP'S ECB\nCSPLFLG  DS    A        PTR TO  FLAG WORD WHICH IS OBTAINED & FREED\n*                       BY CALLER. BIT 0 SET TO 0= SYNTAX CHECKING OF\n*                       COMMAND NAME.\nCSPLOA   DS    A        PTR TO OUTPUT AREA (CSOA DSECT)\nCSPLCBUF DS    A        PTR TO COMMAND BUFFER\n         AGO   .L99\n.L4      AIF   ('&PL(&I)' NE 'DAIRFAIL').L4A\n         IKJEFFDF ,     DAIRFAIL PARM LISTS\n         AGO   .L99\n.L4A     AIF   ('&PL(&I)' NE 'DAIRACB').L5\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR5\n***********************************************************************\n* THE DAIRACB IS USED TO PROVIDE DCB PARAMETERS TO THE DYNAMIC        *\n* ALLOCATION INTERFACE ROUTINE. THE ATTRIBUTES ARE PLACED INTO        *\n* AN ATRCB AND RETAINED ON A CHAIN UNTIL REFERED TO ON AN ALLOCATE CMD\n***********************************************************************\n         SPACE 1\n.PR5     ANOP\nDAIRACB  DS    0D\n         DS    CL8       RESERVED\nDAIMASK  DS    CL8       INOUT-OUTIN OPTION\nDAILABEL EQU   DAIMASK+6 SPECIFY OUTIN OR INOUT                  YM1841\nDAIINOUT EQU   X'80'     INOUT\nDAIOUTIN EQU   X'40'     OUTIN\n         DS    CL3       RESERVED\nDAIEXPDT DS    CL3       DATA SET EXPIRATION DATE\n         DS    CL2       RESERVED\nDAIBUFNO DS    CL1       NO. OF BUFFERS REQUIRED\nDAIBFTEK DS    CL1       BFTEK/BFALN\nDAIBFALN EQU   DAIBFTEK\nDAISIMPL EQU   X'40'     SIMPLE BUFFERING              \"S\"\nDAIAUTO  EQU   X'60'     AUTOMATIC RECORD AREA CONS'T  \"A\"\nDAIRECRD EQU   X'20'     RECORD BUFFERING              \"R\"\nDAIEXC   EQU   X'10'     EXCHANGE BUFFERING            \"E\"\nDAIDOUBL EQU   X'02'     DOUBLE WORD BOUNDARY          \"D\"\nDAIFULL  EQU   X'01'     FULL WORD BOUNDARY            \"F\"\nDAIBUFL  DS    CL2       BUFFER LENGTH\nDAIEROPT DS    CL1       ERROR OPTION\nDAIACEPT EQU   X'80'     ACCEPT\nDAISKIP  EQU   X'40'     SKIP\nDAIABNOR EQU   X'20'     ABNORMAL END OF TASK\nDAIKEYLE DS    CL1       KEY LENGTH\n         DS    CL6       RESERVED\nDAIRECFM DS    CL1       RECORD FORMAT\nDAIFIXED EQU   X'80'     FIXED                         \"F\"\nDAIVARIB EQU   X'40'     VARIABLE                      \"V\"\nDAIUNDEF EQU   X'C0'     UNDEFINED                     \"U\"\nDAITRKOV EQU   X'20'     TRACK OVERFLOW                \"T\"\nDAIBLOCK EQU   X'10'     BLOCKED                       \"B\"\nDAISTAND EQU   X'08'     STANDARD BLOCKS               \"S\"\nDAIASA   EQU   X'04'     ASA PRINTER CHARS.            \"A\"\nDAIMACH  EQU   X'02'     MACH.CNTRL.CHAR.              \"M\"\nDAIOPTCD DS    CL1       OPTION CODES\nDAIWRTCK EQU   X'80'     WRITE VALIDITY CHECK          \"W\"\nDAISCHED EQU   X'20'     CHAINED SCHEDULING            \"C\"\nDAIANSI  EQU   X'08'     ANSI TRANSLATE                \"Q\"\nDAIUSERT EQU   X'02'     USER TOTALING                 \"T\"\nDAIBLKSI DS    CL2       MAXIMUM BLOCK SIZE\nDAILRECL DS    CL2       LOGICAL RECORD LENGTH\nDAINCP   DS    CL1       MAX # OF READ/WRITE MACROS BEFORE CHECK\n         DS    CL4       RESERVED\n         AGO   .L99\n.L5      AIF   ('&PL(&I)' NE 'DAPL').L6\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR6\n***********************************************************************\n*    THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER LIST   *\n*    (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER TO DAIR    *\n*    VIA REGISTER 1\n***********************************************************************\n         SPACE 1\n.PR6     ANOP\nDAPL     DS    0D\nDAPLUPT  DS    A        PTR TO UPT\nDAPLECT  DS    A        PTR TO ECT\nDAPLECB  DS    A        PTR TO CP'S ECB\nDAPLPSCB DS    A        PTR TO PSCB\nDAPLDAPB DS    A        PTR TO DAIR PARAMETER BLOCK\n         AGO   .L99\n.L6      AIF   ('&PL(&I)' NE      'DAPB0C').L7\n         SPACE 1\nDAPB0C   DS    0D\nDA0CCD   DS    CL2      DAIR ENTRY CODE\nDA0CFLG  DS    X        FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\n         DS    X\nDA0CDARC DS    H        DYN ALLOC RETURN CODE\n         DS    CL2      RESERVED\nDA0CNUMB DS    H        NUMBER OF 8 BYTE FIELDS THAT FOLLOW THIS\n*                       DSECT\n         DS    CL2      RESERVED\n         AGO   .L99\n.L7      AIF   ('&PL(&I)' NE      'DAPB04').L8\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR7\n***********************************************************************\n* THIS OPERATION CODE CAUSES A SEARCH OF THE DSE TO BE MADE FOR THE   *\n* SPECIFIED DSNAME. IF IT IS NOT FOUND IN THE DSE THE SYSTEM CATALOG  *\n* IS ALSO SEARCHED                                                    *\n***********************************************************************\n         SPACE 1\n.PR7     ANOP\nDAPB04   DS    0D\nDA04CD   DS    CL2      DAIR ENTRY CODE\nDA04CAT  EQU   X'04'    DSNAME FOUND IN  CATLG\nDA04FLG  DS    X        FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\nDA04DSE  EQU   X'02'    DSNAME FOUND IN  DSE\n         DS    X\n         DS    CL2      RESERVED\nDA04CTRC DS    H                  CATALOG RETURN CODE AREA\nDA04PDSN DS    A        POINTER TO DSNAME TO BE SEARCHED IN DSE\nDA04CTL  DS    X        CONTROL FLGS FOR SPECIAL PROCESSING\nDA04UID  EQU   X'20'    USER ID IS TO BE PREFIXED TO DSNAME\n         DS    CL2      RESERVED\nDA04DSO  DS    CL1      INDICATES DSORG\n         AGO   .L99\n.L8      AIF   ('&PL(&I)' NE      'DAPB00').L9\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR8\n***********************************************************************\n* THIS OPERATION  CODE CAUSES A SEARCH OF THE DSE TO BE MADE FOR THE  *\n* SPECIFIED DSNAME AND SET THE DA00FLG FIELD ACCORDINGLY. IF DDNAME   *\n* IS REQUESTED INFORMATION IS RETURNED IN DA00FLG INDICATING WHETHER  *\n* OR NOT THE DDNAME IS ALLOCATED TO THE TERMINAL                      *\n***********************************************************************\n         SPACE 1\n.PR8     ANOP\nDAPB00   DS    0D\nDA00CD   DS    CL2\nDA00FLG  DS    X        FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\nDA00PERM EQU   X'08'    DSE PERMANENTLY ALLOCATED              M0766\nDA00DYNM EQU   X'04'    DD IS A DYNAM                          M0766\nDA00DSE  EQU   X'02'    DSNAME FOUND IN DSE\nDA00TERM EQU   X'01'    DDNAME ALLOCATED TO A TERMINAL\n         DS    X\nDA00PDSN DS    A        POINTER TO DSNAME TO BE SEARCHED FOR IN DSE\nDA00DDN  DS    CL8      DDNAME TO BE SEARCHED FOR IN DSE\nDA00CTL  DS    X        CONTROL FLAGS FOR SPEC PROCESSING\nDA00UID  EQU   X'20'    USER ID IS TO BE PREFIXED TO DSNAME\n         DS    CL2      RESERVED\nDA00DSO  DS    CL1      INDICATES DSORG\n         AGO   .L99\n.L9      AIF   ('&PL(&I)' NE      'DAPB08').L10\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR9\n***********************************************************************\n* THIS OPERATION CODE CAUSES ALLOCATION OF A DATA SET. IT CAN ALLOC.  *\n* EITHER A NEW OR OLD SET.                                            *\n***********************************************************************\n         SPACE 1\n.PR9     ANOP\nDAPB08   DS    0D\nDA08CD   DS    CL2      DAIR ENTRY CODE\nDA08FLG  DS    X        FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\nDA08FPE  EQU   X'80'    FUNCT PERFORMED BUT ERROR INDICATED BY RETCD\n         DS    X\nDA08DARC DS    H        DYN ALLOC RETURN CODE\nDA08CTRC DS    H        CATALOG RETURN CODE\nDA08PDSN DS    A        POINTER TO DSNAME TO BE SEARCHED IN DSE\nDA08DDN  DS    CL8      DDNAME TO BE SEARCHED IN DSE\nDA08UNIT DS    CL8      UNITNAME REQUESTED\nDA08SER  DS    CL8      VOLUME SERIAL NUMBER-PADDED W/BLANKS\nDA08BLK  DS    CL4      DATA SET  AVERAGE RECORD LENGTH\nDA08PQTY DS    CL4      PRIMARY SPACE QUANTITY\nDA08SQTY DS    CL4      SECONDARY SPACE QUANTITY\nDA08DQTY DS    CL4      DIRECTORY BLOCK QUANTITY\nDA08MNM  DS    CL8      MEMBER NAME\nDA08PSWD DS    CL8      PASSWORD\nDA08DSP1 DS    X        DATA SET STATUS FLGS(IF=0 OLD ASSUMED)\nDA08SHR  EQU   X'08'    DATA SET IS SHR\nDA08NEW  EQU   X'04'    DATA SET IS NEW\nDA08MOD  EQU   X'02'    DATA SET IS MOD\nDA08OLD  EQU   X'01'    DATA SET IS OLD\nDA08DPS2 DS    X        DATA SET DISPOSITION(IF=0 KEEP ASSUMED)\nDA08KEEP EQU   X'08'    DS DISP IS KEEP\nDA08DEL  EQU   X'04'    DS DISP IS DELETE\nDA08CAT  EQU   X'02'    DS DISP IS CATLG\nDA08UCAT EQU   X'01'    DS DISP IS UNCATALOG\nDA08DPS3 DS    X        DATA SET CONDITIONAL DISPOSITION\nDA08KEP  EQU   X'08'\nDA08DELE EQU   X'04'\nDA08CATL EQU   X'02'    DS DISP OF CATLG DESIRED\nDA08UNCT EQU   X'01'    DS DISP OF UNCATLG DESIRED\nDA08CTL  DS    X        FLAGS TO CONTROL ACTIONS TAKEN BY DAIR\nDA08TRKS EQU   X'80'    UNITS ARE TRKS\nDA08ABKL EQU   X'40'\nDA08CYLS EQU   X'C0'    UNITS ARE CYLS\nDA08UID  EQU   X'20'    USER ID IS TO BE PREFIXED\nDA08RLSE EQU   X'10'    RELEASE (RLSE) REQUESTED\nDA08PERM EQU   X'08'    DATA SET MUST BE SPECIFICALLY UNALLOCATED\nDA08DMMY EQU   X'04'\nDA08ATRL EQU   X'02'    ATTRIBUTE LIST SUPPLIED                  C99236\n         DS    CL3      RESERVED\nDA08DSO  DS    CL1      DSORG\nDA08ALN  DS    CL8      ATTR-LIST-NAME                           C99236\n         AGO   .L99\n.L10     AIF   ('&PL(&I)' NE      'DAPB1C').L11\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR10\n***********************************************************************\n* THIS OPERATION CODE REQUESTS ALLOCATION TO THE TERMINAL.            *\n***********************************************************************\n         SPACE 1\n.PR10    ANOP\nDAPB1C   DS    0D\nDA1CCD   DS    CL2      DAIR ENTRY CODE\nDA1CFLG  DS    X        FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\n         DS    X\nDA1CDARC DS    H        DYN ALLOC RETURN CODE\n         DS    CL1      RESERVED\nDA1CCTL  DS    CL1      CONTROL FIELD\nDA1CPERM EQU   X'08'    PERMANENTLY ALLOCATE BIT\nDA1CATRL EQU   X'02'    ATTRIBUTE LIST SUPPLIED                  C99236\nDA1CDDN  DS    CL8      DDNAME TO BE SEARCHED IN DSE\nDA1CALN  DS    CL8      ATTR-LIST-NAME                           C99236\n         AGO   .L99\n.L11     AIF   ('&PL(&I)' NE      'DAPB10').L12\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR11\n***********************************************************************\n* THIS OPERATION CODE CAUSES THE PREVIOUSLY CONCATENATED DDNAME  TO   *\n* BE DECONCATENATED                                                   *\n***********************************************************************\n         SPACE 1\n.PR11    ANOP\nDAPB10   DS    0D\nDA10CD   DS    CL2      DAIR ENTRY CODE\nDA10FLG  DS    X        FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\n         DS    X\nDA10DARC DS    H        DYN ALLOC RETURN CODE\n         DS    CL2      RESERVED\nDA10DDN  DS    CL8      DDNAME TO BE SEARCHED IN DSE\n         AGO   .L99\n.L12     AIF   ('&PL(&I)' NE      'DAPB14').L13\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR12\n***********************************************************************\n* THIS OPERATION CODE RETURNS QUALIFIERS IN THE RETURN AREA FOR THE   *\n* GIVEN INDEX NAME                                                    *\n***********************************************************************\n         SPACE 1\n.PR12    ANOP\nDAPB14   DS    0D\nDA14CD   DS    CL2      DAIR ENTRY CODE\nDA14FLG  DS    X        FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\n         DS    X\nDA14PDSN DS    A        POINTER TO DSNAME TO BE SEARCHED IN DSE\nDA14PRET DS    A        POINTER TO RETURN AREA\nDA14CTL  DS    X        CONTROL FLAGS FOR SPECIAL PROCESSING\nDA14UID  EQU   X'20'    USER ID IS TO BE PREFIXED TO DSNAME\n         DS    CL3      RESERVED\n         AGO   .L99\n.L13     AIF   ('&PL(&I)' NE      'DAPB18').L14\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR13\n***********************************************************************\n* THIS OPERATION CAUSES THE REQUESTED DATA SET OR DDNAME TO BE        *\n* UNALLOCATED. DISPOSITION CAN BE SPECIFIED TO OVERRIDE ANY PREVIOUS  *\n* DISPOSITION. LIKEWISE SYSOUT CLASS MAY BE SPECIFIED TO OVERRIDE ANY *\n* PREVIOUS CLASS.                                                     *\n***********************************************************************\n         SPACE 1\n.PR13    ANOP\nDAPB18   DS    0D\nDA18CD   DS    CL2      DAIR ENTRY CODE\nDA18FLG  DS    X        FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\nDA18FPE  EQU   X'80'    FUNCT PERFORMED BUT ERROR INDICATED BY RETCD\n         DS    X\nDA18DARC DS    H        DYNAMIC ALLOCATION RETURN CODE\nDA18CTRC DS    H        CATALOG RETURN CODE AREA\nDA18PDSN DS    A        POINTER TO DSNAME TO BE SEARCHED IN DSE\nDA18DDN  DS    CL8      DDNAME TO BE SEARCHED IN DSE\nDA18MNM  DS    CL8      MEMBER NAME\nDA18SCLS DS    CL2      SYSOUT CLASS DESIRED WHEN UNALLOCATING  A\n*                       SYSOUT DATA SET\nDA18DPS2 DS    X        DATA SET DISPOSITION\nDA18KEEP EQU   X'08'    CHANGE DISP TO KEEP\nDA18DEL  EQU   X'04'    CHANGE DISP TO DELETE\nDA18CAT  EQU   X'02'    CHANGE DISP TO CATALOG\nDA18UCAT EQU   X'01'    CHANGE DISP TO UNCATLOG\nDA18CTL  DS    X        FLAGS FOR SPECIAL DAIR PROCESSING\nDA18UID  EQU   X'20'    USER ID IS TO BE PREFIXED TO DSNAME\nDA18PERM EQU   X'10'    UNALLOCATE PERM. ALLOCATED DSE'S      M0765\nDA18JBNM DS    CL8      IGNORED AS OF OS VS/2 RELEASE 2       Y02670\n         AGO   .L99\n.L14     AIF   ('&PL(&I)' NE      'DAPB2C').L15\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR14\n***********************************************************************\n* THIS OPERATION CODE ALLOWS FOR RE-USE  OF TIOT ENTRIES              *\n* IT IS USED BY THE TMP BEFORE DETACHING A TASK, AND BY ANY  TASK     *\n* WHICH ATTACHES SUB-TASKS                                            *\n***********************************************************************\n         SPACE 1\n.PR14    ANOP\nDAPB2C   DS    0D\nDA2CCD   DS    CL2      DAIR ENTRY CODE\nDA2CFLG  DS    H        FLAG FIELD\nDA2CTCB  DS    A        TCB ADDR OF DSE ENTRIES MARKED NOT IN USE\nDA2CDDN  DS    CL8        DDNAME\n         AGO   .L99\n.L15     AIF   ('&PL(&I)' NE      'DAPB24').L16\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR15\n***********************************************************************\n* THIS OPERATION CODE ALLOWS ALLOCATION OF A SPECIFIC DDNAME TO AN    *\n* ALREADY ALLOCATED DATA SET OR TO THE SPECIFIED DATA SET  IF THE     *\n* REQUESTED DDNAME IS NOT FOUND OR IS DYNAM                           *\n***********************************************************************\n         SPACE 1\n.PR15    ANOP\nDAPB24   DS    0D\nDA24CD   DS    CL2      DAIR ENTRY CODE\nDA24FLG  DS    X        FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\nDA24FPE  EQU   X'80'    FUNCT PERFORMED BUT ERROR INDICATED BY RETCD\nDA24DMY  EQU   X'08'    DDNAME REQUESTED IS A DUMMY\n         DS    X\nDA24DARC DS    H                  CATALDYNAMIC ALLOCATION RTRN CODE\nDA24CTRC DS    H                  CATALOG RETURN CODE AREA\nDA24PDSN DS    A        POINTER TO DSNAME TO BE SEARCHED IN DSE\nDA24DDN  DS    CL8      DDNAME TO BE SEARCHED IN DSE\nDA24UNIT DS    CL8      UNITNAME REQUESTED\nDA24SER  DS    CL8      VOLUME SERIAL NUMBER-PADDED W/BLANKS\nDA24BLK  DS    CL4      AVERAGE RECORD LENGTH\nDA24PQTY DS    CL4      PRIMARY SPACE QUANTITY\nDA24SQTY DS    CL4      SECONDARY SPACE QUANTITY\nDA24DQTY DS    CL4      DIRECTORY BLOCK QUANTITY\nDA24MNM  DS    CL8      MEMBER NAME\nDA24PSWD DS    CL8      PASSWORD\nDA24DSP1 DS    X        DATA SET STATUS FLGS(IF=0 OLD ASSUMED)\nDA24SHR  EQU   X'08'    DATA SET IS SHR\nDA24NEW  EQU   X'04'    DATA SET IS NEW\nDA24MOD  EQU   X'02'    DATA SET IS MOD\nDA24OLD  EQU   X'01'    DATA SET IS OLD\nDA24DPS2 DS    X        DATA SET DISPOSITION(IF=0 KEEP ASSUMED)\nDA24KEEP EQU   X'08'    DS DISP IS KEEP\nDA24DEL  EQU   X'04'    DS DISP IS DELETE\nDA24CAT  EQU   X'02'    DS DISP IS CATLG\nDA24UCAT EQU   X'01'    DS DISP IS UNCATALOG\nDA24DPS3 DS    X        DATA SET CONDITIONAL DISPOSITION\nDA24KEP  EQU   X'08'\nDA24DELE EQU   X'04'\nDA24CATL EQU   X'02'    DS DISP OF CATLG DESIRED\nDA24UNCT EQU   X'01'    DS DISP OF UNCATLG DESIRED\nDA24CTL  DS    X        FLAGS TO CONTROL ACTIONS TAKEN BY DAIR\nDA24TRKS EQU   X'80'\nDA24ABKL EQU   X'40'\nDA24UID  EQU   X'20'    USER ID IS TO BE PREFIXED\nDA24RLSE EQU   X'10'    RELEASE (RLSE) REQUESTED\nDA24PERM EQU   X'08'    DATA SET MUST BE SPECIFICALLY UNALLOCATED\nDA24DMMY EQU   X'04'    DUMMY                                    C99236\nDA24ATRL EQU   X'02'    ATTRIBUTE LIST SUPPLIED                  C99236\n         DS    CL3      RESERVED\nDA24DSO  DS    CL1      DSORG\nDA24ALN  DS    CL8      ATTR-LIST-NAME                           C99236\n         AGO   .L99\n.L16     AIF   ('&PL(&I)' NE      'DAPB28').L17\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR16\n***********************************************************************\n* THIS OPERATION CODE ALLOWS A LIST OF OPERATIONS TO BE PERFORMED     *\n* IF ANY OPERATION FAILS, PROCESSING STOPS AND THE ADDRESS OF THE     *\n* FAILED OPERATION IS RETURNED IN PFOP                                *\n***********************************************************************\n         SPACE 1\n.PR16    ANOP\nDAPB28   DS    0D\nDA28CD   DS    CL2      DAIR ENTRY CODE\nDA28NOP  DS    H        NUMB OF OPERATION PTR FIELDS WHICH FOLLOW\nDA28PFOP DS    A        POINTER TO FAILED OPERATION\n*                       OPERATION POINTERS ARE PLACED HERE\n         AGO   .L99\n.L17     AIF   ('&PL(&I)' NE      'DAPB30').L18\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR17\n***********************************************************************\n* THIS OPERATION CODE ALLOWS FOR ALLOCATION OF A SYSOUT DATA SET.     *\n***********************************************************************\n         SPACE 1\n.PR17    ANOP\nDAPB30   DS    0D\nDA30CD   DS    CL2      DAIR ENTRY CODE\nDA30FLG  DS    X        FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\nDA30FPE  EQU   X'80'    FUNCT PERFORMED BUT ERROR INDICATED BY RETCD\n         DS    X\nDA30DARC DS    H\n         DS    CL2      RESERVED\nDA30PDSN DS    A        POINTER TO DSNAME TO BE SEARCHED IN DSE\nDA30DDN  DS    CL8      DDNAME TO BE SEARCHED IN DSE\nDA30UNIT DS    CL8      UNITNAME REQUESTED\nDA30SER  DS    CL8      VOLUME SERIAL NUMBER-PADDED W/BLANKS\nDA30BLK  DS    CL4      AVERAGE RECORD LENGTH\nDA30PQTY DS    CL4      PRIMARY SPACE QUANTITY\nDA30SQTY DS    CL4      SECONDARY SPACE QUANTITY\nDA30PGNM DS    CL8      PROGRAM NAME -IF OMITTED MUST BE SET TO BLANKS\nDA30FORM DS    CL4      FORM NUMBER  -IF OMITTED MUST BE SET TO BLANKS\nDA30OCLS DS    CL2      OUTPUT CLASS - IGNORED AS OF OS VS/2 RELEASE 2\n*                                                               Y02670\n         DS    CL1      RESERVED\nDA30CTL  DS    X        FLAGS TO CONTROL ACTIONS TAKEN BY DAIR\nDA30TRKS EQU   X'80'\nDA30ABKL EQU   X'40'\nDA30UID  EQU   X'20'    USER ID IS TO BE PREFIXED\nDA30RLSE EQU   X'10'    RELEASE (RLSE) REQUESTED\nDA30PERM EQU   X'08'    DATA SET MUST BE SPECIFICALLY UNALLOCATED\nDA30DMMY EQU   X'04'\nDA30ATRL EQU   X'02'    ATTRIBUTE LIST SUPPLIED                  C99236\nDA30ALN  DS    CL8      ATTR-LIST-NAME                           C99236\n         AGO   .L99\n.L18     AIF   ('&PL(&I)' NE      'DAPB34').L19\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR18\n***********************************************************************\n* THIS DAIR PARAMETER BLOCK IS USED TO CAUSE :                        *\n*        1) A SEARCH  OF THE ATRCB CHAIN FOR A GIVEN NAME             *\n*        2) AN ATRCB TO BE PLACED ON THE ATRCB CHAIN                  *\n*        3) AN ATRCB TO BE REMOVED FROM THE ATRCB CHAIN               *\n***********************************************************************\n         SPACE 1\n.PR18    ANOP\nDAPB34   DS    0D\nDA34CD   DS    CL2       DAIR ENTRY CODE\nDA34FLG  DS    CL2       FLAG FIELD\nDA34FIND EQU   X'80'     ZERO IF ATTR-LIST-NAME NOT FOUND ONE IF FOUND\nDA34DARC DS    CL2       DYNAMIC ALLOCATION RETURN CODE\nDA34CTRL DS    CL1       CONTROL BYTES\nDA34SRCH EQU   X'80'     SEARCH ATTR.CHAIN FOR NAME\nDA34CHN  EQU   X'40'     CHAIN NEW ATTR.LIST\nDA34UNCH EQU   X'20'     REMOVE ATTR.LIST FROM CHAIN\n         DS    CL1       RESERVED\nDA34NAME DS    CL8       ATTRIBUTE-LIST-NAME\nDA34ADDR DS    CL4       ADDR OF DAIRACB\n         AGO   .L99\n.L19     AIF   ('&PL(&I)' NE      'DFPB').L20\n         SPACE 1\nDFPB     DS    0D\nDFPBCODE DS    0AL1      DEFAULT ENTRY CODE\nDFPBDSN  DS    A         PTR TO DSLENGTH AND DSNAME\nDFPB0C   EQU   X'0C'     ENTRY CODE '0C'\nDFPB08   EQU   X'08'     ENTRY CODE '08'\nDFPB04   EQU   X'04'     ENTRY CODE '04'\nDFPB00   EQU   X'00'     ENTRY CODE '00'\nDFPB8C   EQU   X'8C'     ENTRY CODE '8C'                       @YL026YB\nDFPB88   EQU   X'88'     ENTRY CODE '88'                       @YL026YB\nDFPB84   EQU   X'84'     ENTRY CODE '84'                       @YL026YB\nDFPB80   EQU   X'80'     ENTRY CODE '80'                       @YL026YB\nDFPBCNTL DS    0AL1      DEFAULT CONTROL\nDFPBPSCB DS    A         PTR TO PSCB\nDFPBUID  EQU   X'20'     USERID IS TO BE PREFIXED TO DSNAME\nDFPBRET  EQU   X'04'     RETURN ADDED QUALIFIER\nDFPBADD  EQU   X'02'     ADD SPECIFIED QUALIFIER\nDFPBMSG  EQU   X'01'     ISSUE MESSAGE\nDFPBLORC DS    0AL1      LOCATE RETURN CODE\nDFPBQUAL DS    A         PTR TO DEFAULT QUALIFIER\nDFPBCAT  DS    A         PTR TO USER CATALOG                   @YL026YB\nDFPBPSWD DS    A         PTR TO PASSWORD                       @YL026YB\n         AGO   .L99\n.L20     AIF   ('&PL(&I)' NE      'DFPL').L21\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR19\n***********************************************************************\n*    THE DEFAULT SERVICE ROUTINE PARAMETER LIST (DFPL) IS A LIST OF   *\n*    ADDRESSES PASSED FROM THE INVOKER TO DEFAULT VIA REGISTER 1      *\n***********************************************************************\n         SPACE 1\n.PR19    ANOP\nDFPL     DS    0D\nDFPLUPT  DS    A    PTR TO UPT\nDFPLECT  DS    A    PTR TO ECT\nDFPLECB  DS    A    PTR TO CP'S ECB\nDFPLDFPB DS    A    PTR TO DEFAULT PARAMETER BLOCK\n         AGO   .L99\n.L21     AIF   ('&PL(&I)' NE      'DSE').L22\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR20\n***********************************************************************\n*\n*\n*DSE IS USED TO MAINTAIN DATA SET INFORMATION, SUCH AS THE DDNAME--\n*DSNAME RELATIONSHIP. IT IS A SERIES OF CHAINED ELEMENTS EACH ONE\n*VARIABLE IN SIZE DEPENDENT ON THE INFORMATION PRESENT.\n*\n*\n***********************************************************************\n         SPACE 1\n.PR20    ANOP\nDSE      DS    0D\nDSEFORWD DS    A        ADDRESS OF NEXT DSE BLK(ZERO IN LAST DSE)\nDSEBCKWD DS    A        ADDRESS OF PREV. DSE BLK (ZERO IN FIRST DSE)\nDSEBLKSZ DS    1H       TOTAL NO. OF BYTES IN THIS DSE BLK INCLUDES\n*                       THIS FIELD AND TWO PRIOR FIELDS\nDSESTAT  DS    X        THE ALLOCATED STATUS OF THE DATA SET\n*        EQU   X'80'    RESERVED\n*        EQU   X'40'    RESERVED\n*        EQU   X'20'    RESERVED\n*        EQU   X'10'    RESERVED\nDSESHR   EQU   X'08'    SHR\nDSENEW   EQU   X'04'    NEW\nDSEMOD   EQU   X'02'    MOD\nDSEOLD   EQU   X'01'    OLD\nDSECNTRL DS    X        STATUS OF DATA SETS WHEN BITS ARE ON AS FOLLOWS\nDSEDYN   EQU   X'80'    DATA SET ALLOCATED DYNAMICALLY\nDSENUSED EQU   X'40'    DATA SET NOT IN USE\nDSEMEM   EQU   X'20'    MEMBER FIELD IS PRESENT IN THIS DSE\nDSEDTIOT EQU   X'10'    TIOT ENTRY IS DYNAM\nDSECON   EQU   X'08'    DATA SET CONCATENATED DYNAMICALLY\n*        EQU   X'04'    RESERVED\nDSEPERM  EQU   X'02'    DATA SET IS PERMAMENTLY ALLOCATED\n*        EQU   X'01'    RESERVED\nDSEDDNAM DS    CL8      DDNAME AS IT APPEARS IN TIOT\nDSETCBAD DS    A        ADD. OF TCB FOR CP WHICH SECURED DYNAMIC ALLOC.\nDSETTRPW DS    1F       RELATIVE TTR OF PASSWD FOR THIS FIELD IS ZERO.\nDSENDISP DS    X        NORMAL DISPOSITION IND. BY BIT SETTINGS:\n*        EQU   X'80'    RESERVED\n*        EQU   X'40'    RESERVED\n*        EQU   X'20'    RESERVED\n*        EQU   X'10'    RESERVED\nDSEKEP   EQU   X'08'    KEEP\nDSEDEL   EQU   X'04'    DELETE\nDSECAT   EQU   X'02'    CATLG\nDSEUCAT  EQU   X'01'    UNCATLG\nDSEADISP DS    CL1      ABNORMAL DISPOSITION IS IND. BY SETTING BITS\n*                       IN THIS FIELD THE SAME AS IN DSENDISP\nDSEAKEP  EQU   X'08'    KEEP\nDSEADEL  EQU   X'04'    DELETE\nDSEACAT  EQU   X'02'    CATALOG\nDSEAUCAT EQU   X'01'    UNCATALOG\nDSEDSORG DS    X        ORGANIZATION IND. BY FOLLOWING BITS:\nDSEIS    EQU   X'80'    INDEXED SEQUENTIAL\nDSEPS    EQU   X'40'    PHYSICAL SEQUENTIAL\nDSEDA    EQU   X'20'    DIRECT ORGANIZATION\n*        EQU   X'10'    RESERVED\n*        EQU   X'08'    RESERVED\n*        EQU   X'04'    RESERVED\nDSEPO    EQU   X'02'    PARTITIONED ORGANIZATION\nDSEU     EQU   X'01'    UNMOVABLE\nDSEDSLNG DS    CL1      LENGTH OF DATA SET NAME IN BYTES (1-44)\nDSEDSNAM DS    CL44     DATA SET NAME DSE DESCRIBES\n         AGO   .L99\n.L22     AIF   ('&PL(&I)' NE      'ECT').L23\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR21\n***********************************************************************\n*    THE ENVIRONMENT CONTROL TABLE (ECT) IS BUILT BY THE TMP AND      *\n*    STORED IN A NON-SHARED SUBPOOL. ITS FIELDS CAN BE MODIFIED       *\n*    BY A CP OR SERVICE RTN BUT NOT FREED.                            *\n***********************************************************************\n         SPACE 1\n.PR21    ANOP\nECT      DS    0D\nECTRCDF  DS    X        HIGH ORDER BIT INDICATES CP ABENDED\nECTRTCD  DS    CL3      RETURN CODE FROM LAST CP\n*                         (ABEND CODE IF ECTRCDF IS SET)\nECTIOWA  DS    A        ADDR OF I/O SERVICE ROUTINES WORK AREA\nECTMSGF  DS    X        HIGH ORDER BIT SET MEANS DELETE SECOND LEVEL\n*                         MESSAGE\nECTSMSG  DS    AL3      ADDR OF SECOND LEVEL MSG CHAIN\nECTPCMD  DS    CL8      PRIMARY COMMAND NAME\nECTSCMD  DS    CL8      SUBCOMMAND NAME\nECTSWS   DS    X        1 BYTE OF SWITCHES\nECTNOPD  EQU   X'80'    0 BIT ON= NO OPERANDS EXIST IN CMD BUFFER\n*        EQU   X'40'    RESERVED\nECTATRM  EQU   X'20'    CP TERMINATED BY TMP DETACH W/ STAE\nECTLOGF  EQU   X'10'    LOGON/OFF REQUESTED TMP TO LOGOFF USER\nECTNMAL  EQU   X'08'    NO USER MSGS TO RECVED AT LOGON\nECTNNOT  EQU   X'04'    NO BRDCST NOTICES TO BE RECVED AT LOGON\nECTBKGRD EQU   X'02'    BACKGROUND MODE\nECTATTN  EQU   X'01'    ATTENTION MODE FOR CLIST                Z30NQKM\nECTDDNUM DS    AL3      COUNTER FOR GENERATING TEMP DDNAMES\nECTUSER  DS    A        WORD RESERVED FOR INSTALLATION  USE\nECTBKPB  DS    A        ADDR OF BACKGROUND PARAMETER BLOCK\nECTSWS2  DS    X        EXTENDED FLAG FIELD\nECTDEFCS EQU   X'80'    DEFAULT DELETE CHARACTERS USED\nECTTABND EQU   X'40'    TEST SUBTASK ABENDED\n*        EQU   X'20'    RESERVED\n*        EQU   X'10'    RESERVED\n*        EQU   X'08'    RESERVED\n*        EQU   X'04'    RESERVED\n*        EQU   X'02'    RESERVED\n*        EQU   X'01'    RESERVED\n         DS    CL(3)    RESERVED\n         DS    A        RESERVED\n         DS    A        RESERVED\n         DS    A        RESERVED\n         AGO   .L99\n.L23     AIF   ('&PL(&I)' NE 'GENERFAIL').L23A\n         IKJEFFGF ,               GENERAL FAIL AREA\n         AGO   .L99\n.L23A    AIF   ('&PL(&I)' NE      'GTPB').L24\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR22\n***********************************************************************\n*    THE GETLINE PARAMETER BLOCK (GTPB) IS POINTED TO BY THE          *\n*    PARAMETER LIST PASSED FROM THE INVOKER TO GETLINE.  GETLINE      *\n*    USES IT FOR CONTROL AS WELL AS RETURNING INFORMATION             *\n***********************************************************************\n.PR22    ANOP\n         SPACE 1\nGTPB     DS    0D\n         DS    CL4      INTERNAL GETLINE USAGE\nGTPBIBUF DS    A        ADDR OF OBTAINED INPUT LINE\n         AGO   .L99\n.L24     AIF   ('&PL(&I)' NE      'IOPL').L25\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR23\n***********************************************************************\n*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *\n*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *\n*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *\n***********************************************************************\n.PR23    ANOP\n         SPACE 1\nIOPL     DS    0D\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n         AGO   .L99\n.L25     AIF   ('&PL(&I)' NE      'LSD').L26\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR24\n***********************************************************************\n*    THE (STORAGE) LIST SOURCE DESCRIPTOR (LSD) IS POINTED TO BY THE  *\n*    STPB.  IT IS SET UP BY THE INVOKER OF STACK TO DESCRIBE THE      *\n*    IN STORAGE LIST. IT WILL BE FREED BY STACK WHEN THE LIST HAS     *\n*   BEEN PROCESSED OR WHEN A 'DELETE' FUNCTION HAS BEEN REQUESTED     *\n***********************************************************************\n         SPACE 1\n.PR24    ANOP\nLSD      DS    0D\nLSDADATA DS    A        PTR TO IN STORAGE LIST\nLSDRCLEN DS    H        REC LENGTH -0 IF VARIABLE LEN RECFM\nLSDTOTLN DS    H        TOTAL LEN OF IN STOR LIST(AMT OF CORE TO FREE)\nLSDANEXT DS    A        PTR TO NEXT REC O BE PROCESSED-INITIALIZED TO\n*                       FIRST REC BY INVOKER-UPDATED BY GETLINE/PUTGET\nLSDEXEC  DS    CL4      ADDRESS OF THE EXEC COMMAND DATA BLOCK\n         AGO   .L99\n.L26     AIF   ('&PL(&I)' NE      'PGPB').L27\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR25\n***********************************************************************\n*    THE PUTGET PARAMETER BLOCK (PGPB) IS POINTED TO BY THE LIST      *\n*    PASSED TO PUTGET.  PUTGET USES IT FOR CONTROL AS WELL AS         *\n*    RETURNING INFORMATION.                                           *\n***********************************************************************\n         SPACE 1\n.PR25    ANOP\nPGPB     DS    0D\n         DS    CL12     INTERNAL TO GETLINE/PUTLINE\nPGPBIBUF DS    A        PTR TO OBTAINED INPUT LINE\n         AGO   .L99\n.L27     AIF   ('&PL(&I)' NE      'PPL').L28\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR26\n***********************************************************************\n*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *\n*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *\n***********************************************************************\n         SPACE 1\n.PR26    ANOP\nPPL      DS    0D\nPPLUPT   DS    A        PTR TO UPT\nPPLECT   DS    A        PTR TO ECT\nPPLECB   DS    A        PTR TO CP'S ECB\nPPLPCL   DS    A        PTR TO PCL\nPPLANS   DS    A        PTR TO ANS PLACE\nPPLCBUF  DS    A        PTR TO CMD BUFFER\nPPLUWA   DS    A        PTR TO USER WORK AREA (FOR VALIDITY CK RTNS)\n         AGO   .L99\n.L28     AIF   ('&PL(&I)' NE      'PSCB').L29\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR27\n***********************************************************************\n*    THE PROTECTED STEP CONTROL BLOCK IS CONSTRUCTED BY LOGON AND\n*    FILLED IN FROM THE UADS .  A FIXED LENGTH TABLE WITH ATTRIBUTE\n*    AND ACCOUNTING FIELDS, THE PSCB IS USED TO MAINTAIN USER ATTRI-\n*    BUTES AND ACCOUNTING DATA ON A USERID BASIS.  THE ADDRESS OF PSCB\n*    IS PASSED TO THE TMP.  HENCE IT IS AN EXTERNAL INTERFACE\n***********************************************************************\n         SPACE 1\n.PR27    ANOP\nPSCB     DS    0F\nPSCBUSER DS    CL7      USERID PADDED RIGHT WITH BLANKS\nPSCBUSRL DS    CL1      LENGTH OF USERID\nPSCBGPNM DS    CL8      ESOTERIC GROUP NAME INIT BY LOGON FROM UADS\n*                       USED BY DYN ALLOC WHEN UNITNAME NOT SPECIFIED\n*                       BUT IS REQUIRED\nPSCBATR1 DS    X        A 15 BIT STRING OF USER ATTRIBUTES\nPSCBCTRL EQU   X'80'    OPERATOR COMMAND USER\nPSCBACCT EQU   X'40'    ACCOUNT  COMMAND USER\nPSCBJCL  EQU   X'20'    SUBMIT   COMMAND USER\nPSCBVMNT EQU   X'10'    CNTL VOL MOUNT AUTH                      Y02669\nPSCBATTN EQU   X'08'    LINE DELETE CHAR IS ATTENTION            Y02669\nPSCBRCVR EQU   X'04'    EDIT RECOVER/NORECOVER              @Z40DQKV\n* BITS 6 - 15           RESERVED FOR IBM USE\n         DS    X        RESERVED\nPSCBATR2 DS    X        A 15 BIT STRING RESERVED FOR INSTALLATION USE\n         DS    X\nPSCBLTIM DS    F        DOUBLEWORD FOR LOGON TIME               Y02669\nPSCBLTI2 DS    F        IN STORE CLOCK UNITS                    Y02669\nPSCBSUBH DS    CL1      SUBMIT HOLD CLASS                      @DZ04005\nPSCBSUBC DS    CL1      SUBMIT CLASS                           @DZ04005\nPSCBSUBM DS    CL1      SUBMIT MSGCLASS                        @DZ04005\nPSCBSOUT DS    CL1      SYSOUT CLASS                           @DZ04005\n         DS    2F       RESERVED\nPSCBDEST DS    CL8      DEST FOR SYSOUT DATA SETS               Y02669\nPSCBRLGB DS    A        PTR TO RELOGON BUFFER\nPSCBUPT  DS    A        PTR TO USER PROFILE TABLE\nPSCBUPTL DS    H        LENGTH OF UPT\nPSCBCHAR DS    CL1      USER'S CHARACTER DELETE CHARACTER       Y02669\nPSCBLINE DS    CL1      USER'S LINE DELETE CHARACTER            Y02669\nPSCBRSZ  DS    A        REGION SIZE REQUESTED IN 2K UNITS\nPSCBU    DS    CL8      RESERVED FOR INSTALLATION USE\n         AGO   .L99\n.L29     AIF   ('&PL(&I)' NE      'PTPB').L30\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR28\n***********************************************************************\n*    THE PUTLINE PARAMETER BLOCK (PTPB) IS POINTED TO BY THE PARAM.   *\n*    LIST PASSED TO PUTLINE.  IT IS USED TO RETURN PERTINENT INFO.    *\n*    AS WELL AS CONTROL PUTLINE FUNCTIONS                             *\n***********************************************************************\n         SPACE 1\n.PR28    ANOP\nPTPB     DS    0F\n         DS    CL4      INTERNAL PUTLINE USAGE\nPTPBOPUT DS    A        ADDRESS OF OUTPUT LINE DESCRIPTOR OR DATA LINE\nPTPBFLN  DS    A        PTR TO FORMATTED LINE RETURNED WHEN OUTPUT=\n*                       ADDR,FORMAT) IS SPECIFIED\n         AGO   .L99\n.L30     AIF   ('&PL(&I)' NE      'RLGB').L30A\n         IKJRLGB ,DSECT=NO\n         AGO   .L99\n.L30A    AIF   ('&PL(&I)' NE      'RPL').L30B\nRPL      DS    0D\nRPLIDWD  EQU   *                               RPL IDENTIFICATION WORD\nRPLID    DS    XL1                             RPL IDENTIFIER\nRPLIDD   EQU   X'00'                           IDENTIFIER VALUE - X'00'\nRPLSTYP  DS    XL1                             RPL SUBTYPE - SET TO\n*                                              X'00' FOR DATA\n*                                              MANAGEMENT AND X'0D'\n*                                              FOR JECS\nRPLSVSAM EQU   X'10'                           VSAM SUBTYPE     X04SVHS\nRPLSVRP  EQU   X'11'                           VRP SUBTYPE      X04SVHS\nRPLSVTAM EQU   X'20'                           VTAM SUBTYPE     X04SVHS\nRPLS3540 EQU   X'40'                           3540 SUBTYPE     X04SVHS\nRPLCRID  EQU   X'FF'                           CRPL ID (VTAM)    X03004\nRPLREQ   DS    XL1                             RPL REQUEST TYPE\nRPLGET   EQU   X'00'                           GET\nRPLPUT   EQU   X'01'                           PUT\nRPLPOINT EQU   X'03'                           POINT\nRPLERASE EQU   X'05'                           ERASE\nRPLJSFMT EQU   X'07'                           JES FORMAT REQUEST\n*        THE FOLLOWING CODES ARE NOT STORED IN RPLREQ, BUT ARE\n*        AVAILABLE IN REGISTER 0 WHEN THE FUNCTION IS ENTERED\n*        AND STORED IN RPLREQ DURING PROCESSING OF THE FUNCTION.\nRPLCHECK EQU   X'02'                           CHECK\nRPLENDRE EQU   X'04'                           ENDREQ\nRPLVERIF EQU   X'06'                           VERIFY\nRPLIMPRT EQU   X'07'                           IMPORT\nRPLPFMTD EQU   X'08'                           DATA PREFORMAT\nRPLPFMTI EQU   X'09'                           INDEX PREFORMAT\nRPLFRCIO EQU   X'0A'                           FORCE I/O\nRPLWRITE EQU   X'11'                           WRITE(VTAM)       X03004\nRPLRESET EQU   X'12'                           RESET(VTAM)       X03004\nRPLTERM  EQU   X'13'                           TERMRPL         @ZA32757\nRPLDO    EQU   X'13'                           DO(VTAM)          X03004\nRPLQUISE EQU   X'15'                           SETLOGON(VTAM)    X03004\nRPLSMLGO EQU   X'16'                           SIMLOGON(VTAM)    X03004\nRPLOPNDS EQU   X'17'                           OPNDST(VTAM)      X03004\nRPLCHNG  EQU   X'19'                           CHANGE(VTAM)      X03004\nRPLINQIR EQU   X'1A'                           INQUIRE(VTAM)     X03004\nRPLINTPT EQU   X'1B'                           INTRPRET(VTAM)    X03004\nRPLREAD  EQU   X'1D'                           READ(VTAM)        X03004\nRPLSLICT EQU   X'1E'                           SOLICIT(VTAM)     X03004\nRPLCLOSE EQU   X'1F'                           CLSDST(VTAM)      X03004\nRPLCLACB EQU   X'21'                           CLOSEACB(VTAM)    X03004\nRPLSNDCD EQU   X'22'                           SEND(VTAM)       X3004BS\nRPLRCVCD EQU   X'23'                           RECEIVE(VTAM)    X3004BS\nRPLRSRCD EQU   X'24'                           RESETSR(VTAM)    X3004BS\nRPLSSCCD EQU   X'25'                           SESSIONC(VTAM)   X3004BS\nRPLSDCMD EQU   X'27'                           SENDCMD(VTAM)   @Z40BHUC\nRPLRVCMD EQU   X'28'                           RCVCMD(VTAM)    @Z40BHUC\nRPLTREQS EQU   X'29'                           REQSESS(VTAM)   @G40AKCM\nRPLTOPNS EQU   X'2A'                           OPNSEC(VTAM)    @G40AKCM\nRPLTCLSS EQU   X'2B'                           CLSSEC(VTAM)    @G40AKCM\nRPLTRMS  EQU   X'2C'                           TRMSESS(VTAM)   @G40AKCM\nRPLLEN   DS    0XL1                            LENGTH OF THIS RPL\nRPLLEN2  DS    XL1                             ALTERNATE NAME FOR\n*                                              RPLLEN            X03004\nRPLPLHPT DS    A                               POINTER TO PLACEHOLDER\nRPLECB   DS    A                               INTERNAL ECB OR\n*                                              POINTER TO EXTERNAL ECB\n*        ECB FLAGS\nRPLWAIT  EQU   X'80'                           A REQUEST HAS BEEN\n*                                              ISSUED\nRPLPOST  EQU   X'40'                           THE REQUEST HAS\n*                                              COMPLETED\nRPLFDBWD DS    0XL4                            FEEDBACK WORD    X04SVHS\nRPLSTAT  DS    XL1                             CURRENT RPL STATUS\nRPLFDBK  DS    0XL3                            ERROR FEEDBACK\nRPLRTNCD DS    0XL1                            RPL RETURN CODE\nRPLNOERR EQU   X'00'                           NORMAL RETURN\nRPLBLKER EQU   X'04'                           INVALID CONTROL BLOCK\nRPLCBLKE EQU   X'04'                           ALTERNATE NAME FOR\n*                                              RPLBLKER          X03004\nRPLLOGER EQU   X'08'                           ILLOGICAL REQUEST\nRPLLOGIC EQU   X'08'                           ALTERNATE NAME FOR\n*                                              RPLLOGER          X03004\nRPLPHYER EQU   X'0C'                           PHYSICAL I/O ERROR\nRPLPHYSC EQU   X'0C'                           ALTERNATE NAME FOR\n*                                              RPLPHYER          X03004\nRPLNGRCC EQU   X'10'                           A CONDITIONAL COMMAND\n*                                              WAS ISSUED BUT THE\n*                                              CONDITION WAS NOT\n*                                              MET(VTAM)         X03004\nRPLSPECC EQU   X'14'                           A TEMPORARY OUT-OF-CORE\n*                                              SITUATION EXISTS(VTAM)\n*                                                                X03004\nRPLCMDRT EQU   X'18'                           THE REQUEST WAS\n*                                              CANCELLED BY THE RESET\n*                                              COMMAND(VTAM)     X03004\nRPLPURGE EQU   X'1C'                           THE COMMAND WAS\n*                                              PURGED(VTAM)      X03004\nRPLVTMNA EQU   X'20'                           VTAM IS NOT ACTIVE(VTAM)\n*                                                                X03004\nRPLSYERR EQU   X'24'                           SYSTEM ERROR(VTAM)X03004\nRPLDEVDC EQU   X'28'                           DIAL LINE IS\n*                                              DISCONNECTED(VTAM)X03004\nRPLLIMEX EQU   X'2C'                           RESPONSE LIMIT\n*                                              EXCEEDED(VTAM)   X3004BS\nRPLEXRQ  EQU   X'30'                           EXCEPTION REQUEST\n*                                              RECEIVED(VTAM)   X3004BS\nRPLEXRS  EQU   X'34'                           EXCEPTION RESPONSE\n*                                              RECEIVED(VTAM)   X3004BS\nRPLNOIN  EQU   X'38'                           NO INPUT\n*                                              AVAILABLE(VTAM)  X3004BS\nRPLVABND EQU   X'3C'                           VTAM ENCOUNTERED ABEND\n*                                              CONDITION       @XM08790\nRPLERREG DS    XL1                             ALTERNATE NAME FOR\n*                                              RPLRTNCD\nRPLCNDCD DS    0XL2                            RPL CONDITION CODE\nRPLCMPON DS    0XL1                            COMPONENT ISSUING\n*                                              CODE(VSAM)\nRPLFDB2  DS    XL1                             REASON CODE(VTAM) X03004\nRPLERLK  EQU   X'80'                           ERROR LOCK SET    X03004\nRPLRVID  EQU   X'40'                           RVI RECEIVED      X03004\nRPLATND  EQU   X'20'                           ATTN RECEIVED     X03004\nRPLDVUNS EQU   X'10'                           DEVICE UNUSABLE   X03004\nRPLIOERR EQU   X'08'                           I/O ERROR TYPE- 0=INPUT/\n*                                              1=OUTPUT          X03004\nRPLDLGFL EQU   X'04'                           DIALOG INIT FAILED\n*                                                                X03004\nRPLCUERR EQU   X'02'                           CONTROL UNIT FAILURE\n*                                                                X03004\nRPLSTSAV EQU   X'01'                           SENSE BYTES PRESENT\n*                                                                X03004\nRPLERRCD DS    0XL1                            ERROR CODE(VSAM)\nRPLFDB3  DS    XL1                             DATA FLAGS(VTAM)  X03004\nRPLUINPT EQU   X'80'                           UNSOLICITED INPUT X03004\nRPLSV32  EQU   X'40'                           RESERVED          X03004\nRPLREOB  EQU   X'20'                           END OF BLOCK      X03004\nRPLREOM  EQU   X'10'                           END OF MESSAGE    X03004\nRPLREOT  EQU   X'08'                           END OF TRANSMISSION\n*                                                                X03004\nRPLLGFRC EQU   X'04'                           LOGOFF DETECTED   X03004\nRPLRLG   EQU   X'02'                           LEADING GRAPHICS\n*                                              RECEIVED          X03004\nRPLRDSOH EQU   X'01'                           START OF HEADER (SOH)\n*                                              RECEIVED          X03004\nRPLKEYLE DS    0H                              KEY LENGTH (PROC=GEN)\nRPLKEYL  DS    H                               ALTERNATE NAME FOR\n*                                              RPLKEYLE\nRPLSTRID DS    H                               CCW STRING IDENTIFIER\nRPLCCHAR DS    A                               POINTER TO CONTROL\n*                                              CHARACTER FOR UNIT\n*                                              RECORD DEVICES\nRPLDACB  DS    A                               POINTER TO DATA ACB\nRPLTCBPT DS    A                               POINTER TO TCB\nRPLAREA  DS    A                               POINTER TO AREA\n*                                              CONTAINING DATA RECORD\nRPLARG   DS    0A                              POINTER TO SEARCH\n*                                              ARGUMENT; POINTER TO\n*                                              RELATIVE ADDRESS FOR\n*                                              POINT OPERATION; POINTER\n*                                              TO SETPRT PARMLIST\nRPLSAF   DS    XL2                             SOURCE ADDRESS\n*                                              FIELD(VTAM)       X03004\nRPLDAF   DS    XL2                             DESTINATION ADDRESS\n*                                              FIELD(VTAM)       X03004\nRPLOPTCD DS    0BL4                            OPTION CODES\nRPLOPT1  DS    BL1                             OPTION BYTE 1\nRPLLOC   EQU   X'80'                           LOCATE MODE; MOVE MODE\n*                                              IF 0\nRPLDIR   EQU   X'40'                           DIRECT ACCESS\nRPLSEQ   EQU   X'20'                           SEQUENTIAL ACCESS\nRPLSKP   EQU   X'10'                           SKIP SEQUENTIAL ACCESS\nRPLASY   EQU   X'08'                           ASYNCHRONOUS PROCESSING\nRPLKGE   EQU   X'04'                           SEARCH KEY GT/EQ\nRPLGEN   EQU   X'02'                           GENERIC KEY REQUEST\nRPLECBSW EQU   X'01'                           EXTERNAL ECB\nRPLECBIN EQU   X'01'                           ALTERNATE NAME FOR\n*                                              RPLECBSW          X03004\nRPLOPT2  DS    BL1                             OPTION BYTE 2\nRPLKEY   EQU   X'80'                           KEYED ACCESS\nRPLADR   EQU   X'40'                           ADDRESSED ACCESS\nRPLADD   EQU   X'40'                           ALTERNATE NAME FOR\n*                                              RPLADR\nRPLCNV   EQU   X'20'                           CONTROL INTERVAL ACCESS\nRPLBWD   EQU   X'10'                           FWD=0/BWD=1      X04SVHS\nRPLLRD   EQU   X'08'                           ARD=0/LRD=1      X04SVHS\nRPLWAITX EQU   X'04'                           AYNCH PROC WAIT @ZA07549\nRPLUPD   EQU   X'02'                           UPDATE\nRPLNSP   EQU   X'01'                           NOTE STRING POSITION\nRPLOPT3  DS    BL1                             OPTION BYTE 3\nRPLEODS  EQU   X'80'                           END OF USER SYSOUT\nRPLSFORM EQU   X'40'                           SPECIAL FORM ON REMOTE\n*                                              PRINTER\nRPLBLK   EQU   X'20'                           BLOCKED UCS DATA CHECKS\n*                                              FIXED BLOCK PROCESSING\nRPLVFY   EQU   X'10'                           VERIFY UCS/FCB\n*                                              INFORMATION\nRPLFLD   EQU   X'08'                           LOAD UCS BUFFER IN\n*                                              FOLD MODE\nRPLFMT   EQU   X'02'                           FCB LOAD\nRPLFRMT  EQU   X'06'                           UCS LOAD IF 00\nRPLALIGN EQU   X'01'                           ALIGN FCB BUFFER LOADING\nRPLOPT4  DS    BL1                             OPTCD BYTE 4\nRPLENDTR EQU   X'80'                           3800 END OF TRANSMISSION\n*                                                              @Z40SVHS\nRPLMKFRM EQU   X'40'                           3800 MARK FORM  @Z40SVHS\nRPLNXTRP DS    0A                              POINTER TO NEXT RPL\nRPLCHAIN DS    A                               ALTERNATE NAME FOR\n*                                              RPLNXTRP\nRPLRLEN  DS    A                               LENGTH OF RECORD\nRPLBUFL  DS    A                               USER BUFFER LENGTH\nRPLOPTC2 DS    0XL4                            VTAM OPTIONS      X03004\nRPLOPT5  DS    XL1                             OPTION BYTE 5     X03004\nRPLDLGIN EQU   X'80'                           CONTINUE READING IN\n*                                              SPECIFIC TERMINAL MODE;\n*                                              IF 0, CONTINUE READING\n*                                              IN ANY TERMINAL MODE\n*                                                                X03004\nRPLSSNIN EQU   X'40'                           CONTINUE DIALOG WITH THE\n*                                              SAME TERMINAL; IF 0, END\n*                                              DIALOG WITH THAT\n*                                              TERMINAL          X03004\nRPLPSOPT EQU   X'20'                           PASS TERMINAL TO\n*                                              REQUESTING APPLICATION;\n*                                              IF 0, MAKE TERMINAL\n*                                              AVAILABLE TO ANY\n*                                              APPLICATION       X03004\nRPLNERAS EQU   X'10'                           WRITE TO 3270 BUT DO NOT\n*                                              ERASE WHAT IS CURRENTLY\n*                                              DISPLAYED         X03004\nRPLEAU   EQU   X'08'                           WRITE TO 3270 AND ERASE\n*                                              UNPROTECTED FIELDSX03004\nRPLERACE EQU   X'04'                           WRITE TO 3270 AND ERASE\n*                                              CURRENT DISPLAY   X03004\nRPLNODE  EQU   X'02'                           READ FROM ANY TERMINAL;\n*                                              IF 0, READ FROM A\n*                                              SPECIFIC TERMINAL X03004\nRPLWROPT EQU   X'01'                           CONVERSATIONAL MODE;\n*                                              IF 0, NON-CONVERSATIONAL\n*                                              MODE              X03004\nRPLOPT6  DS    XL1                             OPTION BYTE 6     X03004\nRPLEOB   EQU   X'80'                           WRITE A BLOCK OF DATA\n*                                                                X03004\nRPLEOM   EQU   X'40'                           WRITE THE LAST BLOCK\n*                                              OF A MESSAGE      X03004\nRPLEOT   EQU   X'20'                           WRITE THE LAST BLOCK\n*                                              OF THE TRANSMISSION\n*                                                                X03004\nRPLCOND  EQU   X'10'                           DO NOT STOP OPERATION\n*                                              IF STARTED (USED WITH\n*                                              RESET REQUEST)    X03004\nRPLNCOND EQU   X'08'                           STOP OPERATION\n*                                              IMMEDIATELY (USED WITH\n*                                              RESET REQUEST)    X03004\nRPLLOCK  EQU   X'04'                           RESET ERROR LOCK TO\n*                                              UNLOCKED STATUS   X03004\nRPLRSV67 EQU   X'02'                           RESERVED          X03004\nRPLRSV68 EQU   X'01'                           RESERVED          X03004\nRPLOPT7  DS    XL1                             OPTION BYTE 7     X03004\nRPLCNALL EQU   X'80'                           ALL TERMINALS IN OPNDST\n*                                              LIST MUST BE AVAILABLE\n*                                              BEFORE ANY ARE CONNECTED\n*                                                                X03004\nRPLCNANY EQU   X'40'                           CONNECT ANY ONE TERMINAL\n*                                              IN OPNDST LIST    X03004\nRPLCNIMM EQU   X'20'                           RESERVED          X03004\nRPLQOPT  EQU   X'10'                           QUEUE THE OPNDST REQUEST\n*                                              IF IT CANNOT BE\n*                                              SATISFIED IMMEDIATELY;\n*                                              IF 0, REJECT THE OPNDST\n*                                              REQUEST IF IT CANNOT BE\n*                                              SATISFIED IMMEDIATELY\n*                                                                X03004\nRPLTPOST EQU   X'08'                           RPL ALREADY UNDER PSS\n*                                                              @XM08790\nRPLRLSOP EQU   X'04'                           SCHEDULE THE RELREQ EXIT\n*                                              OF THE REQUIRED TERMINAL\n*                                              IMMEDIATELY; IF 0,\n*                                              EITHER WAIT FOR THE\n*                                              TERMINAL TO BECOME\n*                                              AVAILABLE OR REJECT THE\n*                                              REQUEST IF THE TERMINAL\n*                                              IS BUSY(DEPENDS ON THE\n*                                              SETTING OF RPLQOPT)\n*                                                                X03004\nRPLTCRNO EQU   X'02'                           CLOSE IN PROCESS FOR PO\n*                                              INTERFACE       @Z40BHUC\nRPLRSV78 EQU   X'01'                           RESERVED          X03004\nRPLOPT8  DS    XL1                             OPTION BYTE 8     X03004\nRPLODACQ EQU   X'80'                           THE APPLICATION REQUIRES\n*                                              A SPECIFIC TERMINAL\n*                                                                X03004\nRPLODACP EQU   X'40'                           THE APPLICATION WILL\n*                                              ACCEPT ANY TERMINAL\n*                                              DESIRING LOGON    X03004\nRPLODPRM EQU   X'20'                           A SPECIFIC TERMINAL IS\n*                                              TO BE PREEMPTED EVEN\n*                                              THOUGH ANOTHER\n*                                              APPLICATION IS HOLDING\n*                                              IT (TOLTEP ONLY)  X03004\nRPLPEND  EQU   X'10'                           PREEMPT THE TERMINAL\n*                                              AFTER ALL PENDING\n*                                              OPERATIONS ARE COMPLETED\n*                                              (TOLTEP ONLY)     X03004\nRPLSESS  EQU   X'08'                           PREEMPT THE TERMINAL\n*                                              AFTER COMPLETION OF THE\n*                                              CURRENT DIALOG SESSION\n*                                              (TOLTEP ONLY)     X03004\nRPLACTV  EQU   X'04'                           PREEMPT THE TERMINAL IF\n*                                              CONNECTED BUT NOT BUSY\n*                                              (TOLTEP ONLY)     X03004\nRPLUNCON EQU   X'02'                           PREEMPT THE TERMINAL\n*                                              IMMEDIATELY\n*                                              (TOLTEP ONLY)     X03004\nRPLRSV88 EQU   X'01'                           RESERVED          X03004\nRPLRBAR  DS    0CL8                            RBA RETURN LOCATION\nRPLAIXPC DS    CL2                             AIX POINTER COUNTX04SVHS\nRPLAIXID DS    XL1                             AIX POINTER TYPE X04SVHS\nRPLAXPKP EQU   X'80'                           RBA=1/PRIME=0\n         DS    XL1                             RESERVED         X04SVHS\nRPLDDDD  DS    CL4                             RETURN AREA FOR\n*                                              RELATIVE BYTE ADDRESS\nRPLEXTDS DS    0XL1                            EXIT DEFINITIONS@Z9999DT\nRPLEXTD1 DS    XL1                             ALTERNATE NAME FOR\n*                                              RPLEXTDS          X03004\nRPLEXSCH EQU   X'80'                           AN EXIT HAS BEEN\n*                                              SCHEDULED         X03004\nRPLNEXIT EQU   X'40'                           NO EXIT WAS SPECIFIED\n*                                                                X03004\nRPLEXIT  EQU   X'20'                           ASYNCH EXIT     @XM01127\nRPLTCRYP EQU   X'08'                           IF ON, ENCRYPTION\n*                                              FEATURE REQ     @G40AKSL\nRPLNIB   EQU   X'04'                           THE RPLARG FIELD\n*                                              CONTAINS A POINTER\n*                                              TO THE NIB        X03004\nRPLBRANC EQU   X'02'                           USE A BRANCH ENTRY\n*                                              TO THE MACRO      X03004\nRPLACTIV DS    XL1                             ACTIVE INDICATOR -\n*                                              X'FF' INDICATES ACTIVE;\n*                                              X'00' INDICATES INACTIVE\n*                                                                X03004\nRPLEMLEN DS    H                               LENGTH OF THE ERROR\n*                                              MESSAGE AREA\nRPLERMSA DS    A                               POINTER TO THE ERROR\n*                                              MESSAGE AREA\n         AGO   .L99\n.L30B    AIF   ('&PL(&I)' NE 'SVC99' AND '&PL(&I)' NE 'SVC99BLK').L31\n***********************************************************************\n*                SVC 99 INPUT REQUEST BLOCK\n***********************************************************************\nS99RBP   DS     0F\nS99RBPTR DS     F                      REQUEST BLOCK POINTER\nS99RBPND EQU    X'80'                  LAST POINTER INDICATOR\nS99RB    DS     0F                     REQUEST BLOCK\nS99RBLN  DS     CL1                    LENGTH OF REQUEST BLOCK\nS99VERB  DS     CL1                    VERB CODE\nS99VRBAL EQU    X'01'                  ALLOCATION\nS99VRBUN EQU    X'02'                  UNALLOCATION\nS99VRBCC EQU    X'03'                  CONCATENATION\nS99VRBDC EQU    X'04'                  DECONCATENATION\nS99VRBRI EQU    X'05'                  REMOVE IN-USE\nS99VRBDN EQU    X'06'                  DDNAME ALLOCATION\nS99VRBIN EQU    X'07'                  INFORMATION RETRIEVAL\nS99FLAG1 DS     0CL2                   FLAGS\nS99FLG11 DS     CL1                    FIRST FLAGS BYTE\nS99ONCNV EQU    X'80'                  ALLOC FUNCTION-DO NOT USE AN\n*                                      EXISTING ALLOCATION THAT DOES\n*                                      NOT HAVE THE CONVERTIBLE\n*                                      ATTRIBUTE TO SATISFY A REQUEST\nS99NOCNV EQU    X'40'                  ALLOC FUNCTION-DO NOT USE AN\n*                                      EXISTING ALLOCATION TO SATISFY\n*                                      THE REQUEST\nS99NOMNT EQU    X'20'                  ALLOC FUNCTION-DO NOT MOUNT\n*                                      VOLUMES OR CONSIDER OFFLINE\n*                                      UNITS (THIS FLAG OVERRIDES\n*                                      S99MOUNT AND S99OFFLN BELOW)\nS99JBSYS EQU    X'10'                  ALLOC FUNC-JOB RELATED SYSOUT\nS99CNENQ EQU    X'08'                  ALL FUNCTIONS-ISSUE A   @ZA32641\n*                                      CONDITIONAL ENQ ON TIOT @ZA32641\n*                                      RESOURCE. IF NOT        @ZA32641\n*                                      AVAILABLE, RETURN AN    @ZA32641\n*                                      ERROR CODE TO USER.     @ZA32641\nS99FLG12 DS     CL1                    SECOND BYTE OF FLAGS\nS99RSC   DS     0CL4                   REASON CODE FIELDS\nS99ERROR DS     XL2                    ERROR REASON CODE\nS99INFO  DS     XL2                    INFORMATION REASON CODE\nS99TXTPP DS     F                      ADDR OF LIST OF TEXT UNIT PTRS\nS99RSV01 DS     F                      RESERVED\nS99FLAG2 DS     0CL4                   FLAGS FOR AUTHORIZED FUNCTIONS\nS99FLG21 DS     CL1                    FIRST BYTE OF FLAGS\nS99WTVOL EQU    X'80'                  ALLOC FUNCTION-WAIT FOR\n*                                      VOLUMES\nS99WTDSN EQU    X'40'                  ALLOC FUNCTION-WAIT FOR DSNAME\nS99NORES EQU    X'20'                  ALLOC FUNCTION-DO NOT DO\n*                                      DATA SET RESERVATION\nS99WTUNT EQU    X'10'                  ALLOC FUNCTION-WAIT FOR UNITS\nS99OFFLN EQU    X'08'                  ALLOC FUNCTION-CONSIDER OFFLINE\n*                                      UNITS\nS99TIONQ EQU    X'04'                  ALL FUNCTIONS-TIOT ENQ ALREADY\n*                                      DONE\nS99CATLG EQU    X'02'                  ALLOC FUNCTION-SET SPECIAL\n*                                      CATALOG DATA SET INDICATORS\nS99MOUNT EQU    X'01'                  ALLOC FUNCTION-MAY MOUNT VOLUME\nS99FLG22 DS     CL1                    SECOND BYTE OF FLAGS\nS99UDEVT EQU    X'80'                  ALLOCATION FUNCTION-UNIT NAME\n*                                      PARM IS A DEVICE TYPE\nS99PCINT EQU    X'40'                  ALLOC FUNCTION-ALLOC    @Y30QPPB\n*                                      PRIVATE CATALOG TO      @Y30QPPB\n*                                      INITIATOR               @Y30QPPB\nS99FLG23 DS     CL1                    THIRD BYTE OF FLAGS\nS99FLG24 DS     CL1                    FOURTH BYTE OF FLAGS\nS99RBEND EQU    *                      END MARKER\n***********************************************************************\n* SVC 99 TEXT UNIT POINTER LIST\n***********************************************************************\nS99TUPL  DS     0F                     TEXT UNIT POINTER LIST\nS99TUPTR DS     F                      TEXT UNIT POINTER\nS99TUPLN EQU    X'80'                  LAST TEXT UNIT POINTER IN LIST\n***********************************************************************\n* SVC 99 TEXT UNIT\n***********************************************************************\nS99TUNIT DS     0X                     TEXT UNIT\nS99TUKEY DS     XL2                    KEY\nS99TUNUM DS     XL2                    N0. OF LENGTH+PARAMETER ENTRIES\nS99TUENT DS     0C                     ENTRY OF LENGTH+PARAMETER\nS99TULNG DS     XL2                    LENGH OF 1ST (OR ONLY) PARAMETER\nS99TUPAR DS     C                      1ST (OR ONLY) PARAMETER\n* THE FOLLOWING DSECT IS PROVIDED FOR USE WITH MULTIPLE\n* LENGTH/PARAMETER ENTRIES TO ALLOW ZERO DISPLACEMENT TO THE\n* LENGTH FIELD\nS99TUFLD DS     0X\nS99TULEN DS     XL2                    LENGTH OF PARAMETER\nS99TUPRM DS     C                      PARAMETER\n         AIF   ('&PL(&I)' EQ 'SVC99BLK').L99\n.L31     AIF   ('&PL(&I)' NE 'SVC99' AND '&PL(&I)' NE 'SVC99EQU').L31A\n***********************************************************************\n*\n* KEYS FOR ALLOCATION FUNCTION\n*\n***********************************************************************\nDALDDNAM EQU   X'0001'                 DDNAME\nDALDSNAM EQU   X'0002'                 DSNAME\nDALMEMBR EQU   X'0003'                 MEMBER NAME\nDALSTATS EQU   X'0004'                 DATA SET STATUS\nDALNDISP EQU   X'0005'                 DATA SET NORMAL DISPOSITION\nDALCDISP EQU   X'0006'                 DATA SET CONDITIONAL DISP\nDALTRK   EQU   X'0007'                 TRACK SPACE TYPE\nDALCYL   EQU   X'0008'                 CYLINDER SPACE TYPE\nDALBLKLN EQU   X'0009'                 AVERAGE DATA BLOCK LENGTH\nDALPRIME EQU   X'000A'                 PRIMARY SPACE QUANTITY\nDALSECND EQU   X'000B'                 SECONDARY SPACE QUANTITY\nDALDIR   EQU   X'000C'                 DIRECTORY SPACE QUANTITY\nDALRLSE  EQU   X'000D'                 UNUSED SPACE RELEASE\nDALSPFRM EQU   X'000E'                 CONTIG,MXIG,ALX SPACE FORMAT\nDALROUND EQU   X'000F'                 WHOLE CYLINDER (ROUND) SPACE\nDALVLSER EQU   X'0010'                 VOLUME SERIAL\nDALPRIVT EQU   X'0011'                 PRIVATE VOLUME\nDALVLSEQ EQU   X'0012'                 VOL SEQUENCE NUMBER\nDALVLCNT EQU   X'0013'                 VOLUME COUNT\nDALVLRDS EQU   X'0014'                 VOLUME REFERENCE TO DSNAME\nDALUNIT  EQU   X'0015'                 UNIT DESCRIPTION\nDALUNCNT EQU   X'0016'                 UNIT COUNT\nDALPARAL EQU   X'0017'                 PARALLEL MOUNT\nDALSYSOU EQU   X'0018'                 SYSOUT\nDALSPGNM EQU   X'0019'                 SYSOUT PROGRAM NAME\nDALSFMNO EQU   X'001A'                 SYSOUT FORM NUMBER\nDALOUTLM EQU   X'001B'                 OUTPUT LIMIT\nDALCLOSE EQU   X'001C'                 UNALLOCATE AT CLOSE\nDALCOPYS EQU   X'001D'                 SYSOUT COPIES\nDALLABEL EQU   X'001E'                 LABEL TYPE\nDALDSSEQ EQU   X'001F'                 DATA SET SEQUENCE NUMBER\nDALPASPR EQU   X'0020'                 PASSWORD PROTECTION\nDALINOUT EQU   X'0021'                 INPUT ONLY OR OUTPUT ONLY\nDALEXPDT EQU   X'0022'                 EXPIRATION DATE\nDALRETPD EQU   X'0023'                 RETENTION PERIOD\nDALDUMMY EQU   X'0024'                 DUMMY ALLOCATION\nDALFCBIM EQU   X'0025'                 FCB IMAGE-ID\nDALFCBAV EQU   X'0026'                 FCB FORM ALIGNMENT,IMAGE VERIFY\nDALQNAME EQU   X'0027'                 QNAME ALLOCATION\nDALTERM  EQU   X'0028'                 TERMINAL ALLOCATION\nDALUCS   EQU   X'0029'                 UNIVERSAL CHARACTER SET\nDALUFOLD EQU   X'002A'                 UCS FOLD MODE\nDALUVRFY EQU   X'002B'                 UCS VERIFY CHARACTER SET\nDALDCBDS EQU   X'002C'                 DCB DSNAME REFERENCE\nDALDCBDD EQU   X'002D'                 DCB DDNAME REFERENCE\nDALBFALN EQU   X'002E'                 BUFFER ALIGNMENT\nDALBFTEK EQU   X'002F'                 BUFFERING TECHNIQUE\nDALBLKSZ EQU   X'0030'                 BLOCKSIZE\nDALBUFIN EQU   X'0031'                 NUMBER OF INPUT BUFFERS\nDALBUFL  EQU   X'0032'                 BUFFER LENGTH\nDALBUFMX EQU   X'0033'                 MAXIMUM NUMBER OF BUFFERS\nDALBUFNO EQU   X'0034'                 NUMBER OF DCB BUFFERS\nDALBUFOF EQU   X'0035'                 BUFFER OFFSET\nDALBUFOU EQU   X'0036'                 NUMBER OF OUTPUT BUFFERS\nDALBUFRQ EQU   X'0037'                 NUMBER OF GET MACRO BUFFERS\nDALBUFSZ EQU   X'0038'                 LINE BUFFER SIZE\nDALCODE  EQU   X'0039'                 PAPER TAPE CODE\nDALCPRI  EQU   X'003A'                 SEND/RECEIVE PRIORITY\nDALDEN   EQU   X'003B'                 TAPE DENSITY\nDALDSORG EQU   X'003C'                 DATA SET ORGANIZATION\nDALEROPT EQU   X'003D'                 ERROR OPTIONS\nDALGNCP  EQU   X'003E'                 NO. OF GAM I/O BEFORE WAIT\nDALINTVL EQU   X'003F'                 POLLING INTERVAL\nDALKYLEN EQU   X'0040'                 DATA SET KEYS LENGTH\nDALLIMCT EQU   X'0041'                 SEARCH LIMIT\nDALLRECL EQU   X'0042'                 LOGICAL RECORD  LENGTH\nDALMODE  EQU   X'0043'                 CARD READER/PUNCH MODE\nDALNCP   EQU   X'0044'                 NO. READ/WRITE BEFORE CHECK\nDALOPTCD EQU   X'0045'                 OPTIONAL SERVICES\nDALPCIR  EQU   X'0046'                 RECEIVING PCI\nDALPCIS  EQU   X'0047'                 SENDING PCI\nDALPRTSP EQU   X'0048'                 PRINTER LINE SPACING\nDALRECFM EQU   X'0049'                 RECORD FORMAT\nDALRSRVF EQU   X'004A'                 FIRST BUFFER RESERVE\nDALRSRVS EQU   X'004B'                 SECONDARY BUFFER RESERVE\nDALSOWA  EQU   X'004C'                 TCAM USER WORK AREA SIZE\nDALSTACK EQU   X'004D'                 STACKER BIN\nDALTHRSH EQU   X'004E'                 MESSAGE QUEUE PERCENTAGE\nDALTRTCH EQU   X'004F'                 7-TRACK RECORDING TECHNIQUE\nDALPASSW EQU   X'0050'                 PASSWORD\nDALIPLTX EQU   X'0051'                 IPL TEXT ID\nDALPERMA EQU   X'0052'                 PERMANENTLY ALLOCATED ATTRIB\nDALCNVRT EQU   X'0053'                 CONVERTIBLE ATTRIBUTE\nDALDIAGN EQU   X'0054'                 OPEN/CLOSE/EOV DIAGNOSTIC TRACE\nDALRTDDN EQU   X'0055'                 RETURN DDNAME\nDALRTDSN EQU   X'0056'                 RETURN DSNAME\nDALRTORG EQU   X'0057'                 RETURN D.S. ORGANIZATION\nDALSUSER EQU   X'0058'                 SYSOUT REMOTE USER\nDALSHOLD EQU   X'0059'                 SYSOUT HOLD QUEUE\nDALFUNC  EQU   X'005A'                 D.S. TYPE FOR 3525 CARD DEVICE\nDALFRID  EQU   X'005B'                 IMAGELIB MEMBER FOR SHARK\nDALSSREQ EQU   X'005C'                 SUBSYSTEM REQUEST\nDALRTVOL EQU   X'005D'                 RETURN VOLUME SERIAL\nDALMSVGP EQU   X'005E'                 MSVGP FOR 3330V        @Y30LPPD\nDALSSNM  EQU   X'005F'                 SUBSYSTEM NAME REQUEST @G29AN2F\nDALSSPRM EQU   X'0060'                 SUBSYSTEM PARAMETERS   @G29AN2F\nDALPROT  EQU   X'0061'                 RACF PROTECT FEATURE   @G32HPPJ\nDALSSATT EQU   X'0062'                 SUBSYSTEM ATTRIBUTE    @ZA25778\n**********************************************************************\n*\n* KEYS FOR CONCATENATION FUNCTION\n*\n**********************************************************************\nDCCDDNAM EQU   X'0001'                 DDNAMES\nDCCPERMC EQU   X'0004'                 PERMANENTLY CONCATENATED\n**********************************************************************\n*\n* KEYS FOR DECONCATENATION FUNCTION\n*\n***********************************************************************\nDDCDDNAM EQU   X'0001'                 DDNAME\n***********************************************************************\n*\n* KEYS FOR INFORMATION RETRIEVAL FUNCTION\n*\n***********************************************************************\nDINDDNAM EQU   X'0001'                 DDNAME\nDINDSNAM EQU   X'0002'                 DSNAME\nDINRTDDN EQU   X'0004'                 RETURN DDNAME\nDINRTDSN EQU   X'0005'                 RETURN DSNAME\nDINRTMEM EQU   X'0006'                 RETURN MEMBER NAME\nDINRTSTA EQU   X'0007'                 RETURN DATA SET STATUS\nDINRTNDP EQU   X'0008'                 RETURN NORMAL DISPOSITION\nDINRTCDP EQU   X'0009'                 RETURN CONDITIONAL DISP\nDINRTORG EQU   X'000A'                 RETURN D.S. ORGANIZATION\nDINRTLIM EQU   X'000B'                 RETURN # TO NOT-IN-USE LIMIT\nDINRTATT EQU   X'000C'                 RETURN DYN. ALLOC ATTRIBUTES\nDINRTLST EQU   X'000D'                 RETURN LAST ENTRY INDICATION\nDINRTTYP EQU   X'000E'                 RETURN D.S. TYPE INDICATION\nDINRELNO EQU   X'000F'                 RELATIVE REQUEST NUMBER\n**********************************************************************\n*\n* KEYS FOR REMOVE IN-USE FUNCTION\n*\n**********************************************************************\nDRITCBAD EQU   X'0001'                 TCB ADDRESS\nDRICURNT EQU   X'0002'                 CURRENT TASK OPTION\n**********************************************************************\n*\n* KEYS FOR DDNAME ALLOCATION FUNCTION\n*\n**********************************************************************\nDDNDDNAM EQU   X'0001'                 DDNAME\nDDNRTDUM EQU   X'0002'                 RETURN DUMMY D.S. INDICATION\n**********************************************************************\n*\n* KEYS FOR UNALLOCATION FUNCTION\n*\n**********************************************************************\nDUNDDNAM EQU   X'0001'                 DDNAME\nDUNDSNAM EQU   X'0002'                 DSNAME\nDUNMEMBR EQU   X'0003'                 MEMBER NAME\nDUNOVDSP EQU   X'0005'                 OVERRIDING DISPOSITION\nDUNUNALC EQU   X'0007'                 UNALLOC OPTION\nDUNREMOV EQU   X'0008'                 REMOVE OPTION\nDUNOVSNH EQU   X'000A'                 OVERRIDING SYSOUT NOHOLD\nDUNOVCLS EQU   X'0018'                 OVERRIDING SYSOUT CLASS\nDUNOVSUS EQU   X'0058'                 OVERRIDING SYSOUT REMOTE USER\nDUNOVSHQ EQU   X'0059'                 OVERRIDING SYSOUT HOLD QUEUE\n         AGO   .L99\n.L31A    AIF   ('&PL(&I)' NE      'STPB').L32\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR29\n***********************************************************************\n*    THE STACK PARAMETER BLOCK (STPB) IS A BLOCK POINTED TO BY THE    *\n*    STPL.  STACK USES IT TO STORE THE ADDRESS OF THE (STORAGE) LIST  *\n*    THE STACK PARAMETER BLOCK (STPB) IS A BLOCK POINTED TO BY THE    *\n*    STPL.  STACK USES IT TO STORE THE ADDRESS OF THE (STORAGE) LIST  *\n*    SOURCE DESCRIPTOR (LSD), INPUT AND OUTPUT DDNAMES, AS WELL AS    *\n*    FOR CONTROL.                                                     *\n***********************************************************************\n         SPACE 1\n.PR29    ANOP\nSTPB     DS    0D\n         DS    CL4      INTERNAL TO STACK\nSTPBALSD DS    A        ADDR OF (STORAGE) LIST SOURCE DESCRIPTOR\nSTPBINDD DS    A        ADDR OF INPUT DDNAME\nSTPBOTDD DS    A        ADDR OF OUTPUT DDNAME\nSTPBMBRN DS    A        ADDR OF MEMBER NAME\n         AGO   .L99\n.L32     AIF   ('&PL(&I)' NE      'STPL').L33\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR30\n***********************************************************************\n*    THE STACK PARAMETER LIST (STPL) IS A LIST OF ADDRESSES PASSED    *\n*    FROM THE INVOKER TO STACK VIA REGISTER 1                         *\n***********************************************************************\n         SPACE 1\n.PR30    ANOP\nSTPL     DS    0D\nSTPLUPT  DS    A        PTR TO UPT\nSTPLECT  DS    A        PTR TO ECT\nSTPLECB  DS    A        PTR TO CP'S ECB\nSTPLSTPB DS    A        PTR TO STACK PARM BLOCK\n         AGO   .L99\n.L33     AIF   ('&PL(&I)' NE      'TAIE').L34\n         SPACE 1\nTAIE     DS    0D\nTAIEMSGL DS    CL2 .    MESSAGE LENGTH\nTAIETGET DS    CL1 .    RET CODE FROM TGET ISSUED BY ATTN PROL LOG\n*                       TO BE CHECKED BY USER ATTN RTN\nTAIEATTN DS    CL1 .    TO BE USED BY THE TMP                  @ZA08099\nTAIEIAD  DS    1F .     RIGHT HALF OF INTERRUPT PSW\nTAIERSAV DS    CL64 .   REGS. STORED HERE WHEN AN INTERRUPT\n*                       TO MAINLINE OR ATTEN. EXIT OCCURS\nTAIELNGT EQU   *-TAIE   LENGTH OF TAIE\n         AGO   .L99\n.L34     AIF   ('&PL(&I)' NE      'UPT').L35\n         SPACE 1\n         AIF   ('&OACPRT' EQ 'SHORT').PR31\n***********************************************************************\n*    THE USER PROFILE TABLE (UPT) IS BUILT BY THE LOGON/LOGOFF        *\n*    SCHEDULER FROM INFORMATION STORED IN THE UADS AND FROM THE       *\n*    LOGON COMMAND.  IT IS IN CORE SHARED BY THE TMP AND THE          *\n*    LOGON/LOGOFF SCHEDULER.  CP'S AND SERVICE ROUTINES CAN MODIFY    *\n*    THE UPT, BUT THEY CANNOT FREE IT.                                *\n***********************************************************************\n         SPACE 1\n.PR31    ANOP\nUPT      DS     0D\n         DS    CL2      RESERVED\nUPTUSER  DS    CL10     RESERVED FOR INSTALLATION USE\nUPTSWS   DS    X        USERS ENVIRONMENT SWITCHES\nUPTRCVR  EQU   X'80'    EDIT RECOVER OPTION IS REQUESTED DEFLT @Z40NQKG\nUPTNPRM  EQU   X'40'    NO PROMPTING IS TO BE DONE\nUPTMID   EQU   X'20'    PRINT MESSAGE IDENTIFIERS\nUPTNCOM  EQU   X'10'    NO USER COMMUNICATION ALLOWED VIA SEND COMMAND\nUPTPAUS  EQU   X'08'    PAUSE FOR '?' WHEN IN NON-INTERACTIVE MODE\nUPTALD   EQU   X'04'    ATTN HAS BEEN SPECIFIED AS LINE DELETE CHAR\nUPTMODE  EQU   X'02'    MODE MESSAGES DESIRED                    Y01676\nUPTWTP   EQU   X'01'    WRITE TO PROGRAMMER MESSAGES DESIRED     Y02669\nUPTCDEL  DS    CL1      CHAR DELETE CHARACTER\nUPTLDEL  DS    CL1      LINE DELETE CHARACTER\n         DS    CL1      RESERVED\nUPTPREFX DS    CL7      DSNAME PREFIX                            Y02669\nUPTPREFL DS    BL1      LENGTH OF DSNAME PREFIX                  Y02669\n         AGO   .L99\n.L35     ANOP\n         MNOTE 12,'UNRECOGNIZED PL ''&PL(&I)'''\n.L99     ANOP\n&I       SETA  &I+1\n         AIF   (&I LE &N).LOOP\n         POP   PRINT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OACUSING": {"ttr": 9223, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00>\\x00>\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 62, "newlines": 62, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n         OACUSING &PARMS\n         GBLC  &USELAB(16),&USEREG(16)  PGM LABELS,USE REGISTERS\n         LCLA  &RCNT,&PNDX,&UNDX        # OF OPERANDS,PARM/USE INDICES\n         LCLA  &TP1,&HOLE               TEMP WORK,1ST UNUSED SAVE ENTRY\n         LCLB  &GOTREG                  WHETHER TO DO USING OR NOT\n         LCLC  &CHR1,&CHR2,&C(16)       TEMPORARY WORK CHARS,COMMAS\n         LCLC  &R(16),&S                REGS\n         LCLC  &U,&V,&W                 R(15),C(16),R(16)\n&PNDX    SETA  1                        SET UP PARM STRING INDEX\n&RCNT    SETA  N'&SYSLIST               GET NUMBER OF OPERANDS\n         AIF   (&RCNT LE 1).ERR01       TOO FEW INPUT PARAMETERS\n         AIF   (&RCNT LE 17).SYS1#CK    CONTINUE IF LOW ENOUGH\n         MNOTE 4,'TOO MANY INPUT PARAMETERS. ONLY 17 PROCESSED'\n&RCNT    SETA  17                       SET MAX ALLOWABLE\n.SYS1#CK ANOP\n&S       SETC  '&SYSLIST(1)'            SET FOR SHORTER STRING BELOW\n.COMLOOP ANOP\n&PNDX    SETA  &PNDX+1                  INCREMENT INPUT STRING INDEX\n&UNDX    SETA  0                        INITIALIZE USE INDEX\n&HOLE    SETA  0                        INITIALIZE UNUSED ENTRY INDEX\n.USELOOP AIF   ('&SYSLIST(&PNDX)' EQ '').CHK#END BR IF NULL STRING\n&UNDX    SETA  &UNDX+1                  UP THE USE INDEX\n         AIF   ('&USEREG(&UNDX)' EQ '&SYSLIST(&PNDX)').DO#USE PREVUSE?\n         AIF   ((&HOLE NE 0) OR ('&USEREG(&UNDX)' NE '')).CHKEND\n.* WE BRANCH TO CHKEND IF WE ALREADY HAVE A HOLE OR NO HOLE EXISTS HERE\n&HOLE    SETA  &UNDX                    KEEP THE SAVE TABLE FREE INDEX\n.CHKEND  AIF   (&UNDX LT 16).USELOOP    LOOP FOR ALL ENTRIES\n&UNDX    SETA  &HOLE                    GET FREE ENTRY INDEX IN CASE\n         AIF   (&HOLE NE 0).DO#USE1     BRANCH IF SPACE FOR ENTRY\n         MNOTE 4,'OACUSING SAVE TABLE FULL. OPERAND TRUNCATED'\n         AGO   .USINGGO                 GO DO JUST WHAT WE CAN\n.DO#USE  ANOP\n&CHR1    SETC  '********'(1,K'&SYSLIST(&PNDX)) STARS FOR THE REG\n&CHR2    SETC  '****************'(1,K'&USELAB(&UNDX)) MAX 16 CHAR LABEL\n         MNOTE *,'*********&CHR1*********************&CHR2'\n         MNOTE *,'REGISTER &SYSLIST(&PNDX) PREVIOUSLY BASED ON &USELAB(@\n               &UNDX)'\n         MNOTE *,'*********&CHR1*********************&CHR2'\n.DO#USE1 ANOP                           LOG THE REG USE HERE\n&CHR1    SETC  '&SYSLIST(1)'            GET A DEFAULT LABEL\n         AIF   (&PNDX EQ 2).SETLAB      IF FIRST REG, NO +NNNN TO ADD\n&TP1     SETA  (&PNDX-2)*4096           ELSE GET ADDED AMOUNT\n&CHR1    SETC  '&CHR1'.'+'.'&TP1'       APPEND THE +NN FOR EXTRA REGS\n.SETLAB  ANOP                           MOVE IN THE SAVE LABELS HERE\n&USELAB(&UNDX) SETC '&CHR1'             SET SAVE TABLE DATA\n&USEREG(&UNDX) SETC '&SYSLIST(&PNDX)'   GET THE REG VALUE IN SAVEAREA\n&R(&PNDX-1) SETC '&SYSLIST(&PNDX)'      GET THE REG VALUE FOR USING\n&C(&PNDX-1) SETC ','                    AND A LEADING COMMA ALSO\n&GOTREG  SETB  1                        SAY WE CAN DO USING\n.CHK#END AIF   (&PNDX LT &RCNT).COMLOOP LOOP FOR ALL ENTRIES\n.USINGGO AIF   (NOT &GOTREG).EXIT       NOW TELL ASSEMBLER IF WE CAN\n&U       SETC  '&R(15)'                 SO WE HAVE A SHORTER STRING\n&V       SETC  '&C(16)'                 SO WE HAVE A SHORTER STRING\n&W       SETC  '&R(16)'                 SO WE HAVE A SHORTER STRING\n         USING &S&C(1)&R(1)&C(2)&R(2)&C(3)&R(3)&C(4)&R(4)&C(5)&R(5)&C(6@\n               )&R(6)&C(7)&R(7)&C(8)&R(8)&C(9)&R(9)&C(10)&R(10)&C(11)&R@\n               (11)&C(12)&R(12)&C(13)&R(13)&C(14)&R(14)&C(15)&U&V&W\n         MEXIT\n.ERR01   MNOTE 4,'MISSING INPUT PARAMETERS'\n         MEXIT\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACUVT": {"ttr": 9225, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&LABEL   OACUVT  &DSECT=YES,&PREFIX=UVT\n         LCLC  &LAB,&P\n&LAB     SETC  'UVT     '         SET DEFAULT LABEL\n&P       SETC  '&PREFIX'(1,3)     SET MAX PREFIX\n         AIF   (T'&LABEL EQ 'O').CK#DS BIF NO USER LABEL\n&LAB     SETC  '&LABEL'           SET USER'S LABEL\n.CK#DS   AIF   ('&DSECT' EQ 'YES').DSECT BIF DSECT GENERATION\n&LAB     EQU   *                  OAC USER VECTOR TABLE\n         AGO   .GEN               BIF TO GENERATE DATA\n.DSECT   ANOP                     GENERATE DSECT HERE\n&LAB     DSECT ,                  OAC USER VECTOR TABLE\n.GEN     ANOP\n&P.ID    DC    CL4'UVT '          UVT ID FIELD\n&P.VERS  DS    XL4                UVT VERSION NR\n&P.SIZE  DS    F                  UVT SIZE\n&P.RSV01 DS    A                  RESERVED\n&P.WYLWA DS    A                  WYLBUR GLOBAL STATUS AREA\n*              MAPPED BY ==>       OACWGSA IN 'SYS91.OACMAC60'\n&P.RSV03 DS    A                  RESERVED\n&P.RSV04 DS    A                  RESERVED\n&P.RSV05 DS    A                  RESERVED\n&P.RSV06 DS    A                  RESERVED\n&P.RSV07 DS    A                  RESERVED\n&P.RSV08 DS    A                  RESERVED\n&P.RSV09 DS    A                  RESERVED\n&P.RSV10 DS    A                  RESERVED\n&P.LEN   EQU   8*((*+7-&P.ID)/8)\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACVTOC": {"ttr": 9227, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00^\\x00^\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 94, "newlines": 94, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&LABEL   OACVTOC &TYPE,&DSECT=YES,&PREFIX=\n.**********************************************************************\n.* THIS MACRO GENERATES ALL DATA STRUCTURES REQUIRED TO COMMUNICATE   *\n.* WITH THE VTOC PROGRAM. THE DATA STRUCTURE TO BE DEFINED IS         *\n.* SPECIFIED VIA THE '&TYPE' PARAMETER. THE FOLLOWING TYPES EXIST:    *\n.*      CALL - GENERATE VTOC PARM DATA AND CALL THE PROGRAM           *\n.*     DSECT - GENERATE DSECTS WITH DEFAULT LABELS/PREFIXES           *\n.*      PARM - GENERATE PARMS DSECT OR DATA                           *\n.*      EXIT - GENERATE EXIT DSECT OR DATA                            *\n.*      TEST - PERFORM FLAG TESTS (ALLOWS FLAG OFFSET CHANGES)        *\n.* IF THE TYPE PARAMETER IS NOT CODED, IT DEFAULTS TO 'DSECTS'.       *\n.**********************************************************************\n         LCLB  &DEF               FLAG TO INDICATE DEFAULT DSECT DATA\n         LCLC  &P,&LAB            LOCAL PREFIX,LOCAL LABEL\n         AIF   (T'&TYPE EQ 'O').C#DSE BIF NO TYPE - DO DEFAULT\n         AIF   ('&TYPE' EQ 'CALL').C#CAL BIF TYPE=CALL\n         AIF   ('&TYPE' EQ 'DSECT').C#DSE BIF TYPE=DSECT\n         AIF   ('&TYPE' EQ 'EXIT').C#EXI BIF TYPE=EXIT\n         AIF   ('&TYPE' EQ 'PARM').C#PAR BIF TYPE=PARM\n         MNOTE 8,'INVALID GEN TYPE ''&TYPE'' - PROCESSING TERMINATED'\n         MEXIT\n.C#DSE   ANOP                     GENERATE DSECTS HERE\n&DEF     SETB  1                  FLAG DSECT DEFAULT USAGE\n.C#PAR   SPACE 2                  GENERATE PARMS DATA HERE\n&P       SETC  'VTP'              SET DEFAULT PREFIX\n&LAB     SETC  'VTPARMS'          SET DEFAULT LABEL\n         AIF   (&DEF).PA#DS       BIF DSECT GENERATION\n         AIF   (T'&LABEL EQ 'O').PA#PRE BIF NO LABEL PASSED\n&LAB     SETC  '&LABEL'           ELSE USE USER ENTRY\n.PA#PRE  AIF   (T'&PREFIX EQ 'O').PA#CKD BIF NO PREFIX PASSED\n&P       SETC  '&PREFIX'(1,3)     SET MAX PREFIX SIZE\n         AIF   (K'&PREFIX LE 3).PA#CKD BIF LENGTH OK\n         MNOTE 8,'PREFIX &PREFIX TRUNCATED TO &P'\n.PA#CKD  AIF   ('&DSECT' EQ 'YES').PA#DS BIF DSECT REQUESTED\n&LAB     DC    0F'0'              DEFINE VTOC PARM MAPPING\n         AGO   .PA#GEN            BIF TO GEN DATA\n.PA#DS   ANOP\n&LAB     DSECT ,                  DEFINE VTOC PARM MAPPING\n.PA#GEN  ANOP\n&P.#FLAG DC    0F'0'              CONTROL FLAGS\n&P.#FG1  DC    X'00'              CONTROL FLAG 1\n&P.#F1SB EQU   X'80'              THIS IS A SUBROUTINE CALL (ALWAYS ON)\n&P.#F1PR EQU   X'40'              PROVIDE A SYSPRINT PRINT ROUTINE\n&P.#F1AL EQU   X'20'              RETURN ALL DSCBS IN VTOC ORDER\n&P.#F1LD EQU   X'10'              RETURN LOGICAL DATASETS\n&P.#FG2  DC    X'00'              CONTROL FLAG 2\n&P.#FG3  DC    X'00'              CONTROL FLAG 3\n&P.#FG4  DC    X'00'              CONTROL FLAG 4\n&P.#WORK DC    A(0)               WORK STORAGE AREA OR ZERO\n&P.#CSIZ DC    F'0'               STORAGE USAGE LIMIT OR ZERO\n&P.#USER DC    A(0)               USER DATA TO BE PASSED TO EXIT\n&P.#EXIT DC    A(0)               ADDR OF USER EXIT\n&P.#USIZ DC    F'0'               SIZE OF WORKAREA TO PASS EXIT OR ZERO\n&P.#VOL  DC    CL6' '             VOLUME TO SEARCH\n         AIF   (&DEF).C#EXI       BIF DSECT GENERATION\n         MEXIT\n.C#EXI   SPACE 2                  GENERATE EXIT DATA HERE\n&P       SETC  'VTX'              SET DEFAULT PREFIX\n&LAB     SETC  'VTEXIT'           SET DEFAULT LABEL\n         AIF   (&DEF).EX#DS       BIF DSECT GENERATION\n         AIF   (T'&LABEL EQ 'O').EX#PRE BIF NO LABEL PASSED\n&LAB     SETC  '&LABEL'           ELSE USE USER ENTRY\n.EX#PRE  AIF   (T'&PREFIX EQ 'O').EX#CKD BIF NO PREFIX PASSED\n&P       SETC  '&PREFIX'(1,3)     SET MAX PREFIX SIZE\n         AIF   (K'&PREFIX LE 3).EX#CKD BIF LENGTH OK\n         MNOTE 8,'PREFIX &PREFIX TRUNCATED TO &P'\n.EX#CKD  AIF   ('&DSECT' EQ 'YES').EX#DS BIF DSECT REQUESTED\n&LAB     DC    0F'0'              DEFINE VTOC EXIT PARM MAPPING\n         AGO   .EX#GEN            BIF TO GEN DATA\n.EX#DS   ANOP\n&LAB     DSECT ,                  DEFINE VTOC EXIT PARM MAPPING\n.EX#GEN  ANOP\n&P.#FLAG DC    0F'0'              CONTROL FLAGS\n&P.#FG1  DC    X'00'              CONTROL FLAG 1\n&P.#F1CB EQU   X'80'              ALL EXTENTS ON CYLINDER BOUNDARY\n&P.#F1LD EQU   X'40'              LOGICAL DATASET RETURNED\n&P.#FG2  DC    X'00'              CONTROL FLAG 2\n&P.#FG3  DC    X'00'              CONTROL FLAG 3\n&P.#FG4  DC    X'00'              CONTROL FLAG 4\n&P.#DS1  DC    A(0)               ADDR - RETURNED DSCB OR LOGICAL FMT1\n&P.#DS2  DC    A(0)               ADDR - ZERO OR LOGICAL FMT2\n&P.#DS3  DC    A(0)               ADDR - ZERO OR LOGICAL FMT3\n&P.#USER DC    A(0)               USER DATA PASSED FROM VTOC CALLER\n&P.#EXIT DC    A(0)               ADDR OF USER EXIT\n&P.#TRKS DC    F'0'               TOTAL ALLOCATED TRACKS\n&P.#UCB  DC    A(0)               UCB ADDRESS - CURRENT VOLUME\n&P.#TCYL DC    H'0'               TRACKS/CYL - CURRENT VOLUME\n&P.#CHR  DC    XL5'0'             CCHHR OF DSCB RETURNED\n&P.#VOL  DC    CL6' '             CURRENT VOLUME BEING SEARCHED\n&P.#CDEV DC    CL8' '             CHARACTER DEVICE TYPE - CURRENT VOL\n         MEXIT\n.C#CAL   ANOP                     GENERATE CALL HERE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OLDENTER": {"ttr": 9230, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x01*\\x01*\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 298, "newlines": 298, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&NAME    OACENTER &REGEQU=YES,&BASE=R10,&PARM=R9,&ENTRYS=,&ENTRYR=,    X\n               &EXIT=,&DSECT=,&WORK=,&STACK=,&ROUND=NO,&SP=1,&PLIX=NO, X\n               &ID=,&DATE=,&PRINT=\n         COPY  OACGBLS            GET OAC GLOBAL ASM SYSMS\n         LCLC  &C,&I,&D,&STK,&STKMX,&LEN,&BASEADD,&SPL,&NM\n         LCLA  &N,&X,&WL,&A\n         LCLB  &XZ,&NOSTACK\n&NOSTACK SETB  ('&STACK(1)' EQ ''  OR '&STACK(1)' EQ '0')\n&OACSTMX SETC  '8(R12)'           STACK MAX\n&OACSTER SETC  '16(R12)'          OVERFLOW ROUTINE\n&SPL     SETC  '0'\n&I       SETC  '&NAME'\n         AIF   ('&PLIX' NE 'YES').L0\n&I       SETC  'X&NAME'(1,8)\n.L0      ANOP\n&I       CSECT ,                  AVOID PRIVATE CODE\n         OACPRTPM PRINT=&PRINT\n         AIF   ('&REGEQU' NE 'YES').L1\n         OACREGS PRINT=&OACPRT\n.L1      AIF   ('&DSECT' EQ '').L11\n&DSECT   DSECT\n&LEN     SETC  'XL&SYSNDX'\n&STKMX   SETC  'XL&SYSNDX-71'\n         AIF   (&NOSTACK).L6\n         AIF   ('&PLIX' EQ 'NO').L2\n.PSERR   MNOTE 8,'PLIX=YES AND STACK= ARE MUTUALLY EXCLUSIVE'\n.L2      ANOP\n         DC    AL1(&SP),AL3(0)    SP AND LENGTH OF WORK AREA\n         DC    3A(0)              R13 CHAIN, STKMAX AND STACKERR\n         L     R15,12(R12)        GET ADD OF STK OVERFLOW RTN\n         BR    R15                CALL THE ROUTINE\n         AIF   ('&WORK(2)' EQ '').L3\n         OACWORK &WORK(2)\n.L3      ANOP\n&C       SETC  '&WORK(3)'\n         AIF   ('&WORK(1)' EQ ''  OR '&WORK(1)' EQ '0').L4\n&C       DC    0D'0',&WORK(1)XL1'0' RESERVED AREA\n         AGO   .L4A\n.L4      AIF   ('&C' EQ '').L4A\n&C       DC    0D                 ALIGNED WORK LABEL\n.L4A     ANOP\n&STK     SETC  '&STACK(2)'\n         AIF   ('&STK' NE '').L4B\n&STK     SETC  'XS&SYSNDX'\n.L4B     ANOP\n&A       SETA  ((&STACK(1)+79)/8)*8\n&STK     DC    0D'0',&A.XL1'0'    STACK AREA\n&STK     SETC  '&STK-&DSECT'\n         AIF   ('&ROUND' NE 'YES' ).L5\nXO&SYSNDX EQU 4096*(((*-&DSECT)+4095)/4096)\n         ORG   &DSECT+XO&SYSNDX\n.L5      ANOP\nXL&SYSNDX EQU  *-&DSECT\n         SPACE &OACPRTS\n         AGO   .L20\n.L6      AIF   ('&PLIX' EQ 'YES').L7\n         DC    9D'0'              OS SAVE AREA\n&SPL     SETC  '72'\n         AGO   .L8\n.L7      ANOP\n         DC    22F'0'             DSA HEADER\n&SPL     SETC  '88'\n.L8      ANOP\n&STK     SETC  '0'\n         DC    AL1(&SP),AL3(0)    SP AND LENGTH\n         AIF   ('&WORK(2)' EQ '').L9\n         OACWORK &WORK(2)\n.L9      ANOP\n&C       SETC  '&WORK(3)'\n&C       DC    0D'0'              FORCE ALIGNMENT OF RESERVED AREA\n         AIF   ('&WORK(1)' EQ ''  OR '&WORK(1)' EQ '0').L10\n         DC    &WORK(1)XL1'0'     RESERVED AREA\n.L10     ANOP\nXL&SYSNDX EQU  *-&DSECT\n         SPACE &OACPRTS\n         AGO   .L20\n.L11     AIF   ('&WORK(3)' EQ '').L12\n         MNOTE 4,'WORK LABEL REQUIRES CODING DSECT=NAME'\n.L12     AIF   ('&WORK(2)' EQ '').L13\n         MNOTE 4,'WORK MACRO REQUIRES CODING DSECT=NAME'\n.L13     AIF   ('&STACK(2)' EQ '' ).L14\n         MNOTE 4,'STACK LABEL REQUIRES CODING DSECT=NAME'\n.L14     AIF   (&NOSTACK).L16\n         AIF   ('&PLIX' EQ 'YES').PSERR\n&WL      SETA  24                 OS HEADER ROUNDED TO 8\n&LEN     SETC  '24'\n         AIF   ('&WORK(1)' EQ ''  OR '&WORK(1)' EQ '0').L15\n&WL      SETA  &WL+8*((&WORK(1)+7)/8)\n&LEN     SETC  '&WL'\n&STK     SETC  '&WL'\n.L15     ANOP\n&WL      SETA  &WL+8*((&STACK(1)+79)/8)\n&LEN     SETC  '&WL'\n&STKMX   SETC  '&WL-71'\n         AIF   ('&ROUND' NE 'YES' ).L20\n&WL      SETA  4096*((&WL+4095)/4096)\n&LEN     SETC  '&WL'\n&STLMX   SETC  '&WL-71(R12)'\n         AGO   .L20\n.L16     AIF   ('&PLIX' EQ 'YES').L17\n&SPL     SETC  '72'\n&WL      SETA  80                 OS SAVE +SP +LENGTH\n&LEN     SETC  '80'\n         AGO   .L18\n.L17     ANOP\n&WL      SETA  96                 DSA HEADER +SP+LENGTH\n&LEN     SETC  '96'\n.L18     ANOP\n&STK     SETC  '0'\n         AIF   ('&WORK(1)' EQ ''  OR '&WORK(1)' EQ '0').L20\n&WL      SETA  &WL+8*((&WORK(1)+7)/8)\n&LEN     SETC  '&WL'\n.L20     AIF   ('&BASE(2)' EQ '').L21\n         MNOTE 8,'ONLY ONE BASE REGISTER IS SUPPORTED'\n.L21     AIF   ('&OACPRT' NE 'NONE').L22\n         PRINT ON,GEN\n.L22     ANOP\n         SPACE &OACPRTS\n&I       SETC  '&NAME '\n&D       SETC  '&SYSDATE'\n         AIF   ('&ID' EQ '').L23\n&I       SETC  '&ID '\n.L23     AIF   ('&DATE' EQ '').L24\n&D       SETC  '&DATE'\n         MNOTE 7,'REMOVE DATE= BEFORE FINAL ASSEMBLY'\n.L24     ANOP\n&I       SETC  '&I&D'\n         AIF   ('&PLIX' NE 'YES').L26\n&C       SETC  'X&NAME'(1,8)\n&C       CSECT\n&A       SETA  2*(K'&I/2)\n         AIF   (K'&I NE &A).L25\n&I       SETC  '&I '\n.L25     ANOP\n         DC    C'&I'\n&A       SETA  K'&I\n         DC    AL1(&A)\n         ENTRY &NAME\n&NAME    STM   R14,R11,12(R13)    SAVE CALLERS REGS\n         BALR  &BASE,0            GET BASE\n         OACUSING &NAME+6,&BASE\n&BASEADD SETC  '&NAME+6'\n         AGO   .L27A\n.L26     ANOP\n&NAME    CSECT\n&A       SETA  (2*(K'&I/2))+1+5   FORCE ODD ID LENGTH + AL1 + BRANCH\n         B     &A.(R15)           BRANCH AROUND ID\n&A       SETA  &A-5\n         DC    AL1(&A),CL&A'&I'\n         STM   R14,R12,12(R13)    SAVE CALLERS REGS\n         LR    &BASE,R15          SAVE BASE\n         OACUSING &NAME,&BASE\n&BASEADD SETC  '&NAME'\n.L27A    ANOP\n&N       SETA  N'&ENTRYS\n&NM      SETC  ''\n         AIF   (&N EQ 0).L31\n         AIF   ('&ENTRYR' NE '').L28\n         MNOTE 12,'ENTRYR REQUIRED IF ENTRYS CODED'\n.L28     ANOP\n         SR    &ENTRYR,&ENTRYR    MARK AS MAIN ENTRY\n         B     XC&SYSNDX          GO TO COMMON CODE\n&NM      SETC  'XC&SYSNDX'\n&X       SETA  1\n.LOOP    ANOP\n         SPACE 1\n&C       SETC  '&ENTRYS(&X)'\n         ENTRY &C\n&C       STM   R14,R12,12(R13)    SAVE CALLERS REGS\n&A       SETA  4*&X\n         LA    &ENTRYR,&A         MARK AS ENTRY NO &X\n         L     &BASE,XB&SYSNDX-&C.(R15) GET BASE ADDRESS\n         B     XC&SYSNDX          GO TO COMMON CODE\n&X       SETA  &X+1\n         AIF   (&X LE &N).LOOP\nXB&SYSNDX DC   A(&BASEADD)        BASE ADDRESS\n.L31     AIF   ('&PARM' EQ '').L33\n         AIF ('&PARM(2)' EQ 'L').L32\n&NM      LR    &PARM(1),R1           SAVE PARM REG\n&NM      SETC  ''\n         AGO   .L32A\n.L32     ANOP\n&NM      L     &PARM(1),0(R1)        GET PARM ADDR\n.L32A    AIF   ('&PARM(3)' EQ '').L33\n         OACUSING &PARM(3),&PARM(1)\n&NM      SETC  ''\n.L33     AIF   ('&PLIX' NE 'YES').L36\n&NM      LA    R0,&LEN            LNGTH OF REQUIRED DSA IN R0\n&NM      SETC  ''\n         L     R1,76(R13)         LOAD ADD OF NXT AVAIL BYTE\n         ALR   R0,R1              ADD ADDRESSES\n         CL    R0,12(R12)         SEE IF STACK OVERFLOW\n         BNH   *+10               ENOUGH\n         L     R15,116(R12)       ADD OF PLI STORAGE OVERFLOW\n         BALR  R14,R15            GO TO IT\n         ST    R0,76(R1)          STORE ADD NXT AVAIL BYTE\n         ST    R13,4(R1)          CHAIN DSA'S\n         MVC   72(4,R1),72(R13)   COPY ADD OF LIBRARY\n         LR    R13,R1             PUSH STACK\n         MVI   0(R13),X'80'       SET DSA FLAGS FOR PLI\n         MVI   1(R13),X'00'\n         MVI   86(R13),X'91'\n         MVI   87(R13),X'C0'\n         LA    R0,&LEN            GET LENTH OF DSA\n         ST    R0,&SPL.(R13)      STORE INTO WORK AREA\n         AIF   ('&DSECT' EQ '').L34\n         OACUSING &DSECT,R13\n.L34     AIF   ('&EXIT' EQ '').INUSE\n         B     XZ&SYSNDX          BRANCH AROUND EXIT ROUTINE\n&XZ      SETB  1\n         SPACE &OACPRTS\n&EXIT(1) L     R13,4(R13)         RELEASE CURRENT DSA\n         LM    R14,R11,12(R13)    RESTORE CALLERS REGS\n         LTR   R15,R15            SET CC\n         BR    R14                RETURN TO CALLER\n         AGO   .INUSE\n.L36     ANOP\n&NM      GETMAIN R,LV=&LEN,SP=&SP\n&NM      SETC  ''\n         MVC   &SPL.(4,R1),*-10   COPY SP AND LENGTH\n         ST    R13,4(R1)          DO SAVE AREA CHAINING\n         ST    R1,8(R13)          ESTABLISH ADDRESSABILITY\n         AIF   (&NOSTACK).L38\n         LR    R12,R1             MOVE BASE OF WA\n         AIF   ('&DSECT' EQ '').L37\n         OACUSING &DSECT,R12\n.L37     ANOP\n         LA    R13,&STK.(R12)     BASE OF STACK\n         A     R1,=A(&STKMX)      GET ADD OF STACK MAX\n         ST    R1,&OACSTMX        SAVE INTO WORK AREA\n         MVC   16(6,R12),=XL6'58FC000C07FF'\n         AIF   ('&STACK(3)' EQ '' ).OSEXIT\n         LA    R1,&STACK(3)       GET OVERFLOW ROUTINE ADDRESS\n         ST    R1,12(R12)         STORE IN WORK AREA\n         B     XZ&SYSNDX\n&XZ      SETB  1\n         SPACE &OACPRTS\n&STACK(3) BALR R15,0              GET A BASE\n         USING *,R15\n         WTO  'OAC900 STACK OVERFLOW IN &NAME',ROUTCDE=11,DESC=7\n         DROP  R15\n         AIF   ('&STACK(4)' EQ '' OR '&STACK(4)' EQ 'ABEND').SO\n         LR    R1,R12             SAVE WORK BASE\n         L     R13,4(R12)         UNCHAIN BASE ADDR\n         L     R0,&SPL.(R1)       POINT TO SP AND LENGTH\n         FREEMAIN R,LV=(0),A=(1)  DO THE FREEMAIN\n         LA    R15,&STACK(4)      LOAD RETURN CODE\n         LTR   R15,R15            SET CC\n         BR    R14                RETURN TO CALLER\n         AGO   .OSEXIT\n.SO      ANOP\n         ABEND 900,DUMP           STACK OVERFLOW ABEND\n         AGO   .OSEXIT\n.L38     ANOP\n         LR    R13,R1             NEW WORK BASE\n         AIF   ('&DSECT' EQ '').OSEXIT\n         OACUSING &DSECT,R13\n.OSEXIT  AIF   ('&EXIT' EQ '').INUSE\n         AIF   (&XZ).OSEXIT1\n         B     XZ&SYSNDX\n&XZ      SETB  1\n.OSEXIT1 ANOP\n         SPACE &OACPRTS\n         AIF   (&NOSTACK).OSEXIT2\n&EXIT(1) LR    R1,R12             SAVE BASE ADDR\n         L     R13,4(R12)         UNCHAIN SAVE AREA\n         AGO   .OSEXIT3\n.OSEXIT2 ANOP\n&EXIT(1) LR    R1,R13             SAVE BASE ADDR\n         L     R13,4(R13)         UNCHAIN SAVE AREA\n.OSEXIT3 AIF   ('&EXIT(2)' NE '').L39\n         ST    R15,16(R13)        SAVE RC\n         AGO   .L41\n.L39     ANOP\n&C       SETC  '&EXIT(2)'(1,1)\n         AIF   ('&C' EQ '(').L40\n         MVC   16(4,R13),&EXIT(2) SAVE RC\n         AGO   .L41\n.L40     ANOP\n&C       SETC  '&EXIT(2)'(2,K'&EXIT(2)-1)\n&C       SETC  '&C'(1,K'&C-1)\n         ST    &C,16(R13)         SAVE RC\n.L41     ANOP\n         L     R0,&SPL.(R1)       GET SP AND LENGTH\n         FREEMAIN R,LV=(0),A=(1)  DO THE FREEMAIN\n         LM    R14,R12,12(R13)    RESTORE CALLERS REGS\n         LTR   R15,R15            SET CONDITION CODE\n         BR    R14                RETURN TO CALLER\n.INUSE   AIF   (&NOSTACK).L41A\n         LTORG                    AS GOOD A PLACE AS ANY\n.L41A    ANOP\n         AIF   (NOT &XZ).L42\nXZ&SYSNDX DC   0H'0'\n.L42     ANOP\n         OACINUSE PRINT=&PRINT\n.MEND    POP   PRINT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OLDMUS": {"ttr": 9478, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00H\\x00H\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 72, "newlines": 72, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n         OACMUS &DUMMY,&DSECT=YES\n.*\n.*       PARM  LIST MAPPING MACRO  FOR OACMUS\n.*\n         AIF   ('&DSECT' EQ 'YES').L1\nOACMUSDS DC    0D'0'\n         AGO   .L2\n.L1      ANOP\nOACMUSDS DSECT\n.L2      ANOP\n*        AT THE CALL OF OACMUS, R15 SHOULD POINT TO THE ENTRY POINT,\n*        R13 SHOULD POINT TO A SAVE AREA, R1,SHOULD POINT TO THIS\n*        PARM LIST, AND R0 SHOULD HAVE ONE OF THE FOLLOWING VALUES:\n*                                    0 = REGULAR BATCH\n*                                    4 = LOW PRIORITY BATCH\n*                                    8 = QUICKRUN\n*                                  124 = WYLBUR\n*                                  128 = TSO\n*                                  132 = APL\n*                                  136 = TSO LARGE REGION\n*         NOTE: THE TSO LARGE REGION PARAMETERS ARE NOTICIBLY\n*                DIFFERENT THAN THE STANDARD, BUT THIS FUNCTION\n*                IS INCLUDED HERE, IN THE INTERESTS OF KEEPING\n*                ALL THE PRIME TIME CALCULATIONS IN ONE  PLACE\n*                PARAMETERS AND RETURN AREAS RELEVENT TO TSO LARGE\n*                REGION ARE MARKED WITH A *@\n*\n*        OACMUS ALSO SUPPORTS REQUESTS FOR CURRENT COST           01225\n*        CONSTANTS. CURRENTLY, JES2/HASPPRPU UTILIZES THIS        01225\n*        INTERFACE TO EXTRACT CURRENT UNIT RECORD CHARGES (PAGES, 01225\n*        LINES, ETC.). THE CURRENTLY DEFINED REQUEST CODES (IN    01225\n*        R0) ARE:                                                 01225\n*                                 1000 = PRINTED PAGES            01225\n*                                 1001 = PRINTED LINES            01225\n*                                 1002 = CARDS READ               01225\n*                                 1003 = CARDS PUNCHED            01225\n*                                 1004 = VERSATEC INCHES PLOTTED  01225\nMUSWORK  DS    0D'0',2F'0'        WORK AREA, MUST BE ZERO ON INITIAL\n*                                 CALL. IF NON ZERO ON RETURN. THE\n*                                 OACMUS ROUTINE MUST BE CALLED AGAIN\n*                                 WITH THE SAME, UNMODIFIED PARM BLOCK\n*                                 TO OBTAIN AN ADDITIONAL MESSAGE\n*                                 IF ZERO ON RETURN, MUSMSG CONTAINS\n*                                 THE LAST MESSAGE.\nMUSMSG   DC    CL80' '            MESSAGE RETURNED HERE\nMUSMSGLN EQU   80                 MESSAGE LENGTH\nMUSMUS   DC    A(0)               .01 MUS RETURNED HERE\nMUSCENTS DC    A(0)               MUS COST IN CENTS IS RETURNED HERE\nMUSCPU   DC    A(0)               CALLER SUPPLIED CPU TIME IN .01 SEC\nMUSIO    DC    A(0)               CALLER SUPPLIED NUMBER OF IO'S\nMUSEWSS  DC    A(0)               CALLER SUPPLIED ESTIMATED WORKING\n*                                 SET IN K BYTES. 0 FOR WYLBUR\nMUSVMF   DC    A(0)               VMF VALUE USED RETURNED HERE    01216\nMUSRTE   DC    A(0)               MUS RATE USED RETURNED HERE     01216\nMUSMNTRT DC    A(0)               MOUNT RATE FOR TAPES            01225\nMUSMNTRD DC    A(0)               MOUNT RATE FOR DISKS            01225\n*\n*        NOTE: THE REST OF THIS PARM LIST NEED NOT BE SUPPLIED\n*              IF THE CALLER IS NOT INTERACTIVE\n*\nMUSCSEC  DC    A(0)               CONNECT TIME IN SEC'S RETURNED HERE\n*@ TSO LARGE REGION RETURN THE NUMBER OF SECONDS UNTILL THE\n*@  START OF THE NEXT PRIME PERIOD IN THIS FIELD\nMUSCCENT DC    A(0)               CONNECT COST IN CENTS RETURNED HERE\nMUSSONTD DC    2A(0)              SIGNON TIME/DATE IN TIME BIN FORMAT\n*@ TSO LARGE REGION SUPPLIES THIS VALUE.\nMUSSOFTD DC    2A(0)              SIGNOFF TIME/DATE IN TIME BIN FORMAT\n*@ TSO LARGE REGION RETURNS THE START OF THE NEXT PRIME TIME\n*@ PERIOD IN THIS FIELD, OR SETS IT EQUAL TO MUSSONTD IF THAT IS\n*@ ALREADY IN A PRIME TIME PERIOD.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PTFXREF": {"ttr": 9481, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x8b\\x00\\x8b\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 139, "newlines": 139, "modlines": 0, "user": "FILE149"}, "text": "//CSYSCSTF JOB\n// EXEC PLIXCG,PARM.PLI='MAR(2,72,1),A,X'\n//PLI.SYSIN DD *\n XREF: PROC OPTIONS(MAIN) REORDER;\n-  /*                                                               */\n   /*  THIS IS A BRUTE FORCE PROGRAM TO MAP THE SMP PRE-REQ CHAINS  */\n   /*  ENCOUNTERED DURING PUT APPLY PROCESSING.  THE TERMINATED     */\n   /*  PTFS AND THE MISSING PRE'S ARE READ FROM A FILE WRITTEN      */\n   /*  BY AN SMP4 APPLY CHECK RUN.  THE PRE-REQS FOUND BY SMP ARE   */\n   /*  SORTED AND DUPLICATES ARE REDUCED OUT, RESULTING IN A        */\n   /*  MINIMUM SET OF VILLAINS.                                     */\n   /*                                                               */\n   /*  A RECURSIVE PROC IS THEN CALLED TO LIST THE TERMINATED       */\n   /*  PTFS FOR EACH VILLAIN.  TERMINATED PTFS MAY APPEAR           */\n   /*  MULTIPLE TIMES IN THE TREE IF THEY HAVE MULTIPLE PREREQS.    */\n   /*                                                               */\n   /*  USE THE FOLLOWING JCL AS AN EXAMPLE:                         */\n   /*   // EXEC SMP4                                                */\n   /*   //SMPOUT DD DISP=OLD,DSN=SMPOUT                             */\n   /*   //SYSIN DD *                                                */\n   /*    APPLY CHECK EXCLUDE(...                                    */\n   /*                                                               */\n   /*  USE THE RESULTANT FILE AS INPUT TO THIS PROGRAM              */\n   /*   //GO.SMPOUT DD DISP=SHR,DSN=SMPOUT                          */\n   /*                                                               */\n   /*  CHRIS THOMAS                                                 */\n   /*  OFFICE OF ACADEMIC COMPUTING                                 */\n   /*  UNIVERSITY OF CALIFORNIA, LOS ANGELES                        */\n   /*  LOS ANGELES, CALIFORNIA 90024                                */\n   /*  (213) 825-9308                                               */\n   /*                                                               */\n   /*  THE AUTHOR MAKES NO CLAIMS FOR THE VALIDITY OF THE OUTPUT    */\n   /*  OF THIS PROGRAM, BUT IT SEEMS TO WORK.  FEEDBACK REGARDING   */\n   /*  CORRECTIONS IS SOLICITED.                                    */\n   /*                                                               */\n   /*  VERSION 1.1  --  NOV 1, 1981                                 */\n   /*                                                               */\n   /*  NOTE: WHEN RUN ON ACCEPT OUTPUT INSTEAD OF APPLY OUTPUT,     */\n   /*  SOME OFFSETS MUST BE ADJUSTED BY 1 CHARACTER (\"ACCEPT\" IS    */\n   /*  ONE CHARACTER LONGER THAN \"APPLY\").                          */\n   /*                                                               */\n-DCL TERM(1:500) CHAR(7);\n DCL PRE(1:500) CHAR(7);\n DCL VILLAIN(1:500) CHAR(7);\n DCL TEMPV CHAR(7);\n DCL BUFFER CHAR(121);\n DCL (MULTI,SKIPPED) BIT(1) INIT('0'B);\n DCL (I,J,K,NTERM,NVILLAIN,LEVEL) FIXED BIN(31);\n ON ENDFILE(SMPOUT) GO TO PROCESS;\n-I = 0;\n TERM = ' ';\n PRE = ' ';\n VILLAIN = ' ';\n-DO WHILE('1'B);                        /* READ TERM'S AND PRE'S */\n      IF I > 500 THEN STOP;     /* ERROR STOP - INCREASE ARRAY SIZE */\n      READ FILE(SMPOUT) INTO(BUFFER);\n      IF SUBSTR(BUFFER,2,7)='HMA3022' & SUBSTR(BUFFER,71,7) \u00ac='ALL SUP'\n           THEN DO;\n           PUT SKIP(2) FILE(SYSPRINT) EDIT(BUFFER) (A);\n           I = I + 1;\n           MULTI = '0'B;\n           TERM(I) = SUBSTR(BUFFER,52,7);  /* 52(APPLY)/53(ACCEPT)*/\n           END;\n      ELSE IF SUBSTR(BUFFER,2,7) = 'HMA3590'\n           THEN DO;\n           PUT SKIP(1) FILE(SYSPRINT) EDIT(BUFFER) (A);\n           IF MULTI THEN DO;\n                I = I + 1;\n                TERM(I) = TERM(I-1);\n                END;\n           PRE(I) = SUBSTR(BUFFER,18,7);\n           MULTI = '1'B;\n           END;\n      END;\n-PROCESS:\n NTERM = I;\n PUT SKIP(3) FILE(SYSPRINT) EDIT('THERE WERE ', NTERM, ' TERMINATED-',\n      'MISSING RELATIONSHIPS FOUND BY SMP4.') (A,F(3),A,A);\n-K = 0;\n DO I = 1 TO NTERM;                     /* DEVELOP MINIMUM SET\n                                           OF VILLAINS */\n      DO J = 1 TO I-1;                         /* REMOVE DUPS */\n           IF PRE(I) = PRE(J) THEN GO TO V1;\n           END;\n      DO J = 1 TO NTERM;                       /* REMOVE TERM'S */\n           IF PRE(I) = TERM(J) THEN GO TO V1;\n           END;\n      K = K + 1;\n      VILLAIN(K) = PRE(I);\n      V1: END;\n NVILLAIN = K;\n-PUT PAGE FILE(SYSPRINT) EDIT('THERE APPEAR TO BE ', NVILLAIN,\n      ' BASE PTFS CAUSING TROUBLE.')  (A,F(3),A)\n      ('THEY ARE EITHER EXCLUDED OR MISSING FROM THE PTS.') (SKIP,A);\n PUT SKIP(2) FILE(SYSPRINT);\n-DO I = 1 TO NVILLAIN;                  /* SORT VILLAINS */\n      DO J = 1 TO NVILLAIN;\n           IF VILLAIN(I) < VILLAIN(J)\n                THEN DO;\n                TEMPV = VILLAIN(J);\n                VILLAIN(J) = VILLAIN(I);\n                VILLAIN(I) = TEMPV;\n                END;\n           END;\n      END;\n-DO I = 1 TO NVILLAIN;                  /* LIST SORTED VILLAINS */\n      PUT SKIP EDIT(I,VILLAIN(I)) (F(5),X(5),A);\n      END;\n-PUT PAGE FILE(SYSPRINT) EDIT('THE FOLLOWING IS THE APPARENT',\n     ' RELATIONSHIP AMONG THE TERMINATED PTFS:') (A,A);\n-DO I = 1 TO NVILLAIN;\n     LEVEL = 0;\n     CALL TREE(VILLAIN(I),LEVEL);\n     END;\n-RETURN;\n1TREE: PROC(V,L) RECURSIVE;\n-DCL (L,II,KOL,LL) FIXED BIN(31);\n DCL V CHAR(7);\n-LL = L + 1;\n KOL = 1 + 11*(LL-1);\n IF LL > 15 THEN STOP;    /* ERROR STOP -- OR GET WIDER PAPER */\n-IF LL = 1\n     THEN DO;\n          PUT SKIP(4) EDIT(V) (COL(KOL),X(3),A(7));\n          END;\n     ELSE DO;\n          PUT SKIP(0) EDIT('<--',V) (COL(KOL), A, A);\n          SKIPPED = '0'B;\n          END;\n-DO II = 1 TO NTERM;\n     IF PRE(II) = V THEN CALL TREE(TERM(II),LL);\n     END;\n-IF \u00ac SKIPPED THEN PUT SKIP(1) FILE(SYSPRINT);\n SKIPPED = '1'B;\n RETURN;\n-END TREE;\n-END XREF;\n//GO.SYSPRINT DD SYSOUT=*,DCB=(LRECL=133,BLKSIZE=133,RECFM=FA)\n//GO.SMPOUT DD DISP=SHR,DSN=CSYSCST.OUTPUT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SALVAGE": {"ttr": 9484, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\n\\x1e\\n\\x1e\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 2590, "newlines": 2590, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMASA JOB MSGCLASS=A,NOTIFY=CSYSMAS,COND=(0,NE)\n/*ROUTE PRINT WYLBUR\n//ASM EXEC ASMHCL,\n//  PARM.LKED='XREF,NCAL,LET,MAP,AC=1'\n//ASM.SYSLIB DD\n//           DD\n//           DD DISP=SHR,DSN=SYS5.MSSMAC\n TITLE 'SALAVGE - COMMENTS - DASD RECOVER / ANALYZE / REPLACE'\n*---------------------------------------------------------------------*\n*                                                                     *\n* SALVAGE - DASD RECOVER / ANALYZE / REPLACE                          *\n*                                                                     *\n*  HARDWARE (HDA) SALVAGE PROGRAM ---                                 *\n*                                                                     *\n*  *** BEWARE *** BEWARE *** BEWARE *** BEWARE *** BEWARE *** BEWARE  *\n*                                                                     *\n*   DO NOT USE THE \"WRTSD\" COMMAND UNLESS:                            *\n*   1 - YOU KNOW WHAT OLTEP 3350PSC M3 & M5 OPTIONS ARE               *\n*   2 - YOU UNDERSTAND 3350 SKIP DISPLACEMENT HARDWARE IMPLEMENTATION *\n*                                                                     *\n*   THIS PROGRAM CAN BE USED TO ASSIGN SKIP DISPLACEMENTS             *\n*   BY \"HAND\" TO 3350'S.  THUS SKIP DISPLACEMENTS MAY BE              *\n*   ASSIGNED TO TRACKS ON WHICH M5 WILL NOT FIND ERRORS.              *\n*   IN SOME CASES THIS CAN BE FROM SEVERAL MONTHS OF LOGREC           *\n*   DATA.  (THIS IS ESP USEFUL ON FIXED HEAD TRACKS).                 *\n*                                                                     *\n*   IT IS POSSIBLE TO CREATE A SITUATION IN WHICH REPLACING           *\n*   THE HDA MAY BE THE FASTEST WAY OUT.                               *\n*   (IF SKIP DISPLACEMENTS ARE LOST).                                 *\n*                                                                     *\n* OLTEP M3/M5 NOTE: OLTEP DOES NOT KNOW ABOUT ALT TRKS.               *\n*   WHEN OLTEP REWRITES HOME ADDRESSES, HE MAKES THEM ALL PRIMARIES,  *\n*   THUS YOU *MUST* RE-INIT THE PACK TO REWRITE THEM AGAIN.           *\n*                                                                     *\n*   THE \"WRITE\" COMMAND CAN WRITE RECORDS WITH COUNT FIELDS WHICH     *\n*   DO NOT MATCH THE TRACK THAT THEY ARE ON.  MOST DUMP PROGRAMS      *\n*   WILL THEN REFUSE TO DUMP THE DISK PACK.                           *\n*                                                                     *\n* NOTES: ORIGINAL PLAN WAS TO RECOVER DATA FROM TRACK                 *\n*        AND SAVE IN \"SAVE\" FILE.  THIS CODE WAS NEVER WRITTEN.       *\n*        IT IS SAFER TO USE FDRDSF OR EQUIV TO SAVE THE TRACK         *\n*        IF POSSIBLE.  THUS SAVE FILE IS OPENED/CLOSED BUT NEVER      *\n*        USED.                                                        *\n*                                                                     *\n*        ICKDSF R6 IS RUMORED TO SUPPORT SKIP DISPLACEMENTS           *\n*        ON 3350'S, THUS SOME USES OF SALVAGE MAY SOON BE OBSOLETE.   *\n*                                                                     *\n*  MICHAEL STEIN                                                      *\n*  OFFICE OF ACADEMIC COMPUTING                                       *\n*  5628 MATH SCIENCES ADDITION                                        *\n*  LOS ANGELES, CALIFORNIA 90024                                      *\n*                                                                     *\n*    OPTIONS:                                                         *\n*             1. RESTART FROM SAVE FILE.                              *\n*             2. DISPLAY / ALTER DATA ON TRACK.                       *\n*             3. SCAN FOR ERRORS.                                     *\n*             4. SCAN/TEST FOR ERRORS. (DESTROYS DATA - FORMAT WRITES)*\n*                                                                     *\n*                                                                     *\n*    JCL (OR FILES TO ALLOCATE FOR TSO)                               *\n*                                                                     *\n*                                                                     *\n*      //    EXEC   PGM=SALVAGE                                       *\n*      //STEPLIB  DD DISP=SHR,DSN=???                                 *\n*      //SAVE     DD  <SAVE FILE FOR THIS RUN>                        *\n* THREE CHOICES FOR FOLLOWING CARD INDICATING VOLUME/UNIT TO FIX:     *\n*    PROCESS BY DATASET:                                              *\n*      //VOLUME   DD DISP=OLD,DSN=?????                               *\n*    PROCESS BY UNIT ADDRESS: (CAN POINT TO ANY UNIT,                 *\n*    (UNIT *MUST* BE ONLINE ON AN MVS SYSTEM...)                      *\n*       NOT REQUIRED TO BE ONE TO PROCESS, IE: IF VOLUME LABEL BAD)   *\n*      //VOLUME   DD DISP=OLD,DSN=     ,VOL=SER=????                  *\n*                                                                     *\n*      //SYSPRINT DD SYSOUT=A         (LRECL=133,RECFM=FBA)           *\n*      //SYSIN    DD *                                                *\n*        <CONTROL CARDS OR TSO INPUT>                                 *\n*      //                                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*   GENERAL RESTRICTIONS AND ASSUMPTIONS ---                          *\n*    (THERE ARE SOME EXCEPTIONS TO THESE ASSUMPTIONS).                *\n*     1. EACH TRACK HAS HOME ADDRESS ALREADY WRITTEN WITH THE         *\n*        PHYSICAL SEEK ADDRESS OF THAT TRACK.                         *\n*     2. EACH TRACK HAS STANDARD FORMAT RECORD ZERO WITH ZERO KEY     *\n*        LENGTH AND EIGHT BYTE DATA LENGTH.  RECORD ZERO COUNT FIELD  *\n*        CONTAINS LOGICAL TRACK ADDRESS.                              *\n*     3. IF THE TRACK CONTAINS ANY OTHER RECORDS, THEY HAVE IDS       *\n*        WHICH START WITH RECORD NUMBER ONE AND CONTINUE UP BY ONE.   *\n*        ALL RECORD NUMBERS ON THE TRACK ARE UNIQUE AND IN ORDER.     *\n*                                                                     *\n*        NOTE: THIS DOES NOT REQUIRE THE CCHH PART OF THE RECORD IDS  *\n*              OF RECORDS AFTER ZERO TO CONTAIN ANY SPECIFIC VALUE.   *\n*                                                                     *\n*                                                                     *\n*   DEFECTIVE/ALTERNATE TRACKS ---                                    *\n*     TRACK CONDITION CHECK (SENSE BIT) - CMD OTHER THAN              *\n*         SEARCH HA, READ HA, READ R0 ON DEFECTIVE TRACK.             *\n*                                                                     *\n*                                                                     *\n*     HA CONTAINS SEEK ADDRESS                     (PHYSICAL ADDRESS) *\n*     R0 CONTAINS CCHH OF DEFECTIVE IF ALTERNATE,  (LOGICAL ADDRESS)  *\n*                 CCHH OF ALTERNATE IF DEFECTIVE.                     *\n*        CCHH IN COUNT FIELDS OF RECORDS ON REST                      *\n*        OF TRACK MATCH CCHH OF R0.                (LOGICAL ADDRESS)  *\n*                                                                     *\n*  VM NOTES:                                                          *\n*    VIRTUAL ADDRESS IS RELATIVE TO BEGINING OF MINIDISK.             *\n*    (STARTS AT CYLINDER ZERO.)                                       *\n*                                                                     *\n*     HA CONTAINS PHYSICAL SEEK ADDRESS WHICH GETS                    *\n*        CHANGED BY VM AFTER READ TO VIRTUAL ADDRESS.                 *\n*     R0 CONTAINS VIRTUAL ADDRESS IF CONTROLLER IS NOT 3830,          *\n*        ELSE R0 CONTAINS LOGICAL ADDRESS. (FOR CONTROLLER).          *\n*     CCHH IN COUNT FIELDS OF RECORDS ON REST                         *\n*        OF TRACK CONTAIN VIRTUAL ADDRESSES.                          *\n*                                                                     *\n*    VM PACKS (OR MINIDISKS) ONLY USE ALTERNATE TRACKS AS SUCH        *\n*    ON DEVICES WHICH USE 3830 CONTROLLERS (WHERE THE CONTROLLER      *\n*    DOES THE ALTERNATE TRACK RECOVERY.)                              *\n*    EACH VM MINIDISK IS SOME INTEGER NUMBER OF CYLINDERS.            *\n*                                                                     *\n*    (WHY AREN'T THERE V=R MINIDISKS???)                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*   DEVICE CHARACTERISTICS                                            *\n*                                                                     *\n*    2321    -   NOT SUPPORTED  (DATA CELL)                           *\n*    2311    -   ?                                                    *\n*    2314    -                                                        *\n*    2301    -   FILE MASK STRANGE (8 TRACKS/LOGICAL CYL)             *\n*                READ COUNT STRANGE                                   *\n*    2305-1  -   ?                                                    *\n*    2305-2  -                                                        *\n*    3330    -                                                        *\n*    3330V   -   (SAME AS 3330)                                       *\n*    3330-1  -   (3330 WITH MORE CYLINDERS)                           *\n*    3350    -   (KNOWS WHAT DEVICE TYPE IT IS)                       *\n*                (SENSE I/O TYPE)                                     *\n*                                                                     *\n*    (2311, 2314)    - TEND TO SEEK TO WRONG TRACK (CHECK HA)         *\n*    (2305-1,2305-2) - HA NOT WRITTEN TO TRACK. (ALWAYS CORRECT)      *\n*                    - ORIENT CMD (2305-1 ONLY)                       *\n*                    - VARY SENSING CMD                               *\n*      FILE MASK - 01.. .... - NO WRITE COMMANDS                      *\n*                  10.. .... - WRITE DATA/KEY DATA ONLY               *\n*                  00.. .... - ALL WRITE CMDS BUT WRITE HA / R0       *\n*                  11.. .... - ALL WRITE CMDS ALLOWED                 *\n*                  ..X. .... - <UNUSED>                               *\n*                  ...0 0... - ALL SEEK COMMANDS                      *\n*                  ...0 1... - SEEK CYL / HEAD ONLY                   *\n*                  ...1 0... - SEEK HEAD ONLY                         *\n*                  ...1 1... - NO SEEKS ALLOWED                       *\n*                  .... .X.. - DIAGNOSTIC WRITE                       *\n*                  .... ..0X - PERMIT COMMAND RETRY                   *\n*                  .... ..01 - INTERUPT AFTER CMD RETRY (PCI FETCH)   *\n*                  .... ..10 - INHIBIT COMMAND RETRY (2305 ONLY)      *\n*                                                                     *\n*    (3350)          - SKIP DISPLACEMENTS                             *\n*                                                                     *\n*       SKIP DISPLACEMENT MAPS ON CE CYLINDERS:                       *\n*        CYL 0401 HEAD 0; EACH BLOCK ON TRK 7F8 LONG;                 *\n*          MAY BE MORE THAN ONE BLOCK;                                *\n*        'SDMAP' FOLLOWED BY 9 BYTES ENTRIES  CCH SD SD SD            *\n*         ONLY TRACKS WITH NON-ZERO SKIP DISPLACEMENT ARE LISTED      *\n*         CC OF X'FE00' AT END OF MAP (FOLLOWED BY ALL ZEROS)         *\n*                                                                     *\n* FIX LIST: 3375'S AND 3380'S COMPUTE MAX BLOCK DIFFERENTLY;          *\n*           USE TRKCALC MACRO OR ???                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n TITLE 'SALAVGE - MACROS - DASD RECOVER / ANALYZE / REPLACE'\n         MACRO\n&LBL     RCALL &RTN,&R1,&R0,&ERRAD=\n         LCLC  &L\n&L       SETC  '&LBL'\n         AIF   ('&R1' EQ '' OR '&R1' EQ '(R1)').R1OK2\n         AIF   ('&R1'(1,1) EQ '(').R1REG\n         AIF   ('&R1' EQ '0').R1Z\n&L       LA    R1,&R1\n         AGO   .R1OK1\n.R1Z     ANOP\n&L       SR    R1,R1\n         AGO   .R1OK1\n.R1REG   ANOP\n&L       LR    R1,&R1(1)\n.R1OK1   ANOP\n&L       SETC  ''\n.R1OK2   ANOP\n         AIF   ('&R0' EQ '' OR '&R0' EQ '(R0)').R0OK2\n         AIF   ('&R0'(1,1) EQ '(').R0REG\n         AIF   ('&R0' EQ '0').R0Z\n&L       LA    R0,&R0\n         AGO   .R0OK1\n.R0Z     ANOP\n&L       SR    R0,R0\n         AGO   .R0OK1\n.R0REG   ANOP\n&L       LR    R0,&R0(1)\n.R0OK1   ANOP\n&L       SETC  ''\n.R0OK2   ANOP\n&L       BALR  R10,R12                  TO RCALL\n         DC    Y(&RTN-$)                OFFSET OF ROUTINE\n         AIF   ('&ERRAD' EQ '').EXIT\n         BNZ   &ERRAD\n.EXIT    MEND\n         SPACE 1\n         MACRO\n&LBL     DEVICE &NAME,&TYPE,&ALT=0,&CE=(0,0)\n&LBL     DC     CL8'&NAME',XL1'&TYPE',XL17'00',Y(&ALT),Y&CE\n         MEND\n         SPACE 1\n         MACRO\n&LBL     SBIT  &FLD,&BYTE,&BIT,&MSG\n         LCLA  &A\n         AIF   ('&FLD' EQ 'CSW').CSW\n&A       SETA  16                       SKIP CSW STATUS BITS\n.CSW     ANOP\n&A       SETA  &A+(&BYTE*8)+&BIT\n&LBL     DC    AL1(&A),CL20&MSG\n         MEND\n         SPACE 1\n         MACRO\n&LBL     MSG  &M\n         LCLA &A,&B\n&A       SETA K'&M\n&B       SETA &A-1\n&LBL     DC   AL1(&B),CL&A&M\n         MEND\n TITLE 'SALVAGE - TRACK IMAGE FORMAT DSECT'\n* TRACK IMAGE FORMAT:\n*  THERE ARE THREE SECTIONS TO THE TRACK IMAGE.\n*   1. FIXED LENGTH PREFIX.\n*       CONTAINS RDW\n*   2. FIXED LENGTH RECORD INDEX.\n*       CONTAINS ONE ENTRY FOR EACH OF 257 POSSIBLE RECORDS\n*       ON THE TRACK (THE HOME ADDRESS IS THE FIRST).  THESE\n*       ENTRIES ARE ADDRESSED BY (REC# * 16) + T#BASE.\n*       THIS MAKES THE HOME ADDRESS RECORD -1.\n*   3. KEY/DATA AREA (VARIABLE LENGTH).\n*       THIS AREA IS POINTED TO BY 'T#ROFF'. IT ALWAYS CONTAINS\n*       THE KEY FIRST, THEN THE DATA AREA. NOTE THAT THE KEY\n*       MAY NOT BE VALID IF 'T#REFLG,T#RFKEY' IS ON\n*       AND 'T#RSFLG,T#RFKEY' IS OFF.\n         SPACE 1\nT#       DSECT ,\nT#RDW    DC    Y(0,0)                   RECORD DESCRIPTOR WORD\n         SPACE 1\nT#ENTRY  DC    0D'0'                    BEGINING OF ONE RECORD ENTRY\nT#REFLG  DC    XL1'00'                  FIELD EXISTS FLAGS\nT#RFCNT  EQU   X'80'                     COUNT FIELD\nT#RFKEY  EQU   X'40'                     KEY FIELD\nT#RFDATA EQU   X'20'                     DATA FIELD\nT#RFHA   EQU   X'10'                     HOME ADDRESS\nT#RFERR  EQU   X'01'                     PERM ERROR IN RECORD\nT#RSFLG  DC    XL1'00'                  FIELD SAVED FLAGS\nT#ROFF   DC    H'0'                     OFFSET OF KEY/DATA AREA\n         DC    XL4'00'                  <RESERVED>\nT#RCNT   DC    XL8'0000000000000000'    COUNT FIELD\nT#RL     EQU   *-T#ENTRY\n         SPACE 1\nT#BASE   EQU   *                        ENTRY FOR RECORD 0\n         ORG   *+T#RL*256               HA + 256 RECORDS\nT#L      EQU   *-T#                     TOTAL HEADER LENGTH\n TITLE 'SALAVGE - GLOBALS - DASD RECOVER / ANALYZE / REPLACE'\n*---------------------------------------------------------------------*\n*\n*   REGISTER USAGE:   R13 - STACK POINTER\n*                     R12 - GLOBAL PROGRAM BASE\n*                     R11 - LOCAL PROGRAM BASE\n*                     R10 - LINKAGE REGISTER\n*\n*---------------------------------------------------------------------*\n         SPACE 1\nSALVAGE  CSECT                          START CSECT\n$        EQU   SALVAGE                  BASE FOR OFFSETS (R12)\n         USING SALVAGE,R12              GLOBAL BASE\n         STM   R2,R11,12+4*R2(R13)      SAVE CALLERS R2 - R11\n         SH    R13,=H'72'               BACK UP TO NEXT SAVE AREA\n         LH    R11,0(,R10)              GET CALLED ROUTINE OFFSET\n         AR    R11,R12                  @ CALLED ROUTINE\n         CL    R13,G#STACK              STACK FULL?\n         BNLR  R11                      BIF STACK NOT FULL\n         EX    0,*                      ** STACK OVERFLOW **\n         SPACE 1\nRETM     LA    R15,4                    SET RETURN CODE\n         LCR   R15,R15                  NEGATIVE RETURN CODE\n         B     RET                      AND RETURN\nRETNZ    LA    R15,4                    SET RETURN CODE\n         B     RET                      AND RETURN\nRETZ     SR    R15,R15                  SET RETURN CODE\nRET      LA    R13,72(,R13)             STACK PTR BACK UP\n         LM    R2,R11,12+4*R2(R13)      RESTORE REGISTERS\n         LTR   R15,R15                  SET CONDITION CODE\n         B     2(,R10)                  RETURN (SKIP OFFSET)\n         SPACE 1\n*  S$GET  -  RETURNS TO R10 AFTER GETTING NEXT INPUT RECORD AND\n*            SETTING SCAN POINTERS.\n*             (MUST UPPER CASE INPUT ***********)\n*    CC:  ZERO - EOF HAS OCCURED;  NOT ZERO - NEW INPUT RECORD OBTAINED\n*    (SKIPS COMMENT INPUT RECORDS)\n*\n*     DESTROYS:  R0, R1, R10, R14, R15.\n         SPACE 1\nS$GET    ST    R10,S#GETSAV             SAVE RETURN ADDR\n         NI    S#GETFLG,255-S#FATTN     NO ATTEN YET\n         TM    S#GETFLG,S#FEOF          EOF YET?\n         BO    S$GETEOF                 BIF EOF ALREADY\nS$GET2   GET   SYSIN,S#GETBUF           SET R1 TO ADDR OF INPUT RECORD\n         LA    R15,S#GETBUF             @ INPUT RECORD\n         LA    R1,S#GETBUF+71           @ LAST BYTE OF INPUT DATA\n         LA    R0,1                     INIT CONSTANT FOR SCAN\n         STM   R15,R1,S#SCNPTR          SAVE SCAN VALUES\n         OC    S#GETBUF(72),=CL72' '    FORCE UPPER CASE\n         TM    S#GETFLG,S#FECHO         ECHO INPUT?\n         BZ    S$GETCK\n         MVC   LINE+1(80),S#GETBUF      SET INPUT RECORD\n         BAL   R10,S$PRINT              PRINT THE LINE\nS$GETCK  CLI   S#GETBUF,C'*'            COMMENT?\n         BE    S$GET2                   BIF COMMENT TO SKIP IT\nS$GETE   L     R10,S#GETSAV             RESTORE RETURN ADDR\n         BR    R10                      AND RETURN\nS$GETEOF OI    S#GETFLG,S#FEOF          SET EOF FLAG\n         SR    R15,R15                  SET CC EQUAL\n         B     S$GETE                   AND GO RETURN\n         SPACE 1\n*  S$SCN - RETURNS TO R10 WITH:  CC SET TO LENGTH RETURNED;\n*         IF LENGTH IS < 0 THEN NO MORE INPUT RECORD EXISTS.\n*         IF LENGTH IS > 0 THEN R15 CONTAINS LENGTH,\n*            R14 CONTAINS @ OF STRING.\n*     (LENGTH ZERO CAN NOT OCCUR).\n*    DESTROYS:  R0, R1, R10, R14, R15.\n         SPACE 1\nS$SCN    LM    R15,R1,S#SCNPTR          GET SCAN VALUES\nS$SCN1   CR    R1,R15                   ANY INPUT LEFT? (SET CC)\n         BLR   R10                      RETURN IF NO INPUT LEFT\n         SPACE 1\nS$SCNLP1 CLI   0(R15),C' '              SKIP LEADING BLANKS\n         BNE   S$SCNFD1                 BIF NON-BLANK FOUND\n         BXLE  R15,R0,S$SCNLP1          BIF STILL SKIPING BLANKS\n         B     S$SCN1                   BIF NO MORE INPUT\n         SPACE 1\nS$SCNFD1 LR    R14,R15                  SAVE @ INPUT STRING\nS$SCNLP2 CLI   0(R15),C' '              SKIP NON-BLANKS\n         BE    *+8                      BIF BLANK FOUND\n         BXLE  R15,R0,S$SCNLP2          BIF TO SCAN FOR BLANK\n         ST    R15,S#SCNPTR             SAVE NEW SCAN PTR\n         SR    R15,R14                  GET LENGTH SCANNED\n         BR    R10                      AND RETURN\n         SPACE 2\n*  S$STR -  MOVES STRING TO DWD IF LENGTH <= 8\n*           AFTER CALL TO S$SCN.\n*       CC:  HIGH IF TOO LONG; ELSE STRING MOVED\n         SPACE 1\nS$STR    MVC   DWD(8),=CL8' '           INIT OUTPUT TO BLANKS\n         CH    R15,=H'8'                STRING TOO LONG?\n         BHR   R10                      BIF STRING TOO LONG\n         BCTR  R15,0                    GET EX LENGTH\n         EX    R15,S$STRMVC             MVC DWD(0),0(R14)\n         BR    R10                      AND RETURN\nS$STRMVC MVC   DWD(0),0(R14)            * EXECUTED *\n         EJECT ,\n*  S$HEX - CALLS S$SCN AND RETURNS HEX VALUE IN R0,R1.\n*         RETURNS TO R10.\n*  CC:  M - NO STRING,\n*       Z - INVALID HEX STRING,\n*       P - HAVE HEX VALUE\n         SPACE 1\nS$HEX    ST    R10,G#WORK               SAVE RETURN ADDR\n         BAL   R10,S$SCN                GO GET SOME HEX\n         L     R10,G#WORK               RESTORE RETURN ADDR\n         BMR   R10                      BIF NO INPUT\n         CH    R15,=H'16'               CHECK STRING LENGTH\n         BH    S$HEXER                  BIF HEX STRING TOO LONG\n         SR    R0,R0                    CLEAR FOR SLDL\n         SR    R1,R1\n         SR    R10,R10                  CLEAR FOR IC\nS$HEXL   IC    R10,0(,R14)              GET CHARACTER\n         SH    R10,=Y(C'0')             CONVERT 0 - 9\n         BNM   S$HEXD                   BIF 0 - 9\n         AH    R10,=Y(C'0'-C'A'+X'0A')  CONVERT A - F\n         BM    S$HEXER                  BIF < C'A'\n         CH    R10,=Y(X'0F')            > C'F'?\n         BH    S$HEXER                  BIF > 'F'\nS$HEXD   SLDL  R0,4                     MAKE ROOM FOR NEXT HEX DIGIT\n         OR    R1,R10                   OR IN DIGIT\n         LA    R14,1(,R14)              BUMP CHARACTER PTR\n         BCT   R15,S$HEXL               SCAN ALL OF STRING\n         LTR   R14,R14                  SET CC POSITIVE\nS$HEXE   L     R10,G#WORK               RESTORE RETURN ADDR\n         BR    R10                      AND RETURN\nS$HEXER  SR    R15,R15                  SET CC ZERO (MISSING INPUT)\n         B     S$HEXE                   AND GO RETURN\n         SPACE 2\n*  S$MSG - R1 = @ EX LEN, MSG\n*    PRINTS MSG AND RETURNS\n*\nS$MSGMVC MVC   LINE+1(0),1(R1)          * EXECUTED *\nS$MSG    SR    R15,R15                  CLEAR FOR IC\n         IC    R15,0(,R1)               GET MSG LENGTH - 1\n         EX    R15,S$MSGMVC             MVC LINE+1(0),1(R1)\n*+++++++ B     S$PRINT                  GO PRINT MSG AND RETURN\n         SPACE 1\n*  S$PRINT  -   R10 - RETURN ADDRESS\n*    PRINTS LINE AND BLANKS IT\n*\nS$PRINT  PUT   SYSPRINT,LINE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         BR    R10\n         SPACE 2\n*   S$CLEAR;  S$MOVE  -  R0  - LENGTH TO CLEAR OR MOVE\n*                        R1  - TO ADDRESS\n*                        R15 - FROM ADDRESS\n*                        R10 - RETURN ADDRESS\n         SPACE 1\nS$CLEAR  LTR   R0,R0                    ANY TO CLEAR?\n         BNPR  R10                      RETURN IF NOTHING TO DO\n         MVI   0(R1),0                  CLEAR FIRST BYTE\n         LR    R15,R1                   SET FROM ADDRESS\n         LA    R1,1(,R1)                BUMP TO POINTER\n         BCTR  R0,0                     LENGTH LEFT TO CLEAR\n         SPACE 1\nS$MOVE   LTR   R0,R0                    ANY TO MOVE?\n         BNPR  R10                      RETURN IF NONE\n         LA    R14,256                  CONSTANT\nS$MOVE1  CR    R0,R14                   ROOM FOR BIG MOVE?\n         BNH   S$MOVE2                  BIF SMALL MOVE REQUIRED\n         MVC   0(256,R1),0(R15)         MOVE SOME OF IT\n         AR    R1,R14                   BUMP TO ADDRESS\n         AR    R15,R14                  BUMP FROM ADDRESS\n         SR    R0,R14                   LENGTH LEFT TO MOVE\n         B     S$MOVE1\nS$MOVE2  LR    R14,R0                   COPY LENGTH LEFT\n         BCTR  R14,0                    GET EXECUTE LENGTH\n         EX    R14,S$MOVE3              MVC 0(0,R1),0(R15)\n         AR    R1,R0                    BUMP TO ADDRESS\n         AR    R15,R0                   AND FROM ADDRESS\n         BR    R10                      AND RETURN\nS$MOVE3  MVC   0(0,R1),0(R15)           * EXECUTED *\n         SPACE 2\nS$CCWI   MVC   G#BUFPT,G#BUFIT          RE-INIT BUF AREA PTR\n         MVC   G#CCWPT,G#CCWIT          RE-INIT CCW AREA PTR\n         L     R2,G#CCWPT               INIT CCW PTR REG\n         BR    R10\n         SPACE 1\n* S$CCWD - BUILD CCW (WITH DATA AREA RESERVED)\n* S$CCW  - BUILD CCW (NO DATA AREA RESERVED)\n*    R14,R15 - CCW OR PATTERN CCW TO BUILD\n*    R2      - @ - 8 FOR THIS CCW\n*    R10     - RETURN ADDRESS\n*    R1      - WORK REG (CONTENTS DESTROYED)\n         SPACE 1\nS$CCWD   LR    R1,R15                   COPY LENGTH FROM PATTERN\n         N     R1,=X'0000FFFF'          ONLY WANT LENGTH\n         O     R14,G#BUFPT             DATA ADDRESS TO CCW\n         A     R1,G#BUFPT              NEW DATA ADDRESS FOR NEXT TIME\n         C     R1,G#BUFMX              OVER MAXIUM DATA ADDRESS?\n         BHR   R10                      RETURN IF OUT OF SPACE\n         ST    R1,G#BUFPT              SAVE NEW DATA PTR\n         SPACE 1\nS$CCW    CL    R2,G#CCWMX               ROOM FOR THIS CCW?\n         BHR   R10                      BIF NO ROOM FOR CCW\n         STM   R14,R15,8(R2)            SET CCW\n         LA    R2,8(,R2)                TO NEXT CCW SPOT - 8\n         BR    R10                      AND RETURN\n         SPACE 2\n*  S$DOIO -   R10 - RETURN ADDRESS; IOBSEEK CONTAINS CCHH\n*    IF \u00acCE MODE SETS IOBSEEKM TO EXTENT CONTAINING CCHH IN IOBSEEK\n*        (IF NO EXTENT CONTAINS CCHH USES ZERO)\n*    IF CE MODE\n*       SAVES CCHH (FOR FULL SEEK)\n*       SETS IOBSEEK TO 1ST TRACK IN 1ST EXTENT\n*       PREFIXES CHANNEL PROGRAM WITH FULL SEEK\n*       ISSUES EXCP/WAIT\n*       RESTORES IOBSEEK AND IOBCCWPT\n*\n         SPACE 1\nS$DOIO   L     R1,DCBDEBAD-IHADCB+VOLUME GET @ DEB\n         TM    S#GETFLG,S#FCE           CE MODE?\n         BO    S$DOCE                   BIF CE MODE\n         SR    R0,R0                    CLEAR FOR IC\n         IC    R0,DEBNMEXT-DEBBASIC(,R1) GET NUMBER OF EXTENTS\n         LR    R15,R0                   SAVE # OF EXTENTS\nS$DOIOL  CLC   IOBSEEKB(6),DEBBINUM-DEBDASD+DEBBASND-DEBBASIC(R1)\n         BL    S$DOION                  BIF BEFORE THIS EXTENT\n         CLC   IOBSEEKC(4),DEBENDCC-DEBDASD+DEBBASND-DEBBASIC(R1)\n         BNH   S$DOIOF                  BIF IN THIS EXTENT\nS$DOION  LA    R1,DEBNMTRK+2-DEBDASD(,R1) TO NEXT EXTENT\n         BCT   R0,S$DOIOL               TRY NEXT EXTENT\n         LR    R0,R15                   ELSE USE EXTENT ZERO\nS$DOIOF  SR    R15,R0                   GET EXTENT NUMBER\n         STC   R15,IOBSEEKM             SET 'M' IN IOB\n         EXCP  IOB                      START THE I/O\n         WAIT  ECB=ECB                  WAIT FOR I/O TO FINISH\n         CLI   ECB,X'7F'                SET CC TO I/O RESULT\n         BR    R10                      AND RETURN\n         SPACE 1\nS$DOCE   MVC   G#CESEEK(8),IOBSEEK      SAVE CURRENT BBCCHH\n         MVC   IOBSEEK+1(6),DEBBINUM-DEBDASD+DEBBASND-DEBBASIC(R1)\n         MVI   IOBSEEKM,0               USE EXTENT ZERO\n         L     R1,G#CCWIT               @ 1ST CCW - 8 (PFX CCW)\n         LA    R14,G#CESEEK+1           @ BBCCHH FOR CE CYL\n         ST    R14,0(,R1)               TO FULL SEEK CCW\n         MVI   0(R1),X'07'              MAKE FULL SEEK\n         MVC   4(4,R1),=X'40000006'      FINISH OFF SEEK\n         ST    R1,IOBCCWPT              POINT TO CCW PREFIX\n         EXCP  IOB\n         WAIT  ECB=ECB                  WAIT FOR I/O TO FINISH\n         MVC   IOBSEEK(8),G#CESEEK       RESTORE CALLERS SEEK ADDR\n         L     R14,G#CCWIT                AND RESTORE\n         LA    R14,8(,R14)                ORIG\n         ST    R14,IOBCCWPT               CCW PTR\n         CLI   ECB,X'7F'                SET CC TO I/O RESULT\n         BR    R10                       AND RETURN\n         SPACE 1\n*  S$RETRY -  R10 - RETURN ADDRESS\n*     CC HIGH IF OVER RETRY COUNT\nS$RETRY  LA    R0,1                     ICR FOR RETRY\n         AH    R0,G#TRY                 BUMP TRY COUNT\n         STH   R0,G#TRY                 NEW TRY COUNT\n         CH    R0,G#RETRY               OVER RETRY COUNT?\n         BR    R10                      RETURN WITH CC SET\n         SPACE 1\n*  S$HEXCVT -  R10  - RETURN ADDRESS\n*              R1   - @ OF STUFF TO CONVERT TO HEX (G#WORK)\nS$HEXCVT UNPK  G#WORK(9),0(5,R1)        1ST WORD\n         UNPK  G#WORK+8(9),4(5,R1)      2ND WORD\n         TR    G#WORK(16),G#HEX         TO REAL HEX\n         BR    R10                      AND RETURN\n         SPACE 1\n*  S$OPEN  -  R3  - @ OPEN LIST\n*             R10 - RETURN ADDRESS\n*\nS$OPEN   LA    R2,99                    ABEND CODE FOR OPEN FAILED\n         OPEN  MF=(E,(R3))              OPEN THE FILES\nS$OPENL  L     R1,0(,R3)                GET A DCB ADDRES\n         TM    48(R1),X'10'             DID THIS ONE OPEN?\n         BZ    ABEND                    BIF OPEN FAILED\n         LA    R3,4(,R3)                TO @ NEXT DCB ADDRESS\n         LTR   R1,R1                    ANY MORE DCBS?\n         BP    S$OPENL                  BIF MORE DCBS TO CHECK\n         BR    R10                      RETURN, ALL OK\n         SPACE 1\n*  S$KEY0 / S$KEYNZ  - R10 - RETURN ADDRESS\n*      REQUIRES PROGRAM BE RUNNING AUTHORIZED...\n         SPACE 1\nS$KEY0   MODESET KEY=ZERO               SET KEY ZERO\n         BR    R10                      AND RETURN\n         SPACE 1\nS$KEYNZ  MODESET KEY=NZERO              BACK TO PROBLEM KEY\n         BR    R10                      AND RETURN\n         SPACE 1\n*  ABEND - R2 = ABEND CODE\nABEND    CLOSE MF=(E,CLSPRT)            CLOSE SYSPRINT\n         O     R2,=X'80000000'          SET DUMP FLAG\n         LR    R1,R2                    SET ABEND CODE\n         ABEND (1)                      AND ABEND WITH DUMP\n         SPACE 1\nG#CORE   DC    A(1)                     @ WORK AREA\nG#COREL  DC    A(0)                     LENGTH OF AREA (TOTAL)\nG#STACK  DC    A(0)                     @ STACK; END OF WORK\n         SPACE 1\nG#CCWIT  DC    A(0)                     @ CCW AREA - 8\nG#CCWPT  DC    A(0)                     @ NEXT CCW - 8\nG#CCWMX  DC    A(0)                     @ LAST CCW - 8\nG#BUFIT  DC    A(0)                     @ BUFFER AREA\nG#BUFPT  DC    A(0)                     @ NEXT AREA IN BUFFER\nG#BUFMX  DC    A(0)                     @ LAST BYTE IN BUFFER\nG#TRKIT  DC    A(0)                     @ TRACK AREA\nG#TRKBS  DC    A(0)                     @ R0 ENTRY\nG#TRKMX  DC    A(0)                     @ LAST BYTE IN TRACK AREA\nG#RANGE  DC    F'0'                     END CCHH OF RANGE\n         SPACE 1\nOPNLST   OPEN  (SYSPRINT,(OUTPUT),SYSIN,(INPUT),                       +\n               SAVE,(UPDAT)),MF=L\nOPNVOL   OPEN  (VOLUME,(UPDAT)),MF=L\n         SPACE 1\nCLSPRT   OPEN  (SYSPRINT),MF=L\n         SPACE 1\nG#WORK   DC    10D'0'                   GLOBAL WORK AREA\nDWD      DC    D'0'\nS#GETSAV DC    A(1)                     S$GET SAVE WORD FOR R10\nS#GETFLG DC    X'00'\nS#FEOF   EQU   X'80'           (S$GET)  EOF HAS OCCURED\nS#FECHO  EQU   X'40'           (S$GET)  ECHO INPUT TO SYSPRINT\nS#FTSO   EQU   X'20'                    RUNNING ON TSO\nS#FATTN  EQU   X'10'                    ATTENTION OCCURED (TSO ONLY)\nS#FEXTS  EQU   X'02'                    FILE MSK/UCB ADR/1ST EXT SAVED\nS#FCE    EQU   X'01'                    CE MODE\nS#SCNPTR DC    A(1,1,0)   R15, R0, R1   SCAN POINTERS\n         SPACE 1\nG#DTUCB  DC    F'0'                     UCB DEVICE TYPE\nG#DTSYS  DC    4F'0'                    DEVICE CHARACTERISTICS TABLE\nG#DTSCYL EQU   G#DTSYS+00,2,C'H'        CYLINDERS / PACK\nG#DTSTRK EQU   G#DTSYS+02,2,C'H'        TRACKS / CYLINDER\nG#DTSTLN EQU   G#DTSYS+04,2,C'H'        MAXIUM TRACK LENGTH\nG#DTSBO  EQU   G#DTSYS+06,1,C'X'        BLOCK OVERHEAD (NOT LAST)\nG#DTSBOL EQU   G#DTSYS+07,1,C'X'        BLOCK OVERHEAD (LAST)\nG#DTSBOH EQU   G#DTSYS+06,2,C'H'        HALFWORD BLOCK OVERHEAD\nG#DTSBNK EQU   G#DTSYS+08,1,C'X'        KEY GAP SIZE (- IF NOT KEYED)\nG#DTSFLG EQU   G#DTSYS+09,1,C'X'        FLAGS --\nG#DTSFHO EQU   X'08'                     HALFWORD BLOCK OVERHEAD FMT\nG#DTSFDC EQU   X'02'                     ON FOR 2321\nG#DTSFTL EQU   X'01'                     TOLERANCE FACTOR REQUIRED\nG#DTSTOL EQU   G#DTSYS+10,2,C'H'        TOLERANCE FOR ALL BUT LAST BLK\nG#DTSRRO EQU   G#DTSYS+12,2,C'H'        R0 OVERHEAD FOR SECTOR CALC\nG#DTSRSC EQU   G#DTSYS+14,1,C'X'        NUMBER OF SECTORS FOR DEVICE\nG#DTSRDS EQU   G#DTSYS+15,1,C'X'        NUMBER OF DATA SECTORS\n         SPACE 1\nG#DTMY   DC    32X'00'                  MY DEVICE INFO\nG#DTMALT EQU   G#DTMY+26,2,C'H'         1ST ALTERNATE TRACK CYLINDER\n*                                       (ZERO IF NONE)\nG#DTMCES EQU   G#DTMY+28,2,C'H'         START CE CYLINDER (0 IF NONE)\nG#DTMCEE EQU   G#DTMY+30,2,C'H'         END CE CYLINDER   (0 IF NONE)\nG#MAXBLK DC    F'0'                     MAX BLOCK SIZE ON TRACK\n         SPACE 1\nG#SDVMOD DC    X'00'                    ORIG FILE MASK\nG#SUCBAD DC    Y(0)                     ORIG UCB ADDR OF 1ST EXTENT\nG#SEXT1  DC    XL10'00'                 ORIG CCHHCCHHTT OF 1ST EXTENT\nG#CESEEK DC    XL8'00'                  SAVE IOBSEEK FOR CE MODE\n         SPACE 1\nG#TRY    DC    H'0'                     TRY COUNT\nG#RETRY  DC    H'10'                    MAXIUM RETRY COUNT\n         SPACE 1\n*  X'80' - ALLOW WRITES\n*  X'40' - ALLOW AUTHORIZED COMMANDS\nG#ALLOW  DC    X'00'                    ALLOWED COMMAND FLAGS\n         SPACE 1\n         CNOP  4,8\n         DC    CL8'ECB/IOB'\nECB      DC    F'0'\nIOB      DC    X'C200'                  DATA, CMD CHAIN, UNRELAGED\nIOBSEN0  DC    X'00'                    SENSE BYTE 0\nIOBSEN1  DC    X'00'                    SENSE BYTE 1\n         DC    A(ECB)\nIOBCSW   DC    XL8'00'\nIOBCCWPT DC    A(1)                     @ CHANNEL PROGRAM\n         DC    A(VOLUME,0,0)\nIOBSEEK  DC    XL8'0000000000000000'    SEEK ADDRESS\nIOBSEEKM EQU   IOBSEEK+0,1,C'X'         EXTENT INDEX\nIOBSEEKB EQU   IOBSEEK+1,2,C'X'         BIN NUMBER\nIOBSEEKC EQU   IOBSEEK+3,2,C'X'         CYLINDER NUMBER\nIOBSEEKH EQU   IOBSEEK+5,2,C'X'         HEAD NUMBER\nIOBSEEKR EQU   IOBSEEK+7,1,C'X'         RECORD NUMBER\n         DC    C'IOBSEEK'\nPHYCCHH  DC    F'0'                     PHYSICAL TRACK ADDRESS\nLOGCCHH  DC    F'0'                     LOGICAL TRACK ADDRESS\n         SPACE 1\nS#GETBUF DC    CL80' '                  INPUT CONTROL RECORD\nLINE     DC    CL133' '                 PRINT LINE\n         SPACE 1\nVOLEXT   DC    0F'0',X'87',AL3(V#JFCB)\nPRTEXT   DC    0F'0',X'85',AL3(PRTEXIT)\n         SPACE 1\nPRTEXIT  OC    62(2,R1),62(R1)          ANY BLKSIZE SO FAR?\n         BNZR  R14                      RETURN IF HAVE BLKSIZE\n         MVC   62(2,R1),=AL2(4123)      SET FOR 3330\n         BR    R14                      AND RETURN\n         SPACE 1\n         DC    C'0123456789ABCDEF'      INTERNAL TO HEX TRANSLATE\nG#HEX    EQU   *-256\n         SPACE 1\n         LTORG ,\n         SPACE 1\n         PRINT NOGEN\nVOLUME   DCB   DDNAME=VOLUME,DSORG=PS,MACRF=(E),EXLST=VOLEXT\n         SPACE 1\nSAVE     DCB   DDNAME=SAVE,DSORG=PS,MACRF=(E)\n         SPACE 1\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA,  +\n               EXLST=PRTEXT\n         SPACE 1\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GM,LRECL=80,RECFM=FB,       +\n               EODAD=S$GETEOF\n         PRINT GEN\n         SPACE 1\n         EJECT ,\n*  COMMAND TABLE\n*    CL8'CMD',XL2'FLAGS',Y(ROUTINE OFFSET)\n*       8000 - OPEN FILE IF NOT OPEN YET.\n*       0080 - WRITE MUST BE ALLOWED\n*       0040 - AUTHORIZATION MUST BE ALLOWED\n*       0020 - HAR0 MUST BE ALLOWED\n*\n         SPACE 1\nCMDTAB   DC    CL8'END     ',XL2'0000',Y(C$END-$,H#END-$)\nCMDTABL  EQU   *-CMDTAB\n         DC    CL8'HELP    ',XL2'0000',Y(C$HELP-$,H#HELP-$)\n         DC    CL8'ECHO    ',XL2'0000',Y(C$ECHO-$,H#ECHO-$)\n         DC    CL8'IMSK    ',XL2'8000',Y(C$IMSK-$,H#IMSK-$)\n         DC    CL8'DEVTYPE ',XL2'8000',Y(DEVTYPE-$,H#DEVT-$)\n         DC    CL8'CHECK   ',XL2'8000',Y(C$CHECK-$,H#CHECK-$)\n         DC    CL8'READ    ',XL2'8000',Y(READ-$,H#READ-$)\n         DC    CL8'PRTSD   ',XL2'8000',Y(C$PRTSD-$,H#PRTSD-$)\n         DC    CL8'PRTSDA  ',XL2'8000',Y(C$PRTSDA-$,H#PRTSDA-$)\n         DC    CL8'DISPTRK ',XL2'0000',Y(DISPTRK-$,H#DISPT-$)\n         DC    CL8'REWRITE ',XL2'8080',Y(REWRITE-$,H#RW-$)\n         DC    CL8'ALLOW   ',XL2'0000',Y(ALLOW-$,H#ALLOW-$)\n         DC    CL8'VOLUME  ',XL2'0040',Y(C$VOL-$,H#VOL-$)\n         DC    CL8'UNIT    ',XL2'0040',Y(C$UNIT-$,H#UNIT-$)\n         DC    CL8'WRITE   ',XL2'8080',Y(C$WRITE-$,H#WRITE-$)\n         DC    CL8'SCAN    ',XL2'8000',Y(C$SCAN-$,H#SCAN-$)\n         DC    CL8'CE      ',XL2'8040',Y(C$CE1-$,H#CE1-$)\n         DC    CL8'RESET   ',XL2'8000',Y(C$RESET-$,H#RESET-$)\n         DC    CL8'WRTSD   ',XL2'80E0',Y(C$WRTSD-$,H#WRTSD-$)\n         DC    CL8'WRTCK   ',XL2'8080',Y(C$WRTCK-$,H#WRTCK-$)\nCMDTABE  EQU   *-CMDTABL\n TITLE 'SALAVGE - COMMANDS - DASD RECOVER / ANALYZE / REPLACE'\nC$END    OI    S#GETFLG,S#FEOF          FAKE AN EOF HERE\n         B     RETZ                     AND ALL DONE\n         SPACE 1\nC$ECHO   XI    S#GETFLG,S#FECHO         FLIP ECHO FLAG\n         B     RETZ                     AND RETURN\n         SPACE 1\n         USING C$IMSK,R11\nC$IMSK   XI    DCBIFLGS-IHADCB+VOLUME,DCBIFNE3 FLIP USE ERROR RECOVERY\n         SPACE 1\nM$IMSK   BALR  R11,0                    GET NEW BASE\n         USING *,R11\n         MVC   LINE+1(25),=C'IBM ERROR RECOVERY NOW ON'\n         TM    DCBIFLGS-IHADCB+VOLUME,DCBIFNE3 ERROR RECOVERY ON?\n         BZ    *+10                     BIF RECOVERY IS ON\n         MVC   LINE+1+25-2(3),=C'OFF'\n         BAL   R10,S$PRINT\n         B     RETZ                     AND RETURN\n         SPACE 1\n         USING C$CHECK,R11\nC$CHECK  RCALL RANGEI                   INIT RANGE FOR CHECK\n         BNZ   RET                      BIF INVALID OR MISSING OPERAND\nC$CHREAD RCALL READ                     GO READ TRACK\n         BNZ   RET                      RETURN IF ANY ERROR\n         RCALL RANGEN                   DONE?, TO NEXT TRACK\n         BZ    C$CHREAD                 BIF NOT DONE, CONTINUE\n         B     RET                      RETURN IF DONE\n         DROP  R11\n         SPACE 1\n         USING C$PRTSDA,R11\nC$PRTSDA MVI   C#PRTSDF,1              FLAG PRINT ALL SD'S\n         B     C$PRTSD1\n         USING C$PRTSD,R11\nC$PRTSD  MVI   C#PRTSDF,0              FLAG ONLY NON-ZERO SD'S\nC$PRTSD1 BALR  R11,0\n         USING *,R11\n         RCALL RANGEI                  INIT RANGE\n         BNZ   RET\nC$PRTSD2 RCALL RDSD                    READ SD\n         BNZ   RET\n         CLI   C#PRTSDF,0              PRINT IT?\n         BNE   C$PRTSD3\n         L     R3,IOBCCWPT             @ 1ST CCW\n         L     R1,8+8(,R3)             @ FROM SENSE CCW\n         OC    24-6(6,R1),24-6(R1)     SD ALL ZERO?\n         BZ    C$PRTSD4                BIF ALL ZERO, DON'T PRINT\nC$PRTSD3 RCALL PRTSD                   PRINT SD\nC$PRTSD4 RCALL RANGEN                  TO NEXT TRACK IN RANGE\n         BZ    C$PRTSD2                BIF STILL IN RANGE\n         B     RETZ                     ELSE RETURN\nC#PRTSDF DC    X'00'\n         DROP  R11\n         SPACE 1\n         USING PRTSD,R11\nPRTSD    L     R2,IOBCCWPT              @ CCWS\n         MVC   LINE+1(5),=C'CCHH:'\n         LA    R1,IOBSEEKC\n         BAL   R10,S$HEXCVT\n         MVC   LINE+7(8),G#WORK\n         MVC   LINE+16(3),=C'HA:'\n         L     R1,8(,R2)                @ FROM READ HA CCW\n         BAL   R10,S$HEXCVT\n         MVC   LINE+20(2),G#WORK        FLAG BYTE FROM HA\n         MVC   LINE+23(8),G#WORK+2        CCHH FROM HA\n         MVC   LINE+32(3),=C'SD:'\n         L     R1,8+8(,R2)             @ FROM SENSE CCW\n         LA    R1,24-6(,R1)            @ SD BYTES\n         BAL   R10,S$HEXCVT\n         MVC   LINE+36(4),G#WORK       2 SD BYTES\n         MVC   LINE+41(4),G#WORK+4     2 MORE SD BYTES\n         MVC   LINE+46(4),G#WORK+4+4   LAST 2 SD BYTES (FIRST ASSIGNED)\n         BAL   R10,S$PRINT\n         B     RETZ                     AND RETURN\n         DROP  R11\n         SPACE 1\n         USING RDSD,R11\nRDSD     MVC   IOBSEEKC(4),LOGCCHH      SET CCHH FOR TRACK\n         TM    S#GETFLG,S#FATTN         ATTENTION?\n         BO    RETM                     RIF ATTENTION, STOP NOW\n         BAL   R10,S$CCWI               INIT CCW BUILDER\n         LM    R14,R15,SD#CCWSS         SET SECTOR\n         BAL   R10,S$CCWD\n         MVI   0(R14),0                 MAKE SECTOR 0\n         LM    R14,R15,SD#CCWHA         READ HA\n         BAL   R10,S$CCWD\n         LM    R14,R15,SD#CCWSN         SENSE (24 BYTES)\n         BAL   R10,S$CCWD\n         BAL   R10,S$DOIO               EXECUTE I/O\n         BZ    RETZ                     RIF ALL OK\n         RCALL IOERR                    PRINT ERROR STATUS\n         B     RETM                      RETURN\n         DROP  R11\nSD#CCWSS CCW   X'23',0,X'40',1          SET SECTOR 0\nSD#CCWHA CCW   X'1A',0,X'40',5          READ HA, CHAIN\nSD#CCWSN CCW   X'04',0,X'00',24         SENSE (TO GET SKIP DISP)\n         SPACE 1\n         USING RANGEI,R11\n** RANGEI - INIT LOGCCHH/G#RANGE CCHH CCHH FOR COMMANDS\n**   RETURNS:   M - INVALID OR MISSING OPERAND    (MSG ISSUED)\n**              Z - ALL SET\nRANGEI   BAL   R10,S$HEX                GET TRACK ADDR TO CHECK\n         BNP   RANGEI1                  RIF INVALID OR MISSING OPERAND\n         ST    R1,LOGCCHH               SET LOGICAL CCHH\n         ST    R1,G#RANGE                SAVE END OF RANGE\n         BAL   R10,S$HEX                GET END ADDRESS\n         BM    RETZ                     RIF NO SECOND OPERAND\n         BZ    RANGEI1                  BIF INVALID STRING\n         ST    R1,G#RANGE               SAVE END OF RANGE\n         B     RETZ\nRANGEI1  MVC   LINE+1(26),=C'INVALID OR MISSING OPERAND'\n         BAL   R10,S$PRINT\n         B     RETM\n         DROP  R11\n         SPACE 1\n         USING RANGEN,R11\n** RANGEN - TEST LOGCCHH IF RANGE EXCEEDED, BUMP TO NEXT TRACK\n**   RETURN - Z - STILL IN EXTENT\n**            M - NO MORE TRACKS\nRANGEN   CLC   LOGCCHH,G#RANGE          DONE?\n         BNL   RETM                     RETURN IF DONE\n         LH    R1,LOGCCHH+2             GET HH\n         LA    R1,1(,R1)                TO NEXT HEAD ADDR\n         CH    R1,G#DTSTRK              COMPARE WITH TRKS/CYL\n         BL    RANGEN1\n         LH    R2,LOGCCHH\n         LA    R2,1(,R2)                TO NEXT CYLINDER\n         STH   R2,LOGCCHH               SET NEW CC\n         SR    R1,R1                    NEW HH IS ZERO\nRANGEN1  STH   R1,LOGCCHH+2             SET NEW HH\n         B     RETZ                      AND RETURN ZERO\n         DROP  R11\n TITLE 'SALVAGE - REWRITE COMMAND'\n         USING REWRITE,R11\nREWRITE  BAL   R10,S$CCWI               INIT CCW BUILDER\n         L     R7,G#TRKBS               @ ENTRY FOR RECORD 0\n         USING T#ENTRY,R7\n         LA    R7,T#BASE                @ RECORD 1 ENTRY\n         TM    T#RSFLG,T#RFCNT          HAVE COUNT FIELD?\n         BZ    RW$ETRK                  BIF EMPTY TRACK\n         LM    R14,R15,RW#SRCH          SEARCH ID EQ CCW PATTERN\n         BAL   R10,S$CCWD               ADD CCW / RESERVE SPACE\n         MVC   0(4,R14),LOGCCHH         INIT CCHH FOR SEARCH\n         MVI   4(R14),0                 SEARCH FOR RECORD 0\n         LR    R14,R2                   COPY @ LAST CCW\n         O     R14,=X'08000000'         MAKE TIC *-8\n         BAL   R10,S$CCW                BUILD TIC CCW\n         SPACE 1\nRW$LOOP  TM    T#RSFLG,T#RFCNT+T#RFKEY+T#RFDATA ANY RECORD HERE?\n         BZ    RW$EOT\n         LA    R14,T#RCNT               POINT TO COUNT FIELD\n         O     R14,=X'1D000000'         MAKE WRITE COUNT KEY DATA\n         L     R15,=X'80000008'         DATA CHAIN/COUNT LENGTH\n         BAL   R10,S$CCW                BUILD WRITE CKD\n         SR    R0,R0                    CLEAR FOR IC\n         IC    R0,T#RCNT+5              GET KEY LENGTH\n         L     R15,T#RCNT+4             AND DATA LENGTH\n         N     R15,=X'0000FFFF'\n         AR    R15,R0                   TOTAL KEY/DATA WRITE LENGTH\n         BZ    RW$EOF                   BIF NO KEY OR DATA FIELDS\n         O     R15,=X'40000000'         ADD COMMAND CHAIN FLAG\n         LH    R14,T#ROFF               GET OFFSET OF KEY/DATA FIELDS\n         A     R14,G#TRKIT              @ KEY / DATA FIELDS\n         O     R14,=X'1D000000'         ADD CCW OP CODE\n         BAL   R10,S$CCW                BUILD 2ND WRITE FOR RECORD\nRW$NEXT  LA    R7,T#BASE                POINT TO NEXT RECORD ENTRY\n         B     RW$LOOP                  AND CONTINUE\nRW$EOF   XI    4(R2),X'C0'              CHAIN DATA OFF/CMD ON\n         B     RW$NEXT\nRW$EOT   MVI   4(R2),0                  OFF LAST CHAIN FLAG\n         BAL   R10,S$DOIO               RE-WRITE THE TRACK\n         BE    RETZ\n         RCALL IOERR\n         B     RETNZ\nRW$ETRK  MVC   LINE+1(11),=C'EMPTY TRACK'\n         BAL   R10,S$PRINT\n         B     RETNZ\nRW#SRCH  CCW   X'31',0,X'40',5          PATTERN SEARCH ID EQ\n TITLE 'SALVAGE - WRITE COMMAND'\n         USING C$WRITE,R11\nC$WRITE  BAL   R10,S$HEX                GET SEEK/SEARCH ID\n         BNP   RETZ\n         STM   R0,R1,IOBSEEK            SET BBCCHHR\n         BAL   R10,S$CCWI               INIT CCW STUFF\n         LM    R14,R15,C#WSRCID         SEARCH ID EQ\n         BAL   R10,S$CCW                SET SEARCH ID CCW\n         LR    R14,R2                   @ LAST CCW\n         O     R14,=X'08000000'         MAKE TIC *-8\n         BAL   R10,S$CCW                SET TIC *-8\n         LM    R14,R15,C#WRTCKD         PATTERN WRITE COUNT KEY DATA\n         BAL   R10,S$CCWD               SET AND GET COUNT AREA\n         LR    R6,R14                   SAVE DATA ADDRESS\n         BAL   R10,S$HEX                GET COUNT FIELD TO WRITE\n         BNP   RETZ\n         STM   R0,R1,G#WORK             SET TO CCW AREA\n         MVC   0(8,R6),G#WORK\n         BAL   R10,S$DOIO               GO START IT\n         RCALL IOERR                    DO THIS TOO\n         B     RETZ                     AND RETURN\n         DROP  R11\n         SPACE 1\nC#WSRCID CCW   X'31',IOBSEEKC,X'40',5   SEARCH ID EQ\nC#WRTCKD CCW   X'1D',0,0,8              PATTERN WRITE CKD\n TITLE 'SALVAGE - WRTCK COMMAND'\n* WRTCK <CCHH> <OPT # RETRYES>\n         USING C$WRTCK,R11\nC$WRTCK  BAL   R10,S$HEX          GET CCHH\n         BNP   WCK$INV            RIF INVALID\n         LTR   R0,R0\n         BNZ   WCK$INV\n         ST    R1,LOGCCHH         SAVE LOGICAL CCHH\n         LA    R9,10              ASSUME 10 TRIES\n         BAL   R10,S$HEX          RETRY COUNT\n         BNP   *+6                BIF NOT SPECIFIED\n         LR    R9,R1               ELSE USE IT\n         SPACE 1\n*** WRITE TRACK WITH PATTERN\n* R9  - # OF WRITE/READ TRIES TO MAKE\n* R8  - PATTERN TABLE POINTER\nWCK$RTR1 LA    R8,WCK#PAT         PATTERN TABLE\nWCK$RTR2 L     R5,0(,R8)          TRY THIS PATTERN\n         LA    R6,X'1D'           WRITE CKD\n         RCALL WCK$BLD            WRITE THE TRACK\n         BNZ   RETM               RIF ERROR ON WRITE\n         L     R1,C#WCKPTR        @ WRITE CKD CCW FOR DATA FIELD\n         LM    R0,R1,0(R1)        GET ADDRESS / LENGTH\n         L     R14,G#TRKIT        @ TRACK IMAGE AREA\n         LR    R15,R1\n         MVCL  R14,R0             SAVE WRITTEN DATA\n         L     R5,=X'FFFFFFFF'    REFILL BUFFER BEFORE READ\n         LA    R6,X'1E'           READ CKD\n         RCALL WCK$BLD            READ R1 FROM TRACK\n*** CHECK PATTERN READ\n         L     R1,C#WCKPTR        @ READ CKD CCW FOR DATA FIELD\n         LA    R7,LINE+27         @ FOR OFFSET IN LINE\n         LM    R2,R3,0(R1)        GET ADDRESS / LENGTH\n         L     R4,G#TRKIT         @ TRACK IMAGE AREA\n         LR    R5,R3               COPY LENGTH\n         LR    R6,R3              SAVE ORIG COMPARE LENGTH\nWCK$CLC  CLCL  R2,R4              SAME AS WRITTEN DATA?\n         BE    WCK$EQ             BIF SAME DATA\n         LR    R14,R6             ORIG COMPARE LENGTH\n         SR    R14,R3             - LENGTH REMAINING = OFFSET OF ERROR\n         ST    R14,DWD            SAVE OFFSET\n         LA    R1,DWD\n         BAL   R10,S$HEXCVT\n         MVC   0(4,R7),G#WORK+4   OFFSET TO LINE\n         LA    R7,5(,R7)          BUMP LINE PTR\n         LR    R1,R8              @ PATTERN\n         BAL   R10,S$HEXCVT\n         MVC   LINE+1(8),=C'PATTERN:'\n         MVC   LINE+9(8),G#WORK\n         MVC   LINE+19(7),=C'OFFSET:'\n         LA    R0,LINE+L'LINE-8\n         CR    R7,R0\n         BNH   WCK$NEQ\n         BAL   R10,S$PRINT\n         LA    R7,LINE+27\nWCK$NEQ  LA    R0,1\n         AR    R2,R0              SKIP OVER NON-COMPARING BYTE\n         SR    R3,R0\n         AR    R4,R0\n         SR    R5,R0\n         BP    WCK$CLC\nWCK$EQ   LA    R0,LINE+27\n         CR    R7,R0              LINE EMPTY?\n         BE    *+8\n         BAL   R10,S$PRINT\n         TM    S#GETFLG,S#FATTN   ATTENTION?\n         BO    RETM               RIF ATTENTION\n         LA    R8,4(,R8)          BUMP PATTERN PTR\n         CL    R8,=A(WCK#PATE)\n         BNH   *+8\n         LA    R8,WCK#PAT\n         BCT   R9,WCK$RTR2\n         B     RETZ\n         SPACE 1\nWCK$INV  MVC   LINE+1(15),=C'INVALID OPERAND'\n         BAL   R10,S$PRINT\n         B     RETM\n         SPACE 1\nWCK#PAT  DC    0F'0'\n         DC    X'00000000'\n         DC    X'FFFFFFFF'\n         DC    X'AAAAAAAA'\n         DC    X'55555555'\n         DC    X'DB6DB6DB'\n         DC    X'B6DB6DB6'\n         DC    X'6DB6DB6D'\n         DC    X'DB6DB6DB'\n         DC    X'B6DB6DB6'\n         DC    X'6DB6DB6D'\n         DC    X'DB6DB6DB'\n         DC    X'B6DB6DB6'\n         DC    X'6DB6DB6D'\nWCK#PATE EQU   *-4                @ OF LAST PATTERN\n         SPACE 1\n*  BUILD CCW'S FOR READ/WRITE OF MAX LENGTH BLOCK\n*    R6 = CCW OP CODE (WRITE/READ CKD) = X'1D'/X'1E'\n*    R5 = BUFFER FILL PATTERN\n         USING WCK$BLD,R11\nWCK$BLD  BAL   R10,S$CCWI         INIT CCW BUILDER\n         LM    R14,R15,C#WCKSCH   PATTERN SEARCH ID EQ\n         BAL   R10,S$CCWD         SEARCH ID EQ\n         MVC   0(4,R14),LOGCCHH   SEARCH TARGET\n         MVI   4(R14),0            IS RECORD 0\n         LR    R14,R2\n         O     R14,=X'08000000'   TIC *-8\n         BAL   R10,S$CCW\n         LR    R14,R6             COPY CCW OP-CODE (WRITE/READ CKD)\n         SLL   R14,24\n         L     R15,=X'80000008'   COUNT FIELD PART OF CCW, DATA CHAIN\n         BAL   R10,S$CCWD         BUILD WRITE/READ CKD CCW\n         MVC   0(4,R14),LOGCCHH   SET CCHH (FOR POSSIBLE WRITE)\n         MVI   4(R14),1            IS RECORD 1\n         MVI   5(R14),0            KEY LENGTH 0\n         MVC   6(2,R14),G#MAXBLK+2 AND DATA LENGTH\n         LR    R14,R6             COPY CCW OP-CODE (WRITE/READ CKD)\n         SLL   R14,24\n         L     R15,G#MAXBLK       MAX TRACK BLOCKSIZE\n         BAL   R10,S$CCWD         BUILD WRITE/READ CKD CCW\n         ST    R2,C#WCKPTR        SAVE @ CCW FOR CHECK\n         ST    R5,G#WORK\nWCK$BLD1 MVC   0(4,R14),G#WORK\n         LA    R14,4(,R14)\n         SH    R15,=H'4'\n         BNM   WCK$BLD1\n         MVC   IOBSEEKC(4),LOGCCHH INIT SEEK CCHH\n         BAL   R10,S$DOIO         WRITE OR READ\n         BE    RETZ\n         RCALL IOERR\n         B     RETNZ\n         DROP  R11\nC#WCKSCH CCW   X'31',0,X'40',5    SEARCH ID EQ\nC#WCKPTR DC    A(1)               @ OF READ/WRITE DATA AREA CCW\n TITLE 'SALVAGE - WRTSD COMMAND'\n* WRTSD <SD> <SD> <SD> <F> <CCHH>  <OPT R0 CCHH>\n*  FILE ALREADY OPEN; FILE MASK ALLOWS WRITE HA/R0\n*   (SHOULD READ BACK HA/R0?)\n         USING C$WRTSD,R11\nC$WRTSD  CLC   G#DTUCB+2(2),=X'200B' 3350?\n         BNE   WSD$INV            BIF NOT 3350\n         LA    R7,3               WANT 3 SD'S\n         LA    R6,C#WSDWRK        OUTPUT @ FOR SD'S\nWSD$SDL  BAL   R10,S$HEX          CONVERT 1 SD\n         BNP   WSD$INV\n         STM   R0,R1,G#WORK\n         OC    G#WORK(6),G#WORK   ONLY 2 BYTES MAX OF SD\n         BNZ   WSD$INV\n         STH   R1,0(,R6)\n         LA    R6,2(,R6)\n         BCT   R7,WSD$SDL\n         BAL   R10,S$HEX          CONVERT FLAG BYTE\n         BNP   WSD$INV\n         STM   R0,R1,G#WORK\n         OC    G#WORK(7),G#WORK   ONLY ONE BYTE\n         BNZ   WSD$INV\n         STC   R1,C#WSDWRK+6      SAVE FLAG BYTE\n         BAL   R10,S$HEX          CONVERT CCHH\n         BNP   WSD$INV\n         LTR   R0,R0              ALLOW 4 BYTES\n         BNZ   WSD$INV\n         ST    R1,LOGCCHH         SET LOGICAL CCHH\n         MVC   C#WSDWRK+7(4),LOGCCHH COPY TO HA WORK AREA\n         MVC   C#WSDR0(4),LOGCCHH  DEFAULT R0 TO SAME CCHH\n         BAL   R10,S$HEX          OPT R0 CCHH\n         BM    WSD$XR0\n         BZ    WSD$INV\n         LTR   R0,R0              ALLOW 4 BYTES\n         BNZ   WSD$INV\n         ST    R1,C#WSDR0         SET R0 CCHH\n         SPACE 1\nWSD$XR0  RCALL RDSD               READ CURRENT SD\n         BNZ   RETM               RIF I/O ERROR\n         RCALL PRTSD               AND PRINT THEM\n         SPACE 1\n         BAL   R10,S$CCWI         INIT CCW BUILDER\n         LM    R14,R15,C#WSDSHA   @ SEARCH HA EQ CCW\n         BAL   R10,S$CCWD         BUILD SEARCH HA EQ\n         MVC   0(4,R14),C#WSDWRK+7 FILL IN TARGET CCHH\n         LR    R14,R2             MAKE TIC *-8\n         O     R14,=X'08000000'\n         BAL   R10,S$CCW\n         LM    R14,R15,C#WSDWHA   PATTERN WRITE HA\n         BAL   R10,S$CCWD         BUILD WRITE HA\n         MVC   0(11,R14),C#WSDWRK  DATA FOR WRITE HA\n         LM    R14,R15,C#WSDWR0   PATTERN WRITE R0\n         BAL   R10,S$CCWD\n         XC    0(16,R14),0(R14)   INIT R0 TO ALL ZERO CCHHRKDD XXXXXXXX\n         MVC   0(4,R14),C#WSDR0    FILL IN CCHH IN R0\n         MVI   7(R14),X'08'        AND R0 DATA LENGTH\n         MVC   IOBSEEKC(4),LOGCCHH SET CCHH FOR SEEK\n         BAL   R10,S$DOIO         WRITE HA/R0\n         RCALL IOERR\n         B     RETZ\n         SPACE 1\nWSD$INV  MVC   LINE+1(35),=C'INVALID DEVICE TYPE, SD, F, OR CCHH'\n         BAL   R10,S$PRINT\n         B     RETM\n         DROP  R11\n         SPACE 1\nC#WSDSHA CCW   X'39',0,X'40',4    SEARCH HA EQ\nC#WSDWHA CCW   X'19',0,X'40',11   WRITE HA\nC#WSDWR0 CCW   X'15',0,X'00',16   WRITE R0 (STD R0)\nC#WSDR0  DC    F'0'               CCHH FOR R0 (DEFAULTS TO SAME AS HA)\nC#WSDWRK DC    XL11'00'           SD,SD,SD,F,CCHH\n TITLE 'SALVAGE - RESET COMMAND'\n*  RESET -- RESTORE DEB FILE MASK, UCB ADDRESS, AND FIRST EXTENT\n*   NOTE: THIS IS BOTH A COMMAND ROUTINE AND A SUBROUTINE\n         USING C$RESET,R11\nC$RESET  NI    S#GETFLG,X'FF'-S#FCE     CLEAR CE MODE IF ON\n         TM    G#ALLOW,X'40'            ALLOW AUTH?\n         BZ    RETZ                     JUST RETURN IF NOT AUTH\n         TM    S#GETFLG,S#FEXTS   FILE MSK/UCB ADR/1ST EXTENT SAVED?\n         BZ    RETZ               RIF NOTHING TO RESTORE\n         NI    S#GETFLG,X'FF'-S#FEXTS CLEAR SAVED INFO FLAG\n         L     R4,DCBDEBAD-IHADCB+VOLUME @ DEB\n         BAL   R10,S$KEY0               SET KEY ZERO\n* RESTORE FILE MASK\n         MVC   DEBDVMOD-DEBDASD+DEBBASND-DEBBASIC(1,R4),G#SDVMOD\n* RESTORE ORGINAL UCB ADDRESS\n         MVC   DEBUCBAD-DEBDASD+DEBBASND-DEBBASIC+2(2,R4),G#SUCBAD\n* RESTORE FIRST EXTENT\n         MVC   DEBSTRCC-DEBDASD+DEBBASND-DEBBASIC(10,R4),G#SEXT1\n         BAL   R10,S$KEYNZ\n         B     RETZ\n         DROP R11                       (C$RESET)\n         SPACE 1\n* EXTSAVE - SAVE ORIG FILE MASK, UCB ADDRESS, FIRST EXTENT\n         USING EXTSAVE,R11\nEXTSAVE  TM    S#GETFLG,S#FEXTS   FILE MSK/UCB ADR/1ST EXTENT SAVED?\n         BO    RETZ               RIF ALREADY SAVED\n         L     R4,DCBDEBAD-IHADCB+VOLUME @ DEB\n         MVC   G#SDVMOD(1),DEBDVMOD-DEBDASD+DEBBASND-DEBBASIC(R4)\n         MVC   G#SUCBAD(2),DEBUCBAD-DEBDASD+DEBBASND-DEBBASIC+2(R4)\n         MVC   G#SEXT1(10),DEBSTRCC-DEBDASD+DEBBASND-DEBBASIC(R4)\n         OI    S#GETFLG,S#FEXTS   NOW HAVE SAVED INFO\n         B     RETZ\n         DROP R11\n TITLE 'SALVAGE - CE COMMANDS'\n         USING C$CE1,R11\nC$CE1    LH    R5,G#DTMCEE              CE END CYLINDER\n         LTR   R5,R5                    ANY CE CYLINDERS?\n         BZ    CE1$NONE                 BIF NO CE CYLINDERS EXIST\n         SPACE 1\n         L     R4,DCBDEBAD-IHADCB+VOLUME @ DEB\n         BAL   R10,S$KEY0\n* SET ONLY ALLOW CE CYLINDER SEEKS\n         OI    DEBDVMOD-DEBDASD+DEBBASND-DEBBASIC(R4),X'04'\n* ALLOW FULL SEEKS\n         NI    DEBDVMOD-DEBDASD+DEBBASND-DEBBASIC(R4),X'FF'-X'18'\n         BAL   R10,S$KEYNZ\n         OI    S#GETFLG,S#FCE           SET NOW IS CE MODE\n         B     RETZ\n         SPACE 1\nCE1$NONE MVC   LINE+1(L'CE1#MN),CE1#MN    NOT SUPPORTED\n         BAL   R10,S$PRINT\n         B     RETNZ                     AND RETURN ERROR\n         DROP  R11                      C$CE1\nCE1#MN   DC    C'CE CYLINDERS NOT SUPPORTED FOR THIS DEVICE'\n TITLE 'SALVAGE - HELP COMMAND'\n         USING C$HELP,R11\nC$HELP   BAL   R10,S$SCN                SCAN FOR OPERAND\n         BNP   HL$LIST1                 BIF NO OPERAND\n         BAL   R10,S$STR                GET OPERAND STRING\n         BH    HL$LIST1                 BIF INVALID OPERAND\n         BAL   R9,HL$SCAN               FIND COMMAND\n         BH    HL$LIST1                 BIF OPERAND NOT FOUND\n         CLC   DWD(8),0(R3)             THIS THE COMMAND?\n         BNE   HL$NEXT\n         SPACE 1\n         LH    R4,12(,R3)               GET OFFSET OF HELP STRING\n         AR    R4,R12                   @ HELP STRING\nHL$HLOPL LR    R1,R4\n         BAL   R10,S$MSG                PRINT HELP LINE\n         SR    R1,R1\n         IC    R1,0(,R4)\n         LA    R4,1+1(R1,R4)            TO NEXT HELP LINE\n         CLI   0(R4),X'FF'              END OF THE LINE?\n         BNE   HL$HLOPL\n         B     RETZ\n         SPACE 1\nHL$LIST1 LA    R4,HL#TAB                POINT TO TABLE\nHL$LOOP1 LH    R1,2(,R4)                GET MSG OFFSET\n         AR    R1,R12                   MAKE MSG ADDRESS\n         BAL   R10,S$MSG                GO ISSUE IT\n         BAL   R9,HL$SCAN               FIND COMMAND\nHL$LOOP2 BH    HL$LIST2                 BIF NO MORE COMMANDS\n         MVC   G#WORK(1),9(R3)          COPY CMD FLAGS\n         NC    G#WORK(1),1(R4)          TEST ONLY THESE FLAGS\n         CLC   G#WORK(1),0(R4)          THESE FLAGS MATCH?\n         BNE   HL$NEXT                  SKIP IF MISMATCH\nHL$SEL   BAL   R9,HL$PRT                PRINT COMMAND\n         BAL   R9,HL$NEXT\n         B     HL$LOOP2\n         SPACE 1\nHL$LIST2 BAL   R9,HL$FLUSH              FINISH UP LAST LINE\n         LA    R4,4(,R4)                TO NEXT\n         CLI   0(R4),X'FF'              END OF LIST?\n         BNE   HL$LOOP1\n         LA    R1,H#HELP\n         BAL   R10,S$MSG\n         B     RETZ                     AND RETURN\n         SPACE 1\nHL$SCAN  L     R3,=A(CMDTAB)\n         LA    R6,LINE+1                INIT LINE PTR\n         LA    R7,LINE+79-9             END OF LINE PTR\n         SPACE 1\nHL$NEXT  LA    R3,CMDTABL(,R3)          TO NEXT COMMAND\n         CL    R3,=A(CMDTABE)           ALL COMMANDS DONE?\n         BR    R9                       RETURN WITH CC SET\n         SPACE 1\nHL$PRT   CR    R6,R7                    LINE FULL\n         BL    HL$PRTX\n         BAL   R10,S$PRINT              PRINT SO FAR\n         LA    R6,LINE+1\nHL$PRTX  MVC   0(8,R6),0(R3)            COMMAND NAME TO LINE\n         LA    R6,9(,R6)                BUMP OUTPUT PTR\n         BR    R9                       AND RETURN\n         SPACE 1\nHL$FLUSH LA    R0,LINE+1                EMPTY LINE\n         CR    R6,R0                    LINE EMPTY?\n         BER   R9                       RETURN IF DONE\n         BAL   R10,S$PRINT              ELSE PRINT LAST LINE\n         BR    R9                       AND THEN RETURN\n         DROP  R11                      (C$HELP)\n         SPACE 1\nHL#TAB   DC    0F'0'\n         DC    XL2'00FF',Y(C#HLMSG1-$)\n         DC    XL2'8080',Y(C#HLMSG2-$)\n         DC    XL2'4040',Y(C#HLMSG3-$)\n         DC    X'FF'                    END OF TABLE\n         LTORG ,\n         SPACE 1\nC#HLMSG1 MSG   'SAFE COMMANDS --'\nC#HLMSG2 MSG   '*** COMMANDS WHICH MAY DESTROY DATA ***'\nC#HLMSG3 MSG   '*** COMMANDS REQUIRING AUTHORIZATION ***'\n         SPACE 1\nH#END    MSG   'END - EXIT SALVAGE'\n         DC    X'FF'\nH#HELP   MSG   'HELP - ENTER HELP <COMMAND> FOR MORE IMFORMATION'\n         DC    X'FF'\nH#ECHO   MSG   'ECHO - FLIP ECHO INPUT COMMANDS FLAG'\n         DC    X'FF'\nH#IMSK   MSG   'IMSK - FLIP USE IBM ERROR RECOVERY FLAG'\n         DC    X'FF'\nH#DEVT   MSG   'DEVTYPE - DEVICE TYPE / EXTENTS INFORMATION'\n         DC    X'FF'\nH#CHECK  MSG   'CHECK <START CCHH>  <END CCHH>'\n         MSG   ' TRY READING TRACKS (END DEFAULTS TO START IF OMMITED)'\n         DC    X'FF'\nH#READ   MSG   'READ - READ TRACK LAST CHECKED (NO OPERAND)'\n         DC    X'FF'\nH#PRTSD  MSG   'PRTSD <START CCHH>  <END CCHH>'\n         MSG   ' READ SKIP DISPLACMENT AND PRINT IF NON-ZERO'\n         DC    X'FF'\nH#PRTSDA MSG   'PRTSDA <START CCHH>  <END CCHH>'\n         MSG   ' READ SKIP DISPLACMENT AND PRINT (ALL)'\n         DC    X'FF'\nH#DISPT  MSG   'DISPTRK <# LINES>'\n         MSG   '  DISPLAY CURRENT TRACK IMAGE FROM STORAGE'\n         MSG   '  OPERAND IS THE NUMBER OF LINES OF KEY/DATA TO DISPLAY*\n               '\n         DC    X'FF'\nH#RW     MSG   'REWRITE - REWRITE TRACK IMAGE WITH WRITE CKD'\n         MSG   '  THIS CAN LOOSE INFORMATION IF TRACK IMAGE IS NOT COMP*\n               LETE'\n         DC    X'FF'\nH#ALLOW  MSG   'ALLOW <OPERAND>'\n         MSG   ' ALLOWS NON-SAFE COMMANDS TO BE USED, OPERANDS ARE:'\n         MSG   '    WRITE - ALLOW WRITE (CAN DESTROY DATA)'\n         MSG   '    AUTH  - ALLOW ANY VOLUME / UNIT TO BE USED'\n         DC    X'FF'\nH#VOL    MSG   'VOLUME <VOLSER>'\n         MSG   ' <VOLSER> SET AS TARGET, EXTENTS INCLUDE ENTIRE PACK'\n         MSG   ' REQUIRES AUTHORIZATION AND GOOD VTOC/VOLUME LABEL'\n         DC    X'FF'\nH#UNIT   MSG   'UNIT <ADDR>'\n         MSG   ' <ADDR> SET AS TARGET, EXTENTS INCLUDE ENTIRE PACK'\n         MSG   ' REQUIRES AUTHORIZATION '\n         DC    X'FF'\nH#WRITE  MSG   'WRITE <SEARCH CCHHR> <COUNT FIELD>'\n         MSG   ' WRITE CKD OF <COUNT FIELD> AFTER SEARCH ID EQ FOR SEAR*\n               CH CCHHR'\n         MSG   ' BLOCK WILL CONTAIN ZEROS IN KEY/DATA FIELDS IF ANY'\n         MSG   ' **** REST OF TRACK WILL BE ERASED ****'\n         DC    X'FF'\nH#SCAN   MSG   'SCAN <START CYL> <END CYL>'\n         MSG   ' READ CKD/SKIP/SLI SCAN OVER SPECIFIED AREA'\n         MSG   ' BRIEF NOTE FOR ERRORS, DEFECTIVE/ALT TRACKS'\n         MSG   ' TURNS OFF IBM ERROR RECOVERY'\n         DC    X'FF'\nH#CE1    MSG   'CEON'\n         MSG   ' SET EXTENTS TO CE CYLINDERS'\n         DC    X'FF'\nH#RESET  MSG   'RESET'\n         MSG   ' RESTORE DEB TO ORIGINAL STATE'\n         MSG   ' (RESTORES FILE MASK, UCB ADDR, DEB EXTENTS)'\n         DC    X'FF'\nH#WRTSD  MSG   'WRTSD'\n         MSG   ' WRTSD <SD> <SD> <SD> <F> <CCHH> <OPT R0 CCHH>'\n         MSG   ' WRITE HA/R0 WITH SKIP DISPLACMENTS (3350 ONLY)'\n         MSG   ' *** VERY UNSAFE COMMAND ***'\n         DC    X'FF'\nH#WRTCK  MSG   'WRTCK'\n         MSG   ' WRTCK <CCHH> <OPT # RETRIES>'\n         MSG   ' WRITE R1/READ BACK/COMPARE '\n         DC    X'FF'\n TITLE 'SALVAGE - VOLUME / UNIT COMMANDS'\n*   VOLUME/UNIT COMMANDS\nC$UNIT   LA    R11,C$VOL-C$UNIT(,R11)   GET COMMON BASE\n         USING C$VOL,R11\n         MVI   V#FLAG+1,4               INDICATE UNIT ENTRY\n         B     C$VOLX\n         SPACE 1\nC$VOL    MVI   V#FLAG+1,0               INDICATE VOLUME ENTRY\nC$VOLX   BAL   R10,S$SCN                SCAN FOR VOLSER OR UNIT\n         BNP   V$BOPR                   BIF NO OPERAND\n         BAL   R10,S$STR                SET TO DWD\n         BH    V$BOPR                   BIF > 8 CHARS\n         SPACE 1\n         CLOSE MF=(E,OPNVOL)            MAKE SURE IS CLOSED\n         NI    G#ALLOW,255-X'80'        DON'T ALLOW WRITES YET\n         RDJFCB MF=(E,OPNVOL)           GET JFCB OF VOLUME\n         LA    R2,101                   ABEND CODE FOR RDJFCB FAILED\n         BXH   R15,R15,ABEND            BIF RDJFCB FAILED\n         MVI   V#JFCB,X'04'             SET FMT 4 NAME\n         MVC   V#JFCB+1(43),V#JFCB\n         OI    V#JFCB+52,X'08'          DON'T REWRITE JFCB\n         MVI   OPNVOL,X'80'             FORCE OPEN FOR INPUT\n         OPEN  MF=(E,OPNVOL),TYPE=J     OPEN VTOC\n         TM    VOLUME+48,X'10'          DID IT OPEN?\n         BZ    ABEND                    BIF OPENJ FAILED\n         RCALL EXTSAVE                  SAVE ORIG EXTENTS\n         OI    DCBIFLGS-IHADCB+VOLUME,DCBIFNE3 NO IBM ERROR RECOV\n         SPACE 1\n*  FIND UCB WITH SPECIFIED UNIT OR VOLUME AND CHANGE DEB TO\n*   POINT TO IT.\n*\n         SPACE 1\n         BAL   R10,V$UCBSCN             FIND A UCB\n         B     V$NFND                   BIF UCB NOT FOUND\n         USING UCBOB,R6                 BASE FOR UCB\n         LH    R15,V#FLAG               GET SEARCH TYPE\n         B     *+4(R15)                 TO CORRECT SEARCH\n         B     V$VOLSCH                 BIF VOLUME SEARCH\n*   IS UNIT SEARCH\n         CLC   UCBNAME,DWD              THIS THE UCB?\n         BNE   V$UCBNXT                 TRY NEXT IF NOT\n         B     V$UCBFND\n         SPACE 1\nV$VOLSCH CLC   UCBVOLI,DWD              THIS THE VOLUME?\n         BNE   V$UCBNXT\n         SPACE 1\nV$UCBFND L     R4,DCBDEBAD-IHADCB+VOLUME GET @ OF DEB\n         BAL   R10,S$KEY0\n         STH   R6,DEBUCBAD-DEBDASD+DEBBASND-DEBBASIC+2(,R4) SET @ UCB\n         DROP  R6                       (UCBOB)\n         BAL   R10,S$KEYNZ\n         SPACE 1\n*  GET DEVICE TYPE / CHARACTERISTICS / FULL TRACK BUFFER\n         RCALL DEVTYPE,1                DEVTYPE, NO PRINTING\n         SPACE 1\n*  SET EXTENTS IN DEB TO ENTIRE VOLUME (INCLUDING ALT TRKS)\n         XC    G#WORK(10),G#WORK        ZERO CCHHCCHHTT\n         LH    R7,G#DTSCYL   CYLS / PACK\n         LH    R5,G#DTSTRK   TRKS / CYL      0 2 4 6 8\n         LR    R0,R7                    COPY CYLS / PACK\n         BCTR  R0,0                     GET CYL EXTENT LIMIT\n         STH   R0,G#WORK+4       TO CYL EXTENT LIMIT\n         MR    R6,R5                    GET NUMBER OF TRKS IN EXTENT\n         STH   R7,G#WORK+8\n         BCTR  R5,0              GET HEAD EXTENT LIMIT\n         STH   R5,G#WORK+6       TO HEAD EXTENT LIMIT\n         BAL   R10,S$KEY0\n         MVC   DEBSTRCC-DEBDASD+DEBBASND-DEBBASIC(10,R4),G#WORK\n** ALLOW SEEK HEAD COMMANDS IN FILE MASK\n         NI    DEBDVMOD-DEBDASD+DEBBASND-DEBBASIC(R4),X'FF'-X'08'\n         BAL   R10,S$KEYNZ\n         RCALL DEVTYPE,0                DEVTYPE WITH PRINTING\n         B     RETZ                     AND RETURN\n         SPACE 1\nV$NFND   MVC   LINE+1(24),=C'VOLUME OR UNIT NOT FOUND'\n         B     V$PRTRET                 GO PRINT MSG\n         SPACE 1\nV$BOPR   MVC   LINE+1(26),=C'INVALID OR MISSING OPERAND'\nV$PRTRET BAL   R10,S$PRINT              PRINT ERROR MSG\n         B     RETZ                     AND RETURN\n         SPACE 1\n*  SCAN UCBS; RETURN ALL DASD UCBS.\n*    ON RETURN 0(R10)  - NO MORE UCBS\n*              4(R10)  - R6 CONTAINS @ UCB\n*   USES R5 OVER CALLS FOR UCB ADR TABLE PTR.\n         SPACE 1\nV$UCBSCN L     R1,CVTPTR                @ CVT\n         L     R5,CVTILK2-CVTMAP(,R1)   GET @ UCB @ LIST\n         SPACE 1\nV$UCBNXT LH    R6,0(,R5)                GET @ OF UCB\n         LA    R5,2(,R5)                TO NEXT UCB PTR\n         N     R6,=X'0000FFFF'          MASK UCB ADDRESS\n         BZ    V$UCBNXT                 BIF NO UCB THERE\n         C     R6,=X'0000FFFF'          END OF UCB LIST?\n         BER   R10                      BIF NO MORE UCBS\n         USING UCBOB,R6\n         CLI   UCBTBYT3,UCB3DACC        DASD DEVICE?\n         BNE   V$UCBNXT                 BIF NOT DASD DEVICE\n         B     4(,R10)                  BIF HAVE UCB ADDRESS\n         DROP  R6                       (UCBOB)\n         SPACE 1\nV#FLAG   DC    H'0'      0 - VOLUME ENTRY, 4 - UNIT ENTRY\nV#SAVE   DC    8D'0'                    VOLUME / UNIT SAVE AREA\nV#JFCB   DC    XL176'00'                JFCB AREA\n         LTORG ,\n TITLE 'SALVAGE - DEVTYPE ROUTINE'\n*   IF R1 = 0 THEN PRINTS\n*        VOLUME SERIAL / UNIT ADDRES / UNIT TYPE\n*        EXTENTS IN DEB (HEX)\n         SPACE 1\n         USING DEVTYPE,R11\nDEVTYPE  LR    R7,R1                    SAVE PARM\n         L     R5,DCBDEBAD-IHADCB+VOLUME GET @ DEB\n         L     R6,DEBUCBAD-DEBDASD+DEBBASND-DEBBASIC(,R5) @ UCB\n         USING UCBOB,R6\n         MVC   G#DTUCB(4),UCBTYP        COPY UCB DEVICE TYPE\n         SPACE 1\n         L     R15,CVTPTR               GET @ CVT\n         L     R15,CVTZDTAB-CVTMAP(,R15) @ DEVICE CHAR. TABLE\n         SR    R1,R1                    CLEAR FOR IC\n         IC    R1,G#DTUCB+3             DEVICE TYPE BYTE\n         IC    R1,0(R1,R15)             GET OFFSET OF TYPE INFO\n         AR    R1,R15                   GET @ TYPE INFO\n         MVC   G#DTSYS(4*4),0(R1)       COPY 4 WORDS OF DEVTYPE INFO\n         SPACE 1\n         LM    R15,R1,=A(DEVTAB,DEVTABL,DEVTABE)\nDT$LP1   CLC   UCBTBYT4(1),8(R15)       THIS THE ENTRY?\n         BE    DT$FND                   BIF NOT THE ENTRY\n         BXLE  R15,R0,DT$LP1            CONTINUE SEARCH\nDT$FND   MVC   G#DTMY(32),0(R15)        AND SAVE MY INFO TOO\n         SR    R0,R0\n         ICM   R0,B'0011',G#DTSTLN      MAXIUM TRACK LENGTH\n         SR    R1,R1                    CLEAR FOR IC\n         IC    R1,G#DTSBNK              KEY OVERHEAD\n         AR    R0,R1                    + SPACE BACK NOT KEYED\n         IC    R1,G#DTSBOL              OVERHEAD LAST BLOCK\n         TM    G#DTSFLG,G#DTSFHO        HALFWORD OVERHEAD?\n         BZ    *+8                      BIF NOT H-WORD OVERHEAD\n         LH    R1,G#DTSBOH              GET H-WORD OVERHEAD\n         SR    R0,R1                    - OVERHEAD FOR LAST BLOCK\n         ST    R0,G#MAXBLK              SAVE MAX BLOCK ON TRACK\n         SPACE 1\n         LTR   R7,R7                    PRINT MESSAGE?\n         BNZ   RETZ                     RETURN IF NO MSG REQUIRED\n         MVC   LINE(6),=C'0UNIT '\n         MVC   LINE+6(3),UCBNAME\n         MVC   LINE+10(6),=C'VOLUME'\n         MVC   LINE+17(6),UCBVOLI\n         MVC   LINE+24(4),=C'TYPE'\n         MVC   LINE+29(8),G#DTMY        SET DEVICE TYPE NAME\n         LA    R1,G#DTSCYL              CYLS/PACK, TRKS/CYL\n         BAL   R10,S$HEXCVT              + TRK LEN TO HEX\n         MVC   LINE+38(7),=C'TRK/CYL'\n         MVC   LINE+46(4),G#WORK+4\n         MVC   LINE+51(9),=C'CYLINDERS'\n         MVC   LINE+61(4),G#WORK\n         MVC   LINE+66(8),=C'MAXBLOCK'\n         L     R0,G#MAXBLK\n         CVD   R0,DWD                   TO DECIMAL\n         MVC   LINE+75(5),=X'2020202120'\n         ED    LINE+74(6),DWD+5\n         MVI   LINE+81,C'('\n         LA    R1,G#MAXBLK+2\n         BAL   R10,S$HEXCVT\n         MVC   LINE+82(4),G#WORK\n         MVI   LINE+86,C')'\n         TM    S#GETFLG,S#FCE\n         BZ    *+10\n         MVC   LINE+88(9),=C'>CE MODE<'\n         BAL   R10,S$PRINT\n         DROP  R6                       (UCBOB)\n         SPACE 1\n         MVC   LINE+1(7),=C'EXTENTS'\n         SR    R4,R4                    CLEAR FOR IC\n         IC    R4,DEBNMEXT-DEBBASIC(,R5) NUMBER OF EXTENTS\n         LA    R3,DEBBASND-DEBBASIC(,R5) @ 1ST EXTENT\nDT$EXTLP LA    R1,DEBSTRCC-DEBDASD(,R3)  @ CCHH CCHH\n         BAL   R10,S$HEXCVT             TO HEX\n         MVC   LINE+10(8),G#WORK         CCHH STARTING\n         MVC   LINE+19(8),G#WORK+8       CCHH ENDING\n         LA    R1,DEBNMTRK-DEBDASD(,R3)  @ NUMBER OF TRACKS\n         BAL   R10,S$HEXCVT             TO HEX\n         MVC   LINE+28(4),G#WORK        SET NUMBER OF TRACKS\n         BAL   R10,S$PRINT              PRINT ONE EXTENT\n         LA    R3,DEBNMTRK+2-DEBDASD(,R3) TO NEXT EXTENT\n         BCT   R4,DT$EXTLP              PRINT ALL EXTENTS\n         B     RETZ                     AND RETURN\n TITLE 'SALVAGE - MAIN ENTRY / COMMAND PROCESSOR'\n         ENTRY ENTRY                    ENTRY POINT\n         USING ENTRY,R15\nENTRY    B     ENTRYX\n         DROP  R15\n         DC    AL1(ENTRYX-ENTRY-4)\n         DC    C'SALVAGE/COPYRIGHT.1978.1980.UCLA'\nENTRYX   STM   R14,R12,12(R13)\n         LR    R11,R15                  INIT LOCAL BASE\n         USING ENTRY,R11\n         LR    R12,R11                  INIT GLOBAL BASE\n         SH    R12,=Y(ENTRY-SALVAGE)\n         SPACE 1\n         L     R3,=A(1024*200)          SIZE OF WORK AREA\n         LR    R0,R3                    COPY LENGTH REQUIRED\n         O     R0,=X'03000000'          ADD SUBPOOL\n         GETMAIN R,LV=(0)               GET WORKAREA\n         LA    R2,0(,R1)                CLEAR HIGH BYTE\n         LR    R0,R3                    COPY LENGTH FOR CLEAR\n         BAL   R10,S$CLEAR              GO CLEAR STORAGE\n         LA    R4,0(R2,R3)              @ PAST END OF AREA\n         LR    R15,R13                  SAVE @ CALLERS SAVE AREA\n         SH    R4,=Y(1024)              LEAVE A 1K STACK\n         LA    R13,1024-72(,R4)         POINT TO LAST ON STACK\n         STM   R2,R4,G#CORE             @ START, LENGTH, @ STACK LIMIT\n         SPACE 1\n         LA    R5,8(,R2)                SKIP PFX CCW AREA\n         ST    R5,IOBCCWPT              SET @ FIRST CCW\n         SH    R5,=H'8'                 BACK UP 8 BYTES FOR CCWS\n         SR    R6,R6                    DON'T INIT G#CCWPT\n         LR    R7,R5                    COPY CCW AREA ADDR\n         AH    R7,=Y((10*8+256*8)-1)    POINT TO CCW END ADDR\n         STM   R5,R7,G#CCWIT            SET CCW AREA PTRS\n         LA    R2,8+1(,R7)              POINT TO SPACE LEFT\n         LR    R3,R4                    COPY @ SPACE LEFT\n         SR    R3,R2                    GET LENGTH SPACE LEFT\n         SRL   R3,4                     SPLIT AREA IN HALF\n         SLL   R3,3                     IN DOUBLE WORDS\n         ST    R2,G#BUFIT               SET BUFFER ADDR\n         AR    R2,R3\n         ST    R2,G#TRKIT               SET TRACK ADDR\n         LA    R1,T#BASE-T#(,R2)        GET R0 ENTRY ADDRESS\n         ST    R1,G#TRKBS               SAVE R0 ENTRY ADDRESS\n         BCTR  R2,0\n         ST    R2,G#BUFMX               SET BUFFER LIMIT\n         AR    R2,R3\n         ST    R2,G#TRKMX               SET TRACK LIMIT\n         SPACE 1\n         ST    R13,8(,R15)              CHAIN DOWN TO MINE\n         ST    R15,4(,R13)               AND MINE UP TO HIS\n         RCALL TRKINIT                  INIT TRACK SAVE AREA\n         SPACE 1\n         LA    R3,OPNLST                @ OPEN PARM LIST\n         BAL   R10,S$OPEN               GO OPEN/CHECK OPENS WORKED\n         STAX  C$ATTN,USADDR=(R12),MF=(E,C#ATTN) SET UP STAX\n         BXH   R15,R15,*+8              BIF NOT TSO\n         OI    S#GETFLG,S#FTSO          RUNNING ON TSO\n         SPACE 1\nCM$LOOP  BAL   R10,S$GET                GET A CONTROL RECORD\n         BZ    CM$EOF                   BIF EOF\n         BAL   R10,S$SCN                GET COMMAND\n         BNP   CM$LOOP                  BIF BLANK INPUT RECORD\n         BAL   R10,S$STR                SET CMD TO DWD\n         BH    CM$INV                   BIF INVALID CMD\n         LM    R5,R7,=A(CMDTAB,CMDTABL,CMDTABE) BXLE REGS\nCM$SRCH  CLC   0(8,R5),DWD              THIS THE COMMAND?\n         BE    CM$FND                   BIF COMMAND FOUND\n         BXLE  R5,R6,CM$SRCH            CONTINUE SEARCH\nCM$INV   MVC   LINE+1(19),=C'* INVALID COMMAND *'\n         BAL   R10,S$PRINT              PRINT ERROR MSG\n         B     CM$LOOP                  AND CONTINUE\nCM$FND   MVC   G#WORK(1),G#ALLOW        COPY FLAGS HE HAS SET\n         NC    G#WORK(1),9(R5)          ONLY REQUIRED FLAGS FOR CMD\n         CLC   G#WORK(1),9(R5)          HE HAVE ALL REQUIRED FLAGS?\n         BE    CM$CKOPN                 BIF HE KNOWS WHAT HE IS DOING\n         SPACE 1\n         LA    R1,CM#MSGNA              'COMMAND NOT ALLOWED,\n         BAL   R10,S$MSG                   SEE HELP INFO'\n         B     CM$LOOP\n         SPACE 1\nCM$CKOPN TM    8(R5),X'80'              FILE REQUIRED TO BE OPEN?\n         BZ    CM$CALL                  BIF FILE STATUS NOT IMPORTANT\n         TM    VOLUME+48,X'10'          FILE ALREADY OPEN?\n         BO    CM$CALL                  BIF FILE IS OPEN\n         LA    R3,OPNVOL                PARM FOR S$OPEN/OPEN\n         BAL   R10,S$OPEN               OPEN IT\n         RCALL EXTSAVE                  SAVE ORIG EXTENTS\n         OI    DCBIFLGS-IHADCB+VOLUME,DCBIFNE3 NO IBM ERROR RECOV\n         RCALL DEVTYPE,0                INIT TYPE INFO WITH MSG\nCM$CALL  LH    R15,10(,R5)              GET OFFSET OF CMD ROUTINE\n         RCALL CALL,0                   GO CALL IT (INDIRECTLY)\n         B     CM$LOOP                  AND CONTINE\nCM$EOF   RCALL C$RESET                  RESET DEB IF REQUIRED\n         CLOSE MF=(E,OPNLST)\n         CLOSE MF=(E,OPNVOL)\n         L     R13,4(,R13)              RESTORE CALLERS SAVEAREA\n         LM    R14,R12,12(R13)          AND HIS REGS\n         SR    R15,R15                  RETURN CODE ZERO\n         BR    R14                      AND RETURN\n         SPACE 1\nCM#MSGNA MSG   '*** COMMAND NOT ALLOWED, SEE HELP INFO'\n         SPACE 1\nCALL     AR    R15,R12                  RELOCATE ROUTINE ADDRESS\n         LR    R11,R15                  SET ROUTINE BASE\n         BR    R11                      AND GO TO ROUTINE\n         SPACE 1\nC$ATTN   L     R1,8(,R1)                GET @ OF $\n         OI    S#GETFLG-$(R1),S#FATTN   SET ATTN OCCURED\n         BR    R14                      AND RETURN\n         SPACE 1\nC#ATTN   STAX  0,USADDR=0,MF=L\n TITLE 'SALVAGE - ALLOW COMMAND'\n         USING ALLOW,R11\nALLOW    BAL   R10,S$SCN                SCAN FOR OPERAND\n         BNP   AL$INV                   BIF NO OPERAND\n         BAL   R10,S$STR                GET STRING\n         BH    AL$INV                   BIF STRING TOO LONG\n         SPACE 1\n         LM    R3,R5,=A(AL#TAB,AL#TABL,AL#TABE)\nAL$LOOP  CLC   DWD,0(R3)                FIND ALLOW OPERAND\n         BE    AL$FND                   BIF OPERAND FOUND\n         BXLE  R3,R4,AL$LOOP            CONTINUE SEARCH\nAL$INV   LA    R1,AL#MSGIN               ALLOW OPERAND NOT FOUND\n         B     AL$RET                    AND GO ISSUE MSG\nAL$FND   LH    R15,10(,R3)              GET OFFSET OF ROUTINE\n         B     $(R15)                   TO ROUTINE\n         SPACE 1\nAL$AUTH  NOP   0                        IF WERE AUTHORIZED THEN\n         B     AL$FND2                   MODESET WILL WORK, IF NOT...\n**       BXLE  R15,R15,AL$FND2          BIF WORKED\nAL$AUTHN LA    R1,AL#MSGAF              AUTH FAILED MSG\n         B     AL$RET                   AND GO ISSUE IT\n         SPACE 1\nAL$WRITE TM    VOLUME+48,X'10'          IS FILE OPEN?\n         BZ    AL$FND2                  CONTINUE IF NOT OPEN\n         L     R6,DCBDEBAD-IHADCB+VOLUME @ DEB\n         TM    DEBDVMOD-DEBDASD+DEBBASND-DEBBASIC(R6),X'C0' WRITE OK?\n         BNM   AL$FND2                  BIF FMD WRITE ALLOWED\n         TM    G#ALLOW,X'40'            AUTHORIZED?\n         BZ    AL$AUTHN                 BIF NOT AUTHORIZED\n         BAL   R10,S$KEY0               GET KEY 0\n         NI    DEBDVMOD-DEBDASD+DEBBASND-DEBBASIC(R6),255-X'C0'\n         BAL   R10,S$KEYNZ              ALLOW ALL WRT BUT HA/R0\n         SPACE 1\nAL$FND2  LH    R1,8(,R3)                GET OFFSET OF MSG\n         AR    R1,R12                   @ OF MSG\n         OC    G#ALLOW,12(R3)           ALLOW IT NOW\nAL$RET   BAL   R10,S$MSG                ISSUE MSG\n         B     RET                       AND RETURN\n         SPACE 1\nAL$HAR0  TM    VOLUME+48,X'10'          IS FILE OPEN?\n         BZ    AL$FND2                  CONTINUE IF NOT OPEN\n         L     R6,DCBDEBAD-IHADCB+VOLUME @ DEB\n         TM    DEBDVMOD-DEBDASD+DEBBASND-DEBBASIC(R6),X'C0' HAR0 OK?\n         BO    AL$FND2                  BIF WRITE HA/R0 ALLOWED\n         TM    G#ALLOW,X'40'            AUTHORIZED?\n         BZ    AL$AUTHN                 BIF NOT AUTHORIZED\n         BAL   R10,S$KEY0               GET KEY 0\n         OI    DEBDVMOD-DEBDASD+DEBBASND-DEBBASIC(R6),X'C0'\n         BAL   R10,S$KEYNZ              ALLOW ALL WRT, INC HA/R0\n         B     AL$FND2\n         SPACE 1\nAL#TAB   DC    0H'0',CL8'WRITE   ',Y(AL#MSGW-$,AL$WRITE-$),XL2'8000'\nAL#TABL  EQU   *-AL#TAB\n         DC    0H'0',CL8'AUTH    ',Y(AL#MSGA-$,AL$AUTH-$),XL2'4000'\n         DC    0H'0',CL8'HAR0    ',Y(AL#MSGH-$,AL$HAR0-$),XL2'2000'\nAL#TABE  EQU   *-AL#TABL\n         SPACE 1\nAL#MSGIN MSG   'INVALID OR MISSING OPERAND'\nAL#MSGW  MSG   '*** WRITE NOW ALLOWED, DATA MAY BE DESTROYED'\nAL#MSGA  MSG   '*** AUTHORIZED, VOLUMES MAY BE DESTROYED'\nAL#MSGAF MSG   'NOT AUTHORIZED, COMMAND RESTRICTED'\nAL#MSGH  MSG   '*** HA/R0 WRITE ALLOWED, SKIP DISPLACMENTS MAY BE LOST'\n TITLE 'SALVAGE - IOERR FORMAT ROUTINE'\n*  ECB XX CSW XXXXXX XXXXXXXX SENSE XXXX IOBSEEK XXXXXXXXXXXXXXXX\n*  CCW XXXXXXXX XXXXXXXX DATA XXXXXXXXXXXXXXXX\n         SPACE 1\n         USING IOERR,R11\nIOERR    MVC   LINE+1(3),=C'ECB'\n         LA    R1,ECB                   @ STUFF TO CONVERT\n         BAL   R10,S$HEXCVT             TO HEX\n         MVC   LINE+5(2),G#WORK         SET ECB\n         MVC   LINE+8(3),=C'CSW'\n         LA    R1,IOBCSW\n         BAL   R10,S$HEXCVT\n         MVC   LINE+12(6),G#WORK+2\n         MVC   LINE+19(8),G#WORK+8\n         MVC   LINE+28(5),=C'SENSE'\n         LA    R1,IOBSEN0\n         BAL   R10,S$HEXCVT\n         MVC   LINE+34(4),G#WORK\n         MVC   LINE+39(7),=C'IOBSEEK'\n         LA    R1,IOBSEEK\n         BAL   R10,S$HEXCVT\n         MVC   LINE+47(16),G#WORK\n         BAL   R10,S$PRINT\n         L     R1,IOBCSW                GET ADDR OF CCW + 8\n         N     R1,=X'00FFFFFF'          CLEAR HIGH BYTE / TEST\n         BZ    RETZ\n         SH    R1,=H'8'                 POINT TO CCW\n         CL    R1,G#CCWIT\n         BL    IOERRPT2\n         CL    R1,G#CCWMX\n         BH    IOERRPT2\n         MVC   LINE+1(3),=C'CCW'\n         BAL   R10,S$HEXCVT\n         MVC   LINE+5(8),G#WORK\n         MVC   LINE+14(8),G#WORK+8\n         MVC   LINE+23(4),=C'DATA'\n         L     R1,0(,R1)                GET DATA ADDRESS\n         BAL   R10,S$HEXCVT\n         MVC   LINE+28(16),G#WORK\nIOERRPT2 BAL   R10,S$PRINT\n         SPACE 1\n         MVC   G#WORK(2),IOBCSW+4\n         MVC   G#WORK+2(2),IOBSEN0\n         LA    R6,LINE+1                OUTPUT PTR\n         LR    R7,R6                    SAVE COPY OF LINE+1\n         LA    R4,STBITTAB\nIOERRST1 SR    R2,R2                    CLEAR FOR IC\n         IC    R2,0(,R4)\n         SRDL  R2,3                     GET BYTE OFFSET FROM BITS\n         SRL   R3,29                    GET BIT NUMBER\n         LA    R5,X'80'                 BIT ZERO\n         SRL   R5,0(R3)                 GET BIT TO TEST\n         LA    R2,G#WORK(R2)            POINT TO BYTE TO TEST\n         EX    R5,IOERRTM               TM 0(R2),0\n         BZ    IOERRST5\n         LA    R0,LINE+133-20\n         CR    R6,R0\n         BNH   IOERRST2\n         BAL   R10,S$PRINT\n         LR    R6,R7                    POINT TO LINE+1\nIOERRST2 MVC   0(20,R6),1(R4)           SET MSG\n         LA    R6,20(,R6)\nIOERRST3 CLI   0(R6),C' '\n         BNE   IOERRST4\n         BCT   R6,IOERRST3\nIOERRST4 MVI   1(R6),C','\n         LA    R6,2(,R6)                SKIP COMMA, BLANK\nIOERRST5 LA    R4,21(,R4)               BUMP TO NEXT TABLE ENTRY\n         CLI   0(R4),X'FF'              END OF TABLE?\n         BNE   IOERRST1                 CONTINUE IF NOT END\n         CR    R6,R7                    LINE EMPTY?\n         BE    RETZ\n         BAL   R10,S$PRINT\n         B     RETZ\nIOERRTM  TM    0(R2),0                  * EXECUTED *\n         SPACE 1\n*                       '12345678901234567890'\nSTBITTAB SBIT  CSW,00,0,'ATTENTION           '\n         SBIT  CSW,00,1,'STATUS MODIFIER     '\n         SBIT  CSW,00,2,'CONTROL UNIT END    '\n         SBIT  CSW,00,3,'BUSY                '\n         SBIT  CSW,00,4,'CHANNEL END         '\n         SBIT  CSW,00,5,'DEVICE END          '\n         SBIT  CSW,00,6,'UNIT CHECK          '\n         SBIT  CSW,00,7,'UNIT EXECPTION      '\n         SBIT  CSW,01,0,'PCI                 '\n         SBIT  CSW,01,1,'INCORRECT LENGTH    '\n         SBIT  CSW,01,2,'PROTECTION CHECK    '\n         SBIT  CSW,01,3,'PROGRAM CHECK       '\n         SBIT  CSW,01,4,'CH. DATA CHECK      '\n         SBIT  CSW,01,5,'CH. CONTROL CHECK   '\n         SBIT  CSW,01,6,'IFC CONTROL CHECK   '\n         SBIT  CSW,01,7,'CHAINING CHECK      '\n         SBIT  SEN,00,0,'COMMAND REJECT      '\n         SBIT  SEN,00,1,'INTERV. REQUIRED    '\n         SBIT  SEN,00,2,'BUS OUT PARITY CK   '\n         SBIT  SEN,00,3,'EQUIPMENT CHECK     '\n         SBIT  SEN,00,4,'DATA CHECK          '\n         SBIT  SEN,00,5,'OVERRUN             '\n         SBIT  SEN,00,6,'TRACK CONDITION CK  '\n         SBIT  SEN,00,7,'SEEK CHECK          '\n         SBIT  SEN,01,0,'COUNT AREA CHECK    '\n         SBIT  SEN,01,1,'TRACK OVERRUN       '\n         SBIT  SEN,01,2,'CYLINDER END        '\n         SBIT  SEN,01,3,'INVALID SEQUENCE    '\n         SBIT  SEN,01,4,'NO RECORD FOUND     '\n         SBIT  SEN,01,5,'FILE PROTECTED      '\n         SBIT  SEN,01,6,'MISSING ADR MARKER  '\n         SBIT  SEN,01,7,'OVERFLOW INCOMPLETE '\n         DC    X'FF'                    END OF TABLE\n TITLE 'SALVAGE - READ - TRACK READ ROUTINE'\n*  READ - READ IN TRACK (LOGICAL ADDR IN LOGCCHH)\n*       - IF READ HA / R0 FAILS THEN USE SPACE COUNT TO READ R1\n*       - USE SPACE COUNT TO READ RECORDS AFTER RECORD WITH BAD\n*         COUNT FIELDS???\n* RETURN CODE:  Z - TRACK READ, NO ERRORS\n*               P - TRACK READ, SOME ERRORS (R15 = NUMBER?)\n*               M - FATAL ERROR\n         SPACE 1\n         USING READ,R11\nREAD     RCALL TRKINIT                  INITIALIZE TRACK IMAGE AREA\n         MVC   PHYCCHH,LOGCCHH          INIT PHYSICAL ADDRESS\n         MVC   IOBSEEKC(4),PHYCCHH      AND IOBSEEK ADDRESS\n         USING T#ENTRY,R7               BASE FOR ENTRY\n         SPACE 1\n         XC    G#TRY,G#TRY              SET NO TRIES SO FAR\nR$RETRY  BAL   R10,S$RETRY              TRY (AGAIN)\n         BH    R$GIVEUP                 BIF TIME TO GIVE UP\n         TM    S#GETFLG,S#FATTN         ATTENTION?\n         BO    RETM                     RETURN IF ATTN (FATAL ERROR)\n         SPACE 1\n         L     R7,G#TRKIT               @ T#\n         LA    R7,T#ENTRY-T#(,R7)       @ HA ENTRY\n         BAL   R10,S$CCWI               INIT CCW BUILD\n         LM    R14,R15,R#CCWHA          PATTERN READ HA CCW\n         BAL   R10,S$CCWD               BUILD IT\n         LA    R7,T#BASE                TO R0 ENTRY\n         LM    R14,R15,R#CCWR0          PATTERN READ R0 CCW\n         BAL   R10,S$CCWD               BUILD IT\n         LM    R14,R15,R#CCWSHA         SEARCH HA EQ CCW\n         BAL   R10,S$CCW                SET IT\n         LR    R14,R2                   COPY *-8 FOR TIC\n         O     R14,=X'08000000'         MAKE IT TIC\n         BAL   R10,S$CCW                SET TIC *-8 CCW\n         LA    R6,256                   NUMBER OF READ COUNT CCWS\n         SPACE 1\nR$LOOP1  LA    R7,T#BASE                TO NEXT RECORD ENTRY\n         LM    R14,R15,R#CCWCNT         PATTERN READ COUNT CCW\n         BAL   R10,S$CCWD               BUILD READ CNT CCW\n         BH    R$BUFOUT                 BIF OUT OF SPACE\n         BCT   R6,R$LOOP1               BUILD 256 READ COUNT CCWS\n         LM    R14,R15,R#CCWNOP         ADD NOP AT END\n         BAL   R10,S$CCW                SET NOP CCW AT END OF CHAIN\n         SPACE 1\n         BAL   R10,S$DOIO               GO DO THE I/O\n         RCALL TRKSAVE                  SAVE INFO FROM CORRECT TRACK\n         BM    RET                      BIF FATAL ERROR\n         TM    IOBCSW+4,X'02'           UNIT CHECK?\n         BZ    R$ERR1                   BIF > 255 RECORDS ON TRK\n         TM    IOBSEN1,X'08'            NO RECORD FOUND?\n         BO    R$READ2                  BIF WHAT I EXPECTED\nR$CK2301 CLI   G#DTUCB+3,X'02'          2301 DRUM?\n         BNE   R$ERR1                   BIF NOT DRUM\n         CLI   ECB,X'7F'                ALL I/O OK?\n         BE    R$READ2                  BIF I/O OK FOR DRUM\nR$ERR1   RCALL IOERR                    PRINT RESULTS\n         CLI   ECB,X'42'                EXTENT VIOLATION?\n         BE    RETM                     BIF FATAL ERROR\n         B     R$RETRY                  AND TRY AGAIN\n         EJECT ,\nR$READ2  XC    G#TRY,G#TRY              NO TRYS YET\nR$RETRY2 BAL   R10,S$RETRY              TRY IT AGAIN\n         BH    R$GIVEUP\n         TM    S#GETFLG,S#FATTN         ATTENTION?\n         BO    RETM                     RETURN IF ATTN (FATAL)\n         SPACE 1\n         BAL   R10,S$CCWI               INIT FOR CCW BUILD\n         LM    R14,R15,R#CCWHA          PATTERN READ HA CCW\n         BAL   R10,S$CCWD               SET READ HA CCW\n***** FOLLOWING CODE MAY HANDLE EOF'S INCORRECTLY...\n*****   (WILL NOT READ KEY FIELDS OF EOF; NOR R0 KEY)\n         SPACE 1\n         L     R7,G#TRKBS               @ RECORD 0 ENTRY\nR$LOOP2  LA    R7,T#BASE                POINT TO RECORD 1 ENTRY\n         TM    T#RSFLG,T#RFCNT          SAVED COUNT OF RECORD?\n         BZ    R$EOT                    BIF END OF TRACK\n         SR    R3,R3                    CLEAR FOR IC\n         IC    R3,T#RCNT+5              GET KEY LENGTH\n         L     R4,T#RCNT+4              GET DATA LENGTH\n         N     R4,=X'0000FFFF'          ONLY WANT DATA LENGTH\n         LM    R14,R15,R#CCWCNT         ASSUME EOF\n         BZ    R$EOF2                   BIF IS EOF (DATA LENGTH ZERO)\n         AR    R3,R4                    GET K + DD\n         LM    R14,R15,R#CCWCKD         PATTERN READ CKD CCW\n         AR    R15,R3                   SET LENGTH TO CCW\nR$EOF2   BAL   R10,S$CCWD               BUILD READ CKD CCW\n         BH    R$BUFOUT                 BIF OUT OF BUFFER ROOM\n         B     R$LOOP2                  CONTINUE BUILDING READ CKD\n         SPACE 1\nR$EOT    LM    R14,R15,R#CCWNOP         ADD NOP AT END\n         BAL   R10,S$CCW                ADD IT\n         BAL   R10,S$DOIO               READ THE TRACK\n         L     R15,G#CCWIT              @ 1ST CCW - 8\n         L     R15,8(,R15)              @ HA FIELD\n         CLC   1(4,R15),PHYCCHH         ON CORRECT TRACK?\n         BNE   R$BSEEK                  BIF ON WRONG TRACK\n         RCALL TRKSAVE                  SAVE ANY KEYS/DATA RECOVERED\n         BM    RET                      RETURN IF FATAL ERROR\n         CLI   ECB,X'7F'                ANY ERRORS?\n         BE    R$RET                    GO RETURN IF WORKED OK\n         RCALL IOERR                    ELSE PUBLISH ERROR\n         B     R$RETRY2                 AND TRY AGAIN\n         SPACE 1\nR$GIVEUP MVC   LINE+1(20),=C'RETRY COUNT EXCEEDED'\n         BAL   R10,S$PRINT              PRINT ERROR MSG\nR$RET    LH    R15,G#TRY                GET TRY NUMBER\n         BCTR  R15,0                    ONE TRY IS NORMAL\n         B     RET                      AND RETURN\n         SPACE 1\nR$BUFOUT MVC   LINE+1(16),=C'BUFFER TOO SMALL'\n         BAL   R10,S$PRINT\n         B     RETM                     FATAL ERROR RETURN\n         SPACE 1\nR$BSEEK  MVC   LINE+1(17),=C'** SEEK ERROR, HA'\n         LR    R1,R15                   @ HA\n         BAL   R10,S$HEXCVT\n         MVC   LINE+19(10),G#WORK       HA READ TO LINE\n         MVC   LINE+30(7),=C'PHYCCHH'\n         LA    R1,PHYCCHH\n         BAL   R10,S$HEXCVT\n         MVC   LINE+38(8),G#WORK\n         BAL   R10,S$PRINT\n         B     RETM                     FATAL ERROR\n         SPACE 1\nR#CCWHA  CCW   X'1A',0,X'40',5          PATTERN READ HA\nR#CCWR0  CCW   X'16',0,X'40',16         PATTERN READ R0\nR#CCWSHA CCW   X'39',PHYCCHH,X'40',4     SEARCH HA EQ CCW\nR#CCWSC  CCW   X'0F',0,X'40',3          PATTERN SPACE COUNT\nR#CCWCNT CCW   X'12',0,X'40',8          PATTERN READ COUNT\nR#CCWCKD CCW   X'1E',0,X'40',8          PATTERN READ CKD\nR#CCWNOP CCW   X'03',0,X'20',1          NO OPERATION CCW, SLI\n         SPACE 1\n         LTORG ,\n TITLE 'SALVAGE - C$SCAN  - FAST I/O ERROR SCAN'\n*\n         USING C$SCAN,R11\nC$SCAN   BAL   R10,S$HEX                GET START CYL\n         BNP   SC$MOP                   BIF NO START\n         SLL   R1,16                    TO CYLINDER POSITION\n         ST    R1,LOGCCHH               SET START CYL\n         ST    R1,SC#END                DEFAULT END CYL\n         BAL   R10,S$HEX                GET END CYL\n         BM    SC$GO                    BIF NO END CYL\n         BZ    SC$MOP                   BIF INVALID OPERAND\n         SLL   R1,16                    TO CYL POSITION\n         ST    R1,SC#END                SAVE END CYL\n         SPACE 1\n*  TURN OFF IBM ERROR RECOVERY SO I GET END OF CYLINDER\nSC$GO    OI    DCBIFLGS-IHADCB+VOLUME,DCBIFNE3\n         RCALL M$IMSK                   GO ISSUE MSG\n         EJECT ,\n**** CHANNEL PGM -  READ HA -> SC#HA\n*                   SEARCH ID EQ -> SC#RID\n*                   TIC *-8\n*               (N) READ CKD MT/SLI/ 8 BYTES\n*                   TIC TO 1ST READ CKD\n*\n         SPACE 1\nSC$LP1   XC    IOBSEEK,IOBSEEK          INIT SEEK TO ZERO\n         MVC   IOBSEEKC(4),LOGCCHH      SET CYL, ZERO TRK\n         MVC   SC#RID(5),IOBSEEKC       SET SEARCH ARG CCHHR\n         CLC   LOGCCHH(2),SC#END        DONE?\n         BH    RET                      RETURN IF DONE\n         SPACE 1\nSC$LP2   TM    S#GETFLG,S#FATTN         ATTENTION?\n         BO    RET                      RETURN IF ATTENTION\n         BAL   R10,S$CCWI               INIT CCW BUILDER\n         LM    R14,R15,SC#RHA           GET READ HA CCW\n         BAL   R10,S$CCW                GO SET IT\n         LM    R14,R15,SC#SIDEQ         SEARCH ID EQ CCW\n         BAL   R10,S$CCW                GO SET IT\n         LR    R14,R2                   INIT TIC *-8\n         O     R14,=X'08000000'         MAKE TIC\n         BAL   R10,S$CCW                SET TIC *-8\n         LA    R6,8(,R2)                SAVE @ OF 1ST READ CKD\n         LA    R5,20                    NUMBER OF READ CKD TO BUILD\nSC$CCWLP LM    R14,R15,SC#RCKD          READ CKD MT/SLI/8\n         BAL   R10,S$CCWD               GO BUILD IT\n         MVC   0(8,R14),=8X'FF'         INIT COUNT FIELD\n         BCT   R5,SC$CCWLP              BUILD ALL READ CKD\n         LR    R14,R6                   @ 1ST READ CKD FOR TIC\n         O     R14,=X'08000000'         MAKE TIC\n         BAL   R10,S$CCW                SET TIC\n         BAL   R10,S$DOIO               CHECK A CYLINDER (?)\n         CLC   IOBSEEKC(4),SC#HA+1      CORRECT CYLINDER?\n         BNE   SC$ERR                   BIF IF WRONG SEEK\n         L     R5,IOBCSW                GET @+8 OF LAST CCW DONE\n         LA    R5,0(,R5)                CLEAR HIGH BYTE\n         SH    R5,=H'8'                 BACK UP 8 BYTES\n         BNP   SC$ERR                   BIF INVALID CCW PTR IN CSW\n         CR    R5,R6                    CSW PTR :: @ 1ST READ CKD\n         BL    SC$ERR                   BIF NOT READ CKD ERROR\n         CLI   ECB,X'41'                ERROR I WANT?\n         BNE   SC$ERR                   BIF BAD I/O\n         TM    IOBCSW+4,X'02'           UNIT CHECK?\n         BO    SC$UNITC                 BIF UNIT CHECK\n         TM    IOBCSW+4,X'01'           UNIT EXECPTION (EOF)?\n         BZ    SC$ERR                   ERROR IF NOT EOF\n         L     R1,0(,R5)                GET @ OF COUNT FIELD\n         MVC   SC#RID(5),0(R1)          SET RESTART CCHH\n         MVC   IOBSEEKH(2),SC#RID+2     AND SEEK HH\n         B     SC$LP2                   AND GO RESTART\nSC$UNITC CLC   IOBSEN0(2),=X'0020'      VALID END OF CYLINDER?\n         BE    SC$NEXT                  BIF END OF CYLINDER ONLY\n*        CLC   IOBSEN0(2),=X'0100'      TRACK CONDITION CHECK?\n*        BE\nSC$ERR   RCALL IOERR                    ELSE TELL ALL\n         CLI   ECB,X'41'                I/O TYPE ERROR?\n         BNE   RET                      RETURN IF NOT REAL ERROR\n         SPACE 1\nSC$NEXT  LA    R1,1                     GET LAST CYL DONE\n         AH    R1,LOGCCHH               NEW CYLINDER NUMBER\n         STH   R1,LOGCCHH               SET NEW CYL\n         B     SC$LP1                   CONTINUE\n         SPACE 1\nSC$MOP   LA    R1,SC#OPMSG              INVALID / MISSING OPERAND\n         BAL   R10,S$MSG                GO PRINT IT\n         B     RETM                     AND RETURN\n         SPACE 1\nSC#RHA   CCW   X'1A',SC#HA,X'40',5      READ HA\nSC#SIDEQ CCW   X'31',SC#RID,X'40',5     SEARCH ID EQ\nSC#RCKD  CCW   X'9E',0,X'60',8          READ CKD MT, SLI, 8 BYTES\nSC#END   DC    F'0'                     END CC00 FOR SCAN\nSC#HA    DC    XL5'FFFFFFFFFF'          HA READ AREA\nSC#RID   DC    XL5'FFFFFFFFFF'          SEARCH ID EQ ARG\nSC#OPMSG MSG   'INVALID OR MISSING OPERAND'\n         LTORG ,\n TITLE 'SALVAGE - DISPTRK - DISPLAY TRACK IMAGE'\n*\n         USING DISPTRK,R11\n         USING T#ENTRY,R7\nDISPTRK  BAL   R10,S$HEX                GET OPERAND IF ANY\n         BNP   DT$GO\n         LTR   R1,R1                    IF ZERO\n         BNZ   *+6                      THEN MAKE MAX NUMBER\n         BCTR  R1,0\n         SLL   R1,4                     * 16 BYTES / LINE\n         ST    R1,DT#LINES\nDT$GO    L     R7,G#TRKIT               @ TRACK IMAGE AREA\n         LA    R7,T#ENTRY-T#(,R7)       POINT TO HA ENTRY\n         TM    T#RSFLG,T#RFHA           HAVE HA?\n         BZ    DT$LOOP                  BIF HA NOT READ\n         LA    R1,T#RCNT                POINT TO HA DATA\n         BAL   R10,S$HEXCVT             HA DATA TO HEX\n         MVC   LINE+1(2),=C'HA'         SET ID\n         MVC   LINE+4(10),G#WORK        AND FCCHH\n         BAL   R10,S$PRINT              PRINT HA INFO\n         SR    R3,R3                    INIT RECORD NUMBER TO ZERO\n         SPACE 1\nDT$LOOP  TM    S#GETFLG,S#FATTN         ATTENTION?\n         BO    RET                      RETURN IF ATTENTION\n         LA    R7,T#BASE                TO NEXT RECORD ENTRY\n         TM    T#RSFLG,T#RFCNT          HAVE COUNT FIELD?\n         BZ    DT$KEY                   BIF NO COUNT FIELD\n         MVC   LINE+1(6),=C'RECORD'\n         CVD   R3,G#WORK\n         MVC   LINE+7(4),=X'40202120'\n         ED    LINE+7(4),G#WORK+6\n         MVC   LINE+12(5),=C'COUNT'\n         LA    R1,T#RCNT                POINT TO COUNT FIELD\n         BAL   R10,S$HEXCVT\n         MVC   LINE+18(16),G#WORK\n         BAL   R10,S$PRINT\n         SPACE 1\nDT$KEY   TM    T#RSFLG,T#RFKEY          HAVE KEY FIELD?\n         BZ    DT$DATA\n         MVC   LINE+1(3),=C'KEY'\n         BAL   R10,S$PRINT\n         SR    R0,R0                    CLEAR FOR KEY LENGTH\n         IC    R0,T#RCNT+5              GET KEY LENGTH\n         LH    R1,T#ROFF                GET OFFSET OF KEY/DATA\n         A     R1,G#TRKIT               @ KEY DATA\n         CL    R0,DT#LINES\n         BNH   *+8\n         L     R0,DT#LINES\n         RCALL HEXDISP,(R1),(R0),ERRAD=RET PRINT KEY\n         SPACE 1\nDT$DATA  TM    T#RSFLG,T#RFDATA         HAVE DATA FIELD?\n         BZ    DT$NEXT\n         MVC   LINE+1(4),=C'DATA'\n         BAL   R10,S$PRINT\n         SR    R1,R1                    CLEAR FOR IC\n         IC    R1,T#RCNT+5              GET KEY LENGTH\n         AH    R1,T#ROFF                + OFFSET TO KEY/DATA\n         A     R1,G#TRKIT               @ DATA FIELD\n         L     R0,T#RCNT+4              GET LENGTH OF DATA\n         N     R0,=X'0000FFFF'\n         CL    R0,DT#LINES\n         BNH   *+8\n         L     R0,DT#LINES\n         RCALL HEXDISP,(R1),(R0),ERRAD=RET PRINT DATA\nDT$NEXT  LA    R3,1(,R3)                TO NEXT RECORD NUMBER\n         CH    R3,=H'255'               DONE ALL RECORDS?\n         BNH   DT$LOOP\n         B     RET\nDT#LINES DC    A(1*16)                  MAX BYTES TO DISPLAY\n TITLE 'SALVAGE - TRACK IMAGE SAVE/INIT/GET ROUTINES'\n*  TRKSAVE - SCAN CCW CHAIN AND SAVE RECOVERED DATA.\n*   RETURN CODES:  Z - NO NEW INFORMATION SAVED\n*                  P - NEW INFORMATION SAVED\n*                  M - FATAL ERROR\n*\n*   R9 - ORIENTATION (RECORD # * 4) + FIELD ID + 4\n*        (NO ORIENTATION < 0, HA - 0, R0 - 4)\n*        (COUNT 0, KEY 1, DATA 2)\n*   R8 - CONSTANT OF 8\n*   R7 - BASE FOR T#ENTRY\n*   R6 - @ CURRENT CCW\n*   R5 - LENGTH FROM CURRENT CCW\n*   R4 - ADDRESS FROM CURRENT CCW\n*   R3 - FLAG - ANY NEW INFO SAVED\n*    NOTE: THIS ROUTINE CAN BE CALLED MORE THAN ONCE.\n*\n*    THE CCW WHICH THE CSW-8 POINTS TO IS NOT PROCESSED BY THIS\n*    ROUTINE, AS IT MAY HAVE HAD AN ERROR.  IF A NOP IS ADDED TO\n*    THE END OF THE CHAIN IT WILL BE THE CCW IGNORED.  (ASSUMING NO\n*    REAL I/O ERROR).\n         SPACE 1\n         USING TRKSAVE,R11\nTRKSAVE  SR    R9,R9                    NO ORIENTATION\n         BCTR  R9,0\n         USING T#ENTRY,R7\n         LA    R8,8                     CONSTANT\n         SR    R3,R3                    NO NEW INFO YET\n         L     R1,IOBCSW                GET CSW\n         N     R1,=X'00FFFFFF'          ANY ADDR AT ALL?\n         BZ    TS$DONE                  BIF NO CCW'S TO PROCESS\n         SH    R1,=H'8'                 POINT TO LAST CCW\n         ST    R1,TS#LCCW               SAVE LAST CCW ADDRESS\n         L     R6,IOBCCWPT              @ FIRST CCW\n         N     R6,=X'00FFFFFF'          CLEAN HIGH BYTE\n         SPACE 1\nTS$LOOP  C     R6,TS#LCCW               THIS CCW GET DONE OK?\n         BNL   TS$DONE                  BIF CCW NOT DONE OK\n         LM    R4,R5,0(R6)              GET ADDRESS/LENGTH FROM CCW\n         TM    4(R6),X'80'              DATA CHAINING?\n         BO    TS$ERCCW                 BIF INVALID CCW\n         N     R5,=X'0000FFFF'          ONLY WANT LENGTH\n         TM    4(R6),X'10'              SKIP?\n         BZ    *+6                      BIF NOT SKIP\n         SR    R5,R5                    IF SKIP THEN NO DATA\n         SR    R15,R15                  CLEAR FOR IC\n         IC    R15,0(,R6)               GET CCW OP CODE\n         IC    R15,TS#OPTAB(R15)        LOOK UP CCW OP\n         AR    R15,R15                  GET ROUTINE OFFSET\n         B     TS$RHA(R15)              TO ROUTINE\n         SPACE 1\nTS$NCCW  TM    4(R6),X'40'              COMMAND CHAIN?\n         BZ    TS$DONE                  BIF DONE\n         AR    R6,R8                    BUMP TO NEXT CCW\n         B     TS$LOOP                  AND COUTINUE\n* CCW - READ HA\nTS$RHA   SR    R9,R9                    ORIENT TO HOME ADDRESS\n         BAL   R10,TS$SUBR              POINT TO HA AREA\n         LA    R9,4                     ORIENT AFTER HOME ADDRESS\n         TM    T#RSFLG,T#RFHA           HAVE HA YET?\n         BO    TS$NCCW                  BIF ALREADY HAVE HA\n         CH    R5,=H'5'                 DID IT GET WHOLE HA?\n         BL    TS$ERS                   BIF SHORT READ\n         MVC   T#RCNT(5),0(R4)          SAVE HOME ADDRESS\n         OI    T#RSFLG,T#RFHA\n         OR    R3,R8                    NOTE NEW INFO\n         B     TS$NCCW                  AND CONTINUE\n         SPACE 1\n* CCW - SEARCH HA EQ  (MUST BE FOLLOWED BY TIC *-8)\nTS$SHA   LA    R9,4                     ORIENT AFTER HA\n         CLI   8(R6),X'08'              FOLLOWED BY TIC?\n         BNE   TS$ERCCW                 BIF INVALID CCW\n         ST    R6,G#WORK                SET ADDR OF SEARCH HA CCW\n         CLC   G#WORK+1(3),9(R6)        TIC TO *-8?\n         BNE   TS$ERCCW                 BIF INVALID TIC\n         AR    R6,R8                    SKIP TIC CCW\n         B     TS$NCCW                  CONTINUE IF OK\n         SPACE 1\n* CCW - SPACE COUNT\nTS$SC    LTR   R9,R9                    UNORIENTED SPACE COUNT?\n         BM    TS$SCU                   BIF UNORIENTED SPACE COUNT\n         LA    R9,3(,R9)                ROUND UP TO NEXT COUNT FIELD\n         N     R9,=X'00000FFC'          TO NEXT (OR THIS) COUNT FIELD\n         LA    R9,1(,R9)                NOW AT KEY FIELD\n         B     TS$NCCW                  AND GO DO NEXT CCW\nTS$SCU   LA    R9,8                     ORIENT TO COUNT OF RECORD 1\n         B     TS$NCCW\n         SPACE 1\n* CCW - SEARCH ID EQ\nTS$SRCH  TM    4(R6),X'20'              SLI?\n         BO    TS$ERCCW                 INVALID IF SLI\n         SR    R15,R15                  CLEAR FOR IC\n         IC    R15,4(,R4)               GET RECORD NUMBER OF SEARCH\n         LR    R9,R15                   ASSUME SEARCH IS VALID\n         SLL   R9,2                     SET NEW ORIENTATION\n         LA    R9,1(,R9)                TO KEY FIELD\n         CLI   8(R6),X'08'              IS NEXT CCW TIC?\n         BNE   TS$ERCCW\n         ST    R6,G#WORK                SAVE CCW ADDR\n         CLC   G#WORK+1(3),9(R6)        IS IT TIC *-8?\n         BNE   TS$ERCCW\n         AR    R6,R8                    AND SKIP TIC CCW\n         BAL   R10,TS$SUBR              FIND ENTRY OF SEARCH TARGET\n         TM    T#RSFLG,T#RFCNT          DO I HAVE COUNT FIELD?\n         BZ    TS$ERCCW                 INVALID IF NO COUNT FIELD\n         CLC   T#RCNT(5),0(R4)          THIS THE RECORD?\n         BE    TS$NCCW                  AND CONTINUE IF ALL OK\n         B     TS$ERCCW                 BIF INVALID SEARCH\n         SPACE 1\n* CCW - READ R0\nTS$R0    LA    R9,4                     ORIENT TO R0 COUNT FIELD\n         MVI   TS#CCWOP,X'1E'           FAKE READ CKD\n         B     TS$R0X                   AND PROCESS LIKE READ CKD\n         SPACE 1\n* CCW - READ <COUNT>/<KEY>/<DATA>\nTS$RCCW  LTR   R9,R9                    UNORIENTED?\n         BM    TS$EROR                  BIF UNORIENTED READ\n         MVC   TS#CCWOP(1),0(R6)        INIT CCW OPCODE\n         CH    R9,=H'5'                 ORIENTED TO R0 KEY?\n         BNL   TS$R0X                   BIF AFTER R0 KEY FIELD\n         LA    R9,8                     ELSE ORIENT TO RECORD 1\nTS$R0X   TM    4(R6),X'20'              SLI?\n         BO    TS$ERCCW                 INVALID IF SLI\n         TM    TS#CCWOP,X'10'           DOES CCW PROCESS CNT?\n         BZ    TS$RKEY                  BIF NO COUNT PROCESSED\n         LA    R9,3(,R9)                FIND COUNT FIELD\n         N     R9,=X'0000FFFC'\n         LA    R9,1(,R9)                NOW PAST COUNT FIELD\nTS$RTRY1 BAL   R10,TS$SUBR              FIND ENTRY\n         CR    R5,R8                    AT LEAST COUNT FIELD READ?\n         BL    TS$ERS                   BIF SHORT COUNT READ\n         LR    R1,R9                    COPY ORIENTATION\n         SRL   R1,2                     GET RECORD NUMBER + 1\n         BCTR  R1,0                     GET RECORD NUMBER\n         EX    R1,TS$CLI                CLI 4(R4),0 CORRECT RECORD?\n         BE    TS$RROK                  BIF CORRECT RECORD\n* 2301 DRUM WON'T GET NO REC FND ON READ COUNT....\n         CLI   G#DTUCB+3,X'02'          2301 DRUM?\n         BNE   TS$ERTF                  BIF INVALID TRACK FORMAT\n         CLI   4(R4),X'01'              WRAP BACK TO RECORD 1?\n         BNE   TS$ERTF                  BIF INVALID TRACK FORMAT\n         LA    R9,8+1                   ORIENT AFTER REC 1 COUNT\n         B     TS$RTRY1                 AND TRY AGAIN\nTS$RROK  OI    T#REFLG,T#RFCNT          COUNT FIELD EXISTS\n         MVC   T#RCNT,0(R4)             SAVE COUNT\n         AR    R4,R8                    POINT PAST COUNT FIELD\n         SR    R5,R8                    AND GET LENGTH LEFT\n         TM    T#RSFLG,T#RFCNT          ALREADY HAVE COUNT?\n         BZ    *+6                      BIF ALREADY HAVE COUNT\n         OR    R3,R8                    NOTE NEW FIELD\n         OI    T#RSFLG,T#RFCNT          AND HAVE SAVED COUNT\n*--- RESERVE SPACE FOR KEY/DATA\n         BAL   R10,TS$LEN               GET KEY/DATA LENGTH\n         LTR   R0,R0                    KEY EXIST?\n         BZ    *+8                      BIF NO KEY FIELD\n         OI    T#REFLG,T#RFKEY          KEY EXISTS\n         LTR   R14,R14                  DATA EXIST?\n         BZ    *+8                      BIF NO DATA FIELD\n         OI    T#REFLG,T#RFDATA         DATA EXISTS\n         C     R1,G#TRKIT               SPACE ALREADY RESERVED?\n         BNE   TS$RKEY                  BIF ALREADY RESERVED\n         LH    R15,0(,R1)               GET LENGTH SO FAR FROM RDW\n         AR    R15,R1                   POINT TO END SO FAR\n         AR    R0,R14                   SUM KEY/DATA LENGTHS\n         AR    R0,R15                   POINT AFTER NEW SPACE\n         C     R0,G#TRKMX               WILL IT FIT?\n         BH    TS$ERFL                  BIF OUT OF IMAGE AREA\n         SR    R0,R1                    NEW LENGTH FOR RDW\n         STH   R0,0(,R1)                SET NEW LEN IN RDW\n         SR    R15,R1                   GET OFFSET OF AREA\n         STH   R15,T#ROFF               SAVE OFFSET\n         SPACE 1\nTS$RKEY  TM    TS#CCWOP,X'08'           DOES CCW PROCESS KEY?\n         BZ    TS$RDATA\n         LA    R9,2(,R9)                FIND RECORD CONTAINING KEY\n         N     R9,=X'0000FFFC'\n         LA    R9,1+1(,R9)              NOW PAST KEY\n         BAL   R10,TS$SUBR              FIND ENTRY\n         TM    T#RSFLG,T#RFCNT          HAVE COUNT?\n         BZ    TS$ERCCW                 BIF DON'T KNOW KEY LENGTH\n         TM    T#REFLG,T#RFKEY          KEY FIELD EXIST?\n         BZ    TS$RDATA                 BIF NO KEY\n         BAL   R10,TS$LEN               GET ADR KEY AREA/LEN KEY\n         CR    R5,R0                    HAVE ENTIRE KEY?\n         BL    TS$ERS                   BIF SHORT KEY READ\n         LR    R15,R4                   COPY FROM ADDR FOR MOVE\n         AR    R4,R0                    BUMP ADDR PAST KEY CLEAR FOR IC\n         SR    R5,R0                    LENGTH LEFT AFTER KEY\n         BAL   R10,S$MOVE               MOVE KEY TO AREA\n         TM    T#RSFLG,T#RFKEY          ALREADY HAVE KEY?\n         BO    *+6\n         OR    R3,R8                    NOTE NEW INFO\n         OI    T#RSFLG,T#RFKEY\n         SPACE 1\nTS$RDATA TM    TS#CCWOP,X'04'           DOES CCW PROCESS DATA?\n         BZ    TS$NCCW                  CONTINUE IF NOT\n         LA    R9,1(,R9)                ORIENT TO DATA FIELD\n         N     R9,=X'0000FFFC'\n         LA    R9,3(,R9)                NOW PAST DATA FIELD\n         BAL   R10,TS$SUBR              FIND ENTRY\n         TM    T#RSFLG,T#RFCNT          HAVE COUNT FIELD?\n         BZ    TS$ERCCW                 BIF DON'T KNOW DATA LENGTH\n         TM    T#REFLG,T#RFDATA         DATA FIELD EXIST?\n         BZ    TS$NCCW                  BIF NO DATA FIELD\n         BAL   R10,TS$LEN               GET DATA ADDR/LEN\n         AR    R1,R0                    SKIP KEY IN TO AREA\n         CR    R5,R14                   HAVE ENTIRE DATA FIELD?\n         BL    TS$ERS                   BIF SHORT DATA READ\n         LR    R0,R14                   SET DATA LENGTH TO MOVE\n         LR    R15,R4                   COPY FROM ADDR FOR MOVE\n         BAL   R10,S$MOVE               MOVE DATA TO AREA\n         TM    T#RSFLG,T#RFDATA         ALREADY HAVE DATA?\n         BO    *+6\n         OR    R3,R8                    NOTE NEW INFO\n         OI    T#RSFLG,T#RFDATA\n         B     TS$NCCW                  AND CONTINUE\nTS$CLI   CLI   4(R4),0                  * EXECUTED *\n         SPACE 1\nTS$DONE  LR    R15,R3                   SET RETURN CODE\n         B     RET                      AND RETURN\n         SPACE 1\n** TS$SUBR - FIND T#ENTRY OF CURRENT ORIENTATION\nTS$SUBR  LTR   R7,R9                    ORIENTED?\n         BM    TS$EROR                  BIF UNORIENTED\n         N     R7,=X'0000FFFC'          GET TO RECORD ID\n         SLL   R7,2                     GET (REC NUM + 1) * 16\n         CL    R7,=A(257*16)            RECORD NUMBER VALID?\n         BH    TS$EROR                  BIF INVALID RECORD NUMBER\n         LA    R7,T#ENTRY-T#(,R7)       ACCOUNT FOR PREFIX\n         A     R7,G#TRKIT               POINT TO ENTRY\n         BR    R10                      AND RETURN\n         SPACE 1\n*  RETURN KEY LEN IN R0, DATA LEN IN R14\n*  AND ADDRESS KEY/DATA AREA IN R1.\nTS$LEN   SR    R0,R0                    CLEAR FOR IC\n         IC    R0,T#RCNT+5              GET KEY LENGTH\n         L     R14,T#RCNT+4             GET DATA LENGTH\n         N     R14,=X'0000FFFF'\n         LH    R1,T#ROFF                GET OFFSET OF KEY/DATA AREA\n         A     R1,G#TRKIT               GET @ KEY/DATA AREA\n         BR    R10                      AND RETURN\n         SPACE 1\nTS$ERS   MVC   LINE+1(10),=C'SHORT READ'\n         B     TS$ERR\nTS$EROR  MVC   LINE+1(17),=C'ORIENTATION ERROR'\n         B     TS$ERR\nTS$ERCCW MVC   LINE+1(11),=C'INVALID CCW'\nTS$ERR   LR    R1,R6                    COPY CCW ADDR\n         BAL   R10,S$HEXCVT             TO HEX\n         MVC   LINE+20(16),G#WORK       CCW TO LINE\n         B     TS$ERRRT\nTS$ERFL  MVC   LINE+1(21),=C'TRACK IMAGE AREA FULL'\nTS$ERRRT BAL   R10,S$PRINT              PRINT ERROR MSG\n         LNR   R15,R8                   INDICATE FATAL ERROR\n         B     RET                      AND RETURN CODE ZERO\nTS$ERTF  MVC   LINE+1(32),=C'INVALID TRACK FORMAT, CNT FIELD:'\n         LR    R1,R4                    @ COUNT FIELD\n         BAL   R10,S$HEXCVT             COUNT TO HEX\n         MVC   LINE+34(16),G#WORK\n         B     TS$ERRRT                 IS FATAL ERROR\n         DROP  R7                       (T#ENTRY)\n         SPACE 1\nTS#LCCW  DC    A(0)                     @ LAST CCW EXECUTED BY CHANNEL\nTS#CCWOP DC    X'00'                    CURRENT CCW OPCODE\n         SPACE 1\nTS#OPTAB DC    256AL1((TS$ERCCW-TS$RHA)/2)\n         ORG   TS#OPTAB+X'1A'           READ HA\n         DC    AL1((TS$RHA-TS$RHA)/2)\n         ORG   TS#OPTAB+X'12'           READ COUNT\n         DC    AL1((TS$RCCW-TS$RHA)/2)\n         ORG   TS#OPTAB+X'16'           READ R0\n         DC    AL1((TS$R0-TS$RHA)/2)\n         ORG   TS#OPTAB+X'06'           READ DATA\n         DC    AL1((TS$RCCW-TS$RHA)/2)\n         ORG   TS#OPTAB+X'0E'           READ KEY / DATA\n         DC    AL1((TS$RCCW-TS$RHA)/2)\n         ORG   TS#OPTAB+X'1E'           READ CKD\n         DC    AL1((TS$RCCW-TS$RHA)/2)\n         ORG   TS#OPTAB+X'31'           SEARCH ID EQ\n         DC    AL1((TS$SRCH-TS$RHA)/2)\n         ORG   TS#OPTAB+X'0F'           SPACE COUNT\n         DC    AL1((TS$SC-TS$RHA)/2)\n         ORG   TS#OPTAB+X'39'           SEARCH HA EQ\n         DC    AL1((TS$SHA-TS$RHA)/2)\n         ORG   ,\n         EJECT ,\n* TRKINIT - REINITIALIZE TRACK AREA\n         USING TRKINIT,R11\nTRKINIT  L     R9,G#TRKIT               GET @ AREA\n         LR    R1,R9                    SET CLEAR ADDRESS\n         LH    R8,=Y(T#L)               GET LENGTH TO CLEAR\n         LR    R0,R8                    SET FOR CLEAR\n         BAL   R10,S$CLEAR              GO CLEAR BASIC HEADER\n         STH   R8,0(,R9)                INIT RDW\n         OI    T#REFLG-T#(R9),T#RFHA    HA MUST EXIST\n         B     RET                      AND RETURN\n         SPACE 2\n* TRKCHECK - CHECK IF HAVE ENTIRE TRACK\n         USING TRKCHECK,R11\nTRKCHECK L     R7,G#TRKIT               GET @ TRACK AREA\n         LA    R7,T#ENTRY-T#(,R7)       @ HA ENTRY\n         USING T#ENTRY,R7\n         LA    R6,1+256                 HA + # RECORD ENTRIES\nTC$LOOP  CLC   T#RSFLG,T#REFLG          HAVE ALL FIELDS WHICH EXIST?\n         BNE   TC$RET\n         LA    R7,T#BASE                POINT TO NEXT ENTRY\n         BCT   R6,TC$LOOP\n         B     RETZ\nTC$RET   LR    R15,R7                   RET @ OF IMCOMPLETE ENTRY\n         B     RET\n TITLE 'SALVAGE - HEX DISPLAY ROUTINE'\n*    R0  - DATA LENGTH, R1 - DATA ADDRESS\n*    FORMATS LINES AND PRINTS THEM.\n*\n         SPACE 1\n         USING HEXDISP,R11\nHEXDISP  LR    R9,R1                    COPY DATA ADDRESS\n         LR    R8,R0                    COPY LENGTH LEFT\n         SR    R7,R7                    INIT OFFSET TO ZERO\n         LA    R6,16                    LENGTH LEFT ON LINE (HEX BYTES)\n         SPACE 1\nHD$LOOP  LTR   R8,R8                    ANY DATA LEFT TO DISPLAY?\n         BNP   RETZ                     RETURN IF NO DATA LEFT\n         TM    S#GETFLG,S#FATTN         ATTENTION?\n         BO    RETM                     RETURN IF ATTENTION\n         ST    R7,G#WORK                CONVERT DISPLAY\n         UNPK  HD#ADR(7),G#WORK+1(4)    ADDRESS TO HEX;\n         TR    HD#ADR,G#HEX\n         MVI   HD#ADR+L'HD#ADR,C' '     WIPE OUT GARBAGE BYTE\n         LR    R2,R6                    GET MIN(LENGTH LEFT,\n         CR    R2,R8                            LENGTH ON LINE)\n         BNH   *+6\n         LR    R2,R8\n         BCTR  R2,0                     GET EX LENGTH\n         EX    R2,HD$DMVC               MVC HD#CHAR(0),0(R9)\n         UNPK  G#WORK+1(15),HD#CHAR(8)  MAKE 32 HEX CHARS\n         UNPK  G#WORK+15(15),HD#CHAR+7(8)\n         UNPK  G#WORK+29(5),HD#CHAR+14(3)\n         TR    G#WORK+1(32),G#HEX        MAKE REAL HEX\n         TR    HD#CHAR,HD#VAL            FIX INVALID CHARS IF ANY\n         MVI   HD#OR1,C'|'               ADD OR BARS\n         MVI   HD#OR2,C'|'\n         IC    R3,HD#LEN(R2)            GET PATTERN EX LEN TO USE\n         EX    R3,HD$PATMV              MVC L#D0(0),HD#PAT\n         EX    R3,HD$PATTR              TR  L#D0(0),W#WORK\n**TEMP   L     R3,P#CARROT              GET CARROT DISPLAY ADDR\n         B     HD$NEXT  ** TEMP **\n         SR    R3,R7                    GET OFFSET TO CARROT\n         BM    HD$NEXT                  BIF CARROT ON PREV LINE\n         CR    R3,R2                    CARROT OFFSET :: LINE LEN - 1\n         BH    HD$NEXT                  BIF NOT THIS LINE\n         SR    R4,R4                    CLEAR FOR IC\n         IC    R4,HD#CART(R3)           GET OFFSET FOR CARROT\n         LA    R0,C'>'                  ASSUME EVEN ADDR\n         N     R3,=F'1'                 TEST EVEN/ODD\n         BZ    *+8                      BIF IS EVEN\n         LA    R0,C'<'                  ELSE USE ODD CARROT\n         STC   R0,HD#LINE(R4)           SET CARROT ON LINE\nHD$NEXT  AR    R9,R6                    BUMP DATA PTR\n         AR    R7,R6                    AND DISPLAY ADDR\n         SR    R8,R6                    DCR DATA LEFT\n         BAL   R10,S$PRINT              PRINT COMPLETE LINE\n         B     HD$LOOP                  AND CONTINUE\n         SPACE 1\nHD$DMVC  MVC   HD#CHAR(0),0(R9)         * EXECUTED *\nHD$VALTR TR    HD#CHAR(0),HD#VAL        * EXECUTED *\nHD$PATMV MVC   HD#D0(0),HD#PAT          * EXECUTED *\nHD$PATTR TR    HD#D0(0),G#WORK          * EXECUTED *\n         SPACE 1\n*                0 1 2 3 4 5 6 7 8 9 A B C D E F\nHD#VAL   DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  0\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  1\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  2\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  3\n         DC    X'404B4B4B4B4B4B4B4B4B4A4B4C4D4E4F'  4\n         DC    X'504B4B4B4B4B4B4B4B4B5A5B5C5D5E5F'  5\n         DC    X'604B4B4B4B4B4B4B4B4B6A6B6C6D6E6F'  6\n         DC    X'4B4B4B4B4B4B4B4B4B797A7B7C7D7E7F'  7\n         DC    X'4B8182838485868788894B4B4B4B4B4B'  8\n         DC    X'4B9192939495969798994B4B4B4B4B4B'  9\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'  A\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  B\n         DC    X'4BC1C2C3C4C5C6C7C8C94B4B4B4B4B4B'  C\n         DC    X'4BD1D2D3D4D5D6D7D8D94B4B4B4B4B4B'  D\n         DC    X'4B4BE2E3E4E5E6E7E8E94B4B4B4B4B4B'  E\n         DC    X'F0F1F2F3F4F5F6F7F8F94B4B4B4B4B4B'  F\n         SPACE 1\n         ORG   LINE\nHD#LINE  DC    CL1' '\nHD#ADR   DC    CL6' ',CL3' '\nHD#D0    DC    CL4' ',CL1' '\nHD#D1    DC    CL4' ',CL1' '\nHD#D2    DC    CL4' ',CL1' '\nHD#D3    DC    CL4' ',CL1' '\n         DC    CL2' '\nHD#D4    DC    CL4' ',CL1' '\nHD#D5    DC    CL4' ',CL1' '\nHD#D6    DC    CL4' ',CL1' '\nHD#D7    DC    CL4' ',CL1' '\n         DC    CL3' '\nHD#OR1   DC    CL1' '\nHD#CHAR  DC    CL16' '\nHD#OR2   DC    CL1' '\n         ORG   ,\n         SPACE 1\n* PATTERN LENGTH-1 TO USE INDEXED BY DATA LEN -1\nHD#LEN   DC    AL1(HD#D0+2-HD#D0-1)       0\n         DC    AL1(HD#D0+4-HD#D0-1)       1\n         DC    AL1(HD#D1+2-HD#D0-1)       2\n         DC    AL1(HD#D1+4-HD#D0-1)       3\n         DC    AL1(HD#D2+2-HD#D0-1)       4\n         DC    AL1(HD#D2+4-HD#D0-1)       5\n         DC    AL1(HD#D3+2-HD#D0-1)       6\n         DC    AL1(HD#D3+4-HD#D0-1)       7\n         DC    AL1(HD#D4+2-HD#D0-1)       8\n         DC    AL1(HD#D4+4-HD#D0-1)       9\n         DC    AL1(HD#D5+2-HD#D0-1)       A\n         DC    AL1(HD#D5+4-HD#D0-1)       B\n         DC    AL1(HD#D6+2-HD#D0-1)       C\n         DC    AL1(HD#D6+4-HD#D0-1)       D\n         DC    AL1(HD#D7+2-HD#D0-1)       E\n         DC    AL1(HD#D7+4-HD#D0-1)       F\n         SPACE 1\n* CARROT POSITION ON LINE INDEXED BY DATA OFFSET ON LINE\nHD#CART  DC    AL1(HD#D0-1-HD#LINE)       0\n         DC    AL1(HD#D0+4-HD#LINE)       1\n         DC    AL1(HD#D1-1-HD#LINE)       2\n         DC    AL1(HD#D1+4-HD#LINE)       3\n         DC    AL1(HD#D2-1-HD#LINE)       4\n         DC    AL1(HD#D2+4-HD#LINE)       5\n         DC    AL1(HD#D3-1-HD#LINE)       6\n         DC    AL1(HD#D3+4-HD#LINE)       7\n         DC    AL1(HD#D4-1-HD#LINE)       8\n         DC    AL1(HD#D4+4-HD#LINE)       9\n         DC    AL1(HD#D5-1-HD#LINE)       A\n         DC    AL1(HD#D5+4-HD#LINE)       B\n         DC    AL1(HD#D6-1-HD#LINE)       C\n         DC    AL1(HD#D6+4-HD#LINE)       D\n         DC    AL1(HD#D7-1-HD#LINE)       E\n         DC    AL1(HD#D7+4-HD#LINE)       F\n         SPACE 1\n* MAPS DSECT OF LINE FOR TR INS\nHD#PAT   DC    XL(HD#D7+5-HD#D0)'00'      INIT TO BLANKS\n         ORG   HD#PAT\n         DC    AL1(01,02,03,04)\n         DC    AL1(0)\n         DC    AL1(05,06,07,08)\n         DC    AL1(0)\n         DC    AL1(09,10,11,12)\n         DC    AL1(0)\n         DC    AL1(13,14,15,16)\n         ORG   HD#PAT+HD#D4-HD#D0         TO SECOND HALF\n         DC    AL1(17,18,19,20)\n         DC    AL1(0)\n         DC    AL1(21,22,23,24)\n         DC    AL1(0)\n         DC    AL1(25,26,27,28)\n         DC    AL1(0)\n         DC    AL1(29,30,31,32)\n         ORG   ,\n TITLE 'SALVAGE - DEVICE TYPE TABLE'\n         DC     0D'0'\nDEVTAB   DEVICE 2301,02,ALT=0\nDEVTABL  EQU    *-DEVTAB\n         DEVICE 2311,01,ALT=200\n         DEVICE 2314,08,ALT=200\n         DEVICE 2305-1,06,ALT=0\n         DEVICE 2305-2,07,ALT=0\n         DEVICE 3330,09,ALT=404\n         DEVICE 3330-1,0D,ALT=808\n         DEVICE 3340,0A,ALT=0           STRANGE ALTS/CE\n         DEVICE 3350,0B,ALT=555,CE=(1024,1024)\n         DEVICE 3375,0C,ALT=0\nDEVTABE  DEVICE 3380,0E,ALT=0\n         DEVICE UNKNOWN,FF,ALT=0        DEFAULT DEVICE\n         SPACE 1\n         PRINT NOGEN\n         OACREGS ,\n*        PRINT GEN\n         SPACE 1\nCVT      DSECT ,\n         CVT\n         SPACE 1\n         DCBD\n         SPACE 1\n         IEZDEB\n         SPACE 1\nUCB      DSECT ,\n         IEFUCBOB\n         SPACE 1\n         END\n//*KED.SYSLMOD DD DISP=SHR,DSN=SYS1.OACAPF,SPACE=,UNIT=\n//LKED.SYSIN   DD *\n  ENTRY ENTRY\n  IDENTIFY SALVAGE('CS01431')\n  NAME SALVAGE$(R)\n//*\n//C EXEC PGM=COMPARE,PARM='SALVAGE$,SALVAGE'\n//STEPLIB DD DISP=SHR,DSN=SYS5.MSSLOAD\n//I1      DD DISP=(SHR,PASS),DSN=&&GOSET\n//I2      DD DISP=SHR,DSN=SYS1.OACAPF\n//SYSPRINT DD SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMPULCMP": {"ttr": 10506, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x01'\\x01'\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 295, "newlines": 295, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMASA JOB SMP,MSGCLASS=A,NOTIFY=CSYSMAS,\n//     COND=(5,LT),TIME=(,30),CLASS=F\n/*ROUTE PRINT WYLBUR\n// EXEC PLIXC,PARM.PLI='MAR(2,72,1),X,A,AG,STMT,NMI,GOSTMT'\n//* RG=2048K\n//PLI.SYSIN DD *\n  /*---              SMP UNLOAD COMPARE UTILITY                   ---*/\n  CMPUNLD: PROC OPTIONS(MAIN);\n\n /*------------------------------------------------------------------*/\n /*                                                                  */\n /*  CMPUNLD:  COMPARE SMP UNLOAD OUTPUT                             */\n /*                                                                  */\n /*   JCL TO RUN:  FILE1 - SMP UNLOAD FILE 1                         */\n /*                FILE2 - SMP UNLOAD FILE 2                         */\n /*                SYSPRINT - OUTPUT                                 */\n /*                                                                  */\n /*                                                                  */\n /* SMP UNLOAD REP CARD FORMAT:                                      */\n /*    1,3 = 'REP'                                                   */\n /*    11,8 = ENTRY TYPE (SYS, ASSEM, MAC, LMOD, DLIB, MOD, SYSMOD)  */\n /*    29,8 = ENTRY MODULE NAME (BLANK FOR SYS)                      */\n /*                                                                  */\n /*  IF SAME TYPE (LMOD/MOD/ASSEM/SYS) ASSUME                        */\n /*     ENTRIES ARE IN ORDER (ASCENDING)                             */\n /*                                                                  */\n /*  DON'T COMPARE COLS 73-80...                                     */\n /*  COLUMN ONE STARTS WITH:                                         */\n /*     'UCLIN '                                                     */\n /*     'REP   '                                                     */\n /*     '++ASMIN '                                                   */\n /*     '++ENDASMIN '                                                */\n /*     '++LMODIN '                                                  */\n /*     '++ENDLMODIN '                                               */\n /*                                                                  */\n /*                                                                  */\n /*     <ENDING CARD WITH JUST A PERIOD IN MIDDLE?>                  */\n /*                                                                  */\n /*    OUTPUT FORMAT:                                                */\n /*     132 CHARACTER LINES,                                         */\n /*      80 BYTE (72?) CARD IMAGES                                   */\n /*        1 OVER THE OTHER                                          */\n /*     (MSG WITH TYPE, MOD, CARD#)                                  */\n /*                                                                  */\n /*------------------------------------------------------------------*/\n\n  DCL (FILE1, FILE2) RECORD INPUT;\n\n  DCL 1 F1,\n        2 FFILE    FILE VARIABLE,\n        2 FCNTIN   FIXED BIN(31) INIT(0),\n        2 FCNTMOD  FIXED BIN(31) INIT(0),\n        2 FEOF     FIXED BIN(31) INIT(0),\n        2 FCTL     FIXED BIN(31) INIT(0),\n        2 FTYPEX   FIXED BIN(31) INIT(0),     /* ENCODED FTYPE       */\n        2 FSAVEC   FIXED BIN(31) INIT(0),     /* LAST READ IN S#CARD */\n        2 FSAVEM   FIXED BIN(31) INIT(0),     /* LAST IN S#CARD      */\n        2 FSAVEP   POINTER,\n        2 FCARD    CHAR(80)      INIT(' '),   /* INPUT BUFFER        */\n        2 FSAVE    CHAR(80)      INIT(' '),   /* NEXT IF CTL \u00ac= 0    */\n        2 FTYPE    CHAR(8)       INIT(' '),\n        2 FMOD     CHAR(8)       INIT(' '),\n      1 F2 LIKE F1,\n      1 FX BASED(PX) LIKE F1;\n\n  DCL (P1, P2, PX) POINTER STATIC;\n        P1 = ADDR(F1.FFILE);\n        P2 = ADDR(F2.FFILE);\n\n    F1.FFILE = FILE1;   F2.FFILE = FILE2;\n\n  DCL TTABLE(7) CHAR(8) STATIC INIT(\n       'SYS     ',                   /* TYPES OF ENTRIES             */\n       'ASSEM   ',                   /*  IN ORDER UNLOADED BY SMP    */\n       'LMOD    ',\n       'MAC     ',\n       'MOD     ',\n       'DLIB    ',\n       'SYSMOD  ');\n\n  DCL DOTCARD CHAR(80) STATIC INIT(' ');\n      SUBSTR(DOTCARD,27,1) = '.';\n\n  DCL SCARD# FIXED BIN(31) INIT(7000),\n      S1CARD(SCARD#) CHAR(72),\n      S2CARD(SCARD#) CHAR(72),\n      SXCARD(32767) CHAR(72) BASED(FX.FSAVEP);\n\n      F1.FSAVEP = ADDR(S1CARD(1));\n      F2.FSAVEP = ADDR(S2CARD(1));\n\n  DCL (IX1, MISMATCH)  FIXED BIN(31) STATIC INIT(0);\n\n  DCL (ADDR, SUBSTR, HIGH) BUILTIN;\n\n  DCL (SYSPRINT,PRINT2) FILE PRINT STREAM;\n\n  DCL (TFILE, TTYPE, TMOD) CHAR(8) STATIC INIT(' '),\n       TFLAG BIT(1) STATIC INIT('1'B);\n\n   ON ENDPAGE(PRINT2) BEGIN;\n      PUT FILE(PRINT2) EDIT(' CMPUNLD - SMP UNLOAD COMPARE - ',\n          'FILE ', TFILE, TTYPE, TMOD)\n          (PAGE, A, A, A, A, A);\n      PUT FILE(PRINT2) SKIP;\n   END;\n\n   ON ENDFILE(FILE1) F1.FEOF = -1;\n   ON ENDFILE(FILE2) F2.FEOF = -1;\n\n   DO WHILE(READ(P1,0) = 0);\n   END;\n   DO WHILE(READ(P2,0) = 0);\n   END;\n\n LOOP1:\n   IF READ(P1,1) \u00ac= 0 THEN F1.FTYPEX = 100;\n   IF READ(P2,1) \u00ac= 0 THEN F2.FTYPEX = 100;\n\n LOOP2:\n   IF F1.FTYPEX = 100 & F2.FTYPEX = 100 THEN GOTO EOF;\n\n   IF F1.FTYPEX = F2.FTYPEX & F1.FMOD = F2.FMOD THEN DO;\n     LPEQ1:\n      IX1 = READ(P1,0) & READ(P2,0);\n      IF IX1 = 0 THEN DO;\n         IF F1.FCARD \u00ac= F2.FCARD THEN DO;\n            IF SUBSTR(F1.FCARD,11,8) = 'LASTUPD '\n             & SUBSTR(F2.FCARD,11,8) = 'LASTUPD ' THEN GOTO OKEQ;\n            IF SUBSTR(F1.FCARD,11,12) = 'LASTUPDTYPE '\n             & SUBSTR(F1.FCARD,11,12) = 'LASTUPDTYPE ' THEN GOTO OKEQ;\n            IF F1.FCARD = ' ' & F2.FCARD = DOTCARD THEN GOTO OKEQ;\n            IF F2.FCARD = ' ' & F1.FCARD = DOTCARD THEN GOTO OKEQ;\n            IF SQUEEZE(F1.FCARD) = SQUEEZE(F2.FCARD) THEN GOTO OKEQ;\n            MISMATCH = 1;\n            PUT FILE(SYSPRINT) EDIT(F1.FTYPE, '/', F1.FMOD,\n                                    F1.FCNTMOD, '>', F1.FCARD, '<')\n                    (SKIP(1), A, A, A, F(5), X(1), A, A(72), A);\n            PUT FILE(SYSPRINT) EDIT(F2.FTYPE, '/', F2.FMOD,\n                                    F2.FCNTMOD, '>', F2.FCARD, '<')\n                    (SKIP(1), A, A, A, F(5), X(1), A, A(72), A);\n        OKEQ:\n         END;\n      GOTO LPEQ1;\n      END;\n\n      IF MISMATCH \u00ac= 0 THEN DO;\n         TFILE = 'FILE 1';\n         TTYPE = F1.FTYPE;    TMOD = F1.FMOD;\n         IF TFLAG THEN DO;\n            TFLAG = '0'B;\n            SIGNAL ENDPAGE(PRINT2);\n         END;\n         PUT FILE(PRINT2) EDIT('** FILE 1 ** - ',\n             F1.FTYPE, F1.FMOD)\n             (SKIP(2), A, A, A);\n         DO WHILE(READ(P1,2) = 0);\n            PUT FILE(PRINT2) EDIT(F1.FCNTMOD, '>', F1.FCARD, '<')\n                (SKIP, X(17), F(5), X(1), A, A(72), A);\n         END;\n         TFILE = 'FILE 2';\n         PUT FILE(PRINT2) EDIT('** FILE 2 ** - ',\n             F2.FTYPE, F2.FMOD)\n             (SKIP(2), A, A, A);\n         DO WHILE(READ(P2,2) = 0);\n            PUT FILE(PRINT2) EDIT(F2.FCNTMOD, '>', F2.FCARD, '<')\n                (SKIP, X(17), F(5), X(1), A, A(72), A);\n         END;\n         MISMATCH = 0;\n      END;\n      GOTO LOOP1;\n   END;\n\n   IF (F1.FTYPEX > F2.FTYPEX) |\n      (F1.FTYPEX = F2.FTYPEX & F1.FMOD > F2.FMOD) THEN DO;\n      PUT FILE(SYSPRINT) EDIT(' *** ENTRY/MOD ',\n                               F2.FTYPE, '/', F2.FMOD,\n                              ' MISSING FROM FILE1')\n              (SKIP(1), A, A, A, A, A);\n      DO WHILE(READ(P2,0) = 0);\n      END;\n      IF READ(P2,1) \u00ac= 0 THEN F2.FTYPEX = 100;\n      GOTO LOOP2;\n   END;\n\n   IF (F1.FTYPEX < F2.FTYPEX) |\n      (F1.FTYPEX = F2.FTYPEX & F1.FMOD < F2.FMOD) THEN DO;\n      PUT FILE(SYSPRINT) EDIT(' *** ENTRY/MOD ',\n                               F1.FTYPE, '/', F1.FMOD,\n                              ' MISSING FROM FILE2')\n              (SKIP(1), A, A, A, A, A);\n      DO WHILE(READ(P1,0) = 0);\n      END;\n      IF READ(P1,1) \u00ac= 0 THEN F1.FTYPEX = 100;\n      GOTO LOOP2;\n   END;\n\n    PUT FILE(SYSPRINT) EDIT('*** LOGIC ERROR ***')\n             (SKIP(3), A);\n    STOP;\n\n\n READ:  PROC(ZX,ROPT) RETURNS(FIXED BIN(31));\n  /*                                                                 */\n  /*   READ(??,0) - READ NEXT CARD IN MOD (EOF IF HITS NEXT MOD)     */\n  /*   READ(??,1) - READ NEXT CARD (EOF ON REAL EOF ONLY)            */\n  /*   READ(??,2) - RE-READ CURRENT MOD                              */\n  /*                                                                 */\n  DCL ZX POINTER,\n      ROPT FIXED BIN(31);\n  DCL IX1 FIXED BIN(31);\n     PX = ZX;\n     FX.FCARD = ' ';                           /* NO CARD YET        */\n\n     IF ROPT = 2 THEN DO;                      /* RE-READ CURRENT    */\n        IF FX.FSAVEC >= FX.FSAVEM THEN RETURN(-1);\n        FX.FSAVEC = FX.FSAVEC + 1;\n        FX.FCNTMOD = FX.FSAVEC;\n        FX.FCARD = SXCARD(FX.FSAVEC);\n        RETURN(0);\n     END;\n\n     IF FX.FCTL = 0 THEN DO;                   /* IF NEED NEW CARD   */\n        IF FX.FEOF \u00ac= 0 THEN RETURN(-1);       /* RETURN IF EOF      */\n        READ FILE(FX.FFILE) INTO(FX.FSAVE);    /*   GET IT           */\n        FX.FCNTIN = FX.FCNTIN + 1;             /*   AND COUNT IT     */\n        SUBSTR(FX.FSAVE,73,8) = '        ';    /*   BLANK SEQ FIELD  */\n        FX.FCTL = 1;                           /*   NOW HAVE CARD    */\n     END;\n     IF FX.FEOF \u00ac= 0 THEN RETURN(-1);          /* RETURN IF EOF      */\n     IF SUBSTR(FX.FSAVE,1,4) = 'REP ' THEN DO;\n        IF ROPT = 0 THEN RETURN(-1);           /* IF JUST READ MOD   */\n        FX.FSAVEC = 0;   FX.FSAVEM = 0;        /* CLEAR OUT SXCARD   */\n        FX.FCNTMOD = 0;                        /* ZERO MOD CARD CNT  */\n        FX.FTYPE = SUBSTR(FX.FSAVE,11,8);      /*  ENTRY TYPE        */\n        FX.FMOD  = SUBSTR(FX.FSAVE,29,8);      /*  MOD NAME          */\n        DO IX1 = 1 TO 7;\n           IF TTABLE(IX1) = FX.FTYPE THEN DO;\n              FX.FTYPEX = IX1;\n              GOTO RDFND;\n           END;\n        END;\n       PUT FILE(SYSPRINT) EDIT(' UNKNOWN ENTRY TYPE: ',\n                                FX.FTYPE, FX.FSAVE)\n               (SKIP(3), A, A, SKIP(1), X(20), A);\n       STOP;\n      RDFND:\n     END;\n     FX.FCARD = FX.FSAVE;\n     FX.FCNTMOD = FX.FCNTMOD + 1;\n     FX.FCTL = 0;\n     IF FX.FSAVEM = SCARD# THEN\n        PUT FILE(SYSPRINT) EDIT('*** SAVE OVERFLOW: ',\n                 FX.FTYPE, FX.FMOD)\n                (SKIP(1), A, A, A);\n     ELSE DO;\n        FX.FSAVEM = FX.FSAVEM + 1;\n        SXCARD(FX.FSAVEM) = FX.FCARD;\n     END;\n     RETURN(0);\n END;\n\n\n SQUEEZE: PROC(SQCARD) RETURNS(CHAR(80));\n   DCL SQCARD CHAR(80);\n   DCL WQCARD CHAR(80);\n   DCL (IX1, IX2) FIXED BIN(31);\n\n   WQCARD = ' ';\n   IX1    = 1;          /* FROM POINTER                              */\n   IX2    = 1;          /* TO POINTER                                */\n SQLOOP:\n   /* COPY NONBLANKS STARTING AT IX1 TO IX2                          */\n   DO WHILE (IX1 <= 72 & SUBSTR(SQCARD,IX1,1) \u00ac= ' ');\n      SUBSTR(WQCARD,IX2,1) = SUBSTR(SQCARD,IX1,1);\n      IX1 = IX1 + 1;\n      IX2 = IX2 + 1;\n   END;\n   IX2 = IX2 + 1;       /* LEAVE 1 BLANK FOR BLANKS                  */\n   /* SKIP BLANKS                                                    */\n   DO WHILE (IX1 <= 72 & SUBSTR(SQCARD,IX1,1) = ' ');\n      IX1 = IX1 + 1;\n   END;\n   IF IX1 <= 72 THEN GOTO SQLOOP;\n  RETURN(WQCARD);\n END;  /* SQUEEZE */\n  EOF:\n END;  /* CMPUNLD */\n//\n//GO.PRINT2 DD SYSOUT=*,\n//  DCB=(RECFM=VBA,LRECL=137,BLKSIZE=141)\n//GO.FILE1  DD DISP=SHR,DSN=CSYSCST.UNLOAD.IOGEN,\n//  DCB=(BUFNO=13)\n//GO.FILE2  DD DISP=SHR,DSN=CSYSCST.UNLOAD.FULLGEN,\n//  DCB=(BUFNO=13)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TAPEMAP": {"ttr": 10758, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\x05\\x00\\x05\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "FILE149"}, "text": "*\n* TO SEE THE MOST RECENT VERSION OF TAPEMAP\n* SEE FILE 299 OF THE CBT MODS TAPE FROM DAVE COLE\n* AT COMNET\n*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UNIQUE": {"ttr": 10760, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x01T\\x01T\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 340, "newlines": 340, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMASA JOB ACCNT,MSGCLASS=A,COND=(0,NE)\n/*ROUTE PRINT WYLBUR\n//ASM EXEC ASMHCL\n//ASM.SYSLIB DD\n//           DD\n//           DD DISP=SHR,DSN=SYS5.MSSMAC\n*---------------------------------------------------------------------*\n*                                                                     *\n* UNIQUE - SELECT ONLY UNIQUE RECORDS                                 *\n*                                                                     *\n*  PARM:  (SPECIFIES POSITION OF KEY IN INPUT FILE)                   *\n*         SEQUENCE OF: OFFSET1, LENGTH, ORDER                         *\n*                                                                     *\n*     OFFSETS ORIG 1 (RANGE 1 -> 4095)                                *\n*     LENGTH ORIG 0 (RANGE 1 -> 256)                                  *\n*                                                                     *\n*       OFFSET ORIG 1; LENGTH OF FIELD; SORT ORDER (A OR D)           *\n*                                                                     *\n*  INPUT:  IN  - INPUT FILE                                           *\n*                                                                     *\n*  OUTPUT: OUT - OUTPUT FILE;                                         *\n*                EACH UNIQUE KEYED RECORD FROM INPUT FILE             *\n*                                                                     *\n*   NOTE: ANY OUTPUT RECFM/LRECL WILL BE ACCEPTED,                    *\n*         RDW'S WILL BE BUILD/DESTROYED AND THE                       *\n*         RECORDS WILL BE TRUNCATED OR PADDED AS REQUIRED.            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         OACWORK &DUMMY\nW#DWD    DC    D'0'\nW#BUFPT  DC    A(0)               @ RECORD SAVE BUFFER\nW#SAVPT  DC    A(0,0)             @ SAVED RECORD, LENGTH RECORD\nW#PARM   DC    CL101' '\nW#CODE   DC    50D'0'\n         MEND\n         SPACE 1\nUNIQUE   OACENTER EXIT=(EXIT,(R15)),                                   X\n               WORK=(0,MPARM),DSECT=W#,                                X\n               STACK=(2048,W#STACK,E$OFLOW,ABEND),ROUND=YES\n         SPACE 1\n         SR    R0,R0\n         ST    R0,W#SAVPT\n         ST    R0,W#SAVPT+4\n         OPEN  MF=(E,OPENLIST)    OPEN ALL DATASETS\n         TM    DCBOFLGS-IHADCB+SYSPRINT,DCBOFOPN\n         BZ    ABND99\n         TM    DCBOFLGS-IHADCB+DCBIN,DCBOFOPN\n         BZ    ABND99\n         TM    DCBOFLGS-IHADCB+DCBOUT,DCBOFOPN\n         BZ    ABND99\n         SPACE 1\n         LH    R3,DCBLRECL-IHADCB+DCBIN\n         LA    R3,2048(,R3)\n         GETMAIN R,LV=(R3)        GET SAVE BUFFER\n         LA    R1,0(,R1)\n         ST    R1,W#BUFPT         SAVE @ SAVE BUFFER\n         SPACE 1\n         L     R2,0(,R9)          @ PARM\n         LH    R3,0(,R2)          LENGTH OF PARM\n         LTR   R3,R3\n         BZ    NOPARM             BIF NO PARM\n         LA    R2,2(,R2)          @ PARM STRING\n         LA    R14,W#PARM\n         LA    R15,L'W#PARM\n         MVCL  R14,R2             COPY PARM, PAD WITH X'00'\n         SPACE 1\n         LA    R1,W#PARM\n         LA    R2,W#CODE-2        @ FOR COMPARE ROUTINE\n         SPACE 1\n** IF BOTH EOF THEN MUST RETURN EQUAL\n** ELSE EOF ALWAYS < ANY REAL RECORD\n         SPACE 1\nPARMLP   OACCALL NUMCNVT,ERROR=PARMER GET OFFSET1\n         LR    R5,R0              SAVE OFFSET\n         C     R5,=F'4096'\n         BH    PARMER\n         BCTR  R5,0                GET OFFSET ORIG 0\n         LA    R1,1(,R1)          SKIP COMMA\n         OACCALL NUMCNVT,ERROR=PARMER GET LENGTH\n         LTR   R0,R0\n         BNP   PARMER\n         C     R0,=F'256'\n         BH    PARMER\n         LA    R1,1(,R1)          SKIP COMMA\n         SPACE 1\n         MVC   2+0(8,R2),=X'D50020003000077E' PATTERN CODE\n         STH   R5,W#DWD\n         OC    2+2(2,R2),W#DWD    OFFSET TO IN FIELD\n         OC    2+4(2,R2),W#DWD    OFFSET TO IN FIELD\n         BCTR  R0,0               GET CLC TYPE LENGTH\n         STC   R0,2+1(,R2)        SET LENGTH IN CLC\n         CLI   0(R1),C'A'          ASCENDING ORDER?\n         BE    PARM1\n         CLI   0(R1),C'D'          DESCENDING ORDER?\n         BNE   NOPARM             BIF INVALID PARM\n*** REVERSE ORDER OF CLC FOR ASCENDING ORDER\n         XC    2+2(2,R2),2+4(R2)  SWAP ORDER OF COMPARE FOR\n         XC    2+4(2,R2),2+2(R2)     DESCENDING ORDER\n         XC    2+2(2,R2),2+4(R2)\nPARM1    LA    R2,8(,R2)          POINT PAST FIELD COMPARE\n         LA    R1,1(,R1)          SKIP OVER 'A' OR 'D'\n         CLI   0(R1),C','         COMMA?\n         LA    R1,1(,R1)          SKIP OVER 'A' OR 'D'\n         BE    PARMLP             BIF MORE INPUT\n         MVI   1(R2),X'FE'        CHANGE LAST BCR TO ALWAYS RETURN\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*  COMPARE INPUT RECORDS;                                             *\n*    INPUT FILES ARE ASSUMED IN ASCENDING ORDER                       *\n*     SINCE AN EOF IS HIGHER THAN ANYTHING                            *\n*     (EXCEPT ANOTHER EOF TO WHICH IT IS EQUAL)                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\n         OACCALL GET,MF=(E,IN)    GET RECORD FROM IN\nLOOP1    OACCALL SAVE             SAVE INPUT RECORD (IF ANY)\nMATCH    OACCALL GET,MF=(E,IN)    GET RECORD FROM IN\n         L     R3,IN+8            @ INPUT RECORD (IF ANY)\n         LTR   R3,R3              ANY RECORD HERE?\n         BZ    DONE               BIF EOF ON IN\n         L     R2,W#SAVPT         @ OF PREV SAVED RECORD\n         LA    R15,W#CODE         @ COMPARE ROUTINE\n         BALR  R14,R15            COMPARE SAVED :: INPUT RECORD\n         BE    MATCH              BIF EQUAL RECORDS\n         BH    SEQERR             BIF SAVED > INPUT; SEQUENCE ERROR\n*---     ELSE INPUT RECORD < SAVED RECORD\n         MVC   OUT+8(8),W#SAVPT   COPY ADDR,LEN OF SAVED RECORD\n         OACCALL PUT,MF=(E,OUT)   OUTPUT SAVED RECORD\n         B     LOOP1              AND CONTINUE\n         SPACE 1\n*---     FILE 1 > FILE 2 - (FILE 2 MODULE MISSING FROM FILE 1)\nSEQERR   MVC   LINE+1(14),=C'SEQUENCE ERROR'\n         PUT   SYSPRINT,LINE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         B     DONE\n         EJECT ,\nDONE     LM    R2,R3,W#SAVPT\n         LTR   R2,R2              ANY SAVED RECORD?\n         BZ    DONE2\n         STM   R2,R3,OUT+8\n         OACCALL PUT,MF=(E,OUT)\n         SPACE 1\nDONE2    LA    R2,MSG1\n         LA    R3,IN\n         LA    R4,2\nEOF1     L     R0,0(,R3)\n         CVD   R0,W#DWD\n         MVC   LINE+1(10),=X'40202020202020202120'\n         ED    LINE+1(10),W#DWD+3\n         MVC   LINE+15(30),0(R2)\n         PUT   SYSPRINT,LINE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         LA    R2,30(,R2)\n         LA    R3,4*4(,R3)\n         BCT   R4,EOF1\n         SPACE 1\n         CLOSE MF=(E,OPENLIST)\n         SR    R15,R15\n         B     EXIT\n         SPACE 1\nPARMER   WTO   'MAS000I (UNIQUE) - PARM ERROR',ROUTCDE=(11)\n         ABEND 97\n         SPACE 1\nNOPARM   WTO   'MAS000I (UNIQUE) - NO PARM: OFF,LEN,A/D',ROUTCDE=(11)\n         ABEND 98\n         SPACE 1\nABND99   ABEND 99,DUMP\n         OACDROP R10\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*  SAVE - SAVE INPUT RECORD                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nSAVE     OACSUB INUSE=NO\n         LM    R2,R3,IN+8         ADDR/LEN INPUT RECORD\n         LTR   R2,R2              ANY INPUT RECORD?\n         BZ    SAV$EOF\n         L     R4,W#BUFPT\n         LR    R5,R3              COPY RECORD LENGTH\n         STM   R4,R5,W#SAVPT\n         MVCL  R4,R2              COPY RECORD\nSAV$RET  OACRET ,\nSAV$EOF  STM   R2,R3,W#SAVPT      SAVE EOF INDICATION\n         B     SAV$RET\n         OACDROP R10\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*  GET - GET NEXT INPUT RECORD                                        *\n*                                                                     *\n*   ENTRY: R1  - PARM POINTER                                         *\n*                 + 0 - RECORD COUNT                                  *\n*                 + 4 - @ INPUT DCB                                   *\n*                 + 8 - @ INPUT RECORD (RETURN VALUE, 0 FOR EOF)      *\n*                 +12 - LENGTH OF INPUT RECORD (RETURN VALUE)         *\n*          R14 - RETURN ADDRESS                                       *\n*          R15 - @ GET                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nGET      OACSUB INUSE=NO\n         LR    R9,R1              @ PARM LIST\n         L     R0,8(,R9)          PREV EOF OCCUR?\n         LTR   R0,R0\n         BZ    GET$EOF            BIF PREV EOF\n         L     R8,4(,R9)          @ INPUT DCB\n         OACUSING IHADCB,R8\n         TM    DCBOFLGS,DCBOFOPN  IF NOT OPEN,\n         BZ    GET$EOF              LET IT BE EOF\n         GET   (R8)               LOCATE NEXT INPUT RECORD (OR EOF)\n         SR    R15,R15            RETURN CODE ZERO\n         LA    R2,0(,R1)          @ RECORD WITH CLEAR HIGH BYTE\n         LH    R3,DCBLRECL        LRECL (IF U OR F)\n         TM    DCBRECFM,DCBRECF\n         BNZ   G$SET1             BIF RECFM U OR F\n         MVC   0(2,R13),0(R2)     ALIGN LENGTH FROM RDW\n         LH    R3,0(,R13)\nG$SET1   LA    R0,1               COUNT RECORD\n         AL    R0,0(,R9)\n         ST    R0,0(,R9)\nG$SET2   STM   R2,R3,8(R9)\nG$RET    OACRET RC=(R15)\nGET$EOF  LA    R15,4              EOF\n         SR    R2,R2              NO RECORD ADDRESS\n         SR    R3,R3               RECORD LENGTH ZERO\n         B     G$SET2\n         OACDROP R10,R8\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*  RECPUT - PUT RECORD                                                *\n*                                                                     *\n*   ENTRY: R1  - @ PARMLIST                                           *\n*                  + 0 - RECORD COUNT                                 *\n*                  + 4 - @ OUTPUT DCB                                 *\n*                  + 8 - @ RECORD TO OUTPUT                           *\n*                  +12 - LENGTH OF RECORD TO OUTPUT                   *\n*                                                                     *\n*   (IGNORE CALL IF OUTPUT DCB NOT OPEN)                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nPUT      OACSUB INUSE=NO\n         LR    R9,R1              @ PARMLIST\n         L     R8,4(,R9)          @ OUTPUT DCB\n         OACUSING IHADCB,R8\n         LA    R0,1               COUNT OUTPUT RECORD\n         AL    R0,0(,R9)\n         ST    R0,0(,R9)\n         TM    DCBOFLGS,DCBOFOPN  OUTPUT DCB OPEN?\n         BZ    P$RET              RIF OUTPUT DCB NOT OPEN\n         LM    R2,R3,8(R9)        ADDR, LEN OF OUTPUT RECORD\n         LH    R5,DCBLRECL        ASSUME RECFM=F\n         TM    DCBRECFM,DCBRECV\n         BZ    P$PUT2             BIF RECFM=F\n         LA    R5,4(,R3)          ASSUME RECFM=V\n         TM    DCBRECFM,DCBRECF\n         BZ    P$PUT1             BIF RECFM=V\n         LR    R5,R3              ELSE RECFM=U\nP$PUT1   STH   R5,DCBLRECL        SET LRECL FOR PUT LOCATE\nP$PUT2   PUT   (R8)\n         LA    R4,0(,R1)          @ OUTPUT AREA\n         SPACE 1\n         TM    DCBRECFM,DCBRECF   RECFM=V?\n         BNZ   P$PUT3             BIF NOT RECFM=V\n         LA    R4,4(,R4)          BUMP OUTPUT PTR OVER RDW\n         SH    R5,=H'4'           DCR OUTPUT DATA LENGTH\n         SPACE 1\nP$PUT3   CR    R3,R5              INPUT LEN > OUTPUT LEN?\n         BNH   P$PUT4\n         LR    R3,R5              TRUNCATE LONG INPUT RECORD\nP$PUT4   TM    DCBRECFM,DCBRECF   RECFM=V?\n         BO    P$PUT5             BIF NOT RECFM=V\n         LA    R0,4(,R5)          LENGTH OF RECORD INCLUDING RDW\n         SLL   R0,16\n         ST    R0,0(,R13)\n         MVC   0(4,R1),0(R13)     INIT RDW\nP$PUT5   MVCL  R4,R2              MOVE RECORD DATA TO OUTPUT AREA\nP$RET    OACRET ,\n         OACDROP R10,R8\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n* NUMCNVT - CONVERT CHAR TO BINARY NUMBER                             *\n*                                                                     *\n*  ENTRY: R1 - @ OF INPUT STRING (UPDATED)                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nNUMCNVT  OACSUB INUSE=NO\n         SR    R0,R0              INIT RESULT TO ZERO\n         LA    R15,4              ASSUME RC 4; NO NUMBER EXISTS\nNC$LOOP  CLI   0(R1),C'0'\n         BL    NC$RET\n         CLI   0(R1),C'9'\n         BH    NC$RET\n         IC    R2,0(,R1)\n         N     R2,=X'0000000F'\n         MH    R0,=H'10'\n         AR    R0,R2\n         LA    R1,1(,R1)\n         SR    R15,R15            RETURN CODE 0; HAVE NUMBER\n         B     NC$LOOP\n         SPACE 1\nNC$RET   OACRET RC=(R15)\n         OACDROP R10\n         EJECT ,\n         SPACE 1\nOPENLIST OPEN  (SYSPRINT,(OUTPUT),                                     X\n               DCBIN,(INPUT),                                          X\n               DCBOUT,(OUTPUT)),MF=L\n         SPACE 1\n* RECORD COUNT; @ DCB; @ RECORD OR 0; LENGTH OF RECORD\nIN       DC    F'0',A(DCBIN,1,0)\nOUT      DC    F'0',A(DCBOUT,1,0)\n         SPACE 1\nMSG1     DC    CL30'RECORDS READ               '\n         DC    CL30'RECORDS WRITTEN           '\n         SPACE 1\nLINE     DC    CL133' '           PRINT LINE\n         PRINT NOGEN\nDCBIN    DCB   DDNAME=IN,DSORG=PS,MACRF=GL,EODAD=GET$EOF\nDCBOUT   DCB   DDNAME=OUT,DSORG=PS,MACRF=PL\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,                      X\n               LRECL=133,RECFM=FBA,BLKSIZE=1330\n         SPACE 1\n         DCBD  DSORG=PS\n         END\n//*KED.SYSLMOD DD DISP=SHR,DSN=SYS5.MSSLOAD,SPACE=,UNIT=\n//LKED.SYSIN   DD *\n    ENTRY UNIQUE\n    IDENTIFY UNIQUE('CS01326')\n    NAME UNIQUE(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "URHEXFMT": {"ttr": 11009, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00!\\x00!\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "FILE149"}, "text": "         MACRO\n&LBL     URHEXFMT &DSECT=YES,&PREFIX=IPRM\n         LCLC  &P,&L\n.**********************************************************************\n.*                                                                    *\n.*  URHEXFMT PARAMETER LIST / WORK AREA FORMAT                        *\n.*                                                                    *\n.*    DSECT  - YES/NO                                                 *\n.*    PREFIX - DEFAULT IS 'IPRM'  (ANY 4 CHARS)                       *\n.*                                                                    *\n.**********************************************************************\n.*\n&P       SETC  '&PREFIX'\n&L       SETC  '&PREFIX'\n         AIF   ('&LBL' EQ '').L0\n&L       SETC  '&LBL'\n.L0      AIF   ('&DSECT' NE 'YES').L1\n&L       DSECT ,                  URHEXFMT PARM LIST DSECT\n         AGO   .L2\n.L1      ANOP\n&L       DC    0D'0'              URHEXFMT PARM LIST AREA\n.L2      ANOP\n&P.#WPT  DC    A(0)               @ WORK AREA   (64 BYTES)\n&P.#WL   EQU   64                 LENGTH OF WORK AREA\n&P.#BPT  DC    A(0)               @ OUTPUT AREA (80 BYTES)\n&P.#OL   EQU   80                 LENGTH OF OUTPUT AREA\n&P.#CBR  DC    A(0)               @ STORAGE CONTAINING CTL BLOCK\n&P.#CBA  DC    A(0)               @ CONTROL BLOCK (ORIGIN)\n&P.#CBP  DC    A(0)               CONTROL BLOCK MIN OFFSET\n&P.#CBL  DC    A(0)               CONTROL BLOCK MAX OFF+1 (LEN)\n&P.#CBO  DC    A(0)               CUR CTL BLOCK OFFSET (UPDATED)\n&P.L     EQU   *-&L               LENGTH OF URHEXFMT PARM LIST\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "USERS": {"ttr": 11011, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x00\\xae\\x00\\xae\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 174, "newlines": 174, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMASU JOB ,USERS,NOTIFY=CSYSMAS,MSGCLASS=A,COND=(0,NE)\n/*ROUTE PRINT WYLBUR\n//ASM EXEC ASMHCL\n//ASM.SYSLIB DD\n//           DD\n//           DD DISP=SHR,DSN=SYS5.MSSMAC\n***********************************************************************\n*                                                                     *\n*        USERS:  DISPLAY TSO USERS STATISTICS                         *\n*                                                                     *\n***********************************************************************\n         MACRO\n         OACWORK &DUMMY\nDOUBLE   DS    D                  WORK AREA\nMASK     DS    D                  SELECTION MASKS (CHARACTER)\nMASK2    DS    D                    AND (WILD)   *** ORDER ***\nLINE     DS    0X\nUSERID   DS    CL10               USERID\nPROC     DS    CL10               PROC NAME\nFLG1     DS    CL1                INCORE OR OUT\nFLG2     DS    CL2                REASON FOR WAIT\nCPU      DS    CL10               JOBSTEP AND SRB TIME\nINCORE   DS    CL8                FRAMES IN USE\nWKGSET   DS    CL8                SRM WORKING SET\nWAITS    DS    CL7                NUMBER OF SHORT WAITS\nLINLEN   EQU   *-LINE\n         MEND\nUSERS    OACENTER PARM=(R2),EXIT=EXIT,DSECT=WDSECT,WORK=(,X)\n         LR    R1,R2              RESTORE PARM WHERE IT BELONGS\n         MVC   MASK,=C'********'  INIT\n         MVC   MASK2,=C'        '   MASKS\n         TM    0(R1),X'80'        CALLED ? (R1->PARM)\n         BO    NOTCMD             YES, GO TO PLIX\n         SPACE 1\n         L     R2,0(,R1)          LOAD FIRST PARM ADDR.\n         LH    R3,0(,R2)          LOAD CPPL LENGTH FIELD.\n         LH    R4,2(,R2)          LOAD PARAMETER OFFSET FIELD.\n         SH    R3,=H'4'           REDUCE BY CONTROL WORD LENGTH,\n         SR    R3,R4                AND BY PRE-SCANNED LENGTH.\n         LA    R2,2(R2,R4)        CALCULATE ADDRESS OF NEW LNG  FIELD,\n         STH   R3,0(,R2)            STORE LENGTH LIKE AN EXEC PARM.\n         ST    R2,0(,R1)          CHANGE FIRST PARM ADDR.\n         SPACE 1\nNOTCMD   L     R2,0(,R1)          GET PARM ADDR.\n         LH    R3,0(,R2)            AND LENGTH\n         LTR   R3,R3              ANY ?\n         BNP   NOPARM             BIF NONE\n         CH    R3,=H'8'           TOO MUCH ?\n         BNH   *+8                BIF NOT\n         LA    R3,8               USE MAXIMUM\n         BCTR  R3,0               -1 FOR EXECUTE\n         MVC   MASK(0),2(R2)      << EXECUTED >>\n         EX    R3,*-6             MOVE IN PARM\n         SPACE 1\nNOPARM   OC    MASK,MASK2         ENSURE UPPER CASE\n         LA    R1,MASK            ADDR. OF MASKS\n         LA    R0,8               COUNT\nIMASKL   MVI   8(R1),X'FF'        ASSUME NOT WILD\n         CLI   0(R1),C'*'         IS IT WILD ?\n         BNE   *+8                BIF NOT\n         MVI   8(R1),X'00'        WILD\n         LA    R1,1(,R1)          NEXT POSITION\n         BCT   R0,IMASKL          DO ALL\n         SPACE 1\n         LINK  EP=CLEAR           CLEAR THE SCREEN\n         LA    R1,HEADER          OUTPUT HEADER\n         LA    R0,HDRLEN\n         TPUT  (1),(0),R\n         L     R1,16              FIND CVT\n         L     R1,CVTASVT-CVT(R1) FIND ASVT\n         LA    R3,ASVTENTY-ASVT(R1) POINT TO FIRST ENTRY\n         LA    R4,4               BXLE INCREMENT\n         L     R5,ASVTMAXU-ASVT(R1) GET MAX NUMBER ADDRESS SPACES\n         SLA   R5,2               TIMES 4\n         LA    R5,0(R3,R5)        POINT TO END\n         BCTR  R5,0               BACK UP ONE\nLOOP     TM    0(R3),X'FF'        CHECK FOR BITS ON\n         BNZ   LOOPBXLE           IF ANY SKIP\n         L     R2,0(R3)           POINT TO ASCB\n         OACUSING ASCB,R2\n         MVI   LINE,C' '          CLEAR LINE\n         MVC   LINE+1(LINLEN-1),LINE\n         ICM   R1,15,ASCBJBNS     NAME FOR TSO AND STARTED TASKS\n         BZ    LOOPBXLE\n         MVC   DOUBLE,0(R1)       MOVE IN UID\n         XC    DOUBLE,MASK\n         NC    DOUBLE,MASK2\n         BNZ   LOOPBXLE           BIF NOT SELECTED\n         MVC   USERID(8),0(R1)    MOVE IN UID\n         ICM   R1,15,ASCBCSCB     FIND CSCB\n         BZ    LOOPBXLE\n         CLI   CHTRKID-CHAIN(R1),CHTSID TEST FOR TSU\n         BNE   LOOPBXLE\n         MVC   PROC(8),CHCLS-CHAIN(R1) MOVE IN PROC NAME\n         MVI   FLG1,C'O'          DEFAULT TO OUT OF CORE\n         TM    ASCBRCTF,ASCBOUT   IS IT?\n         BO    L1                 YES\n         MVI   FLG1,C'I'          MARK IN CORE\nL1       L     R1,ASCBOUCB        POINT TO OUCB\n         OACUSING OUCB,R1\n         TM    OUCBSFL,OUCBNSW    NON SWAPPABLE?\n         BNO   L2\n         MVI   FLG1,C'N'          MARK NON SWAPPABLE\nL2       TM    OUCBEFL,OUCBLWT    LONG WAIT?\n         BNO   L3\n         MVI   FLG2,C'L'\nL3       TM    OUCBEFL,OUCBTRM    TERMINAL WAIT\n         BNO   L4\n         MVI   FLG2,C'I'\nL4       TM    OUCBEFL,OUCBOWT    OUTPUT WAIT?\n         BNO   L5\n         MVI   FLG2,C'O'\nL5       TM    OUCBEFL,OUCBNQF    ENQHOLD?\n         BNO   L6\n         MVI   FLG2,C'Q'\nL6       TM    OUCBEFL,OUCBMWT    MSO DETECTED WAIT?\n         BNO   L7\n         MVI   FLG2,C'M'\nL7       LM    R6,R7,ASCBEJST     GET JOB STEP TIME\n         LM    R8,R9,ASCBSRBT     GET SRB TIME\n         ALR   R7,R9              ADD\n         BC    12,NOCARRY\n         LA    R8,1(R8)\nNOCARRY  AR    R6,R8\n         SRDL  R6,24              MOVE TO ODD REG\n         M     R6,=A(1048576)     COMPUTE IN SECONDS\n         D     R6,=A(10000*256)\n         CVD   R7,DOUBLE\n         MVC   CPU(10),=X'4020206B2021204B2020'\n         ED    CPU(10),DOUBLE+4   DO THE EDIT\n         LH    R0,ASCBFMCT        GET ALLOCATED PAGE FRAME COUNT\n         SLA   R0,2               TIMES 4 FOR K\n         CVD   R0,DOUBLE\n         MVC   INCORE(8),=X'4020206B202120D2'\n         ED    INCORE(7),DOUBLE+5\n         LH    R0,OUCBWSS         GET WORKING SET SIZE\n         SLA   R0,2               TIMES 4 FOR K\n         CVD   R0,DOUBLE\n         MVC   WKGSET(8),=X'4020206B202120D2'\n         ED    WKGSET(7),DOUBLE+5\n         SR    R0,R0              CLEAR R0\n         ICM   R0,3,ASCBSWCT      GET SHORT WAIT COUNT\n         CVD   R0,DOUBLE\n         MVC   WAITS(7),=X'4020206B202120'\n         ED    WAITS(7),DOUBLE+5\n         LA    R1,LINE\n         LA    R0,LINLEN\n         TPUT  (1),(0),R\nLOOPBXLE BXLE  R3,R4,LOOP\n         SR    R15,R15\n         B     EXIT\nHEADER   DC    CL10'USER'\n         DC    CL10'PROC'\n         DC    CL3'FLG'\n         DC    CL7' ',C'CPU'\n         DC    CL8'    CORE'\n         DC    CL8' WKG-SET'\n         DC    CL7'  WAITS'\nHDRLEN   EQU   *-HEADER\n         LTORG\n         OACMAP DSECT=(CVT,ASVT,ASCB,CSCB,OUCB),PRINT=NONE\n         END\n//*KED.SYSLMOD DD DISP=OLD,DSN=SYS1.OACLINK,UNIT=,SPACE=\n//LKED.SYSIN   DD *\n   ENTRY USERS\n   IDENTIFY USERS('CS01396')\n   NAME USERS$(R)\n//*\n//C   EXEC PGM=COMPARE,\n//  PARM='USERS$,USERS'\n//STEPLIB  DD DISP=SHR,DSN=SYS5.MSSLOAD\n//SYSPRINT DD SYSOUT=*\n//I1       DD DISP=(SHR,PASS),DSN=&&GOSET\n//I2       DD DISP=SHR,DSN=SYS1.OACLINK\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTOCLIST": {"ttr": 11015, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86)\\x9f\\x00\\x86)\\x9f\\x12\\x00\\x12\\x8d\\x12\\x8d\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf1\\xf4\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-10-26T00:00:00", "modifydate": "1986-10-26T12:00:00", "lines": 4749, "newlines": 4749, "modlines": 0, "user": "FILE149"}, "text": "//CSYSMAS1 JOB MSGCLASS=A,TIME=(1,14),REGION=512K\n/*ROUTE PRINT WYLBUR\n//         EXEC ASMHCL,PARM.ASM='BATCH',\n//  PARM.LKED='LIST,XREF,NCAL,LET'\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.AMODGEN\n//         DD  DISP=SHR,DSN=SYS5.MSSMAC\n//SYSIN DD *\nVLST     TITLE 'DIRECT-ACCESS VOLUME DIRECTORY LISTER'\n         MACRO\n&TAG     XPRINNRA  &WA,&IHBPARM\n.* INNER MACRO USED IN CALLS TO 'XPRNTSUB'\n         DC    V(XPRNTSUB)             PRINTING SUBROUTINE ADDRESS\n&TAG     L     15,*-4                  LOAD ENTRY POINT\n         AIF   ('&WA' NE '').WOK\n         LA    0,XPRDCB01              LOAD STANDARD WORK AREA ADDRESS\n         AGO   .BAL\n.WOK     AIF   ('&WA' EQ '(0)').BAL\n         AIF   ('&WA'(1,1) EQ '(').REG\n         LA    0,&WA                   LOAD WORK AREA ADDRESS\n         AGO   .BAL\n.REG     LR    0,&WA(1)                LOAD WORK AREA ADDRESS\n.BAL     BAL   14,&IHBPARM.(15)        CALL PRINT SUBROUTINE\n         MEND\n         MACRO\n&SYMBOL  XPRCLOSE  &WA\n.* MACRO TO EXECUTE A CLOSE CALL TO 'XPRNTSUB'.\n         CNOP  0,4\n&SYMBOL  B     *+8                     BRANCH AROUND ADDRESS\n         XPRINNRA  &WA,68\n         MEND\n         MACRO\n&SYMBOL  XPRDCB  &DDNAME=SYSPRINT,&BLKSIZE=0\n         LCLC  &TAG\n.* MACRO TO GENERATE A WORK AREA FOR A PRINTER DATA SET, CONTAINING\n.* A SAVE AREA, THE DCB, OPEN AND CLOSE PARAMETER LISTS, AND VARIOUS\n.* CELLS AND SWITCHES.\n&TAG     SETC  '&SYMBOL'\n         AIF   (T'&SYMBOL NE 'O').TOK  TEST IF NAME SUPPLIED\n&TAG     SETC  'XPRDCB01'              SUPPLY STANDARD PRDCB NAME\n.TOK     ANOP\n&TAG     DS    0D                      ALIGN ON DOUBLE-WORD BOUNDARY\n         DS    18F                     STANDARD SAVE AREA\n         SPACE\n*        DCB   DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,           X\n*              BLKSIZE=&BLKSIZE,MACRF=PL,BFTEK=S,BUFNO=2\nIHB&SYSNDX DCB DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,            X\n               BLKSIZE=&BLKSIZE,MACRF=PL,BFTEK=S,BUFNO=2\n         SPACE\n* PARAMETER LISTS FOR OPEN AND CLOSE:\n         SPACE\n         OPEN  (IHB&SYSNDX,(OUTPUT,LEAVE)),MF=L  PARM LIST FOR OPEN\n         SPACE\n         CLOSE (IHB&SYSNDX,LEAVE),MF=L PARM LIST FOR CLOSE\n         SPACE\n* WORK CELLS AND VARIABLE STORAGE:\n         SPACE\n         DS    1D                      WORK CELL\n         DS    3F                      WORK CELLS\n         DS    1A                      PAGE HEADING PARM LIST ADDRESS\n         DS    1F                      MAXIMUM NUMBER OF OUTPUT LINES\n         DS    1H                      PAGE WIDTH\n         DS    1H                      PAGE LENGTH\n         DS    1H                      PAGE NUMBER\n         DS    1H                      PAGE BALANCE\n         DS    1X                      SWITCHES\n         DS    CL24                    DATE & TIME FOR PAGE HEADING\n         SPACE 2\n         MEND\n         MACRO\n&SYMBOL  XPREJECT  &WA,&COND=\n.* MACRO TO EXECUTE AN EJECT CALL TO 'XPRNTSUB'.\n         LCLC  &TAG,&SYM,&OPT,&R\n         LCLA  &K\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n         CNOP  2,4\n.TST1    AIF   ('&COND' NE '').TST2\n&OPT     SETC  'F000'\n         AGO   .SIMPLE\n.TST2    AIF   ('&COND' NE 'ATHOF').TSTC\n&OPT     SETC  'F100'\n.SIMPLE  ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM ADDRESS\n         DC    XL2'&OPT'               OPTION BITS\n         AGO   .VCON\n.TSTC    AIF   ('&COND(1)' NE 'EQ').NE\n&OPT     SETC  '80'\n.NE      AIF   ('&COND(1)' NE 'NE').LT\n&OPT     SETC  '70'\n.LT      AIF   ('&COND(1)' NE 'LT').GT\n&OPT     SETC  '40'\n.GT      AIF   ('&COND(1)' NE 'GT').LE\n&OPT     SETC  '20'\n.LE      AIF   ('&COND(1)' NE 'LE').GE\n&OPT     SETC  'C0'\n.GE      AIF   ('&COND(1)' NE 'GE').NOT\n&OPT     SETC  'A0'\n.NOT     AIF   ('&OPT' NE '').COK\n         MNOTE 4,'COND OPERAND &COND(1) ILLEGAL'\n.COK     AIF   ('&COND(2)' NE '').C2OK\n         MNOTE 4,'COND TEST QUANTITY MISSING'\n         AGO   .NOTREG\n.C2OK    AIF   ('&COND(2)'(1,1) NE '(').NOTREG\n&K       SETA  K'&COND(2)-2\n&R       SETC  '&COND(2)'(2,&K)\n&SYM     STC   &R,&TAG.A               STORE INTO PARM LIST\n&SYM     SETC  ''\n.NOTREG  ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM ADDRESS\n         DC    XL1'&OPT'               CONDITION MASK\n         AIF   ('&COND(2)' EQ '').NOTREG2\n         AIF   ('&COND(2)'(1,1) NE '(').NOTREG2\n&TAG.A   DC    AL1(0)                  TEST QUANTITY\n         AGO   .VCON\n.NOTREG2 DC    AL1(&COND(2))           TEST QUANTITY\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,92\n         MEND\n         MACRO\n&SYMBOL  XPRHEAD  &WA,&LIST=\n.* MACRO TO PRESENT A LIST OF PRINT LINE DESCRIPTORS FOR PAGE HEADINGS\n.* TO 'XPRNTSUB'.\n&SYMBOL  XPRLIST  &WA,LIST=&LIST,IHBPARM=80\n         MEND\n         MACRO\n&SYMBOL  XPRLDEF  &TEXT=,&LENGTH=132,&OFFSET=0,&SPA=1,&SPB=0\n.* MACRO TO DEFINE PRINT LINE DESCRIPTOR BLOCKS (\"PLD\" BLOCKS) FOR\n.* THE PRINTING SUBROUTINE \"XPRNTSUB\".\n         LCLA  &N\n         LCLC  &B3,&B6,&B7\n         ACTR  25                      JUST IN CASE\n&B3      SETC  '0'\n&B6      SETC  '0'\n&B7      SETC  '0'\n.* PROCESS OPTIONS IN SPA OPERAND:\n.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1\n         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2\n&B3      SETC  '1'\n         AGO   .TSTB1\n.TSTA2   MNOTE 4,'OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'\n.* PROCESS OPTIONS IN SPB OPERAND:\n.TSTB1   ANOP\n&N       SETA  2\n.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2\n&B7      SETC  '1'\n         AGO   .TSTB4\n.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3\n&B6      SETC  '1'\n         AGO   .TSTB4\n.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4\n         MNOTE 4,'OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'\n.TSTB4   ANOP\n&N       SETA  &N+1\n         AIF   (&N LE 3).TSTB5\n.IFTEXT  AIF   ('&TEXT' NE '').TOK\n         MNOTE 4,'TEXT ADDRESS MISSING'\n.TOK     ANOP\n&SYMBOL  DS    0F                      ALIGN ON FULL-WORD BOUNDARY\n         DC    BL1'000&B3.00&B6&B7'    OPTION BITS\n         DC    AL3(&TEXT)              TEXT ADDRESS\n         DC    AL1(&LENGTH)            TEXT LENGTH\n         DC    AL1(&OFFSET)            MARGIN OFFSET\n.TESTB   AIF   ('&SPB(1)' EQ 'EJECT').BSKIP\n         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP\n         DC    AL1(&SPB(1))            PRE-SPACING\n         AGO   .TESTA\n.BSKIP   ANOP\n         DC    AL1(255)                EJECT BEFORE PRINTING\n.TESTA   AIF   ('&SPA(1)' EQ 'EJECT').ASKIP\n         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP\n         DC    AL1(&SPA(1))                 POST-SPACING\n         MEXIT\n.ASKIP   ANOP\n         DC    AL1(255)                EJECT AFTER PRINTING\n         MEND\n         MACRO\n&SYMBOL  XPRLIST  &WA,&LIST=,&IHBPARM=32\n.* MACRO TO DELIVER A LIST OF PRINT LINE DESCRIPTORS TO 'XPRNTSUB'.\n         LCLA  &N,&K,&D\n         LCLC  &TAG,&SYM,&R\n         ACTR  100\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n         AIF   ('&LIST' NE '').LOK\n         MNOTE 8,'LIST OPERAND MUST BE SUPPLIED'\n         MEXIT\n.LOK     CNOP  0,4\n         AIF   ('&LIST' NE '(1)').STLOOP\n&SYMBOL  B     &TAG.L                  BRANCH AROUND ADDRESS\n         AGO   .VCON\n.STLOOP  ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&LIST).STDONE\n         AIF   ('&LIST(&N)'(1,1) NE '(').STLOOP\n&K       SETA  K'&LIST(&N)-2\n&R       SETC  '&LIST(&N)'(2,&K)\n&D       SETA  4*(&N-1)\n&SYM     ST    &R,&TAG.A+&D            STORE INTO PARM LIST\n&SYM     SETC  ''\n         AIF   (&N NE N'&LIST).STLOOP\n         OI    &TAG.A+&D,X'80'         SET END-OF-LIST BIT\n.STDONE  ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM LIST ADDRESS\n&SYM     SETC  '&TAG.A'\n&N       SETA  0\n.LOOP    ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&LIST).VCON\n         AIF   ('&LIST(&N)'(1,1) NE '(').NOTREG\n&SYM     DC    A(0)\n&SYM     SETC  ''\n         AGO   .LOOP\n.NOTREG  AIF   (&N EQ N'&LIST).LAST\n&SYM     DC    A(&LIST(&N))\n&SYM     SETC  ''\n         AGO   .LOOP\n.LAST    ANOP\n&SYM     DC    X'80'                   END-OF-LIST BIT\n         DC    AL3(&LIST(&N))\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,&IHBPARM\n         MEND\n         MACRO\n&SYMBOL  XPRMOD  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,       X\n               &TIME=0,&DATE=0\n.* MACRO TO EXECUTE A MODIFY CALL TO 'XPRINTSUB'.\n&SYMBOL  XPROPEN  &WA,MAXLINE=&MAXLINE,PAGENO=&PAGENO,PAGEWID=&PAGEWID,X\n               PAGELEN=&PAGELEN,TIME=&TIME,DATE=&DATE,IHBPARM=104\n         MEND\n         MACRO\n&SYMBOL  XPRNTLIN  &WA,&TEXT=00,&LENGTH=132,&OFFSET=0,&SPB=0,&SPA=1\n         LCLA  &N\n         LCLC  &B3,&B6,&B7,&T,&R\n         ACTR  25\n&T       SETC  'IHB&SYSNDX'\n&B3      SETC  '0'\n&B6      SETC  '0'\n&B7      SETC  '0'\n.* PROCESS OPTIONS IN SPA OPERAND:\n.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1\n         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2\n&B3      SETC  '1'\n         AGO   .TSTB1\n.TSTA2   MNOTE 4,'OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'\n.* PROCESS OPTIONS IN SPB OPERAND:\n.TSTB1   ANOP\n&N       SETA  2\n.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2\n&B7      SETC  '1'\n         AGO   .TSTB4\n.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3\n&B6      SETC  '1'\n         AGO   .TSTB4\n.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4\n         MNOTE 4,'OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'\n.TSTB4   ANOP\n&N       SETA  &N+1\n         AIF   (&N LE 3).TSTB5\n.* GENERATE STORE INSTRUCTIONS IF REGISTER NOTATION IS USED:\n         CNOP  0,4\n         AIF   ('&SYMBOL' EQ '').IFR1\n&SYMBOL  DS    0H\n.IFR1    AIF   ('&TEXT' NE '00').TXTOK\n         MNOTE 4,'TEXT ADDRESS MUST BE SUPPLIED'\n.TXTOK   AIF   ('&TEXT'(1,1) NE '(').IFR2\n         ST    &TEXT(1),&T.A           STORE TEXT ADDRESS\n         MVI   &T.A,B'000&B3.00&B6&B7' INSERT OPTION BITS\n.IFR2    AIF   ('&LENGTH'(1,1) NE '(').IFR3\n         STC   &LENGTH(1),&T.A+4       STORE TEXT LENGTH\n.IFR3    AIF   ('&OFFSET'(1,1) NE '(').IFR4\n         STC   &OFFSET(1),&T.A+5       STORE MARGIN OFFSET\n.IFR4    AIF   ('&SPB(1)'(1,1) NE '(').IFR5\n&N       SETA  K'&SPB(1)-2\n&R       SETC  '&SPB(1)'(2,&N)\n         STC   &R,&T.A+6               STORE PRE-SPACING\n.IFR5    AIF   ('&SPA(1)'(1,1) NE '(').LOAD1\n&N       SETA  K'&SPA(1)-2\n&R       SETC  '&SPA(1)'(2,&N)\n         STC   &R,&T.A+7               STORE POST-SPACING\n.* LOAD REG 1 AND GENERATE PLD LIST ADDRESS:\n.LOAD1   BAL   1,&T.L                  LOAD PARM ADDRESS\n         DC    X'80'                   MARK END OF ADDRESS LIST\n         DC    AL3(&T.A)               ADDRESS OF PLD\n.* GENREATE PLD PARAMETERS TO DESCRIBE THE PRINT LINE:\n.IFR11   AIF   ('&TEXT'(1,1) NE '(').NOTR11\n&T.A     DC    A(0)                    TEXT ADDRESS & OPTION BITS\n         AGO   .IFR12\n.NOTR11  ANOP\n&T.A     DC    B'000&B3.00&B6&B7'      OPTION BITS\n         DC    AL3(&TEXT)              TEXT ADDRESS\n.IFR12   AIF   ('&LENGTH'(1,1) NE '(').NOTR12\n         DC    AL1(0)                  TEXT LENGTH\n         AGO   .IFR13\n.NOTR12  DC    AL1(&LENGTH)            TEXT LENGTH\n.IFR13   AIF   ('&OFFSET'(1,1) NE '(').NOTR13\n         DC    AL1(0)                  MARGIN OFFSET\n         AGO   .IFR14\n.NOTR13  DC    AL1(&OFFSET)            MARGIN OFFSET\n.IFR14   AIF   ('&SPB(1)'(1,1) NE '(').NOTR14\n         DC    AL1(0)                  PRE-SPACING\n         AGO   .IFR15\n.NOTR14  AIF   ('&SPB(1)' EQ 'EJECT').BSKIP\n         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP\n         DC    AL1(&SPB(1))            PRE-SPACING\n         AGO   .IFR15\n.BSKIP   DC    AL1(255)                SKIP BEFOR PRINTING\n.IFR15   AIF   ('&SPA(1)'(1,1) NE '(').NOTR15\n         DC    AL1(0)                  POST-SPACING\n         AGO   .VCON\n.NOTR15  AIF   ('&SPA(1)' EQ 'EJECT').ASKIP\n         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP\n         DC    AL1(&SPA(1))            POST-SPACING\n         AGO   .VCON\n.ASKIP   DC    AL1(255)                SKIP AFTER PRINTING\n.VCON    ANOP\n&T.L    XPRINNRA  &WA,32\n         MEND\n         MACRO\n&SYMBOL  XPROPEN  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,      X\n               &TIME=0,&DATE=0,&DDNAME=SYSPRINT,&IHBPARM=56\n.* MACRO TO EXECUTE AN 'OPEN' OR 'MODIFY' CALL TO 'XPRNTSUB'.\n         LCLC  &TAG\n&TAG     SETC  'IHB&SYSNDX'\n         AIF   ('&SYMBOL' EQ '').T1\n&SYMBOL  DS    0H\n.T1      AIF   ('&MAXLINE'(1,1) NE '(').T2\n         ST    &MAXLINE(1),&TAG.A      STORE IN PARM LIST\n.T2      AIF   ('&PAGENO'(1,1) NE '(').T3\n         STH   &PAGENO(1),&TAG.A+4     STORE IN PARM LIST\n.T3      AIF   ('&PAGEWID'(1,1) NE '(').T4\n         STC   &PAGEWID(1),&TAG.A+6    STORE IN PARM LIST\n.T4      AIF   ('&PAGELEN'(1,1) NE '(').T5\n         STC   &PAGELEN(1),&TAG.A+7    STORE IN PARM LIST\n.T5      AIF   ('&TIME'(1,1) NE '(').T6\n         ST    &TIME(1),&TAG.A+8       STORE IN PARM LIST\n.T6      AIF   ('&DATE'(1,1) NE '(').T7\n         ST    &DATE(1),&TAG.A+12      STORE IN PARM LIST\n.T7      AIF   ('&DDNAME'(1,1) NE '(').CNOP\n         MVC   &TAG.A+16(8),0(&DDNAME(1))  STORE IN PARM LIST\n.CNOP    CNOP  0,4\n         BAL   1,&TAG.L        LOAD PARM LIST ADDRESS\n.P1      AIF   ('&MAXLINE'(1,1) EQ '(').PR1\n&TAG.A   DC    A(&MAXLINE)             PRINT OUTPUT LIMIT\n         AGO   .P2\n.PR1     ANOP\n&TAG.A   DC    A(0)                    PRINT OUTPUT LIMIT\n.P2      AIF   ('&PAGENO'(1,1) EQ '(').PR2\n         DC    AL2(&PAGENO)            PAGE NUMBER\n         AGO   .P3\n.PR2     DC    AL2(0)                  PAGE NUMBER\n.P3      AIF   ('&PAGEWID'(1,1) EQ '(').PR3\n         DC    AL1(&PAGEWID)           PAGE WIDTH\n         AGO   .P4\n.PR3     DC    AL1(0)                  PAGE WIDTH\n.P4      AIF   ('&PAGELEN'(1,1) EQ '(').PR4\n         DC    AL1(&PAGELEN)           PAGE LENGTH\n         AGO   .P5\n.PR4     DC    AL1(0)                  PAGE LENGTH\n.P5      AIF   ('&TIME'(1,1) EQ '(').PR5\n         DC    A(&TIME)                ADDRESS OF TIME\n         AGO   .P6\n.PR5     DC    A(0)                    ADDRESS OF TIME\n.P6      AIF   ('&DATE'(1,1) EQ '(').PR6\n         DC    A(&DATE)                ADDRESS OF DATE\n         AGO   .P7\n.PR6     DC    A(0)                    ADDRESS OF DATE\n.P7      AIF   ('&IHBPARM' NE '56').VCON\n         AIF   ('&DDNAME'(1,1) EQ '(').PR7\n         DC    CL8'&DDNAME'            DDNAME FOR DATA SET\n         AGO   .VCON\n.PR7     DC    CL8' '                  DDNAME FOR DATA SET\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,&IHBPARM\n         MEND\n         MACRO\n&SYMBOL  XPRSPACE  &WA,&LINES=1,&COND=\n.* MACRO TO EXECUTE A SPACE CALL TO 'XPRNTSUB'.\n         LCLA  &N,&B6,&B7\n         LCLC  &TAG,&SYM\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n.LOOP    ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&COND).LDONE\n.TST1    AIF   ('&COND(&N)' NE 'NOEJ').TST2\n&B6      SETA  1\n         AGO   .LOOP\n.TST2    AIF   ('&COND(&N)' NE 'ATHOF').TST3\n&B7      SETA  1\n         AGO   .LOOP\n.TST3    MNOTE 4,'OPERAND &COND(&N) AFTER KEYWORD COND IS ILLEGAL'\n         AGO   .LOOP\n.LDONE   CNOP  2,4\n         AIF   ('&LINES'(1,1) NE '(').NOTREG1\n&SYM     STC   &LINES(1),&TAG.A+1      STORE INTO PARM LIST\n&SYM     SETC  ''\n.NOTREG1 ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM LIST ADDRESS\n&TAG.A   DC    B'000000&B6&B7'         OPTION BITS\n         AIF   ('&LINES'(1,1) NE '(').NOTREG2\n         DC    X'00'                   SPACING AMOUNT\n         AGO   .VCON\n.NOTREG2 DC    AL1(&LINES)             SPACING AMOUNT\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,44\n         MEND\n         SPACE\n         EJECT\n* FUNCTION/OPERATION:  READS AND EDITS THE VOLUME TABLE OF CONTENTS\n*        (VTOC) FROM ONE OR MORE DIRECT ACCESS VOLUMES AND PRINTS\n*        INFORMATION ABOUT THE DATA SETS ON IT AND A TRACK USAGE MAP.\n*        OPTIONALLY, IT LISTS THE DIRECTORY OF EACH PARTITIONED DATA\n*        SET ON THE VOLUME.\n         SPACE\n* ENTRY POINTS:  ENTER AT 'GENESIS' WITH A BALR 14,15 AND REGISTER 13\n*        SET TO A STANDARD SAVE AREA.  REGISTER 1 POINTS TO A FULL WORD\n*        WHICH POINTS TO A PARAMETER FIELD.\n         SPACE\n* INPUT:  THE PARAMETER FIELD REFERENCED BY R1 BEGINS WITH A HALF-WORD\n*        CONTAINING THE BINARY LENGTH OF THE BYTE STRING WHICH FOLLOWS\n*        IT.  THE STRING CONSISTS OF A SERIES OF PARAMETER WORDS\n*        SEPARATED BY COMMAS.  LEGAL WORDS ARE:\n*              DUMP    CAUSES THE DSCB'S TO BE LISTED IN HEX FOLLOWING\n*                      THEIR FORMATTED LISTINGS.\n*              PDS     CAUSES THE DIRECTORY OF EACH PDS TO BE LISTED.\n*              MAP     CAUSES THE TRACK USAGE MAP TO BE PRINTED.\n         SPACE\n* OUTPUT:  A PRINTED LISTING DESCRIBING THE DATA SETS AND TRACK USAGE\n*        FOR EACH VOLUME.\n         SPACE\n* DATA SETS:  PRINTED OUTPUT IS DELIVERED TO A DATA SET DESCRIBED ON A\n*        DD CARD WITH DDNAME 'SYSPRINT'.  EACH VOLUME TO BE LISTED MUST\n*        HAVE A DD CARD WITH THE DDNAME \"VOL.....\", WHERE ONLY THE\n*        FIRST THREE CHARACTERS ARE TESTED.  THE DD CARDS ARE\n*        REQUIRED TO SPECIFY ONLY THE VOLUME SERIAL, UNIT, AND\n*        A DISPOSITION OF 'OLD'.\n         SPACE\n* EXTERNAL ROUTINES:  CALLS 'XDATEDIT' TO FORMAT DATES.\n*        CALLS 'XVTCREAD' TO READ VTOC FROM DIRECT-ACCESS DEVICES.\n*        CALLS 'XPRNTSUB' TO DO PRINTING AND PAGINATION.\n         SPACE\n* EXITS-NORMAL:  RETURNS VIA REG 14 WITH RETURN CODE 0.\n         SPACE\n* EXITS-ERROR:  RETURNS VIA REG 14 WITH RETURN CODES AS FOLLOWS:\n*        4 - MISSING DD CARD;\n*        8 - BAD FORMAT IN A DSCB;\n*        12 - PERMANENT I/O ERROR IN A VTOC OR PDS DIRECTORY;\n*        20 - UNABLE TO OPEN 'SYSPRINT' DATA SET.\n         SPACE\n* TABLES/WORK AREAS:  USES SYSTEM MACROS 'IEFJFCBN' AND 'IECSDSL1' TO\n*        DEFINE A JOB FILE CONTROL BLOCK AND VARIOUS DATA SET CONTROL\n*        BLOCK FORMATS.  USES MACRO 'IEFTIOT1' TO DEFINE TASK IO TABLE.\n         SPACE\n* ATTRIBUTES:  SERIALLY REUSABLE.\n         SPACE\n* MACHINE REQUIREMENTS:  USES A PRINTER WITH 132-CHARACTER PRINT LINE\n*        AND A 60-CHARACTER PRINT TRAIN (PN OR QN ARRANGEMENT).  USES\n*        ONLY THE STANDARD INSTRUCTION SET, EXCEPT FOR A FEW 'EDIT'\n*        INSTRUCTIONS.  CORE REQUIREMENT VARIES WITH THE SIZE OF THE\n*        VTOC BEING LISTED.  A 160-BLOCK VTOC REQUIRES ABOUT 30K.\n         SPACE\n* NOTES:  THE INPUT PARAMETER LIST STRUCTURE IS THAT USED TO PASS\n*        INFORMATION FROM THE 'PARM' FIELD OF AN 'EXEC' CARD.\n         SPACE\n*        HAS BEEN TESTED WITH 2301, 2311, 2314, AND 2321.  NO TROUBLE\n*        ANTICIPATED WITH 2303.  DON'T KNOW ABOUT 2302.\n         SPACE\n*        CURRENTLY IGNORES FORMAT 2 DSCB'S FOR ISAM AND\n*        FORMAT 6 DSCB'S FOR SPLIT-CYLINDER ALLOCATION.\n         SPACE 3                                                     HM\n*        *****  USC MODIFICATIONS BY H. MARIN  --  AUG. 27,1972  ****HM\n*                                                                    HM\n*        VTOCLIST WILL NOW HANDLE 3330 AND 2305-2 VOLUMES.           HM\n*        THESE MODIFICATIONS HAVE BEEN TESTED AND OPERATE CORRECTLY. HM\n*       3330 MOD 11 SUPPORT UNDER BOTH MVT AND MVS ALSO ADDED. 4/75  HM\n*       THE  MOD 11 SUPPORT UNDER MVT IS BASED ON SIZE OF VOLUME...  HM\n*                                                                    HM\n*        ALL MACROS REQUIRED ARE PROVIDED EXCEPT FOR THE THREE IBM   HM\n*        MACROS:                                                     HM\n*               IEFTIOT1                                             HM\n*               IEFJFCBN                                             HM\n*               IECSDSL1                                             HM\n*                                                                    HM\n*        THESE MACROS ARE RELEASE DEPENDENT AND ARE PROVIDED IN FILE HM\n*        SYS1.PVTMACS OF THE DLIB VOLUMES FOR GENERATING A SYSTEM.   HM\n*        THEREFORE, TO ASSEMBLE THIS PROGRAM, IN PARTICULAR CSECT    HM\n*        VTOCLIST, ONE MUST CONCATENATE BOTH MACLIB AND PVTMACS UNDERHM\n*        THE SYSLIB DDNAME OF THE ASSEMBLY STEP.                     HM\n* ----   MVS NOTE:  THESE MACROS ARE FOUND IN SYS1.AMODGEN FOR MVS.  HM\n*                                                                    HM\n* -------- 3330-11 SUPPORT ADDED OCTOBER,1974 BY HECTOR MARIN (UCB)  HM\n*          -------                                                   HM\n*                                                                    SA\n*        *****  TRW MODIFICATIONS BY S. ANDERSON -- APRIL 1976       SA\n*                                                                    SA\n*        IF THE PDS OPTION HAS BEEN SELECTED AND THE DATASET HAS     SA\n*        READ PROTECTION, NO ATTEMPT WILL BE MADE TO LIST THE        SA\n*        DIRECTORY FOR THAT DATASET.                                 SA\n*                                                                    SA\n*                                                                    SA\n*        *****  3350  SUPPORT  ADDED  MAY 5,1977  BY  W. BRICENO  *  WB\n*        *****  THIS  BECOMES  VERSION  3.2  OF  VTOCLIST         *  WB\n*                                                                    WB\n*        *****  TRW MODIFICATIONS BY S. ANDERSON -- APRIL 1979       SA\n*                                                                    SA\n*        SUPPORT ADDED FOR SU 60 LAST REFERENCE DATE. THE LAST       SA\n*        REFERENCE DATE REPLACES SERIAL AND SEQ FIELDS.              SA\n*        ******  TRW MODIFICATIONS BY M. SIMS -- APRIL 16,1979       MS\n*        EXIT LIST ADDED TO TRAP PDS OPEN ERRORS AND TELL USER       MS\n*        ABOUT IT WITHOUT ABENDING THE JOB. ALSO LINKED AS AC(1)     MS\n*        TO STOP ENQ LOCKOUTS CAUSED BY THE OPEN TYPE=J LOGIC.       MS\n*\n*        VERSION 4.0 - CHRIS THOMAS - UCLA/OAC - MODS FOR DFDS       MS\n*        (3380 AND INDEXED VTOC SUPPORT)  5/28/81                    MS\n*\n*\n***********************************************************************\n         EJECT\nVTOCLIST CSECT\n         SPACE 2\n* REGISTER ASSIGNMENTS:\n         SPACE\nR0       EQU   0\nR1       EQU   1\nRPARM    EQU   1\nR2       EQU   2\nRWK1     EQU   2\nR3       EQU   3\nRWK2     EQU   3\nRWK3     EQU   4\nRWK4     EQU   5\nR7       EQU   7\nRPDS     EQU   8\nRLCLBASE EQU   8   BASE FOR CLOSED REG-TRANSPARENT SUBROUTINES\nR8       EQU   8   BASE FOR CLOSED REG-TRANSPARENT SUBROUTINES\nRDS1     EQU   9\nRDS4     EQU   9\nRMB      EQU   9\nRDS3     EQU   10\nRDS5     EQU   10\nRDCB     EQU   10\nRBASE1   EQU   11\nRBASE2   EQU   12\nR12      EQU   12\nRSAVE    EQU   13\nRRET     EQU   14\nR15      EQU   15\nRGO      EQU   15\n         EJECT\n* PARAMETERS AND ASSIGNS:\n         SPACE\nGETSIZE  EQU   2048            BLOCK SIZE FOR GETMAIN REQUESTS\nPGLENGTH EQU   57              LINES PER PAGE        **TRW**\nTOPMARGN EQU   3               LINES TO SKIP BEFORE PAGE HEADING\nALIASMSK EQU   X'80'           PDS DIRECTORY ENTRY IS AN ALIAS\n         SPACE\nDADEVICE EQU   X'20'           CLASS FOR DIRECT ACCESS DEVICES\nDEV2301  EQU   X'02'           UNIT TYPE FOR 2301 DRUM\nDEV2302  EQU   X'04'           UNIT TYPE FOR 2302 DISK FILE\nDEV2303  EQU   X'03'           UNIT TYPE FOR 2303 DRUM\nDEV2311  EQU   X'01'           UNIT TYPE FOR 2311 DISK PACK\nDEV2314  EQU   X'08'           UNIT TYPE FOR 2314 DISK PACK\nDEV2321  EQU   X'05'           UNIT TYPE FOR 2321 DATA CELL\nDEV23051 EQU   X'06'           UNIT TYPE FOR 2305-1 DRUM\nDEV23052 EQU   X'07'           UNIT TYPE FOR 2305-2 DRUM\nDEV3330  EQU   X'09'           UNIT TYPE FOR 3330 DISK PACK\nDEV33301 EQU   X'0D'          UNIT TYPE FOR 3330 MOD 11-DISK PACK   HM\nDEV3350  EQU   X'0B'          UNIT TYPE FOR 3350 NATIVE DISK PACK   WB\nDEV3375  EQU   X'0C'          UNIT TYPE FOR 3375                   CST\nDEV3380  EQU   X'0E'          UNIT TYPE FOR 3380                   CST\n         SPACE\n*        BIT MEANINGS FOR MODESW  --  OPTIONS SWITCH\nDUMPMASK EQU   X'01'           OPTION TO DUMP DSCB'S IN HEX\nPDSLMASK EQU   X'02'           OPTION TO LIST PDS DIRECTORIES\nNODSMASK EQU   X'04'      OPTION TO PREVENT DATA SET LIST\nMAPMASK  EQU   X'08'           OPTION TO LIST TRACK USAGE\nNOHDMASK EQU   X'10'      OPTION TO PREVENT HEADING\nDS1MASK  EQU   X'20'   OPTION TO LIST ONE DATA SET ONLY\nMEOMASK  EQU   X'40'    OPTION TO LIST ONLY MAP ERRORS IF MAPPING\nNOMMASK  EQU   X'80'          PDS DIRECTORY STATS ONLY\n         SPACE\n*        BIT MEANINGS FOR MODESW1 --  OPTIONS SWITCH NUMBER 2\nDSORGMSK EQU   X'80'   SWITCH FOR DSORG\n         SPACE\nISDSORG  EQU   X'80'           INDEXED SEQUENTIAL ORGANIZATION\nPSDSORG  EQU   X'40'           PHYSICAL SEQUENTIAL ORGANIZATION\nDADSORG  EQU   X'20'           DIRECT-ACCESS ORGANIZATION\nPODSORG  EQU   X'02'           PARTITIONED ORGANIZATION\n         SPACE\nPRSP0    EQU   X'00'           PSEUDO CONTROL CHARACTERS FOR PRINTER\nPRSP1    EQU   X'01'\nPRSP2    EQU   X'02'\nPRSP3    EQU   X'03'\n         SPACE\nOPENBIT  EQU   X'10'           DCB IS OPEN (IN 'DCBOFLGS')\n         EJECT\n*************************\n* ENTRANCE AND PROLOGUE *\n*************************\n         SPACE\n* ENTER HERE TO PERFORM STANDARD SAVE OPERATIONS AND ESTABLISH TWO BASE\n* REGISTERS WITH A CONTINUOUS RANGE OF 8K BYTES.\n         SPACE\nGENESIS  SAVE  (14,12),,VTOCLIST-03008219\n         SPACE\n         LR    RBASE1,R15              SET UP BASE REGISTER\n         USING GENESIS,RBASE1,RBASE2\n         LA    RBASE2,4095(RBASE1)     LOAD SECOND BASE 4096 BYTES\n         LA    RBASE2,1(RBASE2)          HIGHER\n         SPACE\n         LR    RWK1,RSAVE\n         LA    RSAVE,SAVEAREA          LOCAL SAVE AREA, 18 WORDS\n         ST    RWK1,SAVEAREA+4         FORWARD CHAIN\n         ST    RSAVE,8(RWK1)           BACKWARD CHAIN\n         SPACE\n         SR    R1,R1                   GENERATE ZERO PROGRAM MASK\n         SPM   R1                      MASK OVERFLOW INTERRUPTS\n         SPACE 3\n* CALL PRINTING SUBROUTINE TO OPEN THE SYSPRINT DATA SET.  SET INITIAL\n* PAGE DIMENSIONS AND HEADING, AND SKIP TO HEAD OF FORM.\n         SPACE\n         XPROPEN  PWA,PAGELEN=PGLENGTH,DDNAME=SYSPRINT\n         LTR   R15,R15                 TEST FOR SUCCESSFUL OPEN\n         BNZ   PROPBAD                 ERROR IF UNABLE TO PRINT\n         SPACE\n         XPRHEAD  PWA,LIST=INITHEAD\n         SPACE\n         XPRNTLIN  PWA,TEXT=REVMSG,LENGTH=L'REVMSG,SPB=SKIP,           X\n               SPA=3,OFFSET=9\n         SPACE 3\n* INITIALIZE OTHER MISCELLANEOUS THINGS.\n         SPACE\n         SR    R0,R0                   GENERATE USEFUL ZERO\n         ST    R0,RETCODE              ZERO RETURN CODE REGISTER\n         STC   R0,MODESW               LISTING OPTION SWITCH\n         SPACE\n* LOCATE THE TIOT AND SAVE THE JOB NAME.\n         SPACE\n         EXTRACT  TIOTLOC,FIELDS=TIOT  OBTAIN TIOT ADDRESS FROM TCB\n         SPACE\n         L     R1,TIOTLOC\n         USING TIOT1,R1\n         MVC   JOBNAME(8),TIOCNJOB     SAVE JOB ANME\n         LA    R1,TIOENTRY             LOAD ADDR OF FIRST TABLE ENTRY\n         DROP  R1\n         ST    R1,TIOTLOC              SAVE TIOT ENTRY ADDRESS\n         EJECT\n******************************\n* INPUT PARAMETER PROCESSING *\n******************************\n         SPACE\n* RETRIEVE AND PRINT THE PARAMETER FIELD.  SCAN IT FOR WORDS AND SET\n* LISTING MODE SWITCHES AND VOLUME COUNT ACCORDINGLY.\n         SPACE 2\nPARMGET  L     R1,SAVEAREA+4           SAVE AREA WHERE R1 STORED\n         L     R1,24(R1)               R1 WHICH WAS PASSED TO US\n         L     RWK1,0(R1)              ADDRESS OF PARM FIELD\n         LH    RWK2,0(RWK1)            LENGTH OF PARM FIELD\n         LA    RWK1,2(RWK1)            SET RWK1 TO FIRST BYTE\n         SPACE\n* PRINT FIELD, OR COMPLAIN IF IT IS TOO LONG.\n         SPACE\n         MVC   PL+10(21),=C'EXEC PARAMETER FIELD:'\n         CH    RWK2,=H'99'             TEST FIELD LENGTH\n         BL    PLNGOK\n         MVC   PL+30(29),=C'  IS TOO LONG AND WAS IGNORED'\n         SR    RWK2,RWK2               SET LENGTH TO 0\n         B     PARMPR\n         SPACE\nPLNGOK   LTR   R1,RWK2                 FIX UP LENGTH FOR MOVE\n         BZ    PARMPR                  SKIP MOVE IF LENGTH ZERO\n         BCTR  R1,0                    SUBTRACT 1 FOR MVC\n         STC   R1,PARMOVE+1\nPARMOVE  MVC   PL+33(0),0(RWK1)        MOVE PARM FIELD TO PRINT LINE\nPARMPR   MVI   PL,PRSP3                PRINT AND SPACE 3\n         BAL   RRET,PRINTSUB\n         SPACE\n* LOOP TO GET PARAMETER WORDS AND SET SWITCHES.\n         SPACE\nPARMLOOP BAL   RRET,SCAN               GET A WORD\n         CLI   SCANWORD,C' '           BLANK WORD MEANS END OF STRING\n         BE    PARMDONE\n         SPACE\nPVOLS    CLC   SCANWORD(4),=C'VOLS'    FOR COMPATIBILITY WITH OLDER\n         BE    PARMLOOP                   VERSIONS\n         SPACE\nPDUMP    CLC   SCANWORD(5),=C'DUMP '\n         BNE   PPDS\n         OI    MODESW,DUMPMASK\n         B     PARMLOOP\n         SPACE\nPPDS     CLC   SCANWORD(4),=C'PDS '\n         BNE   PMAP\n         OI    MODESW,PDSLMASK\n         NI    MODESW,255-NOMMASK  OVERRIDE NOM IF PDS SPECIFIED LATER\n         B     PARMLOOP\n         SPACE\nPMAP     CLC   SCANWORD(4),=C'MAP '\n         BNE   PDIR\n         OI    MODESW,MAPMASK\n         B     PARMLOOP\n         SPACE\nPDIR     CLC   SCANWORD(4),=C'NOM '\n         BNE   PNODS\n         OI    MODESW,PDSLMASK+NOMMASK\n         B     PARMLOOP\n         SPACE\nPNODS    CLC   SCANWORD(5),=C'NODS '\n         BNE   PNOHDNG\n         OI    MODESW,NODSMASK\n         B     PARMLOOP\n         SPACE\nPNOHDNG  CLC   SCANWORD(7),=C'NOHDNG '\n         BNE   P1DSONLY\n         OI    MODESW,NOHDMASK\n         B     PARMLOOP\n         SPACE 2\nP1DSONLY CLC   SCANWORD(3),=C'DS '\n         BNE   PMEONLY\n         OI    MODESW,DS1MASK+NOHDMASK+PDSLMASK+NOMMASK\n         B     PARMLOOP\n         SPACE 2\nPMEONLY  CLC   SCANWORD(4),=C'MEO '\n         BNE   PDSORGF\n         OI    MODESW,MEOMASK+MAPMASK\n         B     PARMLOOP\n         SPACE 2\nPDSORGF  CLC   SCANWORD(5),=C'DSORG='  CHECK FOR KEYWORD\n         BNE   BADPARM\n         OI    MODESW1,DSORGMSK   INDICATE FILTER IN EFFECT\n         L     R1,DSORGTBA   GET DSORG ENTRIES TABLE\n         LA    RRET,DSORGEND   GET NUMBER OF ENTRIES\nLOOPDPRM CLC   SCANWORD+6(2),0(R1)\n         BNE   *+14   NOT A MATCH YET\n         OC    DSORGSW,2(R1)   INDICATE THIS IS WANTED\n         B     PARMLOOP   GO GET NEXT GUY\n         LA    R1,3(,R1)   BUMP TO NEXT ENTRY\n         BCT   RRET,LOOPDPRM   GET NEXT\n*   OTHERS MAY BE ADDED\n         NI    MODESW1,255-DSORGMSK  NEVER MIND-- PARM ERROR\n         SPACE 4\n* PRINT ERROR MESSAGE FOR UNRECOGNIZED PARAMETERS.\n         SPACE\nBADPARM  MVC   PL+10(50),=C'\"        \" IS AN ILLEGAL PARAMETER AND WAS X\n               IGNORED'\n         MVC   PL+11(8),SCANWORD\n         MVI   PL,PRSP3\n         BAL   RRET,PRINTSUB\n         B     PARMLOOP\n         SPACE\n* ALL PARAMETERS HAVE BEEN PROCESSED.  LOAD TIOT POINTER TO PROCESS\n* FIRST VOLUME.\n         SPACE 3\n         SPACE\nPARMDONE DS    0H\n         L     RWK1,TIOTLOC            LOAD TIOT ADDRESS\n         B     VOLJOIN\n         EJECT\n**********************\n* BEGIN A NEW VOLUME *\n**********************\n         SPACE\n* SEARCH TIOT FOR \"VOL.....\" DDNAME.\n         SPACE\nNEWVOL   DS    0H\n         L     RWK1,TIOTLOC            LOAD TIOT ADDRESS\n         USING TIOENTRY,RWK1\n         SR    R1,R1\n         IC    R1,TIOELNGH             GET LENGTH OF CURRENT ENTRY\n         AR    RWK1,R1                 ADVANCE TO NEXT ENTRY\n         ST    RWK1,TIOTLOC            SAVE UPDATED TIOT ADDRESS\nVOLJOIN  CLI   TIOELNGH,X'00'          TEST IF ZERO-LENGTH ENTRY\n         BE    EXODUS                  END OF VOLUMES IF SO\n         CLC   TIOEDDNM(3),=C'VOL'     TEST IF \"VOL.....\" DDNAME\n         BNE   NEWVOL                  SKIP ENTRY IF NOT\n         MVC   DDNAME(8),TIOEDDNM      SAVE DDNAME\n         DROP  RWK1\n         SPACE\n* RESET PAGE NUMBER AND SKIP TO A FRESH PAGE.\n         SPACE\n         XPRMOD  PWA,PAGENO=1          RESET PAGE NUMBER TO 1\n         SPACE\n         XPREJECT  PWA                 SKIP TO A FRESH PAGE\n         SPACE\n         XPRHEAD  PWA,LIST=F1HD3       SET PAGE HEADING LINE\n         SPACE\n* RESET VARIOUS POINTERS AND COUNTERS FOR A NEW VOLUME.\n         SPACE\n         LA    R1,LASTFMT1             RESET FORMAT 1 CHAIN POINTER\n         ST    R1,FMT1ADDR\n         SPACE\n         LA    R1,MBBASE               RESET TRACK MAP CHAIN POINTER\n         ST    R1,MBBASE\n         SPACE\n         SR    R0,R0                   GENERATE USEFUL ZERO\n         STH   R0,FREECYLS             ZERO FREE CYLINDER COUNT\n         STH   R0,FREETRKS               AND FREE TRACK COUNT\n         STH   R0,F5EXTNTS               AND FREE EXTENTS COUNT\n         STH   R0,DSCOUNT                AND DATA SET COUNT\n         SPACE\n* INSERT DDNAME IN DCB FOR PDS DIRECTORY READING.\n         SPACE\n         USING IHADCB,RDCB\n         L     RDCB,PDSDCBA             FIX DCB FOR PDS LISTING\n         MVC   DCBDDNAM(8),DDNAME\n         DROP  RDCB\n         SPACE\n* GET DEVICE TYPE AND VERIFY THAT IT IS DIRECT ACCESS.\n         SPACE\n         DEVTYPE  DDNAME,DEVCHAR       GET DEVICE CHARACTERISTICS\n         SPACE\n         LTR   RGO,RGO                 TEST R15 IF DDNAME FOUND\n         BNZ   NODDCARD                ERROR,DDNAME NOT FOUND\n         CLI   DEVCHAR+2,DADEVICE      TEST FOR DIRECT-ACCESS DEVICE\n         BNE   NOTDACC                 ERROR, NOT DIRECT ACCESS DEVICE\n         SPACE\n* LOOK UP DEVICE NUMBER IN TABLE AND SET UP TRACK ADDRESS CONVERSION\n* PARAMETERS.\n         SPACE\n         L     RWK1,=A(DEVNAMES)       ADDRESS TABLE BEGINNING\nDEVNAMLP CLC   UNITTYPE(1),0(RWK1)     TEST FOR MATCH ON DEVICE TYPE\n         BE    DEVNAMF                 BRANCH WHEN FOUND\n         CLI   0(RWK1),0\n         BE    UNKNDEV                 BRANCH IF NOT\n         LA    RWK1,DEVNAMSZ(RWK1)     STEP THROUGH TABLE\n         B     DEVNAMLP\n         SPACE\nDEVNAMF  ST    RWK1,DEVNAMAD           SAVE ADDRESS OF TABLE ENTRY\n         MVC   FC1(12),16(RWK1)        MOVE IN CONVERSION FACTORS\n         SPACE\n* READ JFCB AND EXTRACT VOLUME SERIAL NUMBER.\n         SPACE\n         RDJFCB  (PDSDCB)              READ JOB FILE CONTROL BLOCK\n         SPACE\n         L     R1,JFCBADR              SET UP JFCB BASE REG\n         USING JFDUMMY,R1\n         MVC   VOLUME(6),JFCBVOLS      SAVE VOLUME SERIAL NUMBER\n         L     RRET,DSN1PTR\n         MVC   0(44,RRET),JFCBDSNM   SAVE DS NAME\n         DROP  R1\n         SPACE\n         MVC   F1HSER1(6),VOLUME       PUT VOLUME SERIAL IN HEADING\n         MVC   F1HSER2(6),VOLUME\n         SPACE\n* CALL VTOC READING ROUTINE TO OPEN VTOC.\n         SPACE\n         LA    R0,1                    CALL MODE 1 FOR OPEN\n         LA    R1,DDNAME               ADDRESS OF DDNAME\n         L     RGO,VTOCREAD            ADDRESS OF SUBROUTINE\n         BALR  RRET,RGO                CALL XVTCREAD\n         B     *+4(R15)                BRANCH ON RETURN CODE\n         B     VOPENED                 0, SUCCESS\n         B     CANTOPEN                4, UNABLE TO OPEN\n         B     NOTDACC                 8, NOT DIRECT ACCESS\nVOPENED  DS    0H\n         SPACE\n* MAKE UP A TRACK MAP ENTRY FOR THE VOLUME LABEL ON TRACK 0.\n         SPACE\n         MVC   FB+4(20),TRK0MAP        INSERT DUMMY ENTRY\n         LA    RWK1,FB\n         BAL   RRET,FILEMAP            GO INSERT IN MAP\n         EJECT\n* READ VTOC INTO CORE\n         SPACE\n* READ THE FIRST DSCB, WHICH SHOULD BE TYPE 4, DESCRIBING THE VOLUME\n* AND VTOC CHARACTERISTICS.\n         SPACE\n         USING DS4,RDS4\nREADFMT4 LA    RWK3,DS4SIZE            SIZE OF CORE BLOCK\n         BAL   RRET,GETBLOCK           GET CORE AREA\n         ST    RWK2,FMT4ADDR           SAVE ADDRESS\n         LR    RDS4,RWK2               SET BASE REG FOR FORMAT 4\n         BAL   RRET,READSEQ            READ FIRST BLOCK\n         BAL   RRET,DISASTER           END OF DATA RETURN\n         CLI   DS4IDFMT,X'F4'          CHECK TYPE\n         BNE   FRSTNOT4                ERROR, FIRST BLOCK NOT TYPE 4\n         SPACE\n         SPACE 4                                                     HM\n*********************************************************************HM\n* *** 3330-11 SUPPORT REQUIRES WE HAVE READ THE VTOC BEFORE KNOWING  HM\n* ***         IF WE HAVE A MOD 1 OR A MOD 11. (MVT KLUDGE - CST)    *HM\n*********************************************************************HM\n**       SPACE 3                                                     HM\n**       CLC   DS4DEVSZ(2),=H'815'   IS NO. OF CYLS EQUAL TO 815     HM\n**       BNE   NOTMOD11                                              HM\n**       L     RWK1,DEVNAMAD           VERIFY DEVICE TYPE FROM UCB   HM\n**       CLI   0(RWK1),DEV3330       WAS IT A 3330   (MOD 1...)      HM\n**       BNE   NOTMOD11    NO, THEN DIFFERENT DEV W. SAME NO. OF TRKSHM\n**       LA    RWK1,DEVNAMSZ(,RWK1)   INCREMENT TO SECOND 3330 DEFINIHM\n**       ST    RWK1,DEVNAMAD          AND STORE UPDATED VALUE        HM\n**       MVC   FC1(12),16(RWK1)     ALSO UPDATE DEVICE FACTORS       HM\n**TMOD11 DS    0H                                                    HM\n**       SPACE 1                                                     HM\n*********** END OF THIS SET OF 3330-11 MODS...    *******************HM\n         SPACE 5                                                     HM\n* PUT VTOC EXTENT INTO THE TRACK MAP.\n         SPACE\n         MVC   FB+FBCCHH1(8),DS4VTOCE+2\n         LA    RWK1,DS4VTOCE\n         BAL   RRET,F13CNVT    GET EXTENT SIZE IN R0\n         STH   R0,FB+FBNTRKS\n         STH   R0,VTOCSIZE             SAVE N TRACKS IN VTOC\n         MVC   FB+FBTTREL1(4),RELTT1   PUT TTREL IN TRACK MAP ENTRY\n         MVC   FB+FBEXT(1),DS4VTOCE+1  EXTENT NUMBER\n         MVC   FB+FBNAME(4),=A(VTOCNAME)  INSERT ADDR OF NAME FOR VTOC\n         LA    RWK1,FB\n         BAL   RRET,FILEMAP            PUT ENTRY IN TRACK MAP\n         DROP  RDS4\n         SPACE 3\n* READ FORMAT 5 DSCB'S INTO CORE, CHAINING THEM TOGETHER.  THE FIRST\n* ONE FOLLOWS THE FORMAT 4 BLOCK; THE OTHERS ARE EACH ADDRESSED FROM\n* THE PRECEDING ONE.\n         SPACE\n         USING DS5,RDS5\n         LA    RWK3,DS5SIZE            SIZE OF BLOCK REQUIRED\n         BAL   RRET,GETBLOCK\n         ST    RWK2,FMT5ADDR           SAVE ADDR OF FIRST FMT 5 BLOCK\n         LR    RDS5,RWK2               SET FORMAT 5 BASE REG\n*\n         L     R15,=A(IXSUB1)                                       CST\n         BALR  RRET,R15                CHECK FOR INDEXED VTOC       CST\n         B     DS5JOIN                 INDEXED VTOC. SKIP OBTAINS   CST\n*\n         BAL   RRET,READSEQ            READ FIRST FMT 5 BLOCK\n         BAL   RRET,DISASTER           END FILE NOT EXPECTED HERE\n         B     DS5JOIN\n         SPACE\nDS5LOOP  LA    RWK3,DS5SIZE\n         BAL   RRET,GETBLOCK\n         ST    RWK2,DS5CHAIN           CHAIN FROM CURRENT TO NEW\n         LA    RWK1,DS5PTRDS           ADDR OF DISK ADDRESS\n         LR    RDS5,RWK2               UPDATE BASE REG TO NEW BLOCK\n*\n         CLC   =C'00001',0(RWK1)       LAST FMT5 FROM IX INTERFACE? CST\n         BNE   DS5NOIX                 NO. USE OBTAINS.             CST\n         L     R15,=A(IXSUB2)                                       CST\n         BALR  RRET,R15                CHECK FOR INDEXED VTOC       CST\n         B     DS5JOIN                                              CST\n         EX    0,*                     SUDDENTLY NOT INDEXED...     CST\n*\nDS5NOIX  BAL   RRET,READDIR            READ NEW BLOCK\nDS5JOIN  CLI   DS5FMTID,X'F5'          MUST BE FORMAT 5, OR ELSE.....\n         BNE   BADFMT5                 ERROR, NOT FORMAT 5 BLOCK\n         SPACE\n         BAL   RRET,F5SPANAL           GO ANALYZE FREE SPACE EXTENTS\n         SPACE\n         CLC   DS5PTRDS(5),=5X'00'     IS THERE ANOTHER BLOCK TO FOLLOW\n         BNE   DS5LOOP                 BRANCH IF YES\n         SR    R0,R0                   IF NOT, SET CHAIN OF LAST\n         ST    R0,DS5CHAIN               BLOCK TO ZERO\n         DROP  RDS5\n         SPACE 3\n* READ ALL THE FORMAT 1 DSCB'S AND CHAIN THEM IN COLLATING SEQUENCE BY\n* DATA SET NAME.  IF THERE ARE FORMAT 3 DSCB'S, THEY ARE READ AND\n* CHAINED TO THE FORMAT 1 BLOCK.\n         SPACE\n         USING DS1,RDS1\nF1RDLOOP LA    RWK3,DS1SIZE            LOAD SIZE OF BLOCK REQUIRED\n         BAL   RRET,GETBLOCK\n         LR    RDS1,RWK2               LOAD BASE REG\nF1RDNEXT BAL   RRET,READSEQ            READ NEXT SEQUENTIAL BLOCK\n         B     VTRDDONE                EXIT AT END OF FILE\n         CLI   DS1FMTID,X'F1'          TEST FOR FORMAT 1\n         BNE   F1RDNEXT                IGNORE IF NOT FORMAT 1\n         SPACE\n         LH    R1,DSCOUNT              COUNT DATA SETS\n         LA    R1,1(R1)\n         STH   R1,DSCOUNT\n         SPACE\n         L     RWK1,FMT1ADDR           LOAD BEGINNING OF CHAIN\n         L     RWK2,=A(FMT1ADDR-FM1NXTF1)  LOAD CHAIN HISTORY REG\nF1SORT   CLC   DS1DSNAM(44),FM1DSNAM(RWK1)  SORT INTO SEQUENCE\n         BL    F1THREAD                BRANCH WHEN PLACE IS FOUND\n         LR    RWK2,RWK1               UPDATE HISTORY REG\n         L     RWK1,FM1NXTF1(RWK1)     FOLLOW CHAIN TO NEXT\n         B     F1SORT\n         SPACE\nF1THREAD ST    RWK1,DS1NXTF1           CHAIN TO FOLLOWING BLOCK\n         ST    RDS1,FM1NXTF1(RWK2)     CHAIN FROM PRECEDING BLOCK\n         SR    R0,R0                   ZERO CHAIN TO POSSIBLE FORMAT 3\n         ST    R0,DS1CHAIN               BLOCK\n         CLC   DS1PTRDS,=5X'00'        TEST FOR FORMAT 3 ADDRESS\n         SPACE\n         BE    F1RDLOOP                BRANCH IF NO\n         LA    RWK3,DS3SIZE            LENGTH OF BLOCK FOR FORMAT 3\n         BAL   RRET,GETBLOCK\n         LR    RDS3,RWK2               BASE REG FOR FMT 3\n         USING  DS3,RDS3\n         LA    RWK1,DS1PTRDS           ADDRESS OF DISK ADDRESS\nF3RD     BAL   RRET,READDIR            READ BLOCK\n         CLI   DS3FMTID,X'F3'          TEST FOR FORMAT 3\n         BE    F3GOT                   BRANCH IF FOUND\n         CLC   DS3PTRDS,=5X'00'        IF NOT 3, TRY FOR ANOTHER\n         BE    F1RDLOOP                BRANCH IF NO MORE\n         LA    RWK1,DS3PTRDS           ADDRESS OF DISK ADDRESS\n         B     F3RD                    TRY AGAIN\nF3GOT    ST    RDS3,DS1CHAIN           CHAIN FROM FMT 1 BLOCK\n         B     F1RDLOOP                GO GET NEXT FORMAT 1 BLOCK\n         DROP  RDS1,RDS3\n         SPACE 3\n* VTOC IS COMPLETELY READ.  CLOSE READING SUBROUTINE.\n         SPACE\nVTRDDONE LA    R0,2                    CALL MODE 2 FOR CLOSE\n         L     RGO,VTOCREAD            ADDRESS OF XVTCREAD\n         BALR  RRET,RGO                BRANCH TO ROUTINE\n         EJECT\n* EDIT FIRST LINE FROM FORMAT 4 DSCB, DESCRIBING DEVICE PARAMETERS.\n         SPACE\n         SPACE 2\n         USING DS4,RDS4\n         L     RDS4,FMT4ADDR\n         TM    MODESW,NOHDMASK   SKIP HEADINGS\n         BO    DS5OK\n         SPACE\n         MVC   V1+1(19),=C'DEVICE DESCRIPTION:'\n         SPACE\n         MVC   V1TYPE(5),=C'TYPE='\n         L     RWK1,DEVNAMAD           LOAD ADDRESS OF TABLE FOR DEVICE\n         MVC   V1TYPE+5(15),1(RWK1)    INSERT DEVICE NAME IN PRINT LINE\n         SPACE\n         MVC   V1NOCYL(7),=C'NOCYLS='  NUMBER OF LOGICAL CYLINDERS\n         LA    RWK1,DS4DEVSZ\n         BAL   RRET,BINALF2\n         MVC   V1NOCYL+7(5),BTAALFJ\n         SPACE\n         MVC   V1TRCYL(9),=C'TRKS/CYL='\n         LA    RWK1,DS4DEVSZ+2         TRACKS PER CYLINDER\n         BAL   RRET,BINALF2\n         MVC   V1TRCYL+9(4),BTAALFJ\n         SPACE\n         MVC   V1DEVTK(8),=C'TRKSIZE=' LENGTH OF TRACK\n         LA    RWK1,DS4DEVTK\n         BAL   RRET,BINALF2\n         MVC   V1DEVTK+8(5),BTAALFJ\n         SPACE\n         MVC   V1DEVDT(9),=C'DSCB/TRK='  DSCB'S PER TRACK\n         LA    RWK1,DS4DEVDT\n         BAL   RRET,BINALF1\n         MVC   V1DEVDT+9(3),BTAALFJ\n         SPACE\n         MVC   V1DEVDB(8),=C'PDS/TRK=' PDS DIRECTORY BLOCKS PER TRACK\n         LA    RWK1,DS4DEVDB\n         BAL   RRET,BINALF1\n         MVC   V1DEVDB+8(3),BTAALFJ\n         SPACE\n         MVI   V1,PRSP2                PRINT AND SPACE 2\n         BAL   RRET,PRINTSUB\n         SPACE 3\n* EDIT THE SECOND LINE FROM THE FORMAT 4 DSCB, DESCRIBING THE VTOC\n* DATA SET.\n         SPACE\n         MVC   V2+1(17),=C'VTOC DESCRIPTION:'\n         SPACE\n         MVC   V2DSCBCT(10),=C'NUM DSCBS='  NUMBER OF DSCBS\n         SR    R0,R0\n         IC    R0,DS4DEVDT             INSERT DSCB'S PER TRACK\n         MH    R0,VTOCSIZE             TIMES NUMBER OF VTOC TRACKS\n         BAL   RRET,BINALFR\n         MVC   V2DSCBCT+10(5),BTAALFJ\n         SPACE\n         MVC   V2DSCBAV(12),=C'AVAIL DSCBS='  NUM UNUSED DSCB'S\n         LA    RWK1,DS4DSREC\n         TM    DS4VTOCI,DS4IVTOC       INDEXED VTOC?                CST\n         BNO   *+8                     NO. SKIP.                    CST\n         L     RWK1,=A(IXFRDSCB)       YES. DS4DSREC NOT VALID      CST\n         BAL   RRET,BINALF2\n         MVC   V2DSCBAV+12(5),BTAALFJ\n         SPACE\n         MVC   V2VTEXT(12),=C'VTOC EXTENT='  VTOC TRACK ADDRESSES\n         MVI   V2VTEXT+16,C'.'\n         MVI   V2VTEXT+21,C'-'\n         MVI   V2VTEXT+26,C'.'\n         UNPK  HEXWORK(15),DS4VTOCE+2(8)\n         TR    HEXWORK(15),HEXEDTAB\n         MVC   V2VTEXT+12(4),HEXWORK\n         MVC   V2VTEXT+17(4),HEXWORK+4\n         UNPK  HEXWORK(15),DS4VTOCE+6(8)\n         TR    HEXWORK(15),HEXEDTAB\n         MVC   V2VTEXT+22(4),HEXWORK\n         MVC   V2VTEXT+27(4),HEXWORK+4\n         SPACE\n         MVC   V2NUMALT(7),=C'NUMALT=' NUMBER OF ALTERNATE TRACKS\n         LA    RWK1,DS4NOATK\n         BAL   RRET,BINALF2\n         MVC   V2NUMALT+7(5),BTAALFJ\n         SPACE\n         MVC   V2NXTALT(13),=C'NEXTALT=    .'  ADDRESS OF NEXT ALT TRK\n         UNPK  HEXWORK(15),DS4HCCHH(8)\n         TR    HEXWORK(15),HEXEDTAB\n         MVC   V2NXTALT+8(4),HEXWORK\n         MVC   V2NXTALT+13(4),HEXWORK+4\n         SPACE\n         MVI   V2,PRSP2                PRINT AND SPACE 2\n         BAL   RRET,PRINTSUB\n         SPACE 3\n         SPACE 3\n* IF VTOC IS INDEXED FORMAT, PRINT AVAILABLE VIRS\n         TM    DS4VTOCI,DS4IVTOC       INDEXED FORMAT VTOC?       CST\n         BNO   CKAVAIL                 IF NOT, SKIP               CST\n         L     R1,=A(IXHEAD)           POINT TO IX HEADER LINE    CST\n         MVC   PL+1(IXHEADL),0(R1)     MOVE TO PRINT BUFFER       CST\n         L     R2,=A(IXCT2)            POINT TO #FREE VIRS        CST\n         L     R0,0(,R2)               LOAD #                     CST\n         BAL   RRET,BINALFR            CVT TO CHAR                CST\n         MVC   PL+1+IXHEADL(4),BTAALFJ MOVE TO PRINT BUFFER       CST\n         MVI   V3,PRSP2                SPACE 2                    CST\n         BAL   RRET,PRINTSUB           PRINT LINE                 CST\n* PRINT A LINE SUMMARIZING THE AVAILABLE SPACE DESCRIBED IN FORMAT\n* 5 DSCB'S.\n         SPACE\nCKAVAIL  MVC   V3+1(16),=C'AVAILABLE SPACE:'\n         SPACE\n         LH    R0,FREETRKS             TOTAL NUMBER OF FREE TRACKS\n         BAL   RRET,BINALFR\n         MVC   V3FRTRKS(5),BTAALF+7\n         MVC   V3FRTRKS+6(9),=C'TRACKS IN'\n         SPACE\n         LH    R0,F5EXTNTS             NUMBER OF FREE EXTENTS\n         BAL   RRET,BINALFR\n         MVC   V3FREXTS(4),BTAALF+8\n         MVC   V3FREXTS+5(18),=C'EXTENTS, INCLUDING'\n         SPACE\n         LH    R0,FREECYLS             NUMBER OF FREE FULL CYLINDERS\n         BAL   RRET,BINALFR\n         MVC   V3FRCYLS(4),BTAALF+8\n         MVC   V3FRCYLS+5(15),=C'FULL CYLINDERS.'\n* DISPLAY VTOC INDICATORS IN HEX... (DIRF, BOS, ETC.)\n         SPACE 2\n         LA    RWK2,DS4VTOCI   LOCATION TO BE TRANS'ED\n         LA    RWK3,V3FRCYLS+5+15+3+16   LOCATION FOR HEX VALUE\n         LA    RWK4,4   NUMBER OF BYTES TO EDIT\n         BAL   RRET,DUMPEDIT   GO EDIT FIELD\n         MVC   V3FRCYLS+5+15+3(16),=C'VTOC INDICATORS='\n         MVC   V3FRCYLS+5+15+3+16+2(6),=8C' '  CLEAR GARBAGE AT END\n         SPACE 3\n         MVI   V3,PRSP2                PRINT AND SPACE 2\n         BAL   RRET,PRINTSUB\n         SPACE 3\n* IF BOS CONTAMINATION FLAG IS ON, WARN USER, AND FORCE TRACK MAP LIST.\n         SPACE\n         TM    DS4VTOCI,DS4IVTOC       INDEXED FORMAT VTOC?       CST\n         BO    DS5OK                   IF NOT, CHECK FOR DOS BIT  CST\n         TM    DS4VTOCI,DS4DOSBT       TEST IF BOS BIT IS ON\n         BZ    DS5OK                   BRANCH IF NOT\n         OI    MODESW,MAPMASK          FORCE TRACK MAP LISTING\n         XPRNTLIN  PWA,TEXT=DS5WARN,LENGTH=L'DS5WARN,SPA=2\nDS5OK    DS    0H\n         SPACE 3\n* IF THE DUMP SWITCH IS ON, EDIT THE FORMAT 4 AND 5 BLOCKS IN HEX.\n         SPACE\n         TM    MODESW,DUMPMASK\n         BZ    F5DONE\n         SPACE\n         LR    RWK1,RDS4               ADDRESS OF FORMAT 4 BLOCK\n         LA    RWK2,DS4FDAD              AND ITS DISK ADDRESS\n         BAL   RRET,DUMPDSCB\n         SPACE\n         USING DS5,RDS5\n         L     RDS5,FMT5ADDR           ADDRESS OF FIRST BLOCK\nDUMP5LUP LTR   RDS5,RDS5               TEST FOR END OF CHAIN\n         BZ    DUMP5DON\n         LR    RWK1,RDS5               ADDRESS OF DSCB\n         LA    RWK2,DS5FDAD              AND ITS DISK ADDRESS\n         BAL   RRET,DUMPDSCB           GO TO PRINT IN HEX\n         L     RDS5,DS5CHAIN           FOLLOW CHAIN TO NEXT BLOCK\n         B     DUMP5LUP\n         SPACE\nDUMP5DON XPRSPACE  PWA,LINES=2         SPACE UP TWO LINES\n         SPACE\nF5DONE   DS    0H\n         DROP  RDS4,RDS5\n         SPACE 3\n         EJECT\n*************************\n* FORMAT 1 EDITING LOOP *\n*************************\n         SPACE\n* NOW ALL FORMAT 1 DSCB'S ARE IN CORE WITH THEIR OPTIONAL FORMAT 3\n* BLOCKS ATTACHED.  EDIT ONE LINE FOR EACH, THEN DUMP THE BLOCKS IN\n* HEX IF THE DUMP SWITCH IS ON.\n         SPACE 2\n         USING DS1,RDS1\n         USING DS3,RDS3\nF1EDIT   L     RDS1,=A(FMT1ADDR-FM1NXTF1)  LOAD CHAIN BEGINNING\n*\n*   TEST FOR NO DS LISTING AND SKIP HEADING IF SO.\n         TM    MODESW,NODSMASK   NO DATA SETS ONLY\n         BO    F1EDLOOP     SKIP HEADING...\n         SPACE 2\n*\n         SPACE\n* PRINT SUB-HEADING LINES ON PAGE FOLLOWING FORMAT 4 AND 5 INFO, AND\n* SET UP PRINTING ROUTINE TO PRINT SUB-HEAD ON SUBSEQUENT PAGES.\n         SPACE\n         XPRLIST  PWA,LIST=(F1SA,F1SB) PRINT SUB-HEADING LINES\n         SPACE\n         XPRHEAD  PWA,LIST=(F1HD2,F1SA,F1SB)  SET UP FULL HEADING\n         SPACE 3\n* BEGIN EACH NEW DATA SET HERE:\n         SPACE\nF1EDLOOP L     RDS1,DS1NXTF1           FOLLOW CHAIN TO NEXT BLOCK\n         CLC   DS1DSNAM(44),LASTFMT1   CHECK FOR CHAIN TERMINATOR\n         BE    ENDF1                   BRANCH AT END\n         L     RDS3,DS1CHAIN           LOAD FORMAT 3 ADDRESS\n         SPACE\n         BAL   RRET,F1SPANAL           ANALYZE SPACE OCCUPIED\n         SPACE 3\n********************************************************\n*  TEST FOR NO DATA SET PRINTING.                      *\n********************************************************\n         SPACE\n         TM    MODESW,NODSMASK    NO DATA SET LISTING...\n         BO    F1PDSDON    NO DATA SETS OR PDS'S LISTED\n         TM    MODESW,DS1MASK   RESTRICT TO ONE DATA SET?\n         BZ    PALLDS    NO, REGULAR\n         L     RRET,DSN1PTR\n         CLC   DS1DSNAM,0(RRET)   TEST AGAINST DSN ON JCL\n         BNE   F1PDSDON   NOT CHOSEN D.S.  SKIP\n         SPACE 3\n         SPACE\n* TEST PAGE BALANCE TO BE SURE ALL OUTPUT FOR A DATA SET WILL APPEAR\n* ON THE SAME PAGE.\n         SPACE\nPALLDS   LA    RWK1,1                  AT LEAST 1 LINE ALWAYS NEEDED\n         TM    MODESW,DUMPMASK         TEST FOR DUMP\n         BZ    F1TEST                  BRANCH IF ONLY 1 LINE\n         AH    RWK1,=H'4'              ADD 4 FOR FORMAT 1 BLOCK DUMP\n         LTR   RDS3,RDS3               TEST FOR PRESENCE OF FORMAT 3\n         BZ    F1TEST\n         AH    RWK1,=H'4'              ADD 4 FOR FORMAT 3 BLOCK\nF1TEST   BAL   RRET,PAGECHEK\n         SPACE 3\n* PRINT ONE LINE OF INFORMATION FROM A FORMAT 1 DSCB.\n         SPACE\n         MVC   F1DSNAM(44),DS1DSNAM    DATA SET NAME\n         SPACE\n         CLI   DS1REFD,X'63'           CHECK\n         BNH   XHEX                     FOR\n         TM    DS1REFD+2,X'0F'           NON-JULIAN\n         BNO   XHEX                       FORMAT\n         XC    DECDATE(8),DECDATE      CLEAR DOUBLE WORD\n         MVC   DECDATE+5(3),DS1REFD    MOVE JULIAN DATE\n         LA    R1,DECDATAD             -> DOUBLE WORD\n         L     RGO,VDATEDIT            V(XDATEDIT)\n         BALR  RRET,RGO                FORMAT JULIAN DATE\n         MVC   F1REFD(8),DECDATE       MOVE FORMATED DATE\n         B     XCREDT\nXHEX     LA    RWK1,DS1REFD            SU 60 HEX FORMAT DATE\n         LA    RWK2,F1REFD             -> RECEIVING FIELD\n         BAL   RRET,VTDATED            FORMAT HEX FORMAT DATE\n         SPACE\nXCREDT   LA    RWK1,DS1CREDT           ADDRESS OF CREATION DATE\n         LA    RWK2,F1CREDT\n         BAL   RRET,VTDATED\n         SPACE\n         LA    RWK1,DS1EXPDT           ADDRESS OF EXPIRATION DATE\n         LA    RWK2,F1EXPDT\n         BAL   RRET,VTDATED\n         SPACE\n         LA    RWK1,F1DSORG            ADDR OF DATA SET ORG FIELD\n         TM    MODESW1,DSORGMSK\n         BZ    NODSORG   BYPASS TEST FOR SPECIFIC DSORG\n         MVC   TSTDSORG,DS1DSORG   PREPARE THE FILTER\n         NC    TSTDSORG,DSORGSW   FILTER SET\n         BNZ   NODSORG  SOME KIND OF HIT\n         MVI   PL+1,C' '   CLEAR LINE OF WHAT'S THERE\n         MVC   PL+2(131),PL+1   AND CONTINUE\n         B     F1PDSDON   GO GET NEXT\n         SPACE 5\nTM2BEX   TM    DS1DSORG,0   TM TO BE 'EXECUTED BELOW'\n         SPACE 2\nNODSORG  DS    0H\n         L     R1,DSORGTBA   POINT AT DSORG TABLE\n         LA    RRET,DSORGEND   HOW MANY ENTRIES\nLOOPDSOG IC    R15,2(R1)   GET CODED DSORG\n         EX    R15,TM2BEX   EXECUTE TM FOR DSORG\n         BZ    *+14   NOT THIS TIME\n         MVC   0(2,RWK1),0(R1)   MOVE EBCDIC TYPE\n         B     NOTU  FOUND A MATCH, GET OUT\n         LA    R1,3(,R1)  BUMP TO NEXT ENTRY\n         BCT   RRET,LOOPDSOG   GO FOR MORE\n* NEVER MIND -- IF DROPPING THRU, LEAVE IT BLANK\n         SPACE 3\nNOTU     DS    0H\n         SPACE\n         UNPK  HEXWORK(15),DS1OPTCD(8) OPTION CODE, IN HEX\n         TR    HEXWORK(15),HEXEDTAB\n         MVC   F1OPTCD(2),HEXWORK\n         SPACE\n         LA    RWK1,F1RECFM            ADDR OF RECORD FORMAT FIELD\n         TM    DS1RECFM,X'C0'\n         BZ    RECFMUP                 ZEROS NOT DEFINED\n         MVI   0(RWK1),C'U'\n         BO    RECFMUP                 11 IS FORMAT 'U'\n         TM    DS1RECFM,X'80'          WE NOW KNOW IT'S MIXED\n         MVI   0(RWK1),C'F'            10 IS FORMAT 'F'\n         BO    RECFMUP\n         MVI   0(RWK1),C'V'            01 IS FORMAT 'V'\nRECFMUP  LA    RWK1,1(RWK1)\n         TM    DS1RECFM,X'20'          TEST TRACK OVERFLOW\n         BZ    RECFMB\n         MVI   0(RWK1),C'T'\n         LA    RWK1,1(RWK1)\nRECFMB   TM    DS1RECFM,X'10'          TEST FOR BLOCKED\n         BZ    RECFMS\n         MVI   0(RWK1),C'B'\n         LA    RWK1,1(RWK1)\nRECFMS   TM    DS1RECFM,X'08'          TEST FOR STANDARD BLOCKS\n         BZ    RECFMAM\n         MVI   0(RWK1),C'S'\n         LA    RWK1,1(RWK1)\nRECFMAM  TM    DS1RECFM,X'06'          TEST CONTROL CHAR TYPE\n         BC    11,RECFME               BRANCH IF NOT MIXED\n         TM    DS1RECFM,X'04'\n         MVI   0(RWK1),C'A'\n         BO    RECFME\n         MVI   0(RWK1),C'M'\nRECFME   DS    0H\n         SPACE\n         LA    RWK1,DS1BLKL            BLOCK SIZE\n         BAL   RRET,BINALF2\n         MVC   F1BLKL(5),BTAALF+7\n         SPACE\n         LA    RWK1,DS1LRECL           LOGICAL RECORD LENGTH\n         BAL   RRET,BINALF2\n         MVC   F1LRECL(5),BTAALF+7\n         SPACE\n         LA    RWK1,DS1KEYL            KEY LENGTH\n         BAL   RRET,BINALF1\n         MVC   F1KEYL(3),BTAALF+9\n         SPACE\n         L     R0,F1TRCNT              ALLOCATION SIZE IN TRACKS\n         BAL   RRET,BINALFR\n         MVC   F1TRALOC(5),BTAALF+7\n         SPACE\n         CLC   DS1LSTAR(3),=XL3'00'\n         BE    NONEUSED\n         NC    F1TRCNT(4),F1TRCNT      SEE IF ANY TRACKS ASSIGNED\n         BZ    NONEUSED                NO; THEN NONE CAN BE USED\n         LH    R0,DS1LSTAR             TRACKS ACTUALLY USED\n         AH    R0,=H'1'\n         BAL   RRET,BINALFR\n         MVC   F1TRUSE(5),BTAALF+7\nNONEUSED DS    0H\n         SPACE\n         LA    RWK1,DS1NOEPV           NUMBER OF EXTENTS\n         BAL   RRET,BINALF1\n         MVC   F1NOEPV(2),BTAALF+10\n         SPACE\n         LA    RWK1,DS1SCALO+1         SECONDARY QUANTITY SIZE\n         BAL   RRET,BINALF3\n         MVC   F1SCALO(5),BTAALF+7\n         SPACE\n         TM    DS1SCALO,X'C0'          TYPE OF SPACE ALLOCATION\n         BC    14,NOTCYL               BR IF NOT ONES\n         MVI   F1ALCTYP,C'C'           CYLINDER\n         B     SCALDONE\nNOTCYL   BC    7,NOTABSTR              BR IF NOT ZEROS\n         MVI   F1ALCTYP,C'A'           ABSOLUTE TRACK\n         B     SCALDONE\nNOTABSTR TM    DS1SCALO,X'80'          NOW KNOW IT IS MIXED\n         BO    TRKALO\n         MVI   F1ALCTYP,C'B'           BLOCK\n         B     SCALDONE\nTRKALO   MVI   F1ALCTYP,C'T'           TRACK\nSCALDONE DS    0H\n*  FINAL CHECK FOR CATALOG DATA SETS...\n         CLC   =C'SYSCTLG ',DS1DSNAM  IS IT A SYSTEM CATLOG\n         B     NOTCOOLC   NOT A COOL CAT...  ***BNE CHANGED TO B ***\n*                         CAMLST TTR DOES NOT WORK ON REL 3 OF MVS\n         L     R15,=A(CATLGCK)   ADDRESS OF CATLOG READER\n         BALR  RRET,R15   GO CHECK IT OUT\nNOTCOOLC DS    0H   ALL DONE...\n         SPACE\n* EACH DATA SET LINE IS SINGLE-SPACED, UNLESS FOLLOWED BY A DUMP OR\n* PDS MEMBER LISTING.\n         SPACE\n         MVI   F1A,PRSP1\n         TM    MODESW,DUMPMASK         TEST IF DUMP FOLLOWS\n         BO    F1PRINT2                YES, DOUBLE SPACE\n         TM    MODESW,NOMMASK+PDSLMASK  TEST IF MEMBER LISTING ON\n         BNM   F1PRINT1  BRANCH IF ONLY PDS DIRECTORY\n         TM    DS1DSORG,PODSORG        TEST IF THIS DS PARTITIONED\n         BZ    F1PRINT1                NO, SINGLE SPACE\nF1PRINT2 MVI   F1A,PRSP2               DOUBLE SPACE\nF1PRINT1 BAL   RRET,PRINTSUB           PRINT THE LINE\n         SPACE\n* IF DUMP SWITCH IS SET, EDIT THE DSCB'S IN HEX.\n         SPACE\n         TM    MODESW,DUMPMASK\n         BZ    F1DMPDON                BRANCH IF NO DUMP\n         SPACE\n         LA    RWK1,DS1                DUMP FORMAT 1 DSCB\n         LA    RWK2,DS1FDAD\n         BAL   RRET,DUMPDSCB\n         SPACE\n         LTR   RDS3,RDS3               TEST FOR FORMAT 3 BLOCK\n         BZ    F1DMPDON\n         LA    RWK1,DS3\n         LA    RWK2,DS3FDAD\n         BAL   RRET,DUMPDSCB\n         SPACE\nF1DMPDON DS    0H\n         SPACE\n* IF THE PDS SWITCH IS SET AND THIS IS A PDS, EDIT ITS DIRECTORY.\n         SPACE\n         TM    MODESW,PDSLMASK         TEST IF LISTING CALLED FOR\n         BZ    F1PDSDON\n         TM    DS1DSORG,PODSORG        TEST IF PARTITIONED\n         BZ    F1PDSDON\n         TM    DS1DSIND,X'14'          IS READ PROTECTION ON?\n         BM    F1PDSDON                YES, SKIP LIST\n         LA    RWK1,DS1DSNAM\n         BAL   RRET,PDSLIST            CALL LISTING SUBROUTINE\nF1PDSDON DS    0H\n         B     F1EDLOOP\n         SPACE 3\n* END DATA SET LISTING.  PRINT A LINE GIVING THE NUMBER OF DATA SETS.\n         SPACE\nENDF1    DS    0H\n         TM    MODESW,NOHDMASK   NO HEADING, THEREFORE NO TRAILER\n         BO    MAPEDIT\n         MVC   PL+49(14),=C'<<<<< END VTOC'\n         LH    R0,DSCOUNT\n         BAL   RRET,BINALFR\n         MVC   PL+64(4),BTAALF+8\n         MVC   PL+69(15),=C'DATA SETS >>>>>'\n         SPACE\n         XPRNTLIN  PWA,TEXT=PL+1,LENGTH=132,SPB=1,SPA=0\n         SPACE\n         MVI   PL+1,C' '               BLANK PRINT LINE\n         MVC   PL+2(131),PL+1\n         SPACE 3\n         DROP  RDS1,RDS3\n         EJECT\n**********************\n* TRACK MAP PRINTING *\n**********************\n         SPACE\n* START A FRESH PAGE AND PRINT THE TRACK MAP FROM CORE, ONE LINE\n* PER ENTRY.\n         SPACE 2\n         USING MB,RMB\nMAPEDIT  TM    MODESW,MAPMASK          TEST IF MAP WANTED\n         BZ    ENDVOL                  BRANCH IF NOT\n         SPACE\n         XPREJECT  PWA                 SKIP TO FRESH PAGE\n         SPACE\n         MVC   TMHSER1(6),VOLUME       PUT VOLUME SERIAL IN HEADING\n         MVC   TMHSER2(6),VOLUME\n         XPRHEAD  PWA,LIST=(TMHEAD,TMSA,TMSB)  SET UP HEADING LINES\n         SPACE\n         L     RMB,MBBASE              BEGINNING OF ENTRY CHAIN\n         L     RWK3,=F'-1'             CLEAR HIGHEST TTREL FOUND\n         SR    RWK4,RWK4               CLEAR TRACK COUNTER\n         SPACE\nMAPELOOP CLC   MBCCHH1(4),MBTERM       TEST FOR END OF CHAIN\n         BE    ENDMAPED\n         SPACE\n* CHECK EACH EXTENT FOR POSSIBLE ERRORS.  BEGIN BY SEEING THAT THE\n* HIGHER RELATIVE TRACK NUMBER DOES NOT EXCEED THE NUMBER OF TRACKS IN\n* THE VOLUME, AND THAT THE LOWER TTREL DOES NOT EXCEED THE HIGHER ONE.\n         SPACE\nTESTEX   CLC   MBTTREL2(2),FMAXTT      TEST 2ND FOR MAX\n         BNL   EXINVAL                 EXTENT INVALID IF HIGH\n         CLC   MBTTREL1(2),MBTTREL2    TEST IF LOWER NOT > HIGHER\n         BH    EXINVAL                 INVALID IF SO\n         SPACE\n* TEST THAT LOWER TTREL IS ONE GREATER THAN THE PREVIOUS HIGHEST TTREL.\n         SPACE\n         LH    R0,MBTTREL1             GET CURRENT LOWER TTREL\n         SR    R0,RWK3                 SUBTRACT HIGHEST TTREL TO DATE\n         S     R0,=F'1'\n         BZ    EXOK                    OK IF EQUAL\n         BP    TMISSING                POSITIVE MEANS MISSING TRACKS\n         SPACE\n* A NEGATIVE DIFFERENCE INDICATES AN OVERLAP WITH A PREVIOUS EXTENT.\n* FLAG THE CURRENT EXTENT, AND SET THE HIGH WATER MARK FROM IT ONLY IF\n* LARGER THAN THE CURRENT VALUE.\n         SPACE\n         MVC   TMERROR-7(7),=C'OVERLAP'\n         CH    RWK3,MBTTREL2           TEST AGAINST PREVIOUS MARK\n         BNL   BYPWK3                  BRANCH IF SMALLER\n         SPACE\n* UPDATE THE HIGH-WATER MARK AND ACCUMULATE THE NUMBER OF TRACKS WHICH\n* HAVE BEEN ACCOUNTED FOR.\n         SPACE\nEXOK     LH    RWK3,MBTTREL2           UPDATE HIGHEST TRACK YET\nBYPWK3   LH    R0,MBNTRKS              LOAD N TRACKS IN EXTENT\n         AR    RWK4,R0                 ACCUMULATE\n         BAL   RRET,BINALFR            CONVERT N TO ALPHA FOR PRINTING\n         MVC   TMEXTSIZ(5),BTAALF+7    PUT IN PRINT LINE\n         B     EDITCCHH                CONTINUE WITH EDITING\n         SPACE\n* FLAG INVALID EXTENTS AND BYPASS HIGHEST TRACK AND COUNT UPDATING.\n         SPACE\nEXINVAL  MVC   TMERROR-14(14),=C'INVALID EXTENT'\n         B     EDITCCHH\n         SPACE\n* WHEN TRACKS ARE MISSING, INDICATE HOW MANY BEFORE PRINTING THE\n* NEXT EXTENT NORMALLY.\n         SPACE\nTMISSING BAL   RRET,BINALFR            EDIT N MISSING TRACKS TO ALF\n         MVC   TMERROR-14(14),=C'TRACKS MISSING'\n         MVC   TMERROR-20(5),BTAALF+7  INSERT N MISSING IN PRINT LINE\n         MVI   TM1,PRSP1\n         BAL   RRET,PRINTSUB           PRINT ERROR MESSAGE\n         B     EXOK\n         SPACE 3\nEDITCCHH DS    0H  EDIT TRK ADDRESS IF NECESSARY\n         TM    MODESW,MEOMASK+DS1MASK   IS IT NECESSARY\n         BZ    GOAHEAD   YES IT IS...\n         TM    MODESW,DS1MASK\n         BZ    COTEM   CHECK ONLY TRACK ERRORS\n         L     R1,MBNAME   POINT AT DATA SET NAME\n         L     RRET,DSN1PTR   POINT AT CHOSEN DATA SET\n         CLC   0(44,R1),0(RRET)  IS IT A DATA SET MATCH?\n         BE    GOAHEAD   YES, GO AHEAD AND PRINT IT...\nCOTEM    CLI   TMERROR,C' '   IS IT AN ERROR TRACK\n         BE    NEXTTME   IF BLANK, NOT AN ERROR-DO NOT PRINT\n         SPACE 1\n* INSERT LOWER AND UPPER ADDRESSES IN CCHH FORM, AND ADD DATA SET NAME.\n         SPACE\nGOAHEAD  UNPK  HEXWORK(15),MBCCHH1(8)  FIRST TRACK ADDRESS\n         TR    HEXWORK(15),HEXEDTAB\n         MVC   TMCCHH1(4),HEXWORK\n         MVI   TMCCHH1+4,C'.'\n         MVC   TMCCHH1+5(4),HEXWORK+4\n         SPACE\n         UNPK  HEXWORK(15),MBCCHH2(8)  ADDR OF LAST TRACK\n         TR    HEXWORK(15),HEXEDTAB\n         MVC   TMCCHH2(4),HEXWORK\n         MVI   TMCCHH2+4,C'.'\n         MVC   TMCCHH2+5(4),HEXWORK+4\n         SPACE\n         TM    MBEXT,X'FF'             TEST IF NO EXTENT NUMBER\n         BO    TMBLEXT\n         SR    R0,R0\n         IC    R0,MBEXT\n         AH    R0,=H'1'\n         BAL   RRET,BINALFR\n         MVC   TMEXTNO(2),BTAALF+10\nTMBLEXT  DS    0H\n         SPACE\n         L     R1,MBNAME               ADDRESS OF DSNAME\n         MVC   TMDSNAM(44),0(R1)\n         SPACE\n         MVI   TM1,PRSP1               PRINT AND SPACE 1\n         BAL   RRET,PRINTSUB\nNEXTTME  L     RMB,MBCHAIN             FOLLOW CHAIN TO NEXT BLOCK\n         B     MAPELOOP\n         SPACE 2\n* END OF MAP.  CHECK THAT THE LAST ENTRY BROUGHT US TO THE LAST\n* PRIMARY TRACK.\n         SPACE\nENDMAPED LH    R0,FMAXTT               LOAD LAST TRK +1\n         SR    R0,RWK3                 TEST AGAINST HIGHEST FOUND\n         S     R0,=F'1'\n         BNP   ENDMAPPR                BRANCH IF ALL FOUND\n         SPACE\n* SOME TRACKS ARE MISSING, SO PRINT A WARNING.\n         SPACE\n         BAL   RRET,BINALFR            EDIT NUMBER MISSING\n         MVC   TMERROR-14(14),=C'TRACKS MISSING'\n         MVC   TMERROR-20(5),BTAALF+7\n         MVI   TM1,PRSP1\n         BAL   RRET,PRINTSUB           PRINT ERROR MESSAGE\n         SPACE\nENDMAPPR DS    0H\n         LR    R0,RWK4                 LOAD TRACK COUNT\n         BAL   RRET,BINALFR            EDIT TO ALPHA\n         MVC   TMEXTSIZ(5),BTAALF+7\n         MVC   TMEXTSIZ+7(20),=C'TRACKS ACCOUNTED FOR'\n         SPACE\n         XPRNTLIN  PWA,TEXT=PL+1,LENGTH=132,SPB=1,SPA=2\n         SPACE\n         MVI   PL+1,C' '\n         MVC   PL+2(131),PL+1\n         SPACE\n         MVC   PL+52(28),=C'<<<<< END OF TRACK MAP >>>>>'\n         MVI   PL,PRSP0\n         BAL   RRET,PRINTSUB\n         SPACE\n         DROP  RMB\n         SPACE 6\n* END OF VOLUME LISTINGS\n         SPACE\nENDVOL   DS    0H\n         BAL   RRET,GBRESET            RELEASE DSCB CORE\n         SPACE\n         B     NEWVOL\n         EJECT\n**************************\n* ERROR MESSAGE PRINTING *\n**************************\n         SPACE\n* ERRORS WHILE TRYING TO OPEN THE VTOC:\n         SPACE\nNODDCARD MVC   PL+41(19),=C'CANNOT FIND DD CARD'\n         B     PRERR1\n         SPACE\nNOTDACC  MVC   PL+41(27),=C'DEVICE IS NOT DIRECT ACCESS'\n         B     PRERR1\n         SPACE\nUNKNDEV  MVC   PL+41(19),=C'UNKNOWN DEVICE TYPE'\n         B     PRERR1\n         SPACE\nCANTOPEN MVC   PL+41(27),=C'ATTEMPT TO OPEN VTOC FAILED'\n         B     PRERR1\n         SPACE\nPRERR1   MVC   PL+10(28),=C'ERROR CONCERNING \"VOLUME01\":'\n         MVC   PL+28(8),DDNAME\n         MVI   PL,PRSP3\n         BAL   RRET,PRINTSUB\n         LA    R0,4                    SET RETURN CODE OF 4\n         C     R0,RETCODE\n         BL    *+8\n         ST    R0,RETCODE\n         B     NEWVOL\n         SPACE 3\n* ERRORS IN DSCB FORMAT:\n         SPACE\nFRSTNOT4 MVC   PL+41(21),=C'FIRST DSCB NOT TYPE 4'\n         LA    RWK1,RDS4               ADDRESS OF BAD BLOCK\n         B     PRERR2\n         SPACE\nBADFMT5  MVC   PL+41(33),=C'BAD DSCB, SHOULD HAVE BEEN TYPE 5'\n         LA    RWK1,RDS5               ADDRESS OF BAD BLOCK\n         B     PRERR2\n         SPACE\n* PRINT ERROR MESSAGE AND DUMP BAD BLOCK.\n         SPACE\nPRERR2   MVC   PL+10(28),=C'ERROR CONCERNING \"VOLUME01\":'\n         MVC   PL+28(8),DDNAME\n         MVI   PL,PRSP3\n         BAL   RRET,PRINTSUB\n         SPACE\n         LA    RWK2,140(RWK1)          ADDR OF FULL DISK ADDRESS\n         BAL   RRET,DUMPDSCB           DUMP BAD BLOCK IN HEX\n         SPACE\n* CLOSE THIS VTOC, SET RETURN CODE, AND GO ON TO NEXT VOLUME.\n         SPACE\n         LA    R0,2                    CALL MODE 2 FOR CLOSE\n         L     RGO,VTOCREAD            ADDRESS OF ROUTINE\n         BALR  RRET,RGO                BRANCH TO XVTCREAD\n         SPACE\n         LA    R0,8                    SET RETURN CODE OF 8\n         C     R0,RETCODE\n         BL    *+8\n         ST    R0,RETCODE\n         B     NEWVOL                  CONTINUE WITH NEXT VOLUME\n         EJECT\n*******************************************\n* PARTITIONED DATA SET DIRECTORY PRINTING *\n*******************************************\n         SPACE\n* ENTER THIS ROUTINE WITH THE NAME OF A PARTITIONED DATA SET AT (RWK1).\n* THE DDNAME REFERRING TO THE PROPER VOLUME IS ALREADY SET UP IN THE\n* DCB.  LIST THE MEMBER ENTRYS FROM THE DIRECTORY, AND PRINT THE\n* NUMBER OF MEMBERS, THE NUMBER OF BLOCKS, AND THE NUMBER OF BLOCKS\n* ACTUALLY USED.\n         SPACE 2\nPDSLIST  ST    RRET,PDSEXIT            SAVE RETURN ADDRESS\n         STM   RWK1,RWK4,PDSSAVE         AND WORK REGISTERS\n         SPACE\n* THE JFCB FOR THIS VOLUME IS ALREADY IN CORE, HAVING BEEN READ WHEN\n* THE VTOC WAS OPENED.\n         SPACE\n         L     R1,JFCBADR              SET UP JFCB BASE REG\n         USING JFDUMMY,R1\n         MVC   JFCBDSNM(44),0(RWK1)    INSERT DATA SET NAME\n         DROP  R1\n         SPACE\n         LM    R2,R3,=CL8'NOUSAGE '    PREVENT SETTING DATA SET USAGE\n         OPEN  (PDSDCB,(INPUT)),TYPE=J\n         L     RRET,PDSDCBA   ADDRESS OF DCB                        MS\n         USING IHADCB,RRET                                          MS\n         TM    DCBOFLGS,DCBOFOPN      SUCCESSFUL OPEN ?             MS\n         BO    OPENOK                 YES                           MS\n         DROP  RRET                                                 MS\n         MVC   PL+10(28),=C'UNABLE TO OPEN PDS DIRECTORY'           MS\n         MVI   PL,PRSP1                                             MS\n         BAL   RRET,PRINTSUB      GO PRINT ERROR MSG                MS\n         B     PDSDONE                                              MS\n         SPACE\nOPENOK   MVI   JFCBADR,X'87'  NULLIFY EXIT FOR OPEN ERROR           MS\n         SR    R0,R0                   RESET VARIOUS COUNTERS\n         STH   R0,PDSBAL\n         STH   R0,PDSDIRCT             DIRECTORY BLOCK COUNT\n         STH   R0,PDSDIRUS             BLOCKS USED\n         STH   R0,PDSMEMCT             MEMBER COUNT\n         STH   R0,PDSALCT              ALIAS COUNT\n         SPACE\n* GET A MEMBER FROM THE DIRECTORY, SETTING REGISTER 'RPDS' TO IT.\n         SPACE\nGETPDS   LH    R0,PDSBAL               LOAD BALANCE IN CURRENT BLOCK\n         LTR   R0,R0                   TEST FOR ZERO\n         BP    PDSBALOK                BR IF BLOCK NOT EMPTY\n         SPACE\n         READ  PDSECB,SF,PDSDCB,PDSBUF    READ A DIRECTORY BLOCK\n         SPACE\n         CHECK PDSECB\n         SPACE\n         L     RWK1,=A(PDSBUF)\n         USING PDSBUF,RWK1\n         LH    R1,PDSDIRCT             COUNT DIRECTORY BLOCKS\n         LA    R1,1(R1)\n         STH   R1,PDSDIRCT\n         LH    R0,PDSLRECL             SET BLOCK BALANCE FROM LOGICAL\n         SH    R0,=H'2'                  BLOCK LENGTH FIELD\n         STH   R0,PDSBAL\n         LA    R1,PDSDATA              SET PDSCLC TO BEGINNING OF BLOCK\n         ST    R1,PDSCLC\n         B     GETPDS                  TEST BALANCE....\n         DROP  RWK1\n         SPACE 2\n         USING DIRBLOCK,RPDS\nPDSBALOK L     RPDS,PDSCLC             LOAD ADDRESS OF DIRECTORY ENTRY\n         IC    RWK1,DIRC               GET USER DATA LENGTH\n         N     RWK1,=F'31'\n         SLL   RWK1,1\n         LR    R1,RPDS                 UPDATE BLOCK CLC\n         AR    R1,RWK1\n         LA    R1,12(R1)\n         ST    R1,PDSCLC\n         LH    R1,PDSBAL               DECREMENT BLOCK BALANCE\n         SR    R1,RWK1\n         SH    R1,=H'12'\n         STH   R1,PDSBAL\n         SPACE\n         CLC   DIRNAME(8),=8X'FF'      TEST FOR LAST NAME\n         BNE   EDITMEMB\n         MVC   PDSDIRUS(2),PDSDIRCT    SAVE COUNT OF BLOCKS USED\n         B     GETPDS                  READ ALL BLOCKS TO GET COUNT\n         SPACE\n* EDIT A LINE FOR THE MEMBER.  IF THE USER DATA WAS MORE THAN 44 BYTES,\n* A SECOND LINE IS REQUIRED.\n         SPACE\nEDITMEMB MVC   PDSMEMB(8),DIRNAME      MEMBER OR ALIAS NAME TO PRINTLIN\n         TM    DIRC,ALIASMSK           TEST IF ALIAS\n         BZ    NOTALIAS                BRANCH IF NOT ALIAS\n         SPACE\n         LH    R1,PDSALCT              COUNT ALIASES\n         LA    R1,1(R1)\n         STH   R1,PDSALCT\n         MVI   PDSALIAS,C'A'           MARK ALIAS IN PRINT LINE\n         B     PDSTTRED\n         SPACE\nNOTALIAS LH    R1,PDSMEMCT             COUNT MEMBER NAMES\n         LA    R1,1(R1)\n         STH   R1,PDSMEMCT\n         SPACE\nPDSTTRED DS    0H\n         TM    MODESW,NOMMASK   SKIP MEMBER LISTING?\n         BO    GETPDS     YEP\n         SPACE\n         UNPK  HEXWORK(15),DIRTTR(8)   EDIT RELATIVE TRACK ADDRESS\n         TR    HEXWORK(15),HEXEDTAB\n         MVC   PDSTTR(4),HEXWORK\n         MVI   PDSTTR+4,C'.'\n         MVC   PDSTTR+5(2),HEXWORK+4\n         SPACE\n         IC    R0,DIRC                 EDIT NUMBER OF TTR'S\n         SRL   R0,5\n         N     R0,=F'3'\n         STC   R0,PDSNTT\n         OI    PDSNTT,X'F0'\n         SPACE\n         LR    RWK4,RWK1               LENGTH OF USER DATA\n         CH    RWK1,=H'44'             TEST IF MORE THAN ONE LINE\n         BNH   PDS1LINE                BR IF ONE LINE\n         SPACE\n         LA    RWK1,2                  ENSURE BOTH LINES ON SAME PAGE\n         BAL   RRET,PAGECHEK\n         LR    RWK1,RWK4               RESTORE RWK1\n         LA    RWK4,44                 LENGTH FOR FIRST LINE\n         SPACE\nPDS1LINE LA    RWK2,DIRUDATA           ADDRESS OF USER DATA\n         LA    RWK3,PDSHEX             PRINT LINE OUTPUT AREA\n         BAL   RRET,DUMPEDIT           EDIT DATA INTO HEX\n         MVI   PDS1,PRSP1              PRINT AND SPACE 1\n         BAL   RRET,PRINTSUB\n         SPACE\n         CH    RWK1,=H'44'             TEST IF SECOND LINE REQUIRED\n         BNH   GETPDS                  BR IF NOT\n         LR    RWK4,RWK1               COMPUTE REMAINING DATA LENGTH\n         SH    RWK4,=H'44'\n         LA    RWK2,DIRUDATA+44\n         LA    RWK3,PDSHEX\n         BAL   RRET,DUMPEDIT\n         MVI   PDS1,PRSP1\n         BAL   RRET,PRINTSUB\n         SPACE\n         B     GETPDS\n         DROP  RPDS\n         SPACE 3\n* WHEN THE END OF THE DIRECTORY IS REACHED, CLOSE THE DATA SET AND\n* PRINT A SUMMARY LINE WITH THE ACCUMULATED TOTALS.\n         SPACE\nPDSEODAD DS    0H\n         SPACE\n         MVI   PDSMEMB,C' '   CLEAR MEMBER NAME OF LST MEMBER\n         MVC   PDSMEMB+1(7),PDSMEMB   AVOID RESIDUAL MEMBER NAME\n         SPACE\n         LH    R0,PDSMEMCT             COUNT OF MEMBERS\n         BAL   RRET,BINALFR\n         MVC   PDSSUMMC(4),BTAALF+8\n         LH    R0,PDSALCT              COUNT OF ALIASES\n         BAL   RRET,BINALFR\n         MVC   PDSSUMAC(4),BTAALF+8\n         LH    R0,PDSDIRUS             DIRECTORY BLOCK USED\n         BAL   RRET,BINALFR\n         MVC   PDSSUMUC(4),BTAALF+8\n         LH    R0,PDSDIRCT             NUMBER OF BLOCKS ALLOCATED\n         BAL   RRET,BINALFR\n         MVC   PDSSUMDC(4),BTAALF+8\n         SPACE\n         XPRNTLIN  PWA,TEXT=PDSSUM,LENGTH=PDSSUMSZ,OFFSET=16,SPA=1\n         SPACE\nPDSCLOSE CLOSE (PDSDCB)\n         SPACE\nPDSDONE  MVI   JFCBADR,X'07'     REESTABLISH EXIT FOR OPEN ERRORS   MS\n         LM    RWK1,RWK4,PDSSAVE\n         L     RRET,PDSEXIT\n         BR    RRET\n         SPACE 3\n* PDS SUMMARY LINE:\n         SPACE\nPDSSUM   DC    C'DIRECTORY CONTAINS '\nPDSSUMMC DC    C'0000 MEMBERS AND '\nPDSSUMAC DC    C'0000 ALIASES, AND USES '\nPDSSUMUC DC    C'0000 OF THE '\nPDSSUMDC DC    C'0000 DIRECTORY BLOCKS ALLOCATED'\nPDSSUMSZ EQU   *-PDSSUM\n         SPACE 2\nPDSEXIT  DC    F'0'\nPDSSAVE  DC    4F'0'\nPDSCLC   DC    A(0)\nPDSBAL   DC    H'0'\nPDSDIRCT DC    H'0'\nPDSDIRUS DC    H'0'\nPDSMEMCT DC    H'0'\nPDSALCT  DC    H'0'\n         SPACE 3\n* SYNAD ROUTINE FOR PDS DIRECTORY.  GET ERROR MESSAGE AND LOAD INTO\n* PRINT LINE.  BRANCH TO CLOSE DCB.\n         SPACE\nPDSSYNAD SYNADAF  ACSMETH=BSAM         GET ERROR MESSAGE FROM OS\n         SPACE\n         MVC   PL+1(30),=C'*******PDS DIRECTORY I/O ERROR'\n         MVC   PL+31(79),49(R1)        ADD TEXT FROM SYNADAF\n         SPACE\n         SYNADRLS                      FREE OS MESSAGE BUFFER\n         SPACE\n         MVI   PL,PRSP3                SET TO SPACE 3\n         BAL   RRET,PRINTSUB           PRINT ERROR MESSAGE\n         L     RRET,PDSDCBA   LOAD ADDRESS OF PDSDCB\n         NI    DCBIFLGS-IHADCB(RRET),X'3F'  RESET DCB ERROR FLAG\n         MVI   RETCODE+3,12            SET RETURN CODE OF 12\n         B     PDSCLOSE                CLOSE DCB\n         EJECT\n*********************\n* VTOC READ ROUTINE *\n*********************\n         SPACE\n* ROUTINE 'READSEQ' READS THE NEXT DSCB IN SEQUENCE INTO THE\n* 140-BYTE AREA ADDRESSED BY 'RWK2'.  IT CALLS ROUTINE 'XVTCREAD' TO DO\n* THE DIRTY WORK.  NORMAL RETURN IS TO THE ADDRESS IN\n* RRET+4.  IF END-OF-DATA IS ENCOUNTERED, RETURN IS TO RRET.\n* THE FULL DISK ADDRESS (MBBCCHHR) IS SAVED IN THE 8 BYTES FOLLOWING\n* THE BUFFER.\n         SPACE 2\nREADSEQ  ST    RRET,RDSEQXT            SAVE RETURN ADDRESS\n         SPACE\n         SR    R0,R0                   CALL MODE 0 FOR READ\n         L     RGO,VTOCREAD            ADDRESS OF XVTCREAD ROUTINE\n         BALR  RRET,RGO                BRANCH TO ROUTINE\n         CH    R15,=H'4'               TEST FOR END OF FILE\n         BE    RDEODAD                 BRANCH IF SO\n         MVC   0(140,RWK2),8(R1)       MOVE KEY AND DATA\n         XC    140(3,RWK2),0(RWK2)     ZERO 'MBB' PART OF ADDRESS\n         MVC   143(5,RWK2),0(R1)       INSERT 'CCHHR' PART OF ADDRESS\n         SPACE\n         L     RRET,RDSEQXT\n         LA    RRET,4(RRET)            INCREMENT FOR NORMAL RETURN\n         BR    RRET\n         SPACE 2\nRDEODAD  L     RRET,RDSEQXT            RETURN AT END OF DATA\n         BR    RRET\n         SPACE 3\nRDSEQXT  DC    F'0'\n         EJECT\n* ROUTINE 'READDIR' IS USED TO READ THE DSCB SPECIFIED BY THE 5-BYTE\n* 'CCHHR' FIELD POINTED TO BY RWK1 INTO THE 140-BYTE BUFFER AT RWK2.\n* THE FULL DISK ADDRESS 'MBBCCHHR' IS INSERTED IN THE 8 BYTES FOLLOW-\n* ING THE 140-BYTE BLOCK.\n         SPACE 2\nREADDIR  ST    RRET,RDDIRXT            SAVE EXIT ADDRESS\n         MVC   OBCCHHR(5),0(RWK1)      GET ADDRESS FROM CALLER\n         SPACE\n         OBTAIN  OBCAMLST              READ SPECIFIED BLOCK\n         SPACE\n         LTR   R15,R15                 TEST RETURN CODE\n         BZ    *+8                     BRANCH IF ZERO\n         BAL   RRET,DISASTER           NO ERROR CONDITIONS TOLERATED\n         L     R1,=A(OBWORK)           ADDRESS WORK AREA\n         MVC   0(140,RWK2),0(R1)       MOVE DSCB TO USER'S AREA\n         XC    140(3,RWK2),0(RWK2)     ZERO 'MBB' PART OF ADDRESS\n         MVC   143(5,RWK2),0(RWK1)     INSERT CCHHR FROM ORIGINAL CALL\n         L     RRET,RDDIRXT\n         BR    RRET                    RETURN TO CALLER\n         SPACE 3\nOBCAMLST CAMLST  SEEK,OBCCHHR,VOLUME,OBWORK\n         SPACE\nOBCCHHR  DC    5X'00'\nRDDIRXT  DC    F'0'\n         EJECT\n************************************\n* COMPUTE DATA SET ALLOCATION SIZE *\n************************************\n         SPACE\n* ENTER HERE TO COMPUTE THE NUMBER OF TRACKS ASSIGNED TO A DATA SET AND\n* PUT THE RESULT IN 'F1TRCNT'.  THE FORMAT 1 DSCB IS ASSUMED\n* TO BE IN AREA 'DS1', AND, IF THE NUMBER OF EXTENTS EXCEEDS 3,\n* THE FORMAT 3 DSCB IS ASSUMED TO BE IN AREA 'DS3'.\n* EACH EXTENT IS FILED IN THE TRACK MAP.\n         SPACE\n         USING DS1,RDS1\n         USING DS3,RDS3\n         SPACE\nF1SPANAL ST    RRET,F1SPAXT            SAVE RETURN ADDRESS\n         SR    RWK4,RWK4\n         ST    RWK4,F1TRCNT            ZERO SIZE RESULT FIELD\n         IC    RWK4,DS1NOEPV           INSERT NUMBER OF EXTENTS\n         LTR   RWK4,RWK4               TEST FOR ZERO EXTENTS\n         BCR   8,RRET                  EXIT IF ZERO\n         SR    RWK2,RWK2               ZERO EXTENT INDEX\n         SR    RWK3,RWK3               TRACK COUNT ACCUMULATOR\n         SPACE\nEXTLOOP  EX    0,EXTLIST(RWK2)         LOAD AN EXTENT ADDRESS IN RWK1\n         BAL   RRET,F13CNVT            GET NUM TRKS IN EXTENT\n         AR    RWK3,R0                 ADD TO TOTAL\n         SPACE\n         MVC   FB+FBCCHH1(8),2(RWK1)   MAKE UP TRACK MAP ENTRY\n         STH   R0,FB+FBNTRKS           SIZE OF EXTENT\n         MVC   FB+FBEXT(1),1(RWK1)     EXTENT NUMBER (-1)\n         MVC   FB+FBTTREL1(4),RELTT1   INSERT REL TRACK LIMITS\n         LA    R0,DS1DSNAM             ADDRESS OF DATA SET NAME\n         ST    R0,FB+FBNAME\n         LA    RWK1,FB\n         BAL   RRET,FILEMAP            FILE IN TRACK MAP\n         SPACE\n         LA    RWK2,4(RWK2)            INDEX TO NEXT EXTENT\n         BCT   RWK4,EXTLOOP            LOOP THROUGH ALL EXTENTS\n         SPACE\n         ST    RWK3,F1TRCNT            STORE RESULT\n         L     RRET,F1SPAXT            LOAD RETURN ADDRESS\n         BR    RRET\n         SPACE 3\nF1SPAXT  DC    F'0'\nF1TRCNT  DC    F'0'\n         SPACE\n* EXECUTED INSTRUCTIONS TO LOAD EXTENT ADDRESSES:\n         SPACE\nEXTLIST  LA    RWK1,DS1EXT1\n         LA    RWK1,DS1EXT2\n         LA    RWK1,DS1EXT3\n         LA    RWK1,DS3EXTNT\n         LA    RWK1,DS3EXTNT+10\n         LA    RWK1,DS3EXTNT+20\n         LA    RWK1,DS3EXTNT+30\n         LA    RWK1,DS3ADEXT\n         LA    RWK1,DS3ADEXT+10\n         LA    RWK1,DS3ADEXT+20\n         LA    RWK1,DS3ADEXT+30\n         LA    RWK1,DS3ADEXT+40\n         LA    RWK1,DS3ADEXT+50\n         LA    RWK1,DS3ADEXT+60\n         LA    RWK1,DS3ADEXT+70\n         LA    RWK1,DS3ADEXT+80\n         SPACE\n         DROP  RDS1,RDS3\n         EJECT\n***********************************\n* FORMAT 1 AND 3 EXTENT CONVERTER *\n***********************************\n         SPACE\n* ENTER WITH THE ADDRESS OF A TEN-BYTE EXTENT DISCRIPTION IN RWK1.\n* RETURN WITH RELATIVE TRACK NUMBERS OF FIRST AND LAST TRACKS IN\n* 'TTREL1' AND 'TTREL2', AND NUMBER OF TRACKS IN R0.\n         SPACE 2\nF13CNVT  CLI   0(RWK1),X'00'           TEST IF THIS IS AN ACTIVE EXTENT\n         BCR   8,RRET                  EXIT IF ZERO\n         LA    RWK1,2(RWK1)            ADDR OF STARTING CCHH\n         BAL   RGO,CCHHCNVT            GET REL TRACK\n         STH   R0,RELTT1\n         LA    RWK1,4(RWK1)            ADDR OF ENDING CCHH\n         BAL   RGO,CCHHCNVT            CONVERT TO TTREL\n         STH   R0,RELTT2\n         LH    R1,RELTT1\n         SR    R0,R1                   COMPUTE NUMBER OF TRACKS\n         AH    R0,=H'1'\n         S     RWK1,=F'6'              RESTORE RWK1 TO CALLER'S VALUE\n         BR    RRET                    RETURN TO CALLER\n         SPACE\n* CONVERT ADDRESS FROM 'CCHH' TO RELATIVE TRACK NUMBER.\n         SPACE\nCCHHCNVT SR    R0,R0                   RESULT WILL BE IN R0\n         IC    R0,0(RWK1)              BYTE C1\n         MH    R0,FC1\n         SR    R1,R1\n         IC    R1,1(RWK1)\n         MH    R1,FC2\n         AR    R0,R1\n         SR    R1,R1\n         IC    R1,2(RWK1)\n         MH    R1,FH1\n         AR    R0,R1\n         SR    R1,R1\n         IC    R1,3(RWK1)\n         MH    R1,FH2\n         AR    R0,R1\n         BR    RGO\n         SPACE 2\n*THESE MUST BE TOGETHER IN THE ORDER SHOWN:\n         SPACE\nRELTT1   DC    H'0'\nRELTT2   DC    H'0'\n         EJECT\n***************************\n* FORMAT 5 SPACE ANALYSIS *\n***************************\n         SPACE\n* ROUTINE TO ANALYZE THE FREE SPACE EXTENTS DESCRIBED IN A FORMAT 5\n* DSCB.  ENTER WITH 'RDS5' SET TO A DSCB.  COMPUTE THE NUMBER OF FREE\n* TRACKS, FREE CYLINDERS, AND EXTENTS.  FILE AN ENTRY IN THE TRACK MAP\n* FOR EACH EXTENT.\n         SPACE 2\n         USING DS5,RDS5\nF5SPANAL ST    RRET,F5SPAXIT           SAVE RETURN ADDRESS\n         SPACE\n         LA    RWK1,DS5AVEXT           ADDR OF 1ST GROUP OF 8 EXTENTS\n         LA    RWK2,8                  COUNTER\nF5SPLUP1 BAL   RRET,F5EXANAL           ANALYZE INDIVIDUAL EXTENT\n         LA    RWK1,5(RWK1)            INDEX TO NEXT ONE\n         BCT   RWK2,F5SPLUP1\n         SPACE\n         LA    RWK1,DS5MAVET           ADDR OF 2ND GROUP OF 18 EXTENTS\n         LA    RWK2,18\nF5SPLUP2 BAL   RRET,F5EXANAL\n         LA    RWK1,5(RWK1)\n         BCT   RWK2,F5SPLUP2\n         SPACE\n         L     RRET,F5SPAXIT\n         BR    RRET\n         DROP  RDS5\n         SPACE 3\n* ANALYZE AN INDIVIDUAL FREE SPACE EXTENT.  IF ALL FIVE BYTES ARE\n* ZERO, NO EXTENT IS DESCRIBED.\n         SPACE\nF5EXANAL ST    RRET,F5EXAXT            SAVE RETURN ADDRESS\n         STM   RWK1,RWK4,F5EXASAV        AND OTHER REGISTERS\n         CLC   0(5,RWK1),=XL5'00'      TEST FOR ACTIVE EXTENT\n         BCR   8,RRET                  EXIT IF ZEROS\n         SPACE\n         LH    R1,F5EXTNTS             COUNT FREE EXTENTS\n         LA    R1,1(R1)\n         STH   R1,F5EXTNTS\n         SPACE\n         MVC   FWORK(4),0(RWK1)        LOAD REGISTERS:\n         LH    RWK2,FWORK                RWK2=RELATIVE ADDR OF 1ST TR\n         LH    RWK3,FWORK+2              RWK3=NUMBER OF FULL CYLS\n         SR    RWK4,RWK4                 RWK4=NUMBER OF ODD TRACKS\n         IC    RWK4,4(RWK1)\n         STH   RWK2,RELTT1             SAVE TT REL OF FIRST TRACK\n         SPACE\n         LH    R0,FREECYLS             COUNT FREE CYLINDERS\n         AR    R0,RWK3\n         STH   R0,FREECYLS\n         SPACE\n         LR    R0,RWK3         COMPUTE EXTENT SIZE (MAY NOT WORK FOR\n         MH    R0,FCYL                   2321 DATA CELL)\n         AR    R0,RWK4\n         STH   R0,FB+FBNTRKS\n         LR    R1,R0                   LOAD SIZE OF THIS EXTENT\n         AH    R1,FREETRKS             COUNT TOTAL FREE TRACKS\n         STH   R1,FREETRKS\n         AR    R0,RWK2                 MAKE TTREL OF LAST TRACK\n         BCTR  R0,0                    DECREMENT BY 1\n         STH   R0,RELTT2\n         SPACE\n         LH    R1,RELTT1               CONVERT TTREL TO CCHH FOR MAP\n         BAL   RRET,TTCNVT\n         MVC   FB+FBCCHH1(4),CCHH\n         LH    R1,RELTT2\n         BAL   RRET,TTCNVT\n         MVC   FB+FBCCHH2(4),CCHH\n         SPACE\n         MVC   FB+FBTTREL1(4),RELTT1   PUT TTREL INTO TRACK MAP\n         MVI   FB+FBEXT,X'FF'          NO EXTENT NUMBER\n         LA    R0,=CL44'   AVAILABLE ******************** AVAILABLE'\n         ST    R0,FB+FBNAME\n         LA    RWK1,FB\n         BAL   RRET,FILEMAP            FILE DATA IN TRACK MAP\n         SPACE\n         LM    RWK1,RWK4,F5EXASAV      RESTORE REGISTERS\n         L     RRET,F5EXAXT\n         BR    RRET\n         SPACE 3\nF5SPAXIT DC    F'0'\nF5EXAXT  DC    F'0'\nF5EXASAV DC    4F'0'\n         EJECT\n*************************\n* CONVERT TTREL TO CCHH *\n*************************\n         SPACE\n* CONVERT RELATIVE TRACK ADDRESS TO ABSOLUTE CCHH FORM.  TTREL IS\n* SUPPLIED IN R1, RESULT IN 'CCHH'.\n         SPACE 2\nTTCNVT   SR    R0,R0                   R0-R1 USED FOR DIVIDE\n         ST    R0,CCHH                 ZERO OUTPUT FIELD\n         LH    RGO,FC1\n         LTR   RGO,RGO                 WATCH FOR DIVIDE BY ZERO\n         BZ    ZFC1\n         DR    R0,RGO\n         STC   R1,CCHH\n         LR    R1,R0\n         SR    R0,R0\nZFC1     LH    RGO,FC2\n         LTR   RGO,RGO\n         BZ    ZFC2\n         DR    R0,RGO\n         STC   R1,CCHH+1\n         LR    R1,R0\n         SR    R0,R0\nZFC2     LH    RGO,FH1\n         LTR   RGO,RGO\n         BZ    ZFH1\n         DR    R0,RGO\n         STC   R1,CCHH+2\n         STC   R0,CCHH+3\n         BR    RRET\nZFH1     STC   R1,CCHH+3\n         BR    RRET\n         SPACE 2\nCCHH     DC    F'0'\n         EJECT\n**************************\n* FILE ITEM IN TRACK MAP *\n**************************\n         SPACE\n* SUBROUTINE USED BY 'F1SPANAL' AND 'F5SPANAL' TO INSERT A SIX-WORD\n* EXTENT DESCRIPTOR BLOCK INTO THE TRACK MAP.  ENTER WITH THE ADDRESS\n* OF THE NEW BLOCK IN 'RWK1'.  THE ROUTINE GETS CORE, MOVES THE BLOCK,\n* AND CHAINS IT IN SEQUENCE WITH OTHER MAP BLOCKS BY ASCENDING ORDER OF\n* LOWER CCHH.\n         SPACE 2\nFILEMAP  ST    RRET,FMEXIT             SAVE EXIT AND WORK REGISTERS\n         STM   RWK2,RWK4,FMSAVE\n         SPACE\n         LA    RWK3,MBSIZE             GET A CORE BLOCK\n         BAL   RRET,GETBLOCK           RETURNS ADDRESS IN RWK2\n         USING MB,RWK2\n         MVC   MB(MBSIZE),0(RWK1)      MOVE NEW BLOCK\n         SPACE\n         L     RWK1,MBBASE             GET CHAIN BEGINNING\n         LA    RWK3,MBBASE             CHAIN HISTORY REG\n         SPACE\nFMSORT   CLC   MBCCHH1(4),FBCCHH1(RWK1)\n         BL    FMTHREAD\n         LR    RWK3,RWK1\n         L     RWK1,FBCHAIN(RWK1)      FOLLOW CHAIN TO NEXT ITEM\n         B     FMSORT\n         SPACE\nFMTHREAD ST    RWK1,MBCHAIN            THREAD FROM NEW TO NEXT\n         ST    RWK2,FBCHAIN(RWK3)      THREAD FROM PRECEDING TO NEW\n         SPACE\n         LM    RWK2,RWK4,FMSAVE        RESTORE REGISTERS\n         L     RRET,FMEXIT\n         BR    RRET\n         DROP  RWK2\n         SPACE 2\nFMSAVE   DC    3F'0'\nFMEXIT   DC    F'0'\nMBBASE   DC    A(*)                    CHAIN BASE ADDRESS\nMBTERM   DC    4X'FF'                  CHAIN END, MUST FOLLOW 'MBBASE'\n         SPACE\nFB       DS    0F                      WORK BLOCK USED BY F1SPANAL\n         DS    24X                       AND F5SPANAL TO ASSEMBLE BLKS\n         EJECT\n***************************\n* BINARY TO ALPHA ROUTINE *\n***************************\n         SPACE\n* ROUTINE TO CONVERT A BINARY NUMBER TO DECIMAL AND EDIT INTO THREE\n* ALPHA FORMATS.  ENTER WITH REGISTER 'RWK1' SET TO THE FIRST BYTE OF\n* THE BINARY FIELD AND THE NUMBER OF BYTES (UP TO FOUR) IN REGISTER\n* 'RWK2'.  THE ALPHA OUTPUT IS IN THREE 12-BYTE FIELDS:\n*        'BTAALF' IS RIGHT-ALIGNED WITH LEADING ZEROS BLANKED;\n*        'BTAALFZ' IS RIGHT-ALIGNED WITH LEADING ZEROS;\n*        'BTAALFJ' IS LEFT-ALIGNED WITH TRAILING BLANKS ADDED.\n* RETURN TO CALLER IS VIA REGISTER 'RRET'.  REGISTER 'R0' IS USED AND\n* IS NOT RESTORED.\n         SPACE\n* THE ALTERNATE ENTRANCE 'BINALFR' MAY BE USED WHEN THE ARGUMENT IS\n* ALREADY IN REGISTER 'R0'.\n         SPACE 2\nBINALF1  LA    RWK2,1                  ENTRANCE FOR 1-BYTE ARG\n         B     BTA\nBINALF2  LA    RWK2,2                  ENTRANCE FOR 2-BYTE ARG\n         B     BTA\nBINALF3  LA    RWK2,3                  ENTRANCE FOR 3-BYTE ARG\n         SPACE\nBTA      SR    R0,R0                   CLEAR ACCUMULATOR\nBTALUP1  SLL   R0,8                    MOVE OVER FOR NEXT BYTE\n         IC    R0,0(RWK1)              GET NEXT BYTE OF ARGUMENT\n         LA    RWK1,1(RWK1)            INCREMENT ADDR OF ARGUMENT\n         BCT   RWK2,BTALUP1            LOOP TO EXTRACT ALL BYTES\n         SPACE\nBINALFR  LPR   R0,R0                   TAKE ABSOLUTE VALUE\n         CVD   R0,BTADWD               CONVERT ARG TO PACKED DECIMAL\n         UNPK  BTAALFZ(12),BTADWD(8)   UNPACK VERSION WITH ZEROS\n         OI    BTAALFZ+11,X'F0'        COVER UP SIGN\n         SPACE\n         MVC   BTAALF(12),BTAPTRN      INSERT EDIT CONTROL CHAR\n         ED    BTAALF(12),BTADWD+2     EDIT ZERO-SUPPRESSED VERSION\n         SPACE\n         MVC   BTAALFJ(11),BTAALF+1    NOTE: BTAALFJ+11 PERMANENT BLANK\nBTALUP2  CLI   BTAALFJ,C' '            CHECK FOR LEADING BLANK\n         BCR   7,RRET                  EXIT IF NOT BLANK, IE, DIGIT\n         MVC   BTAALFJ(11),BTAALFJ+1   SHIFT ONE LEFT\n         B     BTALUP2                 CONTINUE\n         SPACE 3\nBTADWD   DC    D'0'\nBTAPTRN  DC    XL12'402020202020202020202120'     EDIT CONTROL CHARS\nBTAALF   DC    CL12' '\nBTAALFJ  DC    CL12' '\nBTAALFZ  DC    CL12' '\n         EJECT\n*********************\n* VTOC DATE EDITING *\n*********************\n         SPACE\n* SUBROUTINE TO CONVERT FROM THE BINARY FORM 'YDD' IN A DSCB INTO THE\n* CIVILIZED ALPHA FORM 'MM/DD/YY'.  ENTER WITH ADDRESS OF 3-BYTE\n* BINARY ARGUMENT IN RWK1 AND ADDRESS OF 8-BYTE ALPHA RECEIVER IN RWK2.\n         SPACE 2\nVTDATED  ST    RRET,VTDXIT\n         SR    R0,R0\n         IC    R0,0(RWK1)              BINARY YEAR\n         MH    R0,=H'1000'             TIMES 1000\n         MVC   DECDATE(2),1(RWK1)      ALIGN DAY ON HALF-WORD\n         AH    R0,DECDATE              ADD BINARY DAY\n         CVD   R0,DECDATE              CONVERT TO PACKED DECIMAL\n         SPACE\n         LA    R1,DECDATAD             LOAD ADDR OF ARGUMENT ADDRESS\n         L     RGO,VDATEDIT            LOAD SUBROUTINE ADDRESS\n         BALR  RRET,RGO                CALL XDATEDIT ROUTINE\n         SPACE\n         MVC   0(8,RWK2),DECDATE       DELIVER RESULT\n         L     RRET,VTDXIT\n         BR    RRET\n         SPACE 3\nVTDXIT   DC    F'0'\n         EJECT\n*************************\n* DSCB HEX DUMP ROUTINE *\n*************************\n         SPACE\n* THIS SUBROUTINE EDITS A DSCB IN HEX IN THREE LINES.  ENTER WITH THE\n* ADDRESS OF THE DSCB IN RWK1 AND THE ADDRESS OF ITS DISK ADDRESS\n* (MBBCCHHR) IN RWK2.  CHECKS TO BE SURE ALL THREE LINES WILL BE ON\n* THE SAME PAGE.\n         SPACE 2\nDUMPDSCB ST    RRET,DUMPEXIT           SAVE RETURN\n         LR    RWK3,RWK1               TEMP SAVE RWK1\n         LA    RWK1,3                  TO TEST PAGE BALANCE\n         BAL   RRET,PAGECHEK\n         LR    RWK1,RWK3\n         SPACE\n         MVC   PL+8(17),=C'BLK 1234.5678.90:'\n         UNPK  HEXWORK(15),3(8,RWK2)   EDIT DISK ADDRESS OF BLOCK\n         TR    HEXWORK(15),HEXEDTAB\n         MVC   PL+12(4),HEXWORK\n         MVC   PL+17(4),HEXWORK+4\n         MVC   PL+22(2),HEXWORK+8\n         LA    RWK2,0(RWK1)\n         LA    RWK3,PL+35\n         LA    RWK4,44\n         BAL   RRET,DUMPEDIT           EDIT HEX CHARS OF KEY\n         MVI   PL,PRSP1                PRINT AND SPACE 1\n         BAL   RRET,PRINTSUB\n         SPACE\n         MVC   PL+8(13),=C'FORMAT N DSCB'\n         MVC   PL+15(1),44(RWK1)       DSCB TYPE NUMBER\n         OI    PL+15,X'F0'             FOR TYPE 0, IF EVER USED\n         LA    RWK2,44(RWK1)\n         LA    RWK3,PL+26\n         LA    RWK4,48\n         BAL   RRET,DUMPEDIT\n         MVI   PL,PRSP1\n         BAL   RRET,PRINTSUB\n         SPACE\n         LA    RWK2,92(RWK1)\n         LA    RWK3,PL+26\n         LA    RWK4,48\n         BAL   RRET,DUMPEDIT\n         MVI   PL,PRSP2                SPACE 2 ON LAST LINE\n         BAL   RRET,PRINTSUB\n         SPACE\n         L     RRET,DUMPEXIT\n         BR    RRET\n         SPACE\nDUMPEXIT DC    F'0'\n         EJECT\n* HEX DUMP EDIT SUBROUTINE\n         SPACE\n* ROUTINE TO EDIT INTO HEX IN 4-BYTE GROUPS.  'RWK2' IS THE SOURCE\n* ADDRESS, 'RWK3' IS THE RECEIVER ADDRESS, AND 'RWK4' CONTAINS THE\n* NUMBER OF BYTES TO EDIT.\n         SPACE 2\nDUMPEDIT LTR   RWK4,RWK4               TEST FOR ZERO BYTES\n         BCR   13,RRET                 EXIT IF ZERO\n         B     DUMPJOIN\n         SPACE\nDUMPLOOP BCT   R1,DUMPMOVE             TEST FOR 4TH BYTE\n         MVI   0(RWK3),C' '            INSERT BLANK EVERY 4 BYTES\n         LA    RWK3,1(RWK3)            INCREMENT RECEIVER ADDRESS\nDUMPJOIN LA    R1,4                    BEGIN NEW 4-BYTE GROUP\n         SPACE\nDUMPMOVE UNPK  HEXWORK(3),0(2,RWK2)    EDIT ONE BYTE INTO ALPHA\n         TR    HEXWORK(2),HEXEDTAB\n         MVC   0(2,RWK3),HEXWORK\n         LA    RWK2,1(RWK2)            INCREMENT SOURCE ADDR\n         LA    RWK3,2(RWK3)            INCREMENT RECEIVER ADDR\n         BCT   RWK4,DUMPLOOP           COUNT NUMBER OF BYTES EDITED\n         BR    RRET\n         EJECT\n*************************\n* FIELD SCAN SUBROUTINE *\n*************************\n         SPACE\n* SUBROUTINE TO READ A WORD FROM A CHARACTER STRING.  ENTER WITH 'RWK1'\n* SET TO THE BEGINNING OF THE STRING AND 'RWK2' CONTAINING THE LENGTH\n* OF THE STRING.  RETURNS WITH THE WORD IN 8 BYTES AT 'SCANWORD' AND\n* UPDATES 'RWK1' AND 'RWK2' TO GET NEXT WORD IN NEXT CALL.\n         SPACE 2\nSCAN     DS    0H\n         MVC   SCANWORD(8),=8C' '      BLANK OUTPUT FIELD\n         LA    RWK3,SCANWORD\n         SPACE\nSCLOOP   LTR   RWK2,RWK2               TEST FOR END OF INPUT STRING\n         BCR   13,RRET                 EXIT WHEN REACHED\n         CLI   0(RWK1),C' '            BLANKS ARE IGNORED\n         BE    SCANEXT\n         CLI   0(RWK1),C','            TEST FOR COMMA (WORD SEPARATOR)\n         BE    SCANDONE\n         SPACE\n         C     RWK3,=A(SCANWORD+8)     TEST FOR MAX OUTPUT LENGTH\n         BNL   SCANEXT                 SKIP DELIVERY IF OVER 8\n         MVC   0(1,RWK3),0(RWK1)       DELIVER CHAR TO OUTPUT WORD\n         LA    RWK3,1(RWK3)            INCR OUTPUT INDEX\nSCANEXT  LA    RWK1,1(RWK1)            INCR TO NEXT INPUT CHAR, AND\n         BCTR  RWK2,0                    DECREMENT COUNT\n         B     SCLOOP\n         SPACE\nSCANDONE LA    RWK1,1(RWK1)            INCR PAST SEPARATOR AND EXIT\n         BCTR  RWK2,0\n         BR    RRET\n         SPACE 2\nSCANWORD DC    CL8' '\n         EJECT\n************************\n* CORE BLOCK ALLOCATOR *\n************************\n         SPACE\n* THIS ROUTINE IS ENTERED WITH THE SIZE OF A DESIRED BLOCK OF CORE IN\n* 'RWK3'.  IT RETURNS WITH THE ADDRESS OF AN AVAILABLE AREA IN 'RWK2'.\n* THE BLOCK WILL BE ALIGNED ON A FULL-WORD BOUNDARY.\n         SPACE\n* THESE SMALL BLOCKS ARE ALLOCATED FROM LARGE BLOCKS OBTAINED FROM THE\n* SUPERVISOR VIA 'GETMAIN' CALLS.  THE FIRST WORD OF EACH LARGE BLOCK\n* POINTS TO THE NEXT ONE, EXCEPT FOR THE LAST, WHICH CONTAINS A ZERO\n* WORD.  THIS CHAIN IS USED BY THE 'GBRESET' ROUTINE TO RELEASE THE\n* CORE.\n         SPACE 2\nGETBLOCK A     RWK3,=F'3'              ROUND SIZE TO NEXT WORD\n         N     RWK3,ROUND4             'ROUND4 IS X'FFFFFFFC'\nGBJOIN   L     R0,GBBAL                LOAD CURRENT BALANCE\n         SR    R0,RWK3                 SUBTRACT SIZE DESIRED\n         BM    NEWBLOCK                BRANCH IF NOT ENOUGH\n         ST    R0,GBBAL                SAVE NEW BALANCE\n         L     RWK2,GBCLC              LOAD ADDRESS OF BLOCK\n         LR    R0,RWK2\n         AR    R0,RWK3                 UPDATE ADDRESS OF AVAILABLE AREA\n         ST    R0,GBCLC\n         BR    RRET\n         SPACE\n* GET A NEW BLOCK AND CHAIN.\n         SPACE\nNEWBLOCK GETMAIN  EC,LV=GETSIZE,A=GBNEWBL  CONDITIONAL REQUEST FOR CORE\n         LTR   R15,R15                 DID WE GET IT?\n         BNZ   GMFAIL                  NO, BRANCH\n         L     R1,GBNEWBL              LOAD ADDRESS OF GOTTEN CORE\n         L     RWK2,GBBASE             BASE OF CURRENT BLOCK\n         ST    R1,0(RWK2)              CHAIN TO NEW BLOCK\n         ST    R1,GBBASE               UPDATE BASE CELL\n         SR    R0,R0\n         ST    R0,0(R1)                ZERO CHAIN IN NEW BLOCK\n         LA    R1,4(R1)                SET TO FIRST AVAILABLE BYTE\n         ST    R1,GBCLC\n         MVC   GBBAL(4),NEWBAL         RESET BALANCE COUNTER\n         B     GBJOIN\n         SPACE 3\n* RESET ROUTINE TO RELEASE ALL CORE AND RESET POINTERS.\n         SPACE\nGBRESET  L     RWK1,GBFIRST            ADDR OF FIRST BLOCK OF CORE\nGBR1     LTR   RWK1,RWK1               TEST FOR END OF CHAIN\n         BZ    GBR2                    BRANCH IF RELEASING DONE\n         LR    R1,RWK1                 ADDR OF BLOCK TO RELEASE\n         L     RWK1,0(RWK1)            FOLLOW CHAIN TO NEXT BLOCK\n         LA    R0,GETSIZE              SIZE OF BLOCK\n         SPACE\n         FREEMAIN  R,LV=(0),A=(1)\n         SPACE\n         B     GBR1\n         SPACE\nGBR2     SR    R0,R0\n         ST    R0,GBBAL                SET ZERO BALANCE\n         ST    R0,GBFIRST              SET ZERO INITIAL BLOCK ADDRESS\n         LA    R0,GBFIRST\n         ST    R0,GBBASE               POINT BASE BACK TO INITIAL CELL\n         BR    RRET\n         SPACE 2\n* RAN OUT OF CORE.  PRINT MESSAGE AND GO DIRECTLY TO END VOLUME ROUTINE\n         SPACE\nGMFAIL   XPRNTLIN  PWA,TEXT=GMFMSG,LENGTH=L'GMFMSG,SPB=1,SPA=1\n         B     ENDVOL\n         SPACE 3\nGBNEWBL  DC    F'0'\nGBBAL    DC    F'0'\nGBCLC    DC    A(0)\nGBBASE   DC    A(GBFIRST)\nGBFIRST  DC    A(0)\nNEWBAL   DC    A(GETSIZE-4)\n         EJECT\n********************\n* PRINTING ROUTINE *\n********************\n         SPACE\n* ROUTINE TO INTERFACE WITH THE PRINTING ROUTINE.  CALL WITH TEXT IN\n* 133-BYTE LINE 'PL'.  FIRST BYTE CONTAINS DESIRED SPACING AFTER\n* PRINTING.  'PL' IS BLANKED AFTER PRINTING.\n         SPACE\nPRINTSUB ST    RRET,PRSEXIT            SAVE RETURN ADDRESS\n         IC    R0,PL                   PICK UP SPACING AMOUNT\n         SPACE\n         XPRNTLIN  PWA,TEXT=PL+1,LENGTH=132,SPA=((R0))\n         SPACE\n         MVI   PL+1,C' '               BLANK PRINT LINE\n         MVC   PL+2(131),PL+1\n         L     RRET,PRSEXIT            LOAD RETURN ADDRESS\n         BR    RRET                    RETURN TO CALLER\n         SPACE\n* PAGE BALANCE TEST ROUTINE.  SKIP TO HEAD-OF-FORM IF REMAINING LINES\n* ON PAGE ARE LESS THAN THE NUMBER IN 'RWK1'.\n         SPACE\nPAGECHEK ST    RRET,PRSEXIT            SAVE RETURN ADDRESS\n         XPREJECT  PWA,COND=(LT,(RWK1))\n         L     RRET,PRSEXIT            RESTORE EXIT ADDRESS\n         BR    RRET                    RETURN TO CALLER\n         SPACE\nPRSEXIT  DS    F\n         EJECT\n*****************\n* PAGE HEADINGS *\n*****************\n         SPACE\nINITHEAD XPRLDEF  TEXT=IHTXT,LENGTH=L'IHTXT,SPB=(TOPMARGN,ATHOF),SPA=3\n         SPACE\nIHTXT    DC    C'VTOCLIST -- DIRECT-ACCESS VOLUME DIRECTORY LISTER'\n         SPACE 3\nF1HD2    XPRLDEF  TEXT=F1HTXT,LENGTH=LF1HTXT,SPB=(TOPMARGN,ATHOF),SPA=2\n         SPACE\nF1HD3    XPRLDEF  TEXT=F1HTXT,LENGTH=LF1HTXT,SPB=(TOPMARGN,ATHOF),SPA=3\n         SPACE\nF1HTXT   DC    CL20' '\nF1HSER1  EQU   F1HTXT\n         DC    C'TABLE OF CONTENTS FOR VOLUME SERIAL='\nF1HSER2  DC    CL6' '\nLF1HTXT  EQU   *-F1HTXT\n         SPACE 3\nF1SA     XPRLDEF  TEXT=F1SUBA,LENGTH=LF1SUBA,SPA=1,OFFSET=19\n         SPACE\nF1SUBA   DS    0C\n         DC    C'DSNAME'\n         DC    19C' '\n         DC    C' LAST REF  CREDT    EXPDT    '\n         DC    C'DSO RECFM BLKSZ LRECL KEY OP  '\n         DC    C'TRKAL TRKUS EX SECQU T   '\nLF1SUBA  EQU   *-F1SUBA\n         SPACE 3\nF1SB     XPRLDEF  TEXT=F1SUBB,LENGTH=LF1SUBB,SPA=2\n         SPACE\nF1SUBB   DS    0C\n         DC    44C'-'\n         DC    C' -------- -------- --------  '\n         DC    C'--- ----- ----- ----- --- --  '\n         DC    C'----- ----- -- ----- -   '\n******************************************************************\n* NOTE:  UNDERLINE CHARACTERS CHANGED TO DASHES FOR PRINTABILITY.*\n******************************************************************\nLF1SUBB  EQU   *-F1SUBB\n         SPACE\n* PAGE SUB-HEADING LINES FOR TRACK MAP EDITING\n         SPACE\nTMHEAD   XPRLDEF  TEXT=TMHTXT,LENGTH=LTMHTXT,SPB=(TOPMARGN,ATHOF),SPA=2\n         SPACE\n         SPACE\nTMHTXT   DC    CL20' '\nTMHSER1  EQU   TMHTXT\n         DC    C'TRACK ALLOCATION MAP FOR VOLUME SERIAL='\nTMHSER2  DC    CL6' '\nLTMHTXT  EQU   *-TMHTXT\n         SPACE 3\nTMSA     XPRLDEF  TEXT=TMSUBA,LENGTH=LTMSUBA,OFFSET=27,SPA=1\n         SPACE\nTMSUBA   DS    0C\n         DC    C'FIRST TRK   LAST TRK  #TRKS  EXT  DSNAME OR USAGE'\nLTMSUBA  EQU   *-TMSUBA\n         SPACE 3\nTMSB     XPRLDEF  TEXT=TMSUBB,LENGTH=LTMSUBB,OFFSET=27,SPA=2\n         SPACE\nTMSUBB   DS    0C\n         DC    C'---------  ---------  -----  ---  '\n         DC    44C'-'\n***** ABOVE UNDERLINES ALSO CHANGED TO DASHES -- HM  **********\nLTMSUBB  EQU   *-TMSUBB\n         EJECT\n* PRINT LINE FIELD DEFINITIONS\n         SPACE 2\nPL       DC    CL133' '\n         SPACE 3\n* PRINT LINES FOR VOLUME DESCRIPTION:\n         SPACE\nV1       EQU   PL\nV1TYPE   EQU   V1+22\nV1NOCYL  EQU   V1+45\nV1TRCYL  EQU   V1+57\nV1DEVTK  EQU   V1+73\nV1DEVDT  EQU   V1+88\nV1DEVDB  EQU   V1+102\n         SPACE\nV2       EQU   PL\nV2DSCBCT EQU   V2+20\nV2DSCBAV EQU   V2+37\nV2VTEXT  EQU   V2+55\nV2NUMALT EQU   V2+88\nV2NXTALT EQU   V2+102\n         SPACE\nV3       EQU   PL\nV3FRTRKS EQU   PL+18\nV3FREXTS EQU   PL+34\nV3FRCYLS EQU   PL+58\n         SPACE\n* PRINT LINES FOR FORMAT 1 DSCB DESCRIPTION:\n         SPACE\nF1A      EQU   PL\nF1DSNAM  EQU   F1A+1\nF1REFD   EQU   F1A+46\nF1CREDT  EQU   F1A+55\nF1EXPDT  EQU   F1A+64\nF1DSORG  EQU   F1A+74\nF1RECFM  EQU   F1A+78\nF1BLKL   EQU   F1A+84\nF1LRECL  EQU   F1A+90\nF1KEYL   EQU   F1A+96\nF1OPTCD  EQU   F1A+100\nF1TRALOC EQU   F1A+104\nF1TRUSE  EQU   F1A+110\nF1NOEPV  EQU   F1A+116\nF1SCALO  EQU   F1A+119\nF1ALCTYP EQU   F1A+125\n         SPACE\n* PRINT LINES FOR TRACK MAP EDITING:\n         SPACE\nTM1      EQU   PL\nTMERROR  EQU   TM1+26\nTMCCHH1  EQU   TM1+28\nTMCCHH2  EQU   TM1+39\nTMEXTSIZ EQU   TM1+50\nTMEXTNO  EQU   TM1+57\nTMDSNAM  EQU   TM1+62\n         SPACE\n* PRINT LINES FOR PDS DIRECTORY LISTING:\n         SPACE\nPDS1     EQU   PL\nPDSMEMB  EQU   PDS1+12\nPDSALIAS EQU   PDS1+21\nPDSTTR   EQU   PDS1+23\nPDSNTT   EQU   PDS1+32\nPDSHEX   EQU   PDS1+35\n         EJECT\n* EXODUS\n         SPACE\n* WHEN ALL VOLUMES ARE COMPLETED, COME HERE TO CLOSE THE PRINTER,\n* TIDY UP LOOSE ENDS, AND RETURN.\n         SPACE 2\nEXODUS   DS    0H\n         SPACE\n         XPRCLOSE  PWA\n         SPACE\n         L     RSAVE,SAVEAREA+4\n         L     RGO,RETCODE             INSERT RETURN CODE IN REG 15\n         RETURN  (14,12),T,RC=(15)\n         SPACE 6\n* DISASTER ROUTINE\n         SPACE\n* COME HERE TO ABEND FOR CONDITIONS WHICH WERE NOT SUPPOSED TO HAPPEN,\n* OR ERRORS FOR WHICH NO SPECIAL ROUTINE ARE WRITTEN.\n         SPACE 2\nDISASTER ABEND 100,DUMP\n         EJECT\n* PDS DIRECTORY DATA CONTROL BLOCK\n         SPACE 2\nPDSDCBA  DC    A(PDSDCB)   RELOCATE THIS DCB....\nDSN1PTR  DC    A(DSNJFCB)   POINTER TO DSN FROM JCL\nDSORGTBA DC    A(DSORGTAB)   ADDRESSABILITY TRICK....\n         SPACE 6\n* DCB EXIT LIST:\n         SPACE\nJFCBADR  DS    0F\n         DC    X'07'                                               MS\n         DC    AL3(JFCB)\n         DC    X'91'                                               MS\n         DC    AL3(OPENERR)                                        MS\n         EJECT\n* PRINT SUBROUTINE DATA CONTROL BLOCK AND WORK AREA:\n         SPACE 2\n* UNABLE TO OPEN SYSPRINT - TYPE ERROR MESSAGE AND EXIT.\n         SPACE\nPROPBAD  DS    0H\n         MVC   PROPMSGJ(8),JOBNAME     INSERT JOB NAME IN MESSAGE\n         WTO   MF=(E,PROPMSG)          TYPE COMPLAINT ON CONSOLE\n         MVI   RETCODE+3,20            SET RETURN CODE TO 20\n         B     EXODUS                  EXIT\n         SPACE\nPROPMSG  DS    0F\n         DC    AL2(PROPMSGL,0)         FORMAT V CONTROL FIELD\n         DC    C'JOB '\nPROPMSGJ DC    C'12345678 -- VTOCLIST UNABLE TO OPEN SYSPRINT'\nPROPMSGL EQU   *-PROPMSG\n         SPACE 6\nPWA      XPRDCB  DDNAME=SYSPRINT\n         EJECT\n* MISCELLANEOUS CONSTANTS AND WORK CELLS:\n         SPACE 2\nDECDATE  DC    D'0'\n         SPACE\nDECTIME  DC    F'0'\nDEVCHAR  DC    2F'0'\nUNITTYPE EQU   DEVCHAR+3\nFMT1ADDR DC    F'0'\nFMT4ADDR DC    F'0'\nFMT5ADDR DC    F'0'\nFWORK    DC    F'0'\nRETCODE  DC    F'0'\nROUND4   DC    X'FFFFFFFC'\nSAVEAREA DC    18F'0'\nTIOTLOC  DC    A(0)\nVTOCREAD DC    V(XVTCREAD)\nDECDATAD DC    A(DECDATE)\nVDATEDIT DC    V(XDATEDIT)\n         SPACE\nDSCOUNT  DC    H'0'\nFREECYLS DC    H'0'\nFREETRKS DC    H'0'\nF5EXTNTS DC    H'0'\nHWORK    DC    H'0'\nVTOCSIZE DC    H'0'\n         SPACE\nDDNAME   DC    CL8'VOLUME00'\nJOBNAME  DS    CL8\nVOLUME   DS    CL6\nHEXWORK  DC    CL16' '\nLASTFMT1 DC    44X'FF'\nMODESW   DC    X'00'          ORIGINAL SWITCH FOR OPTIONS\nMODESW1  DC    X'00'          SECOND SET OF SWITCHES\nDSORGSW  DC    X'00'            SWITCH FOR TESTING DSORG\nTSTDSORG DC    X'00'   FILTER FOR DSORG\n         SPACE\n         DC    CL16'0123456789ABCDEF'\nHEXEDTAB EQU   *-256\n         SPACE\n* DUMMY TRACK MAP ENTRY FOR VOLUME LABEL ON TRACK 0:\n         SPACE\nTRK0MAP  DC    2F'0'\n         DC    H'1'\n         DC    XL2'FF00'\n         DC    A(TRK0NAME)\n         DC    F'0'\n         EJECT\n* TABLE OF DEVICE SIZE CONSTANTS, FILLED IN FROM DEVICE NAME TABLE WHEN\n* DEVICE TYPE IS DETERMINED.  THE FOUR CONSTANTS FC1, FC2, FH1, AND FH2\n* ARE SCALING FACTORS TO BE APPLIED TO A FULL DIRECT-ACCESS ADDRESS OF\n* THE FORM 'CCHH'.  EACH CONSTANT IS THE NUMBER OF TRACKS REPRESENTED\n* BY ONE UNIT OF THE CORRESPONDING ADDRESS BYTE.  'FMAXTT' IS THE\n* MAXIMUM RELATIVE TRACK ADDRESS FOR THE DEVICE, AND 'FCYL' IS THE\n* NUMBER OF TRACKS PER CYLINDER, AS APPLIED TO THE CYLINDER COUNT IN A\n* FORMAT 5 EXTENT ENTRY.  'DEVNAMAD' IS THE ADDRESS OF THE DEVICE NAME\n* IN THE DEVICE NAME TABLE. (REST OF TABLE MOVED. CST)\n         SPACE\nDEVNAMAD DC    A(0)\nFC1      DC    H'0'\nFC2      DC    H'0'\nFH1      DC    H'0'\nFH2      DC    H'0'\nFCYL     DC    H'0'\nFMAXTT   DC    H'0'\n         EJECT\n* LITERALS\n         SPACE 2\n         LTORG\n         SPACE 2\n         DROP  RBASE1,RBASE2\n         EJECT\n* WORK AREAS WHICH ARE NOT COVERED BY BASE REGISTERS:\n         SPACE\n         ORG   GENESIS+8192            KEEP US HONEST ABOUT BASE REG\n         SPACE 2\n* DEVICE NAME TABLE, TO PROVIDE SPECIFIC INFORMATION FOR EACH DEVICE.\n* THE ORDER OF THE HALF-WORD CONSTANTS MUST CORRESPOND TO \"FC1...\"\n* ABOVE. (MOVED FOR ADDRBLTY. CST. SEE DEVNAMAD FOR REST)\nDEVNAMES DS    0H\n         SPACE\n         DC    AL1(DEV2301)\n         DC    CL15'2301 DRUM'\n         DC    H'0,0,0,1,8,200'\nDEVNAMSZ EQU   *-DEVNAMES\n         SPACE\n         DC    AL1(DEV2302)\n         DC    CL15'2302 DISK FILE'\n         DC    H'0,46,0,1,46,11500'\n         SPACE\n         DC    AL1(DEV2303)\n         DC    CL15'2303 DRUM'\n         DC    H'0,10,0,1,10,800'\n         SPACE 1                                                   HM\n         DC    AL1(DEV23051)                                       HM\n         DC    CL15'2305-1 DRUM'                                   HM\n         DC    H'0,8,0,1,8,768'   ****** THIS IS DEF FOR 2305-2 BAD HM\n         SPACE\n         DC    AL1(DEV23052)\n         DC    CL15'2305-2 DRUM'                                   HM\n         DC    H'0,8,0,1,8,768'\n         SPACE\n         DC    AL1(DEV3330)\n         DC    CL15'3330 DISK PACK'\n         DC    Y((19*256),19,0,1,19,7676)   3330 DEFINITION          HM\n         SPACE 1                                                     HM\n*******  SPECIAL 3330-11 DEFINITION-MUST BE CONTIGOUS TO 3330-1 ***  HM\n         SPACE 2                                                     HM\n         DC    AL1(DEV33301)       DEVTYPR                           HM\n         DC    CL15'3330-11 DISK'    HEADER ID DEVICE NAME           HM\n         DC    Y((19*256),19,0,1,19,15352)  3330-11 DEFINITION       HM\n         SPACE 2\n*******  3350  DEFINITION                                            WB\n         SPACE 2                                                     WB\n         DC    AL1(DEV3350)        DEVTYP                            WB\n         DC    CL15'3350 DISK PACK'                                  WB\n         DC    H'7680,30,0,1,30,16650'                               WB\n*******  3380  DEFINITION                                           CST\n         SPACE 2                                                    CST\n         DC    AL1(DEV3380)        DEVTYP                           CST\n         DC    CL15'3380 DISK PACK'                                 CST\n         DC    H'3840,15,0,1,15,13275'                              CST\n*******  3375  DEFINITION                                           CST\n         SPACE 2                                                    CST\n         DC    AL1(DEV3375)        DEVTYP                           CST\n         DC    CL15'3375 DISK PACK'                                 CST\n         DC    H'3840,15,0,1,15,13275'  (NOT YET ANNOUNCED 5/81)    CST\n         SPACE 5\n         DC    X'00'                   END OF TABLE\n         SPACE 6\n* BUFFER FOR JOB FILE CONTROL BLOCK:\n         SPACE\n         DS    0D\nJFCB     DS    CL176\n         SPACE 2\n* PDS DIRECTORY BLOCK BUFFER:\n         SPACE\nPDSBUF   DS    1D              KEY\nPDSLRECL DS    1H              LOGICAL RECORD LENGTH\nPDSDATA  DS    CL254           DATA\n         SPACE 2\n* WORK AREA FOR 'OBTAIN' MACRO:\n         SPACE\n         ORG   PDSBUF                  OVERLAPS PDS DIRECTORY BUFFER\nOBWORK   DS    0D                      'OBTAIN' WORK AREA\n         DS    350C\n         SPACE 2\n*************************************************************\n*   PDSDCB RELOCATED HERE TO ALLOW FOR MORE SPACE WITHIN    *\n*   THE FIRST @ BASE REGISTER AREA....                      *\n*************************************************************\n         SPACE\nPDSDCB   DCB   DSORG=PS,                                               X\n               MACRF=R,                                                X\n               DDNAME=VOLUME01,                                        X\n               DEVD=DA,                                                X\n               RECFM=F,                                                X\n               KEYLEN=8,                                               X\n               BLKSIZE=256,                                            X\n               EODAD=PDSEODAD,                                         X\n               SYNAD=PDSSYNAD,                                         X\n               EXLST=JFCBADR\n         SPACE 2\n* MISCELLANEOUS.\n         SPACE\nDSNJFCB  DS    CL44\nTRK0NAME DC    CL44'VOLUME LABEL'\nVTOCNAME DC    CL44'VOLUME TABLE OF CONTENTS **VTOC**VTOC**VTOC*'\nREVMSG   DC    C'VERSION 4.0, MAY 1981 -- UCLA/OAC -- ( SUPPORT FOR INDX\n               EXED VTOCS )'                                      CST\nDS5WARN  DC    C'*******WARNING--BOS FLAG IS ON; FORMAT 5 DSCB''S MAY NX\n               OT REFLECT TRUE STATUS OF AVAILABLE TRACKS'\nGMFMSG   DC    C'*******INSUFFICIENT CORE TO HOLD ENTIRE VTOC; GOING ONX\n                TO NEXT VOLUME'\n         SPACE 3\nDSORGTAB DS    0H\n         DC    C'IS',AL1(ISDSORG)\n         DC    C'DA',AL1(DADSORG)\n         DC    C'PS',AL1(PSDSORG)\n         DC    C'PO',AL1(PODSORG)\n         DC    C'U ',AL1(X'01')\nDSORGEND EQU   ((*-DSORGTAB)/3)\n         EJECT\n***********************************************************         CST\n*              INDEXED VTOC INTERFACE                     *         CST\n***********************************************************         CST\n         DC    0F'0'                                                CST\n         USING GENESIS,RBASE1,RBASE2                                CST\n         USING *,R15                                                CST\nIXSUB1   XC    IXWORD,IXWORD           FIRST ENTRY                  CST\n         DROP  R15                                                  CST\nIXSUB2   BALR  R8,0                    SUBSEQUENT ENTRIES           CST\n         USING *,R8                                                 CST\n         ST    RRET,IXSAVE14                                        CST\n         ST    RDS5,IXFMT5             AREA FOR FMT5                CST\n         LA    R1,IXPARM               POINT TO PARMLIST            CST\n         L     R15,IXVCON              POINT TO ROUTINE             CST\n         BALR  RRET,R15                CALL INTERFACE ROUTINE       CST\n         L     RRET,IXSAVE14           RESTORE R14                  CST\n         C     R15,IXFOUR              INTERPRET RETURN CODE        CST\n         BLR   RRET                    RC=0  WORKED OK              CST\n         BE    4(RRET)                 RC=4  NOT INDEXED VTOC       CST\n         EX    0,*                     RC>4  SOME ERROR             CST\n         SPACE 4                                                    CST\nIXPARM   DC    A(IXWORD)               WORK WORD                    CST\n         DC    V(VTOCDCB)              OPEN DCB                     CST\n         DC    A(IXCT1)                COUNT OF FREE DSCBS          CST\n         DC    A(IXCT2)                COUNT OF FREE VIRS           CST\nIXFMT5   DC    A(0)                    PTR TO PSUEDO FMT5           CST\n         SPACE 2                                                    CST\nIXWORD   DC    F'0'                                                 CST\nIXCT1    DC    F'0'                                                 CST\nIXFRDSCB EQU   IXCT1+2                                              CST\nIXCT2    DC    F'0'                                                 CST\n         SPACE 2                                                    CST\nIXSAVE14 DC    F'0'                                                 CST\nIXVCON   DC    V(IXTOFMT5)                                          CST\nIXFOUR   DC    F'4'                                                 CST\nIXHEAD   DC    C'VTOC FORMAT IS INDEXED.  FREE VIRS='               CST\nIXHEADL  EQU   *-IXHEAD                                             CST\n         DROP  RBASE1,RBASE2,R8                                     CST\n         EJECT\n***********************************************************\n*       CATALOG READ ROUTINE FOR CATALOG USAGE.           *\n***********************************************************\n         DC    0F'0' GET SOME DECENT ALIGNMENT\n         USING GENESIS,RBASE1,RBASE2   GET SOME DECENT ADDRESSA\n         USING *,R15\nCATLGCK  STM   RRET,R12,12(RSAVE)\n         B     AROUNDSA\n         DC    CL8'CATLGCK'\nCATCKSA  DC    18F'0'\nAROUNDSA DS    0H\n         LR    RLCLBASE,R15\n         LR    R7,RSAVE   PRESERVE GUYS SAVE AREA POINTER\n         DROP  R15\n         USING CATLGCK,RLCLBASE\n         ST    RSAVE,CATCKSA+4  FORWARD CHAIN\n         LA    RSAVE,CATCKSA   GET OUR OWN SAVE AREA\n         ST    RSAVE,8(,R7)    BACKWARD CHAIN\n         SPACE 5\nREADVICE MVC   TTR,=X'000001'               *ADDR OF FIRT BLOCK\n         LOCATE INDEXBLK   READ 1ST BLOCK OF CATALOG\n*  INSERT ERROR CHECKING ROUTINES HERE\n         SPACE 10\n         LA    R7,BLKAREA+2           *POINT TO V.I.C.E.\n         USING DS4,RDS4\n         L     RDS4,FMT4ADDR   POINT AT VOLUME DESCRIPTION\n         SR    R3,R3   CLEAR WORK REG\n         IC    R3,DS4DEVDB   GET NUMBER OF DIRECTORY BLOCKS/TRACK\n         LH    RWK4,16(R7)           TT (FROM TTR) OF 1ST AVAIL BLOCK\n         MR    RWK3,R3   TOTAL NUMBER OF BLOCKS IN RWK4 (RWK3+1)\n*   RWK3 IS CLEARED TO ZERO BY ABOVE -- PLEASE MAKE A NOTE...\n         IC    RWK3,18(R7)             *R OF 1ST AVAILABLE BLK\n         AR    RWK4,RWK3                    *TOTAL NO OF BLKS USED+1\n         BCTR  RWK4,0                        *DECREMENT BY ONE\n         CVD   RWK4,BLKSUSED\n         OI    BLKSUSED+7,X'0F'             *CHANGE SIGN\n         UNPK  F1DSORG+9(4),BLKSUSED    *MOVE BLKS USED TO PRINT\n         MVC   F1DSORG-1(10),=C'BLKS USED='\n         MVC   F1DSORG+13(2),=8C' ' BLANK OUT MIDDLE GROUND\n* STATUS: RWK4(R5)=BLKS USED, RWK3(R4)=R NO.,R3=DS4DEVDB\n         LH    RWK1,12(R7)             *LAST TT OF CATALOG\n*  NOTE THAT RWK3 IS ZEROES EXCEPT FOR LAST BYTE\n         IC    RWK3,14(R7)             *LAST R\n         MR    RWK1,RWK1   R3 WILL HAVE TOT NO. OF BLOCKS\n*  NOTE: MR OPERATES ON R1+1 AND R2, GIVING PRODUCT IN R1+R2 COMBINED\n         AR    RWK3,R3      *TOTAL NO OF BLOCKS IN CATLG\n         SR    RWK3,RWK4                    *BLKS LEFT\n         CVD   RWK3,BLKSUSED\n         OI    BLKSUSED+7,X'0F'             *CHANGE SIGN\n         MVC   F1OPTCD-10(10),=C'BLKS AVAL='\n         UNPK  F1OPTCD(4),BLKSUSED   *MOVE BLKS LEFT TO PRINT\n         L     RSAVE,CATCKSA+4\n         RETURN (14,12),T,RC=(15)\n         SPACE 10\nBLKSUSED DC    D'0'\nINDEXBLK CAMLST BLOCK,TTR,VOLUME,BLKAREA\n         DS    0H\nTTR      DS    CL3\nBLKAREA  DS    0D\n         DS    265C\n*     ****** MUCHO SPACE ******\n         LTORG *\n         DS    C              INDICATE WHERE IT ALL ENDS...\n         DROP RBASE1,RBASE2,RLCLBASE\n         EJECT\n***********************  EXIT ROUTINE FOR OPEN ERROR **************  MS\nOPENERR  DS    0H                                                    MS\n         MVI   3(R1),X'04'    SET ON BIT TO IGNORE ERROR SO THE      MS\n*                             MAINLINE CODE CAN ISSUE A MSG TO USER  MS\n         BR    RRET           RETURN                                 MS\n TITLE 'DIRECT-ACCESS DIRECTORY LISTER                  DUMMY SECTIONS'\n* DUMMY SECTION TO DEFINE TRACK MAP ENTRY\n         SPACE 2\n*              *************************\n*              *                       *\n*            0 * ADDRESS OF NEXT ENTRY *\n*              *                       *\n*              *************************\n*              *                       *\n*            4 *        CC HH 1        *\n*              *                       *\n*              *************************\n*              *                       *\n*            8 *        CC HH 2        *\n*              *                       *\n*              *************************\n*              *           *     *     *\n*           12 * NUMB TRKS * EXT * NU  *\n*              *           *     *     *\n*              *************************\n*              *                       *\n*           16 *   ADDRESS OF DSNAME   *\n*              *                       *\n*              *************************\n*              *           *           *\n*           20 *  TTREL 1  *  TTREL 2  *\n*              *           *           *\n*              *************************\n         SPACE 2\nMB       DSECT\nMBCHAIN  DS    F\nMBCCHH1  DS    F\nMBCCHH2  DS    F\nMBNTRKS  DS    H\nMBEXT    DS    CL1\n         DS    CL1\nMBNAME   DS    F\nMBTTREL1 DS    H\nMBTTREL2 DS    H\n         SPACE\nMBSIZE   EQU   *-MB\n         SPACE\nFBCHAIN  EQU   MBCHAIN-MB\nFBCCHH1  EQU   MBCCHH1-MB\nFBCCHH2  EQU   MBCCHH2-MB\nFBNTRKS  EQU   MBNTRKS-MB\nFBEXT    EQU   MBEXT-MB\nFBNAME   EQU   MBNAME-MB\nFBTTREL1 EQU   MBTTREL1-MB\nFBTTREL2 EQU   MBTTREL2-MB\n         EJECT\n* DUMMY SECTION TO DEFINE PDS DIRECTORY ITEM\n         SPACE 2\n*              *************************\n*              *                       *\n*            0 *                       *\n*              *      MEMBER NAME      *\n*            4 *                       *\n*              *                       *\n*              *************************\n*              *                 *     *\n*            8 *       TT R      *  C  *\n*              *                 *     *\n*              *************************\n*              *                       *\n*           12 *       USER DATA       *\n*            . *                       *\n*            . *      0-62 BYTES       *\n*            . *                       *\n*            . *           *************\n*            . *           *\n*           72 *           *\n*              *           *\n*              *************\n         SPACE 2\nDIRBLOCK DSECT\n         SPACE\nDIRNAME  DS    CL8\nDIRTTR   DS    CL3\nDIRC     DS    CL1\nDIRUDATA DS    CL62\n         EJECT\n* DSCB FORMATTING DUMMY SECTIONS\n         SPACE\n* FORMAT 1 DSCB:\n         SPACE\nDS1      DSECT\n         IECSDSL1  1\nDS1FDAD  DS    CL8\nDS1CHAIN DS    F\nDS1NXTF1 DS    F\n         SPACE\nDS1SIZE  EQU   *-DS1\n         SPACE\nFM1NXTF1 EQU   DS1NXTF1-DS1\nFM1DSNAM EQU   DS1DSNAM-DS1\n         EJECT\n* FORMAT 2 DSCB:\n         SPACE\nDS2      DSECT\n         IECSDSL1  2\nDS2FDAD  DS    CL8\n         SPACE\nDS2SIZE  EQU   *-DS2\n         EJECT\n* FORMAT 3 DSCB:\n         SPACE\nDS3      DSECT\n         IECSDSL1  3\nDS3FDAD  DS    CL8\nDS3CHAIN DS    F\n         SPACE\nDS3SIZE  EQU   *-DS3\n         EJECT\n* FORMAT 4 DSCB:\n         SPACE\nDS4      DSECT\nDS4DSNAM DS    11F\n         IECSDSL1  4\nDS4FDAD  DS    CL8\n         SPACE\nDS4SIZE  EQU   *-DS4\n         EJECT\n* FORMAT 5 DSCB:\n         SPACE\nDS5      DSECT\n         IECSDSL1  5\nDS5FDAD  DS    CL8\nDS5CHAIN DS    F\n         SPACE\nDS5SIZE  EQU   *-DS5\n         EJECT\n* DCB FIELD DEFINING DUMMY SECTION\n         SPACE 2\n         DCBD  DSORG=PS,DEVD=DA\n         EJECT\n* JOB FILE CONTROL BLOCK DUMMY SECTION\n         SPACE 2\nJFDUMMY  DSECT\n         IEFJFCBN\n         EJECT\n* TASK I/O TABLE (TIOT) DEFINING DUMMY SECTION:\n         SPACE 2\nTIOT     DSECT\n         IEFTIOT1\n         SPACE 6\n         END   VTOCLIST\nXPRT     TITLE 'XPRNTSUB - GENERAL PRINTING SUBROUTINE'\n         SPACE\n* FUNCTION/OPERATION:  THIS IS A GENERAL PRINTING SUBROUTINE TO MANAGE\n*        THE DETAILS OF PAGINATION, HEADINGS, AND OUTPUT COMPRESSION\n*        FOR PRINTED OUTPUT.  IT IS INVOKED FROM A PROBLEM PROGRAM VIA\n*        THE MACRO 'XPRNT', WHICH HAS THE FOLLOWING CALL MODES:\n*           OPEN - INITIALIZES PAGE SIZE PARAMETERS AND MAXIMUM NUMBER\n*              OF OUTPUT LINES, RESETS PAGE NUMBER, CLEARS HEADING\n*              LINES AND INSERTS CURRENT DATE AND TIME, INSERTS DDNAME\n*              IN DCB, AND OPENS THE DATA SET.\n*           MODIFY - ALTERS ANY OR ALL OF THE PARAMETERS LISTED UNDER\n*              'OPEN' EXCEPT THE DDNAME.\n*           SETHEAD - SUPPLIES TEXT FOR ONE OR MORE LINES TO BE USED\n*              PAGE HEADINGS.\n*           PRINT - DELIVERS ONE OR MORE LINES TO BE PRINTED.\n*           SPACE - MOVES THE PAGE VERTICALLY A GIVEN NUMBER OF LINES.\n*           EJECT - CONDITIONAL OR UNCONDITIONAL SKIP TO HEAD-OF-FORM.\n*           CLOSE - CLOSES THE DATA SET.\n         SPACE\n* ENTRY POINTS:  EACH MODE HAS A SEPARATE ENTRY AT A FIXED OFFSET FROM\n*        THE BASE ADDRESS.  ENTRYS ARE EFFECTED BY A  BAL  14,D(15)\n*        (WHERE D IS A DISPLACEMENT WHICH SELECTS THE DESIRED MODE) AND\n*        ASSUMES THAT REGISTER 13 ADDRESSES A STANDARD 18-WORD SAVE\n*        AREA.\n         SPACE\n* INPUT:  ON ENTRY, REG 0 POINTS TO A WORK AREA FOR THE DATA SET, WHICH\n*        IS DESCRIBED IN THIS CODING BY THE DUMMY SECTION 'WORKAREA'.\n*        REG 1 POINTS TO A PARAMETER LIST OF A FORM APPROPRIATE TO THE\n*        CALL MODE.  THESE LISTS ARE EITHER DESCRIBED BY DUMMY SECTIONS\n*        OR ARE STANDARD VARIABLE-LENGTH ADDRESS LISTS.\n         SPACE\n         SPACE\n* OUTPUT:  PRINT LINES AND SPACE CONTROL RECORDS ARE DELIVERED VIA QSAM\n*        TO A SEQUENTIAL DATA SET.  EACH LINE IS REDUCED TO ITS MIN-\n*        IMUM LENGTH BY TRUNCATING TRAILING BLANKS.\n         SPACE\n* DATA SETS:  THE OUTPUT DATA SET IS SEQUENTIAL, ARRANGED FOR BLOCKED\n*        FORMAT V RECORDS USING MACHINE CONTROL CHARACTERS APPROPRIATE\n*        TO 1403 OR 1404 PRINTERS.  THE DDNAME IS SUPPLIED BY THE\n*        'OPEN' CALL; THE STANDARD VALUE IS 'SYSPRINT'.\n         SPACE\n* EXTERNAL ROUTINES:  CALLS 'XDATEDIT' TO FORMAT THE DATE FOR THE\n*        PAGE HEADING LINE.\n         SPACE\n* EXITS - NORMAL:  RETURNS VIA REG 14 WITH RETURN CODE 0 IN REG 15.\n*        THE CURRENT PAGE NUMBER (IN BINARY) IS IN REG 0 AND THE BINARY\n*        NUMBER OF LINES REMAINING ON THE CURRENT PAGE IS IN REG 1.\n*        IF AN OPEN CALL CANNOT OPEN THE DCB, THE RETURN CODE IS 4.\n         SPACE\n* EXITS - ERROR:  ERRONEOUS CALLS RESULT IN AN 'ABEND' WITH ONE OF THE\n*        FOLLOWING COMPLETION CODES:\n*           4000 - ROUTINE WAS ILLEGALLY ENTERED AT ITS BASE ADDRESS.\n*           4002 - A CALL MODE OTHER THAN 'OPEN' WAS DIRECTED TO A DATA\n*              SET WHICH WAS NOT OPEN.\n*           4003 - 'OPEN' OR 'MODIFY' SPECIFIED TOO LARGE A PAGE WIDTH.\n*           4004 - 'OPEN' OR 'MODIFY' SPECIFIED TOO LONG A PAGE.\n*           4005 - 'PRINT' OR 'SETHEAD' SPECIFIED A LINE WHOSE TEXT\n*              LENGTH PLUS OFFSET EXCEEDED THE PAGE WIDTH.\n*           4006 - THE MAXIMUM NUMBER OF OUTPUT LINES WAS EXCEEDED.\n*           4007 - SYNCHRONOUS I/O ERROR.\n         SPACE\n* TABLES/WORK AREAS:  THE CALL PARAMETER LISTS, WORK AREA, AND PRINT\n*        LINE DESCRIPTOR BLOCK ARE ALL DESCRIBED BY DUMMY SECTIONS\n*        AT THE END OF THE PROGRAM.\n         SPACE\n* ATTRIBUTES:  REENTRANT, READ-ONLY.  WILL HANDLE ANY NUMBER OF DATA\n*        SETS SIMULTANEOUSLY, USING A SEPARATE WORK AREA FOR EACH.\n         SPACE\n* OPERATING ENVIRONMENT:  RUNS UNDER OPERATING SYSTEM/360, USING\n*        QSAM DATA MANAGEMENT WITH LOCATE-MODE PUT MACROS AND SIMPLE\n*        BUFFERING.  ASSUMES OPTION 6A OR 6B FOR TIME OF DAY.\n         SPACE\n* NOTES:  NONE.\n         EJECT\nXPRNTSUB CSECT\n         SPACE 2\n* REGISTER ASSIGNMENTS:\n         SPACE 2\n* N.B.  REGISTER GROUPS 'RWA,RWB,RWC,RWD' AND 'RLPEXIT,RPARM' MUST BE\n* KEPT IN ORDER FOR LM AND STM ORDERS.\n         SPACE\nRWA      EQU   2               GENERAL WORK REG\nRWB      EQU   3               GENERAL WORK REG\nRWC      EQU   4               GENERAL WORK REG\nRWD      EQU   5               GENERAL WORK REG\nRSPACE   EQU   6               NUMBER OF LINES TO SPACE\nRBAL     EQU   7               NUMBER OF LINES LEFT ON PAGE\nRLPEXIT  EQU   8               EXIT FROM LIST PROCESSING ROUTINE\nRPARM    EQU   9               CALL PARAMETER LIST ADDR\nRPLD     EQU   10              PLD BLOCK BASE\nRWKAREA  EQU   11              BASE REGISTER FOR WORK AREA\nRBASE    EQU   12              BASE REGISTER FOR CODING\nRRET     EQU   14              STANDARD RETURN ADDR\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 3\n* MASKS FOR CONTROL BYTE \"SWITCHES\":\n         SPACE\nHOFBIT   EQU   X'80'           PAGE IS AT PHYSICAL HEAD-OF-FORM\nNOSKBIT  EQU   X'40'           DISALLOW EJECT DURING HEAD PRINTING\nTXT1BIT  EQU   X'20'           ON FOR FIRST TEXT LINE ON PAGE\nHD1BIT   EQU   X'10'           ON FOR FIRST HEAD LINE WITH PAGE NO, ETC\nSP0BIT   EQU   X'08'           LAST LINE SPACED 0\n         SPACE 2\nEJFORCE  EQU   255             SPACING QUANTITY TO FORCE PAGE EJECT\nOPENBIT  EQU   X'10'           TO TEST 'DCBOFLGS' FOR SUCCESSFUL OPEN\nMAXLNGTH EQU   254             MAXIMUM PAGE LENGTH\nMAXWIDTH EQU   132             MAXIMUM PAGE WIDTH\nDEFBLKSZ EQU   1692            DEFAULT DCB BLOCK SIZE\n         EJECT\n**********************\n* ENTRY AND PROLOGUE *\n**********************\n         SPACE\n* ENTER FROM THE CALLING SEQUENCE VIA THE INSTRUCTION \"BAL 14,X(0,15)\".\n* REGISTER 15 IS SET TO THE BASE OF THE ROUTINE AND THE DISPLACEMENT\n* \"X\" SELECTS THE ENTRY POINT.  EACH ENTRY SAVES REGISTERS, LOADS THE\n* ADDRESS OF THE APPROPRIATE SUBROUTINE, AND GOES TO A COMMON\n* PROLOGUE.  NOTE THAT AN ATTEMPT TO ENTER AT THE BASE RESULTS IN\n* AN ABEND.\n         SPACE 2\nBASEADDR B     20(0,R15)               BRANCH AROUND MODULE IDENTIFIER\n         DC    AL1(15)                 LENGTH OF IDENTIFIER\n         DC    CL15'XPRNTSUB-028214'\n         STM   R14,R12,12(R13)         SAVE CALLER'S REGISTERS\n         SR    R1,R1                   SET ABEND COMPLETION CODE\n         LR    RBASE,R15               SET BASE REG FOR ABEND ROUTINE\n         USING BASEADDR,RBASE\n         B     ABEND\n         DROP  RBASE\n         SPACE 2\n* ENTRY POINTS FOR VARIOUS FUNCTIONS, AT 12-BYTE INTERVALS BEGINNING\n* AT BASEADDR+32.  EACH LOADS \"RWA\" WITH THE ADDRESS OF THE SUBROUTINE\n* TO GO TO AFTER EXECUTING \"PROLOGUE\".\n         SPACE\n         ORG   XPRNTSUB+32\n         USING BASEADDR,R15\n         SPACE\nPRENTRY  STM   R14,R12,12(R13)         PRINT\n         LA    RWA,PRPROC\n         B     PROLOGUE\nSPENTRY  STM   R14,R12,12(R13)         SPACE\n         LA    RWA,SPPROC\n         B     PROLOGUE\nOPENTRY  STM   R14,R12,12(R13)         OPEN\n         LA    RWA,OPPROC\n         B     PROLOGUE\nCLENTRY  STM   R14,R12,12(R13)         CLOSE\n         LA    RWA,CLPROC\n         B     PROLOGUE\nSHENTRY  STM   R14,R12,12(R13)         SETHEAD\n         LA    RWA,SHPROC\n         B     PROLOGUE\nEJENTRY  STM   R14,R12,12(R13)         EJECT\n         LA    RWA,EJPROC\n         B     PROLOGUE\nMDENTRY  STM   R14,R12,12(R13)         MODIFY\n         LA    RWA,MDPROC\n         B     PROLOGUE\n         SPACE 2\n* PROLOGUE.  SET UP BASE REGISTERS FOR CODING AND WORK AREA.  CHAIN\n* SAVE AREAS IN STANDARD FASHION.  LOAD \"RBAL\" WITH CURRENT PAGE\n* BALANCE AND \"RPARM\" WITH THE CALLING PARAMETER LIST ADDRESS.\n         SPACE\nPROLOGUE LR    RBASE,R15               LOAD CODING BASE REG\n         USING BASEADDR,RBASE\n         DROP  R15\n         SPACE\n         LR    RWKAREA,R0              BASE REG FOR WORK AREA\n         USING WORKAREA,RWKAREA\n         SPACE\n         LR    RWB,R13                 ADDR OF CALLER'S SAVE AREA\n         LA    R13,SAVEAREA            ADDR OF OUR SAVE AREA\n         ST    R13,8(RWB)              CHAIN TO US FROM CALLER\n         ST    RWB,SAVEAREA+4          CHAIN TO CALLER FROM US\n         SPACE\n         LR    RPARM,R1                LOAD PARAMETER LIST ADDR\n         LH    RBAL,PAGEBAL            LOAD PAGE LINE COUNT BALANCE\n         MVC   DCBSYNAD(3),=AL3(SYNAD) PUT ERROR ROUTINE ADDRESS IN DCB\n         SPACE\n         TM    DCBOFLGS,OPENBIT        MAKE SURE DATA SET IS OPEN\n         BCR   1,RWA                   BRANCH IF OPEN\n         CL    RWA,=A(OPPROC)          IF NOT, ONLY OPEN CALL ALLOWED\n         BCR   8,RWA                   BR IF OPEN CALL\n         LA    R1,2                    ERROR CODE 2, GO TO ABEND\n         SPACE 3\n* ABEND ROUTINE FOR SERIOUS ERRORS.  ENTER WITH ERROR NUMBER IN R1.\n* ADD DECIMAL 4000 FOR USER CONPLETION CODE AND ISSUE 'ABEND' WITH DUMP\n         SPACE\n         CNOP  2,4                     ALIGN CONSTANT FOLLOWING SVC\nABEND    AL    R1,*+6                  LOAD ABEND CODES\n         SVC   13                      ISSUE ABEND SVC\n         DC    X'80'                   'DUMP' BIT FOR ABEND\n         DC    AL3(4000)               BASE FOR COMPLETION CODE\n         EJECT\n************\n* EPILOGUE *\n************\n         SPACE\n* ALL MODES RETURN TO THE CALLER VIA THIS ROUTINE.  IT EXITS WITH\n* THE RETURN CODE IN REGISTER 15, THE PAGE NUMBER IN REGISTER 0, AND\n* THE NUMBER OF LINES REMAINING ON THE PAGE IN REGISTER 1.\n         SPACE 2\nEXIT4    LA    R15,4                   SET RETURN CODE 4\n         B     EXIT\n         SPACE\nEXIT0    SR    R15,R15                 SET RETURN CODE 0\n         SPACE\nEXIT     LH    R0,PAGENO               LOAD CURRENT PAGE NUMBER\n         LR    R1,RBAL                 LOAD NUMBER OF LINES LEFT\n         STH   RBAL,PAGEBAL            SAVE PAGE BALANCE\n         XC    DCBSYNAD(3),DCBSYNAD    CLEAR ERROR ROUTINE ADDRESS\n         SPACE\n         L     R13,SAVEAREA+4          ADDRESS OF CALLER'S SAVE AREA\n         L     R14,12(R13)             LOAD RETURN ADDRESS\n         LM    R2,R12,28(R13)          RESTORE CALLER'S REGISTERS\n         MVI   12(R13),X'FF'           SET RETURN INDICATION\n         BR    R14                     RETURN TO CALLER\n         EJECT\n******************\n* PRINT FUNCTION *\n******************\n         SPACE\n* PRINT LINE DELIVERY CALL.  THE PARAMETER LIST IS A VARIABLE-LENGTH\n* LIST OF ADDRESSES, THE LAST OF WHICH IS NEGATIVE (I.E. BIT 0 IS A 1).\n* EACH ADDRESS POINTS TO A PLD DESCRIBING A LINE TO BE PRINTED.  CALL\n* THE GENERAL LIST PROCESSING ROUTINE TO DO THE DIRTY WORK.\n         SPACE 2\nPRPROC   BAL   RLPEXIT,LISTPROC        INVOKE LIST PROCESSOR\n         SPACE\n         B     EXIT0                   EXIT TO CALLER\n         EJECT\n******************\n* SPACE FUNCTION *\n******************\n         SPACE\n* CALL TO MOVE THE PAPER A SPECIFIED NUMBER OF LINES.  IF THE NUMBER\n* OF LINES EXCEEDS THE CURRENT PAGE BALANCE, AN EJECT RESULTS, UNLESS\n* SUPPRESSED BY THE 'SPNOEJ' BIT IN THE PARAMETER LIST.  IF THE PAGE\n* IS AT HEAD-OF-FORM, SPACING IS SUPPRESSED UNLESS THE 'SPATHOF' BIT\n* IS SET IN THE PARAMETER LIST.  IN THE LATTER CASE, THE PAGE HEADINGS\n* WILL BE PRINTED BEFORE THE SPACING IS EXECUTED.\n         SPACE 2\n         USING SPPARM,RPARM            ADDRESSING FOR PARM LIST\n         SPACE\nSPPROC   TM    SWITCHES,HOFBIT         TEST IF AT HEAD-OF-FORM\n         BZ    SPSUBTR                 BR IF NOT\n         TM    SPCOND,SPATHOF          IS SPACE ALLOWED AT HOF?\n         BZ    EXIT0                   EXIT IF NOT\n         BAL   RRET,HEADPRNT           IF SO, PRINT HEADINGS FIRST\n         SPACE\nSPSUBTR  SR    RSPACE,RSPACE\n         IC    RSPACE,SPQUAN           LOAD SPACING AMOUNT\n         SR    RBAL,RSPACE             COMPUTE NEW PAGE BALANCE\n         SPACE\n         BP    SPMOVE                  BRANCH IF BAL STILL > 0\n         TM    SPCOND,SPNOEJ           TEST IF EJECT ALLOWED\n         BO    SPMOVE                  BRANCH IF NOT\n         LA    RSPACE,EJFORCE          IF ALLOWED, FORCE EJECT\n         SPACE\nSPMOVE   BAL   RWA,MOVE                CALL PAPER MOVING SUB\n         B     EXIT0                   EXIT TO CALLER\n         SPACE\n         DROP  RPARM\n         EJECT\n******************\n* EJECT FUNCTION *\n******************\n         SPACE\n* CALL TO MOVE THE PAPER TO HEAD-OF-FORM.  IF THE PAGE IS ALREADY\n* THERE, THE EJECT IS NOT EXECUTED UNLESS THE 'EJATHOF' BIT IN THE\n* PARAMETER LIST IS ON.  IN THE LATTER CASE, A SKIP IS EXECUTED WITHOUT\n* PRINTING ANY HEADINGS, RESULTING IN A BLANK PAGE.  IF THE MASK BITS\n* IN THE 'EJCOND' PARAMETER ARE NOT ALL ONES, A CONDITIONAL EJECT IS\n* REQUESTED.  THE PAGE BALANCE IS COMPARED AGAINST THE TEST QUANTITY\n* 'EJQUAN' IN THE PARAMETER LIST, THEN THE DECISION TO EJECT OR NOT\n* IS MADE WITH A 'BC' ORDER USING THE 'EJCOND' BITS AS A MASK.\n         SPACE 2\n         USING EJPARM,RPARM            FOR PARM LIST ADDRESSING\n         SPACE\nEJPROC   TM    SWITCHES,HOFBIT         TEST IF AT HOF\n         BZ    EJTEST                  BR IF NOT\n         TM    EJCOND,EJATHOF          IF SO, IS EJECT ALLOWED?\n         BZ    EXIT0                   IF NOT, EXIT\n         SPACE\nEJTEST   SR    R0,R0\n         IC    R0,EJQUAN               LOAD TEST QUANTITY\n         IC    R1,EJCOND               GET CONDITIONAL TEST MASK\n         N     R1,=XL4'000000F0'       KEEP BITS 24-27 ONLY\n         CR    RBAL,R0                 COMPARE BALANCE WITH TEST QUAN\n         EX    R1,EJBC                 EXECUTE BC WITH MASK FROM PARM\n         B     EXIT0                   EXIT IF CONDITION NOT MET\n         SPACE\nEJMOVE   LA    RSPACE,EJFORCE          TO FORCE EJECT\n         BAL   RWA,MOVE                CALL PAPER MOVER SUB\n         B     EXIT0                   EXIT TO CALLER\n         SPACE 2\nEJBC     BC    0,EJMOVE                BRANCH IF EJECT REQUIRED\n         SPACE\n         DROP  RPARM\n         EJECT\n*****************\n* OPEN FUNCTION *\n*****************\n         SPACE\n* THIS MUST BE THE FIRST CALL FOR A NEW DATA SET.  IT SETS THE DDNAME\n* IN THE DCB AND OPENS THE DATA SET.   ALL COUNTERS AND SWITCHES ARE\n* SET TO THEIR NOMINAL VALUES BEFORE PROCESSING ANY OPTIONS WHICH\n* MAY HAVE BEEN SUPPLIED WITH THE CALL.  THE PAGE BALANCE IS SET TO\n* ZERO, BUT THE PAGE IS NOT MOVED.  THE PROGRAMMER SHOULD NORMALLY\n* ISSUE AN 'EJECT' CALL BEFORE BEGINNING HIS OUTPUT.\n         SPACE\n* IF THE DATA SET IS ALREADY OPEN, THE DDNAME IS IGNORED, THE NOMINAL\n* OPTIONS ARE SET, THEN THIS CALL IS TREATED EXACTLY AS IF IT WERE A\n* 'MODIFY' CALL.\n         SPACE 2\n         USING OMPARM,RPARM\n         SPACE\nOPPROC   MVC   PAPARMS(DEFSIZE),DEFAULTS  SET STANDARD OPTIONS\n         MVI   HLTEXT,C' '             CLEAR HEADING TEXT\n         MVC   HLTEXT+1(HLTXTLNG-1),HLTEXT\n         SPACE\n         TIME  DEC                     GET CURRENT DATE & TIME\n         STM   R0,R1,HPRSAVE           SAVE TIME AND DATE\n         SPACE\n* NOW IF DATA SET IS ALREADY OPEN, GO TO 'MDPROC'.  OTHERWISE, INSERT\n* DDNAME AND OPEN IT.\n         SPACE\n         TM    DCBOFLGS,OPENBIT        TEST IF OPEN\n         BO    OPJOIN                  BR TO 'MDPROC' IF OPEN\n         MVC   DCBDDNAM(8),OMDDNAME    INSERT DDNAME INTO CLOSED DCB\n         MVC   DCBEXLST(3),=AL3(EXLST) INSERT ADDRESS OF EXIT LIST\n         SPACE\n         MVI   DWORK,X'80'             SET END-OF-LIST BIT\n         OPEN  (PRINTDCB,(OUTPUT,LEAVE)),MF=(E,DWORK)\n         SPACE\n         XC    DCBEXLST(3),DCBEXLST    CLEAR ADDRESS OF EXIT LIST\n         TM    DCBOFLGS,OPENBIT        TEST FOR SUCCESSFUL OPEN\n         BO    OPJOIN                  TO 'MDPROC' IF O.K.\n         B     EXIT4                   EXIT WITH RC=4 IF OPEN FAILS\n         SPACE\n         DROP  RPARM\n         EJECT\n* DCB EXIT ROUTINE FOR OPEN.  SET BLOCK SIZE TO THE DEFAULT VALUE IF\n* NOT SPECIFIED IN DS LABEL OR DD CARD.\n         SPACE\nEXLST    DS    0F                      EXIT LIST, ON BOUNDARY\n         DC    X'85'\n         DC    AL3(DCBMOD)\n         SPACE\nDCBMOD   LH    RWA,DCBBLKSZ            LOAD BLOCK SIZE\n         LTR   RWA,RWA                 TEST IF ZERO\n         BNZ   DCBNZ                   BRANCH IF NOT ZERO\nSETDEF   LA    RWA,DEFBLKSZ            SET DEFAULT BLOCK SIZE\n         STH   RWA,DCBBLKSZ            STORE IN DCB\n         BR    R14                     RETURN TO OPEN ROUTINE\nDCBNZ    CH    RWA,=H'141'             TEST FOR MINIMUM BLOCKSIZE\n         BL    SETDEF                  USE DEFAULT IF TOO LOW\n         BR    R14                     RETURN TO OPEN IF OK\n         EJECT\n*******************\n* MODIFY FUNCTION *\n*******************\n         SPACE\n* THIS CALL MAY ALTER ANY  OR ALL OF THE FOLLOWING: DATE, TIME, PAGE\n* NUMBER, PAGE LENGTH, PAGE WIDTH, MAXIMUM NUMBER OF OUTPUT LINES.\n* THE NEW VALUES ARE PRESENTED IN A PARAMETER LIST.  IF A PARAMETER IS\n* ZERO, THE CORRESPONDING QUANTITY IS NOT ALTERED.\n         SPACE\n* THE DATE AND TIME FIELDS MAY BE SUPPLIED BY THE 'OPEN' ROUTINE,\n* WHICH JOINS THIS CODING AT 'OPJOIN'.  IN THAT CASE, THE VALUES\n* INSERTED BY 'OPEN' ARE USED UNLESS OVERRIDDEN BY THE PARAMETER LIST.\n         SPACE\n         USING OMPARM,RPARM\n         SPACE\nMDPROC   SR    R0,R0                   GENERATE TWO ZERO WORDS\n         SR    R1,R1\n         STM   R0,R1,HPRSAVE           SET DATE & TIME FIELDS TO ZERO\n         SPACE\n* ENTER HERE FROM 'OPEN'.  THE OBJECT OF THE FOLLOWING IS TO GET THE\n* ACTUAL TIME AND DATE (IN PACKED DECIMAL) INTO 'HPRSAVE' AND\n* 'HPRSAVE+4', RESPECTIVELY.  THOSE FIELDS MAY HAVE BEEN FILLED IN BY\n* THE OPEN ROUTINE, OR THEY MAY HAVE BEEN SET TO ZEROS BY 'MDPROC'\n* ABOVE.  NOW WE SEE IF ADDRESSES FOR TIME AND/OR DATE VALUES WERE\n* PROVIDED IN THE PARAMETER LIST, AND TRANSFER THE VALUES IF SO.\n         SPACE\nOPJOIN   LM    RWA,RWB,OMTIMEAD        LOAD TIME & DATE ADDRS FROM PARM\n         LTR   RWA,RWA                 TEST FOR TIME ADDR SUPPLIED\n         BZ    NOTIME                  BRANCH IF ZERO\n         MVC   HPRSAVE(4),0(RWA)       GET TIME AS DECIMAL 'HHMMSSTH'\nNOTIME   LTR   RWB,RWB                 TEST IF DATE ADDR SUPPLIED\n         BZ    DATEEDIT                BR IF NOT\n         MVC   HPRSAVE+4(4),0(RWB)     GET DECIMAL DATE AS '00YYDDD+'\n         SPACE\n* IF THE DATE VALUE IS NOT ZERO, EDIT INTO THE HEADING LINE TEXT.  BOTH\n* THE DAY NUMBER AND THE MONTH-DAY-YEAR FORM ARE USED.\n         SPACE\nDATEEDIT LM    RWA,RWB,HPRSAVE         LOAD TIME & DATE FOR TESTING\n         LTR   RWB,RWB                 TEST IF DATE WAS GIVEN\n         BZ    TIMEEDIT                BRANCH IF ZERO\n         SPACE\n         MVC   HLDAY(4),=C'DAY='       INSERT DAY NUMBER\n         UNPK  HLDAY+4(3),HPRSAVE+6(2) UNPACK DAY NUMBER\n         OI    HLDAY+6,X'F0'           TIDY UP SIGN BITS\n         SPACE\n         ST    RWB,DWORK+4             STORE DATE ARG FOR EDIT RTNE\n         LA    R1,DWORK                CONSTRUCT ONE-WORD PARM LIST\n         ST    R1,HPRSAVE+4              FOR XDATEDIT CALL\n         LA    R1,HPRSAVE+4            LOAD PARM LIST ADDRESS\n         L     R15,=V(XDATEDIT)        LOAD ADDRESS OF DATE EDIT RTNE\n         BALR  R14,R15                   TO EDIT DATE AS 'MM/DD/YY'\n         MVC   HLDATE(8),DWORK         INSERT RESULT IN HL TEXT\n         SPACE\n* EDIT TIME IN HOURS AND MINUTES, IF SUPPLIED.\n         SPACE\nTIMEEDIT LTR   RWA,RWA                 TEST IF TIME GIVEN\n         BZ    TSTPGNO                 BR IF ZERO\n         SRL   RWA,4                   ADD LEADING ZERO TO TIME\n         ST    RWA,HPRSAVE             STORE TIME IN WORK LOC\n         MVC   HLTIME(7),=X'402120207A2020'  EDIT CONTROL CHAR\n         ED    HLTIME(7),HPRSAVE       EDIT INTO ALPHA\n         SPACE\n* MODIFY PAGE NUMBER.  VALUE GIVEN IS DECREMENTED BY ONE, SINCE IT IS\n* INCREMENTED BEFORE USE.\n         SPACE\nTSTPGNO  LH    RWA,OMPAGENO            GET VALUE FROM PARM LIST\n         LTR   RWA,RWA                 TEST IF ZERO\n         BZ    TSTPGWID                BR IF ZERO\n         BCTR  RWA,0                   DECREMENT BY 1\n         STH   RWA,PAGENO              STORE\n         SPACE\n* MODIFY PAGE WIDTH, TESTING FOR MAXIMUM ALLOWED.\n         SPACE\nTSTPGWID SR    RWA,RWA\n         IC    RWA,OMPAGWID            GET WIDTH FROM PARM LIST\n         LTR   RWA,RWA                 TEST IF ZERO\n         BZ    TSTPGLNG                BRANCH IF SO\n         CLI   OMPAGWID,MAXWIDTH       TEST MAXIMUM SIZE\n         BNH   PGWIDOK\n         LA    R1,3                    ERROR, TOO LARGE\n         B     ABEND\nPGWIDOK  STH   RWA,PAGWIDTH\n         SPACE\n* MODIFY PAGE LENGTH, TESTING FOR MAXIMUM VALUE.\n         SPACE\nTSTPGLNG SR    RWA,RWA\n         IC    RWA,OMPAGLNG            GET FROM PARM LIST\n         LTR   RWA,RWA                 TEST IF SUPPLIED\n         BZ    TSTMAXLN                BR IF NOT\n         CLI   OMPAGLNG,MAXLNGTH       TEST FOR LEGAL VALUE\n         BNH   PGLNGOK\n         LA    R1,4                    ERROR, ABORT\n         B     ABEND\nPGLNGOK  STH   RWA,PAGELNG             STORE\n         SPACE\n* MODIFY PRINT LINE LIMIT COUNTER.\n         SPACE\nTSTMAXLN L     RWA,OMMAXLIN            GET FROM PARM LIST\n         LTR   RWA,RWA                 TEST IF SUPPLIED\n         BZ    EXIT0                   EXIT IF NOT\n         ST    RWA,MAXLINES            STORE\n         B     EXIT0                   EXIT TO CALLER\n         SPACE\n         DROP  RPARM\n         EJECT\n********************\n* SETHEAD FUNCTION *\n********************\n         SPACE\n* THIS CALL PRESENTS A LIST OF LINES WHICH WILL BE USED AS PAGE HEADING\n* AND SUB-HEADING LINES.  THE PARAMETER LIST IS A VARIABLE-LENGTH LIST\n* OF PLD ADDRESSES, EXACTLY AS FOR 'PRINT' CALLS.  THE FIRST LINE WILL\n* HAVE ADDED TO ITS RIGHT END THE DATE, TIME, AND PAGE NUMBER.\n* HOWEVER, IF ITS LENGTH EXCEEDS 98 BYTES, IT WILL OVERLAY THOSE\n* FIELDS.  THE SECOND AND SUBSEQUENT LINES WILL BE PRINTED NORMALLY.\n* NOTE THAT THESE LINES ARE NOT PRINTED WHEN THE PAGE IS EJECTED, BUT\n* WHEN THE LINE WHICH WILL BE FIRST ON THE NEW PAGE IS DELIVERED, THUS\n* ALLOWING THE HEADINGS TO BE ALTERED AFTER DELIVERY OF THE LAST LINE\n* ON THE PRECEDING PAGE.  THE ADDRESS OF THE PARAMETER LIST IS SAVED\n* BY THE PRINTING ROUTINE, BUT THE PARAMETER LIST, THE PLD'S TO WHICH\n* IT POINTS, AND THE LINE TEXTS TO WHICH THEY POINT, MUST BE PRESERVED\n* BY THE PROBLEM PROGRAM FOR AS LONG AS THEY ARE IN USE, SINCE THEY\n* ARE REFERRED TO AT THE BEGINNING OF EACH NEW PAGE.  EACH CALL TO\n* TO 'SETHEAD' SUPERSEDES THE EFFECT OF THE PREVIOUS CALL.  A CALL WITH\n* A PARAMETER LIST ADDRESS OF ZERO INDICATES THAT NO HEADINGS ARE\n* PROVIDED BY THE PROBLEM PROGRAM, AND ONLY THE PAGE NUMBER, DATE, AND\n* TIME WILL BE PRINTED, WITH A STANDARD SPACING OF THREE.\n         SPACE 2\nSHPROC   LTR   RPARM,RPARM             TEST FOR NULL LIST ADDR\n         BNZ   SHOK                    BRANCH IF NON-ZERO\n         LA    RPARM,NOHDLIST          ADDRESS OF PLD FOR BLANK LINE\nSHOK     ST    RPARM,HEADLIST          STORE ADDR OF HEADING PARMS\n         B     EXIT0                   EXIT\n         EJECT\n******************\n* CLOSE FUNCTION *\n******************\n         SPACE\n* THIS CALL CLOSES THE PRINTER DATA SET.  IT DOES NOT MOVE THE PAGE\n* OR ALTER ANY SWITCHES OR VARIABLES EXCEPT THE DCB ITSELF.\n* AFTER CLOSING THE DCB, IT RELEASES THE PRINT BUFFERS.\n         SPACE 2\nCLPROC   TM    DCBOFLGS,OPENBIT        IS DCB OPEN NOW?\n         BZ    EXIT0                   EXIT IF ALREADY CLOSED\n         MVI   DWORK,X'80'             SET END-OF-LIST BIT\n         CLOSE (PRINTDCB,LEAVE),MF=(E,DWORK)\n         SPACE\n         FREEPOOL  PRINTDCB            FREE THE BUFFER CORE\n         SPACE\n         B     EXIT0                   EXIT TO CALLER\n         EJECT\n************\n* LISTPROC *\n************\n         SPACE\n* THIS ROUTINE PROCESSES A LIST OF PLD ADDRESSES, FORMATTING EACH PRINT\n* LINE AND PERFORMING THE NECESSARY PRE- AND POST-SPACING OPERATIONS.\n* IT IS ENTERED WITH 'RPARM' POINTING TO THE LIST OF ADDRESSES AND\n* 'RLPEXIT' CONTAINING THE EXIT ADDRESS.  IT MAY DISCOVER THAT ITS\n* SPACING OPERATIONS HAVE BROUGHT THE PAGE TO HEAD OF FORM, REQUIRING\n* THAT THE HEADING AND SUB-HEADING LINES BE PRINTED.  WHEN THIS OCCURS,\n* IT BRANCHES TO 'HEADPRNT', WHICH SAVES 'RPARM' AND 'RLPEXIT' AND\n* REENTERS THIS ROUTINE WITH AN ADDRESS LIST FOR THE HEADING LINES.\n* (WHEN THIS SECOND-LEVEL CALL IS MADE, SWITCH 'NOSKPBIT' IS ON,\n* PREVENTING ANY FURTHER PAGE SKIPS AND ELIMINATING THE POSSIBILITY OF\n* YET ANOTHER CALL TO 'HEADPRNT'.)  AFTER THE HEADINGS ARE PRINTED,\n* THE ORIGINAL VALUES ARE RETURNED TO 'RPARM' AND 'RLPEXIT' AND\n* PROCESSING OF THE LIST OF TEXT LINES PROVIDED BY THE CALLER IS\n* CONTINUED.\n         SPACE 2\n         USING PLDBLOCK,RPLD           TO ADDRESS PLD BLOCKS\n         SPACE\nLISTPROC L     RPLD,0(RPARM)           LOAD A PLD BLOCK ADDRESS\n         SPACE\n* IF PAGE IS NOW AT HEAD OF FORM, EXECUTE 'HEADPRNT'.\n         SPACE\n         LA    RRET,LISTPROC           EXIT FROM HEADPRNT STARTS AGAIN\n         TM    SWITCHES,HOFBIT         SEE IF HEAD-OF-FORM FLAG IS ON\n         BO    HEADPRNT                EXIT IF SO\n         SPACE 2\n* TEST WHETHER WE ARE AT THE FIRST TEXT LINE ON A PAGE, AND, IF SO,\n* WHETHER PRE-SPACING IS ALLOWED IN THAT POSITION.  IF NOT, BYPASS\n* PRE-SPACING ALTOGETHER.\n         SPACE\n         TM    SWITCHES,TXT1BIT        TEST IF FIRST TEXT LINE\n         BZ    PRSUBTR                 BRANCH IF NOT\n         TM    PLDFLAGS,PRHOFBIT       TEST IF ALLOW SKIP AT HOF\n         BZ    POSTSP                  SKIP PRESPACING IF NOT\n         SPACE\n* DECREMENT THE PAGE BALANCE BY THE AMOUNT TO BE SPACED.\n         SPACE\nPRSUBTR  SR    RSPACE,RSPACE\n         IC    RSPACE,PLDSPB           LOAD AMOUNT TO SPACE\n         SR    RBAL,RSPACE             DECREMENT PAGE BALANCE\n         SPACE\n* IF SKIPPING IS ALLOWED BY BOTH THE SYSTEM AND THE USER, TEST THE\n* BALANCE AND FORCE A PAGE SKIP IF <= ZERO.\n         SPACE\n         TM    SWITCHES,NOSKBIT        TEST IF SYSTEM ALLOWS SKIP\n         BO    PREMOVE                 BRANCH IF NOT\n         TM    PLDFLAGS,PRSKPBIT       TEST IF USER ALLOWS SKIP\n         BO    PREMOVE                 BRANCH IF NOT\n         LTR   RBAL,RBAL               TEST PAGE BALANCE\n         BP    PREMOVE                 BRANCH IF SOME LINES LEFT\n         LA    RSPACE,EJFORCE          FORCE A PAGE SKIP\n         SPACE\n* MOVE THE PAGE THE NUMBER OF LINES IN 'RSPACE'.\n         SPACE\nPREMOVE  BAL   RWA,MOVE                TO PAPER MOVING SUBROUTINE\n         SPACE\n* IF THAT MOVING PUT US AT HEAD-OF-FORM, PRINT THE HEADINGS.\n         SPACE\n         LA    RRET,LISTPROC           EXIT FROM HEADPRNT STARTS AGAIN\n         TM    SWITCHES,HOFBIT         TEST HEAD-OF-FORM BIT\n         BO    HEADPRNT                EXIT IF AT HEAD\n         SPACE 2\n* NOW CONSIDER THE SPACING TO BE PERFORMED WHEN THE TEXT OF THE LINE\n* IS PRINTED.  BEGIN BY COMPUTING THE NEW PAGE BALANCE.\n         SPACE\nPOSTSP   SR    RSPACE,RSPACE\n         IC    RSPACE,PLDSPA           LOAD AMOUNT TO SPACE AFTER PRINT\n         SR    RBAL,RSPACE             COMPUTE NEW PAGE BALANCE\n         SPACE\n* IF THE SYSTEM AND USER BOTH ALLOW SKIPPING, TEST THE PAGE BALANCE,\n* AND FORCE A SKIP IF <= ZERO.\n         SPACE\n         TM    SWITCHES,NOSKBIT        TEST IF SYSTEM ALLOWS SKIPPING\n         BO    GETPRCC                 BRANCH IF NOT\n         TM    PLDFLAGS,SPSKPBIT       TEST IF USER ALLOWS SKIPPING\n         BO    GETPRCC                 BRANCH IF NOT\n         LTR   RBAL,RBAL               TEST FOR PAGE END\n         BP    GETPRCC                 BRANCH IF SOME LINES LEFT\n         LA    RSPACE,EJFORCE          FORCE PAGE SKIP\n         SPACE\n* NOW CONSTRUCT THE PRINT LINE IN AN OUTPUT BUFFER.  IN THE INTERESTS\n* OF SAVING BUFFER SPACE, THE CALLER'S TEXT IS SCANNED FROM THE RIGHT\n* TO REDUCE ITS NOMINAL LENGTH BY THE NUMBER OF RIGHT BLANKS.  IN THE\n* EXTREME CASE THAT IT IS ENTIRELY BLANK, BYPASS PRINTING ALTOGETHER\n* AND MERELY SPACE.  IF THIS IS TO BE THE FIRST HEADING LINE OF THE\n* PAGE ('HD1BIT' SET), SCANNING IS OMITTED, THE RECORD LENGTH IS SET TO\n* THE PAGE WIDTH, AND THE DATE, TIME, AND PAGE NUMBER ARE INSERTED.\n         SPACE\nGETPRCC  DS    0H\n         SR    RWA,RWA\n         IC    RWA,PLDLNGTH            LOAD NOMINAL LENGTH OF TEXT\n         SR    RWB,RWB\n         IC    RWB,PLDOFFST            LOAD LEFT MARGIN OFFSET\n         SPACE\n         LA    R0,0(RWA,RWB)           LINE LENGTH = TEXT + OFFSET\n         CH    R0,PAGWIDTH             TEST AGAINST PAGE WIDTH\n         BNH   TSTHD1                  BR IF OK\n         LA    R1,5                    ERROR, LINE TOO LONG\n         B     ABEND\n         SPACE\nTSTHD1   TM    SWITCHES,HD1BIT         TEST IF FIRST HEADING LINE\n         BZ    BLNKSCAN                BR IF NOT\n         LH    RWB,PAGWIDTH            SET RECORD LENGTH AS PAGE WIDTH\n         B     GETBUF                  SKIP BLANK SCANNING\n         SPACE\n* SET UP A 'BXH' FOR SCAN.  R0 IS INCREMENT, R1 IS COMPARAND, RWA\n* VARIABLE.\n         SPACE\nBLNKSCAN LH    R0,=H'-1'               INCREMENT IS MINUS 1\n         L     R1,PLDTXTAD-1           LOAD TEXT ADDRESS\n         LA    R1,0(R1)                ZERO HIGH-ORDER BYTE\n         BCTR  R1,0                    DECREMENT BY ONE\n         AR    RWA,R1                  SET RWA TO RIGHT-MOST TEXT BYTE\n         SPACE\n* SCAN THE LINE, SEARCHING FOR FIRST NON-BLANK.  RESULT IS NEW TEXT\n* LENGTH IN RWA, WHICH WILL BE ZERO FOR BLANK LINES.\n         SPACE\nBLNKLOOP CLI   0(RWA),C' '             TEST FOR NON-BLANK CHAR\n         BNE   BLNKDONE                EXIT WHEN FOUND\n         BXH   RWA,R0,BLNKLOOP\nBLNKDONE SR    RWA,R1                  NOW RWA IS NEW TEXT LENGTH\n         BC    13,POSTMOVE             NO PRINTING IF <= 0\n         SPACE\n* NOW ADD OFFSET TO LENGTH OF SURVIVING TEXT TO GET ACTUAL LINE LENGTH.\n         SPACE\n         AR    RWB,RWA                 ADD TEXT LENGTH\n         SPACE\n* NOW RWA IS THE LENGTH OF THE CALLER'S TEXT, AND RWB IS THE LENGTH OF\n* THE LINE.  THE RECORD LENGTH WILL BE FIVE MORE THAT THE LENGTH OF THE\n* LINE, TO INCLUDE FORMAT 'V'  AND PRINTER CONTROL CHARACTERS.  GET\n* A BUFFER OF THE PROPER LENGTH, KEEPING ITS ADDRESS IN R1.\n         SPACE\nGETBUF   LA    RWC,5(RWB)              LOAD LENGTH OF RECORD IN RWC\n         STH   RWC,DCBLRECL            PUT LRECL IN DCB FOR PUT CALL\n         SPACE\n         PUT   PRINTDCB                GET BUFFER ADDRESS IN R1\n         SPACE\n         ST    R1,CCLAST               SAVE LOCATION OF THIS LINE\n         LR    RWD,R1                  RWD BECOMES BUFFER BASE REG\n         MVI   3(RWD),C' '             CLEAR BUFFER TO BLANKS\n         EX    RWB,BLNKMOVE\n         SLL   RWC,16                  SET UP 4-BYTE 'V' CONTROL FIELD\n         ST    RWC,DWORK               CAN'T ASSUME BUFFER ON ANY\n         MVC   0(4,RWD),DWORK            BOUNDARY\n         SPACE\n* IF THIS IS THE FIRST HEADING LINE, INSERT DATE AND TIME, AND EDIT\n* THE PAGE NUMBER.\n         SPACE\n         TM    SWITCHES,HD1BIT         TEST IF FIRST LINE\n         BZ    MOVETEXT                BRANCH IF NOT\n         SPACE\n         LA    RWC,0(RWB,RWD)          ADDRESS RIGHT END -5\n         SH    RWC,=AL2(HLTXTLNG+10-5) LOCATE PLACE FOR HEADING INFO\n         MVC   0(HLTXTLNG,RWC),HLTEXT  INSERT DATE & TIME\n         SPACE\n         LH    R1,PAGENO               INCREMENT PAGE NUMBER\n         LA    R1,1(R1)\n         STH   R1,PAGENO\n         CVD   R1,DWORK                CONVERT TO DECIMAL\n         MVC   HLTXTLNG(10,RWC),=XL10'40404040402020202120'  EDIT CHARS\n         LA    R1,HLTXTLNG+9(RWC)      IN CASE SIGNIFIGANCE FORCED\n         EDMK  HLTXTLNG+4(6,RWC),DWORK+5  EDIT AND MARK SPOT FOR \"PAGE\"\n         SH    R1,=H'5'\n         MVC   0(4,R1),=C'PAGE'        INSERT WORD \"PAGE\"\n         SPACE\n* PUT PRINTER CONTROL CHARACTER AND CALLER'S TEXT INTO THE BUFFER.\n* REGISTER RWA CONTAINS THE LENGTH OF THE TEXT.\n         SPACE\nMOVETEXT BAL   RWB,CCGEN               GO GET CONTROL CHAR\n         STC   R0,4(RWD)               INSERT IN BUFFER\n         NI    4(RWD),B'11111101'      CHANGE SPACE IMMEDIATE TO WRITE\n         SPACE\n         SR    RWB,RWB\n         IC    RWB,PLDOFFST            LOAD LEFT MARGIN OFFSET\n         LA    RWB,5(RWB,RWD)          ADDRESS FOR FIRST TEXT BYTE\n         BCTR  RWA,0                   DECREMENT LENGTH BY 1 FOR MVC\n         L     RWC,PLDTXTAD-1          LOAD ADDRESS OF CALLER'S TEXT\n         EX    RWA,MOVEINST            MOVE TEXT\n         SPACE\n         NI    SWITCHES,255-HD1BIT-TXT1BIT  RESET ONE-SHOT BITS\n         SPACE\n* DECREMENT PRINT LINE LIMIT COUNTER, ABORTING IF IT GOES NEGATIVE.\n         SPACE\n         L     R1,MAXLINES\n         S     R1,=F'1'                BCTR WOULD NOT SET COND CODE\n         ST    R1,MAXLINES\n         BP    POSTMOVE                BRANCH IF POSITIVE\n         LA    R1,6                    ABORT, TOO MUCH OUTPUT\n         B     ABEND\n         SPACE\n* DO ANY ADDITIONAL SPACING NECESSARY.  AMOUNT STILL IN 'RSPACE'.\n         SPACE\nPOSTMOVE BAL   RWA,MOVE                CALL PAPER MOVING SUBROUTINE\n         SPACE 2\n* NOW WE ARE FINISHED WITH THAT LINE.  IF THE ADDRESS WHICH POINTED TO\n* ITS PLD WAS NEGATIVE, THE LIST IS EXHAUSTED AND THE ROUTINE EXITS.\n* OTHERWISE, INCREMENT THE LIST POINTER BY 4 AND START THE NEXT ONE.\n         SPACE\n         LTR   RPLD,RPLD               TEST CURRENT PLD ADDRESS\n         BCR   4,RLPEXIT               EXIT IF NEGATIVE\n         SPACE\n         LA    RPARM,4(RPARM)          INCREMENT LIST POINTER\n         B     LISTPROC                TO PROCESS NEXT LINE\n         SPACE 2\n* EXECUTED INSTRUCTIONS:\n         SPACE\nBLNKMOVE MVC   4(0,RWD),3(RWD)         SPREAD BLANKS IN OUTPUT BUFFER\nMOVEINST MVC   0(0,RWB),0(RWC)         MOVE CALLER'S TEXT TO OUTPUT BUF\n         SPACE\n         DROP  RPLD\n         EJECT\n************\n* HEADPRNT *\n************\n         SPACE\n* ENTER THIS ROUTINE WHEN IT IS DISCOVERED THAT WE ARE AT\n* HEAD-OF-FORM AND ARE ABOUT TO PRINT A LINE.  SAVE THE REGISTERS\n* DEFINING THE STATE OF 'LISTPROC' AND CALL IT WITH A LIST SPECIFYING\n* THE HEADING AND SUB-HEADING LINES.\n         SPACE 2\nHEADPRNT ST    RRET,HPREXIT            SAVE RETURN ADDRESS\n         STM   RLPEXIT,RPARM,HPRSAVE   STORE LISTPROC REGISTERS\n         SPACE\n* RESET HEAD-OF-FORM BIT AND SET NO-SKIP BIT TO SUPPRESS FORM SKIPS\n* AND HEADING LINE BIT TO INCLUDE THE PAGE NUMBER.  RESET PAGE BALANCE.\n         SPACE\n         NI    SWITCHES,255-HOFBIT     RESET HOF BIT\n         OI    SWITCHES,HD1BIT+NOSKBIT SET HEADING AND NOSKIP BITS\n         LH    RBAL,PAGELNG            RESET PAGE BALANCE\n         SPACE\n* LOAD ADDRESS OF HEADINGS LIST AND CALL LIST PROCESSOR.\n         SPACE\n         L     RPARM,HEADLIST          ADDRESS OF HEADINGS LIST\n         BAL   RLPEXIT,LISTPROC        CALL PROCESSING ROUTINE\n         SPACE\n* AFTER PRINTING THE HEADINGS, TURN SYSTEM SKIP-SUPPRESSION BIT OFF\n* AND SET 'TXT1BIT' TO INDICATE THAT THERE ARE NO TEXT LINES ON THE\n* PAGE YET.  THEN RESTORE THE 'LISTPROC' REGISTERS AND RETURN TO\n* PROCESSING THE CALLER'S LINES.\n         SPACE\n         NI    SWITCHES,255-NOSKBIT    RESET NO-SKIP BIT\n         OI    SWITCHES,TXT1BIT        SET FIRST-TEXT-LINE BIT\n         SPACE\n         LM    RLPEXIT,RPARM,HPRSAVE   RESTORE LISTPROC REGISTERS\n         L     RRET,HPREXIT            RECOVER EXIT ADDRESS AND\n         BR    RRET                      RETURN TO CALLER\n         EJECT\n***********************************\n* MOVE - VERTICAL SPACING ROUTINE *\n***********************************\n         SPACE\n* SUBROUTINE TO MOVE THE PAPER BY THE NUMBER OF LINES IN REGISTER\n* 'RSPACE'.  RETURN ADDRESS IS IN 'RWA'.  IF THE CONTROL CHARACTER FOR\n* THE LAST LINE SPACED 0 LINES, REPLACE IT WITH A NEW ONE BEFORE\n* GENERATING ANY EXTRA LINES.\n         SPACE 2\nMOVE     LTR   RSPACE,RSPACE           TEST NUMBER OF LINES TO BE MOVED\n         BCR   13,RWA                  EXIT IF <= ZERO\n         TM    SWITCHES,SP0BIT         DID PREVIOUS LINE SPACE 0?\n         BZ    PREVNOT0                BRANCH IF NOT\n         L     R1,CCLAST               GET ADDRESS OF PREVIOUS LINE\n         BAL   RWB,CCGEN               GENERATE NEW CONTROL CHAR\n         NI    4(R1),X'02'             TEST WRITE/SPACE BIT IN OLD CC\n         STC   R0,4(R1)                STORE NEW CC IN PREVIOUS LINE\n         BNZ   *+8                     BR IF WRITE/SPACE BIT WAS ON\n         NI    4(R1),255-X'02'         TURN WRITE/SPACE BIT OFF\nPREVNOT0 DS    0H\n         MVC   DCBLRECL(2),MOVELINE    SET LOGICAL RECORD LENGTH IN DCB\n         SPACE\n         PUT   PRINTDCB                GET BUFFER ADDRESS IN R1\n         SPACE\n         ST    R1,CCLAST               SAVE LOCATION OF THIS LINE\n         MVC   0(6,R1),MOVELINE        INSERT FORMAT 'V' CONTROL RECORD\n         BAL   RWB,CCGEN               GET PRINT CONTROL CHAR IN R0\n         STC   R0,4(R1)                INSERT IN RECORD\n         SPACE\n         B     MOVE                    LOOP UNTIL 'RSPACE' IS ZERO\n         SPACE 3\nMOVELINE DC    XL6'000600000340'       FORMAT 'V' CONTROL RECORD\n         EJECT\n*****************************************\n* CCGEN - GENERATE PRINTER CONTROL CHAR *\n*****************************************\n         SPACE\n* THIS ROUTINE GENERATES A PRINTER CONTROL CHARACTER TO SPACE OR EJECT\n* IMMEDIATELY (WITHOUT PRINTING).  ENTER WITH THE TOTAL NUMBER OF\n* LINES TO BE MOVED IN 'RSPACE' AND RETURN ADDRESS IN 'RWB'.  EXITS\n* WITH THE CONTROL CHARACTER IN BITS 24-31 OF REGISTER 0 AND THE COUNT\n* IN 'RSPACE' DECREMENTED BY THE AMOUNT WHICH THE CHARACTER WILL SPACE.\n* A SPACE VALUE OF 255 OR GREATER WILL GENERATE AN EJECT CONTROL\n* CHARACTER, SET 'RSPACE' AND 'RBAL' TO ZERO, AND SET THE HEAD-OF-FORM\n* BIT.  NOTE:  MUST NOT USE R1.\n         SPACE 2\nCCGEN    NI    SWITCHES,255-SP0BIT     RESET 'PREVIOUS SPACED 0' BIT\n         CH    RSPACE,=AL2(EJFORCE)    TEST FOR EJECT REQUEST\n         BL    CCNOEJ                  BRANCH IF NOT\n         LA    R0,X'8B'                LOAD 'SKIP TO CHAN 1' CC\n         OI    SWITCHES,HOFBIT         SET HEAD-OF-PAGE BIT\n         SR    RBAL,RBAL               SET PAGE BALANCE TO ZERO\n         SR    RSPACE,RSPACE           SET REMAINING SPACING TO ZERO\n         BR    RWB                     EXIT\n         SPACE\nCCNOEJ   LR    R15,RSPACE              LOAD WORK REGISTER\n         CH    RSPACE,=H'3'            TEST IF OVER THREE LINES\n         BNH   CCOK                    BR IF <= 3\n         LA    R15,3                   SET 3, MAXIMUM FOR 1 OPERATION\nCCOK     SR    RSPACE,R15              DECR RSPACE BY AMOUNT SPACED\n         SLL   R15,3                   PUT AMOUNT IN BITS 2-4 OF BYTE\n         LA    R0,X'03'(R15)           ADD COMMAND BITS AND PUT IN R0\n         LTR   R15,R15                 TEST FOR ZERO SPACING\n         BCR   7,RWB                   EXIT IF NOT ZERO\n         OI    SWITCHES,SP0BIT         SET 'LINE SPACED 0' BIT\n         BR    RWB                     EXIT\n         EJECT\n***********************\n* SYNAD ERROR ROUTINE *\n***********************\n         SPACE\n* IF A PERMANENT I/O ERROR OCCURS, TYPE A DIAGNOSTIC MESSAGE AND ABORT.\n         SPACE\nSYNAD    SYNADAF  ACSMETH=QSAM         GET ERROR MESSAGE FROM O/S\n         LR    RWA,R1                  SAVE MESSAGE ADDRESS\n         GETMAIN  R,LV=128             GET BUFFER FOR MESSAGE\n         MVC   0(LIOMSG,R1),IOMSG      INSERT MESSAGE BEGINNING\n         MVC   LIOMSG(79,R1),49(RWA)   ADD TEXT FROM O/S\n         LR    RWA,R1                  SAVE MESSAGE ADDRESS\n         SYNADRLS                      FREE O/S MESSAGE\n         WTO   MF=(E,(RWA))            TYPE MESSAGE ON CONSOLE\n         LA    R1,7                    LOAD ERROR CODE\n         B     ABEND                   TO ABORT AND DUMP\n         SPACE\nIOMSG    DC    AL2(LIOMSG+78,0)        FORMAT V CONTROL FIELD\n         DC    C'XPRNTSUB I/O ERROR'\nLIOMSG   EQU   *-IOMSG\n         EJECT\n**************************\n* CONSTANTS AND LITERALS *\n**************************\n         SPACE\n* DUMMY PARAMETER LIST AND PLD FOR USE WHEN NO HEADING IS PROVIDED.\n         SPACE\nNOHDLIST DS    0F\n         DC    XL1'80'                 VL LIST BIT\n         DC    AL3(NOHDPLD)            ADDRESS OF PLD BELOW\n         SPACE\nNOHDPLD  DS    0F                      ALIGN ON FULL-WORD BOUNDARY\n         DC    BL1'00010000'           OPTION BITS\n         DC    AL3(BLANK1)             PRINT TEXT ADDRESS\n         DC    AL1(1)                  PRINT TEXT LENGTH\n         DC    AL1(0)                  LEFT MARGIN INDENTATION\n         DC    AL1(0)                  SPACING BEFORE PRINTING\n         DC    AL1(3)                  SPACING AFTER PRINTING\n         SPACE\n* CONSTANTS TO INITIALIZE PARAMETERS AND SWITCHES WHEN 'OPEN' CALL IS\n* RECEIVED.  THE ORDER MUST MATCH THE 'PAPARMS' LIST IN THE WORK AREA.\n         SPACE\nDEFAULTS DS    0F\n         DC    A(NOHDLIST)     PAGE HEADING PARM LIST ADDRESS\n         DC    F'1000000'      MAXIMUM NUMBER OF OUTPUT LINES\n         DC    H'132'          PAGE WIDTH\n         DC    H'57'           PAGE LENGTH            ***TRW***\n         DC    H'0'            PAGE NUMBER (-1)\n         DC    H'0'            PAGE BALANCE\n         DC    X'00'           SWITCHES\nDEFSIZE  EQU   *-DEFAULTS\n         SPACE\n* MISCELLANEOUS CONSTANTS:\n         SPACE\nBLANK1   DC    C' '                    TEXT OF DUMMY HEADING LINE\n         LTORG\n         EJECT\n*******************\n* WORK AREA DSECT *\n*******************\n         SPACE\n* THIS DUMMY SECTION DEFINES THE WORK AREA PROVIDED BY THE PROBLEM\n* PROGRAM FOR EACH DATA SET.  ITS ADDRESS IS PASSED IN PARAMETER\n* REGISTER 0 AT EACH CALL.\n         SPACE 2\nWORKAREA DSECT\n         SPACE 2\n* STANDARD 18-WORD SAVE AREA:\n         SPACE\nSAVEAREA DS    18F\n         SPACE 2\n* DATA CONTROL BLOCK FOR PRINTER DATA SET:\n         SPACE\n         PRINT NOGEN\nPRINTDCB DCB   DDNAME=SYSPRINT,                                        X\n               DSORG=PS,                                               X\n               RECFM=VBM,                                              X\n               LRECL=137,                                              X\n               MACRF=PL,                                               X\n               BFTEK=S,                                                X\n               BUFNO=2,                                                X\n               EROPT=ACC\n         PRINT GEN\n         SPACE\nDCBEXLST EQU   PRINTDCB+37     ADDRESS OF EXIT LIST\nDCBOFLGS EQU   PRINTDCB+48     CONTAINS 'OPENED SUCCESSFULLY' BIT\nDCBDDNAM EQU   PRINTDCB+40     DDNAME (WHEN CLOSED)\nDCBSYNAD EQU   PRINTDCB+57     ADDRESS OF SYNCHRONOUS ERROR ROUTINE\nDCBBLKSZ EQU   PRINTDCB+62     BLOCK SIZE\nDCBLRECL EQU   PRINTDCB+82     LOGICAL RECORD LENGTH\n         SPACE 2\n* ADDRESS OF LAST BUFFER OBTAINED BY \"PUT\" MACRO:\n         SPACE\nCCLAST   DS    1A\n         SPACE\n         DS    1F              SPARE FULL WORD\n         SPACE 2\n* TEMPORARY WORK CELLS:\n         SPACE\nDWORK    DS    1D              DOUBLE-WORD WORK CELL\nHPREXIT  DS    1F              HEADPRNT EXIT SAVE\nHPRSAVE  DS    2F              HEADPRNT REGISTER STORAGE\n         SPACE 2\n* PARAMETERS AND SWITCHES WHICH DEFINE THE PAGE SIZE AND STATUS.\n* SEQUENCE MUST MATCH THAT IN 'DEFAULTS', WHICH INITIALIZES THEM.\n         SPACE\nPAPARMS  DS    0F\nHEADLIST DS    1A              PAGE HEADING PARM LIST ADDRESS\nMAXLINES DS    1F              MAXIMUM NUMBER OF OUTPUT LINES\nPAGWIDTH DS    1H              PAGE WIDTH\nPAGELNG  DS    1H              PAGE LENGTH\nPAGENO   DS    1H              PAGE NUMBER OF CURRENT PAGE\nPAGEBAL  DS    1H              PAGE BALANCE\nSWITCHES DS    1X              SWITCHES\n         SPACE 2\n* STORAGE FOR DATE AND TIME PORTION OF PAGE HEADING:\n         SPACE\nHLTXTLNG EQU   24\nHLTEXT   DS    CL(HLTXTLNG)\nHLDAY    EQU   HLTEXT\nHLTIME   EQU   HLTEXT+7\nHLDATE   EQU   HLTEXT+16\n         EJECT\n*************************\n* PARAMETER LIST DSECTS *\n*************************\n         SPACE 2\n* PARAMETER LIST FOR 'EJECT' CALL:\n         SPACE\nEJPARM   DSECT\n         SPACE\nEJCOND   DS    1X              CONDITIONAL MASK AND SWITCHES\nEJQUAN   DS    1X              CONDITIONAL TEST QUANTITY\n         SPACE\nEJATHOF  EQU   X'01'           MASK FOR 'EJCOND'\n         SPACE 6\n* PARAMETER LIST FOR 'SPACE' CALL:\n         SPACE\nSPPARM   DSECT\n         SPACE\nSPCOND   DS    1X              CONDITIONAL BITS\nSPQUAN   DS    1X              NUMBER OF LINES TO SPACE\n         SPACE\nSPATHOF  EQU   X'01'           MASK FOR 'SPCOND'\nSPNOEJ   EQU   X'02'           MASK FOR 'SPCOND'\n         SPACE 6\n* PARAMETER LIST FOR 'OPEN' AND 'MODIFY' CALLS:\n         SPACE\nOMPARM   DSECT\n         SPACE\nOMMAXLIN DS    1F              MAXIMUM NUMBER OF OUTPUT LINES\nOMPAGENO DS    1H              INITIAL PAGE NUMBER\nOMPAGWID DS    1X              PAGE WIDTH\nOMPAGLNG DS    1X              PAGE LENGTH\nOMTIMEAD DS    1A              ADDRESS OF TIME\nOMDATEAD DS    1A              ADDRESS OF DATE\nOMDDNAME DS    CL8             DDNAME (OPEN CALL ONLY)\n         EJECT\n*************\n* PLD DSECT *\n*************\n         SPACE\n* PRINT LINE DESCRIPTOR DUMMY SECTION:\n         SPACE 2\n*        ******************************************************\n*        *            *                                       *\n*        *   OPTION   *                                       *\n*        *    BITS    *             TEXT ADDRESS              *\n*        *            *                                       *\n*        ******************************************************\n*        *            *            *            *             *\n*        *    TEXT    *    TEXT    *   SPACE    *    SPACE    *\n*        *   LENGTH   *   OFFSET   *   BEFORE   *    AFTER    *\n*        *            *            *            *             *\n*        ******************************************************\n         SPACE 3\nPLDBLOCK DSECT\n         SPACE\nPLDFLAGS DS    1X              OPTION BITS\nPLDTXTAD DS    AL3             TEXT ADDRESS\nPLDLNGTH DS    1X              TEXT LENGTH\nPLDOFFST DS    1X              TEXT OFFSET, OR LEFT MARGIN\nPLDSPB   DS    1X              AMOUNT TO SPACE BEFORE PRINTING\nPLDSPA   DS    1X              AMOUNT TO SPACE AFTER PRINTING\n         SPACE 2\nPRHOFBIT EQU   B'00000010'     MASK FOR 'PLDFLAGS'\nPRSKPBIT EQU   B'00000001'     MASK FOR 'PLDFLAGS'\nSPSKPBIT EQU   B'00010000'     MASK FOR 'PLDFLAGS'\n         SPACE 6\n         END\nVTRD     TITLE 'XVTCREAD - VTOC READING SUBROUTINE'\n         SPACE\n* FUNCTION: THIS SUBROUTINE READS THE VOLUME TABLE OF CONTENTS (VTOC)\n*        FROM A DIRECT-ACCESS DEVICE AND PRESENTS IT TO THE CALLER\n*        ONE RECORD (DSCB) AT A TIME.\n         SPACE\n* OPERATION: THIS ROUTINE IS A SPECIALIZED SEQUENTIAL ACCESS METHOD\n*        FOR VTOC'S.  ITS ADVANTAGE OVER ORDINARY BSAM IS THAT IT READS\n*        AN ENTIRE TRACK IN ONE REVOLUTION, THUS SAVING CONSIDERABLE\n*        TIME.  THE ROUTINE HAS THREE CALL MODES:\n*\n*        0 - READ.  RETURNS WITH THE CORE ADDRESS OF A DSCB IN REGISTER\n*              1.  THE CORE CONSISTS OF 148 CONSECUTIVE BYTES, CONTAIN-\n*              ING THE COUNT (8 BYTES), KEY (44 BYTES), AND DATA (96\n*              BYTES) FOR ONE DSCB.  RETURN CODES ARE:\n*                      0 - NORMAL;\n*                      4 - END OF FILE, NO DATA PRESENTED;\n*                      8 - PERMANENT I/O ERROR.  THE KEY AND DATA AREAS\n*                          WILL BE SET TO ZEROS; THE COUNT AREA WILL\n*                          CONTAIN THE CORRECT CCHHR.  SINCE READING\n*                          IS DONE A TRACK AT A TIME, ALL THE DSCB'S\n*                          FOR THAT TRACK WILL BE MARKED IN ERROR.\n*                          READING MAY CONTINUE ON TO THE NEXT TRACK.\n*\n*        1 - OPEN.  REGISTER 1 SHOULD POINT TO AN 8-BYTE FIELD\n*              CONTAINING THE DDNAME TO BE USED IN THE DCB.  THE\n*              CORRESPONDING DD CARD SHOULD SPECIFY A DISPOSITION OF\n*              (OLD,KEEP).  RETURN CODES:\n*                      0 - NORMAL;\n*                      4 - UNABLE TO OPEN (PROBABLY MISSING DD CARD);\n*                      8 - DD CARD DID NOT REFER TO A DIRECT-ACCESS\n*                          DEVICE, OR DEVICE TYPE UNKNOWN.\n*\n*        2 - CLOSE.  NO ARGUMENTS ARE REQUIRED OR RETURNED.  RETURN\n*              CODE IS 0.\n         SPACE\n* ENTRY POINTS:  ENTRY IS ALWAYS TO 'XVTCREAD' VIA A BALR 14,15 WITH\n*        REGISTER 13 SET TO A SAVE AREA.  REGISTER 0 CONTAINS A\n*        BINARY INTEGER TO INDICATE THE CALL MODE AND REGISTER 1\n*        POINTS TO PARAMETERS AS REQUIRED FOR EACH MODE.\n         SPACE\n* DATA SETS:  READS VOLUME TABLE OF CONTENTS FROM ANY DIRECT-ACCESS\n*        DEVICE.  USES EXCP TO EXECUTE A CHAINED CHANNEL PROGRAM TO\n*        READ AN ENTIRE TRACK AT A TIME.\n         SPACE\n* EXTERNAL ROUTINES:  USES SUPERVISOR ROUTINE 'IECPCNVT' TO CONVERT\n*        A RELATIVE TRACK NUMBER TO AN ABSOLUTE ADDRESS.\n         SPACE\n* EXITS - NORMAL:  RETURNS VIA REGISTER 14 WITH RETURN CODE IN REGISTER\n*        15.  (SEE ABOVE FOR RETURN CODE VALUES.)\n         SPACE\n* EXITS - ERROR:  NONE.\n         SPACE\n* TABLES AND WORK AREAS:  DOES A GETMAIN TO OBTAIN A BUFFER LARGE\n*        ENOUGH TO HOLD AN ENTIRE TRACK FROM THE DEVICE BEING READ.\n*        THIS AREA MAY BE AS LARGE AS 9900 BYTES (FOR 2301 DRUM).\n         SPACE\n* ATTRIBUTES:  SERIALLY REUSABLE.\n         EJECT\n* SECTION DEFINITION AND REGISTER ASSIGNMENTS:\n         SPACE\nXVTCREAD CSECT\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nRWA      EQU   2\nRWB      EQU   3\nRWC      EQU   4\nRPARM    EQU   9\nRRCODE   EQU   10              RETURN CODE REGISTER\nRRET     EQU   11              LOCAL SUBROUTINE EXIT REGISTER\nRBASE    EQU   12              LOCAL BASE REGISTER\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 3\n* TAGS FOR CHANNEL COMMANDS AND FLAG BITS:\n         SPACE\nREADR0   EQU   X'16'           READ RECORD 0\nREADCKD  EQU   X'1E'           READ COUNT, KEY, AND DATA\n         SPACE\nCC       EQU   X'40'           COMMAND CHAIN FLAG\nSLI      EQU   X'20'           SUPPRESS LENGTH INDICATION FLAG\nSKIP     EQU   X'10'           SKIP DATA TRANSFER FLAG\n         SPACE 3\n* COMMUNICATION VECTOR TABLE (CVT) DEFINITIONS:\n         SPACE\nCVT      EQU   16              LOCATION OF CVT BASE ADDRESS\nCVTPCNVT EQU   28              OFFSET TO CONVERT ROUTINE ADDRESS\n         EJECT\n************\n* PROLOGUE *\n************\n         SPACE\n* ENTER HERE AND PERFORM STANDARD REGISTER SAVE AREA HOUSEKEEPING.\n         SPACE\n         SAVE  (14,12),,XVTCREAD-01008218\n         SPACE\n         LR    RBASE,R15               SET LOCAL BASE REGISTER\n         USING XVTCREAD,RBASE\n         LR    R14,R13                 SAVE CALLER'S R13\n         LA    R13,SAVEAREA            ADDRESS LOCAL SAVE AREA\n         ST    R13,8(R14)              CHAIN FORWARD\n         ST    R14,SAVEAREA+4          CHAIN BACKWARD\n         SR    RRCODE,RRCODE           ZERO RETURN CODE REGISTER\n         SPACE\n* SELECT MODE FROM CONTENTS OF REGISTER 0.\n         SPACE\n         LA    RWA,3                   MASK FOR LOW 2 BITS\n         NR    RWA,R0                  GET CALL MODE\n         SLL   RWA,2                   MODE TIMES 4\n         B     *+4(RWA)                BRANCH ON MODE\n         SPACE\n         B     GET                     MODE 0, GET A DSCB\n         B     OPEN                    MODE 1, OPEN A NEW VTOC\n         B     CLOSE                   MODE 2, CLOSE\n         B     RETURN0                 MODE 3 NOT DEFINED, NO OP\n         SPACE 3\n***********\n* RETURNS *\n***********\n         SPACE\nRETURN8  LA    RRCODE,4(RRCODE)        ENTRY FOR RETURN CODE 8\nRETURN4  LA    RRCODE,4(RRCODE)        ENTRY FOR RETURN CODE 4\nRETURN0  LR    R15,RRCODE              ENTRY FOR RETURN CODE 0\n         SPACE\n         L     R13,SAVEAREA+4          RECOVER CALLER'S SAVE AREA\n         L     R14,12(R13)             LOAD RETURN ADDRESS\n         LM    R2,R12,28(R13)          RESTORE OTHER GENERAL REGISTERS\n         MVI   12(R13),X'FF'           SET RETURN FLAG ON\n         BR    R14                     RETURN TO CALLER\n         EJECT\n*********************\n* MODE 0 - GET DSCB *\n*********************\n         SPACE\n* IF END-OF-FILE WAS REACHED, RETURN AT ONCE.\n         SPACE\nGET      DS    0H\n         TM    MODESW,EOFSW            TEST END-OF-FILE BIT\n         BO    RETURN4                 RETURN CODE 4 IF ON\n         SPACE\n* IF CHANNEL PROGRAM HAS BEEN STARTED, GO TO CHECK IT.  OTHERWISE,\n* ASSUME THERE IS AT LEAST ONE FULL BUFFER.\n         SPACE\n         TM    MODESW,XCPRUN           TEST IF EXCP ISSUED\n         BO    XCPTEST                 BRANCH IF SO\n         SPACE\n* SET BUFFER ADDRESS TO NEXT DSCB AND TEST IF LAST ON TRACK.  IF NOT,\n* EXIT WITH ITS ADDRESS IN R1.\n         SPACE\n         L     RWA,DSCBADR             LOAD BUFFER POINTER\n         LA    RWA,148(RWA)            ADVANCE TO NEXT DSCB\nNDXSTORE ST    RWA,DSCBADR             STORE UPDATED POINTER\n         C     RWA,DSCBLIM             TEST IF LAST DSCB IN BUFFER\n         BNL   LASTDSCB                BRANCH IF SO\n         LR    R1,RWA                  PASS ADDRESS TO USER\nGETOUT   TM    MODESW,RDERR            TEST IF ERROR ON THIS TRACK\n         BZ    RETURN0                 RETURN CODE 0 IF NOT\n         B     RETURN8                 RETURN CODE 8 IF ERROR\n         SPACE\n* IF THIS IS THE LAST DSCB, MOVE IT TO THE JFCB BUFFER AND START\n* READING THE NEXT TRACK.\n         SPACE\nLASTDSCB MVC   JFCB(148),0(RWA)        MOVE LAST DSCB\n         L     RWB,TTRN                LOAD RELATIVE TRACK NUMBER\n         AL    RWB,=X'00010000'        INCREMENT TO NEXT TRACK\n         ST    RWB,TTRN\n         BAL   RRET,EXCP               START CHANNEL PROGRAM\n         LA    R1,JFCB                 LOAD DSCB ADDRESS FOR CALLER\n         B     GETOUT                  TO RETURN\n         EJECT\n* WAIT FOR CHANNEL PROGRAM COMPLETION AND TEST THE OUTCOME.\n         SPACE\nXCPTEST  WAIT  ECB=VTOCECB\n         SPACE\n         NI    MODESW,X'FF'-XCPRUN     TURN EXCP STARTED BIT OFF\n         CLI   VTOCECB,X'7F'           TEST COMPLETION CODE\n         BNE   PERMERR                 BRANCH IF ERROR\nSETDSCBA L     RWA,DSCBSTRT            SET BUFFER POINTER TO 1ST DSCB\n         B     NDXSTORE\n         SPACE\n* PERMANENT ERROR FOR THIS TRACK.  ZERO THE DSCB'S AND FILL IN THE\n* CCHHR PORTIONS OF THE COUNT AREAS.\n         SPACE\nPERMERR  OI    MODESW,RDERR            SIGNAL READ ERROR\n         NI    IOBFLAG1,X'FB'          TURN OFF BIT 5 OF IOB FLAG\n         NI    DCBIFLGS,X'3F'          TURN OFF BITS 0 AND 1\n         L     RWA,DSCBSTRT            LOAD ADDRESS OF FIRST DSCB\n         LA    RWB,1                   LOAD RECORD NUMBER\n         SPACE\nDSCBELUP XC    0(148,RWA),0(RWA)       ZERO DSCB BUFFER\n         MVC   0(4,RWA),IOBSEEK+3      INSERT CCHH IN COUNT FIELD\n         STC   RWB,4(RWA)              INSERT R IN COUNT FIELD\n         LA    RWA,148(RWA)            POINT TO NEXT BUFFER\n         LA    RWB,1(RWB)              INCREMENT RECORD NUMBER\n         C     RWA,DSCBLIM             TEST FOR LAST BUFFER\n         BNH   DSCBELUP\n         B     SETDSCBA                BRANCH TO RESET BUFFER POINTER\n         EJECT\n*****************\n* MODE 1 - OPEN *\n*****************\n         SPACE\n* ENTER WITH A DDNAME ADDRESSED BY REGISTER 1.  PERFORM CLOSE\n* SUBROUTINE FIRST TO BE SURE EVERYTHING IS INITIALIZED.\n         SPACE\nOPEN     DS    0H\n         LR    RPARM,R1                SAVE REGISTER 1\n         BAL   RRET,CLOSESUB           CALL CLOSE SUBROUTINE\n         SPACE\n         MVC   DCBDDNAM(8),0(RPARM)    INSERT DDNAME IN DCB\n         SPACE\n* CHECK DEVICE TYPE TO BE SURE IT IS DIRECT ACCESS.\n         SPACE\n         DEVTYPE  DCBDDNAM,DWORK       GET DEVICE TYPE\n         LTR   R15,R15                 TEST IF IT FOUND DD CARD\n         BNZ   RETURN4                 ERROR, DD CARD MISSING\n         CLI   DWORK+2,X'20'           TEST DEVICE TYPE\n         BNE   RETURN8                 ERROR IF NOT DIRECT ACCESS\n         SPACE\n         CLI   DWORK+3,MAXDVT          TEST FOR MAX DEVICE TYPE\n         BNL   RETURN8                 ERROR IF TOO LARGE\n         SR    R1,R1\n         IC    R1,DWORK+3              LOAD DEVICE NUMBER\n         IC    R1,DVICETAB(R1)         LOAD DSCB'S/TRK FROM TABLE\n         LTR   R1,R1                   ZERO IS UNDEFINED DEVICE\n         BZ    RETURN8                 EXIT IF UNKNOWN\n         ST    R1,NDSCBS               STORE NUMBER OF DSCB'S/TRACK\n         SPACE\n* READ JFCB AND INSERT DATA SET NAME OF 44 X'04'.\n         SPACE\n         RDJFCB  VTOCDCB\n         MVI   JFCBDSNM,X'04'          GENERATE DATA SET NAME\n         MVC   JFCBDSNM+1(43),JFCBDSNM\n         SPACE\n* OPEN THE DSCB.\n         SPACE\n         OPEN  (VTOCDCB,(INPUT)),TYPE=J\n         TM    DCBOFLGS,OPENBIT        TEST IF OPEN WORKED\n         BZ    RETURN4                 ERROR IF OPEN FAILED\n         SPACE\n* OBTAIN CORE FOR CHANNEL PROGRAM AND DSCB BUFFERS.\n         SPACE\n         LA    R0,156                  CORE FOR ONE DSCB AND ITS CCW\n         MH    R0,NDSCBS+2             TIMES NUMBER PER TRACK\n         AH    R0,=H'15'               PLUS 1 CCW AND ROUNDING\n         N     R0,=X'FFFFFFF8'         ROUND TO DOUBLE-WORD MULTIPLE\n         ST    R0,CBSIZE               SAVE SIZE OF GOTTEN CORE\n         GETMAIN  R,LV=(0)             GET TRACK BUFFERS\n         ST    R1,CBADDR               SAVE ADDRESS OF GOTTEN CORE\n         OI    MODESW,CBGOT            INDICATE CORE GOTTEN\n         SPACE\n* GENERATE CHANNEL PROGRAM.  IT CONSISTS OF A 'READ R0' ORDER WITH\n* THE SKIP FLAG ON, FOLLOWED BY A 'READ COUNT-KEY-AND-DATA' ORDER FOR\n* EACH DSCB.\n         SPACE\n         L     RWA,NDSCBS              NUMBER OF DSCB'S\n         SLL   RWA,3                   TIMES   8\n         LA    RWA,8(RWA,R1)           PLUS 8 AND BASE = 1ST BUFFER ADD\n         ST    RWA,DSCBSTRT            SAVE ADDRESS OF FIRST BUFFER\n         SPACE\n         ST    R1,IOBSTART             ADDRESS OF CHANNEL PROGRAM\n         MVC   0(8,R1),INITCCW         INSERT FIRST CCW\n         LA    RWB,8(R1)               PLACE FOR NEXT CCW\n         LA    RWC,1                   BUFFER COUNTER\n         SPACE\nCCWLOOP  MVC   0(8,RWB),READCCW        INSERT READ CCW FOR ONE DSCB\n         ST    RWA,0(RWB)              SET ITS BUFFER ADDRESS\n         MVI   0(RWB),READCKD          RESTORE COMMAND CODE\n         C     RWC,NDSCBS              TEST BUFFER COUNTER\n         BNL   LASTCCW                 BRANCH IF LAST BUFFER\n         LA    RWB,8(RWB)              INCREMENT CCW ADDRESS\n         LA    RWA,148(RWA)            INCREMENT BUFFER ADDRESS\n         LA    RWC,1(RWC)              INCREMENT BUFFER COUNTER\n         B     CCWLOOP                 DO NEXT BUFFER\n         SPACE\nLASTCCW  NI    4(RWB),X'FF'-CC         TURN OFF COMMAND CHAIN BIT\n         ST    RWA,DSCBLIM             SAVE ADDRESS OF LAST DSCB BUFFER\n         SPACE\n* SET OTHER THINGS AND START PROGRAM TO FILL BUFFER.\n         SPACE\n         SR    R0,R0\n         ST    R0,TTRN                 SET RELATIVE TRACK NUMBER TO 0\n         NI    MODESW,X'FF'-XCPRUN-RDERR-EOFSW   SET FLAGS OFF\n         BAL   RRET,EXCP               START CHANNEL PROGRAM\n         B     RETURN0                 INDICATE SUCCESSFUL OPEN\n         EJECT\n******************\n* MODE 2 - CLOSE *\n******************\n         SPACE\nCLOSE    BAL   RRET,CLOSESUB           CALL CLOSED CLOSE SUBROUTINE\n         B     RETURN0\n         SPACE 2\n* IF THE CHANNEL PROGRAM IS RUNNING, WAIT FOR IT BEFORE TAKING FURTHER\n* ACTION.\n         SPACE\nCLOSESUB DS    0H\n         TM    MODESW,XCPRUN           TEST IF CHANNEL PROGRAM RUNNING\n         BZ    NOEXCP                  BRANCH IF NOT\n         WAIT  ECB=VTOCECB             WAIT UNTIL COMPLETE\n         NI    MODESW,X'FF'-XCPRUN     TURN RUNNING SWITCH OFF\nNOEXCP   DS    0H\n         SPACE\n* CLOSE THE DCB.\n         SPACE\n         TM    DCBOFLGS,OPENBIT        TEST IF DCB OPEN\n         BZ    NOCLOSE                 BRANCH IF NOT\n         CLOSE VTOCDCB\nNOCLOSE  DS    0H\n         SPACE\n* RELEASE CORE OBTAINED FOR DSCB BUFFERS.\n         SPACE\n         TM    MODESW,CBGOT            TEST IF CORE GOTTEN\n         BZ    NOFREE                  BRANCH IF NOT\n         LM    R0,R1,CBSIZE            LOAD SIZE AND LOCATION\n         FREEMAIN  R,LV=(0),A=(1)      FREE CORE\n         NI    MODESW,X'FF'-CBGOT      SET CORE GOTTEN BIT OFF\nNOFREE   DS    0H\n         SPACE\n         NI    MODESW,X'FF'-RDERR      CLEAR ERROR SWITCH\n         BR    RRET\n         EJECT\n****************\n* EXCP ROUTINE *\n****************\n         SPACE\n* CONVERT RELATIVE TRACK ADDRESS IN 'TTRN' TO ABSOLUTE SEEK ADDRESS IN\n* 'IOBSEEK', USING SUPERVISOR CONVERSION ROUTINE.\n         SPACE\nEXCP     DS    0H\n         STM   R2,R13,EXCPSAVE         SAVE IMPORTANT REGISTERS\n         L     R0,TTRN                 LOAD RELATIVE TRACK NUMBER\n         L     R1,DCBDEBAD             LOAD DEB ADDRESS\n         LA    R2,IOBSEEK              LOAD ADDR TO RECEIVE MBBCCHHR\n         L     R15,CVT                 LOAD CVT ADDRESS\n         L     R15,CVTPCNVT(R15)       LOAD ADDR OF CONVERT ROUTINE\n         BALR  R14,R15                 CONVERT TTRN TO MBBCCHHR\n         DROP  RBASE                   THAT CLOBBERED BASE REG\n         USING *,R14                   R14 SET BY BALR ABOVE\n         LM    R2,R13,EXCPSAVE         RESTORE REGISTERS\n         DROP  R14\n         USING XVTCREAD,RBASE          BASE REGISTER RECOVERED\n         LTR   R15,R15                 TEST IF EXTENT VIOLATED (RC=4)\n         BNZ   SETEOF                  IF SO, MEANS END-OF-FILE\n         SPACE\n* ZERO ECB AND START CHANNEL PROGRAM.\n         SPACE\n         SR    R0,R0\n         ST    R0,VTOCECB              CLEAR ECB\n         NI    MODESW,X'FF'-RDERR      RESET ERROR SWITCH\n         EXCP  VTOCIOB                 START CHANNEL PROGRAM\n         OI    MODESW,XCPRUN           SET 'RUNNING' FLAG\n         BR    RRET\n         SPACE\n* WHEN EXTENT IS VIOLATED, SET END-FILE AND EXIT VIA CLOSE ROUTINE.\n         SPACE\nSETEOF   OI    MODESW,EOFSW            SET END-OF-FILE BIT\n         B     CLOSESUB                EXIT VIA CLOSE SUBROUTINE\n         EJECT\n********************************\n* CONSTANTS, VARIABLES, ETC... *\n********************************\n         SPACE\nINITCCW  CCW   READR0,0,CC+SLI+SKIP,8\nREADCCW  CCW   READCKD,0,CC,148\n         SPACE\nDVICETAB DC    X'00'           TABLE OF NUMBER OF DSCB'S/TRACK\n         DC    AL1(16)            2311                     01\n         DC    AL1(63)            2301                     02\n         DC    AL1(17)            2303                     03\n         DC    AL1(22)            2302                     04\n         DC    AL1(8)             2321                     05\n         DC    AL1(34)            2305-1                   06\n         DC    AL1(34)            2305-2                   07\n         DC    AL1(25)            2314                     08\n         DC    AL1(39)            3330                     09\n         DC    AL1(00)            UNKNOWN AS OF 4/75       0A\n         DC    AL1(47)            3350                     0B\n         DC    AL1(53)            3375  (UNKN ATTRS 5/81)  0C   CST\n         DC    AL1(39)            3330-1                   0D\n         DC    AL1(53)            3380                     0E   CST\n         DC    AL1(00)            UNKNOWN AS OF 4/75       0F\nMAXDVT   EQU   *-DVICETAB\n         SPACE\nDWORK    DS    D               WORK CELL\nSAVEAREA DS    19F             SAVE AREA\nEXCPSAVE EQU   SAVEAREA+12\nCBSIZE   DS    2F              SIZE AND LOCATION OF GOTTEN CORE\nCBADDR   EQU   CBSIZE+4\nNDSCBS   DS    F               NUMBER OF DSCB'S PER TRACK\nDSCBSTRT DS    F               ADDRESS OF 1ST DSCB BUFFER\nDSCBLIM  DS    F               ADDRESS OF LAST DSCB BUFFER\nDSCBADR  DS    F               ADDRESS OF CURRENT DSCB\nTTRN     DS    F               RELATIVE TRACK NUMBER\n         SPACE\n* MODE SWITCH AND BIT DEFINITIONS:\n         SPACE\nMODESW   DC    X'00'\nCBGOT    EQU   X'80'           CORE GOTTEN FOR BUFFER\nXCPRUN   EQU   X'40'           CHANNEL PROGRAM STARTED BUT NOT CHECKED\nRDERR    EQU   X'20'           PERMANENT I/O ERROR\nEOFSW    EQU   X'10'           END-OF-FILE SENSED\n         SPACE\n         LTORG\n         EJECT\n* DATA CONTROL BLOCK\n         SPACE\n*********************************************************************\n         ENTRY VTOCDCB      (USED BY IX VTOC ROUTINE )          CST\n*********************************************************************\nVTOCDCB  DCB   DDNAME=VOLUME01,MACRF=(E),EXLST=JFCBADDR\n         SPACE\nDCBDDNAM EQU   VTOCDCB+40\nDCBIFLGS EQU   VTOCDCB+44\nDCBDEBAD EQU   VTOCDCB+44\nDCBOFLGS EQU   VTOCDCB+48\nOPENBIT  EQU   X'10'\n         EJECT\n* IOB FOR CHANNEL PROGRAM:\n         SPACE\nVTOCIOB  DS    0D\nIOBFLAG1 DC    X'42000000'     COMMAND CHAIN, NOT RELATED\n         DC    A(VTOCECB)\n         DC    2F'0'\nIOBSTART DC    A(0)            CHANNEL PROGRAM BEGINNING\n         DC    A(VTOCDCB)\n         DC    X'03000000'\n         DC    F'0'\nIOBSEEK  DC    D'0'            INITIAL SEEK ADDRESS\n         SPACE\n* EVENT CONTROL BLOCK FOR CHANNEL PROGRAM:\n         SPACE\nVTOCECB  DC    F'0'            EVENT CONTROL BLOCK\n         SPACE 3\n* BUFFER FOR JFCB AND DCB EXIT LIST:\n         SPACE\nJFCBADDR DS    0F\n         DC    X'87'\n         DC    AL3(JFCB)\n         SPACE\nJFCB     DS    0D\n         DS    CL176\n         SPACE\nJFCBDSNM EQU   JFCB            DATA SET NAME\nJFCBVOLS EQU   JFCB+118        VOLUME SERIAL NUMBER\n         SPACE 6\n         END\nDTED     TITLE 'DATE EDITING ROUTINE \"XDATEDIT\"'\n* STATUS:  VERSION 0, MOD 2, 5 OCTOBER 1967.\n         SPACE\n* FUNCTION/OPERATION:  EDITS A PACKED DECIMAL DATE IN YEAR-DAY FORM TO\n*        EBCDIC MONTH-DAY-YEAR FORM.  CORRECTS FOR LEAP YEARS AND\n*        FOR THE TURN OF A CENTURY.\n         SPACE\n* ENTRY POINTS:  ENTER AT \"XDATEDIT\" VIA BALR 14,15 WITH REG 13 SET\n*        TO A STANDARD 18-WORD SAVE AREA.  REGISTER 1 POINTS TO A\n*        PARAMETER LIST CONTAINING ONE ADDRESS.\n         SPACE\n* INPUT:  THE ADDRESS IN THE PARAMETER LIST IS THAT OF AN ALIGNED\n*        DOUBLE WORD CONTAINING THE ARGUMENT IN PACKED DECIMAL AS:\n*        X'0000000000YYDDD+'.\n         SPACE\n* OUTPUT:  THE RESULT IS RETURNED IN THE SAME DOUBLE WORD IN EBCDIC AS\n*        C'MM/DD/YY'.\n         SPACE\n* DATA SETS:  NONE.\n         SPACE\n* EXTERNAL ROUTINES:  NONE.\n         SPACE\n* EXITS-NORMAL:  RETURN VIA REG 14 WITH RETURN CODE 0 IN REG 15.\n         SPACE\n* EXITS-ERROR:  IF THE DAY NUMBER IS ZERO OR EXCEEDS THE MAXIMUM VALUE\n*        APPROPRIATE TO THE YEAR, RETURN VIA REG 14 WITH RETURN CODE 4\n*        IN REG 15 AND THE RESULT FIELD SET TO C' YY.DDD '.\n         SPACE\n* TABLES/WORK AREAS:  NONE.\n         SPACE\n* ATTRIBUTES:  REENTRANT, READ ONLY.\n         SPACE\n* NOTES:  NONE.\n         EJECT\n* DUMMY SECTION TO DEFINE THE ARGUMENT AND RETURN FIELD.\n         SPACE\nDUMMY    DSECT\nDWORD    DS    1D\n         SPACE 6\n* BEGIN CONTROL SECTION HERE.  DEFINE REGISTER TAGS.\n         SPACE\nXDATEDIT CSECT\n         SPACE\nRBASE    EQU   12              LOCAL BASE REGISTER\nRDSECT   EQU   11              BASE REG FOR ARGUMENT/RESULT\nRPARM    EQU   1               PARAMETER LIST POINTER\nRARGSAVE EQU   2               TO SAVE ORIGINAL PACKED ARGUMENT\nRMONTH   EQU   3\nRDAY     EQU   4               RDAY AND RYEAR ARE AN EVEN/ODD\nRYEAR    EQU   5                 PAIR FOR DIVISION\nRWORK    EQU   6\nRLIST    EQU   7\n         SPACE 6\n* ENTER HERE.  SAVE GENERAL REGISTERS AND SET UP BASE REGISTERS.\n         SPACE\n         SAVE  (14,12),,*\n         SPACE\n         BALR  RBASE,0\n         USING *,RBASE\n         L     RDSECT,0(RPARM)         LOAD ARGUMENT ADDRESS\n         USING DWORD,RDSECT\n         EJECT\n* CONVERT YEAR AND DAY TO BINARY, AND SEPARATE BY DIVISION.\n         SPACE\n         MVI   DWORD,X'00'             CLEAR HIGH DECIMAL DIGITS\n         MVC   DWORD+1(4),DWORD          IN ARG TO ZEROS\n         OI    DWORD+7,X'0F'           FORCE PLUS SIGN\n         L     RARGSAVE,DWORD+4        SAVE ARGUMENT FOR 'BADDATE'\n         SPACE\n         CVB   RYEAR,DWORD             CONVERT YYDDD TO BINARY\n         SR    RDAY,RDAY               CLEAR HIGH-ORDER DIVIDEND\n         D     RDAY,F1000              QUOTIENT=YEAR; REMAINDER=DAY\n         SPACE\n* CHECK FOR LEAP YEAR, AND LOAD RLIST WITH BASE ADDRESS OF APPROPRIATE\n* LIST OF MONTH SIZES.\n         SPACE\nDAYOK    DS    0H\n         LA    RLIST,STDLIST           POINT RLIST TO STANDARD MONTHS\n         LTR   RWORK,RYEAR             LOAD BINARY YEAR NUMBER\n         BZ    NOTLEAP                 BR IF TURN OF CENTURY\n         N     RWORK,=F'3'             TEST LOW TWO BITS\n         BC    4,NOTLEAP               BR IF NON-ZERO\n         LA    RLIST,LPYLIST           POINT RLIST TO LEAP-YEAR MONTHS\nNOTLEAP  DS    0H\n         SPACE\n* TEST DAY NUMBER AGAINST ZERO AND THE UPPER LIMIT DETERMINED BY\n* THE YEAR NUMBER.\n         SPACE\n         LTR   RDAY,RDAY               TEST FOR ZERO\n         BZ    BADDATE                 BR IF SO\n         CH    RDAY,0(0,RLIST)         TEST FOR UPPER LIMIT\n         BH    BADDATE                 BR IF TOO LARGE\n         SPACE\n* REDUCE JULIAN DAY TO DAY-OF-MONTH, ACCUMULATING MONTH NUMBER.\n         SPACE\n         LA    RMONTH,1                INITIAL MONTH NUMBER\n         SR    RWORK,RWORK\nDAYLOOP  IC    RWORK,1(RMONTH,RLIST)   LENGTH OF MONTH INTO RWORK\n         CR    RDAY,RWORK              TEST IF DAY IN THIS MONTH\n         BNH   DAYDONE                 BR IF DAY LESS THAN MONTH SIZE\n         SR    RDAY,RWORK              REDUCE DAY BY LENGTH OF MONTH\n         LA    RMONTH,1(RMONTH)        INCREMENT MONTH\n         B     DAYLOOP\nDAYDONE  DS    0H\n         SPACE\n* COMBINE MONTH, DAY, AND YEAR IN BINARY IN ONE REGISTER, MULTIPLYING\n* EACH BY A FACTOR TO PLACE IT PROPERLY IN THE DECIMAL RESULT.\n* THE TRICK IS THAT  1000(1000(MONTH)+DAY)+YEAR  GIVES  MM0DD0YY  WHEN\n* CONVERTED TO DECIMAL.  AFTER UNPACKING, THE ZEROS ARE REPLACED BY\n* SLASHES.\n         SPACE\n         MH    RMONTH,H1000\n         AR    RMONTH,RDAY\n         MH    RMONTH,H1000\n         AR    RMONTH,RYEAR\n         CVD   RMONTH,DWORD\n         MVC   DWORD(5),DWORD+3        MOVE OVER FOR UNPACKING\n         UNPK  DWORD(8),DWORD(5)       CONVERT TO ALPHA\n         OI    DWORD+7,X'F0'           COVER UP SIGN\n         MVI   DWORD+2,C'/'            INSERT SLASHES\n         MVI   DWORD+5,C'/'\n         SR    15,15                   SET NORMAL RETURN CODE OF 0\n         SPACE\nEXIT     RETURN  (14,12),T,RC=(15)     RETURN TO CALLER\n         SPACE 2\n* FOR ARGUMENTS WHOSE DAY NUMBER IS ZERO OR TOO LARGE, RETURN IN\n* 'DWORD' THE EDITED VALUE  C' YY.DDD ' AND SET A RETURN CODE OF 4.\n         SPACE\nBADDATE  ST    RARGSAVE,DWORD          RESTORE ORIGINAL PACKED ARGUMENT\n         UNPK  DWORD+2(5),DWORD+1(3)   UNPACK INTO ALPHA\n         MVC   DWORD+1(2),DWORD+2      SHIFT YEAR 1 LEFT\n         MVI   DWORD,C' '              APPLY COSMETICS\n         MVI   DWORD+3,C'.'\n         MVI   DWORD+7,C' '\n         LA    15,4                    SET RETURN CODE\n         B     EXIT\n         EJECT\n* LISTS OF MONTH SIZES FOR STANDARD AND LEAP YEARS:\n         SPACE\n         SPACE\nSTDLIST  DC    H'365'          DAY LIMIT FOR STANDARD YEARS\n         DC    AL1(31)\n         DC    AL1(28)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         SPACE\nLPYLIST  DC    H'366'          DAY LIMIT FOR LEAP YEARS\n         DC    AL1(31)\n         DC    AL1(29)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         SPACE\nF1000    DC    F'1000'\nH1000    EQU   F1000+2\n         LTORG\n         SPACE\n         END\n//*KED.SYSLMOD DD DISP=OLD,DSN=SYS1.OACLINK\n//LKED.XXX     DD DISP=SHR,DSN=SYS9.MSSLOAD\n//LKED.SYSIN DD *\n INCLUDE XXX(IXTOFMT5)\n ENTRY VTOCLIST\n NAME VTOCLIST(R)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT149/FILE149.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT149", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}