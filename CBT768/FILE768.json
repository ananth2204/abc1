{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012744000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1998724, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE768.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1998724, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1998724, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE768.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x1f\\t'", "DS1TRBAL": "b\"'\\x0c\""}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x055\\x00\\x08\\x057\\x00\\t\\x00 '", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x04K\\x00\\x00\\x01\\x07'?\\x01\\x07'?\\x19Q\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf5@@@\"", "ispf": {"version": "04.75", "flags": 0, "createdate": "2007-09-30T00:00:00", "modifydate": "2007-09-30T19:51:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-475"}, "text": "REGULAR CBT TAPE - VERSION 475    FILE:  768\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT475.FILE768\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 11 MEMBERS COUNTED; CUMULATIVE SIZE IS 18,540 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   09/30/07    19:51:40    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE768": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x04K\\x00\\x00\\x01\\x07'?\\x01\\x07'?\\x19Q\\x00c\\x00c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf5@@@\"", "ispf": {"version": "04.75", "flags": 0, "createdate": "2007-09-30T00:00:00", "modifydate": "2007-09-30T19:51:00", "lines": 99, "newlines": 99, "modlines": 0, "user": "CBT-475"}, "text": "//***FILE 768 is from Rick Bourgeois, and contains an adaptation    *   FILE 768\n//*           of the \"real tape to AWS tape\" and vice-versa         *   FILE 768\n//*           facilities, from File 533, to run under CMS.  The     *   FILE 768\n//*           following is a description of this package.  The      *   FILE 768\n//*           package also includes Sam Golob's utilities to        *   FILE 768\n//*           convert real tape to FLEX-ES (R) Faketape, and        *   FILE 768\n//*           vice-versa.                                           *   FILE 768\n//*                                                                 *   FILE 768\n//*           email:  rick@vsoftsys.com                             *   FILE 768\n//*                                                                 *   FILE 768\n//*     VTT2 AWSTAPE and FAKETAPE                                   *   FILE 768\n//*     Real tape conversion utilities                              *   FILE 768\n//*                                                                 *   FILE 768\n//*     This package updates Sam Golob's REAL tape to AWSTAPE       *   FILE 768\n//*     or FAKETAPE and AWSTAPE or FAKETAPE to REAL tape MVS        *   FILE 768\n//*     package to run under CMS or MVS.                            *   FILE 768\n//*                                                                 *   FILE 768\n//*     Updated by Rick Bourgeois - rick@vsoftsys.com This file     *   FILE 768\n//*     is included in the VTT2EXEC FILES file as VTT2CMS DOC.      *   FILE 768\n//*                                                                 *   FILE 768\n//*     For additional information on Sam's package see             *   FILE 768\n//*     CBT Tape File 533.                                          *   FILE 768\n//*                                                                 *   FILE 768\n//*     The changes to Sam's code that allow his programs to        *   FILE 768\n//*     run under CMS or MVS were done using conditional assembly   *   FILE 768\n//*     code.  A VTTEQUAT copy file was created and contains a      *   FILE 768\n//*     &RUNSYS variable that is used to identify the target        *   FILE 768\n//*     system.  The &RUNSYS variable can be coded as 'O/S' or      *   FILE 768\n//*     'CMS' and the copy file must be in the maclib used for      *   FILE 768\n//*     the assemblies.  It specifies 'CMS' in this                 *   FILE 768\n//*     distribution so must be changed for MVS assemblies.         *   FILE 768\n//*     The VTTEQUAT copy file also contains the register           *   FILE 768\n//*     equates, version variable and default chunk size used       *   FILE 768\n//*     when creating AWSTAPE or FAKETAPE disk files.               *   FILE 768\n//*                                                                 *   FILE 768\n//*     There are 8 members in this file.                           *   FILE 768\n//*                                                                 *   FILE 768\n//*     1. IEBUPDAP EXEC  - Create an append file                   *   FILE 768\n//*     2. IEBUPDEX EXEC  - Extract files from an append file       *   FILE 768\n//*     3. VTT2EXEC FILES - CMS EXEC files                          *   FILE 768\n//*     4. VTT2JCL  FILES - MVS JCL files                           *   FILE 768\n//*     5. VTT2SRCE FILES - Assembler source and copy files         *   FILE 768\n//*     6. VTT2DOC  FILES - Sam's documentation files               *   FILE 768\n//*     7. VTT2TEST FILES - Two test files from Sam's download      *   FILE 768\n//*     8. VTT2TEXT FILES - CMS executable TEXT files               *   FILE 768\n//*                                                                 *   FILE 768\n//*     The IEBUPDAP exec was used to create append files for       *   FILE 768\n//*     each of the different file types.  There is a './ ADD       *   FILE 768\n//*     NAME=filename cmsattrb' where cmsattrb are the CMS          *   FILE 768\n//*     attributes of the file.  Ex;( ./ ADD NAME=IEBUPDAP EXEC     *   FILE 768\n//*     F 80 9/27/07 8:17:46)                                       *   FILE 768\n//*                                                                 *   FILE 768\n//*     The IEBUPDEX exec will extract the individual files         *   FILE 768\n//*     from the append files and write them to a CMS disk or       *   FILE 768\n//*     directory.  IEBUPDTE can be used to add the files to an     *   FILE 768\n//*     MVS PDS.                                                    *   FILE 768\n//*                                                                 *   FILE 768\n//*     IEBUPDEX command format;                                    *   FILE 768\n//*     IEBUPDEX infn FILES infm outfm                              *   FILE 768\n//*     If outfm is omitted the files will be written to the        *   FILE 768\n//*     file mode identified by infm.                               *   FILE 768\n//*                                                                 *   FILE 768\n//*     These are the execs and files in the VTT2EXEC FILES file    *   FILE 768\n//*                                                                 *   FILE 768\n//*     VTT2     CNTRL   - Assembly control file                    *   FILE 768\n//*     IEBUPDAP EXEC    - Build an IEBUPDTE format append file     *   FILE 768\n//*     IEBUPDEX EXEC    - Extract files from an append file        *   FILE 768\n//*     VTT2ASM  EXEC    - Assemble a VTT2 source file              *   FILE 768\n//*     VTT2CNVU EXEC    - Convert VB AWSTAPE disk file to FB       *   FILE 768\n//*     VTT2DISK EXEC    - Real tape to AWSTAPE disk file           *   FILE 768\n//*     VTT2FK2T EXEC    - FAKETAPE disk file to real tape          *   FILE 768\n//*     VTT2INST EXEC    - Build VTT2MAC maclib and assemble        *   FILE 768\n//*                        all source                               *   FILE 768\n//*     VTT2TAPE EXEC    - AWSTAPE disk file to real tape           *   FILE 768\n//*     VTT2T2FK EXEC    - Real tape to FAKETAPE disk file          *   FILE 768\n//*     VTT2DISK INPUT   - SYSIN for VTT2DISK and VTT2T2FK execs    *   FILE 768\n//*     VTT2TAPE INPUT   - SYSIN for VTT2TAPE and VTT2FK2T execs    *   FILE 768\n//*     VTT2AWS INSTDISK - Dummy file to identify the install       *   FILE 768\n//*                        disk                                     *   FILE 768\n//*                                                                 *   FILE 768\n//*     The VTT2INST exec will rebuild the VTT2MAC MACLIB and       *   FILE 768\n//*     assemble all of the assembler source.  The maclib and       *   FILE 768\n//*     text files will be written to the disk that contains        *   FILE 768\n//*     the VTTAWS INSTDISK file.  You can optionally specify a     *   FILE 768\n//*     file mode when you execute the VTT2INST exec.               *   FILE 768\n//*                                                                 *   FILE 768\n//*     The VTT2INST exec will erase the VTT2MAC MACLIB and         *   FILE 768\n//*     regenerate the maclib with the VTTEQUAT COPY file.  If      *   FILE 768\n//*     you want to add additional macros or copy files in the      *   FILE 768\n//*     VTT2MAC MACLIB you can add MACLIB ADD statements            *   FILE 768\n//*     following the MACLIB GEN in the exec.  The VTT2INST         *   FILE 768\n//*     exec executes the VTT2ASM exec for each assemble file       *   FILE 768\n//*     on the install disk.  The VTT2ASM EXEC uses the             *   FILE 768\n//*     VMFHLASM exec for the assemblies.  If you do not have       *   FILE 768\n//*     the high level assembler you will need to change the        *   FILE 768\n//*     VTT2ASM exec for the assembler you use.  The VTT2 CNTRL     *   FILE 768\n//*     file is used to specify the macro libraries for the         *   FILE 768\n//*     VMFHLASM exec.                                              *   FILE 768\n//*                                                                 *   FILE 768\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEBUPDAP": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x07'?\\x01\\x07'?\\x18#\\x00k\\x00k\\x00\\x00\\xd9\\xc9\\xc3\\xd2\\xc2@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-09-30T00:00:00", "modifydate": "2007-09-30T18:23:00", "lines": 107, "newlines": 107, "modlines": 0, "user": "RICKB"}, "text": "/*-----------------------------------------------------------*/\n/* Add the contents of a file to an append file separating   */\n/* the contents with \"./ ADD NAME=filename filetype\".        */\n/*                                                           */\n/* Information folowing the filetype in the ./ ADD card      */\n/* includes the original RECFM, LRECL and the date and time  */\n/* the original file was last updated.                       */\n/*                                                           */\n/* The append file can be VMARC packed for transmission to   */\n/* another location or downloaded and zipped for transmission*/\n/*                                                           */\n/* The files in the append file created by IEBUPDAP can be   */\n/* extracted to a CMS mdisk using the IEBUPDEX exec or can   */\n/* be loaded to a z/OS PDS file using IEBUPDTE.              */\n/*                                                           */\n/* If yoy have any problems with this exec contact;          */\n/* Rick Bourgeois at rick@vsoftsys.com                       */\n/*                                                           */\n/* Syntax: i_fname i_ftype i_fmode o_fname o_ftype o_fmode   */\n/*-----------------------------------------------------------*/\n\naddress command\nsignal on novalue\nsignal on syntax\n\narg newfn newft newfm outfn outft outfm . '(' width\n\nif outfm = '' then signal missing /* Make sure all are given.*/\nif width = '' then width = 80     /* Default width to 80.    */\n\nif newfm = 'A' then do\n   say 'Input filemode is A, continue Y|N'\n   pull ans\n   if ans \\= 'Y' then exit 4\n   end\n\n'MAKEBUF'                         /* Get recfm and lrecl.    */\n'LISTFILE' newfn newft newfm '(FIFO DATE NOHEADER'\nif rc \\= 0 then signal ifile_notfnd\npull . . . recfm wid2 . . fdate ftime .\norgfm = newfm                     /* Save original filemode. */\npack = 'NO'                       /* Default not packed      */\nif wid2 >= 1024 then call unpack\nif wid2 > width then signal trunc_err /* Check new width.    */\n'DROPBUF'\n\n'EXECIO 1 DISKW' outfn outft outfm,   /* Write the separator.*/\n   '0 F' width '(FINIS STRING ./ ADD NAME='newfn ,\n      newft recfm wid2 fdate ftime\n\n'COPYFILE' newfn newft newfm,     /* And write the file data.*/\n   outfn outft outfm '(APPEND'\n\n'FINIS' outfn outft outfm         /* Close the file.         */\nif pack = 'YES' then call repack\nexit\n\nunpack:\n\npack = 'YES'                      /* Unpack file to A-disk.  */\n'COPY' newfn newft newfm '= = A (UNPACK OLDDATE REPLACE'\nif rc \\= 0 then signal unp_failed /* Error if unpack failed  */\nnewfm = 'A'                       /* Append from here now.   */\n'LISTFILE' newfn newft newfm '(FIFO FORMAT NOHEADER'\npull . . . recfm wid2 .           /* Get new width.          */\nrecfm = recfm'P'                  /* Show it's packed.       */\n\nreturn\n\nrepack:\nif orgfm = 'A' then do            /* Repack or erase pkd file*/\n   'COPY' newfn newft newfm '= = = (PACK OLDDATE REPLACE'\n   if rc \\= 0 then signal rep_failed /* Error if repack fails*/\n   end\n   else 'ERASE' newfn newft 'A'\nreturn\n\nmissing:\nsay 'Arg: input-filename type mode, output-filename type mode'\nexit 16\n\ntrunc_err:\nsay 'File' newfn newft newfm 'lrecl is',\n     wid2'; file not appended.'\nexit 24\n\nifile_notfnd:\nsay 'Requested file' newfn newft newfm 'was not found'\nexit 28\n\nrep_failed:\nsay 'Error repacking' newfn newft newfm 'on A-disk.'\nexit 32\n\nunp_failed:\nsay 'Error unpacking' newfn newft newfm 'to A-disk.'\nexit 34\n\nnovalue:\nsay 'NOVALUE error on line' ,\n sigl 'of IEBUPDAP EXEC'\nexit 50\n\nsyntax:\nsay 'SYNTAX error on line' ,\n sigl 'of IEBUPDAP EXEC'\nexit 60\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEBUPDEX": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x07'?\\x01\\x07'?\\x18#\\x00\\x9b\\x00\\x9b\\x00\\x00\\xd9\\xc9\\xc3\\xd2\\xc2@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-09-30T00:00:00", "modifydate": "2007-09-30T18:23:00", "lines": 155, "newlines": 155, "modlines": 0, "user": "RICKB"}, "text": "/*-----------------------------------------------------------*/\n/* Extract logical files from a single input (transfer) file */\n/* which has a \"./ ADD NAME=filename filetype\" in front of   */\n/* each file in an append file created by the IEBUPDAP exec. */\n/*                                                           */\n/* Information folowing the filetype in the ./ ADD card      */\n/* includes the original RECFM, LRECL and the date and time  */\n/* the original file was last updated.                       */\n/*                                                           */\n/* When the file is created on the target CMS mdisk it is    */\n/* created with the original RECFM, LRECL, date and time.    */\n/*                                                           */\n/* The files in the append file can also be loaded to a z/OS */\n/* PDS using IEBUPDTE.                                       */\n/*                                                           */\n/* Be careful, because this exec will replace (erase) files  */\n/* with the output filename and filetype on the target disk. */\n/*                                                           */\n/* If yoy have any problems with this exec contact;          */\n/* Rick Bourgeois at rick@vsoftsys.com                       */\n/*                                                           */\n/* Syntax: input_fname input_ftype input_fmode output_fmode  */\n/*-----------------------------------------------------------*/\n\naddress command\nsignal on novalue\nsignal on syntax\n\narg infn inft infm outfm . '(' opts /* Get the arguments.    */\n\nif infm = '' then signal missing  /* Make sure all are given.*/\n\nif outfm = '' then outfm = infm   /* If no output filemode   */\n\n/* Find the first separator line in the input file.          */\n'EXECIO * DISKR' infn inft infm,\n   '1 (FINIS STEM INFILE. FIND \\./ \\'\nif rc \\= 0 then signal read_error\nfirstrec = word(infile.2,1)       /* First sep line.         */\n\n/* Position the file.                                        */\n'EXECIO' firstrec-1 'DISKR' infn inft infm '1 (SKIP'\nif rc \\= 0 then signal read_error\n\nsepline = ''                      /* Separator line with '\\'.*/\npack = 'N'                        /* Default not to pack.    */\n\ndo forever                        /* Process each line...    */\n   'EXECIO 1 DISKR' infn inft infm '(VAR INFILE'\n   if rc \\= 0 then leave\n   if left(infile,3) = './ ' then do /* For a separator,     */\n      call close                   /* close previous file    */\n      filerecs = 0\n      sepline = infile\n      parse var infile . add nkw '=' outfn outft rf lr fdate ftime . ';'\n      if outfn = '.' then iterate        /* For ;E lines.    */\n      if outft = 'EXEC' then rfm = 'V'   /* EXECs = recfm V  */\n         else rfm = 'F'                  /* by default.      */\n      if rf \\= '' then rfm = left(rf,1)  /* Was recfm given? */\n      if lr = '' then lr = 80     /* Default to lrecl 80*/\n\n      'STATE' outfn outft outfm   /* File exist already?     */\n      staterc = rc\n      if staterc = 0 then ,\n         'ERASE' outfn outft outfm   /* Erase it.            */\n\n      if ftime \\= '' then do\n        if staterc \\= 0             /* Give correct message. */\n           then say 'Creating' outfn outft outfm 'with date' ,\n              fdate ftime\n           else say 'Replacing' outfn outft outfm 'with date',\n              fdate ftime\n        end /* sep line */\n      else do\n        if staterc \\= 0             /* Give correct message. */\n           then say 'Creating' outfn outft outfm\n           else say 'Replacing' outfn outft outfm\n        end /* sep line */\n      end\n\n   else do\n      /* Write line; lrecl ignored for recfm = V.            */\n      'EXECIO 1 DISKW' outfn outft outfm,\n         '0' rfm lr '(STRING' strip(infile,'T')\n\n      if rc \\= 0 then signal write_error  /* Write error?    */\n      filerecs = 1\n      end\n\n   end /* do forever */\n\ncall close                        /* Close last output file. */\n\nexit\n\nclose:\nif sepline = '' then return       /* Nothing the first time. */\n\nif filerecs = 0 then do\n   say outfn outft outfm 'is a null file, contact VSSI'\n   return\n   end /* filerecs */\n\nif outfn \\= '.' then do\n   'FINIS' outfn outft outfm      /* Close the file.         */\n   if rc \\= 0 then signal close_err\n   end\n\nif ftime \\= '' then do\n    'DMSPLU' outfn outft outfm right(fdate,8,0) ,\n       right(ftime,8,0)\n    if rc \\= 0 then\n    say outfn outft outfn 'date set with DMSPLU failed RC' rc\n    end\n\nif right(rf,1) = 'P' then do      /* Pack file if required.  */\n   'COPYFILE' outfn outft outfm '= = = (PACK OLDDATE'\n   if rc \\= 0 then call pack_err\n   end\n\nreturn\n\nread_error:                       /* Error reading file.     */\nsaverc = rc\n'STATE' infn inft infm            /* Is file there?          */\nif rc \\= 0\n then say 'Input file' infn inft infm 'does not exist.'\n else say 'Return code' saverc 'reading file.'\nexit saverc\n\nwrite_error:                      /* Error writing file.     */\nsay 'Return code' rc 'from EXECIO 1 DISKW' outfn outft outfm\nexit rc\npack_err:                         /* Error repacking file.   */\nsay 'Return code' rc 'packing file' outfn outft outfm\nexit rc\n\nclose_err:                        /* Error Closing file.     */\nsay 'Finis return code' rc 'closing file' outfn outft outfm\nexit rc\n\ndropbuf:\nsaverc = rc\n'DROPBUF'\nexit saverc\n\nnovalue:\nsay 'NOVALUE error on line' ,\n sigl 'of IEBUPDEX EXEC'\nexit 50\n\nsyntax:\nsay 'SYNTAX error on line' ,\n sigl 'of IEBUPDEV EXEC'\nexit 60\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTT2CMS": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00!\\x01\\x07'?\\x01\\x07'?\\x18'\\x00S\\x00S\\x00\\x00\\xd9\\xc9\\xc3\\xd2\\xc2@@@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2007-09-30T00:00:00", "modifydate": "2007-09-30T18:27:21", "lines": 83, "newlines": 83, "modlines": 0, "user": "RICKB"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "VTT2DOC": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x07'?\\x01\\x07'?\\x18\\x17\\x01\\xdd\\x01\\xdd\\x00\\x00\\xd9\\xc9\\xc3\\xd2\\xc2@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-09-30T00:00:00", "modifydate": "2007-09-30T18:17:00", "lines": 477, "newlines": 477, "modlines": 0, "user": "RICKB"}, "text": "./ ADD NAME=$$$#DATE DOC F 80 9/21/07 13:45:00\nREGULAR CBT TAPE - VERSION 470    FILE:  533\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT470.FILE533\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 37 MEMBERS COUNTED; CUMULATIVE SIZE IS 14,481 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   09/23/05    10:10:53    GMT-4:00\n\n./ ADD NAME=$$$COSBG DOC F 80 9/21/07 13:45:00\nVirtual Tape Transportation System (VTTS)\n\nCopyright (c) 2001 - 2005 by Sam Golob\n\nAll rights reserved, except where specific permission\nis given by the copyright holder.\n\nPermission is granted to assemble and run the subset of\nthese materials from the Virtual Tape Transportation\nSystem which are present on the CBT Tape collection,\nbut all rights remain with the copyright holder.\n\n./ ADD NAME=$$CHANGE DOC F 80 9/21/07 13:45:00\n        VTT2 Package Revision History - after the initial release\n\n  Copyright (c) 2001-2005 by Sam Golob.\n\n  Any commercially sold or restricted components of this system\n    will not be available or distributed with the CBT Tape\n    software collection.  Presence of a component on the CBT\n    Tape collection indicates that the copyright holder allows\n    use by the public, of that component.\n\n  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nRevision  01/02/05\n\n  VTT2T2FK  -  This is a new program which creates a FAKETAPE (TM)\n   1.12        image disk file from any tape input.  Similar in\n               function to VTT2DISK, except that the output disk\n               file is in FAKETAPE format instead of AWS format.\n\nRevision  12/30/04\n\n  VTT2DISK  -  Fixed the program logic to be able to create an AWS\n   1.12        tape file with any size chunks, up to 65535 bytes\n               (which is the default).  The chunk size can be changed\n               either at assembly time by changing a global variable,\n               or in SYSIN by using the CHUNKSIZE=nnnnn keyword,\n               starting in column 1.  All data folding is now done\n               by a sub-program called FOLDEM, which is driven by a\n               control block called FLDAREA.  See the code for\n               details.\n\nRevision  07/28/05\n\n  VTT2TAPE  -  Put in ASG enhancement to allow a volser change\n   1.13        through a PARM='TVOL=nwvser', or\n               PARM='TVOL(nwvser)'.  When entering the new volser\n               this way, I put in a check for short volsers (less\n               than 6 characters) and ran the volser from the PARM\n               through a translate table first, to uppercase it\n               and clean it up somewhat.  The volser that is coded\n               in the SYSIN DD card can completely override this,\n               so you still have the freedom to create bizarre\n               volsers if you really want to.  BTW, you do not\n               need to code the new volser in the JCL.  This\n               program does not do a RDJFCB to find out what is in\n               the JCL.\n\nRevision  12/12/04\n\n  VTT2TAPE  -  Fixed the program logic to be able to read an AWS\n   1.12        tape file with \"short chunks\".  Included the UNFOLDEM\n               program to do all data moves from the folded FB-80\n               AWS-format file, to the data buffer.  So this logic\n               has been completely removed from the VTT2TAPE main\n               program.  The UNFOLDEM program is driven by the\n               contents of a control block called UNFAREA.  See the\n               program code itself for further explanation.\n\n  VTT2FK2T  -  This is a new program, modeled after the current\n   1.12        version of VTT2TAPE, which reads a FLEX-ES FAKETAPE\n               file, folded into FB-80 format on any MVS system,\n               and writes a real tape on a real (or virtual) tape\n               drive, from the FAKETAPE file data.\n\nRevision  07/22/03\n\n  VTT2TAPE  -  Added optional SYSIN ddname to be able to change\n   1.10        the volser of the output tape.  Code as follows:\n\n               //SYSIN DD *\n               NEWVOL=volser     (has to start in column 1)\n               /*\n\n  VTT2DISK  -  Added parameter IDRCOFF.  If this is coded, then\n   1.10        VTT2DISK turns off the IDRC indicators in the output\n               AWS tape file.  These are in the VOL1 label, and the\n               HDR2, EOF2, EOV2 labels.\n\nRevision  12/11/02\n\n  VTT2CNVU  -  Changed trailer characters to fill out the FB-80\n   1.1         fixed records, from x'20' to x'00' as per request\n               from Reed Petty, and the discussion of the Hercules\n               forum.\n\nRevision  12/10/02\n\n  VTT2DISK  -  Changed trailer characters to fill out the FB-80\n   1.11        fixed records, from x'20' to x'00' as per request\n               from Reed Petty, and the discussion of the Hercules\n               forum.\n\n./ ADD NAME=$VTT2DOC DOC F 80 9/21/07 13:45:00\n         Documentation for the VTT2TAPE and VTT2DISK Programs\n\n        (A part of VTTS - \"Virtual Tape Transportation System\")\n\nSam Golob - copyright (c) 2001-2005 by Sam Golob\n\n    The VTTS (Virtual Tape Transportation System) is copyrighted\n    and owned by Sam Golob.  But modules VTT2TAPE and VTT2DISK in\n    their \"free versions\" will be freely usable without charge,\n    even though these programs are the property of Sam Golob,\n    either in source code, object deck, or load module form, or\n    in any format or encoded in any way.\n\n    What are the \"free versions\"?  These are the versions of VTT2TAPE\n    and VTT2DISK that are distributed with the CBT Tape collection.\n\n    The VTT2DISK and VTT2TAPE programs allow an MVS system to move\n    entire tapes to disk, and create tapes from these disk files again.\n\n    The VTT2CNVU program is an MVS program to convert RECFM=VB AWS\n    files into FB-80 format, so they can be read by VTT2TAPE to cut\n    a real tape.\n\n    The VTT2FK2T program is like VTT2TAPE, but it takes a FAKETAPE\n    virtual tape file (from FLEX-ES), which had been folded into FB-80\n    format on any MVS system, and writes a real tape from that data.\n    FTP will fold an external file of this type, like a FAKETAPE file,\n    into an FB-80 format MVS file, if you tell it to, or if you\n    pre-allocate the target file as FB-80 on the MVS system.\n\nSome of the need for the programs:\n\n            AWS Tape format is produced by P/390 and Hercules systems\n            to create disk files, which an MVS system reads and writes,\n            as if they were actual tapes.   Therefore, an MVS system\n            without a tape drive, if it is so equipped to produce\n            \"virtual tapes\" in AWS Tape format, can write to tapes, and\n            read from tapes.  These tapes are really disk files.\n            Another name for these disk files is \"virtual tapes\",\n            because the MVS system looking at these files \"thinks\"\n            that they really are tapes.\n\n            There have existed programs which can read REAL tapes and\n            create virtual tapes from them.  One example is Brandon\n            Hill's AWSUTIL program.  These virtual tapes can be loaded\n            on a Hercules system somewhere and be read as a tape.\n\n            Our program VTT2DISK performs this function also, by\n            reading a REAL tape and producing an FB-80 \"folded\n            AWS-format tape\" as an MVS disk file.  In doing the reading,\n            the VTT2DISK program produces a lot of stats about the tape.\n            The advantage of the VTT2DISK program is that it can be run\n            on a \"big iron\" mainframe-based MVS system that cannot\n            normally produce AWS-format virtual tapes.  VTT2DISK\n            will produce AWS-format \"tape\" disk files on \"real MVS\".\n\n            The main problem is, to also go the other way.\n\n            Suppose you have an MVS system that can't read a tape in\n            AWS format.  Most large MVS systems which are not P/390 or\n            Hercules machines, but they are real MVS machines--big\n            iron--are in this position.  So for them, how do you\n            convert an AWS \"virtual tape\" disk file to some format\n            that the MVS system can convert into a REAL tape?  That\n            is the purpose of the VTT2TAPE program.\n\n            As easy as the concept seems:  Take an AWS format tape, and\n            make it readable to MVS--in practice, there is a large\n            complication, which I hope to explain.\n\n            A large part of describing this problem is the understanding\n            of the rather simple AWS tape format.  Once you understand\n            AWS tape format (as it exists on an OS/2 system or a PC),\n            the difficulty of reading this file on a \"pure MVS system\"\n            will become clear.  I hope that the rest of my explanation\n            will serve to clear up the difficulty.\n\nAWS Tape File on OS/2 or a PC is a Continuous stream of data:\n\n            The essence of the AWS tape format is that on a PC, or on\n            an OS/2 system, the \"tape file\" appears logically, as one\n            continuous stream of data.  For example, a CBT Master Tape,\n            (the SL version that I use), at the time of this writing,\n            is about 331 million bytes long.  On OS/2 or on the PC, this\n            looks like one continuous stream of data that is 331 million\n            bytes long.  For all practical purposes there is no blocking\n            of the data at all.\n\n            That presents a problem on MVS, where just about all data\n            has to be blocked.   On MVS, you must \"fold the data over\"\n            into blocks and records.  For my convenience, I have\n            chosen to fold the AWS tape data as Fixed Blocked LRECL=80\n            card image files.  Such files are conveniently handled on\n            MVS systems and in transmission processes, and you can\n            browse (and even edit) all of the \"tape data\" on TSO.\n            (You can even read the FB-80 \"tape data\" into an internal\n            reader.)\n\n            Then you must un-fold the data, logically.\n\n            My MVS program VTT2TAPE reads in the AWS tape data that was\n            uploaded to MVS from a PC or OS/2 system, and folded into\n            FB-80 card images, and it writes out an actual tape, using\n            EXCP to write the blocks.\n\n            As with the VTT2DISK program, the VTT2TAPE program produces\n            many stats, as it writes the new tape from the disk version\n            of the \"tape\" in FB-80 AWS format.\n\nAWS Tape Format:\n\n            Although a \"tape\" in the AWS Tape format appears\n            continuous, tape files are delimited by means of 6-byte\n            headers.  Each tape block is preceded by a header, and\n            followed by a header.  Also, end-of-file is indicated by\n            a different header.  The end-of-file header roughly\n            corresponds to a tape mark, preceded by the \"write out\"\n            of the last data block.  Every AWS tape file starts out\n            with a header.\n\n            Three two-byte segments comprise the header.\n\n            The first two-byte segment contains the number of bytes in\n            the block to follow (but this is in \"PC format\" with the\n            two bytes reversed).\n\n            This value will be zero for the header that comes after\n            the last block of a file.\n\n            The second two-byte segment contains the number of bytes in\n            the block of data which immediately preceded this header.\n            That value may be zero, and is zero if the header is the\n            first header for a file.  Again, the two-byte value cannot\n            be read as a halfword quantity, unless the bytes are\n            reversed.  This is the backwards PC Intel format for\n            halfwords (which I term BIF, or Backwards Intel Format).\n\n            The third two-byte piece of the header might be more\n            complicated in the future, but right now it is very\n            simple:   X'A000' denotes a block in the beginning or\n            in the middle of a file.  X'4000' denotes an end-of-file.\n\n            A block of data might be broken up into CHUNKS.  Each\n            chunk lies between two headers.  The flag byte in the\n            header preceding the beginning chunk of a block is\n            X'80'.  The flag byte for the middle chunk of a block is\n            X'00'.  The flag byte for the end chunk of a block is\n            X'20'.  If a chunk is an entire block, then its flag\n            byte of the header preceding it, is X'A0' (combined\n            X'80' and X'20') as we have stated before.\n\n            A final tapemark for a tape, therefore, is:\n                 X'000000004000'\n\n            That's all folks.  It's all very simple.  You just have\n            to think about it.\n\nBackwards Intel Halfword Format:\n\n            Halfwords in the AWS headers are in \"Backwards Intel\n            Format\" or \"PC Format\".  For example, the quantity\n            32720, which is a normal block size for Fixed 80-byte\n            LRECL files, is usually represented in a halfword as\n            X'7FD0'.  But in Backwards Intel Format, this is\n            represented as X'D07F'.  (Got it?)\n\nThe Hard Part:\n\n            The hard part of writing VTT2TAPE was:\n\n            1 - Tracking through the 80-byte records and finding\n                all the headers.\n\n            2 - Correctly moving the right number of data bytes,\n                and the right data blocks that are in between the\n                headers, to the correct place in the output buffer\n                that is in the program.\n\n            3 - Once each data block is moved entirely, and\n                correctly, into the output buffer (in the program),\n                putting them out to tape with EXCP is a snap.\n                The number of bytes to move is taken from the\n                \"next byte count\" field in the header that\n                precedes the current block.  This value is checked\n                against the accumulated total of data bytes moved.\n\n            4 - The X'4000'-third-byte headers cause the write of a\n                tape mark.\n\n   The data unfolding from FB-80 file to tape buffer is now done by\n   a completely separate sub-program called UNFOLDEM.  The data\n   folding from tape buffer to FB-80 file is now done by a completely\n   separate sub-program called FOLDEM.  Each of these sub-programs\n   communicates with its caller by means of a control block.  The\n   UNFOLDEM program uses the UNFAREA control block, and the FOLDEM\n   program uses the FLDAREA control block.  The formats of these\n   are included here, as appropriately named members of this pds.\n\nWell folks, that's how it works:\n\n       Sam Golob        email:  sbgolob@attglobal.net\n                                sbgolob@aol.com\n\n\n./ ADD NAME=@FILE533 DOC F 80 9/21/07 13:45:01\n//***FILE 533 is from Sam Golob, and contains the VTT2TAPE and      *   FILE 533\n//*           VTT2DISK programs, in their \"free versions\".          *   FILE 533\n//*                                                                 *   FILE 533\n//*           The programs in this package are part of the          *   FILE 533\n//*           Virtual Tape Transportation System (VTTS), which      *   FILE 533\n//*           is copyrighted (c) 2001 - 2005 by Sam Golob.          *   FILE 533\n//*                                                                 *   FILE 533\n//*           Copyright notices are present in the source and       *   FILE 533\n//*           load modules, but the versions of these programs      *   FILE 533\n//*           that are on the CBT Tape, ARE ALLOWED TO BE RUN       *   FILE 533\n//*           BY ANYONE, because the copyright holder has given     *   FILE 533\n//*           full permission.  The copyright holder retains all    *   FILE 533\n//*           ownership rights to the software.                     *   FILE 533\n//*                                                                 *   FILE 533\n//*           Unless otherwise mentioned, AWS-format \"virtual tape\" *   FILE 533\n//*           files on an MVS system, have been folded over into    *   FILE 533\n//*           Fixed Blocked 80-byte record format.  AWS-format      *   FILE 533\n//*           files on other systems are just long strings of data. *   FILE 533\n//*           This can't happen on MVS--all data has to be blocked  *   FILE 533\n//*           on MVS.  So I chose FB-80 blocking for the AWS-format *   FILE 533\n//*           and FAKETAPE (TM) format \"virtual tape\" files on MVS. *   FILE 533\n//*                                                                 *   FILE 533\n//*           The FAKETAPE file format is a published interface     *   FILE 533\n//*           of Fundamental Software Inc. and they say in their    *   FILE 533\n//*           documentation that anyone has permission to use the   *   FILE 533\n//*           format, although Fundamental Software reserves the    *   FILE 533\n//*           right to change the format at any time.               *   FILE 533\n//*                                                                 *   FILE 533\n//*           FAKETAPE (TM) and FLEX-ES (TM) are registered         *   FILE 533\n//*           trademarks of Fundamental Software Inc.               *   FILE 533\n//*                                                                 *   FILE 533\n//*       Program Names:                                            *   FILE 533\n//*                                                                 *   FILE 533\n//*           VTT2TAPE - Program to convert AWS-format tape files   *   FILE 533\n//*                      to real tapes.  Any CHUNKSIZE is           *   FILE 533\n//*                      supported, up to the 65535-byte limit.     *   FILE 533\n//*           VTT2DISK - Program to create an AWS-format virtual    *   FILE 533\n//*                      tape file from a real tape.  Any           *   FILE 533\n//*                      CHUNKSIZE tape can be created.  Default    *   FILE 533\n//*                      chunksize is 65535 but that can be either  *   FILE 533\n//*                      changed at assembly time, or with a SYSIN  *   FILE 533\n//*                      CHUNKSIZE=nnnnn parameter.                 *   FILE 533\n//*           VTT2CNVU - Program to convert a VB-format AWS-format  *   FILE 533\n//*                      tape (such as the one produced by Brandon  *   FILE 533\n//*                      Hill's AWSUTIL program on CBT File 467)    *   FILE 533\n//*                      to FB-80 format on MVS, so that VTT2TAPE   *   FILE 533\n//*                      can be used subsequently to convert the    *   FILE 533\n//*                      data to a real tape.                       *   FILE 533\n//*           VTT2T2FK - Like VTT2DISK, except a real tape is       *   FILE 533\n//*                      converted to a FAKETAPE (TM) format tape.  *   FILE 533\n//*           VTT2FK2T - Like VTT2TAPE, except a FAKETAPE (TM)      *   FILE 533\n//*                      tape image, folded over on MVS into FB-80  *   FILE 533\n//*                      format, is converted into a real tape.     *   FILE 533\n//*                                                                 *   FILE 533\n//*           These programs run on an MVS system, and allow        *   FILE 533\n//*           real tapes to be converted to disk files, and         *   FILE 533\n//*           these disk files, back to real tapes.  These          *   FILE 533\n//*           programs do not require a P/390 or a FLEX-ES (TM)     *   FILE 533\n//*           system.  ANY MVS system will run these programs!      *   FILE 533\n//*                                                                 *   FILE 533\n//*           The VTT2DISK program reads a real tape, and           *   FILE 533\n//*           converts it to an AWS-format \"virtual tape\" file      *   FILE 533\n//*           on an MVS system, folded over into FB-80 format.      *   FILE 533\n//*           VTT2DISK now takes SYSIN input in column 1.           *   FILE 533\n//*           Allowed keywords are:                                 *   FILE 533\n//*                                                                 *   FILE 533\n//*           CHUNKSIZE=nnnn     Default is 65535 if not coded.     *   FILE 533\n//*                              This can be changed with an        *   FILE 533\n//*                              assembler global variable.         *   FILE 533\n//*           NEWVOL=volser   -  Changes the VOLSER on VOL1 label   *   FILE 533\n//*           READ            -  Produces READ only run, no AWSOUT  *   FILE 533\n//*           IDRCOFF         -  Turns off \"data is compressed\"     *   FILE 533\n//*                              \"P\" indicators in the tape labels  *   FILE 533\n//*                                                                 *   FILE 533\n//*           The VTT2TAPE program takes this \"folded over\" FB-80   *   FILE 533\n//*           AWS-format file on an MVS system, and cuts a real     *   FILE 533\n//*           tape from it, on a real tape drive.                   *   FILE 533\n//*                                                                 *   FILE 533\n//*           The VTT2FK2T program does a job similar to the        *   FILE 533\n//*           VTT2TAPE program, except that it takes an FB-80       *   FILE 533\n//*           folded image of a FLEX-ES FAKETAPE, and cuts a        *   FILE 533\n//*           real tape from it, on a real tape drive.  Therefore   *   FILE 533\n//*           a FAKETAPE image produced on a FLEX-ES system can     *   FILE 533\n//*           be uploaded in BINARY to an FB-80 format disk file    *   FILE 533\n//*           ON ANY MVS SYSTEM, and a real tape can be cut from    *   FILE 533\n//*           it.                                                   *   FILE 533\n//*                                                                 *   FILE 533\n//*           And VTT2T2FK creates a FAKETAPE file (folded into     *   FILE 533\n//*           FB-80 format) from a real tape.  If this file is      *   FILE 533\n//*           downloaded to the server machine on which FLEX-ES     *   FILE 533\n//*           is running, FLEX-ES can read this image as though     *   FILE 533\n//*           it were a tape.                                       *   FILE 533\n//*                                                                 *   FILE 533\n//*           The disk files which are in FB-80 folded AWS or       *   FILE 533\n//*           FAKETAPE format, can be FTP'ed back to the PC, OS/2   *   FILE 533\n//*           or LINUX server, and read by a P/390 or FLEX-ES or    *   FILE 533\n//*           HERCULES system as a tape.                            *   FILE 533\n//*                                                                 *   FILE 533\n//*           See member $VTT2DOC for details.                      *   FILE 533\n//*                                                                 *   FILE 533\n//*           VTT2TAPE has now been updated to be able to read      *   FILE 533\n//*           a folded AWS tape file that has its chunk size        *   FILE 533\n//*           smaller than the block size, and to produce a         *   FILE 533\n//*           real output tape from it.  Such AWS-format tapes      *   FILE 533\n//*           are created by FLEX-ES systems and the old (very      *   FILE 533\n//*           very very old) P/390 systems.                         *   FILE 533\n//*                                                                 *   FILE 533\n//*           And VTT2DISK can now produced a \"chunked\" AWS tape    *   FILE 533\n//*           file from a real tape.  FAKETAPE (TM) architecture    *   FILE 533\n//*           does not have provision to produced chunked output    *   FILE 533\n//*           (i.e. the tape blocks being divided into smaller      *   FILE 533\n//*           pieces, and the blocks being pieced together later).  *   FILE 533\n//*                                                                 *   FILE 533\n//*           These programs can now be run with PARM=READ in       *   FILE 533\n//*           the EXEC card, which is a \"READ ONLY\" execution       *   FILE 533\n//*           that produces reports about the input tape, or        *   FILE 533\n//*           disk file.                                            *   FILE 533\n//*                                                                 *   FILE 533\n//*           PARM=READ will read the AWS or tape inputs, and       *   FILE 533\n//*           produce these programs' abundant stats.  If you       *   FILE 533\n//*           want to \"measure a tape\" or an AWS-format tape file   *   FILE 533\n//*           on disk, you can use the PARM=READ facility, which    *   FILE 533\n//*           doesn't open the output file.  VTT2CNVU does not      *   FILE 533\n//*           (yet) support PARM=READ.                              *   FILE 533\n//*                                                                 *   FILE 533\n//*           PARM=IDRCOFF in VTT2DISK, will turn off the IDRC      *   FILE 533\n//*           indicators in VOL1, HDR2, EOF2, and EOV2 labels.      *   FILE 533\n//*                                                                 *   FILE 533\n//*           The contents of this file, are part of VTTS           *   FILE 533\n//*           (Virtual Tape Transportation System), which           *   FILE 533\n//*           is copyrighted by Sam Golob, but the versions         *   FILE 533\n//*           of the VTTS programs which are in the CBT Tape        *   FILE 533\n//*           collection, may be used without charge by anyone,     *   FILE 533\n//*           and the copyright owner grants permission.  Same      *   FILE 533\n//*           for the VTT2FK2T and VTT2T2FK programs.               *   FILE 533\n//*                                                                 *   FILE 533\n//*              Sam Golob  -  email:   sbgolob@attglobal.net       *   FILE 533\n//*                                     sbgolob@cbttape.org         *   FILE 533\n//*                                     sbgolob@aol.com             *   FILE 533\n//*                                                                 *   FILE 533\n//*           I've included a free C program from Leland Lucius,    *   FILE 533\n//*           called strippad.c (member STRIPPAD), which strips     *   FILE 533\n//*           off the padding bytes that VTT2DISK adds to the       *   FILE 533\n//*           last FB-80 record on MVS, if it is short.  It seems   *   FILE 533\n//*           that when you copy the FB-80 AWS-format disk file     *   FILE 533\n//*           back to the PC, Hercules has some problems handling   *   FILE 533\n//*           the padding bytes.  The P/390 doesn't.                *   FILE 533\n//*                                                                 *   FILE 533\n//*              Leland Lucius     email:  llucius@moneygram.com    *   FILE 533\n//*                                        llucius@homerow.net      *   FILE 533\n//*                                        hackules@digicron.com    *   FILE 533\n//*                                                                 *   FILE 533\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTT2EXEC": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x07'?\\x01\\x07'?\\x18\\x17\\x03\\x13\\x03\\x13\\x00\\x00\\xd9\\xc9\\xc3\\xd2\\xc2@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-09-30T00:00:00", "modifydate": "2007-09-30T18:17:00", "lines": 787, "newlines": 787, "modlines": 0, "user": "RICKB"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "VTT2JCL": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x07'?\\x01\\x07'?\\x18\\x17\\x01\\xe2\\x01\\xe2\\x00\\x00\\xd9\\xc9\\xc3\\xd2\\xc2@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-09-30T00:00:00", "modifydate": "2007-09-30T18:17:00", "lines": 482, "newlines": 482, "modlines": 0, "user": "RICKB"}, "text": "./ ADD NAME=FOLDEM$ ASMJCL F 80 9/21/07 13:45:02\n//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,ESD,RLD,BATCH,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R15.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R15.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(FOLDEM)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   FOLDEM\n SETSSI  CB468533\n NAME    FOLDEM(R)\n/*\n./ ADD NAME=UNFDRVR$ ASMJCL F 80 9/21/07 13:45:02\n//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,ESD,RLD,BATCH,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R15.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R15.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(UNFDRVR)\n//         DD DISP=SHR,DSN=SBGOLOB.B.ASM(UNFOLDEM)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   UNFDRVR\n SETSSI  CB468533\n NAME    UNFDRVR(R)\n/*\n./ ADD NAME=UNFOLDE$ ASMJCL F 80 9/21/07 13:45:02\n//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,ESD,RLD,BATCH,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R15.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R15.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(UNFOLDEM)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   UNFOLDEM\n SETSSI  CB468533\n NAME    UNFOLDEM(R)\n/*\n./ ADD NAME=VTT2CNV$ ASMJCL F 80 9/21/07 13:45:02\n//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,\n// PARM=(OBJECT,NODECK,BATCH,NOESD,NORLD,NOXREF,SIZE(MAX-1M,ABOVE))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R11.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R11.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(VTT2CNVU)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(CYL,5),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWLKED,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETSSI  CB445533\n SETCODE AC(0)\n NAME VTT2CNVU(R)\n/*\n./ ADD NAME=VTT2DIS$ ASMJCL F 80 9/21/07 13:45:03\n//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,\n// PARM=(OBJECT,NODECK,BATCH,NOESD,NORLD,NOXREF,SIZE(MAX-1M,ABOVE))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R15.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R15.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(VTT2DISK)\n//*        DD DISP=SHR,DSN=SBGOLOB.B.ASM(FOLDEM)\n//SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSALLDA,SPACE=(CYL,5),DISP=(,PASS),\n//            DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETSSI  CB468533\n SETCODE AC(0)\n NAME VTT2DISX(R)\n/*\n./ ADD NAME=VTT2FK2$ ASMJCL F 80 9/21/07 13:45:06\n//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,\n// PARM=(OBJECT,NODECK,BATCH,NOESD,NORLD,NOXREF,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R15.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R15.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(VTT2FK2T)\n//*        DD DISP=SHR,DSN=SBGOLOB.B.ASM(UNFOLDEM)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(CYL,5),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWLKED,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETSSI  CB468533\n SETCODE AC(0)\n NAME VTT2FK2T(R)\n/*\n./ ADD NAME=VTT2TAP$ ASMJCL F 80 9/21/07 13:45:09\n//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,\n// PARM=(OBJECT,NODECK,BATCH,NOESD,NORLD,NOXREF,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R15.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R15.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(VTT2TAPE)\n//*        DD DISP=SHR,DSN=SBGOLOB.B.ASM(UNFOLDEM)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(CYL,5),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWLKED,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETSSI  CB468533\n SETCODE AC(0)\n NAME VTT2TAPX(R)\n/*\n./ ADD NAME=VTT2T2F$ ASMJCL F 80 9/21/07 13:45:11\n//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,\n// PARM=(OBJECT,NODECK,BATCH,NOESD,NORLD,NOXREF,SIZE(MAX-1M,ABOVE))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R15.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R15.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(VTT2T2FK)\n//*        DD DISP=SHR,DSN=SBGOLOB.B.ASM(FOLDEM)\n//SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSALLDA,SPACE=(CYL,5),DISP=(,PASS),\n//            DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY VTT2T2FK\n SETSSI  CB468533\n SETCODE AC(0)\n NAME VTT2T2FK(R)\n/*\n./ ADD NAME=FLDDRVR$ JCL F 80 9/21/07 13:45:01\n//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,ESD,RLD,BATCH,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R15.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R15.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(FLDDRVR)\n//         DD DISP=SHR,DSN=SBGOLOB.B.ASM(FOLDEM)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   FLDDRVR\n SETSSI  CB468533\n NAME    FLDDRVR(R)\n/*\n./ ADD NAME=FLDDRVR# JCL F 80 9/21/07 13:45:01\n//SBGOLOBT JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//UNFTEST  EXEC PGM=FLDDRVR\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//AWSOUT    DD  DISP=(NEW,CATLG,DELETE),DSN=SBGOLOB.FLDDRVR.TEST,\n//          UNIT=SYSALLDA,VOL=SER=WORK01,\n//          DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),\n//          SPACE=(TRK,(15,15),RLSE)\n//TAPIN     DD  DISP=OLD,UNIT=562,VOL=SER=TSTDRV,\n//          LABEL=(1,NL,EXPDT=98000)\n//*         LABEL=(1,BLP,EXPDT=98000)\n//SYSPRINT  DD  SYSOUT=*\n//SYSIN     DD  *\nOFFSET=37\nBYTESM=7643\n/*\n./ ADD NAME=UNFDRVR# JCL F 80 9/21/07 13:45:02\n//SBGOLOBT JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//UNFTEST  EXEC PGM=UNFDRVR\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//AWSIN     DD  DISP=SHR,DSN=SBGOLOB.CBT468.FILE533(TESTDATA)\n//TAPOUT    DD  DISP=OLD,UNIT=562,VOL=SER=TSTDRV,\n//          LABEL=(1,NL,EXPDT=98000)\n//*         LABEL=(1,BLP,EXPDT=98000)\n//SYSPRINT  DD  SYSOUT=*\n//SYSIN     DD  *\nOFFSET=42\nBYTESM=3000\n/*\n./ ADD NAME=VTT2CN1# JCL F 80 9/21/07 13:45:03\n//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//AWSCNVT  EXEC PGM=VTT2CNVU\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//AWSVBIN   DD  DISP=SHR,DSN=SBGOLOB.TST440.AWSIMAGE\n//AWSFBOUT  DD  DISP=SHR,DSN=SBGOLOB.AWSFB80\n//*WSFBOUT  DD  DISP=(NEW,CATLG,DELETE),DSN=SBGOLOB.AWSFB80,\n//*         DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//*         UNIT=SYSALLDA,SPACE=(TRK,(5,5),RLSE)\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n./ ADD NAME=VTT2DIS# JCL F 80 9/21/07 13:45:03\n//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*  Notes:  You can leave all the SYSIN parms out, and\n//*     CHUNKSIZE will default to 65535 (preferred),\n//*     If the new \"virtual tape file\" is Standard Labeled\n//*     (SL) and has a VOLSER, then the new VOLSER will be\n//*     the same as the input tape's VOLSER.\n//*     If the tape was produced originally on a 3490 with\n//*     IDRC compression and is SL, then a virtual 3480 drive\n//*     will not be able to read the tape unless you code\n//*     IDRCOFF, to remove the extra \"P\"s from the tape\n//*     labels, which MVS tape compression introduces.\n//*\n//AWSWRIT  EXEC PGM=VTT2DISK\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//AWSOUT    DD  DISP=SHR,DSN=SBGOLOB.V467MW\n//TAPIN     DD  DISP=OLD,UNIT=562,VOL=SER=V467MU,\n//          LABEL=(1,BLP,EXPDT=98000)\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n//SYSIN     DD  *\nIDRCOFF\nCHUNKSIZE=4096\nNEWVOL=V467MT\n./ ADD NAME=VTT2FK2# JCL F 80 9/21/07 13:45:06\n//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*  Cut a \"real tape\" from a FLEX-ES Faketape virtual\n//*  tape image, which has been folded over on MVS into\n//*  FB (fixed blocked) LRECL=80 format.\n//*\n//AWSREAD  EXEC PGM=VTT2FK2T PARM=READ\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//FAKEIN    DD  DISP=SHR,DSN=SBGOLOB.V467MU.FAKE\n//TAPOUT    DD  DISP=OLD,UNIT=562,VOL=SER=V467TV,\n//          LABEL=(1,BLP,EXPDT=98000)\n//SYSIN     DD  *\nNEWVOL=V467MT\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n./ ADD NAME=VTT2TAP# JCL F 80 9/21/07 13:45:09\n//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*  Produce a \"real tape\" on an MVS system, from an AWS virtual\n//*  tape image that has been folded over on MVS DASD, into\n//*  FB, LRECL=80 format.\n//*\n//AWSREAD  EXEC PGM=VTT2TAPE PARM=READ\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//AWSIN     DD  DISP=SHR,DSN=SBGOLOB.V467TS        <=== FB-80 DISK FILE\n//TAPOUT    DD  DISP=OLD,UNIT=562,VOL=SER=V467TS,\n//          LABEL=(1,BLP,EXPDT=98000)\n//SYSIN     DD  *\nNEWVOL=V467MT\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n./ ADD NAME=VTT2TAP@ JCL F 80 9/21/07 13:45:09\n//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,\n// PARM=(OBJECT,NODECK,BATCH,NOESD,NORLD,NOXREF,SIZE(MAX-1M,ABOVE))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R11.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R11.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(VTT2TAPE)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(CYL,5),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWLKED,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETSSI  CB440533\n SETCODE AC(0)\n NAME VTT2TAPE(R)\n/*\n./ ADD NAME=VTT2TEST JCL F 80 9/21/07 13:45:11\n//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*----------------------------------------------------------*//\n//*  MVS CYCLE TEST FOR VTT2TAPE AND VTT2DISK PROGRAMS       *//\n//*----------------------------------------------------------*//\n//*   DISK FILES SBGOLOB.T439MT AND SBGOLOB.T439MU SHOULD    *//\n//*   COMPARE TO BE IDENTICAL FILES.                         *//\n//*----------------------------------------------------------*//\n//*   USE YOUR OWN TAPE DATA TO RUN THIS TEST IN EITHER      *//\n//*   ORDER - VTT2TAPE FIRST, OR VTT2DISK FIRST.             *//\n//*----------------------------------------------------------*//\n//AWSREAD  EXEC PGM=VTT2TAPE                  /* CUT A REAL TAPE/\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//AWSIN     DD  DISP=SHR,DSN=SBGOLOB.T439MT   /* FB-80 AWS TAPE */\n//TAPOUT    DD  DISP=OLD,UNIT=582,VOL=SER=T439RT,\n//          LABEL=(1,BLP,EXPDT=98000)\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n//*\n//AWSWRIT  EXEC PGM=VTT2DISK                  /* MAKE AN AWS TAPE */\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//TAPIN     DD  DISP=OLD,UNIT=582,VOL=SER=T439RT,\n//          LABEL=(1,BLP,EXPDT=98000)\n//AWSOUT    DD  DSN=SBGOLOB.T439MU,DISP=(NEW,CATLG,DELETE),\n//          UNIT=SYSALLDA,DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//          SPACE=(CYL,(301,10),RLSE),VOL=SER=DATA04\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n./ ADD NAME=VTT2T2F# JCL F 80 9/21/07 13:45:11\n//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*  Read in a real tape on a real tape drive on any MVS system,\n//*  and produce, on any MVS system, a FLEX-ES Faketape-compatible\n//*  \"virtual tape image\", folded over on MVS into FB, LRECL=80\n//*  format.  The virtual tape image can be exported (via FTP or\n//*  anything else which does that) to a PC disk, and read on a\n//*  FLEX-ES system as a tape.\n//*\n//AWSWRIT  EXEC PGM=VTT2T2FK\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//FAKEOUT   DD  DISP=SHR,DSN=SBGOLOB.V467FL\n//TAPIN     DD  DISP=OLD,UNIT=562,VOL=SER=V467MU,\n//          LABEL=(1,BLP,EXPDT=98000)\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n//SYSIN     DD  *\nIDRCOFF\nNEWVOL=C467MU\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTT2SRCE": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x07'?\\x01\\x07'?\\x18\\x175\\xa05\\xa0\\x00\\x00\\xd9\\xc9\\xc3\\xd2\\xc2@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-09-30T00:00:00", "modifydate": "2007-09-30T18:17:00", "lines": 13728, "newlines": 13728, "modlines": 0, "user": "RICKB"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "VTT2TEST": {"ttr": 6920, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x07'?\\x01\\x07'?\\x18\\x17\\x04V\\x04V\\x00\\x00\\xd9\\xc9\\xc3\\xd2\\xc2@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-09-30T00:00:00", "modifydate": "2007-09-30T18:17:00", "lines": 1110, "newlines": 1110, "modlines": 0, "user": "RICKB"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "VTT2TEXT": {"ttr": 7430, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x07'?\\x01\\x07'?\\x18\\x17\\x05\\xdc\\x05\\xdc\\x00\\x00\\xd9\\xc9\\xc3\\xd2\\xc2@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-09-30T00:00:00", "modifydate": "2007-09-30T18:17:00", "lines": 1500, "newlines": 1500, "modlines": 0, "user": "RICKB"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT768/FILE768.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT768", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}