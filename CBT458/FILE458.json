{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012108000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 10522694, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 30, "INMDSNAM": "CBT.V500.FILE458.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 10522694, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 10522694, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE458.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\xa4\\x03'", "DS1TRBAL": "b'\\xb1,'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'P\\xf4\\xfd\\xd0\\x00\\x00\\x03Z\\x00\\x00\\x03d\\x00\\x0e\\x00\\xa5'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95)\\x8f\\x00\\x95)\\x8f\\x16E\\x00L\\x00L\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-10-25T00:00:00", "modifydate": "1995-10-25T16:45:00", "lines": 76, "newlines": 76, "modlines": 0, "user": "SYSPAJA"}, "text": "1   18.11.94                                            DOC - Page 1/2.\n\n          ***************************************************\n          ***     P R E L I M I N A R Y     N O T E S     ***\n          ***************************************************\n\n Files author : MOINIL P.A.\n -------------- Computing Centre (TP361)\n                J.R.C. - Ispra establishment\n                21020 ISPRA (VA), Italy\n\n Products installation requirement :\n -----------------------------------\n     Data-set \"->.SOURCE.FILE0\" is a pre-requisite.\n     See to the member $$$PROCS which contains a job to store the\n     procedures used for products installation.\n\n Data-set members structure :\n ----------------------------\n     The members names ending by a dollar sign ($) are the JCL to\n     install (assembly + link-edit) the modules, and the members\n     names ending by a paragraph sign (@) are the corresponding\n     modules documentation.\n\n                   *********************************\n                   ***     INFORMATION NOTES     ***\n                   *********************************\n\n     Assuming the LISTNO program in \"->.SOURCE.FILE0\" installed, you may\n SUBMIT the job below to obtain a copy of this document :\n         //...      JOB ...\n         //DOC     EXEC PGM=LISTNO,PARM='M=DOC'\n         //SYSPDS    DD DSN=->.SOURCE.FILE4,DISP=SHR\n         //SYSPRINT  DD SYSOUT=A\n     A complete information notes list (about 4500 lines) may be also\n obtained by this job if you specify M=INFO as parameter.\n1   25.10.95                                            DOC - Page 2/2.\n\n  *******************************************************************\n  ***     D A T A - S E T ->.SOURCE.FILE4     C O N T E N T S     ***\n  *******************************************************************\n\n CDSCB      Modify a data-set Format-1 DSCB.\n COMPARE    COMPARE TSO command.\n COMPAREB   A modified version of the YALE COMPARE program.\n CURESTA    Current Region Statistics display.\n DIDOCS     Simulate an OS console at TSO tube.\n DISASM     One-pass Disassembler program.\n DOPROG     DOPROG/DOCP TSO command processor.\n DSNCHECK   DSNCHECK TSO command.\n DSNTAB     DSNTAB routine.\n ETPS       Emergency Tele-Processing Services\n FAKEGSAM   Substitute GSAM routine (used by SCHEDRUN and SCHEDULE).\n GTEMACS    Assembler macros (used by NOTICE).\n HEL        A TSO full-screen HELP command.\n INCORZAP   Main storage superzap service aid program.\n JCLFLOW    JCLflow ISPF/PDF EDIT command.\n LISTICAT   List an ICF catalog program.\n MEMSTAT    Member status TSO command.\n MODLOOK    Module's look up program/command.\n NOTICE     Broadcast notices TSO command.\n OACNOW     Formats date and time routine (used by ZAP).\n PACKLIST   IEAPAK00 member generator program.\n PDFINIT    Dynamic allocation command for ISPF/PDF.\n PDSMATCH   Compare directories of two PO data-sets.\n POF        VTAM secondary Program Operator Facility.\n PSWSAMP    Sampler taker program for PACKLIST.\n PUSE       Pageing utilization program.\n QSP        The QUEUE/SPOOL TSO command.\n ROTATER    3800 printer rotated 90 degrees clockwise program.\n SCHEDMAC   Assembler macros (used by SCHEDRUN, SCHEDULE and XREFASM).\n SCHEDULE   The Schedule facility program.\n TO         Send a message to a user.\n WHATDSN    WHATDSN TSO command.\n XREFASM    A Global Cross-Reference Listing Generator.\n ZAP        Zap data-set TSO command.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$PROCS": {"ttr": 519, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95)\\x8f\\x00\\x95)\\x8f\\x16E\\x00m\\x00m\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-10-25T00:00:00", "modifydate": "1995-10-25T16:45:00", "lines": 109, "newlines": 109, "modlines": 0, "user": "SYSPAJA"}, "text": "//ADDPROCS JOB (........),'INSTALL  PROCEDURES',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=2\n//*----------- ADD PRODUCTS INSTALLATION PROCEDURES -------------------\n//*            ADJUSTMENTS MUST BE DONE BEFORE YOU RUN THIS JOB (SCAN\n//*            ALL \"->\" OCCURENCES AND SET RIGHT DATA-SETS NAMES).\n//* NOTES  1 - I NORMALLY USE THE ASSEMBLER H (DON'T USE ASSEMBLER F,\n//*            THERE IS A GOOD PROBABILITY TO HAVE ERRORS).\n//*        2 - ALL PROCEDURES ASSUME THE FOLLOWING UNIT NAMES :\n//*                     DU=SYSDA : DISK UNIT\n//*                     VU=VIO   : VIRTUAL UNIT\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//*      ASSEMBLER H PROCEDURES.                                      *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//PROCH   EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSUT2    DD DSN=->.TARGET.PROCLIB,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DATA,DLM=ZZ\n./     ADD     NAME=PAJ4AS1        <-------------- ASSEMBLY / 1 MACLIB\n./     NUMBER  NEW1=100,INCR=100\n//PAJ4AS1 PROC OPT=,DU=SYSDA,VU=VIO,MBR=,\n//             DSM='->.SOURCE.FILE0',DM=SHR\n//             DSS='->.SOURCE.FILE4',DS=SHR\n//AS      EXEC PGM=IEV90,\n//             PARM='XREF(SHORT),NODECK,OBJECT&OPT'\n//SYSLIB    DD DSN=&DSM,DISP=&DM\n//          DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1    DD UNIT=&VU,DSN=&&SYSUT1,SPACE=(CYL,(10,5))\n//SYSLIN    DD UNIT=&DU,SPACE=(CYL,(1,1)),DSN=&LOADSET,\n//             DCB=(BLKSIZE=800),DISP=(MOD,PASS,DELETE)\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DSN=&DSS(&MBR),DISP=&DS\n./     ADD     NAME=PAJ4AS2        <------------- ASSEMBLY / 2 MACLIBS\n./     NUMBER  NEW1=100,INCR=100\n//PAJ4AS2 PROC OPT=,DU=SYSDA,VU=VIO,MBR=,\n//             DSM='->.SOURCE.FILE0',DM=SHR\n//             DSS='->.SOURCE.FILE4',DS=SHR\n//AS      EXEC PGM=IEV90,\n//             PARM='XREF(SHORT),NODECK,OBJECT&OPT'\n//SYSLIB    DD DSN=&DSM,DISP=&DM\n//          DD DSN=&DSS,DISP=&DS\n//          DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1    DD UNIT=&VU,DSN=&&SYSUT1,SPACE=(CYL,(10,5))\n//SYSLIN    DD UNIT=&DU,SPACE=(CYL,(1,1)),DSN=&LOADSET,\n//             DCB=(BLKSIZE=800),DISP=(MOD,PASS,DELETE)\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DSN=&DSS(&MBR),DISP=&DS\n./     ADD     NAME=PAJ4AS3        <------------- ASSEMBLY / 3 MACLIBS\n./     NUMBER  NEW1=100,INCR=100\n//PAJ4AS3 PROC OPT=,DU=SYSDA,VU=VIO,MBR=,\n//             DSM='->.SOURCE.FILE0',DM=SHR\n//             DSS='->.SOURCE.FILE4',DS=SHR\n//AS      EXEC PGM=IEV90,\n//             PARM='XREF(SHORT),NODECK,OBJECT&OPT'\n//SYSLIB    DD DSN=&DSM,DISP=&DM\n//          DD DSN=&DSS,DISP=&DS\n//          DD DSN=SYS1.MACLIB,DISP=SHR\n//          DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1    DD UNIT=&VU,DSN=&&SYSUT1,SPACE=(CYL,(10,5))\n//SYSLIN    DD UNIT=&DU,SPACE=(CYL,(1,1)),DSN=&LOADSET,\n//             DCB=(BLKSIZE=800),DISP=(MOD,PASS,DELETE)\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DSN=&DSS(&MBR),DISP=&DS\n./     ADD     NAME=PAJ4AS4        <------------- ASSEMBLY / 4 MACLIBS\n./     NUMBER  NEW1=100,INCR=100\n//PAJ4AS4 PROC OPT=,DU=SYSDA,VU=VIO,MBR=,\n//             DSM='->.SOURCE.FILE0',DM=SHR\n//             DSS='->.SOURCE.FILE4',DS=SHR\n//AS      EXEC PGM=IEV90,\n//             PARM='XREF(SHORT),NODECK,OBJECT&OPT'\n//SYSLIB    DD DSN=&DSM,DISP=&DM\n//          DD DSN=&DSS,DISP=&DS\n//          DD DSN=SYS1.HASPSRC,DISP=SHR\n//          DD DSN=SYS1.MACLIB,DISP=SHR\n//          DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1    DD UNIT=&VU,DSN=&&SYSUT1,SPACE=(CYL,(10,5))\n//SYSLIN    DD UNIT=&DU,SPACE=(CYL,(1,1)),DSN=&LOADSET,\n//             DCB=(BLKSIZE=800),DISP=(MOD,PASS,DELETE)\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DSN=&DSS(&MBR),DISP=&DS\n./     ADD     NAME=PAJ4AS5        <------------- ASSEMBLY / 2 MACLIBS\n./     NUMBER  NEW1=100,INCR=100\n//PAJ4AS5 PROC OPT=,DU=SYSDA,VU=VIO,MBR=,\n//             DSS='->.SOURCE.FILE4',DS=SHR\n//AS      EXEC PGM=IEV90,\n//             PARM='XREF(SHORT),NODECK,OBJECT&OPT'\n//SYSLIB    DD DSN=SYS1.MACLIB,DISP=SHR\n//          DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1    DD UNIT=&VU,DSN=&&SYSUT1,SPACE=(CYL,(10,5))\n//SYSLIN    DD UNIT=&DU,SPACE=(CYL,(1,1)),DSN=&LOADSET,\n//             DCB=(BLKSIZE=800),DISP=(MOD,PASS,DELETE)\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DSN=&DSS(&MBR),DISP=&DS\n./     ADD     NAME=PAJ4AS6        <------------- ASSEMBLY / 3 MACLIBS\n./     NUMBER  NEW1=100,INCR=100\n//PAJ4AS5 PROC OPT=,DU=SYSDA,VU=VIO,MBR=,\n//             DSS='->.SOURCE.FILE4',DS=SHR\n//AS      EXEC PGM=IEV90,\n//             PARM='XREF(SHORT),NODECK,OBJECT&OPT'\n//SYSLIB    DD DSN=&DSS,DISP=&DS\n//          DD DSN=SYS1.MACLIB,DISP=SHR\n//          DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1    DD UNIT=&VU,DSN=&&SYSUT1,SPACE=(CYL,(10,5))\n//SYSLIN    DD UNIT=&DU,SPACE=(CYL,(1,1)),DSN=&LOADSET,\n//             DCB=(BLKSIZE=800),DISP=(MOD,PASS,DELETE)\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DSN=&DSS(&MBR),DISP=&DS\n./     ENDUP\nZZ\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#DOC#": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x11\\x7f\\x00\\x90\\x11\\x7f\\x13W\\x00&\\x00&\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-04-27T00:00:00", "modifydate": "1990-04-27T13:57:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "SYSPAJA"}, "text": "1   27/04/90\n\n\n\n\n\n\n\n\n\n\n\n\n\n                DDDDDDD          OOOOOOO         CCCCCCCC\n                DDDDDDDD        OOOOOOOOO       CCCCCCCCC\n                DD     DD       OO     OO       CC\n                DD     DD       OO     OO       CC\n                DD     DD       OO     OO       CC\n                DD     DD       OO     OO       CC\n                DD     DD       OO     OO       CC\n                DD     DD       OO     OO       CC\n                DDDDDDDD        OOOOOOOOO       CCCCCCCCC\n                DDDDDDD          OOOOOOO         CCCCCCCC\n\n\n\n\n\n\n\n\n\n\n\n\n\n=/MB     $$$DOC\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#INFO#": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95)\\x8f\\x00\\x95)\\x8f\\x16E\\x00<\\x00<\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-10-25T00:00:00", "modifydate": "1995-10-25T16:45:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "SYSPAJA"}, "text": "1   27/04/90\n\n\n\n\n\n\n\n\n\n\n\n\n\n          IIII       NN     NN       FFFFFFFFF        OOOOOOO\n           II        NNN    NN       FFFFFFFFF       OOOOOOOOO\n           II        NNNN   NN       FF              OO     OO\n           II        NN NN  NN       FF              OO     OO\n           II        NN  NN NN       FFFFFF          OO     OO\n           II        NN   NNNN       FFFFFF          OO     OO\n           II        NN    NNN       FF              OO     OO\n           II        NN     NN       FF              OO     OO\n           II        NN     NN       FF              OOOOOOOOO\n          IIII       NN     NN       FF               OOOOOOO\n\n\n\n\n1   25/10/95\n                                                      INDEX     1/1.\n\n=/MB     CDSCB@    Change DSCB (VTOC Format-1).\n=/MB     COMPARE@  COMPARE TSO command.\n=/MB     COMPARB@  A modified version of the YALE COMPARE program.\n=/MB     CURESTA@  Current Region Statistics display.\n=/MB     DIDOCS@   Simulate OS console for TSO user.\n=/MB     DISASM@   Disassemble a CSECT within a load module.\n=/MB     DOPROG@   DOPROG/DOCP TSO command processor.\n=/MB     DSNCHEC@  DSNCHECK TSO command.\n=/MB     DSNTAB@   DSNTAB routine.\n=/MB     ETPS@     Emergency Tele-Processing Services\n=/MB     HEL@      A TSO full-screen HELP command.\n=/MB     INCORZA@  In-core superzap program.\n=/MB     JCLFLOW@  JCLflow ISPF/PDF EDIT command.\n=/MB     LISTICA@  List an ICF catalog program.\n=/MB     MEMSTAT@  Member status TSO command.\n=/MB     MODLOOK@  Module's look up program/command.\n=/MB     NOTICE@   Broadcast notices TSO command.\n=/MB     PACKLIS@  Pack-List Generator (IEAPAK00).\n=/MB     PDFINIT@  Dynamic allocation command for ISPF/PDF.\n=/MB     PDSMATC@  Compare directories of two partitioned data-sets.\n=/MB     POF@      VTAM secondary Program Operator Facility.\n=/MB     PUSE@     Pageing utilization program.\n=/MB     QSP@      QUEUE/SPOOL analyzer.\n=/MB     ROTATER@  3800 printer rotated 90 degrees clockwise program.\n=/MB     SCHEDUL@  The schedule facility.\n=/MB     TO@       Send a message to a user.\n=/MB     WHATDSN@  WHATDSN TSO command.\n=/MB     XREFASM@  A Global Cross-Reference Listing Generator.\n=/MB     ZAP@      Display and modify data-sets.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CDSCB": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90)\\x7f\\x00\\x90)\\x7f\\x11H\\x08X\\x08X\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-24T00:00:00", "modifydate": "1990-10-24T11:48:00", "lines": 2136, "newlines": 2136, "modlines": 0, "user": "SYSPAJA"}, "text": "DSCB     TITLE 'C D S C B  - TSO COMMAND.'\nCDSCB    START 0\n         SPACE 1\n* PURPOSE :    THIS TSO COMMAND ALTERS THE CONTENTS OF A\n* ---------    FORMAT-1 DSCB IN A VTOC.\n*\n*              THE DATA-SET IS ALLOCATED, THEN THE VTOC OF THE\n*              VOLUME CONTAINING IT IS OPENED VIA TYPE-J OPEN.\n*              THE DSCB IS READ USING THE DSNAME AS A KEY. THE\n*              TTR (BLOCK ADDRESS) OF THE RECORD IS RETURNED BY\n*              THE READ. THE DSCB IS RE-WRITTEN USING THE DSNAME\n*              AS THE KEY, WITH THE KEY SEARCH STARTING AT THE\n*              TTR ADDRESS FROM THE READ.\n*\n*              NOTE : UNDER VS2 MVS, A VTOC MAY BE OPENED FOR\n*              UPDATE ONLY BY AUTHORIZED PROGRAMS. THEREFORE\n*              THIS WILL ABEND WITH A 913-10 UNLESS THE COMMAND\n*              CAN BE MADE TO RUN AUTHORIZED.\n*\n*              AUTHORIZE IT BY ADDING THE NAME OF THE COMMAND\n*              TO THE TABLE IN MODULE IKJEFT02 CSECT IKJEFTE2.\n*              OR, WRITE AN SVC AND REPLACE THE 2 'NOPR'\n*              INSTRUCTIONS IN THIS PROGRAM WITH THE SVC.\n*\n*              THE VS ASSEMBLER (OR H ASSEMBLER) MUST BE USED.\n         EJECT\n* AUTHOR :     BILL GODFREY, PRC (PLANNING RESEARCH CORPORATION).\n* --------     INSTALLATION : PRC COMPUTER CENTER, MCLEAN VA.\n*              DATE WRITTEN : MAY 20 1975.\n*              DATE UPDATED : FEBRUARY 12 1982.\n*              ATTRIBUTES : RE-ENTRANT, REFRESHABLE, REUSABLE.\n*\n*              04NOV77 - ADDED RECFM, DSORG, CREATE, EXPDT, UNIT\n*              09DEC77 - ADDED IMPLEXEC, EXIT12\n*              29MAR78 - JFCB+52 SET ON TO PREVENT WRITE-BACK\n*              26JUL78 - PREFIXING DONE BY PARSE (USID)\n*              22NOV78 - REMOVE LOCATE IF VOL NOT SPEC\n*              24NOV78 - ADD CLEAR, PUTLINE, PUTMSG, 2ND BASE REG\n*              12OCT79 - ADD GBLB, RESERVE, DEVTYPE FOR LIMCT.\n*              14OCT79 - ADD STACK DELETE.\n*              10APR80 - USID REMOVED FROM IKJPOSIT FOR SVS/MVT.\n*              11APR80 - SHR KEYWORD ADDED.\n*              25JUL80 - TESTAUTH ADDED. ASTERISK IN CREATE DATE.\n*              01APR81 - ERROR MESSAGE FOR BAD DATES. COMMON EXIT PATH\n*                        USING STATUS. MESSAGE IF NOTHING CHANGED.\n*                        MORE RECFMS AND DSORGS. REFDT. FORMAT1 DSECT.\n*                        ALLOW TO RUN IF UNDER STARTED TASK (TSSO).\n*                        WTO MESSAGE WHEN CHANGING EXPDT.\n*              20APR81 - RACF/NORACF KEYWORDS ADDED.\n*              08MAY81 - MORE RECFMS ADDED (UA UM UT).\n*              07JUL81 - CK FOR ASMI USERID INSTEAD OF ASFI.\n*              12FEB82 - CHECK DSORG RECFM LRECL BLKSI CREDT\n*                        FOR CHANGING TO SAME AS EXISTING VALUE.\n         SPACE 1\n*              ADAPTED BY : MOINIL P.A.                            -EU-\n*                           COMPUTING CENTRE                       -EU-\n*                           J.R.C. - ISPRA ESTABLISHMENT           -EU-\n*                           21020 ISPRA (VA), ITALY                -EU-\n*                                                                  -EU-\n*              12JUN84 - CHANGE TEST FOR ASMI BY OUR TEST,         -EU-\n*                        INSERTED SETAUTH AND RESAUTH SVC'S.       -EU-\n*              22OCT90 - ADDED DISPLAY OF FORMAT 1 DSCB.           -EU-\n         EJECT ,                                                   -EU-\nCDSCB   AMODE  24                                                  -EU-\nCDSCB   RMODE  24                                                  -EU-\n         SPACE 1\n        $DEFREG ,                                                  -EU-\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *  -EU-\n*        AUTHORITY LEVELS DEFINITIONS.                          *  -EU-\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *  -EU-\n         SPACE 1                                                   -EU-\nLV0      EQU   0         REJECT LEVEL.                             -EU-\n         SPACE 1                                                   -EU-\n        $MDL@IX ,        MODULE INDEX.                             -EU-\n         EJECT\n        $XENT  BASE=(R10,R11),LV=@DATAL,SP=1,TYPE=RENT\n         LR    R2,R1\n         USING CPPL,R2\n         LR    R9,R13              SET WORK-AREA POINTER\n         USING @DATA,R9\n         LA    R14,18*4(R9)        POINT TO AREA TO CLEAR\n         L     R15,=A(@SIZE)       GET LENGTH TO CLEAR\n         XR    R0,R0\n         LR    R1,R0\n         MVCL  R14,R0              CLEAR AREA\n         USING PSA,R0\n         L     R1,PSAAOLD          ASCB OLD POINTER\n         DROP  R0\n         USING ASCB,R1\n         L     R15,ASCBJBNI        POINTER TO JOBNAME FIELD\n         LTR   R15,R15             IS THIS A JOB?\n         BNZ   IMPLEXEC            YES, QUIT\n         L     R15,ASCBTSB         ADDRESS OF TSB\n         LTR   R15,R15             IS THIS A TSO SESSION?\n         BZ    IMPLEXEC            NO, BRANCH IF STARTED TASK      -EU-\n         DROP  R1\n         L     R1,CVTPTR           ADDRESS OF CVT\n         USING CVT,R1\n         L     R15,CVTTCBP         TCB WORDS\n         DROP  R1\n         L     R15,4(,R15)         CURRENT TCB\n         USING TCB,R15\n         L     R1,TCBJSCB          ADDRESS OF JOB STEP CONTROL BLOCK\n         DROP  R15\n         USING IEZJSCB,R1\n         L     R1,JSCBPSCB         ADDRESS OF TSO PSCB\n         DROP  R1\n         LTR   R1,R1               ANY PSCB?\n         BZ    IMPLEXEC            NO, NOT A TSO SESSION\n*        USING PSCB,R1                                             -EU-\n*        TM    PSCBATR1,PSCBCTRL   OPERATOR?                       -EU-\n*        BZ    IMPLEXEC            NO, BRANCH                      -EU-\n*        CLC   PSCBUSER(4),ASMI    SYSTEMS SUPPORT USERID          -EU-\n*        BE    PROCEED             YES, BRANCH                     -EU-\n*        LA    R15,USERIDS                                         -EU-\n*AUTHLOOP CLI  0(R15),0            END OF LIST?                    -EU-\n*        BE    IMPLEXEC            YES, NOT AUTHORIZED             -EU-\n*        CLC   PSCBUSER(7),0(R15)                                  -EU-\n*        BE    PROCEED                                             -EU-\n*        LA    R15,8(,R15)         POINT TO NEXT USERID            -EU-\n*        B     AUTHLOOP            GO CHECK IT                     -EU-\n*        DROP  R1                  PSCB                            -EU-\n*ASMI    DC    C'ASMI'                                             -EU-\n*USERIDS DC    0D'0'               ALIGN FOR EASY ZAPS             -EU-\n*        DC    8D'0'               ROOM FOR 8 USERIDS              -EU-\n*        DC    H'0'                END OF USERID LIST              -EU-\n         MVC   REQAUT+1(3),=AL3(MDL@IX)                            -EU-\n         LA    R1,RQA                                              -EU-\n         ST    R1,REQAUT+4                                         -EU-\n        $EACM  REQAUT                                              -EU-\n         CLI   RQA,LV0             AUTHORIZED?                     -EU-\n         BNE   PROCEED             YES.                            -EU-\nIMPLEXEC L     R1,CPPLCBUF\n         XC    2(2,R1),2(R1)       SET CBUF TO IMPLICIT EXEC\n         L     R1,CPPLECT          GET ECT ADDRESS\n         USING ECT,R1\n         CLI   ECTSCMD,C' '        IS THIS A SUBCOMMAND?\n         BNE   *+L'*+6             YES, SAY SUBCOMMAND NOT FOUND\n         MVC   ECTPCMD,=CL8'EXEC'  NO, SAY COMMAND NOT FOUND\n         DROP  R1                  ECT\n         L     R13,4(,R13)\n         FREEMAIN R,A=(R9),LV=@DATAL,SP=1\n         L     R1,24(,R13)         RESTORE CPPL POINTER\n         LA    R15,12(,R13)        POINT TO 2-WORD XCTL PARM\n         XC    0(8,R15),0(R15)     CLEAR IT\n         XCTL  (2,12),EP=EXEC,SF=(E,(15))\n         SPACE 1\n*        SET UP IOPL FOR PUTLINE.\n         SPACE 1\nPROCEED  LA    R15,MYIOPL\n         USING IOPL,R15\n         MVC   IOPLUPT(4),CPPLUPT\n         MVC   IOPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,IOPLECB\n         XC    MYECB,MYECB\n         LA    R0,MYPTPB\n         ST    R0,IOPLIOPB\n         DROP  R15\n         SPACE 1\n*        SET UP PPL FOR PARSE.\n         SPACE 1\n         LA    R15,MYPPL\n         USING PPL,R15\n         MVC   PPLUPT(4),CPPLUPT\n         MVC   PPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,PPLECB\n         XC    MYECB,MYECB\n         L     R0,=A(CDSCBPCL)\n         ST    R0,PPLPCL\n         LA    R0,MYANS\n         ST    R0,PPLANS\n         MVC   PPLCBUF(4),CPPLCBUF\n         ST    R9,PPLUWA\n         DROP  R15                 PPL\n         EJECT\n*        CALL THE PARSE SERVICE ROUTINE.\n         SPACE 1\n         LR    R1,R15              POINT TO PPL\n         CALLTSSR EP=IKJPARS,MF=(E,(1))\n         LTR   R15,R15\n         BNZ   PARSERR\n         SPACE 1\n         L     R12,MYANS\n         USING IKJPARMD,R12\n         SPACE 1\n*        PROCESS THE 'ZAP' PARAMETER.\n         SPACE 1\n         CLI   ZAPKW+1,0           ZAP SPECIFIED?\n         BE    NOREP               NO, BRANCH\n         TM    REP+6,X'80'         ZAP SPECIFIED?\n         BZ    NOREP               NO\n         CLI   REP+8,X'FF'         ONLY ONE REP PARAMETER?\n         BE    INVREP              YES, ERROR, BRANCH\n         MVC   OFFSET(5),=XL5'0'\n         LA    R1,OFFSET\n         CLI   REP+5,4\n         BE    MOVEOFF\n         CLI   REP+5,2\n         BNE   INVREP              OFFSET MUST BE 2 OR 4 CHARS\n         LA    R1,OFFSET+1\nMOVEOFF  L     R14,REP             REG 14 ---> OFFSET\n         LH    R15,REP+4           REG 15 = LENGTH (2 OR 4)\n         BCT   R15,*+L'*+6\n         MVC   0(*-*,R1),0(R14)    <<EXECUTED>>\n         EX    R15,*-6             MOVE 1ST REP TO OFFSET\n         LH    R0,REP+4\n         SRL   R0,1                CUT LENGTH IN HALF\n         BAS   R14,PACK            CONVERT TO BINARY\n         CLI   OFFSET+1,44+1       OFFSETS START WITH X'2D'\n         BL    REPOERR             IF LESS ISSUE MESSAGE\n         L     R6,REP+8            REG 6 ---> NEXT PDE IN LIST VERDATA\n         L     R14,0(,R6)          REG 14 ---> VERDATA\n         LH    R15,4(,R6)          REG 15 = LENGTH\n         BCT   R15,*+L'*+6\n         MVC   VERDATA+1(*-*),0(R14)    <<EXECUTED>>\n         EX    R15,*-6             MOVE 2ND REP TO VERDATA\n         LH    R0,4(,R6)\n         SRL   R0,1                CUT LENGTH IN HALF\n         BCTR  R0,0\n         STC   R0,VERDATA\n         LH    R0,4(,R6)\n         SRL   R0,1                CUT LENGTH IN HALF\n         LA    R1,VERDATA+1\n         BAS   R14,PACK\n         XR    R14,R14\n         IC    R14,VERDATA         R14 = LEN-1 OF VERDATA\n         AH    R14,OFFSET\n         CH    R14,ENDOFREC        BEYOND END OF RECORD?\n         BH    REPVERR             YES, ISSUE MESSAGE\n         CLI   8(R6),X'FF'         3RD REP (REPDATA) SPECIFIED?\n         MVI   VR,C'V'\n         BE    NOREP\n         L     R6,8(,R6)           REG 6 ---> NEXT PDE REPDATA\n         MVI   VR,C'R'\n         L     R14,0(,R6)          REG 14 ---> REPDATA\n         LH    R15,4(,R6)          R15 = LENGTH\n         BCT   R15,*+L'*+6\n         MVC   REPDATA+1(*-*),0(R14)    <<EXECUTED>>\n         EX    R15,*-6             MOVE 3RD REP TO REPDATA\n         LH    R0,4(,R6)\n         SRL   R0,1                CUT LENGTH IN HALF\n         BCTR  R0,0\n         STC   R0,REPDATA\n         LH    R0,4(,R6)\n         SRL   R0,1                CUT LENGTH IN HALF\n         LA    R1,REPDATA+1\n         BAS   R14,PACK\n         CLC   VERDATA(1),REPDATA  COMPARE LENGTHS\n         BL    REPDERR             VER DATA MUST NOT BE SHORTER\n         SPACE 1\n*        PROCESS THE 'RECFM' KEYWORD.\n         SPACE 1\nNOREP    LH    R1,RECFM            GET RECFM\n         LTR   R1,R1               RECFM SPECIFIED?\n         BZ    NOREC               NO, BRANCH\n         IC    R14,RECFMTAB(R1)    GET RECFM BITS\n         STC   R14,NEWRECFM        SAVE NEW RECFM\n         OI    SWITCH2,NEWRECSW    SET SWITCH ON\n         SPACE 1\n*        PROCESS THE 'BLKSIZE' KEYWORD.\n         SPACE 1\nNOREC    CLI   BLKKW+1,0           BLKSIZE SPECIFIED?\n         BE    NOBLK               NO, BRANCH\n         TM    BLK+6,X'80'         VALUE PRESENT?\n         BZ    NOBLK               NO, BRANCH\n         LH    R14,BLK+4           GET LENGTH\n         LTR   R14,R14             LENGTH ZERO?\n         BZ    NOBLK               YES, BRANCH\n         L     R1,BLK              POINT TO VALUE\n         BCT   R14,EXCTPKD+L'EXCTPKD\nEXCTPKD  PACK  DOUBLE(8),0(*-*,R1) <<EXECUTED>>\n         EX    R14,EXCTPKD\n         CVB   R1,DOUBLE           GET BINARY VALUE\n         C     R1,=F'32767'        TOO LARGE?\n         BNH   *+L'*+4             NO, BRANCH\n         L     R1,=F'32767'        YES, REDUCE IT\n         STH   R1,NEWBLK           SAVE IT\n         OI    SWITCH1,NEWBLKSW    SET SWITCH ON\n         SPACE 1\n*        PROCESS THE 'LRECL' KEYWORD.\n         SPACE 1\nNOBLK    CLI   LREKW+1,0           LRECL SPECIFIED?\n         BE    NOLRE               NO, BRANCH\n         TM    LRE+6,X'80'         VALUE PRESENT?\n         BZ    NOLRE               NO, BRANCH\n         LH    R14,LRE+4           GET LENGTH\n         LTR   R14,R14             LENGTH ZERO?\n         BZ    NOLRE               YES, BRANCH\n         L     R1,LRE              POINT TO VALUE\n         BCTR  R14,0\n         EX    R14,EXCTPKD\n         CVB   R1,DOUBLE           GET BINARY VALUE\n         C     R1,=F'32767'        TOO LARGE?\n         BNH   *+L'*+4             NO, BRANCH\n         L     R1,=F'32767'        YES, REDUCE IT\n         STH   R1,NEWLRE           SAVE IT\n         OI    SWITCH1,NEWLRESW    SET SWITCH ON\n         SPACE 1\n*        PROCESS THE 'DSORG' KEYWORD.\n         SPACE 1\nNOLRE    LH    R1,DSORG            GET DSORG\n         LTR   R1,R1               DSORG SPECIFIED?\n         BZ    NODSO               NO, BRANCH\n         IC    R14,DSORGTAB(R1)    GET DSORG BITS\n         STC   R14,NEWDSORG        SAVE NEW DSORG\n         MVI   NEWDSORG+1,0        NEW DSORG PART 2\n         OI    SWITCH1,NEWDSOSW    SET SWITCH ON\n         SPACE 1\n*        PROCESS THE PROTECTION KEYWORDS.\n         SPACE 1\nNODSO    CLI   PROKW+1,0           ANY PROTECTION KEYWORDS?\n         BE    NOPRO               NO, BRANCH\n         MVI   NEWPRO0,B'11111111' START WITH NO BITS TO SET OFF\n         MVI   NEWPRO1,B'00000000'      AND NO BITS TO SET ON.\n         CLI   PROKW+1,2           'PW' OR 'PWREAD'?\n         BH    PRO3                NO, BRANCH\n         MVI   NEWPRO0,B'11111011' SET OFF 1 BIT\n         MVI   NEWPRO1,B'00010000' SET ON 1 BIT\n         B     PROX\nPRO3     CLI   PROKW+1,3           'PWWRITE'?\n         BNE   PRO4                NO, BRANCH\n         MVI   NEWPRO1,B'00010100' SET ON 2 BITS\n         B     PROX\nPRO4     CLI   PROKW+1,4           'NOPW'?\n         BNE   PRO5                NO, BRANCH\n         MVI   NEWPRO0,B'11101011' SET OFF 2 BITS\n         B     PROX\nPRO5     CLI   PROKW+1,5           'RACF'\n         BNE   PRO6\n         MVI   NEWPRO1,B'01000000' SET ON 1 BIT\n         B     PROX\nPRO6     CLI   PROKW+1,6           'NORACF'\n         BNE   NOPRO\n         MVI   NEWPRO0,B'10111111' SET OFF 1 BIT\nPROX     OI    SWITCH1,NEWPROSW    SET SWITCH ON\n         SPACE 1\n*        PROCESS THE 'ALLOC' KEYWORD.\n         SPACE 1\nNOPRO    CLI   ALLKW+1,0           'ALLOC' SPECIFIED?\n         BE    NOALL               NO, BRANCH\n         CLI   ALL+1,0             ANY SUBKEYWORDS?\n         BE    NOALL               NO, BRANCH\n         MVI   NEWALL0,B'11111111' START WITH NO BITS TO SET OFF\n         MVI   NEWALL1,B'00000000'      AND NO BITS TO SET ON.\n         CLI   ALL+1,1             'NONE'?\n         BNE   ALL2                NO, BRANCH\n         MVI   NEWALL0,B'00111111' SET OFF 2 BITS\n         B     ALLX\nALL2     CLI   ALL+1,2             'BLOCKS'\n         BNE   ALL3                NO, BRANCH\n         MVI   NEWALL0,B'01111111' SET OFF 1 BIT\n         MVI   NEWALL1,B'01000000' SET ON 1 BIT\n         B     ALLX\nALL3     CLI   ALL+1,3             'TRACKS'\n         BNE   ALL4                NO, BRANCH\n         MVI   NEWALL0,B'10111111' SET OFF 1 BIT\n         MVI   NEWALL1,B'10000000' SET ON 1 BIT\n         B     ALLX\nALL4     CLI   ALL+1,4             'CYLINDERS'\n         BNE   NOALL               NO, BRANCH\n         MVI   NEWALL1,B'11000000' SET ON 2 BITS\nALLX     OI    SWITCH1,NEWALLSW    SET ON SWITCH\n         SPACE 1\n*        PROCESS THE 'SPACE' PARAMETER.\n         SPACE 1\nNOALL    CLI   SPAKW+1,0           SPACE SPECIFIED?\n         BE    NOSPA               NO, BRANCH\n         TM    SPA+6,X'80'         VALUE PRESENT?\n         BZ    NOSPA               NO, BRANCH\n         LH    R14,SPA+4           GET LENGTH\n         LTR   R14,R14             LENGTH ZERO?\n         BZ    NOSPA               YES, BRANCH\n         L     R1,SPA              POINT TO VALUE\n         BCTR  R14,0\n         EX    R14,EXCTPKD\n         CVB   R1,DOUBLE           GET BINARY VALUE\n         C     R1,=F'32767'        TOO LARGE?\n         BNH   *+L'*+4             NO, BRANCH\n         L     R1,=F'32767'        YES, REDUCE IT\n         ST    R1,NEWSPA           SAVE IT\n         OI    SWITCH1,NEWSPASW    SET SWITCH ON\n         SPACE 1\n*        PROCESS THE 'CREATE' KEYWORD.\n         SPACE 1\nNOSPA    CLI   CREATEKW+1,0        CREATE SPECIFIED?\n         BE    CREATEX             NO, BRANCH\n         TM    CREATE+6,X'80'      VALUE PRESENT?\n         BZ    CREATEX             NO, BRANCH\n         LH    R14,CREATE+4        GET LENGTH\n         LTR   R14,R14             LENGTH ZERO?\n         BZ    CREATEX             YES, BRANCH\n         L     R1,CREATE           POINT TO VALUE\n         CLI   0(R1),C'*'          ASTERISK\n         BNE   CRESET              NO, BRANCH\n         TIME  BIN\n         ST    R1,DOUBLE           STORE 00YYDDDC\n         LA    R1,DATE5            POINT TO FAKE OPERAND\n         UNPK  0(5,R1),DOUBLE+1(3) YYDDD\n         OI    4(R1),C'0'          FIX SIGN BITS\n         B     CREPACK             JUMP BACK IN WITH FAKE OPERAND\nCRESET   BCTR  R14,0\n         EX    R14,EXCTPKD\n         CVB   R15,DOUBLE          GET BINARY VALUE\n         LTR   R15,R15             IS IT ZERO?\n         BZ    CREOK               YES, BRANCH\n         CH    R14,=H'4'           WERE 5 DIGITS SPECIFIED?\n         BNE   ERRCDATE            NO, BRANCH TO ERROR (IGNORE)\nCREPACK  PACK  DOUBLE(8),0(2,R1)   PACK YY\n         CVB   R14,DOUBLE          GET BINARY YY\n         SLL   R14,16              00YY0000\n         PACK  DOUBLE(8),2(3,R1)   PACK DDD\n         CVB   R15,DOUBLE          GET BINARY DDD\n         OR    R15,R14             00YY0DDD\nCREOK    ST    R15,NEWCRE          SAVE NEW CREATION DATE\n         OI    SWITCH1,NEWCRESW    SET SWITCH ON\n         SPACE 1\n*        PROCESS THE 'EXPDT' KEYWORD.\n         SPACE 1\nCREATEX  CLI   EXPDTEKW+1,0        EXPDTE SPECIFIED?\n         BE    NOEXP               NO, BRANCH\n         TM    EXPDTE+6,X'80'      VALUE PRESENT?\n         BZ    NOEXP               NO, BRANCH\n         LH    R14,EXPDTE+4        GET LENGTH\n         LTR   R14,R14             LENGTH ZERO?\n         BZ    NOEXP               YES, BRANCH\n         MVC   EXPCH,=CL5'00000'\n         L     R1,EXPDTE           POINT TO VALUE\n         BCTR  R14,0\n         EX    R14,EXCTPKD\n         CVB   R15,DOUBLE          GET BINARY VALUE\n         LTR   R15,R15             IS IT ZERO?\n         BZ    EXPOK               YES, BRANCH\n         CH    R14,=H'4'           WERE 5 DIGITS SPECIFIED?\n         BNE   ERRXDATE            NO, BRANCH TO ERROR (IGNORE)\n         MVC   EXPCH,0(R1)         SAVE EXPDT\n         PACK  DOUBLE(8),0(2,R1)   PACK YY\n         CVB   R14,DOUBLE          GET BINARY YY\n         SLL   R14,16              00YY0000\n         PACK  DOUBLE(8),2(3,R1)   PACK DDD\n         CVB   R15,DOUBLE          GET BINARY DDD\n         OR    R15,R14             00YY0DDD\nEXPOK    ST    R15,NEWEXP          SAVE NEW EXPIRATION DATE\n         OI    SWITCH1,NEWEXPSW    SET SWITCH ON\n         SPACE 1\n*        PROCESS THE 'REFDT' KEYWORD.\n         SPACE 1\nNOEXP    CLI   REFDTEKW+1,0        REFDT SPECIFIED?\n         BE    NOREFDT             NO, BRANCH\n         TM    REFDTE+6,X'80'      VALUE PRESENT?\n         BZ    NOREFDT             NO, BRANCH\n         LH    R14,REFDTE+4        GET LENGTH\n         LTR   R14,R14             LENGTH ZERO?\n         BZ    NOREFDT             YES, BRANCH\n         L     R1,REFDTE           POINT TO VALUE\n         CLI   0(R1),C'*'          ASTERISK\n         BNE   REFSET              NO, BRANCH\n         TIME  BIN\n         ST    R1,DOUBLE           STORE 00YYDDDC\n         LA    R1,DATE5            POINT TO FAKE OPERAND\n         UNPK  0(5,R1),DOUBLE+1(3) YYDDD\n         OI    4(R1),C'0'          FIX SIGN BITS\n         B     REFPACK             JUMP BACK IN WITH FAKE OPERAND\nREFSET   BCTR  R14,0\n         EX    R14,EXCTPKD\n         CVB   R15,DOUBLE          GET BINARY VALUE\n         LTR   R15,R15             IS IT ZERO?\n         BZ    REFOK               YES, BRANCH\n         CH    R14,=H'4'           WERE 5 DIGITS SPECIFIED?\n         BNE   ERRRDATE            NO, BRANCH TO ERROR (IGNORE)\nREFPACK  PACK  DOUBLE(8),0(2,R1)   PACK YY\n         CVB   R14,DOUBLE          GET BINARY YY\n         SLL   R14,16              00YY0000\n         PACK  DOUBLE(8),2(3,R1)   PACK DDD\n         CVB   R15,DOUBLE          GET BINARY DDD\n         OR    R15,R14             00YY0DDD\nREFOK    ST    R15,NEWREF          SAVE NEW REFERENCED DATE\n         OI    SWITCH2,NEWREFSW    SET SWITCH ON\n         SPACE 1\n*        PROCESS THE DSNAME PARAMETER.\n         SPACE 1\nNOREFDT  LA    R1,DSN\n         L     R8,0(,R1)           R8 ---> DSNAME\n         LH    R7,4(,R1)           R7 = LENGTH\n         LTR   R7,R7               IS LENGTH ZERO?\n         BZ    ERRDSN              YES, WAS (MEMBER) ONLY\n         LR    R6,R7\n         MVI   DSNAME,C' '\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         BCT   R7,*+L'*+6\n         MVC   DSNAME(*-*),0(R8)   <<EXECUTED>>\n         EX    R7,*-6\n         STH   R6,DSNAMEL\n         SPACE 1\n*        PROCESS THE VOLUME PARAMETER.\n         SPACE 1\n         MVC   WRKUNIT,=CL8' '\n         MVC   WRKVOL(6),=CL8' '\n         TM    VOL+6,X'80'         VOLUME SPECIFIED?\n         BZ    DYNALLOC            NO, BRANCH\n         L     R14,VOL             R14 ---> VOLUME\n         LH    R15,VOL+4           R15 = LENGTH\n         BCT   R15,*+L'*+6\n         MVC   WRKVOL(*-*),0(R14)  <<EXECUTED>>\n         EX    R15,*-6\n         SPACE 1\n*        IF VOLUME SPECIFIED, CHECK FOR UNIT PARAMETER.\n         SPACE 1\n         TM    UNIT+6,X'80'        UNIT SPECIFIED?\n         BZ    DYNALLOC            NO, BRANCH\n         L     R14,UNIT            POINT TO UNIT NAME\n         LH    R15,UNIT+4          LENGTH OF UNIT NAME\n         BCT   R15,*+L'*+6\n         MVC   WRKUNIT(*-*),0(R14) <<EXECUTED>>\n         EX    R15,*-6\n         EJECT\n*        CALL DYNAMIC ALLOCATION.\n         SPACE 1\nDYNALLOC LA    R1,MYDAPL\n         USING DAPL,R1\n         MVC   DAPLUPT(4),CPPLUPT\n         MVC   DAPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB(4),CPPLPSCB\n         LA    R0,MYDAPB\n         ST    R0,DAPLDAPB\n         XC    MYECB,MYECB\n         L     R15,DAPLDAPB\n         USING DAPB08,R15\n         XC    0(84,R15),0(R15)\n         MVI   DA08CD+1,X'08'\n         LA    R14,DA08DDN\n         MVI   0(R14),C' '\n         MVC   1(23,R14),0(R14)    DD, UNIT, VOL\n         MVC   DA08SER(6),WRKVOL\n         MVC   DA08UNIT(8),WRKUNIT\n         MVC   DA08MNM(16),0(R14)\n         MVC   DA08ALN(8),0(R14)\n         LA    R0,DSNAMEL\n         ST    R0,DA08PDSN\n         MVI   DA08DSP1,DA08OLD\n         CLI   SHRKW+1,0           'SHR' SPECIFIED?\n         BE    *+L'*+4             BRANCH IF NOT\n         MVI   DA08DSP1,DA08SHR    'SHR' SPECIFIED\n         MVI   DA08DPS2,DA08KEEP\n         MVI   DA08DPS3,DA08KEP\n         BAS   R14,CALLDAIR\n         SPACE 1\n         LTR   R15,R15\n         BNZ   DAIRERR\n         OI    STATUS,STATA        INDICATE ALLOCATED\n         EJECT\n*        SET UP THE DCB.\n         SPACE 1\n         MVC   DCB(DCBLEN),DCBMODEL\n         LA    R15,MYDAPB\n         LA    R3,DCB\n         USING IHADCB,R3\n         MVC   DCBDDNAM(8),DA08DDN\n         LA    R15,JFCB\n         ST    R15,EXLSTD\n         MVI   EXLSTD,X'87'\n         LA    R15,EXLSTD\n         IC    R14,DCBEXLST\n         ST    R15,DCBEXLST        SET DCB EXLST=EXLSTD\n         STC   R14,DCBEXLST\n         SPACE 1\n*        READ THE JFCB.\n         SPACE 1\n         MVC   RDJFCBD,RDJFCB\n         RDJFCB ((R3)),MF=(E,RDJFCBD)\n         SPACE 1\n*        DEFER ATTENTION INTERRUPTS.\n         SPACE 1\n         MVC   STAXD(STAXL),STAXDEF                                -EU-\n         STAX  DEFER=YES,MF=(E,STAXD)\n         OI    STATUS,STATS        INDICATE DEFERED                -EU-\n         SPACE 1\n* -----> INSTALLATION-DEPENDENT CODE\n*        TO GET AROUND ABEND 913-10.\n         SPACE 1\n         L     R1,CVTPTR\n         USING CVT,R1\n         L     R1,CVTTCBP          TCB WORDS\n         DROP  R1\n         L     R1,4(,R1)           R1 ---> TCB\n         USING TCB,R1\n         L     R4,TCBJSCB          R4 ---> JSCB\n         DROP  R1\n         USING IEZJSCB,R4\n         TM    JSCBOPTS,JSCBAUTH   ARE WE AUTHORIZED?\n         BO    AUTHYES             YES, BYPASS AUTH SETTING\n         DROP  R4\n         SETAUTH ,                 SET ON JSCBAUTH                 -EU-\n         OI    STATUS,STATM        INDICATE AUTH HAS BEEN CHANGED\nAUTHYES  TESTAUTH FCTN=1\n         LTR   R15,R15\n         BNZ   AUTHERR\n         SPACE 1\n*        OPEN THE VTOC.\n         SPACE 1\n         DEVTYPE DCBDDNAM,DEVAREA,DEVTAB\n         LH    R1,DEVAREA+10       TRACKS PER CYL\n         MH    R1,=H'5'            ASSUME 5 CYLINDER VTOC\n         STH   R1,TRACKS\n         GETPOOL (R3),2,96\n         OI    STATUS,STATG        INDICATE GETPOOL ISSUED\n         MVI   JFCB,X'04'\n         MVC   JFCB+1(43),JFCB\n         OI    JFCB+52,X'08'       DO NOT WRITE BACK            29MAR78\n         MVC   OPENJD,OPENJ\n         OPEN  ((R3),UPDAT),TYPE=J,MF=(E,OPENJD)\n         TM    DCBOFLGS,DCBOFOPN\n         BZ    OPENERR\n         OI    STATUS,STATO        INDICATE OPENED\n         SPACE 1\n*        ENQ ON THE VTOC.\n         SPACE 1\n         L     R1,DCBDEBAD         POINT TO DEB\n         L     R1,32(,R1)          POINT TO UCB\n         ST    R1,UCBAD            STORE UCB ADDRESS\n         MVC   RNAME,28(R1)        MOVE VOLUME TO RNAME\n         MVC   QNAME,=CL8'SYSVTOC'\n         MVC   RW(RL),R            MOVE MF=L TO WORK AREA\n         RESERVE (QNAME,RNAME,E,L'RNAME,SYSTEMS),RET=HAVE,UCB=UCBAD,   X\n               MF=(E,RW)\n         OI    STATUS,STATQ        INDICATE ENQ ACTIVE\n         EJECT\n*        READ THE FORMAT 1 DSCB USING DSNAME AS KEY.\n         SPACE 1\n         GETBUF (R3),(R4)\n         LH    R1,TRACKS\n         STH   R1,DCBLIMCT+1\n         MVC   READDECB(READL),DECBMODR\n         MVC   TTR(3),=XL3'000001'\n         READ  READDECB,DKF,(R3),(R4),'S',DSNAME,TTR,MF=E\n         NI    STATUS,255-SYNADSWT\n         CHECK READDECB\n         TM    STATUS,SYNADSWT     SYNAD EXIT TAKEN?\n         BO    RDWRERR             YES, BRANCH\n         L     R4,READDECB+(DECAREA-DECB) R4 ---> AREA ADDRESS\n         LR    R5,R4\n         SH    R5,=Y(L'DSNAME)     R5 ---> IMAGINARY KEY-DATA AREA\n         USING FORMAT1,R5\n         SPACE 1\n*        VERIFY.\n         SPACE 1\n         CLI   VR,0                REP SPECIFIED?\n         BE    VRX                 NO, BRANCH\n         LR    R1,R5\n         AH    R1,OFFSET           R1 ---> LOCATION OF VICTIM\n         XR    R14,R14\n         IC    R14,VERDATA\n         EX    R14,EXCTVER         COMPARE VICTIM TO VER DATA\n         BNE   VERREJ              NOT EQUAL, REJECT\n         CLI   VR,C'R'             WAS REP DATA SPECIFIED?\n         BE    REPROUT             YES, BRANCH\n         LA    R1,=CL8'VERIFIED'\n         LA    R0,8\n         BAS   R14,PUTMSG\n         B     VRX\nEXCTVER  CLC   0(*-*,R1),VERDATA+1 <<EXECUTED>>\n         SPACE 1\n*        REPLACE.\n         SPACE 1\nEXCTREP  MVC   0(*-*,R1),REPDATA+1 <<EXECUTED>>\nREPROUT  XR    R14,R14\n         IC    R14,REPDATA\n         EX    R14,EXCTREP         MOVE REP DATA TO RECORD\n         OI    STATUS,CHGSW        SET CHANGED SWITCH\nVRX      TM    SWITCH2,NEWRECSW    RECFM SPECIFIED?\n         BZ    NURECX              NO, BRANCH\n         CLC   DS1RECFM,NEWRECFM   ALREADY THAT?\n         BE    NURECX              YES, BRANCH\n         MVC   DS1RECFM,NEWRECFM   MOVE IN NEW RECFM\n         OI    STATUS,CHGSW        SET SWITCH ON\nNURECX   TM    SWITCH1,NEWDSOSW    DSORG SPECIFIED?\n         BZ    NUDSOX              NO, BRANCH\n         CLC   DS1DSORG,NEWDSORG   ALREADY THAT?\n         BE    NUDSOX              YES, BRANCH\n         MVC   DS1DSORG,NEWDSORG   MOVE IN NEW DSORG\n         OI    STATUS,CHGSW        SET SWITCH ON\nNUDSOX   TM    SWITCH1,NEWBLKSW    BLKSIZE SPECIFIED?\n         BZ    NUBLKX              NO, BRANCH\n         CLC   DS1BLKL,NEWBLK      ALREADY THAT?\n         BE    NUBLKX              YES, BRANCH\n         MVC   DS1BLKL,NEWBLK      MOVE IN NEW BLKSIZE\n         OI    STATUS,CHGSW        SET SWITCH ON\nNUBLKX   TM    SWITCH1,NEWLRESW    LRECL SPECIFIED?\n         BZ    NULREX              NO, BRANCH\n         CLC   DS1LRECL,NEWLRE     ALREADY THAT?\n         BE    NULREX              YES, BRANCH\n         MVC   DS1LRECL,NEWLRE     MOVE IN NEW LRECL\n         OI    STATUS,CHGSW        SET SWITCH ON\nNULREX   TM    SWITCH1,NEWPROSW    PROTECTION MODIFIED?\n         BZ    NUPROX              NO, BRANCH\n         MVC   NEWPROSV,DS1DSIND   HOLD A COPY\n         NC    DS1DSIND,NEWPRO0    SET REQUIRED BITS OFF\n         OC    DS1DSIND,NEWPRO1    SET REQUIRED BITS ON\n         CLC   NEWPROSV,DS1DSIND   ANY CHANGE?\n         BE    NUPROX              NO, LEAVE SWITCH OFF\n         OI    STATUS,CHGSW        YES, SET SWITCH ON\nNUPROX   TM    SWITCH1,NEWALLSW    SEC. ALLOCATION ALTERED?\n         BZ    NUALLX              NO, BRANCH\n         MVC   NEWPROSV,DS1SCALO   HOLD A COPY\n         NC    DS1SCALO(1),NEWALL0 SET REQUIRED BITS OFF\n         OC    DS1SCALO(1),NEWALL1 SET REQUIRED BITS ON\n         CLC   NEWPROSV,DS1SCALO   ANY CHANGE?\n         BE    NUALLX              NO, LEAVE SWITCH OFF\n         OI    STATUS,CHGSW        YES, SET SWITCH ON\nNUALLX   TM    SWITCH1,NEWSPASW    SPACE SPECIFIED?\n         BZ    NUSPAX              NO, BRANCH\n         MVC   DS1SCALO+1(3),NEWSPA+1   MOVE IN NEW SPACE\n         OI    STATUS,CHGSW        SET SWITCH ON\nNUSPAX   TM    SWITCH1,NEWCRESW    CREATE SPECIFIED?\n         BZ    NUCREX              NO, BRANCH\n         CLC   DS1CREDT,NEWCRE+1   IS IT ALREADY THAT VALUE?\n         BE    NUCREX              YES, BRANCH\n         MVC   DS1CREDT,NEWCRE+1   MOVE IN NEW CREATION DATE\n         OI    STATUS,CHGSW        SET SWITCH ON\nNUCREX   MVI   EXPSW,X'FF'\n         TM    SWITCH1,NEWEXPSW    EXPDT SPECIFIED?\n         BZ    NUEXPX              NO, BRANCH\n         CLC   DS1EXPDT,NEWEXP+1   IS IT ALREADY THAT VALUE?\n         BE    NUEXPX              YES, BRANCH\n         MVC   DS1EXPDT,NEWEXP+1   MOVE IN NEW EXPIRATION DATE\n         OI    STATUS,CHGSW        SET SWITCH ON\n         MVI   EXPSW,1             INDICATE NEW EXPDT\n         CLC   NEWEXP+1(3),=AL3(0)\n         BNE   NUEXPX\n         MVI   EXPSW,0             INDICATE NEW EXPDT ZERO\nNUEXPX   TM    SWITCH2,NEWREFSW    REFDT SPECIFIED?\n         BZ    NUREFX              NO, BRANCH\n         CLC   DS1REFD,NEWREF+1    IS IT ALREADY THAT VALUE?\n         BE    NUREFX              YES, BRANCH\n         MVC   DS1REFD,NEWREF+1    MOVE IN NEW REFERENCE DATE\n         OI    STATUS,CHGSW        SET SWITCH ON\n         DROP  R5                  FORMAT1\n         SPACE 1\nNUREFX   MVC   WADS1(DS1END-IECSDSF1),0(R5) RETAIN DSCB FOR LIST\n         TM    STATUS,CHGSW        ANYTHING CHANGED?\n         BO    REWRITE             YES, GO REWRITE THE DSCB\n         LA    R1,=CL15'NOTHING CHANGED'\n         LA    R0,15\n         BAS   R14,PUTMSG\n         B     EXIT0\n         SPACE 1\n*        REWRITE THE FORMAT 1 DSCB.\n         SPACE 1\nREWRITE  MVC   WRITDECB(WRITEL),DECBMODW\n         WRITE WRITDECB,DK,(R3),(R4),,DSNAME,TTR,MF=E\n         NI    STATUS,255-SYNADSWT\n         CHECK WRITDECB\n         TM    STATUS,SYNADSWT     SYNAD EXIT TAKEN?\n         BO    RDWRERR             YES, BRANCH\n         LA    R1,=CL7'CHANGED'\n         LA    R0,7\n         BAS   R14,PUTMSG\n         SPACE 1\n*        WRITE A MESSAGE ON THE CONSOLE LOG.\n         SPACE 1\n         CLI   LOGKW+1,2           NO LOG?\n         BE    EXIT0               YES, BRANCH\n         CLI   EXPSW,X'FF'         WAS EXPDT CHANGED?\n         BE    EXIT0               NO, BRANCH\n         MVC   MSGW(LOGL),LOG\n         L     R1,CVTPTR\n         USING CVT,R1\n         L     R1,CVTTCBP          TCB WORDS\n         DROP  R1\n         L     R1,4(,R1)           CURRENT TCB\n         USING TCB,R1\n         L     R1,TCBTIO           ADDRESS OF TIOT\n         DROP  R1\n         LA    R15,MSGW+21\n         MVC   0(8,R15),0(R1)      INSERT JOBNAME/USERID IN MESSAGE\n         LA    R15,7(,R15)         POINT TO LAST BYTE OF JOBNAME\n         CLI   0(R15),C' '\n         BNE   *+L'*+4\n         BCT   R15,*-8\n         MVC   2(2,R15),=CL2'TO'\n         MVC   5(L'DSNAME,R15),DSNAME\n         LA    R15,L'DSNAME+4(,R15)     POINT TO LAST BYTE OF DSNAME\n         CLI   0(R15),C' '\n         BNE   *+L'*+4\n         BCT   R15,*-8\n         MVC   2(2,R15),=CL2'ON'\n         AH    R1,DCBTIOT          OFFSET FROM TIOT\n         L     R1,16(,R1)          TIOEFSRT-1, PTR TO UCB\n         MVC   5(6,R15),28(R1)     UCBVOLI\n         MVC   12(5,R15),EXPCH     NEW EXPDT\n         WTO   MF=(E,MSGW)\n         B     EXIT0\n         EJECT\n*        THIS ROUTINE IS ENTERED DURING THE 'CHECK'\n*        MACRO IF AN I/O ERROR OCCURS.\n         SPACE 1\nSYNAD    SYNADAF ACSMETH=BDAM\n         MVC   SYNADMSG(L'SYNADMSG),50(R1)\n         OI    STATUS,SYNADSWT     INDICATE EXIT TAKEN\n         SYNADRLS\n         BR    R14\n         EJECT\n*        CALL IKJDAIR.\n         SPACE 1\nCALLDAIR L     R15,CVTPTR          ADDRESS OF CVT\n         USING CVT,R15\n         TM    CVTDAIR,X'80'       IF HIGH ORDER BIT NOT ON\n         BNO   CALLDLNK                 THEN DO LINK, NOT CALL\n         L     R15,CVTDAIR         ADDRESS OF IKJDAIR\n         DROP  R15\n         BR    R15                 CALL IKJDAIR (R14 IS SET)\nCALLDLNK ST    R14,CALLDR14\n         LINK  EP=IKJDAIR,SF=(E,LINKAREA)\n         L     R14,CALLDR14\n         BR    R14\n         EJECT\n*        PARSE VALIDITY CHECK ROUTINE FOR 'REP' KEYWORD.\n         SPACE 1\n         USING *,R6\nREPVALCK STM   R14,R12,12(R13)\n         LR    R6,R15\n         L     R7,0(,R1)           REG 7 ---> PDE\n         L     R4,0(,R7)           REG 4 ---> CHARACTER STRING\n         LH    R0,4(,R7)           REG 0 = LENGTH\n         LA    R15,4               RETURN 4 IF CHECK FAILS\n         TM    5(R7),X'01'         LENGTH AN EVEN NUMBER?\n         BO    VALEXIT             NO, EXIT WITH RC=4\nVALLOOP  CLI   0(R4),C'0'          NUMERIC?\n         BNL   VALINCR             YES, THIS CHAR OK\n         CLI   0(R4),C'F'          IN RANGE A THRU F?\n         BH    VALEXIT             NO, EXIT WITH RC=4\nVALINCR  LA    R4,1(,R4)           POINT TO NEXT CHAR\n         BCT   R0,VALLOOP\n         XR    R15,R15             SET RC=0\nVALEXIT  L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n         DROP  R6\n         EJECT\n*        THIS ROUTINE CONVERTS EXTERNAL HEX TO BINARY HEX.\n         SPACE 1\nPACK     ST    R14,PACK14\n         LR    R15,R1              REG 15 ---> SENDING/RECEIVING FIELD\n         XR    R14,R14\n         IC    R14,0(,R1)          REG 14 = 1ST CHAR\n         CLI   0(R1),C'0'          NUMBER OR LETTER?\n         BNL   *+L'*+4             NUMBER, BRANCH\n         LA    R14,57(,R14)        LETTER, CONVERT TO FA-FF\n         SLL   R14,4               SHIFT LEFT 4 BITS\n         STC   R14,0(,R15)         STORE THE LEFT HALF\n         IC    R14,1(,R1)          REG 14 = 2ND CHAR\n         CLI   1(R1),C'0'          NUMBER OR LETTER?\n         BNL   *+L'*+4             NUMBER, BRANCH\n         LA    R14,57(,R14)        LETTER, CONVERT\n         SLL   R14,28              SHIFT LEFT HALF TO OBLIVION\n         SRL   R14,28              SHIFT BACK AGAIN\n         STC   R14,1(,R15)         STORE RIGHT HALF\n         OC    0(1,R15),1(R15)     'OR' RIGHT HALF OVER LEFT HALF\n         LA    R1,2(,R1)           INCREMENT SENDING FIELD\n         LA    R15,1(,R15)         INCREMENT RECEIVING FLD\n         BCT   R0,PACK+6           LOOP USING LENGTH IN REG 0\n         L     R14,PACK14\n         BR    R14                 EXIT\n         SPACE 2\n*        UNPACK - CONVERT A FIELD TO HEXADECIMAL.\n*              REG 0 = INPUT LENGTH (OUTPUT IS TWICE PLUS 1 BLANK)\n*              REG 1 ---> INPUT\n*              REG 14 ---> RETURN ADDRESS ( BAS   R14,UNPACK )\n*              REG 15 ---> OUTPUT\n         SPACE 1\nUNPACK   UNPK  0(3,R15),0(2,R1)    UNPACK\n         TR    0(2,R15),UNPACKT-C'0'\n         LA    R15,2(,R15)         INCREMENT OUTPUT PTR\n         LA    R1,1(,R1)           INCREMENT INPUT PTR\n         BCT   R0,UNPACK           DECREMENT LENGTH, THEN LOOP\n         MVI   0(R15),C' '         BLANK THE TRAILING BYTE\n         BR    R14                 RETURN TO CALLER\n         EJECT\n*        ERROR MESSAGES.\n         SPACE 1\nINVREP   LA    R1,=CL32'MISSING OR INVALID REP PARAMETER'\n         LA    R0,32\n         B     ERRMSG\nRDWRERR  LA    R1,SYNADMSG\n         LA    R0,L'SYNADMSG\n         B     ERRMSG\nREPDERR  LA    R1,=CL43'INVALID REP - REP LENGTH EXCEEDS VER LENGTH'\n         LA    R0,43\n         B     ERRMSG\nREPOERR  LA    R1,=CL46'REP OFFSET INVALID - MUST BE AT LEAST 2 DIGITS'\n         LA    R0,46\n         B     ERRMSG\nREPVERR  LA    R1,=CL29'REP GOES BEYOND END OF RECORD'\n         LA    R0,29\n         B     ERRMSG\nVERREJ   LA    R1,=CL13'VERIFY REJECT'\n         LA    R0,13\n         B     ERRMSG\nLOCERR   LA    R1,=CL23'DATA-SET NOT IN CATALOG'\n         LA    R0,23\n         B     ERRMSG\nDAIRERR  BAS   R14,DAIRFAIL\n         B     EXIT12\nAUTHERR  LA    R1,=CL33'ENVIRONMENT IS NOT APF AUTHORIZED'\n         LA    R0,33\n         B     ERRMSG\nOPENERR  LA    R1,=CL11'OPEN FAILED'\n         LA    R0,11\n         B     ERRMSG\nPARSERR  LA    R1,=CL12'PARSE FAILED'\n         LA    R0,12\n         B     ERRMSG\nERRCDATE LA    R1,=CL19'INVALID CREATE DATE'\n         LA    R0,19\n         B     ERRMSG\nERRXDATE LA    R1,=CL23'INVALID EXPIRATION DATE'\n         LA    R0,23\n         B     ERRMSG\nERRRDATE LA    R1,=CL22'INVALID REFERENCE DATE'\n         LA    R0,22\n         B     ERRMSG\nERRDSN   LA    R1,=CL42'DATA-SET NAME MUST NOT CONTAIN MEMBER NAME'\n         LA    R0,42\nERRMSG   BAS   R14,PUTMSG\n         B     EXIT12\n         EJECT\n*        PUTMSG ROUTINE.\n         SPACE 1\nPUTMSG   STM   R14,R1,PUTSAVE\n         XC    MYOLD(8),MYOLD\n         XC    MYSEG1,MYSEG1\n         MVC   MYPTPB(PTPBL),MODLPTPM\n         LA    R14,1               NO. OF MESSAGE SEGMENTS\n         ST    R14,MYOLD\n         LA    R14,MYSEG1          POINT TO 1ST SEGMENT\n         ST    R14,MYOLD+4\n         LA    R14,L'MYSGM1        MAX. LENGTH CONTROL\n         CLC   0(3,R1),=CL3'IKJ'   IS DATA PRECEEDED BY MESSAGE ID?\n         BE    *+L'*+2             YES, BRANCH\n         BCTR  R14,0\n         CLR   R0,R14\n         BNH   *+L'*+2\n         LR    R0,R14\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         LA    R15,MYSGM1\n         CLC   0(3,R1),=CL3'IKJ'   IS DATA PRECEEDED BY MESSAGE ID?\n         BE    PUTMSGM             YES, BRANCH\n         LA    R14,1(,R14)         ADD 1 TO LENGTH\n         MVI   0(R15),C' '         INSERT LEADING BLANK\n         LA    R15,1(,R15)         BUMP POINTER\nPUTMSGM  STH   R14,MYSEG1\n         LR    R14,R0\n         BCT   R14,*+L'*+6\n         MVC   0(*-*,R15),0(R1)    <<EXECUTED>>\n         EX    R14,*-6             MOVE MESSAGE IN\n         LA    R1,MYIOPL\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),MF=(E,(1))\n         LM    R14,R1,PUTSAVE\n         BR    R14\n         EJECT\n*        PUTLINE ROUTINE.\n         SPACE 1\nPUTLNE   STM   R14,R1,PUTSAVE\n         XC    MYSEG1,MYSEG1\n         MVC   MYPTPB(PTPBL),MODLPTPB\n         LA    R14,L'MYSGM1        MAX. LENGTH CONTROL\n         CLR   R0,R14\n         BNH   *+L'*+2\n         LR    R0,R14\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCT   R14,*+L'*+6\n         MVC   MYSGM1(*-*),0(R1)   <<EXECUTED>>\n         EX    R14,*-6             MOVE TEXT IN\n         LA    R1,MYIOPL\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYSEG1,DATA),MF=(E,(1))\n         LM    R14,R1,PUTSAVE\n         BR    R14\n         EJECT\n*        DYNAMIC ALLOCATION FAILURE ROUTINE.\n         SPACE 1\nDAIRFAIL ST    R14,MYDFREGS\n         LA    R1,MYDFPARM\n         USING DFDSECTD,R1\n         ST    R15,MYDFRC\n         LA    R15,MYDFRC\n         ST    R15,DFRCP\n         LA    R15,MYDAPL\n         ST    R15,DFDAPLP\n         SLR   R15,R15\n         ST    R15,MYJEFF02\n         LA    R15,MYJEFF02\n         ST    R15,DFJEFF02\n         LA    R15,DFDAIR\n         STH   R15,MYDFID\n         LA    R15,MYDFID\n         ST    R15,DFIDP\n         ST    R2,DFCPPLP\n         DROP  R1\n         LINK  EP=IKJEFF18,SF=(E,LINKAREA)\n         L     R15,MYDFRC\n         L     R14,MYDFREGS\n         BR    R14\n         EJECT\n*        CLOSE THE VTOC.\n         SPACE 1\nEXIT12   LA    R15,12\n         B     EXIT\nEXIT0    XR    R15,R15             RETURN CODE ZERO\nEXIT     ST    R15,RC\n         TM    STATUS,STATQ        IS ENQ ACTIVE?\n         BZ    EXITNODQ            NO, SKIP DEQ\n         MVC   DW(DL),D            MOVE MF=L TO WORK AREA\n         DEQ   (QNAME,RNAME,6,SYSTEMS),RET=HAVE,MF=(E,DW)\n         NI    STATUS,255-STATQ    DEQ\nEXITNODQ TM    STATUS,STATO        IS DCB OPENED?\n         BZ    EXITNOCL            NO, SKIP CLOSE\n         FREEBUF (R3),(R4)\n         MVC   CLOSED,CLOSE\n         CLOSE ((R3)),MF=(E,CLOSED)\n         NI    STATUS,255-STATO    CLOSED\nEXITNOCL TM    STATUS,STATG        WAS GETPOOL ISSUED?\n         BZ    EXITNOFP            NO, SKIP FREEPOOL\n         FREEPOOL (R3)\n         NI    STATUS,255-STATG    CLOSED\n         SPACE 1\n* -----> INSTALLATION-DEPENDENT CODE TO UNDO\n*        THE EARLIER INSTALLATION-DEPENDENT CODE.\n         SPACE 1\nEXITNOFP L     R1,CVTPTR           ADDRESS OF CVT\n         USING CVT,R1\n         L     R1,CVTTCBP          TCB WORDS\n         DROP  R1\n         L     R1,4(,R1)           CURRENT TCB\n         USING TCB,R1\n         L     R4,TCBJSCB          ADDRESS OF JOB STEP CONTROL BLOCK\n         DROP  R1\n         TM    STATUS,STATM        WAS AUTH CHANGED?\n         BZ    EXITNOMS            NO, BRANCH\n         RESAUTH ,                 SET OFF JSCBAUTH                -EU-\n         NI    STATUS,255-STATM\n         SPACE 1                                                   -EU-\n*        RESTORE ATTENTION INTERRUPTS.                             -EU-\n         SPACE 1                                                   -EU-\nEXITNOMS TM    STATUS,STATS        ATTENTION DEFERED               -EU-\n         BZ    EXITNOAD            NO, BRANCH                      -EU-\n         MVC   STAXD(STAXL),STAXDEN                                -EU-\n         STAX  DEFER=NO,MF=(E,STAXD)                               -EU-\n         NI    STATUS,255-STATS                                    -EU-\n         SPACE 1\n*        UNALLOCATE VIA DYNAMIC ALLOCATION.\n         SPACE 1\nEXITNOAD TM    STATUS,STATA        WAS ALLOCATE DONE?\n         BZ    EXITNOFR            NO, BYPASS FREE\n         LA    R1,MYDAPL\n         USING DAPL,R1\n         L     R14,DAPLECB\n         XC    0(4,R14),0(R14)\n         L     R15,DAPLDAPB\n         DROP  R1\n         USING DAPB18,R15\n         XC    0(40,R15),0(R15)\n         MVI   DA18CD+1,X'18'\n         MVC   DA18MNM,=CL8' '\n         MVI   DA18DPS2,DA18KEEP\n         MVI   DA18CTL,0\n         MVC   DA18SCLS(2),=CL8' '\n         MVC   DA18JBNM(8),=CL8' '\n         MVC   DA18DDN(8),DCBDDNAM\n         BAS   R14,CALLDAIR\n         NI    STATUS,255-STATA\n         SPACE 1\n*        FINAL EXIT FROM PROGRAM.\n         SPACE 1\nEXITNOFR IKJRLSA MYANS\n         CLI   RC+3,0              IS RC ZERO?\n         BE    DSPLDS1             YES, BRANCH\n         MVC   MYSTPB(STACKDL),STACKD\n         STACK DELETE=ALL,PARM=MYSTPB,MF=(E,MYIOPL)\n         TCLEARQ\n         B     STACKDX\nDSPLDS1  CLI   LSTKW+1,2           NO LIST?\n         BE    STACKDX             YES, BRANCH\n         BH    *+L'*+8             BRANCH FULL LIST REQUEST\n         L     R7,=A(LSTFDS1)      DISPLAY FORMAT 1 DSCB\n         B     *+L'*+4\n         L     R7,=A(FLSFDS1)      FULL DISPLAY FORMAT 1 DSCB\n         BASR  R6,R7\nSTACKDX  L     R15,RC\n        $XRET  CC=(R15),LV=@DATAL,SP=1,TYPE=RENT\n         EJECT\n*        CONSTANTS.\n         SPACE 1\nUNPACKT  DC    C'0123456789ABCDEF' TRANSLATE TABLE\n         SPACE 1\n         LTORG\n         EJECT\n*        THE BYTES IN THE FOLLOWING TABLES\n*        MUST BE IN THE SAME ORDER AS THE\n*        'IKJNAME' ENTRIES IN THE PARSE\n*        PCL PARAMETERS.\n         SPACE 1\nRECFMTAB DC    AL1(0)                                  NO RECFM\n         DC    AL1(DCBRECF)                            F\n         DC    AL1(DCBRECF+DCBRECSB)                   FS\n         DC    AL1(DCBRECF+DCBRECCA)                   FA\n         DC    AL1(DCBRECF+DCBRECCM)                   FM\n         DC    AL1(DCBRECF+DCBRECBR)                   FB\n         DC    AL1(DCBRECF+DCBRECBR+DCBRECSB)          FBS\n         DC    AL1(DCBRECF+DCBRECBR+DCBRECCA)          FBA\n         DC    AL1(DCBRECF+DCBRECBR+DCBRECCM)          FBM\n         DC    AL1(DCBRECV)                            V\n         DC    AL1(DCBRECV+DCBRECSB)                   VS\n         DC    AL1(DCBRECV+DCBRECCA)                   VA\n         DC    AL1(DCBRECV+DCBRECCM)                   VM\n         DC    AL1(DCBRECV+DCBRECBR)                   VB\n         DC    AL1(DCBRECV+DCBRECBR+DCBRECSB)          VBS\n         DC    AL1(DCBRECV+DCBRECBR+DCBRECCA)          VBA\n         DC    AL1(DCBRECV+DCBRECBR+DCBRECCM)          VBM\n         DC    AL1(DCBRECU)                            U\n         DC    AL1(DCBRECU+DCBRECCA)                   UA\n         DC    AL1(DCBRECU+DCBRECCM)                   UM\n         DC    AL1(DCBRECU+DCBRECTO)                   UT\n         SPACE 1\nDSORGTAB DC    AL1(0)\n         DC    AL1(DCBDSGPS)                           PS\n         DC    AL1(DCBDSGPS+DCBDSGU)                   PSU\n         DC    AL1(DCBDSGPO)                           PO\n         DC    AL1(DCBDSGPO+DCBDSGU)                   POU\n         DC    AL1(DCBDSGDA)                           DA\n         DC    AL1(DCBDSGDA+DCBDSGU)                   DAU\n         EJECT\nMODLPTPM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                         X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE 1\nMODLPTPB PUTLINE OUTPUT=(1,TERM,SINGLE,DATA),                          X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\nPTPBL    EQU   *-MODLPTPM\n         SPACE 1\nENDOFREC DC    0H'0',AL2(44+96-1) OFFSET TO LAST BYTE OF RECORD\n         SPACE 1\n         PRINT GEN                 LIST DCB SO LIMCT CAN BE ZAPPED\nDCBMODEL DCB   DDNAME=DYNAM,DSORG=DA,MACRF=(RKC,WKC),                  X\n               BUFL=96,OPTCD=EF,LIMCT=57,                              X\n               RECFM=F,BLKSIZE=96,KEYLEN=44,                           X\n               EXLST=0,SYNAD=SYNAD\nDCBLEN   EQU   *-DCBMODEL\n         SPACE 1\nRDJFCB   RDJFCB 0,MF=L\n         SPACE 1\nOPENJ    OPEN  0,TYPE=J,MF=L\n         SPACE 1\nCLOSE    CLOSE 0,MF=L\n         SPACE 1\nREAD     READ  DECBMODR,DKF,0,'S','S',0,0,MF=L\nREADL    EQU   *-DECBMODR\n         SPACE 1\nWRITE    WRITE  DECBMODW,DK,0,'S','S',0,0,MF=L\nWRITEL   EQU   *-DECBMODW\n         SPACE 1\nSTAXDEF  STAX  DEFER=YES,MF=L\nSTAXL    EQU   *-STAXDEF                                           -EU-\n         SPACE 1\nSTAXDEN  STAX  DEFER=NO,MF=L\n         SPACE 1\nR        RESERVE (77,88,E,6,SYSTEMS),RET=HAVE,UCB=99,MF=L\nRL       EQU   *-R\n         SPACE 1\nD        DEQ   (77,88,6,SYSTEMS),RET=HAVE,MF=L\nDL       EQU   *-D\n         SPACE 1\n*        WTO   'CMI000I CDSCB BY USER/JOB TO DSNAME---1----+----2----+-\n*              ---3----+----4---- ON VOLUME EXPDT',ROUTCDE=(2),MF=L\nLOG      WTO   'CMI000I CDSCB BY                                       X\n                                                 ',ROUTCDE=(2),MF=L\nLOGL     EQU   *-LOG\nLMSGW    EQU   ((LOGL+3)/4)*4\n         SPACE 1\nSTACKD   STACK DELETE=ALL,MF=L\nSTACKDL  EQU   *-STACKD\n         SPACE 1\n         DC    0D'0'               END OF MAIN CSECT, MAX. BASE REGS\n         EJECT\n*        DISPLAY FORMAT 1 DSCB.\n         SPACE 1\n         USING *,R7\nLSTFDS1  LA    R5,WADS1\n         MVI   MSGT,C' '\n         MVC   MSGT+1(L'MSGT-1),MSGT\n         USING FORMAT1,R5\n         MVC   MSGT(26),=CL26'FORMAT 1 DSCB ON VOLUME :'\n         MVC   MSGT+26(L'RNAME),RNAME\n         LA    R8,LSTFDS1N\nLSTFDS1X LA    R0,L'MSGT\n         LA    R1,MSGT\n         BAS   R14,PUTLNE\n         MVI   MSGT,C' '\n         MVC   MSGT+1(L'MSGT-1),MSGT\n         BR    R8\nLSTFDS1N MVC   MSGT(9),=CL9'DS1DSNAM='\n         LH    R1,DSNAMEL\n         BCT   R1,*+L'*+6\n         MVC   MSGT+9(*-*),DSNAME\n         EX    R1,*-6\n         BAS   R8,LSTFDS1X\n         MVC   MSGT(9),=CL9'DS1FMTID='\n         UNPK  MSGT+9(3),DS1FMTID(2)\n         TR    MSGT+9(2),UNPACKT-C'0'\n         MVI   MSGT+11,C' '\n         MVC   MSGT+38(9),=CL9'DS1DSSN ='\n         UNPK  MSGT+47(13),DS1DSSN(7)\n         TR    MSGT+47(12),UNPACKT-C'0'\n         CLI   103(R5),0           DMS SVC ACTIVE ?\n         BNE   *+L'*+14            YES\n         MVI   MSGT+59,C'='\n         MVC   MSGT+60(6),DS1DSSN\n         B     LSTFDS1A\n         MVC   MSGT+59(10),=CL10'(DMSMODDT='\n         XR    R0,R0\n         ICM   R0,B'0111',DS1DSSN+3\n         SRDL  R0,16\n         SRL   R1,16\n         CVD   R0,DOUBLE\n         CVD   R1,TTR\n         MVC   DOUBLE(4),=XL4'40212020'\n         ED    DOUBLE(4),DOUBLE+6\n         MVC   MSGT+69(2),DOUBLE+2\n         MVC   DOUBLE(6),=XL6'402120202020'\n         ED    DOUBLE(6),TTR+5\n         MVC   MSGT+71(3),DOUBLE+3\n         MVI   MSGT+74,C')'\nLSTFDS1A BAS   R8,LSTFDS1X\n         MVC   MSGT(9),=CL9'DS1VOLSQ='\n         UNPK  MSGT+9(5),DS1VOLSQ(3)\n         TR    MSGT+9(4),UNPACKT-C'0'\n         MVI   MSGT+13,C' '\n         MVC   MSGT+38(9),=CL9'DS1CREDT='\n         UNPK  MSGT+47(7),DS1CREDT(4)\n         TR    MSGT+47(6),UNPACKT-C'0'\n         MVI   MSGT+53,C'('\n         XR    R0,R0\n         ICM   R0,B'0111',DS1CREDT\n         SRDL  R0,16\n         SRL   R1,16\n         CVD   R0,DOUBLE\n         CVD   R1,TTR\n         MVC   DOUBLE(4),=XL4'40212020'\n         ED    DOUBLE(4),DOUBLE+6\n         MVC   MSGT+54(2),DOUBLE+2\n         MVC   DOUBLE(6),=XL6'402120202020'\n         ED    DOUBLE(6),TTR+5\n         MVC   MSGT+56(3),DOUBLE+3\n         MVI   MSGT+59,C')'\n         BAS   R8,LSTFDS1X\n         MVC   MSGT(9),=CL9'DS1EXPDT='\n         UNPK  MSGT+9(7),DS1EXPDT(4)\n         TR    MSGT+9(6),UNPACKT-C'0'\n         XR    R0,R0\n         ICM   R0,B'0111',DS1EXPDT\n         BNZ   *+L'*+8\n         MVI   MSGT+15,C' '\n         B     LSTFDS1B\n         MVI   MSGT+15,C'('\n         SRDL  R0,16\n         SRL   R1,16\n         CVD   R0,DOUBLE\n         CVD   R1,TTR\n         MVC   DOUBLE(4),=XL4'40212020'\n         ED    DOUBLE(4),DOUBLE+6\n         MVC   MSGT+16(2),DOUBLE+2\n         MVC   DOUBLE(6),=XL6'402120202020'\n         ED    DOUBLE(6),TTR+5\n         MVC   MSGT+18(3),DOUBLE+3\n         MVI   MSGT+21,C')'\nLSTFDS1B MVC   MSGT+38(9),=CL9'DS1NOEPV='\n         UNPK  MSGT+47(3),DS1NOEPV(2)\n         TR    MSGT+47(2),UNPACKT-C'0'\n         MVI   MSGT+49,C' '\n         BAS   R8,LSTFDS1X\n         MVC   MSGT(9),=CL9'DS1NOBDB='\n         UNPK  MSGT+9(3),DS1NOBDB(2)\n         TR    MSGT+9(2),UNPACKT-C'0'\n         MVI   MSGT+11,C' '\n         MVC   MSGT+38(9),=CL9'RESERVED='\n         UNPK  MSGT+47(3),61(2,R5)\n         TR    MSGT+47(2),UNPACKT-C'0'\n         MVI   MSGT+49,C' '\n         BAS   R8,LSTFDS1X\n         MVC   MSGT(9),=CL9'DS1SYSCD='\n         UNPK  MSGT+9(15),DS1SYSCD(8)\n         UNPK  MSGT+23(13),DS1SYSCD+7(7)\n         TR    MSGT+9(26),UNPACKT-C'0'\n         MVI   MSGT+35,C'('\n         MVC   MSGT+36(13),DS1SYSCD\n         MVI   MSGT+49,C')'\n         BAS   R8,LSTFDS1X\n         MVC   MSGT(9),=CL9'DS1REFD ='\n         UNPK  MSGT+9(7),DS1REFD(4)\n         TR    MSGT+9(6),UNPACKT-C'0'\n         XR    R0,R0\n         ICM   R0,B'0111',DS1REFD\n         BNZ   *+L'*+8\n         MVI   MSGT+15,C' '\n         B     LSTFDS1C\n         MVI   MSGT+15,C'('\n         SRDL  R0,16\n         SRL   R1,16\n         CVD   R0,DOUBLE\n         CVD   R1,TTR\n         MVC   DOUBLE(4),=XL4'40212020'\n         ED    DOUBLE(4),DOUBLE+6\n         MVC   MSGT+16(2),DOUBLE+2\n         MVC   DOUBLE(6),=XL6'402120202020'\n         ED    DOUBLE(6),TTR+5\n         MVC   MSGT+18(3),DOUBLE+3\n         MVI   MSGT+21,C')'\nLSTFDS1C MVC   MSGT+38(9),=CL9'RESERVED='\n         UNPK  MSGT+47(9),78(5,R5)\n         TR    MSGT+47(8),UNPACKT-C'0'\n         CLI   103(R5),0           DMS SVC ACTIVE ?\n         BNE   *+L'*+8             YES\n         MVI   MSGT+55,C' '\n         B     *+L'*+6\n         MVC   MSGT+55(10),=CL10'(DMSOPCNT)'\n         BAS   R8,LSTFDS1X\n         MVC   MSGT(9),=CL9'DS1DSORG='\n         UNPK  MSGT+9(5),DS1DSORG(3)\n         TR    MSGT+9(4),UNPACKT-C'0'\n         TM    DS1DSORG,DS1DSGIS\n         BZ    *+L'*+10\n         MVC   MSGT+13(4),=CL4'(IS)'\n         B     LSTFDS1D\n         TM    DS1DSORG,DS1DSGPS\n         BZ    *+L'*+10\n         MVC   MSGT+13(4),=CL4'(PS)'\n         B     LSTFDS1D\n         TM    DS1DSORG,DS1DSGDA\n         BZ    *+L'*+10\n         MVC   MSGT+13(4),=CL4'(DA)'\n         B     LSTFDS1D\n         TM    DS1DSORG,DS1DSGPO\n         BZ    *+L'*+10\n         MVC   MSGT+13(4),=CL4'(PO)'\n         B     LSTFDS1D\n         TM    DS1DSORG+1,DS1ACBM+DS1ORGAM\n         BZ    *+L'*+10\n         MVC   MSGT+13(4),=CL4'(VS)'\n         B     LSTFDS1D\n         MVI   MSGT+13,C' '\nLSTFDS1D MVC   MSGT+38(9),=CL9'DS1RECFM='\n         UNPK  MSGT+47(3),DS1RECFM(2)\n         TR    MSGT+47(2),UNPACKT-C'0'\n         TM    DS1RECFM,DS1RECFU\n         BNO   *+L'*+10\n         MVC   MSGT+49(3),=CL3'(U)'\n         B     LSTFDS1E\n         TM    DS1RECFM,DS1RECFF\n         BZ    *+L'*+28\n         TM    DS1RECFM,DS1RECFB\n         BZ    *+L'*+10\n         MVC   MSGT+49(4),=CL4'(FB)'\n         B     LSTFDS1E\n         MVC   MSGT+49(3),=CL3'(F)'\n         B     LSTFDS1E\n         TM    DS1RECFM,DS1RECFV\n         BZ    *+L'*+28\n         TM    DS1RECFM,DS1RECFB\n         BZ    *+L'*+10\n         MVC   MSGT+49(4),=CL4'(VB)'\n         B     LSTFDS1E\n         MVC   MSGT+49(3),=CL3'(V)'\n         B     LSTFDS1E\n         MVI   MSGT+49,C' '\nLSTFDS1E BAS   R8,LSTFDS1X\n         MVC   MSGT(9),=CL9'DS1OPTCD='\n         UNPK  MSGT+9(3),DS1OPTCD(2)\n         TR    MSGT+9(2),UNPACKT-C'0'\n         MVI   MSGT+11,C' '\n         MVC   MSGT+38(9),=CL9'DS1BLKL ='\n         UNPK  MSGT+47(5),DS1BLKL(3)\n         TR    MSGT+47(4),UNPACKT-C'0'\n         XR    R0,R0\n         ICM   R0,B'0011',DS1BLKL\n         BNZ   *+L'*+8\n         MVI   MSGT+51,C' '\n         B     LSTFDS1F\n         CVD   R0,DOUBLE\n         MVC   MSGT+51(6),=XL6'402020202120'\n         ED    MSGT+51(6),DOUBLE+5\n         MVI   MSGT+51,C'('\n         MVI   MSGT+57,C')'\nLSTFDS1F BAS   R8,LSTFDS1X\n         MVC   MSGT(9),=CL9'DS1LRECL='\n         UNPK  MSGT+9(5),DS1LRECL(3)\n         TR    MSGT+9(4),UNPACKT-C'0'\n         XR    R0,R0\n         ICM   R0,B'0011',DS1LRECL\n         BNZ   *+L'*+8\n         MVI   MSGT+13,C' '\n         B     LSTFDS1G\n         CVD   R0,DOUBLE\n         MVC   MSGT+13(6),=XL6'402020202120'\n         ED    MSGT+13(6),DOUBLE+5\n         MVI   MSGT+13,C'('\n         MVI   MSGT+19,C')'\nLSTFDS1G MVC   MSGT+38(9),=CL9'DS1KEYL ='\n         UNPK  MSGT+47(3),DS1KEYL(2)\n         TR    MSGT+47(2),UNPACKT-C'0'\n         MVI   MSGT+49,C' '\n         BAS   R8,LSTFDS1X\n         MVC   MSGT(9),=CL9'DS1RKP  ='\n         UNPK  MSGT+9(5),DS1RKP(3)\n         TR    MSGT+9(4),UNPACKT-C'0'\n         MVI   MSGT+13,C' '\n         MVC   MSGT+38(9),=CL9'DS1DSIND='\n         UNPK  MSGT+47(3),DS1DSIND(2)\n         TR    MSGT+47(2),UNPACKT-C'0'\n         CLI   103(R5),0           DMS SVC ACTIVE ?\n         BNE   *+L'*+8             YES\n         MVI   MSGT+49,C' '\n         B     *+L'*+6\n         MVC   MSGT+49(16),=CL16'(X''02''=DS1DSCHA)'\n         BAS   R8,LSTFDS1X\n         MVC   MSGT(9),=CL9'DS1SCAL1='\n         UNPK  MSGT+9(3),DS1SCAL1(2)\n         TR    MSGT+9(2),UNPACKT-C'0'\n         TM    DS1SCAL1,DS1CYL\n         BNO   *+L'*+10\n         MVC   MSGT+11(5),=CL5'(CYL)'\n         B     LSTFDS1H\n         TM    DS1SCAL1,DS1TRK\n         BZ    *+L'*+10\n         MVC   MSGT+11(5),=CL5'(TRK)'\n         B     LSTFDS1H\n         TM    DS1SCAL1,DS1AVR\n         BZ    *+L'*+10\n         MVC   MSGT+11(5),=CL5'(BLK)'\n         B     LSTFDS1H\n         MVC   MSGT+11(5),=CL5'(ABS)'\nLSTFDS1H MVC   MSGT+38(9),=CL9'DS1SCAL3='\n         UNPK  MSGT+47(7),DS1SCAL3(4)\n         TR    MSGT+47(6),UNPACKT-C'0'\n         MVI   MSGT+53,C' '\n         BAS   R8,LSTFDS1X\n         MVC   MSGT(9),=CL9'DS1LSTAR='\n         UNPK  MSGT+9(7),DS1LSTAR(4)\n         TR    MSGT+9(6),UNPACKT-C'0'\n         MVI   MSGT+15,C' '\n         MVC   MSGT+38(9),=CL9'DS1TRBAL='\n         UNPK  MSGT+47(5),DS1TRBAL(3)\n         TR    MSGT+47(4),UNPACKT-C'0'\n         MVI   MSGT+51,C' '\n         BAS   R8,LSTFDS1X\n         MVC   MSGT(9),=CL9'RESERVED='\n         UNPK  MSGT+9(5),103(3,R5)\n         TR    MSGT+9(4),UNPACKT-C'0'\n         CLI   103(R5),0           DMS SVC ACTIVE ?\n         BNE   *+L'*+8             YES\n         MVI   MSGT+13,C' '\n         B     *+L'*+12\n         MVC   MSGT+13(12),=CL12'(DMSSVCNO= )'\n         MVC   MSGT+23(1),103(R5)\n         MVC   MSGT+38(9),=CL9'DS1EXT1 ='\n         UNPK  MSGT+47(15),DS1EXT1(8)\n         UNPK  MSGT+61(7),DS1EXT1+7(4)\n         TR    MSGT+47(20),UNPACKT-C'0'\n         MVI   MSGT+67,C' '\n         BAS   R8,LSTFDS1X\n         MVC   MSGT(9),=CL9'DS1EXT2 ='\n         UNPK  MSGT+9(15),DS1EXT2(8)\n         UNPK  MSGT+23(7),DS1EXT2+7(4)\n         TR    MSGT+9(20),UNPACKT-C'0'\n         MVI   MSGT+29,C' '\n         MVC   MSGT+38(9),=CL9'DS1EXT3 ='\n         UNPK  MSGT+47(15),DS1EXT3(8)\n         UNPK  MSGT+61(7),DS1EXT3+7(4)\n         TR    MSGT+47(20),UNPACKT-C'0'\n         MVI   MSGT+67,C' '\n         BAS   R8,LSTFDS1X\n         MVC   MSGT(9),=CL9'DS1PTRDS='\n         UNPK  MSGT+9(11),DS1PTRDS(6)\n         TR    MSGT+9(10),UNPACKT-C'0'\n         MVI   MSGT+19,C' '\n         BAS   R8,LSTFDS1X\n         DROP  R5,R7\n         BR    R6\n         SPACE 1\n         LTORG\n         SPACE 1\n         DC    0D'0'               END OF LOCAL CSECT, MAX. BASE REG\n         EJECT\n*        FULL DISPLAY FORMAT 1 DSCB.\n         SPACE 1\n         USING *,R7\nFLSFDS1  LA    R5,WADS1\n         MVI   MSGT,C' '\n         MVC   MSGT+1(L'MSGT-1),MSGT\n         USING FORMAT1,R5\n         MVC   MSGT(26),=CL26'FORMAT 1 DSCB ON VOLUME :'\n         MVC   MSGT+26(L'RNAME),RNAME\n         LA    R8,FLSFDS1N\nFLSFDS1X LA    R0,L'MSGT\n         LA    R1,MSGT\n         BAS   R14,PUTLNE\n         MVI   MSGT,C' '\n         MVC   MSGT+1(L'MSGT-1),MSGT\n         BR    R8\nFLSFDS1N LA    R0,DS1DSNAM-FORMAT1\n         LA    R14,FLSFDS1M\nFLSFDS1Z ST    R0,DOUBLE\n         UNPK  MSGT+5(3),DOUBLE+3(2)\n         TR    MSGT+5(2),UNPACKT-C'0'\n         MVC   MSGT(5),=XL5'402021204D'\n         CVD   R0,DOUBLE\n         ED    MSGT(4),DOUBLE+6\n         MVI   MSGT,C'+'\n         MVC   MSGT+7(2),=CL2')'\n         BR    R14\nFLSFDS1M MVC   MSGT+9(9),=CL9'DS1DSNAM='\n         LH    R1,DSNAMEL\n         BCT   R1,*+L'*+6\n         MVC   MSGT+18(*-*),DSNAME\n         EX    R1,*-6\n         BAS   R8,FLSFDS1X\n         LA    R0,DS1FMTID-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1FMTID='\n         UNPK  MSGT+18(3),DS1FMTID(2)\n         TR    MSGT+18(2),UNPACKT-C'0'\n         MVI   MSGT+20,C' '\n         BAS   R8,FLSFDS1X\n         LA    R0,DS1DSSN-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1DSSN ='\n         UNPK  MSGT+18(13),DS1DSSN(7)\n         TR    MSGT+18(12),UNPACKT-C'0'\n         CLI   103(R5),0           DMS SVC ACTIVE ?\n         BNE   *+L'*+14            YES\n         MVI   MSGT+30,C'='\n         MVC   MSGT+31(6),DS1DSSN\n         B     FLSFDS1A\n         MVC   MSGT+30(10),=CL10'(DMSMODDT='\n         XR    R0,R0\n         ICM   R0,B'0111',DS1DSSN+3\n         SRDL  R0,16\n         SRL   R1,16\n         CVD   R0,DOUBLE\n         CVD   R1,TTR\n         MVC   DOUBLE(4),=XL4'40212020'\n         ED    DOUBLE(4),DOUBLE+6\n         MVC   MSGT+40(2),DOUBLE+2\n         MVC   DOUBLE(6),=XL6'402120202020'\n         ED    DOUBLE(6),TTR+5\n         MVC   MSGT+42(3),DOUBLE+3\n         MVI   MSGT+45,C')'\nFLSFDS1A BAS   R8,FLSFDS1X\n         LA    R0,DS1VOLSQ-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1VOLSQ='\n         UNPK  MSGT+18(5),DS1VOLSQ(3)\n         TR    MSGT+18(4),UNPACKT-C'0'\n         MVI   MSGT+22,C' '\n         BAS   R8,FLSFDS1X\n         LA    R0,DS1CREDT-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1CREDT='\n         UNPK  MSGT+18(7),DS1CREDT(4)\n         TR    MSGT+18(6),UNPACKT-C'0'\n         MVI   MSGT+24,C'('\n         XR    R0,R0\n         ICM   R0,B'0111',DS1CREDT\n         SRDL  R0,16\n         SRL   R1,16\n         CVD   R0,DOUBLE\n         CVD   R1,TTR\n         MVC   DOUBLE(4),=XL4'40212020'\n         ED    DOUBLE(4),DOUBLE+6\n         MVC   MSGT+25(2),DOUBLE+2\n         MVC   DOUBLE(6),=XL6'402120202020'\n         ED    DOUBLE(6),TTR+5\n         MVC   MSGT+27(3),DOUBLE+3\n         MVI   MSGT+30,C')'\n         BAS   R8,FLSFDS1X\n         LA    R0,DS1EXPDT-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1EXPDT='\n         UNPK  MSGT+18(7),DS1EXPDT(4)\n         TR    MSGT+18(6),UNPACKT-C'0'\n         XR    R0,R0\n         ICM   R0,B'0111',DS1EXPDT\n         BNZ   *+L'*+8\n         MVI   MSGT+24,C' '\n         B     FLSFDS1B\n         MVI   MSGT+24,C'('\n         SRDL  R0,16\n         SRL   R1,16\n         CVD   R0,DOUBLE\n         CVD   R1,TTR\n         MVC   DOUBLE(4),=XL4'40212020'\n         ED    DOUBLE(4),DOUBLE+6\n         MVC   MSGT+25(2),DOUBLE+2\n         MVC   DOUBLE(6),=XL6'402120202020'\n         ED    DOUBLE(6),TTR+5\n         MVC   MSGT+27(3),DOUBLE+3\n         MVI   MSGT+30,C')'\nFLSFDS1B BAS   R8,FLSFDS1X\n         LA    R0,DS1NOEPV-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1NOEPV='\n         UNPK  MSGT+18(3),DS1NOEPV(2)\n         TR    MSGT+18(2),UNPACKT-C'0'\n         MVI   MSGT+20,C' '\n         BAS   R8,FLSFDS1X\n         LA    R0,DS1NOBDB-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1NOBDB='\n         UNPK  MSGT+18(3),DS1NOBDB(2)\n         TR    MSGT+18(2),UNPACKT-C'0'\n         MVI   MSGT+20,C' '\n         BAS   R8,FLSFDS1X\n         LA    R0,61\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'RESERVED='\n         UNPK  MSGT+18(3),61(2,R5)\n         TR    MSGT+18(2),UNPACKT-C'0'\n         MVI   MSGT+20,C' '\n         BAS   R8,FLSFDS1X\n         LA    R0,DS1SYSCD-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1SYSCD='\n         UNPK  MSGT+18(15),DS1SYSCD(8)\n         UNPK  MSGT+32(13),DS1SYSCD+7(7)\n         TR    MSGT+18(26),UNPACKT-C'0'\n         MVI   MSGT+44,C'('\n         MVC   MSGT+45(13),DS1SYSCD\n         MVI   MSGT+58,C')'\n         BAS   R8,FLSFDS1X\n         LA    R0,DS1REFD-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1REFD ='\n         UNPK  MSGT+18(7),DS1REFD(4)\n         TR    MSGT+18(6),UNPACKT-C'0'\n         XR    R0,R0\n         ICM   R0,B'0111',DS1REFD\n         BNZ   *+L'*+8\n         MVI   MSGT+24,C' '\n         B     FLSFDS1C\n         MVI   MSGT+24,C'('\n         SRDL  R0,16\n         SRL   R1,16\n         CVD   R0,DOUBLE\n         CVD   R1,TTR\n         MVC   DOUBLE(4),=XL4'40212020'\n         ED    DOUBLE(4),DOUBLE+6\n         MVC   MSGT+25(2),DOUBLE+2\n         MVC   DOUBLE(6),=XL6'402120202020'\n         ED    DOUBLE(6),TTR+5\n         MVC   MSGT+27(3),DOUBLE+3\n         MVI   MSGT+30,C')'\nFLSFDS1C BAS   R8,FLSFDS1X\n         LA    R0,78\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'RESERVED='\n         UNPK  MSGT+18(9),78(5,R5)\n         TR    MSGT+18(8),UNPACKT-C'0'\n         CLI   103(R5),0           DMS SVC ACTIVE ?\n         BNE   *+L'*+8             YES\n         MVI   MSGT+26,C' '\n         B     *+L'*+6\n         MVC   MSGT+26(10),=CL10'(DMSOPCNT)'\n         BAS   R8,FLSFDS1X\n         LA    R0,DS1DSORG-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1DSORG='\n         UNPK  MSGT+18(5),DS1DSORG(3)\n         TR    MSGT+18(4),UNPACKT-C'0'\n         TM    DS1DSORG,DS1DSGIS\n         BZ    *+L'*+10\n         MVC   MSGT+22(4),=CL4'(IS)'\n         B     FLSFDS1D\n         TM    DS1DSORG,DS1DSGPS\n         BZ    *+L'*+10\n         MVC   MSGT+22(4),=CL4'(PS)'\n         B     FLSFDS1D\n         TM    DS1DSORG,DS1DSGDA\n         BZ    *+L'*+10\n         MVC   MSGT+22(4),=CL4'(DA)'\n         B     FLSFDS1D\n         TM    DS1DSORG,DS1DSGPO\n         BZ    *+L'*+10\n         MVC   MSGT+22(4),=CL4'(PO)'\n         B     FLSFDS1D\n         TM    DS1DSORG+1,DS1ACBM+DS1ORGAM\n         BZ    *+L'*+10\n         MVC   MSGT+22(4),=CL4'(VS)'\n         B     FLSFDS1D\n         MVI   MSGT+22,C' '\nFLSFDS1D BAS   R8,FLSFDS1X\n         LA    R0,DS1RECFM-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1RECFM='\n         UNPK  MSGT+18(3),DS1RECFM(2)\n         TR    MSGT+18(2),UNPACKT-C'0'\n         TM    DS1RECFM,DS1RECFU\n         BNO   *+L'*+10\n         MVC   MSGT+20(3),=CL3'(U)'\n         B     FLSFDS1E\n         TM    DS1RECFM,DS1RECFF\n         BZ    *+L'*+28\n         TM    DS1RECFM,DS1RECFB\n         BZ    *+L'*+10\n         MVC   MSGT+20(4),=CL4'(FB)'\n         B     FLSFDS1E\n         MVC   MSGT+20(3),=CL3'(F)'\n         B     FLSFDS1E\n         TM    DS1RECFM,DS1RECFV\n         BZ    *+L'*+28\n         TM    DS1RECFM,DS1RECFB\n         BZ    *+L'*+10\n         MVC   MSGT+20(4),=CL4'(VB)'\n         B     FLSFDS1E\n         MVC   MSGT+20(3),=CL3'(V)'\n         B     FLSFDS1E\n         MVI   MSGT+20,C' '\nFLSFDS1E BAS   R8,FLSFDS1X\n         LA    R0,DS1OPTCD-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1OPTCD='\n         UNPK  MSGT+18(3),DS1OPTCD(2)\n         TR    MSGT+18(2),UNPACKT-C'0'\n         MVI   MSGT+20,C' '\n         BAS   R8,FLSFDS1X\n         LA    R0,DS1BLKL-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1BLKL ='\n         UNPK  MSGT+18(5),DS1BLKL(3)\n         TR    MSGT+18(4),UNPACKT-C'0'\n         XR    R0,R0\n         ICM   R0,B'0011',DS1BLKL\n         BNZ   *+L'*+8\n         MVI   MSGT+22,C' '\n         B     FLSFDS1F\n         CVD   R0,DOUBLE\n         MVC   MSGT+22(6),=XL6'402020202120'\n         ED    MSGT+22(6),DOUBLE+5\n         MVI   MSGT+22,C'('\n         MVI   MSGT+28,C')'\nFLSFDS1F BAS   R8,FLSFDS1X\n         LA    R0,DS1LRECL-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1LRECL='\n         UNPK  MSGT+18(5),DS1LRECL(3)\n         TR    MSGT+18(4),UNPACKT-C'0'\n         XR    R0,R0\n         ICM   R0,B'0011',DS1LRECL\n         BNZ   *+L'*+8\n         MVI   MSGT+22,C' '\n         B     FLSFDS1G\n         CVD   R0,DOUBLE\n         MVC   MSGT+22(6),=XL6'402020202120'\n         ED    MSGT+22(6),DOUBLE+5\n         MVI   MSGT+22,C'('\n         MVI   MSGT+28,C')'\nFLSFDS1G BAS   R8,FLSFDS1X\n         LA    R0,DS1KEYL-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1KEYL ='\n         UNPK  MSGT+18(3),DS1KEYL(2)\n         TR    MSGT+18(2),UNPACKT-C'0'\n         MVI   MSGT+20,C' '\n         BAS   R8,FLSFDS1X\n         LA    R0,DS1RKP-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1RKP  ='\n         UNPK  MSGT+18(5),DS1RKP(3)\n         TR    MSGT+18(4),UNPACKT-C'0'\n         MVI   MSGT+22,C' '\n         BAS   R8,FLSFDS1X\n         LA    R0,DS1DSIND-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1DSIND='\n         UNPK  MSGT+18(3),DS1DSIND(2)\n         TR    MSGT+18(2),UNPACKT-C'0'\n         CLI   103(R5),0           DMS SVC ACTIVE ?\n         BNE   *+L'*+8             YES\n         MVI   MSGT+20,C' '\n         B     *+L'*+6\n         MVC   MSGT+20(16),=CL16'(X''02''=DS1DSCHA)'\n         BAS   R8,FLSFDS1X\n         LA    R0,DS1SCAL1-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1SCAL1='\n         UNPK  MSGT+18(3),DS1SCAL1(2)\n         TR    MSGT+18(2),UNPACKT-C'0'\n         TM    DS1SCAL1,DS1CYL\n         BNO   *+L'*+10\n         MVC   MSGT+20(5),=CL5'(CYL)'\n         B     FLSFDS1H\n         TM    DS1SCAL1,DS1TRK\n         BZ    *+L'*+10\n         MVC   MSGT+20(5),=CL5'(TRK)'\n         B     FLSFDS1H\n         TM    DS1SCAL1,DS1AVR\n         BZ    *+L'*+10\n         MVC   MSGT+20(5),=CL5'(BLK)'\n         B     FLSFDS1H\n         MVC   MSGT+20(5),=CL5'(ABS)'\nFLSFDS1H BAS   R8,FLSFDS1X\n         LA    R0,DS1SCAL3-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1SCAL3='\n         UNPK  MSGT+18(7),DS1SCAL3(4)\n         TR    MSGT+18(6),UNPACKT-C'0'\n         MVI   MSGT+24,C' '\n         BAS   R8,FLSFDS1X\n         LA    R0,DS1LSTAR-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1LSTAR='\n         UNPK  MSGT+18(7),DS1LSTAR(4)\n         TR    MSGT+18(6),UNPACKT-C'0'\n         MVI   MSGT+24,C' '\n         BAS   R8,FLSFDS1X\n         LA    R0,DS1TRBAL-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1TRBAL='\n         UNPK  MSGT+18(5),DS1TRBAL(3)\n         TR    MSGT+18(4),UNPACKT-C'0'\n         MVI   MSGT+22,C' '\n         BAS   R8,FLSFDS1X\n         LA    R0,103\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'RESERVED='\n         UNPK  MSGT+18(5),103(3,R5)\n         TR    MSGT+18(4),UNPACKT-C'0'\n         CLI   103(R5),0           DMS SVC ACTIVE ?\n         BNE   *+L'*+8             YES\n         MVI   MSGT+22,C' '\n         B     *+L'*+12\n         MVC   MSGT+22(12),=CL12'(DMSSVCNO= )'\n         MVC   MSGT+32(1),103(R5)\n         BAS   R8,FLSFDS1X\n         LA    R0,DS1EXT1-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1EXT1 ='\n         UNPK  MSGT+18(15),DS1EXT1(8)\n         UNPK  MSGT+32(7),DS1EXT1+7(4)\n         TR    MSGT+18(20),UNPACKT-C'0'\n         MVI   MSGT+38,C' '\n         BAS   R8,FLSFDS1X\n         LA    R0,DS1EXT2-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1EXT2 ='\n         UNPK  MSGT+18(15),DS1EXT2(8)\n         UNPK  MSGT+32(7),DS1EXT2+7(4)\n         TR    MSGT+18(20),UNPACKT-C'0'\n         MVI   MSGT+38,C' '\n         BAS   R8,FLSFDS1X\n         LA    R0,DS1EXT3-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1EXT3 ='\n         UNPK  MSGT+18(15),DS1EXT3(8)\n         UNPK  MSGT+32(7),DS1EXT3+7(4)\n         TR    MSGT+18(20),UNPACKT-C'0'\n         MVI   MSGT+38,C' '\n         BAS   R8,FLSFDS1X\n         LA    R0,DS1PTRDS-FORMAT1\n         BAS   R14,FLSFDS1Z\n         MVC   MSGT+9(9),=CL9'DS1PTRDS='\n         UNPK  MSGT+18(11),DS1PTRDS(6)\n         TR    MSGT+18(10),UNPACKT-C'0'\n         MVI   MSGT+28,C' '\n         BAS   R8,FLSFDS1X\n         DROP  R5,R7\n         BR    R6\n         SPACE 1\n         LTORG\n         SPACE 1\n         DC    0D'0'               END OF LOCAL CSECT, MAX. BASE REG\n         EJECT\n*------- PARSE PCL CSECT AND PDL DSECT.\n         PRINT NOGEN\n         SPACE 1\n         DS    0D                  BEGIN PARSE PCL CSECT\n         SPACE 1\nCDSCBPCL IKJPARM\nDSN      IKJPOSIT DSNAME,USID,PROMPT='DATASET NAME'\nSHRKW    IKJKEYWD\n         IKJNAME 'SHR'\nVOLKW    IKJKEYWD\n         IKJNAME 'VOLUME',SUBFLD=VOLSUB\nUNIKW    IKJKEYWD\n         IKJNAME 'UNIT',SUBFLD=UNISUB\nZAPKW    IKJKEYWD\n         IKJNAME 'ZAP',SUBFLD=ZAPSUB\nRECKW    IKJKEYWD\n         IKJNAME 'RECFM',SUBFLD=RECSF\nLREKW    IKJKEYWD\n         IKJNAME 'LRECL',SUBFLD=LRESF\nBLKKW    IKJKEYWD\n         IKJNAME 'BLKSIZE',SUBFLD=BLKSF\nDSOKW    IKJKEYWD\n         IKJNAME 'DSORG',SUBFLD=DSOSF\nPROKW    IKJKEYWD\n         IKJNAME 'PW'\n         IKJNAME 'PWREAD'\n         IKJNAME 'PWWRITE'\n         IKJNAME 'NOPW'\n         IKJNAME 'RACF'\n         IKJNAME 'NORACF'\nALLKW    IKJKEYWD\n         IKJNAME 'ALLOC',SUBFLD=ALLSF\nSPAKW    IKJKEYWD\n         IKJNAME 'SPACE',SUBFLD=SPASF\nCREATEKW IKJKEYWD\n         IKJNAME 'CREATE',SUBFLD=CRESF\nEXPDTEKW IKJKEYWD\n         IKJNAME 'EXPDT',SUBFLD=EXPSF\nREFDTEKW IKJKEYWD\n         IKJNAME 'REFDT',SUBFLD=REFSF\nLOGKW    IKJKEYWD\n         IKJNAME 'LOG'\n         IKJNAME 'NOLOG'\nLSTKW    IKJKEYWD\n         IKJNAME 'LIST'\n         IKJNAME 'NOLIST'\n         IKJNAME 'FULL'\n         EJECT\n*------- SUBFIELDS.\n         SPACE 1\nVOLSUB   IKJSUBF\nVOL      IKJIDENT 'VOLUME',FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=6,    X\n               PROMPT='VOLUME SERIAL'\nUNISUB   IKJSUBF\nUNIT     IKJIDENT 'UNIT',FIRST=ALPHANUM,OTHER=ANY,MAXLNTH=8,           X\n               PROMPT='UNIT NAME'\nZAPSUB   IKJSUBF\nREP      IKJIDENT 'ZAP PARAMETER',LIST,                                X\n               FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=12,               X\n               PROMPT='ZAP IN FORMAT : OFFSET VERDATA REPDATA',        X\n               VALIDCK=REPVALCK\nRECSF    IKJSUBF\nRECFM    IKJKEYWD\n         IKJNAME 'F'\n         IKJNAME 'FS'\n         IKJNAME 'FA'\n         IKJNAME 'FM'\n         IKJNAME 'FB'\n         IKJNAME 'FBS'\n         IKJNAME 'FBA'\n         IKJNAME 'FBM'\n         IKJNAME 'V'\n         IKJNAME 'VS'\n         IKJNAME 'VA'\n         IKJNAME 'VM'\n         IKJNAME 'VB'\n         IKJNAME 'VBS'\n         IKJNAME 'VBA'\n         IKJNAME 'VBM'\n         IKJNAME 'U'\n         IKJNAME 'UA'\n         IKJNAME 'UM'\n         IKJNAME 'UT'\nLRESF    IKJSUBF\nLRE      IKJIDENT 'LRECL',                                             X\n               FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=5,                  X\n               PROMPT='LOGICAL RECORD LENGTH'\nBLKSF    IKJSUBF\nBLK      IKJIDENT 'BLOCK SIZE',                                        X\n               FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=5,                  X\n               PROMPT='BLOCK SIZE'\nDSOSF    IKJSUBF\nDSORG    IKJKEYWD\n         IKJNAME 'PS'\n         IKJNAME 'PSU'\n         IKJNAME 'PO'\n         IKJNAME 'POU'\n         IKJNAME 'DA'\n         IKJNAME 'DAU'\nALLSF    IKJSUBF\nALL      IKJKEYWD\n         IKJNAME 'NONE'\n         IKJNAME 'BLOCKS'\n         IKJNAME 'TRACKS'\n         IKJNAME 'CYLINDERS'\nSPASF    IKJSUBF\nSPA      IKJIDENT 'SECONDARY SPACE AMOUNT',                            X\n               FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=4,                  X\n               PROMPT='SECONDARY SPACE AMOUNT'\nCRESF    IKJSUBF\nCREATE   IKJIDENT 'CREATION DATE',ASTERISK,                            X\n               FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=5,                  X\n               PROMPT='CREATION DATE'\nEXPSF    IKJSUBF\nEXPDTE   IKJIDENT 'EXPIRATION DATE',                                   X\n               FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=5,                  X\n               PROMPT='EXPIRATION DATE'\nREFSF    IKJSUBF\nREFDTE   IKJIDENT 'REFERENCE DATE',ASTERISK,                           X\n               FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=5,                  X\n               PROMPT='REFERENCE DATE'\n         IKJENDP\n         EJECT\n*------- DSECTS.\n         SPACE 1\n         PRINT GEN\n         SPACE 1\n@DATA    DSECT\n         DS    18F                 SAVE AREA\nDOUBLE   DS    D\nTTR      DS    D\nLINKAREA DS    2F\nMYPPL    DS    0F,(LPPL)X\nMYANS    DS    F\nMYECB    DS    F                   USED BY PUTLINE ROUTINE\nMYIOPL   DS    0F,(LIOPL)X         USED BY PUTLINE ROUTINE\nMYPTPB   DS    0F,(PTPBL)X         USED BY PUTLINE ROUTINE\nMYOLD    DS    2F                  USED BY PUTLINE ROUTINE\nMYSEG1   DS    F                   USED BY PUTLINE ROUTINE\nMYSGM1   DS    CL100               USED BY PUTLINE ROUTINE\nPUTSAVE  DS    4F                  USED BY PUTLINE ROUTINE\nMYSTPB   DS    0F,(STACKDL)X\nMYDAPL   DS    0F,(LDAPL)X\nMYDAPB   DS    0F,(DAPBL)X\nCALLDR14 DS    F\nRW       DS    0F,(RL)X\nQNAME    DS    CL8\nRNAME    DS    CL6\nDSNAMEL  DS    H\nDSNAME   DS    CL44\nUCBAD    DS    F\nDW       DS    0F,(DL)X\nDEVAREA  DS    5F\nMSGW     DS    0F,(LMSGW)X\nMSGT     EQU   MSGW,78\nSYNADMSG EQU   MSGW,78\nSTAXD    DS    0F,(STAXL)X                                         -EU-\nOPEND    DS    F\nOPENJD   DS    F\nRDJFCBD  DS    F\nREADDECB DS    0F,(READL)X                                         -EU-\nWRITDECB DS    0F,(WRITEL)X                                        -EU-\nDCB      DS    0D,(DCBLEN)X                                        -EU-\nJFCB     DS    0D,XL176\nEXLSTD   DS    F\nCLOSED   DS    F\nPACK14   DS    F\nRC       DS    F\nNEWSPA   DS    F\nNEWCRE   DS    F\nNEWEXP   DS    F\nNEWREF   DS    F\nMYDFPARM DS    0F,(DFLEN)X         USED BY DAIRFAIL\nMYDFREGS DS    F                   USED BY DAIRFAIL\nMYDFRC   DS    F                   USED BY DAIRFAIL\nMYJEFF02 DS    F                   USED BY DAIRFAIL\nMYDFID   DS    H                   USED BY DAIRFAIL\nTRACKS   DS    H\nNEWBLK   DS    H\nNEWLRE   DS    H\nVERDATA  DS    CL14      LENGTH TIED TO MAXLNTH IN IKJPOSIT\nREPDATA  DS    CL14      1ST BYTE IS LENGTH, LAST BYTE USED BY 'PACK'\nWRKUNIT  DS    CL8\nDATE5    DS    0CL5\nWRKVOL   DS    CL6\nOFFSET   DS    H,CL3\nVR       DS    C\nEXPCH    DS    CL5\nNEWPRO0  DS    C\nNEWPRO1  DS    C\nNEWPROSV DS    C\nNEWRECFM DS    C\nNEWALL0  DS    C\nNEWALL1  DS    C\nEXPSW    DS    X\nNEWDSORG DS    XL2                                                 -EU-\nSWITCH1  DS    X                                                   -EU-\nNEWPROSW EQU   X'80'                                               -EU-\nNEWBLKSW EQU   X'40'                                               -EU-\nNEWLRESW EQU   X'20'                                               -EU-\nNEWDSOSW EQU   X'10'                                               -EU-\nNEWALLSW EQU   X'08'                                               -EU-\nNEWSPASW EQU   X'04'                                               -EU-\nNEWCRESW EQU   X'02'                                               -EU-\nNEWEXPSW EQU   X'01'                                               -EU-\nSWITCH2  DS    X                                                   -EU-\nNEWREFSW EQU   X'80'                                               -EU-\nNEWRECSW EQU   X'40'                                               -EU-\nSTATUS   DS    X                                                   -EU-\nSTATA    EQU   X'80'\nSTATM    EQU   X'40'\nSTATG    EQU   X'20'\nSTATO    EQU   X'10'\nSTATQ    EQU   X'08'\nSTATS    EQU   X'04'                                               -EU-\nCHGSW    EQU   X'02'                                               -EU-\nSYNADSWT EQU   X'01'               SYNAD EXIT TAKEN                -EU-\n         SPACE 1\nRQA      DC    XL1'0'                                              -EU-\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(*-*)            -EU-\n         SPACE 1                                                   -EU-\nWADS1    DS    ((((DS1END-IECSDSF1)+7)/8)*8)X\n         SPACE 1\n@DATAL   EQU   (((*-@DATA)+7)/8)*8\n@SIZE    EQU   @DATAL-18*4\n         EJECT\n         PRINT NOGEN\n         IHAPSA\n         IHAASCB\n         CVT   DSECT=YES,LIST=YES\n         IKJTCB\n         IEZJSCB\n         IKJCPPL\n         IKJIOPL\nLIOPL    EQU   *-IOPL\n         IKJUPT\n         IKJECT\n         IKJPPL\nLPPL     EQU   *-PPL\n         IKJDAPL\nLDAPL    EQU   *-DAPL\n         IKJDAP08\nDAPBL    EQU   *-DAPB08            LONGEST DAPB\n         IKJDAP18\n         IKJEFFDF DFDSECT=YES\n         DCBD  DSORG=DA,DEVD=DA\n         IHADECB\nFORMAT1  DSECT\n         IECSDSL1 (1)              FORMAT 1 DSCB\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CDSCB$": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x9f\\x00\\x942\\x9f\\x14\\x17\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-25T00:00:00", "modifydate": "1994-11-25T14:17:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//CDSCB    JOB (........),'INSTALL  - CDSCB -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=5\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ4AS3,OPT=',RENT',MBR=CDSCB\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT,AC=1'\n//SYSIN     DD *\n  ENTRY   CDSCB\n  NAME    CDSCB(R)\n/*\n//HLP     EXEC PAJHELP,MBR=CDSCBH,DSS='->.SOURCE.FILE4'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CDSCB@": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90)o\\x00\\x90)o\\x08U\\x00K\\x00K\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-23T00:00:00", "modifydate": "1990-10-23T08:55:00", "lines": 75, "newlines": 75, "modlines": 0, "user": "SYSPAJA"}, "text": "1   22/10/90\n                                                      CDSCB     1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     CHANGE DSCB (VTOC FORMAT-1)     * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  CBT origin : Extracted from CBT tape 84 JUN, file 300.\n  ------------\n\n  Purpose :   The CDSCB (change DSCB) command modifies a data-set's\n  ---------   format-1 DSCB in a VTOC.\n\n  Authority : Since the format-1 DSCB contains information crucial to\n  ----------- data-sets security and integrity (and in fact to the\n              whole SYSTEM's security and integrity), this command\n              is restricted to Systems Support personnel.\n\n  Syntax :    CDSCB 'DSNAME' EXPDT('YYDDD')   SHR   VOL(VOLUME)\n  --------                   UNIT(UNIT)   CREATE('YYDDD')\n                             REFDT('YYDDD')   DSORG(XX)\n                             RECFM(XX)   LRECL(XX)   BLKSIZE(XX)\n                             ALLOC(TR/CYL/BL)\n                             SPACE(SECONDARY-AMOUNT)\n                             PWR/PWW/NOP/RACF/NORACF\n                             ZAP(OFFSET VERDATA REPDATA)\n                             LIST/NOLIST/FULL\n         Required - 'DSNAME'\n         Defaults - nothing will happen if no changes are specified.\n         ALIAS    - none\n\n  Operands : 'DSNAME' - the name of the data-set whose format-1 DSCB\n  ----------            is to be modified.\n  UNIT(UNIT)  : for uncataloged data-sets, the UNIT TYPE of the volume\n                where the data-set resides.\n  VOL(VOLUME) : for uncataloged data-sets, the VOLUME SERIAL of the\n                data-set.\n  SHR         : this keyword indicates that the DSCB is to be modified\n                even if another job or TSO session is using the\n                data-set.\n  EXPDT('YYDDD') : the EXPIRATION DATE is to be set to the specified\n                Julian date ('YYDDD' must be either a five digit\n                Julian date or a zero).\n  CREATE('YYDDD') : the CREATION DATE is to be set to the specified\n                Julian date ('YYDDD' must be either a five digit\n                Julian date, a zero, or an asterisk (todays date).\n1   22/10/90\n                                                      CDSCB     2/2.\n\n  REFDT('YYDDD') : the REFERENCE DATE is to be set to the specified\n                Julian date ('YYDDD' must be either a five digit\n                Julian date, a zero, or an asterisk (todays date).\n  DSORG(DSORG) : the DSORG is to be changed to the specified type.\n  RECFM(RECFM) : the RECFM is to be changed to the specified type.\n  LRECL(LRECL) : the LRECL is to be changed to the specified value.\n  BLKSIZE(VALUE) : the BLKSIZE is to be changed to the specified value.\n  PWR         : the PROTECTION FLAGS are to be set for PWREAD, meaning\n                a password is required to read or write.\n  PWW         : the PROTECTION FLAGS are to be set for PWWRITE, meaning\n                a password is required to write but not to read.\n  NOP         : the PROTECTION FLAGS are to be set off, meaning a\n                password is never required.\n  RACF        : the data-set is to be marked RACF protected.\n  NORACF      : the data-set is to be marked NOT RACF protected.\n  ZAP(OFFSET VERDATA REPDATA) : this keyword may be used to modify\n                fields within the DSCB by specifying (in HEX) the\n                field offset, the field's current value (in HEX), and\n                the replacement value (in HEX). If the current value\n                does not verify correctly, the data is not replaced.\n                The REPDATA may be omitted if you just want to verify.\n  LIST        : display the Format 1 DSCB.\n  NOLIST      : don't display the Format 1 DSCB.\n  FULL        : fully display the Format 1 DSCB.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CDSCBH": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90)o\\x00\\x90)o\\x08U\\x00<\\x00<\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-23T00:00:00", "modifydate": "1990-10-23T08:55:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=CDSCB\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION : THE CDSCB (CHANGE DSCB) COMMAND MODIFIES A DATA-SET'S\n              FORMAT-1 DSCB IN A VTOC.\n              SINCE THE FORMAT-1 DSCB CONTAINS INFORMATION CRUCIAL TO\n              DATA-SETS SECURITY AND INTEGRITY, (AND IN FACT TO THE\n              WHOLE SYSTEM'S SECURITY AND INTEGRITY), THIS COMMAND\n              IS RESTRICTED TO SYSTEMS SUPPORT PERSONNEL.\n)X SYNTAX  :  CDSCB 'DSNAME' EXPDT('YYDDD')   SHR   VOL(VOLUME)\n                             UNIT(UNIT)   CREATE('YYDDD')\n                             REFDT('YYDDD')   DSORG(XX)\n                             RECFM(XX)   LRECL(XX)   BLKSIZE(XX)\n                             ALLOC(TR/CYL/BL)\n                             SPACE(SECONDARY-AMOUNT)\n                             PWR/PWW/NOP/RACF/NORACF\n                             ZAP(OFFSET VERDATA REPDATA)\n                             LIST/NOLIST/FULL\n         REQUIRED - 'DSNAME'\n         DEFAULTS - NOTHING WILL HAPPEN IF NO CHANGES ARE SPECIFIED.\n         ALIAS    - NONE\n)O OPERANDS : 'DSNAME'  -  THE NAME OF THE DATA-SET WHOSE FORMAT-1 DSCB\n              IS TO BE MODIFIED.\n))UNIT(UNIT)  : FOR UNCATALOGED DATA-SETS, THE UNIT TYPE OF THE VOLUME\n                WHERE THE DATA-SET RESIDES.\n))VOL(VOLUME) : FOR UNCATALOGED DATA-SETS, THE VOLUME SERIAL OF THE\n                DATA-SET.\n))SHR         : THIS KEYWORD INDICATES THAT THE DSCB IS TO BE MODIFIED\n                EVEN IF ANOTHER JOB OR TSO SESSION IS USING THE\n                DATA-SET.\n))EXPDT('YYDDD') : THE EXPIRATION DATE IS TO BE SET TO THE SPECIFIED\n                JULIAN DATE ('YYDDD' MUST BE EITHER A FIVE DIGIT\n                JULIAN DATE OR A ZERO).\n))CREATE('YYDDD') : THE CREATION DATE IS TO BE SET TO THE SPECIFIED\n                JULIAN DATE ('YYDDD' MUST BE EITHER A FIVE DIGIT\n                JULIAN DATE, A ZERO, OR AN ASTERISK (TODAYS DATE).\n))REFDT('YYDDD') : THE REFERENCE DATE IS TO BE SET TO THE SPECIFIED\n                JULIAN DATE ('YYDDD' MUST BE EITHER A FIVE DIGIT\n                JULIAN DATE, A ZERO, OR AN ASTERISK (TODAYS DATE).\n))DSORG(DSORG) : THE DSORG IS TO BE CHANGED TO THE SPECIFIED TYPE.\n))RECFM(RECFM) : THE RECFM IS TO BE CHANGED TO THE SPECIFIED TYPE.\n))LRECL(LRECL) : THE LRECL IS TO BE CHANGED TO THE SPECIFIED VALUE.\n))BLKSIZE(VALUE) : THE BLKSIZE IS TO BE CHANGED TO THE SPECIFIED VALUE.\n))PWR         : THE PROTECTION FLAGS ARE TO BE SET FOR PWREAD, MEANING\n                A PASSWORD IS REQUIRED TO READ OR WRITE.\n))PWW         : THE PROTECTION FLAGS ARE TO BE SET FOR PWWRITE, MEANING\n                A PASSWORD IS REQUIRED TO WRITE BUT NOT TO READ.\n))NOP         : THE PROTECTION FLAGS ARE TO BE SET OFF, MEANING A\n                PASSWORD IS NEVER REQUIRED.\n))RACF        : THE DATA-SET IS TO BE MARKED RACF PROTECTED.\n))NORACF      : THE DATA-SET IS TO BE MARKED NOT RACF PROTECTED.\n))ZAP(OFFSET VERDATA REPDATA) : THIS KEYWORD MAY BE USED TO MODIFY\n                FIELDS WITHIN THE DSCB BY SPECIFYING (IN HEX) THE\n                FIELD OFFSET, THE FIELD'S CURRENT VALUE (IN HEX), AND\n                THE REPLACEMENT VALUE (IN HEX). IF THE CURRENT VALUE\n                DOES NOT VERIFY CORRECTLY, THE DATA IS NOT REPLACED.\n                THE REPDATA MAY BE OMITTED IF YOU JUST WANT TO VERIFY.\n))LIST        : DISPLAY THE FORMAT 1 DSCB.\n))NOLIST      : DON'T DISPLAY THE FORMAT 1 DSCB.\n))FULL        : FULLY DISPLAY THE FORMAT 1 DSCB.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COMPARB@": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x15_\\x00\\x91\\x15_\\x15S\\x008\\x008\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-06-04T00:00:00", "modifydate": "1991-06-04T15:53:00", "lines": 56, "newlines": 56, "modlines": 0, "user": "SYSPAJA"}, "text": "1   30/04/87\n                                                      COMPAREB  1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      A MODIFIED VERSION OF THE      * * * * * * * *\n  * * * * * * * *        YALE COMPARE PROGRAM.        * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  CBT origin : extracted from CBT tape 87 FEB, file 296.\n  ------------ This COMPARE program originated at YALE university and\n               was obtained from the CONNECTICUT BANK AND TRUST company\n               mods tape (file 226 of CBT tape).\n\n  FUNCTION : this COMPARE program uses only columns 1 through 72, thus\n      any two versions of a program may be easily compared even if one\n      (or both) of the files has been resequenced. If neither file has\n      been resequenced, a PARM of \"FULL\" may be coded to request that\n      all 80 columns be used in the comparison. A facility is also\n      provided to ignore trivial card images (such as \" EJECT \" or\n      \" SPACE 3 \" in an assembler source program).\n      This program uses all available core in its region after opening\n      its input/output files (except for 4K which is released). The\n      obtained core area is used as a compare buffer which is only\n      dumped (written to SYSPRINT) when identical records (based on\n      the first 72 bytes) are found in the OLD and NEW data-sets. If\n      the compare buffer overflows, the program terminates. Therefore,\n      if it is suspected that the two data-sets may be very far out of\n      sync, a large region should be used. The number of unmatched\n      records that can be buffered at one time can be calculated from\n      the expression : (REGION SIZE - 8K - BUFFERS) / 160\n      as a general rule, 30K is sufficient for about 100 unmatched\n      records at a time, and 100K is sufficient for about 500 unmatched\n      records at a time.\n\n      Card images of the trivial data is input from the IGNORE DDname.\n      If the DD-card is missing, a table of trivial data for assembler\n      source code will be assumed (this includes \" EJECT \", \" SPACE   \"\n      \" SPACE 1 \", \" SPACE 2 \", \" SPACE 3 \" and blank comment cards).\n\n      The program format on the CBT mods tape was disassembled source,\n      it was recommented, resymbolized, redocumented and slightly\n      modified by A. BRUCE LELAND (ABL), october, 1978.\n\n  CHANGE :    if output is directed to a TSO terminal, only the first\n              78 characters of each line are written. This may not be\n              desirable if you have hard-copy terminals.\n\n  JCL : //STEPNAME EXEC PGM=COMPAREB,REGION=100K\n        //SYSPRINT   DD SYSOUT=A\n        //OLD        DD DSN=... OLD.SEQ.DSN ...\n        //NEW        DD DSN=... NEW.SEQ.DSN ...\n        //IGNORE     DD *   (OR DUMMY -- OR OMITTED)\n         Trivial card images that are to be ignored in the comparison.\n        /*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPARE": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x16O\\x00\\x90\\x16O\\x12\\x13\\x03\\xfc\\x03\\xfc\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-13T00:00:00", "modifydate": "1990-06-13T12:13:00", "lines": 1020, "newlines": 1020, "modlines": 0, "user": "SYSPAJA"}, "text": "CMPR     TITLE 'C O M P A R E -- COMPARE TSO COMMAND.'             -EU-\nCOMPARE  START 0                                                   -EU-\n         SPACE 1                                                   -EU-\n***********************************************************************\n*\n*        WRITTEN BY. BILL GODFREY,  PLANNING RESEARCH CORPORATION.\n*        INSTALLATION. PRC COMPUTER CENTER INC, MCLEAN VA.\n*        DATE WRITTEN. MAY 12 1981.\n*        DATE UPDATED. SEPTEMBER 17 1981.\n*        ATTRIBUTES. RE-ENTRANT.\n*        DESCRIPTION.\n*         THIS TSO COMMAND INVOKES A COMPARE UTILITY PROGRAM\n*         TO COMPARE TWO SEQUENTIAL DATA SETS (OR MEMBERS).\n*\n*         THE INVOKED UTILITY PROGRAM 'COMPAREB' IS A MODIFIED\n*         VERSION OF THE YALE COMPARE PROGRAM FROM THE CBT TAPE.\n*\n*         THE COMMAND CAN OPTIONALLY INVOKE THE IBM UTILITY\n*         'IEBCOMPR' OR A ZAPPED IEBCOMPR NAMED 'ZEBCOMPR'.\n*         ZEBCOMPR DISPLAYS UNMATCHED RECORDS IN EBCDIC INSTEAD OF HEX.\n*\n*         THE COMMAND ALLOCATES THE TWO DATA SETS AND PASSES\n*         THEIR DDNAMES TO THE UTILITY PROGRAM.\n*\n*        LOG OF CHANGES.\n*         14MAY81 - COMPARE MEMBERNAMES BEFORE ISSUING MSG03.\n*         15JUN81 - ZEBCOMPR KEYWORD ADDED.\n*         16JUN81 - FULL KEYWORD ADDED.\n*         16JUN81 - USERS CAN NOW USE THE NAME 'COMPARE' FOR BOTH\n*                   THE TSO COMMAND AND THE BATCH PROGRAM (COMPAREB).\n*                   IF A USER EXECUTES COMPARE AS A BATCH PROGRAM\n*                   (EXEC PGM=COMPARE) OR FROM THE CALL COMMAND,\n*                   THE COMMAND SIMPLY PASSES CONTROL DIRECTLY TO\n*                   THE COMPAREB PROGRAM, AS IF THE USER HAD SPECIFIED\n*                   EXEC PGM=COMPAREB.  THIS IS USEFUL AT INSTALLATIONS\n*                   THAT INSTALLED THE BATCH PROGRAM AS 'COMPARE'\n*                   BEFORE THEY HAD THE COMPARE COMMAND, AND DONT WANT\n*                   TO MAKE THE USERS CHANGE THEIR EXISTING JCL.\n*         17SEP81 - ASM/NOASM KEYWORD ADDED.\n*         08NOV84 - MODIFIED TO USE PDS PROGRAM PUTLINE             ABL\n*         12MAY85 - MVS USES UNIT(SYSALLDA) INSTEAD OF UCB SEARCH   ABL\n*         12JUN85 - FOR PARTITIONED NEW AND OLD DATA SETS, AN OPEN, ABL\n*                   A BLDL AND A CLOSE IS PERFORMED TO AVOID ABEND  ABL\n*                   013-18 SITUATIONS FOR MISSING MEMBERS.          ABL\n*         30APR87 - ZEBCOMPR KEYWORD DELETED.                      -EU-\n*\n*\n***********************************************************************\n         EJECT\n***********************************************************************\n*\n*        SYNTAX.\n*               COMPARE 'OLDDSNAME' 'NEWDSNAME'\n*\n*            OPTIONAL KEYWORDS ARE:\n*               FULL     - INCLUDE THE SEQUENCE NUMBERS (YALE PGM).\n*               ASM      - COMPARING ASSEMBLER SOURCE CODE (YALE PGM).\n*               IEBCOMPR - THE IEBCOMPR UTILITY IS TO BE USED.\n*               ZEBCOMPR - THE MODIFIED IEBCOMPR IS TO BE USED.\n*                          (NO MORE AVAILABLE KEYWORD)             -EU-\n*               OVOL(VOLUME) - VOLUME CONTAINING THE OLD DATA SET.\n*                          NOT NEEDED IF CATALOGED.\n*               NVOL(VOLUME) - VOLUME CONTAINING THE NEW DATA SET.\n*                          NOT NEEDED IF CATALOGED.\n*               OUNIT(UNIT) - UNIT NAME FOR ALLOCATING THE OLD\n*                          DATA SET. NOT NEEDED IF CATALOGED.\n*               NUNIT(UNIT) - UNIT NAME FOR ALLOCATING THE NEW\n*                          DATA SET. NOT NEEDED IF CATALOGED.\n*               SYSOUT   - MESSAGES TO A SYSOUT DATA SET.\n*               PRINT    - MESSAGES TO TERMINAL (DEFAULT).\n*               NOPRINT  - MESSAGES TO DUMMY FILE.\n*               OUTFILE(FILENAME) - MESSAGES TO SPECIFIED DDNAME.\n*\n*            WHEN THE OVOL OR NVOL KEYWORDS ARE USED TO INDICATE\n*            TWO IDENTICALLY NAMED DATASETS ON DIFFERENT VOLUMES\n*            ARE BEING USED, UNEXPECTED RESULTS CAN OCCUR UNLESS\n*            BOTH OVOL AND NVOL ARE SPECIFIED.  FOR EXAMPLE, IF\n*            OVOL IS SPECIFIED AND NVOL IS NOT, THE ALLOCATION\n*            OF 'NEWDSNAME' WITH NO VOLUME SPECIFIED MAY PICK UP\n*            THE ALREADY ALLOCATED 'OLDDSNAME' INSTEAD OF THE\n*            'NEWDSNAME' IN THE CATALOG.\n*\n***********************************************************************\n         SPACE 2                                                   -EU-\n* ORIGIN : EXTRACTED FROM CBT TAPE 87 FEB, FILE 296.               -EU-\n* --------                                                         -EU-\n         EJECT\n         USING *,R10,R11\n         B     @PROLOG-*(,R15)\n         DC    AL1(11),CL11'COMPARE '\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE    DC    0F'0',AL1(1),AL3(@DATAL) SUBPOOL AND LENGTH\n@PROLOG  STM   R14,R12,12(R13)\n         LR    R10,R15             FIRST BASE REGISTER\n         LA    R15,1\n         LA    R11,4095(R15,R10)   SECOND BASE REGISTER\n         LR    R2,R1               PARM POINTER\n         TM    0(R2),X'80'         IS THIS A CPPL\n         BO    *+L'*+8             NO, GO INVOKE COMPAREB\n         TM    4(R2),X'80'         IS THIS A CPPL\n         BZ    CP                  YES, BRANCH\n         LA    R0,80\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)          CHAIN FORWARD\n         ST    R1,8(,R13)          CHAIN BACK\n         LR    R13,R1              UPDATE SAVEAREA POINTER\n         LA    R3,72(,R13)         POINT TO LINK MF=L\n         XC    0(8,R3),0(R3)       CLEAR LINK MF=L\n         LR    R1,R2\n         LINK  EP=COMPAREB,SF=(E,(R3))\n         LR    R2,R15              SAVE RETURN CODE\n         LR    R1,R13              FOR FREEMAIN\n         LA    R0,80               FOR FREEMAIN\n         L     R13,4(,R13)         BACK TO OLD SAVEAREA\n         FREEMAIN R,LV=(0),A=(1)\n         LR    R15,R2              RETURN CODE\n         LM    R0,R12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n         SPACE 1\n         USING CPPL,R2\nCP       L     R0,@SIZE\n         GETMAIN R,LV=(0)\n         LR    R9,R1               INITIALIZE WORKAREA POINTER\n         USING @DATA,R9\n         LR    R15,R1              AREA TO BE CLEARED\n         L     R1,@SIZE            LENGTH TO BE CLEARED\n         LA    R0,0(,R1)           CLEAR HIGH ORDER BYTE\n         SRDL  R0,8                DIVIDE BY 256\n         SRL   R1,24               ISOLATE REMAINDER\n         LTR   R0,R0               IS QUOTIENT ZERO\n         BZ    CLEARR              YES, GO CLEAR REMAINDER\nCLEARQ   XC    0(256,R15),0(R15)   CLEAR 256 BYTES\n         LA    R15,256(,R15)\n         BCT   R0,CLEARQ           DECREMENT QUOTIENT AND BRANCH\nCLEARR   LTR   R1,R1               IS REMAINDER ZERO\n         BZ    CLEARX              YES, BRANCH TO FINISH\n         BCT   R1,*+L'*+6          LENGTH MINUS 1 FOR EX\n         XC    0(0,R15),0(R15)     (EXECUTED)\n         EX    R1,*-6              DO THE ABOVE XC\nCLEARX   ST    R13,4(,R9)          CHAIN FORWARD\n         ST    R9,8(,R13)          CHAIN BACK\n         LR    R13,R9              UPDATE SAVEAREA POINTER\n         SPACE 1\n************************************************************\n*        SET UP IOPL FOR PUTLINE                           *\n************************************************************\n         SPACE 1\n         ST    R2,VECTOR\n         LA    R15,MYIOPL\n         USING IOPL,R15\n         MVC   IOPLUPT(4),CPPLUPT\n         MVC   IOPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,IOPLECB\n         XC    MYECB,MYECB\n         LA    R0,MYPTPB\n         ST    R0,IOPLIOPB\n         DROP  R15                 IOPL\n         L     R15,CVTPTR          LOAD CVT POINTER\n         USING CVT,R15                                             -EU-\n         TM    CVTPUTL,X'80'       IS PUTLINE LOADED? (VS2)\n         BZ    PUTLOAD             NO - BRANCH TO LOAD\n         L     R15,CVTPUTL         YES - USE CVTPUTL\n         DROP  R15                                                 -EU-\n         B     PUTLODED            BRANCH AROUND LOAD\nPUTLOAD  LA    R0,=CL8'IKJPUTL '\n         LOAD  EPLOC=(0)\n         LR    R15,R0              GET ENTRY ADDRESS\n         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE\nPUTLODED ST    R15,MYPUTLEP        SAVE PUTLINE ENTRY ADDRESS\n         EJECT\n************************************************************\n*        SET UP DAPL FOR IKJDAIR                           *\n************************************************************\n         SPACE 1\n         LA    R15,MYDAPL\n         USING DAPL,R15\n         MVC   DAPLUPT(12),MYIOPL  UPT,ECT,ECB\n         MVC   DAPLPSCB,CPPLPSCB\n         LA    R0,MYDAPB\n         ST    R0,DAPLDAPB\n         DROP  R15                 DAPL\n         SPACE 1\n************************************************************\n*        SET UP PPL FOR PARSE                              *\n************************************************************\n         SPACE 1\n         LA    R15,MYPPL\n         USING PPL,R15\n         MVC   PPLUPT(4),CPPLUPT\n         MVC   PPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,PPLECB\n         XC    MYECB,MYECB\n         L     R0,=A(COMPRPCL)\n         ST    R0,PPLPCL\n         LA    R0,MYANS\n         ST    R0,PPLANS\n         MVC   PPLCBUF(4),CPPLCBUF\n         ST    R9,PPLUWA\n         DROP  R15                 PPL\n         EJECT\n************************************************************\n*        CALL THE PARSE SERVICE ROUTINE                    *\n************************************************************\n         SPACE 1\n         LR    R1,R15              POINT TO PPL\n         L     R15,CVTPTR          CVTPTR\n         USING CVT,R15                                             -EU-\n         TM    CVTPARS,X'80'       IF HI ORDER BIT NOT ON\n         BZ    PARSELNK            THEN DO LINK, NOT CALL\n         L     R15,CVTPARS         CVTPARS\n         DROP  R15                                                 -EU-\n         BASR  R14,R15             CALL IKJPARS\n         B     PARSEEXT            SKIP AROUND LINK\nPARSELNK LINK  EP=IKJPARS,SF=(E,LINKAREA)\nPARSEEXT LTR   R15,R15             PARSE SUCCESSFUL?\n         BZ    PARSEOK             YES, BRANCH\n         LA    R1,MSG01\n         LA    R0,L'MSG01\n         BAS   R14,PUTMSG\n         B     EXIT12\nPARSEOK  L     R3,MYANS\n         USING IKJPARMD,R3\n         MVI   DSNAME+2,C' '\n         MVC   DSNAME+3(43),DSNAME+2\n         MVC   DSNAM2+2(44),DSNAME+2\n         MVC   MEMBER1,DSNAME+2\n         MVC   MEMBER2,MEMBER1\n         EJECT\n************************************************************\n*        PROCESS 'OLD' DSNAME                              *\n************************************************************\n         SPACE 1\n         LA    R4,DSN\n         TM    6(R4),X'80'         DSNAME PRESENT\n         BZ    ERRNODSN            NO, BRANCH\n         LH    R1,4(,R4)           GET LENGTH OF DSNAME\n         STH   R1,DSNAME           DSN LENGTH IN DAIR BUFFER\n         L     R15,0(,R4)          GET ADDRESS OF DSNAME\n         BCT   R1,*+L'*+6          LENGTH MINUS 1 FOR EX\n         MVC   DSNAME+2(0),0(R15)  (EXECUTED)\n         EX    R1,*-6              MOVE DSNAME TO DAIR BUFFER\n         LA    R5,MYDAPB           POINT TO DAIR PARAMETER BLOCK\n         USING DAPB08,R5\n         MVC   DA08CD(84),MODEL08  MOVE 08 MODEL DAPB\n         LA    R0,DSNAME\n         ST    R0,DA08PDSN\n         TM    14(R4),X'80'        MEMBER NAME SPECIFIED?\n         BZ    MEMDS1X             NO, BRANCH\n         LH    R1,12(,R4)          YES, GET LENGTH OF MEMBER NAME\n         L     R15,08(,R4)         GET ADDRESS OF MEMBER NAME\n         BCT   R1,*+L'*+6          LENGTH MINUS 1 FOR EX\n         MVC   DA08MNM(0),0(R15)   (EXECUTED)\n         EX    R1,*-6              MOVE MEMBER NAME TO DAPB\n         MVC   MEMBER1,DA08MNM\nMEMDS1X  TM    22(R4),X'80'        DSNAME/PASSWORD SPECIFIED?\n         BZ    NOPASS              NO, BRANCH\n         LH    R1,20(,R4)          YES, GET LENGTH OF PASSWORD\n         L     R15,16(,R4)         GET ADDRESS OF PASSWORD\n         BCT   R1,*+L'*+6          LENGTH MINUS 1 FOR EX\n         MVC   DA08PSWD(0),0(R15)  (EXECUTED)\n         EX    R1,*-6              MOVE PASSWORD TO DAPB\nNOPASS   OI    DA08DSP1,X'08'      DISP=SHR\n         EJECT\n************************************************************\n*        'OLD' UNIT AND VOLUME                             *\n************************************************************\n         SPACE 1\n         LA    R4,OVOL\n         TM    6(R4),X'80'         VOLUME SPECIFIED\n         BZ    NOOVOL              NO, BRANCH\n         LH    R1,4(,R4)           GET LENGTH OF VOLUME\n         LTR   R1,R1               IS LENGTH ZERO\n         BZ    NOOVOL              YES, BRANCH\n         L     R15,0(,R4)          GET ADDRESS OF VOLUME\n         BCT   R1,*+L'*+6          LENGTH MINUS 1 FOR EX\n         MVC   DA08SER(0),0(R15)   (EXECUTED)\n         EX    R1,*-6              MOVE VOLUME TO DAIR PARAM\n         LA    R4,OUNI\n         TM    6(R4),X'80'         UNIT SPECIFIED\n         BZ    OUNIT2              NO, BRANCH\n         LH    R1,4(,R4)           GET LENGTH OF UNIT\n         LTR   R1,R1               IS LENGTH ZERO\n         BZ    OUNIT2              YES, BRANCH\n         L     R15,0(,R4)          GET ADDRESS OF UNIT\n         BCT   R1,*+L'*+6          LENGTH MINUS 1 FOR EX\n         MVC   DA08UNIT(0),0(R15)  (EXECUTED)\n         EX    R1,*-6              MOVE VOLUME TO DAIR PARAM\n         B     NOOVOL\nOUNIT2   LA    R1,DA08SER          POINT TO VOLSER FOR UCB SEARCH\n         MVC   DA08UNIT(8),=C'SYSALLDA'\n         SPACE 1\n************************************************************\n*        ALLOCATE THE 'OLD' DATA SET                       *\n************************************************************\n         SPACE 1\nNOOVOL   BAS   R14,CALLDAIR\n         LTR   R15,R15\n         BNZ   ERRDAIR\n         MVC   DDUT1(8),DA08DDN    SAVE DDNAME\n         EJECT\n************************************************************\n*        MEMBER MUST BE SPECIFIED IF DSORG IS PDS          *\n************************************************************\n         SPACE 1\n         MVC   DSORG1,DA08DSO\n         TM    DA08DSO,X'02'\n         BZ    OKSEQ1\n         CLI   DA08MNM,C' '\n         BE    ERRPDS\n         MVC   MSGWK(8),DA08MNM\n         LA    R6,VERDCBW\n         USING IHADCB,R6                                           -EU-\n         MVC   IHADCB(VERDCBL),VERDCB                              -EU-\n         MVC   DCBDDNAM,DA08DDN                                    -EU-\n         LA    R1,OPEN\n         XC    0(4,R1),0(R1)\n         MVI   0(R1),X'80'\n         OPEN  ((R6),INPUT),MF=(E,(1))\n         TM    DCBOFLGS,DCBOFOPN                                   -EU-\n         BZ    EXIT12                                              -EU-\n         DROP  R6                                                  -EU-\n         MVC   VERBLDL(4),=X'00010010'\n         MVC   VERBLDL+4(8),MSGWK\n         BLDL  (R6),VERBLDL\n         LR    R4,R15\n         LA    R1,OPEN\n         XC    0(4,R1),0(R1)\n         MVI   0(R1),X'80'\n         CLOSE ((R6)),MF=(E,(1))\n         LTR   R4,R4\n         BNZ   MEMERROR\n         EJECT\n************************************************************\n*        PROCESS 'NEW' DATA SET NAME                       *\n************************************************************\n         SPACE 1\nOKSEQ1   LA    R4,DS2\n         TM    6(R4),X'80'         DSNAME PRESENT\n         BZ    ERRNODSN            NO, BRANCH\n         LH    R1,4(,R4)           GET LENGTH OF DSNAME\n         LTR   R1,R1               IS LENGTH ZERO\n         BZ    EXIT12              YES, BRANCH\n         STH   R1,DSNAM2           DSN LENGTH IN DAIR BUFFER\n         L     R15,0(,R4)          GET ADDRESS OF DSNAME\n         BCT   R1,*+L'*+6          LENGTH MINUS 1 FOR EX\n         MVC   DSNAM2+2(0),0(R15)  (EXECUTED)\n         EX    R1,*-6              MOVE DSNAME TO DAIR BUFFER\n         LA    R5,MYDAPB           POINT TO DAIR PARAMETER BLOCK\n         USING DAPB08,R5\n         MVC   DA08CD(84),MODEL08  MOVE 08 MODEL DAPB\n         LA    R0,DSNAM2\n         ST    R0,DA08PDSN\n         TM    14(R4),X'80'        MEMBER NAME SPECIFIED?\n         BZ    MEMDS2X             NO, BRANCH\n         LH    R1,12(,R4)          YES, GET LENGTH OF MEMBER NAME\n         L     R15,08(,R4)         GET ADDRESS OF MEMBER NAME\n         BCT   R1,*+L'*+6          LENGTH MINUS 1 FOR EX\n         MVC   DA08MNM(0),0(R15)   (EXECUTED)\n         EX    R1,*-6              MOVE MEMBER NAME TO DAPB\n         MVC   MEMBER2,DA08MNM\nMEMDS2X  TM    22(R4),X'80'        DSNAME/PASSWORD SPECIFIED?\n         BZ    NOPAS2              NO, BRANCH\n         LH    R1,20(,R4)          YES, GET LENGTH OF PASSWORD\n         LTR   R1,R1               LENGTH ZERO\n         BZ    NOPAS2              YES, BRANCH\n         L     R15,16(,R4)         GET ADDRESS OF PASSWORD\n         BCT   R1,*+L'*+6          LENGTH MINUS 1 FOR EX\n         MVC   DA08PSWD(0),0(R15)  (EXECUTED)\n         EX    R1,*-6              MOVE PASSWORD TO DAPB\nNOPAS2   OI    DA08DSP1,X'08'      DISP=SHR\n         EJECT\n************************************************************\n*        'NEW' UNIT AND VOLUME                             *\n************************************************************\n         SPACE 1\n         LA    R4,NVOL\n         TM    6(R4),X'80'         VOLUME SPECIFIED\n         BZ    NONVOL              NO, BRANCH\n         LH    R1,4(,R4)           GET LENGTH OF VOLUME\n         LTR   R1,R1               IS LENGTH ZERO\n         BZ    NONVOL              YES, BRANCH\n         L     R15,0(,R4)          GET ADDRESS OF VOLUME\n         BCT   R1,*+L'*+6          LENGTH MINUS 1 FOR EX\n         MVC   DA08SER(0),0(R15)   (EXECUTED)\n         EX    R1,*-6              MOVE VOLUME TO DAIR PARAM\n         LA    R4,NUNI\n         TM    6(R4),X'80'         UNIT SPECIFIED\n         BZ    NUNIT2              NO, BRANCH\n         LH    R1,4(,R4)           GET LENGTH OF UNIT\n         LTR   R1,R1               IS LENGTH ZERO\n         BZ    NUNIT2              YES, BRANCH\n         L     R15,0(,R4)          GET ADDRESS OF UNIT\n         BCT   R1,*+L'*+6          LENGTH MINUS 1 FOR EX\n         MVC   DA08UNIT(0),0(R15)  (EXECUTED)\n         EX    R1,*-6              MOVE VOLUME TO DAIR PARAM\n         B     NONVOL\nNUNIT2   LA    R1,DA08SER          POINT TO VOLSER FOR UCB SEARCH\n         MVC   DA08UNIT(8),=C'SYSALLDA'\n         SPACE 1\n************************************************************\n*        ALLOCATE THE 'NEW' DATA SET                       *\n************************************************************\n         SPACE 1\nNONVOL   BAS   R14,CALLDAIR\n         LTR   R15,R15\n         BNZ   ERRDAIR\n         MVC   DDUT2(8),DA08DDN    SAVE DDNAME\n         EJECT\n************************************************************\n*        MEMBER NAME REQUIRED IF DSORG IS PARTITIONED      *\n************************************************************\n         SPACE 1\n         MVC   DSORG2,DA08DSO\n         TM    DA08DSO,X'02'\n         BZ    OKSEQ2\n         CLI   DA08MNM,C' '\n         BE    ERRPD2\n         MVC   MSGWK(8),DA08MNM\n         LA    R6,VERDCBW\n         USING IHADCB,R6                                           -EU-\n         MVC   IHADCB(VERDCBL),VERDCB                              -EU-\n         MVC   DCBDDNAM,DA08DDN                                    -EU-\n         LA    R1,OPEN\n         XC    0(4,R1),0(R1)\n         MVI   0(R1),X'80'\n         OPEN  ((R6),INPUT),MF=(E,(1))\n         TM    DCBOFLGS,DCBOFOPN                                   -EU-\n         BZ    EXIT12                                              -EU-\n         DROP  R6                                                  -EU-\n         MVC   VERBLDL(4),=X'00010010'\n         MVC   VERBLDL+4(8),MSGWK\n         BLDL  (R6),VERBLDL\n         LR    R4,R15\n         LA    R1,OPEN\n         XC    0(4,R1),0(R1)\n         MVI   0(R1),X'80'\n         CLOSE ((R6)),MF=(E,(1))\n         LTR   R4,R4\n         BNZ   MEMERROR\n         EJECT\n************************************************************\n*        CHECK FOR IDENTICAL DSNAMES AND VOLUMES           *\n************************************************************\n         SPACE 1\nOKSEQ2   CLC   DSNAME+2(44),DSNAM2+2\n         BNE   OKDIFF\n         CLC   MEMBER1,MEMBER2\n         BNE   OKDIFF\n         LA    R4,DDUT1            POINT TO INPUT DDNAME\n         BAS   R14,TIOTSCAN\n         MVC   DOUBLE(6),28(R1)    HOLD VOL FROM UCB\n         LA    R4,DDUT2            POINT TO OUTPUT DDNAME\n         BAS   R14,TIOTSCAN\n         CLC   DOUBLE(6),28(R1)    IS IT SAME VOLUME\n         BNE   OKDIFF              NO, BRANCH\n         LA    R1,MSG03\n         LA    R0,L'MSG03\n         BAS   R14,PUTMSG\n         B     OKDIFF\nTIOTSCAN L     R15,CVTPTR          CVTPTR\n         USING CVT,R15                                             -EU-\n         L     R15,CVTTCBP         TCB WORDS\n         DROP  R15                                                 -EU-\n         L     R15,4(,R15)         CURRENT TCB\n         USING TCB,R15                                             -EU-\n         L     R15,TCBTIO          TCBTIOT\n         DROP  R15                                                 -EU-\n         XR    R1,R1\n         USING TIOT,R15\nTIOTLOOP CLI   TIOENTRY,X'00'      END OF TIOT?\n         BER   R14                 YES - RETURN\n         CLC   TIOEDDNM,0(R4)      DOES DDNAME MATCH?\n         BE    TIOTEXIT            YES - RETURN\n         IC    R1,TIOELNGH         GET LENGTH OF ENTRY\n         ALR   R15,R1              POINT TO NEXT ENTRY\n         B     TIOTLOOP\nTIOTEXIT ICM   R1,B'0111',TIOEFSRT GET UCB ADDRESS                 -EU-\n         BR    R14\n         EJECT\n************************************************************\n*        ALLOCATE THE SYSIN FILE                           *\n************************************************************\n         SPACE 1\nOKDIFF   CLI   IEBKW+1,0           IEBCOMPR REQUESTED\n         BE    NOIN                NO, SKIP SYSIN\n         MVC   DA08CD(84),MODEL08\n         MVC   DA08UNIT,@UNITVIO\n         MVI   DA08PQTY+3,1        1 TRACK\n         MVI   DA08DSP1,DA08NEW\n         OI    DA08CTL,DA08TRKS\n         BAS   R14,CALLDAIR\n         LTR   R15,R15\n         BNZ   ERRDAIR\n         MVC   DDIN,DA08DDN\n         SPACE 1\n************************************************************\n*        WRITE SYSIN CONTROL STATEMENTS                    *\n************************************************************\n         SPACE 1\n         LA    R6,CTLDCBW\n         USING IHADCB,R6                                           -EU-\n         MVC   IHADCB(CTLDCBL),CTLDCB                              -EU-\n         MVC   DCBDDNAM,DDIN                                       -EU-\n         LA    R1,OPEN\n         MVI   0(R1),X'80'\n         OPEN  ((R6),OUTPUT),MF=(E,(1))\n         TM    DCBOFLGS,DCBOFOPN                                   -EU-\n         BZ    EXIT12                                              -EU-\n         DROP  R6                                                  -EU-\n         MVI   CARD,C' '\n         MVC   CARD+1(79),CARD\n         MVC   CARD+1(17),=C'COMPARE TYPORG=PS'\n         PUT   (R6),CARD\nMEMX     MVI   CLOSE,X'80'\n         CLOSE ((R6)),MF=(E,CLOSE)\n         EJECT\n************************************************************\n*        ALLOCATE THE SYSPRINT FILE (DUMMY)                *\n************************************************************\n         SPACE 1\nNOIN     CLI   PRINTKW+1,4         'NOPRINT' SPECIFIED?\n         BNE   PRINTERM            NO\n         MVC   DA08CD(84),MODEL08\n         OI    DA08CTL,DA08DMMY\n         BAS   R14,CALLDAIR\n         LTR   R15,R15\n         BNZ   ERRDAIR\n         MVC   DDPRINT,DA08DDN\n         B     PRINTX\n         DROP  R5                  DAPB08\n         SPACE 1\n************************************************************\n*        ALLOCATE THE SYSPRINT FILE TO THE TERMINAL        *\n************************************************************\n         SPACE 1\nPRINTERM CLI   PRINTKW+1,1         PRINT\n         BH    PRINTSYS\n         USING DAPB1C,R5\nPRINTU   MVC   DA1CCD(MODEL1CL),MODEL1C\n         BAS   R14,CALLDAIR\n         LTR   R15,R15\n         BNZ   ERRDAIR\n         MVC   DDPRINT,DA1CDDN\n         DROP  R5                  DAPB1C\n         B     PRINTX\nPRINTSYS CLI   PRINTKW+1,2         SYSOUT\n         BNE   PRINTOUT\n         USING DAPB30,R5\n         MVC   DA30CD(MODEL30L),MODEL30\n         BAS   R14,CALLDAIR\n         LTR   R15,R15\n         BNZ   ERRDAIR\n         MVC   DDPRINT,DA30DDN\n         MVI   FREEOPT,1           FREE DDPRINT WITH CLASS\n         DROP  R5                  DAPB30\n         B     PRINTX\nPRINTOUT CLI   PRINTKW+1,3         OUTFILE\n         BNE   PRINTX              NO, USE SYSPRINT\n         LA    R4,OUT\n         TM    6(R4),X'80'         OUTFILE PRESENT?\n         BZ    PRINTX              NO, USE SYSPRINT\n         LH    R1,4(,R4)           GET LENGTH\n         L     R15,0(,R4)\n         MVC   DDPRINT,=CL8' '\n         BCT   R1,*+L'*+6\n         MVC   DDPRINT(0),0(R15)\n         EX    R1,*-6\n         MVI   FREEOPT,2           DO NOT FREE DDPRINT\n         EJECT\n************************************************************\n*        BUILD PARM FIELD AND DDNAME POINTERS              *\n************************************************************\n         SPACE 1\nPRINTX   LA    R1,PARMPTR\n         LA    R15,PARMLEN\n         ST    R15,0(,R1)\n         LA    R15,DDNAMES\n         ST    R15,4(,R1)\n         OI    4(R1),X'80'\n         LA    R14,88\n         STH   R14,0(,R15)\n         MVC   LINKEP,=CL8'IEBCOMPR'\n         CLI   IEBKW+1,1           IEBCOMPR REQUESTED\n         BE    OKCOMPR             YES\n         MVI   LINKEP,C'Z'         NO, TRY ZEBCOMPR\n         CLI   IEBKW+1,2           ZEBCOMPR REQUESTED\n         BE    OKCOMPR             YES\n         MVC   LINKEP,=CL8'COMPAREB'    NO, USE DEFAULT YALE COMPARE\n         XC    DDIN,DDIN\n         L     R14,VECTOR\n         L     R14,0(,R14)\n         CLI   PRINTKW+1,0         PRINT, DUMMY, SYSOUT OR FILE?\n         BNE   PRINTZ              YES, BRANCH\n         CLI   4(R14),C'*'         CALLED FOR PDS INTERNAL PUTLINE?\n         BNE   PRINTZ              NO, BRANCH\n         MVC   DDRETURN(4),8(R14)  YES, COPY REENTRY VECTOR ADDRESS\n         MVI   DDRETURN,C'*'       YES, MARK FOR COMPAREB\nPRINTZ   CLI   FULLKW+1,1          FULL SPECIFIED\n         BNE   NOTFULL             NO, BRANCH\n         MVI   PARMLEN+1,4\n         MVC   PARM(4),=C'FULL'\n         CLI   ASMKW+1,1           ASM SPECIFIED\n         BNE   OKCOMPR             NO, BRANCH\n         MVI   PARMLEN+1,8\n         MVC   PARM+4(4),=C',ASM'\n         B     OKCOMPR\nNOTFULL  CLI   ASMKW+1,1           ASM SPECIFIED\n         BNE   OKCOMPR             NO, BRANCH\n         MVI   PARMLEN+1,3\n         MVC   PARM(3),=C'ASM'\nOKCOMPR  LINK  EPLOC=LINKEP,SF=(E,LINKAREA)\n         LTR   R15,R15\n         BZ    EXIT0\n         B     ERRCOPY\n         EJECT\n************************************************************\n*        CALL DYNAMIC ALLOCATION                           *\n************************************************************\n         SPACE 1\nCALLDAIR LR    R8,R14\n         LA    R1,MYDAPL\n         L     R15,CVTPTR          CVTPTR\n         USING CVT,R15                                             -EU-\n         TM    CVTDAIR,X'80'       IF HI ORDER BIT NOT ON\n         BZ    DAIRLINK            THEN DO LINK, NOT CALL\n         L     R15,CVTDAIR         CVTDAIR\n         DROP  R15                                                 -EU-\n         BASR  R14,R15             CALL IKJDAIR\n         B     DAIREXIT            SKIP AROUND LINK\nDAIRLINK LINK  EP=IKJDAIR,SF=(E,LINKAREA)\nDAIREXIT LR    R14,R8\n         BR    R14\n         SPACE 1\n************************************************************\n*        DYNAMIC ALLOCATION FAILURE ROUTINE                *\n************************************************************\n         SPACE 1\nDAIRFAIL ST    R14,MYDFREGS\n         LA    R1,MYDFPARM\n         USING DFDSECTD,R1\n         ST    R15,MYDFRC\n         LA    R15,MYDFRC\n         ST    R15,DFRCP\n         LA    R15,MYDAPL\n         ST    R15,DFDAPLP\n         XR    R15,R15\n         ST    R15,MYJEFF02\n         LA    R15,MYJEFF02\n         ST    R15,DFJEFF02\n         LA    R15,DFDAIR\n         STH   R15,MYDFID\n         LA    R15,MYDFID\n         ST    R15,DFIDP\n         ST    R2,DFCPPLP\n         LINK  EP=IKJEFF18,SF=(E,LINKAREA)\n         L     R15,MYDFRC\n         DROP  R1                  DFDSECTD\n         L     R14,MYDFREGS\n         BR    R14\n         SPACE 1\n************************************************************\n*        ERROR HANDLERS                                    *\n************************************************************\n         SPACE 1\nERRNODSN LA    R1,MSG06\n         LA    R0,L'MSG06\n         BAS   R14,PUTMSG\n         B     EXIT12\nERRDAIR  BAS   R14,DAIRFAIL\n         B     EXIT12\nERRPDS   LA    R15,MSGWK\n         BAS   R14,DSNOUT\nERRPDSC  MVC   0(30,R15),=CL30' IS A PARTITIONED DATA SET'\n         LA    R15,30(,R15)\n         LA    R1,MSGWK\n         LR    R0,R15\n         SR    R0,R1\n         BAS   R14,PUTMSG\n         B     EXIT12\nERRPD2   LA    R15,MSGWK\n         BAS   R14,DSNOU2\n         B     ERRPDSC\nMEMERROR LA    R15,MSGWK+8\n         MVC   0(30,R15),=CL30' IS NOT IN THE DATA SET'\n         LA    R15,30(,R15)\n         LA    R1,MSGWK\n         LR    R0,R15\n         SR    R0,R1\n         BAS   R14,PUTMSG\n         B     EXIT12\nERRCOPY  CVD   R15,DOUBLE\n         LA    R15,MSGWK\n         BAS   R14,DSNOUT\n         MVC   0(21,R15),=CL21' COMPARE RETURN CODE'\n         LA    R15,21(,R15)\n         MVI   0(R15),C' '\n         UNPK  1(3,R15),DOUBLE+6(2)\n         OI    3(R15),X'F0'\n         CLI   1(R15),C'0'\n         BNE   *+L'*+10\n         MVC   1(2,R15),2(R15)\n         MVI   3(R15),C' '\n         CLI   1(R15),C'0'\n         BNE   *+L'*+10\n         MVC   1(2,R15),2(R15)\n         MVI   3(R15),C' '\n         LA    R15,4(,R15)\n         LA    R1,MSGWK\n         LR    R0,R15\n         SR    R0,R1\n         CLI   DDRETURN,C'*'       INVOKED BY PDS INTERNAL CALL?\n         BE    EXIT0               YES, BRANCH\n         BAS   R14,PUTLINE\n         B     EXIT0\nDSNOUT   LH    R1,DSNAME\n         BCT   R1,*+L'*+6\n         MVC   0(0,R15),DSNAME+2\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         BR    R14\nDSNOU2   LH    R1,DSNAM2\n         BCT   R1,*+L'*+6\n         MVC   0(0,R15),DSNAM2+2\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         BR    R14\n         EJECT\n************************************************************\n*        PUTMSG ROUTINE                                    *\n************************************************************\n         SPACE 1\nPUTMSG   STM   R14,R1,MYREGS\n         XC    MYOLD(8),MYOLD\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPM\n         LA    R14,1               NO. OF MESSAGE SEGMENTS\n         ST    R14,MYOLD\n         LA    R14,MYSEG1          POINT TO 1ST SEGMENT\n         ST    R14,MYOLD+4\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         LA    R15,MYSEG1+4\n         CLC   0(3,R1),=C'IKJ'     IS DATA PRECEEDED BY MESSAGE ID?\n         BE    *+L'*+12            YES - BRANCH\n         LA    R14,1(,R14)         ADD 1 TO LENGTH\n         MVI   0(R15),C' '         INSERT LEADING BLANK\n         LA    R15,1(,R15)         BUMP POINTER\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCT   R14,*+L'*+6\n         MVC   0(0,R15),0(R1)      MOVE MESSAGE IN\n         EX    R14,*-6\n         LA    R1,MYIOPL\n         L     R15,MYPUTLEP\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),ENTRY=(15),MF=(E,(1))\n         LM    R14,R1,MYREGS\n         BR    R14\n         EJECT\n************************************************************\n*        PUTLINE ROUTINE                                   *\n************************************************************\n         SPACE 1\nPUTLINE  STM   R14,R1,MYREGS\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPB\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCT   R14,*+L'*+6\n         MVC   MYSEG1+4(0),0(R1)   MOVE TEXT IN\n         EX    R14,*-6\n         LA    R1,MYIOPL\n         L     R15,MYPUTLEP\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYSEG1,DATA),ENTRY=(15),MF=(E,(1))\n         LM    R14,R1,MYREGS\n         BR    R14\n         EJECT\nEXIT12   LA    R15,12\n         B     EXIT\nEXIT0    XR    R15,R15             RETURN CODE ZERO\nEXIT     LR    R2,R15              HOLD RETURN CODE\n         IKJRLSA MYANS\n         DROP  R3\n         USING DAPB18,R5\n         CLI   DDUT1,0\n         BE    FFUT1\n         MVC   DA18CD(MODEL18L),MODEL18\n         MVC   DA18DDN,DDUT1\n         BAS   R14,CALLDAIR\nFFUT1    CLI   DDUT2,0\n         BE    FFUT2\n         MVC   DA18CD(MODEL18L),MODEL18\n         MVC   DA18DDN,DDUT2\n         BAS   R14,CALLDAIR\nFFUT2    CLI   DDIN,0\n         BE    FFIN\n         MVC   DA18CD(MODEL18L),MODEL18\n         MVC   DA18DDN,DDIN\n         BAS   R14,CALLDAIR\nFFIN     CLI   DDPRINT,0\n         BE    FFPRINT\n         CLI   FREEOPT,2           OUTFILE\n         BE    FFPRINT             YES, LEAVE ALLOCATED\n         MVC   DA18CD(MODEL18L),MODEL18\n         MVC   DA18DDN,DDPRINT\n         CLI   FREEOPT,1           SYSOUT?\n         BNE   *+L'*+4             NO\n         MVI   DA18SCLS,C'A'       YES\n         BAS   R14,CALLDAIR\n         DROP  R5                  DAPB18\nFFPRINT  TM    MYPUTLEP,X'80'      WAS PUTLINE LOADED\n         BO    DELPUTLX            NO, BRANCH\n         LA    R0,=CL8'IKJPUTL'    YES, DELETE IT\n         DELETE EPLOC=(0)\nDELPUTLX LTR   R2,R2               IS RC ZERO?\n         BZ    EXITX               YES, BRANCH\n         MVC   MYSTPB(STACKDL),STACKD\n         STACK DELETE=ALL,PARM=MYSTPB,MF=(E,MYIOPL)\n         TCLEARQ\nEXITX    LR    R15,R2              RESTORE RETURN CODE\n         LR    R1,R13              SET UP FREE ADDRESS\n         L     R13,4(,R13)         RESTORE PREVIOUS SAVEAREA\n         ST    R15,16(,R13)        STORE RETURN CODE FOR LM\n         L     R0,@SIZE\n         FREEMAIN R,A=(1),LV=(0)\n         LM    R14,R12,12(R13)     LOAD RETURN ADDRESS AND RC\n         BR    R14                 RETURN\n         EJECT\n************************************************************\n*        CONSTANTS                                         *\n************************************************************\n         SPACE 1\n@UNITVIO DC    CL8'SYSDA'\n         SPACE 1\nMODLPTPM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                         X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE 1\nMODLPTPB PUTLINE OUTPUT=(1,TERM,SINGLE,DATA),                          X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE 1\nMODEL08  DC    AL2(8),XL10'0',CL24' ',XL16'0',CL16' ',XL8'0',CL8' '\nMODEL08L EQU   *-MODEL08\nMODEL18  DC    X'0018',XL10'0',CL18' ',XL2'0',CL8' '\nMODEL18L EQU   *-MODEL18\nMODEL1C  DC    X'001C',XL6'0',CL16' '\nMODEL1CL EQU   *-MODEL1C\nMODEL30  DC    X'0030',XL10'0',CL24' ',XL12'0',CL14' ',XL2'0',CL8' '\nMODEL30L EQU   *-MODEL30\n         SPACE 1\nMSG01    DC    C'PARSE ERROR'\nMSG03    DC    C'YOU ARE COMPARING A DATA SET TO ITSELF'\nMSG06    DC    C'IKJ58509I DATA SET NAME REQUIRED WHEN MEMBER IS SPECIF+\n               IED'\nMSGDAIR  DC    C'UNABLE TO ALLOCATE'\n         EJECT\n         LTORG\n         SPACE 1\n         PRINT NOGEN\nCTLDCB   DCB   DDNAME=DYNAM,DSORG=PS,MACRF=PM,BUFNO=2,                 +\n               RECFM=FB,LRECL=80,BLKSIZE=800\nCTLDCBL  EQU   *-CTLDCB\nVERDCB   DCB   DDNAME=DYNAM,DEVD=DA,MACRF=E\nVERDCBL  EQU   *-VERDCB\n         PRINT GEN\n         SPACE 1\nOBTAIN   CAMLST SEARCH,2,3,4\nOBTAINL  EQU   *-OBTAIN\n         SPACE 1\nSTACKD   STACK DELETE=ALL,MF=L\nSTACKDL  EQU   *-STACKD\n         EJECT\n************************************************************\n*        PARSE PCL                                         *\n************************************************************\n         SPACE 1\n         PRINT NOGEN\nCOMPRPCL IKJPARM\nDSN      IKJPOSIT DSNAME,USID,PROMPT='DATA SET NAME',                  +\n               HELP='FIRST (OR OLD) DATA SET NAME'\nDS2      IKJPOSIT DSNAME,USID,PROMPT='DATA SET NAME',                  +\n               HELP='SECOND (OR NEW) DATA SET NAME'\nOUNIKW   IKJKEYWD\n         IKJNAME 'OUNIT',SUBFLD=OUNISF\nNUNIKW   IKJKEYWD\n         IKJNAME 'NUNIT',SUBFLD=NUNISF\nOVOLKW   IKJKEYWD\n         IKJNAME 'OVOLUME',SUBFLD=OVOLSF\nNVOLKW   IKJKEYWD\n         IKJNAME 'NVOLUME',SUBFLD=NVOLSF\nPRINTKW  IKJKEYWD\n         IKJNAME 'PRINT'\n         IKJNAME 'SYSOUT'\n         IKJNAME 'OUTFILE',SUBFLD=OUTSF\n         IKJNAME 'NOPRINT'\nIEBKW    IKJKEYWD\n         IKJNAME 'IEBCOMPR'\n*        IKJNAME 'ZEBCOMPR'                              - DELETED -EU-\nFULLKW   IKJKEYWD\n         IKJNAME 'FULL'\nASMKW    IKJKEYWD DEFAULT='ASM'\n         IKJNAME 'ASM'\n         IKJNAME 'NOASM'\nOUNISF   IKJSUBF\nOUNI     IKJIDENT 'UNIT',FIRST=ALPHANUM,OTHER=ANY,MAXLNTH=8,           +\n               PROMPT='UNIT NAME FOR OLD DATA SET'\nNUNISF   IKJSUBF\nNUNI     IKJIDENT 'UNIT',FIRST=ALPHANUM,OTHER=ANY,MAXLNTH=8,           +\n               PROMPT='UNIT NAME FOR NEW DATA SET'\nOVOLSF   IKJSUBF\nOVOL     IKJIDENT 'VOLUME',FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=6,    +\n               PROMPT='VOLUME SERIAL FOR OLD DATA SET'\nNVOLSF   IKJSUBF\nNVOL     IKJIDENT 'VOLUME',FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=6,    +\n               PROMPT='VOLUME SERIAL FOR NEW DATA SET'\nOUTSF    IKJSUBF\nOUT      IKJIDENT 'OUTFILE FILENAME',                                  +\n               FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=8,                   +\n               PROMPT='OUTFILE FILENAME'\n         IKJENDP\n         PRINT GEN\n         EJECT\n************************************************************\n*        DSECTS                                            *\n************************************************************\n         SPACE 1\n@DATA    DSECT\n         DS    18F                 REGISTER SAVEAREA\nDOUBLE   DS    D\nLINKAREA DS    2F\nLINKEP   DS    0CL8\nMYPPL    DS    7F\nVECTOR   DS    F\nMYANS    DS    F\nMYECB    DS    F                   USED BY PUTLINE ROUTINE\nMYIOPL   DS    4F                  USED BY PUTLINE ROUTINE\nMYPTPB   DS    3F                  USED BY PUTLINE ROUTINE\nMYPUTLEP DS    F                   USED BY PUTLINE ROUTINE\nMYOLD    DS    2F                  USED BY PUTLINE ROUTINE\nMYSEG1   DS    2H,CL100            USED BY PUTLINE ROUTINE\nMYREGS   DS    4F                  USED BY PUTLINE ROUTINE\nMYDFREGS DS    F\nMYSTPB   DS    0F                  USED BY STACK DELETE (5F)\nMYDAPL   DS    5F\nMYDAPB   DS    21F\nDSNAME   DS    H,CL44\nDSNAM2   DS    H,CL44\nMEMBER1  DS    CL8\nMEMBER2  DS    CL8\nMEMDSPDE DS    5F                  FAKE SELECT PDE\nMYDFPARM DS    5F                  USED BY DAIRFAIL\nMYDFRC   DS    F                   USED BY DAIRFAIL\nMYJEFF02 DS    F                   USED BY DAIRFAIL\nMYDFID   DS    H                   USED BY DAIRFAIL\nFREEOPT  DS    H\nPARMPTR  DS    2F,H\nPARMLEN  DS    H\nPARM     DS    0F,CL4\nDDNAMES  DS    H,CL32\nDDIN     DS    CL8\nDDPRINT  DS    CL8\nDDRETURN DS    CL8\nDDUT1    DS    CL8\nDDUT2    DS    CL8\nDDUT3    DS    CL8\nDDUT4    DS    CL8\nMSGWK    DS    CL72\nOPEN     DS    0F\nCLOSE    DS    F\nCTLDCBW  DS    0D,(CTLDCBL)X\nVERDCBW  DS    0D,(VERDCBL)X\nVERREGS  DS    F\nVERBLDL  DS    2H,CL8,CL4\nDSORG1   DS    C\nDSORG2   DS    C\nOBTVOL   DS    CL6\nOBTAINW  DS    4F\nDSCB     DS    CL140\n         DS    0D\nCARD     DS    CL80\n@DATAL   EQU   *-@DATA\n         SPACE 1\n         PRINT NOGEN                                               -EU-\n         CVT   DSECT=YES,LIST=YES                                  -EU-\nTIOT     DSECT\n         IEFTIOT1 ,                                                -EU-\n         IKJTCB ,                                                  -EU-\n         IKJCPPL\n         IKJIOPL\n         IKJPPL\n         IKJDAPL\n         IKJDAP08\n         IKJDAP18\n         IKJDAP1C\n         IKJDAP30\n         IKJEFFDF DFDSECT=YES\n         DCBD  DSORG=PS                                            -EU-\n         PRINT GEN                                                 -EU-\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COMPARE$": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15G\\x00\\x10\\x00\\x10\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:47:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "SYSPAJA"}, "text": "//COMPARE  JOB (........),'INSTALL  -COMPARE-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=8\n//ASC     EXEC PAJ4AS5,MBR=COMPARE\n//LKC     EXEC PAJILKC\n//SYSIN     DD *\n  ENTRY   COMPARE\n  NAME    COMPARE(R)\n/*\n//ASL     EXEC PAJ4AS5,MBR=COMPAREB\n//LKL     EXEC PAJILKL\n//SYSIN     DD *\n  ENTRY   COMPAREB\n  NAME    COMPAREB(R)\n/*\n//HLP     EXEC PAJHELP,MBR=COMPAREH,DSS='->.SOURCE.FILE4'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COMPARE@": {"ttr": 2054, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x12\\x0f\\x00\\x87\\x12\\x0f\\x113\\x004\\x004\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-04-30T00:00:00", "modifydate": "1987-04-30T11:33:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "SYSPAJA"}, "text": "1   30/04/87\n                                                      COMPARE   1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *    C O M P A R E    TSO COMMAND.    * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  CBT origin : Extracted from CBT tape 87 FEB, file 296.\n  ------------\n\n  Function :  the COMPARE command compares two sequential data-sets\n  ----------  or members. The compare is done by either the YALE\n              COMPARE program (COMPAREB) or by the IBM COMPARE utility\n              program (IEBCOMPR). The 'SYSPRINT' messages are written\n              to wherever FILENAME(SYSPRINT) is allocated - usually\n              to the terminal.\n\n  Syntax :    COMPARE 'OLD-DSNAME' 'NEW-DSNAME'\n  --------    Optional keywords are :\n                 FULL     - include the sequence numbers (YALE pgm).\n                 ASM      - comparing assembler source code (YALE pgm).\n                 IEBCOMPR - the IEBCOMPR utility of IBM is to be used.\n                 OVOL(VOLUME) - volume containing the OLD data-set.\n                            Not needed if cataloged.\n                 NVOL(VOLUME) - volume containing the NEW data-set.\n                            Not needed if cataloged.\n                 OUNIT(UNIT) - unit name for allocating the OLD\n                            data-set. Not needed if cataloged.\n                 NUNIT(UNIT) - unit name for allocating the NEW\n                            data-set. Not needed if cataloged.\n                 SYSOUT   - messages to a SYSOUT data-set.\n                 PRINT    - messages to terminal (default).\n                 NOPRINT  - messages to dummy file.\n                 OUTFILE(FILENAME) - messages to specified DDname.\n              When the OVOL or NVOL keywords are used to indicate\n              two identically named data-sets on different volumes\n              are being used, unexpected results can occur unless\n              both OVOL and NVOL are specified. For example, if\n              OVOL is specified and NVOL is not, the allocation\n              of 'NEWDSNAME' with no volume specified may pick up\n              the already allocated 'OLDDSNAME' instead of the\n              'NEWDSNAME' in the catalog.\n         Required - 'OLD DSNAME' and 'NEW DSNAME'\n         Defaults - the YALE COMPARE program (COMPAREB) is used.\n         Alias    - none.\n\n  Operands :  'DSNAME1' - the name of the SYSUT1 or OLD data-set.\n  ----------      A member name must be specified if it is partitioned.\n              'DSNAME2' - the name of the SYSUT2 or NEW data-set.\n                  A member name must be specified if it is partitioned.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COMPAREB": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x8f\\x00\\x882\\x8f\\t3\\x02T\\x02T\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-23T00:00:00", "modifydate": "1988-11-23T09:33:00", "lines": 596, "newlines": 596, "modlines": 0, "user": "SYSPAJA"}, "text": "YCPP     TITLE 'C O M P A R E B -- YALE COMPARE PLUS PROGRAM.'     -EU-\n***********************************************************************\n*                                                                     *\n* COMPAREB - A MODIFIED VERSION OF THE YALE COMPARE PROGRAM.          *\n*                                                                     *\n* MODIFICATIONS AT AFDSC/PENTAGON:                                    *\n*  07MAY81 - BILL GODFREY, PLANNING RESEARCH CORP.                    *\n*   .  CHECK FOR 'IGNORE' DD WITH DEVTYPE AND BYPASS OPEN IF NOT      *\n*      FOUND, SO OPEN WILL NOT WTO 'DD STATEMENT MISSING'.            *\n*   .  NAME CHANGED TO 'COMPAREB' (SAVING NAME 'COMPARE' FOR A TSO    *\n*      COMMAND WHICH WILL INVOKE THIS PROGRAM).                       *\n*   .  ACCEPT ALTERNATE DDNAMES FROM INVOKER.                         *\n*      DDNAMES ARE IN SAME SLOTS AS IBM UTILITIES.                    *\n*   .  USE R11 AS BASE REGISTER INSTEAD OF R13                        *\n*   .  CONVERT PARM TO CAPS.                                          *\n*   .  CHANGE SYSPRINT LRECL FROM 109 TO 121                          *\n*   .  TEST ALL DCB'S FOR SUCCESSFUL OPEN                             *\n*  09JUN81 - BILL GODFREY                                             *\n*   .  PROGRAM CHANGED TO ALLOW RECORDS LONGER THAN 80 BYTES TO       *\n*      BE COMPARED.  A GOOD WAY TO COMPARE LOAD MODULES IS TO         *\n*      COMPARE HEX DUMPS OF THEM. NOW THIS PROGRAM CAN COMPARE        *\n*      PRINT FILES (IF THEY ARE FIXED LENGTH RECORDS).                *\n*   .  CHANGE ALL BAL-R10 INSTRUCTIONS TO USE BAL-R14 INSTEAD,        *\n*      (AND SAVE R14) SO WE CAN USE R10 FOR ANOTHER PURPOSE.          *\n*   .  PUT THE RECORD LENGTH IN R10.                                  *\n*   .  CHANGE ALL INSTRUCTIONS THAT USE THE RECORD LENGTH (80)        *\n*      OR 2 RECORD LENGTHS (160) TO USE THE VALUE IN REGISTER R10     *\n*      INSTEAD, SO THE PROGRAM CAN COMPARE MORE THAN 80 BYTES.        *\n*   .  CHANGE MLENGTH FIELD TO A HALFWORD AND USE IT TO HOLD          *\n*      A ZERO OR AN EIGHT INSTEAD OF A 79 OR 71.                      *\n*   .  FIX S0C9 IN DCB OPEN EXIT, DIVIDING BY LRECL ZERO WHEN         *\n*      RECFM IS UNBLOCKED.                                            *\n*   .  PROGRAM WILL NO LONGER USE DEFAULT IGNORE DATA (FOR ASSEMBLER  *\n*      SOURCE) UNLESS PARM=ASM IS SPECIFIED.                          *\n*   .  FIX PARM FIELD BUG INTRODUCED 07MAY81, PARM=FULL WAS NEVER     *\n*      RECOGNIZED AFTER THAT CHANGE.                                  *\n*   .  CHECK PARM FIELD FOR 'FULL' OR 'ASM' ANYWHERE IN FIRST 16      *\n*      BYTES.                                                         *\n*  16JUN81 - BILL GODFREY                                             *\n*   .  FIX PARM DD BUG INTRODUCED 09JUN81.                            *\n*      R1 WAS DESTROYED PRIOR TO PARMX. USE R4 INSTEAD OF R1.         *\n*   .  CHANGE R10 TO 256 IF LRECL GREATER THAN 256.                   *\n*  08NOV84 - BRUCE LELAND                                             *\n*   .  CHANGED TO RETURN DATA LINES TO THE PDS PUTLINE ROUTINE        *\n*   .  CHANGED TO GETMAIN AND FREEMAIN BETWEEN 20K AND 200K           *\n*                                                                     *\n*   NOTE: THIS PROGRAM WORKS CORRECTLY ONLY ON FIXED LENGTH RECORDS   *\n*   FROM 80 TO 256 BYTES LONG. ONLY THE FIRST 80 BYTES OF A RECORD    *\n*   ARE LISTED. NO WARNING MESSAGE IS ISSUED FOR RECORDS LONGER THAN  *\n*   256 OR VARIABLE LENGTH.                                           *\n*                                                                     *\n*   THE ORIGINAL DOCUMENTATION FOLLOWS. SOME OF IT IS NOW INACCURATE. *\n*                                                                     *\n*$DOC$*****************************************************************\n         EJECT\n***********************************************************************\n*\n*   THIS COMPARE PROGRAM ORIGINATED AT YALE UNIVERSITY AND WAS OBTAINED\n*     FROM THE CONNECTICUT BANK AND TRUST COMPANY MODS TAPE (FILE 226)\n*\n*   THIS COMPARE PROGRAM USES ONLY COLUMNS ONE THROUGH 72; THUS, ANY\n*     TWO VERSIONS OF A PROGRAM MAY BE EASILY COMPARED EVEN IF ONE\n*     (OR BOTH) OF THE FILES HAS BEEN RESEQUENCED.  IF NEITHER FILE\n*     HAS BEEN RESEQUENCED, A PARM OF \"FULL\" MAY BE CODED TO REQUEST\n*     THAT ALL EIGHTY COLUMNS BE USED IN THE COMPARISON.  A FACILITY\n*     IS ALSO PROVIDED TO IGNORE TRIVIAL CARD IMAGES (SUCH AS \" EJECT \"\n*     OR \" SPACE 3 \" IN AN ASSEMBLER SOURCE PROGRAM).\n*\n*   THIS PROGRAM USES ALL AVAILABLE CORE IN ITS REGION AFTER OPENING\n*     ITS INPUT/OUTPUT FILES (EXCEPT FOR 4K WHICH IS RELEASED).  THE\n*     OBTAINED CORE AREA IS USED AS A COMPARE BUFFER WHICH IS ONLY\n*     DUMPED (WRITTEN TO SYSPRINT) WHEN IDENTICAL RECORDS (BASED ON\n*     THE FIRST 72 BYTES) ARE FOUND IN THE OLD AND NEW DATA SETS.  IF\n*     THE COMPARE BUFFER OVERFLOWS, THE PROGRAM TERMINATES.  THEREFORE,\n*     IF IT IS SUSPECTED THAT THE TWO DATA SETS MAY BE VERY FAR OUT OF\n*     SYNC, A LARGE REGION SHOULD BE USED.  THE NUMBER OF UNMATCHED\n*     RECORDS THAT CAN BE BUFFERED AT ONE TIME CAN BE CALCULATED FROM\n*     THE EXPRESSION:  (REGION SIZE - 8K - BUFFERS) / 160\n*     AS A GENERAL RULE, 30K IS SUFFICIENT FOR ABOUT 100 UNMATCHED\n*     RECORDS AT A TIME, AND 100K IS SUFFICIENT FOR ABOUT 500 UNMATCHED\n*     RECORDS AT A TIME.\n*\n*   CARD IMAGES OF THE TRIVAL DATA IS INPUT FROM THE IGNORE DDNAME;\n*     IF THE DDCARD IS MISSING, A TABLE OF TRIVIAL DATA FOR ASSEMBLER\n*     SOURCE CODE WILL BE ASSUMED (THIS INCLUDES \" EJECT \", \" SPACE   \"\n*     \" SPACE 1 \", \" SPACE 2 \", \" SPACE 3 \" AND BLANK COMMENT CARDS).\n*\n*   THE PROGRAM FORMAT ON THE CBT MODS TAPE WAS DISASSEMBLED SOURCE; IT\n*     WAS RECOMMENTED, RESYMBOLIZED, REDOCUMENTED AND SLIGHTLY MODIFIED\n*     BY  A. BRUCE LELAND (ABL)  OCTOBER, 1978\n*\n*   CHANGE: IF OUTPUT IS DIRECTED TO A TSO TERMINAL, ONLY THE FIRST\n*           78 CHARACTERS OF EACH LINE ARE WRITTEN.  THIS MAY NOT BE\n*           DESIRABLE IF YOU HAVE HARD-COPY TERMINALS.\n*\n*   JCL:\n*   //STEPNAME   EXEC  PGM=COMPAREB,REGION=100K\n*   //SYSPRINT   DD    SYSOUT=A\n*   //OLD        DD    DSN=OLD.SEQ.DSN ....\n*   //NEW        DD    DSN=NEW.SEQ.DSN ....\n*   //IGNORE     DD    *      (OR DUMMY  --  OR OMITTED)\n*     TRIVIAL CARD IMAGES THAT ARE TO BE IGNORED IN THE COMPARISON\n*   /*\n*\n***********************************************************************\n         SPACE 1                                                   -EU-\n* ORIGIN : EXTRACTED FROM CBT TAPE 87 FEB, FILE 296.               -EU-\n* --------                                                         -EU-\n         EJECT\nCOMPAREB START 0                                                   -EU-\n         USING *,R11\n         B     @PROLOG-*(,R15)\n         DC    AL1(11),CL11'COMPAREB'\n         DC    CL16' &SYSDATE &SYSTIME '\n@PROLOG  STM   14,12,12(R13)\n         LR    R11,R15             BASE REGISTER\n         LR    R15,R13\n         LA    R13,SAVE\n         ST    R13,8(,R15)         PUT NEW ADDRESS IN OLD SAVE AREA\n         ST    R15,4(,R13)         PUT OLD ADDRESS IN NEW SAVE AREA\n         SPACE 1\n         L     R2,0(,R1)           POINT TO PARM\n         LH    R3,0(,R2)           GET LENGTH OF PARM\n         LTR   R3,R3\n         BZ    PARMX\n         CH    R3,=H'16'           IS LENGTH EXCESSIVE\n         BNH   *+L'*+4             NO\n         LH    R3,=H'16'           YES, TRUNCATE IT\n         BCTR  R3,0                LENGTH MINUS 1 FOR EX\n         B     *+L'*+6             SKIP MVC\n         MVC   PARM(0),2(R2)       EXECUTED\n         EX    R3,*-6              COPY PARM\n         OC    PARM(16),BLANKS     CAPS\n         LA    R4,PARM\n         LA    R0,13               LOOK AT BYTES 1-13\nPARMFUL  CLC   0(4,R4),=C'FULL'    PARM=FULL (COMPARE SEQUENCE NUMBERS)\n         BNE   NOTFULL             NO\n         MVI   MLENGTH+1,0         YES, CHANGE 8 TO ZERO\n         B     PARM2\nNOTFULL  LA    R4,1(,R4)\n         BCT   R0,PARMFUL\nPARM2    LA    R4,PARM\n         LA    R0,14               LOOK AT BYTES 1-14\nPARMASM  CLC   0(3,R4),=C'ASM'     PARM=ASM (USE DEFAULT IGNORE DATA)\n         BNE   NOTASM              NO\n         LA    R2,ENDDFTIG         YES, POINT TO END OF DEFAULT DATA\n         ST    R2,IGASMS+4         STORE ENDING ADDRESS\n         B     PARMX\nNOTASM   LA    R4,1(,R4)\n         BCT   R0,PARMASM\n         SPACE 1\nPARMX    TM    0(R1),X'80'         ONLY 1 PARAMETER\n         BO    NODD                YES, BYPASS DD ROUTINE\n         L     R2,4(,R1)           POINT TO DDNAME LIST\n         LH    R1,0(,R2)           GET LENGTH OF DDNAME LIST\n         LA    R2,2(,R2)           POINT PAST LENGTH\n         SPACE 1\n         CH    R1,=H'40'           LONG ENOUGH FOR SYSIN\n         BL    NODD                NO, BRANCH\n         CLI   32(R2),0            SYSIN OVERRIDE\n         BE    *+L'*+6             NO, SKIP MVC\n         MVC   IGNORE+(DCBDDNAM-IHADCB)(8),32(R2)\n         SPACE 1\n         CH    R1,=H'48'           LONG ENOUGH FOR SYSPRINT\n         BL    NODD                NO, BRANCH\n         CLI   40(R2),0            SYSPRINT OVERRIDE\n         BE    *+L'*+6             NO, SKIP MVC\n         MVC   SYSPRINT+(DCBDDNAM-IHADCB)(8),40(R2)\n         SPACE 1\n         CH    R1,=H'56'           LONG ENOUGH FOR ECHO\n         BL    NODD                NO, BRANCH\n         CLI   48(R2),0            REENTRY OVERRIDE\n         BE    *+L'*+6             NO, SKIP MVC\n         MVC   PVECTOR(4),48(R2)   YES, SAVE THE REENTRY VECTOR\n         SPACE 1\n         CH    R1,=H'64'           LONG ENOUGH FOR SYSUT1\n         BL    NODD                NO, BRANCH\n         CLI   56(R2),0            SYSUT1 OVERRIDE\n         BE    *+L'*+6             NO, SKIP MVC\n         MVC   OLD+(DCBDDNAM-IHADCB)(8),56(R2)\n         SPACE\n         CH    R1,=H'72'           LONG ENOUGH FOR SYSUT2\n         BL    NODD                NO, BRANCH\n         CLI   64(R2),0            SYSUT2 OVERRIDE\n         BE    *+L'*+6             NO, SKIP MVC\n         MVC   NEW+(DCBDDNAM-IHADCB)(8),64(R2)\n         SPACE 1\nNODD     OPEN  (NEW,,OLD,,SYSPRINT,OUTPUT)\n         USING IHADCB,R2                                           -EU-\n         LA    R2,SYSPRINT\n         TM    DCBOFLGS,DCBOFOPN   DID SYSPRINT OPEN\n         BZ    EXIT12              NO, BRANCH\n         LA    R2,OLD\n         TM    DCBOFLGS,DCBOFOPN   DID OLD DCB OPEN\n         BZ    EXIT12              NO, BRANCH\n         LA    R2,NEW\n         TM    DCBOFLGS,DCBOFOPN   DID NEW DCB OPEN\n         BZ    EXIT12              NO, BRANCH\n         LA    R2,IGNORE+(DCBDDNAM-IHADCB)\n         DEVTYPE (R2),DEVAREA\n         LTR   R15,R15             IS IGNORE DD PRESENT\n         BNZ   IGNAB               NO, SKIP OPEN\n         OPEN  (IGNORE)\n         SPACE 1\nIGNAB    LA    R2,OLD\n         LH    R10,DCBLRECL        GET LRECL\n         TM    DCBRECFM,DCBRECBR   IS IT BLOCKED\n         BO    *+L'*+4             YES, BRANCH\n         LH    R10,DCBBLKSI        NO, BLKSIZE IS RECORD LENGTH\n         SPACE 1\n         LA    R2,NEW\n         LH    R1,DCBLRECL         GET LRECL\n         TM    DCBRECFM,DCBRECBR   IS IT BLOCKED\n         BO    *+L'*+4             YES, BRANCH\n         LH    R1,DCBBLKSI         NO, BLKSIZE IS RECORD LENGTH\n         DROP  R2                                                  -EU-\n         SPACE 1\n         CR    R10,R1              IS OLD LONGER THAN NEW\n         BNH   *+L'*+2             NO, BRANCH\n         LR    R10,R1              YES, USE THE SHORTER OF THE TWO\n         LA    R1,256              MAX RECORD SIZE\n         CR    R10,R1              IS LRECL TOO LONG\n         BNH   *+L'*+2             NO, BRANCH\n         LR    R10,R1              YES, USE 256\n         SPACE 1\n         GETMAIN VU,LA=MIN,A=STARTADD   GET ALL AVAILABLE CORE\n         LM    R0,R2,FOURK         LOAD 4K, START, SIZE\n         ST    R2,SIZE             UPDATE REGION SIZE\n         AR    R1,R2               LAST USEABLE BYTE\n         ST    R1,HIGHCORE         SAVE FOR LATER\n         SPACE 1\n         L     R2,STARTADD\n         ST    R2,FIRSTIG\n         TM    IGNORE+(DCBOFLGS-IHADCB),DCBOFOPN  IGNORE OPEN?\n         BO    GETIG               YES, BRANCH                      ABL\n         MVC   FIRSTIG(8),IGASMS   FIRST AND LAST IGNORES           ABL\n         B     NOIG\n         SPACE 1\nGETIG    GET   IGNORE,(2)\n         LA    R2,80(,R2)\n         B     GETIG\n         SPACE 1\nENDIG    CLOSE (IGNORE)\n         ST    R2,LASTIG                                            ABL\nNOIG     ST    R2,LOWOLD                                            ABL\n         ST    R2,HIGHOLD\n         ST    R2,CURROLD\n         AR    R2,R10\n         ST    R2,LOWNEW\n         ST    R2,HIGHNEW\n         ST    R2,CURRNEW\n         LA    R8,OLD\n         LA    R9,NEW\n         SPACE 1\nSWAP     XR    R9,R8\n         XR    R8,R9\n         XR    R9,R8\n         L     R3,CURR(,R9)\n         C     R3,HIGH(,R9)\n         BL    NOINPUT\n         TM    DCBOFLGS-IHADCB(R9),DCBOFOPN  CURRENT DCB OPEN?\n         BZ    SWAP                NO, BRANCH (AND SWAP)\n         LA    R1,0(,R9)\n         GET   (1)\n         SPACE 1\n         LA    R0,0(R10,R3)\n         C     R0,HIGHCORE         FIT IN CORE?\n         BH    NOTCORE             NO, BRANCH\n         LR    R15,R10             GET LENGTH\n         BCTR  R15,0               LENGTH MINUS 1 FOR EX\n         B     *+L'*+6             SKIP MVC\n         MVC   0(0,R3),0(R1)       EXECUTED\n         EX    R15,*-6             MOVE THE RECORD\n         LR    R0,R10              GET LENGTH\n         AR    R0,R0               DOUBLE IT\n         AR    R0,R3               ADD R3\n         ST    R0,HIGH(,R9)\n         SPACE 1\n*        SEE IF THIS RECORD (R3) IS ANYWHERE IN THE OTHER BUFFER\n         SPACE 1\nNOINPUT  L     R2,LOW(,R8)\n         LR    R1,R10              GET LENGTH TO COMPARE\n         BCTR  R1,0                MINUS 1 FOR EX\n         SH    R1,MLENGTH          MINUS 8 FOR SEQUENCE NUMBERS\nNEXT8    C     R2,CURR(,R8)\n         BNL   NO8\n         B     *+L'*+6             SKIP CLC\n         CLC   0(1,R3),0(R2)\n         EX    R1,*-6              EXECUTE CLC\n         BE    FOUND8\n         AR    R2,R10\n         AR    R2,R10\n         B     NEXT8\nNO8      AR    R3,R10              NOT IN THE BUFFER\n         AR    R3,R10\n         ST    R3,CURR(,R9)        UPDATE THE CURRENT POINTER\n         B     SWAP\n         SPACE 1\n*        DOES NOT FIT IN THE ALLOCATED CORE\n         SPACE 1\nNOTCORE  BAS   R14,NOTEQUAL        OUTPUT NOT EQUAL MESSAGE\n         CLOSE (NEW,,OLD)\n         MVI   RETCODE+1,8         RETURN CODE 8\n         MVC   BUFFER(35),CORE     CORE OVERFLOW MESSAGE\n         MVC   BUFFER+35(86),BUFFER+34  CLEAR THE REMAINDER\n         BAS   R14,PUTLINE         INVOKE THE PUTLINE ROUTINE\n         MVI   BUFFER,C' '\n         B     CORETERM\n         SPACE 1\nPUTLINE  ST    R14,R14SAVE\n         CLI   PVECTOR,C'*'        PDS REENTRY?\n         BE    PUTL10              YES, BRANCH\n         PUT   SYSPRINT,BUFFER     NO, OUTPUT THE LINE\n         L     R14,R14SAVE\n         BR    R14\nPUTL10   LA    R1,BUFFER           ADDRESS OF OUTPUT DATA\n         L     R15,PVECTOR         REENTRY VECTOR ADDRESS\n         BASR  R14,R15             RETURN TO PDS\n         LTR   R15,R15             SUCCESSFUL OUTPUT?\n         BNZ   EXIT12              NO - ATTENTION, BRANCH\n         L     R14,R14SAVE\n         BR    R14\n         SPACE 1\n*        RECORD WAS FOUND -- SEE IF IT IS TO BE IGNORED\n         SPACE 1\nFOUND8   CLC   CURR(4,R9),LOW(R9)  RECORDS IN ACTIVE BUFFER?\n         BNE   CHKIG               YES, CHECK IGNORES\n         ST    R2,CURR(,R8)\n         B     IGEQUAL\nCHKIG    L     R15,FIRSTIG         FIRST IGNORE\n         LA    R0,79\n         CR    R1,R0               IS LENGTH GREATER THAN 80\n         BNH   *+L'*+2             NO\n         LR    R1,R0               YES, REDUCE TO 80\nLOOPIG   C     R15,LASTIG          LAST IGNORE?\n         BNL   NOTIG               YES, BRANCH\n         EX    R1,CLCIG            AN IGNORE RECORD?\n         BE    NO8                 YES, BRANCH\n         LA    R15,80(,R15)\n         B     LOOPIG              CHECK ALL IGNORES\nCLCIG    CLC   0(1,R3),0(R15)\nNOTIG    ST    R2,CURR(,R8)        NOT AN IGNORE RECORD\n         BAS   R14,NOTEQUAL        OUTPUT \"NOT EQUAL\"\nIGEQUAL  BAS   R14,INBUFF          ADD TO COMPARE BUFFER\n         XR    R9,R8\n         XR    R8,R9\n         XR    R9,R8\n         BAS   R14,INBUFF          ADD TO OTHER BUFFER\n         B     SWAP\n         SPACE 1\n*        END OF FILE (OLD OR NEW)\n         SPACE 1\nEOLDNEW  CLOSE ((9))               CLOSE THE CURRENT FILE\n         XR    R9,R8\n         XR    R8,R9\n         XR    R9,R8\n         TM    DCBOFLGS-IHADCB(R9),DCBOFOPN  OTHER FILE STILL OPEN?\n         BO    SWAP                YES, BRANCH\n         CLC   LOWOLD(4),HIGHOLD   BUFFER EMPTY?\n         BNE   *+L'*+10            NO, BRANCH\n         CLC   LOWNEW(4),HIGHNEW   OTHER BUFFER EMPTY TOO?\n         BE    TRIPLE              YES, QUIT\n         BAS   R14,NOTEQUAL        FLUSH THE CURRENT BUFFERS\n         SPACE 1\n*        TERMINATE -- LIST NUMBER OF UNEQUAL COMPARES\n         SPACE 1\nTRIPLE   MVI   BUFFER,C'-'\nCORETERM MVC   BUFFER+1(6),EDCOUNT EDIT MASK\n         MVC   BUFFER+7(35),BLOCKS UNEQUAL BLOCKS MESSAGE\n         MVC   BUFFER+42(79),BUFFER+41  BLANK REMAINDER\n         LH    R1,COUNT\n         CVD   R1,DOUBLE\n         ED    BUFFER+1(6),DOUBLE+5\n         BAS   R14,PUTLINE         INVOKE THE PUTLINE ROUTINE\n         B     EXIT\nEXIT12   MVI   RETCODE+1,12\nEXIT     LA    R2,NEW\n         L     R0,SIZE             SIZE OF DYNAMIC AREA\n         L     R1,STARTADD\n         FREEMAIN R,LV=(0),A=(1)   FREE THE DYNAMIC AREA\n         LA    R2,NEW\n         USING IHADCB,R2                                           -EU-\n         TM    DCBOFLGS,DCBOFOPN   IS DCB OPENED?\n         BZ    EXITNEWC\n         CLOSE (NEW)\nEXITNEWC LA    R2,OLD\n         TM    DCBOFLGS,DCBOFOPN   IS DCB OPENED?\n         BZ    EXITOLDC\n         CLOSE (OLD)\nEXITOLDC LA    R2,SYSPRINT\n         TM    DCBOFLGS,DCBOFOPN   IS DCB OPENED?\n         BZ    EXITPRTC\n         CLOSE (SYSPRINT)\n         DROP  R2                                                  -EU-\nEXITPRTC LH   R15,RETCODE\n         L    R13,4(,R13)                                           ABL\n         RETURN (14,12),RC=(15)                                     ABL\n         SPACE 1\n*        RE-INITIALIZE THE ACTIVE BUFFER -- SLIDE UNUSED RECORDS DOWN\n         SPACE 1\nINBUFF   L     R1,LOW(,R9)\n         L     R2,CURR(,R9)\n         ST    R1,CURR(,R9)\n         LR    R15,R10             GET LENGTH FOR EX\n         BCTR  R15,0               LENGTH MINUS 1 FOR EX\nNXTREC   AR    R2,R10\n         AR    R2,R10\n         C     R2,HIGH(,R9)        FINISHED REINITIALIZING?\n         BNL   REINIT              YES, BRANCH\n         EX    R15,SLIDEMVC        MOVE THE RECORD\n         AR    R1,R10\n         AR    R1,R10\n         B     NXTREC\nSLIDEMVC MVC   0(0,R1),0(R2)       EXECUTED\nREINIT   ST    R1,HIGH(,R9)        RESET MAXIMUM POINTER\n         BR    R14\n         SPACE 1\n*        FLUSH OUT THE NON-EQUAL RECORDS\n         SPACE 1\nNOTEQUAL ST    R14,NOTEQR14\n         MVI   RETCODE+1,4         RETURN CODE 4\n         LH    R1,COUNT\n         LA    R1,1(,R1)\n         STH   R1,COUNT\n         MVI   BUFFER,C'-'\n         LA    R3,OLD\n         TM    SYSPRINT+(DCBDEVT-IHADCB),DCBDVTRM TERM=TS           ABL\n         BNO   MOVES               NO, BRANCH                       ABL\n         MVC   BUFFER+1(120),BLANKS     BLANK PAST THE SCREEN WIDTH ABL\n         BAS   R14,PUTLINE         INVOKE THE PUTLINE ROUTINE\nMOVES    MVI   BUFFER+9,C'-'\n         MVC   BUFFER+10(91),BUFFER+9\n         MVC   BUFFER+9(3),OLDNEW(R3)\n         MVC   BUFFER+98(3),OLDNEW(R3)\n         MVI   BUFFER+7,C'-'\n         MVI   BUFFER+102,C'-'\n         ZAP   NUMBER(3),=P'0'\n         L     R5,LOW(,R3)\nFLUSHED  C     R5,CURR(,R3)        IS THIS BUFFER FLUSHED?\n         BNL   GETNEW              YES, BRANCH\n         MVI   BUFFER+7,C'-'\n         MVI   BUFFER+102,C'-'\n         MVC   BUFFER+15(80),0(R5) ALWAY SHOW 80 BYTES\n         AP    NUMBER(3),=P'1'\n         MVC   DOUBLE(6),EDMKPAT\n         EDMK  DOUBLE(6),NUMBER    POINT R1 TO FIRST NONBLANK\n         LA    R14,DOUBLE+5        POINT TO LAST DIGIT\n         SR    R14,R1              GET LENGTH MINUS 1\n         STC   R14,MOVEA+1         ALTER MVC LENGTH CODE\nMOVEA    MVC   BUFFER+103(1),0(R1) MOVE NUMBER\n         LA    R15,BUFFER+104(R14)\n         MVI   0(R15),C'-'\n         LA    R14,1(,R14)\n         STC   R14,MOVEB+1\n         LA    R1,BUFFER+6\n         SR    R1,R14\nMOVEB    MVC   0(1,R1),BUFFER+102\n         TM    SYSPRINT+(DCBDEVT-IHADCB),DCBDVTRM TSO \"DA(*)\"?      ABL\n         BNO   *+L'*+6             NO, BRANCH                       ABL\n         MVC   BUFFER+78(43),BLANKS     BLANK PAST SCREEN WIDTH     ABL\n         BAS   R14,PUTLINE         INVOKE THE PUTLINE ROUTINE\n         MVI   BUFFER,C' '\n         AR    R5,R10\n         AR    R5,R10\n         B     FLUSHED\nGETNEW   LA    R1,NEW\n         CR    R3,R1               NEW DONE?\n         BE    NOTEQRET            YES, RETURN\n         LR    R3,R1               NOW SETUP THE NEW BUFFER\n         MVC   BUFFER+1(7),BLANKS\n         MVI   BUFFER+9,C'-'\n         MVC   BUFFER+10(91),BUFFER+9\n         MVC   BUFFER+102(19),BLANKS\n         TM    SYSPRINT+(DCBDEVT-IHADCB),DCBDVTRM TSO \"DA(*)\"?      ABL\n         BNO   *+L'*+6             NO, BRANCH                       ABL\n         MVC   BUFFER+78(43),BLANKS     BLANK PAST SCREEN WIDTH     ABL\n         BAS   R14,PUTLINE         INVOKE THE PUTLINE ROUTINE\n         MVI   BUFFER,C' '\n         B     MOVES\nNOTEQRET L     R14,NOTEQR14\n         BR    R14\n         SPACE 2\n*        DCB EXIT ROUTINE (USED BY ALL FILES)\n         SPACE 1\n         USING IHADCB,R1                                           -EU-\nDCBEXIT  LH    R3,DCBBLKSI       BLKSIZE\n         LR    R4,R3               BLKSIZE        FIX-0C9\n         TM    DCBRECFM,DCBRECBR   IS IT BLOCKED  FIX-0C9\n         BZ    *+L'*+4             NO             FIX-0C9\n         LH    R4,DCBLRECL         BLOCKED, GET LRECL\n         XR    R2,R2\n         DR    R2,R4               BLOCKSIZE/LRECL\n         MR    R2,R4               BLOCKING*LRECL\n         CR    R3,R4               BLOCKSIZE > LRECL?\n         BH    *+L'*+6             YES, BRANCH\n         LR    R3,R4               MAKE BLKSIZE=LRECL\n         NI    DCBRECFM,255-DCBRECBR    TURN OFF BLOCKING\n         STH   R3,DCBBLKSI         NEW BLOCKSIZE\n         STH   R3,DCBBUFL          BUFLEN PARAMETER\n         CLI   DCBBUFNO,0          BUFNO=0?\n         BNER  R14                 NO, QUIT\n         MVI   DCBBUFNO,3          DEFAULT TO 3 BUFFERS\n         BR    R14                 EXIT\n         DROP  R1                                                  -EU-\n         EJECT\nSAVE     DC    18F'0'\n         SPACE 1\n         PRINT NOGEN                                               -EU-\nSYSPRINT DCB   LRECL=121,RECFM=FBA,EXLST=EXITDCB,DDNAME=SYSPRINT,      X\n               MACRF=(PM),DSORG=PS\nIGNORE   DCB   LRECL=80,RECFM=FB,EXLST=EXITDCB,DDNAME=IGNORE,          X\n               EODAD=ENDIG,MACRF=(GM),DSORG=PS\n         SPACE 1\nFIRSTIG  DC    F'0'                POINTER TO FIRST IGNORE RECORD\nLASTIG   DC    F'0'                POINTER TO LAST IGNORE RECORD\n         SPACE 1\nOLD      DCB   EXLST=EXITDCB,DDNAME=OLD,                               X\n               EODAD=EOLDNEW,MACRF=(GL),DSORG=PS,OPTCD=C\n         SPACE 1\nLOWOLD   DC    F'0'                FIRST OLD RECORD\nHIGHOLD  DC    F'0'                HIGHEST USED OLD RECORD\nCURROLD  DC    F'0'                CURRENT OLD RECORD\nOLDLIT   DC    C'OLD'\n         SPACE 1\nNEW      DCB   EXLST=EXITDCB,DDNAME=NEW,                               X\n               EODAD=EOLDNEW,MACRF=(GL),DSORG=PS,OPTCD=C\n         SPACE 1\nLOWNEW   DC    F'0'                FIRST NEW RECORD\nHIGHNEW  DC    F'0'                HIGHEST USED NEW RECORD\nCURRNEW  DC    F'0'                CURRENT NEW RECORD\nNEWLIT   DC    C'NEW'\n         SPACE 1\n         PRINT GEN                                                 -EU-\nLOW      EQU   LOWNEW-NEW          DISPLACEMENT TO LOWOLD AND LOWNEW\nHIGH     EQU   HIGHNEW-NEW         DISPLACEMENT TO HIGHOLD AND HIGHNEW\nCURR     EQU   CURRNEW-NEW         DISPLACEMENT TO CURROLD AND CURRNEW\nOLDNEW   EQU   NEWLIT-NEW          DISPLACEMENT TO OLD OR NEW LITERAL\n         EJECT\nDOUBLE   DC    D'0'\nEXITDCB  DC    X'85',AL3(DCBEXIT)\nRETCODE  DC    H'0'\nCOUNT    DC    H'0'\nNUMBER   DC    XL3'0'\nMLENGTH  DC    H'8'                ADJUSTMENT TO COMPARE LENGTH\nMIN      DC    F'20480'            MINIMUM CORE TO GETMAIN\nMAX      DC    F'204800'           MAXIMUM CORE TO GETMAIN\nFOURK    DC    F'4096'             AMOUNT OF CORE TO RELEASE\nSTARTADD DC    F'0'                BUFFER START ADDRESS\nSIZE     DC    F'0'                SIZE OF THE BUFFER AREA\nHIGHCORE DC    F'0'                MAXIMUM BUFFER ADDRESS\nBUFFER   DC    X'004040404040406040000000606060'\n         DC    80X'00',X'606060000000',X'4060404040404040'\n         DC    12C' '\nBLANKS   DC    CL121' '\nEDCOUNT  DC    X'402020202120'\nEDMKPAT  DC    X'402020202020'\nCORE     DC    C'-CORE OVERFLOW - COMPARE ABANDONED '\nBLOCKS   DC    C' BLOCKS OF COMPARE ERRORS DETECTED '\nDEVAREA  DC    2F'0'\nPARM     DC    CL16' '\nNOTEQR14 DC    F'0'\nPVECTOR  DC    F'0'\nR14SAVE  DC    F'0'\nIGASMS   DC    A(DFTIG,DFTIG)      DEFAULT IGNORE TABLE             ABL\nDFTIG    DC    CL80'         EJECT   '                              ABL\n         DC    CL80'         SPACE   '                              ABL\n         DC    CL80'         SPACE 1 '                              ABL\n         DC    CL80'         SPACE 2 '                              ABL\n         DC    CL80'         SPACE 3 '                              ABL\n         DC    CL80'*                '                              ABL\nENDDFTIG EQU   *                                                    ABL\n         EJECT\n         LTORG\n         SPACE 1\n         PRINT NOGEN                                               -EU-\n         DCBD  DSORG=PS                                            -EU-\n         PRINT GEN                                                 -EU-\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPAREH": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x12\\x0f\\x00\\x87\\x12\\x0f\\x111\\x00*\\x00*\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-04-30T00:00:00", "modifydate": "1987-04-30T11:31:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=COMPARE\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION : THE COMPARE COMMAND COMPARES TWO SEQUENTIAL DATA-SETS\n              OR MEMBERS. THE COMPARE IS DONE BY EITHER THE YALE\n              COMPARE PROGRAM (COMPAREB) OR BY THE IBM COMPARE UTILITY\n              PROGRAM (IEBCOMPR). THE 'SYSPRINT' MESSAGES ARE WRITTEN\n              TO WHEREVER FILENAME(SYSPRINT) IS ALLOCATED - USUALLY\n              TO THE TERMINAL.\n)X SYNTAX :   COMPARE 'OLD-DSNAME' 'NEW-DSNAME'\n              OPTIONAL KEYWORDS ARE :\n                 FULL     - INCLUDE THE SEQUENCE NUMBERS (YALE PGM).\n                 ASM      - COMPARING ASSEMBLER SOURCE CODE (YALE PGM).\n                 IEBCOMPR - THE IEBCOMPR UTILITY IS TO BE USED.\n                 OVOL(VOLUME) - VOLUME CONTAINING THE OLD DATA-SET.\n                            NOT NEEDED IF CATALOGED.\n                 NVOL(VOLUME) - VOLUME CONTAINING THE NEW DATA-SET.\n                            NOT NEEDED IF CATALOGED.\n                 OUNIT(UNIT) - UNIT NAME FOR ALLOCATING THE OLD\n                            DATA-SET. NOT NEEDED IF CATALOGED.\n                 NUNIT(UNIT) - UNIT NAME FOR ALLOCATING THE NEW\n                            DATA-SET. NOT NEEDED IF CATALOGED.\n                 SYSOUT   - MESSAGES TO A SYSOUT DATA-SET.\n                 PRINT    - MESSAGES TO TERMINAL (DEFAULT).\n                 NOPRINT  - MESSAGES TO DUMMY FILE.\n                 OUTFILE(FILENAME) - MESSAGES TO SPECIFIED DDNAME.\n              WHEN THE OVOL OR NVOL KEYWORDS ARE USED TO INDICATE\n              TWO IDENTICALLY NAMED DATASETS ON DIFFERENT VOLUMES\n              ARE BEING USED, UNEXPECTED RESULTS CAN OCCUR UNLESS\n              BOTH OVOL AND NVOL ARE SPECIFIED.  FOR EXAMPLE, IF\n              OVOL IS SPECIFIED AND NVOL IS NOT, THE ALLOCATION\n              OF 'NEWDSNAME' WITH NO VOLUME SPECIFIED MAY PICK UP\n              THE ALREADY ALLOCATED 'OLDDSNAME' INSTEAD OF THE\n              'NEWDSNAME' IN THE CATALOG.\n         REQUIRED - 'OLD DSNAME'   'NEW DSNAME'\n         DEFAULTS - THE YALE COMPARE PROGRAM (COMPAREB) IS USED.\n         ALIAS    - NONE\n)O OPERANDS : 'DSNAME1' - THE NAME OF THE SYSUT1 OR OLD DATA SET.\n                  A MEMBER NAME MUST BE SPECIFIED IF IT IS PARTITIONED.\n              'DSNAME2' - THE NAME OF THE SYSUT2 OR NEW DATA SET.\n                  A MEMBER NAME MUST BE SPECIFIED IF IT IS PARTITIONED.\n))IEBCOMPR    : THE IBM UTILITY PROGRAM 'IEBCOMPR' IS TO BE USED.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CURESTA": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07O\\x00\\x95\\x07O\\x16\\x03\\x02\\xbf\\x02\\xbf\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-15T00:00:00", "modifydate": "1995-03-15T16:03:00", "lines": 703, "newlines": 703, "modlines": 0, "user": "SYSPAJA"}, "text": "CRSD     TITLE '--- C R S D - CURRENT REGION STATISTICS DISPLAY ---'\nCURESTA  START 0\n        PRINT  OFF\n         GBLC  &PRS,&PRF\n         AIF   ('&SYSPARM' EQ 'FULL').SF\n         AIF   ('&SYSPARM' EQ 'SHORT').SS\n&PRS     SETC  'NOGEN'\n&PRF     SETC  'NOGEN'\n         AGO   .ST\n.SS      ANOP\n&PRS     SETC  'GEN'\n&PRF     SETC  'NOGEN'\n         AGO   .ST\n.SF      ANOP\n&PRS     SETC  'GEN'\n&PRF     SETC  'GEN'\n.ST     PRINT  ON\n         SPACE 1\n* PURPOSE :    DISPLAY (TSO COMMAND) OR LOG (OTHER WAYS OF EXECUTION)\n* ---------    THE CURRENT REGION STATISTICS.\n*              NAME :       CURESTA\n*              ATTRIBUTES : RENT\n*\n* SYNTAX WHEN USED AS TSO COMMAND (OR SUBCOMMAND) :\n* -------------------------------------------------\n*                  COMMAND   OPERAND(S)\n*                  --------  -----------------------------------------\n*                  CURESTA   ID(...) / I(...)    NOLOG / NL\n*                                                LOG / L\n*              OPTIONAL (KEYWORDS) :\n*              ID(...) = IDENTIFY THIS DISPLAY WITH THE GIVEN NUMBER.\n*                    I.E. : ID(11)\n*                    ALIAS : I(...)\n*                    MAXIMUM RANGE FOR ID NUMBER : 0-255.\n*              NOLOG = NORMAL USE OF \"PUTLINE\" TO DISPLAY THE MESSAGES\n*                    (THIS IS THE DEFAULT).\n*                    ALIAS : NL\n*              LOG = FORCE MESSAGES DISPLAY TO GO ON THE JOB LOG (WITH\n*                    COPY IN THE MESSAGES LOG) WHEN IN TSO BACKGROUND.\n*                    WHEN RUNNING IN TSO FOREGROUND SESSION IT HAS NO\n*                    EFFECT (THEY ARE ALWAYS SENDED TO THE TERMINAL).\n*                    ALIAS : L\n*\n* OTHER WAYS OF EXECUTION :\n* -------------------------\n*              1. AS PROGRAM : //...  EXEC PGM=CURESTA\n*                         OR : //...  EXEC PGM=CURESTA,\n*                              //          PARM=INNN OR IDNNN\n*                      WHERE \"NNN\" IS THE ID NUMBER.\n*              2. AS ROUTINE : XR   R1,R1\n*                              CALL CURESTA\n*                              ...\n*                         OR : XR   R1,R1\n*                              CALL CURESTA\n*                              B    *+L'*+2\n*                              DC   AL1(255),AL1(NNN)\n*                              ...\n*                              WHERE \"NNN\" IS THE ID NUMBER.\n*          NOTES : THE BRANCH AFTER THE CALL MAY BE A BRANCH REGISTER\n*                  OPERATION (BR) ALSO.\n*                  THE MESSAGES ARE ALWAYS OUTPUTED ON LOG (UNLESS\n*                  WHEN EXECUTED IN TSO FOREGROUND SESSION).\n         EJECT\n* DEBUGING AIDS : A DEBUG MODE HAS BEEN INCLUDED TO ALLOW AN EASIER\n* --------------- WAY OF SEARCH AND TEST FACILITIES (I.E., IF YOU\n*                 PLAN TO DO SOME PRIVATE MODIFICATIONS).\n*\n*        1. WHEN USED AS TSO COMMAND (OR SUBCOMMAND) :\n*                  COMMAND   OPERAND(S)\n*                  --------  -----------------------------------------\n*                  CURESTA   NODEBUG / ND\n*                            DEBUG / D\n*           OPTIONAL (KEYWORDS) :\n*              NODEBUG = NORMAL DISPLAY MESSAGES TAKES PLACE (THIS IS\n*                      THE DEFAULT).\n*                      ALIAS : ND\n*              DEBUG = DISPLAY OF SENSITIVE \"LDA\" FIELDS.\n*                      ALIAS : D\n*\n*        2. WHEN EXECUTED AS PROGRAM :\n*                      //...  EXEC PGM=CURESTA,\n*                      //          PARM=D OR DEBUG\n*                 OR : //...  EXEC PGM=CURESTA,\n*                      //          PARM='INNN,D' OR 'IDNNN,DEBUG'\n*                      WHERE \"NNN\" IS THE ID NUMBER.\n*\n*        3. WHEN CALLED AS ROUTINE IN A PROGRAM (I.E. ASSEMBLER) :\n*                      XR   R1,R1         OR : XR   R1,R1\n*                      CALL CURESTA            CALL CURESTA\n*                      B    *+L'*+2            B    *+L'*+6\n*                      DC   AL1(1),CL1'D'      DC   AL1(5),CL5'DEBUG'\n*                      ...                     ...\n*                 OR : XR   R1,R1         OR : XR   R1,R1\n*                      CALL CURESTA            CALL CURESTA\n*                      B    *+L'*+4            B    *+L'*+8\n*                      DC   AL1(1),CL1'D'      DC   AL1(5),CL5'DEBUG'\n*                      DC   AL1(255),AL1(NNN)  DC   AL1(255),AL1(NNN)\n*                      ...                     ...\n*                      WHERE \"NNN\" IS THE ID NUMBER.\n*           NOTE : THE BRANCH AFTER THE CALL MAY BE A BRANCH REGISTER\n*                  OPERATION (BR) ALSO.\n*\n* SUPPLIED ASSEMBLER MACRO : ...  $CRS  A,B,C\n* --------------------------            (ALL OPERANDS ARE OPTIONAL)\n*        WHERE A : IS THE ID NUMBER \"NNN\" (OR OMITED).\n*              B : IS \"D\" OR \"DEBUG\" KEYWORD (OR OMITED).\n*              C : IS THE BRANCH LABEL OR REGISTER (OR OMITED).\n         EJECT\n* ORIGIN : EXTRACTED FROM CBT 94 DEC TAPE, FILE 437, MEMBER \"STORUSXA\"\n* --------     (MVS/XA VERSION). REWORKED BY :\n*                      MOINIL P.A.\n*                      COMPUTING CENTRE (TP 361)\n*                      J.R.C. - ISPRA ESTABLISHMENT\n*                      21020 ISPRA (VA), ITALY\n         SPACE 1\n        PRINT  &PRS\n        $DEFREG\n        $XENT  BASE=R12,LV=WKLEN,TYPE=RENT\n        PRINT  GEN\n         LR    R10,R13\n         USING WKAREA,R10\n         LR    R8,R1               RETAIN ENTRY REG. 1\n         ST    R14,SVR14           SAVE ENTRY REG. 14\n         MVI   SWITCH,0\n         BAS   R9,SNDRTNX\n        PRINT  &PRS\n        $TEW$EC NOTTSO=ANAL,NOTCMD=ANAL,MSG=PUTMSG,PUT=PUTLNE,TIOT=YES\n        $TEW$PP PARM=PARMLST,REG=R3,ERR=BEGIN\n        PRINT  GEN\n         CLI   KWID+1,0            ID SPECIFIED ?\n         BE    TSNXT               NO\n         TM    KSID+6,X'80'        VALUE PRESENT ?\n         BZ    TSNXT               NO\n         LH    R14,KSID+4          VALUE LENGTH\n         LTR   R14,R14\n         BNP   TSNXT               INVALID\n         L     R1,KSID             VALUE POINTER\n         BCT   R14,*+L'*+6\n         PACK  DWK,0(0,R1)         <<EXECUTED>>\n         EX    R14,*-6\n         CVB   R0,DWK              VALUE IN BINARY NOW\n         CH    R0,=H'255'\n         BH    TSNXT\n         STC   R0,TREQID\n         OI    SWITCH,TRQRID\nTSNXT    CLC   KWLOG(2),=H'2'      TSO COMMAND OR SUB-COMMAND\n         BE    *+L'*+4\n         OI    SWITCH,USEPLR\n         CLC   KWDBG(2),=H'2'      DEBUG OPTION\n         BNE   *+L'*+4\n         OI    SWITCH,TRQRUN\n         DROP  R3\n        IKJRLSA #TSANSW            RELEASE PDL'S SPACE\n         OI    SWITCH,TRQDTR\n         B     BEGIN\nANAL     LTR   R8,R8               JCL EXEC PARM. FIELD ?\n         BZ    TCALL               NO\n         USING PSA,R0\n         L     R1,PSATOLD          -> TCB\n         DROP  R0\n         USING TCB,R1\n         L     R2,TCBFSA           -> FIRST SAVE AREA OF PROBLEM\n         DROP  R1\n         CL    R8,24(R2)           IS ENTRY REG. 1 ?\n         BNE   TCALL               NO, NOT JCL EXEC PGM=\n         OI    SWITCH,TRQDTR\n         L     R2,0(R8)            -> PARM. FIELD ADDRESS\n         XR    R1,R1\n         ICM   R1,B'0011',0(R2)\n         BZ    BEGIN               NO PARM. FIELD\n         LA    R3,1(R1,R2)\n         LA    R4,2(R2)\n         LA    R2,1\nSCPRM    CLI   0(R4),C'D'\n         BE    TSDBG\n         CLI   0(R4),C'I'\n         BE    TSIDN\nSCPRMT   CLI   0(R4),C','\n         BNE   ERPARM\nSCPRML   BXLE  R4,R2,SCPRM\n         B     BEGIN\nTSDBG    BXLE  R4,R2,*+L'*+4       CHECK D OR DEBUG\n         B     TSDBGX\n         CLI   0(R4),C','\n         BE    TSDBGX\n         LA    R0,4\n         LA    R1,=CL4'EBUG'\nTSDBGL   CLC   0(1,R4),0(R1)\n         BNE   ERPARM\n         BCT   R0,*+L'*+4\n         B     *+L'*+12\n         LA    R1,1(R1)\n         BXLE  R4,R2,TSDBGL\n         B     ERPARM\n         BXLE  R4,R2,*+L'*+4\n         B     TSDBGX\n         CLI   0(R4),C','\n         BNE   ERPARM\nTSDBGX   OI    SWITCH,TRQRUN\n         CLR   R4,R3\n         BNH   SCPRML\n         B     BEGIN\nTSIDN    BXLE  R4,R2,*+L'*+4       CHECK INNN OR IDNNN\n         B     ERPARM\n         CLI   0(R4),C'D'\n         BNE   *+L'*+8\n         BXLE  R4,R2,*+L'*+4\n         B     ERPARM\n         CLI   0(R4),C'0'\n         BL    ERPARM\n         CLI   0(R4),C'9'\n         BH    ERPARM\n         XR    R1,R1\n         LR    R14,R1\n         LA    R15,15\nTSIDNL   IC    R14,0(R4)\n         NR    R14,R15\n         LTR   R1,R1\n         BNP   *+L'*+4\n         MH    R1,=H'10'\n         AR    R1,R14\n         BXLE  R4,R2,*+L'*+4\n         B     TSIDNX\n         CLI   0(R4),C'0'\n         BL    TSIDNX\n         CLI   0(R4),C'9'\n         BNH   TSIDNL\nTSIDNX   CH    R1,=H'255'\n         BH    ERPARM\n         STC   R1,TREQID\n         OI    SWITCH,TRQRID\n         CLR   R4,R3\n         BNH   SCPRMT\n         B     BEGIN\nERPARM   MVC   MSGBUF+2(35),=CL35'<<= JCL-EXEC ... PARM=... ERROR =>>'\n         LA    R0,37\n         BAS   R9,SNDRTN\n         B     LEAVE\nTCALL    L     R14,SVR14           GET CALL-RETURN ADDRESS\n         MVC   DWK(2),0(R14)\n         NI    DWK+1,X'F0'\n         LA    R1,2(R14)\n         CLC   DWK(2),=XL2'07F0'   CHECK IF FOLLOWED BY BR\n         BE    *+L'*+14\n         LA    R1,2(R1)\n         CLC   DWK(2),=XL2'47F0'   CHECK IF FOLLOWED BY B\n         BNE   BEGIN\nTCALLL   CLI   0(R1),X'01'         THEN FOLLOWED BY D\n         BNE   TCALLN\n         CLI   1(R1),C'D'\n         BNE   BEGIN\n         LA    R1,2(R1)\n         B     TCALLD\nTCALLN   CLI   0(R1),X'05'         OR FOLLOWED BY DEBUG\n         BNE   TCALLI\n         CLC   1(5,R1),=CL5'DEBUG'\n         BNE   BEGIN\n         LA    R1,6(R1)\nTCALLD   OI    SWITCH,TRQRUN\n         B     TCALLL\nTCALLI   CLI   0(R1),X'FF'         OR FOLLOWED BY ID\n         BNE   BEGIN\n         MVC   TREQID,1(R1)\n         LA    R1,2(R1)\n         OI    SWITCH,TRQRID\n         B     TCALLL\nBEGIN    MVC   MSGBUF(31),=CL31'CURRENT REGION STATISTICS FOR :'\n         TM    SWITCH,TRQRUN\n         BZ    *+L'*+6\n         MVC   MSGBUF+15(10),=CL10'DEBUG REQ.'\n         L     R1,#TSTIOT          TIOT POINTER\n         USING TIODSECT,R1\n         MVC   MSGBUF+32(L'TIOCNJOB),TIOCNJOB MOVE NAMES\n         MVC   MSGBUF+L'TIOCNJOB+33(L'TIOCSTEP/2),TIOCSTEP\n         MVC   MSGBUF+L'TIOCNJOB+(L'TIOCSTEP/2)+34(L'TIOCSTEP/2),TIOCSTX\n               EP+(L'TIOCSTEP/2)\n         LA    R0,35+L'TIOCNJOB+L'TIOCSTEP\n         TM    SWITCH,TRQRID\n         BZ    TRQR14\n         MVC   MSGBUF+L'TIOCNJOB+L'TIOCSTEP+35(9),=CL9'/ ID ==>>'\n         XR    R1,R1\n         IC    R1,TREQID\n         CVD   R1,DWK\n         UNPK  MSGBUF+L'TIOCNJOB+L'TIOCSTEP+45(3),DWK+L'DWK-2(2)\n         OI    MSGBUF+L'TIOCNJOB+L'TIOCSTEP+47,C'0'\n         AH    R0,=H'13'\n         B     NOTTRQ\nTRQR14   TM    SWITCH,TRQDTR\n         BO    NOTTRQ\n         MVC   MSGBUF+L'TIOCNJOB+L'TIOCSTEP+35(7),=CL7'/ R14 ='\n         LA    R1,MSGBUF+L'TIOCNJOB+L'TIOCSTEP+43\n         LA    R2,SVR14\n         BAS   R9,HEXADD\n         AH    R0,=H'17'\n         DROP  R1\nNOTTRQ   BAS   R9,SNDRTN\n        $TSWXA 31,EXPAND=ONLY\n         USING PSA,R0\n         L     R1,PSAAOLD          -> ASCB\n         DROP  R0\n         USING ASCB,R1\n         L     R8,ASCBLDA          -> LDA\n         DROP  R1\n         USING LDA,R8\n         MVC   XDASTRTA,LDASTRTA\n         MVC   XDASIZA,LDASIZA\n         MVC   XDAESTRA,LDAESTRA\n         MVC   XDAESIZA,LDAESIZA\n         MVC   XDASTRTS,LDASTRTS\n         MVC   XDASIZS,LDASIZS\n         MVC   XDAESTRS,LDAESTRS\n         MVC   XDAESIZS,LDAESIZS\n         MVC   XDASTRTR,LDASTRTR\n         MVC   XDASIZR,LDASIZR\n         MVC   XDAESTRR,LDAESTRR\n         MVC   XDAESIZR,LDAESIZR\n         MVC   XDACRGTP,LDACRGTP\n         MVC   XDAERGTP,LDAERGTP\n         MVC   XDAREGRQ,LDAREGRQ\n         MVC   XDALIMIT,LDALIMIT\n         MVC   XDAVVRG,LDAVVRG\n         MVC   XDAELIM,LDAELIM\n         MVC   XDAEVVRG,LDAEVVRG\n         MVC   XDASMFL,LDASMFL\n         MVC   XDASMFR,LDASMFR\n         MVC   XDASMFEL,LDASMFEL\n         MVC   XDASMFER,LDASMFER\n         DROP  R8\n        $TSWXA 24,EXPAND=ONLY\n         TM    SWITCH,TRQRUN\n         BZ    PROCEED\n         MVC   MSGBUF(8),=CL8'LDASTRTA'\n         LA    R1,MSGBUF+10\n         LA    R2,XDASTRTA\n         BAS   R9,HEXADD\n         L     R3,XDASTRTA\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF+1(7),=CL7'LDASIZA'\n         LA    R1,MSGBUF+10\n         LA    R2,XDASIZA\n         BAS   R9,HEXADD\n         L     R3,XDASIZA\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF(8),=CL8'LDAESTRA'\n         LA    R1,MSGBUF+10\n         LA    R2,XDAESTRA\n         BAS   R9,HEXADD\n         L     R3,XDAESTRA\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF(8),=CL8'LDAESIZA'\n         LA    R1,MSGBUF+10\n         LA    R2,XDAESIZA\n         BAS   R9,HEXADD\n         L     R3,XDAESIZA\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF(8),=CL8'LDASTRTS'\n         LA    R1,MSGBUF+10\n         LA    R2,XDASTRTS\n         BAS   R9,HEXADD\n         L     R3,XDASTRTS\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF+1(7),=CL7'LDASIZS'\n         LA    R1,MSGBUF+10\n         LA    R2,XDASIZS\n         BAS   R9,HEXADD\n         L     R3,XDASIZS\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF(8),=CL8'LDAESTRS'\n         LA    R1,MSGBUF+10\n         LA    R2,XDAESTRS\n         BAS   R9,HEXADD\n         L     R3,XDAESTRS\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF(8),=CL8'LDAESIZS'\n         LA    R1,MSGBUF+10\n         LA    R2,XDAESIZS\n         BAS   R9,HEXADD\n         L     R3,XDAESIZS\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF(8),=CL8'LDASTRTR'\n         LA    R1,MSGBUF+10\n         LA    R2,XDASTRTR\n         BAS   R9,HEXADD\n         L     R3,XDASTRTR\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF+1(7),=CL7'LDASIZR'\n         LA    R1,MSGBUF+10\n         LA    R2,XDASIZR\n         BAS   R9,HEXADD\n         L     R3,XDASIZR\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF(8),=CL8'LDAESTRR'\n         LA    R1,MSGBUF+10\n         LA    R2,XDAESTRR\n         BAS   R9,HEXADD\n         L     R3,XDAESTRR\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF(8),=CL8'LDAESIZR'\n         LA    R1,MSGBUF+10\n         LA    R2,XDAESIZR\n         BAS   R9,HEXADD\n         L     R3,XDAESIZR\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF(8),=CL8'LDACRGTP'\n         LA    R1,MSGBUF+10\n         LA    R2,XDACRGTP\n         BAS   R9,HEXADD\n         L     R3,XDACRGTP\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF(8),=CL8'LDAERGTP'\n         LA    R1,MSGBUF+10\n         LA    R2,XDAERGTP\n         BAS   R9,HEXADD\n         L     R3,XDAERGTP\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF(8),=CL8'LDAREGRQ'\n         LA    R1,MSGBUF+10\n         LA    R2,XDAREGRQ\n         BAS   R9,HEXADD\n         L     R3,XDAREGRQ\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF(8),=CL8'LDALIMIT'\n         LA    R1,MSGBUF+10\n         LA    R2,XDALIMIT\n         BAS   R9,HEXADD\n         L     R3,XDALIMIT\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF+1(7),=CL7'LDAVVRG'\n         LA    R1,MSGBUF+10\n         LA    R2,XDAVVRG\n         BAS   R9,HEXADD\n         L     R3,XDAVVRG\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF+1(7),=CL7'LDAELIM'\n         LA    R1,MSGBUF+10\n         LA    R2,XDAELIM\n         BAS   R9,HEXADD\n         L     R3,XDAELIM\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF(8),=CL8'LDAEVVRG'\n         LA    R1,MSGBUF+10\n         LA    R2,XDAEVVRG\n         BAS   R9,HEXADD\n         L     R3,XDAEVVRG\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF+1(7),=CL7'LDASMFL'\n         LA    R1,MSGBUF+10\n         LA    R2,XDASMFL\n         BAS   R9,HEXADD\n         L     R3,XDASMFL\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF+1(7),=CL7'LDASMFR'\n         LA    R1,MSGBUF+10\n         LA    R2,XDASMFR\n         BAS   R9,HEXADD\n         L     R3,XDASMFR\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF(8),=CL8'LDASMFEL'\n         LA    R1,MSGBUF+10\n         LA    R2,XDASMFEL\n         BAS   R9,HEXADD\n         L     R3,XDASMFEL\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         MVC   MSGBUF(8),=CL8'LDASMFER'\n         LA    R1,MSGBUF+10\n         LA    R2,XDASMFER\n         BAS   R9,HEXADD\n         L     R3,XDASMFER\n         BAS   R9,DMKRTNT\n         BAS   R9,SNDRTNT\n         B     LEAVE\nPROCEED  MVC   MSGBUF+11(20),=CL20'SYSTEM REGION SIZE :'\n         L     R3,XDASTRTA\n         BAS   R9,DMKRTNP\n         BAS   R9,SNDRTNP\n         MVC   MSGBUF+6(25),=CL25'SYSTEM REGION SIZE USED :'\n         L     R3,XDASTRTS\n         BAS   R9,DMKRTNP\n         BAS   R9,SNDRTNP\n         MVC   MSGBUF+8(23),=CL23'REQUESTED REGION SIZE :'\n         L     R3,XDAREGRQ\n         BAS   R9,DMKRTNP\n         LA    R0,51\n         BAS   R9,SNDRTN\n         MVC   MSGBUF+39(6),=CL6'< 16 M'\n         MVC   MSGBUF+61(12),=CL12'> 16 M (EXT)'\n         BAS   R9,SNDRTNP\n         MVI   MSGBUF+32,C'-'\n         MVC   MSGBUF+33(18),MSGBUF+32\n         MVI   MSGBUF+54,C'-'\n         MVC   MSGBUF+55(18),MSGBUF+54\n         BAS   R9,SNDRTNP\n         MVC   MSGBUF+12(19),=CL19'CURRENT SIZE USED :'\n         L     R3,XDACRGTP         CURRENT HIGH ADDRESS OF PVT\n         S     R3,XDASTRTA\n         BAS   R9,DMKRTNP\n         L     R3,XDAERGTP         CURRENT HIGH ADDRESS OF PVT EXT.\n         S     R3,XDAESTRA\n         BAS   R9,DMKRTNE\n         BAS   R9,SNDRTNP\n         MVC   MSGBUF+7(24),=CL24'MAX. PRIVATE AREA SIZE :'\n         L     R3,XDASIZA\n         BAS   R9,DMKRTNP\n         L     R3,XDAESIZA\n         BAS   R9,DMKRTNE\n         BAS   R9,SNDRTNP\n         MVC   MSGBUF+7(24),=CL24'V=V REGION LIMIT VALUE :'\n         L     R3,XDALIMIT\n         BAS   R9,DMKRTNP\n         L     R3,XDAELIM\n         BAS   R9,DMKRTNE\n         BAS   R9,SNDRTNP\n         MVC   MSGBUF+8(23),=CL23'V=V REGION HIGH VALUE :'\n         L     R3,XDAVVRG\n         BAS   R9,DMKRTNP\n         L     R3,XDAEVVRG\n         BAS   R9,DMKRTNE\n         BAS   R9,SNDRTNP\n         L     R3,XDASMFL          SMF IEALIMIT\n         LTR   R3,R3\n         BNP   *+L'*+4\n         BAS   R9,DMKRTNP\n         L     R3,XDASMFEL\n         LTR   R3,R3\n         BNP   *+L'*+4\n         BAS   R9,DMKRTNE\n         CLI   MSGBUF+50,C' '\n         BNE   *+L'*+8\n         CLI   MSGBUF+72,C' '\n         BE    *+L'*+10\n         MVC   MSGBUF+10(21),=CL21'V=V SMF LIMIT VALUE :'\n         BAS   R9,SNDRTNP\n         L     R3,XDASMFR\n         LTR   R3,R3\n         BNP   *+L'*+4\n         BAS   R9,DMKRTNP\n         L     R3,XDASMFER\n         LTR   R3,R3\n         BNP   *+L'*+4\n         BAS   R9,DMKRTNE\n         CLI   MSGBUF+50,C' '\n         BNE   *+L'*+8\n         CLI   MSGBUF+72,C' '\n         BE    *+L'*+10\n         MVC   MSGBUF+11(20),=CL20'V=V SMF HIGH VALUE :'\n         BAS   R9,SNDRTNP\n        PRINT  &PRS\nLEAVE   $XRET  CC=0,LV=WKLEN,TYPE=RENT\n        PRINT  GEN\n         SPACE 1\n*- - - - HEX. ADDRESS EDIT (R9 = LINK / R1 = A.OUTPUT / R2 = A.ADDRESS)\nHEXADD   UNPK  0(9,R1),0(5,R2)\n         TR    0(8,R1),TRTHEX-C'0'\n         MVI   8(R1),C' '\n         BR    R9\n         SPACE 1\n*- - - - DO M AND K ROUTINE (R9 = LINK / R1 = A.OUTPUT / R3 = VALUE)\nDMKRTNT  LA    R1,MSGBUF+20\n         B     DMKRTN\nDMKRTNP  LA    R1,MSGBUF+31\n         B     DMKRTN\nDMKRTNE  LA    R1,MSGBUF+53\nDMKRTN   LTR   R0,R3               SAVE FOR COMPUTATION IN K\n         BNPR  R9\n         M     R2,=F'10'           MULTIPLY BY 10\n         CL    R3,=A(X'00100000')  OVER 1 MEG\n         BL    *+L'*+8             NO, LESS\n         D     R2,=A(X'00100000')  YES, DIVIDE BY 1 MEG\n         B     *+L'*+2\n         XR    R3,R3\n         CVD   R3,DWK              CONVERT\n         MVC   0(7,R1),=XL7'40202020214B20' FORMAT SIZE IN M\n         ED    0(7,R1),DWK+5       MOVE TO OUTPUT\n         MVC   7(3,R1),=CL3'M -'\n         SRA   R0,10               SIZE IN K\n         CVD   R0,DWK              CONVERT\n         MVC   11(8,R1),=XL8'4020202020202120' FORMAT SIZE IN K\n         ED    11(8,R1),DWK+4      MOVE TO OUTPUT\n         MVI   19(R1),C'K'\n         BR    R9\n         SPACE 1\n*- - - - MESSAGE LINE ROUTINE (R9 = LINK / R0 = MSG LENGTH)\nSNDRTNT  LA    R0,40\n         B     SNDRTN\nSNDRTNP  LA    R0,73\nSNDRTN   TM    SWITCH,USEPLR\n         BZ    *+L'*+12\n         LA    R1,MSGBUF\n         BAS   R14,PUTLNE\n         B     SNDRTNX\n         LA    R1,4\n         AR    R1,R0\n         STCM  R1,B'0011',MSGWTO\n         MVC   MSGWTO+2(L'DRCDS1),DRCDS1\n         LA    R1,MSGBUF\n         AR    R1,R0\n         MVC   0(L'DRCDS2,R1),DRCDS2\n         LA    R1,MSGWTO\n         BAS   R14,PUTMSG\nSNDRTNX  MVI   MSGBUF,C' '\n         MVC   MSGBUF+1(L'MSGBUF-1),MSGBUF\n         BR    R9\n         SPACE 1\n*- - - - CONSTANTS\n         SPACE 1\nSKWTO    WTO   '  ',ROUTCDE=11,DESC=7,MF=L\nDRCDS1   EQU   SKWTO+2,2\nDRCDS2   EQU   *-4,4\nTRTHEX   DC    CL16'0123456789ABCDEF'\n         SPACE 1\n*- - - - LITERAL POOL\n         SPACE 1\n        LTORG\n         SPACE 1\n        PRINT  &PRS\nPARMLST  IKJPARM  DSECT=IKJPARMD\nKWID     IKJKEYWD\n         IKJNAME  'ID',SUBFLD=SFID,ALIAS=('I')\nKWLOG    IKJKEYWD DEFAULT='NOLOG'\n         IKJNAME  'NOLOG',ALIAS=('NL')\n         IKJNAME  'LOG',ALIAS=('L')\nKWDBG    IKJKEYWD DEFAULT='NODEBUG'\n         IKJNAME  'NODEBUG',ALIAS=('ND')\n         IKJNAME  'DEBUG',ALIAS=('D')\nSFID     IKJSUBF\nKSID     IKJIDENT 'ID(0-255)',FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=3\n         IKJENDP\n        PRINT  GEN\n         SPACE 1\n*- - - - WORK-AREAS\n         SPACE 1\nWKAREA   DSECT\n         DS    18F                 1ST SAVE AREA\nDWK      DS    D\nXDASTRTA DS    F                   SENSITIVE \"LDA\" FIELDS\nXDASIZA  DS    F\nXDAESTRA DS    F\nXDAESIZA DS    F\nXDASTRTS DS    F\nXDASIZS  DS    F\nXDAESTRS DS    F\nXDAESIZS DS    F\nXDASTRTR DS    F\nXDASIZR  DS    F\nXDAESTRR DS    F\nXDAESIZR DS    F\nXDACRGTP DS    F\nXDAERGTP DS    F\nXDAREGRQ DS    F\nXDALIMIT DS    F\nXDAVVRG  DS    F\nXDAELIM  DS    F\nXDAEVVRG DS    F\nXDASMFL  DS    F\nXDASMFR  DS    F\nXDASMFEL DS    F\nXDASMFER DS    F\nSVR14    DS    F\nMSGWTO   DS    F\nMSGBUF   DS    CL84\nTREQID   DS    AL1\nSWITCH   DS    XL1\nUSEPLR   EQU   X'80'               USE PUTLNE ROUTINE\nTRQRUN   EQU   X'40'               DEBUG RUN\nTRQRID   EQU   X'20'               DISPLAY ID\nTRQDTR   EQU   X'10'               DON'T TRACE R14\n        PRINT  &PRS\n        $TEW$WA\n        PRINT  GEN\nWKLEN    EQU   (((*-WKAREA)+7)/8)*8\n         SPACE 1\n        PRINT  &PRS\n        $TEW$DS\n        PRINT  &PRF\n        IHAPSA DSECT=YES,LIST=YES\n        IKJTCB LIST=YES\n        IHAASCB\n        IHALDA\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CURESTA$": {"ttr": 2568, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07_\\x00\\x95\\x07_\\x100\\x00#\\x00#\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-16T00:00:00", "modifydate": "1995-03-16T10:30:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SYSPAJA"}, "text": "//CURESTA  JOB (........),'INSTALL - CURESTA -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=6\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* ---------- ADJUSTMENTS MUST BE DONE BEFORE YOU RUN THIS JOB (SCAN *\n//*            ALL \"->\" OCCURENCES AND SET RIGHT DATA-SETS NAMES).    *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* NOTE : AT ASSEMBLY, YOU MAY SET THE SYSPARM AS BELOW :            *\n//*        FULL  =  PRINT GEN FOR THE ENTIRE LIST                     *\n//*        SHORT =  REDUCED PRINT GEN                                 *\n//*        NONE  =  PRINT NOGEN FOR THE ENTIRE LIST                   *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ4AS3,OPT=',SYSPARM(NONE)',MBR=CURESTA\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//*        LINK AS ROUTINE                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//LNK     EXEC PAJILKR,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   CURESTA\n  NAME    CURESTA(R)\n/*\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//*        LINK AS COMMAND (AND PROGRAM)                              *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//LNKC    EXEC PGM=IEWL,PARM='LIST,XREF,NCAL,RENT'\n//SYSLMOD   DD DSN=->.TARGET.RTNLIB,DISP=OLD\n//SYSLIBL   DD DSN=->.TARGET.CMDLIB,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,2)\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD *\n    INCLUDE   SYSLIBL(CURESTA)\n    ENTRY     CURESTA\n    ALIAS     CRS                  <<== NAME IS AT YOUR DISCRETION ===\n NAME    CURESTA(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CURESTA@": {"ttr": 2570, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07?\\x00\\x95\\x07?\\t5\\x00m\\x00m\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-14T00:00:00", "modifydate": "1995-03-14T09:35:00", "lines": 109, "newlines": 109, "modlines": 0, "user": "SYSPAJA"}, "text": "1   17/02/95\n                                                      CURESTA   1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *           C U R E S T A             * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *  Current Region Statistics display  * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Display (TSO command or subcommand) or log (other ways\n  ---------    of execution) the current region statistics.\n               Origin :     extracted from CBT 94 DEC tape, file 437,\n                            member STORUSXA (reworked by MOINIL P.A.).\n               Name :       CURESTA\n               Attributes : RENT\n\n  Syntax when used as TSO command (or subcommand) :\n  -------------------------------------------------\n                   Command   Operand(s)\n                   --------  -----------------------------------------\n                   CURESTA   ID(...) / I(...)    NOLOG / NL\n                                                 LOG / L\n               Optional (keywords) :\n               ID(...) = identify this display with the given number.\n                     I.e. : ID(11)\n                     Alias : I(...)\n                     Maximum range for ID number : 0-255.\n               NOLOG = normal use of PUTLINE to display the messages\n                     (this is the default).\n                     Alias : NL\n               LOG = force messages display to go on the JOB log (with\n                     copy in the MESSAGES log) when in TSO background.\n                     When running in TSO foreground session it has no\n                     effect (they are always sended to the terminal).\n                     Alias : L\n\n  Other ways of execution :\n  -------------------------\n               1. as program : //...  EXEC PGM=CURESTA\n                          or : //...  EXEC PGM=CURESTA,\n                               //          PARM=INNN or IDNNN\n                       where NNN is the ID number.\n               2. as routine : XR   R1,R1\n                               CALL CURESTA\n                               ...\n                          or : XR   R1,R1\n                               CALL CURESTA\n                               B    *+L'*+2\n                               DC   AL1(255),AL1(NNN)\n                               ...\n                               where NNN is the ID number.\n           Notes : The branch operation (B) after the CALL may be a\n                   branch register operation (BR) also.\n                   The messages are always outputed on log (unless\n                   when executed in TSO foreground session).\n1   17/02/95\n                                                      CURESTA   2/2.\n\n  Debuging aids : A debug mode has been included to allow an easier\n  --------------- way of search and test facilities (i.e., if you\n                  plan to do some private modifications).\n\n         1. When used as TSO command (or subcommand) :\n                   Command   Operand(s)\n                   --------  -----------------------------------------\n                   CURESTA   NODEBUG / ND\n                             DEBUG / D\n            Optional (keywords) :\n               NODEBUG = normal display messages takes place (this is\n                       the default).\n                       Alias : ND\n               DEBUG = display of sensitive LDA fields.\n                       Alias : D\n\n         2. When executed as program :\n                       //...  EXEC PGM=CURESTA,\n                       //          PARM=D or DEBUG\n                  or : //...  EXEC PGM=CURESTA,\n                       //          PARM='INNN,D' or 'IDNNN,DEBUG'\n                       where NNN is the ID number.\n\n         3. When called as routine in a program (i.e. Assembler) :\n                       XR   R1,R1         or : XR   R1,R1\n                       CALL CURESTA            CALL CURESTA\n                       B    *+L'*+2            B    *+L'*+6\n                       DC   AL1(1),CL1'D'      DC   AL1(5),CL5'DEBUG'\n                       ...                     ...\n                  or : XR   R1,R1         or : XR   R1,R1\n                       CALL CURESTA            CALL CURESTA\n                       B    *+L'*+4            B    *+L'*+8\n                       DC   AL1(1),CL1'D'      DC   AL1(5),CL5'DEBUG'\n                       DC   AL1(255),AL1(NNN)  DC   AL1(255),AL1(NNN)\n                       ...                     ...\n                       where NNN is the ID number.\n            Note : the branch operation (B) after the CALL may be a\n                   branch register operation (BR) also.\n\n  Supplied Assembler macro : ...  $CRS  A,B,C\n  --------------------------            (all operands are optional)\n         where A : is the ID number NNN (value 0-255), or omited.\n                   I.e. : $CRS 123\n               B : is D or DEBUG keyword, or omited.\n                   I.e. : $CRS ,D\n               C : is the branch label or register (where to go), or\n                   omited.\n                   I.e. : $CRS ,,(R9) <- branch is in register 9\n                          $CRS ,,ZULU <- branch to label ZULU\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DIDOCS": {"ttr": 2573, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07O\\x00\\x95\\x07O\\x16\\t\\x06\\xab\\x06\\xab\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-15T00:00:00", "modifydate": "1995-03-15T16:09:00", "lines": 1707, "newlines": 1707, "modlines": 0, "user": "SYSPAJA"}, "text": "DIDOCS   TITLE 'D I D O C S - SIMULATE OS CONSOLE ON TSO USER TUBE.'\n*        DATA-SET DIDOCS : AT LEVEL 002 AS OF 04/05/82.\n         SPACE 1\n         PRINT OFF\n         MACRO\n&LAB    PUTIT  &MESS,&EXIT=SETRC\n         LCLC  &L\n&L       SETC  'L'''\n&LAB    TPUT   M&SYSNDX,&L.M&SYSNDX\n         B     &EXIT\nM&SYSNDX DC    C&MESS\n         MEND\n         MACRO\n&LAB    @SNAP  &ID,&HEADER\n         AIF   ('&ID' EQ '').A\n&LAB     LA    R0,&ID\n         AGO   .B\n.A       ANOP\n&LAB     XR    R0,R0\n.B       AIF   ('&HEADER' EQ '').C\n         L     R1,=A(&HEADER)\n         AGO   .D\n.C       XR    R1,R1\n.D       L     R15,=A(SNAP)\n         BASR  R14,R15\n         LTR   R15,R15\n         MEND\n         COPY  DIDOCSM\n         PRINT ON\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* * * * * * * * *                                     * * * * * * * * *\n* * * * * * * * *        D   I   D   O   C   S        * * * * * * * * *\n* * * * * * * * *                                     * * * * * * * * *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* TSO COMMAND : D I D O C S                                           *\n* -------------                                                       *\n*                                                                     *\n*    (DEVICE INDEPENDENT DISPLAY OPERATOR CONSOLE SUPPORT)            *\n*                                                                     *\n*                                                                     *\n* PURPOSE :                                                           *\n* ---------                                                           *\n*                                                                     *\n*    FOR TSO OPER PRIVLEDGE USERS, SIMULATE AN OS 3277 CONSOLE        *\n*    AT THEIR TSO TUBE BY PEEKING AT THE DIDOCS CONSOLE MESSAGE       *\n*    BUFFERS IN CSA. DIDOCS ACCEPTS A REPLY FROM THE USER.            *\n*    NON-BLANK REPLIES ARE FORMATTED INTO A CMD AND ISSUED VIA        *\n*    SVC34, BLANK REPLIES JUST CAUSE THE SCREEN TO BE UPDATED.        *\n*    ANY COMMANDS ISSUED VIA SVC34 ARE ALSO LOGGED VIA A WTO SO       *\n*    THAT YOUR AUDITORS AND OPERATIONS KNOW WHAT IS GOING ON.         *\n*                                                                     *\n*    THIS CODE IS BASED ON THE DIDOCS COMMAND FROM THE SHARE DCMS     *\n*    SYSTEM. ORIGINAL CODE GENERATED BY FRED LUDDY OF AMDAHL CORP.    *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* TO INVOKE : TYPE DIDOCS                                             *\n*             EXIT FROM DIDOCS IS VIA PFK-3                           *\n*                                                                     *\n* ERROR MESSAGE : NO ACCEPTABLE CONSOLES ACTIVE.                      *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n* MOD 1 - KEN TRUE - FAIRCHILD CAMERA AND INSTRUMENT CORP.  18 MAR 80 *\n*         A) ADDED MODESETS TO FIX FETCH PROT. ON MCS BUFFERS WITH    *\n*            MVS 3.8B. INTERNALIZED ALL MACROS.                       *\n*         B) REMOVED DCMS SCREEN HANDLING AND CONVERTED TO SINGLE     *\n*            CSECT USING DIRECT SCREEN FORMATTING.                    *\n*                                                                     *\n* MOD 2 - ARNOLD CASINGHINO - CONNECTICUT BANK AND TRUST.   18 SEP 82 *\n*         GET THE MASTER CONSOLE ONLY AND BYPASS THE REST.            *\n*                                                                     *\n*  NOTE : LINK WITH 'AC(1)', AND AUTHORIZE COMMAND VIA ENTRY          *\n*         IN IKJEFTE8 (MODULE IKJEFT02).                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n* MODIFIED BY :  MOINIL P.A.\n* -------------  COMPUTING CENTRE (TP 361)\n*                J.R.C. - ISPRA ESTABLISHMENT\n*                21020 ISPRA (VA), ITALY\n*\n* COMMAND SYNTAX : DIDOCS OPMODE\n*\n*        WHERE OPMODE : IF OMITTED, DEFAULT IS DISPLAY COMMANDS,\n*                              WITH LOG, BUT DEPENDING ON USER\n*                              AUTHORITY LEVEL.\n*                       SYSTEM OR S - ALL COMMANDS (OS, JES2, CJS,\n*                              ...), WITH LOG, BUT DEPENDING ON USER\n*                              AUTHORITY LEVEL.\n*                       CASPER OR GHOST - ALL COMMANDS WITH NO LOG.\n*                       DEBUG OR D - DEBUG AID (PFK'S 1-8-9-10-11).\n*\n* ADDS/CHANGES :\n*      18 OCT 88 - DETERMINE AT ENTRY IF TSO COMMAND OR SUB-COMMAND.\n*                - CHECK USER AUTHORITY.\n*                - CONTROL SCREEN SIZE (24 * 80).\n*                - DISPLAY PANEL TO SELECT ANY EXISTING ACTIVE GRAPHIC\n*                  OPERATOR'S CONSOLE ON USER TSO CRT (PFK-2).\n*                - DISPLAY A PANEL WITH THE OPERATOR'S REPLIES PENDING\n*                  INFORMATION IN THE SYSTEM (PFK-5).\n*                - DEBUG (SNAPS) FACILITIES (FILE SYSSNAP NEEDED).\n*                - MODULE CODED RE-ENTERABLE.\n*                - RUN ON MVS/XA VERSIONS 2.2.0 AND 2.2.3.\n*      19 MAR 91 - RESHOW LAST COMMAND (PFK-12).\n         EJECT\nDIDOCS   START 0\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        AUTHORITY LEVELS DEFINITIONS.                          *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nLV15     EQU   15        SYSTEM (AND EVENTUAL SHADOW) DIDOCS LEVEL.\nLV10     EQU   10 - 14   ALL COMMANDS AND LOG LEVEL.\nLV9      EQU   9         DISPLAY COMMANDS AND REPLY TO JES328X LEVEL.\nLV8      EQU   8 - 2     ONLY DISPLAY COMMANDS LEVEL.\nLV1      EQU   1         ONLY REPLY TO JES328X LEVEL.\nLV0      EQU   0         REJECT LEVEL.\n         SPACE 1\n        $MDL@IX\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=(R11,R12),LV=WRKL,TYPE=RENT\n         LA    R10,2048(,R13)      SET WORK AREAS ADDRESSABILITY.\n         LA    R10,2048(,R10)\n         USING WRKDSECT,R13,R10\n        $TEW$EC TIOT=YES,NOTTSO=(,ONLY),MSG=PUTMSG,ERR=SETRC\n         MVC   WTOLOG(WTOLOGL),WTOLOGP INITIALIZE WTO-LOG.\n         USING CPPL,R2\n         L     R1,CPPLPSCB\n         USING PSCB,R1\n         MVC   LOGUSER,PSCBUSER    SET UP TO LOG THE COMMAND.\n         DROP  R1,R2\n         EJECT\n*------- CHECK USER AUTHORITY : SYSTEM, OPERATOR, ...\n         SPACE 1\n         MVI   SWITCH,0            INITIALIZE.\n         MVI   SWTRC,0\n         MVI   AUTH,LV0\n         XC    REQAUT(REQAUTL),REQAUT\n         MVC   REQAUT+1(3),=AL3(MDL@IX)\n         LA    R1,AUTH\n         ST    R1,REQAUT+4\n        $EACM  REQAUT\n         CLI   AUTH,LV0            AUTHORIZED?\n         BE    NOTAUT              NO, REJECT.\n         SPACE 1\n*------- CHECK CALLER TERMINAL.\n         SPACE 1\n        GTSIZE ,                   GET ORIGINAL SCREEN SIZE.\n         LTR   R0,R0               IS IT A SCREEN?\n         BZ    NOTSCR              IF ZERO, NOT A SCREEN.\n         CH    R0,=H'24'           STANDARD NUMBER OF LINES?\n         BL    NOTSTD              BRANCH IF LESS.\n         BE    TSTLNL              BRANCH IF YES.\n         CH    R1,=H'80'           STANDARD LINE LENGTH?\n         BL    NOTSTD              BRANCH IF LESS.\nSETSSZ   ST    R0,SZSCRN           SAVE SCREEN SIZE.\n         ST    R1,SZLINE           SAVE LINE SIZE.\n         OI    SWITCH,SCRST        INDICATE SCREEN SIZE TO BE SET.\n         B     GOPARS\nTSTLNL   CH    R1,=H'80'           STANDARD LINE LENGTH?\n         BL    NOTSTD              BRANCH IF LESS.\n         BH    SETSSZ              BRANCH IF MORE.\n         EJECT\nGOPARS  $TEW$PP PARM=PARMLST,REG=R3\n         SPACE 1\n         MVI   CMDALLOW,C' '       SET DEFAULT.\n         CLI   AUTH,LV1            IS IT COMMON AUTHORITY LEVEL?\n         BE    JONLY               YES.\n         CLI   AUTH,LV9            CHECK AUTHORITY.\n         BL    INITIAL\n         LH    R1,OPMODE\n         LTR   R1,R1\n         BZ    INITIAL\n         BCT   R1,SYSINIT\n         SPACE 1\n*------- LOGGED DIDOCS USER : ACCEPT ALL COMMANDS AND LOG.\n         SPACE 1\n         CLI   AUTH,LV9\n         BE    JONLY\nNORMAL   MVI   CMDALLOW,C'L'\n         B     INITIAL\n         SPACE 1\n*------- SHADOW DIDOCS USER : ACCEPT ALL COMMANDS AND NO-LOG.\n         SPACE 1\nSYSINIT  CLI   AUTH,LV15           CHECK AUTHORITY.\n         BL    NORMAL\n         BCT   R1,TSDBG\n         MVI   CMDALLOW,C'S'\n         B     INITIAL\n         SPACE 1\n*------- DEBUG REQUEST : PFK'S 1-8-9-10-11.\n         SPACE 1\nTSDBG    OI    SWTRC,TRALL         SET TRACE ON.\n         B     INITIAL\n         SPACE 1\n*------- COMMON DIDOCS USER : ACCEPT ONLY DISPLAY COMMANDS AND LOG.\n         SPACE 1\nJONLY    OI    SWITCH,J328X        ACCEPT REPLY TO JES328X.\n         DROP  R3\n         EJECT\nINITIAL IKJRLSA #TSANSW\n         SPACE 1\n*------- CHECK TRACE ALLOWABLE.\n         SPACE 1\nCHECKTR  TM    SWTRC,TRALL         IS TRACE REQUESTED?\n         BZ    INITWA              NO.\n         CLI   AUTH,LV15           AUTHORIZED?\n         BL    CLTRC               NO.\n         XR    R1,R1\n         L     R2,#TSTIOT\n         USING TIODSECT,R2\n         L     R3,=A(SNAPCS)\n         USING IHADCB,R3\nSEARCH   CLC   TIOELNGH(4),=F'0'\n         BE    NOSNAP\n         CLC   TIOEDDNM(L'TIOEDDNM),DCBDDNAM\n         BE    TRREQ\n         IC    R1,TIOELNGH\n         ALR   R2,R1\n         B     SEARCH\n         DROP  R2,R3\nTRREQ    OI    SWTRC,TRALL\n         XC    SVSNAP(18*4),SVSNAP\n         B     INITWA\nCLTRC    MVI   SWTRC,0\n         EJECT\n*------- INITIALIZE WORK AREAS.\n         SPACE 1\nINITWA   L     R1,=A(DCMREND-DCMTSRT)\n         ST    R1,RDCML\n         LA    R1,7(R1)\n         SRL   R1,3\n         SLL   R1,3\n         ST    R1,RDCMLG\n        GETMAIN R,LV=(1),SP=1\n         ST    R1,LOCRDCM\n         XC    LOCTDCM,LOCTDCM\n         XC    LOCBUF,LOCBUF\n         XC    LOCORE,LOCORE\n         MVC   UNITMSG(UNITLEN),UNITMSGP\n         MVC   CMND(L'CMNDP),CMNDP\n         MVC   CMNDBUF(L'CMNDBUF),LOTSBLNK\n         MVC   PFREPLY(L'PFREPLY),LOTSBLNK\n         MVC   SELSCRN(FULLSCRL),FULLSCRP\n         MVC   SELT1A(SELT1L),SELT1\n         MVC   SELT1B(SELT1L),SELT1\n         MVC   SELT2A(SELT2L),SELT2\n         MVC   SELT2B(SELT2L),SELT2\n         MVC   SELSP(SELSPL),SELSPP\n         L     R1,=A(FAKEWARN)\n         MVC   INFLINE(FAKEWRNL),0(R1)\n         CLI   AUTH,LV1            IS IT COMMON AUTHORITY LEVEL?\n         BNE   *+L'*+6             NO.\n         MVC   INFLINE+FAKEWRNR(11),=CL11'INACTIVE.'\n         MVC   SETICT(SETICL),SETIC\n         MVC   FULLSCRN(FULLSCRL),FULLSCRP\n         MVC   OPRPSCRN(OPRPSCRL),OPRPSCRP\n         MVC   OPLST(OPLSTPL),OPLSTP\n         L     R1,=A(HELPSCRP)\n         MVC   HELPSCRN(256),0(R1)\n         MVC   HELPSCRN+256(HELPLEN-256),256(R1)\n         LA    R2,SCREEN\n         LA    R3,SCREENL\n         LA    R4,*\n         XR    R5,R5\n         MVCL  R2,R4\n         MVC   WSPT(WSPL),WSP\n         MVC   MSGLINE(L'MSGLINE),LOTSBLNK\n         MVC   WSIT(WSIL),WSI\n         L     R1,=A(FKWARN)\n         MVC   INFOLINE(FKWRNL),0(R1)\n         CLI   AUTH,LV1            IS IT COMMON AUTHORITY LEVEL?\n         BNE   *+L'*+6             NO.\n         MVC   INFOLINE+FKWRNR(10),=CL11'INACTIVE.'\n         MVC   WSFT(WSFL),WSF\n         MVC   SETCOT(SETCOL),SETCO\n         L     R2,CVTPTR           POINT TO CVT.\n         USING CVT,R2\n         L     R3,CVTSMCA          GET SMF CONTROL AREA ADDRESS.\n         USING SMCABASE,R3\nLSYSID   EQU   L'SMCASID           SYSTEM ID LENGTH.\n         MVC   INFLINE+FAKEWRNL-LSYSID-L'LSF(LSYSID),SMCASID\n         MVC   INFOLINE+FKWRNL-LSYSID-L'LSF(LSYSID),SMCASID\n         MVC   OPSYS(LSYSID),SMCASID\n         DROP  R2,R3\n         TM    SWITCH,J328X        ACCEPT REPLY TO JES328X?\n         BZ    *+L'*+6             NO.\n         MVC   RNJ328X(L'RNJ328X),LOTSBLNK\n         EJECT\n*------- START PROCESSING.\n         SPACE 1\n        STFSMODE ON,INITIAL=YES    TURN ON VTAM FULL SCREEN MODE.\n         TM    SWITCH,SCRST        SCREEN SIZE TO BE SET?\n         BZ    NOSCRS              BRANCH IF NOT.\n        STSIZE SIZE=80,LINE=24     SET STANDARD SCREEN SIZE.\n         OI    SWITCH,SCRRS        INDICATE SCREEN SIZE TO BE RESET.\nNOSCRS  ZEROKEY ,\n         L     R1,CVTPTR           CVT POINTER.\n         L     R1,CVTCUCB-CVT(R1)  UCM BASE POINTER.\n         USING UCM,R1\n         XC    CONASID,CONASID\n         MVC   CONASID+2(2),UCMCTID     GET COMMTASK ASID.\n         DROP  R1\n        ESAR   R5                  GET SECONDARY ASID.\n         ST    R5,SASID            KEEP IT.\n         MVC   AXPL(4),=XL4'00010000'\n        AXRES  AXLIST=AXPL         RESERVE AX.\n         L     R5,CONASID          GET COMMTASK ASID.\n        AXEXT  ASID=(5)            EXTRACT AX OF CONSOLE IN R0.\n        AXSET  AX=(0)              SET AX TO ALLOW CONSOLE AS 2ND.\n        RESETKEY ,\n         EJECT\n*------- DISPLAY USEFULL CONSOLES INFORMATION.\n         SPACE 1\nRESTART  MVC   SELCUU,SELCUUP\n         MVC   SELWHAT,SELWHATP\nRESET    ICM   R1,B'1111',LOCTDCM  TDCM AREA TO BE FREED?\n         BZ    NOFREET             BRANCH IF NOT.\n         L     R14,TDCMLG          LENGTH OF AREA.\n        FREEMAIN R,A=(1),LV=(R14),SP=1\n         XC    LOCTDCM,LOCTDCM     NULLIFY.\nNOFREET  ICM   R1,B'1111',LOCBUF   TDCM BUFFER AREA TO BE FREED?\n         BZ    NOFREEB             BRANCH IF NOT.\n         L     R14,LOCBUFL         LENGTH OF AREA.\n        FREEMAIN R,A=(1),LV=(R14),SP=1\n         XC    LOCBUF,LOCBUF       NULLIFY.\nNOFREEB  LA    R2,SELDT\n         LR    R6,R2\n         LA    R3,SELDTN\n         LR    R7,R3\n         MVC   0(SELDTL,R2),SELDTP\n         LA    R2,SELDTL(,R2)\n         BCT   R3,*-10\n         L     R1,CVTPTR           BEGINNING...\n         L     R1,CVTCUCB-CVT(R1)  ...\n         USING UCM,R1\n         LM    R3,R5,UCMVEA        R3 -> TO THE FIRST UCME,\n*                                   R4 CONTAINS UCME LENGTH,\n*                                    R5 -> TO THE LAST UCME.\n         DROP  R1\n         USING UCMLIST,R3\nNEXTUCM  TM    SWTRC,PF9+TRALL     TRACE REQUESTED AND ALLOWED?\n         BNO   GETUCM              NO.\n         ST    R3,SNAPLST          UCME START.\n         L     R15,=A(UCMESIZE-1)  UCME LENGTH.\n         ALR   R15,R3\n         ST    R15,SNAPLST+4       UCME END.\n         OI    SNAPLST+4,X'80'\n        @SNAP  1,HD1               DUMP UCME.\n         BZ    GETUCM\nSNPERR   MVC   SCREEN(SNPMSGL),SNPMSG\n         TM    SWTRC,SNOPEN\n         BO    *+L'*+6\n         MVC   SCREEN+SNPMSGO(4),=CL4'OPEN'\n         BAS   R9,CVTPRT\n         MVC   SCREEN+SNPRCL(L'CVTA),CVTA\n         LA    R1,FULLSCRN\n         LA    R0,FULLSCRL+SNPMSGL\n         OI    SWITCH,QUIT\n         BAS   R9,STERM            SEND THE SCREEN.\n         B     ENDIT               END.\nGETUCM   TM    UCMATR,UCMUF        IS THIS CONSOLE ACTIVE?\n         BZ    TESTUCM             NO... UNUSABLE.\n         TM    UCMDISP1,UCMDISPC+UCMDISPE    GRAPHICS AND FULL I/O?\n         BNO   TESTUCM             NO... UNACCEPTABLE.\n         ICM   R1,B'1111',UCMXB    IS IT GRAPHICS?\n         BZ    TESTUCM             NO... USELESS.\n         L     R1,UCMUCB           GET THE UCB ADDRESS.\n         USING UCBDSECT,R1\n         MVC   6(L'UCBNAME,R6),UCBNAME\n         DROP  R1\n         XR    R15,R15             GET THE CONSOLE ID.\n         IC    R15,UCMID\n         CVD   R15,CVTA\n         UNPK  12(2,R6),CVTA+6(2)\n         OI    13(R6),C'0'\n         LA    R15,16(R6)          GET AUTHORITY.\n         TM    UCMAUTHA,UCMAUTH1\n         BZ    TAIO\n         MVC   0(4,R15),=CL4'SYS.'\n         LA    R15,3(R15)\nTAIO     TM    UCMAUTHA,UCMAUTH2\n         BZ    TACONS\n         CLI   0(R15),C' '\n         BE    TAIOA\n         MVC   0(5,R15),=CL5', IO.'\n         LA    R15,4(R15)\n         B     TACONS\nTAIOA    MVC   0(3,R15),=CL3'IO.'\n         LA    R15,2(R15)\nTACONS   TM    UCMAUTHA,UCMAUTH3\n         BZ    TAINFO\n         CLI   0(R15),C' '\n         BE    TACONSA\n         MVC   0(7,R15),=CL7', CONS.'\n         B     TAINFO\nTACONSA  MVC   0(5,R15),=CL5'CONS.'\nTAINFO   CLI   16(R6),C' '\n         BNE   *+L'*+6\n         MVC   16(5,R6),=CL5'INFO.'\n         TM    UCMDISP1,UCMDISPA   MASTER CONSOLE?\n         BZ    NOTMS               NO.\n         MVC   34(2,R6),=CL2'MS'\n         MVC   SELCUU(L'UCBNAME),6(R6)\nNOTMS    LA    R6,SELDTL(R6)\n         BCT   R7,TESTUCM\n         B     GOASK\n         DROP  R3\nTESTUCM  BXLE  R3,R4,NEXTUCM       GET THE NEXT ENTRY.\n         CLI   SELDT+6,C' '        ANYTHING RETAINED?\n         BNE   GOASK               YES.\n         MVC   SCREEN(ERMSGL),ERMSG NO ACCEPTABLE CONSOLES ACTIVE.\n         LA    R1,FULLSCRN\n         LA    R0,FULLSCRL+ERMSGL\n         OI    SWITCH,QUIT\n         BAS   R9,STERM            SEND THE SCREEN.\n         B     ENDIT               END.\nGOASK    CLI   AUTH,LV1            IS IT COMMON AUTHORITY LEVEL?\n         BE    GETMS               YES, ONLY MASTER CONSOLE ALLOWED.\n         LA    R1,SELSCRN\n         LA    R0,SELSCRNL\n         NI    SWITCH,255-ADSDV-RLCMD\n         BAS   R9,STERM\n         OC    TXREPLY,LOTSBLNK    CONVERT TO UPPER CASE.\n         LA    R1,L'TXREPLY-1\n         LA    R15,TXREPLY\nSCANREP  CLI   0(R15),C' '         NULL INPUT?\n         BNE   GETCUU              NO.\n         LA    R15,1(R15)\n         BCT   R1,SCANREP\n         CLC   SELCUU,SELCUUP\n         BNE   GETMS\n         MVC   SELCUU,SELCUUP\n         MVC   SELWHAT,=CL10'? MISSING.'\n         B     GOASK\n         EJECT\n*------- SETUP TO COPY PAGEABLE DCM TO OUR ADDRESS SPACE.\n         SPACE 1\nGETCUU   MVC   SELCUU(L'SELCUU),0(R15)\nGETMS    L     R1,CVTPTR           BEGINNING...\n         L     R1,CVTCUCB-CVT(R1)  ...\n         USING UCM,R1\n         LM    R3,R5,UCMVEA        R3 -> TO THE FIRST UCME,\n*                                   R4 CONTAINS UCME LENGTH,\n*                                    R5 -> TO THE LAST UCME.\n         DROP  R1\n         USING UCMLIST,R3\nDIDL     L     R1,UCMUCB           SEARCH FOR SOMETHING USEFULL.\n         USING UCBDSECT,R1\n         CLC   SELCUU(L'UCBNAME),UCBNAME     IS CONSOLE THIS ONE?\n         BNE   DIDT                BRANCH IF NOT.\n         MVC   UNITXXX(L'UCBNAME),UCBNAME    DEBUGGING ...\n         DROP  R1\n         TM    UCMATR,UCMUF        IS IT ACTIVE?\n         BZ    DIDT                NO... UNUSABLE.\n         ICM   R6,B'1111',UCMXB    IS IT GRAPHICS?\n         BZ    DIDT                NO... USELESS.\n         STM   R3,R5,MOVEBSAV      SAVE SCAN REGISTERS.\n        ZEROKEY ,\n         L     R7,CONASID          GET COMMTASK ASID.\n        SSAR   R7                  SET CONSOLE AS SECONDARY.\n         L     R7,LOCRDCM          THE 'TO' ADDRESS.\n         L     R3,RDCML            LENGTH OF THE 'TO'.\n         XR    R15,R15             ZERO R15 FOR 'FROM' KEY.\nMOVERD  MVCP   0(R3,R7),0(R6),R15  MOVE IT.\n         BZ    MOVEDRD\n         AL    R6,=F'256'          BUMP 'FROM' ADDRESS BY 256.\n         AL    R7,=F'256'          BUMP 'TO' ADDRESS BY 256.\n         SL    R3,=F'256'          DECREMENT LENGTH OF MOVE LEFT.\n         B     MOVERD              GO BACK AGAIN.\nMOVEDRD  L     R5,SASID            RESTORE PREVIOUS SECONDARY.\n        SSAR   R5                  SHOULD BE AS PRIMARY.\n        RESETKEY ,\n         L     R9,LOCRDCM          ADDRESS OF COPY OF DCM.\n         USING DCMTSRT,R9\n         ICM   R6,B'1111',DCMADTRN FIND THE PAGEABLE DCM (TDCM).\n         BZ    DIDTRR              DOES IT EXIST? NO...\n         LH    R1,DCMLEN           LENGTH OF PAGEABLE DCM.\n         ST    R1,TDCML\n         LA    R1,7(R1)            ROUND UP TO 8 BYTE BOUNDARY.\n         SRL   R1,3\n         SLL   R1,3\n         ST    R1,TDCMLG\n         TM    SWTRC,PF9+TRALL     TRACE REQUESTED AND ALLOWED?\n         BNO   GETTDCM             NO.\n         DROP  R9\n         ST    R9,SNAPLST          DCM START.\n         L     R15,RDCML           DCM LENGTH.\n         ALR   R15,R9\n         BCTR  R15,0\n         ST    R15,SNAPLST+4       DCM END.\n         OI    SNAPLST+4,X'80'\n        @SNAP  2,HD2               DUMP DCM.\n         BNZ   SNPERR\nGETTDCM  L     R3,MOVEBSAV         RESTORE UCM POINTER.\n         MVC   XUCMID,UCMID        SAVE THIS CONSOLE ID.\n         DROP  R3\n         L     R1,TDCMLG           LENGTH OF PAGEABLE DCM.\n        GETMAIN R,LV=(1),SP=1\n         ST    R1,LOCTDCM          STORE AREA ADDRESS.\n        ZEROKEY ,\n         L     R7,CONASID          GET COMMTASK ASID.\n        SSAR   R7                  SET CONSOLE AS SECONDARY.\n         L     R7,LOCTDCM          THE 'TO' ADDRESS.\n         L     R3,TDCML            LENGTH OF THE 'TO'.\n         XR    R15,R15             ZERO R15 FOR 'FROM' KEY.\nMOVETD  MVCP   0(R3,R7),0(R6),R15  MOVE IT.\n         BZ    MOVEDTD\n         AL    R6,=F'256'          BUMP 'FROM' ADDRESS BY 256.\n         AL    R7,=F'256'          BUMP 'TO' ADDRESS BY 256.\n         SL    R3,=F'256'          DECREMENT LENGTH OF MOVE LEFT.\n         B     MOVETD              GO BACK AGAIN.\nMOVEDTD  L     R5,SASID            RESTORE PREVIOUS SECONDARY.\n        SSAR   R5                  SHOULD BE AS PRIMARY.\n        RESETKEY ,\n         L     R6,LOCTDCM          ADDRESS OF COPY OF TDCM.\n         USING DCMSTRT,R6\n         TM    SWTRC,PF9+TRALL     TRACE REQUESTED AND ALLOWED?\n         BNO   NOTTDCM             NO.\n         ST    R6,SNAPLST          TDCM START.\n         L     R15,TDCMLG          LENGTH OF PAGEABLE DCM.\n         BCTR  R15,0\n         ALR   R15,R6\n         ST    R15,SNAPLST+4       TDCM END.\n         OI    SNAPLST+4,X'80'\n        @SNAP  3,HD3               DUMP TDCM.\n         BNZ   SNPERR\nNOTTDCM  CLI   DCMIONDX,X'10'      IS IT A 3277?\n         BE    GETBUF              YES, BY DINGLES.\n* --->>> DEVICE 3066 (M/165) IS NO MORE SUPPORTED.\n*        CLI   DCMIONDX,X'04'      IS IT A M/165 (3066)?\n*        BE    GETBUF              YES, CAN BE SUPPORTED.\nDIDTRR   LM    R3,R5,MOVEBSAV      RESTORE SCAN REGISTERS.\nDIDT     BXLE  R3,R4,DIDL          GET THE NEXT ENTRY.\n         MVC   SELWHAT,=CL10'? INVALID.'\n         B     RESET\nGETBUF   L     R1,DCMLSCRN         POINT TO LAST BUFFER LINE.\n         AH    R1,DCMCORLN         LENGTH OF DCM LINE IN CORE.\n         L     R0,DCMASCRN         POINT TO FIRST INPUT LINE.\n         SR    R1,R0               COMPUTE AND\n         ST    R1,BUFLGTH               STORE BUFFER LENGTH.\n         LA    R1,7(R1)            ROUND UP TO 8 BYTE BOUNDARY.\n         SRL   R1,3\n         SLL   R1,3\n         ST    R1,LOCBUFL          STORE LENGTH FOR FREE.\n        GETMAIN R,LV=(1),SP=1\n         ST    R1,LOCBUF           STORE BUFFER AREA ADDRESS.\n         EJECT\n*------- A CONSOLE HAS BEEN FOUND COPY THE SCREEN\n*        AND DISPLAY IT FOR THE USER.\n*\n*              R6 -> TDCM\n         SPACE 1\nGOTONE  ZEROKEY ,\n         L     R4,CONASID          GET COMMTASK ASID.\n        SSAR   R4                  SET CONSOLE AS SECONDARY.\n         L     R2,BUFLGTH          LENGTH OF STUFF TO MOVE.\n         L     R7,DCMASCRN         POINT TO THE FIRST INPUT LINE.\n* --->>> DEVICE 3066 (M/165) IS NO MORE SUPPORTED.\n*        CLI   DCMIONDX,X'10'      IS IT A 3277?\n*        BNE   *+L'*+4             BRANCH IF NOT.\n         SL    R7,=F'6'            ADJUST OFFSET.\n         L     R8,LOCBUF           BUFFER ADDRESS.\n         XR    R15,R15             'FROM' KEY.\nMOVEBUF MVCP   0(R2,R8),0(R7),R15  MOVE IT.\n         BZ    ENDMOVE\n         AL    R7,=F'256'          BUMP 'FROM' ADDRESS.\n         AL    R8,=F'256'          BUMP 'TO' ADDRESS.\n         SL    R2,=F'256'          DECREMENT THE LENGTH FIELD.\n         B     MOVEBUF             GO BACK AND GET MORE.\nENDMOVE  L     R4,SASID            RESTORE PREVIOUS SECONDARY.\n        SSAR   R4                  SHOULD BE AS PRIMARY.\n        RESETKEY ,\n         L     R5,LOCBUF           GET BUFFER ADDRESS.\n         TM    SWTRC,PF10+TRALL    TRACE REQUESTED AND ALLOWED?\n         BNO   NOTTBUF             NO.\n         ST    R5,SNAPLST          DCM BUFFER START.\n         L     R15,BUFLGTH         LENGTH OF DCM BUFFER.\n         BCTR  R15,0\n         ALR   R15,R5\n         ST    R15,SNAPLST+4       DCM BUFFER END.\n         OI    SNAPLST+4,X'80'\n        @SNAP  10,HD10             DUMP TDCM BUFFER.\n         BNZ   SNPERR\nNOTTBUF  LH    R4,DCMCORLN         COMPUTE NO. OF LINES IN\n         XR    R2,R2                    CONSOLE BUFFER.\n         L     R3,BUFLGTH\n         DR    R2,R4\n         LA    R0,L'SCREEN-L'TABSET     DETERMINE MOVE LENGTH.\n         CLR   R4,R0\n         BNH   *+L'*+2\n         LR    R4,R0\n         BCTR  R4,0\nNEXTPAGE NI    SWITCH,255-NXTPG\n         LA    R8,SCREEN\n         LA    R9,SCREENL\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',LOTSBLNK     SET UP A BLANK.\n         MVCL  R8,R14              PAD WITH SPACES.\n         LA    R0,NDL              COMPLETE SCREEN INITIALIZATION.\n         L     R1,=A(TABSET)\n         LA    R2,SCREEN\nINITTB   MVC   0(L'TABSET,R2),0(R1)\n         LA    R1,L'TABSET(R1)\n         LA    R2,L'SCREEN(R2)\n         BCT   R0,INITTB\n         LA    R0,NDL              SCREEN LINES NUMBER.\n         LA    R2,SCREEN           SCREEN BUFFER.\n         CLI   DCMIONDX,X'10'      IS IT A 3277?\n         BE    T3277               BRANCH IF YES.\n* --->>> DEVICE 3066 (M/165) IS NO MORE SUPPORTED.\n*        CLI   DCMIONDX,X'04'      IS IT A 3066?\n*        BE    T3066               BRANCH IF YES.\n         MVC   SCREEN(WCOMSGL),WCOMSG   CANNOT OCCURS.\n         LA    R1,FULLSCRN\n         LA    R0,FULLSCRL+WCOMSGL\n         OI    SWITCH,QUIT\n         BAS   R9,STERM            SEND THE SCREEN.\n         B     ENDIT               END.\n         SPACE 1\nT3277    BAS   R9,*+L'*+6\n         MVC   L'TABSET(*-*,R2),5(R5)\n         EX    R4,0(R9)            MOVE A LINE.\n         CLC   3(L'SFINT,R5),SFINT\n         BNE   INCRSB\n         MVC   4(1,R2),SFINT+1     ADJUST ATTRIBUTE BYTE.\n* --->>> DEVICE 3066 (M/165) IS NO MORE SUPPORTED.\n*        B     INCRSB\n         SPACE 1\n*T3066   BAS   R9,*+L'*+6\n*        MVC   L'TABSET(*-*,R2),0(R5)\n*        EX    R4,0(R9)            MOVE A LINE.\n         SPACE 1\nINCRSB   CLC   L'TABSET(L'SCREEN-L'TABSET,R2),LOTSBLNK\n         BE    NOMORE              NOTHING MOVED, STOP HERE.\n         LA    R2,L'SCREEN(R2)     BUMP SCREEN BUFFER POINTER.\n         AH    R5,DCMCORLN         BUMP BUFFER POINTER.\n         BCT   R3,TESTSB           LOOP TILL BUFFER FILLED OUT.\n         B     NOMORE\nTESTSB   BCT   R0,6(R9)            LOOP TILL SCREEN BUFFER FILLED IN.\n         STM   R3,R5,MOVEBSAV      SAVE BUFFER POINTERS.\n         LA    R2,SELDT            LOOK IF REALLY ANYTHING MORE.\n         EX    R4,0(R9)\n         EX    R4,CTRLSB\n         BE    NOMORE\n         OI    SWITCH,NXTPG        MORE DATA TO BE DISPLAYED.\n         MVC   NXTPGI,NXPAGE\n         B     SENDPG\nCTRLSB   CLC   L'TABSET(*-*,R2),LOTSBLNK\nNOMORE   MVC   NXTPGI,NOPAGE\nSENDPG   MVC   MSGLINE(UNITLEN),UNITMSG MOVE IN TITLES.\n         LA    R1,FULLSCRN\n         LA    R0,SCRLEN\nSRSHW    STM   R0,R1,SVPARM\nRDSPL    OI    SWITCH,ADSDV+RLCMD\n         BAS   R9,STERM            DO IT JACK.\n         MVC   SVCRCM,LOTSBLNK\n         MVC   NOTR15,LOTSBLNK\n         MVC   RPLYNO(L'RPLYNO),LOTSBLNK\n         MVC   SETCOT(SETCOL),SETCO\n        $FS    WCC=(KBR,RMDT),MF=(I,FULLSWCC)\n        $FS    SF=NORMAL,MF=(I,WSFM)\n         OC    TXREPLY,LOTSBLNK    CONVERT TO UPPER CASE.\n         LA    R1,L'TXREPLY-1\n         LA    R15,TXREPLY\nSCANIN   CLI   0(R15),C' '         NULL INPUT?\n         BNE   GETIN               NO.\n         LA    R15,1(R15)\n         BCT   R1,SCANIN\n         TM    SWTRC,PF11+TRALL    TRACE REQUESTED AND ALLOWED?\n         BO    TRCRQ               YES.\n         TM    SWITCH,NXTPG        NO COMMAND... GO PEEK AND SHOW SIGH\n         BZ    GOTONE                   ... GOT TO ISSUE THE COMMAND.\n         LM    R3,R5,MOVEBSAV      RESTORE BUFFER POINTERS.\n         B     NEXTPAGE\nTRCRQ    OI    SWTRC,NXTPGT\n         XR    R2,R2\n         B     TSTRC\nGETIN    MVC   CMNDBUF,LOTSBLNK\n         NI    SWITCH,255-NXTPG\n         BCT   R1,*+L'*+6\n         MVC   CMNDBUF(*-*),0(R15)\n         EX    R1,*-6\n         MVC   TXREPLY,LOTSBLNK\n         MVC   LOGCMD,CMNDBUF      SAVE COMMAND AS EXECUTED.\n         CLI   CMNDBUF,C'K'        IS IT A CONTROL COMMAND?\n         BE    DONTDOIT            YES, REJECT IT.\n         SPACE 1\n*------- IF AUTHORITY IS NOT BLANK THEN DO IT.\n         SPACE 1\n         CLI   CMDALLOW,C' '\n         BNE   DOIT\n         SPACE 1\n*------- IF AUTHORITY IS BLANK AND COMMAND IS NOT\n*        A DISPLAY THEN SEE AUTHORITY TO DO IT.\n         SPACE 1\n         CLI   AUTH,LV1            IS IT COMMON AUTHORITY LEVEL?\n         BE    LOOKJ               YES.\n         CLI   CMNDBUF,C'D'        OS?\n         BE    DOIT                YES.\n         CLI   CMNDBUF,C'$'        CJS?\n         BE    LOOKD               YES.\n         CLI   CMNDBUF,C'.'        JES2?\n         BNE   LOOKJ               NO.\nLOOKD    CLI   CMNDBUF+1,C'D'      DISPLAY?\n         BE    DOIT                YES.\nLOOKJ    TM    SWITCH,J328X        ACCEPT REPLY TO JES328X ALSO?\n         BZ    DONTDOIT            NO.\n         CLC   RNJ328X(L'RNJ328X),CMNDBUF    REPLY-ID OK?\n         MVC   RNJ328X(L'RNJ328X),LOTSBLNK   CLEAR REPLY-ID.\n         BNE   DONTDOIT            NO.\n         SPACE 1\n*------- IF AUTHORITY LEVEL IS 'S' THEN DO NOT LOG.\n         SPACE 1\nDOIT     CLI   CMDALLOW,C'S'\n         BE    NOLOG\n         XR    R0,R0\n         IC    R0,XUCMID           QUEUE TO CONSOLE ID.\n        WTO    MF=(E,WTOLOG)       DO THE WTO FOR POSTERITY.\nNOLOG   ZEROKEY ,\n         XR    R0,R0\n         IC    R0,XUCMID           OUR MAN IN THE COMM TASK.\n         XR    R15,R15\n        MGCR   CMND                FIRE HIM THRU.\n         LR    R2,R15              SAVE RETURN CODE.\n        RESETKEY ,\n         B     TSTRC\nDONTDOIT XR    R2,R2\n         MVC   SVCRCM(L'SVCRCM+L'NOTR15),=CL17' COMMAND REJECTED'\nTSTRC    TM    SWTRC,TRALL         TRACE ALLOWED?\n         BZ    PRCDNM              NO.\n         TM    SWTRC,PF11\n         BZ    NODBG\n         LA    R15,SVA             TRACE WORK AREAS.\n         ST    R15,SNAPLST\n         AL    R15,=A(WRKL-1)\n         ST    R15,SNAPLST+4\n         OI    SNAPLST+4,X'80'\n        @SNAP  100,HD100           DUMP WORK AREAS.\n         BZ    NODBG\n         MVC   SVCRCM(L'SVCRCM),=CL9'SNP RC = '\n         TM    SWTRC,SNOPEN\n         BO    TRDBG\n         MVC   SVCRCM(3),=CL3'OPN'\n         B     TRDBG\nNODBG    LTR   R15,R2\n         BNZ   SDERR               NON-ZERO RC.\n         TM    SWTRC,NXTPGT\n         BZ    GOTONE\n         NI    SWTRC,255-NXTPGT\n         TM    SWITCH,NXTPG\n         BZ    GOTONE\n         LM    R3,R5,MOVEBSAV      RESTORE BUFFER POINTERS.\n         B     NEXTPAGE\n         SPACE 1\n*------- SEE IF WE ARE HERE BY A PREVIOUS MARRIAGE ...\n*              (WITH A NON-ZERO RC)\n         SPACE 1\nPRCDNM   LTR   R15,R2\n         BZ    GOTONE              FIND OUT WUTS HAPPENIN.\nSDERR    MVC   SVCRCM(L'SVCRCM),=CL9'CMD RC = '\nTRDBG    BAS   R9,CVTPRT           DO IT.\n         MVC   NOTR15,CVTA         MOVE IN RC.\n         MVC   MSGLINE(UNITLEN),UNITMSG MOVE IN ERROR LINE.\n         LA    R1,FULLSCRN\n         LA    R0,SCRLEN\n         MVC   RPLYNO(L'RPLYNO),LOTSBLNK\n         MVC   SETCOT(SETCOL),SETCO\n         NI    SWITCH,255-ADSDV-RLCMD\n         BAS   R9,STERM\n         MVC   TXREPLY,LOTSBLNK\n         MVC   SVCRCM,LOTSBLNK\n         MVC   NOTR15,LOTSBLNK\n         B     GOTONE\n         DROP  R6\n         EJECT\n*------- RESTORE/REPEAT THE LAST COMMAND TEXT.\n         SPACE 1\nLCMDR    LA    R3,L'RPTCMD\n         LA    R2,CMNDBUF+L'RPTCMD-1\n         CLI   0(R2),C' '\n         BNE   *+L'*+10\n         BCTR  R2,0\n         BCT   R3,*-10\n         B     RDSPL               BACK TO RE-DISPLAY.\n         XC    RPTCMD(RPTLEN),RPTCMD\n         LA    R0,SCRLENF(R3)\n         LA    R2,RPTCMD(R3)\n         BCT   R3,*+L'*+6\n         MVC   RPTCMD(*-*),CMNDBUF\n         EX    R3,*-6\n         MVC   0(SETCOL,R2),SETCO\n        $FS    WCC=(KBR),MF=(I,FULLSWCC)\n        $FS    SF=(MDT),MF=(I,WSFM)\n         L     R1,SVPARM+4         RESTORE ONLY R1 PARM.\n         B     SRSHW               BACK TO RE-DISPLAY.\n         EJECT\n*------- DISPLAY OPERATOR'S REPLIES PENDING.\n         SPACE 1\nDWTOR    ST    R6,SVTDCM           SAVE TDCM ADDRESS.\n         XC    SVOREPT,SVOREPT\n         OC    LOCORE,LOCORE\n         BNZ   DWTORST\n         L     R1,LGTORE\n         AL    R1,LGTWQE\n        GETMAIN R,LV=(1),SP=1\n         ST    R1,LOCORE           SAVE ORE AREA ADDRESS.\n         AL    R1,LGTORE\n         ST    R1,LOCWQE           SAVE WQE AREA ADDRESS.\nDWTORST  LA    R2,OPWTRS\n         LA    R3,OPWTRSL\n         XR    R4,R4\n         L     R5,=A(X'40000000')\n         MVCL  R2,R4\n         ICM   R2,B'1111',SVOREPT\n         BNZ   DWTORPT             ORE CHAIN CONTINUE...\n         L     R1,CVTPTR           BEGINNING...\n         L     R1,CVTCUCB-CVT(R1)\n         USING UCM,R1\n         L     R2,UCMRPYQ          ADDRESS OF FIRST ORE (REPLY-Q).\n         DROP  R1\nDWTORPT  LA    R3,OPWTRS\n         LA    R4,20\n         LTR   R2,R2\n         BZ    DWTOR2              NO ORE CHAIN.\nDWTOR1   L     R7,LOCORE           THE 'TO' ADDRESS.\n         LA    R5,ORESIZE          LENGTH OF THE 'TO'.\n        ZEROKEY ,\n         L     R6,CONASID          GET COMMTASK ASID\n        SSAR   R6                  SET CONSOLE AS SECONDARY.\n         XR    R15,R15             ZERO R15 FOR 'FROM' KEY.\nDWTORM1 MVCP   0(R5,R7),0(R2),R15  MOVE IT.\n         BZ    DWTORM2\n         AL    R2,=F'256'          BUMP 'FROM' ADDRESS BY 256.\n         AL    R7,=F'256'          BUMP 'TO' ADDRESS BY 256.\n         SL    R5,=F'256'          DECREMENT LENGTH OF MOVE LEFT.\n         B     DWTORM1             GO BACK AGAIN.\nDWTORM2  L     R6,SASID            RESTORE PREVIOUS SECONDARY.\n        SSAR   R6                  SHOULD BE AS PRIMARY.\n        RESETKEY ,\n         L     R7,LOCORE           ORE AREA ADDRESS.\n         USING OREF,R7\n         CLC   ORECBID,=CL4'ORE '  CONTROL BLOCK ID?\n         BNE   DWTOR3              NO... STOP HERE.\n         MVC   1(L'OREID,R3),OREID REPLY IDENTIFICATION.\n         ICM   R2,B'1111',ORERWQE  WQE ADDRESS.\n         BZ    DWTOR4              ANY ONE? NO... STOP HERE.\n         L     R8,LOCWQE           THE 'TO' ADDRESS.\n         LA    R5,WQETXTL-WQE      LENGTH OF THE 'TO'.\n        ZEROKEY ,\n         L     R6,CONASID          GET COMMTASK ASID\n        SSAR   R6                  SET CONSOLE AS SECONDARY.\n         XR    R15,R15             ZERO R15 FOR 'FROM' KEY.\nDWTORM3 MVCP   0(R5,R8),0(R2),R15  MOVE IT.\n         BZ    DWTORM4\n         AL    R2,=F'256'          BUMP 'FROM' ADDRESS BY 256.\n         AL    R8,=F'256'          BUMP 'TO' ADDRESS BY 256.\n         SL    R5,=F'256'          DECREMENT LENGTH OF MOVE LEFT.\n         B     DWTORM3             GO BACK AGAIN.\nDWTORM4  L     R6,SASID            RESTORE PREVIOUS SECONDARY.\n        SSAR   R6                  SHOULD BE AS PRIMARY.\n        RESETKEY ,\n         TM    SWTRC,PF8+TRALL     TRACE REQUESTED AND ALLOWED?\n         BNO   DWTORDS             NO.\n         ST    R7,SNAPLST          ORE-WQE START.\n         L     R15,LGTORE          ORE AREA LENGTH.\n         AL    R15,LGTWQE          ADD WQE AREA LENGTH.\n         ALR   R15,R7\n         ST    R15,SNAPLST+4       ORE-WQE END.\n         OI    SNAPLST+4,X'80'\n        @SNAP  20,HD20             DUMP ORE-WQE.\n         BNZ   SNPERR\nDWTORDS  L     R8,LOCWQE           WQE AREA ADDRESS.\n         USING WQE,R8\n         CLC   OREID(L'OREID),WQETXT+1  REPLY-ID MATCH?\n         BNE   DWTORID             NO, SAY IT.\n         MVC   5(L'WQEJOBNM,R3),WQEJOBNM     JOB-NAME.\n         L     R1,WQENBR           MESSAGE TEXT LENGTH.\n         S     R1,=F'4'\n         BNP   DWTORML             WRONG LENGTH.\n         CH    R1,=H'64'\n         BNH   DWTORMV\n         LA    R1,60               TRUNCATE MESSAGE TEXT.\n         LA    R15,WQETXT+62\n         CLI   0(R15),C' '\n         BE    *+L'*+6\n         BCTR  R15,0\n         BCT   R1,*-10\n         LA    R15,16(R1,R3)\n         MVC   0(3,R15),=CL3'...'\nDWTORMV  EX    R1,DWTORMT          SET MESSAGE TEXT\n         TM    SWITCH,J328X        REPLY TO JES328X ACTIVE?\n         BZ    DWTORCN             NO\n         CLC   15(8,R3),=CL8'JES328X '  JOB-NAME MATCH?\n         BNE   DWTORCN             NO\n         MVC   RNJ328X,OREID       GET REPLY-ID.\n         B     DWTORCN\nDWTORMT  MVC   15(*-*,R3),WQETXT+4 << EXECUTED >>\nDWTORID  MVC   15(25,R3),=CL25'... NO MATCH REPLY-ID ...'\n         B     DWTORCN\nDWTORML  MVC   15(25,R3),=CL25'... TEXT LENGTH ERROR ...'\nDWTORCN  ICM   R2,B'1111',ORELKP   LINKAGE POINTER.\n         DROP  R7,R8\n         BZ    DWTOR5              END OF CHAIN.\n         LA    R3,80(R3)\n         BCT   R4,DWTOR1           LOOP WITH NEXT.\n         ST    R2,SVOREPT\n         MVC   OPNXT,NXPAGE\n         B     DWTOR6\nDWTOR2   MVC   15(25,R3),=CL25'... NO OPERATOR REPLY ...'\n         B     DWTOR5\nDWTOR3   MVC   15(22,R3),=CL22'... ORE-ID MISSING ...'\n         B     DWTOR5\nDWTOR4   MVC   15(22,R3),=CL22'... NO WQE POINTER ...'\nDWTOR5   MVC   OPNXT,=CL9'---------'\nDWTOR6   MVC   OPRNM,OPRNMP\n         LA    R1,OPRPSCRN\n         LA    R0,OPRPLEN\n         NI    SWITCH,255-ADSDV-RLCMD\n         BAS   R9,STERM            WRITE SCREEN.\n         OC    TXREPLY(2),LOTSBLNK CONVERT TO UPPER CASE.\n         CLC   TXREPLY(2),LOTSBLNK ANY REPLY NUMBER ENTERED?\n         BNE   DWTORTS             YES, ANALYZE IT.\n         CLC   OPNXT,NXPAGE        ANY CONTINUE?\n         BE    DWTORST             YES.\n         B     DWTORRT             NO.\nDWTORTS  CLC   TXREPLY(2),=CL2'00' VALID INPUT REPLY NUMBER?\n         BL    DWTORST             NO, IGNORE.\n         CLC   TXREPLY(2),=CL2'99'\n         BH    DWTORST             NO, IGNORE.\n         MVC   RPLYNO(L'RPLYNO),TXREPLY DISPLAY REPLY NUMBER.\nDWTORRT  L     R6,SVTDCM           RESTORE TDCM ADDRESS.\n         LM    R0,R1,SVPARM        RESTORE R0-R1 PARM.\n         B     RDSPL               BACK TO RE-DISPLAY.\n         EJECT\n*------- TERMINATE PROCESSING.\n         SPACE 1\nENDIT    LR    R2,R15\n         TM    SWTRC,SNOPEN\n         BZ    NOSNCL\n        CLOSE  (SNAPDCB),MF=(E,SNAPCL)\nNOSNCL   ICM   R1,B'1111',LOCRDCM  DCM AREA TO BE FREED?\n         BZ    NOARR               BRANCH IF NOT.\n         L     R14,RDCMLG          LENGTH OF AREA.\n        FREEMAIN R,A=(1),LV=(R14),SP=1\n         XC    LOCRDCM,LOCRDCM     NULLIFY.\nNOARR    ICM   R1,B'1111',LOCTDCM  TDCM AREA TO BE FREED?\n         BZ    NOART               BRANCH IF NOT.\n         L     R14,TDCMLG          LENGTH OF AREA.\n        FREEMAIN R,A=(1),LV=(R14),SP=1\n         XC    LOCTDCM,LOCTDCM     NULLIFY.\nNOART    ICM   R1,B'1111',LOCBUF   TDCM BUFFER AREA TO BE FREED?\n         BZ    NOARB               BRANCH IF NOT.\n         L     R14,LOCBUFL         LENGTH OF AREA.\n        FREEMAIN R,A=(1),LV=(R14),SP=1\n         XC    LOCBUF,LOCBUF       NULLIFY.\nNOARB    ICM   R1,B'1111',LOCORE   ORE AREA TO BE FREED?\n         BZ    NOORE               BRANCH IF NOT.\n         L     R14,LGTORE          LENGTH OF ORE AREA.\n         AL    R14,LGTWQE          LENGTH OF WQE AREA.\n        FREEMAIN R,A=(1),LV=(R14),SP=1\n         XC    LOCORE,LOCORE       NULLIFY.\nNOORE   ZEROKEY ,\n        AXFRE  AXLIST=AXPL         FREE AX.\n        RESETKEY ,\n         MVC   FULLSCRN(CLEARL),CLEAR   SET CLEAR SEQUENCE.\n         TM    SWITCH,SCRRS        WAS SCREEN SIZE CHANGED?\n         BZ    ENDCL               BRANCH IF NOT.\n        STSIZE SIZELOC=SZLINE,LINELOC=SZSCRN RESTORE ORIGINAL SIZE.\n        $FS    CC=EWA,MF=(I,FULLSCRN)\nENDCL    LA    R1,FULLSCRN\n         LA    R0,CLEARL\n         ICM   R1,B'1000',TPUTFLG  INDICATE FULL SCREEN.\n        TPUT   (1),(0),R\n        STFSMODE OFF               TURN OFF FULL SCREEN MODE.\n         LR    R15,R2\n         CH    R15,=H'16'          IS RETURN CODE HIGHER THAN 16?\n         BNH   EXIT                NO, LET STAY R15.\n         EJECT\n*------- THAT'S ALL FOLKS.\n         SPACE 1\n         XR    R15,R15             ZERO OUT REGISTER 15.\nEXIT    $XRET  CC=(R15),LV=WRKL,TYPE=RENT\nSETRC    LA    R15,16              SET ERROR RETURN CODE.\n         B     EXIT\n         EJECT\n*------- LOCAL SUBROUTINE TO CONVERT R15 TO PRINTABLE HEX (EBCDIC).\n         SPACE 1\nCVTPRT   ST    R15,CVTB\n         UNPK  CVTA(9),CVTB(5)\n         NC    CVTA(8),HEXMASK\n         TR    CVTA(8),HEXTAB\n         BR    R9\n         SPACE 1\n*------- LOCAL SUBROUTINE TO WRITE SCREEN VIA TPUT,\n*        AND TO GET REPLY VIA TGET.\n         SPACE 1\nSTERM    TM    SWITCH,SCRST+SCRRS  FIRST TPUT DONE?\n         BNO   SNDWR               BRANCH IF YES.\n         ST    R1,ASCRN\n        $FS    CC=EW,MF=(I,(R1))   SET ERASE/WRITE.\nSNDWR    ICM   R1,B'1000',TPUTFLG  INDICATE FULL SCREEN.\n        TPUT   (1),(0),R\n         TM    SWITCH,SCRST+SCRRS  FIRST TPUT DONE?\n         BNO   SNDGT               BRANCH IF YES.\n         L     R1,ASCRN\n        $FS    CC=W,MF=(I,(R1))    RESTORE WRITE.\n         NI    SWITCH,255-SCRST    SET FIRST TPUT DONE.\nSNDGT    MVC   PFREPLY(L'PFREPLY),LOTSBLNK\n        TGET   PFREPLY,L'PFREPLY-1,ASIS\n         TM    SWITCH,QUIT         TERMINATING PROCESS?\n         BOR   R9                  YES.\n         CH    R15,=H'20'          TERMINAL DISCONNECTED?\n         BE    ENDIT               YES,... SPLIT.\n         CH    R15,=H'8'           ATTENTION?\n         BE    RESTART             YES,... START OVER.\n         CH    R15,=H'12'          IS INPUT LONGER THAN BUFFER?\n         BNE   SKIPCLRQ            NO.\n        TCLEARQ INPUT              FLUSH THE TRASH.\nSKIPCLRQ CLI   PFREPLY,X'F1'       PF 1 ENTERED?\n         BE    DHELP               YES,... HELP.\n         CLI   PFREPLY,X'C1'       PF 13 ENTERED (ALT. PF 1)?\n         BE    DHELP               YES,... HELP.\n         CLI   PFREPLY,X'F2'       PF 2 ENTERED?\n         BE    RESTART             YES,... START OVER.\n         CLI   PFREPLY,X'C2'       PF 14 ENTERED (ALT. PF 2)?\n         BE    RESTART             YES,... START OVER.\n         CLI   PFREPLY,X'F3'       PF 3 ENTERED?\n         BE    ENDIT               YES,... SPLIT.\n         CLI   PFREPLY,X'C3'       PF 15 ENTERED (ALT. PF 3)?\n         BE    ENDIT               YES,... SPLIT.\n         TM    SWITCH,ADSDV        WTOR'S MAY BE ACCEPTED?\n         BZ    SKWTR               NO.\n         CLI   PFREPLY,X'F5'       PF 5 ENTERED?\n         BE    DWTOR               YES,... WTOR'S.\n         CLI   PFREPLY,X'C5'       PF 17 ENTERED (ALT. PF 5)?\n         BE    DWTOR               YES,... WTOR'S.\nSKWTR    CLI   PFREPLY,X'F8'       PF 8 ENTERED?\n         BE    SWPF8               YES,... SWITCH TRACE OPTION.\n         CLI   PFREPLY,X'C8'       PF 20 ENTERED (ALT. PF 8)?\n         BE    SWPF8               YES,... SWITCH TRACE OPTION.\n         CLI   PFREPLY,X'F9'       PF 9 ENTERED?\n         BE    SWPF9               YES,... SWITCH TRACE OPTION.\n         CLI   PFREPLY,X'C9'       PF 21 ENTERED (ALT. PF 9)?\n         BE    SWPF9               YES,... SWITCH TRACE OPTION.\n         CLI   PFREPLY,X'7A'       PF 10 ENTERED?\n         BE    SWPF10              YES,... SWITCH TRACE OPTION.\n         CLI   PFREPLY,X'4A'       PF 22 ENTERED (ALT. PF 10)?\n         BE    SWPF10              YES,... SWITCH TRACE OPTION.\n         CLI   PFREPLY,X'7B'       PF 11 ENTERED?\n         BE    SWPF11              YES,... SWITCH TRACE OPTION.\n         CLI   PFREPLY,X'4B'       PF 23 ENTERED (ALT. PF 11)?\n         BE    SWPF11              YES,... SWITCH TRACE OPTION.\n         TM    SWITCH,RLCMD        LAST CMD RESTORE MAY BE ACCEPTED?\n         BZR   R9                  NO.\n         CLI   PFREPLY,X'7C'       PF 12 ENTERED?\n         BE    LCMDR               YES,... SPLIT.\n         CLI   PFREPLY,X'4C'       PF 24 ENTERED (ALT. PF 12)?\n         BE    LCMDR               YES,... SPLIT.\n         BR    R9\n         EJECT\n*------- DEBUG FACILITIES (SYSSNAP).\n         SPACE 1\nSWPF8    LA    R0,PF8\n         B     SWTRT\nSWPF9    LA    R0,PF9\n         B     SWTRT\nSWPF10   LA    R0,PF10\n         B     SWTRT\nSWPF11   LA    R0,PF11\nSWTRT    TM    SWTRC,TRALL         TRACE ALLOWED?\n         BZR   R9                  NO.\n         LR    R1,R0\n         EX    R1,TSTM             TEST TRACE OPTION (FLIP-FLOP).\n         BO    SOPON\n         EX    R1,TSOI             TRACE ON.\n         BR    R9\nSOPON    LA    R1,255\n         XR    R1,R0\n         EX    R1,TSNI             TRACE OFF.\n         BR    R9\nTSTM     TM    SWTRC,*-*           TEST OPTION.\nTSOI     OI    SWTRC,*-*           SET OPTION.\nTSNI     NI    SWTRC,*-*           CLEAR OPTION.\nDHELP    TM    SWTRC,TRALL         TRACE ALLOWED?\n         BZR   R9                  NO, ... DEBUG IS INACTIVE.\n         MVC   PF8S,=CL8'INACTIVE'\n         MVC   PF9S,=CL8'INACTIVE'\n         MVC   PF10S,=CL8'INACTIVE'\n         MVC   PF11S,=CL8'INACTIVE'\n         TM    SWTRC,PF8\n         BZ    *+L'*+6\n         MVC   PF8S,=CL8'ACTIVE'\n         TM    SWTRC,PF9\n         BZ    *+L'*+6\n         MVC   PF9S,=CL8'ACTIVE'\n         TM    SWTRC,PF10\n         BZ    *+L'*+6\n         MVC   PF10S,=CL8'ACTIVE'\n         TM    SWTRC,PF11\n         BZ    *+L'*+6\n         MVC   PF11S,=CL8'ACTIVE'\n         LA    R1,HELPSCRN\n         LA    R0,HELPLEN\n         B     STERM\n         EJECT\n*------- DIAGNOSTIC'S MESSAGES.\n         SPACE 1\n        PRINT  NOGEN\nNOTAUT  PUTIT  ' -> UNAUTHORIZED COMMAND.'\nNOTSCR  PUTIT  ' -> DIDOCS RUN ONLY ON A SCREEN TERMINAL.'\nNOTSTD  PUTIT  ' -> DIDOCS WANT TO BE SCREEN SIZED 24 * 80.'\nNOSNAP  PUTIT  ' -> DIDOCS DEBUG NEEDS FILE SYSSNAP ALLOCATED.'\n        PRINT  GEN\n         EJECT\n***********************************************************************\n*        MESSAGES.                                                    *\n***********************************************************************\n         SPACE 1\nWTOLOGP  WTO   'XXXXXXX CMD :                                          C\n                                                      ',               C\n               MCSFLAG=(REG0),MF=L\nWTOLOGL  EQU   *-WTOLOGP\n         SPACE 1\nUNITMSGP $FS   SBA=(22,1),SF=(PROT),MF=L\n         $FS   TEXT='SIMULATED OPER CONSOLE USING DIDOCS CONSOLE AT',  C\n               MF=L\nSFINT    $FS   SF=(PROT,INT),MF=L\n         $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT=(' ',9),MF=L\n         $FS   TEXT=(' ',8),MF=L\n         SPACE 1\nERMSG    $FS   SBA=(1,1),SF=(PROT),MF=L\n         $FS   TEXT='>>> NO ACCEPTABLE CONSOLES ACTIVE <<<',MF=L\n         $FS   SBA=(1,1),SF=(IC),MF=L\nERMSGL   EQU   *-ERMSG\n         SPACE 1\nSNPMSG   $FS   SBA=(1,1),SF=(PROT),MF=L\nSNPMSGO  EQU   (*-SNPMSG)+4\n         $FS   TEXT='--- SNAP RC = ',MF=L\nSNPRCL   EQU   *-SNPMSG\n         $FS   TEXT='         ---',MF=L\n         $FS   SBA=(1,1),SF=(IC),MF=L\nSNPMSGL  EQU   *-SNPMSG\n         SPACE 1\nWCOMSG   $FS   SBA=(1,1),SF=(PROT),MF=L\n         $FS   TEXT='*** UNEXPECTED ERROR ***',MF=L\n         $FS   SBA=(1,1),SF=(IC),MF=L\nWCOMSGL  EQU   *-WCOMSG\n         EJECT\n***********************************************************************\n*        CONSTANTS.                                                   *\n***********************************************************************\n         SPACE 1\nLGTORE   DC    A(((ORESIZE+7)/8)*8)\nLGTWQE   DC    A((((WQEXA-WQE)+7)/8)*8)\nCMNDP    DC    0F'0',AL2(79,0)\nLOTSBLNK DC    CL90' '\nHEXMASK  DC    XL8'0F0F0F0F0F0F0F0F'\nHEXTAB   DC    C'0123456789ABCDEF'\nBLANKTAB DC    CL256' '\n         ORG   BLANKTAB+C'\u00a2'\n         DC    C'\u00a2.<(+|',X'50'\n         ORG   BLANKTAB+C'!'\n         DC    C'!$*);\u00ac-/'\n         ORG   BLANKTAB+C','\n         DC    C',%_>?'\n         ORG   BLANKTAB+C':'\n         DC    C':#@''=\"'\n         ORG   BLANKTAB+X'81'      TRANSLATE LOWER CASE TO UPPER.\n         DC    C'ABCDEFGHI'\n         ORG   BLANKTAB+X'91'      ...\n         DC    C'JKLMNOPQR'\n         ORG   BLANKTAB+X'A2'      ...\n         DC    C'STUVWXYZ '\n         ORG   BLANKTAB+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   BLANKTAB+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   BLANKTAB+C'S'\n         DC    C'STUVWXYZ '\n         ORG   BLANKTAB+C'0'\n         DC    C'0123456789'\n         ORG\n         EJECT\n* TURN OFF FULL SCREEN (SPF), CLEAR AND RESET CURSOR TO ROW1, COL1.\n         SPACE 1\nCLEAR    $FS   CC=EW,WCC=(AL,KBR,RMDT),SBA=(24,79),MF=L\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(IC),MF=L\nCLEARL   EQU   *-CLEAR\nTPUTFLG  DC    X'03'               ITS FULL SCREEN TIME.\n         SPACE 1\nNOPAGE   DC    XL9'6D6D6D6D6D6D6D6D6D'\nNXPAGE   DC    CL9' * MORE *'\n         EJECT\n***********************************************************************\n*        SCREEN FORMATS.                                              *\n***********************************************************************\n         SPACE 1\nFULLSCRP $FS   CC=W,WCC=(KBR,RMDT),SBA=(24,80),MF=L SET BUFFER/CLEAR.\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\nFULLSCRL EQU   *-FULLSCRP\nSELSPP   $FS   SF=(PROT),TEXT='FROM THIS LIST, ',MF=L\n         $FS   TEXT='ENTER THE CONSOLE ADDRESS OF YOUR CHOICE :',MF=L\n         $FS   SF=(INT),MF=L       START OF INPUT LINE.\nSELCUUP  $FS   TEXT='CUU',MF=L     INPUT LINE : CONSOLE ADDRESS.\n         $FS   SF=(PROT,INT),MF=L\nSELWHATP $FS   TEXT=(' ',10),MF=L  RESERVED FOR DIAGNOSE.\n         $FS   SF=(PROT),MF=L\n         $FS   TEXT=(' ',6),MF=L   RESERVED.\nSELSPL   EQU   *-SELSPP\nSELT1    $FS   TEXT=(' ',4),MF=L\n         $FS   SF=(PROT,INT),TEXT='CUU',MF=L\n         $FS   SF=(PROT),TEXT=(' ID  AUTHORITY',31),MF=L\nSELT1L   EQU   *-SELT1\nSELT2    $FS   TEXT=(' ',4),MF=L\n         $FS   SF=(PROT,INT),TEXT='---',MF=L\n         $FS   SF=(PROT),TEXT=(' --  ---------------',31),MF=L\nSELT2L   EQU   *-SELT2\nSELDTP   $FS   TEXT=(' ',4),MF=L\n         $FS   SF=(PROT,INT),TEXT=(' ',3),MF=L\n         $FS   SF=(PROT),TEXT=(' ',21),MF=L\n         $FS   SF=(PROT,INT),TEXT=(' ',2),MF=L\n         $FS   SF=(PROT),TEXT=(' ',6),MF=L\nSELDTL   EQU   *-SELDTP\nSETIC    $FS   SBA=(1,1),SF=(PT,IC),MF=L\nSETICL   EQU   *-SETIC\nWSP      $FS   SBA=(21,1),SF=(PROT,INT),RA=(21,71,6D),MF=L\n         $FS   TEXT=(' ',9),MF=L   NEXT PAGE INDICATOR.\nWSPL     EQU   *-WSP\nWSI      $FS   SBA=(24,1),SF=(PROT),MF=L     LAST LINE.\nWSIL     EQU   *-WSI\nWSF      $FS   SBA=(23,1),SF=NORMAL,MF=L     START OF INPUT LINE.\n         $FS   TEXT=(' ',2),MF=L             REPLY NUMBER.\nWSFL     EQU   *-WSF\nSETCO    $FS   SBA=(1,1),SF=(PT,IC),MF=L\nSETCOL   EQU   *-SETCO\nOPRPSCRP $FS   CC=W,WCC=(KBR,RMDT),SBA=(24,80),MF=L SET BUFFER/CLEAR.\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(PROT,INT),MF=L\n         $FS   TEXT='D I D O C S - REPLIES PENDING IN SYSTEM : ',MF=L\n         DC    CL(LSYSID)' '\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(2,1),MF=L\n         $FS   TEXT='ENTER HERE THE REPLY-ID NUMBER',MF=L\n         $FS   TEXT=' YOU WANT TO USE :',MF=L\n         $FS   SF=(INT),MF=L\nOPRNMP   $FS   TEXT='NN',MF=L      INPUT LINE : REPLY NUMBER.\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(3,1),TEXT=' ID  JOB-NAME  MESSAGE ...',MF=L\n         $FS   SBA=(4,1),SF=(PROT,INT),RA=(4,4,-),MF=L\n         $FS   TEXT=(' ',2),RA=(4,14,-),MF=L\n         $FS   TEXT=(' ',2),RA=(4,71,-),MF=L\n         $FS   TEXT=(' ',9),MF=L   CONTINUE...\n         $FS   SF=(PROT),MF=L\nOPRPSCRL EQU   *-OPRPSCRP\nOPLSTP   $FS   SBA=(1,1),SF=(PT,IC),MF=L\nOPLSTPL  EQU   *-OPLSTP\n         EJECT\n***********************************************************************\n*        LITERAL POOL.                                                *\n***********************************************************************\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R10,R11,R12,R13\n         EJECT\n***********************************************************************\n*        TRACE ROUTINE (DEBUG AID / PF'S 1-8-9-10-11).                *\n*              R0      = SNAP ID NUMBER (0-255).                      *\n*              R1      = SNAP HEADER ADDRESS.                         *\n*              R9-R10  = WORK AREAS POINTERS.                         *\n*              R11     = BASE REGISTER.                               *\n*              R13     = NEW SAVE AREA.                               *\n*              R14     = LINK REGISTER.                               *\n*              R15     = ENTRY ADDRESS.                               *\n*              NOTE - THE FOLLOWING ALLOCATION IS NEEDED TO OBTAIN    *\n*                     THE SNAP DUMPS : ALLOC F(SYSSNAP) SYSOUT(A)     *\n***********************************************************************\n         SPACE 1\n         DS    0D\n         USING *,R11\nSNAP     STM   R14,R12,12(R13)     ENTRY.\n         LR    R11,R15\n         LR    R9,R13\n         USING WRKDSECT,R9,R10\n         LA    R13,SVSNAP\n         ST    R9,4(R13)\n         ST    R13,8(R9)\n         LR    R2,R0\n         ST    R1,SNAPHD\n         OI    SNAPHD,X'80'\n         LA    R3,SNAPDCB\n         USING IHADCB,R3\n         TM    SWTRC,SNOPEN        SNAP ALREADY OPENED?\n         BO    SNS                 YES.\n         MVC   SNAPDCB(SNAPLL),SNAPCS\n         OPEN  ((R3),OUTPUT),MF=(E,SNAPOP)\n         TM    DCBOFLGS,DCBOFOPN   OPENED?\n         BO    SNO                 YES.\n         LA    R15,32              SET OPEN ERROR.\n         B     SNC\nSNO      OI    SWTRC,SNOPEN\nSNS      SNAP  DCB=(R3),TCB='S',ID=(R2),LIST=SNAPLST,                  C\n               STRHDR=SNAPHD,MF=(E,SNAPLIST)\n         LTR   R15,R15             ALL OK?\n         BZ    SNR                 YES.\nSNC      NI    SWTRC,255-TRALL     KILL ALLOWABLE.\nSNR      L     R13,4(R13)          EXIT.\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         MVI   12(R13),X'FF'\n         BR    R14\n         SPACE 1\n         DROP  R3,R9,R10,R11\n         SPACE 1\n         LTORG ,                   LITERAL POOL.\n         EJECT\n***********************************************************************\n*        SKELETONS AND CONSTANTS.                                     *\n***********************************************************************\n         SPACE 1\n         PRINT NOGEN\nSNAPCS   DCB   DSORG=PS,RECFM=VBA,MACRF=(W),BLKSIZE=1632,LRECL=125,    C\n               DDNAME=SYSSNAP\n         OPEN  (*-*),MF=L\n         CLOSE (*-*),MF=L\n         SNAP  MF=L\nSNAPLL   EQU   *-SNAPCS\n         PRINT GEN\n         SPACE 1\nHD1      DC    AL1(L'HD1T)\nHD1T     DC    C'D I D O C S - DUMP OF UCME.'\nHD2      DC    AL1(L'HD2T)\nHD2T     DC    C'D I D O C S - DUMP OF DCM.'\nHD3      DC    AL1(L'HD3T)\nHD3T     DC    C'D I D O C S - DUMP OF TDCM.'\nHD10     DC    AL1(L'HD10T)\nHD10T    DC    C'D I D O C S - DUMP OF TDCM BUFFER.'\nHD20     DC    AL1(L'HD20T)\nHD20T    DC    C'D I D O C S - DUMP OF ORE-WQE.'\nHD100    DC    AL1(L'HD100T)\nHD100T   DC    C'D I D O C S - DUMP OF WORK AREAS.'\n         EJECT\n***********************************************************************\n*        VARIABLES.                                                   *\n***********************************************************************\n         SPACE 1\nTABSET   DS    0XL5\n         $FS   SBA=(1,1),SF=(PROT),MF=L\n         $FS   SBA=(2,1),SF=(PROT),MF=L\n         $FS   SBA=(3,1),SF=(PROT),MF=L\n         $FS   SBA=(4,1),SF=(PROT),MF=L\n         $FS   SBA=(5,1),SF=(PROT),MF=L\n         $FS   SBA=(6,1),SF=(PROT),MF=L\n         $FS   SBA=(7,1),SF=(PROT),MF=L\n         $FS   SBA=(8,1),SF=(PROT),MF=L\n         $FS   SBA=(9,1),SF=(PROT),MF=L\n         $FS   SBA=(10,1),SF=(PROT),MF=L\n         $FS   SBA=(11,1),SF=(PROT),MF=L\n         $FS   SBA=(12,1),SF=(PROT),MF=L\n         $FS   SBA=(13,1),SF=(PROT),MF=L\n         $FS   SBA=(14,1),SF=(PROT),MF=L\n         $FS   SBA=(15,1),SF=(PROT),MF=L\n         $FS   SBA=(16,1),SF=(PROT),MF=L\n         $FS   SBA=(17,1),SF=(PROT),MF=L\n         $FS   SBA=(18,1),SF=(PROT),MF=L\n         $FS   SBA=(19,1),SF=(PROT),MF=L\n         $FS   SBA=(20,1),SF=(PROT),MF=L\n         SPACE 1\nFAKEWARN $FS   TEXT='PRESS',MF=L\n         $FS   SF=(PROT,INT),TEXT='PF-3',MF=L\n         $FS   SF=(PROT),TEXT='TO TERMINATE DIDOCS,',MF=L\n         $FS   SF=(PROT,INT),TEXT='PF-2',MF=L\n         $FS   SF=(PROT),MF=L\nFAKEWRNR EQU   *-FAKEWARN\n         $FS   TEXT='TO RESTART.                SYSTEM :',MF=L\n         $FS   SF=(PROT,INT),MF=L\n         DC    CL(LSYSID)' '\nLSF      $FS   SF=(PROT),MF=L\nFAKEWRNL EQU   *-FAKEWARN\n         SPACE 1\nFKWARN   $FS   TEXT='KEYS',MF=L\n         $FS   SF=(PROT,INT),TEXT='PF-3',MF=L\n         $FS   SF=(PROT),TEXT=': END,',MF=L\n         $FS   SF=(PROT,INT),TEXT='PF-12',MF=L\n         $FS   SF=(PROT),TEXT=': L-CMD,',MF=L\n         $FS   SF=(PROT,INT),TEXT='PF-5',MF=L\n         $FS   SF=(PROT),TEXT=': WTOR-S,',MF=L\n         $FS   SF=(PROT,INT),TEXT='PF-2',MF=L\n         $FS   SF=(PROT),MF=L\nFKWRNR   EQU   *-FKWARN\n         $FS   TEXT=': RESTART.  SYSTEM :',MF=L\n         $FS   SF=(PROT,INT),MF=L\n         DC    CL(LSYSID)' '\n         $FS   SF=(PROT),MF=L\nFKWRNL   EQU   *-FKWARN\n         SPACE 1\nHELPSCRP $FS   CC=W,WCC=(KBR,RMDT),SBA=(24,80),MF=L SET BUFFER/CLEAR.\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(2,1),SF=(PROT,INT),MF=L\n         $FS   TEXT='D I D O C S - DEBUG AID SERVICE :',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(5,21),TEXT='PF 1 OR 13 :',MF=L\n         $FS   SF=(PROT,INT),TEXT='TRACE STATUS',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(6,21),TEXT='PF 8 OR 20 :',MF=L\n         $FS   SF=(PROT,INT),MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   SF=(PROT),TEXT='(DUMP ORE-WQE)',MF=L\n         $FS   SBA=(7,21),TEXT='PF 9 OR 21 :',MF=L\n         $FS   SF=(PROT,INT),MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   SF=(PROT),TEXT='(DUMP UCME-DCM-TDCM)',MF=L\n         $FS   SBA=(8,20),TEXT='PF 10 OR 22 :',MF=L\n         $FS   SF=(PROT,INT),MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   SF=(PROT),TEXT='(DUMP TDCM BUFFER)',MF=L\n         $FS   SBA=(9,20),TEXT='PF 11 OR 23 :',MF=L\n         $FS   SF=(PROT,INT),MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   SF=(PROT),TEXT='(DUMP WORK AREAS)',MF=L\n         $FS   SBA=(12,21),TEXT='PF 2 OR 14 :',MF=L\n         $FS   SF=(PROT,INT),TEXT='SELECT CONSOLE',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(13,21),TEXT='PF 3 OR 15 :',MF=L\n         $FS   SF=(PROT,INT),TEXT='TERMINATE DIDOCS',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(14,21),TEXT='PF 5 OR 17 :',MF=L\n         $FS   SF=(PROT,INT),TEXT='PENDING REPLIES',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(15,20),TEXT='PF 12 OR 24 :',MF=L\n         $FS   SF=(PROT,INT),TEXT='LAST COMMAND',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(16,27),TEXT='PA 1 :',MF=L\n         $FS   SF=(PROT,INT),TEXT='INTERRUPT DIDOCS',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(1,1),SF=(IC),MF=L\n         EJECT\n***********************************************************************\n*        PARSE CONTROL LIST.                                          *\n***********************************************************************\n         SPACE 1\n         PRINT NOGEN\nPARMLST IKJPARM\nOPMODE  IKJKEYWD\n        IKJNAME 'SYSTEM',ALIAS=('S')\n        IKJNAME 'CASPER',ALIAS=('GHOST')\n        IKJNAME 'DEBUG',ALIAS=('D')\n        IKJENDP\n         PRINT GEN\n         EJECT\n***********************************************************************\n*        DATA - WORK AREAS DESCRIPTION.                               *\n***********************************************************************\n         SPACE 1\nWRKDSECT DSECT                     WORK AREAS DESCRIPTION.\n         SPACE 1\nSVA      DS    18F                 SAVE AREA.\nSVSNAP   DS    18F                 SNAP SAVE AREA.\nCVTA     DC    D'0',X'0'           PLUS A GARBAGE BYTE.\nXUCMID   DC    X'0'\nCMDALLOW DC    C' '\nAUTH     DC    X'0'\n         SPACE 1\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(*-*)\nREQAUTL  EQU   *-REQAUT\n         SPACE 1\nMOVEBSAV DS    3F                  REGISTERS SAVE AREA.\nCVTB     DC    F'0'\nSVTDCM   DC    F'0'\nSVPARM   DC    2F'0'\nSVOREPT  DC    F'0'\nSZLINE   DC    F'0'                LINE SIZE (LINE LENGTH).\nSZSCRN   DC    F'0'                SCREEN SIZE (NUMBER OF LINES).\nASCRN    DC    F'0'                SCREEN IMAGE ADDRESS.\nSASID    DS    F                   PREVIOUS SECONDARY ASID.\nCONASID  DS    F                   'CONSOLE' ASID (COMMTASK).\nAXPL     DC    H'1',H'0'           AX PARM LIST.\n         SPACE 1\n        $TEW$WA\n         SPACE 1\nLOCRDCM  DC    A(0)                ADDRESS OF RESIDENT DCM AREA.\nRDCML    DC    A(0)                LENGTH OF RESIDENT DCM AREA.\nRDCMLG   DC    A(0)                LENGTH OF RESIDENT DCM IN CORE.\nLOCTDCM  DC    A(0)                ADDRESS OF PAGEABLE DCM AREA.\nTDCML    DC    A(0)                LENGTH OF PAGEABLE DCM AREA.\nTDCMLG   DC    A(0)                LENGTH OF PAGEABLE DCM IN CORE.\nLOCBUF   DC    A(0)                ADDRESS OF DCM BUFFER AREA.\nLOCBUFL  DC    F'0'                LENGTH OF DCM BUFFER AREA.\nBUFLGTH  DC    F'0'                LENGTH OF DCM BUFFER IN CORE.\nLOCORE   DC    A(0)                ADDRESS OF ORE AREA.\nLOCWQE   DC    A(0)                ADDRESS OF WQE AREA.\n         SPACE 1\n         PRINT NOGEN\nWTOLOG   WTO   'XXXXXXX CMD :                                          C\n                                                      ',               C\n               MCSFLAG=(REG0),MF=L\n         PRINT GEN\n         ORG   WTOLOG+4\nLOGUSER  DS    CL7\n         ORG   WTOLOG+18\nLOGCMD   DS    CL80\nRNJ328X  DS    CL2\n         ORG\n         SPACE 1\n         PRINT NOGEN\nSNAPDCB  DCB   DSORG=PS,RECFM=VBA,MACRF=(W),BLKSIZE=1632,LRECL=125,    C\n               DDNAME=SYSSNAP\nSNAPOP   OPEN  (*-*),MF=L\nSNAPCL   CLOSE (*-*),MF=L\nSNAPLIST SNAP  MF=L\n         PRINT GEN\nSNAPLST  DS    2F\nSNAPHD   DS    F\n         SPACE 1\nCMND     DC    0F'0',AL2(79,0)     SEND COMMAND AREA.\nCMNDBUF  DC    CL80' '\nPFREPLY  DS    0CL86               AREA TO HOLD TGET REPLY.\n         DC    CL6' '              AID + JUNK.\nTXREPLY  DC    CL80' '             REAL REPLY.\n         SPACE 1\nUNITMSG  $FS   SBA=(22,1),SF=(PROT),MF=L\n         $FS   TEXT='SIMULATED OPER CONSOLE USING DIDOCS CONSOLE AT',  C\n               MF=L\n         $FS   SF=(PROT,INT),MF=L\nUNITXXX  $FS   TEXT=(' ',4),MF=L\nSVCRCM   $FS   TEXT=(' ',9),MF=L\nNOTR15   $FS   TEXT=(' ',8),MF=L\nUNITLEN  EQU   *-UNITMSG\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        CONSOLES SELECTION PANEL.                                    *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nSELSCRN  $FS   CC=W,WCC=(KBR,RMDT),SBA=(24,80),MF=L SET BUFFER/CLEAR.\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\nSELT1A   DC    CL(SELT1L)' '\nSELT1B   DC    CL(SELT1L)' '\nSELT2A   DC    CL(SELT2L)' '\nSELT2B   DC    CL(SELT2L)' '\nSELDT    DC    40CL(SELDTL)' '     DATA LINES.\nSELDTN   EQU   ((*-SELDT)/SELDTL)\nSELSP    $FS   SF=(PROT),TEXT='FROM THIS LIST, ',MF=L\n         $FS   TEXT='ENTER THE CONSOLE ADDRESS OF YOUR CHOICE :',MF=L\n         $FS   SF=(INT),MF=L       START OF INPUT LINE.\nSELCUU   $FS   TEXT='CUU',MF=L     INPUT LINE : CONSOLE ADDRESS.\n         $FS   SF=(PROT,INT),MF=L\nSELWHAT  $FS   TEXT=(' ',10),MF=L  RESERVED FOR DIAGNOSE.\n         $FS   SF=(PROT),MF=L\n         $FS   TEXT=(' ',6),MF=L   RESERVED.\nINFLINE  DC    CL(FAKEWRNL)' '     INFORMATIONAL.\nSETICT   $FS   SBA=(1,1),SF=(PT,IC),MF=L\nSELSCRNL EQU   *-SELSCRN\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        CONSOLE DISPLAY PANEL.                                       *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nFULLSCRN $FS   CC=W,MF=L           SET BUFFER/CLEAR.\nFULLSWCC $FS   WCC=(KBR,RMDT),SBA=(24,80),MF=L\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\nSCREEN   DC    20CL84' '           DATA LINES.\nSCREENL  EQU   *-SCREEN            DATA LINES TOTAL LENGTH.\nNDL      EQU   (SCREENL)/L'SCREEN  NUMBER OF LINES.\nWSPT     $FS   SBA=(21,1),SF=(PROT,INT),RA=(21,71,6D),MF=L\nNXTPGI   $FS   TEXT=(' ',9),MF=L   NEXT PAGE INDICATOR.\nMSGLINE  DC    CL80' '\nWSIT     $FS   SBA=(24,1),SF=(PROT),MF=L     LAST LINE.\nINFOLINE DC    CL(FKWRNL)' '       INFORMATIONAL.\nWSFT     $FS   SBA=(23,1),MF=L     START OF INPUT LINE.\nWSFM     $FS   SF=NORMAL,MF=L\nRPLYNO   $FS   TEXT=(' ',2),MF=L   REPLY NUMBER.\nSETCOT   $FS   SBA=(1,1),SF=(PT,IC),MF=L\nSCRLEN   EQU   *-FULLSCRN\n         ORG   RPLYNO\nRPTCMD   DC    CL79' '             REPEAT COMMAND.\n         DC    XL(SETCOL)'0'\nRPTLEN   EQU   *-RPTCMD\nSCRLENF  EQU   SCRLEN-L'RPLYNO\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        OPERATORS REPLIES PANEL.                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nOPRPSCRN $FS   CC=W,WCC=(KBR,RMDT),SBA=(24,80),MF=L SET BUFFER/CLEAR.\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(PROT,INT),MF=L\n         $FS   TEXT='D I D O C S - REPLIES PENDING IN SYSTEM : ',MF=L\nOPSYS    DC    CL(LSYSID)' '\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(2,1),MF=L\n         $FS   TEXT='ENTER HERE THE REPLY-ID NUMBER',MF=L\n         $FS   TEXT=' YOU WANT TO USE :',MF=L\n         $FS   SF=(INT),MF=L\nOPRNM    $FS   TEXT='NN',MF=L      INPUT LINE : REPLY NUMBER.\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(3,1),TEXT=' ID  JOB-NAME  MESSAGE ...',MF=L\n         $FS   SBA=(4,1),SF=(PROT,INT),RA=(4,4,-),MF=L\n         $FS   TEXT=(' ',2),RA=(4,14,-),MF=L\n         $FS   TEXT=(' ',2),RA=(4,71,-),MF=L\nOPNXT    $FS   TEXT=(' ',9),MF=L   CONTINUE...\n         $FS   SF=(PROT),MF=L\nOPWTRS   DC    20CL80' '           WTOR'S INFO LINES.\nOPWTRSL  EQU   *-OPWTRS\nOPLST    $FS   SBA=(1,1),SF=(PT,IC),MF=L\nOPRPLEN  EQU   *-OPRPSCRN\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        DEBUG HELP PANEL.                                            *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nHELPSCRN $FS   CC=W,WCC=(KBR,RMDT),SBA=(24,80),MF=L SET BUFFER/CLEAR.\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(2,1),SF=(PROT,INT),MF=L\n         $FS   TEXT='D I D O C S - DEBUG AID SERVICE :',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(5,21),TEXT='PF 1 OR 13 :',MF=L\n         $FS   SF=(PROT,INT),TEXT='TRACE STATUS',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(6,21),TEXT='PF 8 OR 20 :',MF=L\n         $FS   SF=(PROT,INT),MF=L\nPF8S     $FS   TEXT=(' ',8),MF=L\n         $FS   SF=(PROT),TEXT='(DUMP ORE-WQE)',MF=L\n         $FS   SBA=(7,21),TEXT='PF 9 OR 21 :',MF=L\n         $FS   SF=(PROT,INT),MF=L\nPF9S     $FS   TEXT=(' ',8),MF=L\n         $FS   SF=(PROT),TEXT='(DUMP UCME-DCM-TDCM)',MF=L\n         $FS   SBA=(8,20),TEXT='PF 10 OR 22 :',MF=L\n         $FS   SF=(PROT,INT),MF=L\nPF10S    $FS   TEXT=(' ',8),MF=L\n         $FS   SF=(PROT),TEXT='(DUMP TDCM BUFFER)',MF=L\n         $FS   SBA=(9,20),TEXT='PF 11 OR 23 :',MF=L\n         $FS   SF=(PROT,INT),MF=L\nPF11S    $FS   TEXT=(' ',8),MF=L\n         $FS   SF=(PROT),TEXT='(DUMP WORK AREAS)',MF=L\n         $FS   SBA=(12,21),TEXT='PF 2 OR 14 :',MF=L\n         $FS   SF=(PROT,INT),TEXT='SELECT CONSOLE',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(13,21),TEXT='PF 3 OR 15 :',MF=L\n         $FS   SF=(PROT,INT),TEXT='TERMINATE DIDOCS',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(14,21),TEXT='PF 5 OR 17 :',MF=L\n         $FS   SF=(PROT,INT),TEXT='PENDING REPLIES',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(15,20),TEXT='PF 12 OR 24 :',MF=L\n         $FS   SF=(PROT,INT),TEXT='LAST COMMAND',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(16,27),TEXT='PA 1 :',MF=L\n         $FS   SF=(PROT,INT),TEXT='INTERRUPT DIDOCS',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(1,1),SF=(IC),MF=L\nHELPLEN  EQU   *-HELPSCRN\n         EJECT\n*------- PROCESSING SWITCHES.\n         SPACE 1\nSWITCH   DC    X'0'\nNXTPG    EQU   X'01'               MORE DATA TO BE DISPLAYED.\nSCRST    EQU   X'02'               SCREEN SIZE TO BE SET.\nSCRRS    EQU   X'04'               SCREEN SIZE TO BE RESET.\nQUIT     EQU   X'08'               TERMINATING PROCESS.\nADSDV    EQU   X'10'               ACCEPT WTOR REQUEST.\nJ328X    EQU   X'20'               ACCEPT REPLY TO JES328X.\nRLCMD    EQU   X'40'               ACCEPT REPEAT LAST COMMAND.\n         SPACE 1\nSWTRC    DC    X'0'\nTRALL    EQU   X'01'               TRACE ALLOWED.\nSNOPEN   EQU   X'02'               SNAP OPENED.\nNXTPGT   EQU   X'04'               NEXT PAGE PROCESS.\nPF8      EQU   X'10'               PF8 SNAP ACTIVE.\nPF9      EQU   X'20'               PF9 SNAP ACTIVE.\nPF10     EQU   X'40'               PF10 SNAP ACTIVE.\nPF11     EQU   X'80'               PF11 SNAP ACTIVE.\n         SPACE 1\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK AREAS LENGTH.\n         EJECT\n*------- DSECTS DEFINITIONS.\n         SPACE 1\n        PRINT  NOGEN\n        IEESMCA\n        IEECUCM ,                  MVS UCM DEFINITION.\nDCMTSRT  DSECT DCMTSPTR                                            -EU-\n        IEECRDCM DSECT=YES         MVS RESIDENT DCM DEFINITION (RDCM).\nDCMREND  DS    0C                  END OF DCM                      -EU-\nDCMSTRT  DSECT DCMSTPTR                                            -EU-\n        IEECDCM ,                  MVS TRANSIENT DCM DEFINITION (TDCM).\nUCBDSECT DSECT\n        IEFUCBOB\n        IHAORE ,                                                   -EU-\n        IHAWQE ,                                                   -EU-\n        DCBD   DSORG=PS,DEVD=DA\n        $TEW$DS ,\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DIDOCS$": {"ttr": 3336, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x942o\\x00\\x942o\\x16'\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-22T00:00:00", "modifydate": "1994-11-22T16:27:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "SYSPAJA"}, "text": "//DIDOCS   JOB (........),'INSTALL  - DIDOCS -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=6\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* NOTE - THE ASSEMBLY OF DIDOCS CONTAINS THE FOLLOWING STATEMENT :  *\n//*           COPY  DIDOCSM                                           *\n//*        WHICH IS AN UPDATED VERSION OF THE MACRO IEECRDCM MISSING  *\n//*        IN THE GENERATED SYS1.MODGEN (MVS/XA 2.2.3).               *\n//*        THAT'S ALL FOLKS - GOOD LUCK                               *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ4AS3,OPT=',RENT',MBR=DIDOCS\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   DIDOCS\n  SETCODE AC(1)\n  NAME    DIDOCS(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DIDOCS@": {"ttr": 3338, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\\x19\\x8f\\x00\\x86\\x19\\x8f\\x17&\\x00\"\\x00\"\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-07-17T00:00:00", "modifydate": "1986-07-17T17:26:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SYSPAJA"}, "text": "1   31/01/86\n                                                      DIDOCS    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *        D   I   D   O   C   S        * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    For TSO oper priviledge users, simulate an OS 3277\n  ---------    console at their TSO tube by peeking at the DIDOCS\n               console message buffers in CSA. DIDOCS accepts a reply\n               from the user. Non-blank replies are formatted into a\n               command and issued via svc 34, blank replies just cause\n               the screen to be updated. Any commands issued via svc\n               34 are also logged via a WTO so that your auditors and\n               operations know what is going on.\n\n  Command :    Syntax : DIDOCS OPMODE\n  ---------\n               OPMODE : if omitted, default is display commands,\n                               with log, but depending on user\n                               authority level.\n                        SYSTEM or S : all commands (OS, JES2, CJS,\n                               ...), with log, dut depending on\n                               user authority level.\n                        CASPER or GHOST : all commands with no log.\n                        DEBUG or D : debug aid (PFK's 1-8-9-10-11).\n\n               Exit from DIDOCS is via PFK-3 or PFK-12.\n               Any existing active graphic operator's console may be\n               selected at user TSO CRT (PFK-2).\n               Operator's replies pending information in the system\n               are displayed at user TSO CRT (PFK-5).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DIDOCSM": {"ttr": 3340, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88)\\x1f\\x00\\x88)\\x1f\\x18A\\x01i\\x01i\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-10-17T00:00:00", "modifydate": "1988-10-17T18:41:00", "lines": 361, "newlines": 361, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n         IEECRDCM    &A=,&KEY=,&DSECT=                         @G860P2G\n         SPACE 1                                               @G64UPSS\n***********************************************************************\n*                                                              @G64UPSS\n*          IEECRDCM - RESIDENT DISPLAY CONTROL MODULE          @G64UPSS\n*                                                              @G64UPSS\n* COPYRIGHT  -                                                     @D1C\n*               THIS PRODUCT CONTAINS RESTRICTED MATERIALS OF IBM.\n*               5740-XC6 COPYRIGHT IBM CORPORATION 1980, 1984.\n*\n* STATUS     - OS/VS2 JBB2125                                      @D1C\n*                                                              @G64UPSS\n* INVOCATION - SPECIFY: IEECRDCM A=,KEY=,DSECT=                @G860P2G\n*              WHERE:                                          @G64UPSS\n*\n*                A=     NUMBER OF DISPLAY AREAS AND THE        @G64UPSS\n*                       LENGTHS OF EACH.                       @G64UPSS\n*                       EXAMPLE: A=(6,4) WHERE TWO AREAS ARE   @G64UPSS\n*                       BEING DEFINED. THE FIRST CONSISTS OF   @G64UPSS\n*                       6 LINES; THE SECOND OF 4 LINES.        @G64UPSS\n*\n*                KEY=   THE NUMBER OF PROGRAM FUNCTION KEYS    @G860P2G\n*                       DEFINED FOR THIS DEVICE.               @G860P2G\n*\n*                DSECT= Y ONLY ONE SACB WILL BE GENERATED.     @G64UPSS\n*                       ENTRY STATEMENTS WILL NOT BE           @G64UPSS\n*                       GENERATED. DO NOT SPECIFY DSECT= IF    @G64UPSS\n*                       DSECT=Y IS NOT WANTED.                 @G64UPSS\n*                                                              @G64UPSS\n* FUNCTION   - THIS MACRO IS INVOKED AT SYSGEN TO BUILD AN     @G64UPSS\n*              RDCM WITH SACBS IN THE NUCLEUS. THE MAPPING     @G64UPSS\n*              MACRO FOR THIS CONTROL BLOCK IS IEERDCM.        @G64UPSS\n*                                                              @G64UPSS\n* CHANGE-ACTIVITY -                                            @G64UPSS\n*              G64DPSS, G64UPSS, G811P2G, ZMD0033,             @ZMD0033\n* $L1=XMCTASK,  JBB1326,  801031,  PD2I:  ADDED DCMAASID\n* $L2=CONCOLOR, JBB1326,  801205,  PDSS:  BASE COLOR SUPPORT\n* $P1=PMM0107,  JBB1326,  810402,  PD2I:  BASE ASCB\n*              G860P2G - SUPPORT A PFK AREA FOR EACH CONSOLE   @G860P2G\n*              ZMC0190 - DEFINE FIELD DCMMSGSV                 @ZMC0190\n*              G860PSS - EMBEDDED LABEL LINE SUPPORT           @G860PSS\n* $T1=OZ72482,  JBB2110,  830601,  PD2L:  SUPPORT 3279-2C CONSOLE\n* $D1=DCR43,    JBB2125,  821225,  PDSS:  3290 SUPPORT\n*\n***********************************************************************\n.*                                                             @G811P2G\n.* OPERATION = THIS MACRO DEFINES THE RDCM FIELDS FOR A        @G860P2G\n.*             CONSOLE.  IT ALSO BUILDS AN SACB FOR EACH       @G860P2G\n.*             DISPLAY AREA DEFINED.                           @G811P2G\n.*                                                             @G811P2G\n.* MODULE TYPE = MACRO                                         @G811P2G\n.*                                                             @G811P2G\n.*   PROCESSOR = OS/VS2 ASSEMBLER                              @G811P2G\n.*                                                             @G811P2G\n.*   MODULE SIZE = N/A                                         @G811P2G\n.*                                                             @G811P2G\n.*   ATTRIBUTES = N/A                                          @G811P2G\n.*                                                             @G811P2G\n.* ENTRY POINT = N/A                                           @G811P2G\n.*                                                             @G811P2G\n.* INPUT = SEE 'INVOCATION' ABOVE FOR A DESCRIPTION OF THE     @G811P2G\n.*         INPUT PARAMETERS.                                   @G811P2G\n.*                                                             @G811P2G\n.* OUTPUT = AN RDCM IS BUILT.  ONE SACB IS BUILT FOR EACH      @G811P2G\n.*          DISPLAY AREA DEFINED BY INPUT.                     @G811P2G\n.*                                                             @G811P2G\n.* EXIT - NORMAL = N/A                                         @G811P2G\n.*                                                             @G811P2G\n.* EXIT - ERROR = N/A                                          @G811P2G\n.*                                                             @G811P2G\n.* EXTERNAL REFERENCES = NONE                                  @G811P2G\n.*                                                             @G811P2G\n.* TABLES = &TABLE   - A TABLE OF SCREEN AREA ID'S             @G811P2G\n.*                                                             @G811P2G\n.* VARIABLES = THE FOLLOWING LOCAL VARIABLES ARE USED:         @G811P2G\n.*                                                             @G811P2G\n.*       NAME     FUNCTION                                     @G811P2G\n.*       ----     --------                                     @G811P2G\n.*       &C       THE ID OF THE AREA CURRENTLY BEING DEFINED   @G811P2G\n.*       &D       THE LENGTH OF THE AREA CURRENTLY BEING       @G811P2G\n.*                DEFINED                                      @G811P2G\n.*       &E       INDEX INTO AREA DEFINITION PARAMETER (&A)    @G811P2G\n.*       &F       THE ID OF THE TOPMOST AREA ON THE CONSOLE    @G811P2G\n.*       &N       INDEX INTO THE AREA ID TABLE (&TABLE)        @G811P2G\n.*       &PFKLEN  THE LENGTH OF THE PFK BUFFER                 @G860P2G\n.*       &S       THE TOTAL NUMBER OF SCREEN AREAS DEFINED     @G811P2G\n.*                FOR THIS DEVICE                              @G811P2G\n.*                                                             @G811P2G\n.* MACROS = NONE                                               @G811P2G\n.*                                                             @G811P2G\n.* MESSAGES = NONE                                             @G860P2G\n.*                                                             @G811P2G\n.* COMPLETION CODES = N/A                                      @G811P2G\n.*                                                             @G811P2G\n.**********************************************************************\n.*C (.NOTOPAR, .ZZZ)                                           @G811P2G\n.*A (.DDD)                                                     @G811P2G\n.*C (.FFF)                                                     @ZMD0033\n.*A (DCMBCOLR,DCMECOLR) BASE COLOR SUPPORT                         @L2A\n.*C (DCMAASCB)                                                     @P1A\n.*A (DCMRVRID, DCMRSP21, DCMRVERN, DCMPFKEY, DCMPFKWK)         @G860P2G\n.*A (DCMPFKIN, DCMPFKBD, DCMRCBID, DCMPFKSZ, DCMPFKBF)         @G860P2G\n.*A (DCMRSV02, &PFKLEN)                                        @G860P2G\n.*D (DCMRMS, DCMADRMS, AFTER DCMSUBAD)                         @G860P2G\n.*A (DCMMSGSV)                                                 @ZMC0190\n.*D (DCMAPAD)                                                  @G860PSS\n.*A (DCMAELLF, DCMADLF, DCMANLAB)                              @G860PSS\n.* COMMENT AND PROLOGUE CHANGES ONLY                               @T1A\n.*A (DCMFAIL)                                                      @D1A\n.*A (DCMSPRPQ,DCMEXTDS,DCM14IAD)                                   @D1A\n.*A (DCMIMGLT)                                                     @D1A\n         EJECT ,                                               @G811P2G\n         LCLA  &N,&S,&E,&PFKLEN                                @G860P2G\n         LCLC  &TABLE,&C,&D,&F                                 @G860P2G\n.**********************************************************************\n.*                                                            @G811P2G*\n.*       SET VARIABLES TO GENERATE ONE AREA IF THE RDCM IS    @G811P2G*\n.*       BEING MAPPED                                         @G811P2G*\n.*                                                            @G811P2G*\n.**********************************************************************\n         AIF   ('&DSECT' EQ '').NODEC\n&S       SETA   1\n&E       SETA   1\n&D       SETC   '1'\n         AGO   .POS\n.NODEC   ANOP\n.**********************************************************************\n.*                                                            @G811P2G*\n.*       SET AREA PARAMETERS IF THE RDCM IS BEING CREATED     @G811P2G*\n.*       AND AREAS ARE DEFINED                                @G811P2G*\n.*                                                            @G811P2G*\n.**********************************************************************\n         AIF   ('&A'  EQ  '').NEG\n&S       SETA    N'&A\n&E       SETA  1\n&D       SETC  '&A(&E)'\n         AGO   .POS\n.NEG     ANOP\n&S       SETA  0\n.POS     ANOP\n&N       SETA  1\n&F       SETC  '0'\n&TABLE   SETC  'ABCDEFGHIJK'\n         AIF   (&S  EQ  0).NUN\n&C       SETC  '&TABLE'(&N,1)           COMPUTE AREA ID\n&F       SETC  '&TABLE'(&S,1)\n.NUN     ANOP\n.**********************************************************************\n.*                                                            @G811P2G*\n.*       DEFINE THE FIRST PORTION OF THE RDCM                 @G811P2G*\n.*                                                            @G811P2G*\n.**********************************************************************\nDCMADTRN DC    F'0'                POINTER TO PAGEABLE DCM\nDCMRSP21 EQU   1                   OS/VS2 HBB2102              @G860P2G\nDCMRSP22 EQU   2                   OS/VS2 JBB2220                  -EU-\nDCMRVRID EQU   DCMRSP22            CURRENT VERSION                 -EU-\nDCMRVERN DC    AL1(DCMRVRID)       CONTROL BLOCK VERSION       @G860P2G\n         AIF   (T'&KEY EQ 'O').NOPFKS PFK'S SPECIFIED?         @G860P2G\n         AIF   (&KEY EQ 0).NOPFKS  SPECIFIED AS ZERO?          @G860P2G\nDCMRFLGS DC    X'80'               FLAGS - PFK'S PRESENT       @G860P2G\n         AGO   .SETFLGS            FLAGS ARE SET               @G860P2G\n.NOPFKS  ANOP                                                  @G860P2G\nDCMRFLGS DC    X'00'               FLAGS\n.SETFLGS ANOP                                                  @G860P2G\nDCMPFKEY EQU   X'80'               CONSOLE HAS PFK'S           @G860P2G\nDCMPFKWK EQU   X'40'               PFK'S ARE OPERATIONAL       @G860P2G\nDCMPFKIN EQU   X'20'               PFK INIT. IN PROCESS        @G860P2G\nDCMDOM   EQU   X'10'               DOM MUST BE TRIED\nDCMNIPP  EQU   X'08'               CONSOLE WAS USED BY NIP     @G64UPSS\nDCMPFKBD EQU   X'04'               PFK DEFS ARE NOT FROM DCMLIB AND    *\n                                   CAN'T BE SAVED WHEN CHANGED @G860P2G\nDCMFAIL  EQU   X'02'               MODEL TDCM COULD NOT BE USED    @D1A\nDCMLEN   DC    H'0'                LENGTH OF TRANS DCM\nDCMADKP  DC    A(0)                ADDRESS OF ROUTED K COMMAND\n*                                       PARAMETER LIST\n         AIF   ('&F' EQ '0').NOTOPAR                           @G811P2G\nDCMTOPAR DC    C'&F'               TOP DISPLAY AREA DEFINED\n         AGO   .TOPDONE                                        @G811P2G\n.NOTOPAR ANOP  ,                                               @G811P2G\nDCMTOPAR DC    X'00'\n.TOPDONE ANOP  ,                                               @G811P2G\nDCMTOPDS DC    X'00'               TOP DISPLAY ON SCREEN\nDCMPREVM DC    X'00'               CONSOLE'S PREVIOUS OPER. MODE   -EU-\nDCMPREFC EQU   X'08'               PREVIOUS MODE WAS FC            -EU-\nDCMPREMS EQU   X'04'               PREVIOUS MODE WAS MS            -EU-\nDCMPRESD EQU   X'02'               PREVIOUS MODE WAS SD            -EU-\nDCMDEVTY DC    X'00'               DEVICE TYPE FLAGS\nDCMTY60  EQU   X'80'               USABLE FOR SD              MC X01958\nDCMTY50  EQU   X'40'               UNUSABLE FOR SD            MC X01958\nDCMBCOLR EQU   X'20'               USABLE FOR BASE COLOR           @L2A\nDCMECOLR EQU   X'10'               USABLE FOR EXTENDED COLOR       @L2A\nDCMSPRPQ EQU   X'08'               DEVICE SUPPORTS READ PARTITION      X\n                                   QUERY FUNCTION                  @D1A\nDCMEXTDS EQU   X'04'               DEVICE SUPPORTS EXTENDED DATA       X\n                                   STREAM I/O AND 14 BIT ADDRESSES ON  X\n                                   OUTBOUND DATA                   @D1A\nDCM14IAD EQU   X'02'               DEVICE SUPPORTS 14 BIT ADDRESSES ON X\n                                   INBOUND DATA                    @D1A\nDCMIMGLT EQU   X'01'               DEVICE HAS AN IMAGE LIMIT       @D1A\n         AIF   (&S EQ 0).NONE      IF NO SDS AREAS REQUESTED\nDCMADSDS DC    A(DCMACB)           POINTER TO FIRST SDS SUPPORT AREA\n         AGO   .MCH                                            @G811P2G\n.NONE    ANOP\nDCMADSDS DC    F'0'                POINTER TO FIRST SDS SUPPORT AREA\n.MCH     ANOP                                                  @G811P2G\nDCMRCBID DC    C'RDCM'             CONTROL BLOCK ID            @G860P2G\n.YYY     ANOP\n.**********************************************************************\n.*                                                            @G811P2G*\n.*       DEFINE THE REMAINDER OF THE RDCM                     @G811P2G*\n.*                                                            @G811P2G*\n.**********************************************************************\nDCMWLAST DC    F'0'                PT CON Q ENTRY LAST OUT (O-O-L)\nDCMRMSAL DC    H'0'                NUMBER LINES IN MSG AREA\nDCMDOMKY DC    H'0'                CONSOLE DOM ELEMENT        MC XM5812\nDCMRSV04 DC    F'0'                RESERVED                        -EU-\nDCMADPFK DC    F'0'                POINTER TO RESIDENT PFK AREA\nDCMINTVL DC    H'0'                INTERVAL FOR THIS DCM\nDCMTMCTR DC    H'0'                TIME COUNTER FOR THIS DCM\nDCMR2FLG DC    X'00'               TIMER FLAGS\nDCMRXSFL EQU   X'80'               FULL SCREEN FLAG\nDCMRXUNV EQU   X'40'               UNVIEWABLE MESSAGE DISPLAYED\nDCMRXTMR EQU   X'20'               TIMER FLAG\nDCMRXRLL EQU   X'10'               READY TO ROLL\nDCMRXDEL EQU   X'08'               PENDING DELETE REQUEST\nDCMRXTIM EQU   X'02'               TIMER ELAPSED FOR THIS DISPLAY\nDCMRXDCM EQU   X'01'               T DCM IS IN CORE\nDCMR3FLG DC    X'00'               MISC FLAGS\nDCMSTSWT EQU   X'80'               CHANGING STATUS OF OUTPUT ONLY CON\nDCMKVIP  EQU   X'40'               ENTRY FOR K VARY COMMAND\nDCMCLPR  EQU   X'20'               CLOSE IN PROCESS\nDCMRXSCN EQU   X'10'               ASY ERROR MESSAGE ON SCREEN\nDCMR3PKA EQU   X'08'               DA I/O COMPLETE FLAG\nDCMRXHMT EQU   X'04'               FULL SCREEN SIMULATED?     MC YM4102\nDCMOPEN  EQU   X'02'                                               -EU-\nDCMIFVLD EQU   X'01'                                               -EU-\n         AIF   (T'&KEY EQ 'O').NOKEYS   PFK'S SPECIFIED?       @G860P2G\n         AIF   (&KEY EQ 0).NOKEYS SPECIFIED AS ZERO?           @G860P2G\n&PFKLEN  SETA  (&KEY*110)+19       LENGTH OF PFK AREA IS 110 BYTES     *\n                                   PER KEY + 18-BYTE HEADER + ONE-BYTE *\n                                   STOPPER                     @G860P2G\n&PFKLEN  SETA  (&PFKLEN+7)/8*8     ROUND UP TO DOUBLEWORD      @G860P2G\n.NOKEYS  ANOP                                                  @G860P2G\nDCMPFKSZ DC    H'&PFKLEN'          LENGTH OF PFK BUFFER        @G860P2G\nDCMRQDEL DC    XL8'40'             BUFFER FOR PENDING DELETE REQUESTS\nDCMMSGSV DC    F'0'                LINE COUNT SAVE AREA FOR            *\n                                   IEECVFTP                    @ZMC0190\nDCMPFKBF DC    F'0'                PFK BUFFER ADDRESS          @G860P2G\nDCMRSV01 DC    F'0'                RESERVED                    @G860PSS\nDCMRSV02 DC    F'0'                RESERVED                    @G860P2G\n         AIF   (&S EQ 0).END       IF NO SDS AREAS, DEPART\n         EJECT\n***********************************************************************\n* SCREEN AREA CONTROL BLOCK (SACB)                             @G811P2G\n***********************************************************************\n         SPACE 1                                               @G811P2G\nDCMACB   EQU   *                   SCREEN AREA CONTROL BLOCK\n         AIF   (&N EQ &S).ZERO     BRANCH IF LAST AREA\nDCMACBNX DC    A(*+DCMACBSZ+DCMPRSZ) POINTER TO NEXT SACB\n         AGO   .AID\n.ZERO    ANOP\nDCMACBNX DC    A(0)                POINTER TO NEXT SACB\n.AID     ANOP\nDCMAID   DC    C'&C'               AREA ID\nDCMASACB DC    X'80'               SACB FLAGS\nDCMAUSE  EQU   X'80'               AREA PRESENTLY DEFINED     MB Y02958\nDCMAGM   EQU   X'40'               GETMAINED SACB\nDCMALN   DC    FL2'&D'                  LENGTH OF AREA\nDCMATOP  DC    X'00'               TOP ROW OF AREA\nDCMACLR  EQU   *                   REINITIALIZED PORTION      MB Y02958\nDCMAROW  DC    X'00'               ROW TO BE WRITTEN NEXT\nDCMAFR   DC    H'00'               FRAME ON SCREEN\nDCMAMJWQ DC    A(0)                POINTER TO CON Q ENTRY FOR MAJOR\nDCMAMIN  DC    A(0)                POINTER TO MINOR WQE\nDCMATIME DC    F'0'                TIME CONTROL LINE WAS WRITTEN\nDCMANLAB DC    FL1'0'              NUMBER OF LABEL LINES FOUND @G860PSS\nDCMARES1 DC    XL1'00'             RESERVED                    @G860PSS\nDCMAFLG1 DC    X'00'               AREA FLAGS1\nDCMADISP EQU   X'40'               DISPLAY IN AREA\nDCMADEND EQU   X'20'               END OF DISPLAY ON SCREEN\nDCMAFRPR EQU   X'10'               FRAMING IN PROGRESS\nDCMAFULL EQU   X'08'               FRAME FULL\nDCMABL   EQU   X'04'               BLANKING TO BE DONE\nDCMAELLF EQU   X'02'               EMBEDDED LABEL LINE FOUND   @G860PSS\nDCMADLF  EQU   X'01'               DATA LINE FOUND WHILE WRITING       X\n                                   DISPLAY                     @G860PSS\nDCMAFLG2 DC    X'00'               AREA FLAGS 2\nDCMALMIN EQU   X'80'               SAVED POINTER TO LAST MINOR OUTPUT\nDCMAWCON EQU   X'40'               WRITE CONTROL LINE\nDCMARCON EQU   X'20'               REWRITE CONTROL LINE\nDCMAMJFR EQU   X'10'               MAJOR WQE HAS BEEN FOUND\nDCMADFLG DC    X'00'               DYNAMIC DISPLAY FLAGS      MB Y02958\nDCMADD   EQU   X'80'               TRACK IN AREA              MB Y02958\nDCMAHOLD EQU   X'40'               TRACK IN HOLD MODE         MB Y02958\nDCMACSIB EQU   X'20'               TRACK WITH CONTINUATION LINE IN     *\n                                   SCREEN IMAGE BUFFER        MB Y02958\nDCMATRCK DC    X'00'               TRACK REQUEST INDICATORS   MB Y02958\nDCMATJOB EQU   X'80'               TRACK JOBS                 MB Y02958\nDCMATJBL EQU   X'40'               TRACK JOBS,LIST            MB Y02958\nDCMATTS  EQU   X'08'               TRACK TS                   MB Y02958\nDCMATTSL EQU   X'04'               TRACK TS,LIST              MB Y02958\nDCMATA   EQU   X'88'               TRACK A                    MB Y02958\nDCMATAL  EQU   X'44'               TRACK A,LIST               MB Y02958\nDCMRSV05 DC    H'0'                RESERVED                        -EU-\nDCMATECB DC    F'0'                TRACK CANCEL ECB ADDRESS   MB Y02958\nDCMAASCB DC    F'0'                TRACK ASCB POINTER              @P1C\n*                                  NOTE: WHEN THE SACB IS\n*                                       REINITIALIZED, FIELDS\n*                                       DCMAROW THROUGH THE END\n*                                       (INCLUDING THE RESERVED\n*                                       FIELD) ARE ZERO'D\nDCMACBND EQU   *                   END OF SACB\nDCMCLRLN EQU   *-DCMACLR           LENGTH FOR REINITIALIZING  MB Y02958\nDCMACBID DC    F'0'                ACRONYM = SACB                  -EU-\nDCMRSV03 DC    F'0'                RESERVED                        -EU-\nDCMACBSZ EQU   *-DCMACB            SIZE OF SACB IN BYTES\n.**********************************************************************\n.*                                                            @G811P2G*\n.*       BUILD THE SCREEN AREA CONTROL BLOCKS (SACB'S) - ONE  @G811P2G*\n.*       PER AREA DEFINED                                     @G811P2G*\n.*                                                            @G811P2G*\n.**********************************************************************\n.NEXT    AIF   (&N EQ &S).END      BRANCH IF LAST AREA IS DONE\n&N       SETA  &N+1\n&E       SETA  &E+1\n&C       SETC  '&TABLE'(&N,1)           COMPUTE AREA ID\n&D       SETC  '&A(&E)'\n         SPACE\n***********************************************************************\n* SCREEN AREA CONTROL BLOCK (SACB)                             @G811P2G\n***********************************************************************\n         SPACE 1                                               @G811P2G\n         AIF   (&N EQ &S).Z        BRANCH IF LAST AREA\n         DC    A(*+DCMACBSZ+DCMPRSZ) POINTER TO NEXT SACB\n         AGO   .ID\n.Z       ANOP\n         DC    A(0)                POINTER TO NEXT SACB\n.ID      ANOP\n         DC    C'&C'               AREA ID\n         DC    X'80'               SACB FLAGS\n         DC    FL2'&D'             LENGTH OF AREA\n         DC    X'00'               TOP ROW OF AREA\n         DC    X'00'               ROW TO BE WRITTEN NEXT\n         DC    H'00'               FRAME ON SCREEN\n         DC    A(0)                POINTER TO CON Q ENTRY FOR MAJOR\n         DC    A(0)                POINTER TO MINOR WQE\n         DC    F'0'                TIME CONTROL LINE WAS WRITTEN\n         DC    FL1'0'              NUMBER OF LABEL LINES FOUND @G860PSS\n         DC    XL1'00'             RESERVED                    @G860PSS\n         DC    X'00'               AREA FLAGS1\n         DC    X'00'               AREA FLAGS2\n         DC    X'00'               DISPLAY FLAGS\n         DC    X'00'               TRACK REQUEST INDICATORS   MB Y02958\n         DC    H'0'                RESERVED                        -EU-\n         DC    F'0'                CANCEL TRACK ECB ADDRESS   MB Y01958\n         DC    F'0'                TRACK ASCB POINTER              @P1C\n         DC    F'0'                ACRONYM = SACB                  -EU-\n         DC    F'0'                RESERVED                        -EU-\n         AGO   .NEXT               RETURN TO GENERATE NEXT AREA\n.END     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISASM$": {"ttr": 3590, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x942o\\x00\\x942o\\x16'\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-22T00:00:00", "modifydate": "1994-11-22T16:27:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": "//DISASM   JOB (........),'INSTALL  - DISASM -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=2\n/*JOBPARM L=10\n//AS0     EXEC PAJ4AS2,MBR=DISASM0\n//LK0     EXEC PAJILKL\n//SYSIN     DD *\n  NAME    DISASM(R)\n/*\n//AS1     EXEC PAJ4AS2,MBR=DISASM1\n//LK1     EXEC PAJILKL\n//SYSIN     DD *\n  NAME    DISASM1(R)\n/*\n//AS2     EXEC PAJ4AS2,MBR=DISASM2\n//LK2     EXEC PAJILKL\n//SYSIN     DD *\n  NAME    DISASM2(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISASM@": {"ttr": 3592, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x08O\\x00\\x92\\x08O\\x15\\x05\\x01\\xae\\x01\\xae\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-03-24T00:00:00", "modifydate": "1992-03-24T15:05:00", "lines": 430, "newlines": 430, "modlines": 0, "user": "SYSPAJA"}, "text": "1   19/09/86\n                                                      DISASM    1/9.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      D I S A S S E M B L E R        * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  CBT origin : Extracted from CBT tape 84 JUN, file 217.\n  ------------\n\n     DISASM is a one-pass disassembler which produces an assembler\n  language source program from a CSECT within a load module.\n     Control cards permit specification of areas containing no\n  instructions, allow base registers to be provided so that symbolic\n  labels may be created during disassembly, and definition of DSECTs\n  to be used during disassembly. Conditional branch instructions use\n  the extended mnemonics, where possible, and explicit registers are\n  denoted by R0, R1, ... R15. Informational comments are given on\n  svc's, and various BAL instructions to aid in creating a documented\n  source program.\n\n  1. JCL requirements :\n  ---------------------\n\n       A. EXEC card :        to execute PGM=DISASM. A parm field may\n                             be specified if floating point and/or\n                             privileged instructions are to be\n                             found in the module, and/or branch\n                             register extended mnemonics are desired.\n\n       B. STEPLIB DD card :  optional, specify the PDS containing\n                             the module DISASM.\n\n       C. SYSLIB DD card :   specify PDS containing the module to be\n                             disassembled.\n\n       D. SYSPRINT DD card : optional, specify the printed\n                             output data-set. BLKSIZE must be\n                             specified as a multiple of 121.\n                             RECFM=FBA,LRECL=121 is hard-coded.\n\n       E. SYSPUNCH DD card : optional, specify punched output\n                             data-set. BLKSIZE must be specified\n                             as a multiple of 80.\n                             RECFM=FB,LRECL=80 is hard-coded.\n\n       F. SYSIN DD card :    contains control cards. The MODULE-CSECT\n                             card is required. BLKSIZE must be a\n                             multiple of 80. RECFM=FB,LRECL=80 is\n                             hard-coded.\n1   19/09/86\n                                                      DISASM    2/9.\n\n    JCL example : disassemble csect IECIOSCN in module IEANUC01,\n                  which is in the PDS SYS1.NUCLEUS. The modules\n                  DISASM, DISASM1, and DISASM2 are all in the PDS\n                  PRIVATE.EXEC.LOAD. A printed listing is to be made,\n                  and the source program output will be placed in\n                  the sequential data-set PRIVATE.IECIOSCN.ASM.\n\n        //DISASM EXEC PGM=DISASM\n        //STEPLIB  DD DSN=PRIVATE.EXEC.LOAD,DISP=SHR\n        //SYSPRINT DD SYSOUT=A,DCB=BLKSIZE=121\n        //SYSLIB   DD DSN=SYS1.NUCLEUS,DISP=SHR\n        //SYSPUNCH DD UNIT=SYSDA,SPACE=(TRK,(5,2),RLSE),DISP=(,CATLG),\n                      DSN=PRIVATE.IECIOSCN.ASM,DCB=(BLKSIZE=18960)\n        //SYSIN    DD *\n        IEANUC01 IECIOSCN\n        /*\n\n  2. Parm field on the EXEC card :\n  --------------------------------\n\n     Omit the parm field, unless floating point and/or privileged\n  instructions are to be found in the CSECT being disassembled, and\n  branch register extended mnemonics are desired.\n     When the parm field is not specified, entries for privileged and\n  floating point instructions are erased from the internal instruction\n  tables used during disassemble. Valid parm fields are :\n\n          PARM=(SUPVR)       - Assemble privileged instructions\n          PARM=(FLTPT)       - Assemble floating point instructions\n          PARM=(BREMC)       - Assemble using branch register extended\n                               mnemonics coding.\n          PARM=(BREMC,SUPVR,FLTPT) - Assemble both privileged and\n                               floating point instructions, and use\n                               extended mnemonics for branch register.\n\n  3. Control cards entered in the SYSIN data-set :\n  ------------------------------------------------\n\n     Data is contained only in columns 1-72. Columns 73-80 may be\n  used for any desired purpose. In addition, columns beyond the last\n  specified may be used for any purpose. Leading zeros must be\n  included in all fields giving hexadecimal or decimal data. Name\n  fields must be left justified with trailing blanks. Hexadecimal\n  fields may contain only the hexadecimal digits 0-9 and A-F, while\n  decimal fields may contain only digits 0-9. The MODULE-CSECT card\n  must be the first card in the input stream. DSECT definitions may\n  not include any other control cards. USING cards for DSECTs must\n  be entered at some point after the DSECT definition. DATA-ONLY\n  cards and program USING cards may be entered in any order except\n  within DSECT definitions.\n1   19/09/86\n                                                      DISASM    3/9.\n\n        A. - MODULE-CSECT card (required), must be the first card\n                     in the SYSIN stream. Specifies the MODULE name\n                     and CSECT name. Module name is required, and\n                     must name an entry in the directory of the\n                     PDS specified by the SYSLIB DD card. Csect\n                     name is optional. If specified, the named csect\n                     must exist in the module. If omitted, the\n                     csect with ESDID=0001 is disassembled.\n            Format : free-form, with module name preceding csect name.\n                     At least one blank must separate module name and\n                     csect name. The names may be surrounded by any\n                     number of blanks.\n                     For example, see the JCL example.\n\n        B. - DATA-ONLY card (optional), used to describe areas of\n                     the CSECT being disassembled which contain no\n                     instructions. Use of this card eliminates\n                     creation of instructions from constant data.\n                     Up to 256 DATA-ONLY cards may be entered. These\n                     cards may occur anywhere in the SYSIN stream\n                     after the MODULE-CSECT card, but not within\n                     a DSECT definition set.\n            Format : col  1-4  : literal DATA\n                     col   5   : blank\n                     col  6-11 : offset to beginning of area in hex\n                     col   12  : blank\n                     col 13-18 : offset to end of area in hex\n\n        C. - DSECT definitions (optional). A DSECT is defined by a\n                     header card followed by a variable number of\n                     field definition cards (up to 9999 of them).\n                     No other control card may be entered within a\n                     DSECT definition. Up to 256 DSECT definitions\n                     may be entered.\n            DSECT header card format :\n                     col 1-8    : DSECT name\n                     col 9      : blank\n                     col 10-14  : literal DSECT\n                     col 15     : blank\n                     col 16-19  : number of field cards to follow\n                                  (decimal)\n            DSECT field card format :\n                     col 1-8    : field name\n                     col 9      : blank\n                     col 10-13  : offset to left end of field\n                                  (decimal), maximum offset is 4095\n                     col 14     : blank\n                     col 15-17  : length of field in bytes (decimal),\n                                  maximum length is 256\n1   19/09/86\n                                                      DISASM    4/9.\n\n        D. - ULABL cards. These cards define user labels to be placed\n                     on statements within the program. If program\n                     base registers are set up with USING cards,\n                     these will also be generated as symbolics\n                     operands on instructions. Format is :\n                     col  1-5   : literal ULABL\n                     col   6    : blank\n                     col  7-14  : label name\n                     col  15    : blank\n                     col 16-21  : offset to left end of field, in hex\n                     col  22    : blank\n                     col 23-25  : length of field in decimal (256\n                                  is maximum)\n\n        E. - USING cards. These cards define base register usage.\n                     Up to 256 USING cards may be entered. Use\n                     of these cards permits the disassembler to\n                     convert explicit base-displacement addresses\n                     to symbolic labels. Labels created within\n                     the program will be 7 characters long. The\n                     first character is A, followed by the\n                     6-hex-digit offset to the label. A USING\n                     card must be entered for each DSECT to be used.\n            Format : col 1-5   : literal USING\n                     col 6     : blank\n                     col 7-12  : offset to begin loc for using range\n                                 in hex (this is where the USING\n                                 statement will occur)\n                     col 13    : blank\n                     col 14-19 : offset to ending loc for using\n                                 range in hex (this is where the DROP\n                                 statement will occur)\n                     col 20    : blank\n                     col 21    : base register to be used (hex, 1-F)\n                     col 22    : blank\n                     col 23    : type, P = program base\n                                       D = dsect base\n                     col 24    : blank\n                     col 25-30 : initial base register value in hex\n                                 if type P\n                     col 25-32 : DSECT name if type D\n1   19/09/86\n                                                      DISASM    5/9.\n\n  4. Suggestions for use :\n  ------------------------\n\n     On the first pass, do not use a SYSPUNCH DD card, but print the\n   SYSPRINT listing. Use the listing to determine which registers are\n   used as program base registers, their initial values, and their\n   ranges. Make up USING cards for these. Find any places where no\n   instructions should be generated (only constants), and make up\n   DATA-ONLY cards for these ranges.\n     If you can determine any registers that are bases for areas which\n   can be used for DSECTs (CVT reference, etc...), determine the range\n   of valid use, and make up DSECT definitions and USING cards for\n   these.\n     Make a second run, including the above cards, and creating a\n   source program output with the SYSPUNCH DD card.\n\n  5. Output description :\n  -----------------------\n\n    A. SYSPUNCH : this output contains the disassembled source\n                  program. Statement names begin in column 1,\n                  mnemonics begin in column 10, operands in column\n                  16, and an occasional comment begins in column\n                  44. A sequence number (by tens) is in columns\n                  73-80. Comments are included to show the macro\n                  name associated with svc's, and other statements\n                  are flagged to aid in identification of certain\n                  operations :\n\n                  BALR 14,15              STD linkage\n                  BALR X,0                address set\n                  other BALR's            non-STD linkage\n                  BAL 0,XXX and BAL 1,XXX parm set branch\n                  BAL X,XXX               perform\n                  STM instructions        save regs\n                  LM  instructions        restore regs\n                  BR R14                  exit\n                  abs. location hex 10    CVT address\n                  abs. location hex 4C    CVT address\n                  other abs. locations    PSA reference\n\n                  When used explicitly in instructions, registers\n                  are specified as R0, R1, R2,... R15. A $DEFREG macro\n                  is generated at the end of the program to create\n                  the appropriate EQU statements. If any DSECTs\n                  were defined in the SYSIN data-set, they will\n                  be near the end of the source program.\n                  The extended mnemonics are used for conditional\n                  branches wherever possible.\n1   19/09/86\n                                                      DISASM    6/9.\n\n    B. SYSPRINT content :\n\n       Directory information : contains data from the directory\n                               entry of the module containing\n                               the CSECT to be disassembled.\n       ESD table : a formatted list of all external symbol entries\n                               found in the module.\n       RLD table : a formatted listing of all relocation dictionary\n                               entries pertaining to this CSECT.\n       User entered cards : a list of the cards entered by the user,\n                               with diagnostics, if appropriate.\n       Phase 1 label table : a list of all the labels to be used\n                               during disassembly including those\n                               developed from ESD entries, RLD\n                               entries, and generated names resulting\n                               from USING and ULABL card processing.\n       Text : a storage-dump formatted listing of the text which\n                               comprises the CSECT being disassembled.\n       Source listing : a printout of the generated source program\n                               statements, including the hex value\n                               which resulted in the instruction's\n                               creation.\n\n  6. Program processing description :\n  -----------------------------------\n\n     The disassembler is composed of three modules. The first is called\n   DISASM. The second phase is DISASM1, and the third is DISASM2. The\n   second and third phases are loaded and performed by a BALR 14,15\n   from DISASM.\n\n   DISASM functions :\n\n      . Process the parm field, if any : set indicators used by\n        DISASM1 and DISASM2.\n      . Open all files.\n      . Set up DISASM1 and DISASM2 instruction tables.\n      . Get storage for the symbol table, RLD table, and DATA-ONLY\n        tables (about 128K bytes total).\n      . Process the MODULE-CSECT card to obtain the member and\n        CSECT names.\n      . Issue BLDL against SYSLIB to obtain directory info for the\n        member specified. If the specified member is an ALIAS,\n        re-issue a BLDL for the real member. Print directory\n        information.\n      . Point to the member in the SYSLIB PDS, and process the\n        member. Load modules contain an external symbol dictionary\n        followed by text and relocation dictionary information.\n        All ESD info for the module precedes the first control\n        record. A control record precedes each block of text.\n1   19/09/86\n                                                      DISASM    7/9.\n\n        RLD info for the text follows each text block. Processing\n        of load module information is as follows :\n        A. Build an external symbol table, using the CESD blocks.\n        B. Search for the desired CSECT as the table is being built.\n           This CSECT must be found before the first control record.\n        C. Read blocks until a control record for the desired CSECT\n           is found (by ESD-id).\n        D. When found, issue GETMAIN for an area large enough to\n           contain the entire text.\n        E. Place text blocks in contiguous storage locations and\n           maintain during disassembly.\n        F. Use RLD information for the CSECT to build the RLD table.\n      . Load and perform DISASM1.\n      . If any errors found by DISASM1, terminate processing.\n      . Print the final label table to be used during disassembly.\n      . Load and execute DISASM2.\n      . Generate the $DEFREG macro statement.\n      . Generate the DSECT entries if any.\n      . Generate the END statement.\n      . terminate processing.\n\n   DISASM1 functions :\n\n      DISASM1 is the second phase of disassembly, and is performed\n      by DISASM. A common data area, defined in DISASM, is passed to\n      this program on entry.\n\n      The SYSIN file is read to exhaustion. USING cards are re-\n      formatted and stored in a table - up to 256 USING statements\n      may be entered. DSECT cards may follow the USING statements.\n      When used, DSECT statements are re-formatted, and built into\n      tables. A maximum of 256 DSECTs may be entered. DATA-ONLY cards\n      may be included before, between, or after DSECTs to show areas\n      in the program where no instructions occur. Up to 256 DATA-ONLY\n      areas may be specified.\n\n      At EOF on SYSIN, a pseudo disassembly pass is made using the\n      text stored by DISASM. Any resolvable address within the text\n      is used to create a new entry in the label table, which will be\n      used by DISASM2 in the actual disassembly pass.\n\n      Disassembly tables are set up similarly to those used by\n      DISASM2 for the simulated disassembly performed in this module\n      when any program base register USING statements are entered.\n\n      Storage is obtained for the DSECT table and USING table, and\n      addresses of these tables are stored in the common parameter\n      area. USING and DSECT cards are edited, re-formatted, and\n      placed in the appropriate tables. If any errors are found, they\n      are printed, and the disassembly will be terminated on return\n      to DISASM.\n1   19/09/86\n                                                      DISASM    8/9.\n\n      Storage is obtained for the label table, and a simulated\n      disassembly is performed to create label table entries for\n      labels which will be generated for base-displacement addresses\n      by DISASM2. On return to DISASM, these labels will be sorted\n      with external symbol and RLD labels to form the final label\n      table to be used by DISASM2.\n\n   DISASM2 functions :\n\n      This sub-program is called by DISASM after completion of\n      processing by DISASM1. The final label table and module text\n      is in an area of storage. A common parameter area is defined\n      in DISASM, and passed to this program.\n\n      Text bytes are used to create assembly language statements,\n      and machine instruction statements. Output is written to the\n      SYSPUNCH data-set for further processing by other modules.\n\n      A text byte is considered to be an instruction if it occurs\n      on a halfword boundary, is a valid op-code, and is followed\n      by a valid op-code. Unconditional branches need not be\n      followed by a valid op-code, however. The privileged and\n      floating point instructions are not treated as instructions\n      unless the user specified their inclusion at EXEC time.\n\n  7. Installation :\n  -----------------\n\n     A. Assemble and link the three programs : DISASM0, DISASM1 and\n        DISASM2.\n     B. If a single load module is desired, the LOAD and BALR code\n        in program DISASM0 (load and execute PHASE 1 and PHASE 2)\n        may be changed to CALLs, passing the address of the common\n        parameter area as a parameter. The three programs will all\n        be linked into a single module with entry point DISASM, if\n        this is done.\n     C. If storage utilization is found to be excessive, investigate\n        the possibility of reducing the size of the table GETMAINs\n        in DISASM0 (see at labels SYMLGTH, RLDLGTH, DATLGTH ). The\n        The programs were written for ease of use with an MVS\n        Operating System, and may cause problems in a storage\n        constrained environment.\n     D. The svc table and instruction op-code tables in DISASM0\n        should be changed for Operating System validity, and currency\n        with the hardware from time to time.\n1   19/09/86\n                                                      DISASM    9/9.\n\n     E. Macros used by the disassembler are included in DISASMM.\n        If other macros will be used in their place, make appropriate\n        source code changes in DISASM0, DISASM1, and DISASM2 before\n        assembly.The $DEFREG macro is placed in each disassembled\n        program (see DISASM0).\n     F. Direct technical inquiries, comments, suggestions for\n        improvements, etc..., to :\n\n        1. CBT origin : Extracted from CBT tape 84 JUN, file 217.\n             DICK THORNTON\n             BLUE CROSS OF VIRGINIA\n             2015 STAPLES MILL ROAD\n             RICHMOND, VA. 23279 - Phone : (804) 359-7248\n\n        2. Updated version (marked -EU- in columns 68-71).\n             MOINIL P.A.\n             COMPUTING CENTRE\n             J.R.C. - ISPRA ESTABLISHMENT\n             21020 ISPRA (VA); ITALY - Phone : (0332) 789442\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DISASMM": {"ttr": 3844, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x8f\\x00\\x882\\x8f\\x149\\x01\\xb2\\x01\\xb2\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-23T00:00:00", "modifydate": "1988-11-23T14:39:00", "lines": 434, "newlines": 434, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n&NAME    SVLNK &REG1,&REG2,&REG3,&IND,&LV=\n         GBLC  &EQU\n         GBLC  &GM\n         GBLC  &CSECT\n         LCLC  &REGA\n         AIF   (T'&NAME EQ 'O').NOCSECT\n         AIF   ('&NAME' EQ '*').NOCSECT\n&CSECT   SETC  '&NAME'\n&CSECT   CSECT                         NAME OF PROGRAM\n         AGO   .RST\n.NOCSECT ANOP\n&CSECT   SETC  '*'\n         CSECT                         BEGINNING OF PROGRAM\n.RST     AIF   ('&EQU' EQ 'ON').NRQ\n&EQU     SETC  'ON'\n*\n*** REGISTER EQUATES ***\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n.NRQ     ANOP\n*\n*******************  PROGRAM INITIALIZATION  *************************\n*\n         AIF   (T'&REG1 EQ 'O').NOREG\n&REGA    SETC  '&REG1'\n         AIF   (T'&REG2 EQ 'O').ONEREG\n         USING &CSECT,&REGA,&REG2          ESTABLISH ADDRESSABILITY\n         AGO   .BYUSE\n.NOREG   ANOP\n&REGA    SETC  'R3'\n.ONEREG  USING &CSECT,&REGA              ESTABLISH ADDRESSABILITY\n.BYUSE   STM   R14,R12,12(R13)         STORE REGS IN HIGH SAVE AREA\n         LR    &REGA,R15                  INITIALIZE BASE REG\n         AIF   ('&CSECT' EQ '*').NOMN                              -EU-\n         B     *+L'*+22                                            -EU-\n         DC    CL8'&CSECT'             MODULE IDENTIFIER.          -EU-\n         DC    CL8'&SYSDATE'           ASSEMBLY DATE.              -EU-\n         DC    C'-',CL5'&SYSTIME'      ASSEMBLY TIME.              -EU-\n.NOMN    AIF   (T'&REG2 EQ 'O').NOLA\n         LA    &REG2,4095(&REGA)       INITIALIZE THE SECOND\n         LA    &REG2,1(&REG2)                BASE REGISTER\n.NOLA    AIF   (T'&REG3 EQ 'O').NOLNK\n         L     &REG3,0(R1)                GET PARAMETER LIST ADDR\n.NOLNK   AIF (T'&IND EQ 'O').GETIT\n         CNOP  0,4\n         BAS   R15,SAVEAREA+72         BRANCH AROUND SAVE AREA\nSAVEAREA DC    18F'0'                  REGISTER SAVE AREA\n         ST    R15,8(R13)\n         ST    R13,SAVEAREA+4\n         LR    R13,R15\n         AGO   .NOSAVE\n.GETIT   AIF   (T'&LV EQ 'O').GMD\n&GM      SETC  '&LV'\n         AGO   .DGM\n.GMD     ANOP\n&GM      SETC  '72'\n.DGM     ANOP\n*\n*** GET MAIN STORAGE FOR SAVE AREA ***\n*\n         AIF   ('&GM' LT '4096').LA\n         GETMAIN R,LV=&GM              GET CORE FOR SAVE AREA\n         AGO   .EGM\n.LA      LA    R0,&GM                  GET &GM BYTES\n         GETMAIN R,LV=(0)\n.EGM     ANOP\n*\n*** SET UP SAVE AREA POINTERS ***\n*\n         ST    R1,8(R13)               STORE LOW SAVE POINTER\n         ST    R13,4(R1)               STORE HIGH SAVE POINTER\n         LR    R13,R1                  INITIALIZE SAVE POINTER\n         AIF   (T'&REG3  NE 'O').EXIT\n         L     R1,4(R13)               GET POINTER TO RESTORE PARA REG\n         L     R1,24(R1)               RESTORE PARAMETER REGISTER\n.EXIT    ANOP                          END INITIAL., BEGIN THIS PROG.\n*\n*********************  END INITIALIZATION  ***************************\n*\n         MEND\n         MACRO\n&NAME    SVBCK &DUMMY                                              -EU-\n         GBLC  &GM                                                 -EU-\n*\n*******************  PROGRAM TERMINATION  ****************************\n*\n&NAME    LR    R1,R13              SAVE AREA TO FREE               -EU-\n         L     R13,4(R13)          GET POINTER TO CALLER'S S.A.    -EU-\n*\n*** FREE MAIN STORAGE OF SAVE AREA ***\n*\n         AIF   ('&GM' LT '4096').A0                                -EU-\n        FREEMAIN R,LV=&GM,A=(1)    FREE CORE OF SAVE AREA          -EU-\n         AGO   .A1                                                 -EU-\n.A0      LA    R0,&GM              GET NUMBER OF BYTES             -EU-\n        FREEMAIN R,LV=(0),A=(1)    FREE CORE OF SAVE AREA          -EU-\n.A1      LM    R14,R12,12(R13)     RESTORE CALLER'S REGS           -EU-\n         XR    R15,R15             CLEAR RETURN CODE               -EU-\n         BR    R14                 RETURN TO CALLER                -EU-\n*\n*********************  END TERMINATION  ******************************\n*\n         MEND\n         MACRO\n         DEFCOM &DSECT=NO                                          -EU-\n         SPACE 1\n****************************************************************\n*                 *** DATA AND WORK AREAS ***                  *\n****************************************************************\n*                                                              *\n* FOLLOWING FIELDS: COMMPARM THRU COMMEND ARE COMMON AREAS     *\n* SHARED BY THIS, AND CALLED SUB-PROGRAMS. ALL CHANGES MUST    *\n* BE COORDINATED WITH ALL OTHER PROGRAMS.                      *\n*                                                              *\n****************************************************************\n         SPACE 1\n         AIF   ('&DSECT' EQ 'YES').GDSCT                           -EU-\nCOMMPARM DS    0D -------------------> COMMON AREAS\nDBLWD    DC    D'0'                    DOUBLEWORD WORK AREA\nPUNCHDCB DC    A(SYSPUNCH)             @ SYSPUNCH DCB\nPRINTDCB DC    A(SYSPRINT)             @ SYSPRINT DCB\nINDCB    DC    A(SYSIN)                @ SYSIN DCB\nCSECT    DC    CL8' '                  SPECIFIED CSECT NAME\nESDID    DC    X'0001'                 ESD ID OF SPECIFIED CSECT\nENDLBLNM DC    CL8' '                  SYMBOL FOR END STMT BEGIN POINTE\nLINECT   DC    PL2'0'                  PRINT LINE COUNTER\nSTART    DC    F'0'                    LKED ASSIGNED START ADDR OF CSEC\nEND      DC    F'0'                    CSECT END ADDRESS\nLENGTH   DC    F'0'                    LENGTH OF SPECIFIED CSECT\nLBLTBL   DC    F'0'                    @ LABEL TABLE\nCURRLBL  DC    F'0'                    CURRENT LABEL ENTRY ADDR\nENDLBL   DC    F'0'                    @ END OF LABEL TBL\nSVCOPAD  DC    A(SVCOP)                @ SVC NAME TBL              -EU-\nDBLOPAD  DC    A(DBLOP)                @ TWO-BYTE OP-CODE TBL      -EU-\nSGLOPAD  DC    A(SGLOP)                @ SINGLE-BYTE OP-CODE TBL   -EU-\nSVCOPL   DC    AL2(L'SVCOP)            SVC NAME TBL LEN            -EU-\nDBLOPL   DC    AL2(L'DBLOP)            TWO-BYTE OP-COD TBL LEN     -EU-\nSGLOPL   DC    AL2(L'SGLOP)            SINGLE-BYTE OP-COD TBL LEN  -EU-\nLBLLGTH  DC    AL2(L'LABEL)            LENGTH OF LABEL ENTRY\nTXTSTRT  DC    F'0'                    @ TEXT STORAGE AREA\nTXTCURR  DC    F'0'                    @ CURRENT TEXT LOC\nTXTEND   DC    F'0'                    @ END OF TEXT AREA\nDTBLGTH  DC    A(256*L'DTL+8)          DSECT TABLE STORAGE LENGTH  -EU-\nDTBSTRT  DC    F'0'                    DSECT TABLE START ADDR\nDTBCURR  DC    F'0'                    DSECT TABLE CURRENT ENTRY ADDR\nDTBEND   DC    F'0'                    DSECT TABLE END ADDR\nUSGLGTH  DC    A(256*L'USING+8)        USING TABLE STORAGE LENGTH  -EU-\nUSGSTRT  DC    F'0'                    USING TABLE START ADDR\nUSGCUR   DC    F'0'                    USING TABLE CURRENT ADDR\nUSGEND   DC    F'0'                    USING TABLE END ADDR\nDATONLY  DC    F'0'                    DATA ONLY TABLE ADDR\nDATOCUR  DC    F'0'                    CURRENT DATA ONLY ADDR\nDATOEND  DC    F'0'                    END OF DATA ONLY TABLE\nFLPTASM  DC    X'00'                   FLOATING POINT INDICATOR\nPRIVASM  DC    X'00'                   PRIVILEGED INDICATOR\nBREMASM  DC    X'00'                   BR EXT. MNEMONICS INDICATOR -EU-\nUSERR    DC    X'00'                   ERROR INDIC FOR DISASM1\nNBRLBLS  DC    H'0'                    NBR LABELS FROM DISASM1\nCARDNO   DC    PL4'0'                  OUTPUT CARD NBR\n         SPACE 1\nWORKREC  DS    0CL80                   DISASSEMBLY WORK AREA\nNAME     DC    CL8' '                  NAME\n         DC    CL1' '\nMNEMONIC DC    CL5' '                  INSTRUCTION MNEMONIC\n         DC    CL1' '\nOPNDS    DC    CL27' '                 1ST OPERAND\n         DC    CL1' '\nCOMMENT  DC    CL28' '                 COMMENT\nCOL72    DC    CL1' '\nSEQNBR   DC    CL8' '                  CARD SEQ NBR\n         SPACE 1\nPRTLINE  DS    0CL121                  PRINT LINE\nPCC      DC    C'1'                    CARRIAGE CONTROL\nPRT      DC    CL120' '                PRINT DATA\n         SPACE 1\n         DS    0F\nBLDLIST  DS    0CL62                   BLDL LIST\n         DC    H'1'                    ONE ENTRY\n         DC    H'58'                   LENGTH OF ENTRY\nMEMBER   DC    CL8' '                  MEMBER NAME\nTTRMOD   DC    XL3'000000'             TTR OF MODULE\nCCAT     DC    XL1'00'                 CONCATENATION NUMBER\n         DC    XL1'00'\nALIASIND DC    XL1'00'                 ALIAS AND MISC INDICATOR\n*                           80=ALIAS\nTTR1TXT  DC    XL3'000000'             TTR OF 1ST TXT RECORD\n         DC    XL1'00'\nTTRNS    DC    XL3'000000'             TTR OF NOTE OR SCATTER LIST\nNNOTE    DC    XL1'00'                 NBR ENTRIES IN NOTE LIST\nATTR1A   DC    XL1'00'                 MODULE ATTRIBUTES 1, BYTE 1\n*                           80=RENT\n*                           40=REUS\n*                           20=OVERLAY\n*                           10=UNDER TEST\n*                           08=ONLY LOADABLE\n*                           04=SCATTER FORMAT\n*                           02=EXECUTABLE\n*                           01=ONE TXT, NO RLD RECORDS\nATTR1B   DC    XL1'00'                 ATTRIBUTES 1, BYTE 2\n*                           80=CANNOT BE REPROCESSED BY LKED E\n*                           40=ORIGIN OF 1ST TXT RECORD IS ZERO\n*                           20=ASSIGNED ENTRY POINT ADDR IS ZERO\n*                           10=CONTAINS NO RLD RECORD\n*                           08=CANNOT BE REPROCESSED BY LKED\n*                           04=CONTAINS TESTRAN SYMBOLS\n*                           02=CREATED BY LKED\n*                           01=REFR\nTOTVIRT  DC    XL3'000000'             TOTAL VIRTUAL STRG REQRD FOR MOD\nLENG1    DC    XL2'0000'               LENGTH OF 1ST TEXT RECORD\nLKEPA    DC    XL3'000000'             ASSIGNED ENTRY POINT ADDR\nATTR2    DC    XL1'00'                 ATTRIBUTES 2\n*                           80=PROCESSED BY OS/VS LKED\n*                           20=PAGE ALIGNMENT REQUIRED FOR MODULE\n*                           10=SSI PRESENT\n         DC    XL2'0000'\nSCTRLEN  DC    XL2'0000'               SCATTER LIST LENGTH\nTTLEN    DC    XL2'0000'               TRANSLATION TABLE LENGTH\nSCESDID  DC    XL2'0000'               CESD NBR FOR 1ST TXT RECD\nSCEPESD  DC    XL2'0000'               CESD NBR FOR ENTRY POINT\nALEPA    DC    XL3'000000'             ENTRY POINT OF THE MEMBER NAME\nALMEM    DC    CL8' '                  REAL MEMBER NAME FOR ALIAS\nSSI      DC    XL4'00000000'           SSI BYTES\nAUTHLEN  DC    XL1'00'                 AUTH CODE LENGTH\nAUTHCOD  DC    XL1'00'                 AUTH CODE\n         AGO   .EXIT                                               -EU-\n.GDSCT   ANOP  ,                                                   -EU-\nCOMMPARM DSECT , --------------------> COMMON AREAS\nDBLWD    DS    D                       DOUBLEWORD WORK AREA\nPUNCHDCB DS    F                       @ SYSPUNCH DCB\nPRINTDCB DS    F                       @ SYSPRINT DCB\nINDCB    DS    F                       @ SYSIN DCB\nCSECT    DS    CL8                     SPECIFIED CSECT NAME\nESDID    DS    XL2                     ESD ID OF SPECIFIED CSECT\nENDLBLNM DS    CL8                     SYMBOL FOR END STMT BEGIN POINTE\nLINECT   DS    PL2                     PRINT LINE COUNTER\nSTART    DS    A                       LKED ASSIGNED START ADDR OF CSEC\nEND      DS    A                       CSECT END ADDRESS\nLENGTH   DS    F                       LENGTH OF SPECIFIED CSECT\nLBLTBL   DS    F                       @ LABEL TABLE\nCURRLBL  DS    F                       CURRENT LABEL ENTRY ADDR\nENDLBL   DS    F                       @ END OF LABEL TBL\nSVCOPAD  DS    A                       @ SVC NAME TBL              -EU-\nDBLOPAD  DS    A                       @ TWO-BYTE OP-CODE TBL      -EU-\nSGLOPAD  DS    A                       @ SINGLE-BYTE OP-CODE TBL   -EU-\nSVCOPL   DS    AL2                     SVC NAME TBL LEN            -EU-\nDBLOPL   DS    AL2                     TWO-BYTE OP-COD TBL LEN     -EU-\nSGLOPL   DS    AL2                     SINGLE-BYTE OP-COD TBL LEN  -EU-\nLBLLGTH  DS    AL2                     LENGTH OF LABEL ENTRY\nTXTSTRT  DS    F                       @ TEXT STORAGE AREA\nTXTCURR  DS    F                       @ CURRENT TEXT LOC\nTXTEND   DS    F                       @ END OF TEXT AREA\nDTBLGTH  DS    F                       DSECT TABLE STORAGE LENGTH  -EU-\nDTBSTRT  DS    F                       @ DSECT TBL START\nDTBCURR  DS    F                       @ CURRENT DSECT TBL ENTRY\nDTBEND   DS    F                       @ DSECT TBL END\nUSGLGTH  DS    F                       USING TABLE STORAGE LENGTH  -EU-\nUSGSTRT  DS    F                       @ USING TBL START\nUSGCUR   DS    F                       @ CURRENT USING TBL ENTRY\nUSGEND   DS    F                       @ USING TBL END\nDATONLY  DS    F                       @ DATA ONLY TABLE\nDATOCUR  DS    F                       @ CURRENT DATA ONLY ENTRY\nDATOEND  DS    F                       @ END OF DATA ONLY TABLE\nFLPTASM  DS    XL1                     FLOATING POINT INDICATOR\nPRIVASM  DS    XL1                     PRIVILEGED INDICATOR\nBREMASM  DS    XL1                     BR EXT. MNEMONICS INDICATOR -EU-\nUSERR    DS    XL1                     ERROR INDIC FOR DISASM1\nNBRLBLS  DS    H                       NBR LABELS FROM DISASM1\nCARDNO   DS    PL4                     CURRENT OUTPUT CARD NBR\n         SPACE 1\nWORKREC  DS    0CL80                   DISASSEMBLY WORK AREA\nNAME     DS    CL8                     NAME\n         DS    CL1\nMNEMONIC DS    CL5                     INSTRUCTION MNEMONIC\n         DS    CL1\nOPNDS    DS    CL27                    1ST OPERAND\n         DS    CL1\nCOMMENT  DS    CL28                    COMMENT\nCOL72    DS    CL1                     CONTINUATION COLUMN\nSEQNBR   DS    CL8                     CARD SEQUENCE NBR\n         SPACE 1\nPRTLINE  DS    0CL121                  PRINT LINE\nPCC      DS    CL1                     CARRIAGE CONTROL\nPRT      DS    CL120                   PRINT DATA\n         SPACE 1\n         DS    0F\nBLDLIST  DS    0CL62                   BLDL LIST\n         DS    H                       NUMBER OF ENTRY (ONE)\n         DS    H                       LENGTH OF ENTRY\nMEMBER   DS    CL8                     MEMBER NAME\nTTRMOD   DS    XL3                     TTR OF MODULE\nCCAT     DS    XL1                     CONCATENATION NUMBER\n         DS    XL1\nALIASIND DS    XL1                     ALIAS AND MISC INDICATOR\n*                           80=ALIAS\nTTR1TXT  DS    XL3                     TTR OF 1ST TXT RECORD\n         DS    XL1\nTTRNS    DS    XL3                     TTR OF NOTE OR SCATTER LIST\nNNOTE    DS    XL1                     NBR ENTRIES IN NOTE LIST\nATTR1A   DS    XL1                     MODULE ATTRIBUTES 1, BYTE 1\n*                           80=RENT\n*                           40=REUS\n*                           20=OVERLAY\n*                           10=UNDER TEST\n*                           08=ONLY LOADABLE\n*                           04=SCATTER FORMAT\n*                           02=EXECUTABLE\n*                           01=ONE TXT, NO RLD RECORDS\nATTR1B   DS    XL1                     ATTRIBUTES 1, BYTE 2\n*                           80=CANNOT BE REPROCESSED BY LKED E\n*                           40=ORIGIN OF 1ST TXT RECORD IS ZERO\n*                           20=ASSIGNED ENTRY POINT ADDR IS ZERO\n*                           10=CONTAINS NO RLD RECORD\n*                           08=CANNOT BE REPROCESSED BY LKED\n*                           04=CONTAINS TESTRAN SYMBOLS\n*                           02=CREATED BY LKED\n*                           01=REFR\nTOTVIRT  DS    XL3                     TOTAL VIRTUAL STRG REQRD FOR MOD\nLENG1    DS    XL2                     LENGTH OF 1ST TEXT RECORD\nLKEPA    DS    XL3                     ASSIGNED ENTRY POINT ADDR\nATTR2    DS    XL1                     ATTRIBUTES 2\n*                           80=PROCESSED BY OS/VS LKED\n*                           20=PAGE ALIGNMENT REQUIRED FOR MODULE\n*                           10=SSI PRESENT\n         DS    XL2\nSCTRLEN  DS    XL2                     SCATTER LIST LENGTH\nTTLEN    DS    XL2                     TRANSLATION TABLE LENGTH\nSCESDID  DS    XL2                     CESD NBR FOR 1ST TXT RECD\nSCEPESD  DS    XL2                     CESD NBR FOR ENTRY POINT\nALEPA    DS    XL3                     ENTRY POINT OF THE MEMBER NAME\nALMEM    DS    CL8                     REAL MEMBER NAME FOR ALIAS\nSSI      DS    XL4                     SSI BYTES\nAUTHLEN  DS    XL1                     AUTH CODE LENGTH\nAUTHCOD  DS    XL1                     AUTH CODE\n.EXIT    SPACE 1                                                   -EU-\nCOMMEND  EQU   * <-------------------- END OF COMMON AREAS\n         MEND\n         MACRO\n         DEFCDS &DUMMY                                             -EU-\nLABELD   DSECT ,                       LABEL TABLE ENTRY\nLABEL    DS    0CL13                   13-BYTE ENTRIES\nLBLADR   DS    XL3                     RELATIVE ADDR IN TEXT\nLBLTYP   DS    CL1                     TYPE: L=LABEL, A=ADCON, V=VCON,\nLBLNAME  DS    CL8                     NAME (SYMBOL)\nLBLLEN   DS    XL1                     LENGTH IF A, V, OR W\n         SPACE 2\nUSINGD   DSECT ,                       USING TABLE ENTRY\nUSING    DS    0CL11\nUSBGN    DS    XL3                     OFFSET TO BEGINNING OF RANGE\nUSEND    DS    XL3                     OFFSET TO END OF RANGE\nUSREG    DS    XL1                     BASE REGISTER USED\nUSTYPE   DS    XL1                     TYPE:P=PGM,D=DSECT\nUSVALU   DS    XL3                     BASE REG VALUE\n         SPACE 2                                                   -EU-\nDTDS     DSECT ,                       DSECT TABLE ENTRY           -EU-\nDTL      DS    0CL14                                               -EU-\nDTNAME   DS    CL8                     DSECT NAME                  -EU-\nDTLGTH   DS    XL3                     DSECT FIELD TABLE LENGTH    -EU-\nDTADDR   DS    XL3                     DSECT FIELD TABLE ADDRESS   -EU-\n         SPACE 2\nDSECTD   DSECT ,                       DSECT FIELD TABLE ENTRY\nDSECT    DS    0CL13\nDSOFSET  DS    XL3                     OFFSET TO 1ST BYTE OF FIELD\nDSLBTYP  DS    CL1                     LABEL TYPE = L\nDSNAME   DS    CL8                     FIELD NAME\nDSLENG   DS    XL1                     FIELD LENGTH\n         SPACE 2                                                   -EU-\n         PRINT NOGEN                                               -EU-\n         DCBD  DEVD=DA,DSORG=PS                                    -EU-\n         MEND\n         MACRO\n         DEFINS &DSECT=NO                                          -EU-\n         PRINT GEN                                                 -EU-\n         EJECT ,                                                   -EU-\n******************************************************************\n*                                                                *\n* INSTRUCTION DISASSEMBLY WORK-AREA.                             *\n*                                                                *\n******************************************************************\n         SPACE 1\n         AIF   ('&DSECT' NE 'YES').GENDT                           -EU-\nINSTWA   DSECT ,                                                   -EU-\n.GENDT   ANOP                                                      -EU-\nINSTENT  DS    0CL10          CURRENT INSTRUCTION ENTRY\nINAME    DC    CL5' '              INSTR NAME (MNEMONIC)\nITYPE    DC    XL1'0'              INSTRUCTION TYPE\nRR       EQU   0                       RR FORMAT\nRX       EQU   4                       RX FORMAT\nS        EQU   8                       S FORMAT\nSI       EQU   12                      SI FORMAT\nRS       EQU   16                      RS FORMAT\nSS1      EQU   20                      SS FORMAT, 1 LENGTH\nSS2      EQU   24                      SS FORMAT, 2 LENGTHS\nTWO      EQU   28                      TWO BYTE OP-CODE\nCONDBR   EQU   32                      CONDITIONAL BRANCH\nSVC      EQU   36                      SUPERVISOR CALL\nSSR      EQU   40                      SS FORMAT, 2 REGISTERS      -EU-\nRRE      EQU   44                      RRE FORMAT, 2 REGISTERS     -EU-\nSSE      EQU   48                      SSE FORMAT                  -EU-\nICLASS   DC    XL1'0'              INSTRUCTION CLASS\nPRIV     EQU   X'01'                   PRIVILEGED INSTRUCTION\nIOP      EQU   X'02'                   IGNORE OPERAND              -EU-\nFLTPT    EQU   X'10'                   FLOATING POINT INSTR        -EU-\nFLSHT    EQU   X'20'                   SHORT PREC FLT PT INSTR     -EU-\nFLEXR    EQU   X'40'                   EXTENDED FLT PT INSTR       -EU-\nIEDT     DC    XL1'0'              INSTRUCTION EDITS\nS1       EQU   X'01'                   1ST OPND MUST HAVE BASE/INDEX\nS2       EQU   X'02'                   2ND OPND MUST HAVE BASE\nE2       EQU   X'04'                   2ND OPND ON HALFWORD BOUND\nE4       EQU   X'08'                   2ND OPND ON FULLWORD BOUND\nE8       EQU   X'10'                   2ND OPND ON DBL WORD BOUND\nEPR      EQU   X'20'                   EVEN-ODD REGISTER PAIR\nE1R      EQU   X'40'                   RRE FORMAT, 1 REGISTER      -EU-\nICCSET   DC    XL1'0'              TYPE CONDITION CODE SET\nARITH    EQU   X'01'                   ARITHMETIC TYPE\nCPR      EQU   X'02'                   COMPARE TYPE\nZRO8     EQU   X'04'                   BC 8 MAY BE BZ\nINLNG    DC    XL1'0'              INSTRUCTION LENGTH\n         MEND                                                      -EU-\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISASM0": {"ttr": 3852, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x8f\\x00\\x882\\x8f\\x149\\x07\\xc5\\x07\\xc5\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-23T00:00:00", "modifydate": "1988-11-23T14:39:00", "lines": 1989, "newlines": 1989, "modlines": 0, "user": "SYSPAJA"}, "text": "DIS0     TITLE '*** DISASSEMBLY PHASE 0 ***'\n         PRINT OFF                                                 -EU-\n         COPY  DISASMM                                             -EU-\n         PRINT ON                                                  -EU-\nDISASM   SVLNK R3,R4\n         EJECT\n         PRINT NOGEN\n*DISASSEMBLER PROGRAM TO CREATE AN ASSEMBLER SOURCE PROGRAM\n*FROM A LOAD MODULE IN A PDS. DD CARDS REQUIRED INCLUDE\n*SYSPRINT FOR MESSAGES AND DIAGNOSTICS USING BLKSIZE A MULTIPLE\n*OF 121, SYSLIB SPECIFYING THE PDS CONTAINING THE MEMBER,        FIX***\n*WHICH MUST BE A PDS, SYSPUNCH FOR THE ASSEMBLER SOURCE\n*PROGRAM, HAVING BLKSIZE A MULTIPLE OF 80, AND SYSIN\n*FOR THE CONTROL CARD INPUT. CONTROL INPUT MAY OPTIONALLY\n*BE ENTERED VIA THE PARM ON THE EXECUTE CARD. CONTROL\n*INFORMATION INCLUDES THE MEMBER NAME AND CSECT NAME\n*TO BE DISASSEMBLED. IF CSECT NAME IS OMITTED, THE CSECT\n*FOR ESD-ID 0001 WILL BE USED.\n*\n*\n* FILES USED BY THIS PROGRAM INCLUDE THE FOLLOWING:\n*\n* DDNAME SYSLIB: RECFM=U. INPUT LOAD MODULE LIBRARY.\n*\n* DDNAME SYSPUNCH: RECFM=FB,LRECL=80. OUTPUT FILE CONTAINING\n*                 DISASSEMBLED TEXT. (MAXBLK=18,960)\n*\n* DDNAME SYSPRINT: RECFM=FBA,LRECL=121.  PRINTED OUTPUT CONTAINING A\n*                LIST OF THE ESD TABLE, RLD TABLE, AND TEXT.\n*                (MAXBLK=18997)\n* DDNAME LOADLIB: (OPTIONAL) NAMES A PDS CONTAINING THE\n*                 MODULES OF DISASM IF DIFFERENT FROM\n*                 THE STEPLIB. USED PRIMARILY FOR TSO.\n*\n* DDNAME SYSIN: RECFM=FB, LRECL=80. CONTROL CARD INPUT.\n*\n*\n* THE CONTROL CARD PROVIDES THE MEMBER NAME AND CSECT NAME\n* OF THE PROGRAM TO BE DISASSEMBLED. MEMBER NAME IS REQUIRED.\n* IF CSECT NAME IS OMITTED, THE CSECT WITH ESDID 0001 WILL\n* BE USED. FORMAT IS FREE-FORM. MEMBER NAME MUST PRECEDE CSECT\n* NAME. ANY NUMBER OF BLANKS MAY PRECEDE AND FOLLOW MEMBER NAME.\n* A COMMA MAY IMMEDIATELY FOLLOW MEMBER NAME IF DESIRED.\n         EJECT\n* PARM DATA FROM THE EXECUTE CARD MAY BE USED TO SPECIFY\n* VALIDITY OF PRIVILEGED OR FLOATING POINT INSTRUCTIONS,\n* OR VALIDITY OF BRANCH REGISTER EXTENDED MNEMONICS.               -EU-\n* IF NOT SPECIFIED, PRIVILEGED AND FLOATING POINT OPERATION\n* CODES WILL NOT BE TREATED AS INSTRUCTION OP-CODES,\n* OR BRANCH REGISTER EXTENDED MNEMONICS WILL NOT BE GENERATED.     -EU-\n* TO INCLUDE THESE INSTRUCTIONS, CODE :\n*     PARM=(SUPVR)      PRIVILEGED INSTRUCTIONS\n*     PARM=(FLTPT)      FLOATING POINT INSTRUCTIONS\n*     PARM=(BREMC)      BRANCH REGISTER EXTENDED MNEMONICS CODES   -EU-\n* MULIPLE OPTIONS MAY BE SPECIFIED IN ANY ORDER AS FOLLOWS :       -EU-\n*     PARM=(SUPVR,FLTPT)                                           -EU-\n*     PARM=(BREMC,SUPVR,FLTPT)                                     -EU-\n*\n*\n*PROCESSING FLOW:\n*\n* 1. PROCESS THE CONTROL INFORMATION TO OBTAIN THE MEMBER\n*    AND CSECT NAMES.\n* 2. ISSUE BLDL AGAINST SYSLIB TO OBTAIN DIRECTORY INFO FOR\n*    THE MEMBER SPECIFIED. IF THE SPECIFIED MEMBER IS AN\n*    ALIAS, RE-ISSUE A BLDL FOR THE REAL MEMBER. PRINT\n*    DIRECTORY INFORMATION.\n* 3. POINT TO THE MEMBER IN THE SYSLIB PDS, AND PROCESS THE\n*    MEMBER. LOAD MODULES CONTAIN AN EXTERNAL SYMBOL DICTIONARY\n*    FOLLOWED BY TEXT AND RELOCATION DICTIONARY INFORMATION.\n*    ALL ESD INFO FOR THE MODULE PRECEDES THE FIRST CONTROL\n*    RECORD. A CONTROL RECORD PRECEDES EACH BLOCK OF TEXT.\n*    RLD INFO FOR THE TEXT FOLLOWS EACH TEXT BLOCK. PROCESSING\n*    OF LOAD MODULE INFORMATION IS AS FOLLOWS:\n*    A. BUILD AN EXTERNAL SYMBOL TABLE, USING THE CESD BLOCKS.\n*    B. SEARCH FOR THE DESIRED CSECT AS THE TABLE IS BEING\n*       BUILT. THIS CSECT MUST BE FOUND BEFORE THE FIRST\n*       CONTROL RECORD.\n*    C. READ BLOCKS UNTIL A CONTROL RECORD FOR THE DESIRED\n*       CSECT IS FOUND (BY ESD-ID). WHEN FOUND, SAVE THE\n*       TEXT FOR DISASSEMBLY, AND USE THE FOLLOWING RLD\n*       INFORMATION TO BUILD A RELOCATION DICTIONARY TO BE USED\n*       DURING DISASSEMBLY.\n* 4. DISASSEMBLY USES THE EXTERNAL SYMBOL TABLE, RELOCATION\n*    DICTIONARY, AND TEXT BUILT BY THE PREVIOUS STEPS.\n*\n*\n* AUTHOR R THORNTON - NOV 1977\n*        UPDATES (MARKED -EU- IN COLUMNS 68-71) DONE BY            -EU-\n*        MOINIL P.A. , COMPUTING CENTRE                            -EU-\n*                      J.R.C. - ISPRA ESTABLISHMENT                -EU-\n*                      21020 ISPRA (VA), ITALY                     -EU-\n         EJECT\n****************************************************************\n*                                                              *\n* PROCESS THE PARM FIELD, IF ANY.                              *\n*                                                              *\n****************************************************************\n         SPACE 1\n         L     R12,0(R1)               GET PARM FIELD ADDRESS\n         XR    R1,R1                   CLEAR WORK REG\n         ICM   R1,B'0011',0(R12)       PICK UP PARM LENGTH\n         BZ    OPENS                   NO PARM INFO ENTERED\n         LA    R12,2(R12)              GET PARM FIELD TEXT ADDRESS -EU-\nANYPARM  CH    R1,H5                   5-BYTES OF PARM\n         BNL   SGLPARM                 YES, ANALYZE SINGLE PARM    -EU-\nBADPARM  WTO   'KEYWORD INVALID OR SPECIFIED TWICE',ROUTCDE=11     -EU-\n         B     LEAVE                   EXIT                        -EU-\nSGLPARM  CLC   0(5,R12),=C'SUPVR'      IS PARM=SUPVR\n         BE    SUPARM                  YES\n         CLC   0(5,R12),=C'FLTPT'      PARM IS FLTPT\n         BE    FPTPARM                 YES                         -EU-\n         CLC   0(5,R12),=C'BREMC'      PARM IS BREMC               -EU-\n         BNE   BADPARM                 NO, ERROR\n         CLI   BREMASM,0               BR EXT. MNEMONICS SET       -EU-\n         BNE   BADPARM                 YES, ERROR                  -EU-\n         MVI   BREMASM,1               SET BR EXT. MNEMONICS O.K.  -EU-\n         B     TSTPARM                 CONTINUE                    -EU-\nFPTPARM  CLI   FLPTASM,0               FLOATING POINT SET          -EU-\n         BNE   BADPARM                 YES, ERROR                  -EU-\n         MVI   FLPTASM,1               SET FLOATING POINT O.K.\n         B     TSTPARM                 CONTINUE                    -EU-\nSUPARM   CLI   PRIVASM,0               PRIVILEGED INSTR SET        -EU-\n         BNE   BADPARM                 YES, ERROR                  -EU-\n         MVI   PRIVASM,1               SET PRIVILEGED INSTR O.K.\nTSTPARM  SH    R1,H5                   ANYMORE PARM TEXT           -EU-\n         BNP   OPENS                   NO, END OF PARM             -EU-\n         CLI   5(R12),C','             IS IT SEPARATOR             -EU-\n         BNE   BADPARM                 NO, ERROR                   -EU-\n         LA    R12,6(R12)              POINT TO NEXT PARM TEXT     -EU-\n         BCT   R1,ANYPARM              GO HANDLE ANY OTHER         -EU-\nOPENS    RDJFCB LOADLIB                WAS LOADLIB DD CARD INCLUDED\n         LTR   R15,R15                 JFCB READ O.K.\n         BNZ   OPEN1                   NO, DONT OPEN\n         OPEN  LOADLIB                 GOT DD CARD, OPEN FILE\n         EJECT\n****************************************************************\n*                                                              *\n* GET STORAGE FOR THE SYMBOL TABLE, RLD TABLE, AND DATA-ONLY   *\n* TABLES, AND OPEN FILES.                                      *\n*                                                              *\n****************************************************************\n         SPACE 1\nOPEN1    OPEN  (SYSPRINT,OUTPUT,SYSPUNCH,OUTPUT)\n         OPEN  (SYSLIB,,SYSIN)         OPEN FILES\n         L     R2,INDCB                                            -EU-\n         USING IHADCB,R2                                           -EU-\n         TM    DCBOFLGS,DCBOFOPN       DID SYSIN OPEN O.K.         -EU-\n         BZ    NOCTL                   NO\n         DROP  R2                                                  -EU-\n         BAS   R9,GETCTL               EXTRACT DESIRED MEMBER AND CSECT\n         BAS   R9,BLDL                 ISSUE BLDL AND PRINT\n         MVI   CCAT,0                  INSURE TTR0\n         L     R1,=A(SYSLIB)                                       -EU-\n         POINT (1),TTRMOD              POINT TO 1ST BLOCK OF MODULE\n         L     R0,BUFLGTH              BUFFER STORAGE LENGTH       -EU-\n         GETMAIN R,LV=(0)              GET BUFFER STORAGE          -EU-\n         ST    R1,BUFAD                SAVE BUFFER ADDRESS\n         L     R0,SYMLGTH              SYMBOL TABLE STORAGE LENGTH -EU-\n         GETMAIN R,LV=(0)              GET SYMBOL TABLE STORAGE    -EU-\n         ST    R1,SYMTBAD              SAVE SYMBOL TABLE ADDRESS\n         ST    R1,CURRSYM              SAVE CURRENT SYMBOL ADDRESS\n         MVI   0(R1),X'FF'             TABLE END INDIC\n         A     R1,SYMLGTH              COMPUTE END ADDRESS         -EU-\n         ST    R1,ENDSYM               STORE TBL END ADDRESS\n         L     R0,RLDLGTH              RLD TABLE STORAGE LENGTH    -EU-\n         GETMAIN R,LV=(0)              GET RLD TABLE STORAGE       -EU-\n         ST    R1,RLDTBL               SAVE RLD TABLE ADDRESS\n         ST    R1,CURRLD               SAVE CURRENT RLD ADDRESS\n         MVI   0(R1),X'FF'             TABLE END INDIC\n         A     R1,RLDLGTH              COMPUTE END ADDRESS         -EU-\n         ST    R1,ENDRLD               STORE TBL END ADDRESS\n         L     R0,DATLGTH              DATA ONLY TABLE STOR. LENGTH-EU-\n         GETMAIN R,LV=(0)              GET DATA ONLY TABLE STORAGE -EU-\n         ST    R1,DATONLY              SAVE TBL ADDRESS\n         MVC   0(3,R1),HIVAL           SET END VALUE\n         ST    R1,DATSTART             SAVE START ADDRESS          -EU-\n         ST    R1,DATOCUR              SET CURRENT ADDRESS\n         A     R1,ENDATO               COMPUTE TABLE END ADDRESS\n         ST    R1,DATOEND              SAVE END ADDRESS\n         MVC   PRT+15(29),=C'*** EXTERNAL SYMBOL TABLE ***'\n         MVI   PCC,C'-'                SET SKIP 3 LINES\n         BAS   R9,PRINT                PRINT\n         MVC   PRTLINE,SYMHDR          SYM TBL HEADER\n         BAS   R9,PRINT                PRINT\n         EJECT\n******************************************************************\n*                                                                *\n* CHECK FOR PRIVILEGED AND/OR FLOATING POINT INSTRUCTION OPTION. *\n* IF THESE INSTRUCTIONS ARE NOT TO BE ASSEMBLED, CLEAR THEIR     *\n* INSTRUCTION TABLE ENTRIES.                                     *\n*                                                                *\n******************************************************************\n         SPACE 1\n         CLI   FLPTASM,1               FLOATING POINT INSTR O.K.\n         BE    TSTPRIV                 YES\n         L     R12,SGLOPAD             POINT TO OP-CODE TBL        -EU-\n         USING INSTWA,R12                                          -EU-\nTSTOPND  CLI   0(R12),X'FF'            END OF TBL\n         BE    CKDBLST                 YES                         -EU-\n         TM    ICLASS,FLTPT            IS IT FLOATING POINT        -EU-\n         BZ    FLPSTP                  NO\n         XC    0(L'SGLOP-1,R12),0(R12) CLEAR ENTRY                 -EU-\nFLPSTP   LA    R12,L'SGLOP(R12)        TO NEXT ENTRY\n         B     TSTOPND                 LOOP THRU TABLE\nCKDBLST  L     R12,DBLOPAD             @ 2-BYTE OP-CODE TBL        -EU-\nCKDBNDT  CLI   0(R12),X'FF'            END OF TBL                  -EU-\n         BE    TSTPRIV                 YES                         -EU-\n         TM    ICLASS+2,FLTPT          IS IT FLOATING POINT        -EU-\n         BZ    DBSTPT                  NO                          -EU-\n         XC    0(L'DBLOP-1,R12),0(R12) YES, CLEAR ENTRY            -EU-\nDBSTPT   LA    R12,L'DBLOP(R12)        TO NEXT ENTRY               -EU-\n         B     CKDBNDT                 LOOP THRU TABLE             -EU-\nTSTPRIV  CLI   PRIVASM,1               PRIVILEGED INSTR O.K.\n         BE    MAINLINE                YES                         -EU-\n         L     R12,SGLOPAD             POINT TO OP-CODE TBL        -EU-\nTTOPND   CLI   0(R12),X'FF'            END OF TABLE\n         BE    CKDBLS                  YES\n         TM    ICLASS,PRIV             IS IT PRIVILEGED INSTR      -EU-\n         BZ    PRIVSTP                 NO\n         XC    0(L'SGLOP-1,R12),0(R12) YES, CLEAR ENTRY            -EU-\nPRIVSTP  LA    R12,L'SGLOP(R12)        TO NEXT ENTRY\n         B     TTOPND                  LOOP THRU TABLE\nCKDBLS   L     R12,DBLOPAD             @ 2-BYTE OP-CODE TBL\nCKDBND   CLI   0(R12),X'FF'            END OF TBL\n         BE    MAINLINE                YES                         -EU-\n         TM    ICLASS+2,PRIV           IS IT PRIVILEGED OP-CODE    -EU-\n         BZ    DBSTP                   NO\n         XC    0(L'DBLOP-1,R12),0(R12) YES, CLEAR ENTRY            -EU-\nDBSTP    LA    R12,L'DBLOP(R12)        TO NEXT ENTRY\n         B     CKDBND                  LOOP THRU TABLE\n         DROP  R12                                                 -EU-\n         EJECT\n****************************************************************\n*                                                              *\n* MAINLINE PROCESSING FOR THE LOAD MODULE. THE DIRECTORY ENTRY *\n* AND TEXT ARE PROCESSED.                                      *\n*                                                              *\n****************************************************************\n         SPACE 1\nMAINLINE L     R6,BUFAD                GET BUFFER ADDRESS\n         READ  DECB,SF,SYSLIB,(6),'S'  READ BLOCK FROM MEMBER\n         CHECK DECB                    AWAIT COMPLETION\n         CLI   0(R6),X'20'             CESD RECORD\n         BNE   TESTOTHR                NO\n         BAS   R9,CESDREC              PROCESS CESD RECORDS\n         B     MAINLINE                GO READ AGAIN\nTESTOTHR LA    R9,CNTLRECS             ASSUME CONTROL RECORD\n         CLI   0(R6),1                 IT IS CONTROL\n         BE    PERFORM                 YES\n         CLI   0(R6),5                 IS IT CONTROL\n         BE    PERFORM                 YES\n         CLI   0(R6),13                IS IT CONTROL\n         BE    PERFORM                 YES\n         LA    R9,RLDRECS              ASSUME RLD RECORD\n         CLI   0(R6),2                 IS IT RLD\n         BE    PERFORM                 YES\n         CLI   0(R6),6                 IS IT RLD\n         BE    PERFORM                 YES\n         CLI   0(R6),14                IS IT RLD\n         BE    PERFORM                 YES\n         LA    R9,CTRLRECS             ASSUME CONTROL AND RLD\n         CLI   0(R6),3                 IS IT CTL AND RLD\n         BE    PERFORM                 YES\n         CLI   0(R6),7                 IS IT CTL AND RLD\n         BE    PERFORM                 YES\n         CLI   0(R6),15                IS IT CTL AND RLD\n         BE    PERFORM                 YES\n         B     MAINLINE                NONE OF THESE, SKIP\nPERFORM  TM    PROCESS,X'80'           WAS CSECT FOUND\n         BZ    MISSCS                  NO, ERROR\n         BASR  R9,R9                   PERFORM APPROPRIATE ROUTINE\n         TM    PROCESS,X'40'           MODULE PROCESSING DONE\n         BZ    MAINLINE                NO, GO READ AGAIN\n         MVI   EOFSW,0                 SET END OF FILE SWITCH\n         B     ENDINIT                 GO COMPLETE PROCESSING\n         EJECT\n****************************************************************\n*                                                              *\n* PROCESS LOAD MODULE CONTROL RECORDS. THESE RECORDS PRECEDE   *\n* TEXT RECORDS, WHICH ARE READ AND PLACED IN STORAGE IN CONTIG-*\n* UOUS LOCATIONS SO THAT THE TEXT FOR THE DESIRED CSECT WILL   *\n* ALL BE IN STORAGE FOR THE REMAINDER OF DISASSEMBLY.          *\n*                                                              *\n****************************************************************\n         SPACE 1\nCNTLRECS ST    R9,CT9                  SAVE RETURN ADDR\n         XR    R8,R8                   CLEAR WORK\n         ICM   R8,B'0111',9(R6)        LKED ASGND @ OF TXT\n         TM    0(R6),X'08'             RECORD PRECEDES LAST RECORD OF M\n         BZ    CNCKTYP                 NO\n         OI    PROCESS,X'40'           YES, SHOW PROCESSING COMPLETE\nCNCKTYP  TM    0(R6),X'02'             CONTROL AND RLD\n         BO    CNPASRLD                YES\n         LA    R12,16(R6)              @ CESD ENTRY NBR\n         B     CNCKESD                 CONTINUE\nCNPASRLD LH    R12,6(R6)               GET RLD SECTION LENGTH\n         LA    R12,16(R6,R12)          @ CESD ENTRY NBR\nCNCKESD  LH    R11,4(R6)               LENGTH OF CONTROL INFO SECTION\n         SRL   R11,2                   COMPUTE NBR CNTL ENTRIES\n         XR    R10,R10                 OFFSET TO 1ST BYTE\n         XR    R9,R9                   LENGTH OF TEXT\nCNCKESD1 CLC   ESDID,0(R12)            THIS THE DESIRED ESD   FIX***\n         BE    CNFNDIT                 YES\n         AH    R10,2(R12)              MAINTAIN OFFSET TO 1ST TEXT BYTE\n         LA    R12,4(R12)              TO NEXT CNTL ENTRY\n         BCT   R11,CNCKESD1            LOOP THRU CNTL ENTRIES  FIX***\n         B     READTEXT                GO READ FOLLOWING TEXT\nCNFNDIT  LH    R9,2(R12)               GET TEXT LENGTH\nREADTEXT READ  DECB,SF,,(6),MF=E       READ FOLLOWING TEXT RECORD\n         CHECK DECB                    AWAIT COMPLETION\n         LTR   R9,R9                   DOES IT CONTAIN DESIRED TEXT\n         BZ    CTXIT                   NO, SKIP IT\n         S     R8,START                (-) OFFSET IN MODULE    FIX***\n         AR    R8,R10                  ADD OFFSET OF PORTION IN RCD  **\n*              R8 SHOULD NOW CONTAIN THE OFFSET WITHIN THE CSECT\n*              THAT THIS BLOCK CONTAINS (TRICKY).\n         A     R10,BUFAD               @ 1ST TEXT BYTE\n***      S     R8,START    MOVED UP    RELATIVIZE TEXT ADDR    FIX***\n         A     R8,TXTSTRT              @ PLACE TO MOVE TEXT\n         LR    R11,R9                  COPY LENGTH TO MOVE\n         MVCL  R8,R10                  MOVE TEXT TO STORAGE\nCTXIT    L     R9,CT9                  GET RETURN ADDR\n         BR    R9                      EXIT\n         EJECT\n****************************************************************\n*                                                              *\n* PROCESS RLD RECORDS. A TABLE OF RLD DATA IS BUILT WHICH WILL *\n* LATER BE USED TO BUILD PROGRAM LABELS AND ADCONS.            *\n*                                                              *\n****************************************************************\n         SPACE 1\nRLDRECS  TM    0(R6),X'08'             LAST RECORD OF MODULE\n         BZ    RLSV9                   NO\n         OI    PROCESS,X'40'           SHOW PROCESSING COMPLETE\nRLSV9    ST    R9,RL9                  SAVE RETURN ADDR\nRLDSW    NOP   RLDST                   FIRST TIME SWITCH\n         MVI   RLDSW+1,C'0'            RESET 1ST TIME SW\n         MVC   PRT+15(20),=C'***** RLD INFO *****'\n         MVI   PCC,C'-'                SKIP 3 LINES\n         BAS   R9,PRINT                PRINT\n         MVC   PRTLINE,RLDHDR          RLD HEADER\n         BAS   R9,PRINT                PRINT RLD HEADER\nRLDST    LH    R8,6(R6)                NBR BYTES OF RLD DATA\n         LA    R6,16(R6)               @ 1ST BYTE OF RLD DATA\n         AR    R8,R6                   END OF RLD DATA ADDR\n         L     R7,CURRLD               @ NEXT RLD TBL ENTRY\n         USING RLDTBLD,R7\n         LH    R10,0(R6)               RELOCATION POINTER\n         LH    R11,2(R6)               POSITION POINTER\n         LA    R6,4(R6)                PASS POINTERS\nRLDNXT   CLC   1(3,R6),START+1         RLD ADDR BELOW CSECT\n         BL    RLDSTEP                 LOW, IGNORE\n         CLC   1(3,R6),END+1           RLD ADDR ABOVE CSECT\n         BH    RLDSTEP                 HIGH, IGNORE\n         C     R7,ENDRLD               END OF RLD TBL\n         BE    RLDFULL                 YES, ERROR\n         STH   R10,RLDRP               SAVE RELOC PTR\n         STH   R11,RLDPP               POS PTR\n         PACK  RLDTYPE,0(1,R6)         INVERT FLAG BYTE\n         NI    RLDTYPE,X'0F'           CLEAR HI-ORDER\n         CLI   RLDTYPE,9               UNRESOLVED\n         BNE   RLDMOVLN                NO\n         MVI   RLDTYPE,8               YES, USE PREFERRED VALUE\nRLDMOVLN MVC   RLDLEN,0(R6)            FLAG BYTE\n         NI    RLDLEN,X'0F'            CLEAR HI-ORDER\n         XR    R12,R12                 CLEAR WORK\n         IC    R12,RLDLEN              PICK UP BYTE\n         SRL   R12,2                   SHIFT OUT DIR, IND BITS\n         LA    R12,1(R12)              ADD 1 = LENGTH\n         STC   R12,RLDLEN              LENGTH CODE\n         MVI   RLDDIR,C'+'             ASSUME POS RELOC\n         TM    0(R6),2                 IS IT POSITIVE\n         BZ    RLADMV                  YES\n         MVI   RLDDIR,C'-'             NO, SHOW NEGATIVE\nRLADMV   XR    R1,R1                   CLEAR WORK REG\n         ICM   R1,B'0111',1(R6)        PICK UP ADDRESS\n         S     R1,START                RELATIVIZE WITHIN CSECT\n         STCM  R1,B'0111',RLDADDR      SAVE RELATIVE ADDRESS\n         LA    R12,RLDRP               @ RELOC PTR\n         BAS   R9,HEXPRT2              CONVERT\n         MVC   PRT+6(4),PRTABL         RELOC PTR\n         LA    R12,RLDPP               @ POS PTR\n         BAS   R9,HEXPRT2              CONVERT\n         MVC   PRT+14(4),PRTABL        POS PTR\n         MVC   PRT+24(4),=C'ACON'      ASSUME A TYPE ADCON\n         CLI   RLDTYPE,0               IS IT ADCON\n         BE    RLDLN                   YES\n         MVC   PRT+24(4),=C'VCON'      ASSUME VCON\n         CLI   RLDTYPE,1               IS IT VCON\n         BE    RLDLN                   YES\n         MVC   PRT+22(6),=C'PRDISP'    ASSUME PSEUDO REG DISPL\n         CLI   RLDTYPE,2               IS IT P.R. DISPL\n         BE    RLDLN                   YES\n         MVC   PRT+22(6),=C'PRCUM'     ASSUME PSEUDO REG CUMUL DISPL\n         CLI   RLDTYPE,3               IS IT P.R. CUM DISPL\n         BE    RLDLN                   YES\n         MVC   PRT+21(10),=C'UNRESOLVED' ASSUME UNRESOLVED\n         CLI   RLDTYPE,8               IS IT UNRESOLVED\n         BE    RLDLN                   YES\n         MVC   PRT+21(10),BLANX        CLEAR FIELD\n         MVC   PRT+24(3),=C'??:'\n         LA    R12,RLDTYPE             @ TYPE\n         BAS   R9,HEXPRT1              CONVERT\n         MVC   PRT+27(1),PRTABL+1      TYPE\nRLDLN    MVC   PRT+35(1),RLDLEN        LENGTH\n         OI    PRT+35,C'0'             CLEAR ZONE\n         MVC   PRT+42(1),RLDDIR        RELOCATION DIRECTION\n         LA    R12,RLDADDR             @ ADDRESS\n         BAS   R9,HEXPRT3              CONVERT\n         MVC   PRT+46(6),PRTABL        ADDRESS\n         XC    RLDNAME(9),RLDNAME      CLEAR\n         LH    R15,RLDRP               GET RELOCATION POINTER\n         BCTR  R15,0                   DEDUCT 1\n         LTR   R15,R15                 TEST DIFFERENCE\n         BM    RLPRT                   NEG, ERROR\n         MH    R15,SYMLEN              TIMES SYM TBL ENTRY LENG\n         A     R15,SYMTBAD             @ ESD SYMBOL TBL ENTRY\n         C     R15,CURRSYM             PAST END OF TABLE\n         BH    RLPRT                   YES, ERROR\n         USING SYMTBL,R15\n         MVC   RLDNAME,EXTSYM          ESD SYMBOL TO RLD TBL ENTRY\n         MVC   RLDESDTP,TYPSYM         ESD TYPE TO RLD ENTRY\n         DROP  R15\n         MVC   PRT+60(8),RLDNAME       NAME TO PRINT\n         MVC   PRT+70(2),=C'LR'        ASSUME LR\n         CLI   RLDESDTP,3              IS IT LR\n         BE    RLPRT                   YES\n         MVC   PRT+70(2),=C'SD'        ASSUME SD\n         CLI   RLDESDTP,0              IS IT SD\n         BE    RLPRT                   YES\n         MVC   PRT+70(2),=C'ER'        ASSUME ER\n         CLI   RLDESDTP,2              IS IT ER\n         BE    RLPRT                   YES\n         MVC   PRT+70(2),=C'PC'        ASSUME PC\n         CLI   RLDESDTP,4              IS IT PC\n         BE    RLPRT                   YES\n         MVC   PRT+70(2),=C'PR'        ASSUME PR\n         CLI   RLDESDTP,6              IS IT PR\n         BE    RLPRT                   YES\n         MVC   PRT+70(2),=C'CM'        ASSUME CM\n         CLI   RLDESDTP,5              IS IT CM\n         BE    RLPRT                   YES\n         MVC   PRT+70(2),=C'WX'        ASSUME WX\n         CLI   RLDESDTP,X'0A'          IS IT WX\n         BE    RLPRT                   YES\n         MVC   PRT+70(4),=C'NULL'      ASSUME NULL\n         CLI   RLDESDTP,7              IS IT NULL\n         BE    RLPRT                   YES\n         MVC   PRT+70(6),=C'E/STAB'    ASSUME E/STAB\n         CLI   RLDESDTP,X'0F'          IS IT E/STAB\n         BE    RLPRT                   YES\n         MVC   PRT+70(6),=C'??????'    UNKNOWN YPE\nRLPRT    BAS   R9,PRINT                PRINT\n         CLC   RLDNAME,CSECT           RLD NAME IS CSECT NAME\n         BNE   GOODRLD                 NO\n         CLC   RLDADDR,XZROS           RELATIVE OFFSET IS ZERO\n         BE    RLDSTEP                 YES, IGNORE ENTRY\nGOODRLD  LA    R7,L'RLDENT(R7)         TO NEXT TBL ENTRY\nRLDSTEP  TM    0(R6),1                 NEXT ITEM HAS REL AND POS PTRS\n         BO    RLSAME                  NO\n         LH    R10,4(R6)               PICK UP NEW REL PTR\n         LH    R11,6(R6)               PICK UP NEW POS PTR\n         LA    R6,4(R6)                STEP OVER 4 BYTES\nRLSAME   LA    R6,4(R6)                TO NEXT RLD ITEM\n         CR    R6,R8                   END OF RLD DATA\n         BL    RLDNXT                  NO\n         MVI   0(R7),X'FF'             SET TBL END INDIC\n         ST    R7,CURRLD               SET NEW CURRENT ADDRESS\n         L     R9,RL9                  GET RETURN ADDR\n         BR    R9                      EXIT\n         DROP  R7\n         EJECT\n****************************************************************\n*                                                              *\n* PROCESS CONTROL AND RLD RECORDS. THESE RECORDS CONTAIN BOTH  *\n* RLD AND CONTROL INFORMATION, AND ARE PROCESSED BY BOTH       *\n* THE RLDRECS AND CNTLRECS ROUTINES.                           *\n*                                                              *\n****************************************************************\n         SPACE 1\nCTRLRECS ST    R9,CR9                  SAVE RETURN ADDR\n         BAS   R9,RLDRECS              PROCESS RLD DATA\n         L     R6,BUFAD                RESET BUFFER ADDRESS\n         BAS   R9,CNTLRECS             PROCESS CONTROL DATA\n         L     R9,CR9                  GET RETURN ADDR\n         BR    R9                      EXIT\n         SPACE 2\n****************************************************************\n*                                                              *\n* PROCESS COMPOSITE ESD RECORDS. DATA FROM THESE RECORDS IS    *\n* PLACED IN THE SYMBOL TABLE, AND IS USED TO CREATE PROGRAM    *\n* ENTRY STATEMENTS, AND TO IDENTIFY THE NAMES OF EXTERNAL      *\n* SYMBOLS USED BY THE PROGRAM.                                 *\n*                                                              *\n****************************************************************\n         SPACE 1\nCESDREC  ST    R9,CES9                 SAVE RETURN\n         L     R7,CURRSYM              GET SYMBOL TBL ADDR\n         USING SYMTBL,R7\n         LH    R10,4(R6)               GET ESD ID OF 1ST ITEM\n         LH    R8,6(R6)                NBR BYTES OF ESD DATA\n         SRL   R8,4                    COMPUTE NBR ENTRIES\n         LA    R6,8(R6)                STEP TO 1ST RECORD ESD ITEM\nCESDNXT  C     R7,ENDSYM               END OF TABLE\n         BNL   SYMFULL                 YES, ERROR\n         MVC   EXTSYM,0(R6)            SYMBOL NAME\n         MVC   TYPSYM,8(R6)            TYPE\n         NI    TYPSYM,X'0F'            CLEAR BITS 0-3\n         MVC   SYMIND,8(R6)            INDICATOR BYTE\n         NI    SYMIND,X'0F'            CLEAR BITS 4-7\n         TM    8(R6),X'14'             POSSIBLE ENTAB/SEGTAB\n         BNO   CEMVAD                  NO\n         TM    8(R6),X'03'             IS IT ENTAB/SEGTAB\n         BNZ   CEMVAD                  NO\n         MVC   TYPSYM(2),=X'0F00'      SHOW ENTAB/SEGTAB\nCEMVAD   MVC   SYMADDR,9(R6)           ADDRESS OF SYMBOL\n         MVC   SYMSEG,12(R6)           SEGMENT WHERE DEFINED\n         MVC   SYMLENG,13(R6)          LENGTH OR LR ESD ID\n         STCM  R10,B'0011',SYMESDID    ESD ID\n         MVC   PRT+5(8),EXTSYM         SYMBOL NAME\n         MVC   PRT+20(2),=C'SD'        ASSUME SD\n         CLI   TYPSYM,0                IS IT SD\n         BE    CEPIND                  YES\n         MVC   PRT+20(2),=C'LR'        ASSUME LR\n         CLI   TYPSYM,3                IS IT LR\n         BE    CEPIND                  YES\n         MVC   PRT+20(2),=C'ER'        ASSUME ER\n         CLI   TYPSYM,2                IS IT ER\n         BE    CEPIND                  YES\n         MVC   PRT+20(2),=C'PC'        ASSUME PC\n         CLI   TYPSYM,4                IS IT PC\n         BE    CEPIND                  YES\n         MVC   PRT+20(2),=C'PR'        ASSUME PR\n         CLI   TYPSYM,6                IS IT PR\n         BE    CEPIND                  YES\n         MVC   PRT+20(2),=C'CM'        ASSUME CM\n         CLI   TYPSYM,5                IS IT CM\n         BE    CEPIND                  YES\n         MVC   PRT+20(2),=C'WX'        ASSUME WX\n         CLI   TYPSYM,X'0A'            IS IT WX\n         BE    CEPIND                  YES\n         MVC   PRT+19(4),=C'NULL'      ASSUME NULL\n         CLI   TYPSYM,7                IS IT NULL\n         BE    CEPIND                  YES\n         MVC   PRT+18(6),=C'E/STAB'    ASSUME ENTAB/SEGTAB\n         CLI   TYPSYM,X'0F'            IS IT ENTAB/SEGTAB\n         BE    CEPIND                  YES\n         MVC   PRT+18(4),=C' ??: '     UNIDENTIFIABLE TYPE\n         LA    R12,TYPSYM              @ TYPE\n         BAS   R9,HEXPRT1              CONVERT\n         MVC   PRT+23(2),PRTABL        TYPE\nCEPIND   LA    R12,SYMIND              @ INDICATOR\n         BAS   R9,HEXPRT1              CONVERT\n         MVC   PRT+27(1),PRTABL        INDICATOR\n         LA    R12,SYMADDR             @ SYMBOL ADDR\n         BAS   R9,HEXPRT3              CONVERT\n         MVC   PRT+30(6),PRTABL        SYMBOL ADDR\n         LA    R12,SYMSEG              @ SEGMENT NBR\n         BAS   R9,HEXPRT1              CONVERT\n         MVC   PRT+39(2),PRTABL        SEGMENT NBR\n         CLI   TYPSYM,2                IS IT ER\n         BE    CEESD                   YES\n         CLI   TYPSYM,3                IS IT AN LR\n         BNE   CENOTLR                 NO\n         LA    R12,SYMLRID             @ LR ESD ID\n         BAS   R9,HEXPRT2              CONVERT\n         MVC   PRT+43(4),PRTABL        LR ESD ID\n         B     CEESD                   CONTINUE\nCENOTLR  LA    R12,SYMLENG             @ LENGTH\n         BAS   R9,HEXPRT3              CONVERT\n         MVC   PRT+49(6),PRTABL        SYMBOL LENGTH\nCEESD    LA    R12,SYMESDID            @ ESD ID\n         BAS   R9,HEXPRT2              CONVERT\n         MVC   PRT+57(4),PRTABL        ESD ID\n         TM    PROCESS,X'80'           FOUND CSECT\n         BO    CESDPT                  YES\n         CLI   TYPSYM,0                SD\n         BE    CECKCSB                 YES\n         CLI   TYPSYM,4                PC\n         BNE   CESDPT                  NO\nCECKCSB  CLC   CSECT,BLANX             ANY CSECT NAME ENTERED\n         BNE   CECKNM                  YES\n         MVC   CSECT,EXTSYM            NAME TO CSECT\n         B     CSGOTCS                 CONTINUE\nCECKNM   CLI   TYPSYM,4                PC\n         BE    CESDPT                  YES\n         CLC   CSECT,EXTSYM            FOUND DESIRED NAME\n         BNE   CESDPT                  NO\n         TM    PROCESS,X'80'           ALREADY FOUND CSECT\n         BZ    CSGOTCS                 NO\n         MVC   PRT+15(2),=C'??'        SHOW DUPL\n         B     CESDPT                  CONTINUE\nCSGOTCS  OI    PROCESS,X'80'           SHOW CSECT FOUND\n         MVC   PRT+15(2),=C'**'        FLAG ON PRINTOUT\n         MVC   ESDID,SYMESDID          SAVE ESD ID FOUND\n         MVC   START+1,SYMADDR         SAVE CSECT START ADDR\n         MVC   LENGTH+1(3),SYMLENG     SAVE CSECT LENGTH\n         L     R1,LENGTH               PICK UP LENGTH\n         A     R1,START                COMPUTE CSECT END ADDR\n         ST    R1,END                  SAVE CSECT END ADDR\n         L     R11,LENGTH              TEXT LENGTH\n         LA    R11,256(R11)            ADD FOR SAFETY\n         ST    R11,TXTLGTH             SAVE TEXT LENGTH            -EU-\n         GETMAIN R,LV=(R11)            GET STORAGE FOR TEXT\n         ST    R1,TXTSTRT              SAVE TEXT ADDRESS\n         SH    R11,H256                DEDUCT SAFETY FACTOR\n         AR    R1,R11                  TXT END ADDRESS\n         ST    R1,TXTEND               SAVE TEXT END ADDRESS\nCESDPT   BAS   R9,PRINT                PRINT\n         LA    R7,L'SYMENT(R7)         TO NEXT TBL ENTRY LOCATION\n         LA    R10,1(R10)              ADD 1 TO ESD COUNTER\n         LA    R6,16(R6)               TO NEXT ESD ITEM IN INPUT\n         BCT   R8,CESDNXT              LOOP THRU INPUT RECORD\n         MVI   0(R7),X'FF'             SET END OF TABLE INDIC\n         ST    R7,CURRSYM              SAVE NEXT TABLE ADDR\n         L     R9,CES9                 GET RETURN ADDR\n         BR    R9                      EXIT\n         DROP  R7\n         EJECT\n****************************************************************\n*                                                              *\n* ISSUE BLDL FOR THE MAIN MODULE, AND PRINT MODULE RELATED INFO*\n*                                                              *\n****************************************************************\n         SPACE 1\nBLDL     ST    R9,BL9                  SAVE RETURN ADDR\nISSBLDL  L     R1,=A(SYSLIB)                                       -EU-\n         BLDL  (1),BLDLIST             ISSUE BLDL\n         LTR   R15,R15                 ANY ERRORS\n         BNZ   MISSMEM                 YES\n         LA    R1,MEMBER+35            END OF BASIC PORTION\n         TM    ATTR2,X'10'             SSI PRESENT\n         BZ    BLREFA1                 NO\n         LA    R1,4(R1)                ADD FOR SSI\nBLREFA1  TM    ALIASIND,X'80'          ALIAS\n         BZ    BLREFA2                 NO\n         LA    R1,11(R1)               ADD FOR ALIAS\n         B     BLREFA3                 NO                          -EU-\nBLREFA2  TM    ATTR2,X'10'             SSI PRESENT                 -EU-\n         BZ    BLREFA3                 NO                          -EU-\n         LA    R1,1(R1)                ADJUST TO HALF-WORD BOUNDARY-EU-\nBLREFA3  TM    ATTR1A,X'04'            SCATTER FORMAT\n         BZ    BLREFA4                 NO\n         LA    R1,8(R1)                ADD FOR SCATTER\nBLREFA4  MVC   AUTHLEN(2),0(R1)        AUTH LENGTH AND CODE\n         TM    ATTR2,X'10'             SSI PRESENT\n         BZ    BLCKALI                 NO\n         LA    R1,MEMBER+35            END OF BASIC PORTION\n         TM    ATTR1A,X'04'            SCATTER FORMAT\n         BZ    BLSSI1                  NO\n         TM    ALIASIND,X'80'          ALIAS\n         BO    BLFMTED                 YES, NO REFORMAT NEEDED\n         LA    R1,8(R1)                NO, STEP PAST SCATTER SECTION\n         B     BLSSI2                  GO MOVE SSI                 -EU-\nBLSSI1   TM    ALIASIND,X'80'          ALIAS                       -EU-\n         BZ    BLSSI2                  NO                          -EU-\n         LA    R1,10(R1)               YES, STEP PAST ALIAS SECTION-EU-\nBLSSI2   LA    R1,1(R1)                ADJUST TO HALF-WORD BOUNDARY-EU-\n         MVC   SSI,0(R1)               MOVE SSI DATA\nBLCKALI  TM    ALIASIND,X'80'          ALIAS\n         BO    BLASC                   YES\n         B     BLFMTED                 FINISHED\nBLASC    TM    ATTR1A,X'04'            SCATTER FORMAT\n         BO    BLFMTED                 YES, NO REFORMAT NEEDED\n         MVC   ALMEM,MEMBER+38         MOVE ALIAS MEMBER\n         MVC   ALEPA(3),MEMBER+35      YES, MOVE ALIAS DATA\nBLFMTED  MVC   PRT(26),=C'DIRECTORY INFO FOR MODULE '\n         MVC   PRT+27(8),MEMBER        MEMBER NAME TO PRINT\n         BAS   R9,PRINT                PRINT\n         MVC   PRT+10(14),=C'TTR OF MODULE='\n         LA    R12,TTRMOD              @ TTR\n         BAS   R9,HEXPRT3              CONVERT\n         MVC   PRT+24(6),PRTABL        TTR TO PRINT\n         BAS   R9,PRINT                PRINT\n         MVC   PRT+10(18),=C'CONCATENATION NBR='\n         LA    R12,CCAT                @ CONCATENATION NBR\n         BAS   R9,HEXPRT1              CONVERT\n         MVC   PRT+28(2),PRTABL        CONCATENATION NBR\n         BAS   R9,PRINT                PRINT\n         MVC   PRT+10(12),=C'ALIAS INDIC='\n         LA    R12,ALIASIND            @ ALIAS INDICATOR\n         BAS   R9,HEXPRT1              CONVERT\n         MVC   PRT+22(2),PRTABL        ALIAS INDICATOR\n         TM    ALIASIND,X'80'          IS IT AN ALIAS\n         BZ    BLALPRT                 NO\n         MVC   PRT+50(13),=C'*** ALIAS ***'\nBLALPRT  BAS   R9,PRINT                PRINT\n         MVC   PRT+10(18),=C'TTR, 1ST TXT RECD='\n         LA    R12,TTR1TXT             @ TTR\n         BAS   R9,HEXPRT3              CONVERT\n         MVC   PRT+28(6),PRTABL        TTR OF 1ST TXT BLOCK\n         BAS   R9,PRINT                PRINT\n         MVC   PRT+10(25),=C'TTR OF NOTE/SCATTER LIST='\n         LA    R12,TTRNS               @ TTR\n         BAS   R9,HEXPRT3              CONVERT\n         MVC   PRT+35(6),PRTABL        TTR OF NOTE/SCATTER\n         BAS   R9,PRINT                PRINT\n         MVC   PRT+10(17),=C'NBR NOTE ENTRIES='\n         LA    R12,NNOTE               @ NBR NOTES\n         BAS   R9,HEXPRT1              CONVERT\n         MVC   PRT+27(2),PRTABL        NBR NOTE ENTRIES\n         BAS   R9,PRINT                PRINT\n         MVC   PRT+10(13),=C'ATTRIBUTES 1='\n         LA    R12,ATTR1A              @ ATTRIBUTES\n         BAS   R9,HEXPRT2              CONVERT\n         MVC   PRT+23(4),PRTABL        ATTRIBUTES 1\n         TM    ATTR1A,X'80'            RENT\n         BZ    BLAT1A                  NO\n         MVC   PRT+30(4),=C'RENT'\nBLAT1A   TM    ATTR1A,X'40'            REUS\n         BZ    BLAT1B                  NO\n         MVC   PRT+35(4),=C'REUS'\nBLAT1B   TM    ATTR1A,X'20'            OVLY\n         BZ    BLAT1C                  NO\n         MVC   PRT+40(4),=C'OVLY'\nBLAT1C   TM    ATTR1A,X'10'            TEST\n         BZ    BLAT1D                  NO\n         MVC   PRT+45(4),=C'TEST'\nBLAT1D   TM    ATTR1B,X'08'            OL\n         BZ    BLAT1E                  NO\n         MVC   PRT+50(2),=C'OL'\nBLAT1E   TM    ATTR1A,X'04'            SCTR\n         BZ    BLAT1F                  NO\n         MVC   PRT+53(4),=C'SCTR'\nBLAT1F   TM    ATTR1A,X'02'            EXEC\n         BZ    BLAT1G                  NO\n         MVC   PRT+58(4),=C'EXEC'\nBLAT1G   TM    ATTR1B,X'01'            REFR\n         BZ    BLAT1PRT                NO\n         MVC   PRT+63(4),=C'REFR'\nBLAT1PRT BAS   R9,PRINT                PRINT\n         MVC   PRT+10(13),=C'TOTAL LENGTH='\n         LA    R12,TOTVIRT             @ TOTAL LENGTH\n         BAS   R9,HEXPRT3              CONVERT\n         MVC   PRT+23(6),PRTABL        TOTAL LENGTH OF MODULE\n         BAS   R9,PRINT                PRINT\n         MVC   PRT+10(23),=C'LENGTH OF 1ST TXT RECD='\n         LA    R12,LENG1               @ 1ST TXT LENG\n         BAS   R9,HEXPRT2              CONVERT\n         MVC   PRT+33(4),PRTABL        LENGTH OF 1ST TXT BLOCK\n         BAS   R9,PRINT                PRINT\n         MVC   PRT+10(11),=C'E. P. ADDR='\n         LA    R12,LKEPA               @ E.P. ADDR\n         BAS   R9,HEXPRT3              CONVERT\n         MVC   PRT+21(6),PRTABL        E.P. ADDR\n         BAS   R9,PRINT                PRINT\n         MVC   PRT+10(13),=C'ATTRIBUTES 2='\n         LA    R12,ATTR2               @ ATTRIBUTES 2\n         BAS   R9,HEXPRT1              CONVERT\n         MVC   PRT+23(2),PRTABL        ATTRIBUTES 2\n         TM    ATTR2,X'20'             PAGE ALIGNMENT\n         BZ    BLAT3A                  NO\n         MVC   PRT+30(16),=C'PAGE ALIGN REQRD'\nBLAT3A   TM    ATTR2,X'10'             SSI PRESENT\n         BZ    BLAT3PRT                NO\n         MVC   PRT+50(11),=C'SSI PRESENT'\nBLAT3PRT BAS   R9,PRINT                PRINT\n         TM    ATTR1A,X'04'            SCATTER FORMAT\n         BZ    BLFAL                   NO\n         MVC   PRT+10(8),=C'SCTRLEN='\n         LA    R12,SCTRLEN             @ SCATTER LIST LENGTH\n         BAS   R9,HEXPRT2              CONVERT\n         MVC   PRT+18(4),PRTABL        SCATTER LIST LENGTH\n         BAS   R9,PRINT                PRINT\n         MVC   PRT+10(18),=C'TRANSLATE TBL LEN='\n         LA    R12,TTLEN               @ TRANS TBL LEN\n         BAS   R9,HEXPRT2              CONVERT\n         MVC   PRT+28(4),PRTABL        TRANSLATION TABLE LENGTH\n         BAS   R9,PRINT                PRINT\n         MVC   PRT+10(18),=C'ESD ID OF 1ST TXT='\n         LA    R12,SCESDID             @ ESD ID\n         BAS   R9,HEXPRT2              CONVERT\n         MVC   PRT+28(4),PRTABL        ESD ID OF 1ST TXT\n         BAS   R9,PRINT                PRINT\n         MVC   PRT+10(23),=C'ESD ID CONTAINING E.P.='\n         LA    R12,SCEPESD             @ ESD ID\n         BAS   R9,HEXPRT2              CONVERT\n         MVC   PRT+33(4),PRTABL        @ ESD ID OF CSECT CONTAINING E.P\n         BAS   R9,PRINT                PRINT\nBLFAL    TM    ALIASIND,X'80'          ALIAS\n         BZ    BLFSSI                  NO\n         MVC   PRT+10(28),=C'E.P. ADDRESS OF THIS MEMBER='\n         LA    R12,ALEPA               @ E.P. ADDR\n         BAS   R9,HEXPRT3              CONVERT\n         MVC   PRT+38(6),PRTABL        E.P. ADDR\n         BAS   R9,PRINT\n         MVC   PRT+10(17),=C'REAL MEMBER NAME='\n         MVC   PRT+27(8),ALMEM         REAL MEMBER NAME\n         BAS   R9,PRINT\nBLFSSI   TM    ATTR2,X'10'             ANY SSI INFO\n         BZ    BLAUTHC                 NO\n         MVC   PRT+10(9),=C'SSI INFO='\n         LA    R12,SSI                 @ SSI INFO\n         BAS   R9,HEXPRT4              CONVERT\n         MVC   PRT+19(8),PRTABL        SSI INFO\n         BAS   R9,PRINT                PRINT\nBLAUTHC  MVC   PRT+10(10),=C'AUTH CODE='\n         LA    R12,AUTHCOD             @ AUTH CODE\n         BAS   R9,HEXPRT1              CONVERT\n         MVC   PRT+20(2),PRTABL        AUTH CODE\n         BAS   R9,PRINT                PRINT\n         TM    ALIASIND,X'80'          ALIAS\n         BZ    BLXIT                   NO\n         MVC   PRT+5(38),=C'***** REAL MEMBER DIRECTORY INFO *****'\n         MVI   PCC,C'0'                DOUBLE SPACE\n         BAS   R9,PRINT                PRINT\n         MVC   MEMBER,ALMEM            REAL MEMBER NAME TO LIST\n         B     ISSBLDL                 DO OVER FOR REAL MEMBER\nBLXIT    L     R9,BL9                  GET RETURN ADDR\n         BR    R9                      EXIT\n         EJECT\n****************************************************************\n*                                                              *\n* CREATE PRINTABLE HEX FROM HEX. ON ENTRY, REG 12 CONTAINS THE *\n* ADDRESS OF THE DATA TO BE REFORMATTED. ENTRY POINT USED      *\n* DETERMINES THE SIZE OF THE FIELD. OUTPUT DATA IS PLACED IN   *\n* THE PRTABL FIELD, 2 CHARACTERS PER BYTE.                     *\n*                                                              *\n****************************************************************\n         SPACE 1\nHEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX\nHEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE\n         TR    PRTABL(8),TRTBL         MAKE PRINTABLE\n         BR    R9                      EXIT\n         SPACE 2\n****************************************************************\n*                                                              *\n* PRINT USING SYSPRINT.                                        *\n*                                                              *\n****************************************************************\n         SPACE 1\nPRINT    L     R2,PRINTDCB                                         -EU-\n         USING IHADCB,R2                                           -EU-\n         TM    DCBOFLGS,DCBOFOPN       IS SYSPRINT OPEN            -EU-\n         BNO   CLRPRT                  NO\n         PUT   (R2),PRTLINE            WRITE PRINT LINE            -EU-\n         DROP  R2                                                  -EU-\nCLRPRT   MVC   PRT,BLANX               CLEAR PRINT LINE\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C' '                SINGLE SPACED\n         BE    SETSGL                  YES\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C'0'                DOUBLE SPACED\n         BE    SETSGL                  YES\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C'-'                TRIPLE SPACED\n         BE    SETSGL                  YES\n         ZAP   LINECT,P0               NO, MUST BE NEW PAGE\nSETSGL   MVI   PCC,C' '                SET SINGLE SPACING\n         CP    LINECT,P58              PAST END OF PAGE\n         BH    NEWPAGE                 YES\n         BR    R9                      EXIT\nNEWPAGE  MVI   PCC,C'1'                SET SKIP TO HOF\n         ZAP   LINECT,P0               RESET LINE COUNTER\n         BR    R9                      EXIT\n         EJECT\n****************************************************************\n*                                                              *\n* PROCESS THE CONTROL CARD CONTAINING MODULE NAME AND CSECT.   *\n* THIS MUST BE THE FIRST CARD IN THE SYSIN DECK.               *\n*                                                              *\n****************************************************************\n         SPACE 1\nGETCTL   L     R1,INDCB                                            -EU-\n         GET   (1)                     READ THE CONTROL CARD       -EU-\n         LA    R12,72                  LENGTH OF CONTROL CARD\n         LA    R11,8                   MAX LENGTH OF MEMBER NAME\n         LA    R10,MEMBER              @ MEMBER NAME FIELD\nCKBLK1   CLI   0(R1),C' '              CONTROL BYTE IS BLANK\n         BNE   GCMEMOV                 NO, GO MOVE MEMBER NAME\n         LA    R1,0(R1)                TO NEXT CONTROL BYTE\n         BCT   R12,CKBLK1              SUBTRACT 1 FROM REMAINING LENGTH\n         B     GCEND                   ALL BLANKS, EXIT\nGCMEMOV  MVC   0(1,R10),0(R1)          CONTROL BYTE TO MEMBER NAME\n         LA    R1,1(R1)                TO NEXT CONTROL BYTE\n         BCTR  R12,0                   SUBTRACT 1 FROM LENGTH\n         LA    R10,1(R10)              TO NEXT NAME BYTE\n         BCTR  R11,0                   SUBTRACT 1 FROM LENGTH\n         CLI   0(R1),C' '              GOT A BLANK\n         BE    GCSETUP2                YES\n         CLI   0(R1),C','              GOT A COMMA\n         BE    GCSETUP2                YES\n         LTR   R12,R12                 END OF CONTROL DATA\n         BE    GCEND                   YES\n         LTR   R11,R11                 NAME FULL\n         BNZ   GCMEMOV                 NO, CONTINUE\n         B     NAMEOV8                 YES, NAME TOO LONG\nGCSETUP2 LA    R11,8                   CSECT NAME MAX LENGTH\n         LA    R10,CSECT               @ CSECT NAME FIELD\nGCSTEP2  LA    R1,1(R1)                STEP PAST BLANK\n         BCT   R12,GCHKBK2             CHECK NEXT FOR BLANK\n         B     GCEND                   END OF SCAN\nGCHKBK2  CLI   0(R1),C' '              CONTROL DATA IS BLANK\n         BE    GCSTEP2                 YES\nGCCSMOV  MVC   0(1,R10),0(R1)          CONTROL BYTE TO CSECT NAME\n         LA    R1,1(R1)                TO NEXT CONTROL BYTE\n         LA    R10,1(R10)              TO NEXT NAME BYTE\n         BCTR  R12,0                   DEDUCT 1 FROM CONTROL LENGTH\n         BCTR  R11,0                   DEDUCT 1 FROM NAME LENGTH\n         LTR   R12,R12                 ANY CONTROL BYTES LEFT\n         BZ    GCEND                   NO\n         CLI   0(R1),C' '              NEXT CONTROL BYTE BLANK\n         BE    GCEND                   YES\n         LTR   R11,R11                 ANY NAME BYTES LEFT\n         BNZ   GCCSMOV                 YES, LOOP\n         B     NAMEOV8                 NAME TOO LONG, ERROR\nGCEND    CLC   MEMBER,BLANX            ANY MEMBER NAME FOUND\n         BE    NOMBR                   NO\n         BR    R9                      EXIT\n         EJECT\n****************************************************************\n*                                                              *\n* MISCELLANEOUS ERROR MESSAGES.                                *\n*                                                              *\n****************************************************************\n         SPACE 1\nNOCTL    MVC   PRT(L'NOCNTRL),NOCNTRL  NO CONTROL INFO MESSAGE\n         B     ERREND                  GO PRINT\nNAMEOV8  MVC   PRT(L'OVER8),OVER8      NAME OVER 8 MESSAGE\n         B     ERREND                  GO PRINT\nNOMBR    MVC   PRT(L'NOMEM),NOMEM      MISSING MEMBER NAME MESSAGE\n         B     ERREND                  GO PRINT\nMISSMEM  MVC   PRT(L'INVMEM),INVMEM    MEMBER NOT IN PDS MESSAGE\n         B     ERREND                  GO PRINT\nMISSCS   MVC   PRT(L'INVCSECT),INVCSECT CSECT NOT IN MEMBER MESSAGE\n         B     ERREND                  GO PRINT\nSYMFULL  MVC   PRT(L'FULLSYM),FULLSYM  FULL SYM TBL MSG\n         B     ERREND                  GO PRINT\nRLDFULL  MVC   PRT(L'FULLRLD),FULLRLD  RLD TBL FULL MSDG\n         B     ERREND                  GO PRINT\nERREND   BAS   R9,PRINT                GO PRINT MESSAGE\n         ABEND 777,DUMP                ABEND\n         SPACE 2\n****************************************************************\n*                                                              *\n* COUNT THE ENTRIES IN THE ESD TABLE WHICH WILL RESULT IN      *\n* ENTRIES IN THE LABEL TABLE.                                  *\n*                                                              *\n****************************************************************\n         SPACE 1\nENDINIT  L     R6,SYMTBAD              GET @ ESD TABLE\n         USING SYMTBL,R6\n         LA    R7,4                    INITIAL LABEL COUNT VALUE\nSYMCNT   CLI   0(R6),X'FF'             END OF ESD TBL\n         BE    RLDCNT                  YES\n         CLI   TYPSYM,3                IS ESD AN LR ENTRY\n         BNE   SCSTP                   NO, IGNORE\n         CLC   SYMADDR,START+1         ADDR BELOW DESIRED CSECT\n         BL    SCSTP                   YES, IGNORE\n         CLC   SYMADDR,END+1           ADDR ABOVE DESIRED CSECT\n         BH    SCSTP                   YES, IGNORE\n         LA    R7,1(R7)                ADD TO LABEL COUNT\n         MVC   SYMLENG,=C'***'         FLAG AS USABLE\nSCSTP    LA    R6,L'SYMENT(R6)         TO NEXT ESD ENTRY\n         B     SYMCNT\n         DROP  R6\n         EJECT\n****************************************************************\n*                                                              *\n* COUNT THE ENTRIES IN THE RLD TABLE WHICH WILL RESULT IN      *\n* ENTRIES IN THE LABEL TABLE.                                  *\n*                                                              *\n****************************************************************\n         SPACE 1\nRLDCNT   L     R6,RLDTBL               GET RLD TBL ADDR\n         USING RLDTBLD,R6\nRLDCEND  CLI   0(R6),X'FF'             END OF RLD TABLE\n         BE    LBLGET                  YES\n         CLC   RLDPP,ESDID             ESDID SAME AS DESIRED CSECT -EU-\n         BNE   RLDC1                   NO, EXTRN REF\n         LA    R7,1(R7)                ADD 1 TO LABEL COUNT\nRLDC1    LA    R7,1(R7)                ADD 1 TO LABEL COUNT\n         LA    R6,L'RLDENT(R6)         TO NEXT RLD ENTRY\n         B     RLDCEND                 LOOP THRU RLD TBL\n         DROP  R6\nLBLGET   MH    R7,LBLLGTH              COMPUTE LABEL TABLE SIZE\n         L     R1,LENGTH               GET CSECT LENGTH\n         SRL   R1,2                    DIVIDE BY 4\n         MH    R1,LBLLGTH              TIMES LABEL ENTRY LENGTH\n         AR    R7,R1                   TOTAL LABEL TABLE LENGTH\n         ST    R7,LBLSLG               SAVE LABEL TBL LENGTH       -EU-\n         EJECT\n****************************************************************\n*                                                              *\n* CREATE INITIAL ENTRIES IN THE LABEL TABLE USING DATA FROM    *\n* THE ESD AND RLD TABLES.                                      *\n*                                                              *\n****************************************************************\n         SPACE 1\n         GETMAIN R,LV=(R7)             GET LABEL TBL STORAGE       -EU-\n         ST    R1,LBLTBL               SAVE LABEL TBL ADDR\n         ST    R1,CURRLBL              SAVE CURRENT LABEL ADDR\n         AR    R1,R7                   COMPUTE LABEL TBL END ADDR\n         ST    R1,ENDLBL               SAVE END OF LBL TBL ADDR\n         L     R6,LBLTBL               GET @ LABEL TABLE\n         USING LABELD,R6\n         L     R7,SYMTBAD              GET ESD TBL ADDR\n         USING SYMTBL,R7\n         CLC   LKEPA,XZROS             E.P. ADDR ZERO\n         BE    LRENTS                  YES\n         XR    R1,R1                   CLEAR WORK\n         ICM   R1,B'0111',LKEPA        PICK UP E.P. ADDR\n         S     R1,START                RELATIVIZE IN CSECT\n         BM    LRENTS                  NEG, ERROR\n         STCM  R1,B'0111',LBLADR       SAVE OFFSET\n         MVI   LBLTYP,C'L'             SET LABEL TYPE IN ENTRY\n         LA    R12,LBLADR              POINT TO OFFSET\n         BAS   R9,HEXPRT3              CONVERT TO PRINTABLE\n         MVI   LBLNAME,C'A'            1ST CHAR OF LABEL IS 'A'\n         MVC   LBLNAME+1(6),PRTABL     END OF LABEL IS OFFSET\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         ST    R6,CURRLBL              SAVE IT'S ADDRESS\nLRENTS   CLI   0(R7),X'FF'             END OF ESD TBL\n         BE    RLDLBLS                 YES\n         CLC   SYMLENG,=C'***'         THIS DESIRED LR ENTRY\n         BE    GOTLR                   YES\nLRESTP   LA    R7,L'SYMENT(R7)         TO NEXT ESD ENTRY\n         B     LRENTS                  LOOP THRU ESD TBL\nGOTLR    XR    R12,R12                 CLEAR WORK REG\n         ICM   R12,B'0111',SYMADDR     GET SYMBOL ADDR\n         S     R12,START               RELATIVIZE IN CSECT\n         STCM  R12,B'0111',LBLADR      SAVE RELATIVE ADDR\n         MVC   LBLNAME,EXTSYM          SYMBOL NAME TO OUTPUT\n         MVI   LBLTYP,C'L'             SHOW LABEL ENTRY\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         ST    R6,CURRLBL              SAVE NEXT LABEL ENTRY ADDR\n         B     LRESTP                  CONTINUE ESD PROCESSING\n         DROP  R7\nRLDLBLS  L     R7,RLDTBL               GET RLD TBL ADDR\n         USING RLDTBLD,R7\nRLDLBND  CLI   0(R7),X'FF'             END OF RLD TABLE\n         BE    PHASE1                  YES\n         CLC   RLDRP,ESDID             RLD ESDID = DESIRED CSECT ESDID\n         BE    INTREFS                 YES, INTERNAL ADCON\n         CLC   RLDPP,ESDID             RLD ESDID = CSECT ESDID     -EU-\n         BE    ACONLBL                 YES, CSECT ADCON            -EU-\n         CLI   RLDTYPE,1               VCON\n         BE    EXTREFS                 YES\n         CLI   RLDTYPE,8               IS IT UNRESOLVED\n         BE    EXTREFS                 YES\nRLLSTP   LA    R7,L'RLDENT(R7)         TO NEXT RLD ENTRY\n         B     RLDLBND                 LOOP THRU RLD TABLE\nEXTREFS  CLI   RLDESDTP,X'0A'          W-CON\n         BNE   VCONLBL                 NO, BUILD V-CON\n         MVI   LBLTYP,C'W'             SHOW W-CON\n         B     FXTLBL                  CONTINUE LABEL ENTRY FORMAT\nACONLBL  CLI   RLDTYPE,0               A-CON                       -EU-\n         BNE   RLLSTP                  NO, IGNORE                  -EU-\nVCONLBL  MVI   LBLTYP,C'V'             SHOW V-CON\nFXTLBL   MVC   LBLNAME,RLDNAME         NAME TO LABEL ENTRY\nFINLBL   MVC   LBLADR,RLDADDR          ADDRESS TO LABEL ENTRY\n         MVC   LBLLEN,RLDLEN           LENGTH TO LABEL ENTRY\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL TBL ENTRY\n         ST    R6,CURRLBL              SAVE CURRENT LABEL TBL ADDR\n         B     RLLSTP                  CONTINUE LABEL TABLE BUILD\nINTREFS  CLI   RLDTYPE,0               A-CON\n         BNE   RLLSTP                  NO, IGNORE\n         MVI   LBLTYP,C'L'             SHOW LABEL ENTRY TYPE\n         XR    R12,R12                 CLEAR WORK REG\n         ICM   R12,B'0111',RLDADDR     GET RLD ADDR\n         A     R12,TXTSTRT             FIND LOC IN TEXT\n         MVC   LBLADR,1(R12)           MOVE TO LABEL ENTRY\n         CLI   RLDLEN,4                ADCON IS 4-BYTES\n         BE    INTGOTL                 YES\n         MVC   LBLADR,0(R12)           TEXT TO LABEL ENTRY\n         CLI   RLDLEN,3                ADCON IS 3-BYTES\n         BE    INTGOTL                 YES\n         MVC   LBLADR+1(2),0(R12)      TEXT TO LABEL ENTRY\n         MVI   LBLADR,0                CLEAR 1ST BYTE\n         CLI   RLDLEN,2                ADCON IS 2-BYTES\n         BE    INTGOTL                 YES\n         XC    LBLADR,LBLADR           CLEAR LABEL ENTRY ADDR\n         MVC   LBLADR+2(1),0(R12)      TEXT TO LABEL ENTRY\nINTGOTL  XR    R12,R12                 CLEAR WORK\n         ICM   R12,B'0111',LBLADR      GET ADDRESS\n         S     R12,START               RELATIVIZE IN CSECT\n         BM    RLLSTP                  NEGATIVE, IGNORE\n         STCM  R12,B'0111',LBLADR      STORE RELATIVE ADDRESS\n         LA    R12,LBLADR              POINT TO ADDRESS\n         BAS   R9,HEXPRT3              CONVERT TO PRINTABLE\n         MVI   LBLNAME,C'A'            SET LABEL ENTRY TYPE\n         MVC   LBLNAME+1(6),PRTABL     LOW ORDER NAME POSITIONS\n         MVI   LBLNAME+7,C' '          CLEAR LAST NAME BYTE\n         MVC   L'LABEL(L'LABEL,R6),0(R6) COPY THIS ENTRY TO NEXT\n         MVI   LBLLEN,0                SET LENGTH = 0\n         LA    R6,L'LABEL(R6)          STEP TO NEXT\n         MVI   LBLTYP,C'A'             SHOW TYPE\n         B     FINLBL                  FINISH LABEL\n         DROP  R6\n         DROP  R7\n         EJECT\n****************************************************************\n*                                                              *\n* LOAD AND EXECUTE PHASE 1: DISASM1                            *\n*                                                              *\n****************************************************************\n         SPACE 1\nPHASE1   MVC   0(3,R6),HIVAL           SET END OF LABEL TABLE  FIX***\n         L     R1,=A(LOADLIB)                                      -EU-\n         USING IHADCB,R1                                           -EU-\n         TM    DCBOFLGS,DCBOFOPN       LOADLIB DD CARD ENTERED     -EU-\n         BO    EXEC1                   YES                         -EU-\n         DROP  R1                                                  -EU-\n         XR    R1,R1                   NO                          -EU-\nEXEC1    LOAD  EP=DISASM1,DCB=(1)      LOAD PHASE1                 -EU-\n         LR    R15,R0                  COPY E.P. ADDRESS\n         LA    R1,=A(COMMPARM)         @ PARAMETER LIST\n         BASR  R14,R15                 LINK TO PHASE1\n         DELETE EP=DISASM1             DELETE AFTER USE\n         CLI   USERR,0                 ANY ERRORS\n         BNE   CLOSES                  YES, STOP THE RUN\n         SPACE 2\n****************************************************************\n*                                                              *\n* PRINT THE LABEL TABLE AFTER PHASE 1 COMPLETION.              *\n*                                                              *\n****************************************************************\n         SPACE 1\n         MVC   PRTLINE,PH1LBL          HEADER 1\n         BAS   R9,PRINT                PRINT IT\n         MVC   PRTLINE,PH1HDR          HEADER 2\n         BAS   R9,PRINT                PRINT IT\n         L     R6,LBLTBL               GET LABEL TABLE ADDR\n         USING LABELD,R6\nLPLOOP   LA    R8,PRT                  @ FIRST PRINT LABEL         -EU-\n         LA    R7,4                    4 LABELS PER LINE           -EU-\nLPTEST   C     R6,CURRLBL              END OF TABLE       FIX****\n         BNL   LPEND                   YES                FIX****  -EU-\n         LA    R12,LBLADR              @ LABEL ADDRESS\n         BAS   R9,HEXPRT3              CONVERT\n         MVC   0(6,R8),PRTABL          ADDRESS TO PRINT            -EU-\n         MVC   9(1,R8),LBLTYP          TYPE TO PRINT               -EU-\n         MVC   12(8,R8),LBLNAME        SYMBOL TO PRINT             -EU-\n         CLI   LBLLEN,0                ANY LENGTH\n         BE    LTPPRT                  NO\n         LA    R12,LBLLEN              GET @ LENGTH\n         BAS   R9,HEXPRT1              CONVERT\n         MVC   22(2,R8),PRTABL         LENGTH TO PRINT             -EU-\nLTPPRT   LA    R6,L'LABEL(R6)          TO NEXT ENTRY               -EU-\n         LA    R8,L'LPLEL(R8)          TO NEXT PRINT LOC           -EU-\n         BCT   R7,LPTEST               LOOP IF MORE                -EU-\n         BAS   R9,PRINT                PRINT TBL ENTRIES           -EU-\n         B     LPLOOP                  LOOP THRU TABLE             -EU-\nLPEND    CLI   PRT,C' '                LAST LINE TO BE PRINTED     -EU-\n         BE    FREESTRG                NO                          -EU-\n         BAS   R9,PRINT                PRINT LAST TBL ENTRIES      -EU-\nFREESTRG L     R12,RLDTBL              @ RLD TABLE\n         L     R0,RLDLGTH              RLD TABLE LENGTH            -EU-\n         FREEMAIN R,A=(R12),LV=(0)     FREE RLD TABLE              -EU-\n         SPACE 2\n****************************************************************\n*                                                              *\n* PRINT THE TEXT FOR THE CSECT TO BE DISASSEMBLED.             *\n*                                                              *\n****************************************************************\n         SPACE 1\n         MVI   PCC,C'1'                SET SKIP TO HEAD\n         MVC   PRT+50(19),=C'***** T E X T *****'\n         BAS   R9,PRINT                PRINT TEXT HEADER\n         MVI   PCC,C'0'                SET DOUBLE SPACING\n         L     R11,TXTSTRT             GET TEXT START ADDRESS\nPNEXLIN  LA    R10,2                   GROUPS PER LINE\n         LA    R12,POFSET+1            @ OFFSET\n         BAS   R9,HEXPRT3              CONVERT\n         MVC   PRT(6),PRTABL           OFFSET TO PRINT\n         MVC   PRT+85(32),0(R11)       TEXT TO PRINT\n         L     R8,=A(PRTCHAR)                                      -EU-\n         TR    PRT+85(32),0(R8)        TRANSLATE TO PRINTABLE      -EU-\n         LA    R8,PRT+9                @ 1ST PRINT WORD\n         LA    R7,4                    4 WORDS PER GROUP\nPGRP     LA    R12,0(R11)              @ TEXT WORD\n         BAS   R9,HEXPRT4              CONVERT\n         MVC   0(8,R8),PRTABL          TEXT TO PRINT WORD\n         LA    R11,4(R11)              TO NEXT TEXT WORD\n         LA    R8,9(R8)                TO NEXT PRINT LOC\n         BCT   R7,PGRP                 DO 4 TIMES\n         LA    R8,2(R8)                SPACE BETWEEN GROUPS\n         LA    R7,4                    FOR 2ND GROUP\n         BCT   R10,PGRP                DO 4 MORE TIMES\n         BAS   R9,PRINT                PRINT THE LINE\n         L     R9,POFSET               GET OFFSET\n         LA    R9,32(R9)               ADD 32 BYTES\n         ST    R9,POFSET               UPDATE OFFSET\n         C     R11,TXTEND              END OF TEXT\n         BL    PNEXLIN                 NO, CONTINUE\n         MVI   PCC,C'1'                SET SKIP TO HEAD\n         MVC   WORKREC,BLANX           CLEAR OUTPUT RECORD\n         MVC   NAME,CSECT              CSECT NAME\n         EJECT\n****************************************************************\n*                                                              *\n* CREATE THE INITIAL CSECT INSTRUCTION, AND ANY ENTRY STATE-   *\n* MENTS WHICH MAY BE INDICATED BY ESD TABLE ENTRIES.           *\n*                                                              *\n****************************************************************\n         SPACE 1\n         MVC   MNEMONIC,=C'CSECT'      SET MNEMONIC\n         BAS   R9,WRTOUT               WRITE OUTPUT RECORD\n         BAS   R9,PRINT                AND PRINT IT\n         L     R7,SYMTBAD              GET ESD TBL ADDR\n         USING SYMTBL,R7\nLREFSS   CLI   0(R7),X'FF'             END OF ESD TBL\n         BE    CKLDLB                  YES\n         CLC   SYMLENG,=C'***'         THIS DESIRED LR ENTRY\n         BE    MAKEXT                  YES\nESDTSTP  LA    R7,L'SYMENT(R7)         TO NEXT ESD ENTRY\n         B     LREFSS                  LOOP THRU ESD TBL\nMAKEXT   MVC   MNEMONIC,=C'ENTRY'      MNEMONIC IS ENTRY\n         MVC   OPNDS(8),EXTSYM         SYMBOL TO OPERAND\n         BAS   R9,WRTOUT               WRITE OUTPUT RECORD\n         BAS   R9,PRINT                AND PRINT IT\n         B     ESDTSTP                 CONTINUE ESD PROCESSING\n         DROP  R7\n         DROP  R6\nCKLDLB   L     R12,SYMTBAD             @ ESD SYMBOL TABLE\n         L     R0,SYMLGTH              SYMBOL TABLE STORAGE LENGTH -EU-\n         FREEMAIN R,A=(R12),LV=(0)     FREE SYMBOL TABLE           -EU-\n         SPACE 2\n****************************************************************\n*                                                              *\n* LOAD AND EXECUTE PHASE 2: DISASM2                            *\n*                                                              *\n****************************************************************\n         SPACE 1\n         L     R1,=A(LOADLIB)                                      -EU-\n         USING IHADCB,R1                                           -EU-\n         TM    DCBOFLGS,DCBOFOPN       LOADLIB DD CARD SUPPLIED    -EU-\n         BO    EXEC2                   YES                         -EU-\n         DROP  R1                                                  -EU-\n         XR    R1,R1                   NO                          -EU-\nEXEC2    LOAD  EP=DISASM2,DCB=(1)      LOAD PHASE2                 -EU-\n         LR    R15,R0                  COPY E.P. ADDRESS\n         LA    R1,=A(COMMPARM)         GET PARAMETER ADDRESS\n         BASR  R14,R15                 CALL DISASM2\n         DELETE EP=DISASM2             DELETE AFTER USE\n         B     EOJ                     GO FINISH\n         EJECT\n****************************************************************\n*                                                              *\n* WRITE OUTPUT TO SYSPUNCH.                                    *\n*                                                              *\n****************************************************************\n         SPACE 1\nWRTOUT   MVC   PRT(80),WORKREC         SAVE IN PRINT\n         L     R2,PUNCHDCB                                         -EU-\n         USING IHADCB,R2                                           -EU-\n         TM    DCBOFLGS,DCBOFOPN       IS FILE OPEN                -EU-\n         BZ    CLRWKR                  NO\n         AP    CARDNO,=P'10'           INCREMENT CARD NO\n         UNPK  SEQNBR,CARDNO           UNPACK INTO CARD\n         OI    SEQNBR+7,C'0'           CLEAR SIGN\n         PUT   (R2),WORKREC            WRITE SOURCE CARD           -EU-\n         DROP  R2                                                  -EU-\nCLRWKR   MVC   WORKREC,BLANX           CLEAR OUTPUT RECORD\n         BR    R9                      RETURN\n         SPACE 2\n****************************************************************\n*                                                              *\n* END OF JOB. DISASSEMBLY COMPLETE.                            *\n*                                                              *\n****************************************************************\nEOFSW    EQU   *+1                     END OF JOB SWITCH\nEOJ      B     NOCTL                   RESET IF CTL CARD FOUND\n         MVC   MNEMONIC-1(8),=CL8'$DEFREG'  SET MNEMONIC           -EU-\n         BAS   R9,WRTOUT               WRITE RECORD\n         BAS   R9,PRINT                GO PRINT IT\n         L     R12,DTBSTRT             @ DSECT HEADER TBL\nCENDSTB  CLI   0(R12),X'FF'            END OF TABLE\n         BE    ENDSTMT                 YES\n         USING DTDS,R12                                            -EU-\n         MVC   NAME,DTNAME             DSECT NAME TO RECORD        -EU-\n         MVC   MNEMONIC(5),=C'DSECT'   OPERATION IS DSECT\n         BAS   R9,WRTOUT               WRITE DSECT HEADER\n         BAS   R9,PRINT                AND PRINT IT\n         ICM   R11,B'0111',DTADDR      GET FIELD TABLE ADDR        -EU-\n         USING DSECTD,R11\nCENDFTB  CLI   0(R11),X'FF'            END OF FIELD TABLE\n         BNE   DFMTFLD                 NO\n         XR    R0,R0                                               -EU-\n         XR    R1,R1                                               -EU-\n         ICM   R1,B'0111',DTADDR       FIELD TABLE ADDRESS         -EU-\n         BZ    NOFTBL                  BRANCH IF NONE              -EU-\n         ICM   R0,B'0111',DTLGTH       FIELD TABLE LENGTH          -EU-\n         FREEMAIN R,A=(1),LV=(0)       FREE FIELD TABLE            -EU-\nNOFTBL   LA    R12,L'DTL(R12)          TO NEXT DSECT HEADER        -EU-\n         B     CENDSTB                 LOOP\nDFMTFLD  MVC   NAME,DSNAME             NAME TO RECORD\n         MVC   MNEMONIC(3),=C'EQU'     OPERATION IS EQU\n         MVC   OPNDS(8),DTNAME         BASE NAME TO OPERAND        -EU-\n         LA    R10,OPNDS+7             @ NAME RHE\nCFRHE    CLI   0(R10),C' '             AT RHE\n         BNE   CFPLUS                  YES\n         BCT   R10,CFRHE               BACK UP 1 AND LOOP\nCFPLUS   LA    R10,1(R10)              TO NEXT POS\n         MVI   0(R10),C'+'             DELIMITER\n         XR    R1,R1                   CLEAR WORK\n         ICM   R1,B'0111',DSOFSET      GET OFFSET\n         CVD   R1,DBLWD                CONVERT\n         UNPK  DBLWD(4),DBLWD+4(4)     UNPACK\n         OI    DBLWD+3,C'0'            CLEAR SIGN\n         CH    R1,H1000                OFFSET < 1000\n         BL    CFO100                  YES\n         MVC   1(4,R10),DBLWD          NO, MOVE 4-DIGIT OFFSET\n         LA    R10,5(R10)              TO NEXT POS\n         B     CFCMA                   CONTINUE\nCFO100   CH    R1,H100                 OFFSET < 100\n         BL    CFO10                   YES\n         MVC   1(3,R10),DBLWD+1        NO, MOVE 3-DIGIT OFFSET\n         LA    R10,4(R10)              TO NEXT POS\n         B     CFCMA                   CONTINUE\nCFO10    CH    R1,H10                  OFFSET < 10\n         BL    CFO1                    YES\n         MVC   1(2,R10),DBLWD+2        MOVE 2-DIGIT OFFSET\n         LA    R10,3(R10)              TO NEXT POS\n         B     CFCMA                   CONTINUE\nCFO1     LTR   R1,R1                   ANY OFFSET\n         BZ    CFCMA                   NO\n         MVC   1(1,R10),DBLWD+3        YES, MOVE 1-DIGIT OFFSET\n         LA    R10,2(R10)              TO NEXT POS\nCFCMA    MVI   0(R10),C','             DELIMITER\n         XR    R1,R1                   CLEAR WORK\n         IC    R1,DSLENG               PICK UP LENGTH\n         CVD   R1,DBLWD                CONVERT\n         UNPK  DBLWD(3),DBLWD+4(4)     UNPACK\n         OI    DBLWD+2,C'0'            CLEAR SIGN\n         CH    R1,H100                 LENGTH < 100\n         BL    CFL10                   YES\n         MVC   1(3,R10),DBLWD          NO, MOVE 3-DIGIT LENGTH\n         B     CFWRT                   CONTINUE\nCFL10    CH    R1,H10                  LENGTH < 10\n         BL    CFL1                    YES\n         MVC   1(2,R10),DBLWD+1        NO, MOVE 2-DIGIT LENGTH\n         B     CFWRT                   CONTINUE\nCFL1     MVC   1(1,R10),DBLWD+2        MOVE 1-DIGIT LENGTH\nCFWRT    BAS   R9,WRTOUT               WRITE THE RECORD\n         BAS   R9,PRINT                PRINT THE RECORD\n         LA    R11,L'DSECT(R11)        TO NEXT FIELD ENTRY\n         B     CENDFTB                 LOOP\nENDSTMT  MVC   MNEMONIC,=CL5'END'      MNEMONIC TO OUTPUT RECORD\n         MVC   OPNDS(8),ENDLBLNM       POINT END STMT TO BEGIN LOC\n         BAS   R9,WRTOUT               WRITE THE RECORD\n         BAS   R9,PRINT                GO PRINT IT\n         DROP  R11,R12                                             -EU-\n         EJECT  ,                                                  -EU-\nCLOSES   CLOSE (SYSLIB,,SYSPUNCH,,SYSPRINT,,SYSIN) CLOSE FILES\n         L     R0,BUFLGTH              BUFFER STORAGE LENGTH       -EU-\n         L     R1,BUFAD                BUFFER STORAGE ADDRESS      -EU-\n         FREEMAIN R,LV=(0),A=(1)       FREE BUFFER STORAGE         -EU-\n         L     R1,DATSTART             DATA ONLY TABLE ADDRESS     -EU-\n         L     R0,DATLGTH              DATA ONLY TABLE LENGTH      -EU-\n         FREEMAIN R,A=(1),LV=(0)       FREE DATA ONLY TABLE        -EU-\n         ICM   R1,B'1111',USGSTRT      USING STORAGE ADDRESS       -EU-\n         BZ    NOUSGS                  BRANCH IF NONE              -EU-\n         L     R0,USGLGTH              USING STORAGE LENGTH        -EU-\n         FREEMAIN R,A=(1),LV=(0)       FREE USING STORAGE          -EU-\nNOUSGS   ICM   R1,B'1111',DTBSTRT      DSECT STORAGE ADDRESS       -EU-\n         BZ    NODTBS                  BRANCH IF NONE              -EU-\n         L     R0,DTBLGTH              DSECT STORAGE LENGTH        -EU-\n         FREEMAIN R,A=(1),LV=(0)       FREE DSECT STORAGE          -EU-\nNODTBS   ICM   R1,B'1111',TXTSTRT      TEXT STORAGE ADDRESS        -EU-\n         BZ    NOTXTS                  BRANCH IF NONE              -EU-\n         L     R0,TXTLGTH              TEXT STORAGE LENGTH         -EU-\n         FREEMAIN R,A=(1),LV=(0)       FREE TEXT STORAGE           -EU-\nNOTXTS   ICM   R1,B'1111',LBLTBL       LABEL TABLE ADDRESS         -EU-\n         BZ    LEAVE                   BRANCH IF NONE              -EU-\n         L     R0,LBLSLG               LABEL TABLE STORAGE LENGTH  -EU-\n         FREEMAIN R,A=(1),LV=(0)       FREE LABEL TABLE STORAGE    -EU-\n         SPACE 1                                                   -EU-\n         PRINT GEN                                                 -EU-\nLEAVE    SVBCK ,                       RETURN TO CALLER            -EU-\n         EJECT\n         DEFCOM ,                                                  -EU-\n         SPACE 2                                                   -EU-\n         DEFINS DSECT=YES                                          -EU-\n         EJECT ,                                                   -EU-\n         DEFCDS ,                                                  -EU-\n         EJECT ,                                                   -EU-\nRLDTBLD  DSECT ,                       RELOCATION DICTIONARY TABLE\nRLDENT   DS    0CL20                   11 BYTE ENTRIES\nRLDRP    DS    XL2                     RELOCATION POINTER\nRLDPP    DS    XL2                     POS PTR (SYMBOL CESD NBR)\nRLDTYPE  DS    XL1                     TYPE\n*                    00=A-TYPE ADCON\n*                    01=V-TYPE ADCON\n*                    02=PSEUDO REGISTER DISPLACEMENT\n*                    03=PSEUDO REG CUMULATIVE DISPL\n*                    08=UNRESOLVED\nRLDLEN   DS    XL1                     LENGTH OF CONSTANT\nRLDDIR   DS    CL1                     RELOCATION DIRECTION, + OR\nRLDADDR  DS    XL3                     LKED ASSGND ADDR OF CONSTANT\nRLDNAME  DS    CL8                     NAME FROM ASSOC ESD\nRLDESDTP DS    XL1                     TYPE FROM ASSOC ESD\n         DS    XL1\n         SPACE 2                                                   -EU-\nSYMTBL   DSECT ,                       EXTERNAL SYMBOL TABLE ENTRY\nSYMENT   DS    0CL19                   19 BYTE ENTRIES\nEXTSYM   DS    CL8                     EXTERNAL SYMBOL NAME\nTYPSYM   DS    XL1                     SYMBOL TYPE\n*                        00=SD (NAMED CSECT)\n*                        02=ER (EXTRN)\n*                        03=LR (ENTRY)\n*                        04=PC (UNNAMED CSECT)\n*                        05=CM (COM)\n*                        06=PR (PSEUDO REGISTER)\n*                        07=NULL\n*                        0A=WX (WXTRN)\n*                        0F=ENTAB OR SEGTAB\nSYMIND   DS    XL1                     INDICATOR\n*                        BIT 0 = MAP\n*                        BIT 1 = CHAIN\n*                        BIT 2 = INSERT\n*                        BIT 3 = DELETE/REPLACE\nSYMADDR  DS    XL3                     SYMBOL ADDRESS (0 FOR ER, WX, NU\nSYMSEG   DS    XL1                     SEGMENT ID (0 FOR ER, WX, NULL)\nSYMLRID  DS    0XL2                    ESD ID OF DEF FOR LR\nSYMLENG  DS    XL3                     LENGTH FOR SD, PC, CM, PR\n*                        0 FOR ER, WX, NULL\nSYMESDID DS    XL2                     ESD ID OF THIS ITEM\n         EJECT\nDISASM   CSECT\n         SPACE 1\nBUFAD    DC    F'0'                    SYSLIB BUFFER ADDRESS\nBUFLGTH  DC    F'20000'                SYSLIB BUFFER LENGTH        -EU-\nSYMTBAD  DC    F'0'                    SYMBOL TABLE ADDRESS\nSYMLGTH  DC    A(2000*L'SYMENT)        SYM TABLE LENGTH            -EU-\nCURRSYM  DC    F'0'                    CURRENT SYM TBL ADDRESS\nENDSYM   DC    F'0'                    SYM TBL END ADDRESS         -EU-\nRLDTBL   DC    F'0'                    ADDR OF RLD TABLE\nRLDLGTH  DC    A(3000*L'RLDENT)        RLD TABLE LENGTH            -EU-\nCURRLD   DC    F'0'                    CURR RLD TBL ADDRESS\nENDRLD   DC    F'0'                    RLD TBL END ADDRESS         -EU-\nDATSTART DC    F'0'                    DATA ONLY TABLE ADDRESS     -EU-\nDATLGTH  DC    A(256*6+8)              DATA ONLY TBL STOR. LENGTH  -EU-\nENDATO   DC    A(256*6)                DATA ONLY TBL LENGTH        -EU-\nTXTLGTH  DC    F'0'                    TEXT STORAGE LENGTH         -EU-\nLBLSLG   DC    F'0'                    LABEL TABLE LENGTH          -EU-\nCES9     DC    F'0'                    CESDREC RETURN ADDRESS\nBL9      DC    F'0'                    BLDL RTN RETURN ADDRESS\nCR9      DC    F'0'                    CTRLRECS RETURN ADDRESS\nCT9      DC    F'0'                    CNTLRECS RETURN ADDRESS\nRL9      DC    F'0'                    RLDRECS RETURN ADDRESS\nHIVAL    DC    4X'FF'                  CONSTANT F'S\nH1000    DC    H'1000'                 CONSTANT 1000\nH100     DC    H'100'                  CONSTANT 100\nH10      DC    H'10'                   CONSTANT 10\nSYMLEN   DC    AL2(L'SYMENT)           LENGTH OF SYMTBL ENTRY\nPRTABL   DC    CL9' '                  HEX-PRINTABLE CONVERSION AREA\nP0       DC    P'0'                    CONSTANT 0\nP1       DC    P'1'                    CONSTANT 1\nP58      DC    P'58'                   CONSTANT 58\nPROCESS  DC    XL1'00'                 PROCESS INDIC 80=CSECT FOUND\n*                                                    40=MODULE DONE\nJFCBAD   DS    0F                      DCB EXIT LIST\n         DC    X'87'                   RDJFCB, END OF LIST\n         DC    AL3(JFCB)               ADDRESS OF JFCB READ AREA\nJFCB     DC    XL176'0'                JFCB\n         SPACE 1\nSYMHDR   DC    C'0     SYMBOL        TYPE   IND  ADDR'\n         DC    C'    SEG  LRID   LENG  ESDID'\n         DC    CL64' '\n         SPACE 1\nRLDHDR   DC    C'0     RELPTR  POSPTR      TYPE     LEN'\n         DC    C'    DIR   ADDR'\n         DC    CL90' '\n         SPACE 1\nPH1LBL   DC    CL121'1***** PHASE 1 LABEL TABLE *****'\nPH1HDR   DC    0CL121' ',C'0'                                      -EU-\nLPLEL    DC    4CL30'   ADDR TYPE  SYMBOL  LEN'                    -EU-\n         SPACE 1\nBLANX    DC    CL121' '                CONSTANT BLANKS\nXZROS    DC    8X'00'                  CONSTANT ZEROS\nH5       DC    H'5'                    CONSTANT 5\nH256     DC    H'256'                  CONSTANT 256\nTRTBL    DC    C'0123456789ABCDEF'     TRANSLATE TBL\nNOCNTRL  DC    C'MEMBER AND CSECT MUST BE ENTERED VIA SYSIN'\nOVER8    DC    C'MEMBER OR CSECT NAME OVER 8 CHARACTERS'\nNOMEM    DC    C'NO MEMBER NAME FOUND IN CONTROL CARD OR PARM'\nINVMEM   DC    C'SPECIFIED MEMBER NOT FOUND IN SYSLIB PDS'\nINVCSECT DC    C'SPECIFIED CSECT NOT FOUND IN MEMBER'\nFULLSYM  DC    C'SYMBOL TABLE FULL: OVER 2000 ENTRIES'\nFULLRLD  DC    C'RLD TABLE FULL: OVER 3000 ENTRIES'\nPOFSET   DC    F'0'                    OFFSET FOR TEXT PRINT\n         EJECT ,                                                   -EU-\n         LTORG ,                                                   -EU-\n         EJECT\n* END OF BASE REGISTERS ADDRESSABILITY - - - - - - - - - - - - - - -EU-\n         SPACE 1                                                   -EU-\nPRTCHAR  DC    256C'.'                 CHARACTER TRANSLATE TABLE\n         ORG   PRTCHAR+C' '\n         DC    C' '\n         ORG   PRTCHAR+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   PRTCHAR+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   PRTCHAR+C'S'\n         DC    C'STUVWXYZ'\n         ORG   PRTCHAR+C'0'\n         DC    C'0123456789'\n         ORG\nSYSPUNCH DCB   DSORG=PS,MACRF=(PM,GM),DDNAME=SYSPUNCH,                 X\n               RECFM=FB,LRECL=80\nSYSIN    DCB   DSORG=PS,MACRF=GL,DDNAME=SYSIN,                         X\n               RECFM=FB,LRECL=80,EODAD=NOCTL\nSYSLIB   DCB   DSORG=PO,MACRF=R,DDNAME=SYSLIB,                         X\n               RECFM=U,NCP=1\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      X\n               RECFM=FBA,LRECL=121\nLOADLIB  DCB   DSORG=PO,MACRF=R,DDNAME=LOADLIB,EXLST=JFCBAD\n         EJECT\n******************************************************************\n*                                                                *\n* INSTRUCTION DISASSEMBLY TABLES. THESE TABLES DEFINE VALID      *\n* INSTRUCTION OP-CODES, AND GIVE MNEMONICS, FORMAT-TYPES,        *\n* AND AN INDICATOR TO SHOW CONDITION SETTING INSTRUCTIONS,       *\n* PRIVILEGED INSTRUCTIONS, AND FLOATING POINT INSTRUCTIONS.      *\n*                                                                *\n******************************************************************\n         SPACE 1\nSGLOP    DS    0CL10                   SINGLE BYTE OP-CODE TABLE\n         DC    XL5'0',AL1(0,0,0,0,2)                               00\n         DC    XL5'0',AL1(0,0,0,0,2)                               01\n         DC    XL5'0',AL1(0,0,0,0,2)                               02\n         DC    XL5'0',AL1(0,0,0,0,2)                               03\n         DC    CL5'SPM',AL1(RR,0,0,ZRO8,2)                         04\n         DC    CL5'BALR',AL1(RR,0,0,0,2)                           05\n         DC    CL5'BCTR',AL1(RR,0,0,0,2)                           06\n         DC    CL5'BCR',AL1(CONDBR,0,0,0,2)                        07\n         DC    CL5'SSK',AL1(RR,PRIV,0,0,2)                         08\n         DC    CL5'ISK',AL1(RR,PRIV,0,0,2)                         09\n         DC    CL5'SVC',AL1(SVC,0,0,0,2)                           0A\n         DC    CL5'BSM',AL1(RR,0,0,0,2)                            0B\n         DC    CL5'BASSM',AL1(RR,0,0,0,2)                          0C\n         DC    CL5'BASR',AL1(RR,0,0,0,2)                           0D\n         DC    CL5'MVCL',AL1(RR,0,EPR,CPR,2)                       0E\n         DC    CL5'CLCL',AL1(RR,0,EPR,CPR,2)                       0F\n         DC    CL5'LPR',AL1(RR,0,0,ARITH,2)                        10\n         DC    CL5'LNR',AL1(RR,0,0,ARITH,2)                        11\n         DC    CL5'LTR',AL1(RR,0,0,ARITH,2)                        12\n         DC    CL5'LCR',AL1(RR,0,0,ARITH,2)                        13\n         DC    CL5'NR',AL1(RR,0,0,ZRO8,2)                          14\n         DC    CL5'CLR',AL1(RR,0,0,CPR,2)                          15\n         DC    CL5'OR',AL1(RR,0,0,ZRO8,2)                          16\n         DC    CL5'XR',AL1(RR,0,0,ZRO8,2)                          17\n         DC    CL5'LR',AL1(RR,0,0,0,2)                             18\n         DC    CL5'CR',AL1(RR,0,0,CPR,2)                           19\n         DC    CL5'AR',AL1(RR,0,0,ARITH,2)                         1A\n         DC    CL5'SR',AL1(RR,0,0,ARITH,2)                         1B\n         DC    CL5'MR',AL1(RR,0,EPR,0,2)                           1C\n         DC    CL5'DR',AL1(RR,0,EPR,0,2)                           1D\n         DC    CL5'ALR',AL1(RR,0,0,ARITH,2)                        1E\n         DC    CL5'SLR',AL1(RR,0,0,ARITH,2)                        1F\n         DC    CL5'LPDR',AL1(RR,FLTPT,0,ARITH,2)                   20\n         DC    CL5'LNDR',AL1(RR,FLTPT,0,ARITH,2)                   21\n         DC    CL5'LTDR',AL1(RR,FLTPT,0,ARITH,2)                   22\n         DC    CL5'LCDR',AL1(RR,FLTPT,0,ARITH,2)                   23\n         DC    CL5'HDR',AL1(RR,FLTPT,0,0,2)                        24\n         DC    CL5'LRDR',AL1(RR,FLTPT,0,0,2)                       25\n         DC    CL5'MXR',AL1(RR,FLTPT,0,0,2)                        26\n         DC    CL5'MXDR',AL1(RR,FLTPT,0,0,2)                       27\n         DC    CL5'LDR',AL1(RR,FLTPT,0,0,2)                        28\n         DC    CL5'CDR',AL1(RR,FLTPT,0,CPR,2)                      29\n         DC    CL5'ADR',AL1(RR,FLTPT,0,ARITH,2)                    2A\n         DC    CL5'SDR',AL1(RR,FLTPT,0,ARITH,2)                    2B\n         DC    CL5'MDR',AL1(RR,FLTPT,0,0,2)                        2C\n         DC    CL5'DDR',AL1(RR,FLTPT,0,0,2)                        2D\n         DC    CL5'AWR',AL1(RR,FLTPT,0,ARITH,2)                    2E\n         DC    CL5'SWR',AL1(RR,FLTPT,0,ARITH,2)                    2F\n         DC    CL5'LPER',AL1(RR,FLTPT,0,ARITH,2)                   30\n         DC    CL5'LNER',AL1(RR,FLTPT,0,ARITH,2)                   31\n         DC    CL5'LTER',AL1(RR,FLTPT,0,ARITH,2)                   32\n         DC    CL5'LCER',AL1(RR,FLTPT,0,ARITH,2)                   33\n         DC    CL5'HER',AL1(RR,FLTPT,0,0,2)                        34\n         DC    CL5'LRER',AL1(RR,FLTPT,0,0,2)                       35\n         DC    CL5'AXR',AL1(RR,FLTPT,0,ARITH,2)                    36\n         DC    CL5'SXR',AL1(RR,FLTPT,0,ARITH,2)                    37\n         DC    CL5'LER',AL1(RR,FLTPT,0,0,2)                        38\n         DC    CL5'CER',AL1(RR,FLTPT,0,CPR,2)                      39\n         DC    CL5'AER',AL1(RR,FLTPT,0,ARITH,2)                    3A\n         DC    CL5'SER',AL1(RR,FLTPT,0,ARITH,2)                    3B\n         DC    CL5'MER',AL1(RR,FLTPT,0,0,2)                        3C\n         DC    CL5'DER',AL1(RR,FLTPT,0,0,2)                        3D\n         DC    CL5'AUR',AL1(RR,FLTPT,0,ARITH,2)                    3E\n         DC    CL5'SUR',AL1(RR,FLTPT,0,ARITH,2)                    3F\n         DC    CL5'STH',AL1(RX,0,E2+S2,0,4)                        40\n         DC    CL5'LA',AL1(RX,0,0,0,4)                             41\n         DC    CL5'STC',AL1(RX,0,S2,0,4)                           42\n         DC    CL5'IC',AL1(RX,0,0,0,4)                             43\n         DC    CL5'EX',AL1(RX,0,E2+S2,0,4)                         44\n         DC    CL5'BAL',AL1(RX,0,E2,0,4)                           45\n         DC    CL5'BCT',AL1(RX,0,E2+S2,0,4)                        46\n         DC    CL5'BC',AL1(CONDBR,0,E2,0,4)                        47\n         DC    CL5'LH',AL1(RX,0,E2,0,4)                            48\n         DC    CL5'CH',AL1(RX,0,E2,CPR,4)                          49\n         DC    CL5'AH',AL1(RX,0,E2,ARITH,4)                        4A\n         DC    CL5'SH',AL1(RX,0,E2,ARITH,4)                        4B\n         DC    CL5'MH',AL1(RX,0,E2,0,4)                            4C\n         DC    CL5'BAS',AL1(RX,0,E2,0,4)                           4D\n         DC    CL5'CVD',AL1(RX,0,E8+S2,0,4)                        4E\n         DC    CL5'CVB',AL1(RX,0,E8,0,4)                           4F\n         DC    CL5'ST',AL1(RX,0,E4+S2,0,4)                         50\n         DC    XL5'0',AL1(0,0,0,0,4)                               51\n         DC    XL5'0',AL1(0,0,0,0,4)                               52\n         DC    XL5'0',AL1(0,0,0,0,4)                               53\n         DC    CL5'N',AL1(RX,0,E4,ZRO8,4)                          54\n         DC    CL5'CL',AL1(RX,0,E4,CPR,4)                          55\n         DC    CL5'O',AL1(RX,0,E4,ZRO8,4)                          56\n         DC    CL5'X',AL1(RX,0,E4,ZRO8,4)                          57\n         DC    CL5'L',AL1(RX,0,E4,0,4)                             58\n         DC    CL5'C',AL1(RX,0,E4,CPR,4)                           59\n         DC    CL5'A',AL1(RX,0,E4,ARITH,4)                         5A\n         DC    CL5'S',AL1(RX,0,E4,ARITH,4)                         5B\n         DC    CL5'M',AL1(RX,0,E4+EPR,0,4)                         5C\n         DC    CL5'D',AL1(RX,0,E4+EPR,0,4)                         5D\n         DC    CL5'AL',AL1(RX,0,E4,ARITH,4)                        5E\n         DC    CL5'SL',AL1(RX,0,E4,ARITH,4)                        5F\n         DC    CL5'STD',AL1(RX,FLTPT,0,0,4)                        60\n         DC    XL5'0',AL1(0,0,0,0,4)                               61\n         DC    XL5'0',AL1(0,0,0,0,4)                               62\n         DC    XL5'0',AL1(0,0,0,0,4)                               63\n         DC    XL5'0',AL1(0,0,0,0,4)                               64\n         DC    XL5'0',AL1(0,0,0,0,4)                               65\n         DC    XL5'0',AL1(0,0,0,0,4)                               66\n         DC    CL5'MXD',AL1(RX,FLTPT,0,0,4)                        67\n         DC    CL5'LD',AL1(RX,FLTPT,0,0,4)                         68\n         DC    CL5'CD',AL1(RX,FLTPT,0,CPR,4)                       69\n         DC    CL5'AD',AL1(RX,FLTPT,0,ARITH,4)                     6A\n         DC    CL5'SD',AL1(RX,FLTPT,0,ARITH,4)                     6B\n         DC    CL5'MD',AL1(RX,FLTPT,0,0,4)                         6C\n         DC    CL5'DD',AL1(RX,FLTPT,0,0,4)                         6D\n         DC    CL5'AW',AL1(RX,FLTPT,0,ARITH,4)                     6E\n         DC    CL5'SW',AL1(RX,FLTPT,0,ARITH,4)                     6F\n         DC    CL5'STE',AL1(RX,FLTPT+FLSHT,0,0,4)                  70\n         DC    XL5'0',AL1(0,0,0,0,4)                               71\n         DC    XL5'0',AL1(0,0,0,0,4)                               72\n         DC    XL5'0',AL1(0,0,0,0,4)                               73\n         DC    XL5'0',AL1(0,0,0,0,4)                               74\n         DC    XL5'0',AL1(0,0,0,0,4)                               75\n         DC    XL5'0',AL1(0,0,0,0,4)                               76\n         DC    XL5'0',AL1(0,0,0,0,4)                               77\n         DC    CL5'LE',AL1(RX,FLTPT+FLSHT,0,0,4)                   78\n         DC    CL5'CE',AL1(RX,FLTPT+FLSHT,0,CPR,4)                 79\n         DC    CL5'AE',AL1(RX,FLTPT+FLSHT,0,ARITH,4)               7A\n         DC    CL5'SE',AL1(RX,FLTPT+FLSHT,0,ARITH,4)               7B\n         DC    CL5'ME',AL1(RX,FLTPT+FLSHT,0,0,4)                   7C\n         DC    CL5'DE',AL1(RX,FLTPT+FLSHT,0,0,4)                   7D\n         DC    CL5'AU',AL1(RX,FLTPT+FLSHT,0,ARITH,4)               7E\n         DC    CL5'SU',AL1(RX,FLTPT+FLSHT,0,ARITH,4)               7F\n         DC    CL5'SSM',AL1(S,PRIV,0,0,4)                          80\n         DC    XL5'0',AL1(0,0,0,0,4)                               81\n         DC    CL5'LPSW',AL1(S,PRIV,E8,ARITH,4)                    82\n         DC    XL5'0',AL1(0,0,0,0,4)                               83\n         DC    CL5'WRD',AL1(SI,PRIV,0,0,4)                         84\n         DC    CL5'RDD',AL1(SI,PRIV,0,0,4)                         85\n         DC    CL5'BXH',AL1(RS,0,E2+S2,0,4)                        86\n         DC    CL5'BXLE',AL1(RS,0,E2+S2,0,4)                       87\n         DC    CL5'SRL',AL1(RS,0,0,0,4)                            88\n         DC    CL5'SLL',AL1(RS,0,0,0,4)                            89\n         DC    CL5'SRA',AL1(RS,0,0,ARITH,4)                        8A\n         DC    CL5'SLA',AL1(RS,0,0,ARITH,4)                        8B\n         DC    CL5'SRDL',AL1(RS,0,EPR,0,4)                         8C\n         DC    CL5'SLDL',AL1(RS,0,EPR,0,4)                         8D\n         DC    CL5'SRDA',AL1(RS,0,EPR,ARITH,4)                     8E\n         DC    CL5'SLDA',AL1(RS,0,EPR,ARITH,4)                     8F\n         DC    CL5'STM',AL1(RS,0,E4+S2,0,4)                        90\n         DC    CL5'TM',AL1(SI,0,0,ARITH,4)                         91\n         DC    CL5'MVI',AL1(SI,0,S2,0,4)                           92\n         DC    CL5'TS',AL1(S,0,0,ARITH,4)                          93\n         DC    CL5'NI',AL1(SI,0,0,ZRO8,4)                          94\n         DC    CL5'CLI',AL1(SI,0,0,CPR,4)                          95\n         DC    CL5'OI',AL1(SI,0,0,ZRO8,4)                          96\n         DC    CL5'XI',AL1(SI,0,0,ZRO8,4)                          97\n         DC    CL5'LM',AL1(RS,0,E4,0,4)                            98\n         DC    CL5'TRACE',AL1(RS,PRIV,E4,0,4)                      99\n         DC    XL5'0',AL1(0,0,0,0,4)                               9A\n         DC    XL5'0',AL1(0,0,0,0,4)                               9B\n         DC    CL5' ',AL1(TWO,0,0,0,4)                             9C\n         DC    CL5' ',AL1(TWO,0,0,0,4)                             9D\n         DC    CL5' ',AL1(TWO,0,0,0,4)                             9E\n         DC    CL5' ',AL1(TWO,0,0,0,4)                             9F\n         DC    XL5'0',AL1(0,0,0,0,4)                               A0\n         DC    XL5'0',AL1(0,0,0,0,4)                               A1\n         DC    XL5'0',AL1(0,0,0,0,4)                               A2\n         DC    XL5'0',AL1(0,0,0,0,4)                               A3\n         DC    XL5'0',AL1(0,0,0,0,4)                               A4\n         DC    XL5'0',AL1(0,0,0,0,4)                               A5\n         DC    XL5'0',AL1(0,0,0,0,4)                               A6\n         DC    XL5'0',AL1(0,0,0,0,4)                               A7\n         DC    XL5'0',AL1(0,0,0,0,4)                               A8\n         DC    XL5'0',AL1(0,0,0,0,4)                               A9\n         DC    XL5'0',AL1(0,0,0,0,4)                               AA\n         DC    XL5'0',AL1(0,0,0,0,4)                               AB\n         DC    CL5'STNSM',AL1(SI,PRIV,0,0,4)                       AC\n         DC    CL5'STOSM',AL1(SI,PRIV,0,0,4)                       AD\n         DC    CL5'SIGP',AL1(RS,PRIV,0,ARITH,4)                    AE\n         DC    CL5'MC',AL1(SI,0,0,0,4)                             AF\n         DC    XL5'0',AL1(0,0,0,0,4)                               B0\n         DC    CL5'LRA',AL1(RX,PRIV,0,ARITH,4)                     B1\n         DC    CL5' ',AL1(TWO,0,0,0,4)                             B2\n         DC    XL5'0',AL1(0,0,0,0,4)                               B3\n         DC    XL5'0',AL1(0,0,0,0,4)                               B4\n         DC    XL5'0',AL1(0,0,0,0,4)                               B5\n         DC    CL5'STCTL',AL1(RS,PRIV,0,0,4)                       B6\n         DC    CL5'LCTL',AL1(RS,PRIV,E4,0,4)                       B7\n         DC    XL5'0',AL1(0,0,0,0,4)                               B8\n         DC    XL5'0',AL1(0,0,0,0,4)                               B9\n         DC    CL5'CS',AL1(RS,0,E4+EPR,ARITH,4)                    BA\n         DC    CL5'CDS',AL1(RS,0,E4+EPR,ARITH,4)                   BB\n         DC    XL5'0',AL1(0,0,0,0,4)                               BC\n         DC    CL5'CLM',AL1(RS,0,0,CPR,4)                          BD\n         DC    CL5'STCM',AL1(RS,0,S2,0,4)                          BE\n         DC    CL5'ICM',AL1(RS,0,0,ZRO8,4)                         BF\n         DC    XL5'0',AL1(0,0,0,0,6)                               C0\n         DC    XL5'0',AL1(0,0,0,0,6)                               C1\n         DC    XL5'0',AL1(0,0,0,0,6)                               C2\n         DC    XL5'0',AL1(0,0,0,0,6)                               C3\n         DC    XL5'0',AL1(0,0,0,0,6)                               C4\n         DC    XL5'0',AL1(0,0,0,0,6)                               C5\n         DC    XL5'0',AL1(0,0,0,0,6)                               C6\n         DC    XL5'0',AL1(0,0,0,0,6)                               C7\n         DC    XL5'0',AL1(0,0,0,0,6)                               C8\n         DC    XL5'0',AL1(0,0,0,0,6)                               C9\n         DC    XL5'0',AL1(0,0,0,0,6)                               CA\n         DC    XL5'0',AL1(0,0,0,0,6)                               CB\n         DC    XL5'0',AL1(0,0,0,0,6)                               CC\n         DC    XL5'0',AL1(0,0,0,0,6)                               CD\n         DC    XL5'0',AL1(0,0,0,0,6)                               CE\n         DC    XL5'0',AL1(0,0,0,0,6)                               CF\n         DC    XL5'0',AL1(0,0,0,0,6)                               D0\n         DC    CL5'MVN',AL1(SS1,0,S1,0,6)                          D1\n         DC    CL5'MVC',AL1(SS1,0,S1,0,6)                          D2\n         DC    CL5'MVZ',AL1(SS1,0,S1,0,6)                          D3\n         DC    CL5'NC',AL1(SS1,0,S1,ZRO8,6)                        D4\n         DC    CL5'CLC',AL1(SS1,0,0,CPR,6)                         D5\n         DC    CL5'OC',AL1(SS1,0,S1,ZRO8,6)                        D6\n         DC    CL5'XC',AL1(SS1,0,S1,ZRO8,6)                        D7\n         DC    XL5'0',AL1(0,0,0,0,6)                               D8\n         DC    CL5'MVCK',AL1(SSR,PRIV,0,ZRO8,6)                    D9\n         DC    CL5'MVCP',AL1(SSR,PRIV,0,ZRO8,6)                    DA\n         DC    CL5'MVCS',AL1(SSR,PRIV,0,ZRO8,6)                    DB\n         DC    CL5'TR',AL1(SS1,0,S1,0,6)                           DC\n         DC    CL5'TRT',AL1(SS1,0,0,ZRO8,6)                        DD\n         DC    CL5'ED',AL1(SS1,0,S1,ARITH,6)                       DE\n         DC    CL5'EDMK',AL1(SS1,0,S1,ARITH,6)                     DF\n         DC    XL5'0',AL1(0,0,0,0,6)                               E0\n         DC    XL5'0',AL1(0,0,0,0,6)                               E1\n         DC    XL5'0',AL1(0,0,0,0,6)                               E2\n         DC    XL5'0',AL1(0,0,0,0,6)                               E3\n         DC    XL5'0',AL1(0,0,0,0,6)                               E4\n         DC    CL5' ',AL1(TWO,0,0,0,6)                             E5\n         DC    XL5'0',AL1(0,0,0,0,6)                               E6\n         DC    XL5'0',AL1(0,0,0,0,6)                               E7\n         DC    CL5'MVCIN',AL1(SS1,0,S1,0,6)                        E8\n         DC    XL5'0',AL1(0,0,0,0,6)                               E9\n         DC    XL5'0',AL1(0,0,0,0,6)                               EA\n         DC    XL5'0',AL1(0,0,0,0,6)                               EB\n         DC    XL5'0',AL1(0,0,0,0,6)                               EC\n         DC    XL5'0',AL1(0,0,0,0,6)                               ED\n         DC    XL5'0',AL1(0,0,0,0,6)                               EE\n         DC    XL5'0',AL1(0,0,0,0,6)                               EF\n         DC    CL5'SRP',AL1(SS2,0,S1,ARITH,6)                      F0\n         DC    CL5'MVO',AL1(SS2,0,S1,0,6)                          F1\n         DC    CL5'PACK',AL1(SS2,0,S1,0,6)                         F2\n         DC    CL5'UNPK',AL1(SS2,0,S1,0,6)                         F3\n         DC    XL5'0',AL1(0,0,0,0,6)                               F4\n         DC    XL5'0',AL1(0,0,0,0,6)                               F5\n         DC    XL5'0',AL1(0,0,0,0,6)                               F6\n         DC    XL5'0',AL1(0,0,0,0,6)                               F7\n         DC    CL5'ZAP',AL1(SS2,0,S1,ARITH,6)                      F8\n         DC    CL5'CP',AL1(SS2,0,0,CPR,6)                          F9\n         DC    CL5'AP',AL1(SS2,0,S1,ARITH,6)                       FA\n         DC    CL5'SP',AL1(SS2,0,S1,ARITH,6)                       FB\n         DC    CL5'MP',AL1(SS2,0,S1,0,6)                           FC\n         DC    CL5'DP',AL1(SS2,0,S1,0,6)                           FD\n         DC    XL5'0',AL1(0,0,0,0,6)                               FE\n         DC    XL5'0',AL1(0,0,0,0,6)                               FF\n         DC    X'FFFF'                 TABLE END\n         SPACE 1                                                   -EU-\n*        THE FOLLOWING TEST CONSTANT MUST BE ZERO,                 -EU-\n*        OTHERWISE THERE WILL BE ANY TABLE ERROR.                  -EU-\n         DC    AL4((*-SGLOP)-((256*L'SGLOP)+2))                    -EU-\n         EJECT\nDBLOP    DS    0CL12                   TWO-BYTE OP-CODE TABLE\n         DC    X'9C00',CL5'SIO',AL1(S,PRIV,0,ARITH,4)              9C\n         DC    X'9C01',CL5'SIOF',AL1(S,PRIV,0,ARITH,4)\n         DC    X'9D00',CL5'TIO',AL1(S,PRIV,0,ARITH,4)              9D\n         DC    X'9D01',CL5'CLRIO',AL1(S,PRIV,0,ARITH,4)\n         DC    X'9E00',CL5'HIO',AL1(S,PRIV,0,ARITH,4)              9E\n         DC    X'9E01',CL5'HDV',AL1(S,PRIV,0,ARITH,4)\n         DC    X'9F00',CL5'TCH',AL1(S,PRIV,0,ARITH,4)              9F\n         DC    X'9F01',CL5'CLRCH',AL1(S,PRIV,0,ARITH,4)\n         DC    X'B200',CL5'CONCS',AL1(S,PRIV,0,ARITH,4)            B2\n         DC    X'B201',CL5'DISCS',AL1(S,PRIV,0,ARITH,4)\n         DC    X'B202',CL5'STIDP',AL1(S,PRIV,E8,0,4)\n         DC    X'B203',CL5'STIDC',AL1(S,PRIV,0,ARITH,4)\n         DC    X'B204',CL5'SCK',AL1(S,PRIV,E8,ARITH,4)\n         DC    X'B205',CL5'STCK',AL1(S,0,S2,ARITH,4)\n         DC    X'B206',CL5'SCKC',AL1(S,PRIV,E8,0,4)\n         DC    X'B207',CL5'STCKC',AL1(S,PRIV,E8,0,4)\n         DC    X'B208',CL5'SPT',AL1(S,PRIV,E8,0,4)\n         DC    X'B209',CL5'STPT',AL1(S,PRIV,E8,0,4)\n         DC    X'B20A',CL5'SPKA',AL1(S,PRIV,0,0,4)\n         DC    X'B20B',CL5'IPK',AL1(S,PRIV+IOP,0,0,4)\n         DC    X'B20D',CL5'PTLB',AL1(S,PRIV+IOP,0,0,4)\n         DC    X'B210',CL5'SPX',AL1(S,PRIV,E4,0,4)\n         DC    X'B211',CL5'STPX',AL1(S,PRIV,E4,0,4)\n         DC    X'B212',CL5'STAP',AL1(S,PRIV,E2,0,4)\n         DC    X'B213',CL5'RRB',AL1(S,PRIV,0,ARITH,4)\n         DC    X'B218',CL5'PC',AL1(S,PRIV,0,0,4)\n         DC    X'B219',CL5'SAC',AL1(S,0,0,0,4)\n         DC    X'B221',CL5'IPTE',AL1(RRE,PRIV,0,0,4)\n         DC    X'B222',CL5'IPM',AL1(RRE,0,E1R,0,4)\n         DC    X'B223',CL5'IVSK',AL1(RRE,PRIV,0,0,4)\n         DC    X'B224',CL5'IAC',AL1(RRE,PRIV,E1R,ARITH,4)\n         DC    X'B225',CL5'SSAR',AL1(RRE,PRIV,E1R,0,4)\n         DC    X'B226',CL5'EPAR',AL1(RRE,PRIV,E1R,0,4)\n         DC    X'B227',CL5'ESAR',AL1(RRE,PRIV,E1R,0,4)\n         DC    X'B228',CL5'PT',AL1(RRE,PRIV,0,0,4)\n         DC    X'B229',CL5'ISKE',AL1(RRE,PRIV,0,0,4)\n         DC    X'B22A',CL5'RRBE',AL1(RRE,PRIV,0,ARITH,4)\n         DC    X'B22B',CL5'SSKE',AL1(RRE,PRIV,0,0,4)\n         DC    X'B22C',CL5'TB',AL1(RRE,PRIV,0,ARITH,4)\n         DC    X'B22D',CL5'DXR',AL1(RRE,FLTPT+FLEXR,0,0,4)\n         DC    X'B230',CL5'CSCH',AL1(S,PRIV+IOP,0,ARITH,4)\n         DC    X'B231',CL5'HSCH',AL1(S,PRIV+IOP,0,ARITH,4)\n         DC    X'B232',CL5'MSCH',AL1(S,PRIV,E4,ARITH,4)\n         DC    X'B233',CL5'SSCH',AL1(S,PRIV,E4,ARITH,4)\n         DC    X'B234',CL5'STSCH',AL1(S,PRIV,E4,ARITH,4)\n         DC    X'B235',CL5'TSCH',AL1(S,PRIV,E4,ARITH,4)\n         DC    X'B236',CL5'TPI',AL1(S,PRIV,E4,ARITH,4)\n         DC    X'B237',CL5'SAL',AL1(S,PRIV+IOP,0,0,4)\n         DC    X'B238',CL5'RSCH',AL1(S,PRIV+IOP,0,ARITH,4)\n         DC    X'B239',CL5'STCRW',AL1(S,PRIV,E4,ARITH,4)\n         DC    X'B23A',CL5'STCPS',AL1(S,PRIV,0,0,4)\n         DC    X'B23B',CL5'RCHP',AL1(S,PRIV+IOP,0,ARITH,4)\n         DC    X'B23C',CL5'SCHM',AL1(S,PRIV+IOP,0,0,4)\n         DC    X'E500',CL5'LASP',AL1(SSE,PRIV,E8,ARITH,6)          E5\n         DC    X'E501',CL5'TPROT',AL1(SSE,PRIV,0,ARITH,6)\n         DC    X'FFFF'                 TABLE END\n         SPACE 1                                                   -EU-\n*        THE FOLLOWING TEST CONSTANT MUST BE ZERO,                 -EU-\n*        OTHERWISE THERE WILL BE ANY TABLE ERROR.                  -EU-\n         DC    AL4((*-DBLOP)-((((*-DBLOP)/L'DBLOP)*L'DBLOP)+2))    -EU-\n         EJECT\nSVCOP    DS    0CL15                   SVC NAME TABLE\n         DC    AL1(0),CL14'EXCP/XDAP'\n         DC    AL1(1),CL14'WAIT(R)/PRTOV'\n         DC    AL1(2),CL14'POST'\n         DC    AL1(3),CL14'EXIT'\n         DC    AL1(4),CL14'GETMAIN'\n         DC    AL1(5),CL14'FREEMAIN'\n         DC    AL1(6),CL14'LINK'\n         DC    AL1(7),CL14'XCTL'\n         DC    AL1(8),CL14'LOAD'\n         DC    AL1(9),CL14'DELETE'\n         DC    AL1(10),CL14'GET/FREEMAIN R'\n         DC    AL1(11),CL14'TIME'\n         DC    AL1(12),CL14'SYNCH'\n         DC    AL1(13),CL14'ABEND'\n         DC    AL1(14),CL14'SPIE'\n         DC    AL1(15),CL14'ERREXCP'\n         DC    AL1(16),CL14'PURGE'\n         DC    AL1(17),CL14'RESTORE'\n         DC    AL1(18),CL14'BLDL/FIND'\n         DC    AL1(19),CL14'OPEN'\n         DC    AL1(20),CL14'CLOSE'\n         DC    AL1(21),CL14'STOW'\n         DC    AL1(22),CL14'OPEN TYPE J'\n         DC    AL1(23),CL14'CLOSE TYPE T'\n         DC    AL1(24),CL14'DEVTYPE'\n         DC    AL1(25),CL14'TRKBAL'\n         DC    AL1(26),CL14'LOCATE, ...'\n         DC    AL1(27),CL14'OBTAIN'\n         DC    AL1(29),CL14'SCRATCH'\n         DC    AL1(30),CL14'RENAME'\n         DC    AL1(31),CL14'FEOV'\n         DC    AL1(32),CL14'ALLOC'\n         DC    AL1(33),CL14'IOHALT'\n         DC    AL1(34),CL14'MGCR/QEDIT'\n         DC    AL1(35),CL14'WTO/WTOR'\n         DC    AL1(36),CL14'WTL'\n         DC    AL1(37),CL14'SEGLD/SEGWT'\n         DC    AL1(39),CL14'LABEL'\n         DC    AL1(40),CL14'EXTRACT'\n         DC    AL1(41),CL14'IDENTIFY'\n         DC    AL1(42),CL14'ATTACH'\n         DC    AL1(43),CL14'CIRB'\n         DC    AL1(44),CL14'CHAP'\n         DC    AL1(45),CL14'OVLYBRCH'\n         DC    AL1(46),CL14'TTIMER'\n         DC    AL1(47),CL14'STIMER'\n         DC    AL1(48),CL14'DEQ'\n         DC    AL1(51),CL14'SNAP/SDUMP'\n         DC    AL1(52),CL14'RESTART'\n         DC    AL1(53),CL14'RELEX'\n         DC    AL1(54),CL14'DISABLE'\n         DC    AL1(55),CL14'EOV'\n         DC    AL1(56),CL14'ENQ/RESERVE'\n         DC    AL1(57),CL14'FREEDBUF'\n         DC    AL1(58),CL14'RELBUF/REQBUF'\n         DC    AL1(59),CL14'OLTEP'\n         DC    AL1(60),CL14'(E)STAE/STAI'\n         DC    AL1(61),CL14'IKJEGS6A'\n         DC    AL1(62),CL14'DETACH'\n         DC    AL1(63),CL14'CHKPT'\n         DC    AL1(64),CL14'RDJFCB'\n         DC    AL1(66),CL14'BTAMTEST'\n         DC    AL1(68),CL14'(SYNAD)AF/RLS'\n         DC    AL1(69),CL14'BSP'\n         DC    AL1(70),CL14'GSERV'\n         DC    AL1(71),CL14'ASGNBFR, ...'\n         DC    AL1(72),CL14'(NO MACRO)'\n         DC    AL1(73),CL14'SPAR'\n         DC    AL1(74),CL14'DAR'\n         DC    AL1(75),CL14'DQUEUE'\n         DC    AL1(76),CL14'IFBSTAT'\n         DC    AL1(78),CL14'LSPACE'\n         DC    AL1(79),CL14'STATUS'\n         DC    AL1(81),CL14'SETPRT'\n         DC    AL1(83),CL14'SMFWTM'\n         DC    AL1(84),CL14'GRAPHICS'\n         DC    AL1(85),CL14'DDRSWAP'\n         DC    AL1(86),CL14'ATLAS'\n         DC    AL1(87),CL14'DOM'\n         DC    AL1(91),CL14'VOLSTAT'\n         DC    AL1(92),CL14'TCPEXCP'\n         DC    AL1(93),CL14'TGET/TPUT'\n         DC    AL1(94),CL14'STCC'\n         DC    AL1(95),CL14'SYSEVENT'\n         DC    AL1(96),CL14'STAX'\n         DC    AL1(97),CL14'IKJEGS9G'\n         DC    AL1(98),CL14'PROTECT'\n         DC    AL1(99),CL14'DYNALLOC'\n         DC    AL1(100),CL14'IKJEFFIB'\n         DC    AL1(101),CL14'QTIP'\n         DC    AL1(102),CL14'AQCTL'\n         DC    AL1(103),CL14'XLATE'\n         DC    AL1(104),CL14'TOPCTL'\n         DC    AL1(105),CL14'IMGLIB'\n         DC    AL1(107),CL14'MODESET'\n         DC    AL1(109),CL14'ESR TYPE 4'\n         DC    AL1(110),CL14'(NO MACRO)'\n         DC    AL1(111),CL14'(NO MACRO)'\n         DC    AL1(112),CL14'PGRLSE'\n         DC    AL1(113),CL14'PGFIX, ...'\n         DC    AL1(114),CL14'EXCPVR'\n         DC    AL1(116),CL14'ESR TYPE 1'\n         DC    AL1(117),CL14'DEBCHK'\n         DC    AL1(119),CL14'TESTAUTH'\n         DC    AL1(120),CL14'GETMAIN/FREEMAIN'\n         DC    AL1(121),CL14'VSAM'\n         DC    AL1(122),CL14'ESR TYPE 2'\n         DC    AL1(123),CL14'PURGEDQ'\n         DC    AL1(124),CL14'TPIO'\n         DC    AL1(125),CL14'EVENTS'\n         DC    AL1(126),CL14'MSS(ICB2SVC)'\n         DC    AL1(130),CL14'RACHECK'\n         DC    AL1(131),CL14'RACINIT'\n         DC    AL1(132),CL14'RACLIST'\n         DC    AL1(133),CL14'RACDEF'\n         DC    AL1(137),CL14'ESR'\n         DC    AL1(138),CL14'PGSER'\n         DC    AL1(139),CL14'CVAFDIR, ...'\n         SPACE 1                                                   -EU-\n*        HERE FOLLOWS INSTALLATION DEPENDENT SVC'S.                -EU-\n*        ------------------------------------------                -EU-\n         SPACE 1                                                   -EU-\n         DC    AL1(210),CL14'CICS-VS 1.6.1'                        -EU-\n         DC    AL1(214),CL14'I.M.S. 1.3'                           -EU-\n         DC    AL1(215),CL14'I.M.S. 1.2'                           -EU-\n         DC    AL1(216),CL14'ADABAS'                               -EU-\n         DC    AL1(220),CL14'CICS-VS 1.6.1'                        -EU-\n         DC    AL1(225),CL14'I.M.S. 1.3'                           -EU-\n         DC    AL1(235),CL14'D.M.S.'                               -EU-\n         DC    AL1(247),CL14'EU-SPF-AUTH.'                         -EU-\n         DC    AL1(253),CL14'EU-AUTH.'                             -EU-\n         DC    X'FFFF'                 END OF TABLE\n         SPACE 1                                                   -EU-\n*        THE FOLLOWING TEST CONSTANT MUST BE ZERO,                 -EU-\n*        OTHERWISE THERE WILL BE ANY TABLE ERROR.                  -EU-\n         DC    AL4((*-SVCOP)-((((*-SVCOP)/L'SVCOP)*L'SVCOP)+2))    -EU-\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISASM1": {"ttr": 4867, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x8f\\x00\\x882\\x8f\\x149\\x05|\\x05|\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-23T00:00:00", "modifydate": "1988-11-23T14:39:00", "lines": 1404, "newlines": 1404, "modlines": 0, "user": "SYSPAJA"}, "text": "DIS1     TITLE '*** DISASSEMBLY PHASE 1 ***'\n         PRINT OFF                                                 -EU-\n         COPY  DISASMM                                             -EU-\n         PRINT ON                                                  -EU-\nDISASM1  SVLNK R3,R4\n         EJECT\n         PRINT NOGEN\n* THIS SUB-PROGRAM IS CALLED BY DISASM, AND IS PHASE 2 OF\n* THE DISASSEMBLY PROCESS. A COMMON DATA\n* AREA IS DEFINED IN DISASM, AND PASSED TO THIS PROGRAM.\n*\n*    THE SYSIN FILE IS READ TO EXHAUSTION. USING CARDS ARE\n* REFORMATTED AND STORED IN A TABLE - UP TO 256 USING\n* STATEMENTS MAY BE ENTERED. DSECT CARDS MAY FOLLOW THE\n* USING STATEMENTS. WHEN USED, DSECT STATEMENTS ARE\n* REFORMATTED, AND BUILT INTO TABLES. A MAXIMUM OF 256 DSECTS\n* MAY BE ENTERED. DATA ONLY CARDS MAY BE INCLUDED BEFORE, BETWEEN,\n* OR AFTER DSECTS TO SHOW AREAS IN THE PROGRAM WHERE NO INSTRUCTIONS\n* OCCUR. UP TO 256 DATA ONLY AREAS MAY BE SPECIFIED.\n*\n*     AT EOF ON SYSIN, A PSEUDO DIS-ASSEMBLY PASS IS MADE\n* USING THE TEXT STORED BY DISASM. ANY RESOLVABLE ADDRESS\n* WITHIN THE TEXT IS USED TO CREATE A NEW ENTRY IN THE\n* LABEL TABLE, WHICH WILL BE USED BY DISASM2 IN THE\n* ACTUAL DIS-ASSEMBLY PASS.\n*\n* THE USING CARDS FOR BASE REGISTERS ASSOCIATED WITH DSECT DEFINITIONS\n* MUST BE ENTERED AT SOME POINT AFTER THE DSECT CARDS HAVE BEEN\n* INCLUDED. USING CARDS FOR PROGRAM BASE REGISTERS MAY BE ENTERED\n* AT ANY POINT. THE USING CARD FORMAT IS:\n*       COL 1-5   : LITERAL 'USING'\n*       COL 6     : BLANK\n*       COL 7-12  : OFFSET TO BEGIN LOCATION FOR USING RANGE (HEX)\n*       COL 13    : BLANK\n*       COL 14-19 : OFFSET TO ENDING LOCATION FOR USING RANGE (HEX)\n*       COL 20    : BLANK\n*       COL 21    : BASE RESISTER TO BE USED (HEX, 1-F)\n*       COL 22    : BLANK\n*       COL 23    : TYPE, P=PROGRAM BASE, D=DSECT BASE\n*       COL 24    : BLANK\n*       COL 25-30 : INITIAL BASE REGISTER VALUE IF TYPE P (HEX)\n*       COL 25-32 : DSECT NAME IF TYPE D\n*\n*     A DSECT IS ENTERED USING A HEADER CARD,FOLLOWED BY\n* ONE OR MORE FIELD DEFINITION CARDS. ALL FIELD DEFINITION\n* CARDS MUST FOLLOW THE DSECT HEADER CARD. USING CARDS MAY\n* NOT BE INTERSPERSED WITH DSECT DEFINITIONS, BUT MAY PRECEDE\n* OR FOLLOW ANY DSECT.\n*     DSECT HEADER CARD FORMAT:\n*        COL 1-8    : DSECT NAME\n*        COL 9      : BLANK\n*        COL 10-14  : LITERAL 'DSECT'\n*        COL 15     : BLANK\n*        COL 16-19  : NUMBER OF FIELD CARDS TO FOLLOW (DECIMAL)\n*\n*     DSECT FIELD CARD FORMAT:\n*        COL 1-8    : FIELD NAME\n*        COL 9      : BLANK\n*        COL 10-13  : OFFSET TO LEFT END OF FIELD (DECIMAL)\n*        COL 14     : BLANK\n*        COL 15-17  : LENGTH OF FIELD IN BYTES (DECIMAL)\n*\n*     A DATA ONLY CARD IS USED TO DESIGNATE A RANGE OF OFFSETS\n* BETWEEN WHICH NO INSTRUCTIONS EXIST. USE OF THESE CARDS ELIMINATES\n* THE CHANCE THAT DATA ELEMENTS WILL BE TREATED AS INSTRUCTIONS\n* BETWEEN THE OFFSETS SPECIFIED. FORMAT IS:\n*        COL 1-4    : LITERAL 'DATA'\n*        COL 5      : BLANK\n*        COL 6-11   : OFFSET TO BEGINNING OF AREA (HEX)\n*        COL 12     : BLANK\n*        COL 13-18  : OFFSET TO END OF AREA (HEX)\n*\n*\n*     USER LABEL CARDS ARE USED TO PERMIT SPECIFICATION OF\n* LABELS OTHER THAN THE AXXXXXX NAMES CREATED BY DISASM. THEY\n* MAY APPEAR ANYWHERE IN THE SYSIN STREAM EXCEPT AS THE FIRST\n* CARD, OR WITHIN A DSECT DEFINITION.\n*        COL  1-5  : LITERAL 'ULABL'\n*        COL   6   : BLANK\n*        COL  7-14 : FIELD NAME\n*        COL   15  : BLANK\n*        COL 16-21 : OFFSET TO LEFT END OF AREA (HEX)\n*        COL   22  : BLANK\n*        COL 23-25 : FIELD LENGTH (DECIMAL)\n*\n*      DISASSEMBLY TABLES ARE SET UP IDENTICALLY TO THOSE USED BY\n* DISASM2 FOR THE SIMULATED DISASSEMBLY PERFORMED IN THIS\n* MODULE WHEN ANY PROGRAM BASE REGISTER USING STATEMENTS\n* ARE ENTERED.\n*\n*     STORAGE IS OBTAINED FOR THE DSECT TABLE AND USING TABLE,\n* AND ADDRESSES OF THESE TABLES ARE STORED IN THE COMMON PARAMETER\n* AREA. USING AND DSECT CARDS ARE EDITED, REFORMATTED, AND PLACED\n* IN THE APPROPRIATE TABLES. IF ANY ERRORS ARE FOUND, THEY ARE\n* PRINTED, AND THE DISASSEMBLY WILL BE TERMINATED ON RETURN\n* TO DISASM.\n*\n*     STORAGE IS OBTAINED FOR THE LABEL TABLE, AND A SIMULATED\n* DIS-ASSEMBLY IS PERFORMED TO CREATE LABEL TABLE ENTRIES FOR\n* LABELS WHICH WILL BE GENERATED FOR BASE-DISPLACEMENT ADDRESSES\n* BY DISASM2. ON RETURN TO DISASM, THESE LABELS WILL BE SORTED\n* WITH EXTERNAL SYMBOL AND RLD LABELS TO FORM THE FINAL LABEL\n* TABLE TO BE USED BY DISASM2.\n*\n*\n* AUTHOR R THORNTON - FEB 1978\n*        UPDATES (MARKED -EU- IN COLUMNS 68-71) DONE BY            -EU-\n*        MOINIL P.A. , COMPUTING CENTRE                            -EU-\n*                      J.R.C. - ISPRA ESTABLISHMENT                -EU-\n*                      21020 ISPRA (VA), ITALY                     -EU-\n         EJECT\n******************************************************************\n*                                                                *\n* GET STORAGE FOR USING AND DSECT POINTER TABLES.                *\n*                                                                *\n******************************************************************\n         SPACE 1\n         L     R5,0(R1)                GET PARM FIELD ADDRESS\n         USING COMMPARM,R5\n         L     R0,USGLGTH              USING TABLE LENGTH          -EU-\n         GETMAIN R,LV=(0)              GET STORAGE FOR USING TABLE -EU-\n         MVI   0(R1),X'FF'             SET TABLE END INDIC\n         ST    R1,USGSTRT              SAVE TABLE START ADDRESS\n         ST    R1,USGCUR               SET TABLE CURRENT ADDRESS\n         A     R1,USGLGTH              COMPUTE TABLE END ADDRESS   -EU-\n         SH    R1,H8                                               -EU-\n         ST    R1,USGEND               SAVE USING TABLE END ADDRESS\n         L     R0,DTBLGTH              DSECT TABLE LENGTH          -EU-\n         GETMAIN R,LV=(0)              GET STORAGE FOR DSECT TABLE -EU-\n         MVI   0(R1),X'FF'             SET TABLE END ADDRESS\n         ST    R1,DTBSTRT              SAVE DSECT TABLE START ADDRESS\n         ST    R1,DTBCURR              SAVE DSECT TABLE CURRENT ADDRESS\n         A     R1,DTBLGTH              COMPUTE TABLE END ADDRESS   -EU-\n         SH    R1,H8                                               -EU-\n         ST    R1,DTBEND               SAVE DSECT TABLE END ADDRESS\n         L     R2,INDCB                @ SYSIN DCB                 -EU-\n         USING IHADCB,R2                                           -EU-\n         LA    R1,EOFCARD              GET EOF ADDRESS\n         STCM  R1,B'0111',DCBEODA      SET EOF ADDRESS IN DCB\n         TM    DCBOFLGS,DCBOFOPN       IS IT OPEN\n         BZ    EOFCARD                 NO\n         DROP  R2                                                  -EU-\n         EJECT\n******************************************************************\n*                                                                *\n* READ SYSIN CARDS, AND DISTRIBUTE TO THE APPROPRIATE PROCESSING *\n* ROUTINE: USINGS, DSECTS, OR DATAS. DETECT ANY ERRORS AND PRINT *\n* ALL CARDS WITH MESSAGES AS NECESSARY.                          *\n*                                                                *\n******************************************************************\n         SPACE 1\nRDCARD   L     R1,INDCB                GET SYSIN DCB ADDR\n         GET   (1)                     READ NEXT CARD\n         MVC   WORKREC,0(R1)           MOVE IT TO WORK AREA\n         NOP   MVPRT                   FIRST TIME SWITCH\n         MVI   *-3,C'0'                RESET FIRST TIME SWITCH\n         MVI   PCC,C'1'                SET SKIP TO HEAD\n         MVC   PRT+10(26),=C'*** USER ENTERED CARDS ***'\n         BAS   R9,PRINT                GO PRINT\nMVPRT    MVC   PRT(80),WORKREC         CARD TO PRINT\nRDGRTN   LA    R9,RCCKERR              GET RETURN ADDRESS\n         CLC   WORKREC(5),=C'USING'    IS IT A USING CARD\n         BE    USINGS                  YES\n         CLC   WORKREC+9(5),=C'DSECT'  IS IT A DSECT HEADER\n         BE    DSECTS                  YES\n         CLC   WORKREC(4),=C'DATA'     IS IT DATA ONLY CARD\n         BE    DATAS                   YES\n         CLC   WORKREC(5),=C'ULABL'    IS IT A USER LABEL\n         BE    ULABLS                  YES\n         MVC   PRT+85(21),=C'UNIDENT OR OUT OF SEQ'\n         MVI   USERR,X'FF'             SET ERROR FLAG\nRCCKERR  NI    USERR,X'FE'             RESET CURRENT ERROR FLAG\n         BAS   R9,PRINT                GO PRINT\n         B     RDCARD                  CONTINUE\n         EJECT\n******************************************************************\n*                                                                *\n* EDIT USING CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*\n* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*\n* USING TABLE.                                                   *\n*                                                                *\n******************************************************************\n         SPACE 1\nUSINGS   L     R12,USGCUR              GET CURRENT USING TBL ADDR\n         C     R12,USGEND              END OF TBL\n         BNL   UERR6                   YES, TABLE FULL\n         USING USINGD,R12\n         LM    R10,R11,=A(TRHEX,TRTHEX)                            -EU-\n         TR    WORKREC+6(6),0(R10)     TRANSLATE TO MAKE HEX       -EU-\n         TRT   WORKREC+6(6),0(R11)     CHECK VALID                 -EU-\n         BNZ   UERR1                   INVALID BEGIN ADDR\n         TR    WORKREC+13(6),0(R10)    TRANSLATE TO MAKE HEX       -EU-\n         TRT   WORKREC+13(6),0(R11)    CHECK VALID                 -EU-\n         BNZ   UERR2                   INVALID END ADDR\n         TR    WORKREC+20(1),0(R10)    TRANSLATE TO MAKE HEX       -EU-\n         TRT   WORKREC+20(1),0(R11)    CHECK VALID                 -EU-\n         BNZ   UERR3                   INVALID BASE REG\n         CLI   WORKREC+20,0            VALID BASE REG\n         BE    UERR3                   NO\n         CLI   WORKREC+22,C'P'         VALID TYPE\n         BE    CKINIT                  YES, PROGRAM BASE\n         CLI   WORKREC+22,C'D'         VALID TYPE\n         BNE   UERR8                   NO, ERROR\n         L     R1,DTBSTRT              GET DSECT TABLE STRT\n         USING DTDS,R1                                             -EU-\nCKDSEND  CLI   0(R1),X'FF'             END OF TABLE\n         BE    UERR5                   YES, MISSING DSECT\n         CLC   DTNAME(8),WORKREC+24    THIS THE DSECT ENTRY        -EU-\n         BE    USDSMV                  YES\n         LA    R1,L'DTL(R1)            TO NEXT ENTRY               -EU-\n         B     CKDSEND                 LOOP THRU DSECT TABLE\nUSDSMV   MVC   USVALU,DTADDR           MOVE DSECT TBL ADDR\n         B     USFINI                  CONTINUE\n         DROP  R1                                                  -EU-\nCKINIT   TR    WORKREC+24(6),0(R10)    TRANSLATE TO MAKE HEX       -EU-\n         TRT   WORKREC+24(6),0(R11)    CHECK VALIDITY              -EU-\n         BNZ   UERR4                   INVALID BASE REG VALUE\n         PACK  DBLWD(4),WORKREC+24(7)  PACK TO MAKE HEX\n         MVC   USVALU,DBLWD            BASE REG VALUE TO USING TBL\nUSFINI   PACK  DBLWD(4),WORKREC+6(7)   PACK TO MAKE HEX\n         MVC   USBGN,DBLWD             BEGIN ADDR TO USING TABLE\n         PACK  DBLWD(4),WORKREC+13(7)  PACK TO MAKE HEX\n         MVC   USEND,DBLWD             END ADDR TO USING TABLE\n         TM    USEND+2,1               IS IT ODD\n         BO    UERR2                   YES, ERROR\n         CLI   WORKREC+22,C'D'         DSECT BASE\n         BE    USFREG                  YES\n         CLC   USEND,LENGTH+1          WITHIN PROGRAM\n         BH    UERR2                   YES, ERROR\nUSFREG   MVC   USREG,WORKREC+20        BASE REG TO USING TABLE\n         MVC   USTYPE,WORKREC+22       TYPE TO USING TABLE\n         CLC   USBGN,USEND             END < BEGIN\n         BH    UERR7                   YES, ERROR\n         LA    R12,L'USING(R12)        TO NEXT USING TBL ENTRY\n         MVI   0(R12),X'FF'            SET TABLE END INDIC\n         ST    R12,USGCUR              SAVE UPDATED TABLE ADDR\n         BR    R9                      EXIT\nUERR1    MVC   PRT+85(22),=C'INVALID BEGIN COL 7-12'\n         B     UERRS                   CONTINUE\nUERR2    MVC   PRT+85(21),=C'INVALID END COL 14-19'\n         B     UERRS                   CONTINUE\nUERR3    MVC   PRT+85(18),=C'INVALID REG COL 21'\n         B     UERRS                   CONTINUE\nUERR4    MVC   PRT+85(25),=C'INVALID ADDRESS COL 25-30'\n         B     UERRS                   CONTINUE\nUERR5    MVC   PRT+85(25),=C'UNDEFINED DSECT COL 25-32'\n         B     UERRS                   CONTINUE\nUERR6    MVC   PRT+85(20),=C'OVER 256 USING CARDS'\n         B     UERRS                   CONTINUE\nUERR7    MVC   PRT+85(16),=C'END BEFORE BEGIN'\n         B     UERRS                   CONTINUE\nUERR8    MVC   PRT+85(19),=C'INVALID TYPE COL 23'\nUERRS    MVI   USBGN,X'FF'             INSURE TABLE END INDIC\n         MVI   USERR,X'FF'             SHOW ERROR\n         BR    R9                      EXIT\n         DROP  R12\n         EJECT\n******************************************************************\n*                                                                *\n* EDIT ULABL CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*\n* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*\n* LABEL TABLE. SEARCH FOR ANY TYPE A (ADCON) ENTRIES HAVING A    *\n* SYMBOL OF AXXXXXX, WHERE XXXXXX IS THE HEX OFFSET TO THE USER  *\n* LABEL. IF AN A TYPE ENTRY IS FOUND, CHANGE ITS SYMBOLIC NAME TO*\n* THAT OF THE USER LABEL.                                        *\n*                                                                *\n******************************************************************\n         SPACE 1\nULABLS   STM   R6,R12,ULSAV            SAVE REGS\n         CLI   WORKREC+6,C' '          NAME VALID\n         BE    ULERR1                  NO, 1ST CHAR CANNOT BE BLANK\n         MVC   UNAME+1(6),WORKREC+15   BUILD AXXXXXX NAME\n         LM    R10,R11,=A(TRHEX,TRTHEX)                            -EU-\n         TR    WORKREC+15(6),0(R10)    TRANSLATE TO MAKE HEX       -EU-\n         TRT   WORKREC+15(6),0(R11)    CHECK VALID HEX             -EU-\n         BNZ   ULERR2                  NOT VALID\n         MVZ   NUMCK,WORKREC+22        ZONES FOR NUMERIC TEST\n         CLC   NUMCK(3),ZEROS          LENGTH IS NUMERIC\n         BNE   ULERR3                  NO, ERROR\n         L     R6,CURRLBL              GET CURRENT LABEL TABLE ADDRESS\n         USING LABELD,R6\n         C     R6,ENDLBL               END OF TABLE\n         BNL   ULERR4                  YES, ERROR\n         MVC   LBLNAME,WORKREC+6       NAME TO LABEL ENTRY\n         MVI   LBLTYP,C'U'             TYPE TO LABEL ENTRY\n         PACK  DBLWD,WORKREC+22(3)     PACK LENGTH\n         CP    DBLWD,P256              LENGTH > 256\n         BH    ULERR2                  YES, ERROR\n         CVB   R12,DBLWD               CONVERT TO BINARY\n         STC   R12,LBLLEN              LENGTH TO LABEL ENTRY\n         PACK  DBLWD(4),WORKREC+15(7)  PACK TO MAKE VALID HEX\n         MVC   LBLADR,DBLWD            OFFSET TO LABEL\n         LA    R7,L'LABEL(R6)          @ NEXT LABEL ENTRY\n         MVC   0(3,R7),HIVAL           SET END INDIC\n         ST    R7,CURRLBL              SET NEW TABLE END ADDR\n         LR    R7,R6                   SAVE NEW ENTRY ADDRESS\n         L     R6,LBLTBL               GET 1ST LABEL ENTRY ADDR\nULBCKND  C     R6,CURRLBL              END OF TABLE\n         BNL   ULXIT                   YES, EXIT\n         CLI   LBLTYP,C'A'             IS IT ADCON ENTRY\n         BNE   ULBSTEP                 NO\n         CLC   LBLNAME,UNAME           ADCON SYMBOL AT USER LBL ADDR\n         BNE   ULBSTEP                 NO\n         MVC   LBLNAME,LBLNAME-LABEL(R7) SET USER SYMBOL IN ADCON\nULBSTEP  LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         B     ULBCKND                 LOOP THRU LABEL TABLE\n         B     ULXIT                   EXIT\nULERR1   MVC   PRT+85(21),=C'INVALID NAME COL 7-14'\n         B     ULERRS                  CONTINUE\nULERR2   MVC   PRT+85(28),=C'INVALID HEX OFFSET COL 16-21'\n         B     ULERRS                  CONTINUE\nULERR3   MVC   PRT+85(32),=C'INVALID DECIMAL LENGTH COL 23-25'\n         B     ULERRS                  CONTINUE\nULERR4   MVC   PRT+85(20),=C'LABEL TABLE OVERFLOW'\nULERRS   MVI   USERR,X'FF'             SET ERROR FLAG\nULXIT    LM    R6,R12,ULSAV            RESTORE REGS\n         BR    R9                      EXIT\n         EJECT\n******************************************************************\n*                                                                *\n* EDIT DSECT CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*\n* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*\n* DSECT HEADER TABLE, GETMAIN AN AREA TO CONTAIN THE FIELD       *\n* DESCRIPTION ENTRIES, READ AND BUILD FIELD ENTRIES FOR ALL FIELD*\n* DESCRIPTION CARDS ENTERED.                                     *\n*                                                                *\n******************************************************************\n         SPACE 1\nDSECTS   ST    R9,DSCT9                SAVE RETURN ADDR\n         CLI   WORKREC,C' '            NAME IS BLANK\n         BE    DSERR1                  YES, ERROR\n         MVZ   NUMCK,WORKREC+15        ZONES FOR CHECK\n         CLC   NUMCK,ZEROS             IS NBR FIELDS NUMERIC\n         BNE   DSERR2                  NO, ERROR\n         L     R12,DTBCURR             GET CURRENT DSECT TBL ADDR\n         C     R12,DTBEND              AT END OF TABLE\n         BNL   DSERR5                  YES, ERROR                  -EU-\n         USING DTDS,R12                                            -EU-\n         MVC   DTNAME(8),WORKREC       NAME TO DSECT TABLE         -EU-\n         PACK  DBLWD,WORKREC+15(4)     PACK NBR ENTRIES\n         CVB   R10,DBLWD               CONVERT TO BINARY\n         LA    R10,4(R10)              ADD FOR SAFETY\n         MH    R10,DTBLEN              TIMES ENTRY LENGTH\n         STCM  R10,B'0111',DTLGTH      FIELD TABLE LENGTH          -EU-\n         GETMAIN R,LV=(R10)            GET STORAGE FOR FIELD TABLE -EU-\n         STCM  R1,B'0111',DTADDR       SAVE FIELD TABLE ADDRESS    -EU-\n         LA    R12,L'DTL(R12)          TO NEXT DSECT TABLE ENTRY   -EU-\n         ST    R12,DTBCURR             UPDATE CURRENT DSECT TBL ADDR\n         MVI   0(R12),X'FF'            SET END INDIC\n         DROP  R12                                                 -EU-\n         LR    R12,R1                  COPY FIELD TABLE ADDR\n         BAS   R9,PRINT                PRINT DSECT RECORD\n         USING DSECTD,R12\n         CVB   R11,DBLWD               NBR ENTRIES IN LOOP REG\nRDFLD    L     R1,INDCB                GET SYSIN DCB ADDR\n         GET   (1)                     READ NEXT CARD\n         MVC   WORKREC,0(R1)           MOVE RECORD TO WORK AREA\n         MVC   PRT(80),WORKREC         MOVE RECORD TO PRINT AREA\n         CLI   WORKREC,C' '            NAME FIELD BLANK\n         BE    DSERR1                  YES, ERROR\n         MVC   DSNAME,WORKREC          NAME TO ENTRY\n         MVI   DSLBTYP,C'L'            SET LABEL TYPE\n         MVZ   NUMCK,WORKREC+9         ZONES FOR TEST\n         CLC   NUMCK,ZEROS             IS OFFSET NUMERIC\n         BNE   DSERR3                  NO, ERROR\n         PACK  DBLWD,WORKREC+9(4)      PACK OFFSET\n         CP    DBLWD,P4096             OFFSET > 4096\n         BH    DSERR3                  YES, ERROR\n         CVB   R1,DBLWD                CONVERT\n         STCM  R1,B'0111',DSOFSET      OFFSET TO TABLE ENTRY\n         MVZ   NUMCK(3),WORKREC+14     ZONES FOR TEST\n         CLC   NUMCK(3),ZEROS          IS LENGTH NUMERIC\n         BNE   DSERR4                  NO, ERROR\n         PACK  DBLWD,WORKREC+14(3)     PACK LENGTH\n         CP    DBLWD,P256              LENGTH OVER 256\n         BH    DSERR4                  YES, ERROR\n         CVB   R1,DBLWD                CONVERT\n         LTR   R1,R1                   LENGTH IS ZERO\n         BZ    DSERR4                  YES, ERROR\n         STC   R1,DSLENG               LENGTH TO TABLE ENTRY\n         LA    R12,L'DSECT(R12)        TO NEXT ENTRY\n         MVI   0(R12),X'FF'            SET TBL END INDIC\n         BAS   R9,PRINT                GO PRINT CARD\n         BCT   R11,RDFLD               LOOP THRU DSECT\n         MVC   DSOFSET,HIVAL           TABLE STOPPER\n         L     R9,DSCT9                GET RETURN ADDR\n         BR    R9                      EXIT\nDSERR1   MVC   PRT+85(20),=C'INVALID NAME COL 1-8'\n         B     DSERRS                  CONTINUE\nDSERR2   MVC   PRT+85(28),=C'INVALID NBR FIELDS COL 16-19'\n         B     DSERRS                  CONTINUE\nDSERR3   MVC   PRT+85(24),=C'INVALID OFFSET COL 10-13'\n         B     DSERRS                  CONTINUE\nDSERR4   MVC   PRT+85(24),=C'INVALID LENGTH COL 15-18'\n         B     DSERRS                  CONTINUE\nDSERR5   MVC   PRT+85(20),=C'OVER 256 DSECT CARDS'                 -EU-\nDSERRS   MVI   USERR,X'FF'             SHOW ERROR FOUND\n         L     R9,DSCT9                GET RETURN ADDR\n         BR    R9                      EXIT\n         DROP  R12\n         EJECT\n******************************************************************\n*                                                                *\n* EDIT DATA ONLY CARDS FOR VALIDITY. PLACE ERROR DESCRIPTION IN  *\n* PRINT LINE IF ERRORS FOUND. CREATE DATA ONLY TABLE ENTRY IF NO *\n* ERRORS ARE FOUND.                                              *\n*                                                                *\n******************************************************************\n         SPACE 1\nDATAS    LM    R10,R11,=A(TRHEX,TRTHEX)                            -EU-\n         TR    WORKREC+5(6),0(R10)     TRANSLATE TO MAKE HEX       -EU-\n         TRT   WORKREC+5(6),0(R11)     CHECK VALID                 -EU-\n         BNZ   DERR1                   INVALID HEX\n         TR    WORKREC+12(6),0(R10)    TRANSLATE TO MAKE HEX       -EU-\n         TRT   WORKREC+12(6),0(R11)    CHECK VALID                 -EU-\n         BNZ   DERR2                   INVALID HEX\n         PACK  DBLWD(4),WORKREC+5(7)   PACK TO MAKE HEX\n         PACK  DBLWD+4(4),WORKREC+12(7) PACK TO MAKE HEX\n         CLC   DBLWD(3),DBLWD+4        CHECK 1ST LOW\n         BNL   DERR3                   1ST NOT LOW, ERROR\n         L     R1,DATOCUR              GET TBL ADDRESS\n         CL    R1,DATOEND              END OF DATA ONLY TABLE      -EU-\n         BNL   DERR4                   YES, ERROR                  -EU-\n         MVC   0(3,R1),DBLWD           MOVE 1ST OFFSET TO TBL\n         MVC   3(3,R1),DBLWD+4         MOVE 2ND OFFSET TO TBL\n         LA    R1,6(R1)                TO NEXT ENTRY\n         ST    R1,DATOCUR              SAVE CURRENT ENTRY ADDRESS\n         BR    R9                      EXIT\nDERR1    MVC   PRT+85(22),=C'1ST OFFSET INVALID HEX'\n         B     DERRS                   CONTINUE\nDERR2    MVC   PRT+85(22),=C'2ND OFFSET INVALID HEX'\n         B     DERRS                   CONTINUE\nDERR3    MVC   PRT+85(23),=C'END OFFSET BEFORE BEGIN'\n         B     DERRS                   CONTINUE                    -EU-\nDERR4    MVC   PRT+85(19),=C'OVER 256 DATA CARDS'                  -EU-\nDERRS    MVI   USERR,X'FF'             FLAG ERROR\n         BR    R9                      EXIT\n         EJECT\n******************************************************************\n*                                                                *\n* CHECK FOR ANY USING CARDS ENTERED. IF NOT, NO PRE-ASSEMBLY IS  *\n* NECESSARY. IF ANY USING CARDS FOUND, CREATE LABEL TABLE ENTRIES*\n* SO THAT USING STATEMENTS WILL BE VALID.                        *\n*                                                                *\n******************************************************************\n         SPACE 1\nEOFCARD  CLI   USERR,0                 ANY ERRORS FOUND\n         BNE   EOJ                     YES, EXIT\n         L     R1,DATOCUR              GET CURRENT DATA ONLY @\n         MVC   NOINAD,DATONLY          SAVE DATA ONLY TBL ADDR\n         MVC   0(3,R1),HIVAL           SET END\n         L     R11,USGSTRT             GET USING TBL ADDR\nCUSNGND  CLI   0(R11),X'FF'            END OF TABLE\n         BE    CUSCKPRE                GO CHECK FOR PRE-DISASM\n         L     R10,CURRLBL             GET LABEL ADDRESS\n         USING USINGD,R11\n         CLI   USTYPE,C'D'             IS IT A DSECT               -EU-\n         BE    CUSNEXT                 YES, BYPASS                 -EU-\n         USING LABELD,R10\n         MVC   LBLADR,USVALU           OFFSET TO LABEL\n         MVI   LBLTYP,C'L'             LABEL TYPE ENTRY\n         MVI   LBLLEN,1                SET LENGTH TO 1\n         MVI   LBLNAME,C'A'            1ST CHAR OF NAME\n         LA    R12,USVALU              @ OFFSET\n         BAS   R9,HEXPRT3              CONVERT\n         MVC   LBLNAME+1(6),PRTABL     MIDDLE OF NAME\n         MVI   LBLNAME+7,C' '          BLANK LAST POS\n         LA    R10,L'LABEL(R10)        STEP TO NEXT LABEL\n         ST    R10,CURRLBL             SAVE IN CURRLBL     FIX******\n         MVC   0(3,R10),HIVAL          SET END VALUE       FIX******\nCUSNEXT  LA    R11,L'USING(R11)        STEP TO NEXT USING          -EU-\n         B     CUSNGND                 LOOP\n         DROP  R10\n         DROP  R11\nCUSCKPRE L     R1,USGSTRT              GET USING TBL START ADDR\n         CLI   0(R1),X'FF'             ANY ENTRIES\n         BE    EOJ                     NO, GET OUT                 -EU-\n         BAS   R9,COMPLBL              SORT/COMPRESS LABEL TBL     -EU-\n         EJECT\n******************************************************************\n*                                                                *\n* MAINLINE ROUTINE FOR THE PRE-DISASSEMBLY. PURPOSE OF THIS PART *\n* OF THE PROGRAM IS TO ATTEMPT TO CREATE A LABEL ENTRY FOR INSTR-*\n* UCTIONS HAVING STORAGE OPERANDS. THE RESULTING LABEL TABLE WILL*\n* BE SORTED, AND DUPLICATE ENTRIES ELIMINATED BEFORE EXIT FROM   *\n* THIS PHASE OF DISASSEMBLY.                                     *\n*                                                                *\n******************************************************************\n         SPACE 1\n         L     R6,LBLTBL               @ LABEL TABLE\n         USING LABELD,R6\n         MVC   TXTCURR,TXTSTRT         COPY TEXT START ADDR\nGETCURR  L     R7,TXTCURR              @ CURRENT TXT BYTE\n         C     R7,TXTEND               END OF TEXT\n         BNL   EOJ                     YES             FIX********\n         LR    R12,R7                  COPY TEXT ADDR\n         S     R12,TXTSTRT             COMPUTE OFFSET\n         ST    R12,TXTOFST             SAVE OFFSET TO THIS BYTE\n         CLC   NEXCHG,TXTOFSET         TIME TO CHANGE USING TBLS\n         BH    CKDARNG                 NO\n         BAS   R9,NEXUSG               YES, GO DO IT\nCKDARNG  L     R12,NOINAD              GET DATA ONLY ENTRY ADDRESS\n         CLC   TXTOFSET,0(R12)         NOT YET TO THIS RANGE\n         BL    CKLOSEQ                 TRUE\n         CLC   TXTOFSET,3(R12)         NOW IN THE RANGE\n         BNH   CONST                   TRUE, TREAT AS CONSTANT\n         LA    R12,6(R12)              PAST THIS ONE, STEP TO NEXT\n         ST    R12,NOINAD              SAVE NEW ADDRESS\n         B     CKDARNG                 AND CHECK AGAIN\nCKLOSEQ  CLC   TXTOFSET,LBLADR         LABEL ENTRY OUT OF SEQ\n         BNH   GCKODD                  NO, CONTINUE\n         BAS   R9,FORCONST             YES, FORCE ANY CONSTANT OUT\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL\n         B     CKLOSEQ                 CONTINUE SEQ CHK\nGCKODD   TM    TXTCURR+3,1             ODD ADDRESS\n         BO    CONST                   YES, NOT INSTR\n         CLC   1(3,R7),0(R7)           4 CONSEC IDENTICAL BYTES\n         BE    CONST                   YES, NOT INSTR\n         L     R8,=A(CHARTRAN)                                     -EU-\n         TRT   0(1,R7),0(R8)           TEST TEXT BYTE              -EU-\n         BNZ   CKINSTR                 NOT CHARACTER\n         CLI   CONPROG,1               IS CONSTANT IN PROGRESS\n         BNE   CK6                     NO\n         CLI   CONTYPE,C'C'            IS IT CHARACTER TYPE\n         BE    CONST                   YES, ADD THIS TO CONSTANT\nCK6      TRT   0(6,R7),0(R8)           6 CONSECUTIVE CHARACTERS    -EU-\n         BZ    CONST                   YES, NOT INSTRUCTION\nCKINSTR  XR    R8,R8                   CLEAR WORK\n         IC    R8,0(R7)                PICK UP TXT BYTE\n         MH    R8,SGLOPL               TIMES TABLE LENGTH          -EU-\n         AL    R8,SGLOPAD              @ INSTR TBL ENTRY           -EU-\n         MVC   INSTENT,0(R8)           SAVE INSTRUCTION TBL ENTRY\n         CLI   INAME,0                 IS IT AN INSTR OP-CODE\n         BE    CONST                   NO\n         CLI   ITYPE,TWO               TWO-BYTE OP-CODE\n         BNE   INSTR                   NO\n         L     R8,DBLOPAD              YES, GET 2-BYTE TBL ADDR\nDBLND    CLI   0(R8),X'FF'             END OF TABLE\n         BE    CONST                   YES, NOT INSTR\n         CLC   0(2,R8),0(R7)           THIS ENTRY MATCHES TXT\n         BE    GOTDBLI                 YES\n         AH    R8,DBLOPL               TO NEXT ENTRY               -EU-\n         B     DBLND                   LOOP THRU TBL\nGOTDBLI  LA    R8,2(R8)                PASS OP-CODE BYTES\n         EJECT\n******************************************************************\n*                                                                *\n* CHECK TO SEE IF THIS BYTE OF THE PROGRAM IS AN INSTRUCTION OP  *\n* CODE. IF SO, PERFORM THE APPROPRIATE PROCESSING ROUTINE.       *\n*                                                                *\n******************************************************************\n         SPACE 1\nINSTR    MVC   ILENG+1(1),INLNG        SET INSTR LENGTH\n         LH    R12,ILENG               PICK UP LENGTH\n         AR    R12,R7                  ADDR OF NEXT OP CODE\n         XR    R15,R15                 CLEAR WORK\n         IC    R15,0(R12)              PICK UP NEXT OP-CODE\n         MH    R15,SGLOPL              TIMES TBL ENTRY LENG        -EU-\n         AL    R15,SGLOPAD             INSTR TBL ENTRY ADDR        -EU-\n         CLI   INAME-INSTENT(R15),0    IS IT AN OP-CODE\n         BNE   ICKSEC                  YES\nPOSSB    CLI   0(R7),X'45'             IS IT BAL                   -EU-\n         BE    ICKTBL                  YES, CONTINUE\n         CLI   0(R7),X'07'             NO, IS IT BRANCH\n         BE    POSSB1                  YES\n         CLI   0(R7),X'47'             IS IT BRANCH\n         BNE   CONST                   NO, THEN THIS NOT INSTR\nPOSSB1   TM    1(R7),X'F0'             IS IT UNCOND BRANCH\n         BNO   CONST                   NO, THEN THIS NOT INSTR\n         B     ICKTBL                  ACCEPT UNCOND BRANCHES\nICKSEC   XR    R1,R1                   CLEAR WORK\n         IC    R1,INLNG-INSTENT(R15)   GET INSTR LENGTH\n         AR    R1,R12                  ADDR OF NEXT OP CODE\n         XR    R14,R14                 CLEAR WORK\n         IC    R14,0(R1)               PICK UP NEXT OP-CODE\n         MH    R14,SGLOPL              TIMES TBL ENTRY LENG        -EU-\n         AL    R14,SGLOPAD             INSTR TBL ENTRY ADDR        -EU-\n         CLI   INAME-INSTENT(R14),0    IS IT AN OP-CODE\n         BNE   ICKTBL                  YES\n         CLI   0(R12),X'45'            IS IT BAL\n         BE    ICKTBL                  YES, CONTINUE\n         CLI   0(R12),X'07'            NO, IS IT BRANCH\n         BE    POSSB2                  YES\n         CLI   0(R12),X'47'            IS IT BRANCH\n         BNE   POSSB                   NO, BUT SEE CURRENT INSTR   -EU-\nPOSSB2   TM    1(R12),X'F0'            IS IT UNCOND BRANCH\n         BNO   CONST                   NO, THEN THIS NOT INSTR\nICKTBL   LH    R12,ILENG               GET INSTR LENGTH\n         AR    R12,R7                  @ NEXT TEXT LOC\n         BCTR  R12,0                   BACK UP 1\n         S     R12,TXTSTRT             RELATIVIZE IN CSECT\n         CLM   R12,B'0111',LBLADR      LBL TBL ADDR HERE\n         BL    NOILBL                  NO\n         CLC   TXTOFSET,LBLADR         LABEL AT INSTR START\n         BNE   CONST                   NO, MUST BE CONSTANT\n         CLI   LBLTYP,C'L'             IS IT A LABEL ONLY\n         BNE   CONST                   NO\n         CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   SETLBL                  NO\n         BAS   R9,FORCONST             YES, FORCE IT OUT\nSETLBL   LA    R6,L'LABEL(R6)          TO NEXT LABEL TBL ENTRY\n         B     ICKTBL                  GO CHECK NEXT LABEL\nNOILBL   CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   MVMNE                   NO\n         BAS   R9,FORCONST             YES, FORCE IT OUT\nMVMNE    MVC   MNEMONIC,0(R8)          SET INSTR MNEMONIC\n         MVC   OFFSET,TXTOFSET         SET OFFSET\n         MVC   INSTYP,5(R8)            SET INSTR TYPE\n         MVI   TYPE,X'0D'              SHOW IT IS AN INSTRUCTION\n         MVC   LEN,ILENG+1             SHOW LENGTH\n         MVC   TEXT(6),0(R7)           MOVE ACTUAL TEXT\n         TM    ICLASS,FLTPT            FLOATING POINT OP-CODE\n         BO    FPVERFY                 YES, GO VERIFY\n         CLI   IEDT,0                  ANY EDIT REQUIRED\n         BNE   IVERFY                  YES, GO EDIT\nPFMFMT   XR    R1,R1                   CLEAR WORK\n         IC    R1,INSTYP               GET INSTRUCTION TYPE\n         L     R9,OPND9                GET FORMAT ROUTINE RETURN ADDR\n         B     *+L'*(R1) ------------- TO APPROPRIATE FORMAT ROUTINE\n         B     INSTOUT                 TYPE=0, RR\n         B     RXOPND                  TYPE=4, RX\n         B     SOPND                   TYPE=8, S\n         B     SIOPND                  TYPE=12, SI\n         B     RSOPND                  TYPE=16, RS\n         B     SS1OPND                 TYPE=20, 1-LENGTH SS\n         B     SS2OPND                 TYPE=24, 2-LENGTH SS\n         B     SOPND                   TYPE=28, 2-BYTE OP-CODES\n         B     BCOPND                  TYPE=32, CONDITIONAL BRANCH -EU-\n         B     SVCOPND                 TYPE=36, SVC\n         B     SS1OPND                 TYPE=40, 2 REGISTERS SS     -EU-\n         B     RREOPND                 TYPE=44, 2 REGISTERS RRE    -EU-\n         B     SS1OPND                 TYPE=48, SSE                -EU-\n         SPACE 1                                                   -EU-\nOPNDRTN  B     INSTOUT                 NORMAL OPERAND FORMAT RETURN\n         B     CONST                   ERROR INSTRUCTION, TREAT AS CONS\nINSTOUT  AH    R7,ILENG                STEP TO NEXT TEXT BYTE\n         ST    R7,TXTCURR              SAVE NEXT ADDR\n         B     GETCURR                 CONTINUE TXT PROCESSING\nBCOPND   CLI   TEXT,X'07'              RR BRANCH                   -EU-\n         BE    INSTOUT                 YES                         -EU-\n         B     RXOPND                  NO, GO AS RX                -EU-\n         EJECT\n******************************************************************\n*                                                                *\n* GENERAL OP-CODE TESTS TO VERIFY THAT NON-FLOATING-POINT OP     *\n* CODES ARE INDEED OP-CODES.                                     *\n*                                                                *\n******************************************************************\n         SPACE 1\nIVERFY   TM    IEDT,EPR                EVEN-ODD REG PAIR\n         BZ    IVE2                    NO\n         TM    1(R7),X'10'             R1 IS ODD\n         BO    CONST                   YES, NOT INSTR\n         CLI   0(R7),X'0E'             IS IT MVCL\n         BE    IVTRG2                  YES\n         CLI   0(R7),X'0F'             IS IT CLCL\n         BNE   IVE2                    NO\nIVTRG2   TM    1(R7),X'01'             R2 IS ODD\n         BO    CONST                   YES, NOT INSTR\n         XR    R1,R1                   CLEAR WORK\n         XR    R2,R2                   CLEAR WORK\n         IC    R1,1(R7)                GET R1R2\n         SRL   R1,4                    SHIFT OUT R2\n         PACK  DBLWD(1),1(1,R7)        FLIP R1R2 BYTE\n         IC    R2,DBLWD                PICK UP R2R1\n         SRL   R2,4                    SHIFT OUT R1\n         CR    R1,R2                   R1=R2\n         BE    CONST                   YES, NOT INSTR\n         B     PFMFMT                  NO, GOOD INSTR\nIVE2     TM    IEDT,E2                 HALFWORD STORAGE ALIGNMENT\n         BZ    IVE4                    NO\n         TM    3(R7),X'01'             DISPL IS ODD\n         BZ    IVES2                   NO, O.K.\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   IVES2                   NO, CONTINUE\n         CLI   0(R7),X'44'             EX OP CODE\n         BE    CONST                   YES, NOT INSTR\n         CLI   0(R7),X'47'             BC OP CODE\n         BE    CONST                   YES, NOT INSTR\n         CLI   ITYPE,RS                RS INSTRUCTION\n         BE    CONST                   YES, NOT INSTR\n         TM    1(R7),X'0F'             INDEX REG IS 0\n         BZ    CONST                   YES, NOT INSTR\n         B     IVES2                   CONTINUE\nIVE4     TM    IEDT,E4                 2ND OPND ON FULLWORD BOUND\n         BZ    IVE8                    NO\n         TM    3(R7),X'03'             DISPL DIV BY 4\n         BZ    IVES2                   YES, O.K.\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   IVES2                   NO, CONTINUE\n         CLI   ITYPE,RS                RS INSTRUCTION OP CODE\n         BE    CONST                   YES, NOT INSTR\n         TM    1(R7),X'0F'             INDEX REG = 0\n         BZ    CONST                   YES, NOT INSTR\n         B     IVES2                   NO, CONTINUE\nIVE8     TM    IEDT,E8                 2ND OPND ON DBLWD BOUND\n         BZ    IVES2                   NO\n         TM    3(R7),X'07'             DISPL DIV BY 8\n         BZ    IVES2                   YES, O.K.\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   IVES2                   NO\n         CLI   ITYPE,S                 S INSTRUCTION OP CODE       -EU-\n         BE    CONST                   YES, NOT INSTRUCTION        -EU-\n         CLI   ITYPE,SSE               SSE INSTRUCTION OP CODE     -EU-\n         BE    CONST                   YES, NOT INSTRUCTION        -EU-\n         TM    1(R7),X'0F'             INDEX REG = 0\n         BZ    CONST                   YES, NOT INSTR\nIVES2    CLI   PRIVASM,1               PRIVILEGED INSTR O.K.\n         BE    PFMFMT                  YES\n         TM    IEDT,S2                 OPND2 MUST HAVE BASE\n         BZ    IVES1                   NO\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   PFMFMT                  NO, O.K.\n         CLI   ITYPE,RS                RS INSTRUCTION\n         BE    CONST                   YES, NOT INSTR\n         CLI   ITYPE,S                 S INSTRUCTION               -EU-\n         BE    CONST                   YES, NOT INSTR              -EU-\n         CLI   0(R7),X'92'             IS IT MVI OP CODE\n         BE    CONST                   YES, NOT INSTR\n         TM    1(R7),X'0F'             INDEX REG = 0\n         BZ    CONST                   YES, NOT INSTR\n         B     PFMFMT                  NO, GOOD INSTR\nIVES1    TM    IEDT,S1                 1ST OPND MUST HAVE BASE\n         BZ    PFMFMT                  NO, CONTINUE\n         TM    2(R7),X'F0'             1ST OPND HAS BASE\n         BZ    CONST                   NO, NOT INSTR\n         B     PFMFMT                  YES, INSTR O.K.\n         EJECT\n******************************************************************\n*                                                                *\n* GENERAL OP-CODE TESTS TO VERIFY THAT FLOATING-POINT OP-CODES   *\n* ARE INDEED OP-CODES.                                           *\n*                                                                *\n******************************************************************\n         SPACE 1\nFPVERFY  TM    ICLASS,FLEXR            EXTENDED FLT PT INSTR       -EU-\n         BZ    FPVERFP                 NO                          -EU-\n         TM    3(R7),X'BB'             0 OR 4 ONLY                 -EU-\n         BZ    PFMFMT                  YES, GOOD INSTR             -EU-\n         B     CONST                   NO, NOT INSTR               -EU-\nFPVERFP  TM    1(R7),X'90'             R1 IS 0, 2, 4, OR 6         -EU-\n         BNZ   CONST                   NO, NOT INSTR\n         CLI   0(R7),X'27'             MXDR OP-CODE\n         BE    FPR1EXT                 YES\n         CLI   0(R7),X'67'             MXD OP-CODE\n         BNE   FPCKTYP                 NO\nFPR1EXT  TM    1(R7),X'B0'             R1 IS 0 OR 4\n         BNZ   CONST                   NO, NOT INSTR\nFPCKTYP  CLI   ITYPE,RR                RR TYPE INSTRUCTION\n         BNE   FPRXVER                 NO\n         TM    1(R7),X'09'             R2 IS 0, 2, 4, 6\n         BNZ   CONST                   NO, NOT INSTR\n         CLI   0(R7),X'25'             LRDR OP CODE\n         BE    FPR2EXT                 YES\n         CLI   0(R7),X'37'             SXR OP-CODE\n         BE    FPR2EXT                 YES\n         CLI   0(R7),X'26'             MXR OP-CODE\n         BE    FPR2EXT                 YES\n         CLI   0(R7),X'36'             AXR OP-CODE\n         BNE   PFMFMT                  NO, GOOD INSTR\nFPR2EXT  TM    1(R7),X'0B'             R2 IS 0 OR 4\n         BZ    PFMFMT                  YES, GOOD INSTR\n         B     CONST                   NO, NOT INSTR\nFPRXVER  CLI   PRIVASM,1               PRIVILEGED INSTRUCTIONS O.K.\n         BE    FPALIGN                 YES\n         TM    2(R7),X'F0'             ANT BASE REG\n         BNZ   FPALIGN                 YES\n         TM    1(R7),X'0F'             ANY INDEX REG\n         BZ    CONST                   NO, NOT INSTR\nFPALIGN  TM    2(R7),X'F0'             ANY BASE REG\n         BNZ   PFMFMT                  YES, ACCEPT INSTR\n         TM    1(R7),X'0F'             ANY INDEX REG\n         BNZ   PFMFMT                  YES, ACCEPT INSTR\n         TM    3(R7),X'03'             DISPL DIV BY 4\n         BNZ   CONST                   NO, NOT INSTR\n         TM    ICLASS,FLSHT            SHORT PRECISION\n         BO    PFMFMT                  YES, ACCEPT INSTRUCTION\n         TM    3(R7),X'07'             DISPL DIV BY 8\n         BZ    PFMFMT                  YES, ACCEPT INSTR\n         B     CONST                   NO, NOT INSTR\n         EJECT\n******************************************************************\n*                                                                *\n* PROCESS TEXT BYTES DETERMINED TO BE CONSTANT DATA.             *\n*                                                                *\n******************************************************************\n         SPACE 1\nCONST    MVC   WORKREC,BLANX           CLEAR WORK RECORD AREA\n         CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   CCNEW                   NO\n         CLC   TXTOFSET,LBLADR         LABEL ENTRY HAS THIS OFFSET\n         BNE   CGETYP                  NO\nCSTNEW   BAS   R9,FORCONST             FORCE IT OUT\n         B     CCNEW                   GO START A NEW ONE\nCGETYP   L     R11,=A(CHARTRAN)                                    -EU-\n         TRT   0(1,R7),0(R11)          CHECK DATA TYPE OF BYTE     -EU-\n         BNZ   CHEX                    IT'S HEX\n         MVI   CCKTYP+1,C'C'           SET TYPE IN COMPARE\n         B     CCKTYP                  GO COMPARE\nCHEX     MVI   CCKTYP+1,C'X'           SET TYPE IN COMPARE\nCCKTYP   CLI   CONTYPE,C' '            TYPE IN PROG SAME AS THIS BYTE\n         BNE   CSTNEW                  NO\nCUPDCON  LH    R11,CONLEN              GET CURRENT LENGTH\n         LA    R11,1(R11)              ADD 1\n         STH   R11,CONLEN              UPDATE LENGTH\n         CLI   CONTYPE,C'C'            CHARACTER CONSTANT\n         BE    CCK8                    YES\n         TM    CONOFST+3,1             OFFSET IS ODD\n         BO    CCFIN1                  YES\n         TM    CONOFST+3,2             HALFWORD OFFSET\n         BZ    CCFWD                   NO\n         CLI   CONLEN+1,1              HALFWORD, IS LENGTH = 1\n         BE    CCXIT1                  YES\n         B     CCFIN1                  NO\nCCFWD    CLI   CONLEN+1,4              NO, IS HEX CONST 4 BYTES\n         BL    CCXIT1                  NOT YET\nCCFIN1   BAS   R9,FORCONST             MAX LENG, FORCE IT OUT\n         B     CCXIT1                  FINISH\nCCK8     CLC   CONLEN,H8               CHAR CONSTANT 8 BYTES\n         BNL   CCFIN1                  YES\nCCXIT1   LA    R7,1(R7)                STEP OVER 1 BYTE IN TEXT\n         ST    R7,TXTCURR              UPDATE TEXT ADDR\n         B     GETCURR                 CONTINUE TEXT PROCESSING\nCCNEW    MVI   CONPROG,1               SHOW CONSTANT IN PROGRESS\n         MVC   CONOFST,TXTOFST         SET OFFSET TO 1ST BYTE\n         MVC   CONLEN,XZROS            CLEAR LENGTH\n         CLC   TXTOFSET,LBLADR         LABEL AT THIS OFFSET\n         BE    CLBLD                   YES\nTRTYPE   L     R11,=A(CHARTRAN)                                    -EU-\n         TRT   0(1,R7),0(R11)          CHECK DATA TYPE OF BYTE     -EU-\n         BNZ   CCSHX                   IT'S HEX\n         MVI   CONTYPE,C'C'            IT'S CHAR, SO INDICATE\n         B     CUPDCON                 GO COMPLETE\nCCSHX    MVI   CONTYPE,C'X'            IT'S HEX, SO INDICATE\n         B     CUPDCON                 GO COMPLETE\nCLBLD    CLI   LBLTYP,C'L'             IS IT A LABEL ONLY\n         BNE   CDATACON                NO\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         CLC   TXTOFSET,LBLADR         THIS LABEL AT SAME ADDR\n         BNE   TRTYPE                  NO\n         CLI   LBLTYP,C'L'             THIS ANOTHER LABEL ONLY\n         BNE   CDATACON                NO\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         B     CCNEW                   GO TO NEXT LABEL\nCDATACON MVC   CONTYPE,LBLTYP          TYPE TO CONSTANT AREA\n         XR    R1,R1                   CLEAR WORK\n         IC    R1,LBLLEN               PICK UP CONSTNT LENGTH\n         STH   R1,CONLEN               SAVE CONSTANT LENGTH\n         XR    R11,R11                 CLEAR WORK REG\n         IC    R11,LBLLEN              PICK UP LENGTH\n         AR    R7,R11                  STEP PAST TEXT\n         ST    R7,TXTCURR              UPDATE TEXT ADDRESS\n         BAS   R9,FORCONST             FORCE CONSTANT OUT\n         LA    R6,L'LABEL(R6)          STEP TO NEXT LABEL ENTRY\n         B     GETCURR                 CONTINUE TEXT PROCESS\n         DROP  R6\n         SPACE 2\n******************************************************************\n*                                                                *\n* CLEAR OUT AREAS SET UP FOR CONSTANT DATA.                      *\n*                                                                *\n******************************************************************\n         SPACE 1\nFORCONST MVI   CONPROG,0               RESET CONSTANT IN PROGRESS\n         MVI   CONTYPE,0               RESET TYPE\n         XC    CONLEN,CONLEN           CLEAR LENGTH\n         MVC   CONOFST,XZROS           CLEAR OFFSET TO CONSTANT\n         BR    R9                      EXIT\n         EJECT\n******************************************************************\n*                                                                *\n* PROCESS RX-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *\n* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *\n*                                                                *\n******************************************************************\n         SPACE 1\nRXOPND   XR    R11,R11                 CLEAR WORK REG\n         ICM   R11,B'0011',TEXT+2      GET BDDD\n         TM    TEXT+2,X'F0'            IS B SPECIFIED              -EU-\n         BNZ   RXDCD                   YES                         -EU-\n         XR    R10,R10                 CLEAR WORK REG              -EU-\n         ICM   R10,B'1000',TEXT+1      GET RX OR MX                -EU-\n         SLL   R10,4                   RETAIN X ONLY               -EU-\n         SRL   R10,16                  POSITION X AS B             -EU-\n         OR    R11,R10                 BUILD NEW BDDD              -EU-\nRXDCD    LA    R10,4                   SET LENGTH = 4\n         TM    INLNG,E4                FULLWORD OPERAND\n         BO    RXBDDD                  YES\n         LA    R10,2                   SET LENGTH = 2\n         TM    INLNG,E2                HALFWORD OPERAND\n         BO    RXBDDD                  YES\n         LA    R10,1                   SET LENGTH = 1\n         TM    INLNG,E8                DOUBLEWORD OPERAND\n         BZ    RXBDDD                  NO\n         LA    R10,8                   YES, SET LENGTH = 8\nRXBDDD   B     BDLADR                  CHECK LABEL\n         EJECT\n******************************************************************\n*                                                                *\n* PROCESS S-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS   *\n* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *\n*                                                                *\n******************************************************************\n         SPACE 1\nSOPND    CLI   1(R7),0                 BYTE 2 OF INSTR IS ZERO\n         BE    SCHECK                  YES\n         CLI   0(R7),X'80'             NO, IS IT SSM\n         BE    4(R9)                   YES, NOT INSTR\n         CLI   0(R7),X'82'             NO, IS IT LPSW\n         BE    4(R9)                   YES, NOT INSTR\n         CLI   0(R7),X'93'             NO, IS IT TS\n         BE    4(R9)                   YES, NOT INSTR\nSCHECK   CLI   0(R7),X'B2'             OP-CODE IS B2\n         BNE   SSTRT                   NO\n         TM    ICLASS,IOP              IGNORE OPERAND INSTR        -EU-\n         BZ    SST3A                   NO                          -EU-\n         CLC   2(2,R7),XZROS           3RD AND 4TH BYTES ZERO      -EU-\n         BNE   4(R9)                   NO, NOT INSTR               -EU-\n         BR    R9                      YES, NO MORE TO DO          -EU-\nSST3A    CLI   1(R7),X'3A'             'STCPS' INST                -EU-\n         BNE   SSTRT                   NO                          -EU-\n         TM    3(R7),X'1F'             32-BYTE BOUNDARY            -EU-\n         BZ    SSTRT                   YES                         -EU-\n         TM    2(R7),X'F0'             BASE REG = 0                -EU-\n         BZ    4(R9)                   YES, NOT INSTR              -EU-\nSSTRT    XR    R11,R11                 CLEAR WORK\n         ICM   R11,B'0011',TEXT+2      GET BDDD\n         LA    R10,4                   SET LENGTH = 4\n         TM    INLNG,E4                FULLWORD OPERAND\n         BO    SBDDD                   YES\n         LA    R10,2                   SET LENGTH = 2\n         TM    INLNG,E2                HALFWORD OPERAND\n         BO    SBDDD                   YES\n         LA    R10,1                   SET LENGTH = 1\n         TM    INLNG,E8                DOUBLEWORD OPERAND\n         BZ    SBDDD                   NO\n         LA    R10,8                   YES, SET LENGTH = 8\nSBDDD    B     BDLADR                  CHECK FOR LABEL\n         EJECT\n******************************************************************\n*                                                                *\n* PROCESS SI-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *\n* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *\n*                                                                *\n******************************************************************\n         SPACE 1\nSIOPND   XR    R11,R11                 CLEAR WORK\n         ICM   R11,B'0011',TEXT+2      GET BDDD ADDRESS\n         LA    R10,0                   LENGTH=DON'T CARE\n         B     BDLADR                  CHECK FOR LABEL\n         SPACE 2\n******************************************************************\n*                                                                *\n* PROCESS RS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *\n* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *\n*                                                                *\n******************************************************************\n         SPACE 1\nRSOPND   CLI   0(R7),X'88'             IS IT SHIFT INSTR\n         BL    RSCMA1                  NO\n         CLI   0(R7),X'8F'             IS IT SHIFT INSTR\n         BH    RSCMA1                  NO\n         TM    1(R7),X'0F'             SHIFT, IS R3 POS = 0\n         BZ    0(R9)                   YES, GOOD SHIFT\n         B     4(R9)                   NO, NOT INSTR\nRSCMA1   XR    R11,R11                 CLEAR WORK\n         ICM   R11,B'0011',TEXT+2      GET BDD ADDRESS\n         LA    R10,4                   SET LENGTH = 4\n         TM    INLNG,E4                FULLWORD OPERAND\n         BO    RSBDDD                  YES\n         LA    R10,2                   SET LENGTH = 2\n         TM    INLNG,E2                HALFWORD OPERAND\n         BO    RSBDDD                  YES\n         LA    R10,1                   SET LENGTH = 1\n         TM    INLNG,E8                DOUBLEWORD OPERAND\n         BZ    RSBDDD                  NO\n         LA    R10,8                   YES, SET LENGTH = 8\nRSBDDD   B     BDLADR                  CHECK FOR LABEL\n         EJECT\n******************************************************************\n*                                                                *\n* PROCESS SS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESSES*\n* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION. THE     *\n* 1-LENGTH OR 2-REGS SS FORMAT INSTRUCTIONS ARE HANDLED HERE.    * -EU-\n*                                                                *\n******************************************************************\n         SPACE 1\nSS1OPND  XR    R10,R10                 CLEAR WORK\n         CLI   INSTYP,SSR              2 REGS SS FORMAT            -EU-\n         BE    SS1L1                   YES, USE LENGTH = 1         -EU-\n         CLI   INSTYP,SSE              SSE FORMAT                  -EU-\n         BE    SS1L1                   YES, USE LENGTH = 1         -EU-\n         IC    R10,TEXT+1              GET LENGTH CODE\nSS1L1    LA    R10,1(R10)              COMPUTE ACTUAL LENGTH\n         XR    R11,R11                 CLEAR WORK\n         ICM   R11,B'0011',TEXT+2      GET BDDD ADDRESS\n         LA    R1,SS1RTN               GET RTEURN ADDR\n         MVC   SAVOP9,OPND9            SAVE NORMAL RETURN ADDR\n         ST    R1,OPND9                CHANGE RETURN ADDR\n         B     BDLADR                  CHECK LABEL\nSS1RTN   MVC   OPND9,SAVOP9            RESTORE NORMAL RETURN ADDR\n         XR    R11,R11                 CLEAR WORK\n         ICM   R11,B'0011',TEXT+4      GET SECOND BDDD ADDRESS\n         XR    R10,R10                 CLEAR LENGTH REG\n         CLI   INSTYP,SSR              2 REGS SS FORMAT            -EU-\n         BE    SS1L2                   YES, USE LENGTH = 1         -EU-\n         CLI   INSTYP,SSE              SSE FORMAT                  -EU-\n         BE    SS1L2                   YES, USE LENGTH = 1         -EU-\n         IC    R10,TEXT+1              GET INSTR LENGTH\nSS1L2    LA    R10,1(R10)              COMPUTE ACTUAL LENGTH\n         B     BDLADR                  CHECK FOR LABEL\n         EJECT\n******************************************************************\n*                                                                *\n* PROCESS SS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESSES*\n* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION. THE     *\n* DOUBLE-LENGTH SS FORMAT INSTRUCTIONS ARE HANDLED HERE.         *\n*                                                                *\n******************************************************************\n         SPACE 1\nSS2OPND  XR    R10,R10                 CLEAR WORK\n         IC    R10,TEXT+1              GET L1L2\n         SRL   R10,4                   SHIFT OUT L2\n         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH\n         XR    R11,R11                 CLEAR WORK\n         ICM   R11,B'0011',TEXT+2      GET BDDD ADDRESS\n         LA    R1,SS2RTN               GET RETURN ADDR\n         MVC   SAVOP9,OPND9            SAVE NORMAL RETURN ADDR\n         ST    R1,OPND9                CHANGE RETURN ADDRESS\n         B     BDLADR                  CHECK LABEL\nSS2RTN   MVC   OPND9,SAVOP9            RESTORE NORMAL RETURN ADDR\n         XR    R11,R11                 CLEAR WORK\n         ICM   R11,B'0011',TEXT+4      GET 2ND BDDD ADDR\n         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE\n         XR    R10,R10                 CLEAR WORK\n         IC    R10,DBLWD               PICK UP L2L1\n         SRL   R10,4                   SHIFT OUT L1\n         CLI   TEXT,X'F0'              SRP OP-CODE\n         BNE   SS2BDDD                 NO\n         IC    R10,TEXT+1              GET INSTR LENGTH\n         SRL   R10,4                   SHIFT OUT I3\nSS2BDDD  LA    R10,1(R10)              COMPUTE ACTUAL LENGTH\n         B     BDLADR                  CHECK LABEL\n         EJECT ,                                                   -EU-\n****************************************************************** -EU-\n*                                                                * -EU-\n* PROCESS RRE-FORMAT INSTRUCTIONS.                               * -EU-\n*                                                                * -EU-\n****************************************************************** -EU-\n         SPACE 1                                                   -EU-\nRREOPND  CLI   TEXT+2,0                BYTE 2 OF INSTR IS ZERO     -EU-\n         BNE   4(R9)                   NO, NOT INSTRUCTION         -EU-\n         TM    IEDT,E1R                1 REGISTER                  -EU-\n         BZ    0(R9)                   NO                          -EU-\n         TM    TEXT+3,X'0F'            R2 IS ZERO                  -EU-\n         BNZ   4(R9)                   NO, NOT INSTRUCTION         -EU-\n         BR    R9                      YES                         -EU-\n         SPACE 2\n******************************************************************\n*                                                                *\n* PROCESS SVC INSTRUCTIONS. THE SOLE PROCESSING IS TO VERIFY THAT*\n* THIS IS A VALID SVC.                                           *\n*                                                                *\n******************************************************************\n         SPACE 1\nSVCOPND  L     R1,SVCOPAD              GET SVC TABLE ADDRESS       -EU-\nSVCKND   CLI   0(R1),X'FF'             END OF SVC TABLE\n         BE    NOTSVC                  YES, MUST NOT BE SVC\n         CLC   0(1,R1),TEXT+1          THIS THE ENTRY\n         BE    GOTSVC                  YES\n         BH    NOTSVC                  NO, MUST NOT BE SVC         -EU-\n         AH    R1,SVCOPL               STEP TO NEXT ENTRY          -EU-\n         B     SVCKND                  LOOP THRU TABLE\nNOTSVC   B     4(R9)                   ERROR RETURN\nGOTSVC   BR    R9                      EXIT, NO STORAGE OPND\n         EJECT\n******************************************************************\n*                                                                *\n* SET UP CURRENT BASE REGISTERS IN THE BASE TABLE. THE USING     *\n* TABLE IS SCANNED FOR ENTRIES VALID AT THE CURRENT TEXT OFFSET. *\n* WHEN A BASE REGISTER ENTRY IS FOUND TO BE VALID AT THE CURRENT *\n* TEXT OFFSET, THE USING ENTRY IS MOVED TO THE APPROPRIATE LOC-  *\n* ATION IN THE BASE TABLE FOR USE BY THE BDLADR ROUTINE. THE TEXT*\n* OFFSET TO THE NEXT BASE REGISTER CHANGE IS SET SO THAT THIS    *\n* ROUTINE WILL AGAIN BE ENTERED WHEN THE CURRENT BASE REGISTERS  *\n* ARE EXHAUSTED.                                                 *\n*                                                                *\n******************************************************************\n         SPACE 1\nNEXUSG   MVI   MORUSG,0                RESET INDICATOR\n         L     R1,=A(BASES)                                        -EU-\n         XC    0(L'BASES,R1),0(R1)     CLEAR OLD BASE REG VALUES   -EU-\n         MVC   NEXCHG,HIVAL            SET NEXT CHANGE LOC HIGH\n         L     R2,USGSTRT              GET USING TBL START\n         USING USINGD,R2\nENDUS    CLI   0(R2),X'FF'             END OF TABLE\n         BCR   8,R9                    YES, EXIT\n         CLC   TXTOFSET,USEND          PAST THIS ONE\n         BNL   ECSTEP                  YES\n         OI    MORUSG,X'01'            SHOW MORE BASES AVAILABLE\nUSBGCK   CLC   TXTOFSET,USBGN          THIS STARTS LATER\n         BNL   CKNEWLO                 NO\n         CLC   USBGN,NEXCHG            BEGINS BEFORE NEXT CHG\n         BNL   ECSTEP                  NO\n         MVC   NEXCHG,USBGN            YES, SET NEW CHANGE OFFSET\n         B     ECSTEP                  CONTINUE\nCKNEWLO  CLC   USEND,NEXCHG            NEW LOW CHANGE ADDR\n         BNL   ECMVC                   NO\n         MVC   NEXCHG,USEND            YES, SET LOWER OFFSET\nECMVC    XR    R1,R1                   CLEAR WORK\n         IC    R1,USREG                PICK UP REGISTER\n         MH    R1,USGLEN               TIMES ENTRY LENGTH\n         AL    R1,=A(BASES)            @ TABLE ENTRY               -EU-\n         MVC   0(L'USING,R1),USING     ENTRY TO TABLE\n         OI    MORUSG,X'80'            SHOW BASE REG CURRENT\nECSTEP   LA    R2,L'USING(R2)          TO NEXT USING TBL ENTRY\n         B     ENDUS                   LOOP THRU USING TBL\n         DROP  R2\n         EJECT\n******************************************************************\n*                                                                *\n* A BASE-DISPLACEMENT IS PROVIDED IN REG 11 ON ENTRY. IF ANY     *\n* BASE REGISTERS ARE CURRENT, AND THE BASE REGISTER FOR THE GIVEN*\n* ADDRESS IS A CURRENT PROGRAM BASE REGISTER, A LABEL ENTRY IS   *\n* BUILT. OFFSET TO THE LABEL WILL BE FOUND BY ADDING THE ASSUMED *\n* BASE REGISTER VALUE TO THE GIVEN DISPLACEMENT. THE LABEL NAME  *\n* WILL BE THE LETTER 'A' FOLLOWED BY THE OFFSET.                 *\n*                                                                *\n******************************************************************\n         SPACE 1\nBDLADR   TM    MORUSG,X'01'            ANY BASES CURRENT\n         BZ    BDLXIT                  NO\n         LR    R2,R11                  COPY BDDD ADDRESS\n         SRL   R2,12                   RIGHT JUSTIFY BASE REG\n         MH    R2,USGLEN               TIMES ENTRY LENGTH\n         AL    R2,=A(BASES)            @ BASE REG TABLE ENTRY      -EU-\n         USING USINGD,R2\n         CLI   USTYPE,C'P'             IS IT A PROGRAM BASE\n         BNE   BDLXIT                  NO\n         SLL   R11,20                  ISOLATE THE\n         SRL   R11,20                  DDD IN R11\n         XR    R1,R1                   CLEAR WORK\n         ICM   R1,B'0111',USVALU       GET BASE REG VALUE\n         AR    R11,R1                  COMPUTE PROGRAM OFFSET\n         DROP  R2\n         L     R1,CURRLBL              GET LBL TBL ADDR\n         C     R1,ENDLBL               END OF TABLE\n         BL    GOTHOLE                 NO\n         BAS   R9,COMPLBL              YES, COMPRESS DUPLICATES\n         L     R1,CURRLBL              GET NEW CURRENT LBL ADDR\n         C     R1,ENDLBL               STILL AT END\n         BNL   BDLXIT                  YES, TERMINATE THIS STAGE   -EU-\n         USING LABELD,R1\nGOTHOLE  STCM  R11,B'0111',LBLADR      SET LABEL ENTRY OFFSET\n         MVI   LBLNAME,C'A'            BEGIN LABEL NAME\n         LA    R12,LBLADR              @ OFFSET\n         BAS   R9,HEXPRT3              GO CONVERT\n         MVC   LBLNAME+1(6),PRTABL     REST OF NAME\n         MVI   LBLNAME+7,C' '          FINAL BLANK IN NAME\n         MVI   LBLTYP,C'L'             SET LABEL TYPE\n         CLI   TEXT,X'47'              THIS A CONDITIONAL BRANCH\n         BE    INSTREF                 YES\n         CLI   TEXT,X'45'              BAL INSTR\n         BE    INSTREF                 YES\n         CLI   TEXT,X'46'              BCT INSTR\n         BE    INSTREF                 YES\n         CLI   TEXT,X'44'              EX INSTR\n         BE    INSTREF                 YES\n         CLI   TEXT,X'87'              BXLE INSTRUCTION\n         BE    INSTREF                 YES\n         CLI   TEXT,X'86'              BXH INSTRUCTION\n         BNE   BDLSTP                  NO\nINSTREF  XR    R12,R12                 CLEAR WORK REG\n         A     R11,TXTSTRT             BRCH ADDR IN STORED TEXT\n         LA    R10,4                   ASSUME LENGTH IS 4\n         TM    0(R11),X'C0'            TEST HI 2-BITS OF OP-CODE\n         BM    BDLSTP                  01 OR 10 IS 4-BYTE INSTR\n         BO    BDLSIX                  YES, SIX-BYTE INSTR\n         LA    R10,2                   BOTH OFF, 2-BYTE INSTR\n         B     BDLSTP                  CONTINUE\nBDLSIX   LA    R10,6                   SET LENGTH TO 6\nBDLSTP   STC   R10,LBLLEN              LENGTH TO LABEL ENTRY\n         LA    R1,L'LABEL(R1)          TO NEXT ENTRY\n         ST    R1,CURRLBL              SAVE UPDATED TBL ADDR\nBDLXIT   L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n         DROP  R1\n         EJECT\n******************************************************************\n*                                                                *\n* SORT THE LABEL TABLE AND ELIMINATE ANY DUPLICATE ENTRIES.      *\n*                                                                *\n******************************************************************\n         SPACE 1\n         USING LABELD,R6\nCOMPLBL  L     R6,LBLTBL               GET LABEL TABLE ADDR\nLBSTPASS LA    R7,L'LABEL(R6)          @ NEXT LABEL TABLE ENTRY\nLBLND    C     R7,CURRLBL              AT TABLE END\n         BL    LBSAMPS                 NO\nNEXPAS0  LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         C     R6,CURRLBL              END OF TABLE\n         BL    LBSTPASS                NO\n         B     LBFEND                  YES, FIND END\nLBSAMPS  CLC   LBLADR,LBLADR-LABEL(R7) IDENTICAL OFFSETS\n         BH    LBSWCH                  NO, FIRST HIGH, SWITCH\n         BL    LBSTP                   NO, LOW, CONTINUE SCAN\n         CLC   LABEL,0(R7)             ENTRIES ARE IDENTICAL\n         BNE   LBCKLBL                 NO\nLBNULL2  MVC   LBLADR-LABEL(3,R7),HIVAL YES, NULL 2ND\n         B     LBSTP                   AND CONTINUE SCAN\nLBCKLBL  CLC   LBLNAME,LBLNAME-LABEL(R7) IDENTICAL LABELS\n         BNE   LBCKTYP                 NO, CHECK TYPES\nLBCKLN   CLI   LBLLEN,0                THIS ENTRY LENGTH = 0\n         BNE   LBCKLN2                 NO\n         MVI   LBLLEN,X'FF'            YES, SET HIGH LENGTH\nLBCKLN2  CLC   LBLLEN,LBLLEN-LABEL(R7) COMPARE LENGTHS\n         BH    LBSWCH                  1ST LENGTH HIGH, SWITCH ENTRIES\n         B     LBNULL2                 1ST LOW/=, NULL 2ND\nLBCKTYP  CLC   LBLTYP,LBLTYP-LABEL(R7) SAME ENTRY TYPE\n         BNE   LBCK1L                  NO, CHK TYPE ORDER\n         CLI   LBLTYP,C'L'             ARE THEY TYPE L\n         BE    LBSTP                   YES, CONTINUE SCAN\n         CLI   LBLTYP,C'U'             USER LABEL\n         BNE   LBNULL2                 NO\n         B     LBSTP                   YES\nLBCK1L   CLI   LBLTYP,C'U'             1ST IS USER LABEL\n         BNE   LBCK2L                  NO\n         CLI   LBLTYP-LABEL(R7),C'L'   2ND IS TYPE L\n         BE    LBNULL2                 YES, NULL THE 2ND\n         B     LBSTP                   CONTINUE SCAN\nLBCK2L   CLI   LBLTYP-LABEL(R7),C'U'   2ND IS USER LABEL\n         BE    LBSWCH                  YES\n         CLI   LBLTYP,C'L'             1ST IS LABEL TYPE\n         BE    LBSTP                   YES, CONTINUE SCAN\nLBSWCH   MVC   WORKREC(L'LABEL),LABEL  HOLD 1ST ENTRY\n         MVC   LABEL,0(R7)             MOVE 2ND ENTRY TO 1ST\n         MVC   0(L'LABEL,R7),WORKREC   1ST ENTRY TO 2ND LOCATION\n         B     LBSAMPS                 GO RECHECK\nLBSTP    LA    R7,L'LABEL(R7)          TO NEXT LABEL ENTRY\n         B     LBLND                   CONTINUE SCAN\nLBFEND   L     R6,LBLTBL               @ LABEL TABLE\nLBFCKFF  CLI   LABEL,X'FF'             NULL ENTRY\n         BE    LBSTCURR                YES\n         C     R6,CURRLBL              AT FORMER END\n         BE    LBSTCURR                YES\n         LA    R6,L'LABEL(R6)          TO NEXT ENTRY\n         B     LBFCKFF                 LOOP TO FIND END\nLBSTCURR ST    R6,CURRLBL              SAVE NEW TBL END ADDR\n         BR    R9                      EXIT\n         DROP  R6\n         SPACE 2\n******************************************************************\n*                                                                *\n* END OF PHASE 1. SORT/COMPRESS THE LABEL TABLE AND RETURN.      *\n*                                                                *\n******************************************************************\n         SPACE 1\nEOJ      BAS   R9,COMPLBL              SORT/COMPRESS LABEL TBL\n         L     R6,LBLTBL               GET LABEL TABLE ADDR\n         USING LABELD,R6\nEOJCKND  C     R6,CURRLBL              END OF TABLE\n         BNL   EOJ2                    YES\n         CLI   LBLTYP,C'U'             USER LABEL\n         BNE   EOJSTEP                 NO\n         MVI   LBLTYP,C'L'             YES, CHANGE TO TYPE L\nEOJSTEP  LA    R6,L'LABEL(R6)          TO NEXT ENTRY\n         B     EOJCKND                 CONTINUE LOOP\n         DROP  R6\n         SPACE 2                                                   -EU-\n         PRINT GEN                                                 -EU-\nEOJ2     MVC   PRT,BLANX               CLEAR PRINT\n         SVBCK ,                       RETURN TO CALLER            -EU-\n         PRINT NOGEN                                               -EU-\n         EJECT\n******************************************************************\n*                                                                *\n* CONVERT HEX BYTES TO THEIR PRINTABLE EQUIVALENTS. ON ENTRY, REG*\n* 12 CONTAINS THE ADDRESS OF THE FIRST BYTE TO BE CONVERTED. THE *\n* NUMBER OF BYTES IS DETERMINED BY THE ENTRY SELECTED. PRINTABLE *\n* HEX IS PLACED IN THE FIELD PRTABL, TWO CHARACTERS PER BYTE.    *\n*                                                                *\n******************************************************************\n         SPACE 1\nHEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX\nHEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE\n         TR    PRTABL(8),TRTBL         MAKE PRINTABLE\n         BR    R9                      EXIT\n         SPACE 2\n******************************************************************\n*                                                                *\n* PRINT A LINE USING THE SYSPRINT DCB DEFINED IN DISASM PHASE 0. *\n*                                                                *\n******************************************************************\n         SPACE 1\nPRINT    L     R1,PRINTDCB             @ SYSPRINT DCB\n         USING IHADCB,R1                                           -EU-\n         TM    DCBOFLGS,DCBOFOPN       IS SYSPRINT OPEN\n         BNO   CLRPRT                  NO\n         DROP  R1                                                  -EU-\n         PUT   (1),PRTLINE             WRITE PRINT LINE\nCLRPRT   MVC   PRT,BLANX               CLEAR PRINT LINE\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C' '                SINGLE SPACED\n         BE    SETSGL                  YES\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C'0'                DOUBLE SPACED\n         BE    SETSGL                  YES\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C'-'                TRIPLE SPACED\n         BE    SETSGL                  YES\n         ZAP   LINECT,P0               NO, MUST BE NEW PAGE\nSETSGL   MVI   PCC,C' '                SET SINGLE SPACING\n         CP    LINECT,P58              PAST END OF PAGE\n         BH    NEWPAGE                 YES\n         BR    R9                      EXIT\nNEWPAGE  MVI   PCC,C'1'                SET SKIP TO HOF\n         ZAP   LINECT,P0               RESET LINE COUNTER\n         BR    R9                      EXIT\n         EJECT\n         PRINT GEN                                                 -EU-\n         DEFCOM DSECT=YES                                          -EU-\n         EJECT  ,                                                  -EU-\n         DEFCDS ,                                                  -EU-\n         EJECT\nDISASM1  CSECT\n         SPACE 1\nOPND9    DC    A(OPNDRTN)              RETURN ADDR FOR OPERAND ROUTINES\nDSCT9    DC    F'0'                    RETURN FOR DSECTS\nSAVOP9   DC    F'0'                    SAVE AREA FOR OPND9\nULSAV    DC    7F'0'                   SAVE AREA FOR CKADCON\nNOINAD   DC    F'0'                    DATA ONLY TABLE ADDRESS\nDTBLEN   DC    AL2(L'DSECT)            DSECT TABLE ENTRY LENGTH\nNUMCK    DC    C'0000'                 NUMERIC CHECK AREA\nZEROS    DC    C'0000'                 CONSTANT ZEROS\nILENG    DC    H'0'                    INSTRUCTION LENGTH  FIX***\nHIVAL    DC    4X'FF'                  CONSTANT F'S\nUSGLEN   DC    0H'0',AL2(L'USING)      LENGTH OF USING TBL ENTRY\nNEXCHG   DC    XL3'00'                 NEXT BASE REG CHG OFFSET\nMORUSG   DC    X'00'                   80=CURRENT BASE, 01=MORE BASES\nCONPROG  DC    X'00'                   CONSTANT IN PROGRESS INDIC\nCONTYPE  DC    CL1' '                  TYPE\nCONLEN   DC    H'0'                    CONSTANT LENGTH\nH8       DC    H'8'                    CONSTANT 8\nCONOFST  DC    F'0'                    RELATIVE OFFSET TO CONSTANT\nTXTOFST  DS    0F\n         DC    X'0'\nTXTOFSET DC    XL3'0'                  OFFSET TO TEXT BYTE\nOFFSET   DC    XL3'0'                  OFFSET FROM PGM START\nINSTYP   DC    CL1' '                  INSTRUCTION TYPE\nTYPE     DC    XL1'0'                  TYPE CODE\n*                                       0=CSECT, 1=ADCON, 2=CONST\n*                                       E=USING, D=INSTRUCTION\n*                                       C=COMMENT, 9=ENTRY\n*                                       A=EQU\nLEN      DC    XL1'0'                  TEXT LENGTH\nTEXT     DC    XL8'0'                  TEXT\nP0       DC    P'0'                    CONSTANT 0\nP1       DC    P'1'                    CONSTANT 1\nP58      DC    P'58'                   CONSTANT 58\nP256     DC    P'256'                  CONSTANT 256\nP4096    DC    P'4096'                 CONSTANT 4096\nBLANX    DC    CL121' '                CONSTANT BLANKS\nUNAME    DC    CL8'A'                  USER NAME AREA\nXZROS    DC    8X'00'                  CONSTANT ZEROS\nTRTBL    DC    C'0123456789ABCDEF'     TRANSLATE TBL\nPRTABL   DC    CL9' '                  PRINTABLE HEX WORK\n         SPACE 2                                                   -EU-\n         DEFINS ,                                                  -EU-\n         EJECT\n         LTORG\n         EJECT ,                                                   -EU-\n* END OF BASE REGISTERS ADDRESSABILITY - - - - - - - - - - - - - - -EU-\n         SPACE 1                                                   -EU-\nBASES    DC    XL256'00'               CURRENT BASE REGS\nCHARTRAN DC    256X'FF'           TRT TABLE FOR CHAR/HEX DETERMINATION\n         ORG   CHARTRAN+C' '\n         DC    X'00'                   BLANK IS CHARACTER\n         ORG   CHARTRAN+C'A'\n         DC    9X'00'                  A-I ARE CHARACTERS\n         ORG   CHARTRAN+C'J'\n         DC    9X'00'                  J-R ARE CHARACTERS\n         ORG   CHARTRAN+C'S'\n         DC    8X'00'                  S-Z ARE CHARACTERS\n         ORG   CHARTRAN+C'0'\n         DC    10X'00'                 0-9 ARE CHARACTERS\n         ORG\nTRHEX    DC    256X'FF'                HEX TRANSLATION TABLE\n         ORG   TRHEX+C'A'\n         DC    X'0A0B0C0D0E0F'\n         ORG   TRHEX+C'0'\n         DC    X'00010203040506070809'\n         ORG\nTRTHEX   DS    0X                      VERIFY HEX TABLE\n         DC    XL16'00'\n         DC    XL240'FF'\n         ORG\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISASM2": {"ttr": 5382, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x8f\\x00\\x882\\x8f\\x149\\x08;\\x08;\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-23T00:00:00", "modifydate": "1988-11-23T14:39:00", "lines": 2107, "newlines": 2107, "modlines": 0, "user": "SYSPAJA"}, "text": "DIS2     TITLE '*** DISASSEMBLY PHASE 2 ***'\n         PRINT OFF                                                 -EU-\n         COPY  DISASMM                                             -EU-\n         PRINT ON                                                  -EU-\nDISASM2  SVLNK R3,R4\n         EJECT\n         PRINT NOGEN\n* THIS SUB-PROGRAM IS CALLED BY DISASM AFTER THE DIRECTORY\n* ENTRY AND LOAD MODULE ARE PROCESSED. THE ESD AND RLD\n* ENTRIES HAVE BEEN USED TO CREATE A PROGRAM LABEL TABLE,\n* AND MODULE TEXT IS IN AN AREA OF STORAGE. A COMMON PARAMETER\n* AREA IS DEFINED IN DISASM, AND PASSED TO THIS PROGRAM.\n*\n* TEXT BYTES ARE USED TO CREATE ASSEMBLY LANGUAGE STATEMENTS,\n* AND MACHINE INSTRUCTION STATEMENTS. OUTPUT IS WRITTEN\n* TO THE WORK1 DATASET FOR FURTHER PROCESSING BY OTHER\n* MODULES.\n*   A TEXT BYTE IS CONSIDERED TO BE AN INSTRUCTION IF\n* IT OCCURS ON A HALFWORD BOUNDARY, IS A VALID OP-CODE,\n* AND IS FOLLOWED BY A VALID OP-CODE. UNCONDITIONAL BRANCHES\n* NEED NOT BE FOLLOWED BY A VALID OP-CODE, HOWEVER. THE\n* PRIVILEGED AND FLOATING POINT INSTRUCTIONS ARE NOT\n* TREATED AS INSTRUCTIONS UNLESS THE USER SPECIFIED\n* THEIR INCLUSION AT EXEC TIME.\n*\n*\n* AUTHOR R THORNTON - NOV 1977\n*        UPDATES (MARKED -EU- IN COLUMNS 68-71) DONE BY            -EU-\n*        MOINIL P.A. , COMPUTING CENTRE                            -EU-\n*                      J.R.C. - ISPRA ESTABLISHMENT                -EU-\n*                      21020 ISPRA (VA), ITALY                     -EU-\n         EJECT\n******************************************************************\n*                                                                *\n* MAINLINE ROUTINE FOR DISASSEMBLY. EACH BYTE OF TEXT IS CHECKED *\n* TO DETERMINE WHETHER IT MAY BE AN INSTRUCTION OP-CODE. IF NOT, *\n* THE CONST ROUTINE IS PERFORMED TO HANDLE CONSTANT DATA. IF IT  *\n* APPEARS TO BE AN OP-CODE, THE INSTR ROUTINE IS PERFORMED.      *\n* WHEN TEXT IS EXHAUSTED, THIS PHASE TERMINATES.                 *\n*                                                                *\n******************************************************************\n         SPACE 1\n         L     R5,0(R1)                GET PARM FIELD ADDRESS\n         USING COMMPARM,R5\n         L     R6,LBLTBL               @ LABEL TABLE\n         USING LABELD,R6\n         MVC   TXTCURR,TXTSTRT         COPY TEXT START ADDR\nGETCURR  L     R7,TXTCURR              @ CURRENT TXT BYTE\n         C     R7,TXTEND               END OF TEXT\n         BNL   EOJ                     YES          FIX******\n         LR    R12,R7                  COPY TEXT ADDR\n         S     R12,TXTSTRT             COMPUTE OFFSET\n         ST    R12,TXTOFST             SAVE OFFSET TO THIS BYTE\n         CLC   NEXCHG,TXTOFSET         TIME TO CHANGE BASES\n         BH    CKDARNG                 NO\n         BAS   R9,NEXUSG               YES, GO DO IT\nCKDARNG  L     R12,DATONLY             GET DATA ONLY TBL ADDR\n         CLC   TXTOFSET,0(R12)         RANGE BEGINS LATER\n         BL    CKLOSEQ                 YES\n         CLC   TXTOFSET,3(R12)         THIS BYTE IN THE RANGE\n         BNH   CONST                   YES\n         LA    R12,6(R12)              PAST THIS ENTRY, STEP OVER 1\n         ST    R12,DATONLY             SAVE UPDATED ADDR\n         B     CKDARNG                 GO CHECK AGAIN\nCKLOSEQ  CLC   TXTOFSET,LBLADR         LABEL ENTRY OUT OF SEQ\n         BNH   GCKODD                  NO, CONTINUE\n         BAS   R9,FORCONST             YES, FORCE ANY CONSTANT OUT\n         MVC   NAME,LBLNAME            NAME TO OUTPUT\n         MVC   MNEMONIC,=CL5'EQU'      MNEMONIC\n         MVI   OPNDS,C'*'              OPERAND\n         MVC   COMMENT(14),=14C'?'     SHOW ERROR\n         BAS   R9,WRTOUT               WRITE ERROR RECORD\n         BAS   R9,PRINT                GO PRINT IT\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL\n         B     CKLOSEQ                 CONTINUE SEQ CHK\nGCKODD   TM    TXTCURR+3,1             ODD ADDRESS\n         BO    CONST                   YES, NOT INSTR\n         CLC   1(3,R7),0(R7)           4 CONSEC IDENTICAL BYTES\n         BE    CONST                   YES, NOT INSTR\n         L     R8,=A(CHARTRAN)                                     -EU-\n         TRT   0(1,R7),0(R8)           TEST TEXT BYTE              -EU-\n         BNZ   CKINSTR                 NOT CHARACTER\n         CLI   CONPROG,1               IS CONSTANT IN PROGRESS\n         BNE   CK6                     NO\n         CLI   CONTYPE,C'C'            IS IT CHARACTER TYPE\n         BE    CONST                   YES, ADD THIS TO CONSTANT\nCK6      TRT   0(6,R7),0(R8)           6 CONSECUTIVE CHARACTERS    -EU-\n         BZ    CONST                   YES, NOT INSTRUCTION\nCKINSTR  XR    R8,R8                   CLEAR WORK\n         IC    R8,0(R7)                PICK UP TXT BYTE\n         MH    R8,SGLOPL               TIMES TABLE LENGTH          -EU-\n         AL    R8,SGLOPAD              @ INSTR TBL ENTRY           -EU-\n         MVC   INSTENT,0(R8)           SAVE INSTRUCTION TBL ENTRY\n         CLI   INAME,0                 IS IT AN INSTR OP-CODE\n         BE    CONST                   NO\n         CLI   ITYPE,TWO               TWO-BYTE OP-CODE\n         BNE   INSTR                   NO\n         L     R8,DBLOPAD              YES, GET 2-BYTE TBL ADDR\nDBLND    CLI   0(R8),X'FF'             END OF TABLE\n         BE    CONST                   YES, NOT INSTR\n         CLC   0(2,R8),0(R7)           THIS ENTRY MATCHES TXT\n         BE    GOTDBLI                 YES\n         AH    R8,DBLOPL               TO NEXT ENTRY               -EU-\n         B     DBLND                   LOOP THRU TBL\nGOTDBLI  LA    R8,2(R8)                PASS OP-CODE BYTES\n         MVC   INSTENT,0(R8)           SAVE INSTR TBL ENTRY\n         EJECT\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS ENTERED WHEN CURSORY CHECKS IN THE MAINLINE    *\n* INDICATE THIS TEXT BYTE IS AN INSTRUCTION OP-CODE. FURTHER     *\n* TESTING IS DONE BY THE IVERFY (NON-FLOATING POINT), OR FPVERFY *\n* (FLOATING POINT) ROUTINES. BYTES PASSING THESE TESTS ARE       *\n* ACCEPTED AS OP-CODES, AND ARE PASSED TO THE APPROPRIATE FORMAT *\n* ROUTINES. FORMAT ROUTINES ARE ENTERED VIA A BRANCH TABLE USING *\n* A BYTE IN THE INSTRUCTION OP-CODE TABLE ENTRY.                 *\n*                                                                *\n******************************************************************\n         SPACE 1\nINSTR    MVC   ILENG+1(1),INLNG        SET INSTR LENGTH\n         LH    R12,ILENG               PICK UP LENGTH\n         AR    R12,R7                  ADDR OF NEXT OP CODE\n         XR    R15,R15                 CLEAR WORK\n         IC    R15,0(R12)              PICK UP NEXT OP-CODE\n         MH    R15,SGLOPL              TIMES TBL ENTRY LENG        -EU-\n         AL    R15,SGLOPAD             INSTR TBL ENTRY ADDR        -EU-\n         CLI   INAME-INSTENT(R15),0    IS IT AN OP-CODE\n         BNE   ICKSEC                  YES\nPOSSB    CLI   0(R7),X'45'             IS IT BAL                   -EU-\n         BE    ICKTBL                  YES, CONTINUE\n         CLI   0(R7),X'07'             NO, IS IT BRANCH\n         BE    POSSB1                  YES\n         CLI   0(R7),X'47'             IS IT BRANCH\n         BNE   CONST                   NO, THEN THIS NOT INSTR\nPOSSB1   TM    1(R7),X'F0'             IS IT UNCOND BRANCH\n         BNO   CONST                   NO, THEN THIS NOT INSTR\n         B     ICKTBL                  ACCEPT UNCOND BRANCHES\nICKSEC   XR    R1,R1                   CLEAR WORK\n         IC    R1,INLNG-INSTENT(R15)   GET INSTR LENGTH\n         AR    R1,R12                  ADDR OF NEXT OP CODE\n         XR    R14,R14                 CLEAR WORK\n         IC    R14,0(R1)               PICK UP NEXT OP-CODE\n         MH    R14,SGLOPL              TIMES TBL ENTRY LENG        -EU-\n         AL    R14,SGLOPAD             INSTR TBL ENTRY ADDR        -EU-\n         CLI   INAME-INSTENT(R14),0    IS IT AN OP-CODE\n         BNE   ICKTBL                  YES\n         CLI   0(R12),X'45'            IS IT BAL\n         BE    ICKTBL                  YES, CONTINUE\n         CLI   0(R12),X'07'            NO, IS IT BRANCH\n         BE    POSSB2                  YES\n         CLI   0(R12),X'47'            IS IT BRANCH\n         BNE   POSSB                   NO, BUT SEE CURRENT INSTR   -EU-\nPOSSB2   TM    1(R12),X'F0'            IS IT UNCOND BRANCH\n         BNO   CONST                   NO, THEN THIS NOT INSTR\nICKTBL   LH    R12,ILENG               GET INSTR LENGTH\n         AR    R12,R7                  @ NEXT TEXT LOC\n         BCTR  R12,0                   BACK UP 1\n         S     R12,TXTSTRT             RELATIVIZE IN CSECT\n         CLM   R12,B'0111',LBLADR      LBL TBL ADDR HERE\n         BL    NOILBL                  NO\n         CLC   TXTOFSET,LBLADR         LABEL AT INSTR START\n         BNE   NOTINST                 NO, MUST BE CONSTANT      FIX***\n         CLI   LBLTYP,C'L'             IS IT A LABEL ONLY\n         BNE   NOTINST                 NO                        FIX***\n         CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   CKLBLNG                 NO\n         BAS   R9,FORCONST             YES, FORCE IT OUT\nCKLBLNG  CLC   LBLLEN,INLNG            LENGTHS SAME\n         BE    SETLBL                  YES\n         CLI   LBLLEN,0                DON'T CARE LENGTH\n         BE    SETLBL                  YES\n         BAS   R9,EQUSTMT              NO, BUILD EQU STATEMENT\n         B     ISTPLBL                 CONTINUE\nSETLBL   MVC   NAME,LBLNAME            LABEL ENTRY NAME TO INSTR\n         MVC   CONLEN,LBLLEN           SET CONSTANT LENGTH IN CASE\nISTPLBL  LA    R6,L'LABEL(R6)          TO NEXT LABEL TBL ENTRY\n         CLM   R6,B'0111',LBLADR       THIS ENTRY SAME ADDR\n         BNE   ICKTBL                  NO\n         SH    R6,LBLLGTH              BACK UP TO 1ST ENTRY\n         BAS   R9,EQUSTMT              GO BUILD EQU STATEMENT\n         LA    R6,L'LABEL(R6)          TO NEXT ENTRY\n         B     ICKTBL                  GO CHECK NEXT LABEL\nNOILBL   CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   MVMNE                   NO\n         BAS   R9,FORCONST             YES, FORCE IT OUT\nMVMNE    MVC   MNEMONIC,0(R8)          SET INSTR MNEMONIC\n         MVC   OFFSET,TXTOFSET         SET OFFSET\n         MVC   INSTYP,5(R8)            SET INSTR TYPE\n         MVI   TYPE,X'0D'              SHOW IT IS AN INSTRUCTION\n         MVC   LEN,ILENG+1             SHOW LENGTH\n         MVC   TEXT(6),0(R7)           MOVE ACTUAL TEXT\n         TM    ICLASS,FLTPT            FLOATING POINT OP-CODE\n         BO    FPVERFY                 YES, GO VERIFY\n         CLI   IEDT,0                  ANY EDIT REQUIRED\n         BNE   IVERFY                  YES, GO EDIT\nPFMFMT   XR    R1,R1                   CLEAR WORK\n         IC    R1,INSTYP               GET INSTRUCTION TYPE\n         L     R9,OPND9                GET FORMAT ROUTINE RETURN ADDR\n         B     *+L'*(R1) ------------- TO APPROPRIATE FORMAT ROUTINE\n         B     RROPND                  TYPE=0, RR\n         B     RXOPND                  TYPE=4, RX\n         B     SOPND                   TYPE=8, S\n         B     SIOPND                  TYPE=12, SI\n         B     RSOPND                  TYPE=16, RS\n         B     SS1OPND                 TYPE=20, 1-LENGTH SS\n         B     SS2OPND                 TYPE=24, 2-LENGTH SS\n         B     SOPND                   TYPE=28, 2-BYTE OP-CODES\n         B     BCOPND                  TYPE=32, CONDITIONAL BRANCH\n         B     SVCOPND                 TYPE=36, SVC\n         B     SSROPND                 TYPE=40, 2 REGISTERS SS     -EU-\n         B     RREOPND                 TYPE=44, 2 REGISTERS RRE    -EU-\n         B     SSEOPND                 TYPE=48, SSE                -EU-\n         SPACE 1                                                   -EU-\nOPNDRTN  B     INSTOUT                 NORMAL OPERAND FORMAT RETURN\n         MVC   CONNAME,NAME            ANY NAME TO CONSTANT AREA\n         B     CONST                   ERROR INSTRUCTION, TREAT AS CONS\nNOTINST  CLC   NAME,BLANX              IS NAME FILLED IN?        FIX***\n         BE    CONST                                             FIX***\n         SH    R6,LBLLGTH              BACK UP                   FIX***\n         B     CONST                                             FIX***\nINSTOUT  BAS   R9,WRTOUT               WRITE INSTRUCTION RECORD\n         BAS   R9,TXTFMT               FORMAT HEX DATA\n         BAS   R9,PRINT                GO PRINT IT\n         AH    R7,ILENG                STEP TO NEXT TEXT BYTE\n         ST    R7,TXTCURR              SAVE NEXT ADDR\n         CLI   ICCSET,0                ANY COND CODE SET TYPE      -EU-\n         BE    GETCURR                 NO, CONTINUE TXT PROCESSING -EU-\n         MVC   CCTYPE,ICCSET           SHOW COND CODE SET TYPE\n         B     GETCURR                 CONTINUE TXT PROCESSING\n         EJECT\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS ENTERED FROM THE INSTR ROUTINE FOR NON FLOATING*\n* POINT INSTRUCTIONS. VARIOUS EDITS ARE PERFORMED TO INSURE THE  *\n* INPUT TEXT BYTE IS AN OP-CODE. IF IT IS, RETURN IS TO LABEL    *\n* PFMFMT, OTHERWISE THE CONST ROUTINE IS PERFORMED.              *\n*                                                                *\n******************************************************************\n         SPACE 1\nIVERFY   TM    IEDT,EPR                EVEN-ODD REG PAIR\n         BZ    IVE2                    NO\n         TM    1(R7),X'10'             R1 IS ODD\n         BO    CONST                   YES, NOT INSTR\n         CLI   0(R7),X'0E'             IS IT MVCL\n         BE    IVTRG2                  YES\n         CLI   0(R7),X'0F'             IS IT CLCL\n         BNE   IVE2                    NO\nIVTRG2   TM    1(R7),X'01'             R2 IS ODD\n         BO    CONST                   YES, NOT INSTR\n         XR    R1,R1                   CLEAR WORK\n         XR    R2,R2                   CLEAR WORK\n         IC    R1,1(R7)                GET R1R2\n         SRL   R1,4                    SHIFT OUT R2\n         PACK  DBLWD(1),1(1,R7)        FLIP R1R2 BYTE\n         IC    R2,DBLWD                PICK UP R2R1\n         SRL   R2,4                    SHIFT OUT R1\n         CR    R1,R2                   R1=R2\n         BE    CONST                   YES, NOT INSTR\n         B     PFMFMT                  NO, GOOD INSTR\nIVE2     TM    IEDT,E2                 HALFWORD STORAGE ALIGNMENT\n         BZ    IVE4                    NO\n         TM    3(R7),X'01'             DISPL IS ODD\n         BZ    IVES2                   NO, O.K.\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   IVES2                   NO, CONTINUE\n         CLI   0(R7),X'44'             EX OP CODE\n         BE    CONST                   YES, NOT INSTR\n         CLI   0(R7),X'47'             BC OP CODE\n         BE    CONST                   YES, NOT INSTR\n         CLI   ITYPE,RS                RS INSTRUCTION\n         BE    CONST                   YES, NOT INSTR\n         TM    1(R7),X'0F'             INDEX REG IS 0\n         BZ    CONST                   YES, NOT INSTR\n         B     IVES2                   CONTINUE\nIVE4     TM    IEDT,E4                 2ND OPND ON FULLWORD BOUND\n         BZ    IVE8                    NO\n         TM    3(R7),X'03'             DISPL DIV BY 4\n         BZ    IVES2                   YES, O.K.\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   IVES2                   NO, CONTINUE\n         CLI   ITYPE,RS                RS INSTRUCTION OP CODE\n         BE    CONST                   YES, NOT INSTR\n         TM    1(R7),X'0F'             INDEX REG = 0\n         BZ    CONST                   YES, NOT INSTR\n         B     IVES2                   NO, CONTINUE\nIVE8     TM    IEDT,E8                 2ND OPND ON DBLWD BOUND\n         BZ    IVES2                   NO\n         TM    3(R7),X'07'             DISPL DIV BY 8\n         BZ    IVES2                   YES, O.K.\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   IVES2                   NO\n         CLI   ITYPE,S                 S INSTRUCTION OP CODE       -EU-\n         BE    CONST                   YES, NOT INSTRUCTION        -EU-\n         CLI   ITYPE,SSE               SSE INSTRUCTION OP CODE     -EU-\n         BE    CONST                   YES, NOT INSTRUCTION        -EU-\n         TM    1(R7),X'0F'             INDEX REG = 0\n         BZ    CONST                   YES, NOT INSTR\nIVES2    CLI   PRIVASM,1               PRIVILEGED INSTR O.K.\n         BE    PFMFMT                  YES\n         TM    IEDT,S2                 OPND2 MUST HAVE BASE\n         BZ    IVES1                   NO\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   PFMFMT                  NO, O.K.\n         CLI   ITYPE,RS                RS INSTRUCTION\n         BE    CONST                   YES, NOT INSTR\n         CLI   ITYPE,S                 S INSTRUCTION               -EU-\n         BE    CONST                   YES, NOT INSTR              -EU-\n         CLI   0(R7),X'92'             IS IT MVI OP CODE\n         BE    CONST                   YES, NOT INSTR\n         TM    1(R7),X'0F'             INDEX REG = 0\n         BZ    CONST                   YES, NOT INSTR\n         B     PFMFMT                  NO, GOOD INSTR\nIVES1    TM    IEDT,S1                 1ST OPND MUST HAVE BASE\n         BZ    PFMFMT                  NO, CONTINUE\n         TM    2(R7),X'F0'             1ST OPND HAS BASE\n         BZ    CONST                   NO, NOT INSTR\n         B     PFMFMT                  YES, INSTR O.K.\n         EJECT\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS ENTERED FROM THE INSTR ROUTINE FOR FLOATING    *\n* POINT INSTRUCTIONS. VARIOUS EDITS ARE PERFORMED TO INSURE THE  *\n* INPUT TEXT BYTE IS AN OP-CODE. IF IT IS, RETURN IS TO LABEL    *\n* PFMFMT, OTHERWISE THE CONST ROUTINE IS PERFORMED.              *\n*                                                                *\n******************************************************************\n         SPACE 1\nFPVERFY  TM    ICLASS,FLEXR            EXTENDED FLT PT INSTR       -EU-\n         BZ    FPVERFP                 NO                          -EU-\n         TM    3(R7),X'BB'             0 OR 4 ONLY                 -EU-\n         BZ    PFMFMT                  YES, GOOD INSTR             -EU-\n         B     CONST                   NO, NOT INSTR               -EU-\nFPVERFP  TM    1(R7),X'90'             R1 IS 0, 2, 4, OR 6         -EU-\n         BNZ   CONST                   NO, NOT INSTR\n         CLI   0(R7),X'27'             MXDR OP-CODE\n         BE    FPR1EXT                 YES\n         CLI   0(R7),X'67'             MXD OP-CODE\n         BNE   FPCKTYP                 NO\nFPR1EXT  TM    1(R7),X'B0'             R1 IS 0 OR 4\n         BNZ   CONST                   NO, NOT INSTR\nFPCKTYP  CLI   ITYPE,RR                RR TYPE INSTRUCTION\n         BNE   FPRXVER                 NO\n         TM    1(R7),X'09'             R2 IS 0, 2, 4, 6\n         BNZ   CONST                   NO, NOT INSTR\n         CLI   0(R7),X'25'             LRDR OP CODE\n         BE    FPR2EXT                 YES\n         CLI   0(R7),X'37'             SXR OP-CODE\n         BE    FPR2EXT                 YES\n         CLI   0(R7),X'26'             MXR OP-CODE\n         BE    FPR2EXT                 YES\n         CLI   0(R7),X'36'             AXR OP-CODE\n         BNE   PFMFMT                  NO, GOOD INSTR\nFPR2EXT  TM    1(R7),X'0B'             R2 IS 0 OR 4\n         BZ    PFMFMT                  YES, GOOD INSTR\n         B     CONST                   NO, NOT INSTR\nFPRXVER  CLI   PRIVASM,1               PRIVILEGED INSTRUCTIONS O.K.\n         BE    FPALIGN                 YES\n         TM    2(R7),X'F0'             ANT BASE REG\n         BNZ   FPALIGN                 YES\n         TM    1(R7),X'0F'             ANY INDEX REG\n         BZ    CONST                   NO, NOT INSTR\nFPALIGN  TM    2(R7),X'F0'             ANY BASE REG\n         BNZ   PFMFMT                  YES, ACCEPT INSTR\n         TM    1(R7),X'0F'             ANY INDEX REG\n         BNZ   PFMFMT                  YES, ACCEPT INSTR\n         TM    3(R7),X'03'             DISPL DIV BY 4\n         BNZ   CONST                   NO, NOT INSTR\n         TM    ICLASS,FLSHT            SHORT PRECISION\n         BO    PFMFMT                  YES, ACCEPT INSTRUCTION\n         TM    3(R7),X'07'             DISPL DIV BY 8\n         BZ    PFMFMT                  YES, ACCEPT INSTR\n         B     CONST                   NO, NOT INSTR\n         EJECT\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS ENTERED FROM VARIOUS OTHER ROUTINES WHEN THE   *\n* CURRENT TEXT BYTE IS DETERMINED NOT TO BE AN INSTRUCTION OP    *\n* CODE. A CONSTANT AREA IS BUILT TO CONTAIN THE CONSTANT, IT'S   *\n* DATA TYPE, SYMBOL TO BE USED FOR ADCONS, LABEL TO BE USED, IF  *\n* ANY, ETC. THE CONSTANT IS BUILT BYTE BY BYTE, AND IS TERMINATED*\n* FOR OUTPUT BY THE FORCONST ROUTINE. THIS ROUTINE DETECTS END OF*\n* CONSTANT WHEN THE CONSTANT IN PROGRESS EXCEEDS 2 BYTES FOR A   *\n* HALFWORD, 4 BYTES FOR A FULLWORD, OR 8 BYTES AS A MAXIMUM. IT  *\n* IS ALSO TERMINATED WHEN A CHANGE IN DATA TYPE OCCURS.          *\n*                                                                *\n******************************************************************\n         SPACE 1\nCONST    MVC   WORKREC,BLANX           CLEAR WORK RECORD AREA\n         CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   CCNEW                   NO\n         CLC   TXTOFSET,LBLADR         LABEL ENTRY HAS THIS OFFSET\n         BNE   CGETYP                  NO\nCSTNEW   BAS   R9,FORCONST             FORCE IT OUT\n         B     CCNEW                   GO START A NEW ONE\nCGETYP   L     R11,=A(CHARTRAN)                                    -EU-\n         TRT   0(1,R7),0(R11)          CHECK DATA TYPE OF BYTE     -EU-\n         BNZ   CHEX                    IT'S HEX\n         MVI   CCKTYP+1,C'C'           SET TYPE IN COMPARE\n         B     CCKTYP                  GO COMPARE\nCHEX     MVI   CCKTYP+1,C'X'           SET TYPE IN COMPARE\nCCKTYP   CLI   CONTYPE,C' '            TYPE IN PROG SAME AS THIS BYTE\n         BNE   CSTNEW                  NO\nCUPDCON  LH    R11,CONLEN              GET CURRENT LENGTH\n         LA    R11,1(R11)              ADD 1\n         STH   R11,CONLEN              UPDATE LENGTH\n         L     R11,CONLOC              GET CURRENT LOC IN CONST DATA\n         MVC   0(1,R11),0(R7)          MOVE BYTE TO DATA\n         LA    R11,1(R11)              STEP OVER ONE BYTE\n         ST    R11,CONLOC              SAVE UPDATED DATA ADDR\n         CLI   CONTYPE,C'C'            CHARACTER CONSTANT\n         BE    CCK8                    YES\n         TM    CONOFST+3,1             OFFSET IS ODD\n         BO    CCFIN1                  YES\n         TM    CONOFST+3,2             HALFWORD OFFSET\n         BZ    CCFWD                   NO\n         CLI   CONLEN+1,1              HALFWORD, IS LENGTH = 1\n         BE    CCXIT1                  YES\n         B     CCFIN1                  NO\nCCFWD    CLI   CONLEN+1,4              NO, IS HEX CONST 4 BYTES\n         BL    CCXIT1                  NOT YET\nCCFIN1   BAS   R9,FORCONST             MAX LENG, FORCE IT OUT\n         B     CCXIT1                  FINISH\nCCK8     CLC   CONLEN,H8               CHAR CONSTANT 8 BYTES\n         BNL   CCFIN1                  YES\nCCXIT1   LA    R7,1(R7)                STEP OVER 1 BYTE IN TEXT\n         ST    R7,TXTCURR              UPDATE TEXT ADDR\n         B     GETCURR                 CONTINUE TEXT PROCESSING\nCCNEW    MVI   CONPROG,1               SHOW CONSTANT IN PROGRESS\n         MVC   CONOFST,TXTOFST         SET OFFSET TO 1ST BYTE\n         MVC   CONNAME,BLANX           CLEAR NAME\n         XC    CONDATA,CONDATA         CLEAR DATA AREA\n         MVC   CONSYM,BLANX            CLEAR SYMBOL NAME\n         MVC   CONLEN,XZROS            CLEAR LENGTH\n         LA    R11,CONDATA             GET 1ST DATA BYTE ADDR\n         ST    R11,CONLOC              SET STARTING ADDRESS OF DATA\n         CLC   TXTOFSET,LBLADR         LABEL AT THIS OFFSET\n         BE    CLBLD                   YES\nTRTYPE   L     R11,=A(CHARTRAN)                                    -EU-\n         TRT   0(1,R7),0(R11)          CHECK DATA TYPE OF BYTE     -EU-\n         BNZ   CCSHX                   IT'S HEX\n         MVI   CONTYPE,C'C'            IT'S CHAR, SO INDICATE\n         B     CUPDCON                 GO COMPLETE\nCCSHX    MVI   CONTYPE,C'X'            IT'S HEX, SO INDICATE\n         B     CUPDCON                 GO COMPLETE\nCLBLD    CLI   LBLTYP,C'L'             IS IT A LABEL ONLY\n         BNE   CDATACON                NO\n         MVC   CONNAME,LBLNAME         NAME TO CONSTANT WORK AREA\n         MVC   CONLLEN,LBLLEN         SAVE LENGTH\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         CLC   TXTOFSET,LBLADR         THIS LABEL AT SAME ADDR\n         BNE   TRTYPE                  NO\n         CLI   LBLTYP,C'L'             THIS ANOTHER LABEL ONLY\n         BNE   CDATACON                NO\n         SH    R6,LBLLGTH             BACK UP TO LABEL ENTRY\n         BAS   R9,EQUSTMT             GO BUILD EQU STATEMENT\n         LA    R6,L'LABEL(R6)          TO NEXT LABELENTRY\n         B     CCNEW                   GO TO NEXT LABEL\nCDATACON MVC   CONTYPE,LBLTYP          TYPE TO CONSTANT AREA\n         XR    R1,R1                   CLEAR WORK\n         IC    R1,LBLLEN               PICK UP CONSTNT LENGTH\n         STH   R1,CONLEN               SAVE CONSTANT LENGTH\n         BCTR  R1,0                    COMPUTE CONSTANT LENGTH CODE\n         STC   R1,*+L'*+1              SET MOVE LENGTH CODE\n         MVC   CONDATA(*-*),0(R7)      MOVE DATA TO RECORD\n         MVC   CONSYM,LBLNAME          SYMBOL TO CONSTANT AREA\n         XR    R11,R11                 CLEAR WORK REG\n         IC    R11,LBLLEN              PICK UP LENGTH\n         AR    R7,R11                  STEP PAST TEXT\n         ST    R7,TXTCURR              UPDATE TEXT ADDRESS\n         BAS   R9,FORCONST             FORCE CONSTANT OUT\n         LA    R6,L'LABEL(R6)          STEP TO NEXT LABEL ENTRY\n         B     GETCURR                 CONTINUE TEXT PROCESS\n         EJECT\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS ENTERED BY VARIOUS ROUTINES WHEN IT IS         *\n* NECESSARY TO WRITE THE CONSTANT CURRENTLY IN PROGRESS, AND     *\n* CLEAR FIELDS FOR THE NEXT CONSTANT TO BE CREATED.              *\n*                                                                *\n******************************************************************\n         SPACE 1\nFORCONST ST    R9,FC9                  SAVE RETURN ADDR\n         CLC   CONNAME,BLANX           ANY LABEL NAME SET UP\n         BE    CKCNPRG                 NO, CONTINUE\n         CLC   CONLLEN,CONLEN+1        LENGTHS SAME\n         BE    CKCNPRG                 YES, CONTINUE\n         ST    R6,FC6                  SAVE LABEL TABLE ADDR\n         LA    R6,CONPSLBL             @ PSEUDO LABEL ENTRY\n         BAS   R9,EQUSTMT              GO BUILD EQU STATEMENT\n         MVC   CONNAME,BLANX           CLEAR STATEMENT LABEL FIELD\n         L     R6,FC6                  RESTORE LABEL TABLE POINTER\nCKCNPRG  CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   FCCLR                   NO\n         CLI   CONLEN+1,0              ANY DATA LENGTH\n         BE    FCCLR                   NO\n         XC    TEXT,TEXT               CLEAR TEXT FIELD\n         MVC   MNEMONIC(2),=C'DC'      SET MNEMONIC\n         MVC   OPNDS(1),CONTYPE        SET TYPE\n         MVI   OPNDS+1,C''''           OPERAND DELIMITER\n         MVC   NAME,CONNAME            NAME TO RECORD\n         MVC   OFFSET,CONOFST+1        OFFSET TO RECORD\n         MVI   INSTYP,0                NOT AN INSTRUCTION\n         MVI   TYPE,2                  NON-ADDRESS CONSTANT\n         MVC   LEN,CONLEN+1            DATA LENGTH\n         LH    R11,CONLEN              DATA LENGTH\n         BCTR  R11,0                   DATA LENGTH CODE\n         STC   R11,*+L'*+1             MOVE LENGTH TO MVC\n         MVC   TEXT(*-*),CONDATA       DATA TO RECORD\n         CLI   CONTYPE,C'C'            CHARACTER TYPE\n         BE    FCHAR                   YES\n         CLI   CONTYPE,C'X'            HEX TYPE\n         BNE   FSYMBOL                 NO\n         TM    CONOFST+3,1             OFFSET TO CONSTANT IS ODD\n         BO    FHEX                    YES\n         TM    CONLEN+1,1              LENGTH IS ODD\n         BO    FHEX                    YES\n         TM    CONOFST+3,2             OFFSET DIVISIBLE BY 4\n         BO    FHWD                    NO\n         CLI   CONLEN+1,4              IS IT 4-BYTES\n         BNE   FHWD                    NO, JUST HALFWORD\n         CLC   CONDATA(4),XZROS        CONSTANT IS ALL ZEROS\n         BNE   FFCKNEG                 NO\n         MVC   OPNDS(4),=C'F''0'''     BUILD OPERANDS\n         B     FCWRT                   CONTINUE\nFFCKNEG  ICM   R11,B'1111',CONDATA     GET DATA\n         BM    FHEX                    NEG, TREAT AS HEX\n         C     R11,=F'99999'           VALUE EXCEEDS 99,999\n         BH    FHEX                    YES, TREAT AS HEX\n         MVC   OPNDS(2),=C'F'''        OPERAND DATA TYPE IS F\n         CVD   R11,DBLWD               CONVERT VALUE TO PACKED\n         UNPK  OPNDS+2(5),DBLWD+5(3)   UNPACK INTO OPERAND\n         OI    OPNDS+6,C'0'            SET SIGN = F\n         MVI   OPNDS+7,C''''           ENDING QUOTE\n         B     FCWRT                   CONTINUE\nFHWD     LH    R11,CONDATA             PICK UP HALFWORD\n         LTR   R11,R11                 TEST CONSTANT VALUE\n         BM    FHEX                    NEGATIVE, TREAT AS HEX\n         BNZ   FHCMAX                  NOT ZERO, CHECK MAX VALUE\n         MVC   OPNDS(4),=C'H''0'''     SET OPERAND FOR ZERO\n         B     FCWRT                   CONTINUE\nFHCMAX   CH    R11,=H'9999'            VALUE EXCEEDS 9,999\n         BH    FHEX                    YES, TREAT AS HEX\n         CVD   R11,DBLWD               CONVERT TO PACKED\n         OI    DBLWD+7,X'0F'           CLEAR SIGN TO F\n         MVC   OPNDS(2),=C'H'''        SET DELIMITER IN OPERAND\n         UNPK  OPNDS+2(4),DBLWD+5(3)   UNPACK VALUE TO OPERAND\n         MVI   OPNDS+6,C''''           ENDING DELIMITER\n         B     FCWRT                   CONTINUE\nFCHAR    MVC   OPNDS(2),=C'C'''        OPERAND DELIMITER FOR CHARACTER\n         LH    R11,CONLEN              GET DATA LENGTH\n         BCTR  R11,0                   LENGTH CODE\n         STC   R11,*+L'*+1             SET MOVE LENGTH\n         MVC   OPNDS+2(*-*),CONDATA    DATA TO OPERAND\n         LA    R11,OPNDS+3(R11)        STEP PAST OPERAND DATA\n         MVI   0(R11),C''''            ENDING QUOTE\n         B     FCWRT                   CONTINUE\nFSYMBOL  CLC   CONSYM,BLANX            IS IT BLANK\n         BE    FHEX                    YES, TREAT AS HEX\n         CLI   CONLEN+1,4              LENGTH IS 4\n         BH    FHEX                    NO, GREATER\n         BE    AC4                     YES, 4 BYTES\n         CLI   CONLEN+1,3              LENGTH IS 3\n         BE    AC3                     YES\n         CLI   CONLEN+1,2              LENGTH IS 2\n         BE    AC2                     YES\n         MVC   OPNDS+1(2),=C'L1'       OPND LENGTH\n         B     FSLHE1                  CONTINUE\nAC2      MVC   OPNDS+1(2),=C'L2'       OPND LGTH\n         B     FSLHE1                  CONTINUE\nAC3      MVC   OPNDS+1(2),=C'L3'       OPND LENGTH\n         B     FSLHE1                  CONTINUE\nAC4      LA    R11,OPNDS+1             STEP TO ( POS\n         B     FSLHE                   CONTINUE\nFSLHE1   LA    R11,OPNDS+3             STEP TO ( POS\nFSLHE    MVI   0(R11),C'('             DELIMITER\n         MVC   1(8,R11),CONSYM         SYMBOL TO RECORD\n         LA    R11,9(R11)              @ RHE SYMBOL IN OPERAND\nFRHE     CLI   0(R11),C' '             CHARACTER IS BLANK\n         BNE   SETRPAR                 NO\n         BCT   R11,FRHE                LOOP TO FIND RHE\nSETRPAR  MVI   1(R11),C')'             SET CLOSING PAREN\n         B     FCWRT                   CONTINUE\nFHEX     MVC   OPNDS(2),=C'X'''        TYPE AND BEGIN QUOTE\n         LA    R12,CONDATA             @ CONSTANT DATA\n         BAS   R9,HEXPRT4              CONVERT TO PRINTABLE\n         LH    R12,CONLEN              GET DATA LENGTH\n         SLL   R12,1                   DOUBLE IT\n         BCTR  R12,0                   -1 = LENGTH CODE\n         STC   R12,*+L'*+1             SET MOVE LENGTH\n         MVC   OPNDS+2(*-*),PRTABL     HEX CHARS TO OPERAND\n         LA    R12,OPNDS+2(R12)        OPERAND END ADDRESS\n         MVI   1(R12),C''''            ENDING QUOTE\n         B     FCWRT                   CONTINUE\nFCWRT    BAS   R9,WRTOUT               WRITE RECORD\n         BAS   R9,TXTFMT               GO FORMAT HEX DATA\n         BAS   R9,PRINT                GO PRINT IT\nFCCLR    MVI   CONPROG,0               RESET CONSTANT IN PROGRESS\n         MVC   CONNAME,BLANX           CLEAR NAME\n         MVI   CONTYPE,0               RESET TYPE\n         XC    CONDATA,CONDATA         CLEAR CONSTANT DATA\n         MVC   CONSYM,BLANX            CLEAR SYMBOL\n         XC    CONLEN,CONLEN           CLEAR LENGTH\n         MVC   CONLOC,XZROS            CLEAR LOCATION\n         MVC   CONOFST,XZROS           CLEAR OFFSET TO CONSTANT\n         L     R9,FC9                  GET RETURN ADDR\n         BR    R9                      EXIT\n         EJECT\n******************************************************************\n*                                                                *\n* THIS ROUTINE FORMATS RR-FORMAT INSTRUCTIONS FOR OUTPUT.        *\n*                                                                *\n******************************************************************\n         SPACE 1\nRROPND   CLI   0(R7),X'05'             IS IT BALR\n         BE    RRBL                    YES                         -EU-\n         CLI   0(R7),X'0C'             IS IT BASSM                 -EU-\n         BE    RRBL                    YES                         -EU-\n         CLI   0(R7),X'0D'             IS IT BASR                  -EU-\n         BNE   RRSTRT                  NO\nRRBL     CLI   1(R7),X'EF'             IS IT 14,15                 -EU-\n         BE    RRSTDL                  YES\n         TM    1(R7),X'0F'             NO, IS R2 = 0\n         BNZ   RRNSTD                  NO\n         MVC   COMMENT(11),=C'ADDRESS SET'\n         B     RRSTRT                  CONTINUE\nRRSTDL   MVC   COMMENT(11),=C'STD LINKAGE'\n         B     RRSTRT                  CONTINUE\nRRNSTD   MVC   COMMENT(14),=C'NONSTD LINKAGE'\nRRSTRT   XR    R1,R1                   CLEAR WORK\n         IC    R1,TEXT+1               GET 2ND BYTE\n         SRL   R1,4                    SHIFT OUT R2\n         CVD   R1,DBLWD                CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         MVI   OPNDS,C'R'              BEGIN R1 OPERAND\n         CH    R1,H10                  REG NBR > 9\n         BL    RR1T                    NO, 0-9                     -EU-\n         MVC   OPNDS+1(2),DBLWD        YES, 10-15\n         LA    R1,OPNDS+3              TO NEXT POS\n         B     RRCMA                   CONTINUE\nRR1T     CLI   DBLWD+1,C'0'            R1 = 0                      -EU-\n         BNE   RR11                    NO                          -EU-\n         CLI   0(R7),X'0B'             IS IT BSM                   -EU-\n         BNE   RR11                    NO                          -EU-\n         MVI   OPNDS,C'0'              SET ONLY 0                  -EU-\n         LA    R1,OPNDS+1              TO NEXT POS                 -EU-\n         B     RRCMA1                  CONTINUE                    -EU-\nRR11     MVC   OPNDS+1(1),DBLWD+1      MOVE REG NBR\n         LA    R1,OPNDS+2              TO NEXT POS\nRRCMA    CLI   TEXT,X'04'              IS IT SPM\n         BNE   RRCMA1                  NO\n         TM    1(R7),X'0F'             YES, IS R2 FIELD = 0\n         BZ    RRXIT                   YES, GOOD INSTR\n         B     4(R9)                   ERROR RETURN (NOT INSTR)\nRRCMA1   MVC   0(2,R1),=C',R'          DELIMITERS\n         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE\n         XR    R15,R15                 CLEAR WORK\n         IC    R15,DBLWD               GET R2R1\n         SRL   R15,4                   SHIFT OUT R1\n         CVD   R15,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R15,H10                 R2 > 9\n         BL    RR2T                    NO, 0-9                     -EU-\n         MVC   2(2,R1),DBLWD           YES, MOVE REG 10-15\n         BR    R9                      EXIT\nRR2T     CLI   DBLWD+1,C'0'            R2 = 0                      -EU-\n         BNE   RR21                    NO                          -EU-\n         CLI   0(R7),X'05'             IS IT BALR                  -EU-\n         BE    RR20                    YES                         -EU-\n         CLI   0(R7),X'06'             IS IT BCTR                  -EU-\n         BE    RR20                    YES                         -EU-\n         CLI   0(R7),X'0B'             IS IT BSM                   -EU-\n         BE    RR20                    YES                         -EU-\n         CLI   0(R7),X'0C'             IS IT BASSM                 -EU-\n         BE    RR20                    YES                         -EU-\n         CLI   0(R7),X'0D'             IS IT BASR                  -EU-\n         BNE   RR21                    NO                          -EU-\nRR20     MVI   1(R1),C'0'              SET ONLY 0                  -EU-\n         BR    R9                      EXIT                        -EU-\nRR21     MVC   2(1,R1),DBLWD+1         MOVE REG 0-9\nRRXIT    BR    R9                      EXIT\n         EJECT\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RX-TYPE  *\n* INSTRUCTIONS. THE BDXADR ROUTINE IS CALLED TO FORMAT THE       *\n* STORAGE OPERAND.                                               *\n*                                                                *\n******************************************************************\n         SPACE 1\nRXOPND   CLI   0(R7),X'45'             IS IT BAL OP CODE\n         BNE   RXSTRT                  NO\n         MVC   COMMENT(7),=C'PERFORM'\n         TM    1(R7),X'E0'             R1 = 0 OR 1\n         BNZ   RXSTRT                  NO\n         MVC   COMMENT(13),=C'PARM SET BRCH'\nRXSTRT   XR    R1,R1                   CLEAR WORK\n         IC    R1,TEXT+1               GET R1X2\n         SRL   R1,4                    SHIFT OUT X2\n         CVD   R1,DBLWD                CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         MVI   OPNDS,C'R'              BEGIN 1ST OPERAND\n         CH    R1,H10                  R1 < 10\n         BL    RXR1T                   YES, 0-9\n         MVC   OPNDS+1(2),DBLWD        NO, MOVE REG 10-15\n         LA    R15,OPNDS+3             TO NEXT POS\n         B     RXCMA                   CONTINUE\nRXR1T    CLI   0(R7),X'44'             IS IT EX OP CODE            -EU-\n         BNE   RXR11                   NO                          -EU-\n         CLI   DBLWD+1,C'0'            REG = 0                     -EU-\n         BNE   RXR11                   NO                          -EU-\n         MVI   OPNDS,C'0'              SET ONLY 0                  -EU-\n         LA    R15,OPNDS+1             TO NEXT POS                 -EU-\n         B     RXCMA                   CONTINUE                    -EU-\nRXR11    MVC   OPNDS+1(1),DBLWD+1      MOVE REG 0-9\n         LA    R15,OPNDS+2             TO NEXT POS\nRXCMA    MVI   0(R15),C','             DELIMITER\n         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE\n         XR    R10,R10                 CLEAR WORK\n         IC    R10,DBLWD               PICK UP X2R1\n         SRL   R10,4                   SHIFT OUT R1\n         XR    R11,R11                 CLEAR WORK\n         ICM   R11,B'0011',TEXT+2      GET BDDD\n         TM    TEXT+2,X'F0'            IS B SPECIFIED              -EU-\n         BNZ   RXCONV                  YES                         -EU-\n         SLL   R10,12                  POSITION X2 AS B            -EU-\n         OR    R11,R10                 BUILD NEW BDDD              -EU-\n         XR    R10,R10                 CLEAR X2                    -EU-\nRXCONV   BAS   R9,BDXADR               CONVERT RX ADDRESS\n         STC   R10,*+L'*+1             SET MOVE LENGTH\n         MVC   1(*-*,R15),OPNDWK       MOVE RX OPERAND\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n         EJECT\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT S-TYPE   *\n* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *\n* STORAGE OPERAND.                                               *\n*                                                                *\n******************************************************************\n         SPACE 1\nSOPND    CLI   1(R7),0                 BYTE 2 OF INSTR IS ZERO\n         BE    SCHECK                  YES\n         CLI   0(R7),X'80'             NO, IS IT SSM\n         BE    4(R9)                   YES, NOT INSTR\n         CLI   0(R7),X'82'             NO, IS IT LPSW\n         BE    4(R9)                   YES, NOT INSTR\n         CLI   0(R7),X'93'             NO, IS IT TS\n         BE    4(R9)                   YES, NOT INSTR\nSCHECK   CLI   0(R7),X'B2'             OP-CODE IS B2\n         BNE   SSTRT                   NO\n         TM    ICLASS,IOP              IGNORE OPERAND INSTR        -EU-\n         BZ    SST3A                   NO                          -EU-\n         CLC   2(2,R7),XZROS           3RD AND 4TH BYTES ZERO      -EU-\n         BNE   4(R9)                   NO, NOT INSTRUCTION         -EU-\n         BR    R9                      YES, EXIT                   -EU-\nSST3A    CLI   1(R7),X'3A'             'STCPS' INST                -EU-\n         BNE   SSTRT                   NO                          -EU-\n         TM    3(R7),X'1F'             32-BYTE BOUNDARY            -EU-\n         BZ    SSTRT                   YES                         -EU-\n         TM    2(R7),X'F0'             BASE REG = 0                -EU-\n         BZ    4(R9)                   YES, NOT INSTR              -EU-\nSSTRT    XR    R11,R11                 CLEAR WORK\n         ICM   R11,B'0011',TEXT+2      GET BDDD\n         BAS   R9,BDADR                CONVERT BDDD ADDRESS\n         STC   R10,*+L'*+1             SET MOVE LENGTH\n         MVC   OPNDS(*-*),OPNDWK       MOVE OPERAND\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n         EJECT\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SI-TYPE  *\n* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *\n* STORAGE OPERAND.                                               *\n*                                                                *\n******************************************************************\n         SPACE 1\nSIOPND   XR    R11,R11                 CLEAR WORK\n         ICM   R11,B'0011',TEXT+2      GET BDDD ADDRESS\n         BAS   R9,BDADR                CONVERT ADDRESS\n         STC   R10,*+L'*+1             SET MOVE LENGTH\n         MVC   OPNDS(*-*),OPNDWK       MOVE BDDD OPERAND\n         LA    R15,OPNDS+1(R10)        TO NEXT POS\n         MVI   0(R15),C','             DELIMITER\n         L     R9,=A(CHARTRAN)                                     -EU-\n         TRT   TEXT+1(1),0(R9)         TEST IF CHARACTER           -EU-\n         BNZ   HEXIMM                  NO, HEX\n         CLI   TEXT,X'95'              IS IT CLI\n         BE    CHIMM                   YES\n         CLI   TEXT,X'92'              IS IT MVI\n         BNE   HEXIMM                  NO\nCHIMM    MVC   1(2,R15),=C'C'''        DELIMITER\n         MVC   3(1,R15),TEXT+1         CHARACTER TO OPERAND\n         MVI   4(R15),C''''            ENDING DELIMITER\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\nHEXIMM   MVC   1(2,R15),=C'X'''        DELIMITER FOR HEX\n         LA    R12,TEXT+1              @ HEX BYTE\n         BAS   R9,HEXPRT1              CONVERT\n         MVC   3(2,R15),PRTABL         PRINTABLE HEX TO OPERAND\n         MVI   5(R15),C''''            FINAL QUOTE\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n         EJECT\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RS-TYPE  *\n* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *\n* STORAGE OPERAND.                                               *\n*                                                                *\n******************************************************************\n         SPACE 1\nRSOPND   CLI   TEXT,X'90'              IS IT STM\n         BE    RSSTM                   YES\n         CLI   TEXT,X'98'              IS IT LM\n         BNE   RSCLR1                  NO\n         MVC   COMMENT(12),=C'RESTORE REGS'\n         B     RSCLR1                  CONTINUE\nRSSTM    MVC   COMMENT(9),=C'SAVE REGS'\nRSCLR1   XR    R1,R1                   CLEAR WORK\n         IC    R1,TEXT+1               PICK UP R1R3\n         SRL   R1,4                    SHIFT OUT R3\n         CVD   R1,DBLWD                CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         MVI   OPNDS,C'R'              BEGINNING OPERAND 1\n         CH    R1,H10                  REG NBR < 10\n         BL    RSR11                   YES\n         MVC   OPNDS+1(2),DBLWD        MOVE REG 10-15\n         LA    R15,OPNDS+3             TO NEXT POS\n         B     RSCMA                   CONTINUE\nRSR11    MVC   OPNDS+1(1),DBLWD+1      MOVE REG 0-9\n         LA    R15,OPNDS+2             TO NEXT POS\nRSCMA    CLI   0(R7),X'88'             IS IT SHIFT INSTR\n         BL    RSCMA1                  NO\n         CLI   0(R7),X'8F'             IS IT SHIFT INSTR\n         BH    RSCMA1                  NO\n         TM    1(R7),X'0F'             SHIFT, IS R3 POS = 0\n         BZ    RSBDD                   YES, GOOD SHIFT\n         B     4(R9)                   NO, NOT INSTR\nRSCMA1   CLI   0(R7),X'BD'             CLM, STCM, OR ICM           -EU-\n         BL    RSPK2                   NO\n         CLI   0(R7),X'BF'             CLM, STCM, OR ICM\n         BH    RSPK2                   NO\n* CLM, STCM, ICM HAVE MASK IN R3 POSITION\n         MVC   0(3,R15),=C',B'''       DELIMITERS                  -EU-\n         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE               -EU-\n         XR    R1,R1                   CLEAR WORK                  -EU-\n         IC    R1,DBLWD                GET MR1                     -EU-\n         SRL   R1,4                    SHIFT OUT R1                -EU-\n         SLL   R1,2                    MULTIPLY BY 4               -EU-\n         AL    R1,=A(RSMASKS)          COMPUTE MASK BITS ADDRESS   -EU-\n         MVC   3(4,R15),0(R1)          SET MASK BITS               -EU-\n         MVI   7(R15),C''''            MASK DELIMITER              -EU-\n         LA    R15,8(R15)              TO NEXT POS                 -EU-\n         B     RSBDD                   CONTINUE                    -EU-\nRSPK2    MVC   0(2,R15),=C',R'         DELIMITERS                  -EU-\n         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE               -EU-\n         XR    R1,R1                   CLEAR WORK\n         IC    R1,DBLWD                GET R3R1\n         SRL   R1,4                    SHIFT OUT R1\n         CVD   R1,DBLWD                CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R1,H10                  REG NBR < 10\n         BL    RSR31                   YES, 0-9\n         MVC   2(2,R15),DBLWD          MOVE REG 10-15\n         LA    R15,4(R15)              TO NEXT POS\n         B     RSBDD                   CONTINUE\nRSR31    MVC   2(1,R15),DBLWD+1        MOVE REG 0-9\n         LA    R15,3(R15)              TO NEXT POS\nRSBDD    MVI   0(R15),C','             DELIMITER\n         XR    R11,R11                 CLEAR WORK\n         ICM   R11,B'0011',TEXT+2      GET BDD ADDRESS\n         BAS   R9,BDADR                CONVERT BDDD ADDRESS\n         STC   R10,*+L'*+1             SET MOVE LENGTH\n         MVC   1(*-*,R15),OPNDWK       MOVE BDDD ADDRESS\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n         EJECT\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE  *\n* INSTRUCTIONS OF THE SINGLE LENGTH VARIETY. THE BDLADR ROUTINE  *\n* IS CALLED TO FORMAT THE 1ST STRG OPND, AND BDADR FOR THE 2ND.  *\n*                                                                *\n******************************************************************\n         SPACE 1\nSS1OPND  XR    R10,R10                 CLEAR WORK\n         IC    R10,TEXT+1              GET LENGTH CODE\n         XR    R11,R11                 CLEAR WORK\n         ICM   R11,B'0011',TEXT+2      GET BDDD ADDRESS\n         BAS   R9,BDLADR               CONVERT ADDRESS\n         STC   R10,*+L'*+1             SET MOVE LENGTH\n         MVC   OPNDS(*-*),OPNDWK       MOVE ADDRESS\n         LA    R15,OPNDS+1(R10)        TO NEXT POS\n         MVI   0(R15),C','             DELIMITER\n         XR    R11,R11                 CLEAR WORK\n         ICM   R11,B'0011',TEXT+4      GET SECOND BDDD ADDRESS\n         BAS   R9,BDADR                CONVERT ADDRESS\n         STC   R10,*+L'*+1             SET MOVE LENGTH\n         MVC   1(*-*,R15),OPNDWK       MOVE 2ND OPERAND\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n         EJECT\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE  *\n* INSTRUCTIONS OF THE DOUBLE LENGTH VARIETY. THE BDLADR ROUTINE  *\n* IS CALLED TO FORMAT THE STORAGE OPERANDS.                      *\n*                                                                *\n******************************************************************\n         SPACE 1\nSS2OPND  XR    R10,R10                 CLEAR WORK\n         IC    R10,TEXT+1              GET L1L2\n         SRL   R10,4                   SHIFT OUT L2\n         XR    R11,R11                 CLEAR WORK\n         ICM   R11,B'0011',TEXT+2      GET BDDD ADDRESS\n         BAS   R9,BDLADR               CONVERT ADDRESS\n         STC   R10,*+L'*+1             SET MOVE LENGTH\n         MVC   OPNDS(*-*),OPNDWK       MOVE 1ST OPERAND\n         LA    R15,OPNDS+1(R10)        TO NEXT POS\n         MVI   0(R15),C','             DELIMITER\n         XR    R11,R11                 CLEAR WORK\n         ICM   R11,B'0011',TEXT+4      GET 2ND BDDD ADDR\n         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE\n         XR    R10,R10                 CLEAR WORK\n         IC    R10,DBLWD               PICK UP L2L1\n         SRL   R10,4                   SHIFT OUT L1\n         CLI   TEXT,X'F0'              SRP OP-CODE\n         BE    SRPOP2                  YES\n         BAS   R9,BDLADR               CONVERT ADDRESS\n         STC   R10,*+L'*+1             SET MOVE LENGTH\n         MVC   1(*-*,R15),OPNDWK       MOVE 2ND OPERAND\nSS2XIT   L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\nSRPOP2   BAS   R9,BDADR                GO BUILD OPERAND 2\n         STC   R10,*+L'*+1             SET MOVE LENGTH\n         MVC   1(*-*,R15),OPNDWK       MOVE OPERAND 2\n         LA    R15,2(R10,R15)          TO NEXT OPERAND POS  FIX***\n         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE\n         XR    R10,R10                 CLEAR WORK\n         IC    R10,DBLWD               PICK UP I3L1\n         SRL   R10,4                   SHIFT OUT L1\n         CVD   R10,DBLWD               CONVERT I3\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         MVI   0(R15),C','             OPERAND SEPARATOR    FIX***\n         UNPK  1(1,R15),DBLWD+7(1)     UNPACK I3 TO OPERAND FIX***\n         CH    R10,H10                 I3 < 10                     -EU-\n         BL    SS2XIT                  YES\n         UNPK  1(2,R15),DBLWD+6(2)     NO, UNPACK MORE\n         B     SS2XIT                  CONTINUE\n         EJECT ,                                                   -EU-\n****************************************************************** -EU-\n*                                                                * -EU-\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE  * -EU-\n* INSTRUCTIONS OF THE 2 REGISTERS VARIETY. THE BDLADR ROUTINE IS * -EU-\n* CALLED TO FORMAT THE 1ST STRG OPND, AND BDADR FOR THE 2ND.     * -EU-\n*                                                                * -EU-\n****************************************************************** -EU-\n         SPACE 1                                                   -EU-\nSSROPND  XR    R10,R10                 CLEAR WORK                  -EU-\n         IC    R10,TEXT+1              GET R1R3                    -EU-\n         SRL   R10,4                   SHIFT OUT R3                -EU-\n         XR    R11,R11                 CLEAR WORK                  -EU-\n         ICM   R11,B'0011',TEXT+2      GET BDDD ADDRESS            -EU-\n         BAS   R9,BDLADR               CONVERT ADDRESS             -EU-\n         STC   R10,*+L'*+1             SET MOVE LENGTH             -EU-\n         MVC   OPNDS(*-*),OPNDWK       MOVE 1ST OPERAND            -EU-\n         LA    R15,OPNDS+1(R10)        TO NEXT POS                 -EU-\n         MVI   0(R15),C','             DELIMITER                   -EU-\n         XR    R11,R11                 CLEAR WORK                  -EU-\n         ICM   R11,B'0011',TEXT+4      GET 2ND BDDD ADDR           -EU-\n         BAS   R9,BDADR                CONVERT ADDRESS             -EU-\n         STC   R10,*+L'*+1             SET MOVE LENGTH             -EU-\n         MVC   1(*-*,R15),OPNDWK       MOVE 2ND OPERAND            -EU-\n         LA    R15,2(R10,R15)          TO NEXT POS                 -EU-\n         PACK  DBLWD(1),TEXT+1(1)      FLIP R1R3 BYTE              -EU-\n         XR    R10,R10                 CLEAR WORK                  -EU-\n         IC    R10,DBLWD               PICK UP R3R1                -EU-\n         SRL   R10,4                   SHIFT OUT R1                -EU-\n         CVD   R10,DBLWD               CONVERT R3                  -EU-\n         OI    DBLWD+7,X'0F'           CLEAR SIGN                  -EU-\n         MVC   0(2,R15),=C',R'         OPERAND SEPARATOR           -EU-\n         UNPK  2(1,R15),DBLWD+7(1)     UNPACK R3 TO OPERAND        -EU-\n         CH    R10,H10                 R3 < 10                     -EU-\n         BL    SSRXIT                  YES                         -EU-\n         UNPK  2(2,R15),DBLWD+6(2)     NO, UNPACK MORE             -EU-\nSSRXIT   L     R9,OPND9                GET RETURN ADDR             -EU-\n         BR    R9                      EXIT                        -EU-\n         EJECT ,                                                   -EU-\n****************************************************************** -EU-\n*                                                                * -EU-\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SSE-TYPE * -EU-\n* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE BOTH   * -EU-\n* OPERANDS.                                                      * -EU-\n*                                                                * -EU-\n****************************************************************** -EU-\n         SPACE 1                                                   -EU-\nSSEOPND  XR    R11,R11                 CLEAR WORK                  -EU-\n         ICM   R11,B'0011',TEXT+2      GET BDDD ADDRESS            -EU-\n         BAS   R9,BDADR                CONVERT ADDRESS             -EU-\n         STC   R10,*+L'*+1             SET MOVE LENGTH             -EU-\n         MVC   OPNDS(*-*),OPNDWK       MOVE 1ST OPERAND            -EU-\n         LA    R15,OPNDS+1(R10)        TO NEXT POS                 -EU-\n         MVI   0(R15),C','             DELIMITER                   -EU-\n         XR    R11,R11                 CLEAR WORK                  -EU-\n         ICM   R11,B'0011',TEXT+4      GET 2ND BDDD ADDR           -EU-\n         BAS   R9,BDADR                CONVERT ADDRESS             -EU-\n         STC   R10,*+L'*+1             SET MOVE LENGTH             -EU-\n         MVC   1(*-*,R15),OPNDWK       MOVE 2ND OPERAND            -EU-\n         L     R9,OPND9                GET RETURN ADDR             -EU-\n         BR    R9                      EXIT                        -EU-\n         EJECT\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT COND-    *\n* ITIONAL BRANCH INSTRUCTIONS. AN ATTEMPT IS MADE TO USE THE     *\n* EXTENDED MNEMONICS WHERE POSSIBLE. FOR RR-TYPE BRANCHES, ONLY  *\n* THE BR AND NOPR MNEMONICS ARE USED. FOR RX-TYPE BRANCHES, THE  *\n* FULL SET OF EXTENDED MNEMONICS IS USED. THE TYPES USED ARE     *\n* ARITHMETIC, COMPARE, AND 8=ZERO TYPES. THE SET TO BE USED IS   *\n* DETERMINED BY THE TYPE SAVED BY THE LAST CONDITION-CODE-SETTING*\n* INSTRUCTION GENERATED.                                         *\n*\n******************************************************************\n         SPACE 1\nBCOPND   TM    TEXT+1,X'F0'            UNCONDITIONAL BRANCH\n         BZ    NOPS                    NO, NOP\n         BO    UNCNDS                  YES, UNCONDITIONAL\n         XR    R11,R11                 CLEAR WORK\n         IC    R11,TEXT+1              PICK UP M1X2\n         SRL   R11,4                   SHIFT OUT ALL BUT M1\n         CLI   BREMASM,1               IS BR EXT.MNEMONICS ALLOWED -EU-\n         BE    *+L'*+8                 YES                         -EU-\n         CLI   TEXT,X'07'              BCR OP CODE\n         BE    NOEXTND                 YES, NO EXTENDED MNEMONICS\n         CLI   CCTYPE,0                LAST INSTR SET CC\n         BE    NOEXTND                 NO\n         TM    CCTYPE,ARITH            YES, WAS IT ARITHMETIC\n         BO    EXTARITH                YES\n         TM    CCTYPE,CPR              WAS IT COMPARE\n         BO    EXTCPR                  YES\n         TM    CCTYPE,ZRO8             IS IT VALID FOR 8 = BZ\n         BO    EXTZRO                  YES\nNOEXTND  CVD   R11,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R11,H10                 MASK < 10\n         BL    BCM1                    YES, SINGLE DIGIT MASK\n         MVC   OPNDS(2),DBLWD          2-DIGIT MASK TO OPERAND\n         LA    R15,OPNDS+2             TO NEXT POS\n         B     BCCMA                   CONTINUE\nBCM1     MVC   OPNDS(1),DBLWD+1        SINGLE DIGIT MASK TO OPERAND\n         LA    R15,OPNDS+1             TO NEXT POS\nBCCMA    MVI   0(R15),C','             DELIMITER\n         CLI   TEXT,X'07'              RR BRANCH\n         BE    BCROPND                 YES\nBCXOPND  PACK  DBLWD(1),TEXT+1(1)      PACK 2ND BYTE\n         XR    R10,R10                 CLEAR WORK\n         IC    R10,DBLWD               PICK UP X2M1\n         SRL   R10,4                   SHIFT OUT M1\n         XR    R11,R11                 CLEAR WORK\n         ICM   R11,B'0011',TEXT+2      PICK UP BDDD ADDRESS\n         BNZ   BCXTEST                 BRANCH IF NOT ZERO          -EU-\n         CLC   MNEMONIC,=CL5'NOP'      NOP                         -EU-\n         BNE   BCXTEST                 NO                          -EU-\n         MVI   1(R15),C'0'             SET ONLY 0                  -EU-\n         B     BCOXIT                  GO TO EXIT                  -EU-\nBCXTEST  TM    TEXT+2,X'F0'            IS B SPECIFIED              -EU-\n         BNZ   BCXCONV                 YES                         -EU-\n         SLL   R10,12                  POSITION X2 AS B            -EU-\n         OR    R11,R10                 BUILD NEW BDDD              -EU-\n         XR    R10,R10                 CLEAR X2                    -EU-\nBCXCONV  BAS   R9,BDXADR               CONVERT ADDRESS\n         STC   R10,*+L'*+1             SET MOVE LENGTH\n         MVC   1(*-*,R15),OPNDWK       MOVE OPERAND\n         B     BCOXIT                  GO TO EXIT\nBCROPND  MVI   1(R15),C'R'             REGISTER DELIMITER\n         XR    R10,R10                 CLEAR WORK\n         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE\n         IC    R10,DBLWD               PICK UP R2M1\n         SRL   R10,4                   SHIFT OUT M1\n         CVD   R10,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R10,H10                 REG NBR < 10\n         BL    BCRRT                   YES, 0-9\n         MVC   2(2,R15),DBLWD          MOVE 2-DIGIT REG NBR\n         B     BCOXIT                  GO TO EXIT\nBCRRT    CLI   DBLWD+1,C'0'            REG NBR = 0                 -EU-\n         BNE   BCRR1                   NO                          -EU-\n         CLC   MNEMONIC,=CL5'NOPR'     NOPR                        -EU-\n         BNE   BCRR1                   NO                          -EU-\n         MVI   1(R15),C'0'             SET ONLY 0                  -EU-\n         B     BCOXIT                  GO TO EXIT                  -EU-\nBCRR1    MVC   2(1,R15),DBLWD+1        MOVE 1-DIGIT REG NBR        -EU-\n         B     BCOXIT                  GO TO EXIT\nNOPS     CLI   TEXT,X'07'              RR NOP\n         BNE   BCXNOP                  NO, RX\n         MVC   MNEMONIC,=CL5'NOPR'     SET MNEMONIC\nBCRTFIN  LA    R15,OPNDS-1             TO OPND POS                 -EU-\n         B     BCROPND                 FINISH\nBCXNOP   MVC   MNEMONIC,=CL5'NOP'      SET MNEMONIC\n         LA    R15,OPNDS-1             TO OPND POS                 -EU-\n         B     BCXOPND                 FINISH\nUNCNDS   CLI   TEXT,X'07'              IS IT RR BRANCH\n         BNE   BCXBRCH                 NO, RX\n         MVC   MNEMONIC,=CL5'BR'       SET MNEMONIC\n         LA    R15,OPNDS-1             OPERAND ADDR\n         CLI   TEXT+1,X'FE'            IS IT BR 14\n         BNE   BCROPND                 NO\n         MVC   COMMENT(4),=C'EXIT'     COMMENT\n         B     BCROPND                 FINISH FORMATTING\nBCXBRCH  MVC   MNEMONIC(5),=CL5'B'     SET MNEMONIC\nBCXTFIN  LA    R15,OPNDS-1             SET OPND POS\n         B     BCXOPND                 FINISH FORMAT\nBCOXIT   L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\nEXTARITH CH    R11,H8                  COND CODE = 8\n         BE    ARBZ                    YES\n         BL    ARLOW                   NO, LOWER\n         CH    R11,H14                 COND CODE = 14\n         BE    ARBNO                   YES\n         CH    R11,H13                 COND CODE = 13\n         BE    ARBNP                   YES\n         CH    R11,H11                 COND CODE = 11\n         BE    ARBNM                   YES\n         B     NOEXTND                 NO, NOT EXTENDED\nARLOW    CH    R11,H7                  COND CODE = 7\n         BE    ARBNZ                   YES\n         CH    R11,H1                  COND CODE = 1\n         BE    ARBO                    YES\n         CH    R11,H2                  COND CODE = 2\n         BE    ARBP                    YES\n         CH    R11,H4                  COND CODE = 4\n         BE    ARBM                    YES\n         B     NOEXTND                 NO, NOT EXTENDED\nARBZ     MVC   MNEMONIC(3),=C'BZ '     SET EXT MNEMONIC            -EU-\n         B     BCXBRTS                 CONTINUE                    -EU-\nARBNO    MVC   MNEMONIC(3),=C'BNO'     SET EXTENDED MNEMONIC\n         B     BCXBRTS                 CONTINUE                    -EU-\nARBNP    MVC   MNEMONIC(3),=C'BNP'     SET EXT MNEMONIC\n         B     BCXBRTS                 CONTINUE                    -EU-\nARBNM    MVC   MNEMONIC(3),=C'BNM'     SET EXT MNEMONIC\n         B     BCXBRTS                 CONTINUE                    -EU-\nARBNZ    MVC   MNEMONIC(3),=C'BNZ'     SET EXT MNEMONIC\n         B     BCXBRTS                 CONTINUE                    -EU-\nARBO     MVC   MNEMONIC(3),=C'BO '     SET EXT MNEMONIC            -EU-\n         B     BCXBRTS                 CONTINUE                    -EU-\nARBP     MVC   MNEMONIC(3),=C'BP '     SET EXT MNEMONIC            -EU-\n         B     BCXBRTS                 CONTINUE                    -EU-\nARBM     MVC   MNEMONIC(3),=C'BM '     SET EXT MNEMONIC            -EU-\n         B     BCXBRTS                 CONTINUE                    -EU-\nEXTZRO   CH    R11,H8                  COND CODE = 8\n         BE    ARBZ                    YES, USE BZ MNEMONIC\n         CH    R11,H7                  COND CODE IS 7\n         BE    ARBNZ                   YES\n         B     NOEXTND                 NO, NOT EXTENDED\nEXTCPR   CH    R11,H8                  COND CODE = 8\n         BE    CPBE                    YES\n         CH    R11,H7                  COND CODE = 7\n         BE    CPBNE                   YES\n         BL    CPLOW                   NO, LOWER\n         CH    R11,H13                 COND CODE = 13\n         BE    CPBNH                   YES\n         CH    R11,H11                 COND CODE = 11\n         BE    CPBNL                   YES\n         B     NOEXTND                 NO, NOT EXTENDED\nCPLOW    CH    R11,H4                  COND CODE = 4\n         BE    CPBL                    YES\n         CH    R11,H2                  COND CODE = 2\n         BE    CPBH                    YES\n         B     NOEXTND                 NO, NOT EXTENDED\nCPBE     MVC   MNEMONIC(3),=C'BE '     SET EXT MNEMONIC            -EU-\n         B     BCXBRTS                 CONTINUE                    -EU-\nCPBNE    MVC   MNEMONIC(3),=C'BNE'     SET EXT MNEMONIC\n         B     BCXBRTS                 CONTINUE                    -EU-\nCPBNH    MVC   MNEMONIC(3),=C'BNH'     SET EXT MNEMONIC\n         B     BCXBRTS                 CONTINUE                    -EU-\nCPBNL    MVC   MNEMONIC(3),=C'BNL'     SET EXT MNEMONIC\n         B     BCXBRTS                 CONTINUE                    -EU-\nCPBL     MVC   MNEMONIC(3),=C'BL '     SET EXT MNEMONIC            -EU-\n         B     BCXBRTS                 CONTINUE                    -EU-\nCPBH     MVC   MNEMONIC(3),=C'BH '     SET EXTENDED MNEMONIC       -EU-\nBCXBRTS  CLI   TEXT,X'07'              IS BCR OP CODE              -EU-\n         BNE   BCXTFIN                 NO, CONTINUE                -EU-\n         CLI   MNEMONIC+2,C' '         SET REGISTER MNEMONIC       -EU-\n         BNE   *+L'*+8                                             -EU-\n         MVI   MNEMONIC+2,C'R'                                     -EU-\n         B     BCRTFIN                 CONTINUE                    -EU-\n         MVI   MNEMONIC+3,C'R'                                     -EU-\n         B     BCRTFIN                 CONTINUE\n         EJECT ,                                                   -EU-\n****************************************************************** -EU-\n*                                                                * -EU-\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RRE-TYPE * -EU-\n* INSTRUCTIONS OF THE 2 REGISTERS VARIETY.                       * -EU-\n*                                                                * -EU-\n****************************************************************** -EU-\n         SPACE 1                                                   -EU-\nRREOPND  CLI   TEXT+2,0                BYTE 2 OF INSTR IS ZERO     -EU-\n         BNE   4(R9)                   NO, NOT INSTRUCTION         -EU-\n         TM    IEDT,E1R                1 REGISTER                  -EU-\n         BZ    *+L'*+8                 NO                          -EU-\n         TM    TEXT+3,X'0F'            R2 IS ZERO                  -EU-\n         BNZ   4(R9)                   NO, NOT INSTRUCTION         -EU-\n         XR    R1,R1                   CLEAR WORK                  -EU-\n         IC    R1,TEXT+3               GET R1R2                    -EU-\n         SRL   R1,4                    SHIFT OUT R2                -EU-\n         CVD   R1,DBLWD                CONVERT                     -EU-\n         OI    DBLWD+7,X'0F'           CLEAR SIGN                  -EU-\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK                      -EU-\n         MVI   OPNDS,C'R'              BEGIN 1ST OPERAND           -EU-\n         LA    R15,OPNDS+1             SET 1ST OPERAND POS         -EU-\n         CH    R1,H10                  R1 < 10                     -EU-\n         BL    RRE11                   YES, 0-9                    -EU-\n         MVC   0(2,R15),DBLWD          NO, MOVE REG 10-15          -EU-\n         LA    R15,2(R15)              TO NEXT POS                 -EU-\n         B     RRE1T                   CLEAR WORK                  -EU-\nRRE11    MVC   0(1,R15),DBLWD+1        MOVE REG 0-9                -EU-\n         LA    R15,1(R15)              TO NEXT POS                 -EU-\nRRE1T    TM    IEDT,E1R                1 REGISTER                  -EU-\n         BO    0(R9)                   YES, EXIT                   -EU-\n         MVC   0(2,R15),=C',R'         DELIMITERS 2ND OPERAND      -EU-\n         PACK  DBLWD(1),TEXT+3(1)      FLIP 4TH BYTE               -EU-\n         XR    R1,R1                   CLEAR WORK                  -EU-\n         IC    R1,DBLWD                GET R2R1                    -EU-\n         SRL   R1,4                    SHIFT OUT R1                -EU-\n         CVD   R1,DBLWD                CONVERT                     -EU-\n         OI    DBLWD+7,X'0F'           CLEAR SIGN                  -EU-\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK                      -EU-\n         CH    R1,H10                  R2 < 10                     -EU-\n         BL    RRE21                   YES, 0-9                    -EU-\n         MVC   2(2,R15),DBLWD          NO, MOVE REG 10-15          -EU-\n         BR    R9                      EXIT                        -EU-\nRRE21    MVC   2(1,R15),DBLWD+1        MOVE REG 0-9                -EU-\n         BR    R9                      EXIT                        -EU-\n         EJECT\n******************************************************************\n*                                                                *\n* VALIDATE AND FORMAT SVC INSTRUCTIONS. IF THE SVC OP-CODE IS    *\n* FOUND IN THE SVC TABLE, IT IS ACCEPTED AS AN SVC, AND THE TABLE*\n* LITERAL IS MOVED TO THE COMMENTS FIELD OF THE INSTRUCTION.     *\n*                                                                *\n******************************************************************\n         SPACE 1\nSVCOPND  L     R1,SVCOPAD              GET SVC TABLE ADDRESS       -EU-\nSVCKND   CLI   0(R1),X'FF'             END OF SVC TABLE\n         BE    NOTSVC                  YES, MUST NOT BE SVC\n         CLC   0(1,R1),TEXT+1          THIS THE ENTRY\n         BE    GOTSVC                  YES\n         BH    NOTSVC                  NO, MUST NOT BE SVC         -EU-\n         AH    R1,SVCOPL               STEP TO NEXT ENTRY          -EU-\n         B     SVCKND                  LOOP THRU TABLE\nNOTSVC   B     4(R9)                   ERROR RETURN\nGOTSVC   MVC   COMMENT(14),1(R1)       COMMENT TO WORK AREA\n         XR    R1,R1                   CLEAR WORK\n         IC    R1,TEXT+1               GET SVC OPERAND\n         CVD   R1,DBLWD                CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK\n         CH    R1,H100                 OPERAND > 100\n         BL    SVCK10                  YES\n         MVC   OPNDS(3),DBLWD          MOVE 3-DIGIT OPERAND\n         B     SVCXIT                  EXIT\nSVCK10   CH    R1,H10                  OPERAND < 10\n         BL    SVCL10                  YES\n         MVC   OPNDS(2),DBLWD+1        MOVE 2-DIGIT OPERAND\n         B     SVCXIT                  EXIT\nSVCL10   MVC   OPNDS(1),DBLWD+2        MOVE 1-DIGIT OPERAND\nSVCXIT   BR    R9                      EXIT\n         EJECT\n******************************************************************\n*                                                                *\n* BUILD EQU STATEMENTS USING THE LABEL TABLE ENTRY ADDRESSED BY  *\n* REG 6 ON ENTRY.                                                *\n*                                                                *\n******************************************************************\n         SPACE 1                                                 *\nEQUSTMT  ST    R9,EQU9                 SAVE RETURN ADDR\n         USING LABELD,R6\n         MVC     NAME,LBLNAME          NAME TO EQU STMT\n         MVC   MNEMONIC,=CL5'EQU'      BUILD EQU STATEMENT\n         MVI   OPNDS,C'*'              SET EQU OPERAND\n         CLI   LBLLEN,1                LENGTH 0 OR 1\n         BNH   CCXEQU                  YES\n         XR    R9,R9                   CLEAR WORK\n         IC    R9,LBLLEN               GET LENGTH\n         CVD   R9,DBLWD                CONVERT\n         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK\n         OI    DBLWD+2,C'0'            CLEAR SIGN\n         CH    R9,H100                 LENGTH < 100\n         BL    CCXQ10                  YES\n         MVC   OPNDS+2(3),DBLWD        MOVE LENGTH\n         B     CCXEQC                  GO SET COMMA\nCCXQ10   CH    R9,H10                  LENGTH < 10\n         BL    CCXQ1                   YES\n         MVC   OPNDS+2(2),DBLWD+1      MOVE 2-DIGIT LENGTH\n         B     CCXEQC                  GO SET COMMA\nCCXQ1    MVC   OPNDS+2(1),DBLWD+2      MOVE 1-DIGIT LENGTH\nCCXEQC   MVI   OPNDS+1,C','            SET COMMA\nCCXEQU   BAS   R9,WRTOUT               OUTPUT EQU STATEMENT\n         BAS   R9,PRINT                GO PRINT IT\n         L     R9,EQU9                 GET RETURN ADDR\n         BR    R9                      RETURN\n         DROP  R6\n         EJECT\n******************************************************************\n*                                                                *\n* BUILDS STORAGE OPERANDS CONTAINING BASE, DISPLACEMENT, AND     *\n* LENGTH. ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS, AND REG 10 *\n* CONTAINS THE LENGTH. THE SCHLBL ROUTINE IS CALLED TO CREATE A  *\n* LABEL REFERENCE, IF THE BASE REG IS CURRENT, AND A LABEL EXISTS*\n* IF SCHLBL IS UNSUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM     *\n* DDDD(LLL,RRR) IS CREATED.                                      *\n* IF 2-REGS SS FORMAT, LLL IS A REGISTER, NOT A LENGTH.          * -EU-\n*                                                                *\n******************************************************************\n         SPACE 1\nBDLADR   ST    R9,BDL9                 SAVE RETURN ADDR\n         XR    R0,R0                   CLEAR WORK REG\n         LR    R1,R11                  COPY BDDD ADDRESS\n         SLDL  R0,20                   BASE REG TO R0\n         LTR   R0,R0                   IS BASE REG 0\n         BNZ   BDLSCHL                 NO\n         SRL   R1,20                   RIGHT JUSTIFY DISPL\n         CH    R1,H16                  REFERENCE TO CVT ADDR\n         BE    BDLCVTR                 YES\n         CH    R1,H76                  REF TO ALTERNATE CVT ADDR\n         BE    BDLCVTR                 YES\n         MVC   COMMENT(13),=C'PSA REFERENCE'\n         B     BDLSCHL                 CONTINUE\nBDLCVTR  MVC   COMMENT(11),=C'CVT ADDRESS'\nBDLSCHL  BAS   R9,SCHLBL               SEARCH FOR LABEL\n         B     BDLGLBL                 BRANCH IF LABEL FOUND\n         LR    R1,R11                  COPY BDDD ADDRESS\n         SLL   R1,20                   SHIFT OUT B\n         SRL   R1,20                   RIGHT JUSTIFY DDD\n         CVD   R1,DBLWD                CONVERT DDD\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK\n         MVC   OPNDWK,BLANX            CLEAR WORK AREA\n         CH    R1,H1000                DISPL < 1000\n         BL    BDLD100                 YES\n         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL\n         LA    R1,OPNDWK+4             TO NEXT POS\n         B     BDLLPN                  CONTINUE\nBDLD100  CH    R1,H100                 DISPL < 100\n         BL    BDLD10                  YES\n         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL\n         LA    R1,OPNDWK+3             TO NEXT POS\n         B     BDLLPN                  CONTINUE\nBDLD10   CH    R1,H10                  DISPL < 10\n         BL    BDLD1                   YES\n         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL\n         LA    R1,OPNDWK+2             TO NEXT POS\n         B     BDLLPN                  CONTINUE\nBDLD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL\n         LA    R1,OPNDWK+1             TO NEXT POS\nBDLLPN   MVI   0(R1),C'('              LEFT PAREN DELIMITER\n         CLI   INSTYP,SSR              2-REGS SS FORMAT            -EU-\n         BNE   BDLLGEN                 NO                          -EU-\n         LA    R1,1(R1)                TO NEXT POSITION            -EU-\n         MVI   0(R1),C'R'              SET REGISTER                -EU-\n         B     BDLSET                                              -EU-\nBDLLGEN  LA    R10,1(R10)              COMPUTE ACTUAL LENGTH       -EU-\nBDLSET   CVD   R10,DBLWD               CONVERT                     -EU-\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK\n         CH    R10,H100                LENGTH < 100\n         BL    BDLL10                  YES\n         MVC   1(3,R1),DBLWD           MOVE 3-DIGIT LENGTH\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDLCMA                  CONTINUE\nBDLL10   CH    R10,H10                 LENGTH < 10\n         BL    BDLL1                   YES\n         MVC   1(2,R1),DBLWD+1         MOVE 2-DIGIT LENGTH\n         LA    R1,3(R1)                TO NEXT POS\n         B     BDLCMA                  CONTINUE\nBDLL1    MVC   1(1,R1),DBLWD+2         MOVE 1-DIGIT LENGTH\n         LA    R1,2(R1)                TO NEXT POS\nBDLCMA   MVC   0(2,R1),=C',R'          DELIMITERS\n         SRL   R11,12                  RT JUSTIFY BASE REG\n         CVD   R11,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R11,H10                 REG < 10\n         BL    BDLR1                   YES\n         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT REGISTER\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDLRPN                  CONTINUE\nBDLR1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT REG\n         CLI   INSTYP,SSR              2-REGS SS FORMAT            -EU-\n         BE    BDLB1                   YES                         -EU-\n         CLI   2(R1),C'0'              IS REG = 0\n         BNE   BDLB1                   NO\n         MVC   0(2,R1),BLANX           YES, BLANK IT\n***      BCTR  R1,0                    BACK UP 1            FIX***\n         B     BDLRPN                  CONTINUE\nBDLB1    LA    R1,3(R1)                TO NEXT POS\nBDLRPN   MVI   0(R1),C')'              FINAL DELIMITER\n         LR    R10,R1                  COPY END ADDRESS\n         S     R10,OWSTRT              COMPUTE OPERAND LENGTH CODE\n         L     R9,BDL9                 GET RETURN ADDR\n         BR    R9                      EXIT\n         USING LABELD,R12\nBDLGLBL  MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK\n         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER\nBDLGRHE  CLI   0(R1),C' '              AT RHE\n         BNE   BDLGCKLN                YES\n         BCT   R1,BDLGRHE              LOOP TO RHE\nBDLGCKLN CLI   INSTYP,SSR              2-REGS SS FORMAT            -EU-\n         BNE   BDLLGGN                 NO                          -EU-\n         MVC   1(2,R1),=C'(R'          YES, DELIMITER              -EU-\n         LA    R1,1(R1)                ONE POSITION MORE           -EU-\n         B     BDLRGN                                              -EU-\nBDLLGGN  LA    R10,1(R10)              COMPUTE ACTUAL LENGTH       -EU-\n         CLM   R10,B'0001',LBLLEN      LBL AND INSTR LENGTHS SAME  -EU-\n         BE    BDLGCMP                 YES\n         MVI   1(R1),C'('              NO, DELIMITER\nBDLRGN   CVD   R10,DBLWD               CONVERT LENGTH              -EU-\n         UNPK  DBLWD(3),DBLWD+5(3)     UNPACK\n         OI    DBLWD+2,C'0'            CLEAR SIGN\n         CH    R10,H100                LENGTH < 100\n         BL    BDLG10                  YES\n         MVC   2(3,R1),DBLWD           MOVE 3-DIGIT LENGTH\n         LA    R1,5(R1)                TO NEXT POS\n         B     BDLGRPN                 CONTINUE\nBDLG10   CH    R10,H10                 LENGTH < 10\n         BL    BDLG1                   YES\n         MVC   2(2,R1),DBLWD+1         MOVE 2-DIGIT LENGTH\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDLGRPN                 CONTINUE\nBDLG1    MVC   2(1,R1),DBLWD+2         MOVE 1-DIGIT LENGTH\n         LA    R1,3(R1)                TO NEXT POS\nBDLGRPN  MVI   0(R1),C')'              FINAL DELIMITER\nBDLGCMP  LR    R10,R1                  COPY END ADDRESS\n         S     R10,OWSTRT              COMPUTE LENGTH CODE\n         L     R12,SLSAV+12            RESTORE R12\n         L     R9,BDL9                 GET RETURN ADDR\n         BR    R9                      EXIT\n         DROP  R12\n         EJECT\n******************************************************************\n*                                                                *\n* BUILDS STORAGE OPERANDS CONTAINING BASE AND DISPLACEMENT.      *\n* THE SCHLBL ROUTINE IS CALLED TO SEE WHETHER A LABEL REFERENCE  *\n* MAY BE USED, RATHER THAN AN EXPLICIT ADDRESS. IF LBLSCH IS NOT *\n* SUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM DDDD(RRR) IS FORMED*\n* ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS.                    *\n*                                                                *\n******************************************************************\n         SPACE 1\nBDADR    ST    R9,BD9                  SAVE RETURN ADDR\n         XR    R0,R0                   CLEAR WORK REG\n         LR    R1,R11                  COPY BDDD ADDRESS\n         SLDL  R0,20                   BASE REG TO R0\n         LTR   R0,R0                   IS BASE REG 0\n         BNZ   BDSCHL                  NO\n         CLI   TEXT,X'9F'              I/O OPERATION?              -EU-\n         BH    BDSADR1                 NO                          -EU-\n         CLI   TEXT,X'9C'              I/O OPERATION?              -EU-\n         BNL   BDAIO                   YES                         -EU-\n         CLI   TEXT,X'8F'              SHIFT OPERATION?          FIX***\n         BH    BDSADR1                 NO                        FIX***\n         CLI   TEXT,X'88'              SHIFT OPERATION?          FIX***\n         BNL   BDSCHL                  YES                       FIX***\nBDSADR1  SRL   R1,20                   RIGHT JUSTIFY DISPL       FIX***\n         CH    R1,H16                  REFERENCE TO CVT ADDR\n         BE    BDCVTR                  YES\n         CH    R1,H76                  REF TO ALTERNATE CVT ADDR\n         BE    BDCVTR                  YES\n         MVC   COMMENT(13),=C'PSA REFERENCE'\n         B     BDSCHL                  CONTINUE\nBDCVTR   MVC   COMMENT(11),=C'CVT ADDRESS'\nBDSCHL   BAS   R9,SCHLBL               GO SEARCH FOR LABEL\n         B     BDGLBL                  BRANCH IF FOUND\n         LR    R1,R11                  COPY BDDD ADDRESS\n         SLL   R1,20                   SHIFT OUT B\n         SRL   R1,20                   RIGHT JUSTIFY DDD\n         CVD   R1,DBLWD                CONVERT DISPL\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK\n         CH    R1,H1000                DISPL < 1000\n         BL    BDAD100                 YES\n         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL\n         LA    R1,OPNDWK+4             TO NEXT POS\n         B     BDALPN                  CONTINUE\nBDAD100  CH    R1,H100                 DISPL < 100\n         BL    BDAD10                  YES\n         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL\n         LA    R1,OPNDWK+3             TO NEXT POS\n         B     BDALPN                  CONTINUE\nBDAD10   CH    R1,H10                  DISPL < 10\n         BL    BDAD1                   YES\n         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL\n         LA    R1,OPNDWK+2             TO NEXT POS\n         B     BDALPN                  CONTINUE\nBDAD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL\n         LA    R1,OPNDWK+1             TO NEXT POS\nBDALPN   MVC   0(2,R1),=C'(R'          DELIMITERS\n         SRL   R11,12                  RT JUSTIFY BASE REG\n         CVD   R11,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R11,H10                 BASE REG < 10\n         BL    BDAR1                   YES\n         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT BASE REG\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDARPN                  CONTINUE\nBDAR1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT BASE REG\n         LA    R1,3(R1)                TO NEXT POS\nBDARPN   MVI   0(R1),C')'              FINAL DELIMITER\n         LR    R2,R1                   COPY END ADDRESS\n         SH    R2,H4                   BACK UP 4\n         CLC   1(4,R2),=C'(R0)'        BASE REG IS ZERO\n         BNE   BDCE                    NO\n         MVC   1(4,R2),BLANX           CLEAR BASE REG\n         LR    R1,R2                   COPY NEW END ADDR\nBDCE     LR    R10,R1                  COPY END ADDR\n         S     R10,OWSTRT              COMPUTE LENGTH CODE\n         L     R9,BD9                  GET RETURN ADDR\n         BR    R9                      EXIT\n         USING LABELD,R12\nBDGLBL   MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK\n         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER\nBDGRHE   CLI   0(R1),C' '              AT RHE\n         BNE   BDGCMP                  YES\n         BCT   R1,BDGRHE               LOOP TO RHE\nBDGCMP   LR    R10,R1                  COPY END ADDRESS\n         S     R10,OWSTRT              COMPUTE LENGTH CODE\n         L     R12,SLSAV+12            RESTORE R12\n         L     R9,BD9                  GET RETURN ADDR\n         BR    R9                      EXIT\nBDAIO    MVC   OPNDWK(2),=C'X'''       DELIMITERS                  -EU-\n         LA    R12,TEXT+2              @ OPERAND                   -EU-\n         BAS   R9,HEXPRT2              CONVERT TO PRINTABLE        -EU-\n         MVC   OPNDWK+2(3),PRTABL+1    HEX TO OPERAND              -EU-\n         MVI   OPNDWK+5,C''''          ENDING QUOTE                -EU-\n         LA    R10,5                   LENGTH CODE                 -EU-\n         L     R12,SLSAV+12            RESTORE R12                 -EU-\n         L     R9,BD9                  GET RETURN ADDR             -EU-\n         BR    R9                      EXIT                        -EU-\n         EJECT\n******************************************************************\n*                                                                *\n* BUILDS STORAGE OPERANDS CONTAINING BASE, DISPLACEMENT, AND     *\n* INDEX. ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS, AND REG 10  *\n* CONTAINS THE INDEX. THE SCHLBL ROUTINE IS CALLED TO CREATE A   *\n* LABEL REFERENCE, IF THE BASE REG IS CURRENT, AND A LABEL EXISTS*\n* IF SCHLBL IS UNSUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM     *\n* DDDD(XXX,RRR) IS CREATED.                                      *\n*                                                                *\n******************************************************************\n         SPACE 1\nBDXADR   ST    R9,BDX9                 SAVE RETURN ADDR\n         LTR   R10,R10                 ANY INDEX REG\n         BNZ   BDXSCHL                 YES\n         XR    R0,R0                   CLEAR WORK REG\n         LR    R1,R11                  COPY BDDD ADDRESS\n         SLDL  R0,20                   BASE REG TO R0\n         LTR   R0,R0                   IS BASE REG 0\n         BNZ   BDXSCHL                 NO\n         CLI   TEXT,X'41'              IS IT LA\n         BE    BDXSCHL                 YES\n         SRL   R1,20                   RIGHT JUSTIFY DISPL\n         CH    R1,H16                  REFERENCE TO CVT ADDR\n         BE    BDXCVTR                 YES\n         CH    R1,H76                  REF TO ALTERNATE CVT ADDR\n         BE    BDXCVTR                 YES\n         MVC   COMMENT(13),=C'PSA REFERENCE'\n         B     BDXSCHL                 CONTINUE\nBDXCVTR  MVC   COMMENT(11),=C'CVT ADDRESS'\nBDXSCHL  BAS   R9,SCHLBL               GO SEARCH FOR LABEL\n         B     BDXGLBL                 BRANCH IF FOUND\n         LR    R1,R11                  COPY BDDD ADDRESS\n         SLL   R1,20                   SHIFT OUT BASE REG\n         SRL   R1,20                   RIGHT JUSTIFY DISPL\n         SRL   R11,12                  RT JUSTIFY BASE REG\n         CVD   R1,DBLWD                CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK\n         CH    R1,H1000                DISPL < 1000\n         BL    BDXD100                 YES\n         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL\n         LA    R1,OPNDWK+4             TO NEXT POS\n         B     BDXLPN                  CONTINUE\nBDXD100  CH    R1,H100                 DISPL < 100\n         BL    BDXD10                  YES\n         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL\n         LA    R1,OPNDWK+3             TO NEXT POS\n         B     BDXLPN                  CONTINUE\nBDXD10   CH    R1,H10                  DISPL < 10\n         BL    BDXD1                   YES\n         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL\n         LA    R1,OPNDWK+2             TO NEXT POS\n         B     BDXLPN                  CONTINUE\nBDXD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL\n         LA    R1,OPNDWK+1             TO NEXT POS\nBDXLPN   LTR   R10,R10                 ANY INDEX REG\n         BNZ   BDXLPNR                 YES\n         LTR   R11,R11                 ANY BASE REG\n         BNZ   PREPB                   YES\n         BCTR  R1,0                    NO, BACK UP TO RHE\n         B     BDXCE                   CONTINUE\nPREPB    TM    TEXT+2,X'F0'            REALLY B REG                -EU-\n         BZ    PREPX                   NO                          -EU-\n         MVC   0(3,R1),=C'(,R'         DELIMITERS\n         LA    R1,1(R1)                STEP OVER 1 BYTE\n         B     BDXCBAS                 CONTINUE\nPREPX    LR    R10,R11                 REVERSE                     -EU-\n         XR    R11,R11                                             -EU-\nBDXLPNR  MVC   0(2,R1),=C'(R'          DELIMITERS\n         CVD   R10,DBLWD               CONVERT INDEX REG\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R10,H10                 INDEX REG < 10\n         BL    BDXX1                   YES\n         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT INDEX REG\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDXCMA                  CONTINUE\nBDXX1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT INDEX REG\n         LA    R1,3(R1)                TO NEXT POS\nBDXCMA   LTR   R11,R11                 ANY BASE REG\n         BZ    BDXRPN                  NO\n         MVC   0(2,R1),=C',R'          DELIMITERS\nBDXCBAS  CVD   R11,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R11,H10                 BASE REG < 10\n         BL    BDXB1                   YES\n         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT BASE REG\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDXRPN                  CONTINUE\nBDXB1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT BASE REG\n         LA    R1,3(R1)                TO NEXT POS\nBDXRPN   MVI   0(R1),C')'              FINAL DELIMITER\nBDXCE    LR    R10,R1                  COPY END ADDR\n         S     R10,OWSTRT              COMPUTE LENGTH CODE\n         L     R9,BDX9                 GET RETURN ADDR\n         BR    R9                      EXIT\n         USING LABELD,R12\nBDXGLBL  MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK\n         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER\nBDXGRHE  CLI   0(R1),C' '              AT RHE\n         BNE   BDXGCKLN                YES\n         BCT   R1,BDXGRHE              LOOP TO RHE\nBDXGCKLN LTR   R10,R10                 ANY INDEX REGISTER\n         BZ    BDXGCMP                 NO\n         MVI   1(R1),C'('              YES, DELIMITER\n         CVD   R10,DBLWD               CONVERT LENGTH\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         OI    DBLWD+1,C'0'            CLEAR SIGN\nBDXG10   CH    R10,H10                 LENGTH < 10\n         BL    BDXG1                   YES\n         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT LENGTH\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDXGRPN                 CONTINUE\nBDXG1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT LENGTH\n         LA    R1,3(R1)                TO NEXT POS\nBDXGRPN  MVI   0(R1),C')'              FINAL DELIMITER\nBDXGCMP  LR    R10,R1                  COPY END ADDRESS\n         S     R10,OWSTRT              COMPUTE LENGTH CODE\n         L     R12,SLSAV+12            RESTORE R12\n         L     R9,BDX9                 GET RETURN ADDR\n         BR    R9                      EXIT\n         SPACE 2\n******************************************************************\n*                                                                *\n* WRITE OUTPUT TO SYSPUNCH.                                      *\n*                                                                *\n******************************************************************\n         SPACE 1\nWRTOUT   L     R1,PUNCHDCB             @ SYSPUNCH DCB\n         MVC   PRT(80),WORKREC         SAVE IN PRINT\n         TM    48(R1),X'10'            IS FILE OPEN\n         BZ    CLRWKR                  NO\n         AP    CARDNO,=P'10'           INCREMENT CARD NO\n         UNPK  SEQNBR,CARDNO           UNPACK INTO CARD\n         OI    SEQNBR+7,C'0'           CLEAR SIGN\n         PUT   (1),WORKREC             WRITE SOURCE CARD\nCLRWKR   MVC   WORKREC,BLANX           CLEAR OUTPUT RECORD\n         BR    R9                      RETURN\n         EJECT\n******************************************************************\n*                                                                *\n* SEARCHES THE BASE REGISTER TABLE TO FIND THE BASE REGISTER     *\n* ASSOCIATED WITH THE BDDD OPERAND ADDRESS PASSED IN REG 11 ON   *\n* ENTRY. IF THE BASE REGISTER GIVEN IS NOT A CURRENT BASE REG    *\n* THE UNSUCCESSFUL RETURN IS MADE TO 4 BYTES PAST THE ADDRESS    *\n* IN REG 9 ON ENTRY. WHEN THE CURRENT BASE REGISTER ENTRY IS FOR *\n* A PROGRAM BASE REG, THE DISPLACEMENT IS ADDED TO THE ASSUMED   *\n* BASE REGISTER VALUE IS ADDED TO THE DISPLACEMENT TO GIVE AN    *\n* OFFSET IN THE PROGRAM. THE LABEL TABLE IS SEARCHED FOR AN ENTRY*\n* WITH THIS OFFSET, AND IF FOUND, IS RETURNED TO THE CALLER. WHEN*\n* THE BASE REGISTER FOUND IS FOR A DSECT, THE DSECT HEADER ENTRY *\n* ADDRESS IS GIVEN IN THE BASE TABLE ENTRY. THE DSECT HEADER HAS *\n* THE ADDRESS OF THE FIELD DEFINITION TABLE FOR THE DSECT. THE   *\n* FIELD DEFINITION TABLE IS SEARCHED FOR AN ENTRY HAVING THE     *\n* DISPLACEMENT IN THE BDDD INSTRUCTION, AND IF FOUND IS PASSED   *\n* BACK TO THE CALLER. IF THE LABEL/FIELD TABLE SEARCHES ARE      *\n* UNSUCCESSFUL, RETURN IS TO 4 BYTES PAST REG 9.                 *\n*                                                                *\n******************************************************************\n         SPACE 1\nSCHLBL   TM    MORUSG,X'80'            ANY BASES ACTIVE\n         BZ    4(R9)                   NO, UNSUCCESSFUL EXIT\n         STM   R9,R12,SLSAV            YES, SAVE REGS USED\n         LR    R12,R11                 COPY BDDD ADDRESS\n         SRL   R12,12                  CLEAR WORK REG\n         LTR   R12,R12                 IS BASE REG ZERO\n         BZ    SCHNF                   YES, NO LABEL\n         MH    R12,USGLEN              BASE X BASE TBL ENTRY LENG\n         AL    R12,=A(BASES)           @ BASE TBL ENTRY\n         USING USINGD,R12\n         CLI   USTYPE,0                ENTRY IN USE\n         BE    SCHNF                   NO, EXIT\n         LR    R9,R11                  COPY BDDD ADDRESS\n         SLL   R9,20                   SHIFT OUT BASE\n         SRL   R9,20                   RIGHT JUSTIFY DDD\n         ICM   R11,B'0111',USVALU      GET BASE REG VALUE\n         LA    R11,0(R11)              CLEAR HI-ORDER\n         CLI   USTYPE,C'P'             PROGRAM BASE REG\n         BE    PGMBASE                 YES\n         DROP  R12\n         LR    R12,R11                 COPY DSECT FIELD TBL ADDRESS\n         USING DSECTD,R12\nCKDSCTND CLM   R9,B'0111',DSOFSET      THIS THE ENTRY\n         BE    SCHFD                   YES\n         CLC   DSOFSET,HIVAL           NO, AT TABLE END\n         BE    SCHNF                   YES, NO LABEL FOUND\n         LA    R12,L'DSECT(R12)        STEP TO NEXT ENTRY\n         B     CKDSCTND                LOOP THRU DSECT FIELDS\nPGMBASE  AR    R9,R11                  COMPUTE OFFSET\n         DROP  R12\n         L     R12,LBLTBL              @ LABEL TABLE\n         USING LABELD,R12\nCKENTFD  CLM   R9,B'0111',LBLADR       THIS THE ENTRY\n         BE    SCHFD                   YES\n         LA    R12,L'LABEL(R12)        TO NEXT ENTRY\n         C     R12,CURRLBL             END OF TBL\n         BNL   SCHNF                   YES, NO LABEL\n         B     CKENTFD                 NO, CONTINUE SEARCH\nSCHNF    LM    R9,R12,SLSAV            NOT FOUND, RESTORE REGS\n         B     4(R9)                   NOT FOUND RETURN\nSCHFD    LM    R9,R11,SLSAV            FOUND RESTORE ALL BUT 12\n         BR    R9                      FOUND RETURN\n         DROP  R12\n         SPACE 2\n******************************************************************\n*                                                                *\n* PRINT A LINE USING THE SYSPRINT DCB DEFINED IN DISASM PHASE 0. *\n*                                                                *\n******************************************************************\n         SPACE 1\nPRINT    L     R1,PRINTDCB             @ SYSPRINT DCB\n         USING IHADCB,R1                                           -EU-\n         TM    DCBOFLGS,DCBOFOPN       IS SYSPRINT OPEN\n         BNO   CLRPRT                  NO\n         DROP  R1                                                  -EU-\n         PUT   (1),PRTLINE             WRITE PRINT LINE\nCLRPRT   MVC   PRT,BLANX               CLEAR PRINT LINE\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C' '                SINGLE SPACED\n         BE    SETSGL                  YES\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C'0'                DOUBLE SPACED\n         BE    SETSGL                  YES\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C'-'                TRIPLE SPACED\n         BE    SETSGL                  YES\n         ZAP   LINECT,P0               NO, MUST BE NEW PAGE\nSETSGL   MVI   PCC,C' '                SET SINGLE SPACING\n         CP    LINECT,P58              PAST END OF PAGE\n         BH    NEWPAGE                 YES\n         BR    R9                      EXIT\nNEWPAGE  MVI   PCC,C'1'                SET SKIP TO HOF\n         ZAP   LINECT,P0               RESET LINE COUNTER\n         BR    R9                      EXIT\n         EJECT\n******************************************************************\n*                                                                *\n* CONVERT HEX DATA TO PRINTABLE FORM: 2 CHARACTERS PER BYTE. ON  *\n* ENTRY, REG 12 CONTAINS THE ADDRESS OF THE LEFT END OF THE FIELD*\n* TO BE CONVERTED, AND THE ENTRY POINT USED DETERMINES THE LENGTH*\n* FORMATTED OUTPUT IS PLACED IN THE PRTABL FIELD.                *\n*                                                                *\n******************************************************************\n         SPACE 1\nHEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX\nHEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE\n         TR    PRTABL(8),TRTBL         MAKE PRINTABLE\n         BR    R9                      EXIT\n         SPACE 2\n******************************************************************\n*                                                                *\n* FORMATS THE HEX DATA CORRESPONDING TO THE FORMATTED INSTRUCTION*\n* BEING OUTPUT. PRINTABLE HEX IS PLACED AT THE RIGHT OF THE LINE *\n* ON THE SYSPRINT OUTPUT.                                        *\n*                                                                *\n******************************************************************\n         SPACE 1\nTXTFMT   ST    R9,TX9                  SAVE RETURN ADDR\n         LA    R11,PRT                 @ PRINT LINE\n         CLI   TYPE,1                  ADCON\n         BE    TFOFST                  YES\n         CLI   TYPE,2                  CONSTANT\n         BE    TFOFST                  YES\n         CLI   TYPE,X'0D'              INSTRUCTION\n         BNE   TXTCLEAN                NO\nTFOFST   LA    R12,OFFSET              @ OFFSET TO INSTR\n         BAS   R9,HEXPRT3              CONVERT TO PRINTABLE\n         MVC   PRT+80(6),PRTABL        OFFSET TO PRINT\n         LA    R12,LEN                 @ DATA LENGTH\n         BAS   R9,HEXPRT1              MAKE PRINTABLE\n         MVC   PRT+88(2),PRTABL        LENGTH TO PRINT\n         LA    R12,TEXT                @ TEXT TO PRINT\n         BAS   R9,HEXPRT4              CONVERT 1ST 4 BYTES\n         CLI   LEN,4                   IS IT 4 BYTES\n         BNL   TXT4                    YES, OR MORE\n         CLI   LEN,3                   IS IT 3 BYTES\n         BE    TXT3                    YES\n         CLI   LEN,2                   IS IT 2 BYTES\n         BE    TXT2                    YES\n         MVC   PRT+94(2),PRTABL        TEXT TO PRINT\n         B     TXTCLEAN                FINISH\nTXT2     MVC   PRT+94(4),PRTABL        TEXT TO PRINT\n         B     TXTCLEAN                FINISH\nTXT3     MVC   PRT+94(6),PRTABL        TEXT TO PRINT\n         B     TXTCLEAN                FINISH\nTXT4     MVC   PRT+94(8),PRTABL        TEXT TO PRINT\n         CLI   LEN,4                   IS IT 4 BYTES\n         BE    TXTCLEAN                YES, FINISH\n         LA    R12,TEXT+4              @ TEXT\n         BAS   R9,HEXPRT4              CONVERT\n         CLI   LEN,8                   8 BYTES OF TEXT\n         BE    TXT8                    YES\n         CLI   LEN,7                   7 BYTES OF TEXT\n         BE    TXT7                    YES\n         CLI   LEN,6                   6 BYTES OF TEXT\n         BE    TXT6                    YES\n         MVC   PRT+98(2),PRTABL        TEXT TO PRINT\n         B     TXTCLEAN                FINISH\nTXT6     MVC   PRT+102(4),PRTABL       TEXT TO PRINT\n         B     TXTCLEAN                FINISH\nTXT7     MVC   PRT+102(6),PRTABL       TEXT TO PRINT\n         B     TXTCLEAN                FINISH\nTXT8     MVC   PRT+102(8),PRTABL       TEXT TO PRINT\nTXTCLEAN XC    OFFSET,OFFSET           CLEAR\n         L     R9,TX9                  GET RETURN ADDR\n         BR    R9                      EXIT\n         EJECT\n******************************************************************\n*                                                                *\n* ENTERED WHENEVER THE CURRENT TEXT OFFSET IS PAST THE NEXCHG    *\n* FIELD VALUE. THIS ROUTINE CREATES DROP CARDS FOR EXHAUSTED BASE*\n* REGISTERS, AND USING STATEMENTS FOR NEW BASE REGISTERS. THE    *\n* BASES TABLE IS SCANNED, AND ANY ENTRY WHICH IS NO LONGER IN USE*\n* IS ZEROED OUT, AND A DROP RECORD IS CREATED. NEXT, THE USING   *\n* TABLE IS SCANNED. WHEN AN ENTRY IS FOUND WHICH IS VALID AT THE *\n* CURRENT OFFSET, THE BASE TABLE IS CHECKED. IF THE ENTRY IS NOT *\n* IN USE, A USING STATEMENT IN CREATED, AND THE USING TABLE ENTRY*\n* IS MOVED TO THE BASES TABLE. THE NEXCHG FIELD IS CHANGED TO    *\n* CONTAIN THE OFFSET AT WHICH THE NEXT SCAN MUST BE MADE. AN IND-*\n* ICATOR CALLED MORUSG IS SET TO SHOW WHEN ANY BASE REGISTERS ARE*\n* CURRENTLY IN USE. WHEN NO MORE REGISTERS ARE AVAILABLE, THE    *\n* NEXCHG FIELD IS SET TO HEX FF'S.                               *\n*                                                                *\n******************************************************************\n         SPACE 1\nNEXUSG   MVC   NEXCHG,HIVAL            RESET NEXT CHANGE ADDR\n         MVI   MORUSG,0                CLEAR BASE REG AVAIL INDIC\n         ST    R9,USG9                 SAVE RETURN ADDR\n         L     R2,=A(BASES)                                        -EU-\n         XC    0(L'USING,R2),0(R2)     CLEAR R0 ELEMENT            -EU-\n         MVC   16*L'USING(4,R2),HIVAL  SET TABLE STOPPER           -EU-\n         USING USINGD,R2\n         LA    R2,L'USING(R2)          @ R1'S ELEMENT              -EU-\nDRPCKND  CLI   0(R2),X'FF'             END OF TABLE\n         BE    USGUSG                  YES\n         CLC   USEND,XZROS             ENTRY USED\n         BE    DRPSTEP                 NO\n         CLC   TXTOFSET,USEND          PAST END OF THIS ONE\n         BL    DRPSTEP                 NO\n         MVC   MNEMONIC(4),=C'DROP'    OPERATION IS DROP\n         MVI   OPNDS,C'R'              DELIMITER FOR REGS\n         XR    R12,R12                 CLEAR WORK\n         IC    R12,USREG               GET REG\n         CVD   R12,DBLWD               CONVERT TO PACKED\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         OI    DBLWD+1,C'0'            CLEAR SIGN\n         CH    R12,H10                 REG < 10\n         BL    DPR1                    YES\n         MVC   OPNDS+1(2),DBLWD        MOVE REG NBR\n         B     WRTDROP                 GO WRITE DROP\nDPR1     MVC   OPNDS+1(1),DBLWD+1      MOVE 1-DIGIT REG\nWRTDROP  BAS   R9,WRTOUT               WRITE DROP RECORD\n         BAS   R9,PRINT                PRINT DROP RECORD\n         XC    USING,USING             CLEAR THE ENTRY\nDRPSTEP  LA    R2,L'USING(R2)          TO NEXT BASE ELEMENT\n         B     DRPCKND                 LOOP\nUSGUSG   L     R2,USGSTRT              GET FIRST USING TBL ADDR\nENDUS    CLI   0(R2),X'FF'             END OF TABLE\n         BE    XITUS                   YES\n         CLC   TXTOFSET,USEND          PAST END OF THIS ONE\n         BNL   ECSTEP                  YES\n         OI    MORUSG,X'01'            SHOW MORE BASES AVAIL\nUSBGCK   CLC   TXTOFSET,USBGN          CURR LOC BEFORE THIS\n         BNL   CKNEWLO                 NO\n         CLC   USBGN,NEXCHG            BEGINS BEFORE NEXT CHANGE\n         BNL   ECSTEP                  NO\n         MVC   NEXCHG,USBGN            YES, SET LOWER CHANGE OFFSET\n         B     ECSTEP                  CONTINUE\nCKNEWLO  CLC   USEND,NEXCHG            THIS ENTRY ENDS EARLIER\n         BNL   ECMVC                   NO\n         MVC   NEXCHG,USEND            YES, SET NEW END\nECMVC    XR    R1,R1                   CLEAR WORK\n         IC    R1,USREG                PICK UP REG\n         MH    R1,USGLEN               TIMES ENTRY LENGTH\n         AL    R1,=A(BASES)            @ BASE TABLE ENTRY          -EU-\n         OI    MORUSG,X'80'            SHOW BASE IN USE\n         CLC   USING,0(R1)             OLD AND NEW IDENTICAL\n         BE    ECSTEP                  YES\nMAKUSG   MVC   0(L'USING,R1),USING     NEW USING TO TABLE\n         MVC   MNEMONIC(5),=C'USING'   OPERATION IS USING\n         CLI   USTYPE,C'D'             IS IT A DSECT\n         BNE   CKUTPS                  NO\n         ICM   R12,B'0111',USVALU      YES, GET DSECT HEADER ADDR\n         L     R11,DTBSTRT             @ 1ST DSECT HEADER ENTRY\nDSCTEND  C     R11,DTBCURR             END OF TABLE\n         BH    MVDSNAME                YES\n         USING DTDS,R11                                            -EU-\n         CLM   R12,B'0111',DTADDR      THIS THE HEADER ENTRY       -EU-\n         BE    MVNAME                  YES                         -EU-\n         LA    R11,L'DTL(R11)          TO NEXT HEADER ENTRY        -EU-\n         B     DSCTEND                 LOOP THRU TABLE\nMVNAME   MVC   OPNDS(8),DTNAME         NAME TO OPERANDS            -EU-\n         B     MVDSNAME+L'MVDSNAME     CONTINUE                    -EU-\n         DROP  R11                                                 -EU-\nMVDSNAME MVC   OPNDS(8),0(R12)         DSECT NAME TO OPERANDS\n         LA    R12,OPNDS+7             TO END OF NAME\nUSFRHED  CLI   0(R12),C' '             FOUND RHE\n         BNE   USFMADD                 YES\n         BCT   R12,USFRHED             BACK UP 1 AND LOOP\nUSFMADD  LA    R12,1(R12)              TO NEXT BYTE\nUSFMCMA  MVC   0(2,R12),=C',R'         DELIMITERS\n         XR    R11,R11                 CLEAR WORK\n         IC    R11,USREG               GET REGISTER NBR\n         CVD   R11,DBLWD               CONVERT TO PACKED\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK REG NBR\n         OI    DBLWD+1,C'0'            CLEAR SIGN\n         CH    R11,H10                 REG < 10\n         BL    USFMR1                  YES\n         MVC   2(2,R12),DBLWD          MOVE 2-DIGIT REG NBR\n         B     USINGOUT                GO WRITE USING\nUSFMR1   MVC   2(1,R12),DBLWD+1        MOVE 1-DIGIT REG NBR\nUSINGOUT BAS   R9,WRTOUT               WRITE USING STMT\n         BAS   R9,PRINT                PRINT USING STMT\n         B     ECSTEP                  CONTINUE\nCKUTPS   CLC   USVALU,TXTOFSET         USING AT CURR LOC\n         BNE   USFMLBL                 NO\n         MVI   OPNDS,C'*'              SET CURRENT LOC SYMBOL IN OPERAN\n         LA    R12,OPNDS+1             GET NEXT POS ADDR\n         B     USFMCMA                 GO FORMAT REG\nUSFMLBL  L     R12,LBLTBL              @ LABEL TABLE               -EU-\n         USING LABELD,R12                                          -EU-\nUSLBSCH  CLC   USVALU,LBLADR           THIS THE ENTRY              -EU-\n         BNE   USLBNXT                 YES                         -EU-\n         CLI   LBLTYP,C'L'             TYPE LABEL                  -EU-\n         BE    USLBFND                 YES                         -EU-\nUSLBNXT  LA    R12,L'LABEL(R12)        TO NEXT ENTRY               -EU-\n         C     R12,CURRLBL             END OF TBL                  -EU-\n         BNL   USLBSCN                 YES, NO LABEL               -EU-\n         B     USLBSCH                 NO, CONTINUE SEARCH         -EU-\nUSLBFND  MVC   OPNDS(8),LBLNAME                                    -EU-\n         DROP  R12                                                 -EU-\n         LA    R12,OPNDS               SET NEXT LOC                -EU-\nUSLBSNL  CLI   0(R12),C' '                                         -EU-\n         BE    USFMCMA                 GO FORMAT REG               -EU-\n         LA    R12,1(R12)                                          -EU-\n         B     USLBSNL                                             -EU-\nUSLBSCN  MVI   OPNDS,C'A'              SET 1ST CHAR OF LABEL NAME\n         LA    R12,USVALU              GET OFFSET\n         BAS   R9,HEXPRT3              CONVERT TO PRINTABLE\n         MVC   OPNDS+1(6),PRTABL       PRINTABLE HEX TO LABEL\n         LA    R12,OPNDS+7             TO NEXT LOC\n         B     USFMCMA                 FORMAT REG\nECSTEP   LA    R2,L'USING(R2)          TO NEXT USING ENTRY\n         B     ENDUS                   CONTINUE SCAN\n         DROP  R2                                                  -EU-\nXITUS    L     R9,USG9                 GET RETURN ADDR\n         BR    R9                      EXIT\n         EJECT\n******************************************************************\n*                                                                *\n* END OF PHASE 2 - RETURN TO PHASE 0                             *\n*                                                                *\n******************************************************************\n         SPACE 1\n         PRINT GEN                                                 -EU-\nEOJ      BAS   R9,FORCONST             YES, FORCE IT OUT\n         SVBCK ,                       RETURN TO CALLER            -EU-\n         EJECT\n         DEFCOM DSECT=YES                                          -EU-\n         EJECT  ,                                                  -EU-\n         DEFCDS ,                                                  -EU-\n         EJECT\nDISASM2  CSECT\n         SPACE 1\nOWSTRT   DC    A(OPNDWK)               @ OPERAND WORK AREA\nOPND9    DC    A(OPNDRTN)              RETURN ADDR FOR OPERAND ROUTINES\nUSG9     DC    F'0'                    RETURN SAVE\nEQU9     DC    F'0'                    RETURN ADDR FOR EQUSTMT\nFC6      DC    F'0'                    SAVE AREA FOR R6\nFC9      DC    F'0'                    FORCONST RETURN ADDR\nTX9      DC    F'0'                    RETURN ADDR FOR TXTFMT\nBD9      DC    F'0'                    RETURN FOR BDADR\nBDX9     DC    F'0'                    RETURN FOR BDXADR\nBDL9     DC    F'0'                    RETURN FOR BDLADR\nSLSAV    DC    4F'0'                   SAVE FOR SCHLBL\nILENG    DC    H'0'                    INSTRUCTION LENGTH  FIX***\nCONPROG  DC    X'00'                   CONSTANT IN PROGRESS INDIC\nCONPSLBL DC    0CL13' '                PSEUDO LABEL ENTRY FOR CONSTANTS\n         DC    XL4'0'\nCONNAME  DC    CL8' '                  CONSTANT NAME\nCONLLEN  DC    XL1'0'                  LABEL LENGTH\nCONTYPE  DC    CL1' '                  TYPE\nCCTYPE   DC    X'00'                   CC SET TYPE OF INSTR SETTING\nCONDATA  DC    0H'0',XL8'0'            CONSTANT DATA\nCONSYM   DC    CL8' '                  CONSTANT SYMBOL\nCONLEN   DC    H'0'                    CONSTANT LENGTH\nCONOFST  DC    F'0'                    RELATIVE OFFSET TO CONSTANT\nCONLOC   DC    F'0'                    @ CURRENT BYTE IN CONSTANT\nTXTOFST  DS    0F\n         DC    X'0'\nTXTOFSET DC    XL3'0'                  OFFSET TO TEXT BYTE\nOPNDWK   DC    CL13' '                 OPERAND BUILD AREA\nOFFSET   DC    XL3'0'                  OFFSET FROM PGM START\nINSTYP   DC    CL1' '                  INSTRUCTION TYPE\nTYPE     DC    XL1'0'                  TYPE CODE\n*                                       0=CSECT, 1=ADCON, 2=CONST\n*                                       E=USING, D=INSTRUCTION\n*                                       C=COMMENT, 9=ENTRY\n*                                       A=EQU\nLEN      DC    XL1'0'                  TEXT LENGTH\nTEXT     DC    XL8'0'                  TEXT\nMORUSG   DC    X'00'                   80=CURRENT BASE, 01=MORE BASES\nH1       DC    H'1'                    CONSTANT 1\nH2       DC    H'2'                    CONSTANT 2\nH4       DC    H'4'                    CONSTANT 4\nH7       DC    H'7'                    CONSTANT 7\nH8       DC    H'8'                    CONSTANT 8\nH10      DC    H'10'                   CONSTANT 10\nH11      DC    H'11'                   CONSTANT 11\nH13      DC    H'13'                   CONSTANT 13\nH14      DC    H'14'                   CONSTANT 14\nH16      DC    H'16'                   CONSTANT 16\nH76      DC    H'76'                   CONSTANT 76\nH100     DC    H'100'                  CONSTANT 100\nH1000    DC    H'1000'                 CONSTANT 1000\nP0       DC    P'0'                    CONSTANT 0\nP1       DC    P'1'                    CONSTANT 1\nP58      DC    P'58'                   CONSTANT 58\nUSGLEN   DC    0H'0',AL2(L'USING)      LENGTH OF USING TBL ENTRIES\nXZROS    DC    16X'00'                 CONSTANT ZEROS\nHIVAL    DC    4X'FF'                  CONSTANT X F'S\nNEXCHG   DC    XL3'00'                 OFFSET TO NEXT BASE REG CHG\nBLANX    DC    CL121' '                CONSTANT BLANKS\nTRTBL    DC    C'0123456789ABCDEF'     TRANSLATE TBL\nPRTABL   DC    CL9' '                  PRINTABLE HEX WORK\n         SPACE 2                                                   -EU-\n         DEFINS ,                                                  -EU-\n         EJECT\n         LTORG\n         EJECT ,                                                   -EU-\n* END OF BASE REGISTERS ADDRESSABILITY - - - - - - - - - - - - - - -EU-\n         SPACE 1                                                   -EU-\nRSMASKS  DC    C'0000',C'0001',C'0010',C'0011'   MASK BITS TABLE   -EU-\n         DC    C'0100',C'0101',C'0110',C'0111'                     -EU-\n         DC    C'1000',C'1001',C'1010',C'1011'                     -EU-\n         DC    C'1100',C'1101',C'1110',C'1111'                     -EU-\nBASES    DC    XL256'00'               BASE REG TABLE\nCHARTRAN DC    256X'FF'           TRT TABLE FOR CHAR/HEX DETERMINATION\n         ORG   CHARTRAN+C' '\n         DC    X'00'                   BLANK IS CHARACTER\n         ORG   CHARTRAN+C'A'\n         DC    9X'00'                  A-I ARE CHARACTERS\n         ORG   CHARTRAN+C'J'\n         DC    9X'00'                  J-R ARE CHARACTERS\n         ORG   CHARTRAN+C'S'\n         DC    8X'00'                  S-Z ARE CHARACTERS\n         ORG   CHARTRAN+C'0'\n         DC    10X'00'                 0-9 ARE CHARACTERS\n         ORG\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DOPROG": {"ttr": 6154, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94%\\x1f\\x00\\x94%\\x1f\\x16\\x16\\x05`\\x05`\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-09-08T00:00:00", "modifydate": "1994-09-08T16:16:00", "lines": 1376, "newlines": 1376, "modlines": 0, "user": "SYSPAJA"}, "text": "DOPG     TITLE '--- DOPROG TSO COMMAND PROCESSOR ---'\n*************************************************************JFS03NOV77\n*             LATEST UPDATE DATE   3, JUNE '83   RRS         JFS03NOV77\n*************************************************************JFS03NOV77\n         SPACE 1                                             JFS03NOV77\n* THE DOPROG TSO COMMAND WAS\n*        DESIGNED AND DEVELOPED BY J. SCHINDLER (CSC), MARCH 1975\n* THE DOPROG COMMAND IS BASED ON AN EARLIER VERSION THAT WAS\n*        DESIGNED AND DEVELOPED BY GENE CZARCINSKI\n*                                  NASA, GODDARD SPACE FLIGHT CENTER\n*                                  GREENBELT, MARYLAND\n*\n* UPDATED 10APR77, GENE CZARCINSKI, NASA/GSFC (GT00501)\n*       . RENAME CSECT FROM 'GSFTSODO' TO 'DOPROG' WITH AN\n*         ENTRY POINT OF DOPGM ... MORE CONSISTANCY AND\n*         CLEANER CMDLIB\n*       . CHANGE BASE REG INIT CODE .. IT IS FLAKY AND MAY CAUSE\n*         ERROR*********\n* UPDATED 03NOV77, J. SCHINDLER, (PAC) CSC\n*       . INCLUDED CODE SO THAT THE LATEST UPDATE DATE COULD BE\n*         CHANGED EASILY\n*       . CHANGED THE LOGIC SO THAT THE 2 BYTES FROM THE ATTACH\n*         ECB IS USED AS THE RETURN CODE THAT IS PASSED ON EXIT\n*         FROM THIS COMMAND PROCESSOR\n* UPDATED 18APR80, B. GODFREY, AFDSC\n*       . BALR TO IKJPARS INSTEAD OF LINK, FOR MVS\n*       . REPLACE REGS MACRO WITH 16 EQUATES\n*       . USE UPTPREFX INSTEAD OF PSCBUSER. ADDED IKJUPT MACRO.\n* UPDATED 03JUN83, DICK SZIEDE G.E.\n*       . ADD \"DOCP\" ALIAS, AND SUPPORT CODE TO INVOKE A COMMAND\n*         PROCESSOR. THIS ISN'T JOE'S \"DOCP,\" WHICH IS A STAND-ALONE\n*         CP, RATHER THAN AN ALIAS OF DOPROG. JOE USED TPUT-TGET TO\n*         PROMPT FOR THE COMMAND-LINE, WHICH I DIDN'T LIKE. THIS\n*         VERSION WILL TAKE A CP COMMAND-LINE IN QUOTES, OR WILL\n*         PROMPT WITH PUTGET IF IT DOESN'T FIND ONE. THUS WE CAN BE\n*         USED IN A CLIST.\n*\n* ORIGIN :       EXTRACTED FROM CBT TAPE 88 FEB, FILE 369.\n* ATTRIBUTE :    RENT\n* ALIAS :        DOCP\n* FURTHER UPDATES BY MOINIL P.A., COMPUTING CENTRE (TP 361)\n*                    J.R.C. - ISPRA ESTABLISHMENT\n*                    21020 ISPRA (VA), ITALY\n         EJECT\n* THIS COMMAND PROCESSOR IS DESIGNED TO LOAD AND EXECUTE (ATTACH) A\n*        PROGRAM OR A COMMAND IN ONE OF THE SYSTEM LINK LIBRARIES OR\n*        A USER LIBRARY (TASKLIB).\n* COMMAND SYNTAX :\n* ----------------\n* DOPROG/DOCP  LOAD-MOD-NAME  'PARMS'  TASKLIB/LIB('DSLIST')\n*              RC/NORC/ALLRC  AC\n*\n*        LOAD-MOD-NAME - NAME OF THE LOAD MODULE (PROGRAM OR COMMAND)\n*              TO BE EXECUTED.\n*\n*        'PARMS' - PARM-FIELD TO BE PASSED TO THE PROGRAM OR COMMAND\n*              LINE TO BE PASSED TO COMMAND PROCESSOR (QUOTED STRING).\n*\n*        TASKLIB('DSLIST') - SPECIFIES THE DATA-SET NAME(S) THAT ARE\n*              CONCATENATED AND USED FOR AS TASK LIBRARY, OR\n*        LIB('DSLIST') - ALIAS OF TASKLIB.\n*\n*        RC - SPECIFIES THAT THE NON-ZERO RETURN CODE FROM THE EXECUTED\n*              PROGRAM OR COMMAND IS TO BE VIEWED, OR\n*        NORC - SPECIFIES THAT THE RETURN CODE IS NOT TO BE VIEWED\n*              (DEFAULT), OR\n*        ALLRC - SPECIFIES THAT THE RETURN CODE IS TO BE VIEWED.\n*\n*        AC - SPECIFIES AUTHORIZED MODE (ONLY SYSTEM GROUP USER-ID'S\n*              ALLOWED).\n*\n* NOTE : THE RETURN CODE FROM THE EXECUTED PROGRAM OR COMMAND IS ALWAYS\n*        PASSED. IF THIS COMMAND PROCESSOR ENCOUNTERS AN ERROR OR AN\n*        ATTENTION IS ENTERED, THE RETURN CODE IS 16.\n         EJECT\nDOPROG   START 0\n         SPACE 1\n        $DEFREG\n* FLAGS SETTINGS :\n* ----------------\n*        1... .... - RC (PRINT NON-ZERO RETURN CODES)\n*        .1.. .... - ALLRC (PRINT ALL RETURN CODES)\n*        ..1. .... - TASKLIB SPECIFIED\n*        ...1 .... - DSNAME INPUT IN QUOTES\n*        ...  1... - AC(1) ON\n*        .... .111 - NOT USED\n         SPACE 1\n* FLAGS EQUATES :\n* ---------------\nRCFLG    EQU   B'10000000'    PRINT NON-ZERO RC FLAG\nALLRCFLG EQU   B'01000000'    PRINT ALL RC FLAG\nTASKFLG  EQU   B'00100000'    TASKLIB WAS SPECIFIED\nQFLG     EQU   B'00010000'    DSNAME WAS INPUT IN QUOTES FLAG\nACFLG    EQU   B'00001000'    AC(1) ON FLAG\nPECTFLG  EQU   B'00000010'    PROCESS ECT FLAG\nNOPDFLG  EQU   B'00000001'    ECTNOPD FLAG STATUS\n         SPACE 1\nLV0      EQU   0              AUTHORITY LEVEL DEFINITION : REJECT LEVEL\nAUTHC   $MDL@IX\n         EJECT\n        $XENT  BASE=(R10,R11),LV=WKLEN,TYPE=RENT\n         LR    R12,R13\n         USING WKAREA,R12\n         LR    R9,R1               SAVE ENTRY REGISTER (CPPL)\n        $TEW$EC REG=R9,MSG=PUTMSG,ERR=QUIT\n         USING CPPL,R9\n         SPACE 1\n*------- INIT PARSE PARM LIST (PPL).\n         SPACE 1\n         LA    R8,PARSEPL\n         USING PPL,R8\n         MVC   PPLUPT,CPPLUPT      USER PROFILE TABLE\n         MVC   PPLECT,CPPLECT      ENVIRONMENT CONTROL TABLE\n         LA    R0,ECB\n         ST    R0,PPLECB           ADDR OF ECB\n         LA    R0,ANSWER0\n         ST    R0,PPLANS           ADDR OF PDL\n         MVC   PPLCBUF,CPPLCBUF    COMMAND BUFFER\n         L     R1,CPPLCBUF         FIRST, DETERMINE IF WE'RE        RRS\n         AH    R1,2(R1)            A COMMAND PROCESSOR, QUIT IF NOT.RRS\n         BCTR  R1,0                                                 RRS\n         OC    0(5,R1),=CL8' '                                      RRS\n         LA    R15,4               4 ==> WE ARE DOPROG              RRS\n         CLC   0(5,R1),=CL5'DOCP ' R1 SHOULD POINT TO COMMAND THAT  RRS\n         BNE   *+L'*+8             INVOKED US.                      RRS\n         MVC   MYCPPL(CPPLLEN),CPPLCBUF COPY THE CPPL FOR LATER     RRS\n         XR    R15,R15             0 ==> WE ARE DOCP                RRS\n         ST    R15,MYCPSWIT                                         RRS\n         XC    PPLUWA,PPLUWA       USER WORK AREA ADDR\n         MVC   PPLPCL,=A(PPLPARM)  PARM CONTROL LIST\n         DROP  R8\n         SPACE 1\n*------- INIT STACK IOPL (IOPLIOPB WILL BE INIT BY STACK MACRO).\n         SPACE 1\n         LA    R8,STAKIOPL\n         USING IOPL,R8\n         MVC   IOPLUPT,CPPLUPT\n         MVC   IOPLECT,CPPLECT\n         LA    R0,STAKECB\n         ST    R0,IOPLECB\n         DROP  R8\n         SPACE 1\n*------- INIT IOPL.\n         SPACE 1\n         LA    R8,IOPLA\n         USING IOPL,R8\n         MVC   IOPLUPT,CPPLUPT\n         MVC   IOPLECT,CPPLECT\n         LA    R0,ECB\n         ST    R0,IOPLECB\n         DROP  R8\n         SPACE 1\n*------- INIT DAIR PARM LIST.\n         SPACE 1\n         LA    R8,DAIRPL\n         USING DAPL,R8\n         MVC   DAPLUPT,CPPLUPT\n         MVC   DAPLECT,CPPLECT\n         LA    R0,ECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB,CPPLPSCB   PROTECTED STEP CONTROL BLOCK\n         LA    R0,DAIRPB\n         ST    R0,DAPLDAPB ADDR OF DAIR PARM BLOCK\n         SPACE 1\n*------- SAVE PREFIX AND LENGTH WITH PERIOD (.).\n         SPACE 1\n         L     R15,CPPLUPT\n         XR    R1,R1\n         IC    R1,UPTPREFL-UPT(,R15)    LENGTH OF PREFIX\n         LA    R15,UPTPREFX-UPT(,R15)   ADDRESS OF PREFIX\n         LR    R2,R1\n         BCTR  R1,0\n         LA    R14,USERID\n         EX    R1,MOVE\n         LA    R1,USERID(R2)\n         MVI   0(R1),C'.'          MOVE IN PERIOD\n         LA    R2,1(R2)            FOR PERIOD\n         STH   R2,USERIDL\n         DROP  R8,R9\n         SPACE 1\n*------- INIT PARM BLOCK, ETC...\n         SPACE 1\n         MVC   PTPB(PTREFL),PTREF  INIT PUTLINE PARM BLOCK\n         MVC   PGPB(PGREFL),PGREF  INIT PUTGET PARM BLOCK\n         MVC   STAK(STAKREFL),STAKREF   INIT STACK PARM BLOCK\n         XC    NODDNS,NODDNS INIT NO. OF DDNAMES SPECIFIED BY TASKLIB\n         XC    ANSWER1,ANSWER1\n         MVI   FLAGS,0\n         MVC   EPENTRY(4),=Y(1,LBLDL)\n         MVC   EPNAME,=CL8' '\n         LA    R0,1\n         ST    R0,OLD              ONLY ONE SEGMENT\n         SPACE 1\n*------- PARSE THE COMMAND.\n         SPACE 1\n         XC    ECB,ECB\n        CALLTSSR EP=IKJPARS,MF=(E,PARSEPL)\n         LTR   R15,R15\n         BZ    PARSEOK\nPARSERR  MVC   WORKBUFF(28),=CL28'PARSE ERROR / RETURN CODE = '\n         ST    R15,DWORK+4\n         UNPK  DWORK(5),DWORK+6(3)\n         TR    DWORK(4),HEXTB-C'0'\n         MVC   WORKBUFF+28(4),DWORK\n         LA    R0,L'WORKHEAD+32\n         STH   R0,WORKLEN\n         XC    WORKOFF,WORKOFF\n         LA    R0,WORKHEAD\n         BAL   R14,PUTLNE\n         B     ERRRTN\nPARSEOK  L     R7,ANSWER0\n         USING PDL,R7  - - - - - - - - - - - - - - - - - - - - - - - -\n         CLI   ACKEYWD+1,1         TEST FOR AC(1) REQUESTED\n         BNE   SETSTAX             NO\n         XC    REQAUT(REQAUTL),REQAUT\n         MVC   REQAUT+1(3),=AL3(MDL@IX)\n         LA    R1,AUTH\n         ST    R1,REQAUT+4\n        $EACM  REQAUT\n         CLI   AUTH,LV0            CAN BE ACCEPTED?\n         BNE   ACDOIT              YES, DO IT\n         LA    R0,MSG15            NO, REJECTED\n         BAL   R14,PUTLNE\n         B     SETSTAX\nACDOIT  SETAUTH ,                  ASK AUTHORIZED ON\n         OI    FLAGS,ACFLG         SAY AC(1) ON\nSETSTAX  STM   R14,R12,STXSAVE+12  SAVE REGS SO STAX EXIT CAN USE\n         MVC   STXLIST(STXREFL),STXREF  PROGRAM BASE REGS\n         LA    R0,STXSAVE\n        STAX   STXEXIT,USADDR=(R0),MF=(E,STXLIST)\n         CLI   RCKEYWD+1,2         TEST FOR NO RC\n         BE    TESTAKW             GO TEST FOR TASK LIB\n         BH    *+L'*+8\n         OI    FLAGS,RCFLG\n         B     TESTAKW             GO TEST FOR TASK LIB\n         OI    FLAGS,ALLRCFLG\nTESTAKW  CLI   TASKEYWD+1,0        TEST FOR TASKLIB\n         BE    MOVEEP\n         SPACE 1\n*------- INIT PARSEPL WITH DIFFERENT ANSWER ADDR AND COMMAND BUFFER IN\n*        CASE THE DATA-SET(S) WHOSE NAMES ARE SPECIFIED BY THE TASKLIB\n*        KEYWORD ARE NOT IN THE CATALOG, CANT BE ALLOCATED, ETC...\n         SPACE 1\n         OI    FLAGS,TASKFLG\n         LA    R1,PARSEPL\n         USING PPL,R1\n         LA    R0,ANSWER1\n         ST    R0,PPLANS\n         LA    R0,CMDLEN\n         ST    R0,PPLCBUF\n         MVC   PPLPCL,=A(DSNPPL)\n         DROP  R1\n         LA    R9,TASKDSNA - - - - USE R9 AS BASE FOR DSNAME PDE - - -\nTSKLP    NI    FLAGS,255-QFLG\n         ICM   R15,B'1111',0(R9)   LOAD-TEST ADDR OF DSNAME\n         BNZ   TSKB\n         SPACE 1\n*------- DATA-SET NAME ERROR - PROBABLY MEMBER NAME ONLY.\n         SPACE 1\n         TM    14(R9),X'80'        TEST FOR MEMBER NAME\n         BO    *+L'*+12\n         LA    R0,MSG01            INVALID DSNAME\n         BAL   R14,PUTLNE\n         B     TSKPRMT             GO PROMPT FOR ANOTHER DSNAME\n         OI    FLAGS,QFLG          SO ''( ... )'' WILL BE PRINTED\n         LA    R14,CMDBUF\n         MVI   0(R14),C'('\n         LA    R14,1(R14)\n         LH    R1,12(R9)           LOAD LENGTH OF MEMBER NAME\n         BCTR  R1,0\n         L     R15,8(R9)           LOAD ADDR OF MEMBER NAME\n         EX    R1,MOVE\n         LA    R14,1(R1,R14)\n         MVI   0(R14),C')'\n         LA    R0,2(R1)\n         STH   R0,CMDOFF\n         LA    R0,CMDOFF\n         LA    R1,OUT01L\n         BAL   R6,MSGOUT           GO OUTPUT 'DATA-SET --- INVALID'\n         B     TSKPRMT             GO PROMPT FOR ANOTHER DATA-SET NAME\n         SPACE 1\n*------- DATA-SET NAME WAS SPECIFIED, IGNORE MEMBER NAME IF SPECIFIED.\n         SPACE 1\nTSKB     TM    6(R9),X'40'         TEST FOR QUOTES\n         BZ    *+L'*+4\n         OI    FLAGS,QFLG          SET QUOTES FLAG\n         LH    R1,4(R9)            LOAD LENGTH OF DATA-SET NAME\n         STH   R1,DSNLEN\n         BCTR  R1,0\n         LA    R14,DSNAME          R15= ADDR OF INPUT DSNAME\n         EX    R1,MOVE\n         SPACE 1\n*------- ALLOCATE DATA-SET BY NAME.\n         SPACE 1\n         LA    R8,DAIRPB\n         USING DAPB08,R8\n         MVC   DA08CD,CD08\n         XC    DA08FLG(6),DA08FLG\n         LA    R0,DSNLEN\n         ST    R0,DA08PDSN\n         MVC   DA08DDN,=CL8' '\n         MVC   DA08UNIT,=CL8' '\n         MVC   DA08SER,=CL8' '\n         XC    DA08BLK(L'DA08BLK+L'DA08PQTY+L'DA08SQTY+L'DA08DQTY),DA081\n               BLK\n         MVC   DA08MNM,=CL8' '\n         MVC   DA08PSWD,=CL8' '\n         MVI   DA08DSP1,DA08SHR\n         MVI   DA08DPS2,DA08KEEP\n         MVI   DA08DPS3,DA08KEP\n         XC    DA08CTL(5),DA08CTL\n         TM    FLAGS,QFLG          TEST FOR QUOTE\n         BO    *+L'*+4\n         OI    DA08CTL,DA08UID     PREFIX USER ID\n         BAL   R14,DAIRRTN         LINK TO DAIR\n         LTR   R15,R15\n         BZ    TESTPDS\n         CH    R15,=H'8'           TEST FOR CATALOG ERROR\n         BNE   TSKDAER\n         CLC   DA08DARC(L'DA08DARC+L'DA08CTRC),=XL4'17080008'\n         BNE   TSKCTER\n         TM    FLAGS,QFLG          TEST FOR QUOTES\n         BO    TSKDAER\n         SPACE 1\n*------- SINCE THE DSNAME IS NOT IN QUOTES, AND IF IT IS NOT ALREADY\n*        A COMPOSED NAME, APPEND .LOAD AND TRY ALLOC AGAIN.\n         SPACE 1\n         LH    R2,DSNLEN\n         LR    R14,R2\n         LA    R1,DSNAME(R2)\n         LR    R15,R1\n         B     *+L'*+8\n         CLI   0(R15),C'.'\n         BE    TSKCTER\n         BCTR  R15,0\n         BCT   R14,*-10\n         MVC   0(5,R1),=CL5'.LOAD'\n         LA    R0,5(R2)\n         STH   R0,DSNLEN\n         XC    DA08DARC(4),DA08DARC\n         BAL   R14,DAIRRTN         LINK TO DAIR\n         LTR   R15,R15\n         BZ    TESTPDS\n         LH    R0,DSNLEN\n         SH    R0,=H'5'            FOR .LOAD\n         STH   R0,DSNLEN\n         CH    R15,=H'8'           TEST FOR CATALOG ERROR\n         BNE   TSKDAER\nTSKCTER  LA    R0,DSNLEN           CATALOG ERROR\n         LA    R1,OUT02L           DSNAME NOT IN CATALOG\n         BAL   R6,MSGOUT\n         B     TSKPRMT             GO PROMPT\n         SPACE 1\n*------- ALLOCATION ERROR.\n         SPACE 1\nTSKDAER  ST    R15,SVR15\n         LA    R0,DSNLEN\n         LA    R1,OUT04L\n         BAL   R6,MSGOUT\n         L     R15,SVR15\n         CH    R15,=H'12'\n         BH    TESTDARC\n         MVC   WORKBUFF(34),=CL34'DYNAMIC ALLOCATION / ERROR CODE = '\n         LH    R0,DA08DARC\n         ST    R0,DWORK+4\n         UNPK  DWORK(5),DWORK+6(3)\n         TR    DWORK(4),HEXTB-C'0'\n         MVC   WORKBUFF+34(4),DWORK\n         LA    R0,L'WORKHEAD+38\n         STH   R0,WORKLEN\n         XC    WORKOFF,WORKOFF\n         LA    R0,WORKHEAD\n         BAL   R14,PUTLNE\n         B     TSKPRMT\nTESTDARC CH    R15,=H'16'\n         BH    *+L'*+12\n         LA    R0,MSG13            ALLOCATIONS EXCEEDED\n         BAL   R14,PUTLNE\n         B     TSKPRMT\n         MVC   WORKBUFF(35),=CL35'DYNAMIC ALLOCATION / RETURN CODE = '\n         ST    R15,DWORK+4\n         UNPK  DWORK(5),DWORK+6(3)\n         TR    DWORK(4),HEXTB-C'0'\n         MVC   WORKBUFF+35(4),DWORK\n         LA    R0,L'WORKHEAD+39\n         STH   R0,WORKLEN\n         XC    WORKOFF,WORKOFF\n         LA    R0,WORKHEAD\n         BAL   R14,PUTLNE\n         B     TSKPRMT\n         SPACE 1\n*------- DATA-SET IS ALLOCATED, TEST FOR PDS.\n         SPACE 1\nTESTPDS  TM    DA08DSO,DCBDSGPO TEST FOR PDS\n         BO    SAVEDDN\n         LA    R0,DSNLEN\n         LA    R1,OUT03L\n         BAL   R6,MSGOUT           DS IS NOT PDS\n         LA    R1,DA08DDN\n         BAL   R6,FREEDDN          GO FREE DDNAME\n         B     TSKPRMT\nSAVEDDN  LH    R1,NODDNS           SAVE ALLOCATED DDNAME\n         SLL   R1,3                MULTIPLY BY 8\n         LA    R2,DDNAMES(R1)\n         MVC   0(8,R2),DA08DDN     SAVE DDNAME\n         DROP  R8\n         LH    R1,NODDNS\n         LA    R1,1(R1)\n         STH   R1,NODDNS\n         CH    R1,=H'10'\n         BL    TSKENLP\n         CLI   24(R9),X'FF'        TEST FOR LAST PDE\n         BE    CONCAT              LAST PDE -- GO CONCAT.\n         LA    R0,MSG04  MORE THAN 10 DSNAMES SPECIFIED BY TASKLIB\n         BAL   R14,PUTLNE\n         LA    R0,MSG05\n         ST    R0,OLD+4\n        TCLEARQ INPUT\n         XC    ECB,ECB\n        PUTGET PARM=PGPB,OUTPUT=(OLD,SINGLE,PROMPT),                   1\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     2\n               TERMGET=(EDIT,WAIT),MF=(E,IOPLA)\n         CH    R15,=H'4'\n         BH    TESTPGRC            GO TEST RETURN CODE\n         L     R1,PGPB+12          LOAD ADDR OF INPUT LINE\n         CLC   0(2,R1),=H'4'       TEST LENGTH OF INPUT LINE\n         BNH   CONCAT              NULL LINE\n         B     ERRRTN\n         SPACE 1\n*------- PROMPT FOR TASK LIBRARY DATA-SET NAME.\n         SPACE 1\nTSKPRMT  LA    R0,MSG02            ENTER TASKLIB DSNAME\n         ST    R0,OLD+4\n        TCLEARQ INPUT\n         XC    ECB,ECB\nTSKPRMA PUTGET PARM=PGPB,OUTPUT=(OLD,SINGLE,PROMPT),                   1\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     2\n               TERMGET=(EDIT,WAIT),MF=(E,IOPLA)\n         CH    R15,=H'4'\n         BH    TESTPGRC\n         L     R15,PGPB+12         LOAD ADDR OF INPUT LINE\n         LH    R2,0(R15)           LOAD LENGTH\n         CH    R2,=H'48'           TEST FOR MAX DSN LENGTH\n         BNH   TSKPRMB\n         LR    R0,R2\n         O     R0,=A(X'01000000')  SP=1\n         LR    R1,R15\n        FREEMAIN R,LV=(0),A=(1)\n         LA    R0,MSG03            DSNAME TOO LONG\n         BAL   R14,PUTLNE\n         B     TSKPRMA\nTSKPRMB  BCTR  R2,0\n         LA    R14,CMDLEN\n         EX    R2,MOVE\n         LH    R0,0(R15)\n         O     R0,=A(X'01000000')  SP=1\n         LR    R1,R15\n        FREEMAIN R,LV=(0),A=(1)\n         CLC   CMDLEN,=H'4'        TEST FOR NULL LINE RESPONSE\n         BNH   TSKENLP             GO TO END OF LOOP\n        IKJRLSA ANSWER1\n         XC    ECB,ECB\n        CALLTSSR EP=IKJPARS,MF=(E,PARSEPL)\n         CH    R15,=H'8'           TEST FOR ATTN\n         BE    ERRRTN              GO RETURN\n         BH    PARSERR\n         CH    R15,=H'4'\n         BE    PARSERR\n         L     R15,ANSWER1\n         USING DSNPDL,R15\n         MVC   0(24,R9),NEWDSN     OVERLAY OLD PDE WITH NEW ONE\n         B     TSKLP\n         DROP  R15\n         SPACE 1\n*------- TEST FOR RETURN CODE FROM PUTGET.\n         SPACE 1\nTESTPGRC CH    R15,=H'8'\n         BE    ERRRTN\n         CH    R15,=H'12'\n         BNE   TESTRC24\n         LA    R1,=CL68'CAN''T PROMPT, EITHER YOU ARE IN A CLIST OR YOU1\n               R PROFILE IS NO-PROMPT'\n         LA    R0,68\n         B     ERRSMSG\nTESTRC24 CH    R15,=H'24'\n         BNE   PGRC28\n         LA    R1,=CL35'INVALID PARAMETERS PASSED TO PUTGET'\n         LA    R0,35\n         B     ERRSMSG\nPGRC28   LA    R1,=CL52'NOT ENOUGH SPACE TO OBTAIN OUTPUT BUFFERS FOR P1\n               UTGET'\n         LA    R0,52\nERRSMSG  TM    #TSFLAG,#TSFRUN     TEST IF BACKGROUND OR FOREGROUND\n         BO    FGRUN               BRANCH IF FOREGROUND\n         MVC   WTOMSG(2),WSKEL\n         LR    R15,R0\n         BCT   R15,*+L'*+6\n         MVC   ERRMSG(*-*),0(R1)   <<EXECUTED>>\n         EX    R15,*-6\n         LA    R15,5(R15)\n         STCM  R15,B'0011',WTOMSG+2\n         LA    R1,WTOMSG\n         ALR   R15,R1\n         MVC   0(4,R15),WSKEL+6\n        WTO    MF=(E,(1))\n         B     ERRRTN\nFGRUN   TPUT   (1),(0)\n         B     ERRRTN\n         SPACE 1\n*------- TEST FOR END OF PDE'S.\n         SPACE 1\nTSKENLP  CLI   24(R9),X'FF'\n         BE    CONCAT\n         L     R9,24(R9)           ADDR OF NEXT PDE\n         B     TSKLP\n         SPACE 1\n*------- ALL DATA-SETS FOR TASKLIB HAVE BEEN ALLOCATED.\n*        NOW CONCATENATE THEM.\n         SPACE 1\nCONCAT   CLC   NODDNS,=H'1'        TEST FOR TASK LIBRARIES\n         BE    MOVEEP\n         BH    CONCAT1\n         LA    R0,MSG08\n         BAL   R14,PUTLNE\n         LA    R0,MSG05\n         ST    R0,OLD+4\n        TCLEARQ INPUT\n         XC    ECB,ECB\n        PUTGET PARM=PGPB,OUTPUT=(OLD,SINGLE,PROMPT),                   1\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     2\n               TERMGET=(EDIT,WAIT),MF=(E,IOPLA)\n         CH    R15,=H'4'\n         BH    TESTPGRC            GO TEST RC FROM PUTGET\n         L     R1,PGPB+12          LOAD ADDR OF INPUT LINE\n         CLC   0(2,R1),=H'4'       TEST FOR NULL LINE\n         BH    ERRRTN\n         O     R0,=A(X'01000000')  SP=1\n        FREEMAIN R,LV=(0),A=(1)\n         B     MOVEEP\nCONCAT1  LA    R8,DAIRPB\n         USING DAPB0C,R8\n         MVC   DA0CCD,CD0C\n         XC    DA0CFLG(6),DA0CFLG\n         LH    R1,NODDNS\n         STH   R1,DA0CNUMB\n         XC    DA0CNUMB+2(2),DA0CNUMB+2\n         SLL   R1,3                MULTIPLY BY 8\n         BCTR  R1,0\n         LA    R14,DA0CNUMB+4\n         LA    R15,DDNAMES\n         EX    R1,MOVE\n         DROP  R8\n         BAL   R14,DAIRRTN         LINK TO DAIR\n         LTR   R15,R15\n         BZ    MOVEEP              GO MOVE IN EP NAME\n         LA    R0,MSG06            CONCAT ERROR\n         BAL   R14,PUTLNE\n         B     ERRRTN\n         SPACE 1\n*---     HAVE ALLOCATED AND CONCATENATED THE TASK LIBRARIES, WILL NOW\n*        MOVE LOAD MOD NAME, MOVE THE PARM-FIELD (IF SPECIFIED), OPEN\n*        THE TASKLIB DCB, AND ATTACH.\n         SPACE 1\nMOVEEP   LH    R1,LOADMOD+4\n         STH   R1,EPNAMEL          SAVE LENGTH OF PROGRAM NAME\n         BCTR  R1,0\n         L     R15,LOADMOD\n         LA    R14,EPNAME\n         EX    R1,MOVE             MOVE EP NAME\n         L     R15,MYCPSWIT        ARE WE ATTACHING A CP?\n         B     *+L'*(R15)\n         B     TESTTSK             0 ==> DOCP\n         TM    PARMA+6,X'80'       4 ==> DOPROG, TEST FOR PARM-FIELD\n         BO    *+L'*+10\n         XC    PARMFLDL,PARMFLDL\n         B     TESTTSK\n         LH    R2,PARMA+4          LOAD LENGTH OF QSTRING (PARM-FIELD)\n         CH    R2,=H'256'\n         BNH   *+L'*+12\n         LA    R0,MSG07            PARM-FIELD EXCEEDS 256 BYTES\n         BAL   R14,PUTLNE\n         LH    R2,=H'256'\n         STH   R2,PARMFLDL\n         BCTR  R2,0\n         L     R15,PARMA           LOAD ADDR OF QSTRING\n         LA    R14,PARMFLD\n         EX    R2,MOVE             MOVE PARM-FIELD\n         TM    FLAGS,TASKFLG       WAS TASKLIB SPECIFIED?\n         BZ    ATTACH0             NO\nTESTTSK  OC    NODDNS,NODDNS       TEST FOR TASKLIB DSNAMES\n         BZ    ATTACH0\n         MVC   TASKLIB(SKELDCBL),SKELDCB\n         LA    R1,TASKLIB\n         USING IHADCB,R1\n         MVC   DCBDDNAM,DDNAMES    MOVE DDNAME TO DCB\n         DROP  R1\nATTACH0  MVC   ATTACH(ATREFL),ATREF\n         XC    ECB,ECB\n         LA    R1,PARMFLDL\n         ST    R1,PARMADDR\n         OI    PARMADDR,X'80'\n         TM    FLAGS,TASKFLG       TEST FOR TASK LIB\n         BZ    ATTACH1\n         OC    NODDNS,NODDNS\n         BNZ   OPENDCB\nATTACH1 BLDL   0,EPENTRY\n         LTR   R15,R15             WAS EP NAME FOUND?\n         BNZ   EPERROR             NO - GO PUT OUT MSG\n         LA    R1,PARMADDR\n         L     R15,MYCPSWIT        ARE WE ATTACHING A CP?           RRS\n         B     *+L'*(R15)                                           RRS\n         BAL   R6,CPSTUFF          0 ==> DOCP                   -EU-RRS\n         LA    R15,ATTACH          4 ==> DOPROG                     RRS\n         LA    R2,ECB\n         LA    R0,EPNAME\n         XC    ECB,ECB\n        ATTACH DE=(R0),ECB=(R2),SHSPL=SPLIST,                          1\n               MF=(E,(1)),SF=(E,(15))\n         B     TESTATRC\nOPENDCB  MVC   OPEN(OPENREFL),OPENREF\n         LA    R1,OPEN\n         LA    R2,TASKLIB\n        OPEN   ((R2),(INPUT)),MF=(E,(1))\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN   TEST FOR OPEN\n         BO    *+L'*+12\n         LA    R0,MSG09            DCB NOT OPEN\n         BAL   R14,PUTLNE\n         B     ERRRTN\n         TM    FLAGS,ACFLG         IS AC(1) ON?\n         BZ    OPENOK              NO\n         L     R1,DCBDEBAD         YES, GET TASKLIB DEB\n         USING DEBBASIC,R1\n         TM    DEBFLGS1,DEBAPFIN   IS IT APF AUTHORIZED?\n         BO    OPENOK              YES\n         DROP  R1,R2\n         LA    R0,MSG16            NO, TASKLIB NOT APF, REJECT\n         BAL   R14,PUTLNE\n         B     ERRRTN\nOPENOK   LA    R3,TASKLIB  - - - - PROTECT R3 FROM HERE TO UP \"END-R3\"\n        BLDL   (R3),EPENTRY\n         LTR   R15,R15\n         BZ    GOTEPOK\nEPERROR  LA    R14,WORKBUFF        NAME NOT FOUND\n         MVC   0(13,R14),=CL13'PROGRAM NAME '\n         L     R15,MYCPSWIT        ARE WE ATTACHING A CP?\n         B     *+L'*(R15)\n         B     *+L'*+4             0 ==> DOCP\n         B     *+L'*+6             4 ==> DOPROG\n         MVC   0(7,R14),=CL7'COMMAND'   COMMAND NAME\n         LA    R14,13(R14)\n         MVI   0(R14),C''''\n         LA    R14,1(R14)\n         LH    R1,EPNAMEL\n         BCTR  R1,0\n         LA    R15,EPNAME\n         EX    R1,MOVE             EP NAME\n         LA    R14,1(R1,R14)\n         MVI   0(R14),C''''\n         LA    R14,1(R14)\n         MVC   0(27,R14),=CL27' NOT FOUND IN CONCATENATED '\n         LA    R14,27(R14)\n         OC    NODDNS,NODDNS\n         BZ    *+L'*+10\n         MVC   0(4,R14),=CL4'TASK'\n         B     *+L'*+6\n         MVC   0(4,R14),=CL4'LINK'\n         LA    R14,4(R14)\n         MVC   0(10,R14),=CL10' LIBRARIES'\n         LA    R14,10(R14)\n         LA    R0,WORKHEAD\n         SR    R14,R0\n         STH   R14,WORKLEN\n         XC    WORKOFF,WORKOFF\n         BAL   R14,PUTLNE\nEPERROR1 LA    R0,MSG11\n         L     R14,MYCPSWIT        ARE WE ATTACHING A CP?\n         B     *+L'*(R14)\n         LA    R0,MSG11A           0 ==> DOCP\n         ST    R0,OLD+4            4 ==> DOPROG\n        TCLEARQ INPUT\n         XC    ECB,ECB\n        PUTGET PARM=PGPB,OUTPUT=(OLD,SINGLE,PROMPT),                   1\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     2\n               TERMGET=(EDIT,WAIT),MF=(E,IOPLA)\n         CH    R15,=H'4'\n         BH    TESTPGRC\n         L     R1,PGPB+12          LOAD ADDR\n         LH    R2,0(R1)\n         SH    R2,=H'4'\n         BNP   ERRRTN\n         CH    R2,=H'8'\n         BNH   EPERROR2\n         LA    R0,MSG12            PROGRAM NAME GT 8 CHAR\n         L     R14,MYCPSWIT        ARE WE ATTACHING A CP?\n         B     *+L'*(R14)\n         LA    R0,MSG12A           0 ==> DOCP, CMD NAME GT 8 CHAR\n         BAL   R14,PUTLNE          4 ==> DOPROG\n         B     EPERROR1\nEPERROR2 STH   R2,EPNAMEL          STORE LENGTH OF EP NAME\n         MVC   EPNAME,=CL8' '\n         LA    R14,EPNAME\n         LA    R15,4(R1)\n         BCTR  R2,0\n         EX    R2,MOVE\n         OC    EPNAME,=CL8' '      UPPER CASE EP NAME\n         LH    R0,0(R1)\n         O     R0,=A(X'01000000')  SP=1\n        FREEMAIN R,LV=(0),A=(1)\n         OC    NODDNS,NODDNS\n         BNZ   OPENOK\n         B     ATTACH1\nGOTEPOK  LA    R1,PARMADDR\n         L     R15,MYCPSWIT        ARE WE ATTACHING A CP?           RRS\n         B     *+L'*(R15)                                           RRS\n         BAL   R6,CPSTUFF          0 ==> DOCP                   -EU-RRS\n         LA    R15,ATTACH          4 ==> DOPROG                     RRS\n         LA    R2,ECB\n         LA    R0,EPNAME\n         XC    ECB,ECB\n        ATTACH DE=(R0),ECB=(R2),TASKLIB=(R3),SHSPL=SPLIST,             1\n               MF=(E,(1)),SF=(E,(15))\nTESTATRC ST    R1,TCB\n         LTR   R15,R15             HOW ATTACH COMPLETE?\n         BZ    DOWAIT              OK\n         ST    R15,DWORK+4         ATTACH FAILED\n         LA    R14,WORKBUFF\n         MVC   0(15,R14),=CL15'ATTACH PROGRAM '\n         L     R15,MYCPSWIT        ARE WE ATTACHING A CP?\n         B     *+L'*(R15)\n         B     *+L'*+4             0 ==> DOCP\n         B     *+L'*+6             4 ==> DOPROG\n         MVC   7(7,R14),=CL7'COMMAND'   COMMAND NAME\n         LA    R14,15(R14)\n         MVI   0(R14),C''''\n         LA    R14,1(R14)\n         LH    R1,EPNAMEL\n         BCTR  R1,0\n         LA    R15,EPNAME\n         EX    R1,MOVE             EP NAME\n         LA    R14,1(R1,R14)\n         MVI   0(R14),C''''\n         LA    R14,1(R14)\n         MVC   0(23,R14),=CL23'FAILED / RETURN CODE = '\n         UNPK  DWORK(5),DWORK+6(3)\n         TR    DWORK(4),HEXTB-C'0'\n         MVC   23(4,R14),DWORK\n         LA    R14,27(R14)\n         LA    R0,WORKHEAD\n         SR    R14,R0\n         STH   R14,WORKLEN\n         XC    WORKOFF,WORKOFF\n         BAL   R14,PUTLNE\n         B     SETRC\nDOWAIT   LA    R1,ECB\n        WAIT  ECB=(1)\n         OC    TCB,TCB             TCB PASSED BACK?\n         BZ    MVCCDE              NO\n        DETACH TCB\nMVCCDE   XC    COMPCDE,COMPCDE     CLEAR CONDITION CODE      JFS04NOV77\n         MVC   COMPCDE+1(3),ECB+1  SAVE CONDITION CODE       JFS03NOV77\n         B     RTURN\n         SPACE 1                                                    RRS\n*------- DOCP, PASS A CPPL IN R1, INSTEAD OF A PARM. THE PARM       RRS\n*        QSTRING IS USED AS THE COMMAND-LINE IF PRESENT, ELSE       RRS\n*        THE COMMAND-LINE IS PROMPTED FOR.                          RRS\n*        ON ENTRY - R6 = RETURN ADDRESS (LINK REGISTER).           -EU-\n*              DON'T USE : R3 = A.TASKLIB                          -EU-\n*                          R7 = A.PPL                              -EU-\n*                          R9 = BASE FOR DSNAME PDE                -EU-\n*              WORK-REGISTERS : R0-R1-R2-R4-R8-R14-R15             -EU-\n         SPACE 1                                                    RRS\nCPSTUFF  TM    PARMA+6,X'80'       IS PARM-FIELD PRESENT?           RRS\n         BZ    CPPRMPT             NO ==> PROMPT FOR COMMAND        RRS\n         L     R15,PARMA           THE PARM QSTRING                 RRS\n         LH    R2,PARMA+4          YES ==> GET LENGTH OF QSTRING    RRS\n         CH    R2,=H'256'          AND FORCE LENGTH TO 256          RRS\n         BNH   CPMOVE                                               RRS\n         LA    R0,MSG07A           TOO LONG MSG                     RRS\n         BAL   R14,PUTLNE                                           RRS\n         L     R15,PARMA           THE PARM QSTRING                 RRS\n         LH    R2,=H'256'                                           RRS\n         B     CPMOVE                                               RRS\nCPPRMPT  LA    R0,MSG14            PROMPT FOR A COMMAND-LINE        RRS\n         ST    R0,OLD+4                                             RRS\n        TCLEARQ INPUT                                               RRS\n         XC    ECB,ECB                                              RRS\n        PUTGET PARM=PGPB,OUTPUT=(OLD,SINGLE,PROMPT),                RRS1\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                  RRS2\n               TERMGET=(EDIT,WAIT),MF=(E,IOPLA)                     RRS\n         CH    R15,=H'4'           TEST FOR ERROR RETURN            RRS\n         BH    TESTPGRC                                             RRS\n         L     R15,PGPB+12         ADDR OF INPUT LINE               RRS\n         LH    R2,0(R15)           LENGTH OF INPUT LINE             RRS\n         LA    R15,4(R15)          SKIP OVER HEADER                 RRS\nCPMOVE   LA    R0,4(,R2)           ALLOW FOR RDW, AND               RRS\n         STH   R0,PARMFLDL         SAVE LENGTH OF COMMAND.          RRS\n         BCTR  R2,0                                                 RRS\n         LA    R14,PARMFLD+2       OUR COMMAND BUFFER               RRS\n         EX    R2,MOVE             NOW WE ONLY NEED THE OPERAND     RRS\n         LA    R2,1(R2)            POINTER.                         RRS\n         XR    R4,R4               SCAN FOR THE FIRST BLANK AFTER   RRS\nCPSCAN   CLI   0(R14),C' '         THE FIRST NON-BLANK.             RRS\n         BE    CPBLNK                                               RRS\n         B     *+L'*(R4)                                            RRS\n         LA    R4,4                                                 RRS\n         B     CPINCR                                               RRS\nCPBLNK   B     *+L'*(R4)                                            RRS\n         B     CPINCR                                               RRS\n         B     CPGOTCHA                                             RRS\nCPINCR   LA    R14,1(R14)          INVALID COMMAND SYNTAX WILL      RRS\n         BCT   R2,CPSCAN           FALL THROUGH. LET THE COMMAND    RRS\n         BCTR  R14,0               PROCESSOR DEAL WITH IT           RRS\nCPGOTCHA LA    R15,PARMFLD+1       GET POSITION OF 1ST BLANK        RRS\n         SR    R14,R15             AFTER COMMAND.                   RRS\n         STH   R14,PARMFLDL+2      NOW WE CONSTRUCT A CPPL          RRS\n         LA    R1,PARMFLDL         ADDRESS OF PHONEY COMMAND        RRS\n         ST    R1,MYCPPL                                            RRS\n         LA    R1,MYCPPL           PASS ADDR OF FAKE CPPL           RRS\n         USING CPPL,R1\n         L     R8,CPPLECT          GET ECT ADDRESS\n         DROP  R1\n         USING ECT,R8\n         MVC   SVPCMD,ECTPCMD      SAVE ORIGINALS\n         MVC   SVSCMD,ECTSCMD\n         TM    ECTSWS,ECTNOPD\n         BZ    *+L'*+4\n         OI    FLAGS,NOPDFLG\n         NI    ECTSWS,255-ECTNOPD  REPLACE BY SUPPLIED COMMAND INFO\n         MVC   ECTPCMD,EPNAME\n         MVC   ECTSCMD,=CL8' '\n         LTR   R2,R2\n         BNP   CPSCEND\n         XR    R4,R4               CONTINUE SCAN TO SET SUBCOMMAND\n         ALR   R14,R15\n         CLI   0(R14),C' '\n         BNE   *+L'*+12\n         LA    R14,1(R14)\n         BCT   R2,*-12\n         B     CPSCEND\n         LR    R15,R14\n         LA    R14,1(R14)\n         BCT   R2,*+L'*+4\n         B     *+L'*+8\n         CLI   0(R14),C' '\n         BNE   *-16\n         BCTR  R14,0\n         SR    R14,R15\n         LA    R2,7\n         CLR   R14,R2\n         BNL   *+L'*+2\n         LR    R2,R14\n         LA    R14,ECTSCMD\n         EX    R2,MOVE             SET SUBCOMMAND NAME\n         OI    ECTSWS,ECTNOPD\n         DROP  R8\nCPSCEND  OI    FLAGS,PECTFLG\n         BR    R6                  RETURN                           RRS\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \"END-R3\"\n         SPACE 1\n*------- ERROR RETURN. ATTN, ERROR, ETC... WILL CAUSE CONTROL TO BE\n*        PASSED TO THIS SECTION.\n         SPACE 1\nERRRTN  IKJRLSA ANSWER0\n        IKJRLSA ANSWER1\n         XC    STAKECB,STAKECB\n        STACK  PARM=STAK,DELETE=ALL,MF=(E,STAKIOPL)\nSETRC    XC    COMPCDE,COMPCDE                               JFS03NOV77\n         MVI   COMPCDE+3,16        RC=16 ------------------- JFS03NOV77\n         SPACE 1\n*------- CLEAN UP AND RETURN.\n         SPACE 1\nRTURN    TM    FLAGS,PECTFLG\n         BZ    RTURN0\n         LA    R1,MYCPPL\n         USING CPPL,R1\n         L     R2,CPPLECT          GET ECT ADDRESS\n         DROP  R1\n         USING ECT,R2\n         MVC   ECTPCMD,SVPCMD      RESTORE ORIGINALS\n         MVC   ECTSCMD,SVSCMD\n         NI    ECTSWS,255-ECTNOPD\n         TM    FLAGS,NOPDFLG\n         BZ    *+L'*+4\n         OI    ECTSWS,ECTNOPD\n         DROP  R2\n         NI    FLAGS,255-PECTFLG+NOPDFLG\nRTURN0   LH    R2,NODDNS           ANY DDNAME TO DECONCATENATE?\n         LTR   R2,R2\n         BZ    RTURN1\n         MVC   CLOSE(CLOSREFL),CLOSREF\n         LA    R1,CLOSE\n         LA    R3,TASKLIB\n        CLOSE  ((R3)),MF=(E,(1))\n         CH    R2,=H'1'\n         BE    FREEUP              ONLY ONE\n         LA    R8,DAIRPB\n         USING DAPB10,R8\n         MVC   DA10CD,CD10\n         XC    DA10FLG(6),DA10FLG\n         MVC   DA10DDN,DDNAMES\n         BAL   R14,DAIRRTN         LINK TO DAIR\n         LTR   R15,R15\n         BZ    FREEUP\n         LA    R0,MSG10            DECONT. ERROR\n         BAL   R14,PUTLNE\n         DROP  R8\n         SPACE 1\n*------- FREE THE ALLOCATED DDNAMES.\n         SPACE 1\nFREEUP   LR    R3,R2\n         BCTR  R3,0\n         SLL   R3,3\n         LA    R1,DDNAMES(R3)\n         BAL   R6,FREEDDN          GO FREE DDNAME\n         BCT   R2,FREEUP\nRTURN1   TM    FLAGS,ACFLG         IS AC(1) ON?\n         BZ    RTURN2              NO\n        RESAUTH ,                  YES, ASK AUTHORIZED OFF\n         NI    FLAGS,255-ACFLG     SAY AC(1) OFF\nRTURN2   L     R2,COMPCDE     RETURN CODE FROM ATTACHED PROG JFS03NOV77\n         TM    FLAGS,ALLRCFLG\n         BO    PUTRCOUT\n         LTR   R2,R2\n         BZ    RTURN3\n         TM    FLAGS,RCFLG\n         BZ    QUIT                                                -EU-\n         SPACE 1                                             JFS03NOV77\n*------- CONVERT CONDITION CODE FROM BINARY TO EBCDIC OR     JFS04NOV77\n*        ABEND AND USER CODES FROM BINARY TO HEXADECIMAL -EU-JFS04NOV77\n*        AND OUTPUT THE MESSAGE.                             JFS04NOV77\n         SPACE 1                                             JFS03NOV77\nPUTRCOUT SRDL  R2,12\n         SRL   R3,20\n         LTR   R2,R2\n         BZ    OUTCC\n         MVC   WORKBUFF(14),=CL14'ABEND CODE = S'\n         ST    R2,DWORK+4\n         UNPK  DWORK(5),DWORK+6(3)\n         TR    DWORK(4),HEXTB-C'0'\n         MVC   WORKBUFF+14(3),DWORK+1\n         MVC   WORKBUFF+17(16),=CL16' / USER CODE = U'\n         ST    R3,DWORK+4\n         UNPK  DWORK(5),DWORK+6(3)\n         TR    DWORK(4),HEXTB-C'0'\n         MVC   WORKBUFF+33(3),DWORK+1\n         LA    R0,L'WORKHEAD+36\n         STH   R0,WORKLEN\n         XC    WORKOFF,WORKOFF\n         LA    R0,WORKHEAD\n         BAL   R14,PUTLNE\n         B     QUIT\nOUTCC    MVC   WORKBUFF(17),=CL17'CONDITION CODE = '         JFS03NOV77\n         CVD   R3,DWORK\n         UNPK  DWORK(5),DWORK+5(3)                           JFS03NOV77\n         OI    DWORK+4,C'0'                                  JFS03NOV77\n         LA    R15,DWORK-1                                   JFS03NOV77\n         LA    R1,5                                          JFS04NOV77\n         LA    R15,1(R15)                                    JFS03NOV77\n         CLI   0(R15),C'0'         FIND NON ZERO             JFS03NOV77\n         BNE   *+L'*+8                                       JFS03NOV77\n         BCT   R1,*-12                                       JFS03NOV77\n         LA    R1,1           SO AT LEAST 1 0 WILL BE OUTPUT JFS04NOV77\n         LA    R14,WORKBUFF+17                               JFS03NOV77\n         BCTR  R1,0                -1 FOR MVC                JFS03NOV77\n         EX    R1,MOVE        MOVE IN COMP CODE RETURNED     JFS03NOV77\n         LA    R0,L'WORKHEAD+17+1(R1) +1 FOR MVC             JFS03NOV77\n         STH   R0,WORKLEN\n         XC    WORKOFF,WORKOFF\n         LA    R0,WORKHEAD\n         BAL   R14,PUTLNE\n         LR    R2,R3\nRTURN3  $XRET  CC=(R2),LV=WKLEN,TYPE=RENT\nQUIT     LA    R2,16               RC=16 ------------------------------\n         B     RTURN3\n         SPACE 1\nMOVE     MVC   0(*-*,R14),0(R15)   <<EXECUTED>>\n         EJECT\n*------- PUTLNE (PUTLINE) ROUTINE.\n*        ON ENTRY - R0 = ADDRESS OF MESSAGE,\n*                   R14 = RETURN ADDRESS (LINK REGISTER).\n*              DON'T USE : R3 = A.TASKLIB                          -EU-\n*                          R7 = A.PPL                              -EU-\n*                          R9 = BASE FOR DSNAME PDE                -EU-\n*              WORK-REGISTERS : R0-R1-R14-R15                      -EU-\n         SPACE 1\nPUTLNE   ST    R14,SVR14           SAVE RETURN\n         XC    ECB,ECB\n        PUTLINE PARM=PTPB,OUTPUT=((R0),TERM,SINGLE,DATA),              1\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=(E,IOPLA)\n         LTR   R15,R15 TEST FOR ERRORS, ATTN ETC\n         BZ    PTRTN\n         CH    R15,=H'4'           TEST FOR ATTN\n         BE    ERRRTN              GO RETURN WITH RC=16\n         LA    R1,PTERROR          PUTLINE ERROR\n         LA    R0,L'PTERROR\n         B     ERRSMSG\nPTRTN    L     R14,SVR14           RESTORE RETURN\n         BR    R14                 BACK TO CALLER\n         EJECT\n*------- STAX EXIT.\n         SPACE 1\n        CNOP   0,8\nSTXEXIT SAVE   (14,12)\n         LR    R2,R13              SAVE ADRRESS\n         L     R13,8(R1)           LOAD ADDR OF STAX SAVE AREA\n         USING STXSAVE,R13\n         ST    R2,STXSAVE+4\n         ST    R13,8(R2)\n         LM    R14,R12,STXSAVE+12  RESTORE REGS\n         LA    R2,ECB\n        POST   (R2),16             SET RC=16\n         XC    STAKECB,STAKECB\n        STACK  PARM=STAK,DELETE=ALL,MF=(E,STAKIOPL)\n        TCLEARQ INPUT\n        TCLEARQ OUTPUT\n         TM    FLAGS,PECTFLG\n         BZ    LEAVE\n         LA    R1,MYCPPL\n         USING CPPL,R1\n         L     R2,CPPLECT          GET ECT ADDRESS\n         DROP  R1\n         USING ECT,R2\n         MVC   ECTPCMD,SVPCMD      RESTORE ORIGINALS\n         MVC   ECTSCMD,SVSCMD\n         NI    ECTSWS,255-ECTNOPD\n         TM    FLAGS,NOPDFLG\n         BZ    *+L'*+4\n         OI    ECTSWS,ECTNOPD\n         DROP  R2\n         NI    FLAGS,255-PECTFLG+NOPDFLG\nLEAVE    L     R13,STXSAVE+4\n         DROP  R13\n        RETURN (14,12),RC=0\n         EJECT\n*------- OUTPUT -- 'DATA-SET ---- ' MESSAGE ROUTINE.\n*        ON ENTRY - R0 = ADDRESS OF DSNAME,\n*                   R1 = ADDRESS OF LAST PART OF MESSAGE,\n*                   R6 = RETURN ADDRESS (LINK REGISTER).\n*              DON'T USE : R7 = A.PPL                              -EU-\n*                          R9 = BASE FOR DSNAME PDE                -EU-\n*              WORK-REGISTERS : R0-R1-R2-R14-R15                   -EU-\n         SPACE 1\nMSGOUT   LR    R2,R1\n         LA    R14,WORKBUFF\n         LA    R15,=CL9'DATA-SET '\n         LA    R1,8\n         EX    R1,MOVE\n         LA    R14,1(R1,R14)\n         MVI   0(R14),C''''\n         LA    R14,1(R14)\n         TM    FLAGS,QFLG          TEST FOR QUOTES\n         BZ    *+L'*+12\n         MVI   0(R14),C''''\n         LA    R14,1(R14)\n         B     MSGOUT1\n         LH    R1,USERIDL          LOAD LENGTH OF USER ID\n         LA    R15,USERID\n         BCTR  R1,0\n         EX    R1,MOVE             ID\n         LA    R14,1(R1,R14)\nMSGOUT1  LR    R15,R0\n         LH    R1,0(R15)           LOAD LENGTH OF DSNAME\n         LA    R15,2(R15)\n         BCTR  R1,0\n         EX    R1,MOVE\n         LA    R14,1(R1,R14)\n         TM    FLAGS,QFLG\n         BZ    *+L'*+8\n         MVI   0(R14),C''''\n         LA    R14,1(R14)\n         MVI   0(R14),C''''\n         LA    R14,1(R14)\n         MVI   0(R14),C' '\n         LA    R14,1(R14)\n         LH    R1,0(R2)\n         LA    R15,2(R2)           LOAD ADDRESS OF DSNAME\n         BCTR  R1,0\n         EX    R1,MOVE\n         LA    R14,1(R1,R14)\n         LA    R0,WORKHEAD\n         SR    R14,R0\n         STH   R14,WORKLEN\n         XC    WORKOFF,WORKOFF\n         BAL   R14,PUTLNE\n         BR    R6                  RETURN\n         EJECT\n*------- LINK TO DAIR ROUTINE.\n*        ON ENTRY - R14 = RETURN ADDRESS (LINK REGISTER).\n*              DON'T USE : R7 = A.PPL                              -EU-\n*                          R9 = BASE FOR DSNAME PDE                -EU-\n*              WORK-REGISTERS : R0-R1-R14-R15                      -EU-\n         SPACE 1\nDAIRRTN  ST    R14,DSVR14          SAVE RETURN\n         XC    ECB,ECB\n        CALLTSSR EP=IKJDAIR,MF=(E,DAIRPL)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    DAIRRTNX            ALL OK\n         ST    R15,SVR15\n         LA    R0,DAIRPL\n         LA    R1,DAIRFPL\n         USING DFDSECTD,R1\n         ST    R0,DFDAPLP\n         LA    R0,SVR15\n         ST    R0,DFRCP\n         XC    DWORK(4),DWORK\n         MVC   DWORK+4(2),=H'1'\n         LA    R0,DWORK\n         ST    R0,DFJEFF02\n         LA    R0,DWORK+4\n         ST    R0,DFIDP\n         DROP  R1\n        LINK   EP=IKJEFF18         ERROR MESSAGE ROUTINE\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    DAIRRTNX            ALL OK\n         MVC   WORKBUFF(31),=CL31'DAIRFAIL ERROR / RETURN CODE = '\n         ST    R15,DWORK+4\n         UNPK  DWORK(5),DWORK+6(3)\n         TR    DWORK(4),HEXTB-C'0'\n         MVC   WORKBUFF+31(4),DWORK\n         LA    R0,L'WORKHEAD+35\n         STH   R0,WORKLEN\n         XC    WORKOFF,WORKOFF\n         LA    R0,WORKHEAD\n         BAL   R14,PUTLNE\nDAIRRTNX L     R14,DSVR14          RESTORE RETURN\n         BR    R14                 BACK TO CALLER\n         EJECT\n*------- FREE DATA-SETS BY DDNAME ROUTINE.\n*        ON ENTRY - R1 = ADDRESS OF DDNAME,\n*                   R6 = RETURN ADDRESS (LINK REGISTER)\n*              DON'T USE : R7 = A.PPL                              -EU-\n*                          R9 = BASE FOR DSNAME PDE                -EU-\n*              WORK-REGISTERS : R0-R1-R14-R15                      -EU-\n         SPACE 1\nFREEDDN  LA    R14,DAIRPB\n         USING DAPB18,R14\n         MVC   DA18CD,CD18\n         XC    DA18FLG(10),DA18FLG\n         MVC   DA18DDN,0(R1)       MOVE IN DDNAME\n         MVC   DA18MNM,=CL8' '\n         MVC   DA18SCLS(L'DA18SCLS),=CL8' '\n         MVI   DA18DPS2,DA18KEEP\n         MVI   DA18CTL,DA18PERM    UNALLOC PERM\n         MVC   DA18JBNM,=CL8' '\n         DROP  R14\n         BAL   R14,DAIRRTN         LINK TO DAIR\n         BR    R6                  RETURN\n         EJECT\n*------- ADDRESSES, PARM BLOCKS, ETC...\n         SPACE 1\nATREF   ATTACH SF=L\nATREFL   EQU   *-ATREF\nSTXREF  STAX   STXEXIT,MF=L\nSTXREFL  EQU   *-STXREF\nPGREF   PUTGET MF=L\nPGREFL   EQU   *-PGREF\nPTREF   PUTLINE MF=L\nPTREFL   EQU   *-PTREF\nSTAKREF STACK  MF=L\nSTAKREFL EQU   *-STAKREF\nOPENREF OPEN   (,),MF=L\nOPENREFL EQU   *-OPENREF\nCLOSREF CLOSE  (,),MF=L\nCLOSREFL EQU   *-CLOSREF\n         PRINT NOGEN\nWSKEL   WTO    'XX',ROUTCDE=11,DESC=7,MF=L\nSKELDCB DCB    DSORG=PO,MACRF=R,DDNAME=XXXXXXXX   SKELETON DCB\n         PRINT GEN\nSKELDCBL EQU   *-SKELDCB\nSPLIST   DC    AL1(3,0,1,78)       SHARE SUBPOOL LIST\n        CNOP   0,4\nCD08     DS    0XL2                CODE 0008\nHV8      DC    H'8'\nCD0C     DS    0XL2                CODE 000C\nHV12     DC    H'12'\nCD10     DS    0XL2                CODE 0010\nHV16     DC    H'16'\nCD18     DS    0XL2                CODE 0018\nHV24     DC    H'24'\nHEXTB    DC    C'0123456789ABCDEF' CONVERT TABLE\n         EJECT\n*------- MESSAGES.\n         SPACE 1\nMSG01    DC    Y(MSG01L,0)\n         DC    C'INVALID DATA-SET NAME'\nMSG01L   EQU   *-MSG01\nMSG02    DC    Y(MSG02L,0)\n         DC    C' ENTER TASKLIB DATA-SET NAME-'\nMSG02L   EQU   *-MSG02\nMSG03    DC    Y(MSG03L,0)\n         DC    C'DATA-SET NAME LENGTH EXCEEDS 44 BYTES'\nMSG03L   EQU   *-MSG03\nMSG04    DC    Y(MSG04L,0)\n         DC    C'NO MORE THAN 10 DATA-SET NAMES MAY BE SPECIFIED BY THE1\n                TASKLIB KEYWORD'\nMSG04L   EQU   *-MSG04\nMSG05    DC    Y(MSG05L,0)\n         DC    C' ENTER NULL LINE TO CONTINUE, NON-NULL LINE TO STOP-'\nMSG05L   EQU   *-MSG05\nMSG06    DC    Y(MSG06L,0)\n         DC    C'ERROR IN CONCATENATING TASK LIBRARIES'\nMSG06L   EQU   *-MSG06\nMSG07    DC    Y(MSG07L,0)\n         DC    C'PARM-FIELD SPECIFIED EXCEEDS 256 BYTES, TRUNCATED'\nMSG07L   EQU   *-MSG07\nMSG07A   DC    Y(MSG07AL,0)\n         DC    C'COMMAND-LINE SPECIFIED EXCEEDS 256 BYTES, TRUNCATED'\nMSG07AL  EQU   *-MSG07A\nMSG08    DC    Y(MSG08L,0)\n         DC    C'NO TASK LIBRARIES'\nMSG08L   EQU   *-MSG08\nMSG09    DC    Y(MSG09L,0)\n         DC    C'TASKLIB DCB OPEN ERROR'\nMSG09L   EQU   *-MSG09\nMSG10    DC    Y(MSG10L,0)\n         DC    C'ERROR IN DECONTENATING TASK LIBRARIES'\nMSG10L   EQU   *-MSG10\nMSG11    DC    Y(MSG11L,0)\n         DC    C' ENTER PROGRAM NAME, OR NULL LINE TO STOP-'\nMSG11L   EQU   *-MSG11\nMSG11A   DC    Y(MSG11AL,0)\n         DC    C' ENTER COMMAND NAME, OR NULL LINE TO STOP-'\nMSG11AL  EQU   *-MSG11A\nMSG12    DC    Y(MSG12L,0)\n         DC    C'PROGRAM NAME EXCEEDS 8 CHARACTERS'\nMSG12L   EQU   *-MSG12\nMSG12A   DC    Y(MSG12AL,0)\n         DC    C'COMMAND NAME EXCEEDS 8 CHARACTERS'\nMSG12AL  EQU   *-MSG12A\nMSG13    DC    Y(MSG13L,0)\n         DC    C'MAXIMUM NUMBER OF ALLOCATIONS EXCEEDED'\nMSG13L   EQU   *-MSG13\nMSG14    DC    Y(MSG14L,0)                                          RRS\n         DC    C' ENTER COMMAND-LINE FOR CP-'                       RRS\nMSG14L   EQU   *-MSG14                                              RRS\nMSG15    DC    Y(MSG15L,0)\n         DC    C'AC REJECTED, SORRY'\nMSG15L   EQU   *-MSG15\nMSG16    DC    Y(MSG16L,0)\n         DC    C'TASKLIB DATA-SET IS NOT AN APF LIBRARY'\nMSG16L   EQU   *-MSG16\nOUT01L   DC    Y(L'OUT01)\nOUT01    DC    C'IS AN INVALID TASK LIBRARY NAME'\nOUT02L   DC    Y(L'OUT02)\nOUT02    DC    C'NOT IN CATALOG'\nOUT03L   DC    Y(L'OUT03)\nOUT03    DC    C'IS NOT PARTITIONED'\nOUT04L   DC    Y(L'OUT04)\nOUT04    DC    C'ALLOCATION ERROR'\nPTERROR  DC    C'PUTLINE ERROR'\n         EJECT\n*------- LITERAL POOL.\n         SPACE 1\n        LTORG\n         EJECT\n*------- PARAMETER CONTROL LIST FOR PARSE.\n         SPACE 1\n         PRINT NOGEN\nPPLPARM  IKJPARM DSECT=PDL\nLOADMOD  IKJIDENT 'LOAD-MOD-NAME',                                     1\n               MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM,                   2\n               PROMPT='NAME OF PROGRAM OR COMMAND TO BE EXECUTED'\nPARMA    IKJPOSIT QSTRING,                                             1\n               HELP=('PARM-FIELD TO BE PASSED TO PROGRAM OR',          2\n               'COMMAND-LINE TO BE PASSED TO COMMAND PROCESSOR')\nTASKEYWD IKJKEYWD\n         IKJNAME 'TASKLIB',SUBFLD=TASKSUBF\n         IKJNAME 'LIB',SUBFLD=TASKSUBF\nRCKEYWD  IKJKEYWD DEFAULT='RC'\n         IKJNAME 'RC'\n         IKJNAME 'NORC'\n         IKJNAME 'ALLRC'\nACKEYWD  IKJKEYWD\n         IKJNAME 'AC'\nTASKSUBF IKJSUBF\nTASKDSNA IKJPOSIT DSNAME,LIST,                                         1\n               PROMPT='TASKLIB OR LIB DATA-SET NAME(S)'\n         IKJENDP\n         SPACE 1\n*------- PARSE PARM CONTROL LIST FOR PROMPT OF TASKLIB DATA-SET NAME.\n         SPACE 1\nDSNPPL   IKJPARM DSECT=DSNPDL\nNEWDSN   IKJPOSIT DSNAME,PROMPT='TASKLIB OR LIB DATA-SET NAME'\n         IKJENDP\n         EJECT\n*------- DSECT FOR REENTRANCY.\n         SPACE 1\n         PRINT GEN\nWKAREA   DSECT\n         DS    18F                 INITIAL SAVE AREA\nSTXSAVE  DS    18F                 STAX SAVE AREA\nDWORK    DS    D\nSVR14    DS    F\nDSVR14   DS    F\nSVR15    DS    F\nIOPLA    DS    0F,(LIOPL)X\nSTAKIOPL DS    0F,(LIOPL)X\nPARMADDR DS    F                   ADDR OF PARM-FIELD\nSTAKECB  DS    F\nECB      DS    F\nTCB      DS    F\nPARSEPL  DS    0F,(LPPL)X          PARSE PARM LIST\nDAIRPL   DS    0F,(LDAPL)X         DAIR PARM LIST\nDAIRPB   DS    0F,(MAXDPBL)X       DAIR PARM BLOCK\nDAIRFPL  DS    0F,(DFLEN)X         DAIR FAILURE PARM LIST\nANSWER0  DS    F\nANSWER1  DS    F\nOLD      DS    2F\nCOMPCDE  DS    F                                             JFS04NOV77\nEPENTRY  DC    Y(1,LBLDL)          BLDL LIST\nEPNAME   DS    CL8,XL60\nLBLDL    EQU   *-EPNAME\nWORKHEAD DS    0F\nWORKLEN  DS    H\nWORKOFF  DS    H\nWORKBUFF DS    CL120\nATTACH  ATTACH SF=L\nSTXLIST STAX   STXEXIT,USADDR=STXSAVE,MF=L\nPGPB    PUTGET MF=L\nPTPB    PUTLINE MF=L\nSTAK    STACK  MF=L\nOPEN    OPEN   (,),MF=L\nCLOSE   CLOSE  (,),MF=L\nUSERIDL  DS    H\nUSERID   DS    CL8\nMYCPSWIT DS    F                   4 ==> DOPROG, 0 ==> DOCP         RRS\nMYCPPL   DS    0F                  DOCP CPPL FOR TARGET CP          RRS\n         DS    (CPPLLEN)X\n         PRINT NOGEN\nTASKLIB DCB    DSORG=PO,MACRF=R,DDNAME=XXXXXXXX\n         PRINT GEN\nEPNAMEL  DS    H\nCMDLEN   DS    H\nCMDOFF   DS    H\nCMDBUF   DS    CL44\nDSNLEN   DS    H\nDSNAME   DS    CL44\nNODDNS   DS    H\nDDNAMES  DS    10CL8\nPARMFLDL DS    H\nPARMFLD  DS    CL256,CL2\nFLAGS    DS    X\nAUTH     DS    X\nREQAUT   DS    0F,BL1,AL3,AL4\nREQAUTL  EQU   *-AUTH\nSVPCMD   DS    CL8\nSVSCMD   DS    CL8\n        $TEW$WA\nWTOMSG   DS    F                   WTO - TEXT LENGTH, MCSFLAGS\nERRMSG   DS    CL88                ERROR MESSAGE AREA\n         DS    XL4                 WTO - DESCRIPTOR AND ROUTING CODES\nWKLEN    EQU   (((*-WKAREA)+7)/8)*8\n         SPACE 1\n*------- MAPPING DSECTS.\n         SPACE 1\n         PRINT NOGEN\n        $TEW$DS CVT=YES\n        IKJECT\n        IKJIOPL\nLIOPL    EQU   *-IOPL\n        IKJUPT\n        IKJPPL\nLPPL     EQU   *-PPL\n        IKJDAPL\nLDAPL    EQU   *-DAPL\n        IKJDAP08\nMAXDPBL  EQU   (((*-DAPB08)+7)/8)*8 LARGEST DAIR PARM BLOCK\n        IKJDAP0C\n        IKJDAP10\n        IKJDAP18\n        IKJEFFDF DFDSECT=YES,DFDSEC2=YES\n        DCBD   DEVD=DA,DSORG=PO\n        IEZDEB LIST=YES\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DOPROG$": {"ttr": 6915, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15G\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:47:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": "//DOPROG   JOB (........),'INSTALL  - DOPROG-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ4AS3,OPT=',RENT',MBR=DOPROG\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT'\n//SYSIN     DD *\n  ALIAS   DOCP\n  ENTRY   DOPROG\n  NAME    DOPROG(R)\n/*\n//HLP     EXEC PAJHELP,MBR=DOPROGH,DSS='->.SOURCE.FILE4'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DOPROG@": {"ttr": 6917, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\to\\x00\\x89\\to\\x16Y\\x00)\\x00)\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-04-06T00:00:00", "modifydate": "1989-04-06T16:59:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "SYSPAJA"}, "text": "1   06/04/89\n                                                      DOPROG    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *  DOPROG/DOCP TSO command processor  * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  CBT origin : Extracted from CBT tape 88 FEB, file 369.\n  ------------\n\n  Purpose :   This command processor is designed to load and execute\n  ---------   (ATTACH) a program or a command in one of the system\n              link libraries or a user library (TASKLIB).\n       Note - The return code from the executed program or command is\n              always passed. If this command processor encounters an\n              error or an attention is entered, the return code is 16.\n\n  Syntax :    DOPROG/DOCP  LOAD-MOD-NAME\n  --------                 'PARMS'\n                           TASKLIB/LIB('DSLIST')\n                           RC/NORC/ALLRC\n                           AC\n\n  Operands :\n  ----------\n  LOAD-MOD-NAME : name of the load module (program or command) to be\n               executed.\n  'PARMS' :    parm-field to be passed to the program or command line\n               to be passed to command processor (quoted string).\n  TASKLIB('DSLIST') : specifies the data-set name(s) that are to be\n               concatenated and used for as TASK library, or\n  LIB('DSLIST') : alias of TASKLIB.\n  RC :         specifies that the non-zero return code from the\n               executed program or command is to be viewed, or\n  NORC :       specifies that the return code is not to be viewed\n               (default), or\n  ALLRC :      specifies that the return code is to be viewed.\n  AC :         specifies authorized mode (restricted to only Systems\n               Support personnel).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DOPROGH": {"ttr": 6919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\to\\x00\\x89\\to\\x17\\x11\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-04-06T00:00:00", "modifydate": "1989-04-06T17:11:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=DOPROG\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  THIS COMMAND PROCESSOR IS DESIGNED TO LOAD AND EXECUTE\n               (ATTACH) A PROGRAM OR A COMMAND IN ONE OF THE SYSTEM\n               LINK LIBRARIES OR A USER LIBRARY (TASKLIB).\n        NOTE - THE RETURN CODE FROM THE EXECUTED PROGRAM OR COMMAND IS\n               ALWAYS PASSED. IF THIS COMMAND PROCESSOR ENCOUNTERS AN\n               ERROR OR AN ATTENTION IS ENTERED, THE RETURN CODE IS 16.\n)X SYNTAX :    DOPROG/DOCP  LOAD-MOD-NAME\n                            'PARMS'\n                            TASKLIB/LIB('DSLIST')\n                            RC/NORC/ALLRC\n                            AC\n)O OPERANDS :\n))LOAD-MOD-NAME : NAME OF THE LOAD MODULE (PROGRAM OR COMMAND) TO BE\n               EXECUTED.\n))'PARMS' :    PARM-FIELD TO BE PASSED TO THE PROGRAM OR COMMAND LINE\n               TO BE PASSED TO COMMAND PROCESSOR (QUOTED STRING).\n))TASKLIB('DSLIST') : SPECIFIES THE DATA-SET NAME(S) THAT ARE TO BE\n               CONCATENATED AND USED FOR AS TASK LIBRARY, OR\n  LIB('DSLIST') : ALIAS OF TASKLIB.\n))RC :         SPECIFIES THAT THE NON-ZERO RETURN CODE FROM THE\n               EXECUTED PROGRAM OR COMMAND IS TO BE VIEWED, OR\n  NORC :       SPECIFIES THAT THE RETURN CODE IS NOT TO BE VIEWED\n               (DEFAULT), OR\n  ALLRC :      SPECIFIES THAT THE RETURN CODE IS TO BE VIEWED.\n))AC :         SPECIFIES AUTHORIZED MODE (ONLY SYSTEM GROUP USER-ID'S\n               ALLOWED).\n./     ALIAS   NAME=DOCP\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DSNCHEC$": {"ttr": 6921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15G\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:47:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "SYSPAJA"}, "text": "//DSNCHECK JOB (........),'INSTALL - DSNCHECK -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=3\n//ASS     EXEC PAJ4AS3,OPT=',RENT',MBR=DSNCHECK\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT'\n//SYSIN     DD *\n  ENTRY   DSNCHECK\n  ALIAS   DSNC\n  NAME    DSNCHECK(R)\n/*\n//HLP     EXEC PAJHELP,MBR=DSNCHECH,DSS='->.SOURCE.FILE4'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DSNCHEC@": {"ttr": 6923, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12o\\x00\\x94\\x12o\\x13U\\x00d\\x00d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-06T00:00:00", "modifydate": "1994-05-06T13:55:00", "lines": 100, "newlines": 100, "modlines": 0, "user": "SYSPAJA"}, "text": "1   11/07/90\n                                                      DSNCHECK  1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *        DSNCHECK TSO command         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Command name :      DSNCHECK\n  Author :            Chuck Hoffman, consultant\n                      User Services Center\n                      Bureau of Systems Operations\n                      Office of Management Information Systems\n                      Executive Office for Administration and Finance\n                      Commonwealth of Massachusetts (PHEW)\n                      One Ashburton Place\n                      Boston, MA 02108\n  Origin :            Extracted from tape CBT 89 FEB, file 300\n                      Adapted by MOINIL P.A.\n  Function :          DSNCHECK is a command which checks the system\n                      catalogs for the existence of a data-set name\n                      or alias. If a library (PDS) member name is\n                      specified with the data-set name, DSNCHECK will\n                      check for the existence of the named member.\n\n  Syntax :\n  --------------------------------------------------------------------\n  Command    Operands\n  --------------------------------------------------------------------\n  DSNCHECK   dsname  LIST\n  DSNC               NOLIST\n  --------------------------------------------------------------------\n  Command alias : DSNC\n\n  Operands :\n     Required - none, you will be prompted for dsname\n     Default  - LIST\n\n     dsname = The data-set name you are checking the catalog for.\n                           If the name is enclosed in single quotes\n                           ('), it will be used as is. If it is not\n                           enclosed in single quotes, your TSO prefix\n                           will be added to the beginning of the name.\n                           If you want to check a library (PDS) for a\n                           particular member name, include the member\n                           name within parentheses at the end of the\n                           library name.\n              Examples :\n                 library (data-set) name : 'ABC.YOURLIB.TEXT'\n                 library and member name : 'ABC.YOURLIB.TEXT(LETTER)'\n1   11/07/90\n                                                      DSNCHECK  2/2.\n\n     LIST = Causes DSNCHECK to write a message on the terminal saying\n                           whether or not the data-set was cataloged.\n                           NOTE - LIST is the default.\n\n     NOLIST = Suppresses writing a message to the terminal concerning\n                           whether or not the data-set was cataloged.\n                           This is usefull in CLISTs.\n\n  Return codes :  0 - successfull in locating catalog entry, (and,\n                      optionally, member name).\n                  4 - member not found.\n                  8 - catalog error.\n                 12 - not partitioned data-set (only if member name).\n                 16 - parse error.\n                 20 - allocation error.\n                 24 - open error.\n                 28 - close error.\n                 32 - deallocation error.\n                 36 - run error.\n\n  Examples of use :\n  -----------------\n              1. Find out whether 'MASSTAX' is a member of your own\n                 data-set called LIB.LOAD :\n\n                       DSNCHECK  LIB.LOAD(MASSTAX)\n\n              2. Find out whether a catalog entry exists for a\n                 data-set named : 'ABC1234.STARTUP.CLIST'\n\n                       DSNCHECK  'ABC1234.STARTUP.CLIST'\n\n              3. Write a CLIST to execute a program named 'ACCTREPT'\n                 if it exists in either library 'ABC.PROD.LOAD' or\n                 'XYZ.TEST.LOAD' :\n\n                 PROC  0\n                       DSNCHECK 'ABC.PROD.LOAD(ACCTREPT)' NOLIST\n                       IF &LASTCC EQ 0 THEN +\n                         CALL 'ABC.PROD.LOAD(ACCTREPT)'\n                       ELSE DO\n                         DSNCHECK 'XYZ.TEST.LOAD(ACCTREPT)' NOLIST\n                         IF &LASTCC EQ 0 THEN +\n                           CALL 'XYZ.TEST.LOAD(ACCTREPT)'\n                         END\n                       EXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DSNCHECH": {"ttr": 6926, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12o\\x00\\x94\\x12o\\x13U\\x00*\\x00*\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-06T00:00:00", "modifydate": "1994-05-06T13:55:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=DSNCHECK\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  DSNCHECK is a command which checks the system catalogs\n               for the existence of a data-set name or alias.\n               If a library (PDS) member name is specified with the\n               data-set name, DSNCHECK will check for the existence\n               of the named member.\n)X SYNTAX :    DSNCHECK  dsname  LIST\n               DSNC              NOLIST\n               Command alias : DSNC\n               Return codes:  0 - successfull in locating catalog\n                                  entry (and, optionally, member name).\n                              4 - member not found.\n                              8 - catalog error.\n                             12 - not partitioned data-set (only if\n                                  member name).\n                             16 - parse error.\n                             20 - allocation error.\n                             24 - open error.\n                             28 - close error.\n                             32 - deallocation error.\n                             36 - run error.\n)O OPERANDS :  Required - none, you will be prompted for dsname\n               Default  - LIST\n))dsname : the data-set name you are checking the catalog for. If the\n               name is enclosed in single quotes ('), it will be used\n               as is. If it is not enclosed in single quotes, your TSO\n               prefix will be added to the beginning of the name.\n               If you want to check a library (PDS) for a particular\n               member name, include the member name within parentheses\n               at the end of the library name.\n               Examples :\n               library (data-set) name : 'ABC.YOURLIB.TEXT'\n               library and member name : 'ABC.YOURLIB.TEXT(LETTER)'\n))LIST : causes DSNCHECK to write a message on the terminal saying\n               whether or not the data-set was cataloged.\n               NOTE - LIST is the default.\n))NOLIST : suppresses writing a message to the terminal concerning\n               whether or not the data-set was cataloged. This is\n               usefull in CLISTs.\n./     ALIAS   NAME=DSNC\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DSNCHECK": {"ttr": 6928, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12o\\x00\\x94\\x12o\\x13I\\x01\\xf3\\x01\\xf3\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-06T00:00:00", "modifydate": "1994-05-06T13:49:00", "lines": 499, "newlines": 499, "modlines": 0, "user": "SYSPAJA"}, "text": "DSNC     TITLE 'DSNCHECK -- CHECK FOR DSN OR MEMBER NAME.'\nDSNCHECK START 0\n         SPACE 1\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*                          D S N C H E C K                            *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*\n* FUNCTION :   THIS TSO COMMAND PROCESSOR CHECKS THE SYSTEM CATALOG\n*              FOR THE EXISTENCE OF A NAME OR ALIAS.\n*              IF A MEMBER NAME IS SPECIFIED, \"DSNCHECK\" ATTEMPTS TO\n*              ALLOCATE THE DATA-SET, OPEN IT, AND CHECK FOR A MEMBER\n*              NAME WITH BLDL.\n*\n* SYNTAX :     DSNCHECK  DSNAME  LIST\n*              DSNC              NOLIST\n*\n* ATTRIBUTES : RENT\n* LKED OPTIONS : RENT, REUS, ALIAS(DSNC)\n* RETURN CODES :   0 - SUCCESSFULL\n*                  4 - MEMBER NOT FOUND\n*                  8 - CATALOG ERROR\n*                 12 - NOT PARTITIONED DATA-SET (ONLY IF MEMBER)\n*                 16 - PARSE ERROR\n*                 20 - ALLOCATION ERROR\n*                 24 - OPEN ERROR\n*                 28 - CLOSE ERROR\n*                 32 - DEALLOCATION ERROR\n*                 36 - RUN ERROR\n*\n* AUTHOR :     CHUCK HOFFMAN, CONSULTANT\n*              USER SERVICES CENTER\n*              BUREAU OF SYSTEMS OPERATIONS\n*              OFFICE OF MANAGEMENT INFORMATION SYSTEMS\n*              EXECUTIVE OFFICE FOR ADMINISTRATION AND FINANCE\n*              COMMONWEALTH OF MASSACHUSETTS (PHEW)\n*              ONE ASHBURTON PLACE\n*              BOSTON, MA 02108\n* ORIGIN :     EXTRACTED FROM TAPE CBT 89 FEB, FILE 300.\n*\n* MAINTENANCE HISTORY :\n*           1. ADD FEATURE TO ALLOCATE, OPEN, AND BLDL IF A  CAH83351A\n*              MEMBER NAME IS SPECIFIED IN THE DSNAME.       CAH83351A\n*           2. MODIFY REPORTING TO ACCOUNT FOR MEMBER NAMES. CAH83351A\n*           3. CHANGE DEFAULT FROM NOLIST TO LIST.           CAH83351A\n*           4. ADAPTED BY MOINIL P.A.                             -EU-\n         EJECT\nDSNCHECK AMODE 24\nDSNCHECK RMODE 24\n         SPACE 1\n        $DEFREG\n* REGISTER USAGE :\n*              R0-R1 - LINKAGE CONVENTIONS, MACROS\n*              R2-R5 - WORK\n*                 R6 - (UNUSED)\n*                 R7 - CPPL POINTER\n*                 R8 - COMPLETION CODE\n*                 R9 - BASE OF DSECT IKJPARMD\n*                R10 - BASE OF DSECT WKAREA\n*                R11 - (UNUSED)\n*                R12 - BASE OF CSECT CHECKDSN\n*                R13 - SAVE AREA POINTER\n*                R14 - LINKAGE CONVENTIONS, RETURN ADDRESS\n*                R15 - LINKAGE CONVENTIONS, RETURN CODE\n         EJECT\n        $XENT  BASE=R12,LV=WKLEN,TYPE=RENT\n         LR    R10,R13             GET WORK-AREA ADDRESS\n         USING WKAREA,R10          ADDRESSABILITY OF WORK-AREA\n         LA    R2,18*4(R10)\n         L     R3,=A(WKLEN-(18*4))\n         LR    R4,R2\n         XR    R5,R5\n         MVCL  R2,R4\n         LR    R7,R1               GET ENTRY REGISTER\n        $TEW$EC REG=R7,MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE\n         USING CPPL,R7\n         XR    R8,R8               SET COMPLETION CODE -------------- 0\n        $TEW$PP PARM=PARMLST,REG=R9,ERR=PARSERR\n         SPACE 1\n*------- GET DATA-SET NAME\n         SPACE 1\n         MVI   DSNARG,C' '         CLEAR DSN + TRAILING SPACE\n         MVC   DSNARG+1(L'DSNARG-1),DSNARG\n         LA    R2,PDSN             R2 POINTER TO PDE FOR DSN\n         LH    R3,4(0,R2)          R3 IS LENGTH OF DSN\n         L     R2,0(,R2)           R2 POINTS TO DSN\n         STH   R3,DSNARGLN         SAVE IT\n         BCT   R3,*+L'*+6          R3-1 FOR EXEC\n         MVC   DSNARG(*-*),0(R2)   MOVE DSN TO STORAGE\n         EX    R3,*-6              EXECUTE THE MOVE\n         SPACE 1\n*------- INITIALIZE CIR PARM LIST\n         SPACE 1\n         MVC   CIRPARM(CIRDATAL),CIRDATA CONSTANTS TO PARM LIST\n         LA    R1,CIRWORK          ADDR OF WORK AREA\n         ST    R1,CIRWA            INTO PARM LIST\n         LA    R1,CIRRSA           ADDR OF S.A\n         ST    R1,CIRSAVE          INTO PARM LIST\n         LA    R1,DSNARG           ADDR OF DSN\n         ST    R1,CIRSRCH          INTO PARM LIST\n         MVC   AREALN,=Y(VDATAL)   SET LENGTH OF WORK AREA\n         SPACE 1\n*------- GET INFORMATION FROM CATALOG\n         SPACE 1\n        CALLTSSR EP=IKJEHCIR,MF=(E,CIRPARM)\n         LTR   R15,R15             AND TEST COMPLETION\n         BZ    *+L'*+12            BRANCH IF GOOD\n         ST    R15,ERRCDE          SAVE RETURN CODE\n         LA    R8,8                SET RETURN CODE ------------------ 8\n         B     MALIST\n         SPACE 1\n*------- GET MEMBER NAME INFORMATION\n         SPACE 1\n         TM    PDSN+14,X'80'       ANY MEMBER NAME ?\n         BZ    MALIST              NO\n         LA    R1,DAWRBP           LINK CONTROL BLOCKS\n         USING S99RBP,R1\n         LA    R2,DAWRB\n         ST    R2,S99RBPTR\n         OI    S99RBPTR,S99RBPND\n         DROP  R1\n         USING S99RB,R2\n         MVI   S99RBLN,S99RBEND-S99RB\n         MVI   S99VERB,S99VRBAL\n         MVI   S99FLG11,S99ONCNV+S99NOMNT\n         MVI   S99FLG12,0\n         LA    R1,DAWTUPL\n         ST    R1,S99TXTPP\n         DROP  R2\n         USING S99TUNIT,R1\n         LA    R1,DAWTUN02\n         LA    R2,DALDSNAM         DSNAME\n         STH   R2,S99TUKEY\n         MVC   S99TUNUM,=H'1'\n         MVC   S99TULNG,=Y(L'DAWDSNAM)\n         MVI   S99TUPAR,C' '\n         MVC   S99TUPAR+1(L'DAWDSNAM-1),S99TUPAR\n         ST    R1,DAWTUP02\n         LA    R1,DAWTUN04\n         LA    R2,DALSTATS         DATA-SET STATUS\n         STH   R2,S99TUKEY\n         MVC   S99TUNUM,=H'1'\n         MVC   S99TULNG,=H'1'\n         MVI   S99TUPAR,X'08'      STATUS SHR\n         ST    R1,DAWTUP04\n         LA    R1,DAWTUN55\n         LA    R2,DALRTDDN         RETURN DD-NAME\n         STH   R2,S99TUKEY\n         MVC   S99TUNUM,=H'1'\n         MVC   S99TULNG,=H'8'\n         MVC   S99TUPAR(8),=CL8' '\n         ST    R1,DAWTUP55\n         LA    R1,DAWTUN57\n         LA    R2,DALRTORG         RETURN DS ORGANIZATION\n         STH   R2,S99TUKEY\n         MVC   S99TUNUM,=H'1'\n         MVC   S99TULNG,=H'2'\n         ST    R1,DAWTUP57\n         OI    DAWTUP57,S99TUPLN\n         DROP  R1\n         LA    R2,DAUDFPRM\n         USING DFDSECTD,R2\n         MVC   DFS99RBP,DAWRBP     PTR TO RB\n         LA    R1,DAUS99RC\n         ST    R1,DFRCP            PTR TO S99RC\n         LA    R1,DAUF02EP\n         ST    R1,DFJEFF02         PTR TO EP\n         LA    R1,DAUID\n         ST    R1,DFIDP            PTR TO SW+ID\n         ST    R7,DFCPPLP          PTR TO CPPL\n         DROP  R2\n         MVC   DAUID,=XL2'0032'\n         L     R2,PDSN             R2 POINTS TO DSN\n         LH    R3,PDSN+4           R3 IS DSN LENGTH\n         BCT   R3,*+L'*+6          R3-1 FOR EXEC\n         MVC   DAWDSNAM(*-*),0(R2) MOVE DSN TO T.U.\n         EX    R3,*-6              EXECUTE MOVE\n         LA    R1,DAWRBP           DO DYNAMIC ALLOCATION\n        DYNALLOC ,\n         LTR   R15,R15             TEST RC\n         BZ    DAWOK               BRANCH IF GOOD\n         ST    R15,DAUS99RC        SAVE RC FROM SVC 99\n         LA    R1,DAUDFPRM         POINT TO IKJEFF18 PARM\n        LINK   EP=IKJEFF18         GO TO IKJEFF18 (DAIRFAIL)\n         LA    R8,20               SET RETURN CODE ----------------- 20\nMEABORT  OI    SWITCH,SWAB         TURN ON ABORT SW\n         B     MALIST              GO TO ERROR\nDAWOK    TM    DAWRTORG,DCBDSGPO   IS DSORG PO/POU ?\n         BO    *+L'*+8             BRANCH IF YES\n         LA    R8,12               SET RETURN CODE ----------------- 12\n         B     MEABORT             GO TO ABORT\n         MVC   INDCB(DCBMODLL),DCBMODEL INITIALIZE DCB\n         LA    R2,INDCB            R3 POINTS TO IN DCB\n         USING IHADCB,R2           ADDRESSABILITY\n         MVC   DCBDDNAM,DAWRTDDN   FILL IN DDNAME\n         MVC   OPENLIST(4),OPENLI  OPTIONS TO PARM LIST\n         STCM  R2,B'0111',OPENLIST+1 INTO PARM LIST\n        OPEN  MF=(E,OPENLIST)      OPEN THE DATA-SET\n         TM    DCBOFLGS,DCBOFOPN   OPEN SUCCESSFULL ?\n         BO    *+L'*+12            BRANCH IF YES\n         ST    R15,ERRCDE          SAVE RETURN CODE\n         LA    R8,24               SET RETURN CODE ----------------- 24\n         B     MEABORT             GO TO ABORT\n         DROP  R2                  DROP ADDRESSABILITY\n         MVC   BLDLLIST(BLDLDATL),BLDLDAT INIT BLDL LIST\n         L     R2,PDSN+8           R2 POINT TO MEM NAME\n         LH    R3,PDSN+12          R3 IS MEM NAME LEN\n         BCT   R3,*+L'*+6          R3-1 FOR EXEC\n         MVC   BLDLLIST+4(*-*),0(R2) NAME TO BLDL LIST\n         EX    R3,*-6              EXECUTE MOVE\n        BLDL   INDCB,BLDLLIST      DO BLDL\n         LR    R3,R15              SAVE BLDL RETURN CODE\n         LA    R2,INDCB            ADDRESS OF INPUT DCB\n         MVC   CLOSLIST(4),CLOSLI  INITIALIZE PARM LIST\n        CLOSE  ((R2)),MF=(E,CLOSLIST) CLOSE THE DATA-SET\n         LR    R4,R15              SAVE CLOSE RETURN CODE\n         LA    R1,DUWRBP           LINK CONTROL BLOCKS\n         USING S99RBP,R1\n         LA    R2,DUWRB\n         ST    R2,S99RBPTR\n         OI    S99RBPTR,S99RBPND\n         DROP  R1\n         USING S99RB,R2\n         MVI   S99RBLN,S99RBEND-S99RB\n         MVI   S99VERB,S99VRBUN\n         MVI   S99FLG11,S99ONCNV+S99NOMNT\n         MVI   S99FLG12,0\n         XC    S99ERROR,S99ERROR\n         XC    S99INFO,S99INFO\n         LA    R1,DUWTUPL\n         ST    R1,S99TXTPP\n         XC    S99S99X,S99S99X     (OLD S99RSV01 FIELD)            -EU-\n         XC    S99FLAG2,S99FLAG2\n         DROP  R2\n         USING S99TUNIT,R1\n         LA    R1,DUWTUN01\n         LA    R2,DUNDDNAM         DDNAME\n         STH   R2,S99TUKEY\n         MVC   S99TUNUM,=H'1'\n         MVC   S99TULNG,=H'8'\n         MVC   S99TUPAR(8),=CL8' '\n         ST    R1,DUWTUP01\n         OI    DUWTUP01,S99TUPLN\n         DROP  R1\n         LA    R2,DAUDFPRM\n         USING DFDSECTD,R2\n         MVC   DFS99RBP,DUWRBP     PTR TO RB\n         LA    R1,DAUS99RC\n         ST    R1,DFRCP            PTR TO S99RC\n         LA    R1,DAUF02EP\n         ST    R1,DFJEFF02         PTR TO EP\n         LA    R1,DAUID\n         ST    R1,DFIDP            PTR TO SW+ID\n         ST    R7,DFCPPLP          PTR TO CPPL\n         XC    DFBUFP,DFBUFP       ZERO BUFFER ADDRESS\n         DROP  R2\n         XC    DAUF02EP,DAUF02EP\n         MVC   DAUID,=XL2'0032'\n         MVC   DUWDDNAM(8),DAWRTDDN SET DDNAME\n         LA    R1,DUWRBP           DO DYNAMIC UNALLOCATION\n        DYNALLOC ,\n         LTR   R3,R3               TEST BLDL RETURN CODE\n         BZ    *+L'*+12            BRANCH IF GOOD\n         ST    R3,ERRCDE           SAVE RETURN CODE\n         LA    R8,4                SET RETURN CODE ------------------ 4\n         B     MALIST              GO TO ERROR\n         LTR   R4,R4               TEST CLOSE RETURN CODE\n         BZ    *+L'*+12            BRANCH IF GOOD\n         ST    R4,ERRCDE           SAVE RETURN CODE\n         LA    R8,28               SET RETURN CODE ----------------- 28\n         B     MALIST              GO TO ERROR\n         LTR   R15,R15             TEST RC\n         BZ    MALIST              BRANCH IF GOOD\n         ST    R15,DAUS99RC        SAVE RC FROM SVC 99\n         LA    R1,DAUDFPRM         POINT TO IKJEFF18 PARM\n        LINK   EP=IKJEFF18         GO TO IKJEFF18 (DAIRFAIL)\n         LA    R8,32               SET RETURN CODE ----------------- 32\n         SPACE 1\n*------- LIST DSN AND VOLUME, OR ERROR MESSAGE\n         SPACE 1\nMALIST   CLC   KLIST(2),=H'1'      IF 'LIST' OPERAND NOT USED\n         BNE   LEAVE               GO TO END\n         MVI   MSGAREA,C' '        CLEAR MESSAGE AREA\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA\n         LH    R2,DSNARGLN         R2 IS LENGTH OF DSNARG\n         B     *+L'*+6             BRANCH AROUND MOVE\n         MVC   MSGAREA(*-*),DSNARG MOVE DSN PLUS TRAILING BLANK\n         EX    R2,*-6              EXECUTE THE MOVE\n         LA    R2,MSGAREA+1(R2)    R2 POINTS TO NEXT PLACE IN MSG\n         CH    R8,=H'8'            IS CIR R/C ZERO ?\n         BE    NOTFND              NO, THUS CATALOG FAILS\n         SPACE 1\n*------- CONSTRUCT 'CATALOGED' MESSAGE\n         SPACE 1\n         MVC   0(3,R2),=CL3'ON '   'ON ' TO MSG\n         LA    R2,3(,R2)           INCR POINTER\n         MVC   0(6,R2),VOLSER      VOLSER TO MSG LINE\n         LA    R2,6(,R2)           INCR POINTER\n         TM    PDSN+14,X'80'       IF NO MEMBER NAME\n         BZ    SNDMSG              GO TO END\n         MVC   0(2,R2),=CL2', '    ', ' TO MSG\n         LA    R2,2(,R2)           INCR POINTER\n         L     R1,PDSN+8           R1 POINTS TO MEMNAME\n         LH    R3,PDSN+12          R3 IS LEN OF MEMNAME\n         BCT   R3,*+L'*+6          R3-1 FOR EXEC\n         MVC   0(*-*,R2),0(R1)     MEMNAME TO LINE\n         EX    R3,*-6              EXECUTE THE MOVE\n         LA    R2,1(R3,R2)         INCR POINTER\n         TM    SWITCH,SWAB         IS MEMBER SEARCH ABORTED ?\n         BZ    *+L'*+10            BRANCH IF NOT\n         MVC   0(12,R2),=CL12' NOT CHECKED'\n         B     SNDMSG\n         CH    R8,=H'4'            WAS BLDL BAD ?\n         BNE   *+L'*+10            BRANCH IF NOT\n         MVC   0(10,R2),=CL10' NOT FOUND'\n         B     SNDMSG\n         MVC   0(12,R2),=CL12' IS A MEMBER'\n         B     SNDMSG\n         SPACE 1\n*------- CONSTRUCT 'NOT FOUND' MESSAGE\n         SPACE 1\nNOTFND   MVC   0(20,R2),=CL20'NOT FOUND IN CATALOG'\nSNDMSG   LA    R0,L'MSGAREA        MESSAGE AREA LENGTH\n         LA    R1,MSGAREA          POINT TO MESSAGE AREA\n         BAS   R14,PUTLNE          WRITE THE MESSAGE\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     *+L'*+4             +0 - OK\n         B     LEAVE               +4 - ERROR\n         LTR   R8,R8               EVERY THING GOOD ?\n         BZ    LEAVE               BRANCH IF YES\n         SPACE 1\n*------- CONSTRUCT DIAGNOSE MESSAGE\n         SPACE 1\n         MVI   MSGAREA,C' '        CLEAR MESSAGE AREA\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA\n         MVC   MSGAREA(15),=CL15'===> DIAGNOSE :'\n         CH    R8,=H'4'\n         BNE   TRC8\n         CLC   ERRCDE,=F'4'         IS BLDL MEMBER NOT FOUND ?\n         BE    LEAVE                BRANCH IF YES\n         MVC   MSGAREA+16(4),=CL4'BLDL'\n         LA    R2,MSGAREA+21\n         B     SNDDIAG\nTRC8     CH    R8,=H'8'\n         BNE   TRC24\n         CLC   ERRCDE,=F'4'         IS IKJEHCIR NOT FOUND ?\n         BE    LEAVE                BRANCH IF YES\n         MVC   MSGAREA+16(8),=CL8'IKJEHCIR'\n         LA    R2,MSGAREA+25\n         B     SNDDIAG\nTRC24    CH    R8,=H'24'\n         BNE   TRC28\n         MVC   MSGAREA+16(4),=CL4'OPEN'\n         LA    R2,MSGAREA+21\n         B     SNDDIAG\nTRC28    CH    R8,=H'28'\n         BNE   LEAVE               OTHER, DIAGNOSE ALREADY DONE\n         MVC   MSGAREA+16(5),=CL5'CLOSE'\n         LA    R2,MSGAREA+22\nSNDDIAG  MVC   0(12,R2),=CL12'- R15 (RC) ='\n         UNPK  13(9,R2),ERRCDE(5)\n         MVI   21(R2),C' '\n         LA    R0,L'MSGAREA        MESSAGE AREA LENGTH\n         LA    R1,MSGAREA          POINT TO MESSAGE AREA\n         BAS   R14,PUTLNE          WRITE THE MESSAGE\n         B     LEAVE\n         SPACE 1\n*------- TERMINATION\n         SPACE 1\nPARSERR  LA    R8,16               YES, SET RETURN CODE ------------ 16\nLEAVE   IKJRLSA #TSANSW            RELEASE SPACE\n         B     QUIT\nSETRC    LA    R8,36               SET RETRUN CODE ----------------- 36\nQUIT    $XRET  CC=(R8),LV=WKLEN,TYPE=RENT\n         EJECT\n*------- DATA CONSTANTS\n         SPACE 1\n         PRINT NOGEN\nDCBMODEL DCB   DSORG=PO,MACRF=R,DDNAME=XXXXXXXX\nDCBMODLL EQU   *-DCBMODEL\nOPENLI  OPEN   (,(INPUT)),MF=L\nCLOSLI  CLOSE  (,),MF=L\n         PRINT GEN\n         SPACE 1\nCIRDATA  DS    0D                  CONSTANTS FOR CIR PARM\n         DC    XL1'04'             OPTIONS = GET VOLUME\n         DS    XL2'0'              RESERVED\n         DC    XL1'0'              LOCATE RETURN CODE\n         DC    A(*-*)              ADDRESS OF SEARCH ARGUMENT\n         DC    A(*-*)              ADDR OF VOLID OF CVOL\n         DC    A(*-*)              ADDR OF WORK AREA\n         DC    A(*-*)              ADDR OF SAVE AREA\n         DC    A(*-*)              ADDR OF PASSWORD\nCIRDATAL EQU   *-CIRDATA           LENGTH OF PARM BLOCK\n         SPACE 1\nBLDLDAT  DS    0F\nBLDLFF   DC    H'1'                1 ENTRY\nBLDLLL   DC    H'12'               SHORT FORMAT\nBLDLNAME DC    CL8' '              NAME\nBLDLTTRK DC    XL4'0'              TT, R, K\nBLDLDATL EQU   *-BLDLDAT\n         SPACE 1\n        LTORG\n         SPACE 1\n         PRINT NOGEN\nPARMLST  IKJPARM\nPDSN     IKJPOSIT DSNAME,USID,PROMPT='NAME OF DATA-SET TO BE LOCATED'\nKLIST    IKJKEYWD DEFAULT='LIST'\n         IKJNAME  'LIST'\n         IKJNAME  'NOLIST'\n         IKJENDP\n         PRINT GEN\n         EJECT\n*------- DATA WORK-AREA\n         SPACE 1\nWKAREA   DSECT\n         DS    18F                 REGISTER SAVE AREA\nCIRRSA   DS    18F                 CIR REGISTER SAVE AREA\n         SPACE 1\nCIRPARM  DS    0D\nCIROPT   DS    XL1                 OPTIONS = GET VOLUME\n         DS    XL2                 RESERVED\nCIRLOCRC DS    XL1                 LOCATE RETURN CODE\nCIRSRCH  DS    A                   ADDRESS OF SEARCH ARGUMENT\nCIRCVOL  DS    A                   ADDR OF VOLID OF CVOL\nCIRWA    DS    A                   ADDR OF WORK AREA\nCIRSAVE  DS    A                   ADDR OF SAVE AREA\nCIRPSWD  DS    A                   ADDR OF PASSWORD\n         SPACE 1\nDAWRBP   DS    F                   REQUEST BLOCKS FOR SVC 99\nDAWRB    DS    0F,((((S99RBEND-S99RB)+3)/4)*4)X\nDAWTUPL  DS    0F                  TEXT UNIT POINTER LIST\nDAWTUP02 DS    F\nDAWTUP04 DS    F\nDAWTUP55 DS    F\nDAWTUP57 DS    F\nDAWTUN02 DS    3H                  TEXT UNITS\nDAWDSNAM DS    CL44                DATA-SET NAME\nDAWTUN04 DS    3H\nDAWSTATS DS    XL1                 STATUS\nDAWTUN55 DS    3H\nDAWRTDDN DS    CL8                 RETURNED DD-NAME\nDAWTUN57 DS    3H\nDAWRTORG DS    XL2                 RETURNED DSORG\n         SPACE 1\nDAUDFPRM DS    0F,(DFLEN)X         PARM BLOCK FOR IKJEFF18\nDAUS99RC DS    F                   AREA FOR SVC 99 R/C\nDAUF02EP DS    F                   AREA FOR EP OF IKJEFF18\nDAUID    DS    XL2                 DAIRFAIL SWITCHES & CALLER ID\n         SPACE 1\nDUWRBP   DS    F                   REQUEST BLOCKS FOR SVC 99\nDUWRB    DS    0F,((((S99RBEND-S99RB)+3)/4)*4)X\nDUWTUPL  DS    0F                  TEXT UNIT POINTER LIST\nDUWTUP01 DS    F\nDUWTUN01 DS    3H                  TEXT UNITS\nDUWDDNAM DS    CL8                 DD-NAME\n         SPACE 1\nINDCB    DS    0F,(DCBMODLL)X\nOPENLIST DS    F                   OPEN PARM LIST\nCLOSLIST DS    F                   CLOSE PARM LIST\n         SPACE 1\n        $TEW$WA\n         SPACE 1\nBLDLLIST DS    0F,(BLDLDATL)X      BLDL ENTRY LIST\n         SPACE 1\nERRCDE   DS    F                   ERROR RETURN CODE (R15)\nMSGAREA  DS    CL80                OUTPUT MESSAGE LINE\n         SPACE 1\nDSNARGLN DS    H                   LENGTH OF DSN\nDSNARG   DS    CL45                DSN PLUS TRAILING SPACE\n         SPACE 1\nCIRWORK  DS    0F                  CIR WORK AREA\nAREALN   DS    H                   LENGTH OF AREA\n         DS    H                   LENGTH OF RETURNED DATA\nVDATA    DS    0H                  RETURNED VARIABLE DATA\n         DS    XL1                 NUMBER OF VOLUMES\nVOLDATA  DS    0XL12               RETURNED VOLUME INFORMATION\n         DS    XL4                 DEVICE TYPE\nVOLSER   DS    CL6                 VOLUME SERIAL NUMBER\n         DS    XL2                 FILE SEQUENCE NUMBER (TAPE)\n         DS    19XL(L'VOLDATA)\n         DS    XL1                 RESERVED (CONTAINS X'FF')\n         DS    XL9                 (UNUSED)\nVDATAL   EQU   *-VDATA\n         SPACE 1\nSWITCH   DS    XL1                 SWITCHES\nSWAB     EQU   X'80'               NO CHECK MEM NAME\n         SPACE 1\nWKLEN    EQU   (((*-WKAREA)+7)/8)*8     LENGTH OF WKAREA DATA AREA\n         SPACE 1\n*------- MAPPING MACROS\n         SPACE 1\n         PRINT NOGEN\n        $TEW$DS\n        IEFZB4D0 ,                 MAPS SVC-99 BLOCKS\n        IEFZB4D2\n        IKJEFFDF DFDSECT=YES,DFDSEC2=YES MAPS IKJEFF18 BLK\n        DCBD   DSORG=PS,DEVD=DA    MAPS THE DCB FOR DA\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSNTAB": {"ttr": 7175, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x19\\x0f\\x00\\x90\\x19\\x0f\\x16\\x11\\x00\\xa2\\x00\\xa2\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-07-09T00:00:00", "modifydate": "1990-07-09T16:11:00", "lines": 162, "newlines": 162, "modlines": 0, "user": "SYSPAJA"}, "text": "DSNT     TITLE 'DSNTAB -- DSNAME(S) OF A DDNAME.'\nDSNTAB   START  0\n         SPACE 1\n* ORIGIN :     EXTRACTED FROM TAPE CBT 89 FEB, FILE 270.\n*              DATA-SET 761KKDSNTB AT LEVEL 001 AS OF 08/30/82\n*              WRITTEN BY KERMIT KISER\n*              WASHINGTON STATE DP SERVICE CENTER (WDPSC)\n*              ADAPTED BY MOINIL P.A.\n*              ATTRIBUTES : RE-ENTERABLE\n* PURPOSE :    SUBROUTINE TO PASS BACK LIST OF ALL DSNAMES CONCATENATED\n*              TO A GIVEN DDNAME. THIS IS A SUBROUTINE WHICH ACCEPTS A\n*              A DDNAME AND PASSES PASSES BACK TO THE INVOKER A LIST OF\n*              DSNAMES CONCATENATED TO THAT DDNAME. THE MAXIMUM NUMBER\n*              OF DATA-SETS CONCATENATED TO A GIVEN DDNAME WHICH CAN\n*              BE PASSED BACK BY THE ROUTINE DEPENDS ON THE SIZE OF THE\n*              PASSED ARRAY TABLE. THE ROUTINE WILL DETERMINE WHETHER\n*              THE DDNAME PASSED IS ALLOCATED. IT IT IS ALLOCATED, THEN\n*              IT PASS BACK ALL OF THE ASSOCIATED DSNAMES (AND THEIR\n*              LENGTHS). IF THE DDNAME IS ALLOCATED AND THERE IS NO\n*              OVERFLOW OF THE CONCATENATED DATA-SETS NAMES TABLE, AT\n*              END, THE TABLE IS LOADED WITH ALL THE DSNAMES WHICH ARE\n*              ASSOCIATED WITH THE DDNAME AND THE NUMBER OF SIGNIFICANT\n*              ENTRIES IN THAT TABLE IS STORED. IF THE DDNAME IS NOT\n*              ALLOCATED, THE ROUTINE EXITS WITH RC=4, AND IF THERE\n*              IS AN OVERFLOW OF THE DATA-SETS NAMES TABLE, IT EXITS\n*              WITH RC=8.\n*\n* TO CALL THIS ROUTINE FROM A COBOL PROGRAM, DO THE FOLLOWING :\n*              1. PLACE THE FOLLOWING DATA AREAS IN WORKING STORAGE :\n*                 01  THE-DDNAME                        PIC X(8).\n*                 01  DSNAME-TABLE.\n*                     05  DSNAME-ELEMENT OCCURS N1 TIMES.\n*                         10  FILLER                    PIC X(2).\n*                         10  THE-DSNAME                PIC X(44).\n*                 01  TABLSIZE      VALUE +N2           PIC S9(4) COMP.\n*                 01  NO-OF-SIGNIF-DSNAMES              PIC S9(4) COMP.\n*                 WHERE : N1 IS THE MAXIMUM DESIRED NUMBER OF DATA-SETS\n*                         NAMES, AND N2 IS THE MULTIPLICATION RESULT\n*                         OF N1 BY THE LENGTH OF A TABLE ENTRY.\n*              2. PLACE THE FOLLOWING CODE IN THE PROCEDURE DIVISION :\n*                   MOVE YOUR DDNAME TO THE-DDNAME.\n*                   CALL 'DSNTAB' USING  THE-DDNAME\n*                                        DSNAME-TABLE\n*                                        TABLSIZE\n*                                        NO-OF-SIGNIF-DSNAMES.\n*              AFTER THE CALL, THE LIST OF DSNAMES WILL BE FOUND IN\n*              DSNAME-TABLE AND THE NUMBER OF SIGNIFICANT DATA-SET\n*              NAMES WILL BE FOUND IN NO-OF-SIGNIF-DSNAMES.\n         EJECT\n* POSSIBLE RETURN CODES :\n*    VALUE     MEANING\n*    -----     ------------------------------------------------\n*      0       SUCCESSFUL COMPLETION\n*      4       DDNAME NOT FOUND\n*      8       CONCATENATED DATA-SETS NAMES TABLE OVERFLOW\n         SPACE 2\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12,LV=WKLEN,TYPE=RENT\n         LR    R10,R13\n         USING WKAREA,R10\n         LA    R2,18*4(R10)\n         L     R3,=A(WKLEN-(18*4))\n         LR    R4,R2\n         XR    R5,R5\n         MVCL  R2,R4\n         L     R2,0(,R1)           R2 -> DDNAME PASSED\n         XR    R4,R4               R4 = 0 (RC)\n         XR    R5,R5               R5 = 0 (DSN COUNT)\n         L     R6,4(,R1)           R6 -> DSN TABLE\n         USING DSNTDS,R6\n         L     R7,8(,R1)           R7 -> SIZE OF TABLE\n         LH    R7,0(,R7)           R7 = LENGTH OF TABLE\n         L     R8,12(,R1)          R8 -> ENTRY COUNT PARM\n         MVC   EXTR(LEXTR),EXTRP\n         XC    ATIOT,ATIOT\n        EXTRACT ATIOT,'S',FIELDS=(TIOT),MF=(E,EXTR)\n         SPACE 1\n*------- FIND THE DDNAME IN THE TIOT\n         SPACE 1\n         L     R3,ATIOT            R3 -> TIOT\n         USING TIODSECT,R3\nMTCHL    CLC   TIOELNGH(4),=XL4'0' END OF TIOT ?\n         BNE   *+L'*+8             NO\n         LA    R4,4                YES, R4 = 4 (RC)\n         B     EXIT\n         CLC   TIOEDDNM(L'TIOEDDNM),0(R2) DDNAME MATCH ?\n         BE    *+L'*+8             YES\n         BAL   R14,NEXTDD          R3 -> NEXT DD ENTRY\n         B     MTCHL\n         SPACE 1\n*------- MOVE THE DSN IN THE TABLE\n         SPACE 1\nMOVEL    XR    R1,R1\n         ICM   R1,B'0111',TIOEJFCB R1 -> JFCB\n         CH    R7,=Y(DSNTDSEL)     ROOM IN TABLE FOR THIS NAME ?\n         BNL   *+L'*+8             YES -> DO IT\n         LA    R4,8                NO -> SAY TABLE SIZE ERROR (RC)\n         B     EXIT\n         USING ZB502,R1\n         MVC   DSNTDSN,JFCBDSNM    MOVE THE DSN INTO THE TABLE\n         DROP  R1\n         SPACE 1\n*------- FIND THE LENGTH OF THE DSN\n         SPACE 1\n         LA    R0,44\n         XR    R1,R1               R1 = 0 INIT DSN LEN\n         LA    R2,DSNTDSN          R2 -> DSN\nDSL      CLI   0(R2),C' '          IS IT BLANK ?\n         BE    DSEND               YES\n         LA    R1,1(,R1)           R1 + 1 -> NEXT CHAR\n         LA    R2,1(,R2)           R2 -> NEXT DSN CHAR TO BE CHECKED\n         BCT   R0,DSL              CHECK NEXT IF NO BLANK YET\nDSEND    STH   R1,DSNTDSL          PUT THE DSN LENGTH IN THE TABLE\n         SH    R7,=Y(DSNTDSEL)     UPDATE LENGTH REMAINING IN TABLE\n         LA    R5,1(,R5)           R5 + 1 = DSN COUNT IN TABLE\n         BAL   R14,NEXTDD          R3 -> NEXT DD-ENTRY IN TIOT\n         LA    R6,DSNTDSEL(,R6)    R6 -> NEXT SLOT IN NAME TABLE\n         CLC   TIOELNGH(4),=XL4'0' END OF TIOT ?\n         BE    EXIT                YES\n         CLC   TIOEDDNM(L'TIOEDDNM),=CL8' ' BLANK DD-NAME ?\n         BE    MOVEL               YES -> MUST BE CONCATENATED\nEXIT     STH   R5,0(R8)            PASS THE COUNT OF ENTRIES\n        $XRET  CC=(R4),LV=WKLEN,TYPE=RENT\n         SPACE 1\n*------- SUBROUTINE TO MOVE R3 TO THE NEXT DD-ENTRY IN THE TIOT\n         SPACE 1\nNEXTDD   XR    R0,R0\n         IC    R0,TIOELNGH        R0 = LENGTH OF CURRENT DD-ENTRY\n         ALR   R3,R0              R3 -> NEXT DD-ENTRY IN TIOT\n         BR    R14                RETURN\n         DROP  R3\n         EJECT\n*------- DATA CONSTANTS\n         SPACE 1\nEXTRP   EXTRACT *-*,'S',MF=L\n         SPACE 1\n        LTORG\n         SPACE 1\nWKAREA   DSECT\n         DS    18F            SAVE AREA\nEXTR    EXTRACT *-*,'S',MF=L\nLEXTR    EQU   *-EXTR\nATIOT    DS    A\n         SPACE 1\nWKLEN    EQU   (((*-WKAREA)+7)/8)*8\n         SPACE 1\n*------- DSNAME(S) TABLE DSECT\n         SPACE 1\nDSNTDS   DSECT\nDSNTDSL  DS    H\nDSNTDSN  DS    CL44\nDSNTDSEL EQU   *-DSNTDS\n         SPACE 1\n         SPACE 1\n        PRINT  NOGEN\nTIODSECT DSECT\n        IEFTIOT1\n        IEFZB502 , - - - - - - - -+\n        IEFJFCBN ,                +- SWA CONTROL BLOCK\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DSNTAB$": {"ttr": 7179, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x942o\\x00\\x942o\\x16'\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-22T00:00:00", "modifydate": "1994-11-22T16:27:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//DSNTAB   JOB (........),'INSTALL  - DSNTAB -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=5\n//ASS     EXEC PAJ4AS3,OPT=',RENT',MBR=DSNTAB\n//LNK     EXEC PAJILKR,OPT=',MAP,RENT'\n//SYSIN     DD *\n  ENTRY   DSNTAB\n  NAME    DSNTAB(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DSNTAB@": {"ttr": 7181, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x12$\\x00D\\x00D\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T12:24:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "SYSPAJA"}, "text": "1   10/07/90\n                                                      DSNTAB    1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *           DSNTAB ROUTINE            * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n\n  Routine :      DSNTAB\n  Author :       Kermit Kiser\n  Agency :       WDPSC\n  Origin :       Extracted from tape CBT 89 FEB, file 270\n  Language :     Assembler\n  Attributes :   Re-enterable\n  Function :     Subroutine to pass back list of all DSNAMEs\n                 concatenated to a given DDNAME.\n\n  This is a subroutine which accepts a DDNAME and passes back to the\n  invoker a list of DSNAMEs concatenated to that DDNAME. The maximum\n  number of data-sets concatenated to a given DDNAME which can be\n  passed back by the routine depends on the size of the passed array\n  table.\n\n  To use this routine from a COBOL program, do the following :\n       1. Place the following data areas in WORKING-STORAGE :\n          01  THE-DDNAME                        PIC X(8).\n          01  DSNAME-TABLE.\n              05  DSNAME-ELEMENT OCCURS N1 TIMES.\n                  10  FILLER                    PIC X(2).\n                  10  THE-DSNAME                PIC X(44).\n          01  TABLSIZE      VALUE +N2           PIC S9(4) COMP.\n          01  NO-OF-SIGNIF-DSNAMES              PIC S9(4) COMP.\n          where : N1 is the maximum desired number of data-sets names,\n                  and N2 is the multiplication result of N1 by the\n                  length of a table entry (value is 46).\n                  I.E. : if N1 = 99, then N2 = 4554 (99*46).\n       2. Place the following code in the PROCEDURE DIVISION :\n          MOVE your ddname TO THE-DDNAME.\n          CALL 'DSNTAB' USING THE-DDNAME\n                              DSNAME-TABLE\n                              TABLSIZE\n                              NO-OF-SIGNIF-DSNAMES.\n       After the CALL, the list of DSNAMES will be found in\n       DSNAME-TABLE and the number of significant data-set names\n       will be found in NO-OF-SIGNIF-DSNAMES.\n1   10/07/90\n                                                      DSNTAB    2/2.\n\n\n  To use this routine from an ASSEMBLER program, do the following :\n                ...\n                CALL  DSNTAB,(DDNAME,DSNTAB,TBSIZE,NODSN),VL\n                LTR   R15,R15            Test completion code\n                ...\n       DDNAME   DC    CL8'...'           The DDname\n       TBSIZE   DC    Y(N1*46)           Table size\n       NODSN    DC    H'0'               Number of significant names\n       DSNTAB   DC    (N1)XL46'0'        DSnames table array\n                ...\n\n  Return code   Meaning\n  -----------   ------------------------------------------------------\n\n       0        Successful completion\n       4        DDNAME not found\n       8        Concatenated data-sets names table overflow\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ETPS": {"ttr": 7425, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x07O\\x00\\x96\\x07O\\x13Y\\x11\\xa4\\x11\\xa4\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-03-14T00:00:00", "modifydate": "1996-03-14T13:59:00", "lines": 4516, "newlines": 4516, "modlines": 0, "user": "SYSPAJA"}, "text": "ETPS     TITLE '--- E T P S -- EMERGENCY TELE-PROCESSING SYSTEM ---'\n         PRINT OFF\n         COPY  ETPS$O2A            \"ETPS\" SYSPARM SELECTION\n         MACRO\n        @ULT   &DUMMY\n         GBLA  &ESSN\n         GBLC  &ESSO,&ESSE(1)\n         LCLA  &N\n*------- USERS TABLE ------------------------------------------------*\nUSERTBL  DS    0CL7                START USERS TABLE\n         DC    CL7'&ESSO'          MASTER USER\n&N       SETA  1\n.A       AIF   (&N GT &ESSN).D\n         AIF   ('&ESSE(&N)' EQ '').B\n         DC    CL7'&ESSE(&N)'\n         AGO   .C\n.B       AIF   (&N EQ &ESSN).D\n         DC    CL7' '\n.C       ANOP\n&N       SETA  &N+1\n         AGO   .A\n.D       DC    XL1'0'              END OF TABLE\n         MEND\n         MACRO\n        @MPW   &DUMMY\n         GBLC  &ESSM\n         AIF   ('&ESSM' EQ '').A\nMASTPASS DC    CL8'&ESSM'\n         AGO   .B\n.A       ANOP\nMASTPASS DC    CL8' '\n.B       MEND\n         COPY  ETPSMACS            \"ETPS\" MACROS\n         COPY  ETPSDEFS            \"ETPS\" DEFINITIONS\n         PRINT ON\nETPS     START 0\n         SPACE 1\nETPS     AMODE 24\nETPS     RMODE 24\n         SPACE 1\n**********************************************************************\n** --------------------------  E  T  P  S  ------------------------ **\n**********************************************************************\n**                                                                  **\n**  FUNCTION : THIS PROGRAM IS INTENDED TO PROVIDE EMERGENCY        **\n**             TELE-PROCESSING SERVICES WHEN THE NORMAL SUBSYSTEMS  **\n**             SUCH AS JES2, VTAM, TCAM, ETC... ARE NOT AVAILABLE.  **\n**             IT IS INTENDED TO BE INVOKED AS A STARTED TASK OR A  **\n**             BATCH JOB. IT CAN ALSO BE INVOKED AS A TSO COMMAND   **\n**             PROCESSOR USING A FRONT-END MODULE, \"ETPSTSO\".       **\n**                                                                  **\n**             IF YOU WANT TO INVOKE IT AS A SUB-SYSTEM WHEN JES2   **\n**             IS NOT UP, YOU MUST ADD A SUB-SYSTEM DEFINITION.     **\n**                                                                  **\n**             REMARK : WITH RACF, MODULE \"ICHRIN03\" CONTAINS THE   **\n**                      DEFAULT USER-ID AND GROUP FOR SUB-SYSTEM    **\n**                      AND STARTED TASK.                           **\n**                                                                  **\n**      PARM : THIS PROGRAM MUST BE INVOKED WITH A STANDARD         **\n**             EXECUTE-CARD FORMAT PARAMETER, THE LENGTH MUST BE    **\n**             BYTES, AS FOLLOWS :                                  **\n**             1. THE FIRST 4 CHARACTERS MUST BE \"ETPS\" OR \"OPER\"   **\n**                (THIS LAST BYPASS THE LOGON PANEL).               **\n**             2. THE 5TH BYTE IS TERMINAL TYPE. VALID TERMINAL     **\n**                TYPES ARE :                                       **\n**                A = 3278-2A OR 3279-2C (20-LINE TERMINAL)         **\n**                2 = 3278 MODEL 2                                  **\n**                3 = 3279 MODEL 3B                                 **\n**                4 = 3278 MODEL 4                                  **\n**             3. THE LAST 3 BYTES MUST BE THE UNIT ADDRESS OF THE  **\n**                TERMINAL. AS AN EXAMPLE,                          **\n**                //STEP1  EXEC  PGM=ETPS,PARM='ETPS49C4'           **\n**                STARTS TIME-SHARING ON A LOCAL 3278 MODEL 4 AT    **\n**                ADDRESS 9C4.                                      **\n**             TO INVOKE AS A TSO COMMAND PROCESSOR, THE PARAMETER  **\n**             MUST BE :  DC  H'8',CL8'TSO'  (SEE MODULE ETPSTSO).  **\n**       DOC : REFER TO ETPS@ FOR FURTHER DOCUMENTATION.            **\n**                                                                  **\n**********************************************************************\n         EJECT\n        MIDENT\n         SPACE 1\n**********************************************************************\n**                                                                  **\n**  REMARKS : (ONLY IN THIS MODULE)                                 **\n**  ========= 1. ALL CARDS MARKED <X> IN COLUMNS 68-70 INDICATE THE **\n**               CODED INSTRUCTIONS EXECUTED ONLY WHEN TERMINAL I/O **\n**               IS DONE THROUGH EXCP'S, IN OTHER WORDS, WHEN ETPS  **\n**               RUN AS SUB-SYSTEM OR STARTED-TASK.                 **\n**            2. ALL CARDS MARKED <T> IN COLUMNS 68-70 INDICATE THE **\n**               CODED INSTRUCTIONS EXECUTED WHEN TSO INVOCATION    **\n**               (ETPSTSO) IS DONE WITH THE TEST OPERAND.           **\n**                                                                  **\n**********************************************************************\n         EJECT\n*======= SECTIONS INFORMATION =======================================*\n*   NAME      SAVE-AREA  OTHER SECTIONS USED OR CALLED               *\n*   ========  =========  ========================================    *\n*   ETPS      SAVE1      ETPSXAI                                 <X> *\n*                        ETPSCOMM  ETPSMESS  ETPSFDTE  ETPSLIBM      *\n*                        ETPSCOMP  ETPSIDCA  ETPSZAP   ETPSIZAP      *\n*                        ETPSDSST                                    *\n*   --------  ---------  ----------------------------------------    *\n*   ETPSXAI   SAVE2      XATTN     XABEND                        <X> *\n*   --------  ---------  ----------------------------------------    *\n*   ETPSLIBM  SAVE2      ETPSCOMM  ETPSMESS  ETPSDYNA                *\n*                        ETPSBROW  ETPSEDIT  ETPSMEMC                *\n*   --------  ---------  ----------------------------------------    *\n*   ETPSCOMP  SAVE2      ETPSCOMM  ETPSMESS  ETPSDYNA                *\n*   --------  ---------  ----------------------------------------    *\n*   ETPSIDCA  SAVE2      ETPSCOMM  ETPSMESS                          *\n*                        ETPSBROW                                    *\n*   --------  ---------  ----------------------------------------    *\n*   ETPSZAP   SAVE2      ETPSCOMM  ETPSMESS  ETPSDYNA                *\n*                        ETPSXZAP  ETPSBROW                          *\n*   --------  ---------  ----------------------------------------    *\n*   ETPSIZAP  SAVE2      ETPSCOMM  ETPSMESS  ETPSDYNA                *\n*                        ETPSINCZ  ETPSBROW                          *\n*   --------  ---------  ----------------------------------------    *\n*   ETPSDSST  SAVE2      ETPSCOMM  ETPSMESS  ETPSDYNA                *\n*                        ETPSXDST  ETPSBROW                          *\n*   --------  ---------  ----------------------------------------    *\n*   ETPSBROW  SAVE3      ETPSCOMM                                    *\n*   --------  ---------  ----------------------------------------    *\n*   ETPSEDIT  SAVE3      ETPSCOMM  ETPSMESS                          *\n*   --------  ---------  ----------------------------------------    *\n*   ETPSXZAP  SAVE3      ETPSCOMM  ETPSMESS  ETPSDYNA                *\n*   --------  ---------  ----------------------------------------    *\n*   ETPSINCZ  SAVE3      ETPSDYNA  ETPSFDTE                          *\n*   --------  ---------  ----------------------------------------    *\n*   ETPSXDST  SAVE3      ETPSDYNA  ETPSFDTE                          *\n*   --------  ---------  ----------------------------------------    *\n*   ETPSCOMM  SAVE4      ETPSMESS                                    *\n*   --------  ---------  ----------------------------------------    *\n*   ETPSMEMC  LOCAL-SA                                               *\n*   --------  ---------  ----------------------------------------    *\n*   ETPSDYNA  LOCAL-SA                                               *\n*   --------  ---------  ----------------------------------------    *\n*   ETPSFDTE  LOCAL-SA                                               *\n*   --------  ---------  ----------------------------------------    *\n*   ETPSMESS  LOCAL-SA                                               *\n*====================================================================*\n         EJECT\n         PRINT GEN\n         USING *,R12,R11\n         B     32(,R15)\n         DC    CL28'  ETPS     &SYSDATE &SYSTIME'\n         PRINT &PRF\n         STM   R14,R12,12(R13)     SAVE INPUT REGISTERS\n         LR    R12,R15             SET PROGRAM BASE REGISTER 1\n         LA    R3,1\n         LA    R11,4*KB-1(R3,R12)  SET PROGRAM BASE REGISTER 2\n         L     R2,0(,R1)           SAVE PARM POINTER\n         LR    R4,R0               SAVE \"SNAP\" ADDRESS IF TSO\n         L     R9,GETSIZE          GET WORK-AREA LENGTH\n        GETMAIN R,LV=(R9)          GET \"MYSAVE\" WORK-AREA (UNCOND)\n         LR    R8,R1               SAVE GETMAIN POINTER\n         ST    R8,8(R13)           STORE FORWARD POINTER\n         LR    R5,R13              SAVE BACKWARD POINTER\n         LR    R13,R8              SET DSECT BASE 1\n         LA    R10,4*KB-1(R3,R13)  SET DSECT BASE 2\n         USING MYSAVE,R13,R10 ************************** R13 ==> SAVE1\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R8,R14              CLEAR ALL TO BINARY ZEROS\n         ST    R5,4(R13)           STORE BACKWARD POINTER\n         ST    R13,SAVETOP         SAVE THE START ADDRESS (A.SAVE1)\n         SPACE 1\n*------- INITIALIZATION ---------------------------------------------*\n         LA    R1,1\n         ST    R1,ARSNAP\n        LOAD   EP=ETPSUTIL,ERRET=LUTLERR PLUG EPA'S ADDRESSES\n         LR    R1,R0\n         MVC   ARDYNAM(2*4),0(R1)  SET ADDRESSES\n        LOAD   EP=ETPSMESS,ERRET=LMSGERR PLUG EPA ADDRESS\n         ST    R0,ARMESS           SET ADDRESS\n         MVC   ARPOPS(3*4),=A(ETPSPOPS,ETPSCOMM,ETPSLIBM)\n         MVC   SUPRMOD(SMODLEN),SMOD INITIALIZE MODESETS\n         MVC   PROBMOD(PMODLEN),PMOD\n         MVC   SPLIT1(18*4),0(R13) INITIALIZE SAVE-AREAS FOR\n         MVC   SPLIT2(18*4),0(R13)   SPLIT-SCREEN\n         MVC   SPLOFF1,=A(SPLIT1-SAVE4) 1ST OFFSET TO SPLIT AREA\n         MVC   SPLOFF2,=A(SPLIT2-SAVE4) 2ND OFFSET TO SPLIT AREA\n         MVC   XQSNAP(L'XESNAP),XESNAP INITIALIZE SNAP PROCESSING\n         LA    R1,8                PICK UP PARM = DDNAME\n         CH    R1,0(,R2)           PARM LENGTH = 8?\n         BE    OKPRML              YES\n        XMESS  1001                ELSE SHUT IT DOWN\n         B     RTRNEND\nLUTLERR  XR    R2,R2               SAY \"ETPSUTIL\" (+0)\n         B     *+L'*+4\nLMSGERR  LA    R2,4                SAY \"ETPSMESS\" (+4)\n         LR    R4,R1               SAVE R1 AND R15\n         LR    R5,R15\n         MVC   SPLITWRK+4(EXTLSTL),EXTLST\n        EXTRACT SPLITWRK,'S',FIELDS=(TSO),MF=(E,SPLITWRK+4)\n         L     R3,SPLITWRK\n         MVC   SPLITWRK(LOADMSGL),LOADMSG\n         B     *+L'*(R2)\n         B     *+L'*+4             +0\n         B     *+L'*+10            +4\n         MVC   SPLITWRK+LDMS1(L'LDMS1),=CL4'UTIL'\n         B     *+L'*+6\n         MVC   SPLITWRK+LDMS1(L'LDMS1),=CL4'MESS'\n         TM    0(R3),X'80'         TSO FOREGROUND RUNNING?\n         BZ    *+L'*+6             NO, OK\n         MVC   SPLITWRK+LOADMSGL-L'ALTRDF(L'ALTRDF),ALTRD+ALTRDF\n         CVD   R4,DBLWRD\n         MVC   DBLWRD(4),=XL4'40202120'\n         ED    DBLWRD(4),DBLWRD+6\n         MVC   SPLITWRK+LDMS2(L'LDMS2),DBLWRD+1\n         L     R0,L'LDMS3\n         LA    R15,SPLITWRK+LDMS3+L'LDMS3-1\n         STC   R5,0(R15)\n         BCTR  R15,0\n         SRL   R5,4\n         BCT   R0,*-10\n         NC    SPLITWRK+LDMS3(L'LDMS3),=XL8'0F0F0F0F0F0F0F0F'\n         TR    SPLITWRK+LDMS3(L'LDMS3),=CL16'0123456789ABCDEF'\n         TM    0(R3),X'80'         TSO FOREGROUND RUNNING?\n         BZ    DOWTOM              NO, GO DO WTO\n        TPUT   SPLITWRK+4,L'LOADMSG-8\n         B     WTGEX\nDOWTOM  WTO    MF=(E,SPLITWRK)\nWTGEX    B     *+L'*(R2)\n         B     QUIT                +0\n         B     LEAVE               +4\nOKPRML   CLC   2(4,R2),=CL4'OPER'  OPERATOR TERMINAL?\n         BE    *+L'*+10            YES\n         CLC   2(4,R2),=CL4'ETPS'  USER TERMINAL?\n         BNE   CHKTSO              NO\n         MVC   DYNRB(DYNLENG),CONRB ALLOCATE TUBE                  <X>\n         MVC   TUBEDDNM(L'TUBEDDNM),2(R2) MOVE ENVIRONMENT         <X>\n         LA    R1,DYNDDNAM                                         <X>\n         ST    R1,DYNTEXT1                                         <X>\n         LA    R1,DYNDISP                                          <X>\n         ST    R1,DYNTEXT2                                         <X>\n         LA    R1,DYNUNIT                                          <X>\n         ST    R1,DYNTEXT3                                         <X>\n         OI    DYNTEXT3,S99TUPLN                                   <X>\n         LA    R1,DYNTEXT1                                         <X>\n         ST    R1,TEXTPTRS                                         <X>\n         LA    R1,DYNRB                                            <X>\n         ST    R1,DYNPARM                                          <X>\n         OI    DYNPARM,S99RBPND                                    <X>\n         MVC   UNITADDR,TERMADDR   MOVE IN UNIT ADDRESS            <X>\n         LA    R1,DYNPARM                                          <X>\n        DYNALLOC ,                                                 <X>\n         LTR   R15,R15             HOW COMPLETE?                   <X>\n         BZ    OKDYNA              OK                              <X>\n        XMESS  1003,R15                                            <X>\n         B     RTRNEND                                             <X>\nOKDYNA   NI    COMMSW,255-PERMERR-INTERR-PFKFLAG 1ST TIME THROUGH  <X>\n         MVI   WRITECC,X'0D'       SET ERASE/WRITE ALTERNATE       <X>\n         CLI   TERMTYPE,C'3'       IS IT A MOD3?                   <X>\n         BE    ITSMOD3             GO SET IT                       <X>\n         CLI   TERMTYPE,C'4'       IS IT A MOD4?                   <X>\n         BE    ITSMOD4             GO SET IT                       <X>\n         MVI   WRITECC,X'05'       SET DEFAULT COMMAND CODE  W.A.M.<X>\n         CLI   TERMTYPE,C'A'       IS IT A 3278-2A?          W.A.M.<X>\n         BE    ITSMOD2A            SET 20 LINES              W.A.M.<X>\n         LA    R1,24*80            ASSUME 3278-2, DEF. BUFF.SIZE   <X>\n         ST    R1,SCREENSZ         SET IT                          <X>\n         LA    R15,24              DEFAULT NUMBER OF ROWS          <X>\n         ST    R15,SCROWS          SET IT                          <X>\n         B     SETSCSZ             USE DEFAULT                     <X>\nITSMOD3  LA    R1,28*80            MOD 3 BUFFER SIZE               <X>\n         ST    R1,SCREENSZ         SET IT                          <X>\n         LA    R15,28              DEFAULT NUMBER OF ROWS          <X>\n         ST    R15,SCROWS          SET IT                          <X>\n         B     SETSCSZ             ALL SET                         <X>\nITSMOD4  LA    R1,43*80            MOD 4 BUFFER SIZE               <X>\n         ST    R1,SCREENSZ         SET IT                          <X>\n         LA    R15,43              DEFAULT NUMBER OF ROWS          <X>\n         ST    R15,SCROWS          SET IT                          <X>\n         B     SETSCSZ             ALL SET                         <X>\nITSMOD2A LA    R1,20*80            MOD 2A BUFFER SIZE        W.A.M.<X>\n         ST    R1,SCREENSZ         SET IT                    W.A.M.<X>\n         LA    R15,20              DEFAULT NUMBER OF ROWS    W.A.M.<X>\n         ST    R15,SCROWS          SET IT                    W.A.M.<X>\nSETSCSZ  MVC   SCROWS1,SCROWS                                      <X>\n         XC    SCROWS2,SCROWS2                                     <X>\n         MVC   TUBE(TUBEL),TINIT   SCREEN DCB                      <X>\n         LA    R2,TUBE             GET DCB ADDRESS                 <X>\n         USING IHADCB,R2                                           <X>\n         MVC   DCBDDNAM,TUBEDDNM   SET DD-NAME                     <X>\n         LA    R1,TUBEIOB          SET IOB ADDRESS                 <X>\n         STCM  R1,B'0111',DCBIOBAA IN THE DCB                      <X>\n         MVI   OPCLPL,VLB          SET \"VL\" BIT                    <X>\n        OPEN   ((R2)),MF=(E,OPCLPL) OPEN TUBE                      <X>\n         TM    DCBOFLGS,DCBOFOPN   GOOD OPEN?                      <X>\n         BO    OKOPEN              YES                             <X>\n        XMESS  1004                NOPE                            <X>\n         B     FRTUBE                                              <X>\nOKOPEN   XC    RECB(4),RECB        CLEAR ECB                       <X>\n         MVC   TUBEIOB(IOBLEN),IOBINIT INITIALIZE IOB              <X>\n         STCM  R2,B'0111',TUBEIOB+(IOBDCBPB-IOBSTDRD) SET A(DCB)   <X>\n         AIF   ('&EATL' EQ '').SKX1                                <X>\n         L     R15,=A(ETPSXAI)     GO TO EXCP-ATTENTION INIT.      <X>\n*- - - - ETPSXAI PARM.LIST : NONE (R2 = DCB ADDRESS)               <X>\n        CALL   (15)                                                <X>\n.SKX1    B     INITBUF                                             <X>\n         DROP  R2                                                  <X>\nCHKTSO   CLC   2(3,R2),=CL3'TSO'   TSO TERMINAL?\n         BE    ITSTSO              YES\n        XMESS  1002                NO\n         B     RTRNEND\nITSTSO   MVC   TUBEDDNM(L'TUBEDDNM),2(R2) YES, MOVE ENVIRONMENT\n         CLI   TUBEDDNM+L'TUBEDDNM-1,C'T' WANT TEST LOGON PANEL?   <T>\n         BNE   *+L'*+4             NO                              <T>\n         OI    STATSW,TESTFLG      YES, SET REQUEST                <T>\n         LTR   R4,R4               SNAP ACTIVE?\n         BZ    *+L'*+4             NO, SKIP\n         ST    R4,ARSNAP           YES, SET \"SNAP\" ADDRESS\n        GTSIZE\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    OKSIZE              WELL\n        XMESS  1005,R15\n         B     RTRNEND\nOKSIZE   LTR   R0,R0               ROWS?\n         BNZ   OKROWS\n        XMESS  1006\n         B     RTRNEND\nOKROWS   ST    R0,SCROWS           SET IT\n         ST    R0,SCROWS1          SET IT\n         MH    R1,SCROWS+2\n         ST    R1,SCREENSZ         SET IT\n         XC    SCROWS2,SCROWS2\n        STFSMODE ON,INITIAL=YES    TURN ON VTAM FULL-SCREEN MODE\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    OKSTFS              WELL\n        XMESS  1007,R15\n         B     RTRNEND\nOKSTFS  TPUT   ERSSCR,L'ERSSCR,FULLSCR\nINITBUF  L     R0,=A(STBIGWA-MYSAVE) SET BIG WORK AREAS ADDRESSES\n         AR    R0,R13\n         ST    R0,BUFF\n         AL    R0,=A(4*KB)\n         ST    R0,REPLY\n         AL    R0,=A(4*KB)\n         ST    R0,TERMINPT\n         AL    R0,=A(4*KB)\n         ST    R0,TERMOUT\n         AL    R0,=A(4*KB)\n         LA    R1,DYNRCODE\n         STM   R0,R1,DYNWORKP\n         OI    DYNWORKP+4,VLB      SET \"VL\" BIT\n         MVI   SPLIT,0             NOT IN SPLIT SCREEN\n*- - - - \"TERMOUT\" DESCRIPTION : LINES ARE LOCATED IN \"OUTPTBUF\" AREA\nBUFNOL   EQU   43             MAXIMUM NUMBER OF LINES\nBUFOLL   EQU   93             ONE LINE LENGTH IS 93 BYTES\n*                             (SO, TOTAL LINES LENGTH IS 3999 BYTES)\n*                +0 = ADDRESS OF \"WCCFLG\"\n*                +4 = ADDRESS OF OUPUT LINE 1\n*                +8 = ADDRESS OF OUTPUT LINE 2\n*               ...\n*              +172 = ADDRESS OF OUTPUT LINE 43\n*              NOTE - \"EOS\" (END-OF-SCREEN) MUST BE SET ON FIRST BYTE\n*                     OF ADDRESS TO INDICATE THE LAST LINE OF THE\n*                     SCREEN IMAGE\n*              EACH OUTPUT LINE CONTAINS :\n*                +0 = LENGTH OF THE LINE SCREEN IMAGE\n*                +1 ... = THE LINE SCREEN IMAGE\n         L     R15,TERMOUT         FIRST LINE ADDRESS\n         LA    R14,WCCFLAG         \"WCC\" IS USED TO SET THE ALARM\n         ST    R14,TERMOUT         NOW BUILD OUT-ADDRESSES\n         LA    R14,TERMOUT+4\n         LA    R1,BUFNOL           LOOP CONTROL\n         ST    R15,0(R14)          STORE THE ADDRESS\n         LA    R15,BUFOLL(R15)     BUMP TO NEXT OUTPUT LINE\n         LA    R14,4(R14)          BUMP TO NEXT OUTADDR\n         BCT   R1,*-12             LOOP 43 TIMES\n         MVI   WCCFLAG,C'N'        NO ALARM REQUESTED\n*- - - - \"TERMINPT\" DESCRIPTION : LINES ARE LOCATED IN \"INPTBUF\" AREA\nBUFNIL   EQU   BUFNOL         SAME AS FOR \"TERMOUT\"\nBUFILL   EQU   BUFOLL          \" \"\n*                +0 = ADDRESS OF AID AND CURSOR POSITION (BYTES 0-2)\n*                +4 = ADDRESS OF INPUT LINE 1\n*                +8 = ADDRESS OF INPUT LINE 2\n*               ...\n*              +172 = ADDRESS OF INPUT LINE 43\n*              EACH INPUT LINE CONTAINS AN UPDATED COPY OF THE\n*              CORRESPONDING OUTPUT LINE SCREEN IMAGE IF THERE IS\n*              AT LEAST ONE INPUT FIELD ENTERED :\n*                +0 = LENGTH OF THE LINE SCREEN IMAGE OR ZERO IF NONE\n*                     HAS BEEN ENTERED IN THIS LINE\n*                +1 ... = THE UPDATED LINE SCREEN IMAGE\n         LA    R14,TERMINPT+4      NOW BUILD IN-ADDRESSES\n         LA    R1,BUFNIL           LOOP CONTROL\n         L     R15,TERMINPT        FIRST ADDRESS\n         LA    R15,BUFILL(R15)     BUMP TO NEXT INPUT LINE\n         ST    R15,0(,R14)         STORE THE ADDRESS\n         LA    R15,BUFILL(R15)     BUMP TO NEXT INPUT LINE\n         LA    R14,4(R14)          BUMP TO NEXT INADDR\n         BCT   R1,*-12             LOOP 43 TIMES\n         MVC   LIB1DCB+(DCBDDNAM-IHADCB)(L'DCBDDNAM),=CL8'LIB1DD'\n         MVC   LIB2DCB+(DCBDDNAM-IHADCB)(L'DCBDDNAM),=CL8'LIB2DD'\n         MVC   MEM1DCB+(DCBDDNAM-IHADCB)(L'DCBDDNAM),=CL8'MEM1DD'\n         MVC   MEM2DCB+(DCBDDNAM-IHADCB)(L'DCBDDNAM),=CL8'MEM2DD'\n         MVC   COP1DCB+(DCBDDNAM-IHADCB)(L'DCBDDNAM),=CL8'COP1DD'\n         MVC   COP2DCB+(DCBDDNAM-IHADCB)(L'DCBDDNAM),=CL8'COP2DD'\n         LA    R0,LIB1DCB\n         LA    R1,MEM1DCB\n         LA    R2,COP1DCB\n         LA    R3,LIB2DCB\n         LA    R4,MEM2DCB\n         LA    R5,COP2DCB\n         DROP  R10\n         LA    R10,SPLITWRK        SET DSECT BASE FOR SPLIT-SCREEN\n         USING SPLTAREA,R10\n         ST    R0,ALIBDCB\n         ST    R1,AMEMDCB\n         ST    R2,ACOPDCB\n         MVC   N#IN,=CL8'MYIN$1'\n         MVC   N#PRINT,=CL8'MYPRT$1'\n         MVC   N#UT1,=CL8'MYUT1$1'\n         MVC   N#UT2,=CL8'MYUT2$1'\n         MVC   N#UT3,=CL8'MYUT3$1'\n         MVC   N#UT4,=CL8'MYUT4$1'\n         LR    R14,R13             SAVE THE SAVE-AREA ADDRESS\n         AL    R13,=A(SPLIT2-MYSAVE) OFFSET OF SPLIT2 AREA\n         LA    R10,SPLITWRK\n         ST    R3,ALIBDCB\n         ST    R4,AMEMDCB\n         ST    R5,ACOPDCB\n         MVC   N#IN,=CL8'MYIN$2'\n         MVC   N#PRINT,=CL8'MYPRT$2'\n         MVC   N#UT1,=CL8'MYUT1$2'\n         MVC   N#UT2,=CL8'MYUT2$2'\n         MVC   N#UT3,=CL8'MYUT3$2'\n         MVC   N#UT4,=CL8'MYUT4$2'\n         LR    R13,R14             RESTORE THE SAVE-AREA ADDRESS\n         LA    R10,SPLITWRK\n         MVI   PRIMEFLG,0          NOT IN PRIMARY OPTION MENU\n         USING PSA,R0\n         L     R2,CVTPTR           CVT\n         DROP  R0\n         USING CVTMAP,R2\n         L     R1,CVTJESCT         JES COMM TABLE\n         DROP  R2\n         USING JESCT,R1\n         ICM   R2,B'1111',JESSSCT  SSCT POINTER\n         BZ    STLOGON             NONE\n         USING SSCT,R2\nSJ2LOOP  CLC   SSCTID,=CL4'SSCT'   RIGHT ID?\n         BNE   STLOGON             NO, JUMP\n         CLC   SSCTSNAM,=CL4'JES2' JES2 SSCT?\n         BE    SJ2OK               YES\n         ICM   R2,B'1111',SSCTSCTA NO, GET NEXT SSCT\n         BNZ   SJ2LOOP             AND LOOP IF MORE\n         B     STLOGON             ELSE JES2 NOT FOUND\n         DROP  R1,R2\nSJ2OK    MVC   SUBRB(SUBLEN),SUBRBSK INITIALIZE SUBMIT\n         LA    R1,SUBTXP\n         ST    R1,SUBRB+(S99TXTPP-S99RB)\n         LA    R1,SUBRB\n         ST    R1,SUBSUBP\n         OI    SUBSUBP,S99RBPND    INITIALIZATION DONE\n         SPACE 1\n*------- LOGON PROCESSING -------------------------------------------*\n*              (SIMULATE PROMPT FOR LOGON AND PASSWORD)\nSTLOGON  TM    STATSW,TESTFLG      TSO TEST OF LOGON PANEL?        <T>\n         BO    DOLOGON             YES                             <T>\n         CLI   TUBEDDNM,C'O'       OPERATOR TERMINAL?\n         BE    OPRLOGON            YES, NO LOGON\n         CLI   TUBEDDNM,C'T'       TSO TERMINAL?\n         BE    TSOLOGON            YES, NO LOGON\nDOLOGON  XC    MSGADD(4),MSGADD    NO MESSAGE AT UPPER-RIGHT\nRELOGON  MVI   SPLIT,0             NOT IN SPLIT SCREEN\n         MVI   PRIMEFLG,0          NOT IN PRIMARY OPTION MENU\n         MVC   USERID,=CL8' '      CLEAR USER-ID\n         MVC   USERPASS,=CL8' '    CLEAR PASSWORD\n         MVC   RACGROUP,=CL8' '    CLEAR RACF GROUP-ID\n         MVI   WCCFLAG,C'A'        ALARM REQUESTED\nRSHWLOG  MVI   CURROW,CRLUSC       CURSOR ROW\n         MVI   CURCOL,CCLUSC       CURSOR COLUMN\nRLPRMPT  L     R15,=A(LOGHELP)     HELP SCREEN\n         ST    R15,HELPADD\n         LA    R5,SCRNLOG\n         L     R6,=A(LOGSCR)\n         BAL   R14,SCRNBLD\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         MVI   WCCFLAG,C'N'        NO ALARM REQUESTED\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         LM    R4,R6,TERMINPT+ZIL  PICK UP RESPONSES LINES\n         LTR   R15,R15             IS IT A BAD RETURN CODE?\n         BNZ   OUTEX               YUP, GO EOJ\n         TM    COMMSW,PFKFLAG      IS IT A PF KEY/ATTN?\n         BZ    CHECKIF1            NOPE, IT'S JUST ENTER\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    OUTEX               YUP, GO CLOSE THE TUBE AND EOJ\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BE    OUTEX               YUP, GO CLOSE THE TUBE AND EOJ\n         CLI   0(R2),X'6C'         IS IT PA1?\n         BE    OUTEX               YUP, GO CLOSE THE TUBE AND EOJ\n         CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    RELOGON             YUP, RESHOW SCREEN (FIELDS CLEARED)\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    RSHWLOG             YUP, RESHOW SCREEN AS BEFORE\nCHECKIF1 CLI   0(R4),0             USER-ID ENTERED?\n         BE    CHECKIF2            NO\n         LA    R0,L'LGSCF1-1       YES, LEFT JUSTIFY FIELD IF NEEDED\n         CLI   LGSCF1(R4),C' '\n         BNE   *+L'*+14\n         MVC   LGSCF1(L'LGSCF1-1,R4),LGSCF1+1(R4)\n         MVI   LGSCF1+L'LGSCF1-1(R4),C' '\n         BCT   R0,*-18\n         MVC   USERID(L'USERTBL),LGSCF1(R4) MOVE USER-ID FIELD\nCHECKIF2 CLI   0(R5),0             PASSWORD ENTERED?\n         BE    CHECKIF3            NO\n         LA    R0,L'LGSCF2-1       YES, LEFT JUSTIFY FIELD IF NEEDED\n         CLI   LGSCF2(R5),C' '\n         BNE   *+L'*+14\n         MVC   LGSCF2(L'LGSCF2-1,R5),LGSCF2+1(R5)\n         MVI   LGSCF2+L'LGSCF2-1(R5),C' '\n         BCT   R0,*-18\n         MVC   USERPASS(L'USERPASS),LGSCF2(R5) MOVE PASSWORD FIELD\nCHECKIF3 CLI   0(R6),0             RACF GROUP ENTERED?\n         BE    CHECKPFK            NO\n         LA    R0,L'LGSCF3-1       YES, LEFT JUSTIFY FIELD IF NEEDED\n         CLI   LGSCF3(R6),C' '\n         BNE   *+L'*+14\n         MVC   LGSCF3(L'LGSCF3-1,R6),LGSCF3+1(R6)\n         MVI   LGSCF3+L'LGSCF3-1(R6),C' '\n         BCT   R0,*-18\n         MVC   RACGROUP(L'RACGROUP),LGSCF3(R6) MOVE GROUP-ID FIELD\nCHECKPFK TM    COMMSW,PFKFLAG      WAS IT A PF KEY/ATTN?\n         BZ    *+L'*+12            NO, SEE IF IT IS EOJ\n         LA    R1,INVPFK           YES, IT'S AN INVALID KEY\n         ST    R1,MSGADD\n         B     RSHWLOG             RESHOW SCREEN\n         CLI   USERID,C' '         USER-ID SUPPLIED?\n         BNE   *+L'*+12            YES\n         LA    R1,MNUSER           NO, IT'S MANDATORY, REPROMPT\n         ST    R1,MSGADD\n         B     RSHWLOG             RESHOW SCREEN\n         CLC   USERID(3),=CL4'EOJ ' ALL DONE?\n         BNE   CHECKUSR            NO\n         MVC   USERID,=CL8' '      YES, CLEAR USER-ID\n         MVC   USERPASS,=CL8' '    CLEAR PASSWORD\n         MVC   RACGROUP,=CL8' '    CLEAR RACF GROUP-ID\nOUTEX    TM    STATSW,TESTFLG      TSO TEST OF LOGON PANEL?        <T>\n         BZ    CLOSETB             NO, GO CLOSE THE TUBE AND EOJ\n         MVI   TUBEDDNM+L'TUBEDDNM-1,C' ' YES, RESET TEST LOGON    <T>\n         NI    STATSW,255-TESTFLG  CLEAR REQUEST                   <T>\n         B     TSOEND              TERMINATE TSO RUN               <T>\nCHECKUSR TM    STATSW,TESTFLG      TSO TEST OF LOGON PANEL?        <T>\n         BZ    SKMSTS              NO, SKIP MESSAGE'S TEST         <T>\n         CLI   USERID,C'0'         YES, TEST MESSAGE NUMBER CHECK  <T>\n         BL    SKMSTS                                              <T>\n         CLI   USERID,C'9'                                         <T>\n         BH    SKMSTS                                              <T>\n         XR    R15,R15             GET THE MESSAGE NUMBER          <T>\n         LR    R14,R15                                             <T>\n         LA    R0,L'USERID                                         <T>\n         LA    R1,X'0F'                                            <T>\n         LA    R2,USERID                                           <T>\nNXMSTS   IC    R14,0(R2)                                           <T>\n         NR    R14,R1                                              <T>\n         LTR   R15,R15                                             <T>\n         BNP   *+L'*+4                                             <T>\n         MH    R15,=H'10'                                          <T>\n         AR    R15,R14                                             <T>\n         CH    R15,=H'9999'                                        <T>\n         BNH   *+L'*+12                                            <T>\n         LH    R15,=H'9999'        ANY NUMBER OVER 9999 IS         <T>\n         LA    R15,1(R15)            DISPLAYED AS 10000            <T>\n         B     DOMSTS                                              <T>\n         LA    R2,1(R2)                                            <T>\n         BCT   R0,*+L'*+4                                          <T>\n         B     DOMSTS                                              <T>\n         CLI   0(R2),C' '                                          <T>\n         BE    DOMSTS                                              <T>\n         CLI   0(R2),C'0'                                          <T>\n         BL    *+L'*+8                                             <T>\n         CLI   0(R2),C'9'                                          <T>\n         BNH   NXMSTS                                              <T>\n         LA    R1,INVMSN           INVALID MESSAGE NUMBER          <T>\n         ST    R1,MSGADD                                           <T>\n         B     RSHWLOG             RESHOW SCREEN                   <T>\nDOMSTS   STH   R15,MESSNO          AND NOW JUST TEST IT            <T>\n         MVC   USERID,=CL8' '      CLEAR USER-ID                   <T>\n        XMESS  ,                                                   <T>\n         B     RELOGON             RESHOW SCREEN (FIELDS CLEARED)  <T>\nSKMSTS   CLC   USERID(5),=CL5'DUMP ' TAKE A DUMP?\n         BNE   *+L'*+2             NO, GO CHECK THE USER-ID\n         DC    H'0'                YUP, TAKE AN S0C1 <------------ DUMP\n         L     R1,=A(USERTBL)      VALID USERS TABLE\nUSTLOOP  CLI   0(R1),0             END OF TABLE?\n         BNE   *+L'*+12            NO\n         LA    R1,REJUSER          YES, INVALID USER\n         ST    R1,MSGADD\n         B     RSHWLOG             RESHOW SCREEN (REPROMPT)\n         CLC   USERID(L'USERTBL),0(R1) AUTHORIZED USER-ID?\n         BE    *+L'*+8             YUP, OK\n         LA    R1,L'USERTBL(R1)    BUMP TO NEXT USER IN TABLE\n         B     USTLOOP             LOOP\n*- - - - - - - NOTE : THE PASSWORD IS HANDLED AND USED AS SHIPPED, BUT\n*                     IF YOU NEED TO CHECK IT, DO IT HERE BELOW.\n*                     I.E., YOU MAY DO AS FOLLOWS :\n*                     SCAN \"USERPASS\" AGAINST YOUR PASSWORDS-TABLE\n*                     IF OK, CONTINUE\n*                     ELSE, SET MSG \"PASSWORD REJECTED\"\n*                           SET CURSOR ROW TO \"CRLPSC\"\n*                           SET CURSOR COLUMN TO \"CCLPSC\"\n*                           AND GO BACK TO \"RLPRMPT\"\n         CLI   RACGROUP,C' '       RACF GROUP-ID ENTERED?\n         BE    CHKWHERE            NO\n         CLI   RACGROUP,C'A'       YES, TEST IF IT STARTS BY ALPHA\n         BL    *+L'*+8\n         CLI   RACGROUP,C'Z'\n         BNH   CHKWHERE            OK\n         LA    R1,INVGROUP         NO, INVALID RACF-GROUP\n         ST    R1,MSGADD\n         MVI   CURROW,CRLGSC       CURSOR ROW\n         MVI   CURCOL,CCLGSC       CURSOR COLUMN\n         B     RLPRMPT             RESHOW SCREEN (REPROMPT)\nCHKWHERE TM    STATSW,TESTFLG      TSO TEST OF LOGON PANEL?        <T>\n         BZ    VERUSGRP            NO\n         MVI   TUBEDDNM+L'TUBEDDNM-1,C' ' YES, RESET TEST LOGON    <T>\n         NI    STATSW,255-TESTFLG  CLEAR REQUEST                   <T>\n         B     TSOLOGON                                            <T>\nOPRLOGON MVC   USERID(L'USERTBL),USERTBL SET USER-ID = FIRST IN TABLE\n         MVI   USERID+L'USERTBL,C' '\n         MVC   USERPASS,MASTPASS   PASSWORD IS MASTER PASSWORD\n         B     SETRGRP\n         USING PSA,R0\nTSOLOGON L     R1,PSATOLD          PICK UP TCB\n         DROP  R0\n         USING TCB,R1\n         L     R1,TCBTIO           TCB TIOT\n         DROP  R1\n         USING TIOT,R1\n         MVC   USERID(L'TIOCNJOB),TIOCNJOB SET USER-ID = JOBNAME\n         DROP  R1\n         MVC   USERPASS,=CL8' '    CLEAR PASSWORD\n         USING PSA,R0\n         L     R1,PSAAOLD          PICK UP ASCB\n         DROP  R0\n         USING ASCB,R1\n         L     R2,ASCBTSB          PICK UP TSB\n         DROP  R1\n         LTR   R2,R2\n         BNZ   OKTSB\n        XMESS  1008\n         B     RTRNEND\nOKTSB   MODESET MF=(E,SUPRMOD)\n         USING TSB,R2\n         MVC   TERMSNME,TSBTRMID   TERMINAL SYMBOLIC NAME\n         DROP  R2\n        MODESET MF=(E,PROBMOD)\nSETRGRP  MVC   RACGROUP,=CL8' '    CLEAR RACF GROUP-ID\n*- - - - VERIFY USER AND VERIFY OR SET RACF GROUP\nVERUSGRP RACSTAT ,                 IS RACF ACTIVE?\n         LTR   R15,R15             ACTIVE?\n         BNZ   STNORACF            NO\n         USING PSA,R0\n         L     R15,PSAAOLD         PICK UP ASCB\n         DROP  R0\n         USING ASCB,R15\n         L     R14,ASCBASXB        PICK UP ASXB\n         DROP  R15\n         USING ASXB,R14\n         L     R3,ASXBSENV         PICK UP ACEE\n         DROP  R14\n         LA    R3,0(,R3)\n         LTR   R3,R3               IS THERE AN ACEE?\n         BZ    STNORACF            NO\n         USING ACEE,R3\n         CLC   ACEEACEE,=CL4'ACEE' IS ACEE VALID?\n         BNE   STNORACF            NO\n         TM    ACEEFLG1,ACEERACF   IS USER RACF DEFINED?\n         BZ    STNORACF            NO\n         CLC   USERID,ACEEUSRI     IS USER OK?\n         BE    OKUSER              YES\n        XMESS  1009      (THIS WAY EXECUTED ONLY WHEN NOT OPER NOR TSO)\n         B     CLOSETB\nOKUSER   TM    ACEEFLG1,ACEESPEC   SPECIAL ATTRIBUTE?\n         BZ    *+L'*+4             NO\n         OI    STATSW,SPCLFLG      YES, RETAIN IT\n         CLC   RACGROUP,=CL8' '    GROUP-ID?\n         BNE   *+L'*+10            YES, GO CHECK IT\n         MVC   RACGROUP,ACEEGRPN   NONE, SET IT\n         B     ENDLOGON\n         CLC   RACGROUP,ACEEGRPN   IS GROUP-ID OK?\n         BE    ENDLOGON            YES\n*                                  NO, TRY TO SWITCH IT (THIS WAY IS\n*                                  EXECUTED ONLY WHEN NOT OPER NOR TSO)\n         MVC   VUSWA(RINITSKL),RINITSK\n        MODESET MF=(E,SUPRMOD)\n        RACINIT GROUP=RACGROUP,ENVIR=CHANGE,MF=(E,VUSWA)\n         LR    R2,R15              SAVE RETURN CODE\n        MODESET MF=(E,PROBMOD)\n         LTR   R15,R2              SUCCESSFUL?\n         BZ    OKRACI              YES\n        XMESS  1010,R15  (THIS WAY EXECUTED ONLY WHEN NOT OPER NOR TSO)\n         B     CLOSETB\n         USING PSA,R0              GO PROPAGATE ADSP TO GET AROUND\nOKRACI   L     R1,PSATOLD            IBM BUG / PICK UP TCB\n         DROP  R0\n         USING TCB,R1\n         L     R2,TCBJSCB          GET JSCB ADDRESS\n         DROP  R1\n         USING IEZJSCB,R2\n        MODESET MF=(E,SUPRMOD)\n         NI    JSCBFBYT,X'FF'-JSCBADSP  TURN OFF ADSP IN JSCB\n         TM    ACEEFLG1,ACEEADSP   DOES USER NOW HAVE ADSP?\n         BZ    *+L'*+4             NO, LEAVE JSCBADSP OFF\n         OI    JSCBFBYT,JSCBADSP   YES, TURN JSCBADSP ON\n        MODESET MF=(E,PROBMOD)\n         DROP  R2,R3\n         XC    VUSWA(RINITSKL),VUSWA CLEAR WORK-AREA\n         B     ENDLOGON\nSTNORACF MVC   RACGROUP,=CL8'(-NONE-)' SIGNAL IT\n         L     R1,=A(USERTBL)      VALID USERS TABLE\nUSSLOOP  CLI   0(R1),0             END OF TABLE?\n         BE    ENDLOGON            YES\n         CLC   USERID(L'USERTBL),0(R1) AUTHORIZED USER-ID?\n         BE    *+L'*+8             YUP\n         LA    R1,L'USERTBL(R1)    BUMP TO NEXT USER IN TABLE\n         B     USSLOOP             LOOP\n         OI    STATSW,SPCLFLG      GIVE HIM AUTHORITY\nENDLOGON TM    STATSW,INITFLG      SPLIT-SCREEN REGISTERS SET?\n         BO    *+L'*+8             YUP\n         STM   R10,R13,PRISPLIT    SAVE REGISTERS\n         OI    STATSW,INITFLG      SAY DONE\n         EJECT\n*------- MAINLINE - DISPLAY PRIMARY OPTION MENU ---------------------*\n         CNOP  0,4\nETPSPOPS OI    LIBPASS,C' '\n         CLI   LIBPASS,C' '        IS THERE A PASSWORD SPECIFIED?\n         BNE   PRIOPT              YES\n         MVC   LIBPASS,USERPASS    SET DSN PASSWORD TO LOGON PASSWORD\nPRIOPT   CLI   TUBEDDNM,C'O'       OPERATOR TERMINAL?\n         BE    *+L'*+8             YES\n         CLI   TUBEDDNM,C'T'       TSO TERMINAL?\n         BNE   *+L'*+8             NO\n         L     R15,=A(POPHELPA)    HELP SCREEN\n         B     *+L'*+4\n         L     R15,=A(POPHELP)     HELP SCREEN\n         ST    R15,HELPADD\n         MVI   PRIMEFLG,1          ON SCREEN 1\n         LA    R5,SCRNPRM\n         L     R6,=A(PRIMOPT)\n         BAL   R14,SCRNBLD\n         MVI   CURROW,CRPOSC       CURSOR ROW\n         MVI   CURCOL,CCPOSC       CURSOR COLUMN\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         LTR   R15,R15             HOW COMPLETE?\n         BNZ   PRIEND              YUP, GET OUT\n         MVI   PRIMEFLG,0          ON SCREEN 1\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         L     R4,TERMINPT+ZIP     PICK UP OPTION FIELD LINE\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   PRIBLD              NOPE\n         L     R3,SCROWS1          PICK UP SIZE OF SCREEN 1\n         SLL   R3,2                MULTIPLY BY 4\n         L     R4,TERMINPT+ZIP(R3) PICK UP OPTION FIELD LINE\nPRIBLD   TM    COMMSW,PFKFLAG      IS IT A PF KEY/ATTN?\n         BZ    PRICHK              NO\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    PRIEND              YUP, GO RESHOW THE LOGON PANEL\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BE    PRIEND              YUP, GO RESHOW THE LOGON PANEL\n         CLI   0(R2),X'6C'         IS IT PA1?\n         BE    PRIEND              YUP, GO RESHOW THE LOGON PANEL\n         CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    PRIOPT              YUP, GO RESHOW THE PRIMOPT\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    PRIOPT              YUP, GO RESHOW THE PRIMOPT\n         LA    R1,INVPFK\n         ST    R1,MSGADD\n         B     PRIOPT              RESHOW SCREEN\nPRIEND   CLI   TUBEDDNM,C'T'       TSO TERMINAL?\n         BE    TSOEND              YES\n         CLI   TUBEDDNM,C'O'       OPERATOR TERMINAL?\n         BNE   RELOGON             NO\n         B     CLOSETB             YES, NO LOGON, GO EOJ\nPRICHK   CLI   0(R4),0             OPTION ENTERED?\n         BE    PRIOPT              NO, GO RESHOW PRIMARY OPTION MENU\n         LA    R0,L'POSCF1-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   POSCF1(R4),C' '\n         BNE   *+L'*+18\n         MVC   POSCF1(L'POSCF1-1,R4),POSCF1+1(R4)\n         MVI   POSCF1+L'POSCF1-1(R4),C' '\n         BCT   R0,*-18\n         B     PRIOPT              GO RESHOW THE PRIMARY OPTION MENU\n         CLI   POSCF1+1(R4),C' '   VALID?\n         BNE   PRINVS              NO, INVALID SELECTION\n         CLI   POSCF1(R4),C'X'     OK, IS IT END?\n         BE    PRIEND              YUP, GO RESHOW THE LOGON PANEL\n         SPACE 1\n*- - - - DETERMINE PRIMARY OPTION PROCESSOR\n         CLI   POSCF1(R4),C'1'     BROWSE?\n         BE    BRWOPT              GO DO IT\n         CLI   POSCF1(R4),C'2'     EDIT?\n         BE    EDTOPT              GO DO IT\n         CLI   POSCF1(R4),C'3'     UTILITIES?\n         BE    UTLOPT              GO DO IT\n         CLI   POSCF1(R4),C'4'     IDCAMS INTERFACE?\n         BE    IDOPT               GO DO IT\n         CLI   POSCF1(R4),C'5'     ZAP?\n         BE    ZAOPT               GO DO IT\n         CLI   POSCF1(R4),C'6'     INCORZAP?\n         BE    IZOPT               GO DO IT\n         CLC   POSCF1(5,R4),=CL5'DUMP ' TAKE A DUMP?\n         BNE   *+L'*+2             NO\n         DC    H'0'                YUP, TAKE AN S0C1 <------------ DUMP\nPRINVS   LA    R1,INVOPT\n         ST    R1,MSGADD\n         B     PRIOPT              GO RESHOW THE PRIMARY OPTION MENU\n         SPACE 1\n*- - - - BROWSE PROCESSING\nBRWOPT   MVI   LIBFUNC,C'B'        INDICATE BROWSE FUNCTION\nREBROPT  L     R15,=A(BROHELP)     HELP SCREEN\n         ST    R15,HELPADD\n         LA    R5,SCRNBES\n         L     R6,=A(BROWSCR)\n         BAL   R14,SCRNBLD\n         MVI   CURROW,CRBRSC       CURSOR ROW\n         MVI   CURCOL,CCBRSC       CURSOR COLUMN\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         LTR   R15,R15             BAD RC?\n         BNZ   PRIOPT              YUP\n         TM    COMMSW,PFKFLAG      IS IT A PF KEY/ATTN?\n         BZ    EDCKINPT            NOPE, GO BROWSE THE DATA-SET\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    PRIOPT              YUP, I'M DONE\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BE    PRIOPT              YUP, I'M DONE\n         CLI   0(R2),X'6C'         IS IT PA1?\n         BE    PRIOPT              YUP, I'M DONE\n         CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    REBROPT             YUP, RESHOW SCREEN\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    REBROPT             YUP, RESHOW SCREEN\n         LA    R1,INVPFK\n         ST    R1,MSGADD\n         B     REBROPT             RESHOW SCREEN\n         SPACE 1\n*- - - - EDIT PROCESSING\nEDTOPT   MVI   LIBFUNC,C'E'        INDICATE EDIT FUNCTION\nREEDOPT  L     R15,=A(EDTHELP)     HELP SCREEN\n         ST    R15,HELPADD\n         LA    R5,SCRNBES\n         L     R6,=A(EDITSCR)\n         BAL   R14,SCRNBLD\n         MVI   CURROW,CREDSC       CURSOR ROW\n         MVI   CURCOL,CCEDSC       CURSOR COLUMN\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         LTR   R15,R15             BAD RC?\n         BNZ   PRIOPT              YUP, GO BACK\n         TM    COMMSW,PFKFLAG      IS IT A PF KEY/ATTN?\n         BZ    EDCKINPT            NOPE, GO EDIT THE DATA-SET\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    PRIOPT              YUP, I'M DONE\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BE    PRIOPT              YUP, I'M DONE\n         CLI   0(R2),X'6C'         IS IT PA1?\n         BE    PRIOPT              YUP, I'M DONE\n         CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    REEDOPT             YUP, RESHOW SCREEN\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    REEDOPT             YUP, RESHOW SCREEN\n         LA    R1,INVPFK\n         ST    R1,MSGADD\n         B     REEDOPT             RESHOW SCREEN\nEDCKINPT L     R5,TERMINPT+ZIB1    PICK UP DS-NAME FIELD\n         L     R6,TERMINPT+ZIB2    PICK UP VOL-SER FIELD\n         L     R7,TERMINPT+ZIB3    PICK UP PASSWORD FIELD\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   EDCKINPC            NOPE\n         L     R3,SCROWS1          PICK UP SIZE OF SCREEN 1\n         SLL   R3,2                MULTIPLY BY 4\n         L     R5,TERMINPT+ZIB1(R3) PICK UP DS-NAME FIELD\n         L     R6,TERMINPT+ZIB2(R3) PICK UP VOL-SER FIELD\n         L     R7,TERMINPT+ZIB3(R3) PICK UP PASSWORD FIELD\nEDCKINPC CLI   0(R5),0             DS-NAME ENTERED (OR CHANGED)?\n         BNE   *+L'*+16            YES\n         OI    LIBDSNM,C' '\n         CLI   LIBDSNM,C' '        DS-NAME ALREADY IN?\n         BNE   CHKVLSR             YES\n         B     REEDSCN             ELSE RETRY THE SCREEN\n         LA    R0,L'EDSCF1-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   EDSCF1(R5),C' '\n         BNE   EDDSNMV\n         MVC   EDSCF1(L'EDSCF1-1,R5),EDSCF1+1(R5)\n         MVI   EDSCF1+L'EDSCF1-1(R5),C' '\n         BCT   R0,*-18\n         MVI   LIBDSNM,C' '        RESET DS-NAME FIELD\n         MVC   LIBDSNM+1(L'LIBDSNM-1),LIBDSNM\n         B     REEDSCN             RETRY THE SCREEN\nEDDSNMV  CLC   EDSCF1(4,R5),=CL4'END ' END OF BROWSE/EDIT?\n         BE    PRIOPT              YES, GO BACK\n         MVI   LIBDSNM,C' '        RESET DS-NAME FIELD\n         MVC   LIBDSNM+1(L'LIBDSNM-1),LIBDSNM\n         LA    R0,L'LIBDSNM        MAX. LENGTH FOR A DS-NAME\n         LA    R14,EDSCF1(R5)      START ADDRESS FOR DSN LENGTH CALC\n         XR    R15,R15             SET COUNTER\nEDDSNLOP CLI   0(R14),C'('         LEFT PAREN INDICATES MEMBER?\n         BE    EDDSNEND            GOT END, IGNORE MEMBER\n         CLI   0(R14),C' '         BLANK IS END OF DSN?\n         BE    EDDSNEND            GOT END\n         LA    R14,1(R14)          BUMP ADDRESS\n         LA    R15,1(R15)          BUMP COUNTER\n         BCT   R0,EDDSNLOP         TEST NEXT BYTE\n         LA    R1,BADEDDSN\n         B     EDSTMSG\nEDMOVDSN MVC   LIBDSNM(*-*),EDSCF1(R5) <<EXECUTED>>\nEDDSNEND BCTR  R15,0               SUBTRACT 1\n         EX    R15,EDMOVDSN\nCHKVLSR  MVC   LIBVOL(L'LIBVOL),=CL8' '\n         CLI   0(R6),0             VOL-SER ENTERED?\n         BE    CHKPSWD             NO\n         LA    R0,L'EDSCF2-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   EDSCF2(R6),C' '\n         BNE   *+L'*+14\n         MVC   EDSCF2(L'EDSCF2-1,R6),EDSCF2+1(R6)\n         MVI   EDSCF2+L'EDSCF2-1(R6),C' '\n         BCT   R0,*-18\n         MVC   LIBVOL(L'LIBVOL),EDSCF2(R6) MOVE IN THE VOL-SER\nCHKPSWD  CLI   0(R7),0             PASSWORD ENTERED?\n         BE    EDSETVOL            NO\n         LA    R0,L'EDSCF3-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   EDSCF3(R7),C' '\n         BNE   *+L'*+14\n         MVC   EDSCF3(L'EDSCF3-1,R7),EDSCF3+1(R7)\n         MVI   EDSCF3+L'EDSCF3-1(R7),C' '\n         BCT   R0,*-18\n         MVC   LIBPASS(L'LIBPASS),EDSCF3(R7) MOVE IN THE PASSWORD\nEDSETVOL BAL   R14,CTVTRTN\n         B     EDSTMSG             ERROR RETURN\n         USING DS1FMTID,R1\n         MVC   LIBORG,=CL3'SEQ'    SET DEFAULT DSORG\n         CLC   DS1DSORG(L'DS1DSORG),=AL1(DS1DSGPS,0) IS IT SEQUENTIAL?\n         BE    EDTSTLRC            YUP\n         MVC   LIBORG,=CL3'PDS'    SET DEFAULT DSORG\n         CLC   DS1DSORG(L'DS1DSORG),=AL1(DS1DSGPO,0) IS IT PO?\n         BE    EDTSTLRC            YUP\n         LA    R1,BADEDORG         ELSE NO GOOD, SET MESSAGE\n         B     EDSTMSG\nEDTSTLRC CLI   LIBFUNC,C'E'        EDIT FUNCTION REQUESTED?\n         BNE   EDFMTDIR            NO, SKIP LRECL CHECK\n         CLC   DS1LRECL(L'DS1LRECL),=H'80' IS LRECL=80?\n         BE    EDFMTDIR            YUP, OK\n         DROP  R1\n         LA    R1,BADED80          ELSE NO GOOD, SET MESSAGE\nEDSTMSG  ST    R1,MSGADD\n         B     REEDSCN             RETRY THE SCREEN\nEDFMTDIR L     R15,ARLIBM          GO TO LIBRARY MANAGEMENT\n*- - - - ETPSLIBM PARM.LIST : DS-NAME, VOL-SER, DS-ORG, PASSWORD\n        CALL   (15),(LIBDSNM,LIBVOL,LIBORG,LIBPASS),VL,MF=(E,PARMVL)\nREEDSCN  CLI   LIBFUNC,C'B'        BROWSE FUNCTION REQUESTED?\n         BE    REBROPT             YES, RESHOW THE SCREEN\n         B     REEDOPT             ELSE EDIT, RESHOW THE SCREEN\n         SPACE 1\n*- - - - LIBRARY UTILITY PROCESSING\nUTLOPT   MVI   LIBFUNC,C'U'        INDICATE LIBRARY UTILITY FUNCTION\nREUTOPT  L     R15,=A(UTLHELP)     HELP SCREEN\n         ST    R15,HELPADD\n         LA    R5,SCRNUTL\n         L     R6,=A(UTLMENU)\n         BAL   R14,SCRNBLD\n         CLI   LIBDSNM,C' '        IS THERE A DATA-SET NAME SPECIFIED?\n         BNE   *+L'*+12            BRANCH IF YES\n         MVI   CURROW,CRUTSN       CURSOR ROW\n         MVI   CURCOL,CCUTSN       CURSOR COLUMN\n         B     *+L'*+8\n         MVI   CURROW,CRUTSC       CURSOR ROW\n         MVI   CURCOL,CCUTSC       CURSOR COLUMN\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         LTR   R15,R15             BAD RC?\n         BNZ   PRIOPT              OUT\n         TM    COMMSW,PFKFLAG      IS IT A PF KEY/ATTN?\n         BZ    UTLCMD              NONE\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    PRIOPT              YUP, I'M DONE\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BE    PRIOPT              YUP, I'M DONE\n         CLI   0(R2),X'6C'         IS IT PA1?\n         BE    PRIOPT              YUP, I'M DONE\n         CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    REUTOPT             YUP\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    REUTOPT             YUP\n         LA    R1,INVPFK\n         ST    R1,MSGADD\n         B     REUTOPT\nUTLCMD   L     R3,TERMINPT+ZIUE    PICK UP COMMAND INPUT LINE\n         L     R5,TERMINPT+ZIU1    PICK UP DS-NAME FIELD\n         L     R6,TERMINPT+ZIU2    PICK UP VOL-SER FIELD\n         L     R7,TERMINPT+ZIU3    PICK UP PASSWORD FIELD\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   UTLSEL              NOPE\n         L     R3,SCROWS1          PICK UP SIZE OF SCREEN 1\n         SLL   R3,2                MULTIPLY BY 4\n         L     R5,TERMINPT+ZIU1(R3) PICK UP DS-NAME FIELD\n         L     R6,TERMINPT+ZIU2(R3) PICK UP VOL-SER FIELD\n         L     R7,TERMINPT+ZIU3(R3) PICK UP PASSWORD FIELD\n         L     R3,TERMINPT+ZIUE(R3) PICK UP COMMAND INPUT LINE\nUTLSEL   CLI   0(R3),0             COMMAND ENTERED?\n         BE    UTCHKDSN            NO\n         LA    R0,L'UTSCF1-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   UTSCF1(R3),C' '\n         BNE   *+L'*+14\n         MVC   UTSCF1(L'UTSCF1-1,R3),UTSCF1+1(R3)\n         MVI   UTSCF1+L'UTSCF1-1(R3),C' '\n         BCT   R0,*-18\n         CLC   UTSCF1(4,R3),=CL4'END ' END OF THIS SCREEN?\n         BE    PRIOPT              YES, GO BACK\nUTCHKDSN CLI   0(R5),0             DS-NAME ENTERED (OR CHANGED)?\n         BNE   *+L'*+16            YES\n         OI    LIBDSNM,C' '\n         CLI   LIBDSNM,C' '        DS-NAME ALREADY IN?\n         BNE   UTCHKVOL            YES\n         B     REUTOPT             ELSE RESHOW THE SCREEN\n         LA    R0,L'UTSCF2-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   UTSCF2(R5),C' '\n         BNE   UTDSNMV\n         MVC   UTSCF2(L'UTSCF2-1,R5),UTSCF2+1(R5)\n         MVI   UTSCF2+L'UTSCF2-1(R5),C' '\n         BCT   R0,*-18\n         MVC   LIBDSNM(L'LIBDSNM),UTSCF2(R5)\n         B     REUTOPT             RESHOW THE SCREEN\nUTDSNMV  MVI   LIBDSNM,C' '        RESET DS-NAME FIELD\n         MVC   LIBDSNM+1(L'LIBDSNM-1),LIBDSNM\n         MVC   LIBORG,=CL3'PDS'    SET IT PDS, BY DEFAULT\n         LA    R0,L'LIBDSNM        MAX. LENGTH FOR A DS-NAME\n         LA    R14,UTSCF2(R5)      START ADDRESS FOR DSN LENGTH CALC\n         XR    R15,R15             SET COUNTER\nUTDSNLOP CLI   0(R14),C' '         BLANK IS END OF DSN?\n         BE    UTDSNEND            GOT END\n         CLI   0(R14),C'('         LEFT PAREN?\n         BE    UTDSNEND            GOT END\n         LA    R14,1(R14)          BUMP ADDRESS\n         LA    R15,1(R15)          BUMP COUNTER\n         BCT   R0,UTDSNLOP         TEST NEXT BYTE\n         LA    R1,UTBADDSN\n         B     UTSTMSG\nUTDSNEND BCT   R15,*+L'*+6         SUBTRACT 1\n         MVC   LIBDSNM(*-*),UTSCF2(R5) <<EXECUTED>>\n         EX    R15,*-6\nUTCHKVOL MVC   LIBVOL(L'LIBVOL),=CL8' '\n         CLI   0(R6),0             VOL-SER ENTERED?\n         BE    UTCHKPSW            NO\n         LA    R0,L'UTSCF3-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   UTSCF3(R6),C' '\n         BNE   *+L'*+14\n         MVC   UTSCF3(L'UTSCF3-1,R6),UTSCF3+1(R6)\n         MVI   UTSCF3+L'UTSCF3-1(R6),C' '\n         BCT   R0,*-18\n         MVC   LIBVOL(L'LIBVOL),UTSCF3(R6) MOVE IN THE VOL-SER\nUTCHKPSW CLI   0(R7),0             PASSWORD ENTERED?\n         BE    UTCHKCMD            NO\n         LA    R0,L'UTSCF4-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   UTSCF4(R7),C' '\n         BNE   *+L'*+14\n         MVC   UTSCF4(L'UTSCF4-1,R7),UTSCF4+1(R7)\n         MVI   UTSCF4+L'UTSCF4-1(R7),C' '\n         BCT   R0,*-18\n         MVC   LIBPASS(L'LIBPASS),UTSCF4(R7) MOVE IN THE PASSWORD\nUTCHKCMD CLI   0(R3),0             IF NO COMMAND ENTERED\n         BE    UTLLIST             GO LIST THE LIBRARY\n         CLI   UTSCF1(R3),C' '     IS IT PDS MEMBERS LIST?\n         BE    UTLLIST             YUP\n         CLI   UTSCF1(R3),C'C'     IS IT PDS COMPRESS?\n         BE    UTLCPRS             YUP\n         CLI   UTSCF1(R3),C'S'     IS IT DS STATISTICS?\n         BE    UTLSTAT             YUP\n         LA    R1,INVOPT\n         B     UTSTMSG\nUTLCPRS  ICM   R15,B'1111',ARCOMP\n         BNZ   CALLCM\n        LOAD   EP=ETPSCOMP,ERRET=LDCMERR\n         ST    R0,ARCOMP\n         LR    R15,R0\n*- - - - ETPSCOMP PARM.LIST : DS-NAME, VOL-SER, PASSWORD\nCALLCM  CALL   (15),(LIBDSNM,LIBVOL,LIBPASS),VL,MF=(E,PARMVL)\n         B     REUTOPT\nLDCMERR  STM   R0,R1,MESSPL        COMPRESS IS UNAVAILABLE\n        XMESS  99,R15\n         LA    R1,UTLLDCME\n         B     UTSTMSG\nUTLSTAT  ICM   R15,B'1111',ARSTAT\n         BNZ   CALLST\n        LOAD   EP=ETPSDSST,ERRET=LDSMERR\n         ST    R0,ARSTAT\n         LR    R15,R0\n*- - - - ETPSDSST PARM.LIST : DS-NAME, VOL-SER, PASSWORD, USER-ID\nCALLST  CALL   (15),(LIBDSNM,LIBVOL,LIBPASS,USERID),VL,MF=(E,PARMVL)\n         B     REUTOPT\nLDSMERR  STM   R0,R1,MESSPL        STATDS IS UNAVAILABLE\n        XMESS  99,R15\n         LA    R1,UTLLDSME\n         B     UTSTMSG\nUTLLIST  BAL   R14,CTVTRTN\n         B     UTSTMSG             ERROR RETURN\n         USING DS1FMTID,R1\n         CLC   DS1DSORG(L'DS1DSORG),=AL1(DS1DSGPO,0) IS IT PO?\n         BNE   UTLORBAD            NOPE\n         CLC   DS1LRECL(L'DS1LRECL),=H'80' IS LRECL=80?\n         BNE   UTLLRBAD            IF NO GOOD, RETRY THE SCREEN\n         DROP  R1\n         L     R15,ARLIBM          GO TO LIBRARY MANAGEMENT\n*- - - - ETPSLIBM PARM.LIST : DS-NAME, VOL-SER, DS-ORG, PASSWORD\n        CALL   (15),(LIBDSNM,LIBVOL,LIBORG,LIBPASS),VL,MF=(E,PARMVL)\n         B     REUTOPT             RESHOW THE SCREEN\nUTLORBAD LA    R1,UTBADORG\n         B     UTSTMSG\nUTLLRBAD LA    R1,UTBADLRE\nUTSTMSG  ST    R1,MSGADD\n         B     REUTOPT\n         SPACE 1\n*- - - - CATALOG/VTOC INFO ROUTINE\n*              R14 = LINK REGISTER / RETURN +0 = ERROR (R1 = A.MSG)\n*                                           +4 = OK (R1 = A.VTOC-INFO)\nCTVTRTN  ST    R14,SVRTR14         SAVE RETURN\n         OI    LIBVOL,C' '\n         CLI   LIBVOL,C' '         WAS VOL-SER PROVIDED?\n         BNE   CTVTRTN1            YUP\n         MVC   VCMLST(CTCMLSL),CTCMLST CLEAR CAMLST AREA\n         XC    VUSWA(L'VUSWA),VUSWA\n         XC    VUSWA+L'VUSWA(16),VUSWA+L'VUSWA\n         LA    R15,LIBDSNM         SET DSN\n         XR    R0,R0\n         LA    R1,VUSWA            SET OUTPUT AREA\n         STM   R15,R1,VCMLST+4\n        LOCATE VCMLST\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    *+L'*+8             OK\n         LA    R1,BADCTLOC         ELSE SET MESSAGE\n         B     CTVTRTNX\n         MVC   LIBVOL(L'LIBVOL),VUSWA+6 SET THE VOL-SER\n         OI    PRCSSW,VSRFC        SAY RETRIEVED FROM CATALOG\nCTVTRTN1 MVC   VCMLST(VTCMLSL),VTCMLST CLEAR CAMLST AREA\n         XC    VUSWA(DSCBLGTH),VUSWA\n         LA    R15,LIBDSNM         SET DSN\n         LA    R0,LIBVOL           SET VOL-SER\n         LA    R1,VUSWA            SET OUTPUT AREA ADDRESS\n         STM   R15,R1,VCMLST+4\n        OBTAIN VCMLST\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    *+L'*+8             OK\n         LA    R1,BADVTOBT         ELSE SET MESSAGE\n         B     CTVTRTNX\n         LA    R1,VUSWA            PASS BACK VTOC-INFO ADDRESS\nCTVTRTNX L     R14,SVRTR14         RETURN\n         LTR   R15,R15             TEST RETURN CODE\n         BZ    4(R14)              OK\n         BR    R14                 ERROR\n         SPACE 1\n*- - - - IDCAMS FOREGROUND PROCESSING\nIDOPT    ICM   R15,B'1111',ARIDCA\n         BNZ   CALLID\n        LOAD   EP=ETPSIDCA,ERRET=LDIDERR\n         ST    R0,ARIDCA\n         LR    R15,R0\n*- - - - ETPSIDCA PARM.LIST : NONE\nCALLID  CALL   (15)\n         B     PRIOPT\nLDIDERR  STM   R0,R1,MESSPL        IDCAMS IS UNAVAILABLE\n        XMESS  99,R15\n         LA    R1,UTLLDIDE\n         ST    R1,MSGADD\n         B     PRIOPT\n         SPACE 1\n*- - - - ZAP (DISPLAY/MODIFY DATA-SET)\nZAOPT    ICM   R15,B'1111',ARZAP\n         BNZ   ZACALL\n        LOAD   EP=ETPSZAP,ERRET=LDZAERR\n         ST    R0,ARZAP\n         LR    R15,R0\n*- - - - ETPSZAP PARM.LIST : NONE\nZACALL  CALL   (15)                GO TO ZAP SELECT DATA-SET PROCESS\n         B     PRIOPT              THEN LOOK FOR ANOTHER SELECTION\nLDZAERR  STM   R0,R1,MESSPL        ZAP IS UNAVAILABLE\n        XMESS  99,R15\n         LA    R1,ZAUMSG\n         ST    R1,MSGADD\n         B     PRIOPT\n         SPACE 1\n*- - - - INCORZAP (MAIN STORAGE SUPERZAP FOR MVS)\nIZOPT    TM    STATSW,SPCLFLG      USER HAS SPECIAL ATTRIBUTE?\n         BO    IZGODO              YES, OK\n         LA    R1,IZRUMSG          ELSE USER IS UNAUTHORIZED\n         ST    R1,MSGADD\n         B     PRIOPT\nIZGODO   ICM   R15,B'1111',ARIZAP\n         BNZ   IZCALL\n        LOAD   EP=ETPSIZAP,ERRET=LDIZERR\n         ST    R0,ARIZAP\n         LR    R15,R0\n*- - - - ETPSIZAP PARM.LIST : NONE\nIZCALL  CALL   (15)                GO TO INCORZAP PROCESS\n         B     PRIOPT              THEN LOOK FOR ANOTHER SELECTION\nLDIZERR  STM   R0,R1,MESSPL        INCORZAP IS UNAVAILABLE\n        XMESS  99,R15\n         LA    R1,IZUMSG\n         ST    R1,MSGADD\n         B     PRIOPT\n         EJECT\n*------- PROCESSING TERMINATION -------------------------------------*\n         AIF   ('&EATL' EQ '').SKX2                                <X>\nCLOSETB  TM    ATTNSW,ATTRSET      IS ATTENTION ROUTINE ACTIVE?    <X>\n         BZ    NOATTR              NO                              <X>\n         L     R1,XWAPTR           YES, GET WORK-AREA POINTER      <X>\n         USING XWAREA,R1                                           <X>\n         LA    R15,XWABND          SET RESET ALL ENTRY ADDRESS     <X>\n        CALL   (15)                AND GO DO IT                    <X>\n         DROP  R1                                                  <X>\n         L     R0,=A(XWAREAL)      NOW FREE WORK-AREA              <X>\n        FREEMAIN R,LV=(0),A=(1)                                    <X>\nNOATTR   L     R4,BUFF             ADDRESS OF WRITE BUFFER         <X>\n         AGO   .SKX3                                               <X>\n.SKX2    ANOP  ,                                                   <X>\nCLOSETB  L     R4,BUFF             ADDRESS OF WRITE BUFFER         <X>\n.SKX3    MVI   0(R4),X'7E'         ERASE-WRITE-ALTERNATE           <X>\n         MVC   1(L'ERSSCR,R4),ERSSCR ERASE SCREEN SEQUENCE         <X>\n         MVI   1(R4),X'C3'         RESET KEYBOARD + RESET MDT      <X>\n         LA    R5,L'ERSSCR+1       COMPUTE LENGTH                  <X>\n         XC    RECB,RECB           RESET ECB                       <X>\n         MVC   CCW1(8),SLCCW                                       <X>\n         MVC   CCW2(1),WRITECC     COMMAND CODE SET BASED ON THE   <X>\n         MVC   CCW2+1(7),WRTCCW+1    TERMINAL TYPE                 <X>\n         STCM  R4,B'0111',CCW2+1   SET THE DATA ADDRESS            <X>\n         STCM  R5,B'0011',CCW2+6   SET THE LENGTH                  <X>\n         LA    R1,CCW1                                             <X>\n         STCM  R1,B'0111',TUBEIOB+(IOBSTRTB-IOBSTDRD)              <X>\n         LA    R2,RECB             SET ECB ADDRESS IN THE IOB      <X>\n         STCM  R2,B'0111',TUBEIOB+(IOBECBPB-IOBSTDRD)              <X>\n        EXCP   TUBEIOB                                             <X>\n        WAIT   ECB=RECB                                            <X>\n         LA    R2,TUBE                                             <X>\n         MVI   OPCLPL,VLB          SET \"VL\" BIT                    <X>\n        CLOSE  ((R2)),MF=(E,OPCLPL)                                <X>\nFRTUBE   MVI   VERBCODE,S99VRBUN   SET TO INDICATE UNALLOCATE      <X>\n         OI    DYNTEXT1,S99TUPLN   DDNAME ONLY                     <X>\n         LA    R1,DYNPARM                                          <X>\n        DYNALLOC ,                 DE-ALLOCATE TUBE                <X>\n         LTR   R15,R15             HOW COMPLETE?                   <X>\n         BZ    DELMODS             OK                              <X>\n        XMESS  1101,R15                                            <X>\n         B     DELMODS                                             <X>\nTSOEND  TPUT   ERSSCR,L'ERSSCR,FULLSCR\n        STFSMODE OFF               TURN OFF FULL-SCREEN MODE\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    DELMODS             OK\n        XMESS  1102,R15\nDELMODS  ICM   R0,B'1111',ARBROWSE\n         BZ    DELMOD1\n        DELETE EP=ETPSBROW\nDELMOD1  ICM   R0,B'1111',AREDIT\n         BZ    DELMOD2\n        DELETE EP=ETPSEDIT\nDELMOD2  ICM   R0,B'1111',ARMEMC\n         BZ    DELMOD3\n        DELETE EP=ETPSMEMC\nDELMOD3  ICM   R0,B'1111',ARCOMP\n         BZ    DELMOD4\n        DELETE EP=ETPSCOMP\nDELMOD4  ICM   R0,B'1111',ARIDCA\n         BZ    DELMOD5\n        DELETE EP=ETPSIDCA\nDELMOD5  ICM   R0,B'1111',ARZAP\n         BZ    DELMOD6\n        DELETE EP=ETPSZAP\nDELMOD6  ICM   R0,B'1111',ARIZAP\n         BZ    DELMOD7\n        DELETE EP=ETPSIZAP\nDELMOD7  ICM   R0,B'1111',ARSTAT\n         BZ    RTRNEND\n        DELETE EP=ETPSDSST\nRTRNEND DELETE EP=ETPSMESS\nLEAVE   DELETE EP=ETPSUTIL\nQUIT     L     R0,GETSIZE\n         LR    R1,R13\n         L     R13,4(R13)          PICK UP CALLING SAVE-AREA\n        FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)     RESTORE CALLING REGISTERS\n         XR    R15,R15             SET OK RETURN CODE\n         BR    R14                   AND RETURN\n         EJECT\n*------- GENERAL SCREEN BUILD SUB-ROUTINE ---------------------------*\n*              AT ENTRY, R5 IS THE ADDRESS OF THE SCREEN COMPLETION\n*                            PROCESS TO USE,\n*                        R6 POINTS TO THE BEGINNING OF THE VARIABLE\n*                           LENGTH VECTOR OF THE SCREEN LINES IMAGES\n*                           ADDRESSES, AND\n*                        R14 IS THE RETURN ADDRESS.\nSCRNBLD  L     R4,SCROWS1          NUMBER OF ROWS IN SCREEN 1\n         LA    R3,TERMOUT+4        POINT TO FIRST LINE OF SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2\n         BNE   SCRNBLD1            NOPE, I'M ALL SET\n         SLL   R4,2                MULTIPLY OFFSET BY 4\n         LA    R3,TERMOUT+4(R4)    POINT TO ROW 1 OF SCREEN 2\n         L     R4,SCROWS2          NUMBER OF ROWS IN SCREEN 2\nSCRNBLD1 L     R2,0(,R6)           ADDRESS OF FROM FIELD\n         L     R7,0(,R3)           ADDRESS OF \"TO\" FIELD\n         XR    R1,R1\n         IC    R1,0(,R2)           PICK UP LENGTH\n         EX    R1,*+L'*+2          MOVE IT\n         BR    R5\n         MVC   0(*-*,R7),0(R2)     <<EXECUTED>>\n*- - - - LOGON SCREEN\nSCRNLOG  CLC   LUOFF(13,R7),=CL13'ENTER USER-ID' USER-ID?\n         BNE   SCRNLOGN            NO\n         TM    STATSW,TESTFLG      YES, TSO TEST OF LOGON PANEL?   <T>\n         BZ    *+L'*+6             NO                              <T>\n         MVC   LTOFF(20,R7),=CL20'(OR MSG-NUMBER TEST)'            <T>\n         MVC   LGSCF1(L'LGSCF1,R7),USERID MOVE IT\n         B     SCRNSKP             DO THE REST\nSCRNLOGN CLC   LPOFF(13,R7),=CL13'     PASSWORD' PASSWORD?\n         BNE   *+L'*+10            NO\n         MVC   LGSCF2(L'LGSCF2,R7),USERPASS MOVE IT\n         B     SCRNSKP             DO THE REST\n         CLC   LGOFF(13,R7),=CL13'   RACF GROUP' RACF-GROUP?\n         BNE   SCRNSKP             NOPE, SKIP THIS\n         MVC   LGSCF3(L'LGSCF3,R7),RACGROUP MOVE IT\n         B     SCRNSKP             DO THE REST\n*- - - - PRIMARY OPTION SCREEN\nSCRNPRM  CLC   PROFF1+1(9,R7),=CL9'USER-ID :' USER-ID?\n         BNE   SCRNPRMD            NO\n         MVC   UOFF(L'UOFF,R7),USERID YES, SET USER-ID\n         MVC   GROFF(L'GROFF,R7),RACGROUP SET GROUP-ID\n         CLI   TUBEDDNM,C'T'       TSO TERMINAL?\n         BNE   *+L'*+10            NO\n         MVC   TERMOFF(L'TERMOFF,R7),TERMSNME\n         B     *+L'*+12\n         MVC   TERMOFF(1,R7),TERMTYPE\n         MVC   TERMOFF+2(3,R7),TERMADDR\n         B     SCRNSKP             DO THE REST\nSCRNPRMD CLC   PROFF2+1(14,R7),=CL14'SELECT OPTION ' USER-ID?\n         BNE   SCRNPRMT            NO\n         ST    R14,VUSWA           SAVE R14 AROUND ROUTINE\n         LA    R1,VUSWA+4          -> FORMAT DATE AND TIME WORK-AREA\n         XC    0(FDTWAL,R1),0(R1)  CLEAR\n         L     R15,ARFDTE          GET CURRENT DATE/TIME\n*- - - - ETPSFDTE PARM.LIST : \"FDTWA\" ADDRESS\n        CALL   (15)\n         USING FDTWA,R1\n         LTR   R15,R15             HOW COMPLETE?\n         BNZ   *+L'*+12            ERROR, SKIP\n         AIF   ('&TXV' NE 'EUROPE').SK1\n         MVC   DATEOFF(L'FXDD,R7),FXDD\n         MVC   DATEOFF+L'FXDD+1(L'FXMM,R7),FXMM\n         MVC   DATEOFF+L'FXDD+L'FXMM+2(L'FXYY,R7),FXYY\n         AGO   .SK2\n.SK1     MVC   DATEOFF+L'FXYY+L'FXMM+2(L'FXDD,R7),FXDD\n         MVC   DATEOFF+L'FXYY+1(L'FXMM,R7),FXMM\n         MVC   DATEOFF(L'FXYY,R7),FXYY\n.SK2     MVC   TIMEOFF(L'FTHH,R7),FTHH\n         MVC   TIMEOFF+L'FTHH+1(L'FTMM,R7),FTMM\n         L     R14,VUSWA           RESTORE R14\n         B     SCRNSKP             DO THE REST\n         DROP  R1\nSCRNPRMT CLI   TUBEDDNM,C'O'       OPERATOR TERMINAL?\n         BE    *+L'*+8             YES\n         CLI   TUBEDDNM,C'T'       TSO TERMINAL?\n         BNE   SCRNSKP             NO, DO THE REST\n         CLC   MSGOFF1(11,R7),=CL11'AND RETURN ' EXIT MESSAGE?\n         BE    SCRNPRMX            YES\n         CLC   MSGOFF2(11,R7),=CL11'AND RETURN ' EXIT MESSAGE?\n         BNE   SCRNSKP             NO, DO THE REST\n         MVC   MSGOFF2(L'MSGOFF2,R7),MSGOFF2-1(R7) NO LOGON PANEL\n         MVI   MSGOFF2-1(R7),C'.'\n         B     SCRNSKP             DO THE REST\nSCRNPRMX MVC   MSGOFF1(L'MSGOFF1,R7),MSGOFF1-1(R7) NO LOGON PANEL\n         MVI   MSGOFF1-1(R7),C'.'\n         B     SCRNSKP             DO THE REST\n*- - - - BROWSE/EDIT ENTRY SCREENS\nSCRNBES  TM    PRCSSW,VSRFC        VOL-SER WAS RETRIEVED FROM CATALOG?\n         BZ    *+L'*+10            NO\n         NI    PRCSSW,255-VSRFC\n         MVC   LIBVOL(L'LIBVOL),=CL8' '\n         CLC   EDOFF1(10,R7),=CL10'FULLY-QUAL' DS-NAME?\n         BNE   SCRNBES1            NO\n         OI    LIBDSNM,C' '\n         CLI   LIBDSNM,C' '        IS THERE A DATA-SET NAME SPECIFIED?\n         BE    SCRNSKP             NO\n         MVC   EDSCF1(L'LIBDSNM,R7),LIBDSNM COPY CURRENT DATA-SET NAME\n         B     SCRNSKP             DO THE REST\nSCRNBES1 CLC   EDOFF2(13,R7),=CL13'VOLUME SERIAL' VOL-SER?\n         BNE   SCRNBES2            NO\n         OI    LIBVOL,C' '\n         CLI   LIBVOL,C' '         IS THERE A VOL-SER SPECIFIED?\n         BE    SCRNSKP             NO\n         MVC   EDSCF2(L'EDSCF2,R7),LIBVOL  COPY CURRENT VOL-SER\n         B     SCRNSKP             DO THE REST\nSCRNBES2 CLC   EDOFF3(17,R7),=CL17'DATA-SET PASSWORD' PASSWORD?\n         BNE   SCRNSKP             NOPE, SKIP THIS\n         MVC   EDSCF3(L'EDSCF3,R7),LIBPASS COPY CURRENT PASSWORD\n         CLI   LIBPASS,C' '        IS THERE A PASSWORD SPECIFIED?\n         BE    SCRNSKP             NO\n         MVC   EDOFF4(L'EDOFF4,R7),=CL3'(I)' SAY IN\n         MVI   EDOFF4-1(R7),X'05'  SET INTENS\n         B     SCRNSKP             DO THE REST\n*- - - - LIBRARY UTILITY ENTRY SCREENS\nSCRNUTL  TM    PRCSSW,VSRFC        VOL-SER WAS RETRIEVED FROM CATALOG?\n         BZ    *+L'*+10            NO\n         NI    PRCSSW,255-VSRFC\n         MVC   LIBVOL(L'LIBVOL),=CL8' '\n         CLC   UTOFF1(10,R7),=CL10'FULLY-QUAL' DS-NAME?\n         BNE   SCRNUTL1            NO\n         OI    LIBDSNM,C' '\n         CLI   LIBDSNM,C' '        IS THERE A DATA-SET NAME SPECIFIED?\n         BE    SCRNSKP             NO\n         MVC   UTSCF2(L'UTSCF2,R7),LIBDSNM COPY CURRENT DATA-SET NAME\n         B     SCRNSKP             DO THE REST\nSCRNUTL1 CLC   UTOFF2(13,R7),=CL13'VOLUME SERIAL' VOL-SER?\n         BNE   SCRUTL2             NO\n         OI    LIBVOL,C' '\n         CLI   LIBVOL,C' '         IS THERE A VOL-SER SPECIFIED?\n         BE    SCRNSKP             NO\n         MVC   UTSCF3(L'UTSCF3,R7),LIBVOL  COPY CURRENT VOL-SER\n         B     SCRNSKP             DO THE REST\nSCRUTL2  CLC   UTOFF3(17,R7),=CL17'DATA-SET PASSWORD' PASSWORD?\n         BNE   SCRNSKP             NOPE, SKIP THIS\n         MVC   UTSCF4(L'UTSCF4,R7),LIBPASS COPY CURRENT PASSWORD\n         CLI   LIBPASS,C' '        IS THERE A PASSWORD SPECIFIED?\n         BE    SCRNSKP             NO\n         MVC   UTOFF4(L'UTOFF4,R7),=CL3'(I)' SAY IN\n         MVI   UTOFF4-1(R7),X'05'  SET INTENS\nSCRNSKP  TM    0(R6),EOL           END-OF-LIST?\n         BO    SCRNBLD2            YUP\n         LA    R6,4(R6)            BUMP TO NEXT PARM\n         LA    R3,4(R3)            BUMP TO NEXT PARM\n         NI    0(R3),255-EOS       CLEAR END-OF-SCREEN\n         BCT   R4,SCRNBLD1         KEEP LOOPING\nSCRNBLD2 LTR   R4,R4               END OF SCREEN ROWS?\n         BZ    SCRNBLD4            YES\n         BCTR  R4,0                SUBTRACT 1 FOR LUCK\n         LTR   R4,R4               END OF SCREEN ROWS?\n         BZ    SCRNBLD4            YES\n         LA    R3,4(R3)            BUMP TO NEXT PARM\n         L     R7,0(,R3)           ADDRESS OF \"TO\" FIELD\nSCRNBLD3 MVC   0(DUMMYRWL,R7),DUMMYROW MOVE IN A DUMMY ROW\n         NI    0(R3),255-EOS       CLEAR END-OF-SCREEN\n         LA    R3,4(R3)            BUMP TO NEXT PARM\n         L     R7,0(,R3)           ADDRESS OF \"TO\" FIELD\n         BCT   R4,SCRNBLD3         KEEP LOOPING\n         CLI   SPLIT,1             AM I IN SPLIT-SCREEN, SCREEN 1?\n         BE    SCRNBLD4            YUP, DON'T MOVE THIS IN\n         MVC   0(DUMMYRWL,R7),DUMMYROW MOVE IN A DUMMY ROW\nSCRNBLD4 CLI   SPLIT,1             AM I IN SPLIT-SCREEN, SCREEN 1?\n         BER   R14                 YES\n         OI    0(R3),EOS           SET END-OF-SCREEN\n         BR    R14\n         EJECT\n*------- DATA AREA'S AND CONSTANTS ----------------------------------*\n         SPACE 1\nXESNAP   EQU   *,8\n         BALR  R15,0\n         L     R15,6(,R15)\n         BR    R15\n        @MPW   ,                   MASTER PASSWORD\nRINITSK  RACINIT ENVIR=CHANGE,MF=L\nRINITSKL EQU   *-RINITSK\nCTCMLST CAMLST NAME,*-*,,*-*\nCTCMLSL  EQU   *-CTCMLST\nVTCMLST CAMLST SEARCH,*-*,*-*,*-*\nVTCMLSL  EQU   *-VTCMLST\n         SPACE 1\nGETSIZE  DC    A(GMSIZE)\nSMOD    MODESET KEY=ZERO,MODE=SUP,MF=L       ENTER IN SUP STATE\nSMODLEN  EQU   *-SMOD\nPMOD    MODESET KEY=NZERO,MODE=PROB,MF=L     GET BACK IN PROB STATE\nPMODLEN  EQU   *-PMOD\n*- - - - SUBMIT DYNAMIC ALLOCATION PARAMETERS, ETC...\nSUBRBSK  DC    AL1(S99RBEND-S99RB) LENGTH\n         DC    AL1(S99VRBAL)       VERB CODE = DS-NAME ALLOCATION\n         DC    AL1(0,0)            FLAGS (ALLOW OFFLINE UNITS)\n         DC    2XL2'0'             ERROR-INFORMATION REASON CODES\n         DC    A(*-*)              POINTER TO TEXT POINTERS\nSUBLENI  EQU   (S99RBEND-S99RB)-(*-SUBRBSK)\n         DC    (SUBLENI)X'0'       RESERVED + FLAGS\n         DC    A(SUBDDNAM)         POINTER TO DDNAME\n         DC    A(SUBCLS)           POINTER TO SYSOUT CLASS\n         DC    A(SUBPGM)           POINTER TO INTRDR\n         DC    AL1(S99TUPLN),AL3(SUBFRE) POINTER TO FREE=CLOSE\nSUBLEN   EQU   *-SUBRBSK\n         DS    0H\nSUBDDNAM DC    AL2(DALDDNAM)       DDNAME=  PARAMETER\n         DC    AL2(1)              NUMBER OF TEXT UNITS\n         DC    AL2(6)              LENGTH OF PARM\n         DC    CL8'SUBJOB'         DDNAME\n         DS    0H\nSUBCLS   DC    AL2(DALSYSOU)       SYSOUT= PARAMETER\n         DC    AL2(1)              NUMBER OF TEXT UNITS\n         DC    AL2(1)              LENGTH OF PARM\n         DC    CL1'A'              SYSOUT CLASS\n         DS    0H\nSUBPGM   DC    AL2(DALSPGNM)       INTRDR PARAMETER\n         DC    AL2(1)              NUMBER OF TEXT UNITS\n         DC    AL2(6)              LENGTH OF PARM\n         DC    CL8'INTRDR'         PGM NAME\n         DS    0H\nSUBFRE   DC    AL2(DALCLOSE)       FREE=CLOSE\n         DC    AL2(0)              NUMBER OF TEXT UNITS\n*- - - - DISPLAY TERMINAL ALLOCATION, ETC...                       <X>\nSLCCW    CCW   X'0B',*-*,X'60',1                                   <X>\nWRTCCW   CCW   X'0D',*-*,X'20',*-*                                 <X>\nIOBINIT  DC    AL1(IOBCMDCH+IOBUNREL,0)                            <X>\n         DC    XL(IOBLEN-(IOBSENS0-IOBSTDRD))'0' REST OF IOB       <X>\nTINIT   DCB    DSORG=PS,MACRF=E,DDNAME=SCREEN,BUFL=4*KB,RECFM=U    <X>\n         DS    0F                                                  <X>\nCONRB    DC    AL1(S99RBEND-S99RB) LENGTH                          <X>\n         DC    AL1(S99VRBAL)       VERB CODE = DS-NAME ALLOCATION  <X>\n         DC    AL1(0,0)            FLAGS (ALLOW OFFLINE UNITS)     <X>\n         DC    2XL2'0'             ERROR-INFORMATION REASON CODES  <X>\n         DC    F'0'                POINTER TO TEXT POINTERS        <X>\n         DC    F'0'                RESERVED                        <X>\n         DC    AL1(S99OFFLN,0,0,0) FLAGS (CONSIDER OFFLINE UNITS)  <X>\n         DS    0H                                                  <X>\n         DC    AL2(DALDDNAM)       DDNAME=  PARAMETER              <X>\n         DC    AL2(1)              NUMBER OF TEXT UNITS            <X>\n         DC    AL2(8)              LENGTH OF PARM                  <X>\n         DC    CL8'TUBE'           DDNAME                          <X>\n         DS    0H                                                  <X>\n         DC    AL2(DALSTATS)       DISP= PARAMETER                 <X>\n         DC    AL2(1)              NUMBER OF TEXT UNITS            <X>\n         DC    AL2(1)              LENGTH OF PARM                  <X>\n         DC    XL1'01'             OLD                             <X>\n         DS    0H                                                  <X>\n         DC    AL2(DALUNIT)        UNIT= PARAMETER                 <X>\n         DC    AL2(1)              NUMBER OF TEXT UNITS            <X>\n         DC    AL2(3)              LENGTH OF PARM                  <X>\n         DC    CL3' '              UNIT ADDRESS                    <X>\nCONRBLG  EQU   *-CONRB             VALUE MUST MATCH \"DYNLENG\" VALUE<X>\n         SPACE 1\nDUMMYROW DC    AL1(DUMMYRWL-1),X'04',CL9' '\nDUMMYRWL EQU   *-DUMMYROW\nERSSCR   DC    X'C1115D7E1140403C4040001DC813'\n         SPACE 1\nBADEDORG MSG   'BAD DSORG'\nBADED80  MSG   'LRECL NOT 80'\nBADEDDSN MSG   'DS-NAME ERROR'\nBADCTLOC MSG   'LOCATE FAILED'\nBADVTOBT MSG   'OBTAIN FAILED'\nUTBADORG MSG   'INVALID DSORG'\nINVPFK   MSG   'INVALID PF-KEY'\nINVOPT   MSG   'INVALID OPTION'\nUTBADDSN MSG   'INVALID DS-NAME'\nZAUMSG   MSG   'ZAP UNAVAILABLE'\nREJUSER  MSG   'USER-ID REJECTED'\nMNUSER   MSG   'USER-ID MANDATORY'\nINVMSN   MSG   'INVALID MSG-NUMBER'\nINVGROUP MSG   'INVALID RACF-GROUP'\nUTLLDIDE MSG   'IDCAMS UNAVAILABLE'\nUTLLDSME MSG   'STATDS UNAVAILABLE'\nIZRUMSG  MSG   'RESTRICTED USE ONLY'\nUTBADLRE MSG   'INVALID LRECL-NOT 80'\nUTLLDCME MSG   'COMPRESS UNAVAILABLE'\nIZUMSG   MSG   'INCORZAP UNAVAILABLE'\n         SPACE 1\nEXTLST  EXTRACT ,'S',,MF=L\nEXTLSTL  EQU   *-EXTLST\nLOADMSG WTO    'ETPS0099 : LOAD \"ETPS....\" FAILED / RC = .. / ABEND CODX\n               E = ........ ',ROUTCDE=2,DESC=3,MF=L\nLOADMSGL EQU   *-LOADMSG\nLDMS1    EQU   25,4\nLDMS2    EQU   45,2\nLDMS3    EQU   63,8\nALTRD   WTO    '  ',ROUTCDE=11,DESC=7,MF=L\nALTRDF   EQU   6,4\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R10,R11,R12,R13\n        @ULT   ,                   USERS TABLE\n         EJECT\n*------- LIBRARY MANAGEMENT -----------------------------------------*\n*        AT ENTRY, R1 = A(PARM.LIST) -> (DS-NAME,\n*                                        VOL-SER,\n*                                        DS-ORG,\n*                                        PASSWORD)\n         CNOP  0,4\n         USING *,R12,R11\n         USING SAVE2,R13      ************************** R13 ==> SAVE2\n         USING SPLTAREA,R10   AT ENTRY : R10 MUST POINT TO \"SPLTAREA\"\nETPSLIBM STM   R14,R12,12(R13)     SAVE INPUT REGISTERS\n         LR    R12,R15             SET PROGRAM BASE REGISTER 1\n         LA    R3,1\n         LA    R11,4*KB-1(R3,R12)  SET PROGRAM BASE REGISTER 2\n         LR    R3,R10              SPLIT-SCREEN DSECT\n         SH    R3,=Y(SPLITWRK-SAVE2) POINT TO SAVE2\n         ST    R13,4(,R3)          STORE BACKWARD POINTER\n         ST    R3,8(R13)           STORE FORWARD POINTER\n         LR    R13,R3              SET DSECT BASE\n         L     R7,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R2,R7\n         LH    R3,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R2,R14              CLEAR TO ALL BLANKS\n         LM    R3,R6,0(R1)         PICK UP 4 PARMS\n*                                    R3=DS-NAME\n*                                    R4=VOL-SER\n*                                    R5=DS-ORG\n*                                    R6=PASSWORD (IF ANY)\n         MVC   DIRDSNM(L'DIRDSNM),0(R3) DS-NAME\n         MVC   DIRVOL(L'DIRVOL),0(R4) VOL-SER\n         MVC   DIRORG(L'DIRORG),0(R5) DS-ORG\n         MVC   DIRPASS(L'DIRPASS),0(R6) PASSWORD\n         USING PARMLIST,R7\n*- - - - ALLOCATE THE FILE\n         MVC   DSNAME,DIRDSNM      DS-NAME\n         MVC   DSVOLSER,DIRVOL     VOL-SER\n         MVC   PASSWORD,DIRPASS    PASSWORD\n         MVC   DSSTATUS,=CL8'SHR'  SET DISP=SHR\n         MVC   LOCNAME,=CL8' '     NOT DOING LOCATE\n         MVC   DSUNIT,=CL8'SYSALLDA'\n         CLC   DIRORG,=CL3'SEQ'    IS THIS A SEQUENTIAL FILE?\n         BE    LIBDYN              YUP\n*- - - - DIRECTORY MEMBERS SELECTION TO PROCESS\n         L     R2,ALIBDCB          PICK UP LIBRARY ADDRESS\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R2) DD-NAME\n         MVC   0(DIRDCBL,R2),DIRDCB MOVE DCB SKELETON\n         MVC   DCBDDNAM-IHADCB(L'DCBDDNAM,R2),DDNAME SET BACK DD-NAME\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    OKALLD              OK\n         CLC   DYNRCODE(2),=XL2'0210'\n         BE    ERRINUSE\n        XMESS  1301\n         LA    R1,*+L'*+4\n         B     EDIRSMS             YUP - ALL DONE\n         MSG   'ALLOC \"L\" FAILED',H=Y\nOKALLD   MVI   DIRNOTE,0           INITIALIZE\n         MVI   DRFUSW,0\n         XC    DIRADDR,DIRADDR\n         MVI   SELFUNC,C' '\n         MVI   NWNMFLD,C' '\n         L     R0,SCROWS1          LINES PER PAGE SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+4             NO\n         L     R0,SCROWS2          LINES PER PAGE SCREEN 2\n         SH    R0,=Y(CRDLST)\n         STH   R0,DRSCROLL\nAPDSDCB  TM    DCBOFLGS-IHADCB(R2),DCBOFOPN IS IT OPEN ALREADY?\n         BO    APDSOPND            YUP\n         LA    R1,DRREOF\n         STCM  R1,B'0111',DCBEODA-IHADCB(R2)\n         LA    R1,DIRSYNAD\n         STCM  R1,B'0111',DCBSYNA-IHADCB(R2)\n         NI    DRFLSW,255-SYNADFLG\n         MVI   OPCLPL,VLB          SET \"VL\" BIT\n        OPEN   ((R2),(UPDAT)),MF=(E,OPCLPL) OPEN FILE\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN TEST FOR GOOD OPEN?\n         BO    OKLBOP              OK\n        XMESS  1302\n         LA    R1,*+L'*+4\n         B     EDIRSMS             YUP - ALL DONE\n         MSG   'OPEN \"L\" FAILED',H=Y\nOKLBOP   MVC   DIRDECBW(DIRDECBL),DIRDECB\nAPDSOPND NI    DRFLSW,255-DIREOFLG INDICATE NOT AT EOF\n         XC    DIRTOP,DIRTOP\n         LA    R4,TERMOUT+4        POINT TO START\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+12            NOPE, JUST GO DO IT\n         L     R1,SCROWS1          PICK UP NUMBER OF ROWS ON SCREEN 1\n         SLL   R1,2                MULTIPLY BY 4\n         LA    R4,TERMOUT+4(R1)    POINT TO START\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R14,0(,R4)          PICK UP ADDRESS OF FIRST OUTPUT LINE\n         LA    R15,DIRROW1         PICK UP FIRST LINE OF INPUT\n         XR    R1,R1\n         IC    R1,0(,R15)          PICK UP LENGTH\n         EX    R1,MVEDR            MOVE INPUT INTO OUTADDR WORK AREA\n         LA    R15,DIRDSNAM(R14)\n         MVC   0(L'DIRDSNM,R15),DIRDSNM\n         LA    R1,L'DIRDSNM\n         CLI   0(R15),C' '\n         BNE   *+L'*+4\n         MVI   0(R15),C'-'\n         LA    R15,1(R15)\n         BCT   R1,*-16\n         CLI   LIBFUNC,C'E'        EDIT FUNCTION REQUESTED?\n         BE    *+L'*+20\n         MVC   DIRTITLE(7,R14),=CL7' BROWSE'\n         CLI   LIBFUNC,C'B'        BROWSE FUNCTION REQUESTED?\n         BE    *+L'*+6\n         MVC   DIRTITLE(7,R14),=CL7'UTILITY'\n         L     R14,4(,R4)          BUMP\n         NI    4(R4),255-EOS       CLEAR END-OF-SCREEN\n         LA    R15,DIRROW2         PICK UP NEXT LINE OF INPUT\n         IC    R1,0(,R15)          PICK UP LENGTH\n         EX    R1,MVEDR            MOVE INPUT INTO OUTADDR WORK AREA\n         TM    DRFUSW,DRCRSW\n         BZ    *+L'*+10\n         MVC   DRSCF2(L'DRSCF2,R14),=CL4'CSR'\n         B     *+L'*+24\n         TM    DRFUSW,DRHLSW\n         BZ    *+L'*+10\n         MVC   DRSCF2(L'DRSCF2,R14),=CL4'HALF'\n         B     *+L'*+6\n         MVC   DRSCF2(L'DRSCF2,R14),=CL4'PAGE'\n         L     R14,8(,R4)          BUMP\n         NI    8(R4),255-EOS       CLEAR END-OF-SCREEN\n         LA    R15,DIRROW3         PICK UP NEXT LINE OF INPUT\n         IC    R1,0(,R15)          PICK UP LENGTH\n         EX    R1,MVEDR            MOVE INPUT INTO OUTADDR WORK AREA\n         L     R14,12(,R4)         BUMP\n         NI    12(R4),255-EOS      CLEAR END-OF-SCREEN\n         LA    R15,DIRROW4         PICK UP NEXT LINE OF INPUT\n         IC    R1,0(,R15)          PICK UP LENGTH\n         EX    R1,MVEDR            MOVE INPUT INTO OUTADDR WORK AREA\n         LA    R4,16(,R4)          SET R4 TO START OF BUILD AREA\n         MVC   FIRSTMEM,=CL8' '    RESET FIRST NAME (TOP)\n         LH    R8,DRSCROLL         MAX DIRECTORY MEMBERS ON SCREEN\n         TM    DRFUSW,DRRCSW       DIR. RECORD STILL IN?\n         BZ    DRREAD              NO\n         NI    DRFUSW,255-DRRCSW   YES\n         MVC   DIRBOT,DIRPOINT     COPY CURRENT TTR (BOTTOM)\n         LA    R9,PDSKEY+L'PDSKEY+2 SET FIRST MEMBER ADDRESS\n         B     DRNEXT\nDRREAD   BAL   R14,DRRTN\n         ST    R1,DIRBOT           KEEP CURRENT TTR (BOTTOM)\n         USING PDS2,R9\nDRNEXT   CLI   PDS2NAME,X'FF'      END OF DIRECTORY?\n         BE    DIRENDOF            YES, LAST USED BLOCK\n         TM    DRFLSW,DIREOFLG     HAVE I HIT EOF?\n         BO    DIRENDOF            YUP\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R1,0(,R4)\n         USING DIRMASK,R1\n         MVC   DIRLGTH(DIRELEN),DIRLIST MOVE DIR-ENTRY IN\n*- - - - AM I DOING LOCATE FUNCTION?\n         CLI   LOCNAME,C' '        LOCATE?\n         BE    GOTDLOCF            NOPE\n         CLC   LOCNAME(1),PDS2NAME MATCH?\n         BL    GOTDLOCF            GONE PAST IT\n         BH    DIRBUMP             IF HIGH, KEEP READING DIRECTORY\n         CLI   LOCNAME+1,C' '      END OF STRING?\n         BE    GOTDLOCF            YES, MATCHED UP TO HERE, SO OK\n         CLC   LOCNAME+1(1),PDS2NAME+1 MATCH?\n         BL    GOTDLOCF            GONE PAST IT\n         BH    DIRBUMP             IF HIGH, KEEP READING DIRECTORY\n         CLI   LOCNAME+2,C' '      END OF STRING?\n         BE    GOTDLOCF            YES, MATCHED UP TO HERE, SO OK\n         CLC   LOCNAME+2(1),PDS2NAME+2 MATCH?\n         BL    GOTDLOCF            GONE PAST IT\n         BH    DIRBUMP             IF HIGH, KEEP READING DIRECTORY\n         CLI   LOCNAME+3,C' '      END OF STRING?\n         BE    GOTDLOCF            YES, MATCHED UP TO HERE, SO OK\n         CLC   LOCNAME+3(1),PDS2NAME+3 MATCH?\n         BL    GOTDLOCF            GONE PAST IT\n         BH    DIRBUMP             IF HIGH, KEEP READING DIRECTORY\n         CLI   LOCNAME+4,C' '      END OF STRING?\n         BE    GOTDLOCF            YES, MATCHED UP TO HERE, SO OK\n         CLC   LOCNAME+4(1),PDS2NAME+4 MATCH?\n         BL    GOTDLOCF            GONE PAST IT\n         BH    DIRBUMP             IF HIGH, KEEP READING DIRECTORY\n         CLI   LOCNAME+5,C' '      END OF STRING?\n         BE    GOTDLOCF            YES, MATCHED UP TO HERE, SO OK\n         CLC   LOCNAME+5(1),PDS2NAME+5 MATCH?\n         BL    GOTDLOCF            GONE PAST IT\n         BH    DIRBUMP             IF HIGH, KEEP READING DIRECTORY\n         CLI   LOCNAME+6,C' '      END OF STRING?\n         BE    GOTDLOCF            YES, MATCHED UP TO HERE, SO OK\n         CLC   LOCNAME+6(1),PDS2NAME+6 MATCH?\n         BL    GOTDLOCF            GONE PAST IT\n         BH    DIRBUMP             IF HIGH, KEEP READING DIRECTORY\n         CLI   LOCNAME+7,C' '      END OF STRING?\n         BE    GOTDLOCF            YES, MATCHED UP TO HERE, SO OK\n         CLC   LOCNAME+7(1),PDS2NAME+7 MATCH?\n         BL    GOTDLOCF            GONE PAST IT\n         BH    DIRBUMP             NOPE\nGOTDLOCF OC    DIRTOP,DIRTOP       TOP OF SCREEN DISPLAY UNKNOWN?\n         BNZ   *+L'*+6             NO, SKIP\n         MVC   DIRTOP(L'DIRTOP),DIRBOT YES, RETAIN TTR (TOP)\n*- - - - FORMAT THE PDS MEMBER\n         MVC   DIRNAME(L'PDS2NAME),PDS2NAME MOVE MEMBER NAME TO PRINT\n         CLI   SELFUNC,C' '        SELECT CODE?\n         BE    NOSLCD              BRANCH IF NONE\n         MVC   DIRCODE,SELFUNC     ELSE COPY SELECT CODE\n         CLI   DIRADDR+1,CCDLF1    IS THIS FIELD IN ERROR?\n         BNE   *+L'*+4             NO, SKIP\n         MVI   DIRSUN1,X'02'       YES, SET IT AS INTENS\n         OI    DIRSUN1,INFMOD      AND THEN SET IT AS MDT ON\nNOSLCD   CLI   LIBFUNC,C'U'        LIBRARY UTILITY FUNCTION REQUESTED?\n         BE    *+L'*+8             YES, SKIP\n         MVI   DIRSUN3,X'04'       ELSE INHIBIT USER INPUT\n         B     NONWNM\n         CLI   SELFUNC,C' '        WAS THERE A SELECT CODE?\n         BE    NONWNM              BRANCH IF NONE\n         CLI   NWNMFLD,C' '        NEW MEMBER NAME?\n         BE    NONWNM              BRANCH IF NONE\n         MVC   DIRNWNM,NWNMFLD     ELSE COPY NEW MEMBER NAME\n         CLI   DIRADDR+1,CCDLF2    IS THIS IN ERROR?\n         BNE   *+L'*+4             NO, SKIP\n         MVI   DIRSUN3,X'02'       YES, SET IT AS INTENS\n         OI    DIRSUN3,INFMOD      AND THEN SET IT AS MDT ON\nNONWNM   MVI   SELFUNC,C' '        NOW RESET\n         MVI   NWNMFLD,C' '\n         NI    PDS2INDC,PDS2LUSR\n         CLI   PDS2INDC,X'0F'\n         BNE   NOTSPF\n         LA    R14,PDS2USRD        START  OF USER AREA\n         USING SPFMT,R14\n         XR    R15,R15\n         IC    R15,SPFVER\n         CVD   R15,DBLWRD\n         OI    DBLWRD+7,X'0F'\n         UNPK  DIRLEVEL(3),DBLWRD+6(2)\n         MVI   DIRLEVEL,C' '\n         IC    R15,SPFMOD\n         CVD   R15,DBLWRD\n         OI    DBLWRD+7,X'0F'\n         UNPK  DIRLEVEL+3(3),DBLWRD+6(2)\n         MVI   DIRLEVEL+3,C'.'\n         MVC   DIRLEVEL(5),DIRLEVEL+1\n         MVI   DIRLEVEL+5,C' '\n         UNPK  DIRCREAT(5),SPFCRDT(3) CREATION DATE\n         UNPK  DIRMOD(5),SPFMODT(3) MODIFIED DATE\n         XR    R15,R15\n         ICM   R15,B'0011',SPFSIZE\n         CVD   R15,DBLWRD\n         OI    DBLWRD+7,X'0F'\n         UNPK  DIRLINES(5),DBLWRD+5(3)\n         MVC   DIRUSER(L'SPFUID),SPFUID\n         DROP  R1,R14\nNOTSPF   CLI   FIRSTMEM,C' '\n         BNE   *+L'*+6\n         MVC   FIRSTMEM,PDS2NAME   SET TOP OF LIST\n         BCT   R8,*+L'*+10         KEEP GOING\n         MVC   LASTMEM,PDS2NAME    SET IT\n         B     DIRFMT\n         LA    R4,4(R4)            LOAD ADDRESS OF NEXT MEMBER\nDIRBUMP  MVC   LASTMEM,PDS2NAME    SET IT\n         CLC   PDSKEY,PDS2NAME     TEST FOR LAST MEMBER IN BLOCK\n         BNH   DRREAD\n         XR    R14,R14\n         NI    PDS2INDC,PDS2LUSR   CLEAR ALIAS AND TTR FLAGS\n         IC    R14,PDS2INDC        PICK UP USER DATA LENGTH IN H-WORDS\n         SLL   R14,1               MULTIPLY BY 2\n         LA    R9,PDS2USRD(R14)    POINT TO NEXT MEMBER\n         B     DRNEXT\n         DROP  R9\nMVEDR    MVC   0(*-*,R14),0(R15)   <<EXECUTED>>\n         SPACE 1\n*- - - - READ A DIRECTORY RECORD ROUTINE\n*              R9 = AT EXIT, POINTER TO FIRST MEMBER NAME IN BLOCK\n*              R14 = LINK REGISTER\nDRRTN    ST    R14,DIRSR14\n         L     R2,ALIBDCB\n         LA    R3,PDSKEY\n        READ   DIRDECBW,SF,(R2),(R3),'S',MF=E\n        CHECK  DIRDECBW\n         TM    DRFLSW,SYNADFLG     WAS SYNAD EXIT TAKEN?\n         BZ    *+L'*+8             NO, BRANCH\n         LA    R1,DRLBMSG          YES, ERROR\n         B     EDIRSMS\n        NOTE   (R2)\n         CLM   R1,B'0010',DIRNOTE  KEEP HIGHEST R OF TTR\n         BNH   *+L'*+4\n         STCM  R1,B'0010',DIRNOTE\n         LA    R9,L'PDSKEY+2(R3)   FIRST MEMBER ADDRESS (+KEY+LENGTH)\n         L     R14,DIRSR14\n         BR    R14                 BACK TO CALLER\n         CNOP  0,4\nDRREOF  XMESS  1309\n         LA    R1,*+L'*+4\n         B     EDIRSMS\n         MSG   'DIR.EOF READ',H=Y\n*- - - - FILL REST OF SCREEN (END OF DIRECTORY)\nDIRENDOF NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R1,0(,R4)\n         USING DIRMASK,R1\n         MVC   DIRLGTH(DIRELEN),DIRLIST MOVE DIR-ENTRY IN\n         MVI   DIRSUN1,X'04'       INHIBIT USER TO DO ANY\n         MVI   DIRSUN3,X'04'         SELECTION ON THESE LINES\n         TM    DRFLSW,DIREOFLG     FIRST TIME?\n         BO    *+L'*+14            NO\n         MVI   DIRSUN2,X'05'\n         MVC   DIRNAME,=CL9'** END **'\n         OI    DRFLSW,DIREOFLG     INDICATE I HAVE HIT EOF\n         BCT   R8,*+L'*+4          KEEP GOING\n         B     *+L'*+8\n         LA    R4,4(,4)            LOAD ADDRESS OF NEXT MEMBER\n         B     DIRENDOF\n         DROP  R1\n         OC    DIRTOP,DIRTOP       TOP OF SCREEN DISPLAY UNKNOWN?\n         BNZ   DIRFMT              NO, SKIP\n         MVC   DIRTOP(L'DIRTOP),DIRBOT YES, RETAIN TTR (TOP)\nDIRFMT   CLI   SPLIT,1             AM I ON TOP SCREEN?\n         BE    *+L'*+4             YUP\n         OI    0(R4),EOS           SET END-OF-SCREEN\n         L     R15,=A(LIBHELP)     HELP SCREEN\n         ST    R15,HELPADD\n         XC    CURADDR,CURADDR\n         OC    CURADDR,DIRADDR     ANY CURSOR POSITION REQUESTED?\n         BNZ   *+L'*+8             YES\n         MVI   CURROW,CRDRSC       NO, SET DEFAULT CURSOR ROW\n         MVI   CURCOL,CCDRSC       AND CURSOR COLUMN\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         LTR   R15,R15             BAD RC?\n         BNZ   FREELIB             OUT\n         XC    DIRADDR,DIRADDR\n*- - - - SCREEN MAY HAVE CHANGED\n         L     R0,SCROWS1          LINES PER PAGE SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+4             NO\n         L     R0,SCROWS2          LINES PER PAGE SCREEN 2\n         SH    R0,=Y(CRDLST)\n         STH   R0,DRSCROLL\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         L     R4,TERMINPT+ZIME    PICK UP COMMAND INPUT LINE\n         CLI   SPLIT,2             AM I ON SECOND SCREEN?\n         BNE   DIRSCRL             NO, GO TEST PFKEY\n         L     R3,SCROWS1          PICK UP NUMBER OF ROWS ON SCREEN 1\n         SLL   R3,2                MULTIPLY BY 4\n         L     R4,TERMINPT+ZIME(R3) PICK UP COMMAND INPUT LINE\n*- - - - CHECK IF SCROLL ENTERED\nDIRSCRL  CLI   0(R4),0             COMMAND OR SCROLL ENTERED?\n         BE    DIRCKPF             NOPE\n         TM    DRSCF2-1(R4),INFMOD YES, SCROLL ENRERED?\n         BZ    DIRCKPF             NO\n         LA    R14,DRSCF2(,R4)\n         LA    R0,L'DRSCF2\n         CLI   0(R14),C' '\n         BNE   *+L'*+12\n         LA    R14,1(,R14)\n         BCT   R0,*-12\n         B     *+L'*+18            NONE, CLEARED\n         MVI   DRDBLW,C' '\n         OC    DRDBLW(1),0(R14)\n         NI    DRFUSW,255-DRHLSW-DRCRSW RESET TO PAGE\n         CLI   DRDBLW,C'H'\n         BNE   *+L'*+8\n         OI    DRFUSW,DRHLSW       SET HALF\n         B     DIRCKPF\n         CLI   DRDBLW,C'C'\n         BNE   DIRCKPF\n         OI    DRFUSW,DRCRSW       SET CURSOR\nDIRCKPF  TM    COMMSW,PFKFLAG      IS IT A PF KEY/ATTN?\n         BZ    DIRTCMD             NONE\n*- - - - TEST PF KEYS (PF KEY WAS ENTERED, SEE WHAT IT WAS)\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    FREELIB             YUP - ALL DONE\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BE    FREELIB             YUP - ALL DONE\n         CLI   0(R2),X'F8'         IS IT PF8?\n         BE    DRMORDIR            YUP - SHOW NEXT SCREEN OF DIR\n         CLI   0(R2),X'C8'         IS IT PF20?\n         BE    DRMORDIR            YUP - SHOW NEXT SCREEN OF DIR\n         CLI   0(R2),X'F7'         IS IT PF7?\n         BE    DRPREDIR            YUP - SHOW PREV SCREEN OF DIR\n         CLI   0(R2),X'C7'         IS IT PF19?\n         BE    DRPREDIR            YUP - SHOW PREV SCREEN OF DIR\n         CLI   0(R2),X'6C'         IS IT PA1?\n         BE    FREELIB             YUP - ALL DONE\n         CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    DIRRSHW             YUP - GO RESHOW THE SCREEN\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    DIRRSHW             YUP - GO RESHOW THE SCREEN\n         LA    R1,*+L'*+14\n         ST    R1,MSGADD\nDIRRSHW  MVC   LOCNAME,FIRSTMEM    RE-LOCATE THE TOP OF DISPLAY\n         B     DIRLC2\n         MSG   'INVALID PF-KEY',H=Y\n*- - - - CHECK IF A COMMAND ENTERED\nDIRTCMD  CLI   0(R4),0             COMMAND OR SCROLL ENTERED?\n         BE    DIRSEL              NOPE\n         TM    DRSCF1-1(R4),INFMOD YES, COMMAND ENRERED?\n         BZ    DIRSEL              NO\n         LA    R0,L'DRSCF1-1       YES, LEFT JUSTIFY FIELD IF NEEDED\n         CLI   DRSCF1(R4),C' '\n         BNE   *+L'*+18\n         MVC   DRSCF1(L'DRSCF1-1,R4),DRSCF1+1(R4)\n         MVI   DRSCF1+L'DRSCF1-1(R4),C' '\n         BCT   R0,*-18\n         B     DIRSEL              NONE\n         CLC   DRSCF1(4,R4),=CL4'END ' END OF WORK?\n         BE    FREELIB             YES\n         CLC   DRSCF1(4,R4),=CL4'DUMP' TAKE A DUMP?\n         BNE   *+L'*+2             NOPE\n         DC    H'0'                YUP, TAKE AN S0C1 <------------ DUMP\n         CLI   DRSCF1(R4),C'L'     LOCATE?\n         BE    DIRLOC              YUP, GO LOCATE\n         CLI   DRSCF1(R4),C'F'     ALLOW \"F\" FOR FIND AS WELL\n         BE    DIRLOC              GO LOCATE\n         CLC   DRSCF1(5,R4),=CL5'DOWN' DOWN?\n         BE    DRMORDIR            GO DO IT\n         CLC   DRSCF1(2,R4),=CL2'D' DOWN?\n         BE    DRMORDIR            GO DO IT\n         CLC   DRSCF1(2,R4),=CL2'+' DOWN?\n         BE    DRMORDIR            GO DO IT\n         CLC   DRSCF1(3,R4),=CL3'UP' UP?\n         BE    DRPREDIR            GO DO IT\n         CLC   DRSCF1(2,R4),=CL2'U' UP?\n         BE    DRPREDIR            GO DO IT\n         CLC   DRSCF1(2,R4),=CL2'-' UP?\n         BE    DRPREDIR            GO DO IT\n*- - - - PUT OTHER TESTS FOR COMMAND LINE INPUT HERE\nDIRINVC  LA    R1,*+L'*+4\n         B     EDIRSTM\n         MSG   'INVALID COMMAND',H=Y\nDIRSEL   LA    R3,TERMINPT+ZIMN    POINT TO LINE 5 (1ST SELECT LINE)\n         L     R4,SCROWS1          PICK UP NUMBER OF ROWS ON SCREEN 1\n         CLI   SPLIT,2             AM I ON SECOND SCREEN?\n         BNE   DIRSEL1             NO, GO ROLL\n         LR    R3,R4               NUMBER OF ROWS ON SCREEN 1\n         SLL   R3,2                MULTIPLY BY 4\n         LA    R3,TERMINPT+ZIMN(R3) SET ADDRESS OF 1ST SELECT LINE\n         L     R4,SCROWS2          PICK UP NUMBER OF ROWS ON SCREEN 2\nDIRSEL1  SH    R4,=Y(CRDLST)       MAX DIRECTORY MEMBERS FOR ONE SCREEN\nDIRSEL2  L     R5,0(,R3)           POINT TO EACH LINE IN TURN\n         CLI   0(R5),0             ANY INPUT?\n         BE    *+L'*+8             NO, SKIP\n         CLI   DRSLF1(R5),C' '     YES, BUT IS IT JUST CLEAR FIELD?\n         BNE   DIRSEL4             NO, GO PROCESS IT\nDIRSEL3  LA    R3,4(,R3)           POINT TO NEXT LINE\n         BCT   R4,DIRSEL2\n         B     AMEMEOFG            GO SHOW MORE\nDIRSEL4  CLC   DRSLF2(8,R5),=CL8' '\n         BE    *+L'*+10\n         CLC   DRSLF2(9,R5),=CL9'** END **'\n         BNE   DIRSEL5\n         MVI   DRSLF1(R5),C' '     ERROR, CLEAR IT\n         B     DIRINVS+L'DIRINVS   INVALID SELECTION\nDIRSEL5  MVC   LOCNAME(L'LOCNAME),DRSLF2(R5) SET IT\n         MVC   SELFUNC(L'SELFUNC),DRSLF1(R5) SET SELECT CODE\n         MVI   DRSLF1(R5),C' '     CLEAR IT\n         CLI   SELFUNC,C'S'        SELECT?\n         BE    DIRMEMB             YES\n         CLI   SELFUNC,C'B'        BROWSE?\n         BE    DIRMEMB             YES\n         CLI   LIBFUNC,C'E'        EDIT FUNCTION REQUESTED?\n         BNE   *+L'*+8             NO, SKIP\n         CLI   SELFUNC,C'E'        EDIT?\n         BE    DIRMEMB             YES\n         CLI   LIBFUNC,C'U'        LIBRARY UTILITY FUNCTION REQUESTED?\n         BNE   DIRINVS             NO, SKIP\n         CLI   SELFUNC,C'D'        DELETE?\n         BE    MEMDEL              YES\n         CLI   SELFUNC,C'R'        RENAME?\n         BE    MEMREN              YES\n         CLI   SELFUNC,C'C'        COPY?\n         BE    MEMCPY              YES\n*- - - - PUT TESTS FOR OTHER SELECTION CODES HERE\nDIRINVS  MVC   DIRADDR,=AL1(CRDLST,CCDLF1) PROCESSING AT THIS POINT\n         LA    R1,INVSEL           SET MESSAGE AND TRUNCATE\n         B     EDIRSTM\nDIRMEMB  LR    R0,R7               INITIALIZE DYNAMIC ALLOCATION WORK\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         MVC   DSMEMBER(L'DSMEMBER),DRSLF2(R5) MEMBER SELECTED\n         L     R4,AMEMDCB\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DD-NAME\n         MVC   0(SEQDCBL,R4),SEQDCB MOVE DCB SKELETON\n         MVC   DCBDDNAM-IHADCB(L'DCBDDNAM,R4),DDNAME SET BACK DD-NAME\n         MVC   DSNAME,DIRDSNM      SET DS-NAME OF LIBRARY\n         MVC   DSSTATUS,=CL8'SHR'  STATUS, DISP=SHR\n         MVC   DSVOLSER,DIRVOL\n         MVC   PASSWORD,DIRPASS\n         MVC   DSUNIT,=CL8'SYSALLDA'\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    OKDYNL              OK\n        XMESS  1303\n         LA    R1,*+L'*+4\n         B     EDIRSTM             SKIP IT\n         MSG   'ALLOC \"L(M)\" FAILED',H=Y\nOKDYNL   CLI   LIBFUNC,C'E'        EDIT FUNCTION REQUESTED?\n         BNE   MEMBRO              NO\n         CLI   SELFUNC,C'E'        EDIT?\n         BE    *+L'*+8             YES\n         CLI   SELFUNC,C'S'        SELECT?\n         BNE   MEMBRO              NO\n         MVI   SELFUNC,C' '        NOW RESET\n         LA    R1,AMEMEOF1\n         STCM  R1,B'0111',DCBEODA-IHADCB(R4)\n         LA    R1,SEQSYNAD\n         STCM  R1,B'0111',DCBSYNA-IHADCB(R4)\n         NI    DRFLSW,255-SYNADFLG\n         XR    R3,R3               CLEAR RECORD COUNTER\n         MVI   OPCLPL,VLB          SET \"VL\" BIT\n        OPEN   ((R4),(INPUT)),MF=(E,OPCLPL)\n         TM    DCBOFLGS-IHADCB(R4),DCBOFOPN GOOD OPEN?\n         BO    AMEMDCNT            YES\n        XMESS  1304\n         LA    R1,*+L'*+8\n         ST    R1,MSGADD\n         B     AMEMEOFR            SKIP IT\n         MSG   'OPEN \"L(M)\" FAILED',H=Y\nAMEMDCNT GET   (R4),CRDWA\n         TM    DRFLSW,SYNADFLG     WAS SYNAD EXIT TAKEN?\n         BO    AMEMERR             YES, BRANCH\n         LA    R3,1(R3)            BUMP COUNTER\n         B     AMEMDCNT\n*- - - - BROWSE MEMBER\nMEMBRO   MVI   SELFUNC,C' '        NOW RESET\n         ICM   R15,B'1111',ARBROWSE\n         BNZ   CALLBR1\n        LOAD   EP=ETPSBROW,ERRET=LDB1ERR\n         ST    R0,ARBROWSE\n         LR    R15,R0\n*- - - - ETPSBROW PARM.LIST : DCB, DS-NAME, MEMBER-NAME\nCALLBR1 CALL   (15),((R4),DSNAME,DSMEMBER),VL,MF=(E,PARMVL)\n         B     AMEMEOFR\nLDB1ERR  LA    R2,BRUMSG           BROWSE IS UNAVAILABLE\n         B     LDE1ERR+L'LDE1ERR\nLDE1ERR  LA    R2,EDUMSG           EDIT IS UNAVAILABLE\n         STM   R0,R1,MESSPL\n        XMESS  99,R15\n         ST    R2,MSGADD\n         B     AMEMEOFR\nAMEMERR  LA    R1,DRLBMSG\n         ST    R1,MSGADD\nAMEMEOF1 MVI   OPCLPL,VLB          SET \"VL\" BIT\n        CLOSE  ((R4)),MF=(E,OPCLPL)\n         TM    DRFLSW,SYNADFLG     WAS SYNAD EXIT TAKEN?\n         BO    AMEMEOFR            YES, BRANCH\n         ST    R3,SEQRNUM\n         ICM   R15,B'1111',AREDIT\n         BNZ   CALLED1\n        LOAD   EP=ETPSEDIT,ERRET=LDE1ERR\n         ST    R0,AREDIT\n         LR    R15,R0\n*- - - ETPSEDIT PARM.LIST : DCB, DS-NAME, MEMBER-NAME, DS-ORG,\n*                           NUM-RECS, VOL-SER, PASSWORD\nCALLED1 CALL   (15),((R4),DSNAME,DSMEMBER,DIRORG,SEQRNUM,              X\n               DIRVOL,DIRPASS),VL,MF=(E,PARMVL)\nAMEMEOFR LR    R0,R7               INITIALIZE DYNAMIC ALLOCATION WORK\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DD-NAME\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    AMEMEOFG            OK\n        XMESS  1305\n         TM    DRFLSW,SYNADFLG     WAS SYNAD EXIT TAKEN?\n         BO    AMEMEOFG            YES, BRANCH\n         LA    R1,FRLBMS\nEDIRSTM  ST    R1,MSGADD\nAMEMEOFG MVC   DSMEMBER,=CL8' '    CLEAR MEMBER NAME FIELD\n         NI    DRFLSW,255-SYNADFLG\n         B     DIRLC2\nFRLBMS   MSG   'FREE \"L(M)\" FAILED',H=Y\n*- - - - LOCATE MEMBER IN LIBRARY\nDIRLOC   CLI   DRSCF1+1(R4),C' '\n         BNE   *+L'*+12\n         LA    R0,L'DRSCF1-2\n         LA    R1,DRSCF1+2(R4)\n         B     DIRLC1\n         CLC   DRSCF1+1(6,R4),=CL6'OCATE '\n         BNE   *+L'*+12\n         LA    R0,L'DRSCF1-7\n         LA    R1,DRSCF1+7(R4)\n         B     DIRLC1\n         CLC   DRSCF1+1(4,R4),=CL4'IND '\n         BNE   DIRINVC\n         LA    R0,L'DRSCF1-5\n         LA    R1,DRSCF1+5(R4)\nDIRLC1   CLI   0(R1),C' '\n         BNE   *+L'*+12\n         LA    R1,1(R1)\n         BCT   R0,DIRLC1\n         B     DIRLC2\n         MVC   LOCNAME(L'LOCNAME),0(R1) MOVE IN \"LOCATE\" NAME\nDIRLC2   XC    DIRPOINT,DIRPOINT   POINT TO START OF DIRECTORY\n         MVI   DIRPOINT+2,1\n         L     R2,ALIBDCB\n        POINT  (R2),DIRPOINT\n         B     APDSDCB\n*- - - - DELETE MEMBER\nMEMDEL   LA    R0,DRSLF2(,R5)      POINT TO MEMBER NAME\n         L     R1,ALIBDCB          POINT TO LIBRARY\n        STOW   (1),(0),D\n         LTR   R15,R15             HOW COMPLETE?\n         BNZ   *+L'*+8             BRANCH IF ERROR\n         MVI   SELFUNC,C' '        NOW RESET\n         B     DIRSEL3             LOOK FOR ANOTHER SELECTION\n         LA    R1,=CL6'DELETE'     ERROR, SET MESSAGE AND TRUNCATE\n         B     DOSTWM                PROCESSING AT THIS POINT\n*- - - - RENAME MEMBER\nMEMREN   BAL   R14,CHKNWNM         DO CHECK\n         MVC   VUSWA(8),DRSLF2(R5) MOVE CURRENT NAME\n         MVC   VUSWA+8(8),DRSLF3(R5) MOVE NEW NAME\n         LA    R0,VUSWA            POINT TO MEMBER NAMES\n         L     R1,ALIBDCB          POINT TO LIBRARY\n        STOW   (1),(0),C\n         LTR   R15,R15             HOW COMPLETE?\n         BNZ   *+L'*+18            BRANCH IF ERROR\n         MVC   LOCNAME(L'LOCNAME),DRSLF3(R5) AFTER POINT TO NEW NAME\n         MVI   SELFUNC,C' '        AND NOW RESET\n         MVI   NWNMFLD,C' '\n         B     DIRSEL3             LOOK FOR ANOTHER SELECTION\n         LA    R1,=CL6'RENAME'     SET MESSAGE AND TRUNCATE\nDOSTWM   XR    R14,R14               PROCESSING AT THIS POINT\n         LA    R2,OPFAIL\n         CH    R15,=H'16'\n         BNL   DOSTWMX               BRANCH IF R15 GREATER THAN 12\n         EX    0,*+L'*(R15)          R15 IS LESS THAN 16 AND NEVER 0\n         B     DOSTWMX\n         LA    R2,OPDUPL             = 4\n         LA    R2,OPNFND             = 8\n         LA    R2,OPFULL             = 12\nDOSTWMX  IC    R14,0(R2)\n         EX    R14,MVSTWM\n         CH    R15,=H'16'\n         BL    DOSTWMZ\n         MVC   DRLBMSG+1(6),0(R1)\n         CVD   R15,DBLWRD\n         MVC   DBLWRD(4),=XL4'40202120'\n         ED    DBLWRD(4),DBLWRD+L'DBLWRD-2\n         MVC   DRLBMSG+18(3),DBLWRD+1\nDOSTWMZ  LA    R1,DRLBMSG\n         MVC   DIRADDR,=AL1(CRDLST,CCDLF1)\n         B     EDIRSTM\nMVSTWM   MVC   DRLBMSG(*-*),0(R2)  <<EXECUTED>>\nOPFAIL   MSG   '...... FAILED RC=...'\nOPDUPL   MSG   'DUPLICATE NEW NAME'\nOPNFND   MSG   'NAME NOT FOUND'\nOPFULL   MSG   'NO SPACE IN DIR.',H=Y\n         SPACE 1\n*- - - - CHECK MEMBER NEW NAME ROUTINE\n*              R14 = LINK REGISTER\nCHKNWNM  LA    R0,L'DRSLF3-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   DRSLF3(R5),C' '\n         BNE   CHKNWNM1\n         MVC   DRSLF3(L'DRSLF3-1,R5),DRSLF3+1(R5)\n         MVI   DRSLF3+L'DRSLF3-1(R5),C' '\n         BCT   R0,*-18\n         LA    R1,=CL8'MISSING'    NONE, ERROR, SET MESSAGE AND\n         LA    R0,1                  TRUNCATE PROCESSING AT THIS POINT\n         B     CHKNWNM3\nCHKNWNM1 MVC   NWNMFLD(L'NWNMFLD),DRSLF3(R5)\n         CLC   DRSLF3+L'DRSLF3-(L'DRSLF3-8)(L'DRSLF3-8,R5),=CL8' '\n         BE    CHKNWNM2            OK\n         LA    R1,=CL8'ERROR'      YES, ERROR, SET MESSAGE AND\n         LA    R0,3                  TRUNCATE PROCESSING AT THIS POINT\n         B     CHKNWNM3\nCHKNWNM2 CLC   DRSLF2(8,R5),DRSLF3(R5) CURRENT MEMBER = NEW MEMBER?\n         BNER  R14                 NO, OK\n         LA    R1,=CL8'CONFLICT'   YES, ERROR, SET MESSAGE AND\n         XR    R0,R0                 TRUNCATE PROCESSING AT THIS POINT\nCHKNWNM3 XR    R14,R14\n         IC    R14,NWMBMS\n         EX    R14,MVNWMM\n         SR    R14,R0\n         STC   R14,DRLBMSG\n         MVC   DRLBMSG+12(8),0(R1)\n         LA    R1,DRLBMSG\n         MVC   DIRADDR,=AL1(CRDLST,CCDLF2)\n         B     EDIRSTM\nMVNWMM   MVC   DRLBMSG(*-*),NWMBMS <<EXECUTED>>\nNWMBMS   MSG   'NEW MEMBER ........',H=Y\n*- - - - COPY MEMBER\nMEMCPY   BAL   R14,CHKNWNM         DO CHECK\n         MVC   VUSWA(8),=AL2(1,58) MOVE BLDL LIST\n         MVC   VUSWA+4(8),DRSLF3(R5) MOVE NEW NAME\n         LA    R0,VUSWA            POINT TO MEMBER NAMES\n         L     R1,ALIBDCB          POINT TO LIBRARY\n        BLDL   (1),(0)\n         CH    R15,=H'4'           HOW COMPLETE?\n         BNE   MEMCPY1             ERROR\n         MVI   SELFUNC,C' '        4 = NOT FOUND, OK, NOW RESET\n         MVI   NWNMFLD,C' '\n         ICM   R15,B'1111',ARMEMC\n         BNZ   CALLMM\n        LOAD   EP=ETPSMEMC,ERRET=LDMCERR\n         ST    R0,ARMEMC\n         LR    R15,R0\n*- - - ETPSMEMC PARM.LIST : FROM = DS-NAME, MEMBER-NAME, VOL-SER,\n*                                  PASSWORD\n*                             TO = DS-NAME, MEMBER-NAME, VOL-SER,\n*                                  PASSWORD\nCALLMM  CALL   (15),(DIRDSNM,DRSLF2(,R5),DIRVOL,DIRPASS,               X\n               DIRDSNM,DRSLF3(,R5),DIRVOL,DIRPASS,                     X\n               DRLBMSG),VL,MF=(E,VUSWA)\n         LTR   R15,R15             HOW COMPLETE?\n         BNZ   *+L'*+10            BRANCH IF ERROR\n         MVC   LOCNAME(L'LOCNAME),DRSLF3(R5) AFTER POINT TO NEW NAME\n         B     DIRSEL3             LOOK FOR ANOTHER SELECTION\n         LA    R1,DRLBMSG\n         STM   R0,R1,MESSPL\n        XMESS  1307,R15\n         B     EDIRSTM             TRUNCATE PROCESSING AT THIS POINT\nLDMCERR  STM   R0,R1,MESSPL        COPY IS UNAVAILABLE\n        XMESS  99,R15\n         LA    R1,CPUMSG\n         B     EDIRSTM\nMEMCPY1  BH    MEMCPY2             GREATER THAN 4 = ERROR\n         LA    R1,OPDUPL           0 = NEW NAME ALREADY EXIST\n         MVC   DIRADDR,=AL1(CRDLST,CCDLF2)\n         B     EDIRSTM\nMEMCPY2  XR    R14,R14\n         IC    R14,CPYFAIL\n         EX    R14,MVCPYM\n         CVD   R15,DBLWRD\n         MVC   DBLWRD(4),=XL4'40202120'\n         ED    DBLWRD(4),DBLWRD+L'DBLWRD-2\n         MVC   DRLBMSG+16(3),DBLWRD+1\n         LA    R1,DRLBMSG\n         MVC   DIRADDR,=AL1(CRDLST,CCDLF1)\n         B     EDIRSTM\nMVCPYM   MVC   DRLBMSG(*-*),CPYFAIL <<EXECUTED>>\nCPYFAIL  MSG   'COPY FAILED RC=...',H=Y\n*- - - - SHOW MORE DIRECTORY INFO\nDRMORDIR NI    DRFUSW,255-DRUPSW   SAY DOWN CONTROL\n         BAL   R14,DRCSAR          GET SCROLL AMOUNT\n         B     DRMORMAX            RETURN +0\n         MVI   DIRPOINT+3,0         \" \"   +4\n         MVC   DIRPOINT(L'DIRTOP),DIRTOP SET FIRST BLOCK READ (TOP)\nDRMRDR1  L     R2,ALIBDCB\n        POINT  (R2),DIRPOINT\n         BAL   R14,DRRTN\n         ST    R1,DIRPOINT         KEEP CURRENT TTR\n         LR    R3,R9               RETAIN START ADDRESS\n         USING PDS2,R9\n         CLC   FIRSTMEM,PDS2NAME   IS THIS MEMBER NAME?\n         BE    DRMRDR6             YES, IT IS JUST THIS ONE\n         BH    DRMRDR2             NO\n         BAL   R14,DRSUBBLK        ELSE GO BACK\n         B     DRPREMAX            RETURN +0\n         B     DRMRDR1              \" \"   +4\nDRMRDR2  CLC   FIRSTMEM,PDSKEY     IS MEMBER IN THIS BLOCK?\n         BNH   DRMRDR3             YES\n         BAL   R14,DRRTN           NO, GO AHEAD\n         ST    R1,DIRPOINT         KEEP CURRENT TTR\n         LR    R3,R9               RETAIN START ADDRESS\n         CLC   FIRSTMEM,PDS2NAME   IS THIS MEMBER NAME?\n         BE    DRMRDR6             YES, IT IS JUST THIS ONE\n         BL    DRMRDR9             IT HAS BEEN DELETED, STOP HERE\n         B     DRMRDR2             ELSE\nDRMRDR3  CLC   PDS2NAME,PDSKEY     LAST MEMBER IN BLOCK?\n         BL    DRMRDR4             NO\n         CLI   PDSKEY,X'FF'        YES, END OF DIRECTORY?\n         BE    DRMORMX1            YES\n         BAL   R14,DRRTN           NO, GO AHEAD\n         ST    R1,DIRPOINT         KEEP CURRENT TTR\n         LR    R3,R9               RETAIN START ADDRESS\n         B     DRMRDR5\nDRMRDR4  XR    R14,R14\n         NI    PDS2INDC,PDS2LUSR   CLEAR ALIAS AND TTR FLAGS\n         IC    R14,PDS2INDC        PICK UP USER DATA LENGTH IN H-WORDS\n         SLL   R14,1               MULTIPLY BY 2\n         LA    R9,PDS2USRD(R14)    POINT TO NEXT MEMBER NAME\nDRMRDR5  CLC   FIRSTMEM,PDS2NAME   IS THIS MEMBER NAME?\n         BL    DRMRDR9             IT HAS BEEN DELETED, STOP HERE\n         BH    DRMRDR3             NO\nDRMRDR6  CLC   PDS2NAME,PDSKEY     YES, LAST MEMBER IN BLOCK?\n         BNL   DRMRDR8             YES\nDRMRDR7  XR    R14,R14             NO\n         NI    PDS2INDC,PDS2LUSR   CLEAR ALIAS AND TTR FLAGS\n         IC    R14,PDS2INDC        PICK UP USER DATA LENGTH IN H-WORDS\n         SLL   R14,1               MULTIPLY BY 2\n         LA    R9,PDS2USRD(R14)    LOAD ADDRESS OF NEXT MEMBER NAME\n         B     DRMRDR9\nDRMRDR8  CLI   PDSKEY,X'FF'        END OF DIRECTORY?\n         BE    DRMORMX1            YES\n         BAL   R14,DRRTN\n         ST    R1,DIRPOINT         KEEP CURRENT TTR\n         CLI   PDS2NAME,X'FF'      END OF DIRECTORY?\n         BE    DRMORMX2            YES\n         LR    R3,R9               RETAIN START ADDRESS\nDRMRDR9  BCT   R8,DRMRDR10\n         CLI   PDS2NAME,X'FF'      END OF DIRECTORY?\n         BE    DRMORMX1            YES\n         MVC   LOCNAME,PDS2NAME    NO, LOOKING FOR PARTICULAR MEMBER\n         OI    DRFUSW,DRRCSW       SET DIR. RECORD STILL IN\n         B     APDSDCB\nDRMRDR10 CLC   PDS2NAME,PDSKEY     LAST MEMBER IN BLOCK?\n         BL    DRMRDR7             NO, CONTINUE\n         B     DRMRDR8             YES\nDRMORMAX MVC   DIRPOINT,DIRBOT     SET LAST BLOCK READ (BOTTOM)\n         L     R2,ALIBDCB\n        POINT  (R2),DIRPOINT\n         BAL   R14,DRRTN\n         ST    R1,DIRPOINT         KEEP CURRENT TTR\n         CLI   PDSKEY,X'FF'        END OF DIRECTORY?\n         BNE   *-12                NO\n         B     DRMORMX2            YES\nDRMORMX1 LR    R9,R3               RESTORE START ADDRESS\nDRMORMX2 LH    R8,DRSCROLL         NOW MOVE DOWN THE SCREEN\n         TM    DRFUSW,DRHLSW       HALF PAGE\n         BZ    *+L'*+4             NO\n         SRL   R8,1                YES\n         LTR   R8,R8\n         BP    DRMRPR\n         LA    R8,1\n         B     DRMRPR\n         DROP  R9\n*- - - - SHOW PREVIOUS DIRECTORY INFO\nDRPREDIR OI    DRFUSW,DRUPSW       SAY UP CONTROL\n         BAL   R14,DRCSAR          GET SCROLL AMOUNT\n         B     DRPREMAX            RETURN +0\n         MVI   DIRPOINT+3,0         \" \"   +4\n         MVC   DIRPOINT(L'DIRTOP),DIRTOP SET FIRST BLOCK READ (TOP)\nDRPRDR1  L     R2,ALIBDCB\n        POINT  (R2),DIRPOINT\nDRPRDR2  BAL   R14,DRRTN\n         ST    R1,DIRPOINT         KEEP CURRENT TTR\n         USING PDS2,R9\n         CLI   PDS2NAME,X'FF'      END OF DIRECTORY?\n         BNE   DRPRDR4             NO\nDRPRDR3  BAL   R14,DRSUBBLK        YES, BACK 1 BLOCK\n         B     DRPREMAX            RETURN +0\n         B     DRPRDR1              \" \"   +4\nDRPRDR4  LR    R3,R9               RETAIN START ADDRESS\n         CLC   FIRSTMEM,PDS2NAME   HOW WITH TOP SCREEN MEMBER NAME?\n         BL    DRPRDR3             MUST GO BACK\n         BE    DRPRDR7             IT IS JUST THIS ONE\nDRPRDR5  CLC   FIRSTMEM,PDSKEY     IS MEMBER IN THIS BLOCK?\n         BNH   DRPRDR6             YES\n         BAL   R14,DRRTN           NO, ELSE GO AHEAD\n         ST    R1,DIRPOINT         KEEP CURRENT TTR\n         LR    R3,R9               RETAIN START ADDRESS\n         B     DRPRDR5\nDRPRDR6  CLC   FIRSTMEM,PDS2NAME   IS THIS MEMBER NAME?\n         BNH   DRPRDR7             YES OR IT HAS BEEN DELETED\n         CLC   PDS2NAME,PDSKEY     NO, LAST MEMBER IN BLOCK?\n         BNL   DRPRDR7             IT HAS BEEN DELETED, STOP HERE\n         XR    R14,R14\n         NI    PDS2INDC,PDS2LUSR   CLEAR ALIAS AND TTR FLAGS\n         IC    R14,PDS2INDC        PICK UP USER DATA LENGTH IN H-WORDS\n         SLL   R14,1               MULTIPLY BY 2\n         LA    R9,PDS2USRD(R14)    LOAD ADDRESS OF NEXT MEMBER NAME\n         B     DRPRDR6\nDRPRDR7  LR    R4,R9               NOW TRY TO BACKWARD THE SCREEN\n         LR    R9,R3               RESTORE START ADDRESS\n         XR    R15,R15             ZERO COUNT\nDRPRDR8  CLR   R9,R4               THIS MEMBER NAME?\n         BE    DRPRDR9             YES\n         CLC   PDS2NAME,PDSKEY     NO, LAST MEMBER IN BLOCK?\n         BNL   DRPRDR9             YES\n         LA    R15,1(R15)          NO, UPDATE COUNT\n         XR    R14,R14\n         NI    PDS2INDC,PDS2LUSR   CLEAR ALIAS AND TTR FLAGS\n         IC    R14,PDS2INDC        PICK UP USER DATA LENGTH IN H-WORDS\n         SLL   R14,1               MULTIPLY BY 2\n         LA    R9,PDS2USRD(R14)    LOAD ADDRESS OF NEXT MEMBER NAME\n         B     DRPRDR8\nDRPRDR9  SR    R8,R15              IS IT ENOUGH?\n         BZ    DRPRDR12            YES, EXACTLY THE AMOUNT\n         BM    DRPRDR10            A FEW TOO MUCH\n         BAL   R14,DRSUBBLK        NO, BACK 1 BLOCK\n         B     DRPREMAX            RETURN +0\n         L     R2,ALIBDCB           \" \"   +4\n        POINT  (R2),DIRPOINT\n         BAL   R14,DRRTN\n         ST    R1,DIRPOINT         KEEP CURRENT TTR\nDRMRPR   LR    R3,R9               RETAIN START ADDRESS\n         XR    R4,R4\n         LA    R15,1               COUNT START AT 1\n         B     DRPRDR8\n         DROP  R9\nDRPRDR10 LPR   R8,R8               NUMBER OF NAMES FORWARD IN BLOCK\n         USING PDS2,R3\n         XR    R14,R14\nDRPRDR11 NI    PDS2INDC,PDS2LUSR   CLEAR ALIAS AND TTR FLAGS\n         IC    R14,PDS2INDC        PICK UP USER DATA LENGTH IN H-WORDS\n         SLL   R14,1               MULTIPLY BY 2\n         LA    R3,PDS2USRD(R14)    LOAD ADDRESS OF NEXT MEMBER NAME\n         BCT   R8,DRPRDR11\nDRPRDR12 MVC   LOCNAME,PDS2NAME    LOOKING FOR PARTICULAR MEMBER\n         OI    DRFUSW,DRRCSW       SET DIR. RECORD STILL IN\n         B     APDSDCB\n         DROP  R3\nDRPREMAX MVC   LOCNAME,=CL8' '     BACK TO TOP OF DIRECTORY\n         B     DIRLC2\n         SPACE 1\n*- - - - COMPUTE SCROLL AMOUNT ROUTINE\n*              R14 = LINK REGSITER / RETURN +0 = MAX.\n*                                           +4 = OK (R8 = AMOUNT)\nDRCSAR   ST    R14,DIRSR14\n         CLI   0(R4),0             COMMAND LINE ENTERED?\n         BE    DRCSARDF            NOPE\n         TM    DRSCF1-1(R4),INFMOD YES, COMMAND ENRERED?\n         BZ    DRCSARDF            NO, JUST BUMP DEFAULT\n         LA    R0,L'DRSCF1-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   DRSCF1(R4),C' '\n         BNE   *+L'*+14\n         MVC   DRSCF1(L'DRSCF1-1,R4),DRSCF1+1(R4)\n         MVI   DRSCF1+L'DRSCF1-1(R4),C' '\n         BCT   R0,*-18\n         CLI   DRSCF1(R4),C' '     COMMAND ENTERED?\n         BE    DRCSARDF            NO, JUST BUMP DEFAULT\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         TM    DRFUSW,DRUPSW       UP REQUESTED?\n         BO    DRCSARUP            YES\n         CLI   0(R2),X'F8'         IS IT PF8?\n         BE    DRCSARSC            YES\n         CLI   0(R2),X'C8'         IS IT PF20?\n         BE    DRCSARSC            YES\n         MVC   DRDBLW(7),=CL8' '\n         OC    DRDBLW(7),DRSCF1(R4)\n         CLC   DRDBLW(5),=CL5'DOWN' IS IT \"DOWN\"?\n         BNE   *+L'*+12            NO\n         LA    R4,5(R4)            YES, SEE FORWARD\n         SH    R0,=H'5'\n         B     DRCSARTV\n         CLC   DRDBLW(2),=CL2'D'   IS IT \"DOWN\"?\n         BE    *+L'*+10            YES\n         CLC   DRDBLW(2),=CL2'+'   IS IT \"DOWN\"?\n         BNE   DIRINVC             NO, INVALID COMMAND\n         LA    R4,2(R4)            YES, SEE FORWARD\n         SH    R0,=H'2'\n         B     DRCSARTV\nDRCSARUP CLI   0(R2),X'F7'         IS IT PF7?\n         BE    DRCSARSC            YES\n         CLI   0(R2),X'C7'         IS IT PF19?\n         BE    DRCSARSC            YES\n         MVC   DRDBLW(7),=CL8' '\n         OC    DRDBLW(7),DRSCF1(R4)\n         CLC   DRDBLW(3),=CL3'UP'  IS IT \"UP\"?\n         BNE   *+L'*+12            NO\n         LA    R4,3(R4)            YES, SEE FORWARD\n         SH    R0,=H'3'\n         B     DRCSARTV\n         CLC   DRDBLW(2),=CL2'U'   IS IT \"UP\"?\n         BE    *+L'*+10            YES\n         CLC   DRDBLW(2),=CL2'-'   IS IT \"UP\"?\n         BNE   DIRINVC             NO, INVALID COMMAND\n         LA    R4,2(R4)            YES, SEE FORWARD\n         SH    R0,=H'2'\nDRCSARTV BNP   DRCSARDF            NO MORE, JUST BUMP DEFAULT\n         CLI   DRSCF1(R4),C' '\n         BNE   DRCSARSC\n         LA    R4,1(R4)\n         BCT   R0,*-12\n         B     DRCSARDF            NONE, JUST BUMP DEFAULT\nDRCSARSC MVI   DRDBLW,C' '\n         OC    DRDBLW(1),DRSCF1(R4)\n         CLI   DRDBLW,C'M'         SCROLL \"MAX\"?\n         BNE   *+L'*+6             NO\n         L     R14,DIRSR14         YES\n         BR    R14\n         CLI   DRSCF1(R4),C'0'     IF NOT NUMERIC?\n         BL    DRCSARDF            JUST BUMP DEFAULT\n         LA    R14,DRSCF1(,R4)     SET START OF FIELD\n         LA    R15,6               MAXIMUM LENGTH\n         CLR   R15,R0\n         BNL   *+L'*+2\n         LR    R15,R0\n         XR    R1,R1               COUNTER\n         CLI   0(R14),C'0'         IF NOT NUMERIC\n         BL    *+L'*+12\n         LA    R1,1(,R1)           BUMP COUNTER\n         LA    R14,1(,R14)         BUMP POINTER\n         BCT   R15,*-16\n         LTR   R1,R1               IF LENGTH IS ZERO?\n         BZ    DRCSARDF            JUST BUMP DEFAULT\n         BCT   R1,*+L'*+6          SUBTRACT 1 FOR EXECUTED PACK\n         PACK  DRDBLW,DRSCF1(*-*,R4) <<EXECUTED>>\n         EX    R1,*-6              PACK IT IN DRDBLW\n         CVB   R0,DRDBLW           PUT VALUE IN R0\n         B     DRCSARXQ\nDRCSARDF LH    R0,DRSCROLL         MOVE DOWN THE SCREEN\n         TM    DRFUSW,DRCRSW       CURSOR?\n         BZ    DRCSARHF            NO\n         L     R14,TERMINPT        PICK UP AID/ROW/COL ADDRESS\n         XR    R15,R15\n         IC    R15,1(R14)          GET ROW NUMBER\n         SH    R15,=Y(CRDLST)\n         BNP   DRCSARXQ\n         TM    DRFUSW,DRUPSW       UP REQUESTED?\n         BO    *+L'*+6             YES\n         LR    R0,R15              NO, DOWN\n         B     DRCSARXQ\n         BCTR  R0,0\n         SR    R0,R15\n         B     DRCSARXQ\nDRCSARHF TM    DRFUSW,DRHLSW       HALF PAGE\n         BZ    DRCSARXQ            NO\n         SRL   R0,1                YES\nDRCSARXQ LTR   R8,R0\n         BNP   AMEMEOFG            NONE, RE-DISPLAY\n         L     R14,DIRSR14\n         B     4(R14)\n         SPACE 1\n*- - - - BACK 1 BLOCK TTR OF DIRECTORY ADDRESS COMPUTATION ROUTINE\n*              R14 = LINK REGISTER / RETURN +0 = TOP OF DIRECTORY\n*                                           +4 = OK, DONE\nDRSUBBLK XR    R1,R1\n         CLI   DIRPOINT+2,1        AM I ON BLOCK 1?\n         BE    DRSUBTRK            YES, JUST SUBTRACT FROM TRACK\n         IC    R1,DIRPOINT+2       NO, PICK UP TRACK NUMBER\n         BCTR  R1,0                SUBTRACT 1\n         STC   R1,DIRPOINT+2\n         B     4(R14)\nDRSUBTRK ICM   R1,B'0011',DIRPOINT AM I ON TRACK 0?\n         BZR   R14                 GO POINT TO TOP OF DIRECTORY\n         BCTR  R1,0                SUBTRACT 1\n         STCM  R1,B'0011',DIRPOINT PREVIOUS TRACK\n         MVC   DIRPOINT+2(1),DIRNOTE POINT TO LAST BLOCK OF TRACK\n         B     4(R14)\n*- - - - SEQUENTIAL PROCESS\nLIBDYN   L     R4,ACOPDCB          PICK UP LIBRARY ADDRESS\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DD-NAME\n         MVC   0(SEQDCBL,R4),SEQDCB MOVE DCB SKELETON\n         MVC   DCBDDNAM-IHADCB(L'DCBDDNAM,R4),DDNAME SET BACK DD-NAME\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    OKALLS              OK\n         CLC   DYNRCODE(2),=XL2'0210'\n         BE    ERRINUSE\n        XMESS  1301\n         LA    R1,*+L'*+4\n         B     EDIRSMS             YUP - ALL DONE\n         MSG   'ALLOC \"LIB\" FAILED',H=Y\nOKALLS   CLI   LIBFUNC,C'E'        EDIT FUNCTION REQUESTED?\n         BE    SEQEDIT             YES\n         CLI   LIBFUNC,C'B'        BROWSE FUNCTION REQUESTED?\n         BE    SEQBROWS            YES\n         B     SEQFREE\nSEQEDIT  LA    R1,AMEMEOF2\n         STCM  R1,B'0111',DCBEODA-IHADCB(R4)\n         LA    R1,SEQSYNAD\n         STCM  R1,B'0111',DCBSYNA-IHADCB(R4)\n         NI    DRFLSW,255-SYNADFLG\n         XR    R3,R3               CLEAR RECORD COUNTER\n         MVI   OPCLPL,VLB          SET \"VL\" BIT\n        OPEN   ((R4),(INPUT)),MF=(E,OPCLPL)\n         TM    DCBOFLGS-IHADCB(R4),DCBOFOPN GOOD OPEN?\n         BO    BMEMCOUN            YES\n        XMESS  1302\n         LA    R1,*+L'*+8\n         ST    R1,MSGADD\n         B     SEQFREE             SKIP IT\n         MSG   'OPEN \"LIB\" FAILED',H=Y\nBMEMCOUN GET   (R4),CRDWA\n         TM    DRFLSW,SYNADFLG     WAS SYNAD EXIT TAKEN?\n         BO    *+L'*+8             YES, BRANCH\n         LA    R3,1(R3)            BUMP COUNTER\n         B     BMEMCOUN\n         LA    R1,DRLBMSG\n         ST    R1,MSGADD\nAMEMEOF2 MVI   OPCLPL,VLB          SET \"VL\" BIT\n        CLOSE  ((R4)),MF=(E,OPCLPL)\n         TM    DRFLSW,SYNADFLG     WAS SYNAD EXIT TAKEN?\n         BO    SEQFREE             YES, BRANCH\n         ST    R3,SEQRNUM\n         ICM   R15,B'1111',AREDIT\n         BNZ   CALLED2\n        LOAD   EP=ETPSEDIT,ERRET=LDE2ERR\n         ST    R0,AREDIT\n         LR    R15,R0\n*- - - ETPSEDIT PARM.LIST : DCB, DS-NAME, MEMBER-NAME, DS-ORG,\n*                           NUM-RECS, VOL-SER, PASSWORD\nCALLED2 CALL   (15),((R4),DSNAME,DSMEMBER,DIRORG,SEQRNUM,              X\n               DIRVOL,DIRPASS),VL,MF=(E,PARMVL)\n         B     SEQFREE\nLDB2ERR  LA    R2,BRUMSG           BROWSE IS UNAVAILABLE\n         B     LDE2ERR+L'LDE2ERR\nLDE2ERR  LA    R2,EDUMSG           EDIT IS UNAVAILABLE\n         STM   R0,R1,MESSPL\n        XMESS  99,R15\n         ST    R2,MSGADD\n         B     SEQFREE\nSEQBROWS ICM   R15,B'1111',ARBROWSE\n         BNZ   CALLBR2\n        LOAD   EP=ETPSBROW,ERRET=LDB2ERR\n         ST    R0,ARBROWSE\n         LR    R15,R0\n*- - - - ETPSBROW PARM.LIST : DCB, DS-NAME, MEMBER-NAME\nCALLBR2 CALL   (15),((R4),DSNAME,DSMEMBER),VL,MF=(E,PARMVL)\nSEQFREE  LR    R0,R7               INITIALIZE DYNAMIC ALLOCATION WORK\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DD-NAME\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    DIRRETRN            OK\n        XMESS  1308\n         TM    DRFLSW,SYNADFLG     WAS SYNAD EXIT TAKEN?\n         BO    DIRRETRN            YES, BRANCH\n         LA    R1,*+L'*+8\n         ST    R1,MSGADD\n         B     DIRRETRN\n         MSG   'FREE \"LIB\" FAILED',H=Y\nERRINUSE LA    R1,ALL0210\nEDIRSMS  ST    R1,MSGADD\n*- - - - DONE EDITING THIS FILE, SO FREE IT\nFREELIB  LA    R4,ALIBDCB\n         LA    R3,NLDCB\nBUMPLIB1 L     R2,0(,R4)\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN\n         BZ    BUMPLIB2\n         MVI   OPCLPL,VLB          SET \"VL\" BIT\n        CLOSE  ((R2)),MF=(E,OPCLPL)\nBUMPLIB2 LR    R0,R7               INITIALIZE DYNAMIC ALLOCATION WORK\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         MVI   DSNAME,0\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R2) DD-NAME\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15\n         BZ    NXTLIB\n         CH    R15,=H'4'\n         BNE   *+L'*+8\n         CL    R0,=A(X'04380000')\n         BE    NXTLIB              DD-NAME NOT FOUND (NOT ALLOCATED)\n         ST    R3,MESSPL\n        XMESS  1306\n         OC    MSGADD,MSGADD\n         BNZ   NXTLIB\n         LA    R1,FRFMSG\n         ST    R1,MSGADD\nNXTLIB   LA    R4,4(R4)\n         BCT   R3,BUMPLIB1         LOOP IF MORE\nDIRRETRN NI    DRFLSW,255-SYNADFLG\n         L     R13,4(R13)          PICK UP CALLING SAVE-AREA\n         LM    R14,R12,12(R13)     RESTORE CALLING REGISTERS\n         BR    R14                 NORMAL RETURN\n         DROP  R7\n         SPACE 1\n*------- SYNAD EXITS - ENTERED DURING THE I/O IF AN ERROR OCCURS.\n         CNOP  0,4\nDIRSYNAD SYNADAF ACSMETH=BSAM\n         MVI   DRLBMSG,15\n         MVC   DRLBMSG+1(15),91(R1) ERROR DESCRIPTION ONLY\n         OI    DRFLSW,SYNADFLG\n        SYNADRLS\n         BR    R14\n         CNOP  0,4\nSEQSYNAD SYNADAF ACSMETH=QSAM\n         MVI   DRLBMSG,15\n         MVC   DRLBMSG+1(15),91(R1) ERROR DESCRIPTION ONLY\n         OI    DRFLSW,SYNADFLG\n        SYNADRLS\n         BR    R14\n         SPACE 1\nCPUMSG   MSG   'EDIT UNAVAILABLE'\nEDUMSG   MSG   'EDIT UNAVAILABLE'\nFRFMSG   MSG   'FREE FILE FAILED'\nINVSEL   MSG   'INVALID SELECTION'\nBRUMSG   MSG   'BROWSE UNAVAILABLE'\nALL0210  MSG   '0210/DATA-SET IN USE'\n         SPACE 1\nDIRDCB  DCB    DSORG=PS,MACRF=(RP,WP),DDNAME=DUMMY,RECFM=F,            X\n               LRECL=256,BLKSIZE=256,KEYLEN=8,EODAD=*-*,SYNAD=*-*\nDIRDCBL  EQU   *-DIRDCB\n        READ   DIRDECB,SF,*-*,*-*,'S',MF=L\nSEQDCB  DCB    DSORG=PS,MACRF=(GM,PM),DDNAME=DUMMY,EODAD=*-*,SYNAD=*-*\nSEQDCBL  EQU   *-SEQDCB\n         SPACE 1\n*- - - - DIRECTORY LIST FORMAT\n*        THIS IS THE FORMAT FOR A PDS LIBRARY DIRECTORY LISTING\nDIRROW1  DC    AL1(DIRROW1L-1),XL1'05'\nDIRTITLE EQU   *-DIRROW1,7\n         DC    CL7'   EDIT',CL3' - '\nDIRDSNAM EQU   *-DIRROW1\n         DC    69CL1'-'\nDIRROW1L EQU   *-DIRROW1\nCRDRSC   EQU   01                  CURSOR ROW ON LINE BELOW\nZIME     EQU   (CRDRSC+1)*4        \"TERMINPT\" DISPLACEMENT\nDIRROW2  DC    AL1(DIRROW2L-1)\n         DC    XL1'05',CL12'COMMAND ===>'\nCCDRSC   EQU   *-DIRROW2           CURSOR COLUMN ON FIELD BELOW\nDRSCF1   EQU   (*-DIRROW2)+1,46    INPUT FIELD 1\n         DC    XL1'01',CL46' '\n         DC    XL1'05',CL11'< SCROLL =>'\nDRSCF2   EQU   (*-DIRROW2)+1,4     INPUT FIELD 2\n         DC    XL1'01',CL4' ',XL1'05',CL1'<',XL1'04'\nDIRROW2L EQU   *-DIRROW2\nDIRROW3  DC    AL1(DIRROW3L-1)\n         DC    XL1'05',CL26'    NAME       NEWNAME    '\n         DC    C'VV.MM CREATED   CHANGED         SIZE  ID '\nDIRROW3L EQU   *-DIRROW3\nDIRROW4  DC    AL1(DIRROW4L-1)\n         DC    XL1'05',CL26'    --------   --------   '\n         DC    C'----- -------   -------         ----  ------- '\nDIRROW4L EQU   *-DIRROW4\nCRDLST   EQU   04                  DIRECTORY LIST LINE NUMBER\nZIMN     EQU   (CRDLST+1)*4        \"TERMINPT\" DISPLACEMENT\nDIRLIST  DC    AL1(DIRELEN-1)\nCCDLF1   EQU   *-DIRLIST           CURSOR COLUMN ON FIELD BELOW\nDRSLF1   EQU   (*-DIRLIST)+1,1     INPUT FIELD 1 - SEL.CODE\n         DC    XL1'01',CL1' '\nDRSLF2   EQU   (*-DIRLIST)+3,8     DISPLAY FIELD 2 - NAME\n         DC    XL1'04',CL12' '\nCCDLF2   EQU   *-DIRLIST           CURSOR COLUMN ON FIELD BELOW\nDRSLF3   EQU   (*-DIRLIST)+1,10    INPUT FIELD 3 - NEW NAME OR RENAME\n         DC    XL1'01',CL10' ',XL1'04',CL50' '\nDIRELEN  EQU   *-DIRLIST\n         DROP  R10,R11,R12,R13\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         EJECT\n*------- TERMINAL COMMUNICATIONS SUBROUTINE -------------------------*\n*              (CONSOLE I/O SUBROUTINE)\n*- - - - COMMUNICATIONS SUBROUTINE - EXCP INTERFACE\n*              ON RETURN : R15 =  0 - OK WRITE (TPUT) AND READ (TGET)\n*                              = 16 - WRITE (TPUT) OR READ (TGET) ERROR\n         CNOP  0,4\n         USING *,R12,R11\n         USING SAVE4,R13      ************************** R13 ==> SAVE4\n         USING SPLTAREA,R10   AT ENTRY : R10 MUST POINT TO \"SPLTAREA\"\nETPSCOMM STM   R14,R12,12(R13)     SAVE INPUT REGISTERS\n         LR    R12,R15             SET PROGRAM BASE REGISTER 1\n         LA    R3,1\n         LA    R11,4*KB-1(R3,R12)  SET PROGRAM BASE REGISTER 2\n         LR    R3,R10              SPLIT-SCREEN DSECT\n         SH    R3,=Y(SPLITWRK-SAVE4) POINT TO SAVE4\n         ST    R13,4(,R3)          STORE BACKWARD POINTER\n         ST    R3,8(R13)           STORE FORWARD POINTER\n         LR    R13,R3              SET DSECT BASE\n         TM    COMMSW,EXTSBP       EXTERNAL PROCESS?\n         BZ    RESCREEN            NO\n*- - - - WHEN EXTERNAL SCREEN BUFFER PROCESS, AT ENTRY, REGISTERS\n*              ARE PASSED AS BELOW :\n*              R0 = WRITE/TPUT BUFFER ADDRESS\n*              R1 = WRITE/TPUT LENGTH\n         LR    R4,R0               YES, POSITION REGISTERS\n         LR    R5,R1\n         B     GOTOX1\nRESCREEN NI    COMMSW,255-HELPFLG  INDICATE \"NOT DOING HELP\"\nRESCRHLP L     R9,SCROWS           PICK UP TERMINAL SCREEN SIZE\n         XR    R5,R5               LENGTH COUNTER\n         L     R7,BUFF             ADDRESS OF WRITE BUFFER\n         LR    R0,R7\n         L     R1,=A(4*KB)\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R0,R14              CLEAR BUFFER TO BINARY ZEROS\n         CLI   TUBEDDNM,C'T'       TSO TERMINAL?\n         BNE   *+L'*+12            NO\n         MVI   0(R7),X'27'         YES, SET TSO WRITE SEQUENCE\n         LA    R7,1(R7)            BUMP ADDRESS\n         LA    R5,1(R5)            BUMP COUNTER\n         MVI   0(R7),X'7E'         ERASE-WRITE-ALTERNATE\n         TM    COMMSW,HELPFLG      AM I DOING HELP?\n         BO    BLDBUFFL            YES\n         L     R6,TERMOUT          PICK UP WCC INDICATOR\n         CLI   0(R6),C'A'          ALARM REQUESTED?\n         BNE   BLDBUFFL            NO\n         MVI   1(R7),X'C7'         ALARM + RESET KEYBOARD + RESET MDT\n         B     BLDBUFFL+L'BLDBUFFL\nBLDBUFFL MVI   1(R7),X'C3'         RESET KEYBOARD + RESET MDT\n         LA    R7,2(R7)            BUMP ADDRESS\n         LA    R5,2(R5)            BUMP COUNTER\n         XR    R8,R8               SCREEN ROW 1\n         LA    R6,TERMOUT+4        PICK UP LINE 1\n         TM    COMMSW,HELPFLG      AM I DOING HELP?\n         BZ    BLDBUFFS            NOPE\n         L     R6,HELPADD          YUP, HELP SCREEN\n*- - - - BUILD THE SCREEN I/O OUTPUT BUFFER LOOPING THROUGH ALL THE\n*              \"TERMOUT\" DESCRIPTIONS UNTIL THE TERMINAL SCREEN SIZE\n*              OR THE END-OF-LIST REACHED\nBLDBUFFS XR    R4,R4               SET TO COL 1\n         MVI   0(R7),X'11'         SET SBA CODE\n         STC   R8,SBAROW           GET ROW\n         STC   R4,SBACOL           GET COL\n         BAL   R14,SBASLATE        TRANSLATE TO SBA\n         MVC   1(2,R7),SBAWORK     SET ADDRESS OF FROM FIELD\n         LA    R7,3(R7)            BUMP ADDRESS\n         LA    R5,3(R5)            BUMP COUNTER\n         L     R2,0(R6)            ADDRESS OF FROM FIELD\n         CLI   0(R2),0             IS LENGTH ZERO?\n         BNE   *+L'*+8             NOPE\n         LA    R2,ERRROWZ          SAY ROW LENGTH IS ZERO\n         B     *+L'*+12\n         CLI   0(R2),BUFOLL-1      IS LENGTH TOO HIGH?\n         BNH   *+L'*+4             NOPE\n         LA    R2,ERRROWL          SAY ROW LENGTH IS TOO LONG\n         XR    R1,R1               CLEAR REGISTER\n         IC    R1,0(R2)            PICK UP LENGTH\n         LA    R2,1(R2)            POINT TO FIRST INPUT BYTE\n         XR    R3,R3               SET NO INPUT FIELD PROCESSED\nBUFFMVL  CLI   0(R2),INFMOD+ATTMAX \"SF\" CODE?\n         BNH   BUFFSF              YES, GO PROCESS IT\n         MVC   0(1,R7),0(R2)       NO, MOVE BYTE OF DATA\n         LA    R7,1(R7)            BUMP BUFFER POINTER\n         LA    R5,1(R5)            BUMP BUFFER COUNTER\n         B     BUFFMVT             CONTINUE\nBUFFSF   LTR   R3,R3               HAVE WE PROCESSED AN INPUT FIELD?\n         BZ    BUFFGSF             NO, GO AHEAD\n         BAL   R0,ADJINF           YES, GO LOOK FOR TRAILING BLANKS\n         LTR   R14,R14             ANY TRAILING BLANKS?\n         BZ    BUFFGSF             NONE\n         SR    R7,R14              BACK BUFFER POINTER\n         SR    R5,R14              BACK BUFFER COUNTER\n         MVI   0(R7),X'11'         SET SBA CODE\n         STC   R8,SBAROW           GET ROW\n         STC   R4,SBACOL           GET COL\n         BAL   R14,SBASLATE        TRANSLATE TO SBA\n         MVC   1(2,R7),SBAWORK     SET ADDRESS OF FROM FIELD\n         LA    R7,3(R7)            BUMP ADDRESS\n         LA    R5,3(R5)            BUMP COUNTER\nBUFFGSF  XR    R14,R14\n         IC    R14,0(R2)           PICK UP ATTRIBUTE BYTE\n         LA    R0,ATTMAX\n         NR    R14,R0\n         AR    R14,R14\n         LA    R14,ATTRIBS(R14)    POINT TO ATTRIBUTE\n         TM    0(R14),FPROT        CHECK IF PROTECTED FIELD\n         BZ    *+L'*+6             NO\n         XR    R3,R3               YES, SET NO INPUT FIELD STARTS\n         B     *+L'*+4\n         LA    R3,2(R7)            SET INPUT FIELD START POINT\n         MVI   0(R7),X'1D'         SET SF CODE\n         TM    0(R2),INFMOD        CHECK IF INPUT FIELD MODIFIED?\n         BO    *+L'*+10\n         MVC   1(1,R7),0(R14)      MOVE ATTRIBUTE\n         B     *+L'*+6\n         MVC   1(1,R7),1(R14)      MOVE ATTRIBUTE (+MDT)\n         LA    R7,2(R7)            BUMP BUFFER POINTER\n         LA    R5,2(R5)            BUMP BUFFER COUNTER\nBUFFMVT  LA    R2,1(R2)            BUMP INPUT  POINTER\n         LA    R4,1(R4)            BUMP COL NUMBER\n         BCT   R1,BUFFMVL          MOVE EVERY BYTE\n         LTR   R3,R3               HAVE WE PROCESSED AN INPUT FIELD?\n         BZ    TSIMSG              NO, GO AHEAD\n         BAL   R0,ADJINF           YES, GO LOOK FOR TRAILING BLANKS\n         LTR   R14,R14             ANY TRAILING BLANKS?\n         BZ    TSIMSG              NONE\n         SR    R7,R14              BACK BUFFER POINTER\n         SR    R5,R14              BACK BUFFER COUNTER\nTSIMSG   XR    R14,R14\n         CL    R14,MSGADD          IS THERE A MESSAGE?\n         BE    BLDBUMPT            NO, GO BUMP\n         CLI   SPLIT,2             AM I IN SPLIT-SCREEN 2?\n         BE    CHKMSG              YES, SKIP THIS\n         LA    R14,TERMOUT+4       SET LINE 1 ADDRESS\n         CR    R6,R14              AM I ON LINE1?\n         BE    BLDBUMPS            YES I AM\n         B     BLDBUMPT            NO, GO BUMP\nCHKMSG   L     R14,SCROWS1\n         SLL   R14,2\n         LA    R14,TERMOUT+4(R14)  SET LINE 1 ADDRESS (SCREEN 2)\n         CR    R6,R14              AM I ON LINE1?\n         BNE   BLDBUMPT            NO, GO BUMP\nBLDBUMPS LR    R15,R7\n         L     R14,MSGADD          MESSAGE ADDRESS\n         XR    R2,R2\n         IC    R2,0(R14)           MESSAGE LENGTH\n         LA    R0,20\n         CLR   R2,R0\n         BNH   *+L'*+2\n         LR    R2,R0               TRUNCATE MESSAGE TOO LONG\n         SR    R15,R2\n         AR    R15,R1\n         L     R14,MSGADD          MESSAGE ADDRESS\n         BCT   R2,*+L'*+6\n         MVC   0(*-*,R15),1(R14)   <<EXECUTED>>\n         EX    R2,*-6              PLACE MESSAGE\n         XC    MSGADD(4),MSGADD    CLEAR THE MESSAGE\n         L     R14,BUFF            BUFFER ADDRESS\n         CLI   0(R14),X'27'        IS IT TSO WRITE SEQUENCE?\n         BNE   *+L'*+4             NO\n         LA    R14,1(R14)          YES, ONE MORE AHEAD\n         MVI   1(R14),X'C7'        ALARM + RESET KEYBOARD + RESET MDT\nBLDBUMPT LA    R8,1(R8)            BUMP SCREEN ROW NUMBER\n         TM    0(R6),EOS           END-OF-SCREEN LINES?\n         BO    *+L'*+8             LET 'ER RIP\n         LA    R6,4(R6)            BUMP TO NEXT PARM\n         BCT   R9,BLDBUFFS         GO DO IT\n         MVI   0(R7),X'11'\n         XR    R0,R0\n         IC    R0,CURROW           ROW\n         TM    COMMSW,HELPFLG      AM I DOING HELP?\n         BO    *+L'*+12            YES, DON'T APPLY SPLIT SCREEN\n         CLI   SPLIT,2             AM I IN SPLIT-SCREEN 2?\n         BNE   *+L'*+4             NO\n         A     R0,SCROWS1          YES, ADD ROWS ON SPLIT SCREEN\n         STC   R0,SBAROW\n         MVC   SBACOL,CURCOL       COL\n         BAL   R14,SBASLATE        TRANSLATE TO SBA\n         MVC   1(2,R7),SBAWORK     SET ADDRESS OF CURSOR\n         MVI   3(R7),X'13'\n         LA    R5,4(R5)\n         ST    R5,BUFFL1           MAKE SURE THE LENGTH IS SET\n         L     R4,BUFF             ADDRESS OF WRITE BUFFER\n         L     R0,REPLY            ADDRESS IF INPUT BUFFER\n         L     R1,SCREENSZ\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R0,R14              CLEAR BUFFER TO BINARY ZEROS\n*- - - - WHEN EXTERNAL SCREEN BUFFER PROCESS, AT RETURN, CONDITIONS\n*              OF WRITE-READ/TPUT-TGET ARE PASSED AS BELOW :\n*              R2 = ALWAYS THE \"ECB\" ADDRESS\n*              R15 =  0 - WRITE-READ/TPUT-TGET OK\n*                         R0 = \"REPLY\" LENGTH\n*                         R1 = \"REPLY\" ADDRESS\n*                     4 - WRITE ERROR (R0 = R1 = 0)\n*                     8 - READ ERROR (R0 = R1 = 0)\n*                    12 - WRITE ERROR (R0 = TPUT RC, R1 = 0)\n*                    16 - READ ERROR (R0 = TGET RC, R1 = 0)\nGOTOX1   CLI   0(R4),X'27'         IS IT TSO WRITE SEQUENCE?\n         BE    WRTUBET             YES\n         XC    RECB,RECB           RESET ECB                       <X>\n         MVC   CCW1(8),SELCCW                                      <X>\n         MVC   CCW2(1),WRITECC     COMMAND CODE SET BASED ON       <X>\n         MVC   CCW2+1(7),WRITECCW+1 TERMINAL TYPE                  <X>\n         STCM  R4,B'0111',CCW2+1   SET THE DATA ADDRESS            <X>\n         STCM  R5,B'0011',CCW2+6   SET THE LENGTH                  <X>\n         LA    R1,CCW1                                             <X>\n         STCM  R1,B'0111',TUBEIOB+(IOBSTRTB-IOBSTDRD)              <X>\n         LA    R2,RECB             SET ECB ADDRESS                 <X>\n         STCM  R2,B'0111',TUBEIOB+(IOBECBPB-IOBSTDRD) IN THE IOB   <X>\n        EXCP   TUBEIOB                                             <X>\n        WAIT   ECB=RECB                                            <X>\n         CLI   RECB,ECBNORM        CHECK FOR OK?                   <X>\n         BE    OKWRITE             YES                             <X>\n         TM    COMMSW,EXTSBP       NO, EXTERNAL PROCESS?           <X>\n         BZ    WRFAIL              NO                              <X>\n         LA    R15,4               YES, SET RC=4                   <X>\n         XR    R0,R0                                               <X>\n         B     GOTOX2                                              <X>\nWRFAIL   CLI   RECB,ECBINCPT       CHECK FOR INTERCEPT?            <X>\n         BE    INTIOER             IF YES, I STOP HERE             <X>\n         CLI   RECB,ECBPERR        CHECK FOR PERMANENT I/O ERROR?  <X>\n         BE    PERMIOER            TRY TO RECOVER                  <X>\n        XMESS  1201                                                <X>\n         B     TRETURNX                                            <X>\nOKWRITE  NI    COMMSW,255-PERMERR-INTERR RESET FIRST TIME THROUGH  <X>\n         L     R4,REPLY            PICK UP BUFFER ADDRESS          <X>\n         L     R5,SCREENSZ         PICK UP BUFFER LENGTH           <X>\n         MVC   CCW1(8),SELCCW                                      <X>\n         MVC   CCW2(8),READCCW                                     <X>\n         STCM  R4,B'0111',CCW2+1   SET THE DATA ADDRESS            <X>\n         STCM  R5,B'0011',CCW2+6   SET THE LENGTH                  <X>\n         LA    R1,CCW1                                             <X>\n         STCM  R1,B'0111',TUBEIOB+(IOBSTRTB-IOBSTDRD)              <X>\n         LA    R1,RECB             SET ECB ADDRESS                 <X>\n         STCM  R1,B'0111',TUBEIOB+(IOBECBPB-IOBSTDRD) IN THE IOB   <X>\n         AIF   ('&EATL' EQ '').SKX4                                <X>\n         TM    ATTNSW,ATTRSET      IS ATTENTION ROUTINE ACTIVE?    <X>\n         BZ    TURREAD             NO                              <X>\n         OI    ATTNSW,ATTWAIT      YES, SAY WAITING ATTENTION      <X>\n         XC    RECB,RECB           RESET ECB                       <X>\n        WAIT   ECB=RECB            WAIT ATTENTION                  <X>\n.SKX4    ANOP  ,                                                   <X>\nTURREAD  XC    RECB,RECB           RESET ECB                       <X>\n        EXCP   TUBEIOB                                             <X>\n        WAIT   ECB=RECB                                            <X>\n         CLI   0(R4),X'60'         GOT ANY DATA?                   <X>\n         BNE   READEND             YES, CONTINUE                   <X>\n        STIMER WAIT,BINTVL=TWOSEC  NO AID GENERATED, WAIT-A-BIT    <X>\n         B     TURREAD             AND GO READ AGAIN               <X>\nREADEND  TM    COMMSW,EXTSBP       NO, EXTERNAL PROCESS?           <X>\n         BZ    TESTREAD            NO, GO CHECK READ               <X>\n         CLI   RECB,ECBNORM        CHECK FOR OK?                   <X>\n         BE    TESTREAD            YES                             <X>\n         LA    R15,8               NO, SET RC=8                    <X>\n         XR    R0,R0                                               <X>\n         B     GOTOX2                                              <X>\nWRTUBET TPUT   (R4),(R5),FULLSCR\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    OKTPUT              OK\n         TM    COMMSW,EXTSBP       NO, EXTERNAL PROCESS?\n         BZ    TPFAIL              NO\n         LR    R0,R15              YES, PASS TPUT RC\n         LA    R15,12              SET RC=12\n         B     GOTOX2\nTPFAIL  XMESS  1207,R15            TPUT FAILED, JUST ABEND\n         DC    H'0'                YUP, TAKE AN S0C1 <------------ DUMP\nOKTPUT   L     R1,REPLY            PICK UP BUFFER ADDRESS\n         L     R0,SCREENSZ         PICK UP BUFFER LENGTH\n        TGET   (1),(0),ASIS\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    OKTGET              OK\n         CH    R15,=H'8'           INTERRUPT?\n         BNE   *+L'*+12            NO\n         L     R14,REPLY           PICK UP BUFFER ADDRESS\n         MVI   0(R14),X'6C'        YES, SET PA1\n         B     OKTGET\n         TM    COMMSW,EXTSBP       NO, EXTERNAL PROCESS?\n         BZ    TGFAIL              NO\n         LR    R0,R15              YES, PASS TGET RC\n         LA    R15,16              YES, SET RC=16\nGOTOX2   XR    R1,R1\n         B     TRETURNZ\nTGFAIL  XMESS  1208,R15            TGET FAILED, JUST ABEND\n         DC    H'0'                YUP, TAKE AN S0C1 <------------ DUMP\nOKTGET   L     R0,SCREENSZ         PICK UP BUFFER LENGTH\n         SR    R0,R1               SET R0 = RESIDUAL LENGTH\n         STH   R0,TUBEIOB+(IOBCSW-IOBSTDRD)+5 TUCK IT AWAY IN IOB\n         MVI   RECB,ECBNORM        SET READ OK\n*- - - - EXAMINE READ RESULT AND SET POINTERS TO INPUT FIELDS\nTESTREAD TM    COMMSW,EXTSBP       EXTERNAL PROCESS?\n         BZ    DOPINPT             NO\n         L     R0,SCREENSZ         BUFFER INPUT LENGTH\n         SH    R0,TUBEIOB+(IOBCSW-IOBSTDRD)+5 (RESIDUAL COUNT)\n         L     R1,REPLY            ADDRESS OF INPUT RESPONSE\n         XR    R15,R15             SET RC=0\nTRETURNZ LA    R2,RECB             PASS ADDRESS OF ECB\n         L     R13,4(R13)          PICK UP CALLING SAVE-AREA\n         LM    R3,R12,20+4*R3(R13) RESTORE CALLER REGISTERS\n         L     R14,12(R13)         RESTORE RETURN REGISTER\n         BR    R14                 AND GO BACK TO CALLER\nDOPINPT  LA    R14,TERMINPT+4      NOW CLEAR ALL INPUT LINES\n         L     R1,SCROWS           PICK UP SIZE OF SCREEN\nCLRINPT  L     R15,0(R14)          GET THE ADDRESS\n         MVI   0(R15),0            CLEAR INPUT LINE\n         MVC   1(BUFILL-1,R15),0(R15)\n         LA    R14,4(R14)          BUMP TO NEXT INADDR\n         BCT   R1,CLRINPT          LOOP\n         LA    R4,TERMINPT         GET ADDRESS OF INPUT LINES\n         L     R3,REPLY            GET ADDRESS OF INPUT RESPONSE\n         CLI   RECB,ECBNORM        CHECK FOR OK?\n         BE    OKREAD              YES\n         CLI   RECB,ECBINCPT       CHECK IF READ INTERCEPTED?\n         BE    INTIOER             IF YES, I STOP HERE\n         CLI   RECB,ECBPERR        PERMANENT IO ERROR?\n         BE    PERMIOER            RECOVER IF YES\n        XMESS  1202\n         B     TRETURNX\nOKREAD   NI    COMMSW,255-PERMERR-INTERR-PFKFLAG 1ST TIME THROUGH\n         CLC   0(4,R3),=XL4'016C6102' CHECK FOR TEST-REQ?\n         BE    RESCREEN            RESET SCREEN IF YES\n         CLI   0(R3),X'7D'         IS IT ENTER?\n         BE    *+L'*+4             YES\n         OI    COMMSW,PFKFLAG      IF NOT ENTER, MUST BE PFK\n         TM    COMMSW,HELPFLG      AM I DOING HELP ALREADY?\n         BZ    NOTHLPP             NO\n         TM    COMMSW,PFKFLAG      YES, IS IT A PFK ENTERED?\n         BZ    RESCRHLP            NO, RE-DISPLAY HELP\n         CLI   0(R3),X'F3'         IS IT PF3 (END PFK)?\n         BE    *+L'*+16            YUP\n         CLI   0(R3),X'C3'         IS IT PF15 (END PFK)?\n         BE    *+L'*+8             YUP\n         CLI   0(R3),X'6C'         IS IT PA1?\n         BNE   RESCRHLP            OTHERWISE, GO RE-DISPLAY HELP\n         NI    COMMSW,255-HELPFLG  SHUT IT OFF\n         MVC   CURADDR,HOMEADDR    RESTORE CURSOR ADDRESS\n         B     RESCREEN            GO REDISPLAY THE SCREEN\nNOTHLPP  XC    SBAWORK,SBAWORK\n         OC    SBAWORK(L'SBAWORK),1(R3) GET CURSOR POSITION\n         BZ    SREAD               NONE\n         BAL   R14,SBAXLATE        TRANSLATE TO ROW AND COLUMN\n         CLI   SPLIT,0             AM I IN SPLIT-SCREEN?\n         BE    SREAD               NO\n         CLI   SPLIT,2             YES, AM I IN SPLIT-SCREEN 2?\n         BE    VRFSCT              YES\n         CLC   SBAROW,SCROWS1+3    NO, IS CURSOR IN SCREEN 1?\n         BL    SREAD               YES\n         B     SKPST               ELSE SKIP SET\nVRFSCT   XR    R0,R0               COMPUTE ROW RELATIVE TO SCREEN 2\n         IC    R0,SBAROW\n         S     R0,SCROWS1\n         BNP   SKPST               CURSOR IN SCREEN 1, SKIP SET\n         CL    R0,SCROWS2          IS CURSOR IN SCREEN 2?\n         BNL   SKPST               NO, SKIP SET\n         STC   R0,SBAROW           OK\nSREAD    MVC   CURADDR,SBAWORK     SET CURSOR POSITION\nSKPST    L     R14,0(R4)           PICK UP ADDRESS FOR AID AND CURSOR\n         MVC   0(1,R14),0(R3)      MOVE AID\n         MVC   1(L'CURADDR,R14),CURADDR MOVE CURSOR POSITION\n         TM    COMMSW,PFKFLAG      IS IT A PFK ENTERED?\n         BZ    LREAD               NO, GO PROCESS INPUT FIELDS IF ANY\n*- - - - PF-KEY 2 / 14 : SPLIT SCREEN PROCESS\n         CLI   0(R3),X'F2'         IS IT SPLIT PFKEY?\n         BE    *+L'*+8             YUP\n         CLI   0(R3),X'C2'         IS IT SPLIT PFKEY?\n         BNE   TSWITCH             OTHERWISE, TEST FOR SWITCH\n         CLI   SPLIT,0             SPLIT-SCREEN ALREADY?\n         BE    *+L'*+12            NO, SPLIT IT\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         MVI   0(R2),X'6E'         RESET IT TO PA2\n         B     TRETURN             JUST EXECUTE PA2\n         L     R1,SCROWS           SET IT\n         SRL   R1,1                DIVIDE BY 2\n         ST    R1,SCROWS1          STORE IT\n         L     R0,SCROWS           PICK IT UP\n         SR    R0,R1               SUBTRACT\n         ST    R0,SCROWS2          STORE THE REMAINDER\n         MVI   SPLIT,2             INDICATE SCREEN 2\n         L     R14,SAVETOP         PICK UP ADDRESS OF SAVE1\n         L     R15,=A(AREALEN)     LENGTH OF SPLIT AREA\n         LR    R1,R15\n         L     R0,SPLOFF1\n         AR    R0,R13\n         MVCL  R0,R14              COPY TO SPLIT1\n         L     R14,SAVETOP         PICK UP ADDRESS OF SAVE1\n         L     R15,=A(AREALEN)     LENGTH OF SPLIT AREA\n         LR    R1,R15\n         L     R0,SPLOFF2\n         AR    R0,R13\n         MVCL  R14,R0              COPY FROM SPLIT2\n         L     R14,ARPOPS          PICK UP RETURN ADDRESS\n         LM    R10,R13,PRISPLIT\n         XR    R15,R15             RESET (CLEAR)\n         LR    R0,R15\n         LR    R1,R15\n         LR    R2,R15\n         LR    R3,R15\n         LR    R4,R15\n         LR    R5,R15\n         LR    R6,R15\n         LR    R7,R15\n         LR    R8,R15\n         LR    R9,R15\n         BR    R14                 SHOW PRIMARY OPTION MENU\n*- - - - PF-KEY 9 / 21 : SWITCH SCREEN PROCESS\nTSWITCH  CLI   0(R3),X'F9'         IS IT SWITCH SCREEN?\n         BE    *+L'*+8             YUP\n         CLI   0(R3),X'C9'         IS IT SWITCH SCREEN?\n         BNE   TENDPFK             OTHERWISE, TEST FOR END PFK\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         MVI   0(R2),X'6E'         RESET IT TO PA2\n         CLI   SPLIT,0             IN SPLIT-SCREEN MODE?\n         BE    TRETURN             NO, JUST EXECUTE PA2\n         CLI   SPLIT,1             AM I ON TOP SCREEN?\n         BNE   SWBOTTOP            NOPE, GO FROM BOTTOM TO TOP\n         L     R14,SAVETOP         PICK UP ADDRESS OF SAVE1\n         L     R15,=A(AREALEN)     LENGTH OF SPLIT AREA\n         LR    R1,R15\n         L     R0,SPLOFF1\n         AR    R0,R13\n         MVCL  R0,R14              COPY TO SPLIT1\n         MVI   SPLIT,2             INDICATE SCREEN 2\n         L     R14,SAVETOP         PICK UP ADDRESS OF SAVE1\n         L     R15,=A(AREALEN)     LENGTH OF SPLIT AREA\n         LR    R1,R15\n         L     R0,SPLOFF2\n         AR    R0,R13\n         MVCL  R14,R0              COPY FROM SPLIT2\n         B     RESCREEN            SET UP FOR SWITCH\nSWBOTTOP L     R14,SAVETOP         PICK UP ADDRESS OF SAVE1\n         L     R15,=A(AREALEN)     LENGTH OF SPLIT AREA\n         LR    R1,R15\n         L     R0,SPLOFF2\n         AR    R0,R13\n         MVCL  R0,R14              COPY TO SPLIT2\n         L     R14,SAVETOP         PICK UP ADDRESS OF SAVE1\n         L     R15,=A(AREALEN)     LENGTH OF SPLIT AREA\n         LR    R1,R15\n         L     R0,SPLOFF1\n         AR    R0,R13\n         MVCL  R14,R0              COPY FROM SPLIT1\n         MVI   SPLIT,1             TURN IT ON\n         B     RESCREEN\n*- - - - PF-KEY 3 / 15 : END PROCESS\nTENDPFK  CLI   0(R3),X'F3'         IS IT END PFK?\n         BE    *+L'*+8             YUP\n         CLI   0(R3),X'C3'         IS IT END PFKEY?\n         BNE   LREAD               NO, GO PROCESS INPUT FIELDS IF ANY\n         CLI   SPLIT,0             SPLIT-SCREEN?\n         BE    TRETURN             NOPE, JUST GO PROCESS\n         CLI   PRIMEFLG,0          PRIMARY OPTION MENU ON SCREEN 1?\n         BE    TRETURN             NO, JUST RETURN\n         CLI   SPLIT,2             AM I ON BOTTOM SCREEN?\n         BE    SWBOTEOF            YES, GO END THE BOTTOM SCREEN\n         LM    R0,R1,SPLOFF1       NO, EXCHANGE SPLIT1-SPLIT2\n         ST    R0,SPLOFF2\n         ST    R1,SPLOFF1\nSWBOTEOF L     R2,TERMINPT         PICK UP AID ADDRESS\n         MVI   0(R2),X'6E'         RESET IT TO PA2\n         L     R14,SAVETOP         PICK UP ADDRESS OF SAVE1\n         L     R15,=A(AREALEN)     LENGTH OF SPLIT AREA\n         LR    R1,R15\n         L     R0,SPLOFF1\n         AR    R0,R13\n         MVCL  R14,R0              COPY FROM SPLIT1\n         MVC   SCROWS1,SCROWS      RESET NUMBER OF ROWS\n         XC    SCROWS2,SCROWS2     CLEAR THIS\n         MVI   SPLIT,0             INDICATE NOT IN SPLIT-SCREEN\n         B     TRETURN             GO PROCESS PA2\n*- - - - INPUT FIELDS DATA PROCESS\nLREAD    L     R1,SCREENSZ         START EXAMINING BUFFER FOR DATA\n         SH    R1,TUBEIOB+(IOBCSW-IOBSTDRD)+5 (RESIDUAL COUNT)\n         LA    R9,0(R1,R3)         LAST BYTE OF INPUT READ\n         BCTR  R9,0\n         CL    R1,=F'3'            IS IT ENTER WITH NO DATA?\n         BNH   CHKHLP              YES\n         LA    R4,4(R4)            BUMP TO NEXT ADDRESS\n         LA    R3,3(R3)            POINT PAST AID AND CURSOR\n*- - - - NOW I HAVE TO PICK UP THE SBA AND LOCATE THE CORRESPONDING\n*        OUTPUT LINE (FIRST TRANSLATE SBA CODES TO ROW AND COLUMN)\nGOTSBAL  XR    R6,R6               LENGTH OF DATA\n         LR    R8,R3               START OF DATA\n         CLI   0(R8),X'11'         DO I HAVE AN SBA?\n         BE    OKSBA               YES\n        XMESS  1203\n         B     TRETURNX\nOKSBA    LA    R1,2(R8)            SBA-ADDRESS CHECK\n         CLR   R1,R9               HOW IS IT?\n         BNH   OKCHK               OK\n        XMESS  1204\n         B     TRETURNX\nOKCHK    MVC   SBAWORK(L'SBAWORK),1(R8) SET ADDRESS OF SBA\n         BAL   R14,SBAXLATE        TRANSLATE TO ROW AND COLUMN\n*- - - - CHECK IF WE ARE IN THE ACTIVE PART OF THE SCREEN\n         CLI   SPLIT,0             SPLIT-SCREEN?\n         BE    GTIFLD              NOPE, OK, PROCEED\n         CLI   SPLIT,2             AM I ON BOTTOM SCREEN?\n         BE    *+L'*+14            YES\n         CLC   SBAROW,SCROWS1+3    NO, IS FIELD IN SCREEN 1?\n         BL    GTIFLD              YES, OK, PROCEED\n         B     SKPFLD              ELSE SKIP FIELD\n         XR    R0,R0               COMPUTE ROW RELATIVE TO SCREEN 2\n         IC    R0,SBAROW\n         S     R0,SCROWS1\n         BNP   SKPFLD              FIELD IN SCREEN 1, SKIP FIELD\n         CL    R0,SCROWS2          IS FIELD IN SCREEN 2?\n         BL    GTIFLD              YES, OK, PROCEED\nSKPFLD   LA    R3,3(R3)            BUMP ADDRESS\n         CLR   R3,R9               COMPARE VS LAST BYTE READ IN\n         BH    CHKHLP              OUT LOOPING\n         CLI   0(R3),X'11'         LOOK FOR NEXT SBA\n         BE    GOTSBAL             GOT IT, KEEP LOOPING\n         LA    R3,1(R3)            BUMP ADDRESS\n         B     SKPFLD+L'SKPFLD     CONTINUE\n*- - - - NOW MOVE THE IMAGE OF THE ROW THAT WAS TRANSMITTED TO THE\n*        TERMINAL INTO MY INPUT BUFFER SO THAT I CAN SIMULATE A\n*        FULL-LINE READ (MARK INPUT FIELDS AS ENTERED)\nGTIFLD   LA    R14,TERMOUT+4       LINE 1 THAT WAS DISPLAYED\n         XR    R15,R15             CLEAR REGISTER\n         IC    R15,SBAROW          PICK UP LINE NUMBER (REL 0)\n         SLL   R15,2               MULTIPLY BY 4\n         L     R2,0(R15,R14)       POINT TO ACTUAL OUTPUT LINE\n         LA    R14,TERMINPT+4      POINT TO INPUT LINE SLOT\n         L     R7,0(R15,R14)       POINT TO ACTUAL INPUT LINE\n         LA    R4,0(R15,R14)       SET ADDRESS POINTER\n         CLI   0(R7),0             IS THIS A BLANK LINE?\n         BNE   *+L'*+10            NO, SECOND FIELD ON THIS LINE\n         XR    R14,R14             CLEAR REGISTER\n         IC    R14,0(R2)           PICK UP LENGTH\n         EX    R14,MOVINADD        MOVE LINE IMAGE TO INPUT BUFFER\n         XR    R14,R14             CLEAR REGISTER\n         IC    R14,SBACOL          PICK UP COLUMN (REL 0)\n         LA    R7,0(R7,R14)        POINT TO ACTUAL INPUT ATTRIBUTE\n         OI    0(R7),INFMOD        SET INPUT FIELD MODIFIED\n         LA    R7,1(R7)            POINT TO ACTUAL INPUT LOCATION\n*- - - - NOW I HAVE TO FIND THE LENGTH OF INPUT THAT WAS ENTERED\n*        AT THE TERMINAL SO I CAN MOVE IT INTO THE LINE IMAGE.\n         LA    R3,3(R3)            BUMP ADDRESS\nSBABUMP  CLR   R3,R9               COMPARE VS LAST BYTE READ IN\n         BH    GOTSBAM             OUT LOOPING\n         CLI   0(R3),X'11'         LOOK FOR NEXT SBA\n         BE    GOTSBAM             GOT IT\n         LA    R3,1(R3)            BUMP ADDRESS\n         LA    R6,1(R6)            BUMP LENGTH\n         B     SBABUMP             KEEP LOOPING\nGOTSBAM  LTR   R6,R6               CHECK IF JUST FIELD CANCELED?\n         BZ    GOTSBAF             YES\n         BCTR  R6,0\n         TM    PRCSSW,ASISFLG      ASIS REQUESTED?\n         BO    *+L'*+4             YES\n         EX    R6,REPLYCAP         NO, UPPER-CASE THE INPUT\n         EX    R6,REPLYMVC         MOVE IT INTO THE LINE\n         LA    R7,1(R6,R7)\nGOTSBAF  TM    0(R7),X'F0'         CLEAR FIELD (ALL OR REST)\n         BZ    GOTSBAT\n         MVI   0(R7),C' '\n         LA    R7,1(R7)\n         B     GOTSBAF\nMOVINADD MVC   0(*-*,R7),0(R2)     <<EXECUTED>>\nREPLYCAP TR    3(*-*,R8),CAPSONLY  <<EXECUTED>>\nREPLYMVC MVC   0(*-*,R7),3(R8)     <<EXECUTED>>\nGOTSBAT  CLR   R3,R9               COMPARE VS LAST BYTE READ IN\n         BNH   GOTSBAL             KEEP LOOPING\n*- - - - PF-KEY 1 / 13 : HELP PROCESS\n*              NOTE THAT ALL HELP PANELS HAVE THE CURSOR ON THE FIRST\n*              BLANK LINE (ROW 2, COLUMN 2)\nCHKHLP   TM    COMMSW,PFKFLAG      IS IT A PFK ENTERED?\n         BZ    TRETURN             NO, THAT'S ALL, RETURN\n         L     R3,REPLY            YES, GET ADDRESS OF INPUT RESPONSE\n         CLI   0(R3),X'F1'         IS IT HELP PFKEY?\n         BE    *+L'*+8             YUP\n         CLI   0(R3),X'C1'         IS IT HELP PFKEY?\n         BNE   TRETURN             NO, THAT'S ALL, RETURN\n         OI    COMMSW,HELPFLG      TURN HELP ON\n         MVC   HOMEADDR,CURADDR    SAVE CURSOR ADDRESS\n         MVC   CURADDR,=AL1(1,1)   SET CURSOR OF HELP PANEL\n         L     R1,SCROWS           COPY ALL MODIFIED LINES\n         LA    R2,TERMINPT+4\n         LA    R3,TERMOUT+4\n         XR    R15,R15\nCPYLOOP  L     R4,0(R2)\n         L     R5,0(R3)\n         CLI   0(R4),0\n         BE    *+L'*+8\n         IC    R15,0(R4)\n         EX    R15,COPYOUT\n         LA    R2,4(R2)\n         LA    R3,4(R3)\n         BCT   R1,CPYLOOP\n         B     RESCRHLP            AND GO DISPLAY HELP\nCOPYOUT  MVC   0(*-*,R5),0(R4)     <<EXECUTED>>\nTRETURN  XR    R15,R15             SET RC=0\n         L     R13,4(R13)          PICK UP CALLING SAVE-AREA\n         LM    R0,R12,20(R13)      RESTORE CALLING REGISTERS\n         L     R14,12(R13)         PRESERVE R15\n         BR    R14                 NORMAL RETURN\nPERMIOER TM    COMMSW,PERMERR      FIRST TIME THROUGH?\n         BO    *+L'*+8             NOPE\n         OI    COMMSW,PERMERR      SET NOT FIRST TIME THROUGH\n         B     RESCREEN            TRY TO RESHOW THE SCREEN\n        XMESS  1205\n         B     TRETURNX\nINTIOER  TM    COMMSW,INTERR       FIRST TIME THROUGH?\n         BO    *+L'*+8             NOPE\n         OI    COMMSW,INTERR       SET NOT FIRST TIME THROUGH\n         B     RESCREEN            TRY TO RESHOW THE SCREEN\n        XMESS  1206\nTRETURNX LA    R15,16              SET RC=16\n         B     TRETURN+L'TRETURN\n         SPACE 1\n*- - - - ROUTINE WHICH LOOK TO CUT OUT TRAILING BLANKS\n*              OF THE JUST MOVED INPUT FIELD (THIS DO \"NULLS ON\")\n*              R0 = LINK REGISTER\nADJINF   LR    R15,R7\n         XR    R14,R14\nADJINFL  BCTR  R15,0\n         CLR   R15,R3\n         BL    ADJINFX\n         CLI   0(R15),C' '\n         BNE   ADJINFX\n         MVI   0(R15),0            CLEAR IT\n         LA    R14,1(R14)          BUMP BLANKS COUNT\n         B     ADJINFL\nADJINFX  LR    R15,R0\n         BR    R15\n         SPACE 1\n*- - - - SBA TRANSLATE TO ROW AND COLUMN ROUTINE\n*              R14 = LINK REGISTER\nSBAXLATE STM   R14,R1,12(R13)      SAVE SBA'S-WORK REGISTERS\n         LA    R15,SBAWORK\n         TR    0(2,R15),EBCTOBIN\n         NC    0(2,R15),=XL2'3F3F'\n         XR    R0,R0\n         LR    R1,R0\n         IC    R0,0(R15)\n         IC    R1,1(R15)\n         SLL   R0,6\n         AR    R1,R0\n         XR    R0,R0\n         CL    R1,SCRWIDTH\n         BNL   *+L'*+12\n         STC   R0,SBAROW           0 (1)\n         STC   R1,SBACOL           0-79 (1-80)\n         B     *+L'*+12\n         D     R0,SCRWIDTH\n         STC   R1,SBAROW           0-42 (1-43)\n         STC   R0,SBACOL           0-79 (1-80)\n         LM    R14,R1,12(R13)      RESTORE SBA'S-WORK REGISTERS\n         BR    R14\n         SPACE 1\n*- - - - ROW AND COLUMN TRANSLATE TO SBA ROUTINE\n*              R14 = LINK REGISTER\nSBASLATE STM   R14,R1,12(R13)      SAVE SBA'S-WORK REGISTERS\n         XR    R0,R0               POS = ((ROW-1) * MAXCOL) + (COL-1)\n         LR    R1,R0\n         IC    R1,SBAROW           0-42 (1-43)\n         LTR   R1,R1\n         BZ    *+L'*+4\n         MH    R1,SCRWIDTH+2\n         IC    R0,SBACOL           0-79 (1-80)\n         AR    R1,R0\n         LR    R15,R1\n         SRL   R15,6\n         IC    R0,BINTOEBC(R15)\n         STC   R0,SBAROW\n         N     R1,=A(X'0000003F')\n         IC    R0,BINTOEBC(R1)\n         STC   R0,SBACOL\n         LM    R14,R1,12(R13)      RESTORE SBA'S-WORK REGISTERS\n         BR    R14\n         SPACE 1\nSCRWIDTH DC    F'80'               SCREEN WIDTH\nTWOSEC   DC    A(2*60)             TWO SECONDS TIMER BIN VALUE     <X>\nSELCCW   CCW   X'0B',*-*,X'60',1                                   <X>\nWRITECCW CCW   X'0D',*-*,X'20',*-*                                 <X>\nREADCCW  CCW   X'06',*-*,X'20',*-*                                 <X>\n         SPACE 1\nBINTOEBC DS    0F\n*                    0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    XL16'40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'  0\n         DC    XL16'50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F'  1\n         DC    XL16'6061E2E3E4E5E6E7E8E96A6B6C6D6E6F'  2\n         DC    XL16'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F'  3\n*                    0 1 2 3 4 5 6 7 8 9 A B C D E F\n         SPACE 1\n*- - - - FIELD ATTRIBUTE BYTES TABLE\n*                             (2ND BYTE = + MDT WHEN UNPROTECTED)\nATTRIBS  DC    XL2'40C1'      X'00' - OFFSET ZERO (DEFAULT, NOT USED)\n         DC    XL2'40C1'      X'01' - UNPROTECTED, DISPLAY <=== DEFAULT\n         DC    XL2'C8C9'      X'02' - UNPROTECTED, DISPLAY, INTENSIFIED\n         DC    XL2'4C4D'      X'03' - UNPROTECTED, NONDISPLAY\n         DC    XL2'F0F0'      X'04' - SKIP, DISPLAY\n         DC    XL2'F8F8'      X'05' - SKIP, DISPLAY, INTENSIFIED\n         DC    XL2'7C7C'      X'06' - SKIP, NONDISPLAY\n         DC    XL2'40C1'      X'07' - OFFSET SEVEN (DEFAULT, NOT USED)\n*        BELOW IS THE MAXIMUM VALUE OF AN ATTRIBUTE (MUST BE X'07')\nATTMAX   EQU   ((*-ATTRIBS)-L'ATTRIBS)/L'ATTRIBS\nFPROT    EQU   X'20'               \"PROTECTED-FIELD\" BIT\n         SPACE 1\nEBCTOBIN DC    256AL1(*-EBCTOBIN)\n         ORG   EBCTOBIN+X'40'\n         DC    X'C0'\n         ORG   EBCTOBIN+X'4A'\n         DC    X'CACBCCCDCECF'\n         ORG   EBCTOBIN+X'50'\n         DC    X'D0'\n         ORG   EBCTOBIN+X'5A'\n         DC    X'DADBDCDDDEDF'\n         ORG   EBCTOBIN+X'60'\n         DC    X'E0E1'\n         ORG   EBCTOBIN+X'6A'\n         DC    X'EAEBECEDEEEF'\n         ORG   EBCTOBIN+X'7A'\n         DC    X'FAFBFCFDFEFF'\n         ORG\n         SPACE 1\n*- - - - CAPS ONLY TRANSLATE TABLE\nCAPSONLY DC    CL16' '\n         DC    XL2'1111',CL14' '   SBA\n         DC    CL16' '\n         DC    CL16' '\n         DC    CL10' ',CL6'\u00a2.<(+|'\n         DC    CL1'&&',CL9' ',CL6'!$*);\u00ac'\n         DC    CL2'-/',CL8' ',CL6'\u00a6,%_>?'\n         DC    CL9' ',CL7'`:#@''=\"'\n         DC    CL10' ABCDEFGHI',CL6' '\n         DC    CL10' JKLMNOPQR',CL6' '\n         DC    CL10'  STUVWXYZ',CL6' '\n         DC    CL16' '\n         DC    CL10'{ABCDEFGHI',CL6' '\n         DC    CL10'}JKLMNOPQR',CL6' '\n         DC    CL10'\\ STUVWXYZ',CL6' '\n         DC    CL10'0123456789',CL6' '\n         SPACE 1\nERRROWZ  DC    AL1(ERRROWZL-1)\n         DC    XL1'05',C'===> ROW IS LENGTH 0 <===',XL1'04'\nERRROWZL EQU   *-ERRROWZ\nERRROWL  DC    AL1(ERRROWLL-1)\n         DC    XL1'05',C'===> ROW IS TOO LONG <===',XL1'04'\nERRROWLL EQU   *-ERRROWL\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R10,R11,R12,R13\n         AIF   ('&EATL' EQ '').SKX5                                <X>\n         EJECT ,                                                   <X>\n*------- EXCP ATTENTION INITIALIZATION --------------------------* <X>\n*        HOW DONE : AN ENTRY IS DYNAMICALLY SET IN THE ATTENTION   <X>\n*              TABLE (IOSVATTN) IN ORDER TO CAPTURE THE ATTENTION  <X>\n*              SIGNAL FROM THE ALLOCATED TERMINAL (UCB).           <X>\n*        NOTE : IN CASE THE ENTRY IN THE ATTENTION TABLE CANNOT BE <X>\n*              INSTALLED, \"ETPSCOMM\" WORKS LOOPING ON THE I/O READ <X>\n*              EXCP EVERY TWO SECONDS.                             <X>\n         CNOP  0,4                                                 <X>\n         USING *,R12                                               <X>\n         USING SAVE2,R13      ********************** R13 ==> SAVE2 <X>\nETPSXAI  STM   R14,R12,12(R13)     SAVE INPUT REGISTERS            <X>\n         LR    R12,R15             SET PROGRAM BASE REGISTER       <X>\n         LR    R3,R13              SAVE1 POINTER                   <X>\n         AH    R3,=Y(SAVE2-SAVE1)  POINT TO SAVE2                  <X>\n         ST    R13,4(,R3)          STORE BACKWARD POINTER          <X>\n         ST    R3,8(R13)           STORE FORWARD POINTER           <X>\n         LR    R13,R3              SET DSECT BASE                  <X>\n         USING IHADCB,R2           AT ENTRY R2 = DCB ADDRESS       <X>\n         XR    R1,R1                                               <X>\n         LR    R4,R1                                               <X>\n         ICM   R1,B'0111',DCBDEBA  DEB ADDRESS                     <X>\n         DROP  R2                                                  <X>\nDUPTR    EQU   (DEBBASND-DEBBASIC)+(DEBUCBA-DEBDASD)               <X>\n         ICM   R4,B'0111',DUPTR(R1) UCB ADDRESS                    <X>\n         L     R3,=A(XWAREAL)      GET WORK-AREA                   <X>\n        GETMAIN RC,LV=(R3)                                         <X>\n         LTR   R15,R15             HOW COMPLETE?                   <X>\n         BZ    XANAL               OK                              <X>\n        XMESS  1011,R15            ERROR                           <X>\n         B     XINIT               GO BACK                         <X>\nXANAL    LR    R10,R1              SAVE GETMAIN POINTER            <X>\n         LR    R2,R1                                               <X>\n         LA    R14,*                                               <X>\n         XR    R15,R15                                             <X>\n         MVCL  R2,R14              CLEAR ALL TO BINARY ZEROS       <X>\n         USING XWAREA,R10                                          <X>\n         ST    R4,XWUCB                                            <X>\n         L     R2,CVTPTR           CVT ADDRESS                     <X>\n         USING CVT,R2                                              <X>\n         L     R2,CVTIXAVL         IOCOM ADDRESS                   <X>\n         DROP  R2                                                  <X>\n         USING IOCOM,R2                                            <X>\n         L     R2,IOCATTBL         ATTENTION TABLE ADDRESS         <X>\n         DROP  R2                                                  <X>\n         USING ATB,R2                                              <X>\n         LR    R1,R2               RETAIN ADDRESS FOR LATER        <X>\n         LA    R6,X'&EATL'(R2)     SET MAXIMUM ADDRESS FOR SEARCH  <X>\n         LA    R3,56+4             SET UCBATI PAST SS1/DSM ENTRY   <X>\n         SLL   R3,ATBMP2           APPLY POWER OF 2 MULTIPLIER     <X>\n         LA    R3,ATBFLA(R3)       POINT TO ENTRY                  <X>\n         DROP  R2                                                  <X>\n         USING ATB,R3                                              <X>\n         LR    R0,R3               RETAIN ADDRESS FOR LATER        <X>\n         LA    R4,ATBELL           ONE ENTRY LENGTH                <X>\nXLOOP1   CLC   ATBFLA(XDUML),XDUM  SCAN TABLE FORWARD              <X>\n         BE    XFOUND1             DUMMY ROUTINE FOUND             <X>\n         ALR   R3,R4               FORWARD TO NEXT                 <X>\n         CLR   R3,R6               TOO FAR?                        <X>\n         BL    XLOOP1              NO, LOOP                        <X>\n        XMESS  1012                YES                             <X>\n         B     XNONE                                               <X>\nXFOUND1  L     R2,XCHK             NOW SCAN TABLE BACKWARD         <X>\n         LR    R5,R3                                               <X>\n         DROP  R3                                                  <X>\n         USING ATB,R5                                              <X>\nXLOOP2   SLR   R5,R4               BACKWARD TO PREVIOUS            <X>\n         CL    R3,ATBRTN           TRY TO FIND A FREE/DUMMY ENTRY  <X>\n         BNE   *+L'*+8             DON'T MATCH                     <X>\n         CL    R2,ATBFLA                                           <X>\n         BE    XFOUND2             MATCH                           <X>\n         CLR   R5,R0               TOO FAR?                        <X>\n         BH    XLOOP2              NO, LOOP                        <X>\n         DROP  R5                                                  <X>\n        XMESS  1013                                                <X>\nXNONE    L     R0,=A(XWAREAL)      NO ENTRY, FREE WORK-AREA        <X>\n         LR    R1,R10                                              <X>\n        FREEMAIN R,LV=(0),A=(1)                                    <X>\n         B     XINIT               AND GO BACK                     <X>\nXFOUND2  ST    R10,XWAPTR          SET FOR TERMINATION FREEMAIN    <X>\n         STM   R2,R3,XWRST         RESTORE VALUES                  <X>\n         ST    R5,XWATP            ATTENTION TABLE ENTRY ADDRESS   <X>\n         SLR   R5,R1               COMPUTE ATTENTION INDEX         <X>\n         SRL   R5,ATBMP2           APPLY POWER OF 2 MULTIPLIER     <X>\n         ST    R5,XWAIX            ATTENTION INDEX                 <X>\n         USING PSA,R0                                              <X>\n         L     R1,PSAAOLD          ASCB ADDRESS                    <X>\n         DROP  R0                                                  <X>\n         USING ASCB,R1                                             <X>\n         XR    R2,R2                                               <X>\n         ICM   R2,B'0011',ASCBASID MY AS-ID                        <X>\n         DROP  R1                                                  <X>\n         ICM   R2,B'1000',=AL1(ATBLLKR) LOCAL LOCK REQUIRED        <X>\n         LA    R3,XWATTN           ATTENTION ENTRY ADDRESS         <X>\n         MVC   0(XASKLL,R3),XASKL  MOVE ATTENTION ENTRY CODE       <X>\n         STM   R2,R3,XWSET         SET VALUES                      <X>\n         MVC   XWAREP,=A(XATTN)    ATTENTION ROUTINE ADDRESS       <X>\n         ST    R10,XWARPT          \"XWAREA\" ADDRESS                <X>\n         ST    R13,XWMYSV          \"MYSAVE\" ADDRESS                <X>\n         LA    R3,XWABND           ABEND ENTRY ADDRESS             <X>\n         MVC   0(XXSKLL,R3),XXSKL  MOVE ABEND ENTRY CODE           <X>\n         MVC   XWXAEP,=A(XABEND)   ABEND EXIT ADDRESS              <X>\n         ST    R10,XWXAPT          \"XWAREA\" ADDRESS                <X>\n         MVC   XWLIST(XSKELL),XSKEL ACTIVE ABEND EXIT              <X>\n        ESTAE  (R3),TOKEN=XWTOKEN,MF=(E,XWLIST)                    <X>\n         LM    R2,R3,XWSET         NOW DO THE CHANGES              <X>\n         L     R4,XWATP                                            <X>\n         L     R5,XWUCB                                            <X>\n         L     R6,XWAIX                                            <X>\n         OI    ATTNSW,ATTRSET      SAY ATTENTION ROUTINE ACTIVE    <X>\n        MODESET MF=(E,SUPRMOD)                                     <X>\n         STM   R2,R3,0(R4)         SET ATTENTION TABLE ENTRY       <X>\n        IOSGEN TP,UCB=(R5),VAR=ATNMOD,TABLE=(R6) SET ATTN INDEX    <X>\n        MODESET MF=(E,PROBMOD)                                     <X>\nXINIT    L     R13,4(R13)          PICK UP CALLING SAVE-AREA       <X>\n         LM    R14,R12,12(R13)     RESTORE CALLING REGISTERS       <X>\n         XR    R15,R15             SET RC=0                        <X>\n         BR    R14                 RETURN                          <X>\n         DROP  R10                                                 <X>\n         SPACE 1                                                   <X>\n*- - - - - - - - - - - - - - - - - DUMMY ROUTINE CODE              <X>\nXDUM     SLR   R15,R15             R15 (RETURN CODE) = 0           <X>\n         BSM   0,R14               BRANCH RETURN TO CALLER (IOS)   <X>\nXDUML    EQU   *-XDUM              ROUTINE CODE LENGTH             <X>\n*- - - - - - - - - - - - - - - - - ATTENTION ENTRY CODE            <X>\n         USING XWATTN,R15                                          <X>\nXASKL    STM   R0,R15,0(R13)       SAVE ALL REGISTERS              <X>\n         L     R9,XWARPT           \"XWAREA\" ADDRESS                <X>\n         L     R15,XWAREP          \"XATTN\" ADDRESS                 <X>\n         BR    R15                 GO TO ATTENTION ROUTINE         <X>\n         CNOP  0,4                                                 <X>\nXASKLL   EQU   *-XASKL             ENTRY CODE LENGTH               <X>\n         DROP  R15                                                 <X>\n         SPACE 1                                                   <X>\n*- - - - - - - - - - - - - - - - - ABEND ENTRY CODE                <X>\n         USING XWABND,R15                                          <X>\nXXSKL    STM   R0,R15,XWXSVR       SAVE ALL REGISTERS              <X>\n         L     R9,XWXAPT           \"XWAREA\" ADDRESS                <X>\n         L     R12,XWXAEP          \"XATTN\" ADDRESS                 <X>\n         BR    R12                 GO TO ABEND EXIT                <X>\n         CNOP  0,4                                                 <X>\nXXSKLL   EQU   *-XXSKL             ENTRY CODE LENGTH               <X>\n         DROP  R15                                                 <X>\n         SPACE 1                                                   <X>\nXCHK     DC    0F'0',AL1(ATBSEP+ATBLLKR,0),AL2(1)                  <X>\nXSKEL   ESTAE  *-*,TERM=YES,MF=L                                   <X>\nXSKELL   EQU   *-XSKEL             ESTAE LIST LENGTH               <X>\n         PRINT &PRS                                                <X>\n        LTORG  ,                                                   <X>\n         PRINT &PRF                                                <X>\n         DROP  R12,R13                                             <X>\n         EJECT ,                                                   <X>\n*------- EXCP ATTENTION ROUTINE ---------------------------------* <X>\n         CNOP  0,4                                                 <X>\n         USING *,R15               ESTABLISH LOCAL ADDRESSABILITY  <X>\n         USING IOSB,R1                                             <X>\n         USING XWAREA,R9                                           <X>\nXATTN    CLC   XWUCB,IOSUCB        UCB ADDRESS MATCH?              <X>\n         BNE   XATTNX              NO, IGNORE                      <X>\n         L     R8,XWMYSV           \"MYSAVE\" ADDRESS                <X>\n         USING SAVE2,R8                                            <X>\n         TM    ATTNSW,ATTWAIT      WAITING ATTENTION?              <X>\n         BZ    XATTNX              NO, IGNORE                      <X>\n         NI    ATTNSW,255-ATTWAIT  YES, RESET WAITING ATTENTION    <X>\n         L     R10,=A(X'40000000') GET POST COMPLETION CODE        <X>\n         LA    R11,RECB            ECB ADDRESS                     <X>\n        POST   (11),(10),BRANCH=YES DO POST ECB                    <X>\n         USING PSA,R0                                              <X>\nXATTNX   LM    R0,R15,0(R13)       RESTORE ALL REGISTERS           <X>\n         XR    R15,R15             SET RETURN CODE                 <X>\n         B     PSARET              AND RETURN                      <X>\n         PRINT &PRS                                                <X>\n        LTORG  ,                                                   <X>\n         PRINT &PRF                                                <X>\n         DROP  R0,R1,R8,R9,R15                                     <X>\n         EJECT ,                                                   <X>\n*------- ESTAE EXIT (ABEND EXIT) --------------------------------* <X>\n         CNOP  0,8                                                 <X>\n         USING *,R12               ESTABLISH LOCAL ADDRESSABILITY  <X>\n         USING XWAREA,R9                                           <X>\nXABEND   L     R8,XWMYSV           \"MYSAVE\" ADDRESS                <X>\n         USING SAVE2,R8                                            <X>\n         TM    ATTNSW,ATTRSET      IS ATTENTION ROUTINE ACTIVE?    <X>\n         BZ    XABNDX              NO                              <X>\n         NI    ATTNSW,255-ATTRSET-ATTWAIT YES, RESET ALL           <X>\n         LM    R2,R3,XWRST         RESET ATTENTION ROUTINE ENTRY   <X>\n         L     R4,XWATP                                            <X>\n         L     R5,XWUCB                                            <X>\n         XR    R6,R6               NULLIFY ATTENTION INDEX         <X>\n        MODESET MF=(E,SUPRMOD)                                     <X>\n         STM   R2,R3,0(R4)         RESET ATTENTION TABLE ENTRY     <X>\n        IOSGEN TP,UCB=(R5),VAR=ATNMOD,TABLE=(R6) RESET ATTN        <X>\n        MODESET MF=(E,PROBMOD)                                     <X>\nXABNDX  ESTAE  0,TOKEN=XWTOKEN     CANCEL ETPS ESTAE LEVEL         <X>\n         LM    R0,R15,XWXSVR       RESTORE ALL REGISTERS           <X>\n         XR    R15,R15             SET RETURN CODE                 <X>\n         BR    R14                 AND RETURN                      <X>\n         SPACE 1                                                   <X>\n         DROP  R8,R9,R12                                           <X>\n.SKX5    EJECT\n*------- SCREEN FORMATS ---------------------------------------------*\n*  THE BUFFER ALWAYS STARTS WITH A WRITE CONTROL CHARACTER (WCC) :\n*        X'C7' = SOUND ALARM, RESET KEYBOARD, RESET MDT (MODIFIED\n*                DATA TAG) BITS\n*        X'C3' = RESET KEYBOARD, RESET MDT BITS\n*  AFTER THE WCC, FOLLOWS ORDER CODES AND DATA SEQUENCES.\n*  USED ORDERS ARE :\n*        X'11' = SET BUFFER ADDRESS (SBA), FOLLOWED BY 2-BYTE BUFFER\n*                ADDRESS\n*        X'13' = INSERT CURSOR (IC)\n*        X'1D' = START FIELD (SF), FOLLOWED BY 1-BYTE ATTRIBUTE CHAR.\n         SPACE 1\n*- - - - LOGON SCREEN\n         CNOP  0,4\nLOGSCR   DC    A(LOGSC1)\n         DC    A(LNEBLK)\n         DC    A(LOGSC2)\n         DC    A(LOGSC3)\n         DC    A(LOGSC4)\n         DC    A(LOGSC5)\n         DC    A(LOGSC6)\n         DC    A(LOGSC7)\n         DC    A(LOGSC8)\n         DC    A(LOGSC9)\n         DC    A(LOGSC10)\n         DC    A(LOGSC11)\n         DC    A(LOGSC12)\n         DC    A(LOGSC13)\n         DC    A(LOGSC14)\n         DC    A(LNEBLK)\nCRLUSC   EQU   (*-LOGSCR)/4        CURSOR ROW ON LINE BELOW\nZIL      EQU   (*-LOGSCR)+4        \"TERMINPT\" DISPLACEMENT\n         DC    A(LOGSC15)\nCRLPSC   EQU   (*-LOGSCR)/4        CURSOR ROW ON LINE BELOW\n         DC    A(LOGSC16)\nCRLGSC   EQU   (*-LOGSCR)/4        CURSOR ROW ON LINE BELOW\n         DC    A(LOGSC17)\n         DC    A(LOGSC18)\n         DC    A(LNEBLK)\n         DC    A(EML+HLPLNE)\n         SPACE 1\nLOGSC1   DC    AL1(LOGSC1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL20' ETPS - LOGON PANEL ',49CL1'-'\nLOGSC1L  EQU   *-LOGSC1\nLOGSC2   DC    AL1(LOGSC2L-1),XL1'04',CL16'    E  T  P  S  '\n*     ----+----1----+----2----+----3----+----4----+----5----+----6\n DC C'                    (((-----)))'\nLOGSC2L  EQU   *-LOGSC2\nLOGSC3   DC    AL1(LOGSC3L-1),XL1'04',CL16'    M  E  R  Y  '\n DC C'                  ** (       )**'\nLOGSC3L  EQU   *-LOGSC3\nLOGSC4   DC    AL1(LOGSC4L-1),XL1'04',CL16'    E  L  O  S  '\n DC C'                 *( (        ) )*'\nLOGSC4L  EQU   *-LOGSC4\nLOGSC5   DC    AL1(LOGSC5L-1),XL1'04',CL16'    R  E  C  T  '\n DC C'               ((                )'\nLOGSC5L  EQU   *-LOGSC5\nLOGSC6   DC    AL1(LOGSC6L-1),XL1'04',CL16'    G     E  E  '\n*     ----+----1----+----2----+----3----+----4----+----5----+----6\n* ===>              (  < (O) > < (O) >   )                        <===\n DC C'              (  <',X'05'\n DC C'(O)',XL1'04'\n DC C'> <',XL1'05'\n DC C'(O)',XL1'04'\n DC C'>   )'\nLOGSC6L  EQU   *-LOGSC6\nLOGSC7   DC    AL1(LOGSC7L-1),XL1'04',CL16'    E     S  M  '\n DC C'               ((       (       )))'\nLOGSC7L  EQU   *-LOGSC7\nLOGSC8   DC    AL1(LOGSC8L-1),XL1'04',CL16'    N     S     '\n DC C'               ((               )))'\nLOGSC8L  EQU   *-LOGSC8\nLOGSC9   DC    AL1(LOGSC9L-1),XL1'04',CL16'    C     I     '\n DC C'                ((((    ___   ))))'\nLOGSC9L  EQU   *-LOGSC9\nLOGSC10  DC    AL1(LOGSC10L-1),XL1'04',CL16'    Y     N     '\n DC C'                 ((((        ))))'\nLOGSC10L EQU   *-LOGSC10\nLOGSC11  DC    AL1(LOGSC11L-1),XL1'04',CL16'          G     '\n DC C'                    ((      ))'\nLOGSC11L EQU   *-LOGSC11\nLOGSC12  DC    AL1(LOGSC12L-1),XL1'04',CL16'                '\n DC C'                      )    / '\nLOGSC12L EQU   *-LOGSC12\nLOGSC13  DC    AL1(LOGSC13L-1),XL1'04',CL16'                '\n         AIF   ('&TXV' NE 'EUROPE').SK3\n DC C'                      |( (|'\n         AGO   .SK4\n.SK3     ANOP\n DC C'                      !( (!'\n.SK4     ANOP\nLOGSC13L EQU   *-LOGSC13\nLOGSC14  DC    AL1(LOGSC14L-1),XL1'04',CL16'                '\n         AIF   ('&TXV' NE 'EUROPE').SK5\n DC C'                      |) )|'\n         AGO   .SK6\n.SK5     ANOP\n DC C'                      !) )!'\n.SK6     ANOP\nLOGSC14L EQU   *-LOGSC14\nLOGSC15  DC    AL1(LOGSC15L-1),XL1'04',CL16'                '\nLUOFF    EQU   *-LOGSC15\n         DC    CL13'ENTER USER-ID',XL1'05',CL4'===>'\nCCLUSC   EQU   *-LOGSC15           CURSOR COLUMN ON FIELD BELOW\nLGSCF1   EQU   (*-LOGSC15)+1,7     INPUT FIELD 1\n         DC    XL1'01',CL7' '      SF = UNPROT\nLTOFF    EQU   (*-LOGSC15)+1\n         DC    XL1'04',CL20' '\nLOGSC15L EQU   *-LOGSC15\nLOGSC16  DC    AL1(LOGSC16L-1),XL1'04',CL16'                '\nLPOFF    EQU   *-LOGSC16\n         DC    CL13'     PASSWORD',XL1'05',CL4'===>'\nCCLPSC   EQU   *-LOGSC16           CURSOR COLUMN ON FIELD BELOW\nLGSCF2   EQU   (*-LOGSC16)+1,8     INPUT FIELD 2\n         DC    XL1'03',CL8' '      SF = UNPROT, NO DISPLAY\n         DC    XL1'04',CL1' '\nLOGSC16L EQU   *-LOGSC16\nLOGSC17  DC    AL1(LOGSC17L-1),XL1'04',CL16'                '\nLGOFF    EQU   *-LOGSC17\n         DC    CL13'   RACF GROUP',XL1'05',CL4'===>'\nCCLGSC   EQU   *-LOGSC17           CURSOR COLUMN ON FIELD BELOW\nLGSCF3   EQU   (*-LOGSC17)+1,8     INPUT FIELD 3\n         DC    XL1'01',CL8' '      SF = UNPROT\n         DC    XL1'04',CL13' '\n         DC    X'04',CL9'VERSION :'\n         DC    X'05',CL8'&VNUM..&VMOD (&VIDT)',XL1'04'\nLOGSC17L EQU   *-LOGSC17\nLOGSC18  DC    AL1(LOGSC18L-1),XL1'05',79CL1'-'\nLOGSC18L EQU   *-LOGSC18\nLNEBLK   DC    AL1(LNEBLKL-1),XL1'04',CL9' ' SF = PROT\nLNEBLKL  EQU   *-LNEBLK\n         EJECT\n*- - - - LOGON HELP SCREEN\n         CNOP  0,4\nLOGHELP  DC    A(LOGHL1)\n         DC    A(HLPENT)\n         DC    A(LOGHL2)\n         DC    A(LOGHL3)\n         DC    A(LOGHL4)\n         DC    A(LOGHL5)\n         DC    A(LNEBLK)\n         DC    A(EML+LOGHL6)\n         SPACE 1\nLOGHL1   DC    AL1(LOGHL1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL20' ETPS - LOGON PANEL ',49CL1'-'\nLOGHL1L  EQU   *-LOGHL1\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\nLOGHL2   DC    AL1(LOGHL2L-1),XL1'05'\n         DC    C'THE ETPS LOGON PANEL IS PROVIDED TO ALLOW A USERID TO X\n               BE ENTERED AND VERIFIED'\nLOGHL2L  EQU   *-LOGHL2\nLOGHL3   DC    AL1(LOGHL3L-1),XL1'05'\n         DC    C'    TO LIMIT THE POSSIBILITY OF UNAUTHORIZED USE.'\nLOGHL3L  EQU   *-LOGHL3\nLOGHL4   DC    AL1(LOGHL4L-1),XL1'05'\n         DC    C'    THE PASSWORD FIELD IS NOT VERIFIED BY ETPS, AS SHIX\n               PPED.'                                      '\nLOGHL4L  EQU   *-LOGHL4\nLOGHL5   DC    AL1(LOGHL5L-1),XL1'05'\n         DC    C'    IF RACF IS INSTALLED, THE RACF GROUP IS THE DEFAULX\n               T ONE IF NOT SUPPLIED.'\nLOGHL5L  EQU   *-LOGHL5\nLOGHL6   DC    AL1(LOGHL6L-1),XL1'05'\n         DC    C'PF3, OR ENTERING \"EOJ\" IN THE USERID FIELD LOGS YOU OFX\n               F.'\nLOGHL6L  EQU   *-LOGHL6\nHLPENT   DC    AL1(HLPENTL-1),XL1'01',CL1' ',XL1'05',CL7' '\nHLPENTL  EQU   *-HLPENT\nHLPLNE   DC    AL1(HLPLNEL-1)\n         DC    XL1'05',C'PF1'\n         DC    XL1'04',C'IS ALWAYS'\n         DC    XL1'05',C'HELP'\nHLPLNEL  EQU   *-HLPLNE\n         EJECT\n*- - - - PRIMARY OPTION MENU SCREEN\n         CNOP  0,4\nPRIMOPT  DC    A(PRIML1)\n         DC    A(PRIML2)\nCRPOSC   EQU   (*-PRIMOPT)/4       CURSOR ROW ON LINE BELOW\nZIP      EQU   (*-PRIMOPT)+4       \"TERMINPT\" DISPLACEMENT\n         DC    A(PRIML3)\n         DC    A(PRIML4)\n         DC    A(PRIML5)\n         DC    A(PRIML6)\n         DC    A(PRIML7)\n         DC    A(PRIML8)\n         DC    A(PRIML9)\n         DC    A(LNEBLK)\n         DC    A(PRIML10)\n         DC    A(EML+HLPLNE)\n         SPACE 1\nPRIML1   DC    AL1(PRIML1L-1)\n         DC    XL1'05',10CL1'-'    SF PROTECTED, HIGH-LIGHT\n         DC    CL28' ETPS - PRIMARY OPTION MENU ',41CL1'-'\nPRIML1L  EQU   *-PRIML1\nPRIML2   DC    AL1(PRIML2L-1)\nPROFF1   EQU   *-PRIML2\n         DC    XL1'04',CL9'USER-ID :' SF PROTECTED\nUOFF     EQU   (*-PRIML2)+1,7\n         DC    XL1'05',CL7' '      SF PROTECTED, HIGH-LIGHT\n         DC    XL1'04',CL1' '      SF PROTECTED\n         DC    XL1'04',CL10'GROUP-ID :' SF PROTECTED\nGROFF    EQU   (*-PRIML2)+1,8\n         DC    XL1'05',CL8' '      SF PROTECTED, HIGH-LIGHT\n         DC    XL1'04',CL10'TERMINAL :' SF PROTECTED\nTERMOFF  EQU   (*-PRIML2)+1,8\n         DC    XL1'05',CL8' '      SF PROTECTED, HIGH-LIGHT\n         DC    XL1'04',CL10' VERSION :' SF PROTECTED\n         DC    XL1'05',CL8'&VNUM..&VMOD (&VIDT)' SF PROTECTED, HIGH-L.\nPRIML2L  EQU   *-PRIML2\nPRIML3   DC    AL1(PRIML3L-1)\nPROFF2   EQU   *-PRIML3\n         DC    XL1'05'             SF PROTECTED, HIGH-LIGHT\n         DC    CL18'SELECT OPTION ===>'\nCCPOSC   EQU   (*-PRIML3)          CURSOR COLUMN ON FIELD BELOW\nPOSCF1   EQU   (*-PRIML3)+1,6      INPUT FIELD 1\n         DC    XL1'01',CL6' '      SF UNPROTECTED\n         DC    XL1'04',CL18' ',CL6'TIME =' SF PROTECTED\nTIMEOFF  EQU   (*-PRIML3)+1,5\n         DC    XL1'05',CL5'  :  '  SF PROTECTED, HIGH-LIGHT\n         DC    XL1'04',CL7' ',CL6'DATE =' SF PROTECTED\nDATEOFF  EQU   (*-PRIML3)+1,8\n         DC    XL1'05',CL8'  /  /  ' SF PROTECTED, HIGH-LIGHT\nPRIML3L  EQU   *-PRIML3\nPRIML4   DC    AL1(PRIML4L-1)\n         DC    XL1'05',CL2' 1'     SF PROTECTED, HIGH-LIGHT\n         DC    XL1'04'             SF PROTECTED\n         DC    CL36'BROWSE DATA '\n         DC    XL1'05',CL2' 2'     SF PROTECTED, HIGH-LIGHT\n         DC    XL1'04'             SF PROTECTED\n         DC    CL36'EDIT SOURCE DATA '\nPRIML4L  EQU   *-PRIML4\nPRIML5   DC    AL1(PRIML5L-1)\n         DC    XL1'05',CL2' 3'     SF PROTECTED, HIGH-LIGHT\n         DC    XL1'04'             SF PROTECTED\n         DC    CL36'LIBRARY UTILITY '\n         DC    XL1'05',CL2' 4'     SF PROTECTED, HIGH-LIGHT\n         DC    XL1'04'             SF   PROTECTED\n         DC    CL36'IDCAMS (VSAM) INTERFACE '\nPRIML5L  EQU   *-PRIML5\nPRIML6   DC    AL1(PRIML6L-1)\n         DC    XL1'05',CL2' 5'     SF PROTECTED, HIGH-LIGHT\n         DC    XL1'04'             SF   PROTECTED\n         DC    CL36'ZAP (DISPLAY/MODIFY DATA-SET) '\n         DC    XL1'05',CL2' 6'     SF PROTECTED, HIGH-LIGHT\n         DC    XL1'04'             SF   PROTECTED\n         DC    CL36'INCORZAP (IN-CORE SUPERZAP FOR MVS) '\nPRIML6L  EQU   *-PRIML6\nPRIML7   DC    AL1(PRIML7L-1)\n         DC    XL1'05',CL2' '      SF PROTECTED, HIGH-LIGHT\n         DC    XL1'04'             SF   PROTECTED\n         DC    CL36' '\n         DC    XL1'05',CL2' '      SF PROTECTED, HIGH-LIGHT\n         DC    XL1'04'             SF   PROTECTED\n         DC    CL36' '\nPRIML7L  EQU   *-PRIML7\nPRIML8   DC    AL1(PRIML8L-1)\n         DC    XL1'05',CL2' '      SF PROTECTED, HIGH-LIGHT\n         DC    XL1'04'             SF   PROTECTED\n         DC    CL36' '\n         DC    XL1'05',CL2' '      SF PROTECTED, HIGH-LIGHT\n         DC    XL1'04'             SF   PROTECTED\n         DC    CL36' '\nPRIML8L  EQU   *-PRIML8\nPRIML9   DC    AL1(PRIML9L-1)\n         DC    XL1'05',CL2' X'     SF PROTECTED, HIGH-LIGHT\n         DC    XL1'04'             SF PROTECTED\n         DC    CL22'EXIT - TERMINATE ETPS '\nMSGOFF1  EQU   *-PRIML9,31\n         DC    CL31'AND RETURN TO THE LOGON PANEL.'\nPRIML9L  EQU   *-PRIML9\nPRIML10  DC    AL1(PRIML10L-1)\n         DC    XL1'04'             SF PROTECTED\n         DC    CL5'PRESS '\n         DC    XL1'05'             SF PROTECTED, HIGH-LIGHT\n         DC    CL3'PF3'\n         DC    XL1'04'             SF PROTECTED\n         DC    CL18'TO TERMINATE ETPS '\nMSGOFF2  EQU   *-PRIML10,34\n         DC    CL34'AND RETURN TO THE LOGON PANEL.'\nPRIML10L EQU   *-PRIML10\n         EJECT\n*- - - - PRIMARY OPTION MENU HELP SCREEN\n         CNOP  0,4\nPOPHELP  DC    A(POPHL1)\n         DC    A(HLPENT)\n         DC    A(POPHL2)\n         DC    A(POPHL3)\n         DC    A(LNEBLK)\n         DC    A(POPHX1)\n         DC    A(LNEBLK)\n         DC    A(POPHL4)\n         DC    A(POPHL5)\n         DC    A(EML+POPHL6)\nPOPHELPA DC    A(POPHL1)\n         DC    A(HLPENT)\n         DC    A(POPHL2)\n         DC    A(POPHL3)\n         DC    A(LNEBLK)\n         DC    A(POPHX2)\n         DC    A(LNEBLK)\n         DC    A(POPHL4)\n         DC    A(POPHL5)\n         DC    A(EML+POPHL6)\n         SPACE 1\nPOPHL1   DC    AL1(POPHL1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL28' ETPS - PRIMARY OPTION MENU ',41CL1'-'\nPOPHL1L  EQU   *-POPHL1\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\nPOPHL2   DC    AL1(POPHL2L-1),XL1'05'\n         DC    C'THE PRIMARY OPTION MENU SHOWS WHAT ETPS FUNCTIONS AVAIX\n               LABLE.'\nPOPHL2L  EQU   *-POPHL2\nPOPHL3   DC    AL1(POPHL3L-1),XL1'05'\n         DC    C'    THE OPTIONS ARE INVOKED BY ENTERING THE OPTION NUMX\n               BER IN THE COMMAND LINE.'\nPOPHL3L  EQU   *-POPHL3\nPOPHL4   DC    AL1(POPHL4L-1),XL1'05'\n         DC    C'GENERAL USE OF SOME PF-PA KEYS :'\nPOPHL4L  EQU   *-POPHL4\nPOPHL5   DC    AL1(POPHL5L-1),XL1'05'\n         DC    C'        PF2=SPLIT SCREEN (HALF)   PF9=SWITCH SCREEN'\nPOPHL5L  EQU   *-POPHL5\nPOPHL6   DC    AL1(POPHL6L-1),XL1'05'\n         DC    C'        PA1=CANCEL PROCESS        PA2=RESHOW SCREEN'\nPOPHL6L  EQU   *-POPHL6\nPOPHX1   DC    AL1(POPHX1L-1),XL1'05'\n         DC    C'PF3, OR ENTERING \"X\" IN THE COMMAND LINE RETURNS TO THX\n               E LOGON PANEL.'\nPOPHX1L  EQU   *-POPHX1\nPOPHX2   DC    AL1(POPHX2L-1),XL1'05'\n         DC    C'PF3, OR ENTERING \"X\" IN THE COMMAND LINE TERMINATES ETX\n               PS.'\nPOPHX2L  EQU   *-POPHX2\n         EJECT\n*- - - - BROWSE ENTRY SCREEN\n         CNOP  0,4\nBROWSCR  DC    A(BRROW1)\n         DC    A(BRROW2)\nCRBRSC   EQU   (*-BROWSCR)/4       CURSOR ROW ON LINE BELOW\nZIB1     EQU   (*-BROWSCR)+4       \"TERMINPT\" DISPLACEMENT\n         DC    A(BRROW3)\nZIB2     EQU   (*-BROWSCR)+4       \"TERMINPT\" DISPLACEMENT\n         DC    A(BRROW4)\n         DC    A(LNEBLK)\nZIB3     EQU   (*-BROWSCR)+4       \"TERMINPT\" DISPLACEMENT\n         DC    A(EML+BRROW5)\n         SPACE 1\nBRROW1   DC    AL1(BRROW1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL22' BROWSE - ENTRY PANEL ',47CL1'-'\nBRROW1L  EQU   *-BRROW1\nBRROW2   DC    AL1(BRROW2L-1)\n         DC    XL1'05',CL30'ENTER/VERIFY PARAMETERS BELOW:'\n         DC    XL1'04',CL1' '\nBRROW2L  EQU   *-BRROW2\nBRROW3   DC    AL1(BRROW3L-1)\nBROFF1   EQU   (*-BRROW3)+1,10\n         DC    XL1'04',CL20'FULLY-QUALIFIED NAME',XL1'05',CL3'==>'\nCCBRSC   EQU   (*-BRROW3)          CURSOR COLUMN ON FIELD BELOW\nBRSCF1   EQU   (*-BRROW3)+1,54     INPUT FIELD 1\n         DC    XL1'02',CL54' '\nBRROW3L  EQU   *-BRROW3\nBRROW4   DC    AL1(BRROW4L-1)\nBROFF2   EQU   (*-BRROW4)+10,13\n         DC    XL1'04',CL22'         VOLUME SERIAL'\n         DC    XL1'05',CL3'==>'\nBRSCF2   EQU   (*-BRROW4)+1,6      INPUT FIELD 2\n         DC    XL1'02',CL6' '\n         DC    XL1'04',CL45'          (IF NOT CATALOGED)'\nBRROW4L  EQU   *-BRROW4\nBRROW5   DC    AL1(BRROW5L-1)\nBROFF3   EQU   (*-BRROW5)+6,17\n         DC    XL1'04',CL22'     DATA-SET PASSWORD'\n         DC    XL1'05',CL3'==>'\nBRSCF3   EQU   (*-BRROW5)+1,8      INPUT FIELD 3\n         DC    XL1'03',CL8' '      NO DISPLAY\n         DC    XL1'04',CL37'        (IF PASSWORD PROTECTED)'\nBROFF4   EQU   (*-BRROW5)+1,3\n         DC    XL1'04',CL3'(N)',XL1'04',CL1' '\nBRROW5L  EQU   *-BRROW5\n         EJECT\n*- - - - BROWSE ENTRY HELP SCREEN\n         CNOP  0,4\nBROHELP  DC    A(BROHL1)\n         DC    A(HLPENT)\n         DC    A(BROHL2)\n         DC    A(BROHL3)\n         DC    A(BROHL4)\n         DC    A(LNEBLK)\n         DC    A(EML+BROHL5)\n         SPACE 1\nBROHL1   DC    AL1(BROHL1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL22' BROWSE - ENTRY PANEL ',47CL1'-'\nBROHL1L  EQU   *-BROHL1\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\nBROHL2   DC    AL1(BROHL2L-1),XL1'05'\n         DC    C'THE BROWSE PANEL PROVIDES FOR ENTERING THE DATA-SET NAX\n               ME, WHICH MUST BE A'\nBROHL2L  EQU   *-BROHL2\nBROHL3   DC    AL1(BROHL3L-1),XL1'05'\n         DC    C'    FULLY-QUALIFIED DS-NAME (NEVER DELIMITED BY QUOTESX\n               ).'\nBROHL3L  EQU   *-BROHL3\nBROHL4   DC    AL1(BROHL4L-1),XL1'05'\n         DC    C'    A SPECIFIC VOL-SER MAY ALSO BE ENTERED, AND A PASSX\n               WORD.'\nBROHL4L  EQU   *-BROHL4\nBROHL5   DC    AL1(BROHL5L-1),XL1'05'\n         DC    C'PF3 RETURNS TO THE PRIMARY OPTION MENU PANEL.'\nBROHL5L  EQU   *-BROHL5\n         EJECT\n*- - - - EDIT ENTRY SCREEN\n         CNOP  0,4\nEDITSCR  DC    A(EDROW1)\n         DC    A(EDROW2)\nCREDSC   EQU   (*-EDITSCR)/4       CURSOR ROW ON LINE BELOW\n         DC    A(EDROW3)\n         DC    A(EDROW4)\n         DC    A(LNEBLK)\n         DC    A(EML+EDROW5)\n         SPACE 1\nEDROW1   DC    AL1(EDROW1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL20' EDIT - ENTRY PANEL ',49CL1'-'\nEDROW1L  EQU   *-EDROW1\nEDROW2   DC    AL1(EDROW2L-1)\n         DC    XL1'05',CL30'ENTER/VERIFY PARAMETERS BELOW:'\n         DC    XL1'04',CL1' '\nEDROW2L  EQU   *-EDROW2\nEDROW3   DC    AL1(EDROW3L-1)\nEDOFF1   EQU   (*-EDROW3)+1,10\n         DC    XL1'04',CL20'FULLY-QUALIFIED NAME',XL1'05',CL3'==>'\nCCEDSC   EQU   (*-EDROW3)          CURSOR COLUMN ON FIELD BELOW\nEDSCF1   EQU   (*-EDROW3)+1,54     INPUT FIELD 1\n         DC    XL1'02',CL54' '\nEDROW3L  EQU   *-EDROW3\nEDROW4   DC    AL1(EDROW4L-1)\nEDOFF2   EQU   (*-EDROW4)+10,13\n         DC    XL1'04',CL22'         VOLUME SERIAL'\n         DC    XL1'05',CL3'==>'\nEDSCF2   EQU   (*-EDROW4)+1,6      INPUT FIELD 2\n         DC    XL1'02',CL6' '\n         DC    XL1'04',CL45'          (IF NOT CATALOGED)'\nEDROW4L  EQU   *-EDROW4\nEDROW5   DC    AL1(EDROW5L-1)\nEDOFF3   EQU   (*-EDROW5)+6,17\n         DC    XL1'04',CL22'     DATA-SET PASSWORD'\n         DC    XL1'05',CL3'==>'\nEDSCF3   EQU   (*-EDROW5)+1,8      INPUT FIELD 3\n         DC    XL1'03',CL8' '      NO DISPLAY\n         DC    XL1'04',CL37'        (IF PASSWORD PROTECTED)'\nEDOFF4   EQU   (*-EDROW5)+1,3\n         DC    XL1'04',CL3'(N)',XL1'04',CL1' '\nEDROW5L  EQU   *-EDROW5\n         SPACE 1\n        CKSCF  BRSCF1,EDSCF1       CHECK : THESE\n        CKSCF  BRSCF2,EDSCF2               VALUES\n        CKSCF  BRSCF3,EDSCF3               MUST BE\n        CKSCF  BROFF1,EDOFF1               EQUALS\n        CKSCF  BROFF2,EDOFF2\n        CKSCF  BROFF3,EDOFF3\n        CKSCF  BROFF4,EDOFF4\n         EJECT\n*- - - - EDIT ENTRY HELP SCREEN\n         CNOP  0,4\nEDTHELP  DC    A(EDTHL1)\n         DC    A(HLPENT)\n         DC    A(EDTHL2)\n         DC    A(EDTHL3)\n         DC    A(EDTHL4)\n         DC    A(LNEBLK)\n         DC    A(EML+EDTHL5)\n         SPACE 1\nEDTHL1   DC    AL1(EDTHL1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL20' EDIT - ENTRY PANEL ',49CL1'-'\nEDTHL1L  EQU   *-EDTHL1\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\nEDTHL2   DC    AL1(EDTHL2L-1),XL1'05'\n         DC    C'THE EDIT PANEL PROVIDES FOR ENTERING THE DATA-SET NAMEX\n               , WHICH MUST BE A'\nEDTHL2L  EQU   *-EDTHL2\nEDTHL3   DC    AL1(EDTHL3L-1),XL1'05'\n         DC    C'    FULLY-QUALIFIED DS-NAME (NEVER DELIMITED BY QUOTESX\n               ).'\nEDTHL3L  EQU   *-EDTHL3\nEDTHL4   DC    AL1(EDTHL4L-1),XL1'05'\n         DC    C'    A SPECIFIC VOL-SER MAY ALSO BE ENTERED, AND A PASSX\n               WORD.'\nEDTHL4L  EQU   *-EDTHL4\nEDTHL5   DC    AL1(EDTHL5L-1),XL1'05'\n         DC    C'PF3 RETURNS TO THE PRIMARY OPTION MENU PANEL.'\nEDTHL5L  EQU   *-EDTHL5\n         EJECT\n*- - - - LIBRARY UTILITY ENTRY SCREEN\n         CNOP  0,4\nUTLMENU  DC    A(UTROW1)\nCRUTSC   EQU   (*-UTLMENU)/4       CURSOR ROW ON LINE BELOW\nZIUE     EQU   (*-UTLMENU)+4       \"TERMINPT\" DISPLACEMENT\n         DC    A(UTROW2)\n         DC    A(UTROW3)\n         DC    A(UTROW4)\n         DC    A(LNEBLK)\n         DC    A(UTROW5)\nCRUTSN   EQU   (*-UTLMENU)/4       CURSOR ROW ON LINE BELOW\nZIU1     EQU   (*-UTLMENU)+4       \"TERMINPT\" DISPLACEMENT\n         DC    A(UTROW6)\nZIU2     EQU   (*-UTLMENU)+4       \"TERMINPT\" DISPLACEMENT\n         DC    A(UTROW7)\n         DC    A(LNEBLK)\nZIU3     EQU   (*-UTLMENU)+4       \"TERMINPT\" DISPLACEMENT\n         DC    A(EML+UTROW8)\n         SPACE 1\nUTROW1   DC    AL1(UTROW1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL23' UTILITY - ENTRY PANEL ',46CL1'-'\nUTROW1L  EQU   *-UTROW1\nUTROW2   DC    AL1(UTROW2L-1)\n         DC    XL1'05'             SF PROTECTED, HIGH-LIGHT\n         DC    CL18'SELECT OPTION ===>'\nCCUTSC   EQU   (*-UTROW2)          CURSOR COLUMN ON FIELD BELOW\nUTSCF1   EQU   (*-UTROW2)+1,6      INPUT FIELD 1\n         DC    XL1'01',CL6' '      SF UNPROTECTED\n         DC    XL1'04',CL1' '\nUTROW2L  EQU   *-UTROW2\nUTROW3   DC    AL1(UTROW3L-1)\n         DC    XL1'04',CL3' ',XL1'05',CL5'BLANK'\n         DC    XL1'04',CL25' - PDS MEMBERS LIST'\n         DC    XL1'05',CL5'    C'\n         DC    XL1'04',CL26' - PDS COMPRESS'\nUTROW3L  EQU   *-UTROW3\nUTROW4   DC    AL1(UTROW4L-1)\n         DC    XL1'04',CL3' ',XL1'05',CL5' '\n         DC    XL1'04',CL25' '\n         DC    XL1'05',CL5'    S'\n         DC    XL1'04',CL26' - DS STATISTICS'\nUTROW4L  EQU   *-UTROW4\nUTROW5   DC    AL1(UTROW5L-1)\n         DC    XL1'05',CL30'ENTER/VERIFY PARAMETERS BELOW:'\n         DC    XL1'04',CL48' '\nUTROW5L  EQU   *-UTROW5\nUTROW6   DC    AL1(UTROW6L-1)\nUTOFF1   EQU   (*-UTROW6)+1,10\n         DC    XL1'04',CL20'FULLY-QUALIFIED NAME',XL1'05',CL3'==>'\nCCUTSN   EQU   (*-UTROW6)          CURSOR COLUMN ON FIELD BELOW\nUTSCF2   EQU   (*-UTROW6)+1,44     INPUT FIELD 2\n         DC    XL1'02',CL44' '\n         DC    XL1'04',CL1' '\nUTROW6L  EQU   *-UTROW6\nUTROW7   DC    AL1(UTROW7L-1)\nUTOFF2   EQU   (*-UTROW7)+10,13\n         DC    XL1'04',CL22'         VOLUME SERIAL'\n         DC    XL1'05',CL3'==>'\nUTSCF3   EQU   (*-UTROW7)+1,6      INPUT FIELD 3\n         DC    XL1'02',CL6' '\n         DC    XL1'04',CL45'          (IF NOT CATALOGED)'\nUTROW7L  EQU   *-UTROW7\nUTROW8   DC    AL1(UTROW8L-1)\nUTOFF3   EQU   (*-UTROW8)+6,17\n         DC    XL1'04',CL22'     DATA-SET PASSWORD'\n         DC    XL1'05',CL3'==>'\nUTSCF4   EQU   (*-UTROW8)+1,8      INPUT FIELD 4\n         DC    XL1'03',CL8' '      NO DISPLAY\n         DC    XL1'04',CL37'        (IF PASSWORD PROTECTED)'\nUTOFF4   EQU   (*-UTROW8)+1,3\n         DC    XL1'04',CL3'(N)',XL1'04',CL1' '\nUTROW8L  EQU   *-UTROW8\n         EJECT\n*- - - - LIBRARY UTILITY ENTRY HELP SCREEN\n         CNOP  0,4\nUTLHELP  DC    A(UTLHL1)\n         DC    A(HLPENT)\n         DC    A(UTLHL2)\n         DC    A(UTLHL3)\n         DC    A(UTLHL4)\n         DC    A(LNEBLK)\n         DC    A(UTLHL5)\n         DC    A(UTLHL6)\n         DC    A(UTLHL7)\n         DC    A(LNEBLK)\n         DC    A(EML+UTLHL8)\n         SPACE 1\nUTLHL1   DC    AL1(UTLHL1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL23' UTILITY - ENTRY PANEL ',46CL1'-'\nUTLHL1L  EQU   *-UTLHL1\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\nUTLHL2   DC    AL1(UTLHL2L-1),XL1'05'\n         DC    C'THE UTILITY PANEL PROVIDES FOR ENTERING THE DATA-SET NX\n               AME, WHICH MUST BE A'\nUTLHL2L  EQU   *-UTLHL2\nUTLHL3   DC    AL1(UTLHL3L-1),XL1'05'\n         DC    C'    FULLY-QUALIFIED DS-NAME (NEVER DELIMITED BY QUOTESX\n               ).'\nUTLHL3L  EQU   *-UTLHL3\nUTLHL4   DC    AL1(UTLHL4L-1),XL1'05'\n         DC    C'    A SPECIFIC VOL-SER MAY ALSO BE ENTERED, AND A PASSX\n               WORD.'\nUTLHL4L  EQU   *-UTLHL4\nUTLHL5   DC    AL1(UTLHL5L-1),XL1'05'\n         DC    C'THE OPTIONS ARE : \" \" FOR PDS MEMBERS LIST,'\nUTLHL5L  EQU   *-UTLHL5\nUTLHL6   DC    AL1(UTLHL6L-1),XL1'05'\n         DC    C'                  \"C\" FOR PDS COMPRESS,'\nUTLHL6L  EQU   *-UTLHL6\nUTLHL7   DC    AL1(UTLHL7L-1),XL1'05'\n         DC    C'                  \"S\" FOR DS STATISTICS.'\nUTLHL7L  EQU   *-UTLHL7\nUTLHL8   DC    AL1(UTLHL8L-1),XL1'05'\n         DC    C'PF3 RETURNS TO THE PRIMARY OPTION MENU PANEL.'\nUTLHL8L  EQU   *-UTLHL8\n         EJECT\n*- - - - LIBRARY MEMBERS DISPLAY HELP SCREEN\n         CNOP  0,4\nLIBHELP  DC    A(LIBHL1)\n         DC    A(HLPENT)\n         DC    A(LIBHL2)\n         DC    A(LIBHL3)\n         DC    A(LIBHL4)\n         DC    A(LIBHL5)\n         DC    A(LIBHL6)\n         DC    A(LIBHL7)\n         DC    A(LIBHL8)\n         DC    A(LNEBLK)\n         DC    A(LIBHL9)\n         DC    A(LIBHL10)\n         DC    A(LIBHL11)\n         DC    A(LIBHL12)\n         DC    A(LNEBLK)\n         DC    A(LIBHL13)\n         DC    A(LIBHL14)\n         DC    A(EML+LIBHL15)\n         SPACE 1\nLIBHL1   DC    AL1(LIBHL1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL20' PDS MEMBER OPTIONS ',49CL1'-'\nLIBHL1L  EQU   *-LIBHL1\nLIBHL2   DC    AL1(LIBHL2L-1),XL1'05'\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\n         DC    C'EXECUTING FUNCTIONS: \"B\"(BROWSE), \"E\"(EDIT) AND \"U\"(UTX\n               ILITY)'\nLIBHL2L  EQU   *-LIBHL2\nLIBHL3   DC    AL1(LIBHL3L-1),XL1'05'\n         DC    C'     S ---  BROWSE MEMBER (WHEN \"B\" AND \"U\"), EDIT MEMX\n               BER (WHEN \"E\")'\nLIBHL3L  EQU   *-LIBHL3\nLIBHL4   DC    AL1(LIBHL4L-1),XL1'05'\n         DC    C'     B ---  BROWSE MEMBER (WHEN \"B\")'\nLIBHL4L  EQU   *-LIBHL4\nLIBHL5   DC    AL1(LIBHL5L-1),XL1'05'\n         DC    C'     E ---  EDIT MEMBER (WHEN \"E\")'\nLIBHL5L  EQU   *-LIBHL5\nLIBHL6   DC    AL1(LIBHL6L-1),XL1'05'\n         DC    C'     D ---  DELETE MEMBER (WHEN \"U\")'\nLIBHL6L  EQU   *-LIBHL6\nLIBHL7   DC    AL1(LIBHL7L-1),XL1'05'\n         DC    C'     R ---  RENAME MEMBER, REQUIRE \"NEWNAME\" (WHEN \"U\"X\n               )'\nLIBHL7L  EQU   *-LIBHL7\nLIBHL8   DC    AL1(LIBHL8L-1),XL1'05'\n         DC    C'     C ---  COPY MEMBER, REQUIRE \"NEWNAME\" (WHEN \"U\")'\nLIBHL8L  EQU   *-LIBHL8\nLIBHL9   DC    AL1(LIBHL9L-1),XL1'05'\n         DC    C'COMMANDS ARE :'\nLIBHL9L  EQU   *-LIBHL9\nLIBHL10  DC    AL1(LIBHL10L-1),XL1'05'\n         DC    C' L(OCATE) OR F(IND) ... (MEMBER NAME OR MEMBER NAMES SX\n               TARTING BY THE CHARACTER'\nLIBHL10L EQU    *-LIBHL10\nLIBHL11  DC    AL1(LIBHL11L-1),XL1'05'\n         DC    CL24' ',C'STRING ...)'\nLIBHL11L EQU   *-LIBHL11\nLIBHL12  DC    AL1(LIBHL12L-1),XL1'05'\n         DC    C' UP, U OR -           / DOWN, D OR +         FOLLOWED X\n               BY \"M\" OR A NUMBER'\nLIBHL12L EQU   *-LIBHL12\nLIBHL13  DC    AL1(LIBHL13L-1),XL1'05'\n         DC    C'SCROLL : P(AGE) BY DEFAULT, H(ALF) OR C(SR)'\nLIBHL13L EQU   *-LIBHL13\nLIBHL14  DC    AL1(LIBHL14L-1),XL1'05'\n         DC    C'PFK''S : 7=UP AND 8=DOWN'\nLIBHL14L EQU   *-LIBHL14\nLIBHL15  DC    AL1(LIBHL15L-1),XL1'05'\n         DC    C'        PF3 RETURNS TO THE PREVIOUS BROWSE, EDIT OR UTX\n               ILITY ENTRY PANEL.'\nLIBHL15L EQU   *-LIBHL15\n         EJECT\n         PRINT &PRS\n        SPLTAREA\n         SPACE 1\n        MYSAVE\n         SPACE 1\n        DIRMASK\n         SPACE 1\n        SPFMT\n         SPACE 1\n        PARMLIST\n         SPACE 1\n        FDATE\n         AIF   ('&EATL' EQ '').SKX6                                <X>\n        XAREA  ,                                                   <X>\n.SKX6    PRINT &PRF\n        CVT    DSECT=YES,LIST=YES\n        IHAPSA DSECT=YES,LIST=YES\n        IEFJESCT ,                 JES VECTOR TABLE\n        IEFJSCVT ,                 SUB-SYSTEM COMM. VECTOR TABLE\n        IHAACEE\n        IHAASCB DSECT=YES,LIST=YES\n        IHAASXB DSECT=YES,LIST=YES\n        IKJTCB\nTIOT     DSECT\n        IEFTIOT1\n        IKJTSB\n        IEZJSCB\n        IEFZB4D0\n        IEFZB4D2\n        IHAPDS PDSBLDL=NO\n        DCBD   DSORG=(PS,PO),DEVD=DA\n        IECSDSL1 (1)\nDSCBLGTH EQU   DS1END-IECSDSL1\n        IEZIOB\n        IHAECB\n         AIF   ('&EATL' EQ '').SKX7                                <X>\n        IEZDEB LIST=YES                                            <X>\n        IECDATB ,                                                  <X>\nATBELL   EQU   *-ATB               ATTENTION TABLE ENTRY LENGTH    <X>\n        IECDIOCM ,                                                 <X>\nUCB      DSECT ,                                                   <X>\n        IEFUCBOB ,                                                 <X>\n        IECDIOSB ,                                                 <X>\n.SKX7    PRINT GEN\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPS$": {"ttr": 9220, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x07O\\x00\\x96\\x07O\\x15#\\x00b\\x00b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-03-14T00:00:00", "modifydate": "1996-03-14T15:23:00", "lines": 98, "newlines": 98, "modlines": 0, "user": "SYSPAJA"}, "text": "//ETPS     JOB (........),'INSTALL   E T P S',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=30\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* MANDATORY : BEFORE YOU EXECUTE THIS JOB, READ THE INSTALLATION    *\n//*             DOCUMENTATION IN MEMBER \"ETPS@\".                      *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* AT ASSEMBLY STEPS BELOW, YOU MAY USE THE SYSPARM TO SELECT :      *\n//*      1. THE PRINT OPTION AS FOLLOWS (ALL MODULES) :               *\n//*         NONE OR OMITTED = NO LIST OF MACROS DEVELOPMENT           *\n//*         SHORT = REDUCED LIST OF MACROS DEVELOPMENT                *\n//*         FULL = LIST ALL MACROS DEVELOPMENT                        *\n//*      2. A MODULE OPTION (FOR SPECIFIC MODULES) :                  *\n//*         A) FOR ETPS, ETPSZAP AND ETPSIZAP                         *\n//*            US OR OMITTED = USE USA DISPLAY CHARACTERS             *\n//*            EU = USE EUROPEAN DISPLAY CHARACTERS                   *\n//*         B) FOR ETPSEDIT                                           *\n//*            NO OR OMITTED = NORMAL EDIT VERSION GENERATION         *\n//*            YES = GENERATE AN EDIT TEST VERSION (VERIFY POINTERS   *\n//*                  CHAINING)                                        *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//AS1     EXEC PAJ4AS6,MBR=ETPS,OPT=',RENT,SYSPARM(SHORT,EU)'\n//LK1     EXEC PAJILKL,OPT=',NCAL,RENT'\n//SYSIN     DD *\n  ENTRY   ETPS\n  SETCODE AC(1)\n  NAME    ETPS(R)\n/*\n//AS2     EXEC PAJ4AS6,MBR=ETPSBROW,OPT=',RENT'\n//LK2     EXEC PAJILKL,OPT=',NCAL,RENT'\n//SYSIN     DD *\n  ENTRY   ETPSBROW\n  SETCODE AC(1)\n  NAME    ETPSBROW(R)\n/*\n//AS3     EXEC PAJ4AS6,MBR=ETPSCOMP,OPT=',RENT'\n//LK3     EXEC PAJILKL,OPT=',NCAL,RENT'\n//SYSIN     DD *\n  ENTRY   ETPSCOMP\n  SETCODE AC(1)\n  NAME    ETPSCOMP(R)\n/*\n//AS4     EXEC PAJ4AS6,MBR=ETPSDSST,OPT=',RENT'\n//LK4     EXEC PAJILKL,OPT=',NCAL,RENT'\n//SYSIN     DD *\n  ENTRY   ETPSDSST\n  SETCODE AC(1)\n  NAME    ETPSDSST(R)\n/*\n//AS5     EXEC PAJ4AS6,MBR=ETPSEDIT,OPT=',RENT'\n//LK5     EXEC PAJILKL,OPT=',NCAL,RENT'\n//SYSIN     DD *\n  ENTRY   ETPSEDIT\n  SETCODE AC(1)\n  NAME    ETPSEDIT(R)\n/*\n//AS6     EXEC PAJ4AS6,MBR=ETPSIDCA,OPT=',RENT'\n//LK6     EXEC PAJILKL,OPT=',NCAL,RENT'\n//SYSIN     DD *\n  ENTRY   ETPSIDCA\n  SETCODE AC(1)\n  NAME    ETPSIDCA(R)\n/*\n//AS7     EXEC PAJ4AS6,MBR=ETPSIZAP,OPT=',RENT,SYSPARM(SHORT,EU)'\n//LK7     EXEC PAJILKL,OPT=',NCAL,RENT'\n//SYSIN     DD *\n  ENTRY   ETPSIZAP\n  SETCODE AC(1)\n  NAME    ETPSIZAP(R)\n/*\n//AS8     EXEC PAJ4AS6,MBR=ETPSMEMC,OPT=',RENT'\n//LK8     EXEC PAJILKL,OPT=',NCAL,RENT'\n//SYSIN     DD *\n  ENTRY   ETPSMEMC\n  SETCODE AC(1)\n  NAME    ETPSMEMC(R)\n/*\n//AS9     EXEC PAJ4AS6,MBR=ETPSMESS,OPT=',RENT'\n//LK9     EXEC PAJILKL,OPT=',NCAL,RENT'\n//SYSIN     DD *\n  ENTRY   ETPSMESS\n  SETCODE AC(1)\n  NAME    ETPSMESS(R)\n/*\n//AS10    EXEC PAJ4AS6,MBR=ETPSUTIL,OPT=',RENT'\n//LK10    EXEC PAJILKL,OPT=',NCAL,RENT'\n//SYSIN     DD *\n  ENTRY   ETPSUTIL\n  SETCODE AC(1)\n  NAME    ETPSUTIL(R)\n/*\n//AS11    EXEC PAJ4AS6,MBR=ETPSZAP,OPT=',RENT,SYSPARM(SHORT,EU)'\n//LK11    EXEC PAJILKL,OPT=',NCAL,RENT'\n//SYSIN     DD *\n  ENTRY   ETPSZAP\n  SETCODE AC(1)\n  NAME    ETPSZAP(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPS$O1": {"ttr": 9223, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95)/\\x00\\x95)/\\x128\\x00/\\x00/\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-10-19T00:00:00", "modifydate": "1995-10-19T12:38:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "SYSPAJA"}, "text": "* HERE FOLLOWS THE ASSEMBLY SYSPARM(...) OPTIONS PROCESS WHICH ALLOWS\n*        YOU TO SELECT :\n*        NONE OR OMITTED = NO LIST OF MACROS DEVELOPMENT\n*        SHORT = REDUCED LIST OF MACROS DEVELOPMENT\n*        FULL = LIST ALL MACROS DEVELOPMENT\n*        HOW TO DEFINE OPTIONS : I.E - SYSPARM(FULL)\n*        IF YOU WANT ADD ANOTHER SELECTION, YOU CAN EASILY DO IT\n*        ADJUSTING BELOW THE STATEMENTS MARKED \"<===\", DEFINE THE NEW\n*        OPT(N) DEFAULT, AND SUPPLY THE NEW OPTION CODING JUST BEFORE\n*        THE COMMENT CARD MARKED \"---> ADD OPTION(S)\".\n         GBLC  &PRS,&PRF                                      <===\n         LCLA  &CN,&CT,&LN,&MX,&SB,&ST\n         LCLC  &OPT(1)                                        <===\n&MX      SETA  1                                              <===\n&OPT(1)  SETC  'NONE'\n&CN      SETA  K'&SYSPARM\n         AIF   (K'&SYSPARM EQ 0).SP99\n&CT      SETA  1\n&SB      SETA  1\n&ST      SETA  &CT\n.SP1     AIF   ('&SYSPARM'(&CT,1) EQ ',').SP2\n&CT      SETA  &CT+1\n         AIF   (&CT LE &CN).SP1\n.SP2     ANOP\n&LN      SETA  &CT-&ST\n         AIF   (&LN EQ 0).SP3\n&OPT(&SB) SETC '&SYSPARM'(&ST,&LN)\n.SP3     ANOP\n&SB      SETA  &SB+1\n         AIF   (&SB GT &MX).SP99\n&CT      SETA  &CT+1\n         AIF   (&CT GT &CN).SP99\n&ST      SETA  &CT\n         AGO   .SP1\n.SP99    AIF   ('&OPT(1)' NE 'FULL').SL1\n&PRS     SETC  'GEN'\n&PRF     SETC  'GEN'\n         AGO   .SL99\n.SL1     AIF   ('&OPT(1)' NE 'SHORT').SL2\n&PRS     SETC  'GEN'\n&PRF     SETC  'NOGEN'\n         AGO   .SL99\n.SL2     ANOP\n&PRS     SETC  'NOGEN'\n&PRF     SETC  'NOGEN'\n* ---> ADD OPTION(S)\n.SL99    ANOP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPS$O2A": {"ttr": 9225, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95)/\\x00\\x95)/\\x12@\\x007\\x007\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-10-19T00:00:00", "modifydate": "1995-10-19T12:40:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "SYSPAJA"}, "text": "* HERE FOLLOWS THE ASSEMBLY SYSPARM(...) OPTIONS PROCESS WHICH ALLOWS\n*        YOU TO SELECT :\n*        1. NONE OR OMITTED = NO LIST OF MACROS DEVELOPMENT\n*           SHORT = REDUCED LIST OF MACROS DEVELOPMENT\n*           FULL = LIST ALL MACROS DEVELOPMENT\n*        2. US OR OMITTED = USE USA DISPLAY CHARACTERS\n*           EU = USE EUROPEAN DISPLAY CHARACTERS\n*        HOW TO DEFINE OPTIONS : I.E - SYSPARM(FULL)\n*                                      SYSPARM(,EU)\n*        IF YOU WANT ADD ANOTHER SELECTION, YOU CAN EASILY DO IT\n*        ADJUSTING BELOW THE STATEMENTS MARKED \"<===\", DEFINE THE NEW\n*        OPT(N) DEFAULT, AND SUPPLY THE NEW OPTION CODING JUST BEFORE\n*        THE COMMENT CARD MARKED \"---> ADD OPTION(S)\".\n         GBLC  &PRS,&PRF,&TXV                                 <===\n         LCLA  &CN,&CT,&LN,&MX,&SB,&ST\n         LCLC  &OPT(2)                                        <===\n&MX      SETA  2                                              <===\n&OPT(1)  SETC  'NONE'\n&OPT(2)  SETC  'US'\n&CN      SETA  K'&SYSPARM\n         AIF   (K'&SYSPARM EQ 0).SP99\n&CT      SETA  1\n&SB      SETA  1\n&ST      SETA  &CT\n.SP1     AIF   ('&SYSPARM'(&CT,1) EQ ',').SP2\n&CT      SETA  &CT+1\n         AIF   (&CT LE &CN).SP1\n.SP2     ANOP\n&LN      SETA  &CT-&ST\n         AIF   (&LN EQ 0).SP3\n&OPT(&SB) SETC '&SYSPARM'(&ST,&LN)\n.SP3     ANOP\n&SB      SETA  &SB+1\n         AIF   (&SB GT &MX).SP99\n&CT      SETA  &CT+1\n         AIF   (&CT GT &CN).SP99\n&ST      SETA  &CT\n         AGO   .SP1\n.SP99    AIF   ('&OPT(1)' NE 'FULL').SL1\n&PRS     SETC  'GEN'\n&PRF     SETC  'GEN'\n         AGO   .SL3\n.SL1     AIF   ('&OPT(1)' NE 'SHORT').SL2\n&PRS     SETC  'GEN'\n&PRF     SETC  'NOGEN'\n         AGO   .SL3\n.SL2     ANOP\n&PRS     SETC  'NOGEN'\n&PRF     SETC  'NOGEN'\n.SL3     ANOP\n&TXV     SETC  'EUROPE'\n         AIF   ('&OPT(2)' EQ 'EU').SL99\n&TXV     SETC  'USA'\n* ---> ADD OPTION(S)\n.SL99    ANOP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPS$O2B": {"ttr": 9227, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95)/\\x00\\x95)/\\x14H\\x008\\x008\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-10-19T00:00:00", "modifydate": "1995-10-19T14:48:00", "lines": 56, "newlines": 56, "modlines": 0, "user": "SYSPAJA"}, "text": "* HERE FOLLOWS THE ASSEMBLY SYSPARM(...) OPTIONS PROCESS WHICH ALLOWS\n*        YOU TO SELECT :\n*        1. NONE OR OMITTED = NO LIST OF MACROS DEVELOPMENT\n*           SHORT = REDUCED LIST OF MACROS DEVELOPMENT\n*           FULL = LIST ALL MACROS DEVELOPMENT\n*        2. NO OR OMITTED = NORMAL EDIT VERSION GENERATION\n*           YES = GENERATE AN EDIT TEST VERSION (VERIFY POINTERS CHAIN)\n*        HOW TO DEFINE OPTIONS : I.E - SYSPARM(FULL)\n*                                      SYSPARM(,YES)\n*        IF YOU WANT ADD ANOTHER SELECTION, YOU CAN EASILY DO IT\n*        ADJUSTING BELOW THE STATEMENTS MARKED \"<===\", DEFINE THE NEW\n*        OPT(N) DEFAULT, AND SUPPLY THE NEW OPTION CODING JUST BEFORE\n*        THE COMMENT CARD MARKED \"---> ADD OPTION(S)\".\n         GBLC  &PRS,&PRF,&TXV                                 <===\n         LCLA  &CN,&CT,&LN,&MX,&SB,&ST\n         LCLC  &OPT(2)                                        <===\n&MX      SETA  2                                              <===\n&OPT(1)  SETC  'NONE'\n&OPT(2)  SETC  'NO'\n&CN      SETA  K'&SYSPARM\n         AIF   (K'&SYSPARM EQ 0).SP99\n&CT      SETA  1\n&SB      SETA  1\n&ST      SETA  &CT\n.SP1     AIF   ('&SYSPARM'(&CT,1) EQ ',').SP2\n&CT      SETA  &CT+1\n         AIF   (&CT LE &CN).SP1\n.SP2     ANOP\n&LN      SETA  &CT-&ST\n         AIF   (&LN EQ 0).SP3\n&OPT(&SB) SETC '&SYSPARM'(&ST,&LN)\n.SP3     ANOP\n&SB      SETA  &SB+1\n         AIF   (&SB GT &MX).SP99\n&CT      SETA  &CT+1\n         AIF   (&CT GT &CN).SP99\n&ST      SETA  &CT\n         AGO   .SP1\n.SP99    AIF   ('&OPT(1)' NE 'FULL').SL1\n&PRS     SETC  'GEN'\n&PRF     SETC  'GEN'\n         AGO   .SL3\n.SL1     AIF   ('&OPT(1)' NE 'SHORT').SL2\n&PRS     SETC  'GEN'\n&PRF     SETC  'NOGEN'\n         AGO   .SL3\n.SL2     ANOP\n&PRS     SETC  'NOGEN'\n&PRF     SETC  'NOGEN'\n.SL3     AIF   ('&OPT(2)' NE 'YES').SL4\n&TXV     SETC  'YES'\n         AGO   .SL99\n.SL4     ANOP\n&TXV     SETC  'NO'\n* ---> ADD OPTION(S)\n.SL99    ANOP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPS@": {"ttr": 9229, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x07O\\x00\\x96\\x07O\\x17\\x00\\x00\\xd6\\x00\\xd6\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-03-14T00:00:00", "modifydate": "1996-03-14T17:00:00", "lines": 214, "newlines": 214, "modlines": 0, "user": "SYSPAJA"}, "text": "1   ==  E  T  P  S  - Emergency Tele-Processing Services  ==  Page  1/5\n\n    Origin : BRIAN COOK (CBT tape 94 DEC, file 353).\n    -------- Then adapted and included :\n             a) the \"ZAP\" TSO-command (ETPSZAP),\n             b) the \"INCORZAP\" program (ETPSIZAP), and\n             c) the \"STATDS\" program (ETPSDSST).\n             Changes done by : MOINIL P.A.\n                               Computing Centre (TP 361)\n                               J.R.C. - Ispra Establishment\n                               21020 Ispra (VA), Italy\n             Remark : all notes below are those of Mr. BRIAN COOK\n                      adjusted for this ETPS version.\n\n    ETPS function :\n    ---------------\n         This program provides some basic Time-Sharing Services when\n    TSO or SPF is unavailable (when the normal subsystems such as\n    JES2, VTAM, TCAM, etc... are not available).\n         If you define it as a sub-system, it can be (and has been,\n    to my great relief) brought up even when JES2 abends, or will not\n    initialize (define it as a secondary subsystem in order to be\n    able to start when JES2 is not available).\n         The basic processing appears much like SPF, as far as the\n    primary option menu and so forth are concerned. The full-screen\n    editor is quite primitive, but should suffice for emergency use.\n    Tube I/O is EXCP, so you don't need BTAM, TCAM, or VTAM/TCAS.\n    Terminals supported are 3278-2, 3278-4, 3279-3B (local IBM 3270).\n    This version is indicated as 2.4 (EU) on the primary option menu.\n         The PRIMARY OPTION MENU has 6 options :\n                1. BROWSE DATA\n                2. EDIT SOURCE DATA\n                3. LIBRARY UTILITY\n                4. IDCAMS (VSAM) INTERFACE\n                5. ZAP (DISPLAY/MODIFY DATA-SET)\n                6. INCORZAP (IN-CORE SUPERZAP FOR MVS)\n         The option 3 LIBRARY UTILITY allows :\n                a) PDS members manipulation (RENAME, COPY, DELETE),\n                b) PDS data-set COMPRESS,\n                c) disk data-set statistics (program STATDS).\n1   ==  E  T  P  S  - Emergency Tele-Processing Services  ==  Page  2/5\n\n    Installation steps :\n    --------------------\n    1. Before assemblies, apply your adjustments to the symbolic source\n       member ETPSDEFS (define ETPS modules local requirements).\n       Pay attention to the following definitions (these are obviously\n       local installation depending) :\n         a) the Attention Table length,\n         b) the Master User/Password,\n         c) the Master User/Password,\n         d) the Sensitive data-set's names prefixes,\n         e) the NUCLEUS/LPA data-set's names, and\n         f) the VIO unit name.\n    2. Then all the JCL to assemble and link-edit with AC(1) in the\n       SYS1.LINKLIB is in the member ETPS$.\n       I strongly suggest that you put ETPS in SYS1.LINKLIB. Why?\n       Because there is little point in an emergency recovery system\n       that depends on all of your LNKLST or APF libraries being\n       available -- that may be the problem you are trying to\n       recover from.\n       Do not strip off the assembly and link-edit JCL without looking\n       at it. It is included for your reference. Note authorization\n       requirements, link-edit attributes, etc...\n    3. Create a PROC to invoke ETPS as a sub-system. You must put it\n       in SYS1.PROCLIB (on your IPL volume, I trust).\n       For example :\n         //ETPS    PROC TRM1=ETPS34AB\n         //* ----- Default is 3279 Mod 3 next to MVS master console\n         //ETPS    EXEC PGM=ETPS,PARM=&TRM1,PERFORM=3,TIME=1440\n       The format of the PARM field is discussed below. As a general\n       rule, you should select a default terminal that is near to the\n       MVS master console. An MCS console can be used, but it must be\n       gen'ed as a 3278/9 and vary'ed off as a console and then on.\n       This is something you can easily forget to do when you are in\n       panic mode, so should probably be avoided, if possible.\n       Note : ETPS has been tested only with local non-SNA IBM 3270's.\n              I have no access to other terminal types. The only models\n              I can test with are 3278-2, 3278-4 and 3279-3B.\n       You cannot submit batch jobs to JES when running as a sub-system\n       (well, it ain't easy, and ETPS doesn't do it).\n       PARM : this program must be invoked with a standard execute-card\n              format PARM. The length must be 8 bytes, as follows :\n              1. The first 4 characters must be \"ETPS\".\n              2. The 5th byte is terminal type.\n                 Valid terminal types are :\n                   2 = 3278 model 2\n                   A = 3278 model 2A (per Wayne Mitchell)\n                   3 = 3279 model 3B\n                   4 = 3278 Model 4\n              3. The last 3 bytes must be the UNIT address of the\n                 terminal. As an example :\n                   //STEP1 EXEC PGM=ETPS,PARM='ETPS49C4'\n                 starts Time-Sharing on a local 3278 model 4 at\n                 address 9C4.\n1   ==  E  T  P  S  - Emergency Tele-Processing Services  ==  Page  3/5\n\n       At J.R.C., our procedure is :\n         //ETPS    PROC TRM1=OPER2B0E,ID=IBMUSER,\n         //             D='DUMMY,',U=DISK,V=USER00,P=2,S=1,N=\n         //*        ==> \"OPER\" in place of \"ETPS\" = bypass LOGON panel\n         //*            Default is 3179 Mod 2 in CONSOLE room\n         //*            3179 - ETPS2B0E is in CONSOLE room\n         //*            3179 - ETPS2B2A is in CONSOLE room\n         //*            3279 - ETPS3B0D is in AMDAHL room\n         //ETPSX   EXEC PGM=ETPS,PARM=&TRM1,TIME=1440\n         //STEPLIB   DD UNIT=3380,VOL=SER=CLIB04           <-- Private\n         //             DSN=SYSPAJA.EXEC.LOAD,DISP=SHR     <-- Library\n         //SYSUDUMP  DD &D.UNIT=&U,\n         //             VOL=SER=&V,\n         //             DSN=&ID..ETPSDUMP.DATA&N,\n         //             SPACE=(CYL,(&P,&S)),\n         //             DCB=(RECFM=VBA,BLKSIZE=1632,LRECL=125),\n         //             DISP=(,DELETE,CATLG)\n    4. Create a PROC to invoke ETPS as a normal started task. Put it in\n       SYS1.PROCLIB, preferably. For example :\n         //ETPSJOB PROC TRM1=ETPS34AB\n         //* ----- Default is 3279 Mod 3 next to MVS master console\n         //ETPS    EXEC PGM=ETPS,PARM=&TRM1,PERFORM=3,TIME=1440\n       This second PROC is just in case JES has come up, so that you\n       can submit batch jobs, but the rest of the system may be not be\n       \"up\" far enough to allow you to log onto TSO.\n       At J.R.C., our procedure is :\n         //ETPSSTC PROC TRM1=OPER2B0E,ID=IBMUSER,\n         //             D='DUMMY,',U=DISK,V=USER00,P=2,S=1,N=\n         //*        ==> \"OPER\" in place of \"ETPS\" = bypass LOGON panel\n         //*            Default is 3179 Mod 2 in CONSOLE room\n         //*            3179 - ETPS2B0E is in CONSOLE room\n         //*            3179 - ETPS2B2A is in CONSOLE room\n         //*            3279 - ETPS3B0D is in AMDAHL room\n         //ETPSX   EXEC PGM=ETPS,PARM=&TRM1,TIME=1440\n         //STEPLIB   DD DSN=SYSPAJA.EXEC.LOAD,DISP=SHR   <-- Priv.Lib.\n         //SYSUDUMP  DD &D.UNIT=&U,\n         //             VOL=SER=&V,\n         //             DSN=&ID..ETPSDUMP.DATA&N,\n         //             SPACE=(CYL,(&P,&S)),\n         //             DCB=(RECFM=VBA,BLKSIZE=1632,LRECL=125),\n         //             DISP=(,DELETE,CATLG)\n    5. If you want to run ETPS under TSO, install the program \"ETPSTSO\"\n       into an APF library available to your tso session.\n       Why would you want to do this ?\n       One reason is that ETPS is intended to be used in emergencies.\n       Do you really want to wait until then to start becoming familiar\n       with your recovery tools? When the system is in the bag, I don't\n       want to learn the quirks of a TP system, I mainly want to get\n       the system back up. I suggest a few minutes with the editor\n       might be useful for basic familiarization.\n       The JCL to only assemble and link-edit the TSO module with AC(1)\n       in the SYS1.CMDLIB is in member ETPSTSO$.\n       Note : see ETPSTSO symbolic source to look how to use the SNAP\n              facility when running under TSO.\n1   ==  E  T  P  S  - Emergency Tele-Processing Services  ==  Page  4/5\n\n    6. Define \"ETPS\" as a sub-system. It is not actually a sub-system,\n       but that doesn't matter as long as MVS thinks it is. You can\n       either update your SYSGEN, ZAP it into your sub-system names\n       table, or as I do, put it in \"SYS1.PARMLIB(IEFSSN01)\".\n       At J.R.C., we have added the name ETPS in the member IEFSSN00\n       of the SYS1.PARMLIB.\n       Update your security system. We have RACF, and ETPS is defined\n       to be able to alter all \"SYS1\" stuff, and also has \"SPECIAL\". I\n       don't know what you would have to do for ACF2, or the other\n       systems. Be sure to add both started task names to ICHRIN03, if\n       you have RACF.\n       Note : since writing the above, we have removed RACF, and\n              installed ACF2. We do not check security in started tasks,\n              however, so I can't provide any further guidelines.\n       At J.R.C., ETPS and ETPSSTC have been defined in RACF module\n       ICHRIN03 of the SYS1.LPALIB.\n       If you want to run ETPS under TSO, after the program \"ETPSTSO\"\n       is installed into an APF library available to your tso session,\n       define it as an authorized command in \"SYS1.PARMLIB(IKJTSO00)\".\n       At J.R.C., we have added the name ETPSTSO as authorized command\n       in the member IKJTSO00 of the SYS1.PARMLIB.\n    7. I strongly suggest that you test this on stand-alone time. One\n       installation tried ETPS during the day, lost their consoles and\n       had to re-IPL. Others have had no problems.\n       Check it out for yourself.\n       At J.R.C., we have had no problems.\n1   ==  E  T  P  S  - Emergency Tele-Processing Services  ==  Page  5/5\n\n    OPERATIONAL note :\n       ETPS is implemented as a started task, and is defined as a\n       sub-system in \"SYS1.PARMLIB(IEFSSN01)\". It will start without\n       JES being active. The JCL is just an EXEC card, so the chances\n       of a JCL error are minimal. Also, if put in \"SYS1.PROCLIB\", it\n       should always be start-able, unless that library is damaged.\n       It is started from the console by entering :\n         S ETPS,TRM1=ETPS34AB    (This is the default terminal)\n                         3       indicates a 3279-3B\n                          4AB    CHANNEL and UNIT address\n    LOGGING ON and OFF :\n       The first thing the program does is prompt for a USER-ID and\n       PASSWORD (when not in TSO and PARM=ETPS.... in EXEC card).\n       The USER-ID is compared to a list of valid USER-ID's. This\n       should be changed to check against UADS, maybe (see the member\n       \"ETPSDEFS\").\n       The PASSWORD is not currently validated in any way, but is used\n       as the default PASSWORD for DATASET allocations (it is not the\n       RACF password):\n         The LOGON menu looks like :\n           ENTER USERID ==>_            (only those valid)\n               PASSWORD ==>             (default DATASET password)\n             RACF GROUP ==>             (optional, should be \"SYS1\")\n       To shut down, enter \"EOJ\" in the USER-ID field, or hit PF-key 3.\n       If \"LOGON\" is successful, the primary option menu (as in SPF) is\n       displayed, and the user can begin processing.\n    A special note on PF-key 9 : when in split-screen mode, you must\n       use the PF-key 9 to switch from one screen to another.\n       Just moving the cursor doesn't get it.\n    ETPS is not SPF, but it is very similar, and so, I suggest the use\n       of the PF-key 1 (HELP) to know what you can do at any time.\n\n                          G O O D     L U C K\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPSBROW": {"ttr": 9473, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x07?\\x00\\x96\\x07?\\x14X\\x05\\xb4\\x05\\xb4\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-03-13T00:00:00", "modifydate": "1996-03-13T14:58:00", "lines": 1460, "newlines": 1460, "modlines": 0, "user": "SYSPAJA"}, "text": "BROW     TITLE '--- E T P S -- ETPSBROW - DATA-SET BROWSE ---'\n         PRINT OFF\n         COPY  ETPS$O1             \"ETPS\" SYSPARM SELECTION\n         COPY  ETPSMACS            \"ETPS\" MACROS\n         COPY  ETPSDEFS            \"ETPS\" DEFINITIONS\n         PRINT ON\nETPSBROW START 0\n         SPACE 1\nETPSBROW AMODE 24\nETPSBROW RMODE 24\n        MIDENT\n         EJECT\n*------- AT ENTRY, R1 = A(PARM.LIST) -> (DCB,\n*                                        DS-NAME,\n*                                        MEMBER-NAME)\n         SPACE 1\n         PRINT GEN\n         USING *,R12,R11\n         USING SAVE3,R13      ************************** R13 ==> SAVE3\n         USING SPLTAREA,R10   AT ENTRY : R10 MUST POINT TO \"SPLTAREA\"\n         B     32(,R15)\n         DC    CL28'  ETPSBROW &SYSDATE &SYSTIME'\n         PRINT &PRF\n         STM   R14,R12,12(R13)     SAVE INPUT REGISTERS\n         LR    R12,R15             SET PROGRAM BASE REGISTER 1\n         LA    R3,1\n         LA    R11,4*KB-1(R3,R12)  SET PROGRAM BASE REGISTER 2\n         LR    R3,R10              SPLIT-SCREEN DSECT\n         SH    R3,=Y(SPLITWRK-SAVE3) POINT TO SAVE3\n         ST    R13,4(,R3)          STORE BACKWARD POINTER\n         ST    R3,8(R13)           STORE FORWARD POINTER\n         LR    R13,R3              SET DSECT BASE\n         LM    R2,R4,0(R1)         PICK UP ALL PARMS\n*                                  R2=DCB ADDRESS\n*                                  R3=DS-NAME ADDRESS\n*                                  R4=MEMBER-NAME ADDRESS\n         XR    R14,R14\n         CLI   0(R3),C' '          IS THERE A DSNAME?\n         BE    BBHLT1              NO\n         LA    R14,44              YES, FIND LENGTH\n         LA    R1,43(R3)\n         CLI   0(R1),C' '\n         BNE   *+L'*+6\n         BCTR  R1,0\n         BCT   R14,*-10\nBBHLT1   XR    R15,R15\n         CLI   0(R4),C' '          IS THERE A MEMBER NAME?\n         BE    BBHLT2              NO\n         LA    R15,8               YES, FIND LENGTH\n         LA    R1,7(R4)\n         CLI   0(R1),C' '\n         BNE   *+L'*+6\n         BCTR  R1,0\n         BCT   R15,*-10\nBBHLT2   LA    R1,BRHDLN           BUILD BROWSE HEAD LINE TEXT\n         LTR   R14,R14\n         BZ    BBHLT3\n         BCT   R14,*+L'*+6\n         MVC   0(*-*,R1),0(R3)     <<EXECUTED>>\n         EX    R14,*-6\n         LA    R1,1(R1,R14)\nBBHLT3   LTR   R15,R15\n         BZ    BBHLT4\n         MVI   0(R1),C'('\n         BCT   R15,*+L'*+6\n         MVC   1(*-*,R1),0(R4)     <<EXECUTED>>\n         EX    R15,*-6\n         LA    R1,2(R1,R15)\n         MVI   0(R1),C')'\n         LA    R1,1(R1)\nBBHLT4   LA    R0,BRHDLN+L'BRHDLN-1\n         CLR   R1,R0\n         BH    *+L'*+12\n         MVI   0(R1),C'-'\n         LA    R1,1(R1)\n         B     *-14\n         MVI   BRSTSW,0\n         MVI   BRFSSW,0\n         MVI   BRFUSW,0\n*- - - - DO INITIALIZATION\n         LR    R4,R2               SET UP THE DCB\n         USING IHADCB,R4\n         LM    R0,R1,DCBDDNAM      SAVE DDNAME\n         MVC   0(BRODCBL,R4),BRODCB\n         STM   R0,R1,DCBDDNAM      SET DDNAME\n         LA    R15,DYNEOD\n         STCM  R15,B'0111',DCBEODA\n         LA    R15,DYNSYNAD\n         STCM  R15,B'0111',DCBSYNA\n         LA    R15,DYNEXLST\n         STCM  R15,B'0111',DCBEXLSA\n         LA    R1,DYNDCBEX\n         ST    R1,0(,R15)\n         MVI   0(R15),X'05'\n         LA    R1,DYNABEND\n         ST    R1,4(,R15)\n         MVI   4(R15),X'91'        OPEN ABEND EXIT (MVS)\n         OI    BRSTSW,STOPEN       TELL CLEANUP TO CLOSE DCB\n         MVI   OPCLPL,VLB          SET \"VL\" BIT\n        OPEN   ((R4),INPUT),MF=(E,OPCLPL)\n         TM    DCBOFLGS,DCBOFOPN\n         BO    OKOPEN\n         LA    R1,MSG11\n         TM    BRSTSW,STNOMEM      MEMBER NOT FOUND?\n         BO    XSETSM              YES, BRANCH\n         LA    R1,MSG10\n         B     XSETSM\n*- - - - TESTING THE RECFM FOR RECFM V OR F REQUIRES AT LEAST 2 TESTS\n*              BECAUSE BOTH THE V AND F BITS ARE ON WHEN RECFM IS U.\n*        THIS ROUTINE MAKES A COPY OF THE RECFM BITS AND ZEROES BOTH\n*              THE V AND F BITS IN THE COPY IF THE RECFM IS U.\n*        NOW WE CAN DETERMINE RECFM V OR F IN ONE TEST INSTEAD OF TWO.\n         CNOP  0,4\nDYNDCBEX MVC   WRKRECFM,DCBRECFM   COPY RECFM\n         MVC   TSTRECFM,DCBRECFM   COPY RECFM\n         TM    WRKRECFM,DCBRECU    RECFM U?\n         BNOR  R14                 NO, BRANCH\n         NI    TSTRECFM,255-DCBRECU YES, SET BOTH BITS OFF\n         BR    R14\n         CNOP  0,4\n*- - - - DCB ABEND ROUTINE         R2 -> R13 = AS OPEN ... ISSUED.\nDYNABEND TM    3(R1),B'00000100'   OPTION MASK = OK TO IGNORE?\n         BZ    ABENDX              NO, BRANCH\n         L     R8,0(,R1)           YES, GET COMPLETION CODE\n         N     R8,=A(X'FFF0FF00')\n         CL    R8,=A(X'01301800')  IS IT AN 013-18 ABEND?\n         BNE   ABENDX              NO, BRANCH\n         OI    BRSTSW,STNOMEM      YES, INDICATE MEMBER NOT FOUND\n         NI    3(R1),B'11110101'   OK TO IGNORE ONLY\n         BR    R14                 RETURN\nABENDX   NI    3(R1),B'11110001'   NO, IMMMEDIATE ABEND\n         BR    R14                 RETURN\n*- - - - SET UP THE BUFFER AREA\nOKOPEN   MVC   DYNDECBW(DYNDECBL),DYNDECB\n         LH    R0,DCBBLKSI\n         AH    R0,=H'7'            ROUND\n         N     R0,=A(X'FFFFFFF8')  UPWARDS TO MULTIPLE OF 8\n         ST    R0,SAVBLKSI         SAVE FOR PARTITIONING\n         XR    R0,R0\n         TM    TSTRECFM,DCBRECV+DCBRECSB VS OR VBS?\n         BNO   NOTSPAN             NO, BRANCH\n         LH    R0,DCBLRECL         GET LRECL\n         AH    R0,=H'7'            ROUND\n         N     R0,=A(X'FFFFFFF8')  UPWARDS TO MULTIPLE OF 8\n         LTR   R0,R0               WAS LRECL ZERO?\n         BNZ   *+L'*+4             NO, SKIP NEXT INSTR\n         L     R0,SAVBLKSI         YES, USE BLKSIZE ROUNDED\n         A     R0,=A(2*KB)         ADD 2K IN CASE LRECL IS WRONG\nNOTSPAN  ST    R0,SAVSPANL         SAVE FOR PARTITIONING\n         LH    R0,DCBBLKSI\n         LTR   R0,R0\n         BNZ   *+L'*+4\n         LH    R0,DCBLRECL\n         STH   R0,RECSIZE\n         AH    R0,=H'7'            ROUND\n         N     R0,=A(X'FFFFFFF8')  UPWARDS TO MULTIPLE OF 8\n         CH    R0,=H'1000'         IS LRECL GREATER THAN MAX?\n         BNH   *+L'*+4             NO, SKIP NEXT INSTR\n         LH    R0,=H'1000'         YES, HELD RECORDS MUST BE TRUNCATED\n         ST    R0,SAVLRECL         SAVE FOR HOLD AREA DIVISION\n         MH    R0,SCROWS+2\n         ST    R0,SAVHOLDL         SAVE FOR PARTITIONING\n         A     R0,SAVSPANL         COMBINE LENGTHS FOR GETMAIN\n         A     R0,SAVBLKSI         COMBINE LENGTHS FOR GETMAIN\n         A     R0,=A(200*CHKPTLEN) PLUS ROOM FOR 200 CHECKPOINTS\n         LA    R7,BRRANGE\n         ST    R0,0(,R7)\n         A     R0,=A(824*CHKPTLEN) OPTIONAL ROOM UP TO 1024 CHECKPOINTS\n         ST    R0,4(,R7)\n         LA    R8,BRANSWER\n         MVC   GMVCW(GMVCL),GMVC\n        GETMAIN VC,LA=(R7),A=(R8),MF=(E,GMVCW)\n         LTR   R15,R15             HOW COMPLETE?\n         BNZ   GMERR               ERROR\n         OI    BRSTSW,STGMVC\n         LM    R0,R1,BRANSWER      ADDRESS - LENGTH\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R0,R14              CLEAR ALL TO BINARY ZEROS\n         L     R1,BRANSWER\n         LR    R0,R1\n         A     R0,BRANSWER+4\n         ST    R0,ENDPTR           END OF GETMAINED AREA\n         ST    R1,BLOCKPTR\n         A     R1,SAVBLKSI         POINT PAST BLOCK AREA\n         ST    R1,SPANPTR\n         A     R1,SAVSPANL         POINT PAST SPANNED RECORD AREA\n         ST    R1,HOLDPTR\n         A     R1,SAVHOLDL         POINT PAST HOLD AREA\n         ST    R1,CHKPTTOP\n         XC    0(CHKPTLEN,R1),0(R1) FIRST ENTRY IN TABLE\n         XC    CHKPTDUM(CHKPTLEN),CHKPTDUM\n         XC    DEBLOCKS(3*L'DEBLOCKS),DEBLOCKS\n         XC    BRCOUNT,BRCOUNT\n         XC    BROFFSET,BROFFSET\n         L     R0,SCROWS1          LINES PER PAGE SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+4             NO\n         L     R0,SCROWS2          LINES PER PAGE SCREEN 2\n         SH    R0,=Y(CRBWDT)\n         STH   R0,BRSCROLL\n         XR    R0,R0\n         ST    R0,FNDNUM\n         STH   R0,FNDOFF\n         ST    R0,CHKPTBOT\n         OI    BRFUSW,BRASSW       SET DEFAULT ASIS\n*- - - - INITIALIZE HOLD AREA DIRECTORY\n         LA    R7,HOLDDIR\n         XR    R0,R0\n         L     R15,HOLDPTR\n         TM    TSTRECFM,DCBRECV    RECFM V?\n         BZ    *+L'*+4             NO\n         LA    R15,4(,R15)         YES, POINT 4 BYTES INTO EACH RECORD\n         L     R8,SCROWS           MAX ROWS PER SCREEN\nHOLDLOOP ST    R0,DIRNUM(,R7)      PUT ZERO IN RECORD NUMBER\n         ST    R0,DIRLEN(,R7)      PUT ZERO IN RECORD LENGTH\n         ST    R15,DIRREC(,R7)     STORE ADDRESS OF HELD RECORD\n         A     R15,SAVLRECL        POINT TO NEXT HELD RECORD\n         LA    R1,DIRSIZE(R7)      POINT TO NEXT ENTRY\n         ST    R1,DIRNXT(,R7)      STORE ITS ADDRESS IN THIS ENTRY\n         LR    R14,R7              SAVE LAST ENTRY\n         LR    R7,R1               MAKE NEXT ENTRY THIS ENTRY\n         BCT   R8,HOLDLOOP         DO IT FOR ALL BUT LAST ENTRY\n         LA    R1,HOLDDIR          ADDRESS OF FIRST ENTRY\n         ST    R1,DIRNXT(,R14)     CLOSE THE CIRCLE\n         ST    R1,HOLDTOP          START WITH FIRST AS TOP\n         BAL   R14,FILLHOLD\n*- - - - SET UP THE SCREEN HEADER LINE 1\nFILLSCR  LA    R1,TERMOUT+4        POINT TO START\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+12            NOPE, JUST GO DO IT\n         L     R14,SCROWS1         PICK UP NUMBER OF ROWS ON SCREEN 1\n         SLL   R14,2               MULTIPLY BY 4\n         LA    R1,TERMOUT+4(R14)   POINT TO START\n         ST    R1,TERMTOP          FIRST ROW (HEADING LINE)\n         NI    0(R1),255-EOS       CLEAR END-OF-SCREEN\n         L     R14,0(,R1)          PICK UP ADDRESS OF LINE 1\n         MVC   0(BROSHLL,R14),BROSHL SET LINE 1 OF HEADING\n         MVC   DSNMNM(L'DSNMNM,R14),BRHDLN MOVE IN DSN(MEM) NAME\n         LA    R15,SCRCOL(,R14)    SET COLUMNS NUMBERS DISPLAYED\n         MVC   0(8,R15),=CL8' '\n         LH    R1,BROFFSET\n         LA    R0,80(,R1)\n         LA    R1,1(,R1)\n         TM    BRMODE,MODEX\n         BZ    *+L'*+4\n         SH    R0,=H'40'\n         CH    R0,RECSIZE\n         BNH   *+L'*+4\n         LH    R0,RECSIZE\n         CVD   R1,BRDBLW\n         OI    BRDBLW+7,X'0F'\n         CH    R1,=H'1000'\n         BL    FILLDIG\n         UNPK  0(4,R15),BRDBLW+5(3)\n         CVD   R0,BRDBLW\n         OI    BRDBLW+7,X'0F'\n         UNPK  5(3,R15),BRDBLW+6(2)\n         B     BRHEAD\nFILLDIG  UNPK  0(3,R15),BRDBLW+6(2)\n         CVD   R0,BRDBLW\n         OI    BRDBLW+7,X'0F'\n         UNPK  4(3,R15),BRDBLW+6(2)\n*- - - - SET UP THE COMMAND LINE\nBRHEAD   L     R1,TERMTOP          FIRST ROW\n         LA    R5,4(,R1)           POINT TO SECOND ROW\n         NI    0(R5),255-EOS       CLEAR END-OF-SCREEN\n         L     R14,0(,R5)          PICK UP ADDRESS OF LINE 4\n         MVC   0(BROHDL,R14),BROHD\n         TM    BRFSSW,BRINSW\n         BZ    STSCRLL\n         L     R3,TERMINPT+ZIBD    COMMAND LINE\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+12            NOPE\n         L     R3,SCROWS1          PICK UP SIZE OF SCREEN 1\n         SLL   R3,2                MULTIPLY BY 4\n         L     R3,TERMINPT+ZIBD(R3) PICK UP RESPONSES\n         CLI   0(R3),0             COMMAND ENTERED?\n         BE    STSCRLL             NO\n         TM    BWSCF1-1(R3),INFMOD COMMAND ENTERED?\n         BZ    STSCRLL             NO\n         MVC   BWSCF1(L'BWSCF1,R14),BWSCF1(R3) YES, COPY INPUT COMMAND\nSTSCRLL  TM    BRFUSW,BRCRSW\n         BZ    *+L'*+10\n         MVC   BWSCF2(L'BWSCF2,R14),=CL4'CSR'\n         B     *+L'*+24\n         TM    BRFUSW,BRHLSW\n         BZ    *+L'*+10\n         MVC   BWSCF2(L'BWSCF2,R14),=CL4'HALF'\n         B     *+L'*+6\n         MVC   BWSCF2(L'BWSCF2,R14),=CL4'PAGE'\n*- - - - SET UP THE COLUMN HEADER LINE\n         L     R1,TERMTOP          FIRST ROW\n         LA    R1,4*2(,R1)         POINT TO THIRD ROW\n         NI    0(R1),255-EOS       CLEAR END-OF-SCREEN\n         L     R14,0(,R1)          PICK UP ADDRESS OF LINE 2\n         MVI   0(R14),80           SET LENGTH = 80\n         MVI   1(R14),C' '\n         MVC   2(79,R14),1(R14)\n         LA    R6,1(,R14)\n         LH    R1,BROFFSET\n         LTR   R1,R1               IS OFFSET ZERO?\n         BNZ   *+L'*+4             NO\n         MVI   0(R6),C'1'          YES, SPECIAL CASE, 1\n         XR    R0,R0\n         LA    R14,10\n         DR    R0,R14\n         SR    R14,R0              10 MINUS REMAINDER\n         LTR   R0,R0               WAS REMAINDER 0?\n         BZ    *+L'*+2             YES, USE 0, NOT 10\n         LR    R0,R14\n         LR    R14,R6\n         AR    R14,R0              ADD (0 TO 9) TO LINE\n         BCTR  R14,0               START AT LINE-1 FOR OFFSET 0\n*                                  LINE+8 FOR OFFSET 1\n*                                  LINE+7 FOR OFFSET 2\n*                                  LINE+6 FOR OFFSET 3\n*                                  LINE+0 FOR OFFSET 9\n         LH    R1,BROFFSET\n         AR    R1,R0               ADD (0 TO 9) TO OFFSET\n         LA    R0,9\nCOLNUML  CH    R1,RECSIZE\n         BH    COLNUMX\n         CVD   R1,BRDBLW\n         MVC   COLNUM,=XL6'402020202120'\n         ED    COLNUM,BRDBLW+5\n         CH    R1,=H'10000'        10000-32768?\n         BNL   COLNUMN             YES, USE NNNNN\n         MVC   COLNUM(5),COLNUM+1\n         MVI   COLNUM+5,C' '\n         CH    R1,=H'100'          100-999?\n         BNL   COLNUMN             YES, USE XNNNX\n         MVC   COLNUM(5),COLNUM+1  USE XNNXX\n         MVI   COLNUM+5,C' '\nCOLNUMN  SH    R14,=H'2'\n         CR    R14,R6\n         BL    *+L'*+6\n         MVC   0(5,R14),COLNUM+1\n         LA    R14,12(,R14)\n         TM    BRMODE,MODEX\n         BO    *+L'*+8\n         AH    R1,=H'10'\n         B     *+L'*+4\n         AH    R1,=H'5'\n         BCT   R0,COLNUML\n*- - - - DONE SETTING UP THE COLUMNS, NOW DRAW THE SCALE LINE\nCOLNUMX  L     R1,TERMTOP          FIRST ROW\n         LA    R5,4*3(,R1)         POINT TO FOURTH ROW\n         NI    0(R5),255-EOS       CLEAR END-OF-SCREEN\n         L     R6,0(,R5)           PICK UP ADDRESS OF LINE 3\n         MVI   0(R6),80            SET LENGTH = 80\n         MVI   1(R6),C' '\n         MVC   2(79,R6),1(R6)      FILL LINE WITH BLANKS\n         LH    R1,BROFFSET\n         XR    R0,R0\n         TM    BRMODE,MODEX\n         BO    *+L'*+8\n         LA    R14,10\n         B     *+L'*+4\n         LA    R14,5\n         CLR   R1,R14\n         BL    *+L'*+4\n         DR    R0,R14\n         LR    R1,R0\n         LR    R14,R1\n         TM    BRMODE,MODEX\n         BO    *+L'*+8\n         AL    R14,=A(MARKS)\n         B     *+L'*+6\n         AR    R14,R1\n         AL    R14,=A(MARKH)\n         LH    R1,RECSIZE\n         SH    R1,BROFFSET\n         CH    R1,=H'80'\n         BNH   *+L'*+4\n         LH    R1,=H'80'\n         BCT   R1,*+L'*+6\n         MVC   1(*-*,R6),0(R14)    <<EXECUTED>>\n         EX    R1,*-6\n*- - - - FILL IN THE DATA AREA OF THE SCREEN\n         L     R7,HOLDTOP\n         L     R8,SCROWS1          PICK UP NUMBER OF ROWS\n         CLI   SPLIT,2             AM I IN SPLIT SCREEN?\n         BNE   *+L'*+4             NOPE, JUST GO DO IT\n         L     R8,SCROWS2          MUST BE SCREEN 2\n         SH    R8,=Y(CRBWDT)       MINUS FIRST 4 ROWS = MAX LINES\nFILLOOP  LA    R5,4(,R5)\n         NI    0(R5),255-EOS       CLEAR END-OF-SCREEN\n         L     R6,0(,R5)           PICK UP TERMOUT POINTER\n         MVI   0(R6),80            SET LENGTH = 80\n         MVI   1(R6),C' '\n         MVC   2(80,R6),1(R6)      FILL LINE WITH BLANKS\n         LA    R6,1(,R6)           BUMP PAST LENGTH\n         LM    R1,R2,DIRLEN(R7)    GET LENGTH AND ADDRESS\n         LTR   R1,R1\n         BM    FILBOT\n         BNZ   *+L'*+10\n         MVC   0(6,R6),=CL6'(NULL)'\n         B     FILLNEXT\n         SH    R1,BROFFSET         IS OFFSET BEYOND END OF RECORD\n         BNP   FILLNEXT            YES, LEAVE LINE BLANK\n         AH    R2,BROFFSET\n         TM    BRMODE,MODEX\n         BO    FILLHEX\n         CH    R1,=H'80'\n         BNH   *+L'*+4\n         LH    R1,=H'80'\n         BCT   R1,*+L'*+6\n         MVC   0(*-*,R6),0(R2)     <<EXECUTED>>\n         EX    R1,*-6\n         TM    BRFUSW,BRASSW       ASIS?\n         BO    *+L'*+8             YES\n         L     R15,=A(CAPST)       NO\n         B     *+L'*+4\n         L     R15,=A(ASIST)\n         TR    0(80,R6),0(R15)     TRANSLATE UNVIEWABLE CHARACTERS\n         B     FILLNEXT\nFILLHEX  CH    R1,=H'40'\n         BNH   *+L'*+4\n         LH    R1,=H'40'\n         LR    R0,R1\n         LR    R1,R2\n         LR    R15,R6\nHEXLOOP  MVC   1(1,R15),0(R1)      MOVE BYTE\n         UNPK  0(3,R15),1(2,R15)   UNPACK\n         TR    0(2,R15),HEXTAB-C'0'\n         LA    R15,2(,R15)         INCREMENT OUTPUT PTR\n         LA    R1,1(,R1)           INCREMENT INPUT PTR\n         BCT   R0,HEXLOOP          DECREMENT LENGTH, THEN LOOP\n         MVI   0(R15),C' '         BLANK THE TRAILING BYTE\nFILLNEXT L     R7,DIRNXT(,R7)\n         BCT   R8,FILLOOP\nFILLED   CLI   SPLIT,1             AM I ON SCREEN 1?\n         BE    FILLEND             YES, DON'T SET FLAG\nFILSETL  OI    0(R5),EOS           SET END-OF-SCREEN\n         B     FILLEND\nFILBOT   MVI   0(R6),C'*'\n         MVC   1(79,R6),0(R6)\n         MVC   32(16,R6),=CL16' BOTTOM OF DATA '\n         BCT   R8,*+L'*+4\n         B     FILLED\n         CLI   SPLIT,1             AM I ON SCREEN 1?\n         BNE   FILSETL             NO\nFILBOTL  LA    R5,4(,R5)           YES, COMPLETE SCREEN\n         NI    0(R5),255-EOS       CLEAR END-OF-SCREEN\n         L     R6,0(,R5)           PICK UP TERMOUT POINTER\n         MVI   0(R6),80            SET LENGTH = 80\n         MVI   1(R6),C' '\n         MVC   2(80,R6),1(R6)      FILL LINE WITH BLANKS\n         BCT   R8,FILBOTL\nFILLEND  L     R15,=A(BROHELP)     DEFAULT HELP SCREEN\n         ST    R15,HELPADD\n         MVI   CURROW,CRBWSC       CURSOR ROW\n         MVI   CURCOL,CCBWSC       CURSOR COLUMN\n         TM    BRFUSW,BRASSW       ASIS?\n         BZ    *+L'*+4             NO\n         OI    PRCSSW,ASISFLG      YES, SET ASIS FOR INPUT\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         NI    PRCSSW,255-ASISFLG  RESET ASIS FOR INPUT\n         LTR   R15,R15             BAD RC?\n         BNZ   XEND                OUT\n*- - - - SCREEN MAY HAVE CHANGED\n         L     R0,SCROWS1          LINES PER PAGE SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+4             NO\n         L     R0,SCROWS2          LINES PER PAGE SCREEN 2\n         SH    R0,=Y(CRBWDT)\n         STH   R0,BRSCROLL\n*- - - - CHECK REPLY FROM THE TERMINAL\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    XEND                YES\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BE    XEND                YES\n         CLI   0(R2),X'6C'         IS IT PA1?\n         BE    XEND                YES\n         CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    FILLSCR             YUP, RESHOW\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    FILLSCR             YUP, RESHOW\n*- - - - CHECK IF SCROLL MODE MODIFIED\n         L     R3,TERMINPT+ZIBD    COMMAND LINE\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+12            NOPE\n         L     R3,SCROWS1          PICK UP SIZE OF SCREEN 1\n         SLL   R3,2                MULTIPLY BY 4\n         L     R3,TERMINPT+ZIBD(R3) PICK UP RESPONSES\n         CLI   0(R3),0             COMMAND ENTERED?\n         BE    NOSCRLL             NO\n         TM    BWSCF2-1(R3),INFMOD SCROLL ENRERED?\n         BZ    NOSCRLL             NO\n         LA    R14,BWSCF2(,R3)\n         LA    R0,L'BWSCF2\n         CLI   0(R14),C' '\n         BNE   *+L'*+12\n         LA    R14,1(,R14)\n         BCT   R0,*-12\n         B     *+L'*+18            NONE, CLEARED\n         MVI   BRDBLW,C' '\n         OC    BRDBLW(1),0(R14)\n         NI    BRFUSW,255-BRHLSW-BRCRSW RESET TO PAGE\n         CLI   BRDBLW,C'H'\n         BNE   *+L'*+8\n         OI    BRFUSW,BRHLSW       SET HALF\n         B     NOSCRLL\n         CLI   BRDBLW,C'C'\n         BNE   NOSCRLL\n         OI    BRFUSW,BRCRSW       SET CURSOR\nNOSCRLL  NI    BRFSSW,255-BRINSW-FPFKSW-MAXUSW-MAXDSW\n         TM    COMMSW,PFKFLAG      PF-KEY?\n         BZ    NOPFK\n*------- INTERPRET PROGRAM FUNCTION KEY -----------------------------*\n         OI    0(R2),X'30'         MAKE PFK 13-24 LOOK LIKE 1-12\n         CLI   0(R2),X'7A'         PF10-22?\n         BE    LEFT\n         CLI   0(R2),X'7B'         PF11-23?\n         BE    RIGHT\n         CLI   0(R2),X'F5'         PF5-17?\n         BNE   *+L'*+8\n         OI    BRFSSW,FPFKSW\n         B     NOPFK\n         CLI   0(R2),X'F7'         PF7-19?\n         BNE   *+L'*+8\n         OI    BRFSSW,MAXUSW\n         B     NOPFK\n         CLI   0(R2),X'F8'         PF8-20?\n         BNE   *+L'*+8\n         OI    BRFSSW,MAXDSW\n         B     NOPFK\n         LA    R1,MSG21\nSETMSGA  ST    R1,MSGADD\n         B     FILLSCR\nNOPFK    CLI   0(R3),0             COMMAND ENTERED?\n         BE    GOBACK              NO\n         TM    BWSCF1-1(R3),INFMOD COMMAND ENRERED?\n         BO    CKCMDIN             YES\nGOBACK   TM    BRFSSW,FPFKSW+MAXUSW+MAXDSW PF5-PF7-PF8?\n         BZ    FILLSCR             NOPE, JUST RESHOW THE SCREEN\n         TM    BRFSSW,FPFKSW\n         BO    FINDDEF\n         TM    BRFSSW,MAXUSW\n         BO    UPDEF\n         B     DOWNDEF\nCKCMDIN  LA    R14,BWSCF1(,R3)\n         LA    R0,L'BWSCF1\n         CLI   0(R14),C' '\n         BNE   *+L'*+12\n         LA    R14,1(,R14)\n         BCT   R0,*-12\n         B     GOBACK              NONE\n         TM    BRFSSW,FPFKSW       PF5?\n         BO    FINDTST             YES\n         TM    BRFSSW,MAXUSW       PF7?\n         BO    UPTST               YES\n         TM    BRFSSW,MAXDSW       PF8?\n         BO    DOWNTST             YES\n         MVC   BRDBLW,=CL8' '\n         OC    BRDBLW(L'BRDBLW),0(R14)\n*- - - - PUT TESTS FOR COMMAND LINE HERE BELOW\n         CLC   BRDBLW(4),=CL4'LEFT'\n         BE    LEFT\n         CLI   BRDBLW,C'L'\n         BE    LEFT\n         CLI   BRDBLW,C'<'\n         BE    LEFT\n         CLC   BRDBLW(5),=CL5'RIGHT'\n         BE    RIGHT\n         CLI   BRDBLW,C'R'\n         BE    RIGHT\n         CLI   BRDBLW,C'>'\n         BE    RIGHT\n         CLC   BRDBLW(2),=CL2'UP'\n         BE    UP1\n         CLI   BRDBLW,C'U'\n         BE    UP2\n         CLI   BRDBLW,C'-'\n         BE    UP2\n         CLC   BRDBLW(4),=CL4'DOWN'\n         BE    DOWN1\n         CLI   BRDBLW,C'D'\n         BE    DOWN2\n         CLI   BRDBLW,C'+'\n         BE    DOWN2\n         CLC   BRDBLW(4),=CL4'TOP '\n         BE    TOP\n         CLI   BRDBLW,C'T'\n         BE    TOP\n         CLC   BRDBLW(7),=CL7'BOTTOM '\n         BE    BOTTOM\n         CLC   BRDBLW(4),=CL4'BOT '\n         BE    BOTTOM\n         CLI   BRDBLW,C'B'\n         BE    BOTTOM\n         CLC   BRDBLW(5),=CL5'FIND '\n         BE    FIND1\n         CLC   BRDBLW(2),=CL2'F '\n         BE    FIND2\n         CLC   BRDBLW(4),=CL4'END '\n         BE    XEND\n         CLI   BRDBLW,C'X'\n         BE    XEND\n         CLC   BRDBLW(5),=CL5'ASIS '\n         BE    ASIS\n         CLI   BRDBLW,C'A'\n         BE    ASIS\n         CLC   BRDBLW(5),=CL5'CAPS '\n         BE    CAPS\n         CLI   BRDBLW,C'C'\n         BE    CAPS\n         CLC   BRDBLW(4),=CL4'HEX '\n         BE    HEXMODE\n         CLI   BRDBLW,C'H'\n         BE    HEXMODE\nINVLCMD  LA    R1,MSG20\n         B     SETMSGA\n*- - - - RIGHT - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nRIGHT    LH    R15,=H'80'\n         TM    BRMODE,MODEX\n         BZ    *+L'*+4\n         LH    R15,=H'40'\n         LH    R0,BROFFSET\n         AR    R0,R15              NEW-OFFSET\n         LH    R1,RECSIZE\n         CH    R1,=H'1000'\n         BNH   *+L'*+4\n         LH    R1,=H'1000'\n         SR    R1,R15              GET RECSIZE-OFFSET\n         BNM   *+L'*+2             IF RECSIZE IS LESS THAN OFFSET\n         XR    R1,R1                 THEN RECSIZE-OFFSET IS ZERO\n         CLR   R0,R1               IF NEW-OFFSET GT RECSIZE-OFFSET\n         BNH   *+L'*+2               THEN\n         LR    R0,R1                   USE RECSIZE-OFFSET\n         STH   R0,BROFFSET\n         B     FILLSCR\n*- - - - LEFT  - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nLEFT     LH    R15,=H'80'\n         TM    BRMODE,MODEX\n         BZ    *+L'*+4\n         LH    R15,=H'40'\n         LH    R0,BROFFSET\n         SR    R0,R15              NEW-OFFSET\n         BNM   *+L'*+2             IF RESULT NOT NEGATIVE, OK\n         XR    R0,R0               OTHERWISE, MAKE IT ZERO\n         STH   R0,BROFFSET\n         B     FILLSCR\n*- - - - BOTTOM  - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nBOTTOM   XR    R0,R0\n         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER\n         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET\n         L     R0,=F'99999999'     BOTTOM NINES\n         B     LISTAT\n*- - - - DOWN  - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nDOWN1    LA    R1,4\n         B     DOWNCK\nDOWN2    LA    R1,1\nDOWNCK   AR    R14,R1              POINT TO POSSIBLE OPERAND\n         SR    R0,R1\n         BNP   DOWNDEF\n         CLI   0(R14),C' '\n         BNE   DOWNTST\n         LA    R14,1(,R14)\n         BCT   R0,*-12\n         B     DOWNDEF             NONE, USE DEFAULT RANGE\nDOWNTST  MVI   BRDBLW,C' '\n         OC    BRDBLW(1),0(R14)\n         CLI   BRDBLW,C'M'         OK, MAX?\n         BE    BOTTOM              YES\n         CLI   0(R14),C'0'         NO, NUMERIC?\n         BL    INVLCMD             NO\n         LA    R15,1(R14)          OK, SOME NUMERIC VALUE WAS\n         LA    R1,1                ENTERED, FIND OUT WHAT IT IS...\nDOWNLP   BCT   R0,*+L'*+4\n         B     DOWNDO\n         CLI   0(R15),C' '         SEARCH FOR END?\n         BE    DOWNDO              YES\n         CLI   0(R15),C'0'         NO, NUMERIC?\n         BL    INVLCMD             NO\n         LA    R1,1(,R1)           BUMP 1\n         LA    R15,1(,R15)         BUMP 1\n         B     DOWNLP              LOOP IF MORE\nDOWNDO   CH    R1,=H'6'            EXPRESSED NUMBER TOO HIGH?\n         BH    DOWNDEF             YES, USE DEFAULT RANGE\n         BCTR  R1,0\n         EX    R1,PACKBRO          PACK INTO \"BRDBLW\"\n         OI    BRDBLW+7,X'0F'      MAKE POSITIVE\n         CVB   R0,BRDBLW           PUT BINARY VALUE IN R0\n         B     DOWNRGE             USE RANGE IN R0\nDOWNDEF  LH    R0,BRSCROLL\n         TM    BRFUSW,BRCRSW       CURSOR?\n         BZ    DOWNHLF             NO\n         L     R14,TERMINPT        PICK UP AID/ROW/COL ADDRESS\n         XR    R15,R15\n         IC    R15,1(R14)          GET ROW NUMBER\n         SH    R15,=Y(CRBWDT)\n         BNP   DOWNRGE\n         LR    R0,R15\n         B     DOWNRGE\nDOWNHLF  TM    BRFUSW,BRHLSW       HALF PAGE?\n         BZ    DOWNRGE             NO\n         SRL   R0,1                YES\nDOWNRGE  ST    R0,DOWNAMT\n         XR    R0,R0\n         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER\n         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET\n         BAL   R14,DOWNER\n         B     FILLSCR             FILL THE SCREEN\n*- - - - TOP   - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nTOP      BAL   R14,DOTOP           GO TO DO IT\n         B     FILLSCR\n*- - - - UP    - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nUP1      LA    R1,2\n         B     UPCK\nUP2      LA    R1,1\nUPCK     AR    R14,R1              POINT TO POSSIBLE OPERAND\n         SR    R0,R1\n         BNP   UPDEF\n         CLI   0(R14),C' '\n         BNE   UPTST\n         LA    R14,1(,R14)\n         BCT   R0,*-12\n         B     UPDEF               NONE, USE DEFAULT RANGE\nUPTST    MVI   BRDBLW,C' '\n         OC    BRDBLW(1),0(R14)\n         CLI   BRDBLW,C'M'         OK, MAX?\n         BE    TOP                 YES\n         CLI   0(R14),C'0'         NO, NUMERIC?\n         BL    INVLCMD             NO\n         LA    R15,1(R14)          OK, SOME NUMERIC VALUE WAS\n         LA    R1,1                ENTERED, FIND OUT WHAT IT IS...\nUPLP     BCT   R0,*+L'*+4\n         B     UPDO\n         CLI   0(R15),C' '         SEARCH FOR END?\n         BE    UPDO                YES\n         CLI   0(R15),C'0'         NO, NUMERIC?\n         BL    INVLCMD             NO\n         LA    R1,1(,R1)           BUMP 1\n         LA    R15,1(,R15)         BUMP 1\n         B     UPLP                LOOP IF MORE\nUPDO     CH    R1,=H'6'            EXPRESSED NUMBER TOO HIGH?\n         BH    UPDEF               YES, USE DEFAULT RANGE\n         BCTR  R1,0\n         EX    R1,PACKBRO          PACK INTO \"BRDBLW\"\n         OI    BRDBLW+7,X'0F'      MAKE POSITIVE\n         CVB   R0,BRDBLW           PUT BINARY VALUE IN R0\n         B     UPRANGE             USE RANGE IN R0\nUPDEF    LH    R0,BRSCROLL\n         TM    BRFUSW,BRCRSW       CURSOR?\n         BZ    UPHALF              NO\n         L     R14,TERMINPT        PICK UP AID/ROW/COL ADDRESS\n         XR    R15,R15\n         IC    R15,1(R14)          GET ROW NUMBER\n         LA    R14,CRBWDT-1\n         SR    R15,R14\n         BNP   UPRANGE\n         SR    R0,R15\n         B     UPRANGE\nUPHALF   TM    BRFUSW,BRHLSW       HALF PAGE?\n         BZ    UPRANGE             NO\n         SRL   R0,1                YES\nUPRANGE  ST    R0,DOWNAMT\n         XR    R0,R0\n         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER\n         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET\n         L     R7,HOLDTOP\n         CLC   DIRNUM(4,R7),=F'1'  ARE WE AT TOP ALREADY?\n         BNH   FILLSCR             YES, BRANCH\n         TM    DIRLEN(R7),EOL      IS FIRST LINE END-OF-LIST?\n         BZ    *+L'*+10            NO, BRANCH\n         OC    BRCOUNT,BRCOUNT     IS DATA SET EMPTY?\n         BZ    FILLSCR             YES, BRANCH\n         L     R0,DIRNUM(,R7)      GET RECORD NUMBER OF TOP LINE\n         S     R0,DOWNAMT          GET RECORD NUMBER TO GO BACK TO\n         BP    LISTAT              IF POSITIVE, OK\n         LA    R0,1                ELSE THEN MAKE IT 1\nLISTAT   ST    R0,LISTNUM\n         LA    R15,CHKPTLEN        LENGTH OF CHKPT ENTRY\n         L     R1,CHKPTBOT\n         TM    0(R1),EOL           IS IT END-OF-LIST?\n         BZ    LISTCK\n         CL    R1,CHKPTTOP         IS DATA SET EMPTY?\n         BE    FILLSCR             YES\n         SR    R1,R15              NO, BACK UP ONE ENTRY\nLISTCK   CL    R0,0(,R1)           DOES THIS BLOCK CONTAIN OUR RECORD?\n         BNL   LISTPNT             YES, GO POINT TO IT\n         CL    R1,CHKPTTOP         HAVE I BACKED UP TO TOP?\n         BE    FILLSCR             YES\n         SR    R1,R15              NO, BACK UP ONE BLOCK ENTRY\n         B     LISTCK              CONTINUE\nLISTPNT  MVC   BRCOUNT,0(R1)\n         MVC   DEBLOCKS(3*L'DEBLOCKS),8(R1)\n         MVC   BRTTR,4(R1)         TTR OF FIRST BLOCK\n         MVC   BRTTRZ(3),BRTTR\n        POINT  (R4),BRTTRZ\n         L     R14,SPANPTR\n         XR    R0,R0\n         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH\n         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER\n         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET\n         BAL   R14,FILLHOLD        READ NEXT RECORDS\nLISTFINE L     R7,HOLDTOP          GET ENTRY FOR TOP OF HOLD AREA\n         TM    DIRLEN(R7),EOL      IS END-OF-LIST ON TOP OF SCREEN?\n         BZ    LISTCONT            NO, WE ARE NOT FINISHED\n         CLC   LISTNUM,=F'99999999' WAS THIS A LIST 99999999?\n         BNE   FILLSCR             NO\n         LH    R0,BRSCROLL         YES\n         TM    BRFUSW,BRHLSW       HALF PAGE?\n         BZ    *+L'*+4             NO\n         SRL   R0,1                YES\n         BCTR  R0,0\n         B     UPRANGE\nLISTCONT CLC   LISTNUM,DIRNUM(R7)  IS REQUESTED NUMBER AT TOP?\n         BNH   FILLSCR             YES, BRANCH\n         MVC   DOWNAMT,=F'1'       SET DOWN 1\n         BAL   R14,DOWNER\n         B     LISTFINE\n*- - - - FIND  - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nFIND1    LA    R1,5\n         B     FINDCK\nFIND2    LA    R1,2\nFINDCK   AR    R14,R1              POINT TO POSSIBLE OPERAND\n         SR    R0,R1\n         BNP   FINDDEF\n         CLI   0(R14),C' '\n         BNE   FINDTST\n         LA    R14,1(,R14)\n         BCT   R0,*-12\nFINDDEF  TM    BRFSSW,FSTRSW       HAS A STRING BEEN ENTERED?\n         BO    FINDGO              YES\n         LA    R1,MSG31            NO, ERROR\n         B     SETMSGA\nFINDTST  LA    R15,BWSCF1+L'BWSCF1-1(R3) FIND END OF STRING DEFINITION\n         CLI   0(R15),C' '\n         BNE   *+L'*+4\n         BCT   R15,*-8\n         NI    BRFSSW,255-FSTRSW   NULLIFY PREVIOUS\n         MVC   BRDBLW(2),=CL8' '\n         OC    BRDBLW(2),0(R14)\n         CLC   BRDBLW(2),=CL2'X''' HEX-STRING?\n         BE    FINDHEX             YES\n         CLI   0(R14),X'80'        NO, CHAR-STRING\n         BNL   *+L'*+16\n         CLC   0(1,R14),0(R15)\n         BNE   *+L'*+6\n         LA    R14,1(R14)\n         BCTR  R15,0\n         SR    R15,R14\n         BNP   STRNLL\n         LA    R0,L'BRSTRNG\n         CLR   R15,R0\n         BH    STLONG\n         MVI   BRSTRNG,C' '\n         MVC   BRSTRNG+1(L'BRSTRNG-1),BRSTRNG\n         EX    R15,*+L'*+8\n         STH   R15,BRSTRNGL\n         B     FINDSET\n         MVC   BRSTRNG(*-*),0(R14) <<EXECUTED>>\nSTRNLL   LA    R1,MSG34\n         B     SETMSGI\nSTLONG   LA    R1,MSG35\n         B     SETMSGI\nINVHXD   LA    R1,MSG36\n         B     SETMSGI\nHXSMIS   LA    R1,MSG37\n         B     SETMSGI\nNHXSTR   LA    R1,MSG38\n         B     SETMSGI\nHXSTRO   LA    R1,MSG39\nSETMSGI  OI    BRFSSW,BRINSW\n         B     SETMSGA\nVHXRTN   XR    R1,R1               VERIFY HEX-DIGIT LOCAL ROUTINE\n         LA    R14,1(R14)          R7 = LOCAL LINK REGISTER\n         IC    R1,0(R14)\n         OR    R1,R5\n         STC   R1,BRDBLW\n         CLI   BRDBLW,C'A'\n         BL    INVHXD\n         CLI   BRDBLW,C'F'\n         BH    *+L'*+8\n         LA    R1,9(R1)\n         B     VHXRTN1\n         CLI   BRDBLW,C'0'\n         BL    INVHXD\n         CLI   BRDBLW,C'9'\n         BH    INVHXD\nVHXRTN1  NR    R1,R6\n         BR    R7\nFINDHEX  CLI   0(R15),C''''        LAST QUOTE TYPED?\n         BNE   *+L'*+2             NO\n         BCTR  R15,0               YES, BACK ONE\n         LA    R14,1(R14)\n         CLR   R15,R14\n         BL    HXSMIS\n         BE    NHXSTR\n         SR    R15,R14\n         LA    R0,2*L'BRSTRNG\n         CLR   R15,R0\n         BH    STLONG\n         LR    R0,R15\n         SRL   R0,1\n         SLL   R0,1\n         CLR   R15,R0\n         BNE   HXSTRO\n         SRL   R0,1\n         LR    R15,R0\n         BCTR  R15,0\n         STH   R15,BRSTRNGL\n         MVI   BRSTRNG,C' '\n         MVC   BRSTRNG+1(L'BRSTRNG-1),BRSTRNG\n         LA    R15,BRSTRNG\n         LA    R5,X'40'\n         LA    R6,X'0F'\nFINDHXL  BAL   R7,VHXRTN\n         LR    R2,R1\n         SLL   R2,4\n         BAL   R7,VHXRTN\n         OR    R1,R2\n         STC   R1,0(R15)\n         LA    R15,1(R15)\n         BCT   R0,FINDHXL\nFINDSET  OI    BRFSSW,FSTRSW\n         XR    R0,R0\n         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER\n         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET\nFINDGO   TM    FNDOFF,EOL          BOTTOM (END-OF-LIST) REACHED?\n         BZ    *+L'*+4             NO\n         BAL   R14,DOTOP           YES, RESTART FROM TOP\n         MVI   FNDWA,C' '          PREPARE COMPARE STRING\n         MVC   FNDWA+1(L'FNDWA-1),FNDWA\n         MVI   CRDWA,C' '\n         LH    R14,BRSTRNGL        GET LENGTH CODE OF STRING\n         TM    BRFUSW,BRASSW       ASIS?\n         BZ    *+L'*+8             NO\n         EX    R14,CUCFSTR         YES, COPY AND UPPERCASE\n         B     *+L'*+4\n         EX    R14,CPYFSTR         COPY\n         L     R7,HOLDTOP          GET INFO FOR FIRST HELD RECORD\n         L     R0,DIRNUM(,R7)      GET RECORD NUMBER OF FIRST HELD\n         L     R1,FNDNUM           GET RECORD NUMBER WHERE LAST FOUND\n         LTR   R1,R1               HAS IT BEEN FOUND?\n         BNP   FINDSCR             NO, START WITH HELD RECORDS\n         CLR   R0,R1               ARE WE PAST LAST FOUND REC?\n         BH    FINDSCR             YES, START WITH HELD RECORDS\n         L     R14,HOLDEND\n         L     R15,DIRNUM(,R14)    GET RECORD NUMBER OF LAST HELD\n         CLR   R1,R15              IS LAST FOUND REC ON SCREEN?\n         BH    FINDDOWN            NO, BRANCH\nFINDPREV CL    R1,DIRNUM(,R7)      IS THIS RECORD WHERE LAST FOUND?\n         BE    FINDPCOL            YES, BRANCH\n         CL    R7,HOLDEND          IS THIS LAST RECORD ON SCREEN?\n         BE    FINDDOWN            SHOULD NOT HAPPEN\n         L     R7,DIRNXT(,R7)      POINT TO NEXT RECORD\n         B     FINDPREV\nFINDPCOL L     R15,DIRREC(,R7)     POINT TO RECORD\n         AH    R15,FNDOFF          POINT TO LAST FOUND STRING\n         LA    R15,1(,R15)         POINT PAST LAST FOUND STRING\n         B     FINDSTR\nFINDDOWN MVC   DOWNAMT,=F'1'       SET DOWN 1\n         BAL   R14,DOWNER\n         L     R7,HOLDEND\nFINDSCR  TM    DIRLEN(R7),EOL      ARE WE AT END-OF-LIST?\n         BO    FINDNOTF            YES\n         L     R15,DIRREC(,R7)     POINT TO FIRST BYTE TO EXAMINE\nFINDSTR  L     R0,DIRLEN(,R7)      GET LENGTH OF RECORD\n         CL    R0,SAVLRECL         IS RECORD TRUNCATED?\n         BNH   *+L'*+4             NO, SKIP NEXT INSTR\n         L     R0,SAVLRECL         YES, USE TRUNCATED LENGTH\n         L     R1,DIRREC(,R7)      GET ADDRESS OF RECORD\n         AR    R0,R1               POINT PAST LAST BYTE OF RECORD\n         LH    R14,BRSTRNGL        GET LENGTH CODE OF STRING\n         AR    R15,R14             POINT TO LAST BYTE TO BE COMPARED\n         SR    R0,R15              GET NUMBER OF COMPARISONS\n         BNP   FINDNEXT            STRING TOO LONG FOR REMAINING TEXT\n         SR    R15,R14             PUT STRING ADDRESS BACK\nFINDLOOP MVC   CRDWA+1(L'FNDWA),CRDWA\n         EX    R14,UPPERDT         SET DATA\n         EX    R14,FINDCLC         COMPARE DATA TO STRING\n         BE    FOUND\n         LA    R15,1(,R15)         INCREMENT DATA POINTER\n         BCT   R0,FINDLOOP         GO COMPARE AGAIN\nFINDNEXT CL    R7,HOLDEND          WAS THAT LAST HELD RECORD?\n         BE    FINDDOWN            YES, BRANCH\n         L     R7,DIRNXT(,R7)      POINT TO NEXT RECORD\n         B     FINDSCR             GO PROCESS NEXT RECORD\nFOUND    MVC   BROWMSG(MSG33L),MSG33\n         LA    R1,BROWMSG\n         ST    R1,MSGADD\n         MVC   FNDNUM,DIRNUM(R7)   SAVE RECORD NUMBER\n         S     R15,DIRREC(,R7)     GET OFFSET TO FOUND LOCATION\n         STH   R15,FNDOFF          SAVE OFFSET\n         A     R15,=F'1'           COMPUTE COLUMN NUMBER\n         CVD   R15,BRDBLW\n         OI    BRDBLW+7,X'0F'\n         CH    R15,=H'1000'\n         BL    *+L'*+10\n         UNPK  BROWMSG+MSG33L-4(4),BRDBLW+5(3)\n         B     *+L'*+10\n         UNPK  BROWMSG+MSG33L-4(3),BRDBLW+6(2)\n         MVI   BROWMSG,MSG33L-2\n         L     R6,FNDNUM\n         L     R7,HOLDTOP          POINT TO TOP ENTRY\n         S     R6,DIRNUM(,R7)      COMPUTE DOWN COUNT\n         BNP   FILLSCR\n         MVC   DOWNAMT,=F'1'       SET DOWN 1\n         BAL   R14,DOWNER\n         BCT   R6,*-10\n         B     FILLSCR\nFINDNOTF OI    FNDOFF,EOL          SAY BOTTOM (END-OF-LIST) REACHED\n         LA    R1,MSG32            YES, ERROR\n         B     SETMSGA\n*- - - - HEX   - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nHEXMODE  XI    BRMODE,MODEX        FLIP FLOP THE SWITCH\n         B     FILLSCR\n*- - - - CAPS / ASIS - - - - - - - - - - - - - - - - - - - - - - - - -*\nCAPS     NI    BRFUSW,255-BRASSW   SET CAPS\n         B     FILLSCR\nASIS     OI    BRFUSW,BRASSW       SET ASIS\n         B     FILLSCR\n         SPACE 1\nPACKBRO  PACK  BRDBLW,0(*-*,R14)   <<EXECUTED>>\nCPYFSTR  MVC   FNDWA(*-*),BRSTRNG  <<EXECUTED>>\nCUCFSTR  OC    FNDWA(*-*),BRSTRNG  <<EXECUTED>>\nUPPERDT  OC    CRDWA+1(*-*),0(R15) <<EXECUTED>>\nFINDCLC  CLC   CRDWA+1(*-*),FNDWA  <<EXECUTED>>\n         EJECT\n*------- SUBROUTINE TO EXECUTE TOP COMMAND\n*              R14 = LINK REGISTER\nDOTOP    ST    R14,TOPXR14\n         L     R1,CHKPTTOP\n         MVC   BRTTR,4(R1)         TTR OF FIRST BLOCK\n         MVC   BRTTRZ(3),BRTTR\n        POINT  (R4),BRTTRZ\n         XC    DEBLOCKS(3*L'DEBLOCKS),DEBLOCKS\n         XC    BRCOUNT,BRCOUNT\n         L     R14,SPANPTR\n         XR    R0,R0\n         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH\n         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER\n         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET\n         BAL   R14,FILLHOLD\n         L     R14,TOPXR14\n         BR    R14                 RETURN\n         SPACE 1\n*------- SUBROUTINE TO READ ENOUGH RECORDS TO FILL HOLD AREA\n*              R14 = LINK REGISTER\nFILLHOLD ST    R14,HOLDR14\n         L     R0,HOLDPTR\n         L     R1,SAVHOLDL\n         XR    R14,R14\n         L     R15,=A(X'40000000')\n         MVCL  R0,R14              FILL HOLD AREA WITH BLANKS\n         L     R7,HOLDTOP          POINT TO HOLD AREA DIRECTORY\n         L     R8,SCROWS           MAX ROWS PER SCREEN\nHILLOOP  BAL   R14,GETREC          GET A RECORD\n         LA    R0,1                COMPUTE\n         A     R0,BRCOUNT            THE\n         ST    R0,BRCOUNT              RECORD NUMBER\n         ST    R0,DIRNUM(,R7)      STORE THE RECORD NUMBER\n         ST    R1,DIRLEN(,R7)      LENGTH IN DIRECTORY\n         LTR   R1,R1               END OF FILE\n         BM    HILLED              YES BRANCH\n         CL    R1,SAVLRECL         IS RECORD LONGER THAN MAX\n         BNH   *+L'*+4             NO, SKIP NEXT INSTR\n         L     R1,SAVLRECL         YES, TRUNCATE TO MAX\n         LR    R0,R2               ADDRESS TO MOVE FROM\n         L     R14,DIRREC(,R7)     ADDRESS TO MOVE TO\n         TM    TSTRECFM,DCBRECV    RECFM V\n         BZ    HILLNOTV            NO\n         SH    R14,=H'4'           YES, MOVE TO PTR MINUS 4\n         L     R15,DIRLEN(,R7)\n         SH    R15,=H'4'\n         ST    R15,DIRLEN(,R7)\nHILLNOTV LR    R15,R1              LENGTH FOR MOVE\n         MVCL  R14,R0\n         LR    R1,R7               SAVE PTR TO MOST CURRENT ENTRY\n         L     R7,DIRNXT(,R7)      POINT TO NEXT DIRECTORY ENTRY\n         BCT   R8,HILLOOP\n         LR    R7,R1               GET MOST CURRENT ENTRY\nHILLED   ST    R7,HOLDEND          SAVE LAST RECORD ENTRY\n         L     R14,HOLDR14\n         BR    R14                 RETURN\n         SPACE 1\n*------- SUBROUTINE TO SEE IF EOF IS ON SCREEN AND WOULD BE FORCED OFF\n*              R14 = LINK REGISTER\nDOWNER   L     R7,HOLDEND          POINT TO ENTRY FOR LAST RECORD\n         TM    DIRLEN(R7),EOL      IS END-OF-LIST ON SCREEN?\n         BZ    DOWNNEOF            NO, DOWN IS POSSIBLE\n         L     R7,HOLDTOP\n         L     R0,DOWNAMT          GET DOWN AMOUNT\n         LTR   R0,R0               IS IT VALID?\n         BNPR  R14                 NO, DON'T GO DOWN, RETURN\n         CH    R0,BRSCROLL         OR SCREEN SIZE IF HIGHER\n         BNH   *+L'*+4\n         LH    R0,BRSCROLL\n         TM    DIRLEN(R7),EOL      IS THIS END OF DATA (END-OF-LIST)?\n         BOR   R14                 YES, CANT GO DOWN, RETURN\n         L     R7,DIRNXT(,R7)      GET ENTRY FOR NEXT RECORD\n         BCT   R0,*-10\n         L     R7,HOLDEND          POINT TO ENTRY FOR LAST RECORD\nDOWNNEOF ST    R14,DOWNR14\n         L     R8,DOWNAMT          GET NUMBER OF LINES TO GO DOWN\nDOWNLOOP L     R15,HOLDTOP         POINT TO TOP ENTRY\n         L     R15,DIRNXT(,R15)    GET ADDRESS OF ENTRY AFTER TOP\n         ST    R15,HOLDTOP         MAKE IT NEW TOP\n         TM    DIRLEN(R7),EOL      IS END-OF-LIST ON SCREEN?\n         BO    DOWNNXT             YES, BYPASS GET\n         L     R7,DIRNXT(,R7)      POINT TO NEXT ENTRY\n         BAL   R14,GETREC          GET A RECORD\n         LA    R0,1                COMPUTE\n         A     R0,BRCOUNT            THE\n         ST    R0,BRCOUNT              RECORD NUMBER\n         ST    R0,DIRNUM(,R7)      STORE THE RECORD NUMBER\n         ST    R1,DIRLEN(,R7)      STORE LENGTH\n         LTR   R1,R1               END OF FILE?\n         BNM   DOWNSTR             NO\nDOWNFWD  BCT   R8,*+L'*+4          YES, END OF DATA\n         B     DOWNX               OR END OF DOWN REQUEST\n         L     R15,HOLDTOP         POINT TO TOP ENTRY\n         L     R15,DIRNXT(,R15)    GET ADDRESS OF ENTRY AFTER TOP\n         ST    R15,HOLDTOP         MAKE IT NEW TOP\n         B     DOWNFWD\nDOWNSTR  CL    R1,SAVLRECL         IS RECORD LONGER THAN MAX?\n         BNH   *+L'*+4             NO, SKIP NEXT INSTR\n         L     R1,SAVLRECL         YES, TRUNCATE TO MAX\n         LR    R0,R2               ADDRESS TO MOVE FROM\n         L     R14,DIRREC(,R7)     ADDRESS TO MOVE TO\n         TM    TSTRECFM,DCBRECV    RECFM V?\n         BZ    DOWNNOTV            NO\n         SH    R14,=H'4'           YES, MOVE TO PTR MINUS 4\n         L     R15,DIRLEN(,R7)\n         SH    R15,=H'4'\n         ST    R15,DIRLEN(,R7)\nDOWNNOTV L     R15,SAVLRECL        LENGTH OF RECEIVING FIELD\n         O     R1,=A(X'40000000')  PAD WITH BLANKS\n         MVCL  R14,R0\nDOWNNXT  BCT   R8,DOWNLOOP\nDOWNX    ST    R7,HOLDEND          NEW END POINTER\n         L     R14,DOWNR14\n         BR    R14                 RETURN\n         SPACE 1\n*------- SUBROUTINE TO GET A LOGICAL RECORD\n*              R14 = LINK REGISTER\n*        INPUT :  R4 DCB ADDRESS\n*                 CHKPTTOP -  TOP OF CHECKPOINT TABLE\n*                 CHKPTBOT -  BOTTOM OF CHECKPOINT TABLE, ZERO 1ST TIME\n*                 COUNT    -  LAST LOGICAL RECORD NUMBER READ\n*                 BLOCKPTR -  ADDRESS OF BUFFER\n*                 DEBLOCKS -  DEBLOCKING INFO (ZEROS FIRST TIME)\n*                 SPANPTR  -  ADDRESS OF AREA TO COMBINE SPANNED RECORD\n*                             SEGMENTS\n*        OUTPUT : R1 CONTAINS LENGTH OF RECORD (OR -1 IF END OF FILE)\n*                 R2 CONTAINS ADDRESS OF RECORD (OR 0 IF END OF FILE)\nGETREC   ST    R14,READR14\n         LM    R0,R2,DEBLOCKS      GET DEBLOCKING STATUS\n         TM    WRKRECFM,DCBRECBR   BLOCKED\n         BZ    READI               NO, BRANCH\n         AR    R2,R1               POINT TO NEXT RECORD\n         CLR   R2,R0               END OF BLOCK (OR FIRST TIME)?\n         BNL   READI               YES, BRANCH\n         TM    TSTRECFM,DCBRECV    VARIABLE LENGTH?\n         BO    READVB              YES, BRANCH\n         ST    R2,DEBLOCKS+2*L'DEBLOCKS FIXED BLOCKED\n         B     READX\nREADI    L     R5,CHKPTBOT         GET LAST CHECKPOINT\n         LTR   R5,R5               IS THIS FIRST READ?\n         BNZ   *+L'*+8             BRANCH IF NOT FIRST\n         L     R5,CHKPTTOP\n         B     READNEW             READING A RECORD NOT READ BEFORE\n         L     R1,0(,R5)           GET NUMBER OF HIGHEST RECORD READ\n         LTR   R1,R1               WAS IT EOF?\n         BM    *+L'*+8             YES, BRANCH\n         CL    R1,BRCOUNT          HAVE WE READ THIS RECORD BEFORE?\n         BNH   *+L'*+8             NO, BRANCH\n         LA    R5,CHKPTDUM         YES, DONT CHANGE CHKPT TABLE\n         B     READBRO\n         LA    R5,CHKPTLEN(R5)     ADD AN ENTRY TO THE CHKPT TABLE\n         CL    R5,ENDPTR           IS TABLE FILLED UP?\n         BL    READNEW             NO, SKIP NEXT INSTR\n         LA    R0,CHKPTLEN         YES, HALVE THE TABLE, ENTRY LENGTH\n         L     R15,CHKPTTOP        POINT TO FIRST ENTRY\n         AR    R15,R0              POINT TO SECOND ENTRY\n         LR    R1,R15\n         AR    R1,R0               POINT TO THIRD ENTRY\nREADHMOV MVC   0(CHKPTLEN,R15),0(R1) MOVE 3RD TO 2ND, 5TH TO 3RD,\n*                                         7TH TO 4TH, ETC...\n         AR    R15,R0              RECEIVING FIELD DOWN 1\n         AR    R1,R0               SENDING FIELD DOWN 1\n         AR    R1,R0               SENDING FIELD DOWN 2\n         CLR   R1,R5               ARE WE PAST THE LAST ENTRY\n         BL    READHMOV            NO, BRANCH\n         LR    R5,R15              YES, NEW CURRENT POINTER\nREADNEW  ST    R5,CHKPTBOT         SAVE NEW CURRENT CHECKPOINT POINTER\n         MVC   0(4,R5),BRCOUNT\n         XC    4(4,R5),4(R5)\n         MVC   8(3*L'DEBLOCKS,R5),DEBLOCKS\nREADBRO  L     R2,BLOCKPTR\n        READ   DYNDECBW,SF,(R4),(R2),'S',MF=E\n        CHECK  DYNDECBW\n         TM    BRFSSW,SYNADSW      WAS SYNAD EXIT TAKEN?\n         BO    IOERR               YES, BRANCH\n         LH    R1,DCBBLKSI\n         L     R14,DYNDECBW+(DECIOBPT-DECB)\n         SH    R1,IOBCSW+5-IOBSTDRD(,R14) SUBTRACT RESIDUAL COUNT\n         TM    TSTRECFM,DCBRECV    VARIABLE LENGTH RECORDS?\n         BZ    *+L'*+4             NO, BRANCH\n         LH    R1,0(,R2)           YES, USE BLKSIZE IN BDW\n         LA    R0,0(R1,R2)         END OF BLOCK\n         STM   R0,R2,DEBLOCKS      SAVE STATUS INFO\n         CLC   4(4,R5),=F'0'       IS THIS 2ND READ PER GET?\n         BNZ   NOTED               YES, BYPASS NOTE\n        NOTE   (R4)\n         ST    R1,4(,R5)           SAVE TTR IN TABLE\nNOTED    L     R1,DEBLOCKS+L'DEBLOCKS RESTORE LENGTH\n         TM    WRKRECFM,DCBRECBR   BLOCKED?\n         BO    READB               YES, BRANCH\n         TM    TSTRECFM,DCBRECV+DCBRECSB VARIABLE UNBLOCKED SPANNED?\n         BNO   READX               NO\n         B     READVBS             YES, SAME AS BLOCKED\nREADB    TM    WRKRECFM,DCBRECU    UNDEFINED?\n         BO    READX\n         TM    WRKRECFM,DCBRECV    VARIABLE LENGTH?\n         BO    READVBI\n         LH    R1,DCBLRECL         FIXED BLOCKED\n         ST    R1,DEBLOCKS+L'DEBLOCKS SAVE STATUS INFO\n         B     READX\nREADVBI  LA    R2,4(,R2)           POINT PAST BDW\nREADVB   TM    WRKRECFM,DCBRECSB   SPANNED?\n         BO    READVBS\nREADVBR  LH    R1,0(,R2)\n         STM   R1,R2,DEBLOCKS+L'DEBLOCKS SAVE STATUS INFO\n         B     READX\nREADVBS  CLI   2(R2),0             SEGMENT?\n         BE    READVBR             NO, BRANCH\n*                             THIRD BYTE IS X'01' FOR FIRST SEGMENT\n*                                           X'03' FOR MIDDLE SEGMENT\n*                                           X'02' FOR LAST SEGMENT\n         CLI   2(R2),1             FIRST SEGMENT?\n         BNE   READSEGN\n         L     R14,SPANPTR         ADDRESS TO MOVE TO\n         LH    R15,0(,R2)          LENGTH TO MOVE\n         LR    R1,R15              LENGTH TO MOVE\n         LR    R0,R2               ADDRESS TO MOVE FROM\n         MVCL  R14,R0              MOVE SEGMENT RDW AND DATA\n         B     READSEGD            GO DEBLOCK NEXT SEGMENT\nREADSEGN L     R14,SPANPTR         ADDRESS OF PRIOR SEGMENTS\n         LH    R0,0(,R14)          LENGTH OF PRIOR SEGMENTS\n         LH    R15,0(,R2)          LENGTH+4 OF NEW SEGMENT\n         SH    R15,=H'4'           LENGTH OF NEW SEGMENT\n         LR    R1,R15              LENGTH TO BE MOVED\n         AR    R15,R0              COMBINE LENGTHS\n         STH   R15,0(,R14)         STORE COMBINED LENGTHS\n         LR    R15,R1              LENGTH TO ME MOVED\n         AR    R14,R0              ADDRESS TO MOVE TO\n         LA    R0,4(,R2)           ADDRESS TO MOVE FROM\n         MVCL  R14,R0              MOVE SEGMENT DATA\n         CLI   2(R2),2             LAST SEGMENT?\n         BNE   READSEGD            NO, GO DEBLOCK NEXT SEGMENT\n         LH    R1,0(,R2)           GET LENGTH OF THIS SEGMENT\n         STM   R1,R2,DEBLOCKS+L'DEBLOCKS SAVE LENGTH AND ADDRESS\n         L     R2,SPANPTR          POINT TO COMBINED RECORD\n         LH    R1,0(,R2)           GET COMBINED LENGTH\n         B     READX               EXIT\n*                             NOT NECESSARY TO CHECK RECFM FOR DCBRECBR\nREADSEGD LH    R1,0(,R2)           LENGTH\n         AR    R2,R1               POINT TO NEXT SEGMENT\n         CL    R2,DEBLOCKS         END OF BLOCK?\n         BNL   READBRO             YES, BRANCH\n         B     READVBS             GO PROCESS NEW SEGMENT\n         CNOP  0,4\nDYNEOD   L     R1,=F'-1'           EOF\n         ST    R1,0(,R5)           SAVE EOF IN CHKPT TABLE\n         XR    R2,R2\nREADX    L     R14,READR14\n         BR    R14\n         EJECT\n*------- END OF PROGRAM ---------------------------------------------*\nGMERR   XMESS  1601,R15\n         LA    R1,BRGMMSG\n         B     XSETSM\nIOERR    LA    R1,BROWMSG\nXSETSM   ST    R1,MSGADD\nXEND     TM    BRSTSW,STGMVC\n         BZ    NOGMVC\n         L     R0,BRANSWER+4       LENGTH\n         L     R1,BRANSWER         ADDRESS\n        FREEMAIN R,LV=(0),A=(1)\nNOGMVC   TM    BRSTSW,STOPEN\n         BZ    NOCLOSE\n         TM    DCBOFLGS,DCBOFOPN   IS IT OPEN?\n         BZ    NOCLOSE             NO, BRANCH\n         MVI   OPCLPL,VLB          SET \"VL\" BIT\n        CLOSE  ((R4)),MF=(E,OPCLPL)\n         DROP  R4\nNOCLOSE  L     R13,4(,R13)         PICK UP CALLING SAVE-AREA\n         LM    R14,R12,12(R13)     RESTORE CALLING REGSITERS\n         XR    R15,R15             SET RC=0\n         BR    R14                 RETURN\n         SPACE 1\n*------- SYNAD EXIT - THIS ROUTINE IS ENTERED DURING THE \"CHECK\" MACRO\n*              IF AN I/O ERROR OCCURS.\n         CNOP  0,4\nDYNSYNAD SYNADAF ACSMETH=BSAM\n         MVI   BROWMSG,15\n         MVC   BROWMSG+1(15),91(R1) ERROR DESCRIPTION ONLY\n         OI    BRFSSW,SYNADSW\n        SYNADRLS\n         BR    R14\n         EJECT\n*------- CONSTANTS --------------------------------------------------*\nBROSHL   DC    AL1(BROSHLL-1)\nDSNMNM   EQU   (*-BROSHL)+1,54\n         DC    XL1'05',CL54' ',12CL1'-'\nSCRCOL   EQU   (*-BROSHL)+5,8\n         DC    CL13' COL ... ... '\nBROSHLL  EQU   *-BROSHL\nCRBWSC   EQU   01                  CURSOR ROW ON LINE BELOW\nZIBD     EQU   (CRBWSC+1)*4        \"TERMINPT\" DISPLACEMENT\nBROHD    DC    AL1(BROHDL-1)\n         DC    XL1'05',CL12'COMMAND ===>'\nCCBWSC   EQU   *-BROHD             CURSOR COLUMN ON FIELD BELOW\nBWSCF1   EQU   (*-BROHD)+1,46      INPUT FIELD 1\n         DC    XL1'01',CL46' '\n         DC    XL1'05',CL11'< SCROLL =>'\nBWSCF2   EQU   (*-BROHD)+1,4       INPUT FIELD 2\n         DC    XL1'01',CL4' ',XL1'05',CL1'<',XL1'04'\nBROHDL   EQU   *-BROHD\nCRBWDT   EQU   04             ROW OF FIRST DATA LINE\n         SPACE 1\nHEXTAB   DC    CL16'0123456789ABCDEF' TRANSLATE TABLE\nBRGMMSG  MSG   'GETMAIN FAILED'\nMSG10    MSG   'UNABLE TO OPEN'\nMSG11    MSG   'MEMBER NOT FOUND'\nMSG20    MSG   'INVALID COMMAND'\nMSG21    MSG   'INVALID PF-KEY'\nMSG31    MSG   'STRING NOT SPECIFIED'\nMSG32    MSG   'BOTTOM DATA REACHED'\nMSG33    MSG   'FOUND AT COL. ....'\nMSG33L   EQU   *-MSG33\nMSG34    MSG   'STRING NULL'\nMSG35    MSG   'STRING TOO LONG'\nMSG36    MSG   'INVALID HEX-DIGIT'\nMSG37    MSG   'HEX-STRING MISSING'\nMSG38    MSG   'NULL HEX-STRING'\nMSG39    MSG   'HEX-STRING ODD'\n         SPACE 1\nGMVC    GETMAIN VC,MF=L\nBRODCB  DCB    DSORG=PS,MACRF=(RP),DDNAME=DUMMY,EODAD=*-*,SYNAD=*-*\nBRODCBL  EQU   *-BRODCB\n        READ   DYNDECB,SF,*-*,*-*,'S',MF=L\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         SPACE 1\n         DROP  R10,R11,R12,R13\n         EJECT\n*- - - - TRANSLATE TABLES\nASIST    DC    64X'4B',X'40',9X'4B'\n         DC    X'4A4B4C4D4E4F'     CENT,PERIOD,LESS,LPAREN,PLUS,BAR\n         DC    X'50',9X'4B'        AMPERSAND\n         DC    X'5A5B5C5D5E5F'     EXCL,$,DOT,RPAREN,SEMI,NOT\n         DC    X'6061',8X'4B'      HYPHEN,SLASH\n         DC    X'6A6B6C6D6E6F'     WHAT,COMMA,PERCENT,UNDLN,GT,QM\n         DC    9X'4B',X'79'\n         DC    X'7A7B7C7D7E7F'     COLON,POUND,AT,QUOTE,EQ,DBLQUOTE\n         DC    X'4B',X'818283848586878889',6X'4B'\n         DC    X'4B',X'919293949596979899',6X'4B'\n         DC    X'4B',X'A1A2A3A4A5A6A7A8A9',6X'4B'\n         DC    16X'4B'\n         DC    X'C0',C'ABCDEFGHI',6X'4B'\n         DC    X'D0',C'JKLMNOPQR',6X'4B'\n         DC    X'E0',X'4B',C'STUVWXYZ',6X'4B'\n         DC    C'0123456789',6X'4B'\nCAPST    DC    64X'4B',X'40',9X'4B'\n         DC    X'4A4B4C4D4E4F'     CENT,PERIOD,LESS,LPAREN,PLUS,BAR\n         DC    X'50',9X'4B'        AMPERSAND\n         DC    X'5A5B5C5D5E5F'     EXCL,$,DOT,RPAREN,SEMI,NOT\n         DC    X'6061',8X'4B'      HYPHEN,SLASH\n         DC    X'6A6B6C6D6E6F'     WHAT,COMMA,PERCENT,UNDLN,GT,QM\n         DC    9X'4B',X'79'\n         DC    X'7A7B7C7D7E7F'     COLON,POUND,AT,QUOTE,EQ,DBLQUOTE\n         DC    X'4B',C'ABCDEFGHI',6X'4B'\n         DC    X'4B',C'JKLMNOPQR',6X'4B'\n         DC    2X'4B',C'STUVWXYZ',6X'4B'\n         DC    16X'4B'\n         DC    X'C0',C'ABCDEFGHI',6X'4B'\n         DC    X'D0',C'JKLMNOPQR',6X'4B'\n         DC    X'E0',X'4B',C'STUVWXYZ',6X'4B'\n         DC    C'0123456789',6X'4B'\n         SPACE 1\nMARKS    DC    9CL10'----+----+'\nMARKH    DC    9CL10' - - - - +'\n         EJECT\n*------- BROWSE INTERFACE HELP SCREEN -------------------------------*\n         CNOP  0,4\nBROHELP  DC    A(BROHL1)\n         DC    A(BROENT)\n         DC    A(BROHL2)\n         DC    A(BROHL3)\n         DC    A(BROHL4)\n         DC    A(BROHL5)\n         DC    A(BROHL6)\n         DC    A(BROHL7)\n         DC    A(BROHL8)\n         DC    A(BROBLK)\n         DC    A(BROHL9)\n         DC    A(EML+BROHL10)\n         SPACE 1\nBROHL1   DC    AL1(BROHL1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL18' BROWSE INTERFACE ',51CL1'-'\nBROHL1L  EQU   *-BROHL1\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\nBROHL2   DC    AL1(BROHL2L-1),XL1'05'\n         DC    C'COMMANDS ARE :'\nBROHL2L  EQU   *-BROHL2\nBROHL3   DC    AL1(BROHL3L-1),XL1'05'\n         DC    C' LEFT, L OR <         / RIGHT, R OR >        SCREEN SHX\n               IFTED BY 80-C OR 40-HEX'\nBROHL3L  EQU   *-BROHL3\nBROHL4   DC    AL1(BROHL4L-1),XL1'05'\n         DC    C' UP, U OR -           / DOWN, D OR +         FOLLOWED X\n               BY \"M\" OR A NUMBER'\nBROHL4L  EQU   *-BROHL4\nBROHL5   DC    AL1(BROHL5L-1),XL1'05'\n         DC    C' TOP OR T             / BOTTOM, BOT OR B'\nBROHL5L  EQU   *-BROHL5\nBROHL6   DC    AL1(BROHL6L-1),XL1'05'\n         DC    C' CAPS OR C            / ASIS OR A'\nBROHL6L  EQU   *-BROHL6\nBROHL7   DC    AL1(BROHL7L-1),XL1'05'\n         DC    C' HEX OR H (FLIP-FLOP BETWEEN NORMAL AND HEX DISPLAY)'\nBROHL7L  EQU   *-BROHL7\nBROHL8   DC    AL1(BROHL8L-1),XL1'05'\n         DC    C' FIND OR F ...STRING... OR X''...HEX-STRING...'\nBROHL8L  EQU   *-BROHL8\nBROHL9   DC    AL1(BROHL9L-1),XL1'05'\n         DC    C'SCROLL : P(AGE) BY DEFAULT, H(ALF) OR C(SR)'\nBROHL9L  EQU   *-BROHL9\nBROHL10  DC    AL1(BROHL10L-1),XL1'05'\n         DC    C'PFK''S :  3-4=END, 5=FIND, 7=UP, 8=DOWN, 10=LEFT AND 1X\n               1=RIGHT'\nBROHL10L EQU   *-BROHL10\nBROENT   DC    AL1(BROENTL-1),XL1'01',CL1' ',XL1'05',CL7' '\nBROENTL  EQU   *-BROENT\nBROBLK   DC    AL1(BROBLKL-1),XL1'05',CL9' '\nBROBLKL  EQU   *-BROBLK\n         EJECT\n         PRINT &PRS\n        SPLTAREA\n         SPACE 1\n        MYSAVE\n         PRINT &PRF\n        IEFZB4D0\n        DCBD   DSORG=(PS,PO),DEVD=DA\n        IHADECB\n        IEZIOB\n         PRINT GEN\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPSCOMP": {"ttr": 9989, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x05\\x9f\\x00\\x96\\x05\\x9f\\x17#\\x01\\xc4\\x01\\xc4\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-02-28T00:00:00", "modifydate": "1996-02-28T17:23:00", "lines": 452, "newlines": 452, "modlines": 0, "user": "SYSPAJA"}, "text": "COMP     TITLE '--- E T P S -- ETPSCOMP - COMPRESS LIBRARY ---'\n         PRINT OFF\n         COPY  ETPS$O1             \"ETPS\" SYSPARM SELECTION\n         COPY  ETPSMACS            \"ETPS\" MACROS\n         COPY  ETPSDEFS            \"ETPS\" DEFINITIONS\n         PRINT ON\nETPSCOMP START 0\n         SPACE 1\nETPSCOMP AMODE 24\nETPSCOMP RMODE 24\n        MIDENT\n         EJECT\n*------- AT ENTRY, R1 = A(PARM.LIST) -> (DS-NAME,\n*                                        VOL-SER,\n*                                        PASSWORD)\n         SPACE 1\n         PRINT GEN\n         USING *,R12\n         USING SAVE2,R13      ************************** R13 ==> SAVE2\n         USING SPLTAREA,R10   AT ENTRY : R10 MUST POINT TO \"SPLTAREA\"\n         B     32(,R15)\n         DC    CL28'  ETPSCOMP &SYSDATE &SYSTIME'\n         PRINT &PRF\n         STM   R14,R12,12(R13)     SAVE INPUT REGISTERS\n         LR    R12,R15             SET PROGRAM BASE REGISTER\n         LR    R3,R10              SPLIT-SCREEN DSECT\n         SH    R3,=Y(SPLITWRK-SAVE2) POINT TO SAVE2\n         ST    R13,4(,R3)          STORE BACKWARD POINTER\n         ST    R3,8(R13)           STORE FORWARD POINTER\n         LR    R13,R3              SET DSECT BASE\n         LM    R3,R5,0(R1)         GET PARAMETERS ADDRESSES\n         L     R9,=A(WKLEN)\n        GETMAIN RC,LV=(R9)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    *+L'*+10            OK\n         LR    R5,R15              ERROR, RETAIN GETMAIN RC\n         LA    R4,98               SET GETMAIN ERROR RETURN CODE\n         B     GOBACK\n         LR    R0,R1\n         LR    R1,R9\n         LR    R9,R0\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R0,R14              CLEAR ALL TO BINARY ZEROS\n         USING WKAREA,R9\n         MVC   INDDIN(SKLTUL),SKLTU\n         MVC   INDS(L'INDS),0(R3)  R3 = INPUT DSN\n         MVC   INV(L'INV),0(R4)    R4 = INPUT VOLSER\n         MVC   INP(L'INP),0(R5)    R5 = INPUT PASSWORD\n         MVC   DDIN,N#IN           SET ALL NEEDED DDNAMES\n         MVC   INDD,N#UT1\n         MVC   DDUT3,N#UT3\n         MVC   DDUT4,N#UT4\n         L     R1,ACOPDCB          SET DDNAME FOR SYSPRINT\n         MVC   DDOUT(L'DDOUT),DCBDDNAM-IHADCB(R1)\n         LA    R1,N#IN+L'N#IN-1\n         CLI   0(R1),C' '\n         BNE   *+L'*+4\n         BCT   R1,*-8\n         MVC   STSFX(L'STSFX),0(R1)\n         XR    R3,R3               AUTH-SWITCH USE\n         LR    R4,R3               DYNALLOC RC / R15\n         LR    R5,R3               DYNALLOC REASON-INFO CODES / R0\n         LR    R6,R3               IEBCOPY RC / R15\n         SPACE 1\n         MVC   RB99TU(SKFLEN),SKF  SET FREE LIST\n         LA    R0,INDDUT1          FREE ANY SYSUT1\n         ST    R0,RB99TU\n         LA    R1,RB99TU\n         BAL   R8,UNALL\n         LA    R0,INDDUT3          FREE ANY SYSUT3\n         ST    R0,RB99TU\n         LA    R1,RB99TU\n         BAL   R8,UNALL\n         LA    R0,INDDUT4          FREE ANY SYSUT4\n         ST    R0,RB99TU\n         LA    R1,RB99TU\n         BAL   R8,UNALL\n         LA    R0,INDDIN           FREE ANY SYSIN\n         ST    R0,RB99TU\n         LA    R1,RB99TU\n         BAL   R8,UNALL\n         LA    R0,OUDDNAME         FREE ANY SYSPRINT\n         ST    R0,RB99TU\n         LA    R1,RB99TU\n         BAL   R8,UNALL\n         SPACE 1\n         MVC   RBLBTU(SKLLEN),SKL ALLOCATE LIBRARY AS SYSUT1\n         LA    R0,INDDUT1\n         ST    R0,RBLBTU\n         LA    R0,INDSNAME\n         ST    R0,INNADDR\n         OI    INV,C' '\n         CLI   INV,C' '\n         BE    *+L'*+8\n         LA    R0,INVOLSER\n         ST    R0,INVADDR\n         OI    INP,C' '\n         CLI   INP,C' '\n         BE    *+L'*+8\n         LA    R0,INPASS\n         ST    R0,INPADDR\n         LA    R0,RTNDSORG\n         O     R0,INDSORG\n         ST    R0,INDSORG\n         XC    DSORG,DSORG\n         LA    R1,RBLBTU\n         BAL   R8,DYNALL\n         B     ERRUT1              +0 - ERROR RETURN\n         CLC   DSORG(L'DSORG),=AL1(DCBDSGPO,0)\n         BE    *+L'*+8\n         LA    R4,99               NOT A PARTITIONED\n         B     ERRUT1\n         MVC   RBLBTU(SKUT3L),SKUT3 ALLOCATE SYSUT3\n         LA    R0,INDDUT3\n         ST    R0,RBLBTU\n         LA    R1,RBLBTU\n         BAL   R8,DYNALL\n         B     ERRUT3              +0 - ERROR RETURN\n         MVC   RBLBTU(SKUT4L),SKUT4 ALLOCATE SYSUT4\n         LA    R0,INDDUT4\n         ST    R0,RBLBTU\n         LA    R1,RBLBTU\n         BAL   R8,DYNALL\n         B     ERRUT4              +0 - ERROR RETURN\n         MVC   RBLBTU(SKINL),SKIN  ALLOCATE SYSIN (NULLFILE)\n         LA    R0,INDDIN\n         ST    R0,RBLBTU\n         LA    R1,RBLBTU\n         BAL   R8,DYNALL\n         B     ERRIN               +0 - ERROR RETURN\n         MVC   RBOUTU(SKPLEN),SKP  ALLOCATE SYSPRINT\n         LA    R0,OUDDNAME\n         ST    R0,RBOUTU\n         LA    R0,OUDSNAME\n         ST    R0,OUDSNM\n         LA    R0,OURTDS\n         O     R0,OURDSNM\n         ST    R0,OURDSNM\n         LA    R1,RBOUTU\n         BAL   R8,DYNALL\n         B     ERROUT              +0 - ERROR RETURN\n        TESTAUTH FCTN=1            AUTHORIZATION STATUS\n         LTR   R3,R15\n         BZ    DOLINK\n         LA    R0,1                SET AUTH ON\n         SVC   235\nDOLINK   MVC   PARM1(L'PARM1SK+OPTL),PARM1SK\n         MVC   PARM2,=AL2(DDAL)\n         MVC   PIN,DDIN\n         MVC   PPRT,DDOUT\n         MVC   PUT1,INDD\n         MVC   PUT2,INDD\n         MVC   PUT3,DDUT3\n         MVC   PUT4,DDUT4\n         LA    R0,PARM1\n         ST    R0,PARMLIST\n         LA    R0,PARM2\n         ST    R0,PARMLIST+4\n         OI    PARMLIST+4,VLB      SET \"VL\" BIT\n         LA    R1,PARMLIST\n        LINK   EP=IEBCOPY\n         LR    R6,R15              PICK UP RETURN CODE\n         XR    R5,R5\n         LTR   R3,R3\n         BZ    ALLDONE\n         SR    R0,0                SET AUTH OFF\n         SVC   235\n         SPACE 1\nALLDONE  LTR   R6,R6               IEBCOPY DONE SUCESSFULL?\n         BNZ   ERROUT              NO, SKIP FREE (DELETE LATER)\n         MVC   RB99TU(SKFLEN),SKF  SET FREE LIST\n         LA    R0,OUDDNAME         FREE SYSPRINT\n         ST    R0,RB99TU\n         LA    R1,RB99TU\n         BAL   R8,UNALL\nERROUT   MVC   RB99TU(SKFLEN),SKF  SET FREE LIST\n         LA    R0,INDDIN           FREE SYSIN\n         ST    R0,RB99TU\n         LA    R1,RB99TU\n         BAL   R8,UNALL\nERRIN    MVC   RB99TU(SKFLEN),SKF  SET FREE LIST\n         LA    R0,INDDUT4          FREE SYSUT4\n         ST    R0,RB99TU\n         LA    R1,RB99TU\n         BAL   R8,UNALL\nERRUT4   MVC   RB99TU(SKFLEN),SKF  SET FREE LIST\n         LA    R0,INDDUT3          FREE SYSUT3\n         ST    R0,RB99TU\n         LA    R1,RB99TU\n         BAL   R8,UNALL\nERRUT3   MVC   RB99TU(SKFLEN),SKF  SET FREE LIST\n         LA    R0,INDDUT1          FREE SYSUT1\n         ST    R0,RB99TU\n         LA    R1,RB99TU\n         BAL   R8,UNALL\n         SPACE 1\nERRUT1   LTR   R6,R6               IEBCOPY DONE SUCCESSFULL?\n         BZ    LEAVE               YES\n         LR    R4,R6               NO, BROWSE SYSPRINT\n         L     R3,ACOPDCB\n         LA    R2,OURDS\n         LA    R6,=CL8' '\n         ICM   R15,B'1111',ARBROWSE\n         BNZ   CALLBR\n        LOAD   EP=ETPSBROW,ERRET=XLDERR\n         ST    R0,ARBROWSE\n         LR    R15,R0\n*- - - - ETPSBROW PARM.LIST : DCB, DS-NAME, MEMBER-NAME\nCALLBR  CALL   (15),((R3),(R2),(R6)),VL,MF=(E,PARMVL)\nQUIT     MVC   RB99TU(SKFLEN),SKF  SET FREELIST\n         LA    R0,OUDDNAME         FREE SYSPRINT NOW\n         ST    R0,RB99TU\n         LA    R1,RB99TU\n         BAL   R8,UNALL\nLEAVE    LR    R1,R9\n         L     R0,=A(WKLEN)\n        FREEMAIN R,LV=(0),A=(1)\nGOBACK   LA    R1,OKMSG\n         LTR   R5,R5\n         BZ    SETMSG\n         ST    R4,MESSPL           ERROR\n        XMESS  1401,R15\n         LA    R1,NPOMSG\n         CH    R4,=H'99'\n         BE    SETMSG\n         LA    R1,GEMSG\n         CH    R4,=H'98'\n         BE    SETMSG\n         LA    R1,BADMSG\nSETMSG   ST    R1,MSGADD\n         L     R13,4(R13)          PICK UP CALLING SAVE-AREA\n         LM    R14,R12,12(R13)     RESTORE CALLING REGISTERS\n         XR    R15,R15             SET RC=0\n         BR    R14                 RETURN\nXLDERR   STM   R0,R1,MESSPL        BROWSE IS UNAVAILABLE\n        XMESS  99,R15\n         B     QUIT\n         SPACE 1\nUNALL    LA    R0,S99VRBUN         UNALL ROUTINE --------------------*\n         B     DYNALL+L'DYNALL\nDYNALL   LA    R0,S99VRBAL         DYNALL ROUTINE -------------------*\n         MVC   RB99P(SKRLEN),SKR\n         STC   R0,RB99VR\n         ST    R1,RB99TUP\n         LA    R0,RB99\n         O     R0,RB99P\n         ST    R0,RB99P\n         LA    R1,RB99P\n        DYNALLOC\n         CLI   RB99VR,S99VRBAL     DYNALL?\n         BNER  R8                  NO, ALWAYS RETURN\n         L     R5,RB99RC           YES, CHECK ANY ERROR\n         LTR   R4,R15\n         BNZR  R8                  ERROR, RETURN +0\n         LTR   R5,R5\n         BNZR  R8                  ERROR, RETURN +0\n         B     4(R8)               NORMAL, RETURN +4\n         EJECT\nSKR      DC    0F'0',AL1(S99RBPND),AL3(*-*)\nSKRP     DC    AL1(S99RBEND-S99RB)\n         DC    AL1(*-*)            VERB CODE\n         DC    AL1(0,0)            FLAGS\n         DC    2XL2'0'             ERROR-INFORMATION REASON CODES\n         DC    A(*-*)\nSKRL     EQU   (S99RBEND-S99RB)-(*-SKRP)\n         DC    (SKRL)X'0'\nSKRLEN   EQU   *-SKR\n         SPACE 1\nSKF      DC    A(*-*)\n         DC    AL1(S99TUPLN),AL3(UNCOND)\nSKFLEN   EQU   *-SKF\n         SPACE 1\nSKL      DC    A(*-*)\n         DC    A(*-*)\n         DC    A(*-*)\n         DC    A(*-*)\n         DC    A(DISPSHR)\n         DC    A(DISPKEEP)\n         DC    AL1(S99TUPLN),AL3(*-*)\nSKLLEN   EQU   *-SKL\n         SPACE 1\nSKP      DC    A(*-*)\n         DC    A(*-*)\n         DC    A(UNIT)\n         AIF   ('&CSPUN' NE 'TRK').SK1\n         DC    A(TRKS)\n         AGO   .SK2\n.SK1     DC    A(CYLS)\n.SK2     DC    A(PRIMRY)\n         DC    A(SECNRY)\n         DC    A(RECFM)\n         DC    A(BLKSZ)\n         DC    A(LRECL)\n         DC    A(DISPNEW)\n         DC    A(DISPDEL)\n         DC    A(DISPCDEL)\n         DC    AL1(S99TUPLN),AL3(*-*)\nSKPLEN   EQU   *-SKP\n         SPACE 1\nSKUT3    DC    A(*-*)\n         DC    A(CYLS)\n         DC    A(PRIMRY)\n         DC    A(SECNRY)\n         DC    AL1(S99TUPLN),AL3(DISPNEW)\nSKUT3L   EQU   *-SKUT3\n         SPACE 1\nSKUT4    DC    A(*-*)\n         DC    A(CYLS)\n         DC    A(PRIMRY)\n         DC    A(SECNRY)\n         DC    A(KEYLEN)\n         DC    AL1(S99TUPLN),AL3(DISPNEW)\nSKUT4L   EQU   *-SKUT4\n         SPACE 1\nSKIN     DC    A(*-*)\n         DC    AL1(S99TUPLN),AL3(DUMMY)\nSKINL    EQU   *-SKIN\n         SPACE 1\nSKLTU    DC    AL2(DALDDNAM),AL2(1),AL2(8)   OR (DUNDDNAM)\n         DC    CL8' '\n         DC    AL2(DALDDNAM),AL2(1),AL2(8)   OR (DUNDDNAM)\n         DC    CL8' '\n         DC    AL2(DALDDNAM),AL2(1),AL2(8)  OR (DUNDDNAM)\n         DC    CL8' '\n         DC    AL2(DALDDNAM),AL2(1),AL2(8)  OR (DUNDDNAM)\n         DC    CL8' '\n         DC    AL2(DALDSNAM),AL2(1),AL2(44)\n         DC    CL44' '\n         DC    AL2(DALVLSER),AL2(1),AL2(6)\n         DC    CL6' '\n         DC    AL2(DALPASSW),AL2(1),AL2(8)\n         DC    CL8' '\n         DC    AL2(DALRTORG),AL2(1),AL2(2)\n         DC    XL2'0'\n         DC    AL2(DALDDNAM),AL2(1),AL2(8) OR (DUNDDNAM)\n         DC    CL8' '\n         DC    AL2(DALDSNAM),AL2(1),AL2(44)\n         DC    CL44'&&&&LIST '\n         DC    AL2(DALRTDSN),AL2(1),AL2(44)\n         DC    CL44' '\nSKLTUL   EQU   *-SKLTU\n         SPACE 1\nUNIT     DC    AL2(DALUNIT),AL2(1),AL2(8),CL8'&CUNME'\nPRIMRY   DC    AL2(DALPRIME),AL2(1),AL2(3),AL3(&CPRIQ)\nSECNRY   DC    AL2(DALSECND),AL2(1),AL2(3),AL3(&CSECQ)\nBLKSZ    DC    AL2(DALBLKSZ),AL2(1),AL2(2),AL2(&CBLSZ)\nLRECL    DC    AL2(DALLRECL),AL2(1),AL2(2),AL2(&CLRCL)\nRECFM    DC    AL2(DALRECFM),AL2(1),AL2(1)\n        SETRF  &CRCFM\nKEYLEN   DC    AL2(DALKYLEN),AL2(1),AL2(1),AL1(8)\nDISPNEW  DC    AL2(DALSTATS),AL2(1),AL2(1),XL1'04'\nDISPSHR  DC    AL2(DALSTATS),AL2(1),AL2(1),XL1'08'\nDISPDEL  DC    AL2(DALNDISP),AL2(1),AL2(1),XL1'04'\nDISPKEEP DC    AL2(DALNDISP),AL2(1),AL2(1),XL1'08'\nDISPCDEL DC    AL2(DALCDISP),AL2(1),AL2(1),XL1'04'\nCYLS     DC    AL2(DALCYL),AL2(0)\n         AIF   ('&CSPUN' NE 'TRK').SK3\nTRKS     DC    AL2(DALTRK),AL2(0)\n.SK3     ANOP\nDUMMY    DC    AL2(DALDUMMY),AL2(0)\nUNCOND   DC    AL2(DUNUNALC),AL2(0)\n         SPACE 1\nPARM1SK  DC    AL2(OPTL)\nOPT      DC    C'SIZE=100K'\nOPTL     EQU   *-OPT\n         SPACE 1\nOKMSG    MSG   'COMPRESS SUCCESSFUL'\nNPOMSG   MSG   'NOT PARTITIONED'\nGEMSG    MSG   'GETMAIN ERROR'\nBADMSG   MSG   'COMPRESS FAILED'\n         SPACE 1\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R9,R10,R12,R13\n         EJECT\n*------- LOCAL WORK-AREA --------------------------------------------*\nWKAREA   DSECT\nRB99P    DS    A\nRB99     DS    AL1\nRB99VR   DS    AL1                 VERB CODE\n         DS    AL2                 FLAGS\nRB99RC   DS    XL4                 ERROR-INFORMATION REASON CODES\nRB99TUP  DS    A\nRB99L    EQU   (S99RBEND-S99RB)-(*-RB99)\n         DS    (RB99L)X\nRB99TU   DS    13A\n         ORG   RB99TU\nRBLBTU   DS    A\nINNADDR  DS    A\nINVADDR  DS    A\nINPADDR  DS    A\n         DS    2A\nINDSORG  DS    A\n         ORG   RB99TU\nRBOUTU   DS    A\nOUDSNM   DS    A\n         DS    10A\nOURDSNM  DS    A\n         ORG   ,                   \"SKLTU\" MOVED BELOW\nINDDIN   DS    3AL2\nDDIN     DS    CL8\nINDDUT1  DS    3AL2\nINDD     DS    CL8\nINDDUT3  DS    3AL2\nDDUT3    DS    CL8\nINDDUT4  DS    3AL2\nDDUT4    DS    CL8\nINDSNAME DS    3AL2\nINDS     DS    CL44\nINVOLSER DS    3AL2\nINV      DS    CL6\nINPASS   DS    3AL2\nINP      DS    CL8\nRTNDSORG DS    3AL2\nDSORG    DS    XL2\nOUDDNAME DS    3AL2\nDDOUT    DS    CL8\nOUDSNAME DS    3AL2\nOUDS     DS    CL44\nSTSFX    EQU   OUDS+6,1\nOURTDS   DS    3AL2\nOURDS    DS    CL44\nPARMLIST DS    2F                  IEBCOPY PARM.LIST\n         DS    H\nPARM1    DS    H\n         DS    CL8\n         DS    H\nPARM2    DS    H\n         DS    4XL8\nPIN      DS    XL8                  5 - SYSIN\nPPRT     DS    XL8                  6 - SYSPRINT\n         DS    XL8\nPUT1     DS    XL8                  8 - SYSUT1\nPUT2     DS    XL8                  9 - SYSUT2\nPUT3     DS    XL8                 10 - SYSUT3\nPUT4     DS    XL8                 11 - SYSUT4\nDDAL     EQU   (*-PARM2)-L'PARM2\nWKLEN    EQU   (((*-WKAREA)+7)/8)*8\n         SPACE 1\n         PRINT &PRS\n        SPLTAREA\n         SPACE 1\n        MYSAVE\n         PRINT &PRF\n        IEFZB4D0\n        IEFZB4D2\n        DCBD   DSORG=(PS,PO),DEVD=DA\n        IEZIOB\n         PRINT GEN\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPSDEFS": {"ttr": 10243, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x07_\\x00\\x96\\x07_\\x111\\x00\\xa2\\x00\\xa2\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-03-15T00:00:00", "modifydate": "1996-03-15T11:31:00", "lines": 162, "newlines": 162, "modlines": 0, "user": "SYSPAJA"}, "text": "         GBLB  &ETPSSW\n*------- ETPS (MAIN MODULE) DEFINITIONS :\n         GBLC  &EATL\n         AIF   (&ETPSSW).MAIN1\n*- - - - (1) ATTENTION TABLE LENGTH :\n*              TO DEFINE IT, LOOK (DISPLAY DIRECTORY) AT THE MODULE\n*              \"IOSVATTN\" IN THE \"SYS1.AOSC5\" DATA-SET OF YOUR\n*              DLIB-PACK AND THEN, DEFINE BELOW THE MODULE LENGTH\n*              (HEXADECIMAL VALUE).\n*      NOTES : A) IF YOU DEFINE THE ATTENTION TABLE LENGTH AS NULL\n*                 (A '' VALUE), THE ATTENTION INSTALLATION CODE IS\n*                 NOT GENERATED (\"ETPS\" WORKS AS IN B).\n*              B) IF THE ENTRY IN THE ATTENTION TABLE CANNOT BE\n*                 INSTALLED, \"ETPS\" WORKS LOOPING ON THE I/O READ\n*                 EXCP EVERY TWO SECONDS.\n&EATL    SETC  'B0'                ATTENTION TABLE LENGTH (IOSVATTN)\n.MAIN1   ANOP\n         GBLC  &ESSO,&ESSM\n         AIF   (&ETPSSW).MAIN2\n*- - - - (2) MASTER USER/PASSWORD :\n*              WHEN \"ETPS\" IS STARTED WITH PARM='OPER....' (THE LOGON\n*              PANEL IS BYPASSED), THE DEFAULT (MASTER) USER NAME MUST\n*              BE DEFINED BELOW (SAME AS IN \"ICHRIN03\" IF RACF IS\n*              INSTALLED IN YOUR SYSTEM).\n&ESSO    SETC  'IBMUSER'           MASTER USER\n*              WITH HIS EVENTUAL DATA-SET PASSWORD (THIS IS NOT THE\n*              RACF PASSWORD).\n&ESSM    SETC  ''                  MASTER PASSWORD\n.MAIN2   ANOP\n         GBLA  &ESSN\n         GBLC  &ESSE(1)\n         AIF   (&ETPSSW).COMP\n*- - - - (3) OTHER USERS :\n*              A. WHEN RACF IS ACTIVE, A USER IS AUTHORIZED TO MODIFY\n*                 (DO \"ZAP\") SENSITIVE DATA-SETS (I.E. VTOC, ...)\n*                 AND/OR EXECUTE THE \"INCORZAP\" PROGRAM ONLY IF HE\n*                 HAS THE \"SPECIAL\" RACF ATTRIBUTE.\n*              B. WHEN RACF IS INACTIVE OR DOESN'T EXIST IN THE SYSTEM,\n*                 THE ONLY WAY A USER MAY RUN \"ETPS\" OUTSIDE \"TSO\" IS\n*                 TO DEFINE HIM HERE BELOW. NOTE THAT TO RUN ONLY IN\n*                 \"TSO\", IT IS NOT NECESSARY TO DEFINE HIM HERE BELOW,\n*                 UNLESS IF HE MUST BE AUTHORIZED TO MODIFY (DO \"ZAP\")\n*                 SENSITIVE DATA-SETS AND/OR EXECUTE \"INCORZAP\".\n&ESSN    SETA  1                   NUMBER OF USERS NAMES\n&ESSE(1) SETC  ''                  USERS NAMES ...\n.COMP    ANOP\n*------- ETPSCOMP (COMPRESS LIBRARY) DEFINITIONS :\n         GBLC  &CUNME,&CSPUN,&CPRIQ,&CSECQ,&CRCFM,&CBLSZ,&CLRCL\n         AIF   (&ETPSSW).EDIT\n*- - - - IEBCOPY SYSPRINT ALLOCATION :\n&CUNME   SETC  'VIO'               UNIT NAME\n&CSPUN   SETC  'TRK'               SPACE UNIT (TRK/CYL)\n&CPRIQ   SETC  '10'                PRIMARY QUANTITY\n&CSECQ   SETC  '30'                SECONDARY QUANTITY\n&CRCFM   SETC  'FBA'               RECORD FORMAT\n&CBLSZ   SETC  '605'               BLOCK SIZE\n&CLRCL   SETC  '121'               LOGICAL RECORD LENGTH\n.EDIT    ANOP\n*------- ETPSEDIT (DATA-SET EDITOR) DEFINITIONS :\n         GBLC  &ELIMT\n         AIF   (&ETPSSW).IDCA\n*- - - - THE THRESHOLD LIMIT IS THE MAXIMUM NUMBER OF CARDS THE EDIT\n*              IS ALLOWED TO HANDLE IN CORE STORAGE.\n&ELIMT   SETC  '50000'             THRESHOLD LIMIT\n.IDCA    ANOP\n*------- ETPSIDCA (IDCAMS INTERFACE) DEFINITIONS :\n         GBLC  &IUNME,&ISPUN,&IPRIQ,&ISECQ,&IRCFM,&IBLSZ,&ILRCL\n         AIF   (&ETPSSW).ZAP\n*- - - - IDCAMS SYSPRINT ALLOCATION :\n&IUNME   SETC  'VIO'               UNIT NAME\n&ISPUN   SETC  'TRK'               SPACE UNIT (TRK/CYL)\n&IPRIQ   SETC  '10'                PRIMARY QUANTITY\n&ISECQ   SETC  '30'                SECONDARY QUANTITY\n&IRCFM   SETC  'VBA'               RECORD FORMAT\n&IBLSZ   SETC  '629'               BLOCK SIZE\n&ILRCL   SETC  '125'               LOGICAL RECORD LENGTH\n.ZAP     ANOP\n*------- ETPSZAP (DATA-SET DISPLAY/MODIFY) DEFINITIONS :\n         GBLC  &ZUNME,&ZVLSR,&ZSPUN,&ZPRIQ,&ZSECQ\n         AIF   (&ETPSSW).ZAP1\n*- - - - (1) ZAP-LOG DATA-SET ALLOCATION :\n&ZUNME   SETC  'SYSALLDA'          UNIT NAME\n&ZVLSR   SETC  'USER00'            VOLUME SERIAL NUMBER\n&ZSPUN   SETC  'TRK'               SPACE UNIT (TRK/CYL)\n&ZPRIQ   SETC  '1'                 PRIMARY QUANTITY\n&ZSECQ   SETC  '5'                 SECONDARY QUANTITY\n.ZAP1    ANOP\n         GBLA  &ZSSN\n         GBLC  &ZSSE(4)\n         AIF   (&ETPSSW).IZP\n*- - - - (2) SENSITIVE DATA-SET'S NAMES PREFIXES TABLE :\n&ZSSN    SETA  4                   NO. OF ELEMENTS (PREFIXES) IN TABLE\n&ZSSE(1) SETC  'SYS1.'             MVS SYSTEM DATA-SETS\n&ZSSE(2) SETC  'SYSCTLG'           OLD OS CATALOGS\n&ZSSE(3) SETC  'CATALOG.'          MVS SYSTEM CATALOGS\n&ZSSE(4) SETC  'UCAT.'             MVS USERS CATALOGS\n.IZP     ANOP\n*------- ETPSIZAP (INCORZAP INTERFACE) DEFINITIONS :\n         GBLA  &IZNE\n         GBLC  &IZSL(3),&IZDS(3)\n         AIF   (&ETPSSW).IZP1\n*- - - - (1) NUCLEUS/LPA DATA-SET'S NAMES TABLE :\n&IZNE    SETA  3                   NO. OF ELEMENTS IN TABLE\n&IZSL(1) SETC  'N'                 NUCLEUS SELECTION CODE\n&IZDS(1) SETC  'SYS1.NUCLEUS'       \" \"    DATA-SET NAME\n&IZSL(2) SETC  'L'                 SYSTEM LPA SELECTION CODE\n&IZDS(2) SETC  'SYS1.LPALIB'        \" \"   \" \" DATA-SET NAME\n&IZSL(3) SETC  'P'                 LOCAL LPA SELECTION CODE\n&IZDS(3) SETC  'EUR1.LPALIB'        \" \"  \" \" DATA-SET NAME\n.IZP1    ANOP\n         GBLC  &IZUNM,&IZVSN,&IZSPU,&IZPRQ,&IZSCQ\n         AIF   (&ETPSSW).STAT\n*- - - - (2) INCORZAP \"PRT\" (SYSPRINT) ALLOCATION :\n&IZUNM   SETC  'SYSALLDA'          UNIT NAME\n&IZVSN   SETC  'USER00'            VOLUME SERIAL NUMBER\n&IZSPU   SETC  'TRK'               SPACE UNIT (TRK/CYL)\n&IZPRQ   SETC  '5'                 PRIMARY QUANTITY\n&IZSCQ   SETC  '10'                SECONDARY QUANTITY\n.STAT    ANOP\n*------- ETPSDSST (STATDS INTERFACE) DEFINITIONS :\n         GBLC  &STTMM,&STTMG\n         AIF   (&ETPSSW).DST\n*- - - - (1) PARTITIONED DATA-SETS PROGRAM LIMITS :\n&STTMM   SETC  '3000'              MAX. NUMBER OF \"REAL\" MEMBERS\n&STTMG   SETC  '1000'              MAX. NUMBER OF \"GAS\" MEMBERS\n.DST     ANOP\n         GBLC  &DPUNM,&DPVSN,&DPSPU,&DPPRQ,&DPSCQ\n         AIF   (&ETPSSW).DST1\n*- - - - (2) OUTPUT \"PRT\" (SYSPRINT) ALLOCATION :\n&DPUNM   SETC  'SYSALLDA'          UNIT NAME\n&DPVSN   SETC  'USER00'            VOLUME SERIAL NUMBER\n&DPSPU   SETC  'TRK'               SPACE UNIT (TRK/CYL)\n&DPPRQ   SETC  '5'                 PRIMARY QUANTITY\n&DPSCQ   SETC  '10'                SECONDARY QUANTITY\n.DST1    ANOP\n         GBLC  &DTUNM,&DTVSN,&DTSPU,&DTPRQ,&DTSCQ\n         AIF   (&ETPSSW).EVD\n*- - - - (3) OUTPUT \"TRC\" (TRACE) ALLOCATION :\n&DTUNM   SETC  'SYSALLDA'          UNIT NAME\n&DTVSN   SETC  'USER00'            VOLUME SERIAL NUMBER\n&DTSPU   SETC  'TRK'               SPACE UNIT (TRK/CYL)\n&DTPRQ   SETC  '5'                 PRIMARY QUANTITY\n&DTSCQ   SETC  '10'                SECONDARY QUANTITY\n.EVD     ANOP\n*------- ETPS VERSION DEFINITIONS :\n         GBLC  &VNUM\n         GBLC  &VMOD\n         GBLC  &VIDT\n         AIF   (&ETPSSW).END\n&VNUM    SETC  '2'                 VERSION NUMBER\n&VMOD    SETC  '4'                  \" \"    MODIFICATION\n&VIDT    SETC  'EU'                 \" \"    IDENTIFICATION\n         AIF   (K'&VNUM EQ 1).OKVN\n         MNOTE 8,' INVALID VERSION NUMBER ************************** '\n.OKVN    AIF   (K'&VMOD EQ 1).OKVM\n         MNOTE 8,' INVALID VERSION MODIFICATION ******************** '\n.OKVM    AIF   (K'&VIDT EQ 1).OKVI\n         AIF   (K'&VIDT EQ 2).OKVI\n         MNOTE 8,' INVALID VERSION IDENTIFICATION ****************** '\n.OKVI    ANOP\n&ETPSSW  SETB  1\n.END     ANOP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPSDSST": {"ttr": 10247, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x07?\\x00\\x96\\x07?\\x16Q\\x0cN\\x0cN\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-03-13T00:00:00", "modifydate": "1996-03-13T16:51:00", "lines": 3150, "newlines": 3150, "modlines": 0, "user": "SYSPAJA"}, "text": "DSST     TITLE '--- E T P S -- ETPSDSST - DATA-SET STATISTICS ---'\n         PRINT OFF\n         COPY  ETPS$O2A            \"ETPS\" SYSPARM SELECTION\n         MACRO\n&LBL    HEXES  &SRC,&NUM,&OUT      OUTPUT LOOKS LIKE C1.C2.C3 ...\n         LCLC  &ONE                  FOR NUM SOURCE CHARACTERS\n&ONE     SETC  'HX'.'&SYSNDX'\n&LBL     XR    R15,R15\n         LA    R14,&NUM\n         LR    R1,R14\n         BCTR  R1,0\n         LA    R1,&NUM.(R1,R1)     LAST PERIOD AT (N-1)*3+1\n         LA    R1,&OUT.(R1)\n         SH    R1,=H'3'            OUTPUT START LOCATION\n&ONE     LA    R15,&SRC            SOURCE BASE ADDRESS\n         XR    R0,R0\n         BCTR  R15,0\n         IC    R0,0(R14,R15)       INPUT CHARACTER\n         LR    R15,R0\n         N     R15,=F'15'\n         IC    R15,HEXTBL(R15)\n         STC   R15,2(,R1)          LOW NIBBLE\n         LR    R15,R0\n         SRL   R15,4\n         IC    R15,HEXTBL(R15)\n         STC   R15,1(,R1)          HIGH NIBBLE\n         MVI   0(R1),C'.'          SEPARATOR\n         SH    R1,=H'3'            BACK UP 3 IN OUTPUT ADDRESS\n         BCT   R14,&ONE            DO PREVIOUS INPUT CHARACTER\n         MVI   3(R1),C' '          BLANK THE LEADING PERIOD\n         MEND\n         MACRO\n&LBL    MVMSG  &MS,&R=R1           MOVE MESSAGE MACRO\n&LBL     L     &R,=A(&MS)          GET MESSAGE TEXT ADDRESS\n         MVC   WRKLNE(L'&MS),0(&R) MOVE MESSAGE TEXT\n         MEND\n         MACRO\n&LBL    OUTPT  &R0,&R1,&LN,&A=I    OUTPUT MACRO\n         AIF   ('&LN' NE '').NOR0\n&LBL     LA    R15,L'&R1           LENGTH OF STRING\n         AGO   .NOR1\n.NOR0    ANOP\n&LBL     LA    R15,&LN             LENGTH OF STRING\n.NOR1    AIF   ('&R0' EQ 'R0').NOR2\n         L     R0,&R0              NUMBER TO BE OUTPUT\n.NOR2    AIF   ('&R1' EQ 'R1').NOR4\n         AIF   ('&A' EQ 'I').NOR3\n         LA    R1,&R1              STRING TO FOLLOW\n         AGO   .NOR4\n.NOR3    L     R1,=A(&R1)          ADDRESS OF STRING TO FOLLOW\n.NOR4    BAL   R14,OUTRTN          OUTPUT ROUTINE\n         AIF   ('&R1' NE 'WRKLNE').MEND\n         MVC   WRKLNE,ZBLKS\n.MEND    MEND\n         MACRO\n&LBL    TTRMBB &TTR,&MBB=DOUBLE    TTR TO MBBCCHHR CONVERSION MACRO\n&LBL     STM   R14,R12,12(R13)\n         XR    R0,R0\n         ICM   R0,B'1110',&TTR     GET TTR INTO R0\n         L     R1,DCBDEBAD         DEB ADDRESS\n         LA    R2,&MBB             RESULT ADDRESS\n         LR    R3,R13              SAVE SAVE-AREA REGISTER\n         L     R15,CVTPTR          CVT POINTER\n         USING CVT,R15             CVT ADDRESSABILITY\n         L     R15,CVTPCNVT        TTRN TO MBBCCHHR ROUTINE ADDRESS\n         DROP  R15\n         BALR  R14,R15\n         LR    R13,R3\n         LM    R14,R12,12(R13)\n         MEND\n         COPY  ETPSMACS            \"ETPS\" MACROS\n         COPY  ETPSDEFS            \"ETPS\" DEFINITIONS\n         PRINT ON\nETPSDSST START 0\n         SPACE 1\nETPSDSST AMODE 24\nETPSDSST RMODE 24\n        MIDENT\n         EJECT\n*------- AT ENTRY, R1 = A(PARM.LIST) -> (DS-NAME,\n*                                        VOL-SER,\n*                                        PASSWORD,\n*                                        USER-ID)\n         SPACE 1\n         PRINT GEN\n         USING *,R12,R11\n         USING SAVE2,R13      ************************** R13 ==> SAVE2\n         USING SPLTAREA,R10   AT ENTRY : R10 MUST POINT TO \"SPLTAREA\"\n         B     32(,R15)\n         DC    CL28'  ETPSDSST &SYSDATE &SYSTIME'\n         PRINT &PRF\n         STM   R14,R12,12(R13)     SAVE INPUT REGISTERS\n         LR    R12,R15             SET PROGRAM BASE REGISTER 1\n         LA    R3,1\n         LA    R11,4*KB-1(R3,R12)  SET PROGRAM BASE REGISTER 2\n         LR    R3,R10              SPLIT-SCREEN DSECT\n         SH    R3,=Y(SPLITWRK-SAVE2) POINT TO SAVE2\n         ST    R13,4(,R3)          STORE BACKWARD POINTER\n         ST    R3,8(R13)           STORE FORWARD POINTER\n         LR    R13,R3              SET SAVE-AREA POINTER\n         LR    R5,R1               RETAIN PARM.LIST POINTER\n         L     R0,=A(DWALEN)\n        GETMAIN RC,LV=(0)          GET \"DWAREA\" WORK-AREA\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    DSTINIT             OK\n        XMESS  5001,R15            ERROR\n         LA    R1,SGMMSG\n         ST    R1,MSGADD\n         B     DSTGBK\nDSTINIT  LR    R0,R1\n         LR    R9,R1\n         L     R1,=A(DWL1)\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R0,R14              CLEAR ALL TO BINARY ZEROS\n         USING DWAREA,R9\n         MVC   EYECATCH,=CL8'X.STATDS'\n         LM    R1,R4,0(R5)         PICK UP 3 PARMS\n*                                    R1=DS-NAME\n*                                    R2=VOL-SER\n*                                    R3=PASSWORD (IF ANY)\n*                                    R4=USER-ID\n         MVC   DSSTDSN(L'DSSTDSN),0(R1) DS-NAME\n         MVC   DSSTVOL(L'DSSTVOL),0(R2) VOL-SER\n         MVC   DSSTPSW(L'DSSTPSW),0(R3) PASSWORD\n         MVC   DSSTUID(L'DSSTUID),0(R4) USER-ID\n         MVC   DSSTDDN,N#IN\n         MVC   DSPRTDDN,N#PRINT\n         MVC   DSTRCDDN,N#UT1\n*- - - - ALLOCATE THE FILE\n         L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         MVC   DDNAME,DSSTDDN      DD-NAME\n         MVC   DSNAME,DSSTDSN      DS-NAME\n         MVC   DSVOLSER,DSSTVOL    VOL-SER\n         MVC   PASSWORD,DSSTPSW    PASSWORD\n         MVC   DSSTATUS,=CL8'SHR'  SET DISP=SHR\n         DROP  R2\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    DSTSTTM             OK\n        XMESS  5009\n         LA    R1,ALFMSG\n         ST    R1,MSGADD\n         B     DSTEXIT             YUP - ALL DONE\n*- - - - SET UP THE PROCESS PARM ENTRY SCREEN\nDSTSTTM  LA    R4,TERMOUT+4        PICK UP ADDRESS OF FIRST OUTPUT LINE\n         L     R8,SCROWS           PICK UP NUMBER OF ROWS\n         CLI   SPLIT,0             AM I DOING SPLIT-SCREEN?\n         BE    DSTSTNX             NOPE\n         L     R8,SCROWS1          PICK UP NUMBER OF ROWS ON SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   DSTSTNX             NO, GO DO IT\n         SLL   R8,2                MULTIPLY BY 4\n         LA    R4,TERMOUT+4(R8)    SET ADDRESS OF FIRST OUTPUT LINE\n         L     R8,SCROWS2          PICK UP NUMBER OF ROWS ON SCREEN 2\nDSTSTNX  LM    R2,R3,=A(NDSROW,ADSROW) NUMBER AND ADDRESSES OF ROWS\nDSTLOOP  NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R14,0(,R4)          PICK UP ADDRESS OF OUTPUT LINE\n         L     R15,0(,R3)          GET DATA LINE ADDRESS\n         XR    R5,R5\n         IC    R5,0(,R15)          GET DATA LINE LENGTH\n         EX    R5,*+L'*+8          FILL IN LINE\n         BCT   R8,*+L'*+10\n         B     DSTCKSL\n         MVC   0(*-*,R14),0(R15)   <<EXECUTED>>\n         LA    R3,4(,R3)           NEXT TEXT ROW\n         BCT   R2,*+L'*+4\n         B     DSTFILL\n         LA    R4,4(,R4)           BUMP\n         B     DSTLOOP\nDSTFILL  LA    R4,4(,R4)           BUMP\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R14,0(,R4)          PICK UP ADDRESS OF NEXT OUTPUT LINE\n         MVC   0(BLNKLL,R14),BLNKL FILL IN A BLANK LINE\n         BCT   R8,DSTFILL\nDSTCKSL  CLI   SPLIT,1             AM I DOING SPLIT-SCREEN 1?\n         BE    *+L'*+4             YES\n         OI    0(R4),EOS           NO, SET END-OF-SCREEN\n         L     R15,=A(DSTHELP)     HELP SCREEN\n         ST    R15,HELPADD\n         MVI   CURROW,CRDSTC       CURSOR ROW\n         MVI   CURCOL,CCDSTC       CURSOR COLUMN\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         LTR   R15,R15             BAD RC?\n         BNZ   DSTEOJ              OUT\n         TM    COMMSW,PFKFLAG      PFK/ATTN ENTERED?\n         BZ    DSTSTTS             NONE\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    DSTEOJ              YUP, OUT\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BE    DSTEOJ              YUP, OUT\n         CLI   0(R2),X'6C'         IS IT PA1?\n         BE    DSTEOJ              YUP, OUT\n         CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    DSTSTTM             YUP, RESHOW SCREEN\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    DSTSTTM             YUP, RESHOW SCREEN\n         LA    R1,IPFMSG\nDSTSTMS  ST    R1,MSGADD\n         B     DSTSTTM\n*- - - - CHECK ENTERED PROCESSING PARM\nDSTSTTS  XC    PRMFLD,PRMFLD       SET NO PARM.FIELD\n         L     R5,TERMINPT+DSI     PICK UP SELECT FIELD\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+12            NOPE\n         L     R3,SCROWS1          PICK UP SIZE OF SCREEN 1\n         SLL   R3,2                MULTIPLY BY 4\n         L     R5,TERMINPT+DSI(R3) PICK UP SELECT FIELD\n         CLI   0(R5),0             PARM ENTERED?\n         BE    DSTXEQ              NO, NONE\n         LA    R0,L'DSTCF1-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   DSTCF1(R5),C' '\n         BNE   *+L'*+18\n         MVC   DSTCF1(L'DSTCF1-1,R5),DSTCF1+1(R5)\n         MVI   DSTCF1+L'DSTCF1-1(R5),C' '\n         BCT   R0,*-18\n         B     DSTXEQ              NONE\n         MVC   PRMTXT(L'PRMTXT),DSTCF1(R5)   COPY PARM.FIELD\n         LA    R1,PRMTXT+L'PRMTXT-1\n         CLI   0(R1),C' '\n         BNE   *+L'*+4\n         BCT   R1,*-8\n         LA    R0,PRMTXT-1         VERIFY PARM.FIELD\n         SR    R1,R0\n         STH   R1,PRMFLD\n         BNP   DSTXEQ\n         CH    R1,=H'13'           IS PARM LENGTH 13?\n         BE    *+L'*+8             YES\n         CH    R1,=H'8'            IS PARM LENGTH 8?\n         BNE   DSTWHAT             NO, GO SEE WHAT ELSE\n         CLC   PRMTXT(4),=CL4'GAS(' PARM=GAS(TT.TT.RR) OR GAS(ALL)?\n         BNE   DSTWHAT             NO, GO SEE WHAT ELSE\n         CH    R1,=H'8'            IS PARM LENGTH 8?\n         BNE   DSTGTTR             NO\n         CLC   PRMTXT+4(4),=CL4'ALL)' CONTROL SYNTAX\n         BE    DSTXEQ\nDSTWRNG  LA    R1,WRNMSG\n         B     DSTSTMS\nDSTGTTR  CLI   PRMTXT+6,C'.'       CONTROL SYNTAX\n         BNE   DSTWRNG\n         CLI   PRMTXT+9,C'.'\n         BNE   DSTWRNG\n         CLI   PRMTXT+12,C')'\n         BNE   DSTWRNG\n         MVC   DSSTWK(L'DSSTWK),PRMTXT+4 SAVE TT.TT.RR\n         LA    R0,8                TT.TT.RR CONTROL\n         LA    R15,DSSTWK+L'DSSTWK-1\nDSTHXL   CLI   0(R15),C'.'\n         BE    DSTHXI\n         CLI   0(R15),C'A'\n         BL    DSTWRNG\n         CLI   0(R15),C'F'\n         BNH   DSTHXI\n         CLI   0(R15),C'0'\n         BL    DSTWRNG\n         CLI   0(R15),C'9'\n         BH    DSTWRNG\nDSTHXI   BCTR  R15,0\n         BCT   R0,DSTHXL\n         B     DSTXEQ\nDSTWHAT  CLI   PRMTXT,C'U'         PARM=U SAME AS NO PARM\n         BE    DSTXEQ              YES, BRANCH\n         CLI   PRMTXT,C'N'         NO, ARE GAS RECORDS DESIRED?\n         BE    DSTXEQ              YES, BRANCH\n         CLI   PRMTXT,C'F'         NO, FULLY INFORMATION LIST?\n         BE    DSTXEQ              YES, BRANCH\n         CLI   PRMTXT,C'T'         NO, TEST INFORMATION LIST?\n         BE    DSTXEQ              YES, BRANCH\n         CLI   PRMTXT,C'L'         NO, LABEL INFORMATION ONLY?\n         BE    DSTXEQ              YES, BRANCH\n         LA    R1,UNKMSG\n         B     DSTSTMS\nDSTXEQ   MVI   DSPRTDSN,C' '       RESET \"PRT\" DS-NAME\n         MVC   DSPRTDSN+1(L'DSPRTDSN-1),DSPRTDSN\n         MVC   DSTRCDSN,DSPRTDSN   RESET \"TRC\" DS-NAME\n         L     R15,=A(ETPSXDST)\n*- - - - ETPSXDST PARM. LIST : PARM.FIELD\n        CALL   (15),(PRMFLD),VL,MF=(E,PARMVL) INVOKE STATDS PROGRAM\n         CLI   DSPRTDSN,C' '       IS THERE A \"PRT\" DS-NAME?\n         BE    DSTTEST             NO\n*- - - - BUILD \"PRT\" ENTRY SCREEN\n         NI    PRFLGS,255-VIEWFLG-DELFLG-ALTFLG RESET ALL\nDPRBLD   L     R5,=A(DPRSCR)\n         L     R4,SCROWS1          NUMBER OF ROWS IN SCREEN 1\n         LA    R3,TERMOUT+4        POINT TO FIRST LINE OF SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2\n         BNE   DPRBLD1             NOPE, I'M ALL SET\n         SLL   R4,2                MULTIPLY OFFSET BY 4\n         LA    R3,TERMOUT+4(R4)    POINT TO ROW 1 OF SCREEN 2\n         L     R4,SCROWS2          NUMBER OF ROWS IN SCREEN 2\nDPRBLD1  NI    0(R3),255-EOS       CLEAR END-OF-SCREEN\n         L     R2,0(,R5)           ADDRESS OF FROM FIELD\n         L     R6,0(,R3)           ADDRESS OF \"TO\" FIELD\n         XR    R1,R1\n         IC    R1,0(,R2)           PICK UP LENGTH\n         EX    R1,DPRMVL           MOVE IT\n         CLC   DPOFF1(10,R6),=CL10'PRINT VIEW' VIEWING?\n         BNE   DPRBLD2             NO\n         TM    PRFLGS,VIEWFLG      YES\n         BO    *+L'*+10\n         MVC   DPSCF1(2,R6),=CL2'NO' SET \"NO\"\n         B     DPRBLD3             DO THE REST\n         MVC   DPSCF1(3,R6),=CL3'YES' SET \"YES\"\n         B     DPRBLD3             DO THE REST\nDPRMVL   MVC   0(*-*,R6),0(R2)     <<EXECUTED>>\nDPRBLD2  CLC   DPOFF2(8,R6),=CL8'AND / OR' DELETE?\n         BNE   DPRBLD3             NO\n         TM    PRFLGS,DELFLG       YES\n         BO    *+L'*+10\n         MVC   DPSCF2(2,R6),=CL2'NO' SET \"NO\"\n         B     DPRBLD3             DO THE REST\n         MVC   DPSCF2(3,R6),=CL3'YES' SET \"YES\"\nDPRBLD3  TM    0(R5),EOL           END-OF-LIST?\n         BO    DPRBLD4             YUP\n         BCT   R4,*+L'*+4          END OF SCREEN ROWS?\n         B     DPRBLD5             YUP\n         LA    R5,4(R5)            BUMP TO NEXT PARM\n         LA    R3,4(R3)            BUMP TO NEXT PARM\n         B     DPRBLD1             KEEP LOOPING\nDPRBLD4  BCT   R4,*+L'*+4          END OF SCREEN ROWS?\n         B     DPRBLD5             YUP\n         LA    R3,4(R3)            BUMP TO NEXT PARM\n         L     R6,0(,R3)           ADDRESS OF \"TO\" FIELD\n         NI    0(R3),255-EOS       CLEAR END-OF-SCREEN\n         MVC   0(BLNKLL,R6),BLNKL  MOVE IN A DUMMY ROW\n         B     DPRBLD4             KEEP LOOPING\nDPRBLD5  CLI   SPLIT,1             AM I IN SPLIT-SCREEN, SCREEN 1?\n         BE    *+L'*+4             YES\n         OI    0(R3),EOS           SET END-OF-SCREEN\n         L     R15,=A(DPRHELP)     HELP SCREEN\n         ST    R15,HELPADD\n         TM    PRFLGS,ALTFLG       ALTERNATE POSITION?\n         BO    *+L'*+12            YES\n         MVI   CURROW,CRDPSC       CURSOR ROW\n         MVI   CURCOL,CCDPSC       CURSOR COLUMN\n         B     *+L'*+8\n         MVI   CURROW,CRAPSC       ALTERNATE CURSOR ROW\n         MVI   CURCOL,CCAPSC       ALTERNATE CURSOR COLUMN\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         LTR   R15,R15             BAD RC?\n         BNZ   DSTEOJ              YUP\n         TM    COMMSW,PFKFLAG      IS IT A PF KEY/ATTN?\n         BZ    DPCKINPT            NOPE, GO CHECK THE INPUT\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    DPCKINPT            YUP, LIKE ENTER\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BE    DPCKINPT            YUP, LIKE ENTER\n         CLI   0(R2),X'6C'         IS IT PA1?\n         BE    DSTTEST             YUP, FORCE LIKE NO VIEW / NO DELETE\n         CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    DPRBLD              YUP, RESHOW SCREEN\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    DPRBLD              YUP, RESHOW SCREEN\n         LA    R1,IPFMSG\nDPRMSG   ST    R1,MSGADD\n         B     DPRBLD              RESHOW SCREEN\n*- - - - CHECK ENTERED \"PRT\" SELECTIONS\nDPCKINPT NI    PRFLGS,255-ALTFLG-POCFLG RESET ALTERNATE AND CHANGED\n         L     R5,TERMINPT+DPZ1    PICK UP VIEWING FIELD\n         L     R6,TERMINPT+DPZ2    PICK UP DELETE FIELD\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   DPCKINPV            NOPE\n         L     R3,SCROWS1          PICK UP SIZE OF SCREEN 1\n         SLL   R3,2                MULTIPLY BY 4\n         L     R5,TERMINPT+DPZ1(R3) PICK UP VIEWING FIELD\n         L     R6,TERMINPT+DPZ2(R3) PICK UP DELETE FIELD\nDPCKINPV CLI   0(R5),0             VIEWING ENTERED (OR CHANGED)?\n         BE    DPCKINPD            NO\n         OI    PRFLGS,POCFLG       YES, SAY PANEL OPTION CHANGED\n         LA    R0,L'DPSCF1-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   DPSCF1(R5),C' '\n         BNE   DPSTVW\n         MVC   DPSCF1(L'DPSCF1-1,R5),DPSCF1+1(R5)\n         MVI   DPSCF1+L'DPSCF1-1(R5),C' '\n         BCT   R0,*-18\nDPRSVW   NI    PRFLGS,255-VIEWFLG  RESET VIEW REQUEST\n         B     DPCKINPD\nDPSTVW   CLI   DPSCF1(R5),C'N'\n         BE    DPRSVW\n         CLI   DPSCF1(R5),C'Y'\n         BE    *+L'*+8\n         LA    R1,IOPMSG\n         B     DPRMSG\n         OI    PRFLGS,VIEWFLG      SET VIEW REQUESTED\nDPCKINPD CLI   0(R6),0             DELETE ENTERED?\n         BE    DPROCHK             NO\n         OI    PRFLGS,POCFLG       YES, SAY PANEL OPTION CHANGED\n         LA    R0,L'DPSCF2-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   DPSCF2(R6),C' '\n         BNE   DPSTDL\n         MVC   DPSCF2(L'DPSCF2-1,R6),DPSCF2+1(R6)\n         MVI   DPSCF2+L'DPSCF2-1(R6),C' '\n         BCT   R0,*-18\nDPRSDL   NI    PRFLGS,255-DELFLG   RESET DELETE REQUEST\n         B     DPROCHK\nDPSTDL   CLI   DPSCF2(R6),C'N'\n         BE    DPRSDL\n         CLI   DPSCF2(R6),C'Y'\n         BE    *+L'*+12\n         OI    PRFLGS,ALTFLG\n         LA    R1,IOPMSG\n         B     DPRMSG\n         OI    PRFLGS,DELFLG       SET VIEW REQUESTED\nDPROCHK  TM    PRFLGS,POCFLG       ANY OPTION CHANGED?\n         BO    DPRBLD              YES, RESHOW\n         TM    PRFLGS,VIEWFLG+DELFLG HOW SELECTION IS?\n         BZ    DPKEPT              NO VIEW / NO DELETE\n         TM    PRFLGS,VIEWFLG      VIEW REQUESTED?\n         BZ    DPBRWOK             NO\n         ICM   R15,B'1111',ARBROWSE YES, VERIFY BROWSE AVAILABLE?\n         BNZ   DPBRWOK             YES, OK\n        LOAD   EP=ETPSBROW,ERRET=DLBRERR\n         ST    R0,ARBROWSE         LOADED, OK\n*- - - - PROCESS THE \"PRT\" DATA-SET\nDPBRWOK  L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         MVC   DSNAME,DSPRTDSN     DS-NAME\n         MVC   DSVOLSER,DSPRTVOL   VOL-SER\n         MVC   DSSTATUS,=CL8'SHR'  SET DISP=SHR\n         TM    PRFLGS,DELFLG       DELETE REQUESTED?\n         BZ    *+L'*+12            NO\n         MVC   DSNDISP,=CL8'UNCATLG' YES, SET DISP=(SHR,UNCATLG,KEEP)\n         MVC   DSADISP,=CL8'KEEP'\n         L     R4,ACOPDCB          PICK UP LIBRARY ADDRESS\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DDNAME\n         MVC   0(DPRDCBL,R4),DPRDCB MOVE DCB SKELETON\n         MVC   DCBDDNAM-IHADCB(L'DCBDDNAM,R4),DDNAME SET BACK DDNAME\n         DROP  R2\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    DPALLOK             OK\n        XMESS  5010\n         TM    PRFLGS,VIEWFLG      VIEW REQUESTED?\n         BZ    *+L'*+8             NO\n         LA    R1,DPRVMSG          YES\n         B     DPRTMSG             YUP - ALL DONE\n         LA    R1,DPRUMSG\nDPRTMSG  ST    R1,MSGADD           YUP - ALL DONE\n         B     DSTTEST\nDPALLOK  TM    PRFLGS,VIEWFLG      VIEW REQUESTED?\n         BZ    DPFREE              NO\n         LA    R2,DSPRTDSN         YES\n         LA    R3,=CL8' '\n         L     R15,ARBROWSE\n*- - - - ETPSBROW PARM.LIST : DCB, DS-NAME, MEMBER-NAME\n        CALL   (15),((R4),(R2),(R3)),VL,MF=(E,PARMVL)\nDPFREE   L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DDNAME\n         DROP  R2\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    DPFROK              OK\n        XMESS  5013\n         TM    PRFLGS,VIEWFLG      VIEW REQUESTED?\n         BZ    *+L'*+8             NO\n         LA    R1,DFPVMSG          YES\n         B     DPRTMSG             YUP - ALL DONE\n         LA    R1,DFPUMSG\n         B     DPRTMSG             YUP - ALL DONE\nDPFROK   TM    PRFLGS,DELFLG       DELETE REQUESTED?\n         BO    DPDEL               YES\nDPKEPT   LA    R1,DPKMSG           NO, KEPT\n         B     DPRTMSG\nDPDEL    L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         MVC   DSNAME,DSPRTDSN     DS-NAME\n         MVC   DSVOLSER,DSPRTVOL   VOL-SER\n         MVC   DSSTATUS,=CL8'SHR'  SET DISP=SHR\n         MVC   DSNDISP,=CL8'DELETE' SET DISP=(SHR,DELETE,DELETE)\n         MVC   DSADISP,=CL8'DELETE'\n         L     R4,ACOPDCB          PICK UP LIBRARY ADDRESS\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) GET DDNAME FOR USE\n         DROP  R2\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    DPDLAOK             OK\n        XMESS  5010\n         LA    R1,DPRDMSG\n         B     DPRTMSG             YUP - ALL DONE\nDPDLAOK  L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         USING PARMLIST,R2\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DDNAME\n         DROP  R2\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BNZ   *+L'*+8             WITH ERROR\n         LA    R1,DPDMSG           OK\n         B     DPRTMSG             YUP - ALL DONE\n        XMESS  5013\n         LA    R1,DFPDMSG\n         B     DPRTMSG             YUP - ALL DONE\nDLBRERR  STM   R0,R1,MESSPL        BROWSE IS UNAVAILABLE\n        XMESS  99,R15\n         LA    R1,BLDMSG\n         B     DPRTMSG             YUP - ALL DONE\nDSTTEST  CLI   DSTRCDSN,C' '       IS THERE A \"TRC\" DS-NAME?\n         BE    DSTSTTM             NO\n*- - - - BUILD \"TRC\" ENTRY SCREEN\n         NI    PRFLGS,255-VIEWFLG-DELFLG-ALTFLG RESET ALL\nDTRBLD   L     R5,=A(DTRSCR)\n         L     R4,SCROWS1          NUMBER OF ROWS IN SCREEN 1\n         LA    R3,TERMOUT+4        POINT TO FIRST LINE OF SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2\n         BNE   DTRBLD1             NOPE, I'M ALL SET\n         SLL   R4,2                MULTIPLY OFFSET BY 4\n         LA    R3,TERMOUT+4(R4)    POINT TO ROW 1 OF SCREEN 2\n         L     R4,SCROWS2          NUMBER OF ROWS IN SCREEN 2\nDTRBLD1  NI    0(R3),255-EOS       CLEAR END-OF-SCREEN\n         L     R2,0(,R5)           ADDRESS OF FROM FIELD\n         L     R6,0(,R3)           ADDRESS OF \"TO\" FIELD\n         XR    R1,R1\n         IC    R1,0(,R2)           PICK UP LENGTH\n         EX    R1,DTRMVL           MOVE IT\n         CLC   DTOFF1(10,R6),=CL10'TRACE VIEW' VIEWING?\n         BNE   DTRBLD2             NO\n         TM    PRFLGS,VIEWFLG      YES\n         BO    *+L'*+10\n         MVC   DTSCF1(2,R6),=CL2'NO' SET \"NO\"\n         B     DTRBLD3             DO THE REST\n         MVC   DTSCF1(3,R6),=CL3'YES' SET \"YES\"\n         B     DTRBLD3             DO THE REST\nDTRMVL   MVC   0(*-*,R6),0(R2)     <<EXECUTED>>\nDTRBLD2  CLC   DTOFF2(8,R6),=CL8'AND / OR' DELETE?\n         BNE   DTRBLD3             NO\n         TM    PRFLGS,DELFLG       YES\n         BO    *+L'*+10\n         MVC   DTSCF2(2,R6),=CL2'NO' SET \"NO\"\n         B     DTRBLD3             DO THE REST\n         MVC   DTSCF2(3,R6),=CL3'YES' SET \"YES\"\nDTRBLD3  TM    0(R5),EOL           END-OF-LIST?\n         BO    DTRBLD4             YUP\n         BCT   R4,*+L'*+4          END OF SCREEN ROWS?\n         B     DTRBLD5             YUP\n         LA    R5,4(R5)            BUMP TO NEXT PARM\n         LA    R3,4(R3)            BUMP TO NEXT PARM\n         B     DTRBLD1             KEEP LOOPING\nDTRBLD4  BCT   R4,*+L'*+4          END OF SCREEN ROWS?\n         B     DTRBLD5             YUP\n         LA    R3,4(R3)            BUMP TO NEXT PARM\n         L     R6,0(,R3)           ADDRESS OF \"TO\" FIELD\n         NI    0(R3),255-EOS       CLEAR END-OF-SCREEN\n         MVC   0(BLNKLL,R6),BLNKL  MOVE IN A DUMMY ROW\n         B     DTRBLD4             KEEP LOOPING\nDTRBLD5  CLI   SPLIT,1             AM I IN SPLIT-SCREEN, SCREEN 1?\n         BE    *+L'*+4             YES\n         OI    0(R3),EOS           SET END-OF-SCREEN\n         L     R15,=A(DTRHELP)     HELP SCREEN\n         ST    R15,HELPADD\n         TM    PRFLGS,ALTFLG       ALTERNATE POSITION?\n         BO    *+L'*+12            YES\n         MVI   CURROW,CRDTSC       CURSOR ROW\n         MVI   CURCOL,CCDTSC       CURSOR COLUMN\n         B     *+L'*+8\n         MVI   CURROW,CRATSC       ALTERNATE CURSOR ROW\n         MVI   CURCOL,CCATSC       ALTERNATE CURSOR COLUMN\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         LTR   R15,R15             BAD RC?\n         BNZ   DSTEOJ              YUP\n         TM    COMMSW,PFKFLAG      IS IT A PF KEY/ATTN?\n         BZ    DTCKINPT            NOPE, GO CHECK THE INPUT\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    DTCKINPT            YUP, LIKE ENTER\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BE    DTCKINPT            YUP, LIKE ENTER\n         CLI   0(R2),X'6C'         IS IT PA1?\n         BE    DSTSTTM             YUP, FORCE LIKE NO VIEW / NO DELETE\n         CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    DTRBLD              YUP, RESHOW SCREEN\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    DTRBLD              YUP, RESHOW SCREEN\n         LA    R1,IPFMSG\nDTRMSG   ST    R1,MSGADD\n         B     DTRBLD              RESHOW SCREEN\n*- - - - CHECK ENTERED \"TRC\" SELECTIONS\nDTCKINPT NI    PRFLGS,255-ALTFLG-POCFLG RESET ALTERNATE AND CHANGED\n         L     R5,TERMINPT+DTZ1    PICK UP VIEWING FIELD\n         L     R6,TERMINPT+DTZ2    PICK UP DELETE FIELD\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   DTCKINPV            NOPE\n         L     R3,SCROWS1          PICK UP SIZE OF SCREEN 1\n         SLL   R3,2                MULTIPLY BY 4\n         L     R5,TERMINPT+DTZ1(R3) PICK UP VIEWING FIELD\n         L     R6,TERMINPT+DTZ2(R3) PICK UP DELETE FIELD\nDTCKINPV CLI   0(R5),0             VIEWING ENTERED (OR CHANGED)?\n         BE    DTCKINPD            NO\n         OI    PRFLGS,POCFLG       YES, SAY PANEL OPTION CHANGED\n         LA    R0,L'DTSCF1-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   DTSCF1(R5),C' '\n         BNE   DTSTVW\n         MVC   DTSCF1(L'DTSCF1-1,R5),DTSCF1+1(R5)\n         MVI   DTSCF1+L'DTSCF1-1(R5),C' '\n         BCT   R0,*-18\nDTRSVW   NI    PRFLGS,255-VIEWFLG  RESET VIEW REQUEST\n         B     DTCKINPD\nDTSTVW   CLI   DTSCF1(R5),C'N'\n         BE    DTRSVW\n         CLI   DTSCF1(R5),C'Y'\n         BE    *+L'*+8\n         LA    R1,IOPMSG\n         B     DTRMSG\n         OI    PRFLGS,VIEWFLG      SET VIEW REQUESTED\nDTCKINPD CLI   0(R6),0             DELETE ENTERED?\n         BE    DTROCHK             NO\n         OI    PRFLGS,POCFLG       YES, SAY PANEL OPTION CHANGED\n         LA    R0,L'DTSCF2-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   DTSCF2(R6),C' '\n         BNE   DTSTDL\n         MVC   DTSCF2(L'DTSCF2-1,R6),DTSCF2+1(R6)\n         MVI   DTSCF2+L'DTSCF2-1(R6),C' '\n         BCT   R0,*-18\nDTRSDL   NI    PRFLGS,255-DELFLG   RESET DELETE REQUEST\n         B     DTROCHK\nDTSTDL   CLI   DTSCF2(R6),C'N'\n         BE    DTRSDL\n         CLI   DTSCF2(R6),C'Y'\n         BE    *+L'*+12\n         OI    PRFLGS,ALTFLG\n         LA    R1,IOPMSG\n         B     DTRMSG\n         OI    PRFLGS,DELFLG       SET VIEW REQUESTED\nDTROCHK  TM    PRFLGS,POCFLG       ANY OPTION CHANGED?\n         BO    DTRBLD              YES, RESHOW\n         TM    PRFLGS,VIEWFLG+DELFLG HOW SELECTION IS?\n         BZ    DTKEPT              NO VIEW / NO DELETE\n         TM    PRFLGS,VIEWFLG      VIEW REQUESTED?\n         BZ    DTBRWOK             NO\n         ICM   R15,B'1111',ARBROWSE YES, VERIFY BROWSE AVAILABLE?\n         BNZ   DTBRWOK             YES, OK\n        LOAD   EP=ETPSBROW,ERRET=TLBRERR\n         ST    R0,ARBROWSE         LOADED, OK\n*- - - - PROCESS THE \"TRC\" DATA-SET\nDTBRWOK  L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         MVC   DSNAME,DSTRCDSN     DS-NAME\n         MVC   DSVOLSER,DSTRCVOL   VOL-SER\n         MVC   DSSTATUS,=CL8'SHR'  SET DISP=SHR\n         TM    PRFLGS,DELFLG       DELETE REQUESTED?\n         BZ    *+L'*+12            NO\n         MVC   DSNDISP,=CL8'UNCATLG' YES, SET DISP=(SHR,UNCATLG,KEEP)\n         MVC   DSADISP,=CL8'KEEP'\n         L     R4,ACOPDCB          PICK UP LIBRARY ADDRESS\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DDNAME\n         MVC   0(DPRDCBL,R4),DPRDCB MOVE DCB SKELETON\n         MVC   DCBDDNAM-IHADCB(L'DCBDDNAM,R4),DDNAME SET BACK DDNAME\n         DROP  R2\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    DTALLOK             OK\n        XMESS  5011\n         TM    PRFLGS,VIEWFLG      VIEW REQUESTED?\n         BZ    *+L'*+8             NO\n         LA    R1,DTRVMSG          YES\n         B     DTRTMSG             YUP - ALL DONE\n         LA    R1,DTRUMSG\nDTRTMSG  ST    R1,MSGADD           YUP - ALL DONE\n         B     DSTSTTM\nDTALLOK  TM    PRFLGS,VIEWFLG      VIEW REQUESTED?\n         BZ    DTFREE              NO\n         LA    R2,DSTRCDSN         YES\n         LA    R3,=CL8' '\n         L     R15,ARBROWSE\n*- - - - ETPSBROW PARM.LIST : DCB, DS-NAME, MEMBER-NAME\n        CALL   (15),((R4),(R2),(R3)),VL,MF=(E,PARMVL)\nDTFREE   L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DDNAME\n         DROP  R2\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    DTFROK              OK\n        XMESS  5014\n         TM    PRFLGS,VIEWFLG      VIEW REQUESTED?\n         BZ    *+L'*+8             NO\n         LA    R1,DFTVMSG          YES\n         B     DTRTMSG             YUP - ALL DONE\n         LA    R1,DFTUMSG\n         B     DTRTMSG             YUP - ALL DONE\nDTFROK   TM    PRFLGS,DELFLG       DELETE REQUESTED?\n         BO    DTDEL               YES\nDTKEPT   LA    R1,DTKMSG           NO, KEPT\n         B     DTRTMSG\nDTDEL    L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         MVC   DSNAME,DSTRCDSN     DS-NAME\n         MVC   DSVOLSER,DSTRCVOL   VOL-SER\n         MVC   DSSTATUS,=CL8'SHR'  SET DISP=SHR\n         MVC   DSNDISP,=CL8'DELETE' SET DISP=(SHR,DELETE,DELETE)\n         MVC   DSADISP,=CL8'DELETE'\n         L     R4,ACOPDCB          PICK UP LIBRARY ADDRESS\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) GET DDNAME FOR USE\n         DROP  R2\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    DTDLAOK             OK\n        XMESS  5011\n         LA    R1,DTRDMSG\n         B     DTRTMSG             YUP - ALL DONE\nDTDLAOK  L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         USING PARMLIST,R2\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DDNAME\n         DROP  R2\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BNZ   *+L'*+8             WITH ERROR\n         LA    R1,DTDMSG           OK\n         B     DTRTMSG             YUP - ALL DONE\n        XMESS  5013\n         LA    R1,DFTDMSG\n         B     DTRTMSG             YUP - ALL DONE\nTLBRERR  STM   R0,R1,MESSPL        BROWSE IS UNAVAILABLE\n        XMESS  99,R15\n         LA    R1,BLDMSG\n         B     DTRTMSG             YUP - ALL DONE\n*- - - - STATDS INTERFACE TERMINATION\nDSTEOJ   L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME,DSSTDDN      DD-NAME\n         DROP  R2\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    DSTEXIT             OK\n        XMESS  5012\n         OC    MSGADD,MSGADD\n         BNZ   DSTEXIT\n         LA    R1,FLFMSG\n         ST    R1,MSGADD\nDSTEXIT  L     R0,=A(DWALEN)\n        FREEMAIN R,LV=(0),A=(R9)   FREE \"DWAREA\" WORK-AREA\nDSTGBK   L     R13,4(,R13)         PICK UP CALLING SAVE-AREA\n         LM    R14,R12,12(R13)     RESTORE CALLING REGISTERS\n         XR    R15,R15             SET RC=0\n         BR    R14                 RETURN\n         EJECT\nWRNMSG   MSG   'SYNTAX ERROR'\nUNKMSG   MSG   'UNKNOWN PARM'\nIPFMSG   MSG   'INVALID PF-KEY'\nFLFMSG   MSG   'FREE \"LIB\" FAILED'\nDPKMSG   MSG   'STATDS \"PRT\" KEPT'\nDTKMSG   MSG   'STATDS \"TRC\" KEPT'\nALFMSG   MSG   'ALLOC \"LIB\" FAILED'\nBLDMSG   MSG   'BROWSE UNAVAILABLE'\nDFPVMSG  MSG   'FREE \"PRT\"/V FAILED'\nDFPUMSG  MSG   'FREE \"PRT\"/U FAILED'\nDFPDMSG  MSG   'FREE \"PRT\"/D FAILED'\nDFTVMSG  MSG   'FREE \"TRC\"/V FAILED'\nDFTUMSG  MSG   'FREE \"TRC\"/U FAILED'\nDFTDMSG  MSG   'FREE \"TRC\"/D FAILED'\nSGMMSG   MSG   'STATDS GETMAIN ERROR'\nIOPMSG   MSG   'INVALID OPTION (N/Y)'\nDPRVMSG  MSG   'ALLOC \"PRT\"/V FAILED'\nDPRUMSG  MSG   'ALLOC \"PRT\"/U FAILED'\nDPRDMSG  MSG   'ALLOC \"PRT\"/D FAILED'\nDPDMSG   MSG   'STATDS \"PRT\" DELETED'\nDTRVMSG  MSG   'ALLOC \"TRC\"/V FAILED'\nDTRUMSG  MSG   'ALLOC \"TRC\"/U FAILED'\nDTRDMSG  MSG   'ALLOC \"TRC\"/D FAILED'\nDTDMSG   MSG   'STATDS \"TRC\" DELETED'\n         SPACE 1\nBLNKL    DC    AL1(BLNKLL-1),XL1'04',CL9' '\nBLNKLL   EQU   *-BLNKL\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\nDPRDCB  DCB    DSORG=PS,MACRF=(GM,PM),DDNAME=DUMMY,EODAD=*-*,SYNAD=*-*\nDPRDCBL  EQU   *-DPRDCB\n         SPACE 1\n         DROP  R9,R10,R11,R12,R13\n         SPACE 1\nADSROW   DC    A(DSROW1,DSROW2,DSROW3,DSROW4,DSROW5,DSROW6,DSROW7)\nNDSROW   EQU   (*-ADSROW)/L'ADSROW\nDSROW1   DC    AL1(DSROW1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL34' STATDS INTERFACE - PROCESS PANEL ',35CL1'-'\nDSROW1L  EQU   *-DSROW1\nCRDSTC   EQU   01                  CURSOR ROW ON LINE BELOW\nDSI      EQU   (CRDSTC+1)*4        \"TERMINPT\" DISPLACEMENT\nDSROW2   DC    AL1(DSROW2L-1)\n         DC    XL1'05'             PROTECT, HIGH-LIGHT\n         DC    CL20'PROCESSING PARM ===>'\nCCDSTC   EQU   (*-DSROW2)          CURSOR COLUMN ON FIELD BELOW\nDSTCF1   EQU   (*-DSROW2)+1,16     INPUT FIELD 1\n         DC    XL1'01',CL16' '     SF UNPROTECTED\n         DC    XL1'04'             SF PROTECTED\n         DC    C'<- NONE OR \"NO\" OR \"LABEL\" OR \"FULL\" OR'\nDSROW2L  EQU   *-DSROW2\nDSROW3   DC    AL1(DSROW3L-1)\n         DC    XL1'04',CL38' '     PROTECT\n         DC    C'   \"GAS(TT.TT.RR)\" OR \"GAS(ALL)\"'\nDSROW3L  EQU   *-DSROW3\nDSROW4   DC    AL1(DSROW4L-1)\n         DC    XL1'05'             PROTECT, HIGH-LIGHT\n         DC    C'DATA-SET STATISTICS :'\n         DC    XL1'04'             PROTECT\n         DC    C'FORMATS INFORMATION ON ANY DISK DATA-SET.'\nDSROW4L  EQU   *-DSROW4\nDSROW5   DC    AL1(DSROW5L-1)\n         DC    XL1'04'             PROTECT\n*                ----+----1----+----2----+----3----+----4\n         DC    C'  IT READS THROUGH THE ENTIRE DATA-SET A'\n         DC    C'ND OUTPUTS DISK TRACK USAGE, BLOCK-SIZE'\nDSROW5L  EQU   *-DSROW5\nDSROW6   DC    AL1(DSROW6L-1)\n         DC    XL1'04'             PROTECT\n         DC    C'     AND OTHER STATISTICS.'\nDSROW6L  EQU   *-DSROW6\nDSROW7   DC    AL1(DSROW7L-1)\n         DC    XL1'04'             PROTECT\n         DC    C'  IT ALLOWS ALSO TO RESURRECT \"GAS\" MEMB'\n         DC    C'ERS IN A NOT COMPRESSED PDS DATA-SET.'\nDSROW7L  EQU   *-DSROW7\n         EJECT\n*------- STATDS PROCESS HELP SCREEN ---------------------------------*\n         CNOP  0,4\nDSTHELP  DC    A(DSTHL1)\n         DC    A(HLPENT)\n         DC    A(DSTHL2)\n         DC    A(DSTHL3)\n         DC    A(DSTHL4)\n         DC    A(DSTHL5)\n         DC    A(DSTHL6)\n         DC    A(DSTHL7)\n         DC    A(DSTHL8)\n         DC    A(DSTHL9)\n         DC    A(DSTHL10)\n         DC    A(DSTHL11)\n         DC    A(DSTHL12)\n         DC    A(DSTHL13)\n         DC    A(DSTHL14)\n         DC    A(DSTHL15)\n         DC    A(DSTHL16)\n         DC    A(DSTHL17)\n         DC    A(DSTHL18)\n         DC    A(DSTHL19)\n         DC    A(DSTHL20)\n         DC    A(LNEBLK)\n         DC    A(EML+DSTHL21)\n         SPACE 1\nDSTHL1   DC    AL1(DSTHL1L-1)      ROW 01, COL 01\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL18' STATDS INTERFACE ',51CL1'-'\nDSTHL1L  EQU   *-DSTHL1\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\nDSTHL2   DC    AL1(DSTHL2L-1),XL1'05'\n         DC    C'IF NO PARM IS CODED, THE FOLLOWING INFORMATION WILL BEX\n                GIVEN :'\nDSTHL2L  EQU   *-DSTHL2\nDSTHL3   DC    AL1(DSTHL3L-1),XL1'05'\n         DC    C'  A) DCB AND DSCB CHARACTERISTICS.'\nDSTHL3L  EQU   *-DSTHL3\nDSTHL4   DC    AL1(DSTHL4L-1),XL1'05'\n         DC    C'  B) RECORD COUNTS, RECORD SIZE, TRACK USAGE STATISTICX\n               S FOR ANY TYPE OF'\nDSTHL4L  EQU   *-DSTHL4\nDSTHL5   DC    AL1(DSTHL5L-1),XL1'05'\n         DC    C'     DATA-SET ORGANIZATION. FOR DSORG=IS, IT READS THRX\n               OUGH THE ENTIRE DATA-SET'\nDSTHL5L  EQU   *-DSTHL5\nDSTHL6   DC    AL1(DSTHL6L-1),XL1'05'\n         DC    C'     (THERE MAY BE UP TO THREE SEPARATE FILES OF DATA X\n               AND REPORTS ON EACH'\nDSTHL6L  EQU   *-DSTHL6\nDSTHL7   DC    AL1(DSTHL7L-1),XL1'05'\n         DC    C'     FILE). ALSO, THE ISAM LABEL (FORMAT 2 DSCB) RECORX\n               D WILL BE READ AND A'\nDSTHL7L  EQU   *-DSTHL7\nDSTHL8   DC    AL1(DSTHL8L-1),XL1'05'\n         DC    C'     DATA-SET PROFILE WHICH INCLUDES DATA-SET REORGANIX\n               ZATION DATA AND DATA-SET'\nDSTHL8L  EQU   *-DSTHL8\nDSTHL9   DC    AL1(DSTHL9L-1),XL1'05'\n         DC    C'     CHARACTERISTICS WILL BE PROVIDED.'\nDSTHL9L  EQU   *-DSTHL9\nDSTHL10  DC    AL1(DSTHL10L-1),XL1'05'\n         DC    C'  C) FOR DSORG=PO, THE DIRECTORY TTR''S WILL BE COMPARX\n               ED AGAINST ACTUAL DISK'\nDSTHL10L EQU   *-DSTHL10\nDSTHL11  DC    AL1(DSTHL11L-1),XL1'05'\n         DC    C'     ADDRESSES TO DETERMINE THE TTRS OF \"GAS\" MEMBERS X\n               (THE FIRST 72 CHARACTERS'\nDSTHL11L EQU   *-DSTHL11\nDSTHL12  DC    AL1(DSTHL12L-1),XL1'05'\n         DC    C'     OF ANY \"GAS\" MEMBER ARE OUTPUTED). STATISTICS AREX\n                MAINTAINED ON THE SIZE'\nDSTHL12L EQU   *-DSTHL12\nDSTHL13  DC    AL1(DSTHL13L-1),XL1'05'\n         DC    C'     OF \"GAS\" AND \"REAL\" MEMBERS AND THE NUMBER OF ALIX\n               AS MEMBERS. IF ANY'\nDSTHL13L EQU   *-DSTHL13\nDSTHL14  DC    AL1(DSTHL14L-1),XL1'05'\n         DC    C'     ALIASES ARE IN THE DATA-SET, A CHECK IS MADE TO SX\n               EE THAT THE CORRESPONDING'\nDSTHL14L EQU   *-DSTHL14\nDSTHL15  DC    AL1(DSTHL15L-1),XL1'05'\n         DC    C'     REAL ENTRIES ALSO EXIST.'\nDSTHL15L EQU   *-DSTHL15\nDSTHL16  DC    AL1(DSTHL16L-1),XL1'05'\n         DC    C'A PARM OF \"NO\" NULLIFY THE GAS TTR REPORT.'\nDSTHL16L EQU   *-DSTHL16\nDSTHL17  DC    AL1(DSTHL17L-1),XL1'05'\n         DC    C'A PARM OF \"LABEL\" GIVE ONLY DCB AND DSCB CHARACTERISTIX\n               CS.'\nDSTHL17L EQU   *-DSTHL17\nDSTHL18  DC    AL1(DSTHL18L-1),XL1'05'\n         DC    C'A PARM OF \"FULL\" SUPPLY THE DIRECTORY MEMBERS LIST (ONX\n               LY DSORG=PO).'\nDSTHL18L EQU   *-DSTHL18\nDSTHL19  DC    AL1(DSTHL19L-1),XL1'05'\n         DC    C'A PARM OF \"GAS(TT.TT.RR)\" ADD A NAME TO THE DIREDTORY X\n               FOR THE \"GAS\" HAVING'\nDSTHL19L EQU   *-DSTHL19\nDSTHL20  DC    AL1(DSTHL20L-1),XL1'05'\n         DC    C'  THE SPECIFIED TTR LOCATION (IN HEX, CAN BE DETERMINEX\n               D FROM A PREVIOUS RUN).'\nDSTHL20L EQU   *-DSTHL20\nDSTHL21  DC    AL1(DSTHL21L-1),XL1'05'\n         DC    C'PF3 RETURNS TO THE PRIMARY OPTION MENU PANEL.'\nDSTHL21L EQU   *-DSTHL21\nHLPENT   DC    AL1(HLPENTL-1),XL1'01',CL1' ',XL1'04',CL7' '\nHLPENTL  EQU   *-HLPENT\nLNEBLK   DC    AL1(LNEBLKL-1),XL1'04',CL9' '\nLNEBLKL  EQU   *-LNEBLK\n         EJECT\n*- - - - \"PRT\" ENTRY SCREEN\n         CNOP  0,4\nDPRSCR   DC    A(DPROW1)\n         DC    A(DPROW2)\n         DC    A(LNEBLK)\nCRDPSC   EQU   (*-DPRSCR)/4        CURSOR ROW ON LINE BELOW\nDPZ1     EQU   (*-DPRSCR)+4        \"TERMINPT\" DISPLACEMENT\n         DC    A(DPROW3)\n         DC    A(LNEBLK)\nCRAPSC   EQU   (*-DPRSCR)/4        ALTERNATE CURSOR ROW ON LINE BELOW\nDPZ2     EQU   (*-DPRSCR)+4        \"TERMINPT\" DISPLACEMENT\n         DC    A(EML+DPROW4)\n         SPACE 1\nDPROW1   DC    AL1(DPROW1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL38' STATDS INTERFACE - ENTRY PRINT PANEL ',31CL1'-'\nDPROW1L  EQU   *-DPROW1\nDPROW2   DC    AL1(DPROW2L-1)\n         DC    XL1'05',CL39'ENTER/VERIFY STATDS PRINT REQUIREMENTS:'\n         DC    XL1'04',CL1' '\nDPROW2L  EQU   *-DPROW2\nDPROW3   DC    AL1(DPROW3L-1)\nDPOFF1   EQU   (*-DPROW3)+9,10\n         DC    XL1'04',CL21'        PRINT VIEWING',XL1'05',CL3'==>'\nCCDPSC   EQU   (*-DPROW3)          CURSOR COLUMN ON FIELD BELOW\nDPSCF1   EQU   (*-DPROW3)+1,3      INPUT FIELD 1\n         DC    XL1'02',CL3' ',XL1'04',C'(NO/N/YES/Y) '\nDPROW3L  EQU   *-DPROW3\nDPROW4   DC    AL1(DPROW4L-1)\nDPOFF2   EQU   (*-DPROW4)+1,8\n         DC    XL1'04',CL21'AND / OR PRINT DELETE',XL1'05',CL3'==>'\nCCAPSC   EQU   (*-DPROW4)          ALTERNATE CURSOR COL. ON FIELD BELOW\nDPSCF2   EQU   (*-DPROW4)+1,3      INPUT FIELD 2\n         DC    XL1'02',CL3' ',XL1'04',C'(NO/N/YES/Y) '\nDPROW4L  EQU   *-DPROW4\n         EJECT\n*- - - - \"PRT\" ENTRY HELP SCREEN\n         CNOP  0,4\nDPRHELP  DC    A(DPRHL1)\n         DC    A(HLPENT)\n         DC    A(DPRHL2)\n         DC    A(DPRHL3)\n         DC    A(LNEBLK)\n         DC    A(DPRHL4)\n         DC    A(DPRHL5)\n         DC    A(DPRHL6)\n         DC    A(EML+DPRHL7)\n         SPACE 1\nDPRHL1   DC    AL1(DPRHL1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL18' STATDS INTERFACE ',51CL1'-'\nDPRHL1L  EQU   *-DPRHL1\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\nDPRHL2   DC    AL1(DPRHL2L-1),XL1'05'\n         DC    C'THE PRINT PANEL ALLOWS TO VIEW THE SESSION OUTPUT PRINX\n               T DATA-SET (WHEN IT HAS'\nDPRHL2L  EQU   *-DPRHL2\nDPRHL3   DC    AL1(DPRHL3L-1),XL1'05'\n         DC    C'    BEEN CREATED), AND / OR DELETE IT (IF NEEDED, ELSEX\n                IT IS KEPT).'\nDPRHL3L  EQU   *-DPRHL3\nDPRHL4   DC    AL1(DPRHL4L-1),XL1'05'\n         DC    C'THE OUTPUT PRINT DATA-SET IS ALWAYS NAMED AS FOLLOWS:'\nDPRHL4L  EQU   *-DPRHL4\nDPRHL5   DC    AL1(DPRHL5L-1),XL1'05'\n         DC    C'         <USER-ID>.ETPS.DSSTPRT.DYYDDD.THHMMSS.LIST'\nDPRHL5L  EQU   *-DPRHL5\nDPRHL6   DC    AL1(DPRHL6L-1),XL1'05'\n         DC    C'    WHERE \"YYDDD\" IS THE YEAR AND SERIAL DAY, AND'\nDPRHL6L  EQU   *-DPRHL6\nDPRHL7   DC    AL1(DPRHL7L-1),XL1'05'\n         DC    C'          \"HHMMSS\" IS THE TIME OF DAY.'\nDPRHL7L  EQU   *-DPRHL7\n         EJECT\n*- - - - \"TRC\" ENTRY SCREEN\n         CNOP  0,4\nDTRSCR   DC    A(DTROW1)\n         DC    A(DTROW2)\n         DC    A(LNEBLK)\nCRDTSC   EQU   (*-DTRSCR)/4        CURSOR ROW ON LINE BELOW\nDTZ1     EQU   (*-DTRSCR)+4        \"TERMINPT\" DISPLACEMENT\n         DC    A(DTROW3)\n         DC    A(LNEBLK)\nCRATSC   EQU   (*-DTRSCR)/4        ALTERNATE CURSOR ROW ON LINE BELOW\nDTZ2     EQU   (*-DTRSCR)+4        \"TERMINPT\" DISPLACEMENT\n         DC    A(EML+DTROW4)\n         SPACE 1\nDTROW1   DC    AL1(DTROW1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL38' STATDS INTERFACE - ENTRY TRACE PANEL ',31CL1'-'\nDTROW1L  EQU   *-DTROW1\nDTROW2   DC    AL1(DTROW2L-1)\n         DC    XL1'05',CL39'ENTER/VERIFY STATDS TRACE REQUIREMENTS:'\n         DC    XL1'04',CL1' '\nDTROW2L  EQU   *-DTROW2\nDTROW3   DC    AL1(DTROW3L-1)\nDTOFF1   EQU   (*-DTROW3)+9,10\n         DC    XL1'04',CL21'        TRACE VIEWING',XL1'05',CL3'==>'\nCCDTSC   EQU   (*-DTROW3)          CURSOR COLUMN ON FIELD BELOW\nDTSCF1   EQU   (*-DTROW3)+1,3      INPUT FIELD 1\n         DC    XL1'02',CL3' ',XL1'04',C'(NO/N/YES/Y) '\nDTROW3L  EQU   *-DTROW3\nDTROW4   DC    AL1(DTROW4L-1)\nDTOFF2   EQU   (*-DTROW4)+1,8\n         DC    XL1'04',CL21'AND / OR TRACE DELETE',XL1'05',CL3'==>'\nCCATSC   EQU   (*-DTROW4)          ALTERNATE CURSOR COL. ON FIELD BELOW\nDTSCF2   EQU   (*-DTROW4)+1,3      INPUT FIELD 2\n         DC    XL1'02',CL3' ',XL1'04',C'(NO/N/YES/Y) '\nDTROW4L  EQU   *-DTROW4\n         EJECT\n*- - - - \"TRC\" ENTRY HELP SCREEN\n         CNOP  0,4\nDTRHELP  DC    A(DTRHL1)\n         DC    A(HLPENT)\n         DC    A(DTRHL2)\n         DC    A(DTRHL3)\n         DC    A(LNEBLK)\n         DC    A(DTRHL4)\n         DC    A(DTRHL5)\n         DC    A(DTRHL6)\n         DC    A(EML+DTRHL7)\n         SPACE 1\nDTRHL1   DC    AL1(DTRHL1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL18' STATDS INTERFACE ',51CL1'-'\nDTRHL1L  EQU   *-DTRHL1\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\nDTRHL2   DC    AL1(DTRHL2L-1),XL1'05'\n         DC    C'THE TRACE PANEL ALLOWS TO VIEW THE SESSION OUTPUT TRACX\n               E DATA-SET (WHEN IT HAS'\nDTRHL2L  EQU   *-DTRHL2\nDTRHL3   DC    AL1(DTRHL3L-1),XL1'05'\n         DC    C'    BEEN CREATED), AND / OR DELETE IT (IF NEEDED, ELSEX\n                IT IS KEPT).'\nDTRHL3L  EQU   *-DTRHL3\nDTRHL4   DC    AL1(DTRHL4L-1),XL1'05'\n         DC    C'THE OUTPUT TRACE DATA-SET IS ALWAYS NAMED AS FOLLOWS:'\nDTRHL4L  EQU   *-DTRHL4\nDTRHL5   DC    AL1(DTRHL5L-1),XL1'05'\n         DC    C'         <USER-ID>.ETPS.DSSTTRC.DYYDDD.THHMMSS.LIST'\nDTRHL5L  EQU   *-DTRHL5\nDTRHL6   DC    AL1(DTRHL6L-1),XL1'05'\n         DC    C'    WHERE \"YYDDD\" IS THE YEAR AND SERIAL DAY, AND'\nDTRHL6L  EQU   *-DTRHL6\nDTRHL7   DC    AL1(DTRHL7L-1),XL1'05'\n         DC    C'          \"HHMMSS\" IS THE TIME OF DAY.'\nDTRHL7L  EQU   *-DTRHL7\n         EJECT\n*------- DISK DATA-SET STATISTICS PROGRAM (STATDS) ------------------*\n*              COMPUTE DISK DATA-SET USEAGE STATISTICS.\n*              AT ENTRY, R1 = A(PARM.LIST) -> (PRMFLD)\n*                        R9 = \"DWAREA\" WORK-AREA POINTER\n         CNOP  0,8\n         USING *,R12,R11,R8\n         USING SAVE3,R13      ************************** R13 ==> SAVE3\n         USING SPLTAREA,R10   AT ENTRY : R10 MUST POINT TO \"SPLTAREA\"\n         USING DWAREA,R9\nETPSXDST STM   R14,R12,12(R13)     SAVE INPUT REGISTERS\n         LR    R12,R15             SET PROGRAM BASE REGISTER 1\n         LA    R3,1\n         LA    R11,4*KB-1(R3,R12)  SET PROGRAM BASE REGISTER 2\n         LA    R8,4*KB-1(R3,R11)   SET PROGRAM BASE REGISTER 3\n         LR    R3,R10              SPLIT-SCREEN DSECT\n         SH    R3,=Y(SPLITWRK-SAVE3) POINT TO SAVE3\n         ST    R13,4(,R3)          STORE BACKWARD POINTER\n         ST    R3,8(R13)           STORE FORWARD POINTER\n         LR    R13,R3              SET SAVE-AREA POINTER\n         L     R2,0(R1)            PARM ADDRESS\n         NI    PRFLGS,255-PRTALL-TRCALL RESET\n         LR    R0,R9\n         AL    R0,=A(DWL1)\n         L     R1,=A(DWL2)\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R0,R14              CLEAR ALL TO BINARY ZEROS\n         L     R1,=A(CCWSK)        INITIALIZATION\n         MVC   CCWA1(CCWSKL),0(R1)\n         LA    R1,DSIOBSK+3\n         STCM  R1,B'0111',CCWA1+1\n         STCM  R1,B'0111',CCWA3+1\n         STCM  R1,B'0111',CCWB2+1\n         STCM  R1,B'0111',CCWB5+1\n         LA    R1,SECTNO\n         STCM  R1,B'0111',CCWB1+1\n         STCM  R1,B'0111',CCWB6+1\n         LA    R1,CCWA1\n         STCM  R1,B'0111',CCWA2+1\n         LA    R1,CCWB2\n         STCM  R1,B'0111',CCWB3+1\n         MVI   DSSTIOB,IOBDATCH+IOBCMDCH+IOBUNREL\n         LA    R1,DSSTECB\n         ST    R1,DSSTIOB+4\n         LA    R1,DSSTIN\n         ST    R1,DSSTCPA+4\n         MVC   MINBLK,=F'33000'\n         MVC   MINBLKI,=F'33000'\n         MVI   MINGAS,X'7F'\n         MVI   MINREL,X'7F'\n         MVI   MINBYTE,X'7F'\n         MVC   MINR,=F'255'\n         LA    R1,TLG\n         ST    R1,TLC\n         L     R1,TLMXGM           GAS RECORDING ELEMENTS AREA\n         LA    R15,L'STOWTTR\n         MR    R0,R15\n         LR    R0,R1\n         SR    R1,R0\n         STM   R15,R0,GTSTR+4\n         AH    R1,=H'7'\n         SRL   R1,3\n         SLL   R1,3\n         ST    R1,GTLGTH\n         LA    R1,TRCLNE+6\n         ST    R1,TCURPTR\n         ST    R1,TSTRPTR\n         LA    R1,TRCLNE+(4*18)\n         ST    R1,TMAXPTR\n         MVC   STOWMEM,=CL8'$GAS0000'\n         MVI   STOWTTR+L'STOWTTR,PDS2ALIS\n         L     R1,=A(OUTSK)\n         MVC   DSSTOUT(OUTSKL),0(R1)\n         MVC   DSSTOUT+DCBDDNAM-IHADCB(L'DCBDDNAM),DSPRTDDN\n         L     R1,=A(TRCSK)\n         MVC   DSSTTRC(TRCSKL),0(R1)\n         MVC   DSSTTRC+DCBDDNAM-IHADCB(L'DCBDDNAM),DSTRCDDN\n         L     R1,=A(PDSSK)\n         MVC   DSSTPDS(PDSSKL),0(R1)\n         MVC   DSSTPDS+DCBDDNAM-IHADCB(L'DCBDDNAM),DSSTDDN\n         L     R1,=A(INSK)\n         MVC   DSSTIN(INSKL),0(R1)\n         MVC   DSSTIN+DCBDDNAM-IHADCB(L'DCBDDNAM),DSSTDDN\n         LA    R1,JFCBXIT\n         STCM  R1,B'0111',DSSTIN+DCBEXLSA-IHADCB\n         LA    R1,DSSTJF\n         STCM  R1,B'0111',JFCBXIT+1\n         L     R1,=A(CAMSK)\n         MVC   DSSTCLS(CAMSKL),0(R1)\n         LA    R15,JFCBDSNM\n         LA    R0,JFCBVOLS\n         LA    R1,DSSTWA\n         STM   R15,R1,DSSTCLS+4\n         LA    R1,GASREQ\n         STC   R1,DSSTFL\n         MVC   CURMBB(L'CURMBB),ZBLKS\n         MVC   MBBCCHH(L'MBBCCHH),ZBLKS\n         LA    R0,WKLNES\n         L     R1,=A(WKBLL)\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',ZBLKS\n         MVCL  R0,R14              SET TO ALL BLANKS\n         L     R3,TLMXRM           ROOM FOR DIRECTORY ENTRIES\n         AH    R3,=H'1'\n         MH    R3,TLC+2\n         LR    R5,R3\n         LA    R3,7(R3)\n         SRL   R3,3\n         SLL   R3,3\n         AL    R3,=A(32776)\n         ST    R3,ARLGTH\n        GETMAIN R,LV=(R3)\n         ST    R1,BUFFER\n         STCM  R1,B'0111',CCWB4+1\n         AL    R1,=A(32776)\n         LR    R4,R1\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',ZBLKS\n         MVCL  R4,R14              SET TO ALL BLANKS\n         SL    R1,TLC\n         ST    R1,SAVETBL\n         LA    R6,DSSTWA\n         USING DS1FMTID,R6\n         LA    R7,DSSTIN\n         USING IHADCB,R7\n         LH    R0,0(R2)\n         LTR   R0,R0               IS LENGTH ZERO?\n         BNP   NOPARM              YES, BRANCH\n         CH    R0,=H'13'           IS PARM LENGTH 13?\n         BE    *+L'*+8             YES\n         CH    R0,=H'8'            IS PARM LENGTH 8?\n         BNE   GSWH                NO, GO SEE WHAT ELSE\n         CLC   2(4,R2),=C'GAS('    PARM=GAS(TT.TT.RR) OR GAS(ALL)?\n         BNE   GSWH                NO, GO SEE WHAT ELSE\n         CH    R0,=H'8'            IS PARM LENGTH 8?\n         BNE   GTTTR               NO\n         CLC   6(4,R2),=CL4'ALL)'  CONTROL SYNTAX\n         BNE   WRONG\n         OI    DSSTFL,GASALL\n         B     SETGS\nGTTTR    CLI   8(R2),C'.'          CONTROL SYNTAX\n         BNE   WRONG\n         CLI   11(R2),C'.'\n         BNE   WRONG\n         CLI   14(R2),C')'\n         BNE   WRONG\n         MVC   GASTTR(L'GASTTR),6(R2) SAVE TT.TT.RR\n         LA    R0,8                TT.TT.RR CONTROL\n         LA    R15,GASTTR+L'GASTTR-1\nHEXCTLL  CLI   0(R15),C'.'\n         BE    HEXCTLI\n         CLI   0(R15),C'A'\n         BL    WRONG\n         CLI   0(R15),C'F'\n         BNH   HEXCTLI\n         CLI   0(R15),C'0'\n         BL    WRONG\n         CLI   0(R15),C'9'\n         BH    WRONG\nHEXCTLI  BCTR  R15,0\n         BCT   R0,HEXCTLL\nSETGS    OI    DSSTFL,GASADD\n         B     NOPARM\nWRONG   OUTPT  =F'-1',WRMSG\n         B     ENDALL\nGSWH     CLI   2(R2),C'U'          PARM=U SAME AS NO PARM\n         BE    NOPARM              YES, BRANCH\n         CLI   2(R2),C'N'          NO, ARE GAS RECORDS DESIRED?\n         BNE   *+L'*+4             YES, BRANCH\n         NI    DSSTFL,255-GASREQ   NO, TURN OFF GAS RECORDS\n         CLI   2(R2),C'F'          FULLY INFORMATION LIST?\n         BNE   *+L'*+4             NO, BRANCH\n         OI    DSSTFL,FULLIL       YES, TURN ON FULL LIST\n         CLI   2(R2),C'T'          TEST INFORMATION LIST?\n         BNE   *+L'*+4             NO, BRANCH\n         OI    DSSTFL,FULLIL+TRCFLG YES, TURN ON FULL & TEST LIST\n         CLI   2(R2),C'L'          LABEL INFORMATION ONLY?\n         BNE   NOPARM              NO, BRANCH\n         OI    DSSTFL,LBLFLG       YES, SET THE \"LABELS ONLY\" FLAG\nNOPARM   TM    DSSTFL,GASALL       ALL GAS TO RECOVER?\n         BZ    NOGALL              NO\n         L     R3,GTLGTH           YES, GET RECORDING AREA\n        GETMAIN R,LV=(R3)\n         ST    R1,GTANK\n         LR    R2,R1\n         SL    R1,GTSTR+4\n         ST    R1,GTSTR\n         AL    R1,GTSTR+8\n         ST    R1,GTSTR+8\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R2,R14              SET TO ALL ZEROS\nNOGALL   BAL   R14,OPENIN          OPEN THE INPUT FILE\n        OUTPT  =F'-1',SQL\n        OUTPT  =F'-1',PRGRM        PROGRAM NAME AND PURPOSE\n        OUTPT  =F'-1',SQL\n        OUTPT  =F'-1',ZBLKS,10,A=\n         MVC   WRKLNE(4),=CL4'DSN='\n         MVC   WRKLNE+4(44),JFCBDSNM DATA-SET NAME\n         LA    R1,WRKLNE+4\n         LA    R1,1(,R1)           SCAN FOR\n         CLI   0(R1),C' '            FINAL\n         BNE   *-8                     BLANK\n         MVC   0(9,R1),=CL9',VOL=SER='\n         MVC   9(6,R1),JFCBVOLS    ADD THE VOLUME SERIAL\n        OUTPT  =F'-1',WRKLNE,,A=\n         TM    DSSTFL,GASADD       GAS TO RECOVER?\n         BZ    NDCB                NO, BRANCH\n         TM    DS1DSORG,DS1DSGPO   PARTITIONED DATA-SET ORG?\n         BO    OKPO                YES, BRANCH\n        OUTPT  =F'-1',NOTPDS\n         B     ENDZ\nOKPO     MVC   TEMPW(L'TEMPW),DS1LSTAR\n        TTRMBB TEMPW,MBB=LASTMBB   SAVE THE LAST USED MBBCCHHR\n         B     ITSPO\n*- - - - FORMATS A STRING LIKE \"DCB=(RECFM=...)\".\nNDCB     LA    R1,WRKLNE           FORMAT THE DCB INFORMATION\n         MVC   0(12,R1),=CL12'DCB=(RECFM=*'\n         LA    R1,11(,R1)\n         TM    DS1RECFM,DCBRECU    RECFM=U?\n         BNO   *+L'*+8             NO, BRANCH\n         MVI   0(R1),C'U'\n         B     NDCB1\n         TM    DS1RECFM,DCBRECF    RECFM=F?\n         BNO   *+L'*+8             NO, BRANCH\n         MVI   0(R1),C'F'\n         B     NDCB1\n         TM    DS1RECFM,DCBRECV    RECFM=V?\n         BNO   NDCB1               NO, BRANCH\n         MVI   0(R1),C'V'\nNDCB1    LA    R1,1(,R1)\n         TM    DS1RECFM,DCBRECBR   RECFM=.B?\n         BNO   *+L'*+8             NO, BRANCH\n         MVI   0(R1),C'B'\n         LA    R1,1(,R1)\n         TM    DS1RECFM,DCBRECTO   RECFM=.T?\n         BNO   *+L'*+8             NO, BRANCH\n         MVI   0(R1),C'T'\n         LA    R1,1(,R1)\n         TM    DS1RECFM,DCBRECCA   RECFM=.A?\n         BNO   *+L'*+8             NO, BRANCH\n         MVI   0(R1),C'A'\n         LA    R1,1(,R1)\n         TM    DS1RECFM,DCBRECCM   RECFM=.M?\n         BNO   *+L'*+8             NO, BRANCH\n         MVI   0(R1),C'M'\n         LA    R1,1(,R1)\n         TM    DS1RECFM,DCBRECU    RECFM=U?\n         BO    NDCB3               YES, NO LRECL MESSAGE\n         MVC   0(7,R1),=CL7',LRECL='\n         LA    R1,7(,R1)\n         LH    R15,DS1LRECL\n         CVD   R15,DOUBLE\n         UNPK  DOUBLE(5),DOUBLE+5(3)\n         LA    R15,DOUBLE-1\n         LA    R15,1(,R15)         SCAN\n         CLI   0(R15),C'0'           PAST LAST\n         BE    *-8                     LEADING ZERO\n         OI    DOUBLE+4,X'F0'\nNDCB2    MVC   0(1,R1),0(R15)      MOVE IN EACH CHARACTER\n         LA    R1,1(,R1)\n         LA    R15,1(,R15)\n         TM    0(R15),X'F0'        NEXT CHARACTER NUMERIC?\n         BO    NDCB2               NO, BRANCH\nNDCB3    MVC   0(9,R1),=CL9',BLKSIZE='\n         LA    R1,9(,R1)\n         LH    R15,DS1BLKL\n         CVD   R15,DOUBLE\n         UNPK  DOUBLE(5),DOUBLE+5(3)\n         LA    R15,DOUBLE-1\n         LA    R15,1(,R15)         SCAN\n         CLI   0(R15),C'0'           PAST LAST\n         BE    *-8                     LEADING ZERO\n         OI    DOUBLE+4,X'F0'\nNDCB4    MVC   0(1,R1),0(R15)      MOVE IN EACH CHARACTER\n         LA    R1,1(,R1)\n         LA    R15,1(,R15)\n         TM    0(R15),X'F0'        NEXT CHARACTER NUMERIC?\n         BO    NDCB4               NO, BRANCH\n         MVC   0(7,R1),=CL7',DSORG='\n         LA    R1,7(,R1)\n         TM    DS1DSORG,DS1DSGPS   PS?\n         BNO   *+L'*+6             NO, BRANCH\n         MVC   0(2,R1),=CL2'PS'\n         TM    DS1DSORG,DS1DSGPO   PO?\n         BNO   *+L'*+6             NO, BRANCH\n         MVC   0(2,R1),=CL2'PO'\n         TM    DS1DSORG,DS1DSGDA   DA?\n         BNO   *+L'*+6             NO, BRANCH\n         MVC   0(2,R1),=CL2'DA'\n         TM    DS1DSORG,DS1DSGIS   IS?\n         BNO   *+L'*+6             NO, BRANCH\n         MVC   0(2,R1),=CL2'IS'\n         TM    DS1DSORG,DS1DSGU    UNMOVEABLE?\n         BNO   *+L'*+8             NO, BRANCH\n         MVI   2(R1),C'U'\n         LA    R1,1(,R1)\n         MVI   2(R1),C')'\n        OUTPT  =F'-1',WRKLNE,,A=\n         L     R1,DCBDEBAD\n         L     R14,NUMEXT          NUMBER OF EXTENTS\n         XR    R0,R0\n         AH    R0,46(,R1)          TRACKS IN THE EXTENT\n         LA    R1,16(,R1)          OFFSET BETWEEN EXTENTS\n         BCT   R14,*-8             REPEAT FOR EACH EXTENT\n         ST    R0,TOTALTRK         SAVE TRACK TOTAL\n         LH    R1,DS1LSTAR         LAST TT USED\n         SR    R0,R1               AVAILABLE SPACE + 0.5 TRACKS\n         BCTR  R0,0                SUBTRACT ONE MORE\n         ST    R0,AVAILTRK\n         MVC   TEMPW(L'TEMPW),DS1LSTAR\n        TTRMBB TEMPW,MBB=LASTMBB   SAVE THE LAST USED MBBCCHHR\n        OUTPT  TOTALTRK,NUMTRKS\n        OUTPT  AVAILTRK,FRETRKS\n         MVC   TEMPW(2),=H'0'\n         MVC   TEMPW+2(2),DS1TRBAL\n        OUTPT  TEMPW,TRBALS        BYTES LEFT ON LAST USED TRACK\n        OUTPT  NUMEXT,NUMEXTS\n         L     R2,DCBDEBAD\n         L     R3,NUMEXT\n        MVMSG  PROTECT             PREPARE MESSAGE\n         XR    R1,R1\n         IC    R1,24(R2)\n         SRL   R1,4\n         IC    R1,HEXTBL(R1)\n         STC   R1,WRKLNE           PROTECTION KEY FOR THIS DATA-SET\n        OUTPT  =F'-1',WRKLNE,L'PROTECT,A=\n        MVMSG  SCALOS              PREPARE MESSAGE\n         TM    DS1SCALO,X'C0'      CYLINDER ALLOC?\n         BNO   *+L'*+10            NO, BRANCH\n         MVC   WRKLNE+25(9),=CL9'CYLINDERS' YES\n         B     ALLOCS\n         BNZ   *+L'*+10            ABS. TRACKS\n         MVC   WRKLNE+25(15),=CL15'ABSOLUTE TRACKS' YES\n         B     ALLOCS\n         TM    DS1SCALO,X'80'      TRACKS?\n         BNO   *+L'*+10            NO, BRANCH\n         MVC   WRKLNE+25(6),=CL6'TRACKS' YES\n         B     ALLOCS\n         MVC   WRKLNE+25(6),=CL6'BLOCKS' BLOCKS\n         TM    DS1SCALO,X'01'      ROUND TO CYL?\n         BNO   ALLOCS              NO, BRANCH\n         MVC   WRKLNE+32(12),=CL12'(WITH ROUND)' YES\nALLOCS  OUTPT  =F'-1',WRKLNE,L'SCALOS,A=\n         MVC   TEMPW+1(3),DS1SCALO+1 SECONDARY ALLOCATION QUANTITY\n         MVI   TEMPW,0\n         OC    TEMPW,TEMPW         ANY SECONDARIES ALLOWED?\n         BNZ   SECS                YES, BRANCH\n        OUTPT  =F'-1',NOSEC        NO\n         B     ALLSECS\nSECS    OUTPT  TEMPW,EXTENTS\nALLSECS  XR    R4,R4               EXTENT NUMBER\n        MVMSG  LSTAR               PREPARE MESSAGE\n        HEXES  LASTMBB,8,WRKLNE+13\n        OUTPT  =F'-1',WRKLNE,L'LSTAR,A= LAST USED MBBCCHHR\n        OUTPT  =F'-1',ZBLKS,10,A=\n        OUTPT  =F'-1',EXTHDR\n        OUTPT  =F'-1',EXTUND\nHEXAGN   CVD   R4,DOUBLE\n         LA    R4,1(,R4)\n         UNPK  DOUBLE(5),DOUBLE+5(3)\n         MVC   WRKLNE+1(2),DOUBLE+3\n         OI    WRKLNE+2,X'F0'      EXTENT NUMBER\n         CLI   WRKLNE+1,C'0'\n         BNE   *+L'*+4\n         MVI   WRKLNE+1,C' '\n         L     R1,32(R2)           UCB ADDRESS\n         MVC   WRKLNE+8(3),13(R1)  UCB\n        HEXES  38(R2),4,WRKLNE+14  INITIAL CCHH\n        HEXES  42(R2),4,WRKLNE+28  END CCHH\n         LH    R1,46(,R2)          NUMBER OF TRACKS IN THIS EXTENT\n         CVD   R1,DOUBLE\n         UNPK  WRKLNE+41(9),DOUBLE+3(5)\n         LA    R1,WRKLNE+40\n         LA    R1,1(,R1)\n         CLI   1(R1),C'0'          NEXT DIGIT ZERO?\n         MVI   0(R1),C' '          REPLACE CURRENT DIGIT WITH BLANK\n         BE    *-12                YES, CONTINE BLANKING LEADING ZEROES\n         OI    WRKLNE+49,X'F0'     MAKE THE ZONE PRINTABLE\n        OUTPT  =F'-1',WRKLNE,,A=\n         LA    R2,16(,R2)          NEXT EXTENT DISPLACEMENT\n         BCT   R3,HEXAGN\n        OUTPT  =F'-1',ZBLKS,10,A=\n         XR    R0,R0\n         IC    R0,DS1KEYL\n         LTR   R0,R0               KEY-LENGTH=0?\n         BZ    DSORGTST            YES, BRANCH\n        OUTPT  R0,KEYLEN           NO, OUTPUT KEYLEN AND RKP\n         MVC   TEMPW+2(2),DS1RKP\n        OUTPT  TEMPW,KEYPOS\n        OUTPT  =F'-1',ZBLKS,10,A=\nDSORGTST TM    DSSTFL,LBLFLG       LABEL INFORMATION ONLY DESIRED?\n         BO    ENDX                YES, DO NOT DO ANY READS\n         TM    DS1DSORG,DS1DSGPO   PARTITIONED DATA-SET ORGANIZATION?\n         BO    ITSPO               YES, BRANCH. NO -- PS, DA OR IS\nINPUTS   BAL   R14,EXCPSTAT        READ EACH BLOCK AND COLLECT STATS\n         LTR   R15,R15             END OF FILE?\n         BZ    INPUTS              NO, CONTINUE READING\n         LR    R2,R15              SAVE FOR LATER\n        OUTPT  =F'-1',EOFSS\n         TM    DS1DSORG,DS1DSGIS   ISAM?\n         BNO   ENDDATA             NO, BRANCH -- END OF DATA-SET\n         CLC   MINBLKI,=F'33000'   EVER CHANGED?\n         BNE   *+L'*+6             YES, BRANCH\n         XR    R14,R14             NO, RESET TO ZERO\n         ST    R14,MINBLKI\n        OUTPT  MINBLKI,MINBLKS\n         LA    R14,1\n         C     R14,READTOTI\n         BH    *+L'*+4\n         L     R14,READTOTI        TAKE MAX OF READTOTI AND 1\n         L     R1,READTOTI\n         SRL   R1,1\n         A     R1,BYTECNTI\n         XR    R0,R0\n         DR    R0,R14              AVG BLK = (BYTECNTI+READTOTI/2) /\n         LR    R0,R1                 MAX(READTOTI,1)\n        OUTPT  R0,AVGBLKS\n        OUTPT  MAXBLKI,MAXBLKS\n        OUTPT  READTOTI,NUMBLKS\n        OUTPT  =F'-1',ZBLKS,10,A=\n         MVC   MINBLKI,=F'33000'   RESET\n         XR    R14,R14               THE\n         ST    R14,READTOTI            FILE\n         ST    R14,MAXBLKI               STATISTICS\n         ST    R14,BYTECNTI                VARIABLES\n         CH    R2,=H'5'            END OF DATA-SET?\n         BL    INPUTS              NO, REPORT ON THE NEXT SEGMENT\nENDDATA  L     R0,READTOT\n         LTR   R0,R0               ANY RECORDS READ?\n         BP    ENDPSPO             YES, NORMAL DATA-SET\n        OUTPT  =F'-1',NULL         NO RECORDS IN THE DATA-SET\n         B     ENDX                EXIT\nITSPO    XR    R5,R5               CLEAR R5 FOR LATER\n         MVI   DSSTSW,0\n         OI    DSSTFL,DIRECTOR     TURN ON THE \"IN DIRECTORY\" FLAG\n         TM    DSSTFL,GASADD       GAS TO RECOVER?\n         BO    NEXTMBR             YES, BRANCH\n         CLI   DS1NOBDB,0          LAST DIRECTORY BLOCK IN USE?\n         BE    NEXTMBR             NO, BRANCH\n         XR    R0,R0\n         IC    R0,DS1NOBDB         NUMBER OF BYTES IN USE\n         ST    R0,TEMPW\n        OUTPT  TEMPW,NOBDBS\nNEXTMBR  BAL   R14,MEMBERS         GET THE NEXT MEMBER\n         B     *+L'*(R15)          BRANCH TABLE\n         B     GOODMBR             SUCCESSFUL\n         B     MBREOF              EOF IN DIRECTORY\n         B     LASTUSED            LAST USED ENTRY FOUND\n         B     NOTDIREC            NOT A DIRECTORY RECORD\nGOODMBR  LA    R2,REALMBR          SET A REAL ENTRY\n         NI    DSSTSW,255-ALIASF   TURN OFF THE ALIAS BIT FOR NAME\n         TM    PDS2INDC-PDS2(R1),PDS2ALIS ALIAS ENTRY?\n         BZ    NOTAL               NO, BRANCH\n         LA    R2,ALIASES          YES, AN ALIAS ENTRY\n         OI    DSSTSW,ALIASF       TURN ON THE ALIAS BIT FOR NAME\nNOTAL    L     R14,0(,R2)\n         LA    R14,1(,R14)         INCREMENT ALIASES OR REALMBR\n         ST    R14,0(,R2)\n         LR    R2,R1\n        TTRMBB PDS2TTRP-PDS2(R1),MBB=DOUBLE CONVERT TTR TO MBBCCHHR\n         TM    DSSTFL,FULLIL       FULLY LIST REQUESTED?\n         BZ    STTBL               NO, BRANCH\n         TM    DSSTSW,DIRPRF\n         BO    PRDIR\n         OI    DSSTSW,DIRPRF\n        OUTPT  =F'-1',DIRTLA\n        OUTPT  =F'-1',DIRTL1\n        OUTPT  =F'-1',DIRTL2\nPRDIR    MVC   WRKLNE,ZBLKS        CLEAR WORK LINE\n         MVC   WRKLNE(8),PDS2NAME-PDS2(R2) MOVE MEMBER OR ALIAS NAME\n         MVC   WRKLNE+8(3),=C'(M)' INDICATE MEMBER NAME\n         TM    DSSTSW,ALIASF       ALIAS ENTRY?\n         BZ    *+L'*+4             NO, OK\n         MVI   WRKLNE+9,C'A'       INDICATE ALIAS NAME\n        HEXES  PDS2TTRP-PDS2(R2),3,WRKLNE+15 TTR\n        HEXES  DOUBLE,8,WRKLNE+26  MBBCCHHR\n        OUTPT  =F'-1',WRKLNE,,A=\nSTTBL    L     R1,SAVETBL\nTBLINC   AL    R1,TLC\n         USING TLELM,R1\n         CLI   0(R1),C' '          EMPTY TABLE ENTRY?\n         BE    INSERT              YES, BRANCH\n         CLC   TLADDR(L'TLADDR),DOUBLE IS IT THIS ENTRY?\n         BNE   TBLINC              NO, CHECK NEXT ENTRY\n         TM    DSSTSW,ALIASF       ALIAS?\n         BO    NEXTMBR             YES, BRANCH\n         MVC   TLNAME(L'TLNAME),PDS2NAME-PDS2(R2) NO, USE REAL NAME\n         B     NEXTMBR\nINSERT   MVC   TLNAME(L'TLNAME),PDS2NAME-PDS2(R2) INSERT THE NAME\n         MVC   TLADDR(L'TLADDR),DOUBLE INSERT THE MBBCCHHR\n         MVC   TLTTR(L'TLTTR),PDS2TTRP-PDS2(R2) INSERT THE TTR\n         MVI   TLSTAT,0\n         TM    DSSTSW,ALIASF       ALIAS?\n         BZ    *+L'*+4             NO, BRANCH\n         OI    TLSTAT,TLALIAS      INDICATE ALIAS NAME\n         DROP  R1\n         LR    R5,R1               SAVE THE \"HIGH-WATER\" MARK\n         L     R1,REALENT\n         LA    R1,1(,R1)           COUNT THE NUMBER OF TABLE ENTRIES\n         ST    R1,REALENT\n         C     R1,TLMXRM\n         BL    NEXTMBR\n        OUTPT  =F'-1',MANYENT      TOO MANY MEMBER ENTRIES IN TABLE\n         MVC   MESSPL,TLMXRM\n        XMESS  5002\n         LA    R1,OVMMSG\nENDY     ST    R1,MSGADD\n         TM    DSSTFL,TRCFLG       TRACE WAS REQUESTED?\n         BZ    ENDZ                NO, BRANCH\n         TM    DSSTTRC+DCBOFLGS-IHADCB,DCBOFOPN TRC OPEN?\n         BZ    ENDZ                NO, BRANCH\n         L     R1,=F'-1'           CLOSE TRACE\n         BAL   R14,TRACE\n         B     ENDZ\nNOTDIREC XR    R15,R15             SIMULATED END OF FILE (GOOD READ)\nMBREOF   L     R1,READTOT          END OF FILE IN DIRECTORY\n         ST    R1,USEDBLK          USED COUNT\n         ST    R1,ALLOCBLK         ALLOCATED COUNT\n         B     PRESORT\nLASTUSED L     R0,READTOT          END OF USED ENTRIES IN DIRECTORY\n         ST    R0,USEDBLK\nRPTEXCP  BAL   R14,EXCPSTAT        READ AND COLLECT STATISTICS\n         LTR   R15,R15\n         BZ    RPTEXCP\n         L     R1,READTOT\n         ST    R1,ALLOCBLK         ALLOCATED COUNT\nPRESORT  XR    R0,R0\n         XI    DSSTFL,DIRECTOR     TURN OFF THE \"IN DIRECTORY\" FLAG\n         ST    R15,TEMPW           SAVE FOR LATER\n         ST    R0,READTOT          REINITIALIZE READTOT\n         ST    R0,MAXBLK             MAXBLK\n         ST    R0,BYTECNT              BYTECNT\n         MVC   MINBLK(4),=F'33000' REINITIALIZE MINBLK\n*- - - - SORT THE MEMBER ARRAY BY MBBCCHHR (USES A SHELLSORT).\n         L     R3,REALENT          NUMBER OF ELEMENTS TO SORT\n         LTR   R3,R3\n         BNP   SORTED\n         MH    R3,TLC+2            GAP IS LENGTH * NO. OF ELEMENTS\n         LR    R0,R3               N=GAP\nSHELLG   XR    R2,R2               GAP=GAP/2  (DROP FRACTION BITS)\n         D     R2,TLC\n         SRL   R3,1\n         LTR   R3,R3               GAP LESS THAN ONE?\n         BZ    SORTED              YES, DONE\n         MH    R3,TLC+2\n         L     R2,SAVETBL          TABLE BASE ADDRESS\n         LR    R4,R3               I=GAP\nSHELLI   AL    R4,TLC              I=I+1 (TABLE WIDTH)\n         CR    R4,R0               I<=N?\n         BH    SHELLG              NO, HALVE THE GAP\n         LR    R1,R4               YES, J=I\nSHELLJ   SR    R1,R3               J=J-GAP\n         BNP   SHELLI              IF J<=0, INCREMENT I\n         LA    R15,0(R2,R1)        ADDRESS OF SAVETBL(J)\n         LA    R14,0(R3,R1)        JG=J+GAP\n         LA    R14,0(R2,R14)       ADDRESS OF SAVETBL(JG)\n         CLC   8(8,R15),8(R14)     MBBCCHHR(J) <= MBBCCHHR(JG)\n         BNH   SHELLI              YES, INCREMENT I\n         XC    0(TLG,R14),0(R15)   INTERCHANGE\n         XC    0(TLG,R15),0(R14)     SAVETBL ENTRIES\n         XC    0(TLG,R14),0(R15)       J AND JG\n         B     SHELLJ              INCREMENT J\nSORTED   TM    DSSTSW,DIRPRF\n         BZ    LKTBL\n        OUTPT  =F'-1',ZBLKS,10,A=\n        OUTPT  =F'-1',DIRTLB\n        OUTPT  =F'-1',DIRTL1\n        OUTPT  =F'-1',DIRTL2\n         L     R2,SAVETBL\n         AL    R2,TLC\n         MVC   WRKLNE,ZBLKS        CLEAR WORK LINE\n         USING TLELM,R2\nPSDIR    MVC   WRKLNE(L'TLNAME),TLNAME MOVE MEMBER NAME\n         MVC   WRKLNE+L'TLNAME(3),=C'(M)' INDICATE MEMBER NAME\n        HEXES  TLTTR,L'TLTTR,WRKLNE+15 TTR\n        HEXES  TLADDR,L'TLADDR,WRKLNE+26 MBBCCHHR\n        OUTPT  =F'-1',WRKLNE,,A=\n         AL    R2,TLC\n         CLI   0(R2),C' '          EMPTY TABLE ENTRY?\n         BNE   PSDIR               NO, BRANCH\n         DROP  R2\n        OUTPT  =F'-1',ZBLKS,10,A=\n         L     R2,SAVETBL\n         B     NULLPDS\nLKTBL    L     R2,SAVETBL\n         LTR   R5,R5               ANY MEMBERS?\n         BZ    NULLPDS             NO, BRANCH\n         TM    DSSTFL,GASADD       GAS TO RECOVER?\n         BO    NULLPDS             YES, BRANCH\n         USING TLELM,R5\n        MVMSG  LASTMEMS            PREPARE MESSAGE\n         MVC   WRKLNE(L'TLNAME),TLNAME LAST MEMBER IN THE PDS\n         DROP  R5\n        OUTPT  =F'-1',WRKLNE,L'LASTMEMS,A=\nNULLPDS  L     R15,TEMPW           RESTORE THE RETURN CODE\nNXTREAL  AL    R2,TLC              LAST MEMBER WAS REAL\n         USING TLELM,R2\n         TM    DSSTFL,TRCFLG       TRACE REQUESTED?\n         BZ    NXTONE              NO, BRANCH\n         XR    R1,R1               TRACE TABLED MBBCCHHR\n         BAL   R14,TRACE\nNXTONE   L     R0,BYTECNT          LAST MEMBER WAS GAS\n         ST    R0,SAVETOT          SAVE FOR LATER\n         CH    R15,=H'8'           END OF DATA-SET?\n         BE    LASTMTCH            YES, BRANCH\n         OI    DSSTFL,REALONE      SET FLAG FOR ACTUAL MEMBER\nNXTTBL   L     R1,=A(CURRMBR)      PREPARE MESSAGE\n         MVC   AW2LNE(L'CURRMBR),0(R1)\n         MVC   AW2LNE(L'TLNAME),TLNAME SAVE THE CURRENT MEMBER NAME\n         CLC   TLADDR(L'TLADDR),DSIOBSK NEXT MBBCCHHR IN THE TABLE?\n         BE    REALRD              YES, BRANCH TO READ LOOP\n         BH    GSMBF               NO, HIGHER -- A \"GAS\" MEMBER\n         CLI   TLG(R2),C' '        EMPTY TABLE?\n         BE    DISTTR              YES, BRANCH\n        OUTPT  =F'-1',ZBLKS,10,A=  NO, INVALID TTR\n        MVMSG  INVTTR              PREPARE MESSAGE\n         MVC   WRKLNE+9(L'TLNAME),TLNAME SET MEMBER NAME IN MESSAGE\n        OUTPT  =F'-1',WRKLNE,L'INVTTR,A=\n         AL    R2,TLC              BUMP TABLE POINTER\n         TM    DSSTFL,TRCFLG       TRACE REQUESTED?\n         BZ    NXTTBL              NO, BRANCH\n         XR    R1,R1               TRACE TABLED MBBCCHHR\n         BAL   R14,TRACE\n         B     NXTTBL              TRY WITH NEXT\nDISTTR  OUTPT  =F'-1',TTRTOLOW     TABLED TTR < CURRENT TTR\n         LA    R1,TTRMSG\n         B     ENDY\nGSMBF    L     R1,GASCNT           NO, HIGHER -- A \"GAS\" MEMBER\n         LA    R1,1(,R1)\n         ST    R1,GASCNT           ADD ONE TO THE GAS MEMBER COUNT\n         XI    DSSTFL,REALONE      TURN OFF THE ACTUAL MEMBER FLAG\n         TM    DSSTFL,GASREQ       GAS RECORDS DESIRED?\n         BNO   GASRD               NO, BRANCH\n         L     R0,TRACKNUM         CURRENT TRACK NUMBER (RELATIVE 1)\n         BCTR  R0,0                CURRENT TRACK NUMBER (RELATIVE 0)\n         L     R1,LASTR            CURRENT RECORD NUMBER\n         LA    R1,1(,R1)           NEXT RECORD NUMBER (R OF TTR)\n         CLC   CURMBB(7),DSIOBSK   SWITCHED TRACKS?\n         BE    *+L'*+6             NO, BRANCH\n         LA    R1,1                RECORD ONE\n         AR    R0,R1               NEXT RELATIVE TRACK\n         STH   R0,TEMPW            SAVE RELATIVE TRACK NUMBER\n         STC   R1,TEMPW+2          SAVE RECORD NUMBER\n         L     R1,=A(GASMEM)       PREPARE MESSAGE\n         MVC   AW1LNE(L'GASMEM),0(R1)\n        HEXES  TEMPW,3,AW1LNE+21\n         TM    DSSTFL,GASADD       GAS TO RECOVER?\n         BZ    NORCV               NO, BRANCH\n         OC    STOWTTR,STOWTTR     ALREADY RESOLVED?\n         BNZ   NORCV               YES, BRANCH\n         TM    DSSTFL,GASALL       ALL GAS TO RECOVER?\n         BZ    NOGAST              NO\n         L     R1,GTSTR\n         LM    R14,R15,GTSTR+4\n         BXLE  R1,R14,SVTTR\n         TM    DSSTSW,SWOVG\n         BO    NORCV\n         OI    DSSTSW,SWOVG\n        OUTPT  =F'-1',GOVFLOW\n         MVC   MESSPL,TLMXGM\n        XMESS  5008\n         B     NORCV\nSVTTR    MVC   0(L'STOWTTR,R1),TEMPW SAVE TTR FOR STOW\n         ST    R1,GTSTR\n         B     NORCV\nNOGAST   CLC   GASTTR(L'GASTTR),AW1LNE+20 IS THIS THE ONE?\n         BNE   NORCV               NO, BRANCH\n         MVC   STOWTTR(L'STOWTTR),TEMPW SAVE TTR FOR STOW\nNORCV    TM    DS1RECFM,DCBRECU    LRECL=U?\n         BNO   DODATA              NO, BRANCH\n        OUTPT  =F'-1',AW1LNE,28,A= YES, DO NOT DO A DATA LINE\n         MVC   AW1LNE(L'GASMEM),ZBLKS RESET\n         B     GASRD\nDODATA  OUTPT  =F'-1',ZBLKS,10,A=\n        OUTPT  =F'-1',AW1LNE,L'GASMEM,A=\n         MVC   AW1LNE(L'GASMEM),ZBLKS RESET\n         BAL   R14,EXCPSTAT        INPUT THE NEXT REAL BLOCK\n         ST    R15,TEMPW           SAVE THE RETURN CODE\n         L     R15,CURLGTH\n         CH    R15,=H'72'\n         BNH   *+L'*+4\n         LH    R15,=H'72'          LIMIT OUTPUT LENGTH TO 72 BYTES\n         L     R1,BUFFER           BUFFER ADDRESS\n         LTR   R15,R15\n         BNZ   *+L'*+8\n         LA    R15,1               IF NULL LENGTH, USE ONE BYTE AND\n         MVI   0(R1),C' '            BLANK THE FIRST BYTE OF BUFFER\n        OUTPT  =F'-1',R1,0(R15)\n         L     R15,TEMPW           RESTORE THE RETURN CODE\n         B     GASRDF              SKIP THE FIRST READ (ALREADY DONE)\nGASRD    BAL   R14,EXCPSTAT        \"GAS\" MEMBER\n         L     R1,GASRDS\n         LA    R1,1(,R1)           ADD ONE TO THE GAS RECORD COUNT\n         ST    R1,GASRDS\n         TM    DSSTFL,TRCFLG       TRACE REQUESTED?\n         BZ    GASRDF              NO, BRANCH\n         LA    R1,DSIOBSK          TRACE NEXT MBBCCHHR\n         BAL   R14,TRACE\nGASRDF   LTR   R15,R15             (DON'T COUNT THE FIRST ONE)\n         BNZ   GASRDE\n         CLC   TLADDR(L'TLADDR),DSIOBSK NEXT MBBCCHHR IN THE TABLE?\n         BH    GASRD               NO, CONTINUE\n*                                  YES, END OF \"GAS\", THUS\nGASRDE   L     R0,BYTECNT            START OF A \"REAL\"\n         S     R0,SAVETOT          GAS BYTES THIS MEMBER\n         L     R1,GASBYTE\n         AR    R1,R0\n         ST    R1,GASBYTE          TOTAL GAS BYTES\n         C     R0,MAXGAS\n         BNH   *+L'*+4\n         ST    R0,MAXGAS           MAX BYTES/GAS MEMBER\n         C     R0,MINGAS\n         BNL   NXTONE\n         ST    R0,MINGAS           MIN BYTES/GAS MEMBER\n         B     NXTONE\nREALRD   BAL   R14,EXCPSTAT        \"REAL\" MEMBER\n         TM    DSSTFL,TRCFLG       TRACE REQUESTED?\n         BZ    REALRDF             NO, BRANCH\n         LA    R1,DSIOBSK          TRACE NEXT MBBCCHHR\n         BAL   R14,TRACE\nREALRDF  LTR   R15,R15             END OF FILE?\n         BNZ   REALRDE             YES, END OF \"REAL\"\n         CLI   TLG(R2),C' '        EMPTY TABLE?\n         BE    REALRD              NO, CONTINUE\n         CLC   TLADDR+TLG(L'TLADDR),DSIOBSK NEXT MBBCCHHR IN TABLE?\n         BH    REALRD              NO, CONTINUE\n        OUTPT  =F'-1',ZBLKS,10,A=\n        MVMSG  NOMEOF              PREPARE MESSAGE\n         MVC   WRKLNE+9(8),AW2LNE  SET MEMBER NAME IN MESSAGE\n        OUTPT  =F'-1',WRKLNE,L'NOMEOF,A= END OF \"REAL\", BUT NO EOF\n         LA    R15,4               SET RETURN CODE\nREALRDE  L     R0,BYTECNT\n         S     R0,SAVETOT\n         L     R1,RELBYTE\n         AR    R1,R0\n         ST    R1,RELBYTE          TOTAL BYTES FOR REAL MEMBERS\n         C     R0,MAXREL\n         BNH   *+L'*+4\n         ST    R0,MAXREL           MAX BYTES/REAL MEMBER\n         C     R0,MINREL\n         BNL   NXTREAL\n         ST    R0,MINREL           MIN BYTES/REAL MEMBER\n         B     NXTREAL\nLASTMTCH CLI   0(R2),C' '\n         BE    ENDPO\n        OUTPT  =F'-1',NOTFOUND     ALL MEMBERS NOT FOUND IN TABLE\n         LA    R1,MBSMSG\n         B     ENDY\nENDPO    TM    DSSTFL,GASADD       GAS TO RECOVER?\n         BO    STOW                YES, BRANCH\n         DROP  R2\n         TM    DSSTFL,TRCFLG       TRACE REQUESTED?\n         BZ    ENDPSPO             NO, BRANCH\n         L     R1,=F'-1'           CLOSE TRACE\n         BAL   R14,TRACE\nENDPSPO OUTPT  =F'-1',ZBLKS,10,A=\n        OUTPT  MINR,MINRS\n         L     R15,TRACKNUM\n         SRL   R15,1\n         A     R15,ALLR            (ALLR + TRACKNUM/2) / TRACKNUM\n         XR    R14,R14\n         D     R14,TRACKNUM        AVERAGE RECORDS PER TRACK\n         LR    R0,R15\n        OUTPT  R0,AVGRS\n        OUTPT  MAXR,MAXRS\n        OUTPT  =F'-1',ZBLKS,10,A=\n         L     R15,TRACKNUM\n         SRL   R15,1\n         A     R15,TRKBYTE         (TRKBYTE + TRACKNUM/2) / TRACKNUM\n         XR    R14,R14\n         D     R14,TRACKNUM        AVERAGE BYTES PER TRACK\n         ST    R15,AVGBTRK\n        OUTPT  MINBYTE,MINBYTES    MIN BYTES/TRACK\n        OUTPT  AVGBTRK,AVGBYTES    AVG BYTES/TRACK\n        OUTPT  MAXBYTE,MAXBYTES    MAX BYTES/TRACK\n        OUTPT  =F'-1',ZBLKS,10,A=\n        OUTPT  TRKBYTE,TOTBYTS     TOTAL DATA BYTES ON ALL TRACKS\n        OUTPT  =F'-1',ZBLKS,10,A=\n         CLC   MINBLK,=F'33000'    EVER CHANGED?\n         BNE   *+L'*+6             YES, BRANCH\n         XR    R14,R14             NO, RESET TO ZERO\n         ST    R14,MINBLK\n        OUTPT  MINBLK,MINBLKS\n         LA    R14,1\n         C     R14,READTOT\n         BH    *+L'*+4\n         L     R14,READTOT         TAKE MAX OF READTOT AND 1\n         L     R1,READTOT\n         SRL   R1,1\n         A     R1,BYTECNT\n         XR    R0,R0\n         DR    R0,R14              AVG BLK = (BYTECNT+READTOT/2) /\n         LR    R0,R1                 MAX(READTOT,1)\n        OUTPT  R0,AVGBLKS\n        OUTPT  MAXBLK,MAXBLKS\n        OUTPT  =F'-1',ZBLKS,10,A=\n        OUTPT  READTOT,NUMBLKS\n         TM    DS1DSORG,DS1DSGPO   DSORG=PO?\n         BNO   ENDX\n        OUTPT  GASRDS,GASBLKS\n        OUTPT  EOFS,ENDMBR\n        OUTPT  GASCNT,GASMBR\n         L     R0,GASCNT\n         LTR   R0,R0\n         BZ    NOGASM\n        OUTPT  =F'-1',ZBLKS,10,A=\n        OUTPT  MINGAS,MINGASS      MIN BYTES PER GAS MEMBER\n         L     R15,GASCNT\n         SRL   R15,1\n         A     R15,GASBYTE\n         XR    R14,R14\n         D     R14,GASCNT\n         LR    R0,R15\n        OUTPT  R0,AVGGASS          AVG BYTES PER GAS MEMBER\n        OUTPT  MAXGAS,MAXGASS      MAX BYTES PER GAS MEMBER\n        OUTPT  =F'-1',ZBLKS,10,A=\n         L     R1,GASBYTE\n         LA    R15,100\n         MR    R0,R15\n         AH    R1,=H'5'\n         D     R0,AVGBTRK          TRKS*100 = (GASBYTE*100+5) / AVGBTRK\n         CVD   R1,DOUBLE             (DOES THE REQUIRED ROUNDING)\n        MVMSG  GASTRK              PREPARE MESSAGE\n         UNPK  WRKLNE(9),DOUBLE+3(5)\n         MVC   WRKLNE+8(1),WRKLNE+7 MOVE TENS DIGIT OVER HUNDREDS\n         MVI   WRKLNE+7,C'.'       MOVE IN THE DECIMAL POINT\n         LA    R1,WRKLNE-1\n         LA    R1,1(,R1)           SCAN FOR\n         CLI   0(R1),C'0'            FIRST\n         BE    *-8                     NON-ZERO\n         CLI   0(R1),C'.'          WAS FIRST NON-ZERO THE PERIOD?\n         BNE   *+L'*+2             NO, BRANCH\n         BCTR  R1,0                YES, BACK UP ONE CHARACTER\n        OUTPT  =F'-1',0(R1),50,A= OUTPUT GAS TRACK TOTAL\nNOGASM  OUTPT  =F'-1',ZBLKS,10,A=\n         L     R0,EOFS\n         S     R0,GASCNT\n         BNP   NOREAL\n         ST    R0,TEMPW\n        OUTPT  MINREL,MINRELS      MIN BYTES PER REAL MEMBER\n         L     R15,TEMPW\n         SRL   R15,1\n         A     R15,RELBYTE\n         XR    R14,R14\n         D     R14,TEMPW\n         LR    R0,R15\n        OUTPT  R0,AVGRELS          AVG BYTES PER MEMBER\n        OUTPT  MAXREL,MAXRELS      MAX BYTES PER MEMBER\n         B     SOMEARE\nNOREAL  OUTPT  =F'-1',NOREALS\nSOMEARE OUTPT  =F'-1',ZBLKS,10,A=\n        OUTPT  ALLOCBLK,ALLBLK\n        OUTPT  USEDBLK,USEBLK\n         L     R1,REALMBR\n         A     R1,ALIASES\n         ST    R1,MINBLK\n        OUTPT  MINBLK,USENAME\n         L     R1,ALIASES\n         LTR   R1,R1\n         BZ    ENDX\n        OUTPT  ALIASES,ALSNAME\n         CLC   REALMBR,REALENT     ANY ALIASES WITHOUT REALS?\n         BE    ENDX                NO, DONE\n        OUTPT  =F'-1',ZBLKS,10,A=\n         BAL   R14,REREAD\n         L     R3,ALIASES\nTRYAGN   L     R2,SAVETBL\n         USING TLELM,R2\n         BAL   R14,MEMBERS\n         LTR   R15,R15\n         BP    ENDX\n         TM    PDS2INDC-PDS2(R1),PDS2ALIS ALIAS?\n         BNO   TRYAGN              NO, GET THE NEXT ENTRY\n        MVMSG  ALNOREAL,R=R14      PREPARE ERROR MESSAGE\n         MVC   WRKLNE(8),PDS2NAME-PDS2(R1)\n        TTRMBB PDS2TTRP-PDS2(R1),MBB=DOUBLE\nREALAGN  AL    R2,TLC\n         CLC   TLADDR(L'TLADDR),DOUBLE CORRESPONDING TABLE ENTRY?\n         BNE   REALAGN             NO, TRY THE NEXT ONE\n         TM    TLSTAT,TLALIAS      YES, ALIAS (IN THE TABLE)?\n         BZ    FOUNDIT             NO, BRANCH\n        OUTPT  =F'-1',WRKLNE,L'ALNOREAL,A= YES, ALIAS WITH NO REAL\nFOUNDIT  BCT   R3,TRYAGN\n         DROP  R2\nENDX     LA    R0,DSSTIN\n         O     R0,OCRLIST\n         ST    R0,OCPRLS\n        CLOSE  MF=(E,OCPRLS)       END POINT IF DSORG=PO, PS OR DA\n         TM    DS1DSORG,DS1DSGIS   ISAM DATA-SET?\n         BNO   ENDALL              NO, BRANCH\n         OI    JFCBTSDM,JFCNWRIT   PREVENT REVERSE MERGE TO JFCB\n         MVI   JFCBDSNM,X'04'      SET-UP DSNAME FOR\n         MVC   JFCBDSNM+1(43),JFCBDSNM FORMAT 4 DSCB\n         LA    R0,DSSTIN\n         O     R0,OCRLIST\n         ST    R0,OCPRLS\n        OPEN   TYPE=J,MF=(E,OCPRLS) DO AN OPEN JFCB\n         TM    DCBOFLGS,DCBOFOPN   OPENED CORRECTLY?\n         BO    OPNJOK              YES\n         LA    R1,OPJMSG           NO, ERROR\n         ST    R1,MSGADD\n         B     ENDALL\nOPNJOK   BAL   R14,REREAD\n         MVC   DSIOBSK+3(5),DS1PTRDS POINTER TO FORMAT 2 DSCB\n         BAL   R14,EXCP            READ THE FORMAT 2 DSCB\n         LTR   R15,R15\n         BZ    FMT2OK\n        OUTPT  =F'-1',NODSCB2      FORMAT 2 DSCB NOT READ CORRECTLY\n         LA    R1,FM2MSG\n         ST    R1,MSGADD\n         B     ENDZ\nFMT2OK  OUTPT  =F'-1',ZBLKS,10,A=\n        OUTPT  =F'-1',DSCB2\n         L     R5,BUFFER\n         USING DS2FMTID,R5\n         XR    R0,R0\n         IC    R0,DS2NOLEV\n         ST    R0,TEMPW\n        OUTPT  R0,DSSNOLEV         INDEX LEVELS\n         MVC   TEMPW+3(1),DS2DVIND\n        OUTPT  TEMPW,DSSDVIND      TRACKS FOR MASTER INDEX\n         MVC   TEMPW+3(1),DS2CYLOV\n        OUTPT  TEMPW,DSSCYLOV      TRACKS OF CYL. OVERFLOW PER CYLINDER\n         MVC   TEMPW+2(2),DS2TAGDT\n        OUTPT  TEMPW,DSSTAGDT      TAGGED FOR DELETION\n         MVC   TEMPW+1(3),DS2RORG3\n        OUTPT  TEMPW,DSSRORG3      OVERFLOW RECORD ACCESSES\n         LH    R0,DS2NOBYT\n        OUTPT  R0,DSSNOBYT         CORE TO HOLD THE HIGHEST INDEX\n         XR    R0,R0\n         IC    R0,DS2NOTRK\n        OUTPT  R0,DSSNOTRK         TRACKS OCCUPIED BY THE HIGHEST INDEX\n         MVC   TEMPW(L'TEMPW),DS2PRCTR\n        OUTPT  TEMPW,DSSPRCTR      RECORDS IN THE PRIME AREA\n         LH    R0,DS2BYOVL\n        OUTPT  R0,DSSBYOVL         BYTES LEFT ON CUR. IND. OVER. TRACK\n         LH    R0,DS2RORG2\n        OUTPT  R0,DSSRORG2         TRACKS LEFT IN IND. OVERFLOW AREA\n         LH    R0,DS2OVRCT\n        OUTPT  R0,DSSOVRCT         RECORDS IN THE OVERFLOW AREA\n         LH    R0,DS2RORG1\n        OUTPT  R0,DSSRORG1         CYLINDER OVERFLOW AREAS (FULL)\n         DROP  R5\nENDZ     LA    R0,DSSTIN\n         O     R0,OCRLIST\n         ST    R0,OCPRLS\n        CLOSE  MF=(E,OCPRLS)\n         B     ENDALL\nSTOW     LA    R0,DSSTIN\n         O     R0,OCRLIST\n         ST    R0,OCPRLS\n        CLOSE  MF=(E,OCPRLS)\n         TM    DSSTFL,GASALL       ALL GAS TO RECOVER?\n         BO    STGALL              YES\n         OC    STOWTTR,STOWTTR     GAS (TTR) ENCOUNTERED?\n         BNZ   STOWIT              YES, BRANCH\n        OUTPT  =F'-1',NTFGAS\n         B     ENDALL\nSTGALL   CLC   GTSTR,GTANK         ANY GAS FOUND?\n         BL    NGDS                NO\n         MVC   GTSTR+8,GTSTR       YES, SET POINTERS\n         MVC   GTSTR,GTANK\n         B     STOWIT\nNGDS    OUTPT  =F'-1',NGASDS\n         B     ENDALL\nSTOWIT   LA    R0,DSSTPDS\n         O     R0,OPLSUPD\n         ST    R0,OCPRLS\n        OPEN   MF=(E,OCPRLS)\n         LA    R3,1                MEMBER NAME SEQUENCE NUMBER\nSTOWLP   CVD   R3,DOUBLE\n         UNPK  STOWMEM+4(4),DOUBLE+5(3)\n         OI    STOWMEM+7,C'0'\n         L     R2,SAVETBL\n         USING TLELM,R2\nSTOWST   AL    R2,TLC\n         CLI   0(R2),C' '          EMPTY TABLE ENTRY?\n         BE    STOWOK              YES, BRANCH\n         CLC   TLNAME(L'TLNAME),STOWMEM IS IT THIS ENTRY?\n         BNE   STOWST              NO, CHECK NEXT ENTRY\n         B     STOWNX\n         DROP  R2\nSTOWONA  ST    R1,GTSTR\nSTOWNX   LA    R3,1(R3)            NEXT SEQUENCE NUMBER\n         CL    R3,=F'9999'         MAXIMUM REACHED?\n         BNH   STOWLP              NO\n         TM    DSSTFL,GASALL       YES, ALL GAS TO RECOVER?\n         BO    GALLUN              YES\n        OUTPT  =F'-1',GUNABLE\n         B     STOWEX\nGALLUN  OUTPT  =F'-1',TOOMUCH\n         B     STOWEX\nSTOWOK   TM    DSSTFL,GASALL       ALL GAS TO RECOVER?\n         BZ    *+L'*+10            NO\n         L     R1,GTSTR            YES, SET TTR OF GAS\n         MVC   STOWTTR(L'STOWTTR),0(R1)\n         XR    R15,R15\n        STOW   DSSTPDS,STOWMEM,A\n         MVC   WRKLNE,ZBLKS        CLEAR WORK LINE\n         MVC   WRKLNE(6),=CL6'MEMBER'\n         MVC   WRKLNE+7(L'STOWMEM),STOWMEM\n         MVC   WRKLNE+L'STOWMEM+8(L'STOWMSGA),STOWMSGA\n         LTR   R15,R15\n         BNZ   STOWERR\n         TM    DSSTFL,GASALL       ALL GAS TO RECOVER?\n         BO    *+L'*+10            YES\n         MVC   WRKLNE+L'STOWMEM+L'STOWMSGA+9(L'GASTTR),GASTTR\n         B     STOWMS\n         UNPK  DOUBLE(2*L'STOWTTR+1),STOWTTR(L'STOWTTR+1)\n         TR    DOUBLE(2*L'STOWTTR),HEXTBL-X'F0'\n         MVC   WRKLNE+L'STOWMEM+L'STOWMSGA+9(2),DOUBLE\n         MVI   WRKLNE+L'STOWMEM+L'STOWMSGA+11,C'.'\n         MVC   WRKLNE+L'STOWMEM+L'STOWMSGA+12(2),DOUBLE+2\n         MVI   WRKLNE+L'STOWMEM+L'STOWMSGA+14,C'.'\n         MVC   WRKLNE+L'STOWMEM+L'STOWMSGA+15(2),DOUBLE+4\n        OUTPT  =F'-1',WRKLNE,,A=\n         L     R1,TOTGAS\n         AH    R1,=H'1'\n         ST    R1,TOTGAS\n         L     R1,GTSTR\n         LM    R14,R15,GTSTR+4\n         BXLE  R1,R14,STOWONA\n         L     R1,TOTGAS\n         CVD   R1,DOUBLE\n         MVC   LASTMBB(6),=XL6'402020202120'\n         ED    LASTMBB(6),DOUBLE+5\n        MVMSG  ENDGALL             PREPARE MESSAGE\n         MVC   WRKLNE(5),LASTMBB+1\n        OUTPT  =F'-1',WRKLNE,L'ENDGALL,A=\n         B     STOWEX\nSTOWERR  MVC   WRKLNE+L'STOWMEM+8(L'STOWMSGB),STOWMSGB\n         STC   R15,WRKLNE+L'STOWMEM+L'STOWMSGB-9\n         SRL   R15,4\n         STC   R15,WRKLNE+L'STOWMEM+L'STOWMSGB-10\n         NC    WRKLNE+L'STOWMEM+L'STOWMSGB-10(2),=XL2'0F0F'\n         TR    WRKLNE+L'STOWMEM+L'STOWMSGB-10(2),HEXTBL\n         STC   R0,WRKLNE+L'STOWMEM+L'STOWMSGB-1\n         SRL   R0,4\n         STC   R0,WRKLNE+L'STOWMEM+L'STOWMSGB-2\n         NC    WRKLNE+L'STOWMEM+L'STOWMSGB-2(2),=XL2'0F0F'\n         TR    WRKLNE+L'STOWMEM+L'STOWMSGB-2(2),HEXTBL\nSTOWMS  OUTPT  =F'-1',WRKLNE,,A=\nSTOWEX   LA    R0,DSSTPDS\n         O     R0,OCRLIST\n         ST    R0,OCPRLS\n        CLOSE  MF=(E,OCPRLS)\nENDALL   TM    DSSTOUT+DCBOFLGS-IHADCB,DCBOFOPN OPEN?\n         BZ    SKCOUT              NO, SKIP\n         LA    R0,DSSTOUT\n         O     R0,OCRLIST\n         ST    R0,OCPRLS\n        CLOSE  MF=(E,OCPRLS)\nSKCOUT   TM    PRFLGS,PRTALL       \"PRT\" IS ALLOCATED?\n         BZ    SKCTRC              NO\n*- - - - DE-ALLOCATE OUTPUT FILE (\"SYSPRINT\")\n         L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL1' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME,DSPRTDDN     DD-NAME\n         DROP  R2\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    SKCTRC              OK\n        XMESS  5013\n         OC    MSGADD,MSGADD\n         BNZ   SKCTRC\n         LA    R1,FPFMSG\n         ST    R1,MSGADD\nSKCTRC   TM    PRFLGS,TRCALL       \"TRC\" IS ALLOCATED?\n         BZ    FREEWA              NO\n*- - - - DE-ALLOCATE TRACE FILE (\"SYSUT1\")\n         L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL1' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME,DSTRCDDN     DD-NAME\n         DROP  R2\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    FREEWA              OK\n        XMESS  5014\n         OC    MSGADD,MSGADD\n         BNZ   FREEWA\n         LA    R1,FTFMSG\n         ST    R1,MSGADD\nFREEWA   TM    DSSTFL,GASALL       WAS ALL GAS TO RECOVER?\n         BZ    QUIT                NO\n         LM    R0,R1,GTLGTH        YES\n        FREEMAIN R,A=(1),LV=(0)\nQUIT     LM    R0,R1,ARLGTH\n        FREEMAIN R,A=(1),LV=(0)\n         L     R13,4(R13)          PICK UP OLD SAVE-AREA\n         LM    R14,R12,12(R13)     RESTORE ALL REGISTERS\n         XR    R15,R15             SET RETURN CODE\n         BR    R14                 AND EXIT PROGRAM\n         EJECT\n*------ ISSUES EXCP'S AND GATHERS STATISTICS ROUTINE.\n*              R14 = LINK REGISTER\nEXCPSTAT ST    R14,STATR14\n         BAL   R14,EXCP\n         B     *+L'*(R15)\n         B     R15IS0              GOOD READ\n         B     R15IS4              END OF FILE OR END OF MEMBER\n         B     R15IS8              END OF DATA-SET\nR15IS12 OUTPT  =F'-1',ZBLKS,10,A=  I/O OR OTHER DISK ERROR\n         L     R14,INAROW\n         LA    R14,1(,R14)         UPDATE NUMBER OF CONSECUTIVE ERRORS\n         ST    R14,INAROW\n         CH    R14,=H'10'          ALLOW ONLY 10 CONSECUTIVE ERRORS\n         BL    CONTN\n        OUTPT  =F'-1',TOOMANY      TOO MANY CONSECUTIVE ERRORS\n         LA    R1,IODMSG\n         B     ENDY\nCONTN   MVMSG  IOERROR             PREPARE MESSAGE\n        HEXES  SAVECB,1,WRKLNE+21  ECB ERROR CODE\n        HEXES  CURMBB+3,5,WRKLNE+33 CURRENT DISK CCHHR\n        OUTPT  =F'-1',WRKLNE,L'IOERROR,A=\n         TM    DS1DSORG,DS1DSGPO   PDS?\n         BNO   BLKNUM              NO, BRANCH\n         TM    DSSTFL,DIRECTOR     ERROR IN THE DIRECTORY?\n         BO    DIRERR              YES, BRANCH\n         TM    DSSTFL,REALONE      ACTUAL MEMBER?\n         BNO   GASERR              NO, BRANCH\n        OUTPT  =F'-1',AW2LNE,L'CURRMBR,A= OUT CURRENT MEMBER NAME\n         MVC   AW2LNE(L'CURRMBR),ZBLKS RESET\n         B     R15IS4$\nGASERR  OUTPT  =F'-1',GASERRS      ERROR IN READING GAS DATA\n         B     R15IS4$\nDIRERR  OUTPT  =F'-1',DIRERRS      DIRECTORY I/O ERROR (IGNORE BLOCK)\nBLKNUM  OUTPT  READTOT,BLKNUMS     READ ERROR MESSAGE\n         B     EXCPSTAT+4          CONTINUE -- USING THE NEXT BLOCK\nR15IS4   XC    INAROW,INAROW       END OF MEMBER\nR15IS4$  LA    R15,4               TREAT AS END OF MEMBER CONDITION\n         L     R1,EOFS\n         LA    R1,1(,R1)           END OF MEMBER COUNTER\n         ST    R1,EOFS\n         CLC   MBBCCHH(7),CURMBB   NEW TRACK\n         BNE   NEWTRACK\n         L     R1,LASTR\n         LA    R1,1(,R1)\n         ST    R1,LASTR            UPDATE THE RECORD COUNT\n         B     RETURNS\nR15IS0   XC    INAROW,INAROW       GOOD READ\nR15IS0$  L     R1,READTOT\n         LA    R1,1(,R1)\n         ST    R1,READTOT          COUNT OF BLOCKS READ\n         L     R1,CURLGTH          CURRENT BLKSIZE\n         LR    R0,R1               SAVE FOR LATER\n         C     R1,MINBLK\n         BH    *+L'*+4\n         ST    R1,MINBLK           MINIMUM LENGTH BLOCK READ\n         C     R1,MAXBLK\n         BL    *+L'*+4\n         ST    R1,MAXBLK           MAXIMUM LENGTH BLOCK READ\n         A     R1,BYTECNT\n         ST    R1,BYTECNT          TOTAL NUMBER OF BYTES READ\n         TM    DS1DSORG,DS1DSGIS   ISAM DATA-SET?\n         BNO   NOFILSUM            NO, BRANCH\n         L     R1,READTOTI\n         LA    R1,1(,R1)\n         ST    R1,READTOTI         COUNT OF BLOCKS READ\n         LR    R1,R0               CURRENT BLKSIZE\n         C     R1,MINBLKI\n         BH    *+L'*+4\n         ST    R1,MINBLKI          MINIMUM LENGTH BLOCK READ\n         C     R1,MAXBLKI\n         BL    *+L'*+4\n         ST    R1,MAXBLKI          MAXIMUM LENGTH BLOCK READ\n         A     R1,BYTECNTI\n         ST    R1,BYTECNTI         TOTAL NUMBER OF BYTES READ\nNOFILSUM CLC   MBBCCHH(7),CURMBB   SAME MBBCCHH?\n         BNE   NEWTRACK            NO, BRANCH\n         A     R0,CURBYTE\n         ST    R0,CURBYTE          ACCUMULATE TRACK BYTE COUNT\n         L     R1,LASTR\n         LA    R1,1(,R1)\n         ST    R1,LASTR            ACCUMULATE RECORD COUNT/TRACK\n         B     RETURNS\nNEWTRACK L     R1,TRACKNUM         SWITCH TRACKS --\n         LA    R1,1(,R1)\n         ST    R1,TRACKNUM         ACTUAL TRACKS USED\nR15IS8   MVC   MBBCCHH(7),CURMBB   SAVE CURRENT TRACK NUMBER\n         L     R0,CURBYTE\n         L     R1,CURLGTH\n         ST    R1,CURBYTE\n         L     R1,TRKBYTE\n         AR    R1,R0\n         ST    R1,TRKBYTE          COUNT OF ALL CHARACTERS READ\n         L     R1,LASTR\n         LA    R14,1\n         ST    R14,LASTR\n         L     R14,ALLR\n         AR    R14,R1\n         ST    R14,ALLR            COUNT OF ALL READS\n         LTR   R0,R0               FIRST ENTRY HERE?\n         BNP   NOMINS              YES, BRANCH\n         C     R0,MINBYTE\n         BNL   *+L'*+4\n         ST    R0,MINBYTE          MIN BYTES/TRACK\n         C     R1,MINR\n         BNL   NOMINS\n         ST    R1,MINR             MIN RECORD NUMBER/TRACK\nNOMINS   C     R0,MAXBYTE\n         BNH   *+L'*+4\n         ST    R0,MAXBYTE          MAX BYTES/TRACK\n         C     R1,MAXR\n         BNH   RETURNS\n         ST    R1,MAXR             MAX RECORD NUMBER/TRACK\nRETURNS  L     R14,STATR14\n         BR    R14\n*------- MEMBER INPUT ROUTINE.\n*              R14 = LINK REGSITER\nMEMBERS  ST    R14,MEMBR14\n         LM    R15,R1,DIRPTRS      PICK UP ADDR, INCR, LIMIT\n         LTR   R1,R1               INITIALIZED?\n         BNZ   DEBLOCK             YES, BRANCH\n         BAL   R14,REREAD          OPEN IN FOR INPUT OF THE DIRECTORY\nGETBLK   BAL   R14,EXCPSTAT        GET A DIRECTORY BLOCK\n         LTR   R15,R15             END OF FILE?\n         BP    MBRDONE             YES, END OF FILE INDICATION\n         CLC   CURLGTH+2(2),=H'256' GOOD DIRECTORY BLOCK?\n         BNE   NDIRBLK             NO, BRANCH\n         LA    R0,2                INCREMENT IS 2 FIRST\n         L     R15,BUFFER          START\n         LH    R1,0(R15)           LENGTH HALFWORD\n         LA    R1,0(R1,R15)        LIMIT\n         BCTR  R1,0\nDEBLOCK  BXH   R15,R0,GETBLK\n         IC    R0,11(,R15)\n         N     R0,=F'31'           GET LENGTH BITS\n         AR    R0,R0               LENGTH * 2\n         AH    R0,=H'12'           LENGTH * 2  +  12\n         STM   R15,R1,DIRPTRS      SAVE FOR LATER\n         CLI   0(R15),X'FF'        LAST MEMBER\n         BNE   *+L'*+8             NO, BRANCH\n         LA    R15,8               LAST MEMBER USED INDICATION\n         B     MBRDONE\n         LR    R1,R15              ADDRESS OF MEMBER NAME (RETURNED)\n         XR    R15,R15             GOOD READ INDICATION\n         B     MBRDONE\nNDIRBLK OUTPT  =F'-1',EOFSIMS      RECORD LENGTH IS NOT 256\n        OUTPT  CURLGTH,BLOCKLEN    OUTPUT CURRENT LRECL\n         LA    R15,12              ERROR INDICATION\nMBRDONE  L     R14,MEMBR14         RETURN ADDRESS\n         BR    R14\n         EJECT\n*======= EXCP SUBROUTINES (OPENIN, REREAD AND EXCP).\n*------- OPEN THE FILE WITH DD-NAME FOR \"SYSIN\".\n*              R14 = LINK REGISTER\nOPENIN   ST    R14,EXCPR14         ENTRY TO OPEN THE FILE\n         LA    R0,DSSTIN\n         O     R0,OCRLIST\n         ST    R0,OCPRLS\n        RDJFCB MF=(E,OCPRLS)       GET DSN AND VOLUME SERIAL\n         LTR   R15,R15             SUCCESSFUL?\n         BZ    RDJFOK              YES, BRANCH\n        OUTPT  =F'-1',NOTRDJF\n        XMESS  5003,R15            ERROR\n         LA    R1,RJFMSG\n         B     ENDALL\nRDJFOK  OBTAIN DSSTCLS             READ IN THE FORMAT 1 DSCB\n         LTR   R15,R15             SUCCESSFUL?\n         BZ    OBTNOK              YES, BRANCH\n        OUTPT  =F'-1',NOTOBTN\n        XMESS  5004,R15            ERROR\n         LA    R1,OBTMSG\n         B     ENDALL\nOBTNOK   LA    R0,DSSTIN\n         O     R0,OCRLIST\n         ST    R0,OCPRLS\n        OPEN   MF=(E,OCPRLS)\n         TM    DCBOFLGS,DCBOFOPN   FILE OPEN?\n         BO    REREAD+4            YES, OK\n        OUTPT  =F'-1',NOTOPEN\n         LA    R1,OPNMSG\n         B     ENDALL\n*------- ENTRY TO REREAD THE OPENED DATA-SET (\"SYSIN\").\n*              R14 = LINK REGISTER\nREREAD   ST    R14,EXCPR14\n         L     R1,DCBDEBAD\n         XR    R14,R14\n         IC    R14,16(R1)          NUMBER OF EXTENTS\n         ST    R14,NUMEXT          SAVE FOR LATER\n         LA    R14,16(R1)          CURRENT EXTENT POINTER - 16\n         ST    R14,CUREXT          SAVE FOR LATER\n         MVI   DSIOBSK,0           RESET THE EXTENT NUMBER\n         LA    R15,4               EARLY EXIT FLAG\n         B     FIRSTONE            DO THE INITIAL EXTENT\n*- - - - FOR EACH EXTENT, INITIALIZE CCHHR, SECTOR NUMBER\n*        AND READ IN THE LENGTH OF THE FIRST RECORD.\nEACHXTNT XR    R1,R1               AFTER THE FIRST EXTENT --\n         IC    R1,DSIOBSK\n         LA    R1,1(,R1)\n         STC   R1,DSIOBSK          INCREMENT THE EXTENT NUMBER\n         C     R1,NUMEXT           PAST LAST EXTENT?\n         BNL   EOF$DS              YES, NO END OF DATA-SET RECORDED\nFIRSTONE ST    R15,EXCPR15         SAVE ENTRY CODE FOR LATER\n         L     R1,CUREXT\n         LA    R1,16(R1)           CURRENT EXTENT ENTRY\n         MVC   DSIOBSK+3(4),6(R1)  INITIAL CCHH\n         ST    R1,CUREXT           UPDATE FOR LATER\n         MVI   DSIOBSK+7,0\n         MVI   SECTNO,0            SET SECTOR NUMBER=ZERO\n         LA    1,CCWA1\n         ST    1,DSSTCPA\n        EXCP   DSSTIOB\n        WAIT   ECB=DSSTECB\n         CLI   DSSTECB,ECBNORM     GOOD READ?\n         BE    READOK              YES, BRANCH\n        OUTPT  =F'-1',FIRSTRD      1ST READ OF EXTENT DID NOT WORK\n         LA    R2,FRDMSG\n         B     EXCPERR\nREADOK   LA    R1,CCWB2\n         ST    R1,DSSTCPA\n         MVC   CCWB4+6(2),DATALN   GET LENGTH FOR NEXT READ\n         MVI   DSIOBSK+7,1         SET R=1\n         L     R15,EXCPR15\n         LTR   R15,R15             EARLY EXIT DESIRED?\n         BZ    EXCP+4              NO, ISSUE THE EXCP AGAIN\n         L     R14,EXCPR14         RETURN FROM OPENIN, REREAD OR\n         BR    R14                 AFTER EOF AND EXTENT VIOLATION\n*------- ENTRY FOR EACH EXCP TO BE PERFORMED.\n*              R14 = LINK REGISTER\nEXCP     ST    R14,EXCPR14\n         CLI   DSSTECB,ECBDAEA     EXTENT VIOLATION LAST TIME?\n         BE    EACHXTNT            YES, DO THE NEXT EXTENT\n         MVC   CURMBB(8),DSIOBSK   SAVE DISK ADDRESS OF THIS RECORD\n         MVC   CURLGTH+2(2),DATALN SAVE BLOCK LENGTH FOR THIS READ\n        EXCP   DSSTIOB\n        WAIT   ECB=DSSTECB\n         XR    R15,R15             GOOD READ FLAG\n         CLI   DSSTECB,ECBDAEA     EXTENT VIOLATION (NEXT TIME)?\n         BE    ENDEXCP             YES, EXIT\n         TM    DS1DSORG,DS1DSGIS   ISAM DATA-SET?\n         BO    *+L'*+10            YES, IGNORE DS1LSTAR CHECK FOR ISAM\n         CLC   LASTMBB(8),CURMBB   PAST THE DS1LSTAR MARKER?\n         BNH   EOF$DS              YES, END OF FILE AND DATA-SET\n         CLI   DSSTECB,ECBNORM     GOOD READ?\n         BE    ENDEXCP             YES, EXIT\n         CLI   DSSTECB,ECBPERR     PERMANENT ERROR?\n         BE    ERRPERM             YES, BRANCH\n        OUTPT  =F'-1',BADERROR\n         B     SOMERR              BAD ERROR, ECB NOT-X 41, 42 OR 7F\nERRPERM  TM    DSSTCSW+4,IOBUSB7   ACTUALLY EOF (UNIT EXCEPTION)?\n         BO    EOF\n         CLC   DSSTCSW+4(4),NZMBDS NULL MEMBER OR DATA-SET?\n         BE    EOF                 YES, BRANCH\n        OUTPT  =F'-1',PRMERROR\nSOMERR   LA    R15,12              PERMANENT ERROR -- NOT END OF FILE\n         MVC   SAVECB(1),DSSTECB   SAVE ECB CODE FOR LATER\n         B     REISSUE\nEOF      TM    DS1DSORG,DS1DSGPS+DS1DSGDA    DSORG=PS OR DA?\n         BNZ   EOF$DS              YES, END OF FILE AND DATA-SET\n         LA    R15,4               END OF MEMBER FLAG\n         CLC   =H'0',DATALN        NEXT BLOCK LENGTH = 0?\n         BNE   ENDEXCP             NO, BRANCH\nREISSUE  ST    R15,EXCPR15\n         LA    R1,CCWA1            NEED TO REISSUE THE INITIALIZATION\n         ST    R1,DSSTCPA            EXCP TO GET LENGTH AND ADDRESS\n        EXCP   DSSTIOB                 OF THE NEXT DATA BLOCK\n        WAIT   ECB=DSSTECB\n         L     R15,EXCPR15         READ ERROR (12) OR END OF MEMBER (4)\n         LA    R1,CCWB2\n         ST    R1,DSSTCPA\n         MVC   CCWB4+6(2),DATALN   DATA LENGTH FOR NEXT EXCP\n         CLI   DSSTECB,ECBDAEA     EXTENT VIOLATION?\n         BE    EACHXTNT            YES, DO NEXT EXTENT -- EARLY EXIT\n         CLI   DSSTECB,ECBNORM     GOOD READ?\n         BE    ENDEXCP             YES, EXIT\n         CLI   DSSTECB,ECBPERR     PERMANENT ERROR?\n         BE    CHKEOF              YES, CHECK EOF\n        OUTPT  =F'-1',BADERROR     SOME OTHER BAD ERROR\n         LA    R2,NRDMSG\n         B     EXCPERR\nCHKEOF   TM    DSSTCSW+4,IOBUSB7   NULL MEMBER (ANOTHER EOF)?\n         BO    ENDEXCP\n        OUTPT  =F'-1',PRMERROR     PERMANENT ERROR AFTER EOF\n         LA    R2,PRMMSG\nEXCPERR  MVC   MESSPL,DSSTECB\n        XMESS  5005                ERROR\n         LR    R1,R2\n         B     ENDY\nEOF$DS   LA    R15,8               END OF FILE AND DATA-SET FLAG\nENDEXCP  L     R14,EXCPR14         RETURN ADDRESS\n         BR    R14\n         EJECT\n*------- OUTPUT ROUTINE (\"SYSPRINT\").\n*        NOTE : R0 NEGATIVE IF NO NUMERIC OUTPUT,\n*                  OTHERWISE OUTPUT NUMERIC\n*               R1 CONTAINS THE ADDRESS OF THE STRING TO OUTPUT\n*               R14 CONTAINS THE RETURN ADDRESS\n*               R15 CONTAINS THE LENGTH OF THE STRING\nOUTRTN   ST    R14,RETOUT\n         BCTR  R15,0               MACHINE LENGTH\n         EX    R15,OUTMOVE         MOVE IN THE STRING\n         LTR   R0,R0               ANY LEADING NUMERICS?\n         LA    R1,OUTLNE+10\n         BM    OUTSTMT             NO, BRANCH\n         CVD   R0,DOUBLE\n         UNPK  OUTLNE(9),DOUBLE+3(5) ASSUME NO MORE THAN 9 DIGITS\n         LA    R1,OUTLNE-1\n         LA    R1,1(,R1)           SCAN FOR\n         CLI   0(R1),C'0'            FIRST\n         BE    *-8                     NON-ZERO\n         OI    OUTLNE+8,X'F0'      MAKE THE LAST DIGIT PRINTABLE\nOUTSTMT  TM    DSSTOUT+DCBOFLGS-IHADCB,DCBOFOPN OUT OPEN?\n         BO    OUTNOW              YES, BRANCH TO OUTPUT\n         ST    R1,SAVER1           SAVE R1\n*- - - - ALLOCATE OUTPUT FILE (\"SYSPRINT\")\n         L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL1' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         MVC   DDNAME,DSPRTDDN     DDNAME\n         MVC   DSNAME(L'DSSTUID),DSSTUID BUILD DS-NAME\n         LA    R3,DSNAME+L'DSSTUID-1\n         CLI   0(R3),C' '\n         BNE   *+L'*+4\n         BCT   R3,*-8\n         MVC   1(10,R3),=CL10'.ETPS.DSST'\n         MVC   11(5,R3),=CL5'PRT.D'\n         LA    R3,16(R3)\n         LA    R1,VUSWA            -> FORMAT DATE AND TIME WORK-AREA\n         XC    0(FDTWAL,R1),0(R1)  CLEAR\n         L     R15,ARFDTE          GET CURRENT DATE/TIME\n*- - - - ETPSFDTE PARM.LIST : \"FDTWA\" ADDRESS\n        CALL   (15)\n         USING FDTWA,R1\n         MVC   0(L'FXYY,R3),FXYY   SET YEAR (YY)\n         MVC   0+L'FXYY(L'FXDDD,R3),FXDDD SET DAY (DDD)\n         MVC   0+L'FXYY+L'FXDDD(2,R3),=CL2'.T'\n         LA    R3,2+L'FXYY+L'FXDDD(R3)\n         MVC   0(L'FTM,R3),FTM     SET TIME HHMMSS\n         MVC   0+L'FTM(5,R3),=CL5'.LIST'\n         DROP  R1\n         MVC   DSUNIT,=CL8'&DPUNM'\n         MVC   DSVOLSER,=CL6'&DPVSN' VOL-SER\n         MVC   DSALLOC,=CL5'&DPSPU' SPACE UNIT (TRK/CYL)\n         MVC   DSPRI,=CL6'&DPPRQ'  PRIMARY QUANTITY\n         MVC   DSSEC,=CL6'&DPSCQ'  SECONDARY QUANTITY\n         MVI   DSRECFM1,C'F'       SET RECFM=FBA\n         MVI   DSRECFM2,C'B'\n         MVC   DSBLKSI,=CL5'800 '  SET BLKSIZE\n         MVC   DSLRECL,=CL5'80 '   SET LRECL\n         MVC   DSSTATUS,=CL8'NEW ' SET DISP=(NEW,CATLG,CATLG)\n         MVC   DSNDISP,=CL8'CATLG '\n         MVC   DSADISP,=CL8'CATLG '\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    OUTOKA              OK\n        XMESS  5010                ERROR\n         LA    R1,APFMSG\n         B     ENDY\nOUTOKA   OI    PRFLGS,PRTALL       \"PRT\" IS ALLOCATED\n         MVC   DSPRTDSN,DSNAME\n         MVC   DSPRTVOL,DSVOLSER\n         DROP  R2\n         LA    R0,DSSTOUT\n         O     R0,OPLSOUT\n         ST    R0,OCPRLS\n        OPEN   MF=(E,OCPRLS)       OPEN PRINT OUTPUT\n         TM    DSSTOUT+DCBOFLGS-IHADCB,DCBOFOPN OPEN NOW?\n         BO    OUTRST              YES, BRANCH\n        XMESS  5006                ERROR\n         LA    R1,OFOMSG           OUTPUT FILE DID NOT OPEN\n         B     ENDY\nOUTRST   L     R1,SAVER1           RESTORE R1\nOUTNOW   BCTR  R1,0\n         MVI   0(R1),C' '\n         LR    R0,R1\n        PUT    DSSTOUT,(0)         OUTPUT THE LINE\n         TM    DSSTSW,OERRFL       ERROR?\n         BZ    *+L'*+8             NO, OK\n         LA    R1,OFEMSG           OUTPUT FILE ERROR\n         B     ENDY\n         MVI   OUTLNE,C' '\n         MVC   OUTLNE+1(L'OUTLNE-1),OUTLNE BLANK IT\n         L     R14,RETOUT          RETURN\n         BR    R14\nOUTMOVE  MVC   OUTLNE+10(*-*),0(R1) <<EXECUTED>>\n         EJECT\n*------- TRACE ROUTINE (\"SYSUT1\").\n*        NOTE : R1 POSITIVE = NEXT MBBCCHHR, ZERO = TABLED MBBCCHHR\n*                  AND NEGATIVE = CLOSE TRACE.\n*               R15 = CURRENT 'EXCP' CC (ONLY WHEN R1 POSITIVE).\n*      OUTPUT : 4 MBBCCHHR'S BY LINE, EACH ONE PRECEEDED BY\n*               - A BLANK TO INDICATE A NORMAL DATA BLOCK READ,\n*               - THE CHARACTER 'T' FOR A TABLED LOCATION (DIRECTORY),\n*               - ANOTHER CHARACTER (GENERALLY '4' FOR AN EOF) TO SAY\n*                 SPECIAL CONDITION.\nTRACE    STM   R14,R3,TRSVREG      SAVE REGISTERS AROUND ROUTINE\n         L     R3,TCURPTR          GET CURRENT POINTER\n         LTR   R1,R1               WHAT REQUESTED?\n         BZ    TR01                TABLED\n         BP    TR02                NEXT\n         CL    R3,TSTRPTR          FINAL, ANYTHING TO TRACE?\n         BE    TR07                NO, BRANCH TO CLOSE\n         LR    R2,R1               YES, PASS INDICATOR\n         B     TR04                GO OUTPUT LAST INFORMATION\n         USING TLELM,R2\nTR01     MVI   0(R3),C'T'          INDICATE TABLED ORIGIN\n         UNPK  1(9,R3),TLADDR(5)   STORE TABLED MBBCCHHR\n         UNPK  9(9,R3),TLADDR+4(5)\n         MVI   17(R3),C' '\n         TR    1(16,R3),HEXTBL-X'F0'\n         B     TR03\n         DROP  R2\nTR02     MVI   0(R3),C' '\n         UNPK  1(9,R3),0(5,R1)     STORE NEXT MBBCCHHR\n         UNPK  9(9,R3),4(5,R1)\n         MVI   17(R3),C' '\n         TR    1(16,R3),HEXTBL-X'F0'\n         LTR   R15,R15             EOF ON PREVIOUS MBBCCHHR?\n         BZ    TR03                NO, BRANCH\n         STC   R15,0(R3)           INDICATE EOF\n         OI    0(R3),X'F0'\n         TR    0(1,R3),HEXTBL-X'F0'\nTR03     LA    R3,18(,R3)          BUMP POINTER\n         CL    R3,TMAXPTR          END OF AREA?\n         BL    TR09                NO, BRANCH\nTR04     TM    DSSTTRC+DCBOFLGS-IHADCB,DCBOFOPN TRC OPEN?\n         BO    TR06                YES, BRANCH\n*- - - - ALLOCATE TRACE FILE (\"SYSUT1\")\n         L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL1' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         MVC   DDNAME,DSTRCDDN     DDNAME\n         MVC   DSNAME(L'DSSTUID),DSSTUID BUILD DS-NAME\n         LA    R3,DSNAME+L'DSSTUID-1\n         CLI   0(R3),C' '\n         BNE   *+L'*+4\n         BCT   R3,*-8\n         MVC   1(10,R3),=CL10'.ETPS.DSST'\n         MVC   11(5,R3),=CL5'TRC.D'\n         LA    R3,16(R3)\n         LA    R1,VUSWA            -> FORMAT DATE AND TIME WORK-AREA\n         XC    0(FDTWAL,R1),0(R1)  CLEAR\n         L     R15,ARFDTE          GET CURRENT DATE/TIME\n*- - - - ETPSFDTE PARM.LIST : \"FDTWA\" ADDRESS\n        CALL   (15)\n         USING FDTWA,R1\n         MVC   0(L'FXYY,R3),FXYY   SET YEAR (YY)\n         MVC   0+L'FXYY(L'FXDDD,R3),FXDDD SET DAY (DDD)\n         MVC   0+L'FXYY+L'FXDDD(2,R3),=CL2'.T'\n         LA    R3,2+L'FXYY+L'FXDDD(R3)\n         MVC   0(L'FTM,R3),FTM     SET TIME HHMMSS\n         MVC   0+L'FTM(5,R3),=CL5'.LIST'\n         DROP  R1\n         MVC   DSUNIT,=CL8'&DTUNM'\n         MVC   DSVOLSER,=CL6'&DTVSN' VOL-SER\n         MVC   DSALLOC,=CL5'&DTSPU' SPACE UNIT (TRK/CYL)\n         MVC   DSPRI,=CL6'&DTPRQ'  PRIMARY QUANTITY\n         MVC   DSSEC,=CL6'&DTSCQ'  SECONDARY QUANTITY\n         MVI   DSRECFM1,C'F'       SET RECFM=FBA\n         MVI   DSRECFM2,C'B'\n         MVC   DSBLKSI,=CL5'800 '  SET BLKSIZE\n         MVC   DSLRECL,=CL5'80 '   SET LRECL\n         MVC   DSSTATUS,=CL8'NEW ' SET DISP=(NEW,CATLG,CATLG)\n         MVC   DSNDISP,=CL8'CATLG '\n         MVC   DSADISP,=CL8'CATLG '\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    TR05                OK\n        XMESS  5011                ERROR\n        OUTPT  =F'-1',TRCAERR      TRACE FILE DID NOT ALLOCATE\n         LA    R1,ATFMSG\n         B     ENDY\nTR05     OI    PRFLGS,TRCALL       \"TRC\" IS ALLOCATED\n         MVC   DSTRCDSN,DSNAME\n         MVC   DSTRCVOL,DSVOLSER\n         DROP  R2\n         L     R2,TRSVREG+16       RESTORE R2\n         LA    R0,DSSTTRC\n         O     R0,OPLSOUT\n         ST    R0,OCPRLS\n        OPEN   MF=(E,OCPRLS)       OPEN TRACE OUTPUT\n         TM    DSSTTRC+DCBOFLGS-IHADCB,DCBOFOPN OPEN NOW?\n         BO    TR06                YES, BRANCH\n        OUTPT  =F'-1',TRCOERR      TRACE FILE DID NOT OPEN\n        XMESS  5007                ERROR\n         LA    R1,TRCMSG\n         B     ENDY\nTR06    PUT    DSSTTRC,TRCLNE      OUTPUT THE LINE\n         TM    DSSTSW,TERRFL       ERROR?\n         BZ    *+L'*+8             NO, OK\n         LA    R1,TREMSG           TRACE FILE ERROR\n         B     ENDY\n         MVC   TRCLNE+1(L'TRCLNE-1),TRCLNE BLANK IT\n         LTR   R2,R2               FINAL CALL?\n         BNM   TR08                NO, BRANCH\nTR07     LA    R0,DSSTTRC\n         O     R0,OCRLIST\n         ST    R0,OCPRLS\n        CLOSE  MF=(E,OCPRLS) CLOSE TRACE\n         NI    DSSTFL,255-TRCFLG   OFF TRACE\nTR08     L     R3,TSTRPTR          SET STARTING ADDRESS\nTR09     ST    R3,TCURPTR          SET NEW CURRENT POINTER\n         LM    R14,R3,TRSVREG      RESTORE REGISTERS\n         BR    R14                 RETURN\n         SPACE 1\n         DROP  R6,R7               END OF GLOBAL ADDRESSABILITY\n         SPACE 1\n         CNOP  0,8\n*------- SYNAD ROUTINES : AN I/O ERROR HAS OCCURED.\nOSYNAD   OI    DSSTSW,OERRFL       SIGNAL ERROR\n         BR    R14                 AND RETURN\n         CNOP  0,8\nTSYNAD   OI    DSSTSW,TERRFL       SIGNAL ERROR\n         BR    R14                 AND RETURN\n         EJECT\nTLMXRM   DC    A(&STTMM)           MAX. NUMBER OF \"REAL\" MEMBERS\nTLMXGM   DC    A(&STTMG)           MAX. NUMBER OF \"GAS\" MEMBERS\nNZMBDS   DC    0F'0',AL1(0,IOBCSB2),H'0'\nOCRLIST OPEN   (*-*,INPUT),MF=L    ALSO USED FOR CLOSE AND RDJFCB\nOPLSUPD OPEN   (*-*,UPDAT),MF=L\nOPLSOUT OPEN   (*-*,OUTPUT),MF=L\nHEXTBL   DC    CL16'0123456789ABCDEF'\nZBLKS    DC    CL80' '\nRJFMSG   MSG   'RDJFCB FAILED'\nOBTMSG   MSG   'OBTAIN FAILED'\nIODMSG   MSG   'I/O DISK ERROR'\nFRDMSG   MSG   '1ST READ ERROR'\nTTRMSG   MSG   'TTR DISCREPANCY'\nNRDMSG   MSG   'NEXT READ ERROR'\nPRMMSG   MSG   'PERMANENT ERROR'\nOPNMSG   MSG   'OPEN \"IN\" FAILED'\nOVMMSG   MSG   'MEMBERS OVERFLOW'\nFM2MSG   MSG   'FMT 2 DSCB ERROR'\nOFEMSG   MSG   'PUT \"PRT\" FAILED'\nTREMSG   MSG   'PUT \"TRC\" FAILED'\nOFOMSG   MSG   'OPEN \"PRT\" FAILED'\nTRCMSG   MSG   'OPEN \"TRC\" FAILED'\nOPJMSG   MSG   'OPEN TYPE=J ERROR'\nFPFMSG   MSG   'FREE \"PRT\" FAILED'\nFTFMSG   MSG   'FREE \"TRC\" FAILED'\nAPFMSG   MSG   'ALLOC \"PRT\" FAILED'\nATFMSG   MSG   'ALLOC \"TRC\" FAILED'\nMBSMSG   MSG   'MEMBERS DISCREPANCY'\nSTOWMSGA DC    C'ADDED TO DIRECTORY FOR TTR'\nSTOWMSGB DC    C'NOT ADDED TO DIRECTORY : R15=XX - R0=XX'\n         PRINT &PRS\n        LTORG\n         SPACE 1\n         DROP  R8,R9,R10,R11,R12   END OF BASE REGISTERS ADDRESSABILITY\n         EJECT\n*------- MODIFIED MESSAGES / OUTPT ...,A=\n*                ----+----1----+----2----+----3----+----4----+----5\nALNOREAL DC    C'12345678 IS AN ALIAS BUT HAS NO \"REAL\" ENTRY '\nSCALOS   DC    C'DATA-SET IS ALLOCATED IN 123456                   '\nIOERROR  DC    C'READ ERROR -- ECB = 12, CCHHR = 12.45.78.01.34    '\nCURRMBR  DC    C'12345678 IS THE MEMBER (END OF MEMBER SIMULATED) '\nLASTMEMS DC    C'12345678 IS THE LAST REAL MEMBER IN THE DATA-SET '\nPROTECT  DC    C'X IS THE PROTECTION KEY '\nGASMEM   DC    C'\"GAS\" MEMBER AT TTR TT.TT.RR, DATA : '\nLSTAR    DC    C'DS1LSTAR IS MM.BB.BB.CC.CC.HH.HH.RR '\nNOMEOF   DC    C'MEMBER : 12345678 (END OF MEMBER MISSING) ++++++++'\nINVTTR   DC    C'MEMBER : 12345678 (INVALID TTR POINTER) ..........'\nENDGALL  DC    C'12345 \"GAS\" MEMBERS PROCESSED - END '\nGASTRK   DC    CL60'1234567.9 TRACKS WOULD BE REGAINED BY COMPRESSING '\n         SPACE 1\n*------- UNMODIFIED MESSAGES / OUTPT ...,A=I (DEFAULT)\n*                ----+----1----+----2----+----3----+----4----+----5\nPRGRM    DC    C'ETPSDSST : DISK DATA-SET STATISTICS PROGRAM'\nSQL      DC    C'-------------------------------------------'\nNODSCB2  DC    C'ISAM FMT 2 DSCB READ ERROR -----------------------'\nDSCB2    DC    C'THE FOLLOWING DATA IS FROM THE ISAM LABEL RECORD :'\nDSSNOLEV DC    C'INDEX LEVELS PRESENT IN THIS DATA-SET'\nDSSDVIND DC    C'TRACKS FOR EACH MASTER INDEX'\nDSSCYLOV DC    C'TRACKS OF CYLINDER OVERFLOW AREA ON EACH CYLINDER'\nDSSTAGDT DC    C'RECORDS TAGGED FOR DELETION'\nDSSRORG3 DC    C'OVERFLOW ACCESSES (NOT COUNTING FIRST IN CHAIN)'\nDSSNOBYT DC    C'BYTES NEEDED TO HOLD THE HIGHEST INDEX IN CORE'\nDSSNOTRK DC    C'TRACKS OCCUPIED BY THE HIGHEST-LEVEL INDEX'\nDSSPRCTR DC    C'RECORDS IN THE PRIME AREA'\nDSSBYOVL DC    C'BYTES LEFT ON CURRENT INDEPENDENT OVERFLOW TRACK'\nDSSRORG2 DC    C'TRACKS REMAINING IN THE INDEPENDENT OVERFLOW AREA'\nDSSOVRCT DC    C'RECORDS IN THE OVERFLOW AREA'\nDSSRORG1 DC    C'CYLINDER OVERFLOW AREAS THAT ARE FULL'\nMINRS    DC    C'IS THE MINIMUM NUMBER OF RECORDS PER TRACK'\nAVGRS    DC    C'IS THE AVERAGE NUMBER OF RECORDS PER TRACK'\nMAXRS    DC    C'IS THE MAXIMUM NUMBER OF RECORDS PER TRACK'\nMINBYTES DC    C'IS THE MINIMUM NUMBER OF DATA BYTES PER TRACK'\nAVGBYTES DC    C'IS THE AVERAGE NUMBER OF DATA BYTES PER TRACK'\nMAXBYTES DC    C'IS THE MAXIMUM NUMBER OF DATA BYTES PER TRACK'\nMINGASS  DC    C'IS THE MINIMUM NUMBER OF BYTES IN ANY GAS MEMBER'\nAVGGASS  DC    C'IS THE AVERAGE NUMBER OF BYTES IN A GAS MEMBER'\nMAXGASS  DC    C'IS THE MAXIMUM NUMBER OF BYTES IN ANY GAS MEMBER'\nMINRELS  DC    C'IS THE MINIMUM NUMBER OF BYTES IN ANY REAL MEMBER'\nAVGRELS  DC    C'IS THE AVERAGE NUMBER OF BYTES IN A REAL MEMBER'\nMAXRELS  DC    C'IS THE MAXIMUM NUMBER OF BYTES IN ANY REAL MEMBER'\nNOREALS  DC    C'NO REAL MEMBERS ARE IN THIS PARTITIONED DATA-SET'\nMINBLKS  DC    C'IS THE SHORTEST BLOCK LENGTH'\nAVGBLKS  DC    C'IS THE AVERAGE BLOCK LENGTH'\nMAXBLKS  DC    C'IS THE MAXIMUM BLOCK LENGTH'\nTOTBYTS  DC    C'TOTAL DATA BYTES ARE IN THIS DATA-SET'\nNUMBLKS  DC    C'TOTAL DATA BLOCKS ARE RECORDED'\nGASBLKS  DC    C'OF THESE ARE GAS BLOCKS'\nEOFSS    DC    C'END OF FILE'\nENDMBR   DC    C'END OF MEMBER (FILE MARKS) ARE RECORDED'\nGASMBR   DC    C'OF THESE ARE FOR GAS MEMBERS'\nALLBLK   DC    C'DIRECTORY BLOCKS ARE ALLOCATED'\nUSEBLK   DC    C'OF THESE ARE IN USE'\nUSENAME  DC    C'MEMBER NAMES ARE IN THE DIRECTORY'\nALSNAME  DC    C'OF THESE ARE ALIASES'\nNUMTRKS  DC    C'TRACKS ARE ALLOCATED FOR THIS DATA-SET'\nEXTENTS  DC    C'IS THE SECONDARY ALLOCATION QUANTITY'\nNOSEC    DC    C'NO SECONDARY ALLOCATION QUANTITY IS IN THE LABEL'\nFRETRKS  DC    C'OF THESE ARE NOT IN USE'\nNUMEXTS  DC    C'EXTENTS ARE IN THIS DATA-SET'\nNOBDBS   DC    C'BYTES ARE USED IN LAST PDS DIRECTORY BLOCK'\nTRBALS   DC    C'BYTES ARE AVAILABLE ON THE LAST USED TRACK'\nTOOMANY  DC    C'TOO MANY CONSECUTIVE I/O ERRORS (10) -------------'\nMANYENT  DC    C'MEMBER ENTRIES TABLE OVERFLOW --------------------'\nNOTRDJF  DC    C'RDJFCB FOR \"SYSIN\" FAILED ------------------------'\nNOTOBTN  DC    C'OBTAIN FOR \"SYSIN\" FAILED ------------------------'\nNOTOPEN  DC    C'OPEN FOR \"SYSIN\" FAILED --------------------------'\nFIRSTRD  DC    C'FIRST READ OF AN EXTENT DID NOT WORK -------------'\nTTRTOLOW DC    C'TTR IN MEMBER TABLE .LT. CURRENT TTR -------------'\nNOTFOUND DC    C'MEMBER(S) NOT FOUND IN THE MEMBERS TABLE ---------'\nBADERROR DC    C'UNDEFINED READ ERROR -----------------------------'\nPRMERROR DC    C'UNDEFINED PERMANENT ERROR ------------------------'\nEOFSIMS  DC    C'BAD DIRECTORY RECORD -- RECORD LENGTH IS NOT 256 -'\nBLOCKLEN DC    C'IS THE BLOCK LENGTH (END OF DIRECTORY SIMULATED)'\nDIRERRS  DC    C'READ ERROR IN THE DIRECTORY ----------------------'\nBLKNUMS  DC    C'IS THE BLOCK NUMBER (BLOCK IGNORED)'\nGASERRS  DC    C'ERROR IN A GAS MEMBER (END OF MEMBER SIMULATED)'\nKEYLEN   DC    C'IS THE KEY LENGTH'\nKEYPOS   DC    C'IS THE RELATIVE KEY POSITION'\nNULL     DC    C'DATA-SET IS EMPTY --------------------------------'\nEXTHDR   DC    C'EXTENT  UCB  CC.CC.HH.HH   CC.CC.HH.HH   T./TRACKS'\nEXTUND   DC    C'------  ---  -----------   -----------   ---------'\nNOTPDS   DC    C'THIS IS NOT A PARTITIONED DATA-SET ... -----------'\nNTFGAS   DC    C'REQUESTED \"GAS\" (TTR) NOT FOUND ... --------------'\nNGASDS   DC    C'NO \"GAS\" IN THE DATA-SET ... ---------------------'\nGOVFLOW  DC    C'NUMBER OF \"GAS\" OVERFLOW (INCOMPLETE PROCESS) ----'\nGUNABLE  DC    C'UNABLE TO RECOVER THE REQUESTED \"GAS\" ... --------'\nTOOMUCH  DC    C'UNABLE TO RECOVER ALL \"GAS\" IN DATA-SET ... ------'\nWRMSG    DC    C'PARM=GAS(TT.TT.RR) SYNTAX ERROR ... --------------'\nTRCAERR  DC    C'\"TRACE\" FILE COULD NOT BE ALLOCATED --------------'\nTRCOERR  DC    C'\"TRACE\" FILE COULD NOT BE OPENED -----------------'\nDIRTLA   DC    C'DIRECTORY CONTENTS :'\nDIRTLB   DC    C'MEMBERS SORTED BY MBBCCHHR (OR TTR) :'\nDIRTL1   DC    C'NAME    M/A   TT.TT.RR   MM.BB.BB.CC.CC.HH.HH.RR'\nDIRTL2   DC    C'----    ---   --------   -----------------------'\n         PRINT &PRF\nCCWSK    CCW   X'31',*-*,X'60',5        SEARCH ID EQUAL (CCHHR)\n         CCW   X'08',*-*,X'60',1        TIC\n         CCW   X'92',*-*,X'20',8        MT READ NEXT COUNT\n         CCW   X'23',*-*,X'60',1        SET SECTOR\n         CCW   X'31',*-*,X'60',5        SEARCH ID EQUAL (CCHHR)\n         CCW   X'08',*-*,X'60',1        TIC\n         CCW   X'06',*-*,X'60',32767    READ DATA\n         CCW   X'92',*-*,X'60',8        MT READ NEXT COUNT\n         CCW   X'22',*-*,X'20',1        READ SECTOR NUMBER\nCCWSKL   EQU   *-CCWSK\nOUTSK   DCB    DSORG=PS,DDNAME=XXXXXXXX,MACRF=PM,SYNAD=OSYNAD\nOUTSKL   EQU   *-OUTSK\nTRCSK   DCB    DSORG=PS,DDNAME=XXXXXXXX,MACRF=PM,SYNAD=TSYNAD\nTRCSKL   EQU   *-TRCSK\nPDSSK   DCB    DSORG=PO,DDNAME=XXXXXXXX,MACRF=(R)\nPDSSKL   EQU   *-PDSSK\nINSK    DCB    DSORG=PS,DDNAME=XXXXXXXX,MACRF=E,EXLST=*-*\n         DC    0F'0',XL1'87',AL3(*-*)   JFCB BLOCK\nINSKL    EQU   *-INSK\nCAMSK   CAMLST SEARCH,*-*,*-*,*-*\nCAMSKL   EQU   *-CAMSK\n         PRINT &PRS\n         EJECT\nTLELM    DSECT                     \"SAVETBL\" ELEMENT DESCRIPTION\nTLNAME   DS    CL8                 MEMBER NAME\nTLADDR   DS    XL8                 MBBCCHHR\nTLTTR    DS    XL3                 TTR\nTLSTAT   DS    XL1                 STATUS FLAGS\nTLALIAS  EQU   X'01'                    ALIAS NAME\nTLG      EQU   *-TLELM             \"SAVETBL\" ELEMENT LENGTH\n         SPACE 1\nDWAREA   DSECT , ----------------- WORK-AREA -------------------------\nEYECATCH DS    CL8                 \"X.STATDS\"\nDSSTWK   DS    XL8                 WORK FIELD\nDSSTUID  DS    CL8                 USER-ID\nDSSTDDN  DS    CL8                 DATA-SET DD-NAME\nDSSTPSW  DS    CL8                  \" \"     PASSWORD\nDSSTDSN  DS    CL44                 \" \"     NAME\nDSSTVOL  DS    CL6                  \" \"     VOL-SER\nPRMFLD   DS    H                   PARM.FIELD LENGTH OF TEXT\nPRMTXT   DS    CL16                 \" \"       TEXT\nDSPRTDDN DS    CL8                 \"PRT\" DD-NAME\nDSPRTDSN DS    CL44                \"PRT\" DATA-SET NAME\nDSPRTVOL DS    CL6                 \"PRT\" VOLUME SERIAL NUMBER\nDSTRCDDN DS    CL8                 \"TRC\" DD-NAME\nDSTRCDSN DS    CL44                \"TRC\" DATA-SET NAME\nDSTRCVOL DS    CL6                 \"TRC\" VOLUME SERIAL NUMBER\nPRFLGS   DS    XL1                 PROCESSING FLAGS\nPRTALL   EQU   X'80'                    \"PRT\" FILE ALLOCATED\nTRCALL   EQU   X'40'                    \"TRC\" FILE ALLOCATED\nVIEWFLG  EQU   X'08'                    VIEW DATA-SET REQUESTED\nDELFLG   EQU   X'04'                    DELETE DATA-SET REQUESTED\nALTFLG   EQU   X'02'                    ALTERNATE CURSOR POSITION\nPOCFLG   EQU   X'01'                    PANEL OPTION CHANGED\n         DS    0D\nDWL1     EQU   *-DWAREA\nCCWA1    DS    D                   SEARCH ID EQUAL (CCHHR)\nCCWA2    DS    D                   TIC\nCCWA3    DS    D                   MT READ NEXT COUNT\nCCWB1    DS    D                   SET SECTOR\nCCWB2    DS    D                   SEARCH ID EQUAL (CCHHR)\nCCWB3    DS    D                   TIC\nCCWB4    DS    D                   READ DATA\nCCWB5    DS    D                   MT READ NEXT COUNT\nCCWB6    DS    D                   READ SECTOR NUMBER\nDSSTIOB  DS    F\n         DS    A\nDSSTCSW  DS    2A\nDSSTCPA  DS    A\n         DS    A\n         DS    2A\nDSIOBSK  DS    2A                  NEXT MBBCCHHR ADDRESS\n         DS    XL1                 NEXT KEY-LENGTH\nDATALN   DS    XL2                 NEXT RECORD LENGTH\nSECTNO   DS    XL1                 NEXT SECTOR NUMBER\nDSSTECB  DS    F                   ECB\nDOUBLE   DS    D\nLASTMBB  DS    D\nCURMBB   DS    CL8                 CURRENT MBBCCHHR ADDRESS\nMBBCCHH  DS    CL7                 SAVE AREA FOR MBBCCHH\nSAVECB   DS    XL1                 SAVE AREA FOR ECB\nOCPRLS   DS    F                   OPEN-CLOSE PARM.LIST\nDIRPTRS  DS    3A                  SAVE-AREA FOR R15, R0 AND R1\nMEMBR14  DS    A                   SAVE-AREA FOR RETURN ADDRESS\nRETOUT   DS    A                   SAVE-AREA FOR RETURN ADDRESS\nSAVER1   DS    A                   SAVE-AREA FOR R1 DURING OPEN\nCURLGTH  DS    F                   LENGTH OF THE CURRENT RECORD\nLASTR    DS    F                   CURRENT NUMBER OF RECORDS/TRK\nEXCPR14  DS    F                   RETURN REGISTER FOR EXCP\nEXCPR15  DS    F                   EXIT FLAG REGISTER SAVE-AREA\nSTATR14  DS    F                   RETURN REGISTER FOR EXCPSTAT\nCUREXT   DS    F                   ADDRESS OF THE CURRENT EXTENT\nNUMEXT   DS    F                   TOTAL EXTENTS IN THE DATA-SET\nREADTOT  DS    F                   TOTAL RECORDS READ\nMINBLK   DS    F                   MINIMUM LENGTH BLOCK\nMAXBLK   DS    F                   MAXIMUM LENGTH BLOCK\nBYTECNT  DS    F                   TOTAL BYTES READ\nREADTOTI DS    F                   TOTAL RECORDS READ (ISAM)\nMINBLKI  DS    F                   MINIMUM LENGTH BLOCK (ISAM)\nMAXBLKI  DS    F                   MAXIMUM LENGTH BLOCK (ISAM)\nBYTECNTI DS    F                   TOTAL BYTES READ (ISAM)\nTEMPW    DS    F                   TEMPORARY WORK STORAGE\nGASBYTE  DS    F                   TOTAL BYTES IN GAS MEMBERS\nRELBYTE  DS    F                   TOTAL BYTES IN REAL MEMBERS\nMINGAS   DS    F                   MIN BYTES IN GAS MEMBERS\nMAXGAS   DS    F                   MAX BYTES IN GAS MEMBERS\nMINREL   DS    F                   MIN BYTES IN REAL MEMBERS\nMAXREL   DS    F                   MAX BYTES IN REAL MEMBERS\nSAVETOT  DS    F                   STARTING BYTE COUNT HOLD\nMAXR     DS    F                   MAXIMUM RECORDS/TRACK\nMINR     DS    F                   MINIMUM RECORDS/TRACK\nTRKBYTE  DS    F                   SUM OF ALL BLOCKSIZES\nINAROW   DS    F                   NUMBER OF CONSECUTIVE ERRORS\nALLR     DS    F                   SUM OF ALL RECORDS READ\nCURBYTE  DS    F                   CURRENT TRACK BYTE COUNT\nMAXBYTE  DS    F                   MAXIMUM BYTES/TRACK\nMINBYTE  DS    F                   MINIMUM BYTES/TRACK\nTRACKNUM DS    F                   ACTUAL COUNT OF TRACKS USED\nEOFS     DS    F                   COUNT OF END OF FILES\nGASCNT   DS    F                   NUMBER OF \"GAS\" MEMBERS\nGASRDS   DS    F                   NUMBER OF \"GAS\" RECORDS\nAVGBTRK  DS    F                   AVERAGE BYTES PER TRACK\nAVAILTRK DS    F                   FREE TRACKS\nTOTALTRK DS    F                   TOTAL TRACKS\nALIASES  DS    F                   ALIASES IN THE DIRECTORY\nREALMBR  DS    F                   REAL ENTRIES (DIRECTORY)\nREALENT  DS    F                   MEMBER TABLE ENTRIES\nALLOCBLK DS    F                   DIRECTORY BLOCKS ALLOCATED\nUSEDBLK  DS    F                   DIRECTORY BLOCKS USED\nTOTGAS   DS    F                   TOTAL GAS MEMBERS PROCESSED\nTLC      DS    F\nARLGTH   DS    F                   I/O AREA AND DIR. ENTRIES LENGTH\nBUFFER   DS    A                   I/O AREA AND DIR. ENTRIES ADDRESS\nGTLGTH   DS    A                   GAS RECORDING AREA LENGTH\nGTANK    DS    A                   GAS RECORDING AREA ADDRESS\nGTSTR    DS    3A                  TO STORE GAS TTR'S\nSAVETBL  DS    A                   BASE ADDR. TO ROOM FOR DIR. ENTRIES\nTRSVREG  DS    6F\nTCURPTR  DS    A\nTSTRPTR  DS    A\nTMAXPTR  DS    A\nSTOWMEM  DS    CL8                 GAS - MEMBER NAME\nSTOWTTR  DS    XL3,XL1             TTR, INDICATOR BYTE\nGASTTR   DS    XL8\nDSSTOUT  DS    0F,XL(OUTSKL)\nDSSTTRC  DS    0F,XL(TRCSKL)\nDSSTPDS  DS    0F,XL(PDSSKL)\nDSSTIN   DS    0F,XL(INSKL-L'JFCBXIT)\nJFCBXIT  DS    F                   JFCB BLOCK\nDSSTJF   DS    0D\n        IEFJFCBN ,                 JFCB MAPPING MACRO\nDSSTCLS  DS    0F,XL(CAMSKL)\nDSSTWA   DS    0D,148X\nDSSTFL   DS    XL1                 FLAGS BYTE\nGASREQ   EQU   X'01'                    GAS RECORDS DESIRED (DEFAULT)\nLBLFLG   EQU   X'02'                    LABELS ONLY (NO DATA READ)\nFULLIL   EQU   X'04'                    FULLY INFORMATION LIST\nTRCFLG   EQU   X'08'                    TRACE MBBCCHHR'S\nGASADD   EQU   X'10'                    GAS RECORD TO BE RECOVERED\nGASALL   EQU   X'20'                    ALL GAS RECORDS TO BE RECOVERED\nREALONE  EQU   X'40'                    ERROR IN ACTUAL MEMBER FLAG\nDIRECTOR EQU   X'80'                    ERROR IN DIRECTORY RECORDS\nDSSTSW   DS    XL1                 WORK SWITCHES BYTE\nDIRPRF   EQU   X'01'                    DIRECTORY PRINT SWITCH\nALIASF   EQU   X'02'                    ALIAS NAME SWITCH\nOERRFL   EQU   X'10'                    OUTPUT FILE ERROR OCCURED\nTERRFL   EQU   X'20'                    TRACE FILE ERROR OCCURED\nSWOVG    EQU   X'80'                    MAX. GAS OVERFLOW OCCURED\nWKLNES   EQU   *\nAW1LNE   DS    CL50                1ST ALTERNATE WORK LINE\nAW2LNE   DS    CL50                2ND  \" \"      \" \"  \" \"\nWRKLNE   DS    CL80,CL2            WORK LINE\nOUTLNE   DS    CL90                OUTPUT PRINT LINE\nTRCLNE   DS    CL80                TRACE LINE\nWKBLL    EQU   *-WKLNES\nDWALEN   EQU   (((*-DWAREA)+7)/8)*8 --- WORK-AREA LENGTH -------------\nDWL2     EQU   DWALEN-DWL1\n         SPACE 1\n        SPLTAREA\n         SPACE 1\n        MYSAVE\n         SPACE 1\n        PARMLIST\n         SPACE 1\n        FDATE\n         PRINT &PRF\n        CVT    DSECT=YES,LIST=YES\nDSCDSECT DSECT\n        IECSDSL1 (1)\n         ORG   DS1DSNAM\n        IECSDSL1 (2)\n        IEFZB4D0\n        IEZIOB\n        IHAECB\n        DCBD   DSORG=PS,DEVD=DA\n        IHAPDS PDSBLDL=NO\n        PRINT  GEN\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPSEDIT": {"ttr": 11525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x07?\\x00\\x96\\x07?\\x14X\\x10q\\x10q\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-03-13T00:00:00", "modifydate": "1996-03-13T14:58:00", "lines": 4209, "newlines": 4209, "modlines": 0, "user": "SYSPAJA"}, "text": "EDIT     TITLE '--- E T P S -- ETPSEDIT - DATA-SET EDITOR ---'\n         PRINT OFF\n         COPY  ETPS$O2B            \"ETPS\" SYSPARM SELECTION\n         COPY  ETPSMACS            \"ETPS\" MACROS\n         COPY  ETPSDEFS            \"ETPS\" DEFINITIONS\n         PRINT ON\nETPSEDIT START 0\n         SPACE 1\nETPSEDIT AMODE 24\nETPSEDIT RMODE 24\n        MIDENT\n         EJECT\n*------- AT ENTRY, R1 = A(PARM.LIST) -> (DCB,\n*                                        DS-NAME,\n*                                        MEMBER-NAME,\n*                                        DS-ORG,\n*                                        NUM-RECS,\n*                                        VOL-SER,\n*                                        PASSWORD)\n         SPACE 1\n*------- FOLLOWS HOW DATA CARDS ARE STORED IN CORE :\nCDTA     EQU   0,72      CARDS DATA (CARDS COL. 1-72)\nCCNU     EQU   72,6      CARDS COLUMNS NUMBER USED (CARDS COL. 73-78)\nLCMF     EQU   78,2      LINE COMMANDS MEMORY FIELD (CARDS COL. 79-80)\nPPTR     EQU   80,4      PREVIOUS CARD POINTER (0 = BACKWARD END)\nNPTR     EQU   84,4      NEXT CARD POINTER (0 = FORWARD END)\nXLNG     EQU   88        HOLD DATA RECORD IN-CORE LENGTH\n         PRINT OFF\n$#L      EQU   &ELIMT              THRESHOLD VALUE (MAXIMUM CARDS)\n$#BN     EQU   1629                BASIC NUMBER OF CARDS\n$#BS     EQU   ($#BN*XLNG)+8       BASIC SPACE (52K = 13 PAGES)\n$#AN     EQU   512                 ADDITIONAL NUMBER OF CARDS\n$#AS     EQU   ($#AN*XLNG)         ADDITIONAL SPACE (44K = 11 PAGES)\n         PRINT ON\n         PRINT GEN\n         USING *,R12,R11\n         USING SAVE3,R13      ************************** R13 ==> SAVE3\n         USING SPLTAREA,R10   AT ENTRY : R10 MUST POINT TO \"SPLTAREA\"\n         B     32(,R15)\n         DC    CL28'  ETPSEDIT &SYSDATE &SYSTIME'\n         PRINT &PRF\n         STM   R14,R12,12(R13)     SAVE INPUT REGISTERS\n         LR    R12,R15             SET PROGRAM BASE REGISTER 1\n         LA    R3,1\n         LA    R11,4*KB-1(R3,R12)  SET PROGRAM BASE REGISTER 2\n         LR    R3,R10              SPLIT-SCREEN DSECT\n         SH    R3,=Y(SPLITWRK-SAVE3) POINT TO SAVE3\n         ST    R13,4(,R3)          STORE BACKWARD POINTER\n         ST    R3,8(R13)           STORE FORWARD POINTER\n         LR    R13,R3              SET DSECT BASE\n         LM    R2,R8,0(R1)         PICK UP THE REGISTERS\n*                                  R2=DCB ADDRESS\n*                                  R3=DS-NAME ADDRESS\n*                                  R4=MEMBER-NAME ADDRESS\n*                                  R5=DS-ORG ADDRESS\n*                                  R6=RECORDS COUNT ADDRESS\n*                                  R7=VOL-SER NAME ADDRESS\n*                                  R8=PASSWORD ADDRESS\n         ST    R2,EDTDCB           SAVE DCB ADDRESS\n         MVC   EDTDSNM(L'EDTDSNM),0(R3) SAVE DS-NAME\n         MVC   EDTMEM(L'EDTMEM),0(R4) SAVE MEMBER NAME\n         MVC   EDTORG(L'EDTORG),0(R5) SAVE DSORG\n         L     R6,0(R6)            PUT RECORDS COUNT IN R6\n         ST    R6,EDTRECS          SAVE RECORDS COUNT\n         ST    R6,EDTNOWL           \" \"\n         MVC   EDTVOL(L'EDTVOL),0(R7) SAVE VOL-SER\n         MVC   EDTPASS(L'EDTPASS),0(R8) SAVE PASSWORD\n         L     R0,SCROWS1          LINES PER PAGE SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+4             NO\n         L     R0,SCROWS2          LINES PER PAGE SCREEN 2\n         SH    R0,=Y(CREWDT)\n         STH   R0,EDSCROLL\n         XC    EDADDR,EDADDR       SET CURSOR POSITION DEFAULT\n         MVI   EDFSSW,0\n         MVI   EDPNSW,0\n         MVI   EDFUSW,0\n         MVI   EDFINDL,0           CLEAR FIND/CHANGE STRINGS FIELDS\n         MVI   EDCHNGL,0\n         MVI   EDFINDS,C' '\n         MVC   EDFINDS+1(L'EDFINDS-1),EDFINDS\n         MVC   EDCHNGS,EDFINDS\n         XR    R0,R0\n         ST    R0,EDTFCCP\n         STH   R0,EDTFOFF\n*- - - - OBTAIN SPACE TO HOLD DATA RECORDS\n         L     R4,=A($#L)\n         CLR   R6,R4               THRESHOLD, CAN I ACCEPT FILE?\n         BNH   OKFILE              YES\n         ST    R4,MESSPL           ELSE TOO LARGE\n        XMESS  2004\n         LA    R1,*+L'*+8\n         ST    R1,MSGADD\n         B     LEAVE\n         MSG   'SORRY, FILE TOO BIG',H=Y\nOKFILE   LM    R0,R1,=A($#AN,$#AS)\n         LM    R2,R3,=A($#BN,$#BS)\n         CLR   R2,R6\n         BNL   *+L'*+8\n         AR    R2,R0\n         AR    R3,R1\n         B     *-10\n        GETMAIN RC,LV=(R3)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    OKGETF              OK\n        XMESS  2011,R15            ERROR\n         LA    R1,*+L'*+8\n         ST    R1,MSGADD\n         B     LEAVE\n         MSG   'GETMAIN(I) FAILED',H=Y\nOKGETF   LR    R5,R1\n         ST    R5,EDTMAIN          1ST DATA GETMAINED AREA\n         ST    R3,EDTLENG          1ST DATA GETMAINED AREA LENGTH\n         LR    R0,R5\n         LR    R1,R3\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R0,R14              CLEAR ALL TO BINARY ZEROS\n         CLR   R2,R4               THRESHOLD REACHED?\n         BNH   *+L'*+2\n         LR    R2,R4\n         SR    R2,R6\n         ST    R2,EDTGASL          NUMBER OF GAS CARDS\n         LA    R1,8(R5)\n         ST    R1,EDTPOOL          FREE POOL CHAIN POINTER\n         MH    R2,=Y(XLNG)         MULTIPLY BY IN-CORE LENGTH\n         AR    R2,R1\n         ST    R2,EDTFIRST         FIRST POINTER (START LOCATION)\n         LR    R3,R1\n         LA    R1,XLNG(R3)\n         CLR   R1,R2               END OF FREE POOL CHAIN?\n         BNL   *+L'*+8             YES\n         ST    R1,NPTR(R3)\n         B     *-16\n*- - - - READ IN DATA-SET\n         L     R2,EDTDCB           PICK UP DCB ADDRESS\n         LM    R0,R1,DCBDDNAM-IHADCB(R2) SAVE DD-NAME\n         L     R2,AMEMDCB\n         MVC   0(PMVDCBL,R2),PMVDCB SET MACRF TO GET-MOVE\n         MVC   DCBMACR-IHADCB(L'DCBMACR,R2),=AL1(DCBMRGET+DCBMRMVG,0)\n         STM   R0,R1,DCBDDNAM-IHADCB(R2) STORE DD-NAME\n         LA    R1,EDEOFR           SET EODAD\n         STCM  R1,B'0111',DCBEODA-IHADCB(R2)\n         LA    R1,EDGSYNA          SET SYNAD\n         STCM  R1,B'0111',DCBSYNA-IHADCB(R2)\n         NI    EDTQST,255-GTSYFLG\n         MVI   OPCLPL,VLB          SET \"VL\" BIT\n        OPEN   ((R2),(INPUT)),MF=(E,OPCLPL)\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN TEST FOR GOOD OPEN?\n         BO    OKOPIN              OK\n        XMESS  2001\n         LA    R1,*+L'*+4\n         B     EDSMSG              ALL DONE\n         MSG   'OPEN INPUT FAILED',H=Y\nOKOPIN   L     R3,EDTFIRST         FIRST POINTER\n         ST    R3,EDTCURR          SET CURRENT POINTER\n         LA    R4,10               FIRST CARD NUMBER\n         XR    R6,R6\nEDGETR  GET    (R2),(R3)\n         TM    EDTQST,GTSYFLG      WAS SYNAD EXIT TAKEN?\n         BZ    *+L'*+12            NO, BRANCH\n         NI    EDTQST,255-GTSYFLG  YES, ERROR\n         LA    R1,EDTMSG\n         B     EDSMSG              STOP HERE, GO BACK\n         CVD   R4,EDDBLW\n         OI    EDDBLW+7,X'0F'\n         UNPK  EDTNUM(L'EDTNUM),EDDBLW+4(4)\n         MVC   CCNU(L'CCNU,R3),EDTNUM+L'EDTNUM-L'CCNU\n         XC    LCMF(L'LCMF,R3),LCMF(R3)\n         ST    R6,PPTR(R3)\n         LA    R5,XLNG(R3)\n         ST    R5,NPTR(R3)\n         TM    EDFSSW,EDDTSW       LOOK IF ASIS DATA\n         BO    EDGETN\n         MVI   CRDWA,C' '\n         MVC   CRDWA+1(L'CDTA-1),CRDWA\n         OC    CRDWA(L'CDTA),CDTA(R3)\n         CLC   CRDWA(L'CDTA),CDTA(R3)\n         BE    EDGETN\n         OI    EDFSSW,EDDTSW       SET ASIS DATA\n         OI    EDFUSW,EDASSW       SET ASIS\nEDGETN   LR    R6,R3\n         LR    R3,R5\n         LA    R4,10(R4)\n         B     EDGETR\n         CNOP  0,4\n*- - - - AT END OF READ, BUILD FREE POOL CHAIN\nEDEOFR   MVI   OPCLPL,VLB          SET \"VL\" BIT\n        CLOSE  ((R2)),MF=(E,OPCLPL)\n         XC    NPTR(L'NPTR,R6),NPTR(R6)\n         ST    R6,EDTLAST          SET LAST POINTER\n*- - - - DISPLAY MEMORIZED DATA\nEDSHOWS  LA    R5,TERMOUT+4        POINT TO START\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+12            NOPE, JUST GO DO IT\n         L     R3,SCROWS1          PICK UP NUMBER OF ROWS ON SCREEN 1\n         SLL   R3,2                MULTIPLY BY 4\n         LA    R5,TERMOUT+4(R3)    POINT TO START\n         L     R1,0(R5)            PICK UP TERMOUT POINTER\n         MVC   0(EDTROW1L,R1),EDTROW1 SET FIRST ROW\n         MVC   DSNMNM(L'EDTDSNM,R1),EDTDSNM SET EDIT HEAD LINE TEXT\n         LA    R1,L'EDTDSNM-1(R1)\n         CLI   0(R1),C' '\n         BNE   *+L'*+4\n         BCT   R1,*-8\n         CLI   EDTMEM,C' '\n         BE    EDHDLTE\n         MVI   1(R1),C'('\n         MVC   2(L'EDTMEM,R1),EDTMEM\n         LA    R1,L'EDTMEM+1(R1)\n         CLI   0(R1),C' '\n         BNE   *+L'*+4\n         BCT   R1,*-8\n         MVI   1(R1),C')'\nEDHDLTL  LA    R1,1(R1)\nEDHDLTE  CLI   1(R1),C' '\n         BNE   *+L'*+8\n         MVI   1(R1),C'-'\n         B     EDHDLTL\n         NI    0(R5),255-EOS       CLEAR END-OF-SCREEN\n         LA    R5,4(R5)\n         L     R1,0(R5)            PICK UP TERMOUT POINTER\n         MVC   0(EDTROW2L,R1),EDTROW2 SET NEXT ROW (COMMAND-SCROLL)\n         TM    EDFUSW,EXTCPY       COPY PENDING?\n         BZ    *+L'*+6             NO\n         MVC   EWSCF1(4,R1),=CL5'COPY' YES, VIEW COMMAND\n         TM    EDFUSW,EDCRSW\n         BZ    *+L'*+10\n         MVC   EWSCF2(L'EWSCF2,R1),=CL4'CSR'\n         B     *+L'*+24\n         TM    EDFUSW,EDHLSW\n         BZ    *+L'*+10\n         MVC   EWSCF2(L'EWSCF2,R1),=CL4'HALF'\n         B     *+L'*+6\n         MVC   EWSCF2(L'EWSCF2,R1),=CL4'PAGE'\n         NI    0(R5),255-EOS       CLEAR END-OF-SCREEN\n         LA    R5,4(R5)\n         L     R1,0(R5)            PICK UP TERMOUT POINTER\n         MVC   0(EDTROW3L,R1),EDTROW3 SET NEXT ROW (FIND-CHANGE)\n         MVC   EWSCF3(L'EWSCF3,R1),EDFINDS SET FIND STRING\n         MVC   EWSCF4(L'EWSCF4,R1),EDCHNGS SET CHANGE STRING\n         NI    0(R5),255-EOS       CLEAR END-OF-SCREEN\n         LA    R5,4(R5)\n         L     R1,0(R5)            PICK UP TERMOUT POINTER\n         MVC   0(EDTROW4L,R1),EDTROW4 SET NEXT ROW (SCALE)\n         NI    0(R1),255-EOS       CLEAR END-OF-SCREEN\n         L     R3,EDTCURR          PICK UP CURRENT POINTER\n         L     R6,SCROWS1          PICK UP NUMBER OF ROWS\n         CLI   SPLIT,2             AM I IN SPLIT SCREEN?\n         BNE   *+L'*+4             NOPE, JUST GO DO IT\n         L     R6,SCROWS2          MUST BE SCREEN 2\n         LA    R1,4                SUBTRACT FIRST 4 ROWS\n         SR    R6,R1               MAX LINES ON SCREEN\nEDMOVE   LTR   R3,R3               LAST CARD?\n         BZ    EDBOTT              EOF BEFORE END OF SCREEN\n         NI    0(R5),255-EOS       CLEAR END-OF-SCREEN\n         LA    R5,4(R5)\n         L     R1,0(R5)            PICK UP TERMOUT POINTER\n         MVC   0(EDTLNEL,R1),EDTLNE MOVE IN MASK\n         CLI   LCMF(R3),0          ANY PENDING LINE COMMAND?\n         BE    *+L'*+14            NO\n         MVC   EWSCF5(L'LCMF,R1),LCMF(R3) YES, MOVE IN LINE COMMAND\n         MVI   EWSCF5-1(R1),X'02'  CHANGE ATTRIBUTE TO INTENSIFIED\n         B     *+L'*+6\n         MVC   EWSCF5(L'EWSCF5,R1),CCNU(R3) MOVE IN CARD NUMBER\n         MVC   EWSCF6(L'EWSCF6,R1),CDTA(R3) MOVE IN CARD DATA\n         TM    EDFUSW,EDASSW\n         BO    *+L'*+8\n         L     R15,=A(CAPST)\n         B     *+L'*+4\n         L     R15,=A(ASIST)\n         TR    EWSCF6(L'EWSCF6,R1),0(R15) TRANSLATE UNVIEWABLE CHAR.\n         L     R3,NPTR(R3)         BUMP\n         BCT   R6,EDMOVE\n         B     EDENDS\nEDBOTT   NI    0(R5),255-EOS       CLEAR END-OF-SCREEN\n         LA    R5,4(R5)\n         L     R1,0(R5)            PICK UP TERMOUT POINTER\n         MVI   0(R1),80            SET LENGTH = 80\n         MVI   1(R1),X'05'\n         MVI   2(R1),C'*'\n         MVC   3(78,R1),2(R1)\n         MVC   33(16,R1),=CL16' BOTTOM OF DATA '\n         BCT   R6,*+L'*+4\n         B     EDENDS\n         CLI   SPLIT,1             AM I ON SCREEN 1?\n         BNE   EDSETL              NO\nEDBOTL   NI    0(R5),255-EOS       CLEAR END-OF-SCREEN\n         LA    R5,4(R5)\n         L     R1,0(R5)            PICK UP TERMOUT POINTER\n         MVI   0(R1),10            SET LENGTH = 10\n         MVI   1(R1),X'04'\n         MVI   2(R1),C' '\n         MVC   3(8,R1),2(R1)\n         BCT   R6,EDBOTL\nEDENDS   CLI   SPLIT,1             AM I ON SCREEN 1?\n         BE    EDCOMM              YES, DON'T SET PARM FLAG\nEDSETL   OI    0(R5),EOS           SET END-OF-SCREEN\nEDCOMM   L     R15,=A(EDTHELP)     DEFAULT HELP SCREEN\n         ST    R15,HELPADD\n         MVC   EDTCMND(L'EDTCMND),=CL8' '\n         TM    EDFUSW,EDASSW       ASIS?\n         BZ    *+L'*+4             NO\n         OI    PRCSSW,ASISFLG      YES, SET ASIS FOR INPUT\n         XC    CURADDR,CURADDR\n         OC    CURADDR,EDADDR      ANY CURSOR POSITION REQUESTED?\n         BNZ   *+L'*+8             YES\n         MVI   CURROW,CREWSC       NO, SET DEFAULT CURSOR ROW\n         MVI   CURCOL,CCEWSC       AND CURSOR COLUMN\n         AIF   ('&TXV' NE 'YES').SKVPC1\n*- - - - VERIFY POINTERS CHAINING\n*        FOLLOWING TEN INSTRUCTIONS ARE NORMALLY DELETED FROM THE\n*        ASSEMBLY (WHEN YOU GENERATE A FINAL EXECUTABLE VERSION).\n*        BUT IF YOU WANT, YOU MAY KEPT THEM BY SETTING THE GLOBAL\n*        VARIABLE \"&TXV\" TO VALUE \"YES\" (EVERY TERMINAL I/O YOU\n*        JUST LOST THE TIME TO SCAN THE POINTERS CHAIN).\n         L     R15,=A(VERCHAIN)\n        CALL   (15)\n         LTR   R0,R0\n         BZ    EDGOCO\n        XSNAP  1\n         LA    R1,*+L'*+8\n         ST    R1,MSGADD\n         B     EDGOCO\n         MSG   'CHAINING ERROR'\nEDGOCO   DS    0H\n.SKVPC1  ANOP\n*- - - - TERMINAL COMMUNICATION\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         NI    PRCSSW,255-ASISFLG  RESET ASIS FOR INPUT\n         LTR   R15,R15             BAD RC?\n         BZ    EDANAL              NO, OK\n         MVI   MSGBUFF,20\n         MVC   MSGBUFF+1(20),=CL20'T-I/O ERROR (RC=   )'\n         CVD   R15,EDDBLW\n         OI    EDDBLW+7,X'F0'\n         UNPK  EDDBLW(3),EDDBLW+6\n         MVC   MSGBUFF+17(3),EDDBLW\n         LA    R1,MSGBUFF\n         B     EDSMSG\n*- - - - SCREEN MAY HAVE CHANGED\nEDANAL   L     R0,SCROWS1          LINES PER PAGE SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+4             NO\n         L     R0,SCROWS2          LINES PER PAGE SCREEN 2\n         SH    R0,=Y(CREWDT)\n         STH   R0,EDSCROLL\n         MVC   EDADDR,CURADDR      COPY CURSOR POSITION\n*- - - - CHECK IF ANY PF-KEY COMMAND\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         CLI   0(R2),X'7D'         IS IT \"ENTER\"?\n         BE    EDLNES              YUP, CONTINUE\n         CLI   EDPNSW,0            ANY PENDING LINE COMMAND?\n         BNE   EDCOMM1             YES, SKIP\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    *+L'*+8             YES\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BNE   *+L'*+10            NO\n         MVC   EDTCMND(7),=CL7'SAVEND'\n         B     EDLNES              CONTINUE\n         CLI   0(R2),X'F4'         IS IT PF4?\n         BE    *+L'*+8             YES\n         CLI   0(R2),X'C4'         IS IT PF16?\n         BNE   *+L'*+10            NO\n         MVC   EDTCMND(7),=CL7'SAVEND'\n         B     EDLNES              CONTINUE\nEDCOMM1  CLI   0(R2),X'F7'         IS IT PF7?\n         BE    *+L'*+8             YES\n         CLI   0(R2),X'C7'         IS IT PF19?\n         BNE   *+L'*+10            NO\n         MVC   EDTCMND(7),=CL7'UP'\n         B     EDLNES              CONTINUE\n         CLI   0(R2),X'F8'         IS IT PF8?\n         BE    *+L'*+8             YES\n         CLI   0(R2),X'C8'         IS IT PF20?\n         BNE   *+L'*+10            NO\n         MVC   EDTCMND(7),=CL7'DOWN'\n         B     EDLNES              CONTINUE\n         CLI   0(R2),X'F5'         IS IT PF5?\n         BE    *+L'*+8             YES\n         CLI   0(R2),X'C5'         IS IT PF17?\n         BNE   *+L'*+10            NO\n         MVC   EDTCMND(7),=CL7'RFIND'\n         B     EDLNES              CONTINUE\n         CLI   0(R2),X'F6'         IS IT PF6?\n         BE    *+L'*+8             YES\n         CLI   0(R2),X'C6'         IS IT PF18?\n         BNE   *+L'*+10            NO\n         MVC   EDTCMND(7),=CL7'CHANGE'\n         B     EDLNES              CONTINUE\n         CLI   0(R2),X'7C'         IS IT PF12?\n         BE    *+L'*+8             YES\n         CLI   0(R2),X'4C'         IS IT PF24?\n         BNE   EDCOMM2             NO\n         CLI   EDPNSW,0            YES, ANY PENDING LINE COMMAND?\n         BNE   *+L'*+10            YES, ANALYZE WHAT\nGOBACK   XC    EDADDR,EDADDR       NO, FORCE DEFAULT\n         B     EDSHOWS             RESHOW THE SCREEN\n*- - - - \"EDPNSW\" PENDING LINE COMMAND STATUS (0 = OFF, 1 = ON) WHICH\n*        MAY OCCURS :\n*        AFBESW  RNGESW  CPABSW  MVABSW  CPRGSW  MVRGSW  DLRGSW  RPRGSW\n*          0       0       0       0       0       0       0       0\n*          1       0       0       0       0       0       0       0\n*          0       0       1       0       0       0       0       0\n*          0       0       0       1       0       0       0       0\n*          0       0       0       0       1       0       0       0\n*          0       0       0       0       0       1       0       0\n*          0       1       0       0       1       0       0       0\n*          0       1       0       0       0       1       0       0\n*          1       0       0       0       1       0       0       0\n*          1       0       0       0       0       1       0       0\n*          0       0       0       0       0       0       1       0\n*          0       0       0       0       0       0       0       1\n*                        <---------------- EXCLUSIVES ---------------->\n         TM    EDPNSW,DLRGSW\n         BZ    *+L'*+8\n         LA    R1,XCAMSG1          DD PENDING\n         B     EDSTMS\n         TM    EDPNSW,RPRGSW\n         BZ    *+L'*+8\n         LA    R1,XCAMSG2          RR PENDING\n         B     EDSTMS\n         TM    EDPNSW,AFBESW\n         BZ    EDSTPN1\n         TM    EDPNSW,CPRGSW\n         BZ    *+L'*+8\nEDSMS3   LA    R1,XCAMSG3          CC PENDING\n         B     EDSTMS\n         TM    EDPNSW,MVRGSW\n         BZ    *+L'*+8\nEDSMS4   LA    R1,XCAMSG4          MM PENDING\n         B     EDSTMS\n         TM    EDFUSW,EXTCPY       A/B PENDING WITH COPY?\n         BO    EDLNES              YES, OK\n         LA    R1,XCAMSG5          C/CC/M/MM PENDING\n         B     EDSTMS\nEDSTPN1  TM    EDPNSW,CPRGSW\n         BZ    EDSTPN2\n         TM    EDPNSW,RNGESW\n         BZ    EDSMS3\nEDSMS6   LA    R1,XCAMSG6          A/B PENDING\n         B     EDSTMS\nEDSTPN2  TM    EDPNSW,MVRGSW\n         BZ    EDSMS6\n         TM    EDPNSW,RNGESW\n         BO    EDSMS6\n         B     EDSMS4\nEDCOMM2  CLI   0(R2),X'6C'         IS IT PA1?\n         BNE   EDCOMM3             NO\n         LA    R1,*+L'*+4          YUP, ALL DONE (LIKE CANCEL)\n         B     EDSMSG\n         MSG   'PA1 PRESSED = CANCEL',H=Y\nEDCOMM3  CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    GOBACK              YUP, RESHOW SCREEN\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    GOBACK              YUP, RESHOW SCREEN\n         LA    R1,*+L'*+8\n         ST    R1,MSGADD\n         B     EDLNES              CONTINUE AS ENTER\n         MSG   'INVALID PF-KEY',H=Y\n*- - - - CHECK IF SCROLL MODIFIED\nEDLNES   L     R3,TERMINPT+ZIED    COMMAND LINE\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+12            NOPE\n         L     R3,SCROWS1          PICK UP SIZE OF SCREEN1\n         SLL   R3,2                MULTIPLY BY 4\n         L     R3,TERMINPT+ZIED(R3) ADJUST POINTER\n         CLI   0(R3),0             WAS THIS LINE CHANGED BY OPERATOR?\n         BE    EDDLM               NO\n         TM    EWSCF2-1(R3),INFMOD YES, SCROLL ENRERED?\n         BZ    EDDLM               NO\n         L     R14,TERMINPT        PICK UP AID/ROW/COL ADDRESS\n         CLI   1(R14),CREWSC       CURSOR ON THIS LINE?\n         BNE   *+L'*+6             NO\n         XC    EDADDR,EDADDR       YES, FORCE DEFAULT\n         LA    R14,EWSCF2(,R3)\n         LA    R0,L'EWSCF2\n         CLI   0(R14),C' '\n         BNE   *+L'*+12\n         LA    R14,1(,R14)\n         BCT   R0,*-12\n         B     *+L'*+18            NONE, CLEARED\n         MVI   EDDBLW,C' '\n         OC    EDDBLW(1),0(R14)\n         NI    EDFUSW,255-EDHLSW-EDCRSW RESET TO PAGE\n         CLI   EDDBLW,C'H'\n         BNE   *+L'*+8\n         OI    EDFUSW,EDHLSW       SET HALF\n         B     EDDLM\n         CLI   EDDBLW,C'C'\n         BNE   EDDLM\n         OI    EDFUSW,EDCRSW       SET CURSOR\n*- - - - CHECK IF ANY DATA LINES MODIFIED\nEDDLM    ICM   R3,B'1111',EDTCURR  PICK UP CURRENT POINTER\n         BZ    EDFCS               NONE\n         LA    R4,TERMINPT+ZIEL    POINT TO LINE DATA INPUT ADDRESS\n         L     R2,SCROWS1          PICK UP NUMBER OF ROWS\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   EDDLM1              NOPE\n         L     R1,SCROWS1          PICK UP SIZE OF SCREEN1\n         SLL   R1,2                MULTIPLY BY 4\n         LA    R4,TERMINPT+ZIEL(R1) ADJUST POINTER\n         L     R2,SCROWS2          PICK UP NUMBER OF ROWS\nEDDLM1   LA    R1,4                SUBTRACT FIRST 4 ROWS\n         SR    R2,R1               MAX LINES ON SCREEN\nEDDLM2   L     R5,0(,R4)           POINT TO LINE TERMINAL INPUT\n         CLI   0(R5),0             WAS THIS LINE CHANGED BY OPERATOR?\n         BE    EDDLM3              NO, GO CHECK FOR NEXT LINE\n         TM    EWSCF6-1(R5),INFMOD YES, FIELD MODIFIED?\n         BZ    EDDLM3              NO\n         MVC   CDTA(L'EWSCF6,R3),EWSCF6(R5) MOVE IN LINE DATA\n         OI    EDFSSW,SVDTSW       SAY DATA CHANGED\nEDDLM3   LA    R4,4(R4)            BUMP TO NEXT TERM INPUT ADDRESS\n         ICM   R3,B'1111',NPTR(R3) BUMP, IF I'VE LOOKED AT ALL,\n         BZ    *+L'*+4             GO TO NEXT CHECK\n         BCT   R2,EDDLM2           LOOP\n*- - - - CHECK IF FIND AND/OR CHANGE STRINGS ENTERED/MODIFIED\nEDFCS    LA    R4,TERMINPT+ZIEF    POINT TO LINE FND/CHG INPUT ADDRESS\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+12            NOPE\n         L     R1,SCROWS1          PICK UP SIZE OF SCREEN1\n         SLL   R1,2                MULTIPLY BY 4\n         LA    R4,TERMINPT+ZIEF(R1) ADJUST POINTER\n         L     R5,0(,R4)           POINT TO LINE TERMINAL INPUT\n         CLI   0(R5),0             WAS THIS LINE CHANGED BY OPERATOR?\n         BE    EDLCM               NO\n         TM    EWSCF3-1(R5),INFMOD FIELD MODIFIED?\n         BZ    EDFCSN              NO\n         LA    R0,L'EWSCF3-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   EWSCF3(R5),C' '\n         BNE   STFNDS\n         MVC   EWSCF3(L'EWSCF3-1,R5),EWSCF3+1(R5)\n         MVI   EWSCF3+L'EWSCF3-1(R5),C' '\n         BCT   R0,*-18\n         NI    EDFSSW,255-FNDSSW   NONE (CLEARED)\n         MVI   EDFINDL,0\n         MVI   EDFINDS,C' '\n         MVC   EDFINDS+1(L'EDFINDS-1),EDFINDS\n         CLI   EDROW,CREWFC        IS CURSOR ON THIS LINE?\n         BNE   EDFCSN              NO\n         CLI   EDCOL,CCEWCH        IS CURSOR ON FIND STRING FIELD?\n         BNL   EDFCSN              NO\n         XC    EDADDR,EDADDR       YES, FORCE DEFAULT\n         B     EDFCSN\nSTFNDS   XR    R0,R0\n         ST    R0,EDTFCCP          RESET F/C CURRENT POINTER\n         STH   R0,EDTFOFF          RESET OFFSET\n         LA    R14,EWSCF3+L'EWSCF3-1(R5) SET END OF FIND STRING FIELD\n         LA    R15,L'EDFINDS-1     MAXIMUM LENGTH FOR FIND STRING\n         CLI   0(R14),C' '         LOOK FOR LAST CHARACTER\n         BNE   *+L'*+6\n         BCTR  R14,0               DECREMENT BASE ADDRESS\n         BCT   R15,*-10\n         OI    EDFSSW,FNDSSW\n         MVI   EDFINDS,C' '\n         MVC   EDFINDS+1(L'EDFINDS-1),EDFINDS\n         LTR   R15,R15\n         BNP   STFNDS2             ONLY ONE CHARACTER\n         CLI   EWSCF3(R5),X'80'\n         BNL   STFNDS2\n         CLC   EWSCF3(1,R5),0(R14)\n         BNE   STFNDS2\n         SH    R15,=H'2'\n         BNP   STFNDS1\n         STC   R15,EDFINDL         SET LENGTH-1\n         EX    R15,*+L'*+4         MOVE STRING\n         B     EDFCSN\n         MVC   EDFINDS(*-*),EWSCF3+1(R5) <<EXECUTED>>\nSTFNDS1  AH    R15,=H'2'\nSTFNDS2  STC   R15,EDFINDL         SET LENGTH-1\n         EX    R15,*+L'*+4         MOVE STRING\n         B     EDFCSN\n         MVC   EDFINDS(*-*),EWSCF3(R5) <<EXECUTED>>\nEDFCSN   TM    EWSCF4-1(R5),INFMOD FIELD MODIFIED?\n         BZ    EDLCM               NO\n         LA    R0,L'EWSCF4-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   EWSCF4(R5),C' '\n         BNE   STCHGS\n         MVC   EWSCF4(L'EWSCF4-1,R5),EWSCF4+1(R5)\n         MVI   EWSCF4+L'EWSCF4-1(R5),C' '\n         BCT   R0,*-18\n         NI    EDFSSW,255-CHGSSW   NONE (CLEARED)\n         MVI   EDCHNGL,0\n         MVI   EDCHNGS,C' '\n         MVC   EDCHNGS+1(L'EDCHNGS-1),EDCHNGS\n         CLI   EDROW,CREWFC        IS CURSOR ON THIS LINE?\n         BNE   EDLCM               NO\n         CLI   EDCOL,CCEWCH        IS CURSOR ON CHANGE STRING FIELD?\n         BL    EDLCM               NO\n         XC    EDADDR,EDADDR       YES, FORCE DEFAULT\n         B     EDLCM\nSTCHGS   LA    R14,EWSCF4+L'EWSCF4-1(R5) SET END OF CHANGE STRING FIELD\n         LA    R15,L'EDCHNGS-1     MAXIMUM LENGTH FOR CHANGE STRING\n         CLI   0(R14),C' '         LOOK FOR LAST CHARACTER\n         BNE   *+L'*+6\n         BCTR  R14,0               DECREMENT BASE ADDRESS\n         BCT   R15,*-10\n         OI    EDFSSW,CHGSSW\n         MVI   EDCHNGS,C' '\n         MVC   EDCHNGS+1(L'EDCHNGS-1),EDCHNGS\n         LTR   R15,R15\n         BNP   STCHGS2             ONLY ONE CHARACTER\n         CLI   EWSCF4(R5),X'80'\n         BNL   STCHGS2\n         CLC   EWSCF4(1,R5),0(R14)\n         BNE   STCHGS2\n         SH    R15,=H'2'\n         BNP   STCHGS1\n         STC   R15,EDCHNGL         SET LENGTH-1\n         EX    R15,*+L'*+4         MOVE STRING\n         B     EDLCM\n         MVC   EDFINDS(*-*),EWSCF3+1(R5) <<EXECUTED>>\nSTCHGS1  AH    R15,=H'2'\nSTCHGS2  STC   R15,EDCHNGL         SET LENGTH-1\n         EX    R15,*+L'*+4         MOVE STRING\n         B     EDLCM\n         MVC   EDCHNGS(*-*),EWSCF4(R5) <<EXECUTED>>\n*- - - - CHECK IF ANY LINE COMMANDS\nEDLCM    NI    EDFSSW,255-RNUMSW\n         ICM   R3,B'1111',EDTCURR  PICK UP CURRENT POINTER\n         BZ    EDLNXDR             NONE\n         LA    R4,TERMINPT+ZIEL    POINT TO LINE DATA INPUT ADDRESS\n         L     R2,SCROWS1          PICK UP NUMBER OF ROWS\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   EDLCM1              NOPE\n         L     R1,SCROWS1          PICK UP SIZE OF SCREEN1\n         SLL   R1,2                MULTIPLY BY 4\n         LA    R4,TERMINPT+ZIEL(R1) ADJUST POINTER\n         L     R2,SCROWS2          PICK UP NUMBER OF ROWS\nEDLCM1   LA    R1,4                SUBTRACT FIRST 4 ROWS\n         SR    R2,R1               MAX LINES ON SCREEN\nEDLCM2   L     R5,0(,R4)           POINT TO LINE TERMINAL INPUT\n         CLI   0(R5),0             WAS THIS LINE CHANGED BY OPERATOR?\n         BE    EDLCM6              NO, GO CHECK FOR NEXT LINE\n         TM    EWSCF5-1(R5),INFMOD FIELD MODIFIED?\n         BZ    EDLCM6              NO\n         OC    EWSCF5(L'EWSCF5,R5),=CL8' '\n         LA    R8,CCNU(R3)         POINT TO SEQ.NUMBER\n         LA    R6,EWSCF5(,R5)      POINT TO LINE NUMBER COLUMNS\n         LA    R7,L'EWSCF5         SET LOOP CONTROL\n         LR    R0,R7\n         LR    R1,R6\n         CLI   0(R1),C' '          CHECK IF LINE COMMAND CLEARED?\n         BNE   EDLCM3              NO\n         LA    R1,1(R1)            BUMP POINTER\n         BCT   R0,*-12             LOOP\n         LA    R14,EDLCM6          SET RETURN TO CHECK FOR NEXT LINE\n         SPACE 1\n*                                  ------- \"DO CHECKS\" ROUTINE -------\n*                                  R14 = LINK REGISTER\nEDLCMR   CLI   LCMF(R3),0          WAS SOMETHING DEFINED?\n         BER   R14                 NO, RETURN\n         CLC   LCMF(L'LCMF,R3),=CL2'A' WAS AN AFTER?\n         BE    *+L'*+10\n         CLC   LCMF(L'LCMF,R3),=CL2'B' WAS A BEFORE?\n         BNE   EDLCMR1\n         NI    EDPNSW,255-AFBESW\n         XC    EDTABLOC,EDTABLOC\n         B     EDLCMRX\nEDLCMR1  CLC   LCMF(L'LCMF,R3),=CL2'C' WAS A COPY?\n         BNE   EDLCMR2\n         NI    EDPNSW,255-CPABSW\n         XC    EDTOFLOC,EDTOFLOC\n         B     EDLCMRX\nEDLCMR2  CLC   LCMF(L'LCMF,R3),=CL2'CC' WAS A COPY RANGE?\n         BNE   EDLCMR3\n         TM    EDPNSW,RNGESW\n         BO    EDLCMRZ\n         NI    EDPNSW,255-CPRGSW\n         B     EDLCMRY\nEDLCMR3  CLC   LCMF(L'LCMF,R3),=CL2'M' WAS A MOVE?\n         BNE   EDLCMR4\n         NI    EDPNSW,255-MVABSW\n         XC    EDTOFLOC,EDTOFLOC\n         B     EDLCMRX\nEDLCMR4  CLC   LCMF(L'LCMF,R3),=CL2'MM' WAS A MOVE RANGE?\n         BNE   EDLCMR5\n         TM    EDPNSW,RNGESW\n         BO    EDLCMRZ\n         NI    EDPNSW,255-MVRGSW\n         B     EDLCMRY\nEDLCMR5  CLC   LCMF(L'LCMF,R3),=CL2'DD' WAS A DELETE RANGE?\n         BNE   EDLCMR6\n         TM    EDPNSW,RNGESW\n         BO    EDLCMRZ\n         NI    EDPNSW,255-DLRGSW\n         B     EDLCMRY\nEDLCMR6  CLC   LCMF(L'LCMF,R3),=CL2'RR' WAS A REPEAT RANGE?\n         BNE   EDLCMRX\n         TM    EDPNSW,RNGESW\n         BO    EDLCMRZ\n         NI    EDPNSW,255-RPRGSW\nEDLCMRY  XC    EDTOFLOC,EDTOFLOC\n         B     EDLCMRX\nEDLCMRZ  NI    EDPNSW,255-RNGESW\n         CL    R3,EDTOTLOC\n         BE    *+L'*+6\n         MVC   EDTOFLOC,EDTOTLOC\n         XC    EDTOTLOC,EDTOTLOC\nEDLCMRX  XC    LCMF(L'LCMF,R3),LCMF(R3) CLEAR IT\n         BR    R14                 RETURN\n         SPACE 1\nEDLCM3   CLI   0(R6),C'A'          LINE AFTER LOCATION?\n         BNE   *+L'*+8             NO\n         ICM   R0,B'0011',=CL2'A'  SET AFTER THIS\n         B     *+L'*+12\n         CLI   0(R6),C'B'          LINE BEFORE LOCATION?\n         BNE   EDNXT1              NO\n         ICM   R0,B'0011',=CL2'B'  SET BEFORE THIS\n         TM    EDPNSW,AFBESW+DLRGSW+RPRGSW ALREADY IN OR ANY EXCLUSIVE?\n         BNZ   EDLCM6              YES, REJECT, CHECK FOR NEXT LINE\n         BAL   R14,EDLCMR          DO CHECKS\n         OI    EDPNSW,AFBESW\n         STCM  R0,B'0011',LCMF(R3) RETAIN AFTER/BEFORE THIS\n         ST    R3,EDTABLOC         RETAIN LOCATION\n         B     EDLCM6              CHECK FOR NEXT LINE\nEDNXT1   CLI   0(R6),C'C'          LINE COPY?\n         BNE   EDNXT2              NO\n         CH    R7,=H'1'\n         BE    *+L'*+10\n         CLC   0(2,R6),=CL2'CC'    LINE COPY RANGE?\n         BE    EDCPR1              YES\n         TM    EDPNSW,CPABSW+MVABSW+CPRGSW+MVRGSW+DLRGSW+RPRGSW\n         BNZ   EDLCM6              REJECT, CHECK FOR NEXT LINE\n         BAL   R14,EDLCMR          DO CHECKS\n         OI    EDPNSW,CPABSW\n         MVC   LCMF(L'LCMF,R3),=CL2'C' RETAIN COPY IT\n         ST    R3,EDTOFLOC         RETAIN LOCATION\n         B     EDLCM6              CHECK FOR NEXT LINE\nEDCPR1   TM    EDPNSW,CPABSW+MVABSW+MVRGSW+DLRGSW+RPRGSW\n         BNZ   EDLCM6              REJECT, CHECK FOR NEXT LINE\n         TM    EDPNSW,CPRGSW       START OF RANGE SET?\n         BO    EDCPR2              YES\n         BAL   R14,EDLCMR          DO CHECKS\n         OI    EDPNSW,CPRGSW\n         MVC   LCMF(L'LCMF,R3),=CL2'CC' RETAIN COPY IT\n         ST    R3,EDTOFLOC         RETAIN START (OR END) LOCATION\n         B     EDLCM6              CHECK FOR NEXT LINE\nEDCPR2   TM    EDPNSW,RNGESW       END OF RANGE SET?\n         BO    EDLCM6              YES, REJECT, CHECK FOR NEXT LINE\n         OI    EDPNSW,RNGESW\n         MVC   LCMF(L'LCMF,R3),=CL2'CC' RETAIN COPY IT\nSSLOC    L     R15,EDTFIRST        FIRST POINTER\nSSLOCL   CL    R15,EDTOFLOC        SEARCH THE STARTING LOCATION\n         BNE   *+L'*+8\n         ST    R3,EDTOTLOC         RETAIN END LOCATION\n         B     EDLCM6              CHECK FOR NEXT LINE\n         CLR   R3,R15\n         BE    *+L'*+8\n         L     R15,NPTR(R15)       NEXT CARD\n         B     SSLOCL\n         MVC   EDTOTLOC,EDTOFLOC   EXCHANGE START-END LOCATIONS\n         ST    R3,EDTOFLOC\n         B     EDLCM6              CHECK FOR NEXT LINE\nEDNXT2   CLI   0(R6),C'M'          LINE MOVE?\n         BNE   EDNXT3              NO\n         CH    R7,=H'1'\n         BE    *+L'*+10\n         CLC   0(2,R6),=CL2'MM'    LINE MOVE RANGE?\n         BE    EDMVR1              YES\n         TM    EDPNSW,CPABSW+MVABSW+CPRGSW+MVRGSW+DLRGSW+RPRGSW\n         BNZ   EDLCM6              REJECT, CHECK FOR NEXT LINE\n         BAL   R14,EDLCMR          DO CHECKS\n         OI    EDPNSW,MVABSW\n         MVC   LCMF(L'LCMF,R3),=CL2'M' RETAIN MOVE IT\n         ST    R3,EDTOFLOC         RETAIN LOCATION\n         B     EDLCM6              CHECK FOR NEXT LINE\nEDMVR1   TM    EDPNSW,CPABSW+MVABSW+CPRGSW+DLRGSW+RPRGSW\n         BNZ   EDLCM6              REJECT, CHECK FOR NEXT LINE\n         TM    EDPNSW,MVRGSW       START OF RANGE SET?\n         BO    EDMVR2              YES\n         BAL   R14,EDLCMR          DO CHECKS\n         OI    EDPNSW,MVRGSW\n         MVC   LCMF(L'LCMF,R3),=CL2'MM' RETAIN MOVE IT\n         ST    R3,EDTOFLOC         RETAIN START (OR END) LOCATION\n         B     EDLCM6              CHECK FOR NEXT LINE\nEDMVR2   TM    EDPNSW,RNGESW       END OF RANGE SET?\n         BO    EDLCM6              YES, REJECT, CHECK FOR NEXT LINE\n         OI    EDPNSW,RNGESW\n         MVC   LCMF(L'LCMF,R3),=CL2'MM' RETAIN MOVE IT\n         B     SSLOC\nEDNXT3   CLI   0(R6),C'D'          LINE DELETE?\n         BNE   EDNXT4              NO\n         CH    R7,=H'1'\n         BE    *+L'*+10\n         CLC   0(2,R6),=CL2'DD'    LINE DELETE RANGE?\n         BE    EDDDR1              YES\n         BAL   R14,EDLCMR          DO CHECKS\n         MVC   LCMF(L'LCMF,R3),=CL2'D' SET LINE TO BE DELETED\n         B     EDLCM6              CHECK FOR NEXT LINE\nEDDDR1   TM    EDPNSW,AFBESW+CPABSW+MVABSW+CPRGSW+MVRGSW+RPRGSW\n         BNZ   EDLCM6              REJECT, CHECK FOR NEXT LINE\n         TM    EDPNSW,DLRGSW       START OF RANGE SET?\n         BO    EDDDR2              YES\n         BAL   R14,EDLCMR          DO CHECKS\n         OI    EDPNSW,DLRGSW\n         MVC   LCMF(L'LCMF,R3),=CL2'DD' RETAIN DELETE IT\n         ST    R3,EDTOFLOC         RETAIN START (OR END) LOCATION\n         B     EDLCM6              CHECK FOR NEXT LINE\nEDDDR2   TM    EDPNSW,RNGESW       END OF RANGE SET?\n         BO    EDLCM6              YES, REJECT, CHECK FOR NEXT LINE\n         OI    EDPNSW,RNGESW\n         MVC   LCMF(L'LCMF,R3),=CL2'DD' RETAIN DELETE IT\n         B     SSLOC\nEDNXT4   CLI   0(R6),C'R'          LINE REPEAT?\n         BNE   EDNXT5              NO\n         CH    R7,=H'1'\n         BE    *+L'*+10\n         CLC   0(2,R6),=CL2'RR'    LINE REPEAT RANGE?\n         BE    EDRPR1              YES\n         BAL   R14,EDLCMR          DO CHECKS\n         MVC   LCMF(L'LCMF,R3),=CL2'R' SET LINE TO BE REPEATED\n         B     EDLCM6              CHECK FOR NEXT LINE\nEDRPR1   TM    EDPNSW,AFBESW+CPABSW+MVABSW+CPRGSW+MVRGSW+DLRGSW\n         BNZ   EDLCM6              REJECT, CHECK FOR NEXT LINE\n         TM    EDPNSW,RPRGSW       START OF RANGE SET?\n         BO    EDRPR2              YES\n         BAL   R14,EDLCMR          DO CHECKS\n         OI    EDPNSW,RPRGSW\n         MVC   LCMF(L'LCMF,R3),=CL2'RR' RETAIN REPEAT IT\n         ST    R3,EDTOFLOC         RETAIN START (OR END) LOCATION\n         B     EDLCM6              CHECK FOR NEXT LINE\nEDRPR2   TM    EDPNSW,RNGESW       END OF RANGE SET?\n         BO    EDLCM6              YES, REJECT, CHECK FOR NEXT LINE\n         OI    EDPNSW,RNGESW\n         MVC   LCMF(L'LCMF,R3),=CL2'RR' RETAIN REPEAT IT\n         B     SSLOC\nEDNXT5   CLI   0(R6),C'I'          LINE INSERT?\n         BNE   EDLCM4              NO\n         BAL   R14,EDLCMR          DO CHECKS\n         MVC   LCMF(L'LCMF,R3),=CL2'I' SET LINE TO BE INSERTED AFTER\n         B     EDLCM6              CHECK FOR NEXT LINE\n*- - - - PUT TESTS FOR OTHER LINE COMMANDS HERE - - - - - - - - - - -*\nEDLCM4   CLI   0(R6),C' '          IS IT A BLANK?\n         BE    EDLCM5              YES, GO SEE NEXT\n         CLC   0(1,R6),0(R8)       IS IT THE ORIGINAL SEQ.NUMBER?\n         BE    EDLCM5              YES, GO SEE NEXT\n         BAL   R14,EDLCMR          ELSE LIKE CLEARED, DO CHECKS\n         B     EDLCM6              CHECK FOR NEXT LINE\nEDLCM5   LA    R6,1(R6)            BUMP POINTER\n         LA    R8,1(R8)            BUMP POINTER\n         BCT   R7,EDLCM3           LOOP\nEDLCM6   LA    R4,4(R4)            BUMP TO NEXT TERM INPUT ADDRESS\n         ICM   R3,B'1111',NPTR(R3) BUMP, IF I'VE LOOKED AT ALL,\n         BZ    *+L'*+4             CHECK FOR COMMANDS, PFK\n         BCT   R2,EDLCM2           LOOP\n*- - - - EXECUTE ALL DELETE, REPEAT AND/OR INSERT\nEDLNXDR  L     R9,=A(EDDRIX)\n         BR    R9\n*- - - - NOW SEE IF THERE IS SOMETHING PENDING\nEDLNXQ   CLI   EDPNSW,0            ANY PENDING LINE COMMAND?\n         BE    CHECKRN             NONE, OK\n         TM    EDPNSW,AFBESW+CPABSW COPY?\n         BO    EDXCAB              COMPLETE, GO DO IT\n         TM    EDPNSW,AFBESW+CPRGSW+RNGESW COPY RANGE?\n         BO    EDXCGAB             COMPLETE, GO DO IT\n         TM    EDPNSW,AFBESW+MVABSW MOVE?\n         BO    EDXMAB              COMPLETE, GO DO IT\n         TM    EDPNSW,AFBESW+MVRGSW+RNGESW MOVE RANGE?\n         BO    EDXMGAB             COMPLETE, GO DO IT\n         TM    EDPNSW,DLRGSW+RNGESW DELETE RANGE?\n         BO    EDXDL               COMPLETE, GO DO IT\n         TM    EDPNSW,RPRGSW+RNGESW REPEAT RANGE?\n         BO    EDXRP               COMPLETE, GO DO IT\n         TM    EDPNSW,DLRGSW       ELSE INCOMPLETE\n         BZ    *+L'*+8\n         LA    R1,XCAMSG1          DD PENDING\n         B     EDLNLVE\n         TM    EDPNSW,RPRGSW\n         BZ    *+L'*+8\n         LA    R1,XCAMSG2          RR PENDING\n         B     EDLNLVE\n         TM    EDPNSW,AFBESW\n         BZ    EDLTPN1\n         TM    EDPNSW,CPRGSW\n         BZ    *+L'*+8\nEDLMS3   LA    R1,XCAMSG3          CC PENDING\n         B     EDLNLVE\n         TM    EDPNSW,MVRGSW\n         BZ    *+L'*+8\nEDLMS4   LA    R1,XCAMSG4          MM PENDING\n         B     EDLNLVE\n         TM    EDFUSW,EXTCPY       A/B PENDING WITH COPY?\n         BO    CHECKRN             YES, OK\n         LA    R1,XCAMSG5          C/CC/M/MM PENDING\n         B     EDLNLVE\nEDLTPN1  TM    EDPNSW,CPRGSW\n         BO    EDLTPN2\n         TM    EDPNSW,MVRGSW\n         BZ    EDLMS6\n         TM    EDPNSW,RNGESW\n         BO    EDLMS6\n         B     EDLMS4\nEDLTPN2  TM    EDPNSW,RNGESW\n         BZ    EDLMS3\nEDLMS6   LA    R1,XCAMSG6          A/B PENDING\nEDLNLVE  ST    R1,MSGADD\nCHECKRN  TM    EDFSSW,RNUMSW\n         BO    FORCERN\n         B     HNDLCMD\n*- - - - COPY ONE CARD AFTER/BEFORE ANOTHER\nEDXCAB   L     R9,=A(EDCABX)\n         BR    R9\n*- - - - COPY A GROUP OF CARDS AFTER/BEFORE ANOTHER\nEDXCGAB  L     R9,=A(EDCGABX)\n         BR    R9\n*- - - - MOVE ONE CARD AFTER/BEFORE ANOTHER\nEDXMAB   L     R9,=A(EDMABX)\n         BR    R9\n*- - - - MOVE A GROUP OF CARDS AFTER/BEFORE ANOTHER\nEDXMGAB  L     R9,=A(EDMGABX)\n         BR    R9\n*- - - - DELETE A GROUP OF CARDS\nEDXDL    L     R9,=A(EDDLG)\n         BR    R9\n*- - - - REPEAT A GROUP OF CARDS\nEDXRP    L     R9,=A(EDRPG)\n         BR    R9\n*- - - - NEXT HANDLE ANY COMMAND\nFORCERN  BAL   R14,EDRNRTN         RENUMBER\nHNDLCMD  L     R3,TERMINPT+ZIED    COMMAND LINE\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+12            NOPE\n         L     R3,SCROWS1          PICK UP SIZE OF SCREEN1\n         SLL   R3,2                MULTIPLY BY 4\n         L     R3,TERMINPT+ZIED(R3) ADJUST POINTER\n         CLI   EDTCMND,C' '        ANY PFK (COMMAND) STILL IN?\n         BNE   EDLNSTC             YES\n         CLI   0(R3),0             WAS THIS LINE CHANGED BY OPERATOR?\n         BE    EDLNSTC             NO\n         TM    EWSCF1-1(R3),INFMOD COMMAND ENTERED?\n         BZ    EDLNSTC             NO\n         NI    EDFUSW,255-EXTCPY   YES, RESET ANY COPY REQUEST\n         LA    R0,L'EWSCF1-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   EWSCF1(R3),C' '\n         BNE   *+L'*+14\n         MVC   EWSCF1(L'EWSCF1-1,R3),EWSCF1+1(R3)\n         MVI   EWSCF1+L'EWSCF1-1(R3),C' '\n         BCT   R0,*-18\n         OC    EDTCMND(7),EWSCF1(R3)\nEDLNSTC  CLI   EDTCMND,C' '        ANY COMMAND IN?\n         BNE   EDLNESN             YES\n         TM    EDFUSW,EXTCPY       NO, BUT COPY PENDING?\n         BZ    EDLNMV              NO, SKIP NEXT TEST\n         CLI   EDPNSW,AFBESW       YES, A/B PENDING IS ALONE?\n         BE    EDTCPYX             YES, COMPLETE, CAN DO COPY\n         CLI   EDPNSW,0            NO, ANY OTHER PENDING LINE COMMAND?\n         BNE   GOBACK              YES, RESHOW THE SCREEN\n         B     EDSMS7              ELSE SET MESSAGE\nEDLNMV   CLI   EDPNSW,0            NO, ANY PENDING LINE COMMAND?\n         BNE   GOBACK              YES, RESHOW THE SCREEN\n         L     R2,TERMINPT         PICK UP AID/ROW/COL ADDRESS\n         CLC   EDADDR,1(R2)        IS CURSOR POSITION MODIFIED?\n         BNE   EDSHOWS             YES, RESHOW THE SCREEN\n         CLI   EDROW,CREWDT        NO, IS CURSOR IN DATA LINES?\n         BL    GOBACK              NO, RESHOW THE SCREEN\n         XR    R1,R1               YES\n         IC    R1,EDROW\n         CLI   EDCOL,CCEWDT        IS CURSOR IN DATA COLUMNS?\n         BNL   EDLNMV1             YES\n         ICM   R3,B'1111',EDTCURR  NO, LET CURSOR ON CURRENT LINE\n         BZ    GOBACK              YUP, NONE\n         LA    R0,CREWDT\n         SR    R1,R0\n         LTR   R15,R1\n         BNP   EDLNMV5\n         ICM   R2,B'1111',NPTR(R3)\n         BZ    GOBACK              YUP, CURSOR PAST LAST DATA LINE\n         LR    R3,R2\n         BCT   R1,*-10\n         B     EDLNMV5\nEDLNMV1  LR    R14,R1              MOVE CURSOR ONE LINE AHEAD\n         LA    R0,CREWDT-1\n         SR    R1,R0\n         LR    R15,R1\n         ICM   R2,B'1111',EDTCURR\n         BZ    GOBACK              YUP, NONE\nEDLNMV2  ICM   R3,B'1111',NPTR(R2)\n         BZ    EDLNMV3\n         LR    R2,R3\n         BCT   R1,EDLNMV2\n         CH    R15,EDSCROLL\n         BE    EDLNMV4\n         LA    R14,1(R14)\n         STC   R14,EDROW\n         B     EDLNMV5\nEDLNMV3  LR    R3,R2\n         CH    R15,EDSCROLL\n         BNE   GOBACK\n         IC    R1,EDROW\n         BCTR  R1,0\n         STC   R1,EDROW\nEDLNMV4  ICM   R2,B'1111',EDTCURR\n         BZ    GOBACK              YUP, NONE\n         ICM   R2,B'1111',NPTR(R2)\n         ST    R2,EDTCURR\nEDLNMV5  LA    R14,CDTA(R3)        MOVE CURSOR AT START OF TEXT\n         LA    R15,L'CDTA\n         LA    R1,CCEWDT\nEDLNMV6  CLI   0(R14),C' '\n         BNE   EDLNMV7\n         LA    R14,1(R14)\n         LA    R1,1(R1)\n         BCT   R15,EDLNMV6\n         MVI   EDCOL,CCEWDT\n         B     EDSHOWS\nEDLNMV7  STC   R1,EDCOL\n         B     EDSHOWS\n*- - - - PUT TESTS FOR COMMAND HERE BELOW - - - - - - - - - - - - - -*\nEDLNESN  CLC   EDTCMND(5),=CL5'DUMP' TAKE A DUMP?\n         BNE   *+L'*+2             NO\n         DC    H'0'                YUP, TAKE AN S0C1 <------------ DUMP\n         TM    EDFUSW,EXTCPY       COPY PENDING?\n         BO    EDLNESN1            YES, SKIP\n         CLI   EDPNSW,0            ANY PENDING LINE COMMAND?\n         BNZ   EDLNESN1            YES, SKIP\n         CLC   EDTCMND(7),=CL7'SAVEND' IS \"SAVEND\"?\n         BE    EDSAVE              YES, GO DO IT\n         CLC   EDTCMND(5),=CL5'SAVE' IS \"SAVEND\"?\n         BE    EDSAVE              YES, GO DO IT\n         CLC   EDTCMND(4),=CL4'END' IS IT \"SAVEND\"?\n         BE    EDSAVE              YES, GO DO IT\n         CLC   EDTCMND(7),=CL7'SUBMIT' IS IT \"SUBMIT\"?\n         BE    EDSUBMT             YES, GO DO IT\n         CLC   EDTCMND(4),=CL4'SUB' IS IT \"SUBMIT\"?\n         BE    EDSUBMT             YES, GO DO IT\nEDLNESN1 CLC   EDTCMND(7),=CL7'CANCEL' IS IT \"CANCEL\"?\n         BE    *+L'*+10            YES\n         CLC   EDTCMND(4),=CL4'CAN' IS IT \"CANCEL\"?\n         BNE   EDLNESN2            NO\n         LA    R1,*+L'*+4\n         B     EDSMSG\n         MSG   'YUP, CANCEL DONE',H=Y\nEDLNESN2 CLC   EDTCMND(6),=CL7'RFIND' IS IT \"RFIND\"?\n         BE    EDRFIND             YES, GO DO IT\n         CLC   EDTCMND(5),=CL5'FIND' IS IT \"RFIND\"?\n         BE    EDRFIND             YES, GO DO IT\n         CLC   EDTCMND(3),=CL3'RF' IS IT \"RFIND\"?\n         BE    EDRFIND             YES, GO DO IT\n         CLC   EDTCMND(2),=CL2'F'  IS IT \"RFIND\"?\n         BE    EDRFIND             YES, GO DO IT\n         CLC   EDTCMND(2),=CL2'L'  IS IT \"RFIND\"?\n         BE    EDRFIND             YES, GO DO IT\n         CLC   EDTCMND(5),=CL7'DOWN' IS IT \"DOWN\"?\n         BE    EDMORMX             YES, GO DO IT\n         CLC   EDTCMND(2),=CL2'D'  IS IT \"DOWN\"?\n         BE    EDMORMX             YES, GO DO IT\n         CLC   EDTCMND(2),=CL2'+'  IS IT \"DOWN\"?\n         BE    EDMORMX             YES, GO DO IT\n         CLC   EDTCMND(3),=CL7'UP' IS IT \"UP\"?\n         BE    EDPREMX             YES, GO DO IT\n         CLC   EDTCMND(2),=CL2'U'  IS IT \"UP\"?\n         BE    EDPREMX             YES, GO DO IT\n         CLC   EDTCMND(2),=CL2'-'  IS IT \"UP\"?\n         BE    EDPREMX             YES, GO DO IT\n         CLC   EDTCMND(7),=CL7'CHANGE' IS IT \"CHANGE\"?\n         BE    EDCHANG             YES, GO DO IT\n         CLC   EDTCMND(2),=CL2'C'  IS IT \"CHANGE\"?\n         BE    EDCHANG             YES, GO DO IT\n         CLC   EDTCMND(5),=CL5'CAPS' IS IT \"CAPS\"?\n         BE    EDCAPS              YES, GO DO IT\n         CLC   EDTCMND(5),=CL5'ASIS' IS IT \"ASIS\"?\n         BE    EDASIS              YES, GO DO IT\n         CLC   EDTCMND(6),=CL6'WHERE' IS IT \"WHERE\"?\n         BE    EDWHERE             YES, GO DO IT\n         CLC   EDTCMND(2),=CL2'W'  IS IT \"WHERE\"?\n         BE    EDWHERE             YES, GO DO IT\n         CLC   EDTCMND(2),=CL2'?'  IS IT \"WHERE\"?\n         BE    EDWHERE             YES, GO DO IT\n         CLC   EDTCMND(5),=CL5'COPY' IS IT \"COPY\"?\n         BE    EDTCPY              YES, GO DO IT\n         TM    EDFUSW,EXTCPY       COPY PENDING?\n         BZ    EDLNESN3            NO\nEDSMS7   LA    R1,XCAMSG7          YES, A/B MISSING\n         B     EDSTMS\nEDLNESN3 CLI   EDPNSW,0            ANY PENDING LINE COMMAND?\n         BNE   GOBACK              YES, RESHOW THE SCREEN\n         ICM   R14,B'1111',EDTFIRST IS FILE EMPTY?\n         BNZ   EDLNESNX            NO\n         CLC   EDTCMND(6),=CL6'INPUT' IS IT \"INPUT\"?\n         BE    EDINPT1             YES, GO DO IT\n         CLC   EDTCMND(2),=CL2'I'  IS IT \"INPUT\"?\n         BE    EDINPT2             YES, GO DO IT\nEDLNESNX LA    R1,*+L'*+4          ELSE WHAT'S THAT\n         B     EDSTMS\n         MSG   'INVALID COMMAND',H=Y\n*- - - - CAPS / ASIS COMMANDS\nEDCAPS   NI    EDFUSW,255-EDASSW-EXTCPY SET CAPS AND RESET COPY REQ\n         B     GOBACK              RESHOW THE SCREEN\nEDASIS   NI    EDFUSW,255-EXTCPY   RESET ANY COPY REQUEST\n         OI    EDFUSW,EDASSW       SET ASIS\n         B     GOBACK              RESHOW THE SCREEN\n*- - - - WHERE PENDING ACTION COMMAND\nEDWHERE  NI    EDFUSW,255-EXTCPY   RESET ANY COPY REQUEST\n         CLI   EDPNSW,0            ANY PENDING LINE COMMAND?\n         BNE   EDWHERE1            YES\n         LA    R1,*+L'*+4          NONE\n         B     EDSTMS\n         MSG   'NONE PENDING',H=Y\nEDWHERE1 TM    EDPNSW,DLRGSW+RPRGSW\n         BZ    *+L'*+8\n         L     R3,EDTOFLOC         GET LOCATION\n         B     EDWHERE2\n         TM    EDPNSW,CPABSW+MVABSW+CPRGSW+MVRGSW+RNGESW\n         BNZ   *+L'*+8\n         L     R3,EDTABLOC         GET AFTER/BEFORE LOCATION\n         B     EDWHERE2\n         L     R3,EDTOFLOC         GET LOCATION\n         TM    EDPNSW,CPRGSW+RNGESW\n         BO    *+L'*+8\n         TM    EDPNSW,MVRGSW+RNGESW\n         BNO   EDWHERE2\n         CLC   EDTCURR,PPTR(R3)\n         BNE   EDWHERE2\n         L     R3,EDTOTLOC         GET ALTERNATE LOCATION\nEDWHERE2 ICM   R1,B'1111',PPTR(R3) POINT TO PREVIOUS\n         BZ    *+L'*+2             NONE, FIRST\n         LR    R3,R1               ELSE THIS FOR DISPLAY\n         ST    R3,EDTCURR          SET CURRENT POINTER\n         B     GOBACK              RESHOW (MESSAGE STILL SET)\n*- - - - INPUT ONE OR MORE CARDS COMMAND\nEDINPT1  LA    R3,6(R3)\n         LA    R1,6\n         B     EDINPT3\nEDINPT2  LA    R3,2(R3)\n         LA    R1,2\nEDINPT3  L     R9,=A(EDINPTX)\n         BR    R9\n*- - - - CHANGE THE NEXT OCCURRENCE OF A STRING COMMAND\nEDCHANG  NI    EDFUSW,255-EXTCPY   RESET ANY COPY REQUEST\n         TM    EDFSSW,FNDSSW       HOW FIND STRING?\n         BZ    EDCHANG1            NONE\n         TM    EDFSSW,CHGSSW       HOW CHNG STRING?\n         BO    EDRFIND1            OK, REPEAT FIND\n         MVI   EDROW,CREWFC        SET CURSOR ON CHANGE STRING\n         MVI   EDCOL,CCEWCH\n         LA    R1,*+L'*+4\n         B     EDSTMSM\n         MSG   'ENTER \"CHNG\" STRING',H=Y\nEDCHANG1 MVI   EDROW,CREWFC        SET CURSOR ON FIND STRING\n         MVI   EDCOL,CCEWFN\n         LA    R1,*+L'*+4\n         B     EDSTMSM\n         MSG   'ENTER \"FIND\" STRING',H=Y\n*- - - - FIND THE NEXT OCCURRENCE OF A STRING COMMAND\nEDRFIND  TM    EDFSSW,FNDSSW       NO FIND STRING?\n         BZ    EDCHANG1\nEDRFIND1 L     R9,=A(EDXRFND)\n         BR    R9\n*- - - - DOWN COMMAND\nEDMORMX  L     R9,=A(EDMORMEM)\n         BR    R9\n*- - - - UP COMMAND\nEDPREMX  L     R9,=A(EDPREMEM)\n         BR    R9\n*- - - - COPY COMMAND\nEDTCPY   OI    EDFUSW,EXTCPY       SAY COPY REQUESTED\n         TM    EDPNSW,AFBESW       A/B PENDING WITH COPY?\n         BZ    EDSMS7              NO, GO SET MESSAGE\nEDTCPYX  XC    MSGADD,MSGADD       YES, GO DO COPY\n         LM    R8,R9,=A(CPWKARL,EDXCPY)\n         BR    R9\n*- - - - SUBMIT COMMAND\n*              NOTE : ALL THE DATA-SET SUBMIT LOGIC GOES HERE.\nEDSUBMT  CLI   SUBRB,S99RBEND-S99RB SUBMIT AVAILABLE?\n         BNE   EDSERR              NO (NO JES2)\n         ICM   R4,B'1111',EDTFIRST PICK UP FIRST POINTER\n         BZ    EDSNON              NONE\n         LA    R1,SUBSUBP\n        DYNALLOC\n         L     R0,SUBRB+S99RSC-S99RB CHECK IF ANY ERROR\n         LTR   R15,R15\n         BNZ   EDSALL              ERROR\n         LTR   R0,R0\n         BNZ   EDSALL              ERROR\n        GENCB  BLK=ACB,AM=VSAM,MACRF=(ADR,SEQ,OUT),                    X\n               DDNAME=SUBJOB,MF=(G,ACBWORK)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    EDSUB1              OK\n         ST    R0,MESSPL           ERROR\n        XMESS  2015,R15\n         LA    R3,*+L'*+4\n         B     EDSUBZ              ALL DONE\n         MSG   'SUBMIT ACB FAILED',H=Y\nEDSUB1   ST    R1,SUBACB\n         LR    R2,R1               ACB ADDRESS\n         USING IFGACB,R2\n        GENCB  BLK=RPL,AM=VSAM,ACB=(R2),OPTCD=(ADR,SEQ,SYN,NUP),       X\n               RECLEN=80,MF=(G,RPLWORK)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    EDSUB2              OK\n         ST    R0,MESSPL           ERROR\n        XMESS  2016,R15\n         LA    R3,*+L'*+4\n         B     EDSUBZ              ALL DONE\n         MSG   'SUBMIT RPL FAILED',H=Y\nEDSUB2   ST    R1,SUBRPL\n         LR    R3,R1               RPL ADDRESS\n         USING IFGRPL,R3\n         MVI   OPCLPL,VLB          SET \"VL\" BIT\n        OPEN   ((R2)),MF=(E,OPCLPL)\n         LTR   R15,R15             GOOD OPEN?\n         BZ    EDSUB3              OK\n         XR    R0,R0               ERROR\n         IC    R0,ACBERFLG\n         ST    R0,MESSPL           ERROR\n        XMESS  2003,R15\n         LA    R3,*+L'*+4\n         B     EDSUBZ              ALL DONE\n         MSG   'SUBMIT OPEN FAILED',H=Y\n         DROP  R2\nEDSUBZ   L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R2               INITIALIZE DYNAMIC ALLOCATION WORK\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DD-NAME\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    EDSUBY              OK\n        XMESS  2022\n         B     EDSUBY\n         DROP  R2\n         USING IFGACB,R2\nEDSUB3   MVC   LCMF(L'LCMF,R4),=CL2'00'\n        MODCB  RPL=(R3),AREA=(R4),ACB=(R2),MF=(G,MODWORK)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    EDSUB4              OK\n         ST    R0,MESSPL           ERROR\n        XMESS  2017,R15\n         LA    R3,*+L'*+4\n         B     EDSUBX              ALL DONE\n         MSG   'SUBMIT MODCB FAILED',H=Y\nEDSUB4  PUT    RPL=(R3)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    EDSUB5              OK\n         MVC   MESSPL,RPLFDBWD     ERROR\n        XMESS  2018,R15\n         LA    R3,*+L'*+4\n         B     EDSUBX              ALL DONE\n         MSG   'SUBMIT PUT FAILED',H=Y\nEDSUBX   MVI   OPCLPL,VLB          SET \"VL\" BIT\n        CLOSE  ((R2)),MF=(E,OPCLPL)\nEDSUBY   LR    R1,R3\n         B     EDSTMS\nEDSUB5   XC    LCMF(L'LCMF,R4),LCMF(R4)\n         ICM   R4,B'1111',NPTR(R4)\n         BNZ   EDSUB3\n        ENDREQ RPL=(R3)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    EDSUB6              OK\n         MVC   MESSPL,RPLFDBWD     ERROR\n        XMESS  2019,R15\n         LA    R3,*+L'*+4\n         B     EDSUBX              ALL DONE\n         MSG   'SUBMIT ENDREQ FAILED',H=Y\nEDSUB6   MVC   MSGBUFF+1(8),RPLRBAR BUILD JOB (NUMBER) MESSAGE\n         LA    R1,MSGBUFF+8\n         LA    R15,8\n         CLI   0(R1),C' '\n         BNE   *+L'*+6\n         BCTR  R1,0\n         BCT   R15,*-10\n         MVC   1(10,R1),=CL10' SUBMITTED'\n         LA    R15,10(R15)\n         STC   R15,MSGBUFF         SET MESSAGE LENGTH\n         MVI   OPCLPL,VLB          SET \"VL\" BIT\n        CLOSE  ((R2)),MF=(E,OPCLPL)\n         LTR   R15,R15             GOOD CLOSE?\n         BZ    EDSOKS              OK\n         XR    R0,R0               ERROR\n         IC    R0,ACBERFLG\n         ST    R0,MESSPL           ERROR\n        XMESS  2020,R15\n         LA    R1,*+L'*+4\n         B     EDSTMS              ALL DONE\n         MSG   'SUBMIT CLOSE FAILED',H=Y\nEDSOKS   LA    R1,MSGBUFF\n         B     EDSTMS\nEDSERR   LA    R1,*+L'*+4\n         B     EDSTMS\n         MSG   'SUBMIT UNAVAILABLE',H=Y\nEDSNON   LA    R1,*+L'*+4\n         B     EDSTMS\n         MSG   'NONE TO SUBMIT',H=Y\nEDSALL   ST    R0,MESSPL\n        XMESS  2021,R15\n         LA    R1,*+L'*+4\n         B     EDSTMS\n         MSG   'SUBMIT ALLOC FAILED',H=Y\n         DROP  R2,R3\n*- - - - SAVE PROCESSING COMMAND\n*              NOTE : ALL THE DATA-SET SAVE LOGIC GOES HERE.\n*              FIRST COUNT THE NUMBER OF RECORDS IN MY EDIT WORK AREA\n*              TO DETERMINE WHETHER I CAN DO AN UPDATE-IN-PLACE.\nEDSAVE   ICM   R3,B'1111',EDTFIRST PICK UP FIRST POINTER\n         BNZ   EDSVCD              OK\n         LA    R1,*+L'*+4\n         B     EDSTMS\n         MSG   'NONE TO SAVE',H=Y\nEDSVCD   TM    EDFSSW,SVDTSW       ANY DATA CHANGED?\n         BO    EDSVDT              YES\n         MVC   MSGBUFF(13),*+L'*+4 NO\n         B     EDMSGT\n         MSG   'NONE CHANGED',H=Y\nEDSVDT   L     R1,EDTNOWL          PICK UP NUMBER OF CARDS\n         CL    R1,EDTRECS     COMPARE CURRENT RECS VERSUS ORIGINAL RECS\n         BNE   EDSUPD              NO MATCH, CAN'T DO UPDATE-IN-PLACE\n         L     R2,EDTDCB           PICK UP DCB ADDRESS\n         MVC   DCBMACR-IHADCB(L'DCBMACR,R2),=AL1(DCBMRGET+DCBMRLCG,DCBMX\n               RPUT+DCBMRMVP)      SET MACRF TO (GL,PM)\n         LA    R1,EDLEOF           SET EODAD\n         STCM  R1,B'0111',DCBEODA-IHADCB(R2)\n         LA    R1,EDPSYNA          SET SYNAD\n         STCM  R1,B'0111',DCBSYNA-IHADCB(R2)\n         NI    EDTQST,255-PTSYFLG-EODIFLG\n         MVI   OPCLPL,VLB          SET \"VL\" BIT\n        OPEN  ((R2),(UPDAT)),MF=(E,OPCLPL)\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN TEST FOR GOOD OPEN?\n         BO    EDPUT1              OK\nEDGBCK  XMESS  2002\n         LA    R1,*+L'*+4\n         B     EDSMSG              ALL DONE\n         MSG   'OPEN OUTPUT FAILED',H=Y\nEDPUT1  GET    (R2)\n         TM    EDTQST,PTSYFLG      WAS SYNAD EXIT TAKEN?\n         BO    EDREOF              YES, ERROR\n         MVC   0(L'CDTA+L'CCNU,R1),CDTA(R3)\n         MVC   LCMF(L'LCMF,R1),=CL2'00'\n        PUTX   (R2)\n         TM    EDTQST,PTSYFLG      WAS SYNAD EXIT TAKEN?\n         BO    EDREOF              YES, ERROR\n         ICM   R3,B'1111',NPTR(R3)\n         BNZ   EDPUT1\n         B     EDREOF\nEDLEOF   OI    EDTQST,EODIFLG      SET EODAD EXIT TAKEN\n         B     EDREOF\nEDSUPD   ST    R1,EDTRECS          SET CURRENT RECS\n         L     R2,EDTDCB           PICK UP DCB ADDRESS\n         LM    R0,R1,DCBDDNAM-IHADCB(R2) SAVE DD-NAME\n         MVC   0(PMVDCBL,R2),PMVDCB SET MACRF TO PUT-MOVE\n         STM   R0,R1,DCBDDNAM-IHADCB(R2) STORE DD-NAME\n         LA    R1,EDPSYNA          SET SYNAD\n         STCM  R1,B'0111',DCBSYNA-IHADCB(R2)\n         NI    EDTQST,255-PTSYFLG\n         MVI   OPCLPL,VLB          SET \"VL\" BIT\n        OPEN  ((R2),(OUTPUT)),MF=(E,OPCLPL)\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN TEST FOR GOOD OPEN?\n         BZ    EDGBCK              NO, ERROR\nEDPUT2   MVC   LCMF(L'LCMF,R3),=CL2'00'\n        PUT    (R2),(R3)\n         TM    EDTQST,PTSYFLG      WAS SYNAD EXIT TAKEN?\n         BO    EDREOF              YES, ERROR\n         XC    LCMF(L'LCMF,R3),LCMF(R3)\n         ICM   R3,B'1111',NPTR(R3)\n         BNZ   EDPUT2\nEDREOF   MVI   OPCLPL,VLB          SET \"VL\" BIT\n        CLOSE ((R2)),MF=(E,OPCLPL)\n         TM    EDTQST,PTSYFLG      WAS SYNAD EXIT TAKEN?\n         BZ    *+L'*+12            NO, BRANCH\n         NI    EDTQST,255-PTSYFLG  YES, ERROR\n         LA    R1,EDTMSG\n         B     EDSMSG              STOP HERE, GO BACK\n         TM    EDTQST,EODIFLG      WAS EODAD EXIT TAKEN?\n         BZ    *+L'*+12            NO, BRANCH\n         NI    EDTQST,255-EODIFLG  YES, ERROR\n         LA    R1,XEODMSG\n         B     EDSMSG              STOP HERE, GO BACK\n         MVI   MSGBUFF,L'EDMSAVDS+L'EDMSAVMM\n         MVC   MSGBUFF+1(L'EDMSAVDS+L'EDMSAVMM),EDMSAVDS\n         CLI   EDTMEM,C' '         MEMBER PROVIDED?\n         BE    EDMSGT              NOPE\n         CLC   EDTORG(3),=CL3'SEQ' SEQUENTIAL FILE?\n         BE    EDMSGT              YES, DON'T DO STOW\n         L     R2,ALIBDCB\n         L     R15,=A(SPFSTOW)\n*- - - - SPFSTOW PARM.LIST : DCB, REC-COUNT, USER-ID, MEMBER-NAME\n        CALL   (15),((R2),EDTRECS,USERID,EDTMEM),VL,MF=(E,PARMVL)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    EDSTWOK             OK\n        XMESS  2009,R15            ERROR\nEDSTWOK  MVI   MSGBUFF,L'EDTMEM+L'EDMSAVMM\n         MVC   MSGBUFF+1(L'EDTMEM),EDTMEM\n         MVC   MSGBUFF+L'EDTMEM+1(L'EDMSAVMM),EDMSAVMM\nEDMSGT   LA    R1,MSGBUFF\n         CLC   EDTCMND(7),=CL7'SAVEND' SAVE AND END?\n         BE    EDSMSG              ALL DONE\n         CLC   EDTCMND(3),=CL4'END' JUST END?\n         BE    EDSMSG              ALL DONE\nEDSTMS   XC    EDADDR,EDADDR       FORCE DEFAULT\nEDSTMSM  ST    R1,MSGADD\n         B     EDSHOWS             RESHOW THE SCREEN\nEDSMSG   ST    R1,MSGADD\n         L     R2,EDTMAIN          1ST DATA GETMAINED AREA\n         L     R3,EDTLENG          1ST DATA GETMAINED AREA LENGTH\nEDFREE   LM    R4,R5,0(R2)         GET NEXT IF ANY\n        FREEMAIN R,LV=(R3),A=(R2)  FREE ALL DATA GETMAINED AREAS\n         LTR   R2,R4\n         BZ    LEAVE\n         LR    R3,R5\n         B     EDFREE\nLEAVE    L     R13,4(R13)          PICK UP CALLING SAVE-AREA\n         LM    R14,R12,12(R13)     RESTORE CALLING REGISTERS\n         XR    R15,R15             SET RC=0\n         BR    R14                 RETURN\n         SPACE 1\n*------- ROUTINE TO COUNT CARDS\n*              R0 = NUMBER OF CARDS\n*              R3-R4 = WORK REGISTERS\n*              R14 = LINK REGISTER\nCNTCRDS  L     R3,EDTOFLOC         START LOCATION\n         LA    R0,1\n         LR    R4,R0\n         AR    R0,R4               COUNT CARDS UNTIL END\n         L     R3,NPTR(R3)         NEXT CARD\n         CL    R3,EDTOTLOC\n         BNE   *-10\n         BR    R14                 RETURN\n         SPACE 1\n*------- ROUTINE TO ADD CARD(S)\n*              NOTES - CARDS ARE ADDED IN CHAIN OF THE CURRENT ONE\n*                    - R14-R15-R0-R1 ARE SAVED-RESTORED\n*              R0 = NUMBER OF CARDS TO ADD\n*              R3 = CURRENT CARD POINTER (UNCHANGED)\n*              R14 = LINK REGISTER\nEDADRTN  CL    R0,EDTGASL          REQUEST CAN BE EXHAUSTED?\n         BNH   EDADRTN4            YES, OK\n         STM   R14,R6,VUSWA        NO, SAVE REGISTERS\n         L     R6,EDTGASL          DO ACTUAL TOTAL OF CARDS\n         A     R6,EDTNOWL\n         L     R4,=A($#L)          THRESHOLD LIMIT\n         CLR   R6,R4               CAN I ACCEPT MORE?\n         BL    EDADRTN1            YES\n         LA    R1,*+L'*+4          NO\n         B     EDSTMS              STOP HERE, GO BACK\n         MSG   'YUP, FILE IS FULL',H=Y\n*- - - - TRY OBTAIN MORE SPACE FOR DATA RECORDS\nEDADRTN1 S     R0,EDTGASL\n         LM    R14,R15,=A($#AN,$#AS)\n         LM    R2,R3,=A($#BN,$#BS)\n         CLR   R2,R0\n         BNL   *+L'*+8\n         AR    R2,R14\n         AR    R3,R15\n         B     *-10\n        GETMAIN RC,LV=(R3)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    EDADRTN2            OK\n        XMESS  2012,R15            ERROR\n         LA    R1,*+L'*+8\n         ST    R1,MSGADD\n         B     EDSTMS              STOP HERE, GO BACK\n         MSG   'GETMAIN(N) FAILED',H=Y\nEDADRTN2 LR    R5,R1               RETAIN ADDRESS\n         LR    R0,R5\n         LR    R1,R3\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R0,R14              CLEAR ALL TO BINARY ZEROS\n         L     R14,EDTMAIN         1ST DATA GETMAINED AREA\n         ICM   R15,B'1111',0(R14)  END OF AREAS CHAINING?\n         BZ    *+L'*+6             YES\n         LR    R14,R15             NO\n         B     *-10                LOOP TO NEXT\n         ST    R5,0(R14)           GETMAIN ADDRESS CHAIN\n         ST    R3,4(R14)           GETMAIN LENGTH\n         AR    R6,R2               DO NEW TOTAL OF CARDS\n         CLR   R6,R4               THRESHOLD, CAN I ACCEPT IT?\n         BNH   *+L'*+4             YES\n         SR    R6,R4               NO, REDUCE\n         SR    R2,R6\n         L     R1,EDTGASL\n         AR    R1,R2\n         ST    R1,EDTGASL          NEW NUMBER OF GAS CARDS\n         LA    R5,8(R5)            BUILD FREE POOL CHAIN\n         LR    R3,R5\nEDADRTN3 LA    R1,XLNG(R3)\n         BCT   R2,*+L'*+4\n         B     *+L'*+10\n         ST    R1,NPTR(R3)\n         LR    R3,R1\n         B     EDADRTN3\n         ICM   R1,B'1111',EDTPOOL  ADD TO FREE POOL CHAIN\n         BNZ   *+L'*+8             NOT HERE\n         ST    R5,EDTPOOL\n         B     *+L'*+14\n         LR    R2,R1\n         ICM   R1,B'1111',NPTR(R2) NEXT ONE\n         BNZ   *-6                 NOT HERE, LOOP\n         ST    R5,NPTR(R2)\n         LM    R14,R6,VUSWA        RESTORE REGISTERS\nEDADRTN4 STM   R14,R1,12(R13)      SAVE REGISTERS\n         L     R15,EDTGASL         UPDATE FREE COUNT\n         SR    R15,R0\n         ST    R15,EDTGASL\n         L     R15,EDTNOWL         UPDATE NUMBER OF CARDS\n         AR    R15,R0\n         ST    R15,EDTNOWL\n         L     R15,EDTPOOL         GET FREE CARDS\n         L     R1,NPTR(R3)\n         ST    R15,NPTR(R3)\n         LR    R14,R3\nEDADRTN5 ST    R14,PPTR(R15)\n         BCT   R0,*+L'*+4\n         B     EDADRTN6\n         LR    R14,R15\n         L     R15,NPTR(R15)\n         B     EDADRTN5\nEDADRTN6 MVC   EDTPOOL,NPTR(R15)   OUT OF POOL\n         ST    R1,NPTR(R15)\n         LTR   R1,R1               LAST CARD?\n         BNZ   *+L'*+8             NO\n         ST    R15,EDTLAST         YES, SET LAST POINTER\n         B     *+L'*+4\n         ST    R15,PPTR(R1)\n         OI    EDFSSW,SVDTSW       SAY DATA CHANGED\n         LM    R14,R1,12(R13)      RESTORE REGISTERS\n         BR    R14                 RETURN\n         SPACE 1\n*------- ROUTINE TO DELETE CARD(S)\n*              NOTES - DELETED CARDS ARE PLACED IN THE FREE POOL\n*                    - R14-R15-R0-R1 ARE SAVED-RESTORED\n*              R0 = NUMBER OF CARDS TO DELETE\n*              R3 = CURRENT CARD POINTER (UPDATED TO POINT ON PREVIOUS\n*                                         OR ZERO WHEN WAS FIRST ONE)\n*              R14 = LINK REGISTER\nEDDLRTN  STM   R14,R1,12(R13)      SAVE REGISTERS\n         L     R15,EDTGASL         UPDATE FREE COUNT\n         AR    R15,R0\n         ST    R15,EDTGASL\n         L     R15,EDTNOWL         UPDATE NUMBER OF CARDS\n         SR    R15,R0\n         ST    R15,EDTNOWL\n         L     R1,PPTR(R3)\n         LR    R14,R3\nEDDLRTN1 XC    CDTA(XLNG-L'NPTR,R14),CDTA(R14) CLEAR DELETED CARD\n         L     R15,NPTR(R14)\n         BCT   R0,*+L'*+4\n         B     EDDLRTN2\n         LR    R14,R15\n         B     EDDLRTN1\nEDDLRTN2 LTR   R1,R1               FIRST CARD?\n         BZ    *+L'*+8             YES\n         ST    R15,NPTR(R1)\n         B     *+L'*+4\n         ST    R15,EDTFIRST        SET FIRST POINTER\n         LTR   R15,R15             LAST CARD?\n         BZ    *+L'*+8             YES\n         ST    R1,PPTR(R15)        NO\n         B     *+L'*+4\n         ST    R1,EDTLAST          SET LAST POINTER\n         MVC   NPTR(L'NPTR,R14),EDTPOOL\n         ST    R3,EDTPOOL          ADD IT TO FREE POOL\n         LR    R3,R1               NEW CURRENT LOCATION\n         OI    EDFSSW,SVDTSW       SAY DATA CHANGED\n         OC    EDTNOWL,EDTNOWL     NUMBER OF CARDS?\n         BNZ   *+L'*+8             OK\n         LA    R1,*+L'*+10         NULL, SEND ADVICE\n         ST    R1,MSGADD\n         LM    R14,R1,12(R13)      RESTORE REGISTERS\n         BR    R14                 RETURN\n         MSG   'YUP, FILE IS EMPTY',H=Y\n         SPACE 1\n*------- ROUTINE TO RENUMBER CARDS BY 10\n*              R0-R1-R15 = WORK REGISTERS\n*              R14 = LINK REGISTER\nEDRNRTN  NI    EDFSSW,255-RNUMSW\n         ICM   R15,B'1111',EDTFIRST START LOCATION\n         BZR   R14                 NONE, RETURN\n         LA    R1,10\nEDRNRTN1 CVD   R1,EDDBLW\n         OI    EDDBLW+7,X'0F'\n         UNPK  EDTNUM(L'EDTNUM),EDDBLW+4(4)\n         MVC   CCNU(L'CCNU,R15),EDTNUM+L'EDTNUM-L'CCNU\n         LA    R1,10(R1)\n         ICM   R15,B'1111',NPTR(R15)\n         BNZ   EDRNRTN1\n         BR    R14                 RETURN\n         SPACE 1\n*------- SYNAD EXITS - ENTERED DURING THE I/O IF AN ERROR OCCURS.\n         CNOP  0,4\nEDGSYNA SYNADAF ACSMETH=QSAM\n         MVI   EDTMSG,15\n         MVC   EDTMSG+1(15),91(R1) ERROR DESCRIPTION ONLY\n         OI    EDTQST,GTSYFLG\n        SYNADRLS\n         BR    R14\n         CNOP  0,4\nEDPSYNA SYNADAF ACSMETH=QSAM\n         MVI   EDTMSG,15\n         MVC   EDTMSG+1(15),91(R1) ERROR DESCRIPTION ONLY\n         OI    EDTQST,PTSYFLG\n        SYNADRLS\n         BR    R14\n         SPACE 1\nNUMPACK  PACK  EDDBLW,EWSCF1(*-*,R3) <<EXECUTED>>\n         SPACE 1\nXCAMSG1  MSG   'DD PENDING'\nXCAMSG2  MSG   'RR PENDING'\nXCAMSG3  MSG   'CC PENDING'\nXCAMSG4  MSG   'MM PENDING'\nXCAMSG5  MSG   'C/CC/M/MM PENDING'\nXCAMSG6  MSG   'A/B PENDING'\nXCAMSG7  MSG   'A/B MISSING'\nXEODMSG  MSG   'SAVE IN-PLACE EOF'\nEDMSAVDS DC    CL7'DATASET'\nEDMSAVMM DC    CL6' SAVED'\n         SPACE 1\nPMVDCB  DCB    DSORG=PS,MACRF=PM,DDNAME=DUMMY,EODAD=*-*,SYNAD=*-*\nPMVDCBL  EQU   *-PMVDCB\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n*------- EDIT FILE SCREEN FORMAT ------------------------------------*\n*              THIS IS THE FORMAT FOR A PDS LIBRARY MEMBER OR\n*              A SEQUENTIAL FILE.\nEDTROW1  DC    AL1(EDTROW1L-1)\nDSNMNM   EQU   (*-EDTROW1)+1,54\n         DC    XL1'05',79CL1'-'\nEDTROW1L EQU   *-EDTROW1\nCREWSC   EQU   01             CURSOR ROW ON LINE BELOW (DEFAULT)\nZIED     EQU   (CREWSC+1)*4        \"TERMINPT\" DISPLACEMENT\nEDTROW2  DC    AL1(EDTROW2L-1)\n         DC    XL1'05',CL12'COMMAND ===>'\nCCEWSC   EQU   *-EDTROW2      CURSOR COLUMN ON FIELD BELOW (DEFAULT)\nEWSCF1   EQU   (*-EDTROW2)+1,46    INPUT FIELD 1\n         DC    XL1'01',CL46' '\n         DC    XL1'05',CL11'< SCROLL =>'\nEWSCF2   EQU   (*-EDTROW2)+1,4     INPUT FIELD 2\n         DC    XL1'01',CL4' ',XL1'05',CL1'<',XL1'04'\nEDTROW2L EQU   *-EDTROW2\nCREWFC   EQU   02             CURSOR ROW ON LINE BELOW (FIND/CHANGE)\nZIEF     EQU   (CREWFC+1)*4        \"TERMINPT\" DISPLACEMENT\nEDTROW3  DC    AL1(EDTROW3L-1)\n         DC    XL1'05',CL11'FIND STR =>'\nCCEWFN   EQU   *-EDTROW3      CURSOR COLUMN ON FIELD BELOW (FIND)\nEWSCF3   EQU   (*-EDTROW3)+1,24    INPUT FIELD 3\n         DC    XL1'01',CL24' '\n         DC    XL1'05',CL15'< CHANGE STR =>'\nCCEWCH   EQU   *-EDTROW3      CURSOR COLUMN ON FIELD BELOW (CHANGE)\nEWSCF4   EQU   (*-EDTROW3)+1,24    INPUT FIELD 4\n         DC    XL1'01',CL24' ',XL1'05',CL1'<'\nEDTROW3L EQU   *-EDTROW3\nEDTROW4  DC    AL1(EDTROW4L-1)\n         DC    XL1'04',CL7'    '\n         DC    CL72'----+----1----+----2----+----3----+----4----+----5-X\n               ---+----6----+----7--'\nEDTROW4L EQU   *-EDTROW4\nCREWDT   EQU   04             CURSOR ROW ON LINE BELOW (FIRST DATA)\nZIEL     EQU   (CREWDT+1)*4        \"TERMINPT\" DISPLACEMENT\nEDTLNE   DC    AL1(EDTLNEL-1)\nEWSCF5   EQU   (*-EDTLNE)+1,6      INPUT FIELD 5\n         DC    XL1'01',CL6' '\nCCEWDT   EQU   *-EDTLNE       CURSOR COLUMN ON FIELD BELOW (DATA)\nEWSCF6   EQU   (*-EDTLNE)+1,72     INPUT FIELD 6\n         DC    XL1'01',CL72' '\nEDTLNEL  EQU   *-EDTLNE\n         SPACE 1\n*- - - - R12-R11 BASE REGISTERS HIGH LIMIT - - - - - - - - - - - <===*\n         EJECT\n*------- EXECUTE ALL DELETE, REPEAT AND/OR INSERT PROCESS\n         DS    0H\n         USING *,R9\nEDDRIX   ICM   R3,B'1111',EDTFIRST FIRST POINTER\n         BZ    EDLNXQ              NONE\nEDDRIX1  CLC   LCMF(L'LCMF,R3),=CL2'D' DELETE?\n         BNE   EDDRIX2             NO\n         XC    EDADDR,EDADDR       YES, FORCE DEFAULT\n         LA    R0,1                DELETE ONE CARD\n         BAL   R14,EDDLRTN\n         LTR   R3,R3               HOW IS UPDATED POINTER?\n         BNZ   EDDRIX5             OK\n         ICM   R3,B'1111',EDTFIRST ELSE HOW WITH FIRST?\n         BZ    *+L'*+12            FILE IS EMPTY\n         ST    R3,EDTCURR          OK, UPDATE CURRENT POINTER\n         OI    EDFSSW,RNUMSW       FORCE RENUM\n         B     EDDRIX1             AND THIS IS ALSO THE NEXT\n         ST    R3,EDTCURR          UPDATE CURRENT POINTER\n         B     EDLNXQ              NO MORE\nEDDRIX2  CLC   LCMF(L'LCMF,R3),=CL2'R' REPEAT?\n         BNE   EDDRIX3             NO\n         LA    R0,1                YES, REPEAT ONE CARD\n         BAL   R14,EDADRTN\n         L     R15,NPTR(R3)\n         MVC   CDTA(L'CDTA,R15),CDTA(R3)\n         XC    LCMF(L'LCMF,R3),LCMF(R3)\n         B     EDDRIX4\nEDDRIX3  CLC   LCMF(L'LCMF,R3),=CL2'I' INSERT?\n         BNE   EDDRIX6             NO\n         LA    R0,1                YES, ADD ONE CARD\n         BAL   R14,EDADRTN\n         XC    LCMF(L'LCMF,R3),LCMF(R3)\n         L     R15,NPTR(R3)\n         MVI   CDTA(R15),C' '\n         MVC   CDTA+1(L'CDTA-1,R15),CDTA(R15)\nEDDRIX4  MVI   EDROW,CREWDT+1      CURSOR ON ADDED LINE\n         MVI   EDCOL,CCEWDT        CURSOR ON DATA FIELD\n         LTR   R3,R3               HOW IS UPDATED POINTER?\n         BNZ   EDDRIX5             OK\n         L     R3,EDTFIRST         ELSE SET FIRST POINTER\nEDDRIX5  ST    R3,EDTCURR          UPDATE CURRENT POINTER\n         OI    EDFSSW,RNUMSW       FORCE RENUM\nEDDRIX6  ICM   R3,B'1111',NPTR(R3) BUMP, LAST CARD?\n         BNZ   EDDRIX1             NO, CONTINUE\n         B     EDLNXQ\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R9\n         SPACE 1\n*------- COPY ONE CARD AFTER/BEFORE ANOTHER PROCESS\n         DS    0H\n         USING *,R9\nEDCABX   L     R3,EDTABLOC         GET AFTER/BEFORE LOCATION\n         LA    R0,1                ADD ONE CARD\n         BAL   R14,EDADRTN\n         L     R15,NPTR(R3)\n         CLC   LCMF(L'LCMF,R3),=CL2'A' COPY WHERE?\n         BE    *+L'*+12            BRANCH IF AFTER\n         MVC   CDTA(L'CDTA,R15),CDTA(R3)\n         LR    R4,R3\n         B     *+L'*+2\n         LR    R4,R15\n         XC    LCMF(L'LCMF,R3),LCMF(R3)\n         L     R5,EDTOFLOC         GET COPY LOCATION\n         XC    LCMF(L'LCMF,R5),LCMF(R5)\n         MVC   CDTA(L'CDTA,R4),CDTA(R5) MOVE IN REPEATED CARD\n         ICM   R3,B'1111',PPTR(R4) HOW IS UPDATED POINTER?\n         BNZ   *+L'*+4             OK\n         L     R3,EDTFIRST         ELSE SET FIRST POINTER\n         ST    R3,EDTCURR          UPDATE CURRENT POINTER\n         XC    EDADDR,EDADDR       FORCE DEFAULT\n         NI    EDPNSW,255-AFBESW-CPABSW\n         XC    EDTABLOC,EDTABLOC\n         XC    EDTOFLOC,EDTOFLOC\n         B     FORCERN\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R9\n         SPACE 1\n*------- COPY A GROUP OF CARDS AFTER/BEFORE ANOTHER PROCESS\n         DS    0H\n         USING *,R9\nEDCGABX  BAL   R14,CNTCRDS         GO COUNT CARDS TO COPY\n         L     R3,EDTABLOC         GET AFTER/BEFORE LOCATION\n         BAL   R14,EDADRTN         ADD CARDS\n         CLC   LCMF(L'LCMF,R3),=CL2'B' COPY WHERE?\n         BE    *+L'*+10            BRANCH IF BEFORE\n         XC    LCMF(L'LCMF,R3),LCMF(R3) ELSE IT IS AFTER\n         B     EDCGABX1\n         LR    R14,R0              SET BEFORE TO LOOK LIKE AFTER\n         LR    R15,R3\n         L     R15,NPTR(R15)\n         BCT   R14,*-4\n         XC    LCMF(L'LCMF,R15),LCMF(R15)\n         MVC   CDTA(L'CDTA,R15),CDTA(R3) MOVE IN BEFORE CARD\n         XC    LCMF(L'LCMF,R3),LCMF(R3)\n         LR    R5,R3\n         ICM   R3,B'1111',PPTR(R3) AND POINT TO PREVIOUS CARD\n         BNZ   EDCGABX1            BRANCH IF NOT FIRST CARD\n         LR    R3,R5\n         B     EDCGABX1+L'EDCGABX1\nEDCGABX1 L     R5,NPTR(R3)\n         L     R4,EDTOFLOC\n         XC    LCMF(L'LCMF,R4),LCMF(R4)\nEDCGABX2 XC    LCMF(L'LCMF,R5),LCMF(R5)\n         MVC   CDTA(L'CDTA,R5),CDTA(R4) MOVE IN REPEATED CARD\n         CLR   R4,R3\n         BNE   *+L'*+8\n         L     R4,NPTR(R4)\n         BCT   R0,*-4\n         CL    R4,EDTOTLOC\n         BE    EDCGABX3\n         L     R4,NPTR(R4)         BUMP TO NEXTS\n         L     R5,NPTR(R5)\n         B     EDCGABX2\nEDCGABX3 XC    LCMF(L'LCMF,R4),LCMF(R4)\n         ST    R3,EDTCURR          UPDATE CURRENT POINTER\n         XC    EDADDR,EDADDR       FORCE DEFAULT\n         NI    EDPNSW,255-AFBESW-CPRGSW-RNGESW\n         XC    EDTABLOC,EDTABLOC\n         XC    EDTOFLOC,EDTOFLOC\n         XC    EDTOTLOC,EDTOTLOC\n         B     FORCERN\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R9\n         SPACE 1\n*------- MOVE ONE CARD AFTER/BEFORE ANOTHER\n         DS    0H\n         USING *,R9\nEDMABX   L     R3,EDTOFLOC         GET MOVE LOCATION\n         L     R6,EDTABLOC         GET AFTER/BEFORE LOCATION\n         CLC   LCMF(L'LCMF,R6),=CL2'A' MOVE WHERE?\n         BNE   EDMABX1             BRANCH IF BEFORE\n         LM    R4,R5,PPTR(R3)\n         L     R7,NPTR(R6)\n         ICM   R0,B'1111',PPTR(R6) GET PREVIOUS POINTER OF AFTER\n         BNZ   *+L'*+2             OK\n         LR    R0,R6               ELSE SET AFTER POINTER\n         CLR   R3,R7               WHERE MUST WE MOVE?\n         BE    EDMABX3             IN PLACE, NONE TO DO\n         ST    R6,PPTR(R3)\n         ST    R3,NPTR(R6)\n         ST    R7,NPTR(R3)\n         LTR   R7,R7\n         BNZ   *+L'*+8\n         ST    R3,EDTLAST\n         B     EDMABX2\n         ST    R3,PPTR(R7)\n         B     EDMABX2\nEDMABX1  LM    R4,R5,PPTR(R3)\n         L     R7,PPTR(R6)\n         LTR   R0,R7               SET PREVIOUS POINTER OF MOVE\n         BNZ   *+L'*+2             OK\n         LR    R0,R3               ELSE SET MOVE POINTER\n         CLR   R3,R7               WHERE MUST WE MOVE?\n         BE    EDMABX3             IN PLACE, NONE TO DO\n         ST    R6,NPTR(R3)\n         ST    R3,PPTR(R6)\n         ST    R7,PPTR(R3)\n         LTR   R7,R7\n         BNZ   *+L'*+8\n         ST    R3,EDTFIRST\n         B     EDMABX2\n         ST    R3,NPTR(R7)\nEDMABX2  LTR   R5,R5\n         BNZ   *+L'*+8\n         ST    R4,EDTLAST\n         B     *+L'*+4\n         ST    R4,PPTR(R5)\n         LTR   R4,R4\n         BNZ   *+L'*+8\n         ST    R5,EDTFIRST\n         B     *+L'*+4\n         ST    R5,NPTR(R4)\n         OI    EDFSSW,SVDTSW       SAY DATA CHANGED\nEDMABX3  XC    LCMF(L'LCMF,R3),LCMF(R3)\n         XC    LCMF(L'LCMF,R6),LCMF(R6)\n         ST    R0,EDTCURR          UPDATE CURRENT POINTER\n         XC    EDADDR,EDADDR       FORCE DEFAULT\n         NI    EDPNSW,255-AFBESW-MVABSW\n         XC    EDTABLOC,EDTABLOC\n         XC    EDTOFLOC,EDTOFLOC\n         B     FORCERN\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R9\n         SPACE 1\n*------- MOVE A GROUP OF CARDS AFTER/BEFORE ANOTHER\n         DS    0H\n         USING *,R9\nEDMGABX  L     R3,EDTOFLOC         GET MOVE START LOCATION\n         L     R5,EDTOTLOC         GET MOVE END LOCATION\n         L     R7,EDTABLOC         GET AFTER/BEFORE LOCATION\n         CLC   LCMF(L'LCMF,R7),=CL2'A' MOVE WHERE?\n         BNE   EDMGABX1            BRANCH IF BEFORE\n         L     R4,PPTR(R3)\n         L     R6,NPTR(R5)\n         L     R8,NPTR(R7)\n         CLR   R3,R8               WHERE MUST WE MOVE?\n         BNE   *+L'*+6\n         LR    R0,R7               IN PLACE, NONE TO DO\n         B     EDMGABX2\n         LR    R14,R3\n         L     R14,NPTR(R14)\n         CLR   R14,R5\n         BE    *+L'*+12\n         CLR   R14,R7              WHERE IS THE TARGET OF MOVE?\n         BNE   *-12\n         LR    R0,R3               INTO THE RANGE, NONE TO DO\n         B     EDMGABX2\n         ST    R7,PPTR(R3)\n         ST    R3,NPTR(R7)\n         ST    R8,NPTR(R5)\n         LTR   R8,R8\n         BNZ   *+L'*+8\n         ST    R5,EDTLAST\n         B     *+L'*+4\n         ST    R5,PPTR(R8)\n         LTR   R6,R6\n         BNZ   *+L'*+8\n         ST    R4,EDTLAST\n         B     *+L'*+4\n         ST    R4,PPTR(R6)\n         LTR   R4,R4\n         BNZ   *+L'*+8\n         ST    R6,EDTFIRST\n         B     *+L'*+4\n         ST    R6,NPTR(R4)\n         ICM   R0,B'1111',PPTR(R7) GET PREVIOUS POINTER OF AFTER\n         BNZ   *+L'*+2             OK\n         LR    R0,R7               ELSE SET AFTER POINTER\n         OI    EDFSSW,SVDTSW       SAY DATA CHANGED\n         B     EDMGABX2\nEDMGABX1 L     R4,PPTR(R3)\n         L     R6,NPTR(R5)\n         L     R8,PPTR(R7)\n         CLR   R5,R8               WHERE MUST WE MOVE?\n         BNE   *+L'*+6\n         LR    R0,R3               IN PLACE, NONE TO DO\n         B     EDMGABX2\n         LR    R14,R3\n         L     R14,NPTR(R14)\n         CLR   R14,R5\n         BE    *+L'*+12\n         CLR   R14,R7              WHERE IS THE TARGET OF MOVE?\n         BNE   *-12\n         LR    R0,R3               INTO THE RANGE, NONE TO DO\n         B     EDMGABX2\n         ST    R8,PPTR(R3)\n         ST    R5,PPTR(R7)\n         ST    R7,NPTR(R5)\n         LTR   R8,R8\n         BNZ   *+L'*+8\n         ST    R3,EDTFIRST\n         B     *+L'*+4\n         ST    R3,NPTR(R8)\n         LTR   R6,R6\n         BNZ   *+L'*+8\n         ST    R4,EDTLAST\n         B     *+L'*+4\n         ST    R4,PPTR(R6)\n         LTR   R4,R4\n         BNZ   *+L'*+8\n         ST    R6,EDTFIRST\n         B     *+L'*+4\n         ST    R6,NPTR(R4)\n         ICM   R0,B'1111',PPTR(R3) GET PREVIOUS POINTER OF MOVE\n         BNZ   *+L'*+2             OK\n         LR    R0,R3               ELSE SET MOVE POINTER\n         OI    EDFSSW,SVDTSW       SAY DATA CHANGED\nEDMGABX2 XC    LCMF(L'LCMF,R3),LCMF(R3)\n         XC    LCMF(L'LCMF,R5),LCMF(R5)\n         XC    LCMF(L'LCMF,R7),LCMF(R7)\n         ST    R0,EDTCURR          UPDATE CURRENT POINTER\n         XC    EDADDR,EDADDR       FORCE DEFAULT\n         NI    EDPNSW,255-AFBESW-MVRGSW-RNGESW\n         XC    EDTABLOC,EDTABLOC\n         XC    EDTOFLOC,EDTOFLOC\n         XC    EDTOTLOC,EDTOTLOC\n         B     FORCERN\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R9\n         SPACE 1\n*------- DELETE A GROUP OF CARDS\n         DS    0H\n         USING *,R9\nEDDLG    BAL   R14,CNTCRDS         GO COUNT CARDS TO DELETE\n         L     R3,EDTOFLOC         GET START LOCATION\n         BAL   R14,EDDLRTN         DELETE CARDS\n         LTR   R3,R3               HOW IS UPDATED POINTER?\n         BNZ   *+L'*+4             OK\n         L     R3,EDTFIRST         ELSE SET FIRST POINTER\n         ST    R3,EDTCURR          UPDATE CURRENT POINTER\n         XC    EDADDR,EDADDR       FORCE DEFAULT\n         NI    EDPNSW,255-DLRGSW-RNGESW\n         XC    EDTOFLOC,EDTOFLOC\n         XC    EDTOTLOC,EDTOTLOC\n         B     FORCERN\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R9\n         SPACE 1\n*------- REPEAT A GROUP OF CARDS\n         DS    0H\n         USING *,R9\nEDRPG    BAL   R14,CNTCRDS         GO COUNT CARDS TO REPEAT\n         L     R3,EDTOTLOC         GET END LOCATION\n         BAL   R14,EDADRTN         ADD CARDS\n         L     R4,EDTOFLOC         GET START LOCATION\n         L     R5,NPTR(R3)         GET INITIAL COPY LOCATION\nEDRPG1   XC    LCMF(L'LCMF,R4),LCMF(R4)\n         XC    LCMF(L'LCMF,R5),LCMF(R5)\n         MVC   CDTA(L'CDTA,R5),CDTA(R4) MOVE IN REPEATED CARD\n         CLR   R4,R3\n         BE    *+L'*+12\n         L     R4,NPTR(R4)         BUMP TO NEXTS\n         L     R5,NPTR(R5)\n         B     EDRPG1\n         ST    R3,EDTCURR          UPDATE CURRENT POINTER\n         XC    EDADDR,EDADDR       FORCE DEFAULT\n         NI    EDPNSW,255-RPRGSW-RNGESW\n         XC    EDTOFLOC,EDTOFLOC\n         XC    EDTOTLOC,EDTOTLOC\n         B     FORCERN\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R9\n         SPACE 1\n*------- INPUT ONE OR MORE CARDS COMMAND\n         DS    0H\n         USING *,R9\nEDINPTX  BCTR  R0,0\n         BCT   R1,*-2\n         CLI   EWSCF1(R3),C' '\n         BNE   *+L'*+8\n         BCT   R0,*-8\n         B     EDINPTDF            JUST SET DEFAULT\n         CLI   EWSCF1(R3),C'0'     IF NOT NUMERIC?\n         BL    EDINPTDF            JUST SET DEFAULT\n         LR    R14,R3\n         LA    R15,6               MAXIMUM LENGTH\n         CLR   R15,R0\n         BNH   *+L'*+2\n         LR    R15,R0\n         XR    R1,R1               COUNTER\n         CLI   EWSCF1(R14),C'0'    IF NOT NUMERIC\n         BL    *+L'*+12\n         LA    R1,1(,R1)           BUMP COUNTER\n         LA    R14,1(,R14)         BUMP POINTER\n         BCT   R15,*-16\n         LTR   R1,R1               IF LENGTH IS ZERO\n         BZ    EDINPTDF            JUST SET DEFAULT\n         BCTR  R1,0                SUBTRACT 1 FOR EXECUTED PACK\n         EX    R1,NUMPACK          PACK IT IN EDDLBW\n         CVB   R0,EDDBLW           PUT VALUE IN R0\n         CH    R0,EDSCROLL         OVER MAXIMUM ALLOWED?\n         BNH   EDINPTXQ            NO\nEDINPTDF LH    R0,EDSCROLL         BUMP THE SCREEN\n         TM    EDFUSW,EDHLSW       HALF PAGE\n         BZ    EDINPTXQ            NO\n         SRL   R0,1                YES\nEDINPTXQ ST    R0,EDTNOWL          UPDATE BY REQUEST\n         L     R3,EDTGASL          REDUCE BY REQUEST\n         SR    R3,R0\n         ST    R3,EDTGASL\n         L     R3,EDTPOOL          GET FIRST FREE CARD\n         ST    R3,EDTFIRST         SET FIRST POINTER\n         ST    R3,EDTCURR          SET CURRENT POINTER\nEDINPTXL MVI   CDTA(R3),C' '\n         MVC   CDTA+1(L'CDTA-1,R3),CDTA(R3)\n         LR    R4,R3\n         L     R3,NPTR(R3)         BUMP TO NEXT\n         BCT   R0,*+L'*+4\n         B     *+L'*+8\n         ST    R4,PPTR(R3)\n         B     EDINPTXL\n         ST    R0,NPTR(R4)\n         ST    R4,EDTLAST          SET LAST POINTER\n         ST    R3,EDTPOOL          SET NEW FIRST IN POOL\n         ST    R0,EDTFCCP          RESET F/C CURRENT POINTER\n         STH   R0,EDTFOFF          RESET OFFSET\n         OI    EDFSSW,SVDTSW       SAY DATA CHANGED\n         BAL   R14,EDRNRTN         RENUMBER\n         MVI   EDROW,CREWDT        SET CURSOR ON FISRT LINE ADDED\n         MVI   EDCOL,CCEWDT\n         B     EDSHOWS             RE-DISPLAY\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R9\n         SPACE 1\n*------- FIND THE NEXT OCCURRENCE OF A STRING COMMAND AND CHANGE\n*        THE NEXT OCCURRENCE OF A STRING COMMAND PROCESSES\n         DS    0H\n         USING *,R9\nEDXRFND  XR    R14,R14             CLEAR THE REGISTER\n         IC    R14,EDFINDL         SET LENGTH FOR EXECUTED CLC\n         MVI   FNDWA,C' '          PREPARE COMPARE STRING\n         MVC   FNDWA+1(L'FNDWA-1),FNDWA\n         MVI   CRDWA,C' '\n         TM    EDFUSW,EDASSW       ASIS?\n         BO    *+L'*+16            YES\n         TM    EDFSSW,EDDTSW       NO, ASIS DATA?\n         BO    *+L'*+12            NO\n         EX    R14,CPYFSTR         YES ,COPY\n         B     *+L'*+4\n         EX    R14,CUCFSTR         COPY AND UPPERCASE\n         ICM   R1,B'1111',EDTCURR  PICK UP CURRENT POINTER\n         BZ    EDRFCBGN            NONE\n         CL    R1,EDTFCCP          CONTINUE ON SAME CARD?\n         BNE   EDRFCNEW            NO\n         LR    R15,R1              YES, COPY START OF CARD\n         CLI   EDTCMND,C'C'        CHANGE?\n         BE    EDRCHANG            YES\n         LA    R0,CCNU-1           NO, START ONE COLUMN FORWARD\n         SH    R0,EDTFOFF\n         SR    R0,R14              SET R0 TO MAXIMUM CARD LOOP\n         BNP   EDRFNEXT            BUT IF NO MORE, START WITH NEXT\n         AH    R1,EDTFOFF\n         LA    R1,1(,R1)           BUMP 1 BYTE\n         B     EDRFCTST\nEDRCHANG LA    R0,CCNU             START ON SAME COLUMN JUST BECAUSE\n         SH    R0,EDTFOFF            A PREVIOUS FIND MAY HAVE DONE\n         SR    R0,R14              SET R0 TO MAXIMUM CARD LOOP\n         BNP   EDRFNEXT            BUT IF NO MORE, START WITH NEXT\n         AH    R1,EDTFOFF\n         B     EDRFCTST\nEDRFCNEW CL    R1,EDTLAST          ALL DONE?\n         BNE   EDXRFND1            NO\nEDRFCBGN L     R1,EDTFIRST         ALL DONE (LOOP TO BEGINNING) OR NONE\nEDXRFND1 LTR   R15,R1              COPY START OF CARD\n         BZ    EDRFNOTF            IF PAST END OF FILE? ALL DONE\n         LA    R0,CCNU\n         SR    R0,R14              SET R0 TO MAXIMUM CARD LOOP\nEDRFCTST TM    EDFUSW,EDASSW       ASIS?\n         BO    EDRFCHKD            YES\n         TM    EDFSSW,EDDTSW       NO, ASIS DATA?\n         BZ    EDRFLOOP            NO\nEDRFCHKD MVC   CRDWA+1(L'FNDWA),CRDWA\n         EX    R14,UPPERDT         SET DATA\n         EX    R14,FINDCLC         COMPARE DATA TO STRING\n         BE    EDXRFND2            GOT IT\n         LA    R1,1(,R1)           BUMP 1 BYTE\n         BCT   R0,EDRFCHKD         KEEP LOOPING\n         B     EDRFNEXT\nEDRFLOOP EX    R14,FNDCLC          SEARCH FOR THE STRING\n         BE    EDXRFND2            GOT IT\n         LA    R1,1(,R1)           BUMP 1 BYTE\n         BCT   R0,EDRFLOOP         KEEP LOOPING\nEDRFNEXT L     R1,NPTR(R15)        BUMP TO NEXT CARD\n         B     EDXRFND1            ALL DONE\nEDXRFND2 CLI   EDTCMND,C'C'        CHANGE?\n         BNE   EDXRFND3            NO, JUST FIND\n         CLC   EDCHNGL(1),EDFINDL  STRINGS ARE SAME LENGTH?\n         BL    EDCHSH              NO, CHANGE IS SHORT\n         BH    EDCHLG              NO, CHANGE IS LONG\n         EX    R14,CHGMVC          YES, JUST REPLACE THE STRING\n         B     EDCHEND\nEDCHSH   XR    R2,R2\n         IC    R2,EDCHNGL          GET LENGTH FOR EXECUTED MVC\n         EX    R2,CHGMVC           REPLACE THE STRING\n         LA    R2,1(R2,R1)         NOW SHIFT LEFT IF NEEDED\n         LA    R3,1(R14,R1)\n         LA    R0,CCNU-1(R15)\n         NI    EDTQST,255-QSTRSW-NQSTSW\nEDCHSH1  TM    EDTQST,QSTRSW\n         BO    *+L'*+8\n         CLI   0(R3),C' '\n         BE    EDCHSH2\n         CLI   0(R3),C''''\n         BNE   *+L'*+4\n         XI    EDTQST,QSTRSW\n         MVC   0(1,R2),0(R3)\n         LA    R2,1(R2)\n         LA    R3,1(R3)\n         CLR   R3,R0\n         BL    EDCHSH1\nEDCHSH2  MVI   0(R2),C' '\n         LA    R2,1(R2)\n         CLR   R2,R3\n         BL    EDCHSH2\n         B     EDCHEND\nEDCHLG   MVI   CRDWA,C' '\n         MVC   CRDWA+1(L'CRDWA-1),CRDWA\n         LA    R3,CRDWA\n         LR    R2,R1\n         SR    R2,R15\n         BNP   *+L'*+2\n         AR    R3,R2               SKIP UNCHANGED STARTING PORTION\n         LR    R5,R3               RETAIN THIS ADDRESS\n         XR    R2,R2\n         IC    R2,EDCHNGL          GET LENGTH FOR EXECUTED MVC\n         EX    R2,MVCCHG           MOVE THE CHANGE STRING\n         LA    R3,1(R2,R3)         NOW TRY TO COMPLETE CARD\n         LA    R2,1(R1,R14)\n         LA    R0,CRDWA+CCNU\n         LA    R14,CRDWA\n         NI    EDTQST,255-QSTRSW-NQSTSW\nEDCHLG1  TM    EDTQST,QSTRSW\n         BO    *+L'*+8\n         CLI   0(R2),C' '\n         BE    EDCHLG3\n         TM    EDTQST,NQSTSW\n         BO    EDCHLG2\n         CLI   0(R2),C''''\n         BNE   EDCHLG2\n         XI    EDTQST,QSTRSW\nEDCHLG2  MVC   0(1,R3),0(R2)\n         LA    R2,1(R2)\n         LA    R3,1(R3)\n         CLR   R3,R0\n         BL    EDCHLG1\n         B     EDCHERR\nEDCHLG3  MVI   0(R3),C' '\n         OI    EDTQST,NQSTSW\n         LR    R4,R3\n         SR    R4,R14\n         AR    R4,R15\nEDCHLG4  LA    R2,1(R2)\n         CLR   R2,R4\n         BH    EDCHLG5\n         CLI   0(R2),C' '\n         BE    EDCHLG4\n         LA    R3,1(R3)\n         CLR   R3,R0\n         BL    EDCHLG2\nEDCHERR  MVC   MSGBUFF(9),=CL9' AT COL. '\n         MVI   MSGBUFF,17\n         SR    R1,R15              COMPUTE COLUMN NUMBER\n         LA    R0,1(R1)\n         CVD   R0,EDDBLW\n         OI    EDDBLW+7,X'0F'\n         UNPK  MSGBUFF+9(3),EDDBLW+6(2)\n         MVC   MSGBUFF+12(6),=CL6' DO IT'\n         B     EDXRFND4\nEDCHLG5  LR    R4,R3\n         SR    R4,R5\n         BCT   R4,*+L'*+6\n         MVC   0(*-*,R1),0(R5)     <<EXECUTED>>\n         EX    R4,*-6              MOVE NEW PART IN CARD\nEDCHEND  OI    EDFSSW,SVDTSW       SAY DATA CHANGED\n         MVI   MSGBUFF,19\n         MVC   MSGBUFF+1(7),=CL7'CHANGED'\n         MVC   MSGBUFF+8(9),=CL9' AT COL. '\n         SR    R1,R15              COMPUTE COLUMN NUMBER\n         LA    R0,1(R1)\n         CVD   R0,EDDBLW\n         OI    EDDBLW+7,X'0F'\n         UNPK  MSGBUFF+17(3),EDDBLW+6(2)\n         B     EDXRFND4\nCPYFSTR  MVC   FNDWA(*-*),EDFINDS  <<EXECUTED>>\nCUCFSTR  OC    FNDWA(*-*),EDFINDS  <<EXECUTED>>\nUPPERDT  OC    CRDWA+1(*-*),0(R1)  <<EXECUTED>>\nFINDCLC  CLC   CRDWA+1(*-*),FNDWA  <<EXECUTED>>\nFNDCLC   CLC   EDFINDS(*-*),0(R1)  <<EXECUTED>>\nCHGMVC   MVC   0(*-*,R1),EDCHNGS   <<EXECUTED>>\nMVCCHG   MVC   0(*-*,R3),EDCHNGS   <<EXECUTED>>\nEDXRFND3 MVI   MSGBUFF,17\n         MVC   MSGBUFF+1(5),=CL5'FOUND'\n         MVC   MSGBUFF+6(9),=CL9' AT COL. '\n         SR    R1,R15              COMPUTE COLUMN NUMBER\n         LA    R0,1(R1)\n         CVD   R0,EDDBLW\n         OI    EDDBLW+7,X'0F'\n         UNPK  MSGBUFF+15(3),EDDBLW+6(2)\nEDXRFND4 ST    R15,EDTCURR         SET CURRENT POINTER\n         ST    R15,EDTFCCP         SET F/C CURRENT POINTER\n         STH   R1,EDTFOFF          SET OFFSET\n         MVI   EDROW,CREWDT        SET CURSOR AT START OF STRING\n         LA    R1,CCEWDT(R1)\n         STC   R1,EDCOL\n         LA    R1,MSGBUFF          FOUND\n         B     EDSTMSM\nEDRFNOTF MVC   EDTCURR,EDTLAST     NOT FOUND, CURRENT POINTER TO LAST\n         XR    R0,R0\n         ST    R0,EDTFCCP          RESET F/C CURRENT POINTER\n         STH   R0,EDTFOFF          RESET OFFSET\n         LA    R1,*+L'*+4\n         B     EDSTMS\n         MSG   'STRING NOT FOUND'\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R9\n         SPACE 1\n*------- DOWN COMMAND\n         DS    0H\n         USING *,R9\nEDMORMEM CLI   0(R3),0             WAS THIS LINE CHANGED BY OPERATOR?\n         BE    EDMORMDF            NO, JUST BUMP DEFAULT\n         TM    EWSCF1-1(R3),INFMOD COMMAND ENTERED?\n         BZ    EDMORMDF            NO, JUST BUMP DEFAULT\n         LA    R0,L'EWSCF1-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   EWSCF1(R3),C' '\n         BNE   *+L'*+14\n         MVC   EWSCF1(L'EWSCF1-1,R3),EWSCF1+1(R3)\n         MVI   EWSCF1+L'EWSCF1-1(R3),C' '\n         BCT   R0,*-18\n         CLI   EWSCF1(R3),C' '     COMMAND ENTERED?\n         BE    EDMORMDF            NO, JUST BUMP DEFAULT\n         L     R2,TERMINPT         PICK UP AID/ROW/COL ADDRESS\n         CLI   0(R2),X'F8'         IS IT PF8?\n         BE    EDMORMSC            YES\n         CLI   0(R2),X'C8'         IS IT PF20?\n         BE    EDMORMSC            NO\n         MVC   EDDBLW(7),=CL8' '\n         OC    EDDBLW(7),EWSCF1(R3)\n         CLC   EDDBLW(5),=CL7'DOWN' IS IT \"DOWN\"?\n         BNE   *+L'*+12            NO\n         LA    R3,5(R3)            YES, SEE FORWARD\n         SH    R0,=H'5'\n         B     *+L'*+28\n         CLC   EDDBLW(2),=CL2'D'   IS IT \"DOWN\"?\n         BE    *+L'*+10            YES\n         CLC   EDDBLW(2),=CL2'+'   IS IT \"DOWN\"?\n         BNE   EDLNESNX            NO, INVALID COMMAND\n         LA    R3,2(R3)            YES, SEE FORWARD\n         SH    R0,=H'2'\n         BNP   EDPREMDF            NO MORE, JUST BUMP DEFAULT\n         CLI   EWSCF1(R3),C' '\n         BNE   EDMORMSC\n         LA    R3,1(R3)\n         BCT   R0,*-12\n         B     EDMORMDF            NONE, JUST BUMP DEFAULT\nEDMORMSC MVI   EDDBLW,C' '\n         OC    EDDBLW(1),EWSCF1(R3)\n         CLI   EDDBLW,C'M'         SCROLL \"MAX\"?\n         BE    EDMORMAX            GO TO BOTTOM\n         CLI   EWSCF1(R3),C'0'     IF NOT NUMERIC?\n         BL    EDMORMDF            JUST BUMP DEFAULT\n         LA    R14,EWSCF1(,R3)     SET START OF FIELD\n         LA    R15,6               MAXIMUM LENGTH\n         CLR   R15,R0\n         BNL   *+L'*+2\n         LR    R15,R0\n         XR    R1,R1               COUNTER\n         CLI   0(R14),C'0'         IF NOT NUMERIC\n         BL    *+L'*+12\n         LA    R1,1(,R1)           BUMP COUNTER\n         LA    R14,1(,R14)         BUMP POINTER\n         BCT   R15,*-16\n         LTR   R1,R1               IF LENGTH IS ZERO\n         BZ    EDMORMDF            JUST BUMP DEFAULT\n         BCTR  R1,0                SUBTRACT 1 FOR EXECUTED PACK\n         EX    R1,NUMPACK          PACK IT IN EDDLBW\n         CVB   R0,EDDBLW           PUT VALUE IN R0\n         B     EDMORXEQ\nEDMORMDF LH    R0,EDSCROLL         BUMP THE SCREEN\n         TM    EDFUSW,EDCRSW       CURSOR?\n         BZ    EDMORHLF            NO\n         L     R14,TERMINPT        PICK UP AID/ROW/COL ADDRESS\n         XR    R15,R15\n         IC    R15,1(R14)          GET ROW NUMBER\n         SH    R15,=Y(CREWDT)\n         BNP   EDMORXEQ\n         LR    R0,R15\n         B     EDMORXEQ\nEDMORHLF TM    EDFUSW,EDHLSW       HALF PAGE?\n         BZ    EDMORXEQ            NO\n         SRL   R0,1                YES\nEDMORXEQ LTR   R0,R0\n         BNP   EDMOREX             GO BACK\n         ICM   R1,B'1111',EDTCURR\n         BZ    EDMORMAX            GO TO BOTTOM\n         ICM   R1,B'1111',NPTR(R1)\n         BZ    EDMORMAX            GO TO BOTTOM\n         BCT   R0,*-8\n         ST    R1,EDTCURR          SET CURRENT POINTER\n         B     EDMOREX             GO BACK\nEDMORMAX ICM   R1,B'1111',EDTLAST  BUMP SCREEN TO BOTTOM\n         BZ    EDMORSET            NONE\n         LH    R0,EDSCROLL         AND THEN BACK UP\n         TM    EDFUSW,EDHLSW       HALF PAGE\n         BZ    *+L'*+4             NO\n         SRL   R0,1                YES\n         BCT   R0,*+L'*+4          (-1 = BOTTOM MARKER)\n         B     EDMORSET\n         BCT   R0,*+L'*+4\n         B     EDMORSET\n         ICM   R1,B'1111',PPTR(R1)\n         BNZ   *-12\n         L     R1,EDTFIRST         HERE WE ARE AT TOP\nEDMORSET ST    R1,EDTCURR\nEDMOREX  TM    EDFUSW,EXTCPY       COPY PENDING?\n         BZ    GOBACK              NO, RE-DISPLAY\n         B     EDSMS7              ELSE SET MESSAGE\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R9\n         SPACE 1\n*------- UP COMMAND\n         DS    0H\n         USING *,R9\nEDPREMEM CLI   0(R3),0             WAS THIS LINE CHANGED BY OPERATOR?\n         BE    EDPREMDF            NO, JUST BUMP DEFAULT\n         TM    EWSCF1-1(R3),INFMOD COMMAND ENTERED?\n         BZ    EDPREMDF            NO, JUST BUMP DEFAULT\n         LA    R0,L'EWSCF1-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   EWSCF1(R3),C' '\n         BNE   *+L'*+14\n         MVC   EWSCF1(L'EWSCF1-1,R3),EWSCF1+1(R3)\n         MVI   EWSCF1+L'EWSCF1-1(R3),C' '\n         BCT   R0,*-18\n         CLI   EWSCF1(R3),C' '     COMMAND ENTERED?\n         BE    EDPREMDF            NO, JUST BUMP DEFAULT\n         L     R2,TERMINPT         PICK UP AID/ROW/COL ADDRESS\n         CLI   0(R2),X'F7'         IS IT PF7?\n         BE    EDPREMSC            YES\n         CLI   0(R2),X'C7'         IS IT PF19?\n         BE    EDPREMSC            YES\n         MVC   EDDBLW(7),=CL8' '\n         OC    EDDBLW(7),EWSCF1(R3)\n         CLC   EDDBLW(3),=CL3'UP'  IS IT \"UP\"?\n         BNE   *+L'*+12            NO\n         LA    R3,3(R3)            YES, SEE FORWARD\n         SH    R0,=H'3'\n         B     *+L'*+28\n         CLC   EDDBLW(2),=CL2'U'   IS IT \"UP\"?\n         BE    *+L'*+10            YES\n         CLC   EDDBLW(2),=CL2'-'   IS IT \"UP\"?\n         BNE   EDLNESNX            NO, INVALID COMMAND\n         LA    R3,2(R3)            YES, SEE FORWARD\n         SH    R0,=H'2'\n         BNP   EDPREMDF            NO MORE, JUST BUMP DEFAULT\n         CLI   EWSCF1(R3),C' '\n         BNE   EDPREMSC\n         LA    R3,1(R3)\n         BCT   R0,*-12\n         B     EDPREMDF            NONE, JUST BUMP DEFAULT\nEDPREMSC MVI   EDDBLW,C' '\n         OC    EDDBLW(1),EWSCF1(R3)\n         CLI   EDDBLW,C'M'         SCROLL \"MAX\"?\n         BE    EDPREMAX            GO TO TOP\n         CLI   EWSCF1(R3),C'0'     IF NOT NUMERIC?\n         BL    EDPREMDF            JUST BUMP DEFAULT\n         LA    R14,EWSCF1(,R3)     SET START OF FIELD\n         LA    R15,6               MAXIMUM LENGTH\n         CLR   R15,R0\n         BNL   *+L'*+2\n         LR    R15,R0\n         XR    R1,R1               COUNTER\n         CLI   0(R14),C'0'         IF NOT NUMERIC\n         BL    *+L'*+12\n         LA    R1,1(,R1)           BUMP COUNTER\n         LA    R14,1(,R14)         BUMP POINTER\n         BCT   R15,*-16\n         LTR   R1,R1               IF LENGTH IS ZERO?\n         BZ    EDPREMDF            JUST BUMP DEFAULT\n         BCTR  R1,0                SUBTRACT 1 FOR EXECUTED PACK\n         EX    R1,NUMPACK          PACK IT IN EDDBLW\n         CVB   R0,EDDBLW           PUT VALUE IN R0\n         B     EDPREXEQ\nEDPREMDF LH    R0,EDSCROLL         BACK UP THE SCREEN\n         TM    EDFUSW,EDCRSW       CURSOR?\n         BZ    EDPREHLF            NO\n         L     R14,TERMINPT        PICK UP AID/ROW/COL ADDRESS\n         XR    R15,R15\n         IC    R15,1(R14)          GET ROW NUMBER\n         LA    R14,CREWDT-1\n         SR    R15,R14\n         BNP   EDPREXEQ\n         SR    R0,R15\n         B     EDPREXEQ\nEDPREHLF TM    EDFUSW,EDHLSW       HALF PAGE\n         BZ    EDPREXEQ            NO\n         SRL   R0,1                YES\nEDPREXEQ LTR   R0,R0\n         BNP   EDPREEX             GO BACK\n         ICM   R1,B'1111',EDTCURR\n         BZ    EDPREMAX\n         ICM   R1,B'1111',PPTR(R1)\n         BZ    EDPREMAX\n         BCT   R0,*-8\n         ST    R1,EDTCURR          SET CURRENT POINTER\n         B     EDPREEX             GO BACK\nEDPREMAX MVC   EDTCURR,EDTFIRST\nEDPREEX  TM    EDFUSW,EXTCPY       COPY PENDING?\n         BZ    GOBACK              NO, RE-DISPLAY\n         B     EDSMS7              ELSE SET MESSAGE\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R9\n         SPACE 1\n*------- EXECUTE COPY COMMAND\n         CNOP  2,4\n         USING *,R9\nEDXCPY   LR    R2,R8\n        GETMAIN RC,LV=(R8)         GET \"CPWKAR\" WORK-AREA\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    EDXCOK              OK\n        XMESS  2010,R15            ERROR\n         LA    R1,*+L'*+10\n         ST    R1,MSGADD\n         L     R14,=A(CPLEAVE)\n         BR    R14                 CANCEL REQUEST\n         MSG   'GETMAIN \"CPY\" FAILED'\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\nEDXCOK   LR    R0,R1\n         LR    R1,R8\n         LR    R8,R0               SET GETMAIN POINTER\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R0,R14              CLEAR ALL TO BINARY ZEROS\n         USING CPWKAR,R8\n         ST    R2,CPWKLN           SAVE LENGTH\n         STM   R11,R12,CPSVRS      SAVE R11-R12\n         DROP  R9,R11,R12\n         LR    R11,R9\n         LA    R12,2048(R11)\n         LA    R12,2048(R12)\n         USING EDXCPY,R11,R12\n         MVC   CPWDSN,EDTDSNM      SET CURRENT DS-NAME\n         MVC   CPWVOL,EDTVOL       SET CURRENT VOL-SER\n         MVC   CPWPSW,EDTPASS      SET CURRENT PASSWORD\n*- - - - LOOK IF DATA-SET IN CATALOG\n         MVC   VCMLST(CTCMLSL),CTCMLST CLEAR CAMLST AREA\n         XC    VUSWA(L'VUSWA),VUSWA\n         XC    VUSWA+L'VUSWA(16),VUSWA+L'VUSWA\n         LA    R15,CPWDSN          SET DS-NAME\n         XR    R0,R0\n         LA    R1,VUSWA            SET OUTPUT AREA\n         STM   R15,R1,VCMLST+4\n        LOCATE VCMLST\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   EDXBLD              NOT IN CATALOG\n         CLC   CPWVOL(L'CPWVOL),VUSWA+6 IS IT THIS VOL-SER?\n         BNE   EDXBLD              NO, NOT IN CATALOG\n         OI    CPWKSW,VLRFC        YES, SAY RETRIEVED FROM CATALOG\n*- - - - BUILD COPY ENTRY SCREEN\nEDXBLD   TM    CPWKSW,VLRFC        VOL-SER WAS RETRIEVED FROM CATALOG?\n         BZ    *+L'*+10            NO\n         NI    CPWKSW,255-VLRFC\n         MVC   CPWVOL,=CL6' '\n         L     R5,=A(CPYSCR)\n         L     R4,SCROWS1          NUMBER OF ROWS IN SCREEN 1\n         LA    R3,TERMOUT+4        POINT TO FIRST LINE OF SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2\n         BNE   EDXBLD1             NOPE, I'M ALL SET\n         SLL   R4,2                MULTIPLY OFFSET BY 4\n         LA    R3,TERMOUT+4(R4)    POINT TO ROW 1 OF SCREEN 2\n         L     R4,SCROWS2          NUMBER OF ROWS IN SCREEN 2\nEDXBLD1  NI    0(R3),255-EOS       CLEAR END-OF-SCREEN\n         L     R2,0(,R5)           ADDRESS OF FROM FIELD\n         L     R6,0(,R3)           ADDRESS OF \"TO\" FIELD\n         XR    R1,R1\n         IC    R1,0(,R2)           PICK UP LENGTH\n         EX    R1,EDXSMVL          MOVE IT\n         CLC   CPOFF1(10,R6),=CL10'FULLY-QUAL' DS-NAME?\n         BNE   EDXBLD2             NO\n         OI    CPWDSN,C' '\n         CLI   CPWDSN,C' '         IS THERE A DATA-SET NAME SPECIFIED?\n         BE    EDXBLD4             NO\n         MVC   CPSCF1(L'CPWDSN,R6),CPWDSN COPY CURRENT DATA-SET NAME\n         B     EDXBLD4             DO THE REST\nEDXSMVL  MVC   0(*-*,R6),0(R2)     <<EXECUTED>>\nEDXBLD2  CLC   CPOFF2(13,R6),=CL13'VOLUME SERIAL' VOL-SER?\n         BNE   EDXBLD3             NO\n         OC    CPWVOL,=CL6' '\n         CLI   CPWVOL,C' '         IS THERE A VOL-SER SPECIFIED?\n         BE    EDXBLD4             NO\n         MVC   CPSCF2(L'CPSCF2,R6),CPWVOL COPY CURRENT VOL-SER\n         B     EDXBLD4             DO THE REST\nEDXBLD3  CLC   CPOFF3(17,R6),=CL17'DATA-SET PASSWORD' PASSWORD?\n         BNE   EDXBLD4             NO\n         MVC   CPSCF3(L'CPSCF3,R6),CPWPSW COPY CURRENT PASSWORD\n         CLI   CPWPSW,C' '         IS THERE A PASSWORD SPECIFIED?\n         BE    EDXBLD4             NO\n         MVC   CPOFF4(L'CPOFF4,R6),=CL3'(I)' SAY IN\n         MVI   CPOFF4-1(R6),X'05'  SET INTENS\nEDXBLD4  TM    0(R5),EOL           END-OF-LIST?\n         BO    EDXBLD5             YUP\n         BCT   R4,*+L'*+4          END OF SCREEN ROWS?\n         B     EDXBLD6             YUP\n         LA    R5,4(R5)            BUMP TO NEXT PARM\n         LA    R3,4(R3)            BUMP TO NEXT PARM\n         B     EDXBLD1             KEEP LOOPING\nEDXBLD5  BCT   R4,*+L'*+4          END OF SCREEN ROWS?\n         BZ    EDXBLD6             YUP\n         LA    R3,4(R3)            BUMP TO NEXT PARM\n         L     R6,0(,R3)           ADDRESS OF \"TO\" FIELD\n         NI    0(R3),255-EOS       CLEAR END-OF-SCREEN\n         MVC   0(XDUMMYL,R6),XDUMMY MOVE IN A DUMMY ROW\n         B     EDXBLD5             KEEP LOOPING\nEDXBLD6  CLI   SPLIT,1             AM I IN SPLIT-SCREEN, SCREEN 1?\n         BE    *+L'*+4             YES\n         OI    0(R3),EOS           SET END-OF-SCREEN\n         L     R15,=A(CPYHLP)      HELP SCREEN\n         ST    R15,HELPADD\n         MVI   CURROW,CRCPSC       CURSOR ROW\n         MVI   CURCOL,CCCPSC       CURSOR COLUMN\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         LTR   R15,R15             BAD RC?\n         BNZ   CPDEXIT             YUP\n         TM    COMMSW,PFKFLAG      IS IT A PF KEY/ATTN?\n         BZ    CPCKINPT            NOPE, GO CHECK THE INPUT\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    CPDEXIT             YUP, I'M DONE\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BE    CPDEXIT             YUP, I'M DONE\n         CLI   0(R2),X'6C'         IS IT PA1?\n         BE    CPDEXIT             YUP, I'M DONE\n         CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    EDXBLD              YUP, RESHOW SCREEN\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    EDXBLD              YUP, RESHOW SCREEN\n         LA    R1,XINVPFK\nCPSTMSG  ST    R1,MSGADD\n         B     EDXBLD              RESHOW SCREEN\n*- - - - CHECK ENTERED COPY SELECTIONS\nCPCKINPT L     R5,TERMINPT+ZCP1    PICK UP DS-NAME FIELD\n         L     R6,TERMINPT+ZCP2    PICK UP VOL-SER FIELD\n         L     R7,TERMINPT+ZCP3    PICK UP PASSWORD FIELD\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   CPCKINPC            NOPE\n         L     R3,SCROWS1          PICK UP SIZE OF SCREEN 1\n         SLL   R3,2                MULTIPLY BY 4\n         L     R5,TERMINPT+ZCP1(R3) PICK UP DS-NAME FIELD\n         L     R6,TERMINPT+ZCP2(R3) PICK UP VOL-SER FIELD\n         L     R7,TERMINPT+ZCP3(R3) PICK UP PASSWORD FIELD\nCPCKINPC CLI   0(R5),0             DS-NAME ENTERED (OR CHANGED)?\n         BNE   *+L'*+16            YES\n         OI    CPWDSN,C' '\n         CLI   CPWDSN,C' '         DS-NAME ALREADY IN?\n         BNE   CPCVLSR             YES\n         B     EDXBLD              ELSE RETRY THE SCREEN\n         LA    R0,L'CPSCF1-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   CPSCF1(R5),C' '\n         BNE   CPDSNMV\n         MVC   CPSCF1(L'CPSCF1-1,R5),CPSCF1+1(R5)\n         MVI   CPSCF1+L'CPSCF1-1(R5),C' '\n         BCT   R0,*-18\n         MVC   CPWDSN(L'CPWDSN),CPSCF1(R5)\n         B     EDXBLD              RETRY THE SCREEN\nCPDSNMV  MVI   CPWDSN,C' '         RESET DS-NAME FIELD\n         MVC   CPWDSN+1(L'CPWDSN-1),CPWDSN\n         LA    R0,L'CPWDSN         MAX. LENGTH FOR A DS-NAME\n         LA    R14,CPSCF1(R5)      START ADDRESS FOR DSN LENGTH CALC\n         XR    R15,R15             SET COUNTER\nCPDSNLOP CLI   0(R14),C' '         BLANK IS END OF DSN?\n         BE    CPDSNEND            GOT END\n         CLI   0(R14),C'('         LEFT PAREN INDICATES MEMBER?\n         BE    CPDSNEND            YES, GOT END\n         LA    R14,1(R14)          BUMP ADDRESS\n         LA    R15,1(R15)          BUMP COUNTER\n         BCT   R0,CPDSNLOP         TEST NEXT BYTE IF ANY\n         LA    R1,XBADDSN          ELSE ERROR\n         B     CPSTMSG\nCPDSNEND BCT   R15,*+L'*+6         SUBTRACT 1\n         MVC   CPWDSN(*-*),CPSCF1(R5) <<EXECUTED>>\n         EX    R15,*-6\nCPCVLSR  CLI   0(R6),0             VOL-SER ENTERED?\n         BE    CPCPSWD             NO\n         MVC   CPWVOL,=CL6' '\n         LA    R0,L'CPSCF2-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   CPSCF2(R6),C' '\n         BNE   *+L'*+14\n         MVC   CPSCF2(L'CPSCF2-1,R6),CPSCF2+1(R6)\n         MVI   CPSCF2+L'CPSCF2-1(R6),C' '\n         BCT   R0,*-18\n         MVC   CPWVOL(L'CPWVOL),CPSCF2(R6) MOVE IN THE VOL-SER\nCPCPSWD  CLI   0(R7),0             PASSWORD ENTERED?\n         BE    CPGOCHK             NO\n         LA    R0,L'CPSCF3-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   CPSCF3(R7),C' '\n         BNE   *+L'*+14\n         MVC   CPSCF3(L'CPSCF3-1,R7),CPSCF3+1(R7)\n         MVI   CPSCF3+L'CPSCF3-1(R7),C' '\n         BCT   R0,*-18\n         MVC   CPWPSW(L'CPWPSW),CPSCF3(R7) MOVE IN THE PASSWORD\n*- - - - VERIFY CATALOG/VTOC INFO\nCPGOCHK  OI    CPWVOL,C' '\n         CLI   CPWVOL,C' '         WAS VOL-SER PROVIDED?\n         BNE   CPGOCHK1            YES\n         MVC   VCMLST(CTCMLSL),CTCMLST CLEAR CAMLST AREA\n         XC    VUSWA(L'VUSWA),VUSWA\n         XC    VUSWA+L'VUSWA(16),VUSWA+L'VUSWA\n         LA    R15,CPWDSN          SET DS-NAME\n         XR    R0,R0\n         LA    R1,VUSWA            SET OUTPUT AREA\n         STM   R15,R1,VCMLST+4\n        LOCATE VCMLST\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    *+L'*+8             OK\n         LA    R1,BADCTLOC         ELSE SET MESSAGE\n         B     CPSTMSG\n         MVC   CPWVOL(L'CPWVOL),VUSWA+6 SET THE VOL-SER\n         OI    CPWKSW,VLRFC        SAY RETRIEVED FROM CATALOG\nCPGOCHK1 MVC   VCMLST(VTCMLSL),VTCMLST CLEAR CAMLST AREA\n         XC    VUSWA(DSCBLGTH),VUSWA\n         LA    R15,CPWDSN          SET DS-NAME\n         LA    R0,CPWVOL           SET VOL-SER\n         LA    R1,VUSWA            SET OUTPUT AREA ADDRESS\n         STM   R15,R1,VCMLST+4\n        OBTAIN VCMLST\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    *+L'*+8             OK\n         LA    R1,BADVTOBT         ELSE SET MESSAGE\n         B     CPSTMSG\n         LA    R1,VUSWA            VTOC-INFO ADDRESS\n         USING DS1FMTID,R1         SET ADDRESSABILITY\n         CLC   DS1DSORG(L'DS1DSORG),=AL1(DS1DSGPS,0) IS IT SEQUENTIAL?\n         BE    CPTSTLRC            YUP, DEFAULT DSORG IS PS\n         OI    CPWKSW,PODS         SET DSORG IS PO\n         CLC   DS1DSORG(L'DS1DSORG),=AL1(DS1DSGPO,0) IS IT PO?\n         BE    CPTSTLRC            YUP\n         LA    R1,BADEDORG         ELSE NO GOOD, SET MESSAGE\n         B     CPSTMSG\nCPTSTLRC CLC   DS1LRECL(L'DS1LRECL),=H'80' IS LRECL=80?\n         BE    *+L'*+8             YUP, OK\n         DROP  R1\n         LA    R1,BADED80          ELSE NO GOOD, SET MESSAGE\n         B     CPSTMSG\n         MVC   CPWMEM,=CL8' '      CLEAR MEMBER NAME FIELD\n         CLC   CPWKSW,PODS         IS IT A SEQUENTIAL FILE?\n         BZ    CPLBSQ              YES\n*- - - - ALLOCATE THE FILE TO DO MEMBER SELECTION\n         L     R7,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R7\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R7\n         MVC   DDNAME,N#UT1        DD-NAME\n         MVC   DSNAME,CPWDSN       DS-NAME\n         MVC   DSVOLSER,CPWVOL     VOL-SER\n         MVC   PASSWORD,CPWPSW     PASSWORD\n         MVC   DSSTATUS,=CL8'SHR'  SET DISP=SHR\n         MVC   DSUNIT,=CL8'SYSALLDA'\n         DROP  R7\n         MVC   CPWDCB(SKDDCBL),SKDDCB MOVE DCB SKELETON\n         MVC   CPWDCB+DCBDDNAM-IHADCB(L'DCBDDNAM),N#UT1 SET DD-NAME\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    CPOKAD              OK\n         CLC   DYNRCODE(2),=XL2'0210'\n         BE    CPINUSE\n        XMESS  2005\n         LA    R1,*+L'*+4\n         B     CPDSMS\n         MSG   'ALLOC \"DIR\" FAILED',H=Y\nCPINUSE  LA    R1,*+L'*+4\n         B     CPDSMS\n         MSG   '0210/DATA-SET IN USE',H=Y\n*- - - - DIRECTORY MEMBERS SELECTION PROCESS\nCPOKAD   MVI   CPWNOTE,0           INITIALIZE\n         MVI   CPFUSW,0\n         MVC   CPWLOC,=CL8' '      NOT DOING LOCATE\n         MVI   CPWSLF,C' '\n         XC    CPADDR,CPADDR\n         L     R0,SCROWS1          LINES PER PAGE SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+4             NO\n         L     R0,SCROWS2          LINES PER PAGE SCREEN 2\n         SH    R0,=Y(CPDLST)\n         STH   R0,CPSCROLL\nCPDSDCB  TM    CPWDCB+DCBOFLGS-IHADCB,DCBOFOPN IS IT OPEN ALREADY?\n         BO    CPDSOPND            YUP\n         LA    R1,CPDREOF\n         STCM  R1,B'0111',CPWDCB+DCBEODA-IHADCB\n         LA    R1,CPDSYNA\n         STCM  R1,B'0111',CPWDCB+DCBSYNA-IHADCB\n         NI    CPFLSW,255-CPWSYFLG\n         MVI   OPCLPL,VLB          SET \"VL\" BIT\n        OPEN   (CPWDCB,(INPUT)),MF=(E,OPCLPL) OPEN FILE\n         TM    CPWDCB+DCBOFLGS-IHADCB,DCBOFOPN TEST FOR GOOD OPEN?\n         BO    CPOKLOP             OK\n         OI    CPFUSW,CPXREQ\n         LA    R1,*+L'*+8\n         ST    R1,MSGADD\n         B     CPDNTO              YUP - ALL DONE\n         MSG   'OPEN \"DIR\" FAILED',H=Y\nCPOKLOP  MVC   CPWDECBW(CPWDECBL),CPWDECB\nCPDSOPND NI    CPFLSW,255-CPWEOFLG INDICATE NOT AT EOF\n         XC    CPWTOP,CPWTOP\n         LA    R4,TERMOUT+4        POINT TO START\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+12            NOPE, JUST GO DO IT\n         L     R1,SCROWS1          PICK UP NUMBER OF ROWS ON SCREEN 1\n         SLL   R1,2                MULTIPLY BY 4\n         LA    R4,TERMOUT+4(R1)    POINT TO START\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R14,0(,R4)          PICK UP ADDRESS OF FIRST OUTPUT LINE\n         LA    R15,CPWROW1         PICK UP FIRST LINE OF INPUT\n         XR    R1,R1\n         IC    R1,0(,R15)          PICK UP LENGTH\n         EX    R1,CPMVEDR          MOVE INPUT INTO OUTADDR WORK AREA\n         LA    R15,CPWDSNAM(R14)\n         MVC   0(L'CPWDSN,R15),CPWDSN\n         LA    R1,L'CPWDSN\n         CLI   0(R15),C' '\n         BNE   *+L'*+4\n         MVI   0(R15),C'-'\n         LA    R15,1(R15)\n         BCT   R1,*-16\n         L     R14,4(,R4)          BUMP\n         NI    4(R4),255-EOS       CLEAR END-OF-SCREEN\n         LA    R15,CPWROW2         PICK UP NEXT LINE OF INPUT\n         IC    R1,0(,R15)          PICK UP LENGTH\n         EX    R1,CPMVEDR          MOVE INPUT INTO OUTADDR WORK AREA\n         TM    CPFUSW,CPCRSW\n         BZ    *+L'*+10\n         MVC   CDSCF2(L'CDSCF2,R14),=CL4'CSR'\n         B     *+L'*+24\n         TM    CPFUSW,CPHLSW\n         BZ    *+L'*+10\n         MVC   CDSCF2(L'CDSCF2,R14),=CL4'HALF'\n         B     *+L'*+6\n         MVC   CDSCF2(L'CDSCF2,R14),=CL4'PAGE'\n         L     R14,8(,R4)          BUMP\n         NI    8(R4),255-EOS       CLEAR END-OF-SCREEN\n         LA    R15,CPWROW3         PICK UP NEXT LINE OF INPUT\n         IC    R1,0(,R15)          PICK UP LENGTH\n         EX    R1,CPMVEDR          MOVE INPUT INTO OUTADDR WORK AREA\n         L     R14,12(,R4)         BUMP\n         NI    12(R4),255-EOS      CLEAR END-OF-SCREEN\n         LA    R15,CPWROW4         PICK UP NEXT LINE OF INPUT\n         IC    R1,0(,R15)          PICK UP LENGTH\n         EX    R1,CPMVEDR          MOVE INPUT INTO OUTADDR WORK AREA\n         LA    R4,16(,R4)          SET R4 TO START OF BUILD AREA\n         MVC   CPWFMEM,=CL8' '     RESET FIRST NAME (TOP)\n         LH    R6,CPSCROLL         MAX DIRECTORY MEMBERS ON SCREEN\n         TM    CPFUSW,CPRCSW       DIR. RECORD STILL IN?\n         BZ    CPREAD              NO\n         NI    CPFUSW,255-CPRCSW   YES\n         MVC   CPWBOT,CPWPOINT     COPY CURRENT TTR (BOTTOM)\n         LA    R9,CPWKEY+L'CPWKEY+2 SET FIRST MEMBER ADDRESS\n         B     CPNEXT\nCPREAD   BAL   R14,CPDRTN\n         ST    R1,CPWBOT           KEEP CURRENT TTR (BOTTOM)\n         USING PDS2,R9\nCPNEXT   CLI   PDS2NAME,X'FF'      END OF DIRECTORY?\n         BE    CPRENDOF            YES, LAST USED BLOCK\n         TM    CPFLSW,CPWEOFLG     HAVE I HIT EOF?\n         BO    CPRENDOF            YUP\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R1,0(,R4)\n         USING DIRMASK,R1\n         MVC   DIRLGTH(CPWELEN),CPWLIST MOVE DIR-ENTRY IN\n*- - - - AM I DOING LOCATE FUNCTION?\n         CLI   CPWLOC,C' '         LOCATE?\n         BE    CPDLOCF             NOPE\n         CLC   CPWLOC(1),PDS2NAME  MATCH?\n         BL    CPDLOCF             GONE PAST IT\n         BH    CPDBUMP             IF HIGH, KEEP READING DIRECTORY\n         CLI   CPWLOC+1,C' '       END OF STRING?\n         BE    CPDLOCF             YES, MATCHED UP TO HERE, SO OK\n         CLC   CPWLOC+1(1),PDS2NAME+1 MATCH?\n         BL    CPDLOCF             GONE PAST IT\n         BH    CPDBUMP             IF HIGH, KEEP READING DIRECTORY\n         CLI   CPWLOC+2,C' '       END OF STRING?\n         BE    CPDLOCF             YES, MATCHED UP TO HERE, SO OK\n         CLC   CPWLOC+2(1),PDS2NAME+2 MATCH?\n         BL    CPDLOCF             GONE PAST IT\n         BH    CPDBUMP             IF HIGH, KEEP READING DIRECTORY\n         CLI   CPWLOC+3,C' '       END OF STRING?\n         BE    CPDLOCF             YES, MATCHED UP TO HERE, SO OK\n         CLC   CPWLOC+3(1),PDS2NAME+3 MATCH?\n         BL    CPDLOCF             GONE PAST IT\n         BH    CPDBUMP             IF HIGH, KEEP READING DIRECTORY\n         CLI   CPWLOC+4,C' '       END OF STRING?\n         BE    CPDLOCF             YES, MATCHED UP TO HERE, SO OK\n         CLC   CPWLOC+4(1),PDS2NAME+4 MATCH?\n         BL    CPDLOCF             GONE PAST IT\n         BH    CPDBUMP             IF HIGH, KEEP READING DIRECTORY\n         CLI   CPWLOC+5,C' '       END OF STRING?\n         BE    CPDLOCF             YES, MATCHED UP TO HERE, SO OK\n         CLC   CPWLOC+5(1),PDS2NAME+5 MATCH?\n         BL    CPDLOCF             GONE PAST IT\n         BH    CPDBUMP             IF HIGH, KEEP READING DIRECTORY\n         CLI   CPWLOC+6,C' '       END OF STRING?\n         BE    CPDLOCF             YES, MATCHED UP TO HERE, SO OK\n         CLC   CPWLOC+6(1),PDS2NAME+6 MATCH?\n         BL    CPDLOCF             GONE PAST IT\n         BH    CPDBUMP             IF HIGH, KEEP READING DIRECTORY\n         CLI   CPWLOC+7,C' '       END OF STRING?\n         BE    CPDLOCF             YES, MATCHED UP TO HERE, SO OK\n         CLC   CPWLOC+7(1),PDS2NAME+7 MATCH?\n         BL    CPDLOCF             GONE PAST IT\n         BH    CPDBUMP             NOPE\nCPDLOCF  OC    CPWTOP,CPWTOP       TOP OF SCREEN DISPLAY UNKNOWN?\n         BNZ   *+L'*+6             NO, SKIP\n         MVC   CPWTOP(L'CPWTOP),CPWBOT YES, RETAIN TTR (TOP)\n*- - - - FORMAT THE PDS MEMBER\n         MVC   DIRNAME(L'PDS2NAME),PDS2NAME MOVE MEMBER NAME TO DISPLAY\n         CLI   CPWSLF,C' '         SELECT CODE?\n         BE    CPNOSC              BRANCH IF NONE\n         MVC   DIRCODE,CPWSLF      ELSE COPY IT\n         MVI   DIRSUN1,X'02'+INFMOD AND SET INTENS + MDT ON\n         MVI   CPWSLF,C' '         THEN RESET\nCPNOSC   NI    PDS2INDC,PDS2LUSR\n         CLI   PDS2INDC,X'0F'\n         BNE   CPNSPF\n         LA    R14,PDS2USRD        START OF USER AREA\n         USING SPFMT,R14\n         XR    R15,R15\n         IC    R15,SPFVER\n         CVD   R15,DBLWRD\n         OI    DBLWRD+7,X'0F'\n         UNPK  DIRLEVEL(3),DBLWRD+6(2)\n         MVI   DIRLEVEL,C' '\n         IC    R15,SPFMOD\n         CVD   R15,DBLWRD\n         OI    DBLWRD+7,X'0F'\n         UNPK  DIRLEVEL+3(3),DBLWRD+6(2)\n         MVI   DIRLEVEL+3,C'.'\n         MVC   DIRLEVEL(5),DIRLEVEL+1\n         MVI   DIRLEVEL+5,C' '\n         UNPK  DIRCREAT(5),SPFCRDT(3) CREATION DATE\n         UNPK  DIRMOD(5),SPFMODT(3) MODIFIED DATE\n         XR    R15,R15\n         ICM   R15,B'0011',SPFSIZE\n         CVD   R15,DBLWRD\n         OI    DBLWRD+7,X'0F'\n         UNPK  DIRLINES(5),DBLWRD+5(3)\n         MVC   DIRUSER(L'SPFUID),SPFUID\n         DROP  R1,R14\nCPNSPF   CLI   CPWFMEM,C' '\n         BNE   *+L'*+6\n         MVC   CPWFMEM,PDS2NAME    SET TOP OF LIST\n         BCT   R6,*+L'*+10         KEEP GOING\n         MVC   CPWLMEM,PDS2NAME    SET IT\n         B     CPDFMT\n         LA    R4,4(R4)            LOAD ADDRESS OF NEXT MEMBER\nCPDBUMP  MVC   CPWLMEM,PDS2NAME    SET IT\n         CLC   CPWKEY,PDS2NAME     TEST FOR LAST MEMBER IN BLOCK\n         BNH   CPREAD\n         XR    R14,R14\n         NI    PDS2INDC,PDS2LUSR   CLEAR ALIAS AND TTR FLAGS\n         IC    R14,PDS2INDC        PICK UP USER DATA LENGTH IN H-WORDS\n         SLL   R14,1               MULTIPLY BY 2\n         LA    R9,PDS2USRD(R14)    POINT TO NEXT MEMBER\n         B     CPNEXT\n         DROP  R9\nCPMVEDR  MVC   0(*-*,R14),0(R15)   <<EXECUTED>>\n         SPACE 1\n*- - - - READ A DIRECTORY RECORD ROUTINE\n*              R9 = AT EXIT, POINTER TO FIRST MEMBER NAME IN BLOCK\n*              R14 = LINK REGISTER\nCPDRTN   ST    R14,CPWSR14\n         LA    R3,CPWKEY\n        READ   CPWDECBW,SF,CPWDCB,(R3),'S',MF=E\n        CHECK  CPWDECBW\n         TM    CPFLSW,CPWSYFLG     WAS SYNAD EXIT TAKEN?\n         BZ    *+L'*+8             NO, BRANCH\n         LA    R1,CPWMSG           YES, ERROR\n         B     CPDSTM\n        NOTE   CPWDCB\n         CLM   R1,B'0010',CPWNOTE  KEEP HIGHEST R OF TTR\n         BNH   *+L'*+4\n         STCM  R1,B'0010',CPWNOTE\n         LA    R9,L'CPWKEY+2(R3)   FIRST MEMBER ADDRESS (+KEY+LENGTH)\n         L     R14,CPWSR14\n         BR    R14                 BACK TO CALLER\nCPDREOF XMESS  2014\n         LA    R1,*+L'*+8\nCPDSTM   ST    R1,MSGADD\n         B     CPDXBK\n         MSG   'DIR.EOF READ',H=Y\n         SPACE 1\n*- - - - FILL REST OF SCREEN (END OF DIRECTORY)\nCPRENDOF NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R1,0(,R4)\n         USING DIRMASK,R1\n         MVC   DIRLGTH(CPWELEN),CPWLIST MOVE DIR-ENTRY IN\n         MVI   DIRSUN1,X'04'       INHIBIT SELECT OF THESE LINES\n         TM    CPFLSW,CPWEOFLG     FIRST TIME?\n         BO    *+L'*+14            NO\n         MVI   DIRSUN2,X'05'\n         MVC   DIRNAME,=CL9'** END **'\n         OI    CPFLSW,CPWEOFLG     INDICATE I HAVE HIT EOF\n         BCT   R6,*+L'*+4          KEEP GOING\n         B     *+L'*+8\n         LA    R4,4(,4)            LOAD ADDRESS OF NEXT MEMBER\n         B     CPRENDOF\n         DROP  R1\n         OC    CPWTOP,CPWTOP       TOP OF SCREEN DISPLAY UNKNOWN?\n         BNZ   CPDFMT              NO, SKIP\n         MVC   CPWTOP(L'CPWTOP),CPWBOT YES, RETAIN TTR (TOP)\nCPDFMT   CLI   SPLIT,1             AM I ON TOP SCREEN?\n         BE    *+L'*+4             YUP\n         OI    0(R4),EOS           SET END-OF-SCREEN\n         L     R15,=A(CPWHELP)     HELP SCREEN\n         ST    R15,HELPADD\n         XC    CURADDR,CURADDR\n         OC    CURADDR,CPADDR      ANY CURSOR POSITION REQUESTED?\n         BNZ   *+L'*+8             YES\n         MVI   CURROW,CPDRSC       NO, SET DEFAULT CURSOR ROW\n         MVI   CURCOL,CCDRSC       AND CURSOR COLUMN\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         LTR   R15,R15             BAD RC?\n         BNZ   CPDXRQ              OUT\n         XC    CPADDR,CPADDR\n*- - - - SCREEN MAY HAVE CHANGED\n         L     R0,SCROWS1          LINES PER PAGE SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+4             NO\n         L     R0,SCROWS2          LINES PER PAGE SCREEN 2\n         SH    R0,=Y(CPDLST)\n         STH   R0,CPSCROLL\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         L     R4,TERMINPT+CPZE    PICK UP COMMAND INPUT LINE\n         CLI   SPLIT,2             AM I ON SECOND SCREEN?\n         BNE   CPDSCRL             NO, GO TEST PFKEY\n         L     R3,SCROWS1          PICK UP NUMBER OF ROWS ON SCREEN 1\n         SLL   R3,2                MULTIPLY BY 4\n         L     R4,TERMINPT+CPZE(R3) PICK UP COMMAND INPUT LINE\n*- - - - CHECK IF SCROLL ENTERED\nCPDSCRL  CLI   0(R4),0             COMMAND OR SCROLL ENTERED?\n         BE    CPDCKPF             NOPE\n         TM    CDSCF2-1(R4),INFMOD YES, SCROLL ENRERED?\n         BZ    CPDCKPF             NO\n         LA    R14,CDSCF2(,R4)\n         LA    R0,L'CDSCF2\n         CLI   0(R14),C' '\n         BNE   *+L'*+12\n         LA    R14,1(,R14)\n         BCT   R0,*-12\n         B     *+L'*+18            NONE, CLEARED\n         MVI   CPWDBLW,C' '\n         OC    CPWDBLW(1),0(R14)\n         NI    CPFUSW,255-CPHLSW-CPCRSW RESET TO PAGE\n         CLI   CPWDBLW,C'H'\n         BNE   *+L'*+8\n         OI    CPFUSW,CPHLSW       SET HALF\n         B     CPDCKPF\n         CLI   CPWDBLW,C'C'\n         BNE   CPDCKPF\n         OI    CPFUSW,CPCRSW       SET CURSOR\nCPDCKPF  TM    COMMSW,PFKFLAG      IS IT A PF KEY/ATTN?\n         BZ    CPDTCMD             NONE\n*- - - - TEST PF KEYS (PF KEY WAS ENTERED, SEE WHAT IT WAS)\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    CPDXBK              YUP - ALL DONE\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BE    CPDXBK              YUP - ALL DONE\n         CLI   0(R2),X'F8'         IS IT PF8?\n         BE    CPDMORE             YUP - SHOW NEXT SCREEN OF DIR\n         CLI   0(R2),X'C8'         IS IT PF20?\n         BE    CPDMORE             YUP - SHOW NEXT SCREEN OF DIR\n         CLI   0(R2),X'F7'         IS IT PF7?\n         BE    CPDPREV             YUP - SHOW PREV SCREEN OF DIR\n         CLI   0(R2),X'C7'         IS IT PF19?\n         BE    CPDPREV             YUP - SHOW PREV SCREEN OF DIR\n         CLI   0(R2),X'6C'         IS IT PA1?\n         BE    CPDXRQ              YUP - ALL DONE\n         CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    CPDRSHW             YUP - GO RESHOW THE SCREEN\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    CPDRSHW             YUP - GO RESHOW THE SCREEN\n         LA    R1,*+L'*+14\n         ST    R1,MSGADD\nCPDRSHW  MVC   CPWLOC,CPWFMEM      RE-LOCATE THE TOP OF DISPLAY\n         B     CPDRLC2\n         MSG   'INVALID PF-KEY',H=Y\n*- - - - CHECK IF A COMMAND ENTERED\nCPDTCMD  CLI   0(R4),0             COMMAND OR SCROLL ENTERED?\n         BE    CPDSEL              NOPE\n         TM    CDSCF1-1(R4),INFMOD YES, COMMAND ENRERED?\n         BZ    CPDSEL              NO\n         LA    R0,L'CDSCF1-1       YES, LEFT JUSTIFY FIELD IF NEEDED\n         CLI   CDSCF1(R4),C' '\n         BNE   *+L'*+18\n         MVC   CDSCF1(L'CDSCF1-1,R4),CDSCF1+1(R4)\n         MVI   CDSCF1+L'CDSCF1-1(R4),C' '\n         BCT   R0,*-18\n         B     CPDSEL              NONE\n         CLC   CDSCF1(4,R4),=CL4'END ' END OF WORK?\n         BE    CPDXBK              YES\n         CLC   CDSCF1(4,R4),=CL4'DUMP' TAKE A DUMP?\n         BNE   *+L'*+2             NOPE\n         DC    H'0'                YUP, TAKE AN S0C1 <------------ DUMP\n         CLI   CDSCF1(R4),C'L'     LOCATE?\n         BE    CPDRLOC             YUP, GO LOCATE\n         CLI   CDSCF1(R4),C'F'     ALLOW \"F\" FOR FIND AS WELL\n         BE    CPDRLOC             GO LOCATE\n         CLC   CDSCF1(5,R4),=CL5'DOWN' DOWN?\n         BE    CPDMORE             GO DO IT\n         CLC   CDSCF1(2,R4),=CL2'D' DOWN?\n         BE    CPDMORE             GO DO IT\n         CLC   CDSCF1(2,R4),=CL2'+' DOWN?\n         BE    CPDMORE             GO DO IT\n         CLC   CDSCF1(3,R4),=CL3'UP' UP?\n         BE    CPDPREV             GO DO IT\n         CLC   CDSCF1(2,R4),=CL2'U' UP?\n         BE    CPDPREV             GO DO IT\n         CLC   CDSCF1(2,R4),=CL2'-' UP?\n         BE    CPDPREV             GO DO IT\n*- - - - PUT OTHER TESTS FOR COMMAND LINE INPUT HERE\nCPDINVC  LA    R1,*+L'*+4\n         B     CPDRSTM\n         MSG   'INVALID COMMAND',H=Y\nCPDSEL   LA    R3,TERMINPT+CPZN    POINT TO LINE 5 (1ST SELECT LINE)\n         L     R4,SCROWS1          PICK UP NUMBER OF ROWS ON SCREEN 1\n         CLI   SPLIT,2             AM I ON SECOND SCREEN?\n         BNE   CPDSEL1             NO, GO ROLL\n         LR    R3,R4               NUMBER OF ROWS ON SCREEN 1\n         SLL   R3,2                MULTIPLY BY 4\n         LA    R3,TERMINPT+CPZN(R3) SET ADDRESS OF 1ST SELECT LINE\n         L     R4,SCROWS2          PICK UP NUMBER OF ROWS ON SCREEN 2\nCPDSEL1  SH    R4,=Y(CPDLST)       MAX DIRECTORY MEMBERS FOR ONE SCREEN\nCPDSEL2  L     R5,0(,R3)           POINT TO EACH LINE IN TURN\n         CLI   0(R5),0             ANY INPUT?\n         BE    CPDSEL3             NO, SKIP\n         CLI   CPSLF1(R5),C' '     YES, BUT IS IT JUST CLEAR FIELD?\n         BNE   CPDSEL4             NO, GO PROCESS IT\nCPDSEL3  LA    R3,4(,R3)           POINT TO NEXT LINE\n         BCT   R4,CPDSEL2\n         B     CPDRCL              GO SHOW MORE\nCPDSEL4  CLC   CPSLF2(8,R5),=CL8' '\n         BE    *+L'*+10\n         CLC   CPSLF2(9,R5),=CL9'** END **'\n         BNE   CPDSEL5\n         MVI   CPSLF1(R5),C' '     ERROR, CLEAR IT\n         B     CPDINVS+L'CPDINVS   INVALID SELECTION\nCPDSEL5  MVC   CPWLOC(L'CPWLOC),CPSLF2(R5) SET IT\n         MVC   CPWSLF(L'CPWSLF),CPSLF1(R5) SET SELECT CODE\n         MVI   CPSLF1(R5),C' '     CLEAR IT\n*- - - - PUT TESTS FOR OTHER SELECTION CODES HERE\n         CLI   CPWSLF,C'S'         SELECT?\n         BE    *+L'*+8             YES\n         CLI   CPWSLF,C'C'         OR COPY?\n         BNE   CPDINVS             NO\n         MVC   CPWMEM(L'CPWMEM),CPSLF2(R5) THIS MEMBER SELECTED\n         B     CPDFND\nCPDINVS  MVC   CPADDR,=AL1(CPDLST,CCDLST)\n         LA    R1,*+L'*+4          SET MESSAGE AND TRUNCATE\n         B     CPDRSTM               PROCESSING AT THIS POINT\n         MSG   'INVALID SELECTION',H=Y\n*- - - - LOCATE MEMBER IN LIBRARY\nCPDRLOC  CLI   CDSCF1+1(R4),C' '\n         BNE   *+L'*+12\n         LA    R0,L'CDSCF1-2\n         LA    R1,CDSCF1+2(R4)\n         B     CPDRLC1\n         CLC   CDSCF1+1(6,R4),=CL6'OCATE '\n         BNE   *+L'*+12\n         LA    R0,L'CDSCF1-7\n         LA    R1,CDSCF1+7(R4)\n         B     CPDRLC1\n         CLC   CDSCF1+1(4,R4),=CL4'IND '\n         BNE   CPDINVC\n         LA    R0,L'CDSCF1-5\n         LA    R1,CDSCF1+5(R4)\nCPDRLC1  CLI   0(R1),C' '\n         BNE   *+L'*+12\n         LA    R1,1(R1)\n         BCT   R0,CPDRLC1\n         B     CPDRLC2\n         MVC   CPWLOC(L'CPWLOC),0(R1) MOVE IN \"LOCATE\" NAME\n         B     CPDRLC2\nCPDRSTM  ST    R1,MSGADD\nCPDRCL   MVC   CPWMEM,=CL8' '      CLEAR MEMBER NAME FIELD\nCPDRLC2  XC    CPWPOINT,CPWPOINT   POINT TO START OF DIRECTORY\n         MVI   CPWPOINT+2,1\n        POINT  CPWDCB,CPWPOINT\n         B     CPDSDCB\n*- - - - SHOW MORE DIRECTORY INFO\nCPDMORE  NI    CPFUSW,255-CPUPSW   SAY DOWN CONTROL\n         BAL   R14,CPCSAR          GET SCROLL AMOUNT\n         B     CPDMRMX             RETURN +0\n         MVI   CPWPOINT+3,0         \" \"   +4\n         MVC   CPWPOINT(L'CPWTOP),CPWTOP SET FIRST BLOCK READ (TOP)\nCPDMRD1 POINT  CPWDCB,CPWPOINT\n         BAL   R14,CPDRTN\n         ST    R1,CPWPOINT         KEEP CURRENT TTR\n         LR    R3,R9               RETAIN START ADDRESS\n         USING PDS2,R9\n         CLC   CPWFMEM,PDS2NAME    IS THIS MEMBER NAME?\n         BE    CPDMRD6             YES, IT IS JUST THIS ONE\n         BH    CPDMRD2             NO\n         BAL   R14,CPSBLK          ELSE GO BACK\n         B     CPDPRMX             RETURN +0\n         B     CPDMRD1              \" \"   +4\nCPDMRD2  CLC   CPWFMEM,CPWKEY      IS MEMBER IN THIS BLOCK?\n         BNH   CPDMRD3             YES\n         BAL   R14,CPDRTN          NO, GO AHEAD\n         ST    R1,CPWPOINT         KEEP CURRENT TTR\n         LR    R3,R9               RETAIN START ADDRESS\n         CLC   CPWFMEM,PDS2NAME    IS THIS MEMBER NAME?\n         BE    CPDMRD6             YES, IT IS JUST THIS ONE\n         BL    CPDMRD9             IT HAS BEEN DELETED, STOP HERE\n         B     CPDMRD2             ELSE\nCPDMRD3  CLC   PDS2NAME,CPWKEY     LAST MEMBER IN BLOCK?\n         BL    CPDMRD4             NO\n         CLI   CPWKEY,X'FF'        YES, END OF DIRECTORY?\n         BE    CPDMRMX1            YES\n         BAL   R14,CPDRTN          NO, GO AHEAD\n         ST    R1,CPWPOINT         KEEP CURRENT TTR\n         LR    R3,R9               RETAIN START ADDRESS\n         B     CPDMRD5\nCPDMRD4  XR    R14,R14\n         NI    PDS2INDC,PDS2LUSR   CLEAR ALIAS AND TTR FLAGS\n         IC    R14,PDS2INDC        PICK UP USER DATA LENGTH IN H-WORDS\n         SLL   R14,1               MULTIPLY BY 2\n         LA    R9,PDS2USRD(R14)    POINT TO NEXT MEMBER NAME\nCPDMRD5  CLC   CPWFMEM,PDS2NAME    IS THIS MEMBER NAME?\n         BL    CPDMRD9             IT HAS BEEN DELETED, STOP HERE\n         BH    CPDMRD3             NO\nCPDMRD6  CLC   PDS2NAME,CPWKEY     YES, LAST MEMBER IN BLOCK?\n         BNL   CPDMRD8             YES\nCPDMRD7  XR    R14,R14             NO\n         NI    PDS2INDC,PDS2LUSR   CLEAR ALIAS AND TTR FLAGS\n         IC    R14,PDS2INDC        PICK UP USER DATA LENGTH IN H-WORDS\n         SLL   R14,1               MULTIPLY BY 2\n         LA    R9,PDS2USRD(R14)    LOAD ADDRESS OF NEXT MEMBER NAME\n         B     CPDMRD9\nCPDMRD8  CLI   CPWKEY,X'FF'        END OF DIRECTORY?\n         BE    CPDMRMX1            YES\n         BAL   R14,CPDRTN\n         ST    R1,CPWPOINT         KEEP CURRENT TTR\n         CLI   PDS2NAME,X'FF'      END OF DIRECTORY?\n         BE    CPDMRMX2            YES\n         LR    R3,R9               RETAIN START ADDRESS\nCPDMRD9  BCT   R6,CPDMRD10\n         CLI   PDS2NAME,X'FF'      END OF DIRECTORY?\n         BE    CPDMRMX1            YES\n         MVC   CPWLOC,PDS2NAME     NO, LOOKING FOR PARTICULAR MEMBER\n         OI    CPFUSW,CPRCSW       SET DIR. RECORD STILL IN\n         B     CPDSDCB\nCPDMRD10 CLC   PDS2NAME,CPWKEY     LAST MEMBER IN BLOCK?\n         BL    CPDMRD7             NO, CONTINUE\n         B     CPDMRD8             YES\nCPDMRMX  MVC   CPWPOINT,CPWBOT     SET LAST BLOCK READ (BOTTOM)\n        POINT  CPWDCB,CPWPOINT\n         BAL   R14,CPDRTN\n         ST    R1,CPWPOINT         KEEP CURRENT TTR\n         CLI   CPWKEY,X'FF'        END OF DIRECTORY?\n         BNE   *-12                NO\n         B     CPDMRMX2            YES\nCPDMRMX1 LR    R9,R3               RESTORE START ADDRESS\nCPDMRMX2 LH    R6,CPSCROLL         NOW MOVE DOWN THE SCREEN\n         TM    CPFUSW,CPHLSW       HALF PAGE\n         BZ    *+L'*+4             NO\n         SRL   R6,1                YES\n         LTR   R6,R6\n         BP    CPRMRPR\n         LA    R6,1\n         B     CPRMRPR\n         DROP  R9\n*- - - - SHOW PREVIOUS DIRECTORY INFO\nCPDPREV  OI    CPFUSW,CPUPSW       SAY UP CONTROL\n         BAL   R14,CPCSAR          GET SCROLL AMOUNT\n         B     CPDPRMX             RETURN +0\n         MVI   CPWPOINT+3,0         \" \"   +4\n         MVC   CPWPOINT(L'CPWTOP),CPWTOP SET FIRST BLOCK READ (TOP)\nCPDPRD1 POINT  CPWDCB,CPWPOINT\nCPDPRD2  BAL   R14,CPDRTN\n         ST    R1,CPWPOINT         KEEP CURRENT TTR\n         USING PDS2,R9\n         CLI   PDS2NAME,X'FF'      END OF DIRECTORY?\n         BNE   CPDPRD4             NO\nCPDPRD3  BAL   R14,CPSBLK          YES, BACK 1 BLOCK\n         B     CPDPRMX             RETURN +0\n         B     CPDPRD1              \" \"   +4\nCPDPRD4  LR    R3,R9               RETAIN START ADDRESS\n         CLC   CPWFMEM,PDS2NAME    HOW WITH TOP SCREEN MEMBER NAME?\n         BL    CPDPRD3             MUST GO BACK\n         BE    CPDPRD7             IT IS JUST THIS ONE\nCPDPRD5  CLC   CPWFMEM,CPWKEY      IS MEMBER IN THIS BLOCK?\n         BNH   CPDPRD6             YES\n         BAL   R14,CPDRTN          NO, ELSE GO AHEAD\n         ST    R1,CPWPOINT         KEEP CURRENT TTR\n         LR    R3,R9               RETAIN START ADDRESS\n         B     CPDPRD5\nCPDPRD6  CLC   CPWFMEM,PDS2NAME    IS THIS MEMBER NAME?\n         BNH   CPDPRD7             YES OR IT HAS BEEN DELETED\n         CLC   PDS2NAME,CPWKEY     NO, LAST MEMBER IN BLOCK?\n         BNL   CPDPRD7             IT HAS BEEN DELETED, STOP HERE\n         XR    R14,R14\n         NI    PDS2INDC,PDS2LUSR   CLEAR ALIAS AND TTR FLAGS\n         IC    R14,PDS2INDC        PICK UP USER DATA LENGTH IN H-WORDS\n         SLL   R14,1               MULTIPLY BY 2\n         LA    R9,PDS2USRD(R14)    LOAD ADDRESS OF NEXT MEMBER NAME\n         B     CPDPRD6\nCPDPRD7  LR    R4,R9               NOW TRY TO BACKWARD THE SCREEN\n         LR    R9,R3               RESTORE START ADDRESS\n         XR    R15,R15             ZERO COUNT\nCPDPRD8  CLR   R9,R4               THIS MEMBER NAME?\n         BE    CPDPRD9             YES\n         CLC   PDS2NAME,CPWKEY     NO, LAST MEMBER IN BLOCK?\n         BNL   CPDPRD9             YES\n         LA    R15,1(R15)          NO, UPDATE COUNT\n         XR    R14,R14\n         NI    PDS2INDC,PDS2LUSR   CLEAR ALIAS AND TTR FLAGS\n         IC    R14,PDS2INDC        PICK UP USER DATA LENGTH IN H-WORDS\n         SLL   R14,1               MULTIPLY BY 2\n         LA    R9,PDS2USRD(R14)    LOAD ADDRESS OF NEXT MEMBER NAME\n         B     CPDPRD8\nCPDPRD9  SR    R6,R15              IS IT ENOUGH?\n         BZ    CPDPRD12            YES, EXACTLY THE AMOUNT\n         BM    CPDPRD10            A FEW TOO MUCH\n         BAL   R14,CPSBLK          NO, BACK 1 BLOCK\n         B     CPDPRMX             RETURN +0\n        POINT  CPWDCB,CPWPOINT      \" \"   +4\n         BAL   R14,CPDRTN\n         ST    R1,CPWPOINT         KEEP CURRENT TTR\nCPRMRPR  LR    R3,R9               RETAIN START ADDRESS\n         XR    R4,R4\n         LA    R15,1               COUNT START AT 1\n         B     CPDPRD8\n         DROP  R9\nCPDPRD10 LPR   R6,R6               NUMBER OF NAMES FORWARD IN BLOCK\n         USING PDS2,R3\n         XR    R14,R14\nCPDPRD11 NI    PDS2INDC,PDS2LUSR   CLEAR ALIAS AND TTR FLAGS\n         IC    R14,PDS2INDC        PICK UP USER DATA LENGTH IN H-WORDS\n         SLL   R14,1               MULTIPLY BY 2\n         LA    R3,PDS2USRD(R14)    LOAD ADDRESS OF NEXT MEMBER NAME\n         BCT   R6,CPDPRD11\nCPDPRD12 MVC   CPWLOC,PDS2NAME     LOOKING FOR PARTICULAR MEMBER\n         OI    CPFUSW,CPRCSW       SET DIR. RECORD STILL IN\n         B     CPDSDCB\n         DROP  R3\nCPDPRMX  MVC   CPWLOC,=CL8' '      BACK TO TOP OF DIRECTORY\n         B     CPDRLC2\n         SPACE 1\n*- - - - COMPUTE SCROLL AMOUNT ROUTINE\n*              R14 = LINK REGSITER / RETURN +0 = MAX.\n*                                           +4 = OK (R6 = AMOUNT)\nCPCSAR   ST    R14,CPWSR14\n         CLI   0(R4),0             COMMAND LINE ENTERED?\n         BE    CPCSARDF            NOPE\n         TM    CDSCF1-1(R4),INFMOD YES, COMMAND ENRERED?\n         BZ    CPCSARDF            NO, JUST BUMP DEFAULT\n         LA    R0,L'CDSCF1-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   CDSCF1(R4),C' '\n         BNE   *+L'*+14\n         MVC   CDSCF1(L'CDSCF1-1,R4),CDSCF1+1(R4)\n         MVI   CDSCF1+L'CDSCF1-1(R4),C' '\n         BCT   R0,*-18\n         CLI   CDSCF1(R4),C' '     COMMAND ENTERED?\n         BE    CPCSARDF            NO, JUST BUMP DEFAULT\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         TM    CPFUSW,CPUPSW       UP REQUESTED?\n         BO    CPCSARUP            YES\n         CLI   0(R2),X'F8'         IS IT PF8?\n         BE    CPCSARSC            YES\n         CLI   0(R2),X'C8'         IS IT PF20?\n         BE    CPCSARSC            YES\n         MVC   CPWDBLW(7),=CL8' '\n         OC    CPWDBLW(7),CDSCF1(R4)\n         CLC   CPWDBLW(5),=CL5'DOWN' IS IT \"DOWN\"?\n         BNE   *+L'*+12            NO\n         LA    R4,5(R4)            YES, SEE FORWARD\n         SH    R0,=H'5'\n         B     CPCSARTV\n         CLC   CPWDBLW(2),=CL2'D'  IS IT \"DOWN\"?\n         BE    *+L'*+10            YES\n         CLC   CPWDBLW(2),=CL2'+'  IS IT \"DOWN\"?\n         BNE   CPDINVC             NO, INVALID COMMAND\n         LA    R4,2(R4)            YES, SEE FORWARD\n         SH    R0,=H'2'\n         B     CPCSARTV\nCPCSARUP CLI   0(R2),X'F7'         IS IT PF7?\n         BE    CPCSARSC            YES\n         CLI   0(R2),X'C7'         IS IT PF19?\n         BE    CPCSARSC            YES\n         MVC   CPWDBLW(7),=CL8' '\n         OC    CPWDBLW(7),CDSCF1(R4)\n         CLC   CPWDBLW(3),=CL3'UP' IS IT \"UP\"?\n         BNE   *+L'*+12            NO\n         LA    R4,3(R4)            YES, SEE FORWARD\n         SH    R0,=H'3'\n         B     CPCSARTV\n         CLC   CPWDBLW(2),=CL2'U'  IS IT \"UP\"?\n         BE    *+L'*+10            YES\n         CLC   CPWDBLW(2),=CL2'-'  IS IT \"UP\"?\n         BNE   CPDINVC             NO, INVALID COMMAND\n         LA    R4,2(R4)            YES, SEE FORWARD\n         SH    R0,=H'2'\nCPCSARTV BNP   CPCSARDF            NO MORE, JUST BUMP DEFAULT\n         CLI   CDSCF1(R4),C' '\n         BNE   CPCSARSC\n         LA    R4,1(R4)\n         BCT   R0,*-12\n         B     CPCSARDF            NONE, JUST BUMP DEFAULT\nCPCSARSC MVI   CPWDBLW,C' '\n         OC    CPWDBLW(1),CDSCF1(R4)\n         CLI   CPWDBLW,C'M'        SCROLL \"MAX\"?\n         BNE   *+L'*+6             NO\n         L     R14,CPWSR14         YES\n         BR    R14\n         CLI   CDSCF1(R4),C'0'     IF NOT NUMERIC?\n         BL    CPCSARDF            JUST BUMP DEFAULT\n         LA    R14,CDSCF1(,R4)     SET START OF FIELD\n         LA    R15,6               MAXIMUM LENGTH\n         CLR   R15,R0\n         BNL   *+L'*+2\n         LR    R15,R0\n         XR    R1,R1               COUNTER\n         CLI   0(R14),C'0'         IF NOT NUMERIC\n         BL    *+L'*+12\n         LA    R1,1(,R1)           BUMP COUNTER\n         LA    R14,1(,R14)         BUMP POINTER\n         BCT   R15,*-16\n         LTR   R1,R1               IF LENGTH IS ZERO?\n         BZ    CPCSARDF            JUST BUMP DEFAULT\n         BCT   R1,*+L'*+6          SUBTRACT 1 FOR EXECUTED PACK\n         PACK  CPWDBLW,CDSCF1(*-*,R4) <<EXECUTED>>\n         EX    R1,*-6              PACK IT IN CPWDBLW\n         CVB   R0,CPWDBLW          PUT VALUE IN R0\n         B     CPCSARXQ\nCPCSARDF LH    R0,CPSCROLL         MOVE DOWN THE SCREEN\n         TM    CPFUSW,CPCRSW       CURSOR?\n         BZ    CPCSARHF            NO\n         L     R14,TERMINPT        PICK UP AID/ROW/COL ADDRESS\n         XR    R15,R15\n         IC    R15,1(R14)          GET ROW NUMBER\n         SH    R15,=Y(CPDLST)\n         BNP   CPCSARXQ\n         TM    CPFUSW,CPUPSW       UP REQUESTED?\n         BO    *+L'*+6             YES\n         LR    R0,R15              NO, DOWN\n         B     CPCSARXQ\n         BCTR  R0,0\n         SR    R0,R15\n         B     CPCSARXQ\nCPCSARHF TM    CPFUSW,CPHLSW       HALF PAGE\n         BZ    CPCSARXQ            NO\n         SRL   R0,1                YES\nCPCSARXQ LTR   R6,R0\n         BNP   CPDRCL              NONE, RE-DISPLAY\n         L     R14,CPWSR14\n         B     4(R14)\n         SPACE 1\n*- - - - BACK 1 BLOCK TTR OF DIRECTORY ADDRESS COMPUTATION ROUTINE\n*              R14 = LINK REGISTER / RETURN +0 = TOP OF DIRECTORY\n*                                           +4 = OK, DONE\nCPSBLK   XR    R1,R1\n         CLI   CPWPOINT+2,1        AM I ON BLOCK 1?\n         BE    CPSTRK              YES, JUST SUBTRACT FROM TRACK\n         IC    R1,CPWPOINT+2       NO, PICK UP TRACK NUMBER\n         BCTR  R1,0                SUBTRACT 1\n         STC   R1,CPWPOINT+2\n         B     4(R14)\nCPSTRK   ICM   R1,B'0011',CPWPOINT AM I ON TRACK 0?\n         BZR   R14                 GO POINT TO TOP OF DIRECTORY\n         BCTR  R1,0                SUBTRACT 1\n         STCM  R1,B'0011',CPWPOINT PREVIOUS TRACK\n         MVC   CPWPOINT+2(1),CPWNOTE POINT TO LAST BLOCK OF TRACK\n         B     4(R14)\n         SPACE 1\n*- - - - MEMBER SELECTION DONE\nCPDXBK   OI    CPFUSW,CPXBCK\nCPDXRQ   OI    CPFUSW,CPXREQ\nCPDFND   TM    CPWDCB+DCBOFLGS-IHADCB,DCBOFOPN\n         BZ    CPDNTO\n         MVI   OPCLPL,VLB          SET \"VL\" BIT\n        CLOSE  (CPWDCB),MF=(E,OPCLPL)\nCPDNTO   L     R7,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R7\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R7\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME,N#UT1        DD-NAME\n         DROP  R7\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15\n         BZ    CPDFRF\n        XMESS  2006\n         TM    CPFUSW,CPXREQ       EXIT REQUESTED?\n         BO    CPDEXIT             YES, ALL DONE (MESSAGE STILL SET)\n         LA    R1,*+L'*+8\nCPDSMS   ST    R1,MSGADD\n         B     CPDEXIT             YUP - ALL DONE\n         MSG   'FREE \"DIR\" FAILED',H=Y\nCPDFRF   TM    CPFUSW,CPXREQ       EXIT OR BACK REQUESTED?\n         BZ    CPLBSQ              NO\n         TM    CPFUSW,CPXBCK       YES, BACK REQUESTED?\n         BO    EDXBLD              YES, GO BACK\n         B     CPDEXIT             ELSE ALL DONE (MESSAGE STILL SET)\n*- - - - ALLOCATE THE FILE TO DO THE COPY\nCPLBSQ   L     R7,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R7\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R7\n         MVC   DDNAME,N#UT1        DD-NAME\n         MVC   DSNAME,CPWDSN       DS-NAME\n         MVC   DSMEMBER,CPWMEM     MEMBER NAME (IF PO)\n         MVC   DSVOLSER,CPWVOL     VOL-SER\n         MVC   PASSWORD,CPWPSW     PASSWORD\n         MVC   DSSTATUS,=CL8'SHR'  SET DISP=SHR\n         MVC   DSUNIT,=CL8'SYSALLDA'\n         DROP  R7\n         MVC   CPWDCB(SKCDCBL),SKCDCB MOVE DCB SKELETON\n         MVC   CPWDCB+DCBDDNAM-IHADCB(L'DCBDDNAM),N#UT1 SET DD-NAME\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    CPOKAC              OK\n        XMESS  2007\n         LA    R1,*+L'*+4\n         B     CPRSMS\n         MSG   'ALLOC \"CPY\" FAILED',H=Y\nCPOKAC   LA    R1,CPREOF\n         STCM  R1,B'0111',CPWDCB+DCBEODA-IHADCB\n         LA    R1,CPRSYNA\n         STCM  R1,B'0111',CPWDCB+DCBSYNA-IHADCB\n         NI    CPFLSW,255-CPWSYFLG\n         MVI   OPCLPL,VLB          SET \"VL\" BIT\n        OPEN   (CPWDCB,(INPUT)),MF=(E,OPCLPL)\n         TM    CPWDCB+DCBOFLGS-IHADCB,DCBOFOPN GOOD OPEN?\n         BO    CPRCRD              YES\n         OI    CPFUSW,CPXREQ\n         LA    R1,*+L'*+8\n         ST    R1,MSGADD\n         B     CPRNTO              YUP - ALL DONE\n         MSG   'OPEN \"CPY\" FAILED',H=Y\nCPRCRD   L     R2,EDTPOOL          READ DATA IN FREE POOL\n         XR    R3,R3\n         LA    R4,1\n         LR    R5,R4\n         TM    EDFSSW,EDDTSW       LOOK IF ASIS DATA\n         BZ    CPRLOOP\n         OI    CPFLSW,CPWASFLG\nCPRLOOP  CL    R4,EDTGASL          CAN BE HANDLED?\n         BNH   CPRGCRD             YES\n         STM   R14,R6,VUSWA        NO, SAVE REGISTERS\n         L     R6,EDTGASL          DO ACTUAL TOTAL OF CARDS\n         A     R6,EDTNOWL\n         L     R4,=A($#L)          THRESHOLD LIMIT\n         CLR   R6,R4               CAN I ACCEPT MORE?\n         BNL   CPROVFL             NO MORE SPACE\n*- - - - TRY OBTAIN MORE SPACE FOR DATA RECORDS\n         LM    R2,R3,=A($#BN,$#BS)\n        GETMAIN RC,LV=(R3)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    CPGMOK              OK\n        XMESS  2013,R15            ERROR\n         LA    R1,*+L'*+4\n         B     CPROVFL+L'CPROVFL   STOP HERE, GO BACK\n         MSG   'GETMAIN(C) FAILED',H=Y\nCPGMOK   LR    R5,R1               RETAIN ADDRESS\n         LR    R0,R5\n         LR    R1,R3\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R0,R14              CLEAR ALL TO BINARY ZEROS\n         L     R14,EDTMAIN         1ST DATA GETMAINED AREA\n         ICM   R15,B'1111',0(R14)  END OF AREAS CHAINING?\n         BZ    *+L'*+6             YES\n         LR    R14,R15             NO\n         B     *-10                LOOP TO NEXT\n         ST    R5,0(R14)           GETMAIN ADDRESS CHAIN\n         ST    R3,4(R14)           GETMAIN LENGTH\n         AR    R6,R2               DO NEW TOTAL OF CARDS\n         CLR   R6,R4               THRESHOLD, CAN I ACCEPT IT?\n         BNH   *+L'*+4             YES\n         SR    R6,R4               NO, REDUCE\n         SR    R2,R6\n         L     R1,EDTGASL\n         AR    R1,R2\n         ST    R1,EDTGASL          NEW NUMBER OF GAS CARDS\n         LA    R5,8(R5)            BUILD FREE POOL CHAIN\n         LR    R3,R5\nCPBFPL   LA    R1,XLNG(R3)\n         BCT   R2,*+L'*+4\n         B     *+L'*+10\n         ST    R1,NPTR(R3)\n         LR    R3,R1\n         B     CPBFPL\n         ST    R5,VUSWA+16         SET NEW R2\n         LM    R14,R6,VUSWA        RESTORE REGISTERS\n         ST    R2,NPTR(R3)         ADD TO FREE POOL CHAIN\nCPRGCRD GET    CPWDCB,(R2)\n         TM    CPFLSW,CPWSYFLG     WAS SYNAD EXIT TAKEN?\n         BZ    *+L'*+8             NO, BRANCH\n         LA    R1,CPWMSG           YES, ERROR\n         B     CPROVFL+L'CPROVFL   STOP HERE, GO BACK\n         ST    R3,PPTR(R2)\n         XC    LCMF(L'LCMF,R2),LCMF(R2)\n         LR    R3,R2\n         L     R2,NPTR(R3)\n         AR    R4,R5\n         TM    CPFLSW,CPWASFLG     LOOK IF ASIS DATA\n         BO    CPRLOOP\n         MVI   CPWCARD,C' '\n         MVC   CPWCARD+1(L'CDTA-1),CPWCARD\n         OC    CPWCARD(L'CDTA),CDTA(R3)\n         CLC   CPWCARD(L'CDTA),CDTA(R3)\n         BE    CPRLOOP\n         OI    CPFLSW,CPWASFLG     SET ASIS DATA\n         B     CPRLOOP\nCPREOF   SR    R4,R5               NOW SET DATA IN EDIT FILE\n         BNP   CPRCLF              NONE ... GO CLOSE\n         L     R15,EDTGASL         UPDATE FREE COUNT\n         SR    R15,R4\n         ST    R15,EDTGASL\n         L     R15,EDTNOWL         UPDATE NUMBER OF CARDS\n         AR    R15,R4\n         ST    R15,EDTNOWL\n         L     R2,EDTPOOL          ADDRESS OF START DATA\n         MVC   EDTPOOL,NPTR(R3)    NEW FREE POOL START\n         L     R4,EDTABLOC         GET AFTER/BEFORE LOCATION\n         CLC   LCMF(L'LCMF,R4),=CL2'B' COPY WHERE?\n         BE    CPDBFR              BRANCH IF BEFORE\n         ICM   R1,B'1111',NPTR(R4) ELSE IT IS AFTER\n         BNZ   *+L'*+8\n         ST    R3,EDTLAST\n         B     *+L'*+4\n         ST    R3,PPTR(R1)\n         ST    R1,NPTR(R3)\n         ST    R2,NPTR(R4)\n         ST    R4,PPTR(R2)\n         LR    R0,R4               SET CURRENT POINTER\n         B     CPSTCP\nCPDBFR   ICM   R1,B'1111',PPTR(R4)\n         BNZ   *+L'*+10\n         ST    R2,EDTFIRST\n         LR    R0,R2               SET CURRENT POINTER\n         B     *+L'*+6\n         ST    R2,NPTR(R1)\n         LR    R0,R1               SET CURRENT POINTER\n         ST    R1,PPTR(R2)\n         ST    R3,PPTR(R4)\n         ST    R4,NPTR(R3)\nCPSTCP   ST    R0,EDTCURR          UPDATE CURRENT POINTER\n         OI    EDFSSW,SVDTSW       SAY DATA CHANGED\n         TM    CPFLSW,CPWASFLG     ASIS DATA?\n         BZ    CPRCLF              NO, GO CLOSE\n         OI    EDFSSW,EDDTSW       YES, SET ASIS DATA\n         OI    EDFUSW,EDASSW       SET ASIS\n         B     CPRCLF              GO CLOSE\nCPROVFL  LA    R1,*+L'*+12\n         ST    R1,MSGADD\n         OI    CPFUSW,CPXREQ\n         B     CPRCLF              YUP - ALL DONE\n         MSG   'YUP, SPACE SHORTAGE',H=Y\nCPRCLF   MVI   OPCLPL,VLB          SET \"VL\" BIT\n        CLOSE  (CPWDCB),MF=(E,OPCLPL)\nCPRNTO   L     R7,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R7\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R7\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME,N#UT1        DD-NAME\n         DROP  R7\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15\n         BZ    CPDEXIT\n        XMESS  2008\n         TM    CPFUSW,CPXREQ       EXIT REQUESTED?\n         BO    CPDEXIT             YES, ALL DONE (MESSAGE STILL SET)\n         LA    R1,*+L'*+8\nCPRSMS   ST    R1,MSGADD\n         B     CPDEXIT             YUP - ALL DONE\n         MSG   'FREE \"CPY\" FAILED',H=Y\nCPDEXIT  LM    R11,R12,CPSVRS      RESTORE R11-R12\n         DROP  R11,R12\n         USING ETPSEDIT,R12,R11\n         L     R0,CPWKLN           LENGTH\n        FREEMAIN R,LV=(0),A=(R8)\nCPLEAVE  L     R1,EDTABLOC         GET AFTER/BEFORE LOCATION\n         XC    LCMF(L'LCMF,R1),LCMF(R1)\n         XC    EDTABLOC,EDTABLOC\n         NI    EDFUSW,255-EXTCPY   RESET COPY REQUEST\n         NI    EDPNSW,255-AFBESW   RESET A/B PENDING\n         XC    EDADDR,EDADDR       FORCE DEFAULT\n         LA    R14,GOBACK          SET RETURN ADDRESS\n         TM    EDFSSW,SVDTSW       DATA CHANGED?\n         BZR   R14                 NO, RESHOW THE SCREEN\n         B     EDRNRTN             ELSE RENUMBER BEFORE\n         DROP  R11,R12\n         SPACE 1\n         USING EDXCPY,R11,R12\n*------- SYNAD EXITS - ENTERED DURING THE I/O IF AN ERROR OCCURS.\n         CNOP  0,4\nCPDSYNA SYNADAF ACSMETH=BSAM\n         MVI   CPWMSG,15\n         MVC   CPWMSG+1(15),91(R1) ERROR DESCRIPTION ONLY\n         OI    CPFLSW,CPWSYFLG\n        SYNADRLS\n         BR    R14\n         CNOP  0,4\nCPRSYNA SYNADAF ACSMETH=QSAM\n         MVI   CPWMSG,15\n         MVC   CPWMSG+1(15),91(R1) ERROR DESCRIPTION ONLY\n         OI    CPFLSW,CPWSYFLG\n        SYNADRLS\n         BR    R14\n         SPACE 1\nCTCMLST CAMLST NAME,*-*,,*-*\nCTCMLSL  EQU   *-CTCMLST\nVTCMLST CAMLST SEARCH,*-*,*-*,*-*\nVTCMLSL  EQU   *-VTCMLST\nBADEDORG MSG   'BAD DSORG'\nBADED80  MSG   'LRECL NOT 80'\nXBADDSN  MSG   'DS-NAME ERROR'\nBADCTLOC MSG   'LOCATE FAILED'\nBADVTOBT MSG   'OBTAIN FAILED'\nXINVPFK  MSG   'INVALID PF-KEY'\nXDUMMY   DC    AL1(XDUMMYL-1),X'04',CL9' '\nXDUMMYL  EQU   *-XDUMMY\n         SPACE 1\nSKDDCB  DCB    DSORG=PS,MACRF=RP,DDNAME=DUMMY,RECFM=F,                 X\n               LRECL=256,BLKSIZE=256,KEYLEN=8,EODAD=*-*,SYNAD=*-*\nSKDDCBL  EQU   *-SKDDCB\n        READ   CPWDECB,SF,*-*,*-*,'S',MF=L\nSKCDCB  DCB    DSORG=PS,MACRF=GM,DDNAME=DUMMY,EODAD=*-*,SYNAD=*-*\nSKCDCBL  EQU   *-SKCDCB\n         SPACE 1\n*- - - - DIRECTORY LIST FORMAT\n*        THIS IS THE FORMAT FOR A PDS LIBRARY DIRECTORY LISTING\nCPWROW1  DC    AL1(CPWROW1L-1),XL1'05'\n         DC    CL27'EDIT - COPY SELECTION FROM '\nCPWDSNAM EQU   *-CPWROW1\n         DC    52CL1'-'\nCPWROW1L EQU   *-CPWROW1\nCPDRSC   EQU   01                  CURSOR ROW ON LINE BELOW\nCPZE     EQU   (CPDRSC+1)*4        \"TERMINPT\" DISPLACEMENT\nCPWROW2  DC    AL1(CPWROW2L-1)\n         DC    XL1'05',CL12'COMMAND ===>'\nCCDRSC   EQU   *-CPWROW2           CURSOR COLUMN ON FIELD BELOW\nCDSCF1   EQU   (*-CPWROW2)+1,46    INPUT FIELD 1\n         DC    XL1'01',CL46' '\n         DC    XL1'05',CL11'< SCROLL =>'\nCDSCF2   EQU   (*-CPWROW2)+1,4     INPUT FIELD 2\n         DC    XL1'01',CL4' ',XL1'05',CL1'<',XL1'04'\nCPWROW2L EQU   *-CPWROW2\nCPWROW3  DC    AL1(CPWROW3L-1)\n         DC    XL1'05',CL26'    NAME                  '\n         DC    C'VV.MM CREATED   CHANGED         SIZE  ID '\nCPWROW3L EQU   *-CPWROW3\nCPWROW4  DC    AL1(CPWROW4L-1)\n         DC    XL1'05',CL26'    --------              '\n         DC    C'----- -------   -------         ----  ------- '\nCPWROW4L EQU   *-CPWROW4\nCPDLST   EQU   04                  DIRECTORY LIST LINE NUMBER\nCPZN     EQU   (CPDLST+1)*4        \"TERMINPT\" DISPLACEMENT\nCPWLIST  DC    AL1(CPWELEN-1)\nCCDLST   EQU   *-CPWLIST           CURSOR COLUMN ON FIELD BELOW\nCPSLF1   EQU   (*-CPWLIST)+1,1     INPUT FIELD 1 - SEL.CODE\n         DC    XL1'01',CL1' '\nCPSLF2   EQU   (*-CPWLIST)+3,8     DISPLAY FIELD 2 - NAME\n         DC    XL1'04',CL12' '\n         DC    XL1'04',CL60' '\nCPWELEN  EQU   *-CPWLIST\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R8,R10,R11,R12,R13\n         EJECT\n*------- SPF STATISTICS ---------------------------------------------*\n         CNOP  0,4\n         USING *,R12\nSPFSTOW  STM   R14,R12,12(R13)     SAVE INPUT REGISTERS\n         LR    R12,R15             SET BASE REGISTER\n         USING SAVE3,R13\n         XC    VUSWA,VUSWA         CLEAR ALL TO BINARY ZEROS\n         LA    R11,VUSWA\n         DROP  R13\n         USING STOWSAVE,R11\n         ST    R13,4(R11)          STORE BACKWARD POINTER\n         ST    R11,8(R13)          STORE FORWARD POINTER\n         LR    R13,R11\n         LM    R2,R5,0(R1)         R2=ADDRESS OF OPEN DIRECTORY DCB\n         L     R3,0(,R3)           R3=NUMBER OF CARDS\n*                                  R4=ADDRESS OF USERID\n*                                  R5=ADDRESS OF MEMBER NAME\n         MVC   BLDLENT(4),=AL2(1,BLDLLEN)\n         MVC   MEMNAME(8),0(R5)    MOVE THE MEMBER NAME\n         XC    TTRC(L'TTRC+L'STALIAS),TTRC\n         MVI   SPFVR,C' '\n         MVC   SPFVR+1(SPFLLEN+L'BLDLPAD-1),SPFVR\n        BLDL   (R2),BLDLENT\n         LTR   R15,R15\n         BZ    *+L'*+2\n         DC    H'0'                YUP, TAKE AN S0C1 <------------ DUMP\n         MVC   SPFVR(SPFLLEN),SPFVR+2 SKIP BLDL JUNK\n         CLI   STALIAS,X'0F'\n         BNE   NOTASPF\n         XR    R15,R15\n         IC    R15,SPFMD\n         LA    R15,1(R15)\n         STC   R15,SPFMD\n         B     ITSASPF\nNOTASPF  MVC   SPFVR(5),=XL5'0100000000'\n         MVI   STALIAS,X'0F'\nITSASPF  MVI   SPFUS+7,C' '\n         MVC   SPFUS(7),0(R4)      USERID\n        TIME   ,                   R0 = HHMMSSTH / R1 = 0CYYDDDF\n         STCM  R1,B'0111',SPFMDT\n         CLC   SPFCDT(3),=CL3' '\n         BNE   *+L'*+4\n         STCM  R1,B'0111',SPFCDT\n         STCM  R0,B'1100',SPFMDTM\n         STCM  R3,B'0011',SPFSZ\n         CLC   SPFSZI(2),=CL3' '\n         BNE   *+L'*+4\n         STCM  R3,B'0011',SPFSZI\n        STOW   (R2),MEMNAME,R\n         L     R13,4(,R13)         PICK UP CALLING SAVE-AREA\n         LM    R14,R12,12(R13)     RESTORE INPUT REGISTERS\n         XR    R15,R15             SET RC=0\n         BR    R14                 RETURN\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R11,R12\n         AIF   ('&TXV' NE 'YES').SKVPC2\n         EJECT\n*------- VERIFY CHAINING (BACKWARD-FORWARD POINTERS) ----------------*\n*        USEFULL TO DEBUG A NEW IMPLEMENTED COMMAND OR LINE COMMAND\n*        WHEN YOU ARE TESTING IT IN TSO.\n*        YOU HAVE JUST TO ALLOCATE A \"SYSSNAP\" DD AND THE \"XSNAP\"\n*        WILL BE ACTIVE IN CASE OF A CHAINING ERROR.\n*              R14 = LINK REGISTER\n*              R15 = ENTRY ADDRESS (BASE REGISTER)\n*              R0 = AT EXIT : 0 - OK\n*                             4 - ERROR / \"EDDBLW\" SET (SEE NOTE BELOW)\n*              NOTE - \"EDDBLW\" DOUBLE-WORD FIELD SETTING DESCRIPTION :\n*                     BYTES 0-7 = ALL ZEROES : THE INITIAL \"PPTR\" IS\n*                                              NOT ZERO\n*                     BYTE 0 = FF : \"EDTNOWL\" IS NOT ZERO\n*                     BYTE 1 = FF : \"EDTNOWL\" COUNT ERROR\n*                     BYTE 2 = FF : \"EDTLAST\" IS NOT ZERO\n*                     BYTE 3 = FF : \"EDTLAST\" POINTER ERROR\n*                     BYTES 4-7 = ADDRESS OF ERROR (THE NEXT \"PPTR\"\n*                                 DOES NOT MATCH THIS ADDRESS)\n         CNOP  0,4\n         USING *,R15\nVERCHAIN STM   R1,R3,24(R13)       SAVE R1-R3\n         USING SPLTAREA,R10\n         XR    R0,R0               SET RC=0\n         XR    R1,R1               SET COUNT TO ZERO\n         XC    EDDBLW,EDDBLW\n         ICM   R3,B'1111',EDTFIRST\n         BNZ   VERGO\n         CL    R0,EDTLAST\n         BE    *+L'*+8\n         MVI   EDDBLW+2,X'FF'\n         B     VERERRX\n         CL    R0,EDTNOWL\n         BE    VEREX\n         MVI   EDDBLW+0,X'FF'\n         B     VERERRX\nVERGO    LR    R2,R0\nVERLOOP  CL    R2,PPTR(R3)\n         BE    *+L'*+8\n         ST    R2,EDDBLW+4\n         B     VERERRX\n         LA    R1,1(R1)\n         LR    R2,R3\n         ICM   R3,B'1111',NPTR(R2)\n         BNZ   VERLOOP\n         CL    R2,EDTLAST\n         BE    *+L'*+8\n         MVI   EDDBLW+3,X'FF'\n         B     VERERRX\n         CL    R1,EDTNOWL\n         BE    VEREX\n         MVI   EDDBLW+1,X'FF'\nVERERRX  LA    R0,4\nVEREX    LM    R1,R3,24(R13)       RESTORE R1-R3\n         BR    R14                 RETURN\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R10\n.SKVPC2  EJECT\n*- - - - TRANSLATE TABLES\nASIST    DC    64X'4B',X'40',9X'4B'\n         DC    X'4A4B4C4D4E4F'     CENT,PERIOD,LESS,LPAREN,PLUS,BAR\n         DC    X'50',9X'4B'        AMPERSAND\n         DC    X'5A5B5C5D5E5F'     EXCL,$,DOT,RPAREN,SEMI,NOT\n         DC    X'6061',8X'4B'      HYPHEN,SLASH\n         DC    X'6A6B6C6D6E6F'     WHAT,COMMA,PERCENT,UNDLN,GT,QM\n         DC    9X'4B',X'79'\n         DC    X'7A7B7C7D7E7F'     COLON,POUND,AT,QUOTE,EQ,DBLQUOTE\n         DC    X'4B',X'818283848586878889',6X'4B'\n         DC    X'4B',X'919293949596979899',6X'4B'\n         DC    X'4B',X'A1A2A3A4A5A6A7A8A9',6X'4B'\n         DC    16X'4B'\n         DC    X'C0',C'ABCDEFGHI',6X'4B'\n         DC    X'D0',C'JKLMNOPQR',6X'4B'\n         DC    X'E0',X'4B',C'STUVWXYZ',6X'4B'\n         DC    C'0123456789',6X'4B'\nCAPST    DC    64X'4B',X'40',9X'4B'\n         DC    X'4A4B4C4D4E4F'     CENT,PERIOD,LESS,LPAREN,PLUS,BAR\n         DC    X'50',9X'4B'        AMPERSAND\n         DC    X'5A5B5C5D5E5F'     EXCL,$,DOT,RPAREN,SEMI,NOT\n         DC    X'6061',8X'4B'      HYPHEN,SLASH\n         DC    X'6A6B6C6D6E6F'     WHAT,COMMA,PERCENT,UNDLN,GT,QM\n         DC    9X'4B',X'79'\n         DC    X'7A7B7C7D7E7F'     COLON,POUND,AT,QUOTE,EQ,DBLQUOTE\n         DC    X'4B',C'ABCDEFGHI',6X'4B'\n         DC    X'4B',C'JKLMNOPQR',6X'4B'\n         DC    2X'4B',C'STUVWXYZ',6X'4B'\n         DC    16X'4B'\n         DC    X'C0',C'ABCDEFGHI',6X'4B'\n         DC    X'D0',C'JKLMNOPQR',6X'4B'\n         DC    X'E0',X'4B',C'STUVWXYZ',6X'4B'\n         DC    C'0123456789',6X'4B'\n         EJECT\n*- - - - EDIT INTERFACE HELP SCREEN\n         CNOP  0,4\nEDTHELP  DC    A(EDTHL1)\n         DC    A(EDTENT)\n         DC    A(EDTHL2)\n         DC    A(EDTHL3)\n         DC    A(EDTHL4)\n         DC    A(EDTHL5)\n         DC    A(EDTHL6)\n         DC    A(EDTHL7)\n         DC    A(EDTBLK)\n         DC    A(EDTHL8)\n         DC    A(EDTHL9)\n         DC    A(EDTHL10)\n         DC    A(EDTHL11)\n         DC    A(EDTHL12)\n         DC    A(EDTHL13)\n         DC    A(EDTBLK)\n         DC    A(EDTHL14)\n         DC    A(EDTHL15)\n         DC    A(EML+EDTHL16)\n         SPACE 1\nEDTHL1   DC    AL1(EDTHL1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL16' EDIT INTERFACE ',53CL1'-'\nEDTHL1L  EQU   *-EDTHL1\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\nEDTHL2   DC    AL1(EDTHL2L-1),XL1'05'\n         DC    C'COMMANDS ARE :'\nEDTHL2L  EQU   *-EDTHL2\nEDTHL3   DC    AL1(EDTHL3L-1),XL1'05'\n         DC    C' SAVE=SAVE NO END     / SAVEND=SAVE END      / END=SAVX\n               E END'\nEDTHL3L  EQU   *-EDTHL3\nEDTHL4   DC    AL1(EDTHL4L-1),XL1'05'\n         DC    C' CAN=NO SAVE END      / SUB=SUBMIT (IF JES2) / I=INPUTX\n                (ONLY WHEN FILE EMPTY)'\nEDTHL4L  EQU   *-EDTHL4\nEDTHL5   DC    AL1(EDTHL5L-1),XL1'05'\n         DC    C' F=FIND               / C=CHANGE             / ?=W=WHEX\n               RE (PENDING RETRIEVE)'\nEDTHL5L  EQU   *-EDTHL5\nEDTHL6   DC    AL1(EDTHL6L-1),XL1'05'\n         DC    C' UP, U OR -           / DOWN, D OR +         (FOLLOWEDX\n                BY \"M\" OR A NUMBER)'\nEDTHL6L  EQU   *-EDTHL6\nEDTHL7   DC    AL1(EDTHL7L-1),XL1'05'\n         DC    C' COPY                 (USED WITH AFTER/BEFORE)'\nEDTHL7L  EQU   *-EDTHL7\nEDTHL8   DC    AL1(EDTHL8L-1),XL1'05'\n         DC    C'LINE PREFIX COMMANDS ARE :'\nEDTHL8L  EQU   *-EDTHL8\nEDTHL9   DC    AL1(EDTHL9L-1),XL1'05'\n         DC    C' I=INSERT A BLANK LINE IMMEDIATELY AFTER THIS ONE'\nEDTHL9L  EQU   *-EDTHL9\nEDTHL10  DC    AL1(EDTHL10L-1),XL1'05'\n         DC    C' C/CC=COPY LINE(S)    / M/MM=MOVE LINE(S)'\nEDTHL10L EQU   *-EDTHL10\nEDTHL11  DC    AL1(EDTHL11L-1),XL1'05'\n         DC    C' D/DD=DELETE LINE(S)  / R/RR=REPEAT LINE(S)'\nEDTHL11L EQU   *-EDTHL11\nEDTHL12  DC    AL1(EDTHL12L-1),XL1'05'\n         DC    C' A=AFTER / B=BEFORE  (USED WITH COPY/C/CC/M/MM)'\nEDTHL12L EQU   *-EDTHL12\nEDTHL13  DC    AL1(EDTHL13L-1),XL1'05'\n         DC    C'REMARK : C, CC, M, MM, DD AND RR ARE MUTUALLY EXCLUSIVX\n               E LINE COMMANDS'\nEDTHL13L EQU   *-EDTHL13\nEDTHL14  DC    AL1(EDTHL14L-1),XL1'05'\n         DC    C'SCROLL : P(AGE) BY DEFAULT, H(ALF) OR C(SR)'\nEDTHL14L EQU   *-EDTHL14\nEDTHL15  DC    AL1(EDTHL15L-1),XL1'05'\n         DC    C'PFK''S : 3-4=END, 5=FIND, 6=CHANGE, 7=UP AND 8=DOWN'\nEDTHL15L EQU   *-EDTHL15\nEDTHL16  DC    AL1(EDTHL16L-1),XL1'05'\n         DC    C'        12=RESET (RESHOW/RESTORE PREVIOUS SCREEN WITH X\n               CURSOR AT COMMAND LINE)'\nEDTHL16L EQU   *-EDTHL16\nEDTENT   DC    AL1(EDTENTL-1),XL1'01',CL1' ',XL1'05',CL7' '\nEDTENTL  EQU   *-EDTENT\nEDTBLK   DC    AL1(EDTBLKL-1),XL1'05',CL9' '\nEDTBLKL  EQU   *-EDTBLK\n         EJECT\n*- - - - EDIT - COPY ENTRY SCREEN\n         CNOP  0,4\nCPYSCR   DC    A(CPROW1)\n         DC    A(CPROW2)\nCRCPSC   EQU   (*-CPYSCR)/4        CURSOR ROW ON LINE BELOW\nZCP1     EQU   (*-CPYSCR)+4        \"TERMINPT\" DISPLACEMENT\n         DC    A(CPROW3)\nZCP2     EQU   (*-CPYSCR)+4        \"TERMINPT\" DISPLACEMENT\n         DC    A(CPROW4)\n         DC    A(EDTBLK)\nZCP3     EQU   (*-CPYSCR)+4        \"TERMINPT\" DISPLACEMENT\n         DC    A(EML+CPROW5)\n         SPACE 1\nCPROW1   DC    AL1(CPROW1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL25' EDIT - COPY ENTRY PANEL ',44CL1'-'\nCPROW1L  EQU   *-CPROW1\nCPROW2   DC    AL1(CPROW2L-1)\n         DC    XL1'05',CL30'ENTER/VERIFY PARAMETERS BELOW:'\n         DC    XL1'04',CL1' '\nCPROW2L  EQU   *-CPROW2\nCPROW3   DC    AL1(CPROW3L-1)\nCPOFF1   EQU   (*-CPROW3)+1,10\n         DC    XL1'04',CL20'FULLY-QUALIFIED NAME',XL1'05',CL3'==>'\nCCCPSC   EQU   (*-CPROW3)          CURSOR COLUMN ON FIELD BELOW\nCPSCF1   EQU   (*-CPROW3)+1,54     INPUT FIELD 1\n         DC    XL1'02',CL54' '\nCPROW3L  EQU   *-CPROW3\nCPROW4   DC    AL1(CPROW4L-1)\nCPOFF2   EQU   (*-CPROW4)+10,13\n         DC    XL1'04',CL22'         VOLUME SERIAL'\n         DC    XL1'05',CL3'==>'\nCPSCF2   EQU   (*-CPROW4)+1,6      INPUT FIELD 2\n         DC    XL1'02',CL6' '\n         DC    XL1'04',CL45'          (IF NOT CATALOGED)'\nCPROW4L  EQU   *-CPROW4\nCPROW5   DC    AL1(CPROW5L-1)\nCPOFF3   EQU   (*-CPROW5)+6,17\n         DC    XL1'04',CL22'     DATA-SET PASSWORD'\n         DC    XL1'05',CL3'==>'\nCPSCF3   EQU   (*-CPROW5)+1,8      INPUT FIELD 3\n         DC    XL1'03',CL8' '      NO DISPLAY\n         DC    XL1'04',CL37'        (IF PASSWORD PROTECTED)'\nCPOFF4   EQU   (*-CPROW5)+1,3\n         DC    XL1'04',CL3'(N)',XL1'04',CL1' '\nCPROW5L  EQU   *-CPROW5\n         EJECT\n*- - - - EDIT - COPY ENTRY HELP SCREEN\n         CNOP  0,4\nCPYHLP   DC    A(CPYHL1)\n         DC    A(EDTENT)\n         DC    A(CPYHL2)\n         DC    A(CPYHL3)\n         DC    A(CPYHL4)\n         DC    A(EDTBLK)\n         DC    A(EML+CPYHL5)\n         SPACE 1\nCPYHL1   DC    AL1(CPYHL1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL25' EDIT - COPY ENTRY PANEL ',44CL1'-'\nCPYHL1L  EQU   *-CPYHL1\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\nCPYHL2   DC    AL1(CPYHL2L-1),XL1'05'\n         DC    C'THE EDIT COPY PANEL PROVIDES FOR ENTERING THE DATA-SETX\n                NAME, WHICH MUST BE A'\nCPYHL2L  EQU   *-CPYHL2\nCPYHL3   DC    AL1(CPYHL3L-1),XL1'05'\n         DC    C'    FULLY-QUALIFIED DS-NAME (NEVER DELIMITED BY QUOTESX\n               ).'\nCPYHL3L  EQU   *-CPYHL3\nCPYHL4   DC    AL1(CPYHL4L-1),XL1'05'\n         DC    C'    A SPECIFIC VOL-SER MAY ALSO BE ENTERED, AND A PASSX\n               WORD.'\nCPYHL4L  EQU   *-CPYHL4\nCPYHL5   DC    AL1(CPYHL5L-1),XL1'05'\n         DC    C'PF3 RETURNS TO THE EDIT ENTRY PANEL.'\nCPYHL5L  EQU   *-CPYHL5\n         EJECT\n*- - - - EDIT - COPY SELECTION HELP SCREEN\n         CNOP  0,4\nCPWHELP  DC    A(CPWHL1)\n         DC    A(EDTENT)\n         DC    A(CPWHL2)\n         DC    A(CPWHL3)\n         DC    A(EDTBLK)\n         DC    A(CPWHL4)\n         DC    A(CPWHL5)\n         DC    A(CPWHL6)\n         DC    A(CPWHL7)\n         DC    A(EDTBLK)\n         DC    A(CPWHL8)\n         DC    A(CPWHL9)\n         DC    A(EML+CPWHL10)\n         SPACE 1\nCPWHL1   DC    AL1(CPWHL1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL29' EDIT - COPY SELECTION PANEL ',40CL1'-'\nCPWHL1L  EQU   *-CPWHL1\nCPWHL2   DC    AL1(CPWHL2L-1),XL1'05'\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\n         DC    C'THE COPY SELECTION PANEL ALLOWS YOU TO SELECT THE PDS X\n               DATA-SET''S MEMBER-NAME'\nCPWHL2L  EQU   *-CPWHL2\nCPWHL3   DC    AL1(CPWHL3L-1),XL1'05'\n         DC    C'     YOU WANT COPY BY TYPING A \"S\" OR \"C\" IN FRONT OF X\n               THE DESIRED NAME.'\nCPWHL3L  EQU   *-CPWHL3\nCPWHL4   DC    AL1(CPWHL4L-1),XL1'05'\n         DC    C'COMMANDS ARE :'\nCPWHL4L  EQU   *-CPWHL4\nCPWHL5   DC    AL1(CPWHL5L-1),XL1'05'\n         DC    C' L(OCATE) OR F(IND) ... (MEMBER NAME OR MEMBER NAMES SX\n               TARTING BY THE CHARACTER'\nCPWHL5L  EQU    *-CPWHL5\nCPWHL6   DC    AL1(CPWHL6L-1),XL1'05'\n         DC    CL24' ',C'STRING ...)'\nCPWHL6L  EQU   *-CPWHL6\nCPWHL7   DC    AL1(CPWHL7L-1),XL1'05'\n         DC    C' UP, U OR -           / DOWN, D OR +         FOLLOWED X\n               BY \"M\" OR A NUMBER'\nCPWHL7L  EQU   *-CPWHL7\nCPWHL8   DC    AL1(CPWHL8L-1),XL1'05'\n         DC    C'SCROLL : P(AGE) BY DEFAULT, H(ALF) OR C(SR)'\nCPWHL8L  EQU   *-CPWHL8\nCPWHL9   DC    AL1(CPWHL9L-1),XL1'05'\n         DC    C'PFK''S : 7=UP AND 8=DOWN'\nCPWHL9L  EQU   *-CPWHL9\nCPWHL10  DC    AL1(CPWHL10L-1),XL1'05'\n         DC    C'        PF3 RETURNS TO THE EDIT COPY ENTRY PANEL.'\nCPWHL10L EQU   *-CPWHL10\n         EJECT\nCPWKAR   DSECT\nCPWKLN   DS    F                   COPY-WORK-AREA LENGTH\nCPSVRS   DS    2F                  SAVE R11-R12\nCPWDSN   DS    CL44\nCPWPSW   DS    CL8\nCPWVOL   DS    CL6\nCPWKSW   DS    XL1\nVLRFC    EQU   X'80'               VOLSER RETRIEVED FROM CATALOG\nPODS     EQU   X'01'               ON = DSORG IS PO\nCPWSLF   DS    CL1                 SELECT CODE = S OR C\nCPWDBLW  DS    D\nCPWDCB   DS    0F,XL(DCBLNGQS)     DCB WORK-AREA\nCPWPOINT DS    F                   TTR0 TO POINT A DIR. RECORD\nCPWNOTE  DS    XL1                 MAX. R OF TTR'S DIR. TRACK\nCPWTOP   DS    XL3                 TTR OF TOP SCREEN MEMBER NAME\nCPWBOT   DS    F                   TTR0 OF BOTTOM SCREEN MEMBER NAME\nCPWSR14  DS    F\nCPWMEM   DS    CL8                 SELECTION MEMBER NAME\nCPWFMEM  DS    CL8                 TOP SCREEN MEMBER NAME\nCPWLMEM  DS    CL8                 BOTTOM SCREEN MEMBER NAME\nCPWLOC   DS    CL8                 LOCATE MEMBER NAME\nCPSCROLL DS    H\nCPADDR   DS    XL2                 REQUESTED CURSOR (ROW,COLUMN)\n        READ   CPWDECBW,SF,*-*,*-*,'S',MF=L\nCPWDECBL EQU   *-CPWDECBW\nCPWCARD  DS    CL80\nCPWKEY   DS    CL8,XL256\nCPFLSW   DS    XL1                 TESTS\nCPWEOFLG EQU   X'80'                    ON = EOF ON \"CPY\" DIR.\nCPWSYFLG EQU   X'40'                    ON = ERROR ON \"CPY\" DIR.\nCPWASFLG EQU   X'01'                    ON = ASIS DATA IN \"CPY\" MEMBER\nCPFUSW   DS    XL1                 FUNCTIONS\nCPRCSW   EQU   X'80'                    DIR. RECORD STILL IN \"CPWKEY\"\nCPHLSW   EQU   X'40'                    ON = HALF, OFF = PAGE\nCPCRSW   EQU   X'20'                    ON = CURSOR, OFF = PAGE\nCPUPSW   EQU   X'10'                    ON = UP, OFF = DOWN\nCPXBCK   EQU   X'02'                    ON = BACK REQUESTED\nCPXREQ   EQU   X'01'                    ON = EXIT REQUESTED\nCPWMSG   DS    CL22\nCPWKARL  EQU   (((*-CPWKAR)+7)/8)*8\n         SPACE 1\nSTOWSAVE DSECT\n         DS    18F\nBLDLENT  DS    F\nMEMNAME  DS    CL8\nTTRC     DS    XL3\nSTALIAS  DS    XL1\nSPFVR    DS    XL1                 SPF USER DATA\nSPFMD    DS    XL1\n         DS    XL2\n         DS    XL1\nSPFCDT   DS    PL3\n         DS    XL1\nSPFMDT   DS    PL3\nSPFMDTM  DS    XL2\nSPFSZ    DS    XL2\nSPFSZI   DS    XL2\nSPFMD2   DS    XL2\nSPFUS    DS    CL7\n         DS    CL3\nSPFLLEN  EQU   *-SPFVR\nBLDLPAD  DS    XL14\nBLDLLEN  EQU   *-MEMNAME\nSTOWSVL  EQU   (((*-STOWSAVE)+7)/8)*8\nSTOWSVLT EQU   L'VUSWA-STOWSVL\n         DS    0XL(STOWSVLT)       \"STOWSVL\" VALIDITY CHECK\n         SPACE 1\n         PRINT &PRS\n        SPLTAREA\n         SPACE 1\n        MYSAVE\n         SPACE 1\n        DIRMASK\n         SPACE 1\n        SPFMT\n         SPACE 1\n        PARMLIST\n         PRINT &PRF\n        IEFZB4D0\n        IFGACB\n        IFGRPL\n        IHAPDS PDSBLDL=NO\n        DCBD   DSORG=(PS,PO),DEVD=DA\n        IECSDSL1 (1)\nDSCBLGTH EQU   DS1END-IECSDSL1\n        IEZIOB\n         PRINT GEN\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPSIDCA": {"ttr": 13315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x07?\\x00\\x96\\x07?\\x14X\\x029\\x029\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-03-13T00:00:00", "modifydate": "1996-03-13T14:58:00", "lines": 569, "newlines": 569, "modlines": 0, "user": "SYSPAJA"}, "text": "IDCA     TITLE '--- E T P S -- ETPSIDCA - IDCAMS INTERFACE ---'\n         PRINT OFF\n         COPY  ETPS$O1             \"ETPS\" SYSPARM SELECTION\n         COPY  ETPSMACS            \"ETPS\" MACROS\n         COPY  ETPSDEFS            \"ETPS\" DEFINITIONS\n         PRINT ON\nETPSIDCA START 0\n         SPACE 1\nETPSIDCA AMODE 24\nETPSIDCA RMODE 24\n        MIDENT\n         EJECT\n*------- AT ENTRY, R1 = NONE (NO PARM.LIST)\n         SPACE 1\n         PRINT GEN\n         USING *,R12,R11\n         USING SAVE2,R13      ************************** R13 ==> SAVE2\n         USING SPLTAREA,R10   AT ENTRY : R10 MUST POINT TO \"SPLTAREA\"\n         B     32(,R15)\n         DC    CL28'  ETPSIDCA &SYSDATE &SYSTIME'\n         PRINT &PRF\n         STM   R14,R12,12(R13)     SAVE INPUT REGISTERS\n         LR    R12,R15             SET PROGRAM BASE REGISTER 1\n         LA    R3,1\n         LA    R11,4*KB-1(R3,R12)  SET PROGRAM BASE REGISTER 2\n         LR    R3,R10              SPLIT-SCREEN DSECT\n         SH    R3,=Y(SPLITWRK-SAVE2) POINT TO SAVE2\n         ST    R13,4(,R3)          STORE BACKWARD POINTER\n         ST    R3,8(R13)           STORE FORWARD POINTER\n         LR    R13,R3              SET DSECT BASE\n         L     R9,=A(WKLEN)\n        GETMAIN RC,LV=(R9)         GET \"IDCSAVE\" WORK-AREA\n         LTR   R5,R15              HOW COMPLETE?\n         BZ    *+L'*+8             OK\n         LA    R4,99\n         B     GOBACK\n         LR    R0,R1\n         LR    R1,R9\n         LR    R9,R0\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R0,R14              CLEAR ALL TO BINARY ZEROS\n         USING IDCSAVE,R9\n         MVC   EYECATCH,=CL8'CALLVSAM'\n         LA    R2,IDCPARMS\n         USING PDSECT,R2\n         XC    0(PARMLEN,R2),0(R2)\n         MVC   DDNAMES,=AL2(DDAL)\n         LA    R14,PARMFLD\n         LA    R15,DDNAMES\n         MVC   DDIN,N#IN           SET DDNAME FOR SYSIN\n         LA    R0,PAGELIST\n         LA    R1,IOLIST\n         STM   R14,R1,VPARMS\n         OI    VPARMS+12,VLB       SET \"VL\" BIT\n         LA    R14,1               NUMBER OF ENTRIES\n         LA    R15,IODDIN          SET UP IOLIST ENTRY FOR SYSIN\n         L     R0,=A(IDCIOR)\n         STM   R14,R0,IOLIST\n         ST    R9,IOLIST+12\n         MVC   IODDIN(2),=CL2'DD'\n         MVC   IODDIN+2(8),N#IN\n         L     R1,ACOPDCB          SET DDNAME FOR SYSPRINT\n         MVC   DDPRINT(L'DDPRINT),DCBDDNAM-IHADCB(R1)\n         DROP  R2\n         MVC   OUDDNAME(SKLTUL),SKLTU\n         MVC   DDOUT(L'DDOUT),DCBDDNAM-IHADCB(R1)\n         LA    R0,NBRCMDS\n         LA    R1,CMDLNES\n         MVI   0(R1),C' '\n         MVC   1(L'CMDLNES-1,R1),0(R1)\n         LA    R1,L'CMDLNES(R1)\n         BCT   R0,*-14\n         MVC   RB99TU(SKFLEN),SKF  FREE ANY SYSPRINT\n         LA    R0,OUDDNAME\n         ST    R0,RB99TU\n         LA    R1,RB99TU\n         BAL   R8,UNALL\n*- - - - SET UP THE COMMAND SCREEN\nIDCCMND  LA    R4,TERMOUT+4        PICK UP ADDRESS OF FIRST OUTPUT LINE\n         L     R8,SCROWS           PICK UP NUMBER OF ROWS\n         CLI   SPLIT,0             AM I DOING SPLIT-SCREEN?\n         BE    SETIDCNX            NOPE\n         L     R8,SCROWS1          PICK UP NUMBER OF ROWS ON SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   SETIDCNX            NO, GO DO IT\n         SLL   R8,2                MULTIPLY BY 4\n         LA    R4,TERMOUT+4(R8)    SET ADDRESS OF FIRST OUTPUT LINE\n         L     R8,SCROWS2          PICK UP NUMBER OF ROWS ON SCREEN 2\nSETIDCNX L     R14,0(,R4)          PICK UP ADDRESS OF FIRST OUTPUT LINE\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         MVC   0(IDCROW1L,R14),IDCROW1 FILL IN LINE1\n         BCT   R8,*+L'*+4\n         B     CHKSPLT\n         LA    R4,4(,R4)           BUMP\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R14,0(,R4)          PICK UP ADDRESS OF NEXT OUTPUT LINE\n         MVC   0(IDCROW2L,R14),IDCROW2 FILL IN LINE2\n         BCT   R8,*+L'*+4\n         B     CHKSPLT\n         LA    R4,4(,R4)           BUMP\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R14,0(,R4)          PICK UP ADDRESS OF NEXT OUTPUT LINE\n         MVC   0(IDCROW3L,R14),IDCROW3 FILL IN LINE3\n         BCT   R8,*+L'*+4\n         B     CHKSPLT\n         LA    R15,CMDLNES         COMMANDS START ADDRESS\n         LA    R0,NBRCMDS          NUMBER OF COMMANDS LINES\nSTOCMDS  LA    R4,4(,R4)           BUMP\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R14,0(,R4)          PICK UP ADDRESS OF NEXT OUTPUT LINE\n         MVC   0(IDCROW4L,R14),IDCROW4 FILL FROM LINE3\n         MVC   CCSCF1(L'CCSCF1,R14),1(R15) COPY COMMAND TO SCREEN\n         BCT   R8,*+L'*+4\n         B     CHKSPLT\n         LA    R15,L'CMDLNES(R15)  BUMP TO NEXT COMMAND\n         BCT   R0,STOCMDS\nLOOPFILL LA    R4,4(,R4)           BUMP\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R14,0(,R4)          PICK UP ADDRESS OF NEXT OUTPUT LINE\n         MVC   0(BLKLNL,R14),BLKLN FILL IN A BLANK LINE\n         BCT   R8,LOOPFILL\nCHKSPLT  CLI   SPLIT,1             AM I DOING SPLIT-SCREEN 1?\n         BE    *+L'*+4             YES\n         OI    0(R4),EOS           NO, SET END-OF-SCREEN\n         L     R15,=A(IDCHELP)     HELP SCREEN\n         ST    R15,HELPADD\n         MVI   CURROW,CRIDSC       CURSOR ROW\n         MVI   CURCOL,CCIDSC       CURSOR COLUMN\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         LTR   R15,R15             BAD RC?\n         BNZ   EOJ                 OUT\n*- - - - CHECK TO SEE WHETHER AN IDCAMS COMMAND WAS ENTERED\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         LA    R4,TERMINPT+ZII     SET START ADDRESS OF REPLY FIELDS\n         L     R8,SCROWS           PICK UP NUMBER OF ROWS\n         CLI   SPLIT,0             AM I DOING SPLIT-SCREEN?\n         BE    IDCFMTPF            NOPE\n         L     R8,SCROWS1          PICK UP NUMBER OF ROWS ON SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   IDCFMTPF            NO, GO TEST PFKEY\n         SLL   R8,2                MULTIPLY BY 4\n         LA    R4,TERMINPT+ZII(R8) SET START ADDRESS OF REPLY FIELDS\n         L     R8,SCROWS2          PICK UP NUMBER OF ROWS ON SCREEN 2\nIDCFMTPF TM    COMMSW,PFKFLAG      PFK/ATTN ENTERED?\n         BZ    IDCCMDS             NONE\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    EOJ                 YES\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BE    EOJ                 YES\n         CLI   0(R2),X'6C'         IS IT PA1?\n         BE    EOJ                 YES\n         CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    IDCCMND             YUP, RESHOW SCREEN\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    IDCCMND             YES, RESHOW SCREEN\n         LA    R1,INVMSG\n         ST    R1,MSGADD\n*- - - - SET UP IDCAMS COMMANDS\nIDCCMDS  NI    IDCSW,255-TEXTENT   RESET TEXT-ENTERED\n         LA    R15,CMDLNES         COMMANDS START ADDRESS\n         LA    R0,NBRCMDS          NUMBER OF COMMANDS LINES\nGETCMDS  BCT   R8,*+L'*+4          START SKIPPING LINE1\n         B     ENDCMDS\n         L     R14,0(,R4)          PICK UP ADDRESS OF INPUT LINE\n         CLI   0(R14),0            COMMAND ENTERED?\n         BE    NXTCMDS             NOPE\n         MVC   1(L'CMDLNES-1,R15),0(R15)\n         OC    1(L'CCSCF1,R15),CCSCF1(R14) COPY TEXT IN UPPERCASE\n         OI    IDCSW,TEXTENT       SET TEXT-ENTERED\nNXTCMDS  BCT   R0,*+L'*+4\n         B     ENDCMDS\n         LA    R4,4(,R4)           BUMP\n         LA    R15,L'CMDLNES(R15)  BUMP TO NEXT COMMAND\n         B     GETCMDS\nENDCMDS  TM    COMMSW,PFKFLAG      PFK/ATTN ENTERED?\n         BO    IDCCMND             YES, IT WAS AN INVALID PF-KEY\n         TM    IDCSW,TEXTENT       IS TEXT JUST ENTERED?\n         BO    IDCCMND             YES, WAIT EMPTY PRESS ENTER-KEY\n         LA    R15,CMDLNES         COMMANDS START ADDRESS\n         LA    R0,NBRCMDS          NUMBER OF COMMANDS LINES\n         CLC   1(L'CCSCF1,R15),=CL71' ' IS THERE A COMMAND?\n         BNE   *+L'*+12            YES\n         LA    R15,L'CMDLNES(R15)  NO, BUMP TO NEXT COMMAND\n         BCT   R0,*-14\n         B     IDCCMND             NONE, NO COMMAND(S)\n*- - - - INVOKE IDCAMS PROGRAM\n         TM    IDCSW,PRALLOC       SYSPRINT ALREADY ALLOCATED?\n         BO    DOLINK\n         MVC   RBOUTU(SKPLEN),SKP  ALLOCATE SYSPRINT\n         LA    R0,OUDDNAME\n         ST    R0,RBOUTU\n         LA    R0,OUDSNAME\n         ST    R0,OUDSNM\n         LA    R0,OURTDS\n         O     R0,OURDSNM\n         ST    R0,OURDSNM\n         LA    R1,RBOUTU\n         BAL   R8,DYNALL\n         B     QUIT                +0 - ERROR RETURN\n         OI    IDCSW,PRALLOC       +4 - SET ALLOCATED\nDOLINK   LA    R1,IDCPARMS\n        LINK   EP=IDCAMS\n*- - - - INVOKE BROWSE\n         L     R3,ACOPDCB\n         LA    R2,OURDS\n         LA    R4,=CL8' '\n         ICM   R15,B'1111',ARBROWSE\n         BNZ   CALLBR\n        LOAD   EP=ETPSBROW,ERRET=XLDERR\n         ST    R0,ARBROWSE\n         LR    R15,R0\n*- - - - ETPSBROW PARM.LIST : DCB, DS-NAME, MEMBER-NAME\nCALLBR  CALL   (15),((R3),(R2),(R4)),VL,MF=(E,PARMVL)\n         B     IDCCMND             BACK TO ENTER COMMAND(S)\nXLDERR   STM   R0,R1,MESSPL        BROWSE IS UNAVAILABLE\n        XMESS  99,R15\n         LA    R1,LDBMSG\n         ST    R1,MSGADD\n*- - - - TERMINATE IDCAMS INTERFACE\nEOJ      TM    IDCSW,PRALLOC       SYSPRINT ALLOCATED?\n         BZ    LEAVE               NO\n         MVC   RB99TU(SKFLEN),SKF  YES, FREE IT\n         LA    R0,OUDDNAME\n         ST    R0,RB99TU\n         LA    R1,RB99TU\n         BAL   R8,UNALL\nLEAVE    XR    R4,R4\n         LR    R5,R4\nQUIT     L     R0,=A(WKLEN)\n        FREEMAIN R,LV=(0),A=(R9)\nGOBACK   LTR   R5,R5               HOW COMPLETE?\n         BZ    RETXIT              OK\n         ST    R4,MESSPL           ERROR\n        XMESS  1501,R15\n         LA    R1,ALLMSG           SET MESSAGE\n         CH    R4,=H'99'\n         BNE   *+L'*+4\n         LA    R1,GMEMSG\n         ST    R1,MSGADD\nRETXIT   L     R13,4(,R13)         PICK UP CALLING SAVE-AREA\n         LM    R14,R12,12(R13)     RESTORE CALLING REGISTERS\n         XR    R15,R15             SET RC=0\n         BR    R14                 RETURN\n         SPACE 1\nUNALL    LA    R0,S99VRBUN         UNALL ROUTINE --------------------*\n         B     DYNALL+L'DYNALL\nDYNALL   LA    R0,S99VRBAL         DYNALL ROUTINE -------------------*\n         MVC   RB99P(SKRLEN),SKR\n         STC   R0,RB99VR\n         ST    R1,RB99TUP\n         LA    R0,RB99\n         O     R0,RB99P\n         ST    R0,RB99P\n         LA    R1,RB99P\n        DYNALLOC\n         CLI   RB99VR,S99VRBAL     DYNALL?\n         BNER  R8                  NO, ALWAYS RETURN\n         L     R5,RB99RC           YES, CHECK ANY ERROR\n         LTR   R4,R15\n         BNZR  R8                  ERROR, RETURN +0\n         LTR   R5,R5\n         BNZR  R8                  ERROR, RETURN +0\n         B     4(R8)               NORMAL, RETURN +4\n         SPACE 1\nSKR      DC    0F'0',AL1(S99RBPND),AL3(*-*)\nSKRP     DC    AL1(S99RBEND-S99RB)\n         DC    AL1(*-*)            VERB CODE\n         DC    AL1(0,0)            FLAGS\n         DC    2XL2'0'             ERROR-INFORMATION REASON CODES\n         DC    A(*-*)\nSKRL     EQU   (S99RBEND-S99RB)-(*-SKRP)\n         DC    (SKRL)X'0'\nSKRLEN   EQU   *-SKR\n         SPACE 1\nSKF      DC    A(*-*)\n         DC    AL1(S99TUPLN),AL3(UNCOND)\nSKFLEN   EQU   *-SKF\n         SPACE 1\nSKP      DC    A(*-*)\n         DC    A(*-*)\n         DC    A(UNIT)\n         AIF   ('&ISPUN' NE 'TRK').SK1\n         DC    A(TRKS)\n         AGO   .SK2\n.SK1     DC    A(CYLS)\n.SK2     DC    A(PRIMRY)\n         DC    A(SECNRY)\n         DC    A(RECFM)\n         DC    A(BLKSZ)\n         DC    A(LRECL)\n         DC    A(DISPNEW)\n         DC    A(DISPDEL)\n         DC    A(DISPCDEL)\n         DC    AL1(S99TUPLN),AL3(*-*)\nSKPLEN   EQU   *-SKP\n         SPACE 1\nSKLTU    DC    AL2(DALDDNAM),AL2(1),AL2(8) OR (DUNDDNAM)\n         DC    CL8' '\n         DC    AL2(DALDSNAM),AL2(1),AL2(44)\n         DC    CL44'&&&&OUTLIST '\n         DC    AL2(DALRTDSN),AL2(1),AL2(44)\n         DC    CL44' '\nSKLTUL   EQU   *-SKLTU\n         SPACE 1\nUNIT     DC    AL2(DALUNIT),AL2(1),AL2(8),CL8'&IUNME'\nPRIMRY   DC    AL2(DALPRIME),AL2(1),AL2(3),AL3(&IPRIQ)\nSECNRY   DC    AL2(DALSECND),AL2(1),AL2(3),AL3(&ISECQ)\nBLKSZ    DC    AL2(DALBLKSZ),AL2(1),AL2(2),AL2(&IBLSZ)\nLRECL    DC    AL2(DALLRECL),AL2(1),AL2(2),AL2(&ILRCL)\nRECFM    DC    AL2(DALRECFM),AL2(1),AL2(1)\n        SETRF  &IRCFM\nDISPNEW  DC    AL2(DALSTATS),AL2(1),AL2(1),XL1'04'\nDISPDEL  DC    AL2(DALNDISP),AL2(1),AL2(1),XL1'04'\nDISPCDEL DC    AL2(DALCDISP),AL2(1),AL2(1),XL1'04'\n         AIF   ('&ISPUN' NE 'TRK').SK3\nTRKS     DC    AL2(DALTRK),AL2(0)\n         AGO   .SK4\n.SK3     ANOP\nCYLS     DC    AL2(DALCYL),AL2(0)\n.SK4     ANOP\nUNCOND   DC    AL2(DUNUNALC),AL2(0)\n         SPACE 1\nINVMSG   MSG   'INVALID PF-KEY'\nLDBMSG   MSG   'BROWSE UNAVAILABLE'\nALLMSG   MSG   'IDCAMS ALLOC. FAILED'\nGMEMSG   MSG   'IDCAMS GETMAIN ERROR'\n         SPACE 1\nIDCROW1  DC    AL1(IDCROW1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL32' IDCAMS INTERFACE - ENTRY PANEL ',37CL1'-'\nIDCROW1L EQU   *-IDCROW1\nIDCROW2  DC    AL1(IDCROW2L-1)\n         DC    XL1'05'             PROTECT, HIGH-LIGHT\n         DC    C'ENTER IDCAMS COMMANDS (CARD COL.2-72) BELOW:'\n         DC    XL1'04',CL1' '\nIDCROW2L EQU   *-IDCROW2\nIDCROW3  DC    AL1(IDCROW3L-1)\n         DC    XL1'04',CL6' '\n         DC    CL71'---+----1----+----2----+----3----+----4----+----5--X\n               --+----6----+----7--',CL2' '\nIDCROW3L EQU   *-IDCROW3\nCRIDSC   EQU   03                  CURSOR ROW ON LINE BELOW\nZII      EQU   (CRIDSC+1)*4        \"TERMINPT\" DISPLACEMENT\nIDCROW4  DC    AL1(IDCROW4L-1)\n         DC    XL1'05',CL5' ===>'\nCCIDSC   EQU   *-IDCROW4           CURSOR COLUMN ON FIELD BELOW\nCCSCF1   EQU   (*-IDCROW4)+1,71    INPUT FIELD 1\n         DC    XL1'01',CL71' ',XL1'05',CL1'<'\nIDCROW4L EQU   *-IDCROW4\nBLKLN    DC    AL1(BLKLNL-1),XL1'04',CL9' '\nBLKLNL   EQU   *-BLKLN\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R9,R10,R11,R12,R13\n         EJECT\n*------- IDCAMS INPUT-OUTPUT ROUTINE --------------------------------*\n         CNOP  0,4\n         USING *,R12\nIDCIOR   STM   R14,R12,12(R13)     SAVE INPUT REGS\n         LR    R12,R15             SET BASE REGISTER\n         LR    R8,R13              SAVE R13\n         LM    R9,R11,0(R1)        PICK UP PARMS\n         ST    R9,8(R8)            STORE FORWARD POINTER\n         ST    R8,4(R9)            STORE BACKWARD POINTER\n         LR    R13,R9\n         USING IDCSAVE,R9\n         USING VFLAGS,R10\n         USING VINFO,R11\n         CLI   VFLAG1,VOPEN\n         BE    IDCOPEN\n         CLI   VFLAG1,VGET\n         BE    IDCGET\n         B     RC0                 IGNORE ANYTHING ELSE\nIDCOPEN  TM    VFLAG2,VINPUT\n         BZ    RC0\n         MVI   IOFLAG,0\n         B     RC0\nIDCGET   LA    R4,NBRCMDS\n         XR    R3,R3\n         IC    R3,IOFLAG\n         CLR   R3,R4\n         BE    RC4\n         BH    RC12\n         LA    R2,CMDLNES\n         LTR   R0,R3\n         BZ    INCMDS\n         LA    R2,L'CMDLNES(R2)\n         BCT   R0,*-4\nINCMDS   LA    R3,1(R3)\n         CLR   R3,R4\n         BH    RC4\n         CLC   0(80,R2),=CL80' '\n         BNE   *+L'*+8\n         LA    R2,L'CMDLNES(R2)\n         B     INCMDS\n         STC   R3,IOFLAG\n         ST    R2,VRECA\n         LA    R1,L'CMDLNES\n         ST    R1,VRECL\nRC0      XR    R15,R15\n         B     RETURN\nRC4      MVI   IOFLAG,NBRCMDS\n         LA    R15,4\n         B     RETURN\nRC12     LA    R15,12\nRETURN   L     R13,4(,R13)         PICK UP CALLING SAVE-AREA\n         LM    R0,R12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R9,R10,R11,R12\n         EJECT\n*------- IDCAMS HELP SCREEN -----------------------------------------*\n         CNOP  0,4\nIDCHELP  DC    A(IDCHL1)\n         DC    A(IDCENT)\n         DC    A(IDCHL2)\n         DC    A(IDCBLK)\n         DC    A(IDCHL3)\n         DC    A(IDCHL4)\n         DC    A(IDCBLK)\n         DC    A(IDCHL5)\n         DC    A(IDCHL6)\n         DC    A(IDCHL7)\n         DC    A(IDCHL8)\n         DC    A(IDCHL9)\n         DC    A(IDCBLK)\n         DC    A(IDCHL10)\n         DC    A(IDCHL11)\n         DC    A(IDCBLK)\n         DC    A(EML+IDCHL12)\n         SPACE 1\nIDCHL1   DC    AL1(IDCHL1L-1)      ROW 01, COL 01\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL18' IDCAMS INTERFACE ',51CL1'-'\nIDCHL1L  EQU   *-IDCHL1\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\nIDCHL2   DC    AL1(IDCHL2L-1),XL1'05'\n         DC    C'EIGHT COMMAND LINES ARE PROVIDED TO ENTER ONE OR MORE X\n               IDCAMS COMMANDS.'\nIDCHL2L  EQU   *-IDCHL2\nIDCHL3   DC    AL1(IDCHL3L-1),XL1'05'\n         DC    C'NOTE THAT IF AN IDCAMS COMMAND REQUIRES MORE THAN ONE X\n               LINE, YOU MUST INDICATE'\nIDCHL3L  EQU   *-IDCHL3\nIDCHL4   DC    AL1(IDCHL4L-1),XL1'05'\n         DC    C'    CONTINUATIONS WITH A HYPHEN.'\nIDCHL4L  EQU   *-IDCHL4\nIDCHL5   DC    AL1(IDCHL5L-1),XL1'05'\n         DC    C'EACH COMMAND LINE IS PASSED TO IDCAMS AS A CARD IMAGE,X\n                JUST AS IF IDCAMS WAS'\nIDCHL5L  EQU   *-IDCHL5\nIDCHL6   DC    AL1(IDCHL6L-1),XL1'05'\n         DC    C'    INVOKED IN A BATCH JOB. DO NOT USE ANY OF THE TSO X\n               COMMAND SYNTAX, THINK'\nIDCHL6L  EQU   *-IDCHL6\nIDCHL7   DC    AL1(IDCHL7L-1),XL1'05'\n         DC    C'    AS IN BATCH JOB RUNNING. I.E. :'\nIDCHL7L  EQU   *-IDCHL7\nIDCHL8   DC    AL1(IDCHL8L-1),XL1'05'\n         DC    C'    ===>  LISTCAT  NVSAM  ENT(...DATA-SET NAME...)  ALX\n               L'\nIDCHL8L  EQU   *-IDCHL8\nIDCHL9   DC    AL1(IDCHL9L-1),XL1'05'\n         DC    C'    ===>  LISTCAT  NVSAM  LVL(...LEVEL NAME...)  ALL'\nIDCHL9L  EQU   *-IDCHL9\nIDCHL10  DC    AL1(IDCHL10L-1),XL1'05'\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\n         DC    C'AFTER YOU HAVE TYPED IN THE COMMAND(S) LINE(S), JUST PX\n               RESS ONCE AGAIN THE'\nIDCHL10L EQU   *-IDCHL10\nIDCHL11  DC    AL1(IDCHL11L-1),XL1'05'\n         DC    C'    ENTER-KEY TO INVOKE THE IDCAMS PROCESSING.'\nIDCHL11L EQU   *-IDCHL11\nIDCHL12  DC    AL1(IDCHL12L-1),XL1'05'\n         DC    C'PF3 RETURNS TO THE PRIMARY OPTION MENU PANEL.'\nIDCHL12L EQU   *-IDCHL12\nIDCENT   DC    AL1(IDCENTL-1),XL1'01',CL1' ',XL1'05',CL7' '\nIDCENTL  EQU   *-IDCENT\nIDCBLK   DC    AL1(IDCBLKL-1),XL1'05',CL9' '\nIDCBLKL  EQU   *-IDCBLK\n         EJECT\nIDCSAVE  DSECT\n         DS    18F                 SAVE-AREA OF \"IDCIOR\"\nEYECATCH DS    CL8                 \"CALLVSAM\"\nIDCPARMS DS    XL(PARMLEN)\nIOFLAG   DS    XL1\nIDCSW    DS    XL1\nPRALLOC  EQU   X'80'               SYSPRINT IS ALLOCATED\nTEXTENT  EQU   X'01'               COMMAND(S) TEXT JUST ENTERED\n         DS    0D\nCMDLNES  DS    8CL80\nNBRCMDS  EQU   (*-CMDLNES)/L'CMDLNES\nRB99P    DS    A\nRB99     DS    AL1\nRB99VR   DS    AL1                 VERB CODE\n         DS    AL2                 FLAGS\nRB99RC   DS    XL4                 ERROR-INFORMATION REASON CODES\nRB99TUP  DS    A\nRB99L    EQU   (S99RBEND-S99RB)-(*-RB99)\n         DS    (RB99L)X\nRB99TU   DS    13A\n         ORG   RB99TU\nRBOUTU   DS    A\nOUDSNM   DS    A\n         DS    10A\nOURDSNM  DS    A\n         ORG   ,                   \"SKLTU\" MOVED BELOW\nOUDDNAME DS    3AL2\nDDOUT    DS    CL8\nOUDSNAME DS    3AL2\nOUDS     DS    CL44\nOURTDS   DS    3AL2\nOURDS    DS    CL44\nWKLEN    EQU   (((*-IDCSAVE)+7)/8)*8\n         SPACE 1\nVFLAGS   DSECT\nVFLAG1   DS    XL1\nVOPEN    EQU   X'00'\nVCLOSE   EQU   X'04'\nVGET     EQU   X'08'\nVPUT     EQU   X'0C'\nVFLAG2   DS    XL1\nVINPUT   EQU   X'80'\nVOUTPUT  EQU   X'40'\nVDDN     EQU   X'20'\nVDSN     EQU   X'10'\nVFLAG3   DS    XL1\nVFLAG4   DS    XL1\n         SPACE 1\nVINFO    DSECT\nVRECA    DS    F\nVRECL    DS    F\n         SPACE 1\nPDSECT   DSECT\nVPARMS   DS    F                   OPTIONS LIST POINTER\n         DS    F                   DDNAMES LIST\n         DS    F                   PAGE NUMBER LIST\n         DS    F                   I/O LIST\nPARMFLD  DS    H\nDDNAMES  DS    H\n         DS    4XL8\nDDIN     DS    XL8                 5 - SYSIN\nDDPRINT  DS    XL8                 6 - SYSPRINT\nDDAL     EQU   (*-DDNAMES)-L'DDNAMES\nPAGELIST DS    H\nIOLIST   DS    F                   NUMBER OF ENTRIES\n         DS    3F                  1 - DDNAME/IOROUTINE/USERDATA\nIODDIN   DS    CL10\nPARMLEN  EQU   *-PDSECT\n         PRINT &PRS\n        SPLTAREA\n         SPACE 1\n        MYSAVE\n         PRINT &PRF\n        IEFZB4D0\n        IEFZB4D2\n        DCBD   DSORG=(PS,PO),DEVD=DA\n        IEZIOB\n         PRINT GEN\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPSIZAP": {"ttr": 13569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x07?\\x00\\x96\\x07?\\x14X\\x0c\\x1f\\x0c\\x1f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-03-13T00:00:00", "modifydate": "1996-03-13T14:58:00", "lines": 3103, "newlines": 3103, "modlines": 0, "user": "SYSPAJA"}, "text": "IZAP     TITLE '--- E T P S -- ETPSIZAP - INCORZAP INTERFACE ---'\n         PRINT OFF\n         COPY  ETPS$O2A            \"ETPS\" SYSPARM SELECTION\n         MACRO\n        @DST   &DUMMY\n         GBLA  &IZNE\n         GBLC  &IZSL(1),&IZDS(1)\n         LCLA  &L,&M,&N\n         AIF   (&IZNE LT 1).ERR1\n*------- NUCLEUS/LPA DATA-SETS NAMES TABLE --------------------------*\nNLDSTBL  DS    0CL1                START OF TABLE\n&N       SETA  1\n.LOOP    AIF   (&N GT &IZNE).END\n         AIF   ('&IZSL(&N)' EQ '').ERR2\n         AIF   ('&IZDS(&N)' EQ '').ERR3\n&L       SETA  K'&IZSL(&N)\n&M       SETA  K'&IZDS(&N)\n         AIF   (&L NE 1).ERR4\n         AIF   (&M GT 44).ERR5\n         AIF   ('&IZSL(&N)'(1,1) EQ ' ').ERR6\n         AIF   ('&IZDS(&N)'(1,1) EQ ' ').ERR7\n         DC    CL1'&IZSL(&N)',AL1(&M-1),C'&IZDS(&N)'\n&N       SETA  &N+1\n         AGO   .LOOP\n.ERR1    MNOTE 8,' NO. OF ELEMENTS (&IZNE) IN TABLE ERROR ********* '\n         AGO   .END\n.ERR2    MNOTE 8,' ACCESS-CODE (&N) MISSING *********************** '\n         AGO   .END\n.ERR3    MNOTE 8,' DS-NAME (&N) MISSING *************************** '\n         AGO   .END\n.ERR4    MNOTE 8,' ACCESS-CODE (&N) LENGTH ERROR (&L) ************* '\n         AGO   .END\n.ERR5    MNOTE 8,' DS-NAME (&N) LENGTH ERROR (&M) ***************** '\n         AGO   .END\n.ERR6    MNOTE 8,' ACCESS-CODE (&N) INVALID *********************** '\n         AGO   .END\n.ERR7    MNOTE 8,' DS-NAME (&N) INVALID *************************** '\n.END     DC    XL1'0'              END OF TABLE\n         MEND\n         COPY  ETPSMACS            \"ETPS\" MACROS\n         COPY  ETPSDEFS            \"ETPS\" DEFINITIONS\n         PRINT ON\nETPSIZAP START 0\n         SPACE 1\nETPSIZAP AMODE 24\nETPSIZAP RMODE 24\n        MIDENT\n         EJECT\n*------- AT ENTRY, R1 = NONE (NO PARM.LIST)\n         SPACE 1\n         PRINT GEN\n         USING *,R12,R11\n         USING SAVE2,R13      ************************** R13 ==> SAVE2\n         USING SPLTAREA,R10   AT ENTRY : R10 MUST POINT TO \"SPLTAREA\"\n         B     32(,R15)\n         DC    CL28'  ETPSIZAP &SYSDATE &SYSTIME'\n         PRINT &PRF\n         STM   R14,R12,12(R13)     SAVE INPUT REGISTERS\n         LR    R12,R15             SET PROGRAM BASE REGISTER 1\n         LA    R3,1\n         LA    R11,4*KB-1(R3,R12)  SET PROGRAM BASE REGISTER 2\n         LR    R3,R10              SPLIT-SCREEN DSECT\n         SH    R3,=Y(SPLITWRK-SAVE2) POINT TO SAVE2\n         ST    R13,4(,R3)          STORE BACKWARD POINTER\n         ST    R3,8(R13)           STORE FORWARD POINTER\n         LR    R13,R3              SET DSECT BASE\n         L     R9,=A(@SIZE)\n        GETMAIN RC,LV=(R9)         GET \"WADATA\" WORK-AREA\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    SZSINIT             OK\n        XMESS  4007,R15            ERROR\n         LA    R1,ZGTMMSG\n         ST    R1,MSGADD\n         B     GOBACK\nSZSINIT  LR    R0,R1\n         LR    R9,R1\n         L     R1,=A(WALEN)\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R0,R14              CLEAR ALL TO BINARY ZEROS\n         USING WADATA,R9\n         MVC   EYECATCH,=CL8'INCORZAP'\n         MVI   ISZAC,C' '          INITIALIZATION\n         LA    R0,NBRSTTS\n         LA    R1,STMLNES\n         MVI   0(R1),C' '\n         MVC   1(L'STMLNES-1,R1),0(R1)\n         LA    R1,L'STMLNES(R1)\n         BCT   R0,*-14\n         MVC   IZUSRID,USERID\n         MVC   IZLIBDDN,N#UT1\n         MVI   IZLIBDSN,C' '\n         MVC   IZLIBDSN+1(L'IZLIBDSN-1),IZLIBDSN\n         MVC   IZPRTDDN,N#PRINT\n*- - - - SET UP THE SELECT SCREEN\nSZSSTTM  LA    R4,TERMOUT+4        PICK UP ADDRESS OF FIRST OUTPUT LINE\n         L     R8,SCROWS           PICK UP NUMBER OF ROWS\n         CLI   SPLIT,0             AM I DOING SPLIT-SCREEN?\n         BE    SZSSETNX            NOPE\n         L     R8,SCROWS1          PICK UP NUMBER OF ROWS ON SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   SZSSETNX            NO, GO DO IT\n         SLL   R8,2                MULTIPLY BY 4\n         LA    R4,TERMOUT+4(R8)    SET ADDRESS OF FIRST OUTPUT LINE\n         L     R8,SCROWS2          PICK UP NUMBER OF ROWS ON SCREEN 2\nSZSSETNX L     R14,0(,R4)          PICK UP ADDRESS OF FIRST OUTPUT LINE\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         MVC   0(IZROW1L,R14),IZROW1 FILL IN LINE1\n         BCT   R8,*+L'*+4\n         B     SZSCKSPL\n         LA    R4,4(,R4)           BUMP\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R14,0(,R4)          PICK UP ADDRESS OF NEXT OUTPUT LINE\n         MVC   0(IZROW2L,R14),IZROW2 FILL IN LINE2\n         MVC   SZSCF1(L'ISZAC,R14),ISZAC DISPLAY CURRENT ACCESS-CODE\n         BCT   R8,*+L'*+4\n         B     SZSCKSPL\n         L     R2,=A(NLDSTBL)      DS-NAMES TABLE START ADDRESS\n         XR    R15,R15\nSZSSTST  LA    R4,4(,R4)           BUMP\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R14,0(,R4)          PICK UP ADDRESS OF NEXT OUTPUT LINE\n         IC    R15,1(R2)           GET DS-NAME LENGTH\n         MVC   0(IZROWLL,R14),IZROWL FILL FROM LINE3\n         MVC   SZOFF1(L'SZOFF1,R14),0(R2) COPY ACCESS-CODE TO SCREEN\n         EX    R15,*+L'*+8         COPY DS-NAME TO SCREEN\n         BCT   R8,*+L'*+10\n         B     SZSCKSPL\n         MVC   SZOFF2(*-*,R14),2(R2) <<EXECUTED>>\n         LA    R2,3(R15,R2)        BUMP TO NEXT DS-NAME\n         CLI   0(R2),0             END OF TABLE?\n         BNE   SZSSTST             NO, LOOP\nSZSLFILL LA    R4,4(,R4)           BUMP\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R14,0(,R4)          PICK UP ADDRESS OF NEXT OUTPUT LINE\n         MVC   0(BLNKLL,R14),BLNKL FILL IN A BLANK LINE\n         BCT   R8,SZSLFILL\nSZSCKSPL CLI   SPLIT,1             AM I DOING SPLIT-SCREEN 1?\n         BE    *+L'*+4             YES\n         OI    0(R4),EOS           NO, SET END-OF-SCREEN\n         L     R15,=A(IZHELP)      HELP SCREEN\n         ST    R15,HELPADD\n         MVI   CURROW,CRSZSC       CURSOR ROW\n         MVI   CURCOL,CCSZSC       CURSOR COLUMN\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         LTR   R15,R15             BAD RC?\n         BNZ   IZEOJ               OUT\n         TM    COMMSW,PFKFLAG      PFK/ATTN ENTERED?\n         BZ    SZSSTTS             NONE\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    IZEOJ               YUP, OUT\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BE    IZEOJ               YUP, OUT\n         CLI   0(R2),X'6C'         IS IT PA1?\n         BE    IZEOJ               YUP, OUT\n         CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    SZSSTTM             YUP, RESHOW SCREEN\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    SZSSTTM             YUP, RESHOW SCREEN\n         LA    R1,IPFMSG\nSZSTMSG  ST    R1,MSGADD\n         B     SZSSTTM\n*- - - - CHECK ENTERED ACCESS-CODE\nSZSSTTS  L     R5,TERMINPT+SZI     PICK UP SELECT FIELD\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   *+L'*+12            NOPE\n         L     R3,SCROWS1          PICK UP SIZE OF SCREEN 1\n         SLL   R3,2                MULTIPLY BY 4\n         L     R5,TERMINPT+SZI(R3) PICK UP SELECT FIELD\n         CLI   0(R5),0             ACCESS-CODE ENTERED?\n         BNE   *+L'*+12            YES\n         CLI   ISZAC,C' '          NO, CURRENT EXIST?\n         BNE   IZPSTTM             YES, USE IT (NO CHANGE)\n         B     SZSSTTM             ELSE RESHOW SCREEN\n         LA    R0,L'SZSCF1-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   SZSCF1(R5),C' '\n         BNE   SZVERAC\n         MVC   SZSCF1(L'SZSCF1-1,R5),SZSCF1+1(R5)\n         MVI   SZSCF1+L'SZSCF1-1(R5),C' '\n         BCT   R0,*-18\n         MVI   ISZAC,C' '          RESET CURRENT ACCESS-CODE\n         B     SZSSTTM             RESHOW SCREEN\nSZVERAC  CLC   SZSCF1+1(L'SZSCF1-1,R5),=CL8' '\n         BNE   SZINVMS\n         L     R4,=A(NLDSTBL)      DS-NAMES TABLE START ADDRESS\n         XR    R15,R15\nSZTLOOP  CLC   0(1,R4),SZSCF1(R5)  IS THIS ACCESS-CODE?\n         BE    SZFOUND             YES\n         IC    R15,1(R4)           NO, GET DS-NAME LENGTH\n         LA    R4,3(R15,R4)        BUMP TO NEXT DS-NAME\n         CLI   0(R4),0             END OF TABLE?\n         BNE   SZTLOOP             NO, LOOP\nSZINVMS  LA    R1,INVMSG           ELSE INVALID\n         B     SZSTMSG\nSZMVDSN  MVC   IZLIBDSN(*-*),2(R4) <<EXECUTED>>\nSZFOUND  CLC   ISZAC,0(R4)         IS IT THE CURRENT ONE?\n         BE    IZPSTTM             YES\n         CLI   IZLIBDSN,C' '       NO, PREVIOUS \"LIB\" ALLOCATED?\n         BE    SZSTNEW             NO\n         MVI   ISZAC,C' '          YES, RESET CURRENT ACCESS-CODE\n         MVI   IZLIBDSN,C' '       CLEAR \"LIB\" DS-NAME\n         MVC   IZLIBDSN+1(L'IZLIBDSN-1),IZLIBDSN\n         L     R7,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R2,R7\n         LH    R3,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R2,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R7\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME,IZLIBDDN     DD-NAME\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    SZSTNEW             OK\n        XMESS  4002\n         LA    R1,ZFLBMSG\n         B     SZSTMSG\nSZSTNEW  MVC   ISZAC,0(R4)         SET THE NEW CURRENT\n         IC    R15,1(R4)           GET DS-NAME LENGTH\n         EX    R15,SZMVDSN         SET NEW \"LIB\" DS-NAME\n         L     R7,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R2,R7\n         LH    R3,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R2,R14              CLEAR TO ALL BLANKS\n         MVC   DDNAME,IZLIBDDN     DD-NAME\n         MVC   DSNAME,IZLIBDSN     DS-NAME\n         MVC   DSSTATUS,=CL8'SHR'  DISP=SHR\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    IZPSTTM             OK\n        XMESS  4001\n         LA    R1,ZLLBMSG\n         B     SZSTMSG\n         DROP  R7\n*- - - - SET UP THE STATEMENTS SCREEN\nIZPSTTM  LA    R4,TERMOUT+4        PICK UP ADDRESS OF FIRST OUTPUT LINE\n         L     R8,SCROWS           PICK UP NUMBER OF ROWS\n         CLI   SPLIT,0             AM I DOING SPLIT-SCREEN?\n         BE    IZPSETNX            NOPE\n         L     R8,SCROWS1          PICK UP NUMBER OF ROWS ON SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   IZPSETNX            NO, GO DO IT\n         SLL   R8,2                MULTIPLY BY 4\n         LA    R4,TERMOUT+4(R8)    SET ADDRESS OF FIRST OUTPUT LINE\n         L     R8,SCROWS2          PICK UP NUMBER OF ROWS ON SCREEN 2\nIZPSETNX L     R14,0(,R4)          PICK UP ADDRESS OF FIRST OUTPUT LINE\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         MVC   0(ISZROW1L,R14),ISZROW1 FILL IN LINE1\n         BCT   R8,*+L'*+4\n         B     IZPCKSPL\n         LA    R4,4(,R4)           BUMP\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R14,0(,R4)          PICK UP ADDRESS OF NEXT OUTPUT LINE\n         MVC   0(ISZROW2L,R14),ISZROW2 FILL IN LINE2\n         BCT   R8,*+L'*+4\n         B     IZPCKSPL\n         LA    R4,4(,R4)           BUMP\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R14,0(,R4)          PICK UP ADDRESS OF NEXT OUTPUT LINE\n         MVC   0(ISZROW3L,R14),ISZROW3 FILL IN LINE3\n         BCT   R8,*+L'*+4\n         B     IZPCKSPL\n         LA    R15,STMLNES         STATEMENTS START ADDRESS\n         LA    R0,NBRSTTS          NUMBER OF STATEMENTS LINES\nIZPSTST  LA    R4,4(,R4)           BUMP\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R14,0(,R4)          PICK UP ADDRESS OF NEXT OUTPUT LINE\n         MVC   0(ISZROW4L,R14),ISZROW4 FILL FROM LINE4\n         MVC   IZSCF1(L'IZSCF1,R14),1(R15) COPY STATEMENTS TO SCREEN\n         BCT   R8,*+L'*+4\n         B     IZPCKSPL\n         LA    R15,L'STMLNES(R15)  BUMP TO NEXT STATEMENT\n         BCT   R0,IZPSTST\nIZPLFILL LA    R4,4(,R4)           BUMP\n         NI    0(R4),255-EOS       CLEAR END-OF-SCREEN\n         L     R14,0(,R4)          PICK UP ADDRESS OF NEXT OUTPUT LINE\n         MVC   0(BLNKLL,R14),BLNKL FILL IN A BLANK LINE\n         BCT   R8,IZPLFILL\nIZPCKSPL CLI   SPLIT,1             AM I DOING SPLIT-SCREEN 1?\n         BE    *+L'*+4             YES\n         OI    0(R4),EOS           NO, SET END-OF-SCREEN\n         L     R15,=A(ISZHELP)     HELP SCREEN\n         ST    R15,HELPADD\n         MVI   CURROW,CRIZSC       CURSOR ROW\n         MVI   CURCOL,CCIZSC       CURSOR COLUMN\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         LTR   R15,R15             BAD RC?\n         BNZ   IZEOJ               OUT\n*- - - - CHECK TO SEE WHETHER INCORZAP STATEMENTS WAS ENTERED\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         LA    R4,TERMINPT+ZSI     SET START ADDRESS OF REPLY FIELDS\n         L     R8,SCROWS           PICK UP NUMBER OF ROWS\n         CLI   SPLIT,0             AM I DOING SPLIT-SCREEN?\n         BE    IZPFMTPF            NOPE\n         L     R8,SCROWS1          PICK UP NUMBER OF ROWS ON SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   IZPFMTPF            NO, GO TEST PFKEY\n         SLL   R8,2                MULTIPLY BY 4\n         LA    R4,TERMINPT+ZSI(R8) SET START ADDRESS OF REPLY FIELDS\n         L     R8,SCROWS2          PICK UP NUMBER OF ROWS ON SCREEN 2\nIZPFMTPF TM    COMMSW,PFKFLAG      PFK/ATTN ENTERED?\n         BZ    IZPSTTS             NONE\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    SZSSTTM             YES, BACK TO SELECT PANEL\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BE    SZSSTTM             YES, BACK TO SELECT PANEL\n         CLI   0(R2),X'6C'         IS IT PA1?\n         BE    SZSSTTM             YES, BACK TO SELECT PANEL\n         CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    IZPSTTM             YUP, RESHOW SCREEN\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    IZPSTTM             YES, RESHOW SCREEN\n         LA    R1,IPFMSG\n         ST    R1,MSGADD\n*- - - - SET UP INCORZAP STATEMENTS\nIZPSTTS  NI    ISZSW,255-STTXENT   RESET TEXT-ENTERED\n         LA    R15,STMLNES         STATEMENTS START ADDRESS\n         LA    R0,NBRSTTS          NUMBER OF STATEMENTS LINES\nGETSTTS  BCT   R8,*+L'*+4          START SKIPPING LINE1\n         B     ENDSTTS\n         L     R14,0(,R4)          PICK UP ADDRESS OF INPUT LINE\n         CLI   0(R14),0            STATEMENT ENTERED?\n         BE    NXTSTTS             NOPE\n         MVC   1(L'STMLNES-1,R15),0(R15)\n         OC    1(L'IZSCF1,R15),IZSCF1(R14) COPY TEXT IN UPPERCASE\n         OI    ISZSW,STTXENT       SET TEXT-ENTERED\nNXTSTTS  BCT   R0,*+L'*+4\n         B     ENDSTTS\n         LA    R4,4(,R4)           BUMP\n         LA    R15,L'STMLNES(R15)  BUMP TO NEXT STATEMENT\n         B     GETSTTS\nENDSTTS  TM    COMMSW,PFKFLAG      PFK/ATTN ENTERED?\n         BO    IZPSTTM             YES, IT WAS AN INVALID PF-KEY\n         TM    ISZSW,STTXENT       IS TEXT JUST ENTERED?\n         BO    IZPSTTM             YES, WAIT EMPTY PRESS ENTER-KEY\n         LA    R15,STMLNES         STATEMENTS START ADDRESS\n         LA    R0,NBRSTTS          NUMBER OF STATEMENTS LINES\n         CLC   1(L'IZSCF1,R15),=CL71' ' IS THERE A STATEMENT?\n         BNE   *+L'*+12            YES\n         LA    R15,L'STMLNES(R15)  NO, BUMP TO NEXT STATEMENT\n         BCT   R0,*-14\n         B     IZPSTTM             NONE, NO STATEMENT(S)\n         MVI   IZPRTDSN,C' '       CLEAR \"PRT\" DS-NAME\n         MVC   IZPRTDSN+1(L'IZPRTDSN-1),IZPRTDSN\n         MVC   IZPRTVOL(L'IZPRTVOL),IZPRTDSN CLEAR \"PRT\" VOL-SER\n         L     R15,=A(ETPSINCZ)\n*- - - - ETPSINCZ PARM.LIST : NONE\n        CALL   (15)                INVOKE INCORZAP PROGRAM\n         LTR   R1,R1               IS THERE A MESSAGE?\n         BNZ   IZMSST              YES\n         LTR   R15,R15             NO, IS THERE A RC?\n         BZ    IZPTST              NO\n         MVC   IZMSGWA(INCZRCL),INCZRC YES, DISPLAY IT\n         CVD   R15,DBLWRD\n         MVC   DBLWRD(4),=XL4'40202120'\n         ED    DBLWRD(4),DBLWRD+L'DBLWRD-2\n         MVC   IZMSGWA+INCZRCL-2(2),DBLWRD+2\n         LA    R1,IZMSGWA\nIZMSST   ST    R1,MSGADD           SET MESSAGE\nIZPTST   CLI   IZPRTDSN,C' '       IS THERE A \"PRT\" DS-NAME?\n         BE    IZPSTTM             NO, BACK TO ENTER STATEMENT(S)\n*- - - - BUILD \"PRT\" ENTRY SCREEN\n         NI    ISZSW,255-ZPRVIEW-ZPRDEL-ZPRALT RESET ALL\nZPRSBLD  L     R5,=A(ZPRSCR)\n         L     R4,SCROWS1          NUMBER OF ROWS IN SCREEN 1\n         LA    R3,TERMOUT+4        POINT TO FIRST LINE OF SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2\n         BNE   ZPRSBLD1            NOPE, I'M ALL SET\n         SLL   R4,2                MULTIPLY OFFSET BY 4\n         LA    R3,TERMOUT+4(R4)    POINT TO ROW 1 OF SCREEN 2\n         L     R4,SCROWS2          NUMBER OF ROWS IN SCREEN 2\nZPRSBLD1 NI    0(R3),255-EOS       CLEAR END-OF-SCREEN\n         L     R2,0(,R5)           ADDRESS OF FROM FIELD\n         L     R6,0(,R3)           ADDRESS OF \"TO\" FIELD\n         XR    R1,R1\n         IC    R1,0(,R2)           PICK UP LENGTH\n         EX    R1,ZPRSMVL          MOVE IT\n         CLC   ZPOFF1(10,R6),=CL10'PRINT VIEW' VIEWING?\n         BNE   ZPRSBLD2            NO\n         TM    ISZSW,ZPRVIEW       YES\n         BO    *+L'*+10\n         MVC   ZPSCF1(2,R6),=CL2'NO' SET \"NO\"\n         B     ZPRSBLD3            DO THE REST\n         MVC   ZPSCF1(3,R6),=CL3'YES' SET \"YES\"\n         B     ZPRSBLD3            DO THE REST\nZPRSMVL  MVC   0(*-*,R6),0(R2)     <<EXECUTED>>\nZPRSBLD2 CLC   ZPOFF2(8,R6),=CL8'AND / OR' DELETE?\n         BNE   ZPRSBLD3            NO\n         TM    ISZSW,ZPRDEL        YES\n         BO    *+L'*+10\n         MVC   ZPSCF2(2,R6),=CL2'NO' SET \"NO\"\n         B     ZPRSBLD3            DO THE REST\n         MVC   ZPSCF2(3,R6),=CL3'YES' SET \"YES\"\nZPRSBLD3 TM    0(R5),EOL           END-OF-LIST?\n         BO    ZPRSBLD4            YUP\n         BCT   R4,*+L'*+4          END OF SCREEN ROWS?\n         B     ZPRSBLD5            YUP\n         LA    R5,4(R5)            BUMP TO NEXT PARM\n         LA    R3,4(R3)            BUMP TO NEXT PARM\n         B     ZPRSBLD1            KEEP LOOPING\nZPRSBLD4 BCT   R4,*+L'*+4          END OF SCREEN ROWS?\n         B     ZPRSBLD5            YUP\n         LA    R3,4(R3)            BUMP TO NEXT PARM\n         L     R6,0(,R3)           ADDRESS OF \"TO\" FIELD\n         NI    0(R3),255-EOS       CLEAR END-OF-SCREEN\n         MVC   0(ZDUMML,R6),ZDUMM  MOVE IN A DUMMY ROW\n         B     ZPRSBLD4            KEEP LOOPING\nZPRSBLD5 CLI   SPLIT,1             AM I IN SPLIT-SCREEN, SCREEN 1?\n         BE    *+L'*+4             YES\n         OI    0(R3),EOS           SET END-OF-SCREEN\n         L     R15,=A(ZPRHELP)     HELP SCREEN\n         ST    R15,HELPADD\n         TM    ISZSW,ZPRALT        ALTERNATE POSITION?\n         BO    *+L'*+12            YES\n         MVI   CURROW,CRZPSC       CURSOR ROW\n         MVI   CURCOL,CCZPSC       CURSOR COLUMN\n         B     *+L'*+8\n         MVI   CURROW,CRAPSC       ALTERNATE CURSOR ROW\n         MVI   CURCOL,CCAPSC       ALTERNATE CURSOR COLUMN\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         LTR   R15,R15             BAD RC?\n         BNZ   IZEOJ               YUP\n         TM    COMMSW,PFKFLAG      IS IT A PF KEY/ATTN?\n         BZ    ZPCKINPT            NOPE, GO CHECK THE INPUT\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    ZPCKINPT            YUP, LIKE ENTER\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BE    ZPCKINPT            YUP, LIKE ENTER\n         CLI   0(R2),X'6C'         IS IT PA1?\n         BE    IZPSTTM             YUP, FORCE LIKE NO VIEW / NO DELETE\n         CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    ZPRSBLD             YUP, RESHOW SCREEN\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    ZPRSBLD             YUP, RESHOW SCREEN\n         LA    R1,IPFMSG\nZPSTMSG  ST    R1,MSGADD\n         B     ZPRSBLD             RESHOW SCREEN\n*- - - - CHECK ENTERED \"PRT\" SELECTIONS\nZPCKINPT NI    ISZSW,255-ZPRALT-ZPRPOC RESET ALTERNATE AND CHANGED\n         L     R5,TERMINPT+ZPZ1    PICK UP VIEWING FIELD\n         L     R6,TERMINPT+ZPZ2    PICK UP DELETE FIELD\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   ZPCKINPV            NOPE\n         L     R3,SCROWS1          PICK UP SIZE OF SCREEN 1\n         SLL   R3,2                MULTIPLY BY 4\n         L     R5,TERMINPT+ZPZ1(R3) PICK UP VIEWING FIELD\n         L     R6,TERMINPT+ZPZ2(R3) PICK UP DELETE FIELD\nZPCKINPV CLI   0(R5),0             VIEWING ENTERED (OR CHANGED)?\n         BE    ZPCKINPD            NO\n         OI    ISZSW,ZPRPOC        YES, SAY PANEL OPTION CHANGED\n         LA    R0,L'ZPSCF1-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   ZPSCF1(R5),C' '\n         BNE   ZPSTVW\n         MVC   ZPSCF1(L'ZPSCF1-1,R5),ZPSCF1+1(R5)\n         MVI   ZPSCF1+L'ZPSCF1-1(R5),C' '\n         BCT   R0,*-18\nZPRSVW   NI    ISZSW,255-ZPRVIEW   RESET VIEW REQUEST\n         B     ZPCKINPD\nZPSTVW   CLI   ZPSCF1(R5),C'N'\n         BE    ZPRSVW\n         CLI   ZPSCF1(R5),C'Y'\n         BE    *+L'*+8\n         LA    R1,IOPMSG\n         B     ZPSTMSG\n         OI    ISZSW,ZPRVIEW       SET VIEW REQUESTED\nZPCKINPD CLI   0(R6),0             DELETE ENTERED?\n         BE    ZPROCHK             NO\n         OI    ISZSW,ZPRPOC        YES, SAY PANEL OPTION CHANGED\n         LA    R0,L'ZPSCF2-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   ZPSCF2(R6),C' '\n         BNE   ZPSTDL\n         MVC   ZPSCF2(L'ZPSCF2-1,R6),ZPSCF2+1(R6)\n         MVI   ZPSCF2+L'ZPSCF2-1(R6),C' '\n         BCT   R0,*-18\nZPRSDL   NI    ISZSW,255-ZPRDEL    RESET DELETE REQUEST\n         B     ZPROCHK\nZPSTDL   CLI   ZPSCF2(R6),C'N'\n         BE    ZPRSDL\n         CLI   ZPSCF2(R6),C'Y'\n         BE    *+L'*+12\n         OI    ISZSW,ZPRALT\n         LA    R1,IOPMSG\n         B     ZPSTMSG\n         OI    ISZSW,ZPRDEL        SET VIEW REQUESTED\nZPROCHK  TM    ISZSW,ZPRPOC        ANY OPTION CHANGED?\n         BO    ZPRSBLD             YES, RESHOW\n         TM    ISZSW,ZPRVIEW+ZPRDEL HOW SELECTION IS?\n         BZ    ZPKEPT              NO VIEW / NO DELETE\n         TM    ISZSW,ZPRVIEW       VIEW REQUESTED?\n         BZ    ZPBRWOK             NO\n         ICM   R15,B'1111',ARBROWSE YES, VERIFY BROWSE AVAILABLE?\n         BNZ   ZPBRWOK             YES, OK\n        LOAD   EP=ETPSBROW,ERRET=ZLBRERR\n         ST    R0,ARBROWSE         LOADED, OK\n*- - - - PROCESS THE \"PRT\" DATA-SET\nZPBRWOK  L     R7,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R2,R7\n         LH    R3,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R2,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R7\n         MVC   DSNAME,IZPRTDSN     DS-NAME\n         MVC   DSVOLSER,IZPRTVOL   VOL-SER\n         MVC   DSSTATUS,=CL8'SHR'  SET DISP=SHR\n         TM    ISZSW,ZPRDEL        DELETE REQUESTED?\n         BZ    *+L'*+12            NO\n         MVC   DSNDISP,=CL8'UNCATLG' YES, SET DISP=(SHR,UNCATLG,KEEP)\n         MVC   DSADISP,=CL8'KEEP'\n         L     R4,ACOPDCB          PICK UP LIBRARY ADDRESS\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DDNAME\n         MVC   0(ZPRDCBL,R4),ZPRDCB MOVE DCB SKELETON\n         MVC   DCBDDNAM-IHADCB(L'DCBDDNAM,R4),DDNAME SET BACK DDNAME\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    ZPALLOK             OK\n        XMESS  4003\n         TM    ISZSW,ZPRVIEW       VIEW REQUESTED?\n         BZ    *+L'*+8             NO\n         LA    R1,ZPRVMSG          YES\n         B     ZPRTMSG             YUP - ALL DONE\n         LA    R1,ZPRUMSG\nZPRTMSG  ST    R1,MSGADD           YUP - ALL DONE\n         B     IZPSTTM             BACK TO ENTER STATEMENT(S)\nZPALLOK  TM    ISZSW,ZPRVIEW       VIEW REQUESTED?\n         BZ    ZPFREE              NO\n         LA    R2,IZPRTDSN         YES\n         LA    R3,=CL8' '\n         L     R15,ARBROWSE\n*- - - - ETPSBROW PARM.LIST : DCB, DS-NAME, MEMBER-NAME\n        CALL   (15),((R4),(R2),(R3)),VL,MF=(E,PARMVL)\nZPFREE   LR    R0,R7               INITIALIZE DYNAMIC ALLOCATION WORK\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DDNAME\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    ZPFROK              OK\n        XMESS  4004\n         TM    ISZSW,ZPRVIEW       VIEW REQUESTED?\n         BZ    *+L'*+8             NO\n         LA    R1,ZFPVMSG          YES\n         B     ZPRTMSG             YUP - ALL DONE\n         LA    R1,ZFPUMSG\n         B     ZPRTMSG             YUP - ALL DONE\nZPFROK   TM    ISZSW,ZPRDEL        DELETE REQUESTED?\n         BO    ZPDEL               YES\nZPKEPT   LA    R1,ZPKMSG           NO, KEPT\n         B     ZPRTMSG\nZPDEL    LR    R2,R7               INITIALIZE DYNAMIC ALLOCATION WORK\n         LH    R3,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R2,R14              CLEAR TO ALL BLANKS\n         MVC   DSNAME,IZPRTDSN     DS-NAME\n         MVC   DSVOLSER,IZPRTVOL   VOL-SER\n         MVC   DSSTATUS,=CL8'SHR'  SET DISP=SHR\n         MVC   DSNDISP,=CL8'DELETE' SET DISP=(SHR,DELETE,DELETE)\n         MVC   DSADISP,=CL8'DELETE'\n         L     R4,ACOPDCB          PICK UP LIBRARY ADDRESS\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) GET DDNAME FOR USE\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    ZPDLAOK             OK\n        XMESS  4003\n         LA    R1,ZPRDMSG\n         B     ZPRTMSG             YUP - ALL DONE\nZPDLAOK  LR    R0,R7               INITIALIZE DYNAMIC ALLOCATION WORK\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DDNAME\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BNZ   *+L'*+8             WITH ERROR\n         LA    R1,ZPDMSG           OK\n         B     ZPRTMSG             YUP - ALL DONE\n        XMESS  4004\n         LA    R1,ZFPDMSG\n         B     ZPRTMSG             YUP - ALL DONE\n         DROP  R7\nZLBRERR  STM   R0,R1,MESSPL        BROWSE IS UNAVAILABLE\n        XMESS  99,R15\n         LA    R1,BLDMSG\n         B     ZPRTMSG             YUP - ALL DONE\n*- - - - TERMINATE INCORZAP INTERFACE\nIZEOJ    CLI   IZLIBDSN,C' '       ANY \"LIB\" ALLOCATED?\n         BE    LEAVE               NO\n         L     R7,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R2,R7\n         LH    R3,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R2,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R7\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME,IZLIBDDN     DD-NAME\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    LEAVE               OK\n        XMESS  4002\n         LA    R1,ZFLBMSG\n         ST    R1,MSGADD\nLEAVE    L     R0,=A(@SIZE)\n        FREEMAIN R,LV=(0),A=(R9)\nGOBACK   L     R13,4(,R13)         PICK UP CALLING SAVE-AREA\n         LM    R14,R12,12(R13)     RESTORE CALLING REGISTERS\n         XR    R15,R15             SET RC=0\n         BR    R14                 RETURN\n         SPACE 1\nZDUMM    DC    AL1(ZDUMML-1),XL1'04',CL9' '\nZDUMML   EQU   *-ZDUMM\n         SPACE 1\nIPFMSG   MSG   'INVALID PF-KEY'\nINCZRC   MSG   'INCORZAP RC=XX'\nINCZRCL  EQU   *-INCZRC\nZPKMSG   MSG   'IZAP \"PRT\" KEPT'\nZFLBMSG  MSG   'FREE \"LIB\" FAILED'\nZLLBMSG  MSG   'ALLOC \"LIB\" FAILED'\nBLDMSG   MSG   'BROWSE UNAVAILABLE'\nZPDMSG   MSG   'IZAP \"PRT\" DELETED'\nINVMSG   MSG   'INVALID ACCESS-CODE'\nZFPVMSG  MSG   'FREE \"PRT\"/V FAILED'\nZFPUMSG  MSG   'FREE \"PRT\"/U FAILED'\nZFPDMSG  MSG   'FREE \"PRT\"/D FAILED'\nZGTMMSG  MSG   'IN-ZAP GETMAIN ERROR'\nIOPMSG   MSG   'INVALID OPTION (N/Y)'\nZPRVMSG  MSG   'ALLOC \"PRT\"/V FAILED'\nZPRUMSG  MSG   'ALLOC \"PRT\"/U FAILED'\nZPRDMSG  MSG   'ALLOC \"PRT\"/D FAILED'\n         SPACE 1\nIZROW1   DC    AL1(IZROW1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL35' INCORZAP INTERFACE - SELECT PANEL ',34CL1'-'\nIZROW1L  EQU   *-IZROW1\nCRSZSC   EQU   01                  CURSOR ROW ON LINE BELOW\nSZI      EQU   (CRSZSC+1)*4        \"TERMINPT\" DISPLACEMENT\nIZROW2   DC    AL1(IZROW2L-1)\n         DC    XL1'05'             PROTECT, HIGH-LIGHT\n         DC    CL22'ENTER ACCESS-CODE ===>'\nCCSZSC   EQU   (*-IZROW2)          CURSOR COLUMN ON FIELD BELOW\nSZSCF1   EQU   (*-IZROW2)+1,6      INPUT FIELD 1\n         DC    XL1'01',CL6' '      SF UNPROTECTED\n         DC    XL1'04',CL16'(SEE LIST BELOW)' SF PROTECTED\nIZROW2L  EQU   *-IZROW2\nIZROWL   DC    AL1(IZROWLL-1)\n         DC    XL1'04',CL4' '      SF PROTECTED\nSZOFF1   EQU   (*-IZROWL)+1,1\n         DC    XL1'05',CL1' '      PROTECT, HIGH-LIGHT\n         DC    XL1'04',CL2'- '     SF PROTECTED\nSZOFF2   EQU   (*-IZROWL)+0,44\n         DC    CL44' ',CL2' '\nIZROWLL  EQU   *-IZROWL\n         SPACE 1\nISZROW1  DC    AL1(ISZROW1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL34' INCORZAP INTERFACE - ENTRY PANEL ',35CL1'-'\nISZROW1L EQU   *-ISZROW1\nISZROW2  DC    AL1(ISZROW2L-1)\n         DC    XL1'05'             PROTECT, HIGH-LIGHT\n         DC    C'ENTER STATEMENTS (CARD COL.2-72) BELOW:'\n         DC    XL1'04',CL1' '\nISZROW2L EQU   *-ISZROW2\nISZROW3  DC    AL1(ISZROW3L-1)\n         DC    XL1'04',CL6' '\n         DC    CL71'---+----1----+----2----+----3----+----4----+----5--X\n               --+----6----+----7--',CL2' '\nISZROW3L EQU   *-ISZROW3\nCRIZSC   EQU   03                  CURSOR ROW ON LINE BELOW\nZSI      EQU   (CRIZSC+1)*4        \"TERMINPT\" DISPLACEMENT\nISZROW4  DC    AL1(ISZROW4L-1)\n         DC    XL1'05',CL5' ===>'\nCCIZSC   EQU   *-ISZROW4           CURSOR COLUMN ON FIELD BELOW\nIZSCF1   EQU   (*-ISZROW4)+1,71    INPUT FIELD 1\n         DC    XL1'01',CL71' ',XL1'05',CL1'<'\nISZROW4L EQU   *-ISZROW4\n         SPACE 1\nBLNKL    DC    AL1(BLNKLL-1),XL1'04',CL9' '\nBLNKLL   EQU   *-BLNKL\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\nZPRDCB  DCB    DSORG=PS,MACRF=(GM,PM),DDNAME=DUMMY,EODAD=*-*,SYNAD=*-*\nZPRDCBL  EQU   *-ZPRDCB\n         SPACE 1\n         DROP  R9,R10,R11,R12,R13\n        @DST   ,                   DATA-SETS NAMES TABLE\n         EJECT\n*------- INCORZAP SELECT HELP SCREEN --------------------------------*\n         CNOP  0,4\nIZHELP   DC    A(IZHL1)\n         DC    A(HLPENT)\n         DC    A(IZHL2)\n         DC    A(IZHL3)\n         DC    A(IZHL4)\n         DC    A(IZHL5)\n         DC    A(IZHL6)\n         DC    A(IZHL7)\n         DC    A(IZHL8)\n         DC    A(IZHL9)\n         DC    A(IZHL10)\n         DC    A(IZHL11)\n         DC    A(IZHL12)\n         DC    A(IZHL13)\n         DC    A(LNEBLK)\n         DC    A(IZHL14)\n         DC    A(IZHL15)\n         DC    A(IZHL16)\n         DC    A(IZHL17)\n         DC    A(LNEBLK)\n         DC    A(EML+IZHL18)\n         SPACE 1\nIZHL1    DC    AL1(IZHL1L-1)       ROW 01, COL 01\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL20' INCORZAP INTERFACE ',49CL1'-'\nIZHL1L   EQU   *-IZHL1\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\nIZHL2    DC    AL1(IZHL2L-1),XL1'05'\n         DC    C'MAIN STORAGE SUPERZAP FOR MVS : INSPECT OR MODIFY LOADX\n                MODULES IN THE NUCLEUS'\nIZHL2L   EQU   *-IZHL2\nIZHL3    DC    AL1(IZHL3L-1),XL1'05'\n         DC    C'    OR IN THE LINK PACK AREA.'\nIZHL3L   EQU   *-IZHL3\nIZHL4    DC    AL1(IZHL4L-1),XL1'05'\n         DC    C'ONCE A MODULE IS LOADED INTO MAIN STORAGE, CSECT INFORX\n               MATION IS GENERALLY NOT'\nIZHL4L   EQU   *-IZHL4\nIZHL5    DC    AL1(IZHL5L-1),XL1'05'\n         DC    C'    AVAILABLE (THE MVS/XA NUCLEUS IS AN EXCEPTION). FOX\n               R THIS REASON MOST'\nIZHL5L   EQU   *-IZHL5\nIZHL6    DC    AL1(IZHL6L-1),XL1'05'\n         DC    C'    OTHER MECHANISMS TO MODIFY MAIN STORAGE WORK WITH X\n               ABSOLUTE ADDRESSES OR'\nIZHL6L   EQU   *-IZHL6\nIZHL7    DC    AL1(IZHL7L-1),XL1'05'\n         DC    C'    LOAD MODULES ONLY.'\nIZHL7L   EQU   *-IZHL7\nIZHL8    DC    AL1(IZHL8L-1),XL1'05'\n         DC    C'INCORZAP READS THE LIBRARY FROM WHICH THE MAIN STORAGEX\n                VERSION OF THE MODULE'\nIZHL8L   EQU   *-IZHL8\nIZHL9    DC    AL1(IZHL9L-1),XL1'05'\n         DC    C'    WAS LOADED IN ORDER TO DETERMINE CSECT PLACEMENT IX\n               NFORMATION. THIS IS THEN'\nIZHL9L   EQU   *-IZHL9\nIZHL10   DC    AL1(IZHL10L-1),XL1'05'\n         DC    C'    USED BY INCORZAP TO PERMIT CSECT LEVEL REFERENCES X\n               AND CHANGES.'\nIZHL10L  EQU   *-IZHL10\nIZHL11   DC    AL1(IZHL11L-1),XL1'05'\n         DC    C'SO, ENTER THE \"ACCESS-CODE\" TO INDICATE THE CORRESPONDX\n               ING SYSTEM LIBRARY FROM'\nIZHL11L  EQU   *-IZHL11\nIZHL12   DC    AL1(IZHL12L-1),XL1'05'\n         DC    C'    WHICH HAS BEEN LOADED THE CSECT (MODULE) YOU WANT X\n               INSPECT OR MODIFY, AND'\nIZHL12L  EQU   *-IZHL12\nIZHL13   DC    AL1(IZHL13L-1),XL1'05'\n         DC    C'    THEN PRESS THE ENTER-KEY.'\nIZHL13L  EQU   *-IZHL13\nIZHL14   DC    AL1(IZHL14L-1),XL1'05'\n         DC    C'EXAMPLE - 1. ENTER THE ACCESS-CODE FOR \"NUCLEUS\", AND X\n               PRESS THE ENTER-KEY.'\nIZHL14L  EQU   *-IZHL14\nIZHL15   DC    AL1(IZHL15L-1),XL1'05'\n         DC    C'          2. ENTER THE STATEMENT \"DUMP IEANUC01 IGC018X\n               \", AND PRESS TWICE TIME'\nIZHL15L  EQU   *-IZHL15\nIZHL16   DC    AL1(IZHL16L-1),XL1'05'\n         DC    C'             THE ENTER-KEY.'\nIZHL16L  EQU   *-IZHL16\nIZHL17   DC    AL1(IZHL17L-1),XL1'05'\n         DC    C'          3. VIEW THE OUTPUT PRINT (DUMP OF IGC018 CSEX\n               CT IN IEANUC01).'\nIZHL17L  EQU   *-IZHL17\nIZHL18   DC    AL1(IZHL18L-1),XL1'05'\n         DC    C'PF3 RETURNS TO THE PRIMARY OPTION MENU PANEL.'\nIZHL18L  EQU   *-IZHL18\n         EJECT\n*------- INCORZAP STATEMENTS HELP SCREEN ----------------------------*\n         CNOP  0,4\nISZHELP  DC    A(ISZHL1)\n         DC    A(HLPENT)\n         DC    A(ISZHL2)\n         DC    A(ISZHL3)\n         DC    A(ISZHL4)\n         DC    A(ISZHL5)\n         DC    A(ISZHL6)\n         DC    A(ISZHL7)\n         DC    A(ISZHL8)\n         DC    A(ISZHL9)\n         DC    A(ISZHL10)\n         DC    A(ISZHL11)\n         DC    A(ISZHL12)\n         DC    A(ISZHL13)\n         DC    A(ISZHL14)\n         DC    A(ISZHL15)\n         DC    A(ISZHL16)\n         DC    A(LNEBLK)\n         DC    A(ISZHL17)\n         DC    A(ISZHL18)\n         DC    A(LNEBLK)\n         DC    A(EML+ISZHL19)\n         SPACE 1\nISZHL1   DC    AL1(ISZHL1L-1)      ROW 01, COL 01\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL20' INCORZAP INTERFACE ',49CL1'-'\nISZHL1L  EQU   *-ISZHL1\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\nISZHL2   DC    AL1(ISZHL2L-1),XL1'05'\n         DC    C'EIGHT STATEMENTS LINES ARE PROVIDED TO ENTER ONE OR MOX\n               RE INCORZAP STATEMENTS.'\nISZHL2L  EQU   *-ISZHL2\nISZHL3   DC    AL1(ISZHL3L-1),XL1'05'\n         DC    C'CONTROL STATEMENTS ARE COMPATIBLE WITH THE IBM''S SERVX\n               ICE AID IMASPZAP OR'\nISZHL3L  EQU   *-ISZHL3\nISZHL4   DC    AL1(ISZHL4L-1),XL1'05'\n         DC    C'    SUPERZAP PROGRAM. FOLLOWS A SHORT SUMMARY OF SOME X\n               CONTROL STATEMENTS :'\nISZHL4L  EQU   *-ISZHL4\nISZHL5   DC    AL1(ISZHL5L-1),XL1'05'\n         DC    C'NAME LOADMOD  CSECT      SPECIFY MODULE AND/OR CSECT TX\n               O MODIFY.'\nISZHL5L  EQU   *-ISZHL5\nISZHL6   DC    AL1(ISZHL6L-1),XL1'05'\n         DC    C'VER  OFFSET   HEXSTRING  VERIFY STORAGE AT OFFSET WITHX\n               IN MODULE/CSECT MATCHES'\nISZHL6L  EQU   *-ISZHL6\nISZHL7   DC    AL1(ISZHL7L-1),XL1'05'\n         DC    C'                         HEXSTRING.'\nISZHL7L  EQU   *-ISZHL7\nISZHL8   DC    AL1(ISZHL8L-1),XL1'05'\n         DC    C'REP  OFFSET   HEXSTRING  CHANGE STORAGE AT OFFSET WITHX\n               IN MODULE/CSECT TO MATCH'\nISZHL8L  EQU   *-ISZHL8\nISZHL9   DC    AL1(ISZHL9L-1),XL1'05'\n         DC    C'                         HEXSTRING (CAUSES PGFIX IF PAX\n               GEABLE).'\nISZHL9L  EQU   *-ISZHL9\nISZHL10  DC    AL1(ISZHL10L-1),XL1'05'\n         DC    C'RES  OFFSET   HEXSTRING  LIKE REP, BUT CAUSES PGFREE.'\nISZHL10L EQU   *-ISZHL10\nISZHL11  DC    AL1(ISZHL11L-1),XL1'05'\n         DC    C'ZAP  OFFSET   HEXSTRING  ZEROES STORAGE IF EQUAL TO HEX\n               STRING.'\nISZHL11L EQU   *-ISZHL11\nISZHL12  DC    AL1(ISZHL12L-1),XL1'05'\n         DC    C'DUMP LOADMOD  CSECT      PRINT MODULE OR CSECT.'\nISZHL12L EQU   *-ISZHL12\nISZHL13  DC    AL1(ISZHL13L-1),XL1'05'\n         DC    C'BASE HEXVALUE            HEXVALUE WILL BE SUBTRACTED FX\n               ROM NUMERIC OFFSETS.'\nISZHL13L EQU   *-ISZHL13\nISZHL14  DC    AL1(ISZHL14L-1),XL1'05'\n         DC    C'RESET                    CLEARS NO-GO SWITCH (SET BY VX\n               ER FAILURE).'\nISZHL14L EQU   *-ISZHL14\nISZHL15  DC    AL1(ISZHL15L-1),XL1'05'\n         DC    C'/                        LOGICAL LINE SEPARATOR.'\nISZHL15L EQU   *-ISZHL15\nISZHL16  DC    AL1(ISZHL16L-1),XL1'05'\n         DC    C'*                        COMMENT.'\nISZHL16L EQU   *-ISZHL16\nISZHL17  DC    AL1(ISZHL17L-1),XL1'05'\n         DC    C'AFTER YOU HAVE TYPED IN THE STATEMENT(S) LINE(S), JUSTX\n                PRESS ONCE AGAIN THE'\nISZHL17L EQU   *-ISZHL17\nISZHL18  DC    AL1(ISZHL18L-1),XL1'05'\n         DC    C'    ENTER-KEY TO INVOKE THE INCORZAP PROCESSING.'\nISZHL18L EQU   *-ISZHL18\nISZHL19  DC    AL1(ISZHL19L-1),XL1'05'\n         DC    C'PF3 RETURNS TO THE SELECT ENTRY PANEL.'\nISZHL19L EQU   *-ISZHL19\nHLPENT   DC    AL1(HLPENTL-1),XL1'01',CL1' ',XL1'04',CL7' '\nHLPENTL  EQU   *-HLPENT\nLNEBLK   DC    AL1(LNEBLKL-1),XL1'04',CL9' '\nLNEBLKL  EQU   *-LNEBLK\n         EJECT\n*- - - - \"PRT\" ENTRY SCREEN\n         CNOP  0,4\nZPRSCR   DC    A(ZPROW1)\n         DC    A(ZPROW2)\n         DC    A(LNEBLK)\nCRZPSC   EQU   (*-ZPRSCR)/4        CURSOR ROW ON LINE BELOW\nZPZ1     EQU   (*-ZPRSCR)+4        \"TERMINPT\" DISPLACEMENT\n         DC    A(ZPROW3)\n         DC    A(LNEBLK)\nCRAPSC   EQU   (*-ZPRSCR)/4        ALTERNATE CURSOR ROW ON LINE BELOW\nZPZ2     EQU   (*-ZPRSCR)+4        \"TERMINPT\" DISPLACEMENT\n         DC    A(EML+ZPROW4)\n         SPACE 1\nZPROW1   DC    AL1(ZPROW1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL40' INCORZAP INTERFACE - ENTRY PRINT PANEL ',29CL1'-'\nZPROW1L  EQU   *-ZPROW1\nZPROW2   DC    AL1(ZPROW2L-1)\n         DC    XL1'05',CL41'ENTER/VERIFY INCORZAP PRINT REQUIREMENTS:'\n         DC    XL1'04',CL1' '\nZPROW2L  EQU   *-ZPROW2\nZPROW3   DC    AL1(ZPROW3L-1)\nZPOFF1   EQU   (*-ZPROW3)+9,10\n         DC    XL1'04',CL21'        PRINT VIEWING',XL1'05',CL3'==>'\nCCZPSC   EQU   (*-ZPROW3)          CURSOR COLUMN ON FIELD BELOW\nZPSCF1   EQU   (*-ZPROW3)+1,3      INPUT FIELD 1\n         DC    XL1'02',CL3' ',XL1'04',C'(NO/N/YES/Y) '\nZPROW3L  EQU   *-ZPROW3\nZPROW4   DC    AL1(ZPROW4L-1)\nZPOFF2   EQU   (*-ZPROW4)+1,8\n         DC    XL1'04',CL21'AND / OR PRINT DELETE',XL1'05',CL3'==>'\nCCAPSC   EQU   (*-ZPROW4)          ALTERNATE CURSOR COL. ON FIELD BELOW\nZPSCF2   EQU   (*-ZPROW4)+1,3      INPUT FIELD 2\n         DC    XL1'02',CL3' ',XL1'04',C'(NO/N/YES/Y) '\nZPROW4L  EQU   *-ZPROW4\n         EJECT\n*- - - - \"PRT\" ENTRY HELP SCREEN\n         CNOP  0,4\nZPRHELP  DC    A(ZPRHL1)\n         DC    A(HLPENT)\n         DC    A(ZPRHL2)\n         DC    A(ZPRHL3)\n         DC    A(LNEBLK)\n         DC    A(ZPRHL4)\n         DC    A(ZPRHL5)\n         DC    A(ZPRHL6)\n         DC    A(EML+ZPRHL7)\n         SPACE 1\nZPRHL1   DC    AL1(ZPRHL1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL20' INCORZAP INTERFACE ',49CL1'-'\nZPRHL1L  EQU   *-ZPRHL1\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\nZPRHL2   DC    AL1(ZPRHL2L-1),XL1'05'\n         DC    C'THE PRINT PANEL ALLOWS TO VIEW THE SESSION OUTPUT PRINX\n               T DATA-SET (WHEN IT HAS'\nZPRHL2L  EQU   *-ZPRHL2\nZPRHL3   DC    AL1(ZPRHL3L-1),XL1'05'\n         DC    C'    BEEN CREATED), AND / OR DELETE IT (IF NEEDED, ELSEX\n                IT IS KEPT).'\nZPRHL3L  EQU   *-ZPRHL3\nZPRHL4   DC    AL1(ZPRHL4L-1),XL1'05'\n         DC    C'THE OUTPUT PRINT DATA-SET IS ALWAYS NAMED AS FOLLOWS:'\nZPRHL4L  EQU   *-ZPRHL4\nZPRHL5   DC    AL1(ZPRHL5L-1),XL1'05'\n         DC    C'         <USER-ID>.ETPS.IZAPPRT.DYYDDD.THHMMSS.LIST'\nZPRHL5L  EQU   *-ZPRHL5\nZPRHL6   DC    AL1(ZPRHL6L-1),XL1'05'\n         DC    C'    WHERE \"YYDDD\" IS THE YEAR AND SERIAL DAY, AND'\nZPRHL6L  EQU   *-ZPRHL6\nZPRHL7   DC    AL1(ZPRHL7L-1),XL1'05'\n         DC    C'          \"HHMMSS\" IS THE TIME OF DAY.'\nZPRHL7L  EQU   *-ZPRHL7\n         EJECT\n*------- MAIN STORAGE SUPERZAP FOR MVS (INCORZAP) -------------------*\n*        HOUSEKEEPING (PERFORMS PROGRAM INITIALIZATION)\n*        AT ENTRY, R9 = \"WADATA\" WORK-AREA POINTER\n*                  AND R10 POINTS TO \"SPLTAREA\"\n         SPACE 1\n         CNOP  0,4\n         USING *,R12,R10\n         USING SAVE3,R13      ************************** R13 ==> SAVE3\nETPSINCZ STM   R14,R12,12(R13)     SAVE INPUT REGISTERS\n         LR    R12,R15             SET PROGRAM BASE REGISTER 1\n         LR    R11,R10             SPLIT-SCREEN DSECT\n         LA    R3,1\n         LA    R10,4*KB-1(R3,R12)  SET PROGRAM BASE REGISTER 2\n         SH    R11,=Y(SPLITWRK-SAVE3) POINT TO SAVE3\n         ST    R13,4(,R11)         STORE BACKWARD POINTER\n         ST    R11,8(R13)          STORE FORWARD POINTER\n         LR    R13,R11             SET DSECT BASE\n         L     R1,=A(WALEN)\n         LA    R5,0(R1,R9)         1ST WORK-AREA BASE\n         LA    R6,4*KB-1(R3,R5)    2ND WORK-AREA BASE\n         LR    R0,R5\n         L     R1,=A(@DATAL)\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R0,R14              CLEAR ALL TO BINARY ZEROS\n         USING @DATA,R5,R6\n         ST    R9,AWADT            SAVE IT FOR LATER USE\n         USING WADATA,R9\n         LA    R11,XDCBL\n         L     R15,=A(LIBDCB)      POINTER TO DCB IMAGE\n         MVC   0(LIBDCBL,R11),0(R15) MOVE DCB PROTOTYPE\n         USING IHADCB,R11\n         MVC   DCBDDNAM(L'DCBDDNAM),IZLIBDDN SET DD-NAME\n         MVI   XDCBA,VLB           SET \"VL\" BIT\n        OPEN   ((R11),(UPDAT)),MF=(E,XDCBA) OPEN LIB\n         TM    DCBOFLGS,DCBOFOPN   WAS OPEN SUCCESSFUL?\n         BO    LBOPNOK             YES\n         DROP  R11\n         LA    R14,MSG06           NO, LIBRARY OPEN ERROR\n         ST    R14,XMSE\n         BAL   R14,GENERR\n         B     DOTEST\nLBOPNOK  LA    R15,STMLNES         STATEMENTS START ADDRESS\n         LA    R0,NBRSTTS          NUMBER OF STATEMENTS LINES\n         STM   R15,R0,XINSTAC\n         LA    R14,XCARD+71        POINT TO COLUMN 72\n         ST    R14,XPENDREC        SET END OF PHYSICAL RECORD\n         LA    R14,1(R14)          POINT TO BYTE FOLLOWING COL 72\n         ST    R14,XENDREC         TO FORCE NEXT CARD (STATEMENT)\n         B     DOTEST\n         DROP  R9\n         EJECT\n* ROUTINES-SUBROUTINES FLOW :\n* ===========================\n*           NAME     -> CALL R= ROUTINES NAMES OR S= SUBROUTINES NAMES\n*           --------    -----------------------------------------------\n* 1. MAIN : GETREC   -> S= GLREC\n*           GLREC\n*           VERBSCN  -> S= GETFLD   SYNERR\n*                       R= VER      REP      NAM      DUM      COMMENT\n*                          RC       ZAP      GLO      LOC      GETOFF\n* 2. VERB : VER      -> S= GETOFF   GETHEX   BIT31    BIT24    PUTLINE\n*                          DUMP\n*           REP      -> S= PUTLINE  GETOFF   GETHEX   FIXER    MODIFY\n*           NAM      -> S= GETFLD   PUTLINE  SCANMOD  SCANLPA  GENERR\n*                          PRADDR\n*           DUM      -> R= NAM\n*                       S= DUMP\n*           COMMENT\n*           RC       -> S= HEXCV    PUTLINE\n*           ZAP      -> R= VER\n*                       S= FIXER    MODIFY\n*           GLO\n*           LOC\n*           GETOFF   -> S= GETHEX   SYNERR   GETFLD   SCANMOD  PRADDR\n* 3. CALL : GETHEX   -> S= SYNERR\n*           DUMP     -> S= HEXCV    MODESET1 BIT31    BIT24    MODESET2\n*                          PUTLINE\n*           FIXER    -> S= MODESET1 MODESET2\n*           MODIFY   -> S= HEXCV    PUTLINE  MODESET1 BIT31    REAL2VIR\n*                          BIT24    MODESET2\n*           GETFLD   -> S= SYNERR\n*           SCANMOD  -> S= FIND     BIT31    BIT24    READLIB  SYMCHK\n*                          SECTMAP  GENERR\n*           SCANLPA  -> S= GENERR\n*           PRADDR   -> S= HEXCV    PUTLINE\n*           HEXCV    -> S= MODESET1 BIT31    BIT24    MODESET2\n*           REAL2VIR\n*           FIND     -> S= GENERR\n*           SYMCHK   -> S= SYMNEW   SYMFETCH\n*           SYMFETCH -> S= SYMNEW\n*           SYMNEW   -> S= READLIB\n*           READLIB\n*           SECTMAP\n*           BIT24\n*           BIT31\n*           MODESET1\n*           MODESET2\n*           GENERR   -> S= PUTLINE\n*           SYNERR   -> S= PUTLINE\n*           PUTLINE\n         EJECT\n*------- MAIN-LINE EXECUTION : DO WHILE XFEOD=0\n*                                 CALL \"GETREC\"\n*                                 IF XFEOD=0 THEN\n*                                    PRINT REC\n*                                    CALL \"VERBSCN\"\n*                                    END\n*                                 END\n*                              CLOSE FILES\n*                              RETURN\nDOLOOP   BAL   R14,GETREC          GET A LOGICAL RECORD\n         TM    XFLAGS,XFEOD        END-OF-DATA?\n         BO    DOTEST              YES\n         MVI   @LINE,C' '\n         MVC   @LINE+1(L'@LINE-1),@LINE\n         L     R14,XFLDSTRT        POINT TO DATA TO BE MOVED\n         L     R11,XENDREC         GET ADDRESS OF END OF DATA\n         SLR   R11,R14             COMPUTE LENGTH\n         EX    R11,LOGMVC          MOVE R14 TO @LN01\n         BAL   R14,PUTLINE         LOG THE STATEMENT\n         BAL   R14,VERBSCN\nDOTEST   TM    XFLAGS,XFEOD        END-OF-DATA?\n         BZ    DOLOOP              NO\n         MVI   XDCBA,VLB           SET \"VL\" BIT\n        CLOSE (XDCBL),MF=(E,XDCBA) CLOSE LIB\n         TM    XFLAGS,XFOOP        PRT OPENED?\n         BZ    DOFREE              NO\n*- - - - CLOSE AND DE-ALLOCATE THE OUTPUT DATA-SET\n         MVI   XDCBA,VLB           SET \"VL\" BIT\n        CLOSE (XDCBP),MF=(E,XDCBA) CLOSE PRT\n         NI    XFLAGS,255-XFOOP    RESET FLAG\nDOFREE   TM    XFLAGS,XFOAL        PRT ALLOCATED?\n         BZ    DOQUIT              NO, GO BACK AS WELL DONE\n         L     R2,DYNWORKP         INIT. DYNAMIC ALLOC. WORK-AREA\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL72' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         L     R9,AWADT\n         USING WADATA,R9\n         MVC   DDNAME,IZPRTDDN     DDNAME\n         DROP  R9\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         DROP  R2\n         NI    XFLAGS,255-XFOAL    RESET FLAG\n         L     R15,ARDYNAM         FREE IT\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    DOQUIT              OK\n        XMESS  4006                ERROR\n         OC    XMSGA,XMSGA         MESSAGE ADDRESS ALREADY IN?\n         BNZ   *+L'*+8             YES, SKIP\n         LA    R1,FPFMSG           NO\n         ST    R1,XMSGA            SET MESSAGE ADDRESS\n         MVC   XCODE,=F'16'        SET RETURN CODE = 16\nDOQUIT   L     R13,4(,R13)         SWITCH TO OLD SAVE-AREA\n         L     R15,XCODE           RETURN CODE\n         L     R1,XMSGA            MESSAGE ADDRESS (OR ZERO)\n         L     R14,12(,R13)        RESTORE REGISTERS\n         L     R0,20(R13)\n         LM    R2,R12,28(R13)\n         BR    R14                 EXIT PROGRAM\n         EJECT\n*------- VERB ROUTINES ----------------------------------------------*\n         SPACE 1\n*- - - - VERIFY (R14 = LINK REGISTER)\nVER      STM   R14,R12,@SVVER\n         BAL   R14,GETOFF          GO GET VALUE OF OFFSET\n         BAL   R14,GETHEX          GO GET HEX STRING\n         TM    XFLAGS,XFEOD        EXIT REQUESTED?\n         BO    VERX                YES\n         BAL   R14,BIT31           GET INTO 31-BIT MODE\n         L     R14,XHL\n         BCTR  R14,0\n         L     R11,XZADDR\n         EX    R14,VERCLC          VERIFY THE DATA\n         BNE   VERNO               BRANCH NOT VERIFIED\n         BAL   R14,BIT24           INSURE BACK TO 24-BIT MODE\n         B     VERX                EXIT IF IT VERIFIES OK\nVERNO    OI    XFLAGS,XFNOGO       SET NO-GO SWITCH\n         MVC   XCODE,=F'4'         SET RETURN CODE = 4\n         MVI   @LN33,C' '\n         MVC   @LN34(87),@LN33\n         MVC   @LN01(32),REJECT\n         BAL   R14,BIT24           GET BACK TO 24-BIT MODE\n         BAL   R14,PUTLINE         ISSUE REJECT MESSAGE\n         TM    XFLAGS,XFERR        PRT IN ERROR?\n         BO    VERX                YES, GO BACK (FLUSH)\n         BAL   R14,DUMP            DUMP THE MODULE\nVERX     LM    R14,R12,@SVVER\n         BR    R14\n*- - - - REP OR RES OR RESET (R14 = LINK REGISTER)\nREP      STM   R14,R12,@SVREP\n         CLC   XEBV,=CL8'RESET'    IS IT RESET?\n         BNE   REPIN               NO, BRANCH IF REP OR RES\n         NI    XFLAGS,255-XFNOGO   RESET, JUST SET NO-GO SWITCH OFF\n         B     REPX\nREPIN    TM    XFLAGS,XFNOGO       IS NO-GO SWITCH ON?\n         BZ    REPGO               NO, BRANCH\n         MVI   @LN37,C' '\n         MVC   @LN38(83),@LN37\n         MVC   @LN01(36),IGNORED\n         BAL   R14,PUTLINE\n         B     REPX\nREPGO    BAL   R14,GETOFF\n         BAL   R14,GETHEX\n         TM    XFLAGS,XFEOD        EXIT REQUESTED?\n         BO    REPX                YES\n         CLC   XEBV,=CL8'REP'      IS THIS A REP?\n         BNE   RESTX               NO, GO DO RESTORE PROCESSING\n         BAL   R14,FIXER           FIX PAGE IF REP\n         BAL   R14,MODIFY          GO MODIFY STORAGE\n         B     REPX                SKIP RESTORE PROCESSING\nRESTX    BAL   R14,MODIFY          GO MODIFY STORAGE\n         BAL   R14,FIXER           GO UNFIX STORAGE\nREPX     LM    R14,R12,@SVREP\n         BR    R14\n*- - - - NAME (R14 = LINK REGISTER)\nNAM      STM   R14,R12,@SVNAM\n         NI    XFLAGS,255-XFNOGO   RESET NO-GO SWITCH\n         SLR   R14,R14\n         STCM  R14,B'0111',XCSLEN+1\n         ST    R14,XBASE           GET OPERANDS\n         MVC   XRCVLEN,=F'8'\n         LA    R14,XEBLM           PUT ADDRESS OF MEMBER\n         ST    R14,XRCVADDR        IN GETFLD RESULT POINTER\n         B     NAMGO1              DO UNTIL POINTER GT MEMBER+8\nNAMLP1   BAL   R14,GETFLD          CALL GETFLD TO GET NEXT OPERAND\n         LA    R14,8               ADD 8\n         AL    R14,XRCVADDR         TO\n         ST    R14,XRCVADDR          GETFLD RESULT ADDRESS\nNAMGO1   LA    R11,XEBCS           IF R14 GT MEMBER+8\n         CR    R14,R11              THEN\n         BNH   NAMLP1                EXIT DO LOOP\n*                                  CHECK FOR A GLOBAL MODULE IN\n         TM    @SWB,XFLOCSW         LOCAL MODE?\n         BZ    NAMOK1              NO, BRANCH\n         CLC   XEBLM(6),=CL6'IEANUC'    YES, DOES NAME LOOK GLOBAL\n         BE    NAMWARN             YES, ISSUE WARNING\n         CLC   XEBLM(5),=CL5'IGC00'     DOES NAME LOOK GLOBAL?\n         BNE   NAMOK1              NO, BRANCH\nNAMWARN  MVI   @LN58,C' '          ISSUE WARNING\n         MVC   @LN59(62),@LN58\n         MVC   @LN01(57),WARNMSG\n         BAL   R14,PUTLINE\n*              IF A CSECT WAS SPECIFIED, GET THE OFFSET TO THIS\n*              CSECT FROM THE BEGINNING OF THE LOAD MODULE\nNAMOK1   TM    XFLAGS,XFEOD        EXIT REQUESTED?\n         BO    NAMOK3              YES\n         CLC   XEBCS(L'XEBCS),=CL72' '\n         BNE   NAMOK2\n         SLR   R14,R14             CSECT OMITTED\n         ST    R14,XCSOFF          OFFSET ZERO INTO MODULE\n         B     NAMOK3\nNAMOK2   MVC   XEBLBL(8),XEBCS     MAKE CSECT THE LABEL TO LOOKUP\n         BAL   R14,SCANMOD         GO SCAN MODULE FOR THIS LABEL\n         L     R14,XOFFSET\n         ST    R14,XCSOFF          OFFSET INTO MODULE\nNAMOK3   TM    XFLAGS,XFEOD        GET IN-CORE ADDRESS OF LOAD MODULE\n         BO    NAMEX               BR IF EXIT REQUESTED\n         TM    @SWB,XFLOCSW\n         BZ    NAMOK4              BR IF NOT LOCAL MODE\n        LOAD   EPLOC=XEBLM,DCB=XDCBL LOAD A COPY FOR LOCAL MODE\n         BAL   R14,SCANLPA         GO FIND LOADED MODULE IN JPA\n         B     NAMEEOD\nNAMOK4   CLC   XEBLM(6),=CL6'IEANUC'\n         BNE   NAMSCNL\n         CLC   XEBCS(L'XEBCS),=CL72' ' NUCLEUS, IS CSECT SPECIFIED ?\n         BNE   PASTNCSE            YES, BRANCH\n         LA    R14,MSG05           NO, CSECT REQUIRED WITH NUCLEUS\n         ST    R14,XMSE\n         BAL   R14,GENERR\n         B     NAMEX               EXIT\nPASTNCSE L     R14,CVTPTR          CVT ADDRESS\n         USING CVT,R14\n         TM    CVTDCB,CVTMVSE      IS THIS MVS/XA?\n         DROP  R14\n         BO    NAMEEOD             YES, SKIP LM ADDR (SET BY SCANMOD)\n         SLR   R14,R14\n         ST    R14,XLMADDR         NUCLEUS LOCATION IS ZERO\n         B     NAMEEOD\nNAMSCNL  BAL   R14,SCANLPA\nNAMEEOD  TM    XFLAGS,XFEOD        EXIT REQUESTED?\n         BO    NAMEX               YES\n         L     R14,XLMADDR\n         AL    R14,XCSOFF\n         ST    R14,XCSADDR         ADDRESS OF CSECT\n         ST    R14,XLOC\n         BAL   R14,PRADDR\nNAMEX    LM    R14,R12,@SVNAM\n         BR    R14\n*- - - - DUMP (R14 = LINK REGISTER)\nDUM      STM   R14,R12,@SVDUM\n         BAL   R14,NAM\n         BAL   R14,DUMP\n         LM    R14,R12,@SVDUM\n         BR    R14\n*- - - - HANDLE COMMENT STATEMENTS (R14 = LINK REGISTER)\nCOMMENT  BR    R14\n*- - - - RETURN CODE (R14 = LINK REGISTER)\nRC       STM   R14,R12,@SVRC\n         MVI   @LN17,C' '\n         MVC   @LN18(103),@LN17\n         MVC   @LN01(16),EQRC      DISPLAY CURRENT RETURN CODE\n         LA    R14,XCODE\n         AL    R14,=F'3'\n         ST    R14,XHEX\n         LA    R14,@LN01\n         ST    R14,XEBAD\n         MVC   XHEXL,ONE\n         BAL   R14,HEXCV\n         BAL   R14,PUTLINE\n         LM    R14,R12,@SVRC\n         BR    R14\n*- - - - ZERO (AND PGFIX) STORAGE (R14 = LINK REGISTER)\nZAP      STM   R14,R12,@SVZAP\n         BAL   R14,VER\n         TM    XFLAGS,XFEOD+XFNOGO EXIT OR NO-GO REQUESTED?\n         BNZ   ZAPX                YES\n         BAL   R14,FIXER           FIX PAGE IF LPA\n         L     R14,XHL\n         BCTR  R14,0               LENGTH MINUS 1 FOR EX\n         EX    R14,ZAPXC           MAKE REP DATA ALL ZEROS\n         BAL   R14,MODIFY\nZAPX     LM    R14,R12,@SVZAP\n         BR    R14\n*- - - - GLOBAL (R14 = LINK REGISTER)\nGLO      NI    @SWB,255-XFLOCSW\n         BR    R14\n*- - - - LOCAL (R14 = LINK REGISTER)\nLOC      OI    @SWB,XFLOCSW\n         BR    R14\n*- - - - BASE - GET OFFSET (R14 = LINK REGSITER)\n*              INPUT : XFLDSTRT\n*              OUTPUT : XZADDR = IN-CORE ADDR CORRESPONDING TO OFFSET\nGETOFF   STM   R14,R12,@SVBASE\n         SLR   R14,R14\n         ST    R14,XGOS\n         MVI   XGOC,C' '\n         B     BASGO1              SCAN FOR 1ST CHAR OF OFFSET\nBASLP1   L     R14,XFLDSTRT\n         CL    R14,XENDREC\n         BNH   BASOK1\n         ST    R14,XGOS\n         B     BASGO1\nBASOK1   L     R14,XFLDSTRT\n         CLI   0(R14),C' '\n         BNE   BASOK2\n         AL    R14,ONE\n         ST    R14,XFLDSTRT\n         B     BASGO1\nBASOK2   L     R14,XFLDSTRT\n         MVC   XGOC,0(R14)\n         ST    R14,XGOS\nBASGO1   L     R14,XGOS\n         LTR   R14,R14\n         BZ    BASLP1\n*                                  CHECK FIRST CHAR TO DETERMINE\n*                                   TYPE OF OFFSET (HEX OR LBL)\n         CLI   XGOC,C''''          QUOTE (LABEL OFFSET)?\n         BE    BASQOT              YES, BRANCH\n*                                  PROCESS A HEXADECIMAL OFFSET\n         BAL   R14,GETHEX          GET HEX OFFSET\n         L     R14,XHL\n         CL    R14,=F'4'\n         BNH   BASOK3\n         LA    R14,MSG02           OFFSET FIELD IS TOO LONG\n         ST    R14,XMSE\n         BAL   R14,SYNERR          SYNTAX ERROR\n         B     BASX\nBASOK3   L     R14,XHL\n         SLR   R11,R11\n         CR    R14,R11             IS XHL ZERO?\n         BE    BASX                YES, GO EXIT\n         ST    R11,XHOP            LEADING ZEROES\n         LCR   R14,R14             1, 2, 3, OR 4 BECOME -1, -2, -3, -4\n         AL    R14,=F'5'           BECOME +4 +3 +2 +1\n         LA    R11,XHOP-1(R14)\n         LCR   R14,R14             BECOME -4 -3 -2 -1\n         AL    R14,=F'4'           BECOME 0 1 2 3 LENGTH CODE\n         EX    R14,MVREPDT         MOVE REPDATA TO R11\n         CLC   XEBV(3),=CL3'BAS'   IS THIS A BASE STATEMENT?\n         BNE   BASINN              NO, ITS A VER OR REP, BRANCH\n         L     R14,XHOP\n         ST    R14,XBASE           STORE BASE VALUE\n         B     BASX\nBASINN   L     R14,XCSADDR         GET ADDRESS OF CSECT\n         AL    R14,XHOP            ADD OFFSET\n         SL    R14,XBASE           SUBTRACT VALUE FROM 'BASE' VERB\n         ST    R14,XZADDR          SAVE THIS AS ADDRESS TO ZAP\n         B     BASX                GO EXIT\nBASQOT   MVI   XEBLBL+1,C' '       PROCESS A SYMBOLIC (LABEL) OFFSET\n         MVC   XEBLBL+2(6),XEBLBL+1\n         MVI   XEBLBL,C' '\n         LA    R14,XEBLBL\n         ST    R14,XRCVADDR\n         MVC   XRCVLEN,=F'8'\n         BAL   R14,GETFLD          GO GET LABEL\n         CLC   XEBLBL(L'XEBLBL),=CL72' '\n         BE    BASMISS\n         BAL   R14,SCANMOD         GO SCAN MOD FOR VALUE OF LABEL\n         L     R14,XLMADDR         GET ADDRESS OF MODULE\n         AL    R14,XOFFSET         ADD OFFSET TO CSECT\n         ST    R14,XZADDR          STORE ADDR TO ZAP\n         ST    R14,XLOC\n         TM    XFLAGS,XFEOD        END-OF-DATA?\n         BO    BASX                NO\n         BAL   R14,PRADDR          GO PRINT ADDRESS\n         B     BASX                GO EXIT\nBASMISS  LA    R14,MSG10           REQUIRED FIELD MISSING\n         ST    R14,XMSE\n         BAL   R14,SYNERR          SYNTAX ERROR\nBASX     LM    R14,R12,@SVBASE\n         BR    R14\n         EJECT\n*------- SUBROUTINES ------------------------------------------------*\n         SPACE 1\n*- - - - RECORD FETCHING (R14 = LINK REGISTER)\nGETREC   STM   R14,R12,@SVGTRC\n         BAL   R14,GLREC           TRY TO GET A LOGICAL RECORD\n         B     GETCGO              DO WHILE NO LOGICAL REC GOTTEN\nGETCLP   LM    R15,R0,XINSTAC      GET A PHYSICAL RECORD\n         LTR   R0,R0               ALL STATEMENTS PROCESSED?\n         BNP   CTLEOD              YES\n         CLC   0(72,R15),=CL72' '  NO, IS THERE A STATEMENT?\n         BNE   GETINS              YES, PROCESS IT\n         LA    R15,L'STMLNES(R15)  NO, BUMP TO NEXT STATEMENT\n         BCT   R0,*-14             ALL STATEMENTS PROCESSED?\n*                                  YES, END-OF-DATA (EODAD) FOR INPUT\nCTLEOD   OI    XFLAGS,XFEOD        SET IT\n         B     GETCX\nGETINS   MVC   XCARD(L'XCARD),0(R15) COPY CARD\n         LA    R15,L'STMLNES(R15)  BUMP TO NEXT STATEMENT\n         BCTR  R0,0                REDUCE STATEMENTS COUNT\n         STM   R15,R0,XINSTAC      AND SAVE\n         LA    R14,XCARD\n         LR    R11,R14\n         BCTR  R11,0\n         ST    R11,XENDREC         POINT TO BYTE PRECEDING COL 1\n         SL    R14,=F'-71'         POINT TO COLUMN 72\n         ST    R14,XPENDREC        THIS IS END OF PHYSICAL RECORD\n         BAL   R14,GLREC           NOW GO GET LOGICAL RECORD\nGETCGO   CLC   XENDREC,XPENDREC    IS THERE MORE PHYS REC LEFT\n         BH    GETCLP              BRANCH IF NOT\nGETCX    LM    R14,R12,@SVGTRC\n         BR    R14\n*- - - - LOGICAL RECORD EXTRACTION (R14 = LINK REGISTER)\nGLREC    STM   R14,R12,@SVGLRC\n         L     R14,XENDREC\n         CL    R14,XPENDREC\n         BH    SEPX\n         AL    R14,ONE             ADD 1 TO\n         ST    R14,XENDREC          END POINTER\n         ST    R14,XFLDSTRT        INITIALIZE GETFLD BEGIN ADDRESS\n         SLR   R14,R14             SET\n         ST    R14,XPS              SW = 0\n         B     SEPGO1              DO UNTIL SW NE 0\nSEPLP1   CLC   XENDREC,XPENDREC\n         BL    SEPOK1\n         LA    R14,1               SET\n         ST    R14,XPS              SW = 1\n         B     SEPGO1\nSEPOK1   L     R14,XENDREC\n         CLI   0(R14),C'/'         MULTIPLE STATEMENTS PER CARD?\n         BNE   SEPNXT              NO\n         MVI   0(R14),C' '         YES, CHANGE SLASH TO BLANK\n         LA    R14,1               SET\n         ST    R14,XPS              SW = 1\n         B     SEPGO1\nSEPNXT   LA    R14,1               ADD 1\n         AL    R14,XENDREC          TO\n         ST    R14,XENDREC           END POINTER\nSEPGO1   L     R14,XPS\n         LTR   R14,R14\n         BZ    SEPLP1\nSEPX     LM    R14,R12,@SVGLRC\n         BR    R14\n*- - - - VERB SCANNING AND ROUTING (R14 = LINK REGISTER)\nVERBSCN  TM    XFLAGS,XFERR        PRT IN ERROR?\n         BOR   R14                 YES, GO BACK (FLUSH)\n         STM   R14,R12,@SVVSCN\n         LA    R14,XEBV\n         ST    R14,XRCVADDR\n         MVC   XRCVLEN,=F'8'\n         BAL   R14,GETFLD\n         SLR   R14,R14\n         ST    R14,XVXSW           SET SW OFF\n         LA    R14,1\n         ST    R14,XVX             SET SUBSCRIPT TO 1\n         L     R8,=A(OPCODES)      ADDRESS OF VERB TABLE\n         L     R9,=A(OPENTRY)      ADDRESS OF VERB ROUTINES TABLE\nPROCLOOP L     R11,XVXSW\n         LTR   R11,R11             HAS SW BEEN SET ON?\n         BNZ   PROCDONE            YES, JUMP OUT\n         BCTR  R14,0\n         LR    R11,R14\n         MH    R11,=Y(L'OPCODES)\n         LA    R7,0(R8,R11)        GET ADDRESS OF VERB TABLE ENTRY\n         CLC   XEBV(3),0(R7)       IS THIS THE RIGHT VERB?\n         BNE   PROCINCR            NO, GO INCREMENT TO NEXT ONE\n         SLA   R14,2\n         L     R15,0(R9,R14)       GET VERB ROUTINE ADDRESS\n         BALR  R14,R15             CALL THE ROUTINE FOR THIS OPERATION\n         TM    XFLAGS,XFEOD        EXIT REQUESTED?\n         BO    VERBSCNX            YES\n         LA    R14,1\n         ST    R14,XVXSW           SET SW ON\nPROCINCR LA    R14,1\n         AL    R14,XVX\n         ST    R14,XVX\n         CH    R14,=Y(OPNUM)       HAVE ALL VERBS BEEN CHECKED?\n         BNH   PROCLOOP            NO, KEEP CHECKING\nPROCDONE L     R14,XVXSW           WAS SW EVER SET ON\n         LTR   R14,R14             YES, BRANCH\n         BNZ   VERBSCNX\n         LA    R14,MSG09           OPERATION REQUESTED IS INVALID\n         ST    R14,XMSE\n         BAL   R14,SYNERR          SYNTAX ERROR\nVERBSCNX LM    R14,R12,@SVVSCN\n         BR    R14\n*- - - - HEXADECIMAL FIELD FETCHING (R14 = LINK REGISTER)\n*              INPUT : XFLDSTRT = ADDR OF START OF FIELD\n*              OUTPUT : XHS = HEX STRING\n*                       XHSL = LENGTH OF HEX STRING\nGETHEX   STM   R14,R12,@SVGHEX\n         SLR   R14,R14\n         ST    R14,XHSW            SET SW = 0\n         ST    R14,XHL             SET LEN = 0\n         L     R14,XFLDSTRT\n         ST    R14,XHP\n*                                  MOVE FIELD TO 'XHW' AND\n*                                   STRIP OUT COMMAS\n         B     HPAGO1              DO UNTIL XHSW NE 0\nHPALP1   CLC   XHP,XENDREC         STILL WITHIN STATEMENT?\n         BNH   HPAIN1              YES, BRANCH\n         MVC   XHSW,ONE\n         B     HPAGO1\nHPAIN1   L     R14,XHP\n         CLI   0(R14),C' '         IS IT A BLANK?\n         BNE   HPANBK              NO, BRANCH\n         L     R14,XHL\n         LTR   R14,R14\n         BNP   *+L'*+10\n         MVC   XHSW,ONE\n         B     HPAGO1\n         LA    R14,1\n         AL    R14,XHP\n         ST    R14,XHP\n         B     HPAGO1\nHPANBK   L     R14,XHP             NOT A BLANK\n         CLI   0(R14),C','         IS IT A COMMA?\n         BE    HPAINCR             YES, GO IGNORE IT\n         LA    R11,1               ADD 1\n         AL    R11,XHL              TO\n         ST    R11,XHL               MODLEN\n         LA    R7,XHW-1(R11)\n         MVC   0(1,R7),0(R14)      COPY THE CHARACTER TO WORK-AREA\nHPAINCR  LA    R14,1               POINT\n         AL    R14,XHP              TO\n         ST    R14,XHP               NEXT CHARACTER\nHPAGO1   SLR   R14,R14\n         CL    R14,XHSW\n         BE    HPALP1\n         L     R11,XHP             CHECK FOR MISSING FIELD\n         ST    R11,XFLDSTRT\n         CL    R14,XHL             IS LENGTH ZERO?\n         BNE   HPAOK1              NO, BRANCH\n         LA    R14,MSG10           REQUIRED FIELD MISSING\n         ST    R14,XMSE\n         BAL   R14,SYNERR          SYNTAX ERROR\n         B     HPAX\nHPAOK1   SLR   R2,R2               CHECK FOR INVALID (NON-HEX) CHARS\n         L     R1,XHL\n         BCTR  R1,0\n         L     R14,=A(HEXTRT)\n         EX    R1,HPRTRT           TRT WORK-AREA\n         LTR   R2,R2               ARE ALL CHARACTERS HEX?\n         BZ    HPAOK2              YES, BRANCH\n         LA    R14,MSG03           INVALID HEX CHARACTER\n         ST    R14,XMSE\n         BAL   R14,SYNERR          SYNTAX ERROR\n         B     HPAX\nHPAOK2   L     R14,=A(HEXTR)       TRANSLATE FROM EBCDIC TO HEX\n         TR    XHW,0(R14)          TRANSLATE TO 'UNPACKED' HEX\n         LA    R14,XHS\n         ST    R14,XHSPTR\n         LA    R14,XHW             SET\n         ST    R14,XHWPTR           PTR = ADDR(WORK-AREA)\n         B     HPAGO2              DO WHILE PTR LE ADDR(WORK-AREA)+LEN\nHPALP2   L     R14,XHWPTR\n         PACK  XHPW,0(16,R14)      PACK 16 BYTES AT A TIME\n         L     R11,XHSPTR\n         MVO   0(9,R11),XHPW       SHIFT TO GET RID OF SIGN\n         AL    R11,=F'8'           ADD 8 TO\n         ST    R11,XHSPTR           HEX RESULT ADDRESS\n         AL    R14,=F'16'          ADD 16 TO\n         ST    R14,XHWPTR           PTR\nHPAGO2   L     R14,XHL\n         LA    R11,XHW\n         ALR   R11,R14\n         CL    R11,XHWPTR\n         BH    HPALP2              END OF DO LOOP\n*                                  CHECK FOR EVEN NUMBER OF\n*                                   HEX DIGITS\n         ST    R14,Y\n         LR    R2,R14              PREPARE TO DIVIDE\n         SRDA  R2,32               PREPARE TO DIVIDE\n         D     R2,=F'2'            HALVE THE LENGTH\n         ST    R3,XHL              SAVE LENGTH\n         ALR   R3,R3               DOUBLE IT\n         CR    R14,R3              AND COMPARE TO ORIGINAL\n         BE    HPAX                IF EQUAL, THERE WERE AN EVEN NUMBER\n         LA    R14,MSG11           UNEVEN NUMBER OF HEX DIGITS\n         ST    R14,XMSE\n         BAL   R14,SYNERR          SYNTAX ERROR\nHPAX     LM    R14,R12,@SVGHEX\n         BR    R14\n*- - - - DUMP MAIN STORAGE (R14 = LINK REGISTER)\n*              INPUT : XCSADDR=ADDRESS OF CSECT TO BE DUMPED\n*                      XCSLEN = LENGTH TO DUMP\nDUMP     STM   R14,R12,@SVDMP\n         L     R14,XCSLEN          IS\n         LA    R14,0(,R14)          AN\n         LTR   R14,R14               ENDING ADDRESS SPECIFIED?\n         BNZ   *+L'*+6             YES, BRANCH\n         MVC   XCSLEN+1(3),ONE+1\n         L     R14,=F'-32'         FFFFFFE0\n         L     R11,XCSADDR         GET STARTING ADDRESS\n         L     R7,XCSLEN           GET LENGTH\n         LA    R7,0(,R7)\n         ALR   R7,R11              ADD TO START ADDRESS\n         BCTR  R7,0\n         NR    R7,R14              ROUND DOWN TO MULTIPLE OF 32\n         ST    R7,XDUMPEND         SAVE DUMP END ADDRESS\n         MVI   @LN02,C' '\n         MVC   @LN03(L'@LINE-3),@LN02\n         MVI   @LN01,C' '\n         MVC   XHEXL,=F'4'\n         NR    R11,R14             ROUND DOWN TO MULTIPLE OF 32\n         ST    R11,XDP             DUMP START ADDRESS\n         B     DUMPGO\nDUMPLP   LA    R14,@LN01\n         ST    R14,XEBAD\n         LA    R14,XDP\n         ST    R14,XHEX\n         BAL   R14,HEXCV           PUT HEX ADDRESS IN LINE\n         L     R14,XDP\n         ST    R14,XHEX\n         LA    R14,1\n         ST    R14,I               SET SUBSCRIPT TO 1\nDUMPLLP  MH    R14,=H'9'           ADD SUBSCRIPT*9\n         LA    R14,@LN03(14)        TO LINE+3\n         ST    R14,XEBAD           SAVE RESULT IN HEX TO ADDRESS\n         BAL   R14,HEXCV           PERFORM HEX CONVERSION\n         L     R14,XHEX            ADD\n         AL    R14,XHEXL            HEXLEN\n         ST    R14,XHEX              TO HEXFR\n         LA    R14,1               ADD 1\n         AL    R14,I                TO\n         ST    R14,I                 SUBSCRIPT\n         CL    R14,=F'4'           IS SUBSCRIPT GT 4?\n         BNH   DUMPLLP             NO, LOOP (LEFT HALF OF PAGE)\n         LA    R14,1               YES,\n         ST    R14,I                RESET SUBSCRIPT TO 1\nDUMPRLP  MH    R14,=H'9'\n         LA    R14,@LN41(14)\n         ST    R14,XEBAD\n         BAL   R14,HEXCV\n         L     R14,XHEX\n         AL    R14,XHEXL\n         ST    R14,XHEX\n         LA    R14,1\n         AL    R14,I\n         ST    R14,I\n         CL    R14,=F'4'           IS SUBSCRIPT GT 4?\n         BNH   DUMPRLP             NO, LOOP (RIGHT HALF OF PAGE)\n         MVI   @LN87,C'*'\n         MVI   @LN120,C'*'\n         BAL   R14,MODESET1        GET INTO KEY 0\n         BAL   R14,BIT31           GET INTO 31-BIT MODE\n         L     R14,XDP\n         MVC   @LN88(32),0(R14)    MOVE IN CHAR PORTION\n         BAL   R14,BIT24           GET BACK TO 24-BIT MODE\n         BAL   R14,MODESET2        GET BACK TO USER KEY\n         L     R14,=A(EBCDIC)\n         TR    @LN88(32),0(R14)\n         BAL   R14,PUTLINE\n         TM    XFLAGS,XFERR        PRT IN ERROR?\n         BO    DUMPX               YES, GO BACK (FLUSH)\n         LA    R11,32              ADD 32\n         AL    R11,XDP              TO\n         ST    R11,XDP               DUMP ADDRESS\nDUMPGO   CL    R11,XDUMPEND\n         BNH   DUMPLP\nDUMPX    LM    R14,R12,@SVDMP\n         BR    R14\n*- - - - PGFIX/FREE (R14 = LINK REGISTER)\n*              INPUT : XZADDR = ADDR OF STORAGE TO BE CHANGED\n*                      XHL = LENGTH OF STORAGE\n*                      XEBV = VERB\nFIXER    STM   R14,R12,@SVFXR\n         TM    @SWB,XFLOCSW\n         BO    PAGEX\n         CLC   XEBLM(6),=CL6'IEANUC' IS THIS A NUCLEUS ZAP?\n         BE    PAGEX               YES, NO NEED TO FIX/FREE\n         BAL   R14,MODESET1        SUP STATE, KEY ZERO\n         AL    R13,=F'12'          CHANGE R13 FOR SETLOCK\n        SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=SAVE,RELATED=X\n         SLR   R4,R4               NO TCB - PGFIX NOT TO BE OWNED\n         ST    R4,XPECB            CLEAR THE ECB\n         LA    R0,XPECB            ECB ADDRESS\n         L     R14,XZADDR          GET STARTING ADDRESS\n         LR    R1,R14              STARTING ADDRESS\n         AL    R14,XHL             COMPUTE ENDING ADDRESS\n         LR    R2,R14              ENDING ADDRESS+1\n         BCTR  R14,0               ENDING ADDRESS\n         CLC   XEBV(3),=CL8'RESET' IS THIS A RES?\n         BE    FREEPAGE            YES, FREE THE PAGE\nFIXPAGE PGSER  R,FIX,A=(1),EA=(R14),TCB=0,ECB=(0),LONG=Y,BRANCH=Y,     X\n               RELATED=FREEPAGE\n         B     SVPSRC\nFREEPAGE PGSER R,FREE,A=(1),EA=(R14),TCB=0,BRANCH=Y,RELATED=FIXPAGE\nSVPSRC   ST    R15,XPSRC           SAVE RETURN CODE\n        SETLOCK RELEASE,TYPE=LOCAL,REGS=SAVE,RELATED=X\n         SL    R13,=F'12'          PUT R13 BACK TO NORMAL\n         BAL   R14,MODESET2        PROBLEM STATE, KEY NZERO\n         CLC   XPSRC,=F'8'         DID PAGE SERVICES RETURN AN 8?\n         BNE   PAGEX               NO, NO NEED TO WAIT\n        WAIT   ECB=XPECB\nPAGEX    LM    R14,R12,@SVFXR\n         BR    R14\n*- - - - MODIFY STORAGE (R14 = LINK REGISTER)\n*              INPUT : XHS = HEX STRING\n*                      XHL = LENGTH OF HEX STRING\n*                      XZADDR = ADDRESS OF CORE TO BE OVERLAYED\nMODIFY   STM   R14,R12,@SVMOD\n         MVI   @LN14,C' '\n         MVC   @LN15(106),@LN14\n         MVC   @LN01(13),OLDWAS\n         L     R14,XHL             LENGTH OF DATA TO BE MODIFIED\n         ST    R14,XHEXL\n         L     R14,XZADDR          ADDRESS OF DATA TO BE MODIFIED\n         ST    R14,XHEX\n         LA    R14,@LN01\n         AL    R14,=F'13'\n         ST    R14,XEBAD           PUT HEX DUMP AT LINE+1+13\n         BAL   R14,HEXCV           CONVERT OLD DATA TO HEX\n         BAL   R14,PUTLINE         DISPLAY OLD DATA\n         TM    XFLAGS,XFERR        PRT IN ERROR?\n         BO    MODIFYX             YES, GO BACK (FLUSH)\n         BAL   R14,MODESET1        SUPV STATE KEY ZERO\n         BAL   R14,BIT31           GET 31-BIT MODE\n         L     R14,XZADDR          GET ADDRESS TO BE MODIFIED\n         L     R11,XHL             GET LENGTH OF DATA\n         B     MODLPTST            GO DO LOOP TEST\nMODLOOP  LA    R8,0(R11,R14)       POINT AT BYTE TO MOVE\n         USING PSA,R0\n         L     R2,PSAAOLD          GET ADDR OF CURRENT ASCB\n         DROP  R0\n         N     R8,MASKPAGE         GET LOWER PAGE BOUNDARY\n         STCTL 1,1,I               GET SET TABLE ORIGIN\n         L     R2,I                GET CONTENTS OF STO REG\n*                                  TURN OFF PAGE PROTECTION FOR XA\n         XR    R9,R9               CLEAR SECOND REG OF PAIR\n         SRDL  R8,20               ISOLATE SX & PUT PX IN R9\n         SLL   R8,2                GET SEG TBL OFFSET (SX*4)\n         N     R2,MASKSTOX         ISOLATE ADDR OF SEG TABLE\n         BAL   R15,REAL2VIR        GET VIRTUAL ADDR\n         ALR   R2,R8               GET ADDR OF SEG TBL ENTRY\n         SRL   R9,22               GET PAGE TABLE OFFSET (PX*2)\n         L     R2,0(,R2)           GET CONTENT OF SEG TBL ENTRY\n         N     R2,MASKSTE          ISOLATE ADDR OF PAGE TBL ORIGIN\n         BAL   R15,REAL2VIR        GET VIRTUAL ADDR\n         ALR   R9,R2               GET ADDR OF PAGE TBL ENTRY\n         L     R8,0(,R9)           GET CONTENTS OF PAGE TABLE ENTRY\n         N     R8,MASKPPBT         ISOLATE PAGE PROT BIT\n         BZ    MODIT               BR IF NO PAGE PROT\n         SRL   R8,8                SHIFT BYTE TO LO-ORDER\n         LA    R9,2(,R9)           GET ADDR OF BYTE WITH PP BIT IN IT\n         NI    0(R9),X'FD'         TURN OFF PAGE PROT\n         PTLB  ,                   ELIM PROT BIT FROM TLB\n*                                  MODIFY STORAGE A BYTE AT A TIME\nMODIT    IC    R0,XHS(R11)         GET FROM BYTE\n         STC   R0,0(R11,R14)       MODIFY STORAGE\n         EX    R8,ORPROT           TURN PROT BIT BACK ON\nMODLPTST S     R11,ONE             DECREMENT\n         BNM   MODLOOP             BRANCH UNTIL DONE\n         BAL   R14,BIT24           GET BACK TO 24-BIT MODE\n         BAL   R14,MODESET2        PROBLEM STATE KEY NZERO\nMODIFYX  LM    R14,R12,@SVMOD\n         BR    R14\n*- - - - FIELD FETCHING (R14 = LINK REGISTER)\n*              INPUT : XRCVADDR = ADDR OF RECEIVING FIELD\n*                      XRCVLEN = LENGTH OF RECEIVING FIELD\n*              OUTPUT : XFLDALEN = ACTUAL LENGTH OF FETCHED FIELD\n*                       (BLANKS ARE RETURNED IF NO FIELD IS FOUND)\nGETFLD   STM   R14,R12,@SVGFLD\n         L     R14,XFLDSTRT\n         ST    R14,XFLDCUR         SET CURRENT = STARTING\n         SLR   R14,R14             SET\n         ST    R14,XSCANSW         SW = 0\n*                                  SCAN PAST LEADING DELIMITERS\n         B     PARGO1              DO UNTIL SW NE 0\nPARLP1   CLC   XFLDCUR,XENDREC     STILL WITHIN STATEMENT?\n         BNH   PARIN1              YES, BRANCH\n*                                  IS BEYOND END OF STMT\n         LA    R14,1               SET\n         ST    R14,XSCANSW         SW = 1\n         B     PARGO1\nPARIN1   L     R14,XFLDCUR\n         CLI   0(R14),C' '         BLANK?\n         BE    PARNX1\n         CLI   0(R14),C''''        QUOTE?\n         BNE   PARFN1\nPARNX1   LA    R14,1               QUOTE OR BLANK\n         AL    R14,XFLDCUR         POINT TO\n         ST    R14,XFLDCUR          NEXT CHARACTER\n         B     PARGO1\n*                                  NEITHER QUOTE NOR BLANK\n*                                  SET TO EXIT LOOP\nPARFN1   LA    R14,1               SET\n         ST    R14,XSCANSW          SW = 1\nPARGO1   SLR   R14,R14\n         CL    R14,XSCANSW\n         BE    PARLP1              END OF DO LOOP (SKIPPING LEADING\n*                                  DELIMITERS)\n*                                  SCAN FOR END OF FIELD\n         L     R11,XFLDCUR         GET TRUE START OF FIELD\n         ST    R11,XFLDSTRT\n         ST    R14,XSCANSW         SET SW = 0\n         B     PARGO2              DO UNTIL SW NE 0\nPARLP2   CLC   XFLDCUR,XENDREC     STILL WITHIN STATEMENT?\n         BNH   PARIN2              YES, BRANCH\n         LA    R14,1               SET\n         ST    R14,XSCANSW          SW = 1\n         B     PARGO2\nPARIN2   LA    R14,1               POINT XFLDCUR TO\n         AL    R14,XFLDCUR          NEXT\n         ST    R14,XFLDCUR           CHARACTER\n         CLI   0(R14),C' '         BLANK?\n         BE    PARFN2\n         CLI   0(R14),C''''        QUOTE?\n         BNE   PARGO2\nPARFN2   LA    R14,1               SET\n         ST    R14,XSCANSW          SW = 1\nPARGO2   L     R14,XSCANSW\n         LTR   R14,R14\n         BZ    PARLP2              END OF DO LOOP (FOUND END)\n*                                  CALCULATE LENGTH AND CHECK\n*                                   FOR A TOO LONG FIELD\n         L     R14,XFLDCUR         GET ADDRESS OF BLANK OR QUOTE\n         SL    R14,XFLDSTRT        COMPUTE LENGTH\n         ST    R14,XFLDALEN        SAVE LENGTH\n         CL    R14,XRCVLEN         WILL IT FIT IN RESULT?\n         BNH   PAROKL              YES, BRANCH\n         LA    R14,MSG01           FIELD IS TOO LONG\n         ST    R14,XMSE\n         BAL   R14,SYNERR          SYNTAX ERROR\n         B     PARMOV              GO TRUNCATE MOVE\n*                                  MOVE IN FETCHED FIELD (IF ANY)\nPAROKL   L     R14,XRCVADDR        GET ADDRESS OF GETFLD RESULT\n         L     R11,XRCVLEN\n         BCTR  R11,0\n         EX    R11,PARBLNK         MOVE BLANKS TO GETFLD RESULT\nPARMOV   L     R14,XFLDALEN        IF LENGTH\n         LTR   R14,R14              GREATER THAN\n         BZ    PARNUL                ZERO\n         L     R11,XRCVADDR        GET ADDRESS OF GETFLD RESULT\n         BCTR  R14,0\n         L     R7,XFLDSTRT\n         EX    R14,PARMVC          MOVE R7 TO R11\nPARNUL   L     R14,XFLDCUR         GET ADDR OF TRAILING DELIMITER\n         ST    R14,XFLDSTRT        READY FOR NEXT CALL\n         CLI   0(R14),C''''        QUOTE?\n         BNE   PARX                BRANCH IF NOT QUOTED\n         AL    R14,ONE             POINT BEYOND QUOTE\n         ST    R14,XFLDSTRT\nPARX     LM    R14,R12,@SVGFLD\n         BR    R14                 RETURN\n*- - - - CONTROL SCANNING OF A MODULE FOR A DESIRED LABEL\n*              (R14 = LINK REGISTER)\n*              INPUT : XEBLM = LOAD MODULE TO SCAN\n*                      XEBLBL = CESD LABEL WHOSE OFFSET IS TO BE\n*                               RETURNED\n*                      XEBCS = CSECT WHEREIN THE LABEL RESIDES\n*                              (BLANK MEANS FIRST CSECT)\n*              OUTPUT : XOFFSET = OFFSET IN LOAD MODULE TO LABEL\n*                       XCSLEN = LENGTH OF SPECIFIED CSECT\nSCANMOD  STM   R14,R12,@SVSCMD\n         BAL   R14,FIND            GO FIND MODULE ON LIBRARY\n         TM    XFLAGS,XFEOD        END-OF-DATA?\n         BO    SCMEXIT             YES\n         SLR   R14,R14\n         BCTR  R14,0\n         ST    R14,XOFFSET         SHOW LABEL REMAINS TO BE FOUND\n         ST    R14,XSYMOFF         SHOW SYMBOL REMAINS TO BE FOUND\n         SLR   R14,R14\n         ST    R14,XCESDN\n*                                  PERFORM SPECIAL PROCESSING FOR\n*                                   THE NUCLEUS LOAD MODULE\n         CLC   XEBLM(6),=CL6'IEANUC'\n         BNE   SCNMD1\n         BAL   R14,BIT31           GET INTO 31-BIT MODE\n         CLC   XEBCS,=CL8'IEAVFX00'     IS THIS PSA CSECT?\n         BNE   PASTCS0             NO, SKIP\n         XR    R2,R2               CLEAR REGISTER\n         ST    R2,XLMADDR          ADDR IS ZERO\n         B     PASTLKU1            SKIP LOOKUP STUFF\nPASTCS0 NUCLKUP BYNAME,NAME='IEAVBK00',ADDR=(R2) ADDR OF 1ST CSECT\n         LA    R2,0(,R2)           CLEAR HI-ORDER BIT\n         ST    R2,XLMADDR          SAVE AS ADDR OF LOAD MOD\nPASTLKU1 NUCLKUP BYNAME,NAME=XEBLBL,ADDR=(R3) GET ADDR OF LABEL\n         LTR   R15,R15\n         BNZ   LBLNTFND            BR IF LABEL NOT FOUND\n         LA    R3,0(,R3)           CLEAR HI-ORDER BIT\n         SLR   R3,R2               GET OFFSET INTO NUC LOAD MOD\n         ST    R3,XOFFSET          SAVE THIS OFFSET\n        NUCLKUP BYNAME,NAME=XEBCS,ADDR=(R3) GET LENGTH OF CSECT\n         LTR   R15,R15\n         BNZ   LBLNTFND            BR IF LABEL NOT FOUND\n         ST    R1,XCSLEN           SAVE CSECT LENGTH\n         BAL   R14,BIT24           GET BACK TO 24-BIT MODE\n         B     SCMEXIT             EXIT\nSCNMD1   NI    @SWB,255-XFSKIP1\nSCNMD2   SLR   R14,R14             CLEAR THE CSECT DESCRIPTOR ARRAY\n         ST    R14,XSDCNT\n         LA    R14,1\n         ST    R14,@ESDSUB\nSCNMD3   LR    R11,R14\n         MH    R11,=Y(XSD@L)\n         LA    R7,XSDNO(R11)\n         XC    0(XSD@L,R7),0(R7)\n         AL    R14,ONE\n         ST    R14,@ESDSUB\n         CL    R14,=F'400'\n         BNH   SCNMD3\n         SLR   R14,R14             READ AND PROCESS CESD RECORDS\n         ST    R14,XCRSW           CLEAR LOOP SWITCH\n         B     SCNMD10\nSCNMD4   BAL   R14,READLIB\n         CLI   XLREC,C' '          SYM RECORD?\n         BNE   SCNMD5              NO, BRANCH\n         BAL   R14,SYMCHK          GO PROCESS SYM RECORD\nSCNMD5   CLI   XLREC,X'20'         CESD RECORD?\n         BE    SCNMD6              YES, BRANCH\n         LA    R14,1\n         ST    R14,XCRSW\n         B     SCNMD10\n*                                  SCAN CESD ENTRIES ON CESD RECORD\nSCNMD6   LH    R2,XLREC+6          GET LENGTH OF ESD DATA\n         SRDA  R2,32\n         D     R2,=F'16'           GET NUMBER OF ENTRIES\n         ST    R3,XNUMCESD\n         LA    R14,1               START WITH ENTRY NUMBER 1\n         B     ESDGO\nSCNMD7   LA    R14,1\n         AL    R14,XCESDN\n         ST    R14,XCESDN\n         TM    @SWB,XFSKIP1\n         BZ    SCNMD8\n         NI    @SWB,255-XFSKIP1\n         B     ESDINCR\nSCNMD8   L     R14,@ESDSUB\n         SLA   R14,4               MULTIPLY BY 16\n         LA    R11,XLREC(R14)      ACTUALLY XLREC+16-16\n         TM    0(R11),X'0F'        IS IT AN SD?\n         BZ    GOTSD               YES, BRANCH\n         LA    R11,XLREC(R14)\n         TM    0(R11),X'03'        COULD IT BE AN LR?\n         BNO   ESDINCR             NO, BRANCH\n         TM    0(R11),X'0C'        MAY BE, IS IT AN LR?\n         BNZ   ESDINCR             NO, BRANCH\nGOTSD    L     R14,@ESDSUB\n         ST    R14,XCESDX          SET INDEX TO CESD ENTRY\n         BAL   R14,SECTMAP         USE THIS CESD TO MAP LOAD MODULE\n         L     R14,@ESDSUB\n         SLA   R14,4\n         LA    R11,XLREC-8(R14)    ACTUALLY BUFFER+8-16\n         CLC   0(8,R11),XEBLBL     IS THIS THE RIGHT LABEL?\n         BNE   SCNMD9              NO, BRANCH\n         L     R14,XLREC(R14)      ACTUALLY BUFFER+16-16\n         LA    R14,0(,R14)         ZERO HI ORDER BYTE OF ADDRESS\n         ST    R14,XOFFSET         SAVE CSECT ADDRESS\nSCNMD9   L     R14,@ESDSUB\n         SLA   R14,4\n         LA    R11,XLREC(R14)      ACTUALLY BUFFER+8-16\n         TM    0(R11),X'0F'        IS THIS AN SD?\n         BNZ   ESDINCR             NO, BRANCH\n         LA    R11,XLREC-8(R14)\n         CLC   0(8,R11),XEBCS      IS THIS THE REQUESTED CSECT?\n         BNE   ESDINCR             NO, BRANCH\n         L     R14,XLREC(R14)      ACTUALLY BUFFER+16-16\n         LA    R14,0(,R14)         ZERO HI ORDER BYTE OF ADDRESS\n         ST    R14,XCSDADR         SAVE CSECT ADDRESS\n         L     R14,XSDX\n         ST    R14,XCSECNO\nESDINCR  LA    R14,1               ADD 1 TO\n         AL    R14,@ESDSUB          ESD SUBSCRIPT\nESDGO    ST    R14,@ESDSUB\n         CL    R14,XNUMCESD        HAS SUBSCRIPT HIT SIZE YET?\n         BNH   SCNMD7              NO, BRANCH\nSCNMD10  SLR   R14,R14             CHECK FOR SUCCESSFUL SCAN\n         CL    R14,XCRSW\n         BE    SCNMD4\n         CLC   XEBCS(L'XEBCS),=CL72' '\n         BNE   SCNMD11             IF NO CSECT SPECIFIED\n         MVC   XCSECNO,ONE         USE THE FIRST CSECT\n         ST    R14,XCSDADR          AND RELATIVE ADDRESS IS 0\nSCNMD11  L     R14,XSYMOFF\n         LTR   R14,R14             WAS LABEL FOUND IN A SYM REC?\n         BM    SCNMD12             NO, BR\n         AL    R14,XCSDADR         GET POSITION WITHIN LOAD MOD\n         ST    R14,XOFFSET         STORE SYM OFFSET + CSECT ADDR\nSCNMD12  SLR   R14,R14\n         CL    R14,XSDCNT          WAS AT LEAST ONE CSECT FOUND?\n         BNL   LBLNTFND            BR IF NO\n         L     R11,XCSECNO\n         CR    R11,R14             WAS OWNING CSECT FOUND?\n         BNH   LBLNTFND            BR IF NO\n         CL    R14,XOFFSET         WAS DESIRED LABEL FOUND?\n         BH    LBLNTFND            BR IF NO\n         MH    R11,=Y(XSD@L)\n         LA    R7,XSDLEN(R11)\n         MVC   XCSLEN+1(3),0(R7)   MOVE IN CSECT LENGTH\n*              SCATTER LOAD PROCESSING FOR NUCLEUS GO THROUGH TABLE\n*              ADDING UP LENGTH OF EACH CSECT (ROUNDED UP TO NEAREST\n*              DOUBLE WORD) PREVIOUS TO DESIRED CSECT.\n         CLC   XEBLM(6),=CL6'IEANUC'\n         BNE   SCNMD15\n         ST    R14,XACCUM          CLEAR ACCUMULATED LENGTH\n         LA    R14,1               SET CSECT COUNTER\n         B     SCNMD14             GO DO LOOP TEST\nSCNMD13  L     R11,XACCUM          GET ACCUMULATED LENGTH\n         ST    R11,XSMCSD          SAVE IT\n         LR    R7,R14              GET CSECT NUMBER\n         MH    R7,=Y(XSD@L)        GET OFFSET INTO TABLE\n         XR    R4,R4               CLEAR REG.\n         LA    R7,XSDLEN(R7)       POINT AT CSECT LENGTH\n         ICM   R4,B'0111',0(R7)    LOAD CSECT LENGTH\n         LA    R4,7(,R4)           ADD IN ROUNDUP VALUE\n         N     R4,=F'-8'           GET DBL WORD ROUNDED UP VALUE\n         ST    R4,XWORK\n         ALR   R11,R4              ADD TO ACCUMULATED VALUE\n         ST    R11,XACCUM\n         AL    R14,ONE             INCREMENT CSECT COUNTER\nSCNMD14  ST    R14,@ESDSUB\n         CL    R14,XCSECNO         ALL PREV CSECTS PROCESSED?\n         BNH   SCNMD13             NO, BRANCH\n         B     SCNMD16\nSCNMD15  L     R14,XCSDADR         NON-SCATTER-LOAD PROCESSING\n         ST    R14,XSMCSD          DISK ADDR IS SAME AS IN-CORE\nSCNMD16  L     R14,XOFFSET\n         SL    R14,XCSDADR         GET OFFSET WITHIN CSECT\n         ST    R14,XOFFSET\n         AL    R14,XSMCSD          GET OFFSET WITHIN LOAD MOD\n         ST    R14,XOFFSET\n         B     SCMEXIT\nLBLNTFND LA    R14,MSG08           SYMBOL NOT FOUND IN LOAD MODULE\n         ST    R14,XMSE\n         BAL   R14,BIT24           BE SURE WE ARE IN 24 BIT MODE\n         BAL   R14,GENERR\nSCMEXIT  LM    R14,R12,@SVSCMD\n         BR    R14\n*- - - - SCAN LPA/JPA LOOKING FOR LOAD MODULE (R14 = LINK REGISTER)\n*              INPUT : XEBLM = NAME OF LOAD MODULE\n*              OUTPUT : XLMADDR = ADDR OF LOAD MODULE\nSCANLPA  STM   R14,R12,@SVSCLP\n         TM    @SWB,XFLOCSW        IS IT LOCAL MODE?\n         BO    SCLPA1              YES, GO LOOK IN JPA\n         L     R8,CVTPTR           CVT ADDRESS\n         USING CVT,R8\n         LA    R8,CVTQLPAQ         LINK PACK POINTER\n         DROP  R8\n         B     SCLPA2\nSCLPA1   L     R14,CVTPTR          CVT ADDRESS\n         USING CVT,R14\n         L     R14,CVTTCBP         TCB WORDS\n         DROP  R14\n         L     R14,4(,R14)         CURRENT TCB\n         USING TCB,R14\n         L     R8,TCBJSTCB\n         DROP  R14\n         USING TCB,R8\n         LA    R14,TCBJPQ          LAST CDE\n         DROP  R8\n         LR    R8,R14\nSCLPA2   LA    R9,XEBLM\n         LR    R4,R9\n         SL    R4,=F'48'\n         L     R7,CVTPTR           CVT ADDRESS\n         USING CVT,R7\n         L     R15,CVTQCDSR        CDE SEARCH RTN\n         DROP  R7\n         BALR  R14,R15             STD LINKAGE\n*                                  (RETURNS AT +4 IF NAME NOT FOUND)\n         LA    R0,0                INDICATE NAME WAS FOUND\n         LTR   R0,R0\n         BNZ   SCLPA3              BR IF NAME NOT FOUND\n         TM    28(R11),X'04'       IS THIS A MINOR CDE?\n         BZ    GETEXTL             NO, SKIP OBTAINING MAJOR CDE\n         L     R11,20(,R11)        GET ADDR OF MAJOR CDE\nGETEXTL  L     R14,20(,R11)        GET ADDR OF EXTENT LIST\n         L     R7,12(,R14)         GET ADDR OF LOAD MOD\n         ST    R7,XLMADDR          ADDRESS OF MODULE\n         L     R7,XCSLEN\n         LA    R7,0(,R7)\n         LTR   R7,R7               IS CSECT LENGTH CURRENTLY 0?\n         BNZ   SCLPA4              NO, SKIP\n         MVC   XCSLEN+1(3),9(R14)  USE LOAD MODULE LENGTH\n         B     SCLPA4\nSCLPA3   SLR   R14,R14\n         ST    R14,XLMADDR         INDICATE NO CDE FOUND\nSCLPA4   L     R14,XLMADDR         SCAN LPA DIRECTORY (LPDE'S)\n         LTR   R14,R14\n         BNZ   SCLPA7              BRANCH IF MODULE ALREADY FOUND\n         TM    @SWB,XFLOCSW\n         BO    SCLPA7              BR IF LOCAL MODE (SKIP SEARCH)\n         L     R14,CVTPTR          CVT ADDRESS\n         USING CVT,R14\n         TM    CVTDCB,CVTMVS2      MVS BIT ON?\n         BZ    SCLPA7\n         SLR   R0,R0               SET\n         BCTR  R0,0                 R0 NEGATIVE\n         L     R1,CVTLPDIA         LPA DIRECTORY\n         LA    R1,0(,R1)\n         B     LOCATGO1            DO WHILE R0 NEGATIVE\n         DROP  R14\nLOCATLP1 CLC   8(8,R1),XEBLM\n         BNE   SCLPA6\n         TM    28(R1),X'04'        ALIAS?\n         BZ    SCLPA5              NO\n         MVC   XEBLM,32(R1)        YES, GET REAL NAME AND START OVER\n         L     R14,CVTPTR          CVT ADDRESS\n         USING CVT,R14\n         L     R1,CVTLPDIA         LPA DIRECTORY\n         LA    R1,0(,R1)\n         B     LOCATINC\n         DROP  R14\nSCLPA5   L     R0,36(,R1)          SET R0 TO MODULE ADDRESS\n         L     R14,XCSLEN\n         LA    R14,0(,R14)\n         LTR   R14,R14             IS THERE A CSECT LENGTH YET?\n         BNZ   LOCATINC            YES, BRANCH\n         MVC   XCSLEN+1(3),33(R1)  USE LOAD MOD LEN AS CSECT LEN\n         B     LOCATINC\nSCLPA6   CLC   8(8,R1),=XL8'FFFFFFFFFFFFFFFF'  HAVE WE SEE ALL LPDE'S?\n         BNE   LOCATINC            NO, BRANCH\n         SLR   R0,R0               END OF DIRECTORY, SET R0 NON NEG\nLOCATINC AL    R1,=F'40'           POINT AT NEXT LPDE\nLOCATGO1 LTR   R0,R0\n         BM    LOCATLP1\n         ST    R0,XLMADDR          SAVE LOCATION OF MODULE\nSCLPA7   L     R14,XLMADDR\n         LTR   R14,R14             WAS END OF DIRECTORY HIT?\n         BNZ   SCANLPAX            NO, BRANCH\n         LA    R14,MSG04           MODULE NOT FOUND IN MAIN STORAGE\n         ST    R14,XMSE\n         BAL   R14,GENERR\nSCANLPAX LM    R14,R12,@SVSCLP\n         BR    R14\n*- - - - PRINT ADDRESS OF SYMBOL (CSECT, LABEL, ETC...)\n*              (R14 = LINK REGISTER)\n*              INPUT : XLOC = FOUR-BYTE ADDRESS TO BE DISPLAYED\nPRADDR   STM   R14,R12,@SVPRAD\n         MVI   @LN47,C' '\n         MVC   @LN48(73),@LN47\n         MVC   @LN01(46),WHEREMSG\n         LA    R14,XLOC\n         ST    R14,XHEX            ADDR OF WHERE HEX IS COMING FROM\n         MVC   XHEXL,=F'4'\n         LA    R14,@LN01\n         ST    R14,XEBAD           ADDR WHERE WE WANT EBCDIC ADDR\n         BAL   R14,HEXCV           CONVERT HEX ADDR TO EBCDIC\n         BAL   R14,PUTLINE         GO PRINT IT OUT\n         LM    R14,R12,@SVPRAD\n         BR    R14\n*- - - - HEX TO EBCDIC CONVERSION (R14 = LINK REGISTER)\n*              INPUT : XHEX = ADDR OF HEX DATA TO BE CONVERTED\n*                      XHEXL = LENGTH OF HEX DATA\n*                      XEBAD = ADDRESS OF TARGET AREA TO RECEIVE\n*                              EBCDIC DATA\nHEXCV    STM   R14,R12,@SVHXCV\n         BAL   R14,MODESET1        GET INTO KEY 0\n         LA    R14,1               SET UP LOOP VARIABLE\n         B     HEXCT\nHEXLP    L     R11,XEBAD           GET ADDR OF TARGET EBCDIC AREA\n         L     R7,XHEX             GET ADDR OF 'FROM' FIELD\n         ALR   R7,R14\n         BCTR  R7,0                POINT AT CURRENT CHARACTER\n         LR    R4,R14              SAVE LOOP COUNTER\n         BAL   R14,BIT31           GET 31-BIT MODE IF XA\n         MVC   1(1,R11),0(R7)      MOVE CHARACTER TO TARGET AREA\n         BAL   R14,BIT24           GET BACK TO 24-BIT MODE\n         LR    R14,R4\n         UNPK  0(1,R11),1(1,R11)   GET FIRST NIBBLE INTO NEXT BYTE\n         NC    0(2,R11),=XL2'0F0F' STRIP ZONE BITS\n         TR    0(2,R11),=CL16'0123456789ABCDEF'   TRANSLATE TO EBCDIC\n         AL    R11,=F'2'           BUMP TARGET CHAR POINTER\n         ST    R11,XEBAD\n         AL    R14,ONE             INCREMENT LOOP COUNTER\nHEXCT    ST    R14,XX\n         CL    R14,XHEXL           ARE THERE MORE CHAR'S TO CONVERT\n         BNH   HEXLP\n         BAL   R14,MODESET2        GET BACK TO USER KEY\n         LM    R14,R12,@SVHXCV\n         BR    R14\n*- - - - REAL TO VIRTUAL CONVERSION (R15 = LINK REGISTER)\n*              INPUT : R2 - REAL ADDR\n*              OUTPUT : R1,R3 - ALTERED\n*                       R2 - CONVERTED VIRTUAL ADDRESS\nREAL2VIR LR    R1,R2               COPY INPUT ADDR\n         SRL   R1,12               SHIFT OFF DISPLACEMENT\n         L     R3,CVTPTR           GET ADDR OF CVT\n         USING CVT,R3\n         L     R3,CVTPVTP          GET ADDR OF PVT\n         DROP  R3\n         USING PVT,R3\n         L     R3,PVTRIT           GET ADDR OF RIT\n         DROP  R3\n         L     R3,RITPFT(,R3)      GET ADDR OF PFT\n         SLL   R1,5                GET PFT DISPLACEMENT\n         L     R1,PFTVSA(R1,R3)    GET VIRT PAGE ADDR\nR2VB     N     R2,MASKPGDP         GET PAGE DISPLACEMENT\n         OR    R2,R1               COMBINE WITH VIRT PAGE NO.\n         BR    R15                 RETURN\n*- - - - FIND MODULE ON PROGRAM LIBRARY (R14 = LINK REGISTER)\nFIND     STM   R14,R12,@SVFIND\n        FIND   XDCBL,XEBLM,D       FIND\n         LTR   R15,R15             WAS MEMBER FOUND?\n         BZ    FINDOK              YES, BRANCH\n         LA    R14,MSG07           MEMBER NOT FOUND IN LIBRARY\n         ST    R14,XMSE\n         BAL   R14,GENERR\nFINDOK   LM    R14,R12,@SVFIND\n         BR    R14\n*- - - - SYM REC PROCESSING (R14 = LINK REGISTER)\n*              INPUT : XEBCS = CSECT CONTAINING LABEL\n*                      XEBLBL = LABEL BEING SEARCHED FOR\n*                      XLREC = FIRST SYMREC\n*              OUTPUT : XSYMOFF = OFFSET OF LABEL IN CSECT\n*                       XLREC = NEXT LIBRARY RECORD AFTER ALL SYMREC'S\nSYMCHK   STM   R14,R12,@SVSCHK\n         SLR   R14,R14\n         ST    R14,XSYMTOTX\n         LA    R14,XLREC+4\n         ST    R14,XSYMCPT\n         OI    @SWB,XFSYMSKP+XFSYMGO\n         BAL   R14,SYMNEW\n         B     SYMCHK12\nSYMCHK1  LA    R14,@WAY08\n         B     SYMCHK3\nSYMCHK2  BAL   R14,SYMFETCH\n         LA    R14,1\n         AL    R14,XSYMFAD\nSYMCHK3  ST    R14,XSYMFAD\n         LA    R11,@WAY08\n         SL    R11,=F'-3'\n         CR    R14,R11\n         BNH   SYMCHK2\n         TM    @SWB,XFSYMGO\n         BZ    SYMCHK12\n         TM    @WAY08,X'88'\n         BO    SYMCHK9\n         MVC   @WAY08A(8),=CL72' '\n         LA    R14,@WAY08A\n         B     SYMCHK5\nSYMCHK4  BAL   R14,SYMFETCH\n         LA    R14,1\n         AL    R14,XSYMFAD\nSYMCHK5  ST    R14,XSYMFAD\n         LA    R11,@WAY08A\n         LA    R7,7\n         SLR   R4,R4\n         IC    R4,@WAY08\n         NR    R7,R4\n         ALR   R11,R7\n         CR    R14,R11\n         BNH   SYMCHK4\n         TM    @SWB,XFSYMSKP\n         BZ    SYMCHK7\n         TM    @WAY08,X'80'\n         BO    SYMCHK9\n         TM    @WAY08,X'10'\n         BZ    SYMCHK9\n         TM    @WAY08,X'60'\n         BNZ   SYMCHK9\n         CLC   @WAY08A(8),XEBCS\n         BE    SYMCHK6\n         CLC   XEBCS(L'XEBCS),=CL72' '\n         BNE   SYMCHK9\nSYMCHK6  NI    @SWB,255-XFSYMSKP\n         B     SYMCHK9\nSYMCHK7  TM    @WAY08,X'80'\n         BO    SYMCHK8\n         TM    @WAY08,X'10'\n         BZ    SYMCHK8\n         TM    @WAY08,X'60'\n         BNZ   SYMCHK8\n         CLC   XEBCS(L'XEBCS),=CL72' '\n         BE    SYMCHK9\n         OI    @SWB,XFSYMSKP\n         B     SYMCHK9\nSYMCHK8  CLC   @WAY08A(8),XEBLBL\n         BNE   SYMCHK9\n         SLR   R14,R14\n         ICM   R14,B'0111',@WAY08Z\n         ST    R14,XSYMOFF\nSYMCHK9  TM    @WAY08,X'80'\n         BZ    SYMCHK12\n         LA    R14,@WAY08B\n         ST    R14,XSYMFAD\n         BAL   R14,SYMFETCH\n         LA    R14,@WAY08C\n         ST    R14,XSYMFAD\n         BAL   R14,SYMFETCH\n         CLI   @WAY08B,X'10'\n         BNL   SYMCHK10\n         BAL   R14,SYMFETCH\nSYMCHK10 TM    @WAY08,X'40'\n         BZ    SYMCHK11\n         BAL   R14,SYMFETCH\n         BAL   R14,SYMFETCH\n         BAL   R14,SYMFETCH\nSYMCHK11 TM    @WAY08,X'10'\n         BZ    SYMCHK12\n         BAL   R14,SYMFETCH\n         BAL   R14,SYMFETCH\nSYMCHK12 TM    @SWB,XFSYMGO\n         BO    SYMCHK1\n         LM    R14,R12,@SVSCHK\n         BR    R14\n*- - - - CHARACTER FETCHING (FOR SYMREC PROCESSING)\n*              (R14 = LINK REGISTER)\n*              INPUT : XSYMFAD = ADDR OF BYTE TO RECEIVE FETCHED\n*                                CHARACTER\n*              OUTPUT : XSYMFAD -> BYTE = FETCHED CHARACTER\n*                       XSYMFGO = ON IF DATA IS EXHAUSTED\nSYMFETCH STM   R14,R12,@SVSFCH\n         L     R14,XSYMRECX\n         L     R11,XSYMCPT\n         ICM   R11,B'1100',10(R11)\n         SRA   R11,16\n         CR    R14,R11\n         BL    SYMFTCH1\n         BAL   R14,SYMNEW\nSYMFTCH1 TM    @SWB,XFSYMGO\n         BZ    SYMFTCH2\n         L     R14,XSYMFAD\n         L     R11,XSYMFPT\n         MVC   0(1,R14),0(R11)\n         LA    R14,1\n         L     R7,XSYMRECX\n         ALR   R7,R14\n         ST    R7,XSYMRECX\n         ALR   R11,R14\n         ST    R11,XSYMFPT\nSYMFTCH2 LM    R14,R12,@SVSFCH\n         BR    R14\n*- - - - GET A NEW SYMREC LOGICAL RECORD (R14 = LINK REGISTER)\nSYMNEW   STM   R14,R12,@SVSNEW\n         SLR   R14,R14\n         ST    R14,XSYMRECX\n         ST    R14,XSYMFPT         SET PNTR = 0\n         B     SYMNEW5             DO WHILE PNTR = 0 AND XFSYMGO ON\nSYMNEW1  L     R14,XSYMTOTX\n         CH    R14,XLREC+2\n         BL    SYMNEW3\n         SLR   R14,R14\n         ST    R14,XSYMTOTX\n         BAL   R14,READLIB\n         CLI   XLREC,C' '          SYM?\n         BNE   SYMNEW2             NO, BRANCH\n         LA    R14,XLREC+4\n         ST    R14,XSYMCPT\n         B     SYMNEW3\nSYMNEW2  NI    @SWB,255-XFSYMGO    SET XFSYMGO OFF\nSYMNEW3  L     R14,XSYMTOTX\n         LTR   R14,R14\n         BZ    SYMNEW4\n         LA    R14,80\n         AL    R14,XSYMCPT\n         ST    R14,XSYMCPT\nSYMNEW4  LA    R14,80\n         AL    R14,XSYMTOTX\n         ST    R14,XSYMTOTX\n         L     R14,XSYMCPT\n         CLC   1(3,R14),=CL3'SYM'\n         BNE   SYMNEW5\n         L     R11,XSYMOFF\n         LTR   R11,R11\n         BNM   SYMNEW5\n         LA    R14,16(,R14)\n         ST    R14,XSYMFPT\nSYMNEW5  L     R14,XSYMFPT\n         LTR   R14,R14\n         BNZ   SYMNEW6\n         TM    @SWB,XFSYMGO\n         BO    SYMNEW1\nSYMNEW6  LM    R14,R12,@SVSNEW\n         BR    R14\n*- - - - READ RECORD FROM LIBRARY (R14 = LINK REGISTER)\nREADLIB  STM   R14,R12,@SVRDLB\n        READ   @DECB,SF,XDCBL,XLREC,248,MF=E\n        CHECK  @DECB\n         LM    R14,R12,@SVRDLB\n         BR    R14\n*- - - - CSECT MAPPING (R14 = LINK REGISTER)\n*              INPUT : XCESDX = INDEX INTO ARRAY OF CESD ENTRIES IN A\n*                               CESD REC\n*                      XCESDN = CESD NO. OF CURRENT CESD ENTRY\n*                      CESD = A CESD RECORD\n*                      XEBLM = LOAD MODULE NAME\n*              OUTPUT : XSDNO = ARRAY OF CESD NO.S FRO CSECTS (SD'S) IN\n*                               LD MOD\n*                       XSDLEN = ARRAY OF CSECT LENGTHS\n*                       XSDCNT = COUNT OF CSECTS IN LOAD MODULE\n*                                (THUS FAR)\n*                       XSDX = FOR A SD ENTRY, THE RELATIVE CSECT\n*                              NUMBER WITHIN THE IN-CORE VERSION OF\n*                              THE LOAD MODULE\nSECTMAP  STM   R14,R12,@SVSCTM\n         L     R14,XCESDX          GET ESD SUBSCRIPT\n         SLA   R14,4               MULTIPLY BY 16\n         LA    R11,XLREC(R14)      POINT TO ESD ENTRY + 8\n         TM    0(R11),X'03'        IS IT AN LR?\n         BNO   SCTMP4              NO, BRANCH\n         TM    0(R11),X'0C'        IS IT AN LR?\n         BNZ   SCTMP4              NO, BRANCH\n*              IF CESD ENTRY IS A LABEL REFERENCE (ENTRY POINT)\n*              CHECK FOR SCATTER LOADING (IE. NUCLEUS). SINCE THE\n*              SCATTER-LOADED NUCLEUS IS LOADED AS CESD ENTRIES\n*              (SD'S OR LR'S) OCCUR IN THE CESD RECORDS, ADD THE CESD\n*              NUMBER OF THE LABEL'S CSECT TO THE SD (CSECT) ARRAY.\n         CLC   XEBLM(6),=CL6'IEANUC' IS THIS A NUCLEUS ZAP?\n         BNE   SCTMP4              NO, BRANCH\n         MVC   XSDX,ONE\n         B     SCTMP3\nSCTMP1   L     R14,XSDX\n         L     R11,XSDCNT\n         CR    R14,R11\n         BNH   SCTMP2\n         AL    R11,ONE\n         ST    R11,XSDCNT\n         MH    R14,=Y(XSD@L)\n         L     R11,XCESDX\n         SLA   R11,4\n         LH    R11,XLREC+6(R11)\n         N     R11,MASKFFFF\n         LA    R7,XSDNO(R14)\n         STCM  R11,B'0011',0(R7)\n         B     SCTMP3\nSCTMP2   LA    R14,1\n         AL    R14,XSDX\n         ST    R14,XSDX\nSCTMP3   L     R14,XSDX\n         MH    R14,=Y(XSD@L)\n         L     R11,XCESDX\n         SLA   R11,4\n         LH    R11,XLREC+6(R11)\n         N     R11,MASKFFFF\n         LA    R7,XSDNO(R14)\n         ICM   R14,B'1100',0(R7)\n         SRA   R14,16\n         CR    R11,R14\n         BNE   SCTMP1\n*              IF CESD ENTRY IS A SECTION DEFINITION (SD OR CSECT),\n*              ADD THE CESD NO. FOR THE CSECT TO THE ARRAY. IF LOAD\n*              MOD IS THE NUCLEUS CHECK FIRST THAT AN ENTRY MIGHT\n*              ALREADY BE IN THE ARRAY FOR THIS CESD NO. FROM AN\n*              EARLIER 'LR' ENTRY. ONCE THE PROPER CESD ENTRY HAS\n*              BEEN FOUND OR ADDED TO THE ARRAY, PUT IN THE LENGTH\n*              OF THIS CSECT.\nSCTMP4   L     R14,XCESDX          GET ESD SUBSCRIPT\n         SLA   R14,4               MULTIPLY BY 16\n         LA    R11,XLREC(R14)      POINT TO ESD ENTRY + 8\n         TM    0(R11),X'0F'        IS IT AN SD?\n         BNZ   SCTMP10             NO, BRANCH\n         CLC   XEBLM(6),=CL6'IEANUC'    IS THIS A NUCLEUS ZAP?\n         BNE   SCTMP8              NO, BRANCH\n         MVC   XSDX,ONE\n         B     SCTMP7\nSCTMP5   L     R14,XSDX\n         L     R11,XSDCNT\n         CR    R14,R11\n         BNH   SCTMP6\n         AL    R11,ONE\n         ST    R11,XSDCNT\n         MH    R14,=Y(XSD@L)\n         L     R11,XCESDN\n         LA    R7,XSDNO(R14)\n         STCM  R11,B'0011',0(R7)\n         B     SCTMP7\nSCTMP6   LA    R14,1\n         AL    R14,XSDX\n         ST    R14,XSDX\nSCTMP7   L     R14,XSDX\n         MH    R14,=Y(XSD@L)\n         LA    R11,XSDNO(R14)\n         ICM   R14,B'1100',0(R11)\n         SRA   R14,16\n         CL    R14,XCESDN\n         BNE   SCTMP5\n         B     SCTMP9\nSCTMP8   LA    R14,1\n         AL    R14,XSDCNT\n         ST    R14,XSDCNT\n         ST    R14,XSDX\n         MH    R14,=Y(XSD@L)\n         L     R11,XCESDN\n         LA    R7,XSDNO(R14)\n         STCM  R11,B'0011',0(R7)\nSCTMP9   L     R14,XSDX\n         MH    R14,=Y(XSD@L)\n         L     R11,XCESDX          GET SUBSCRIPT\n         SLA   R11,4               MULTIPLY BY 16\n         LA    R7,XSDLEN(R14)\n         LA    R14,XLREC+4+1(R11)\n         MVC   0(3,R7),0(R14)\nSCTMP10  LM    R14,R12,@SVSCTM\n         BR    R14\n*- - - - OBTAIN 24-BIT ADDRESSING MODE (R14 = LINK REGISTER)\nBIT24    LA    R14,0(,R14)         CLEAR HI-ORDER PORTION\n         BSM   0,R14               RETURN IN 24-BIT MODE\n*- - - - OBTAIN 31-BIT ADDRESSING MODE (R14 = LINK REGISTER)\nBIT31    LA    R14,0(,R14)         CLEAR OUT BAL STUFF, ETC...\n         O     R14,HIORDBIT        TURN ON AMODE-31 BIT\n         BSM   0,R14               RETURN IN 31-BIT MODE\n*- - - - GAIN SUPERVISOR STATE, KEY ZERO (R14 = LINK REGISTER)\nMODESET1 STM   R14,R12,@SVMST1\n        MODESET KEY=ZERO,MODE=SUP\n         LM    R14,R12,@SVMST1\n         BR    R14\n*- - - - RETURN TO PROBLEM STATE AND KEY (R14 = LINK REGISTER)\nMODESET2 STM   R14,R12,@SVMST2\n        MODESET KEY=NZERO,MODE=PROB\n         LM    R14,R12,@SVMST2\n         BR    R14\n*- - - - GENERAL ERROR (R14 = LINK REGISTER)\n*              INPUT : XMSE = ADDR OF MESSAGE LIST\nGENERR   STM   R14,R12,@SVGNRR\n         MVI   @LN02,C' '\n         MVC   @LN03(L'@LINE-3),@LN02\n         L     R14,XMSE            GET ADDRESS OF MESSAGE\n         XR    R11,R11\n         IC    R11,0(,R14)         GET LENGTH OF MESSAGE\n         EX    R11,PUTMSGM         MOVE R14+4 TO @LN01\n         BAL   R14,PUTLINE         WRITE THE MESSAGE\n         TM    XFLAGS,XFERR        PRT IN ERROR?\n         BO    GENERRX             YES, GO BACK (FLUSH)\n         MVC   XCODE,=F'12'        SET RETURN CODE = 12\n         OI    XFLAGS,XFEOD        FORCE END-OF-DATA (FLUSH)\nGENERRX  LM    R14,R12,@SVGNRR\n         BR    R14\n*- - - - SYNTAX ERROR MESSAGE (R14 = LINK REGISTER)\nSYNERR   STM   R14,R12,@SVSNRR\n         MVI   @LN02,C' '\n         MVC   @LN03(L'@LINE-3),@LN02\n         MVI   @LN01,C' '\n         MVC   @LN01(15),SYNTAX\n         L     R14,XMSE\n         XR    R11,R11\n         IC    R11,0(,R14)\n         EX    R11,PUTM8MV         MOVE 1(R14) TO LINE+16\n         BAL   R14,PUTLINE\n         TM    XFLAGS,XFERR        PRT IN ERROR?\n         BO    SYNERRX             YES, GO BACK (FLUSH)\n         MVC   XCODE,=F'8'         SET RETURN CODE = 8\n         OI    XFLAGS,XFEOD        FORCE END-OF-DATA\nSYNERRX  LM    R14,R12,@SVSNRR\n         BR    R14\n*- - - - OUTPUT RECORD PRINTING (CREATE AND OPEN THE DATA-SET)\n*              (R14 = LINK REGISTER)\nPUTLINE  TM    XFLAGS,XFERR        PRT IN ERROR?\n         BOR   R14                 YES, GO BACK (FLUSH)\n         STM   R14,R12,@SVPUTL\n         TM    XFLAGS,XFOOP        PRT OPENED?\n         BO    PUTLN               YES\n         L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL72' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         L     R9,AWADT\n         USING WADATA,R9\n         MVC   DDNAME,IZPRTDDN     DDNAME\n         MVC   DSNAME(L'IZUSRID),IZUSRID BUILD DS-NAME\n         LA    R3,DSNAME+L'IZUSRID-1\n         CLI   0(R3),C' '\n         BNE   *+L'*+4\n         BCT   R3,*-8\n         MVC   1(15,R3),=CL15'.ETPS.IZAPPRT.D'\n         LA    R3,16(R3)\n         LA    R1,VUSWA            -> FORMAT DATE AND TIME WORK-AREA\n         XC    0(FDTWAL,R1),0(R1)  CLEAR\n         L     R15,ARFDTE          GET CURRENT DATE/TIME\n*- - - - ETPSFDTE PARM.LIST : \"FDTWA\" ADDRESS\n        CALL   (15)\n         USING FDTWA,R1\n         MVC   0(L'FXYY,R3),FXYY   SET YEAR (YY)\n         MVC   0+L'FXYY(L'FXDDD,R3),FXDDD SET DAY (DDD)\n         MVC   0+L'FXYY+L'FXDDD(2,R3),=CL2'.T'\n         LA    R3,2+L'FXYY+L'FXDDD(R3)\n         MVC   0(L'FTM,R3),FTM     SET TIME HHMMSS\n         MVC   0+L'FTM(5,R3),=CL5'.LIST'\n         DROP  R1\n         MVC   DSUNIT,=CL8'&IZUNM'\n         MVC   DSVOLSER,=CL6'&IZVSN' VOL-SER\n         MVC   DSALLOC,=CL5'&IZSPU' SPACE UNIT (TRK/CYL)\n         MVC   DSPRI,=CL6'&IZPRQ'  PRIMARY QUANTITY\n         MVC   DSSEC,=CL6'&IZSCQ'  SECONDARY QUANTITY\n         MVI   DSRECFM1,C'F'       SET RECFM=FBA\n         MVI   DSRECFM2,C'B'\n         MVI   DSRECFM5,C'A'\n         MVC   DSBLKSI,=CL5'3630 ' SET BLKSIZE\n         MVC   DSLRECL,=CL5'121 '  SET LRECL\n         MVC   DSSTATUS,=CL8'NEW ' SET DISP=(NEW,CATLG,CATLG)\n         MVC   DSNDISP,=CL8'CATLG '\n         MVC   DSADISP,=CL8'CATLG '\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    PUTLAL              OK\n        XMESS  4005                ERROR\n         LA    R1,APFMSG\nPUTLMS   ST    R1,XMSGA            SET MESSAGE ADDRESS\n         MVC   XCODE,=F'16'        SET RETURN CODE = 16\n         OI    XFLAGS,XFEOD+XFERR  FORCE END-OF-DATA (FLUSH) AND ERROR\n         B     PUTLX\nPUTLAL   OI    XFLAGS,XFOAL        PRT IS ALLOCATED\n         LA    R11,XDCBP\n         L     R15,=A(PRTDCB)      POINTER TO DCB IMAGE\n         MVC   0(PRTDCBL,R11),0(R15) MOVE DCB PROTOTYPE\n         USING IHADCB,R11\n         MVC   DCBDDNAM(L'DCBDDNAM),IZPRTDDN SET DD-NAME\n         MVI   XDCBA,VLB           SET \"VL\" BIT\n        OPEN   ((R11),(OUTPUT)),MF=(E,XDCBA) OPEN PRT\n         TM    DCBOFLGS,DCBOFOPN   WAS OPEN SUCCESSFUL?\n         BO    PUTLOK              IF SO, GO PUT\n         DROP  R11\n         LA    R1,OPFMSG           ELSE IF NOT, ERROR\n         B     PUTLMS\nPUTLOK   OI    XFLAGS,XFOOP        PRT IS OPENED\n         XC    XPGNO(L'XPGNO+L'XLNNO),XPGNO AND CLEAR PAGE AND LINE\n         MVC   IZPRTDSN,DSNAME     PASS BACK \"PRT\" DS-NAME\n         MVC   IZPRTVOL,DSVOLSER   PASS BACK \"PRT\" VOL-SER\n         DROP  R2,R9\nPUTLN    LH    R0,XLNNO            GET LINE NUMBER\n         CLI   @LN00,C'1'          SKIP TO PAGE?\n         BE    PUTPG               YES, FORCE PAGE SKIP\n         CLI   @LN00,C'0'          DOUBLE SPACE?\n         BE    PUTS2               YES\n         CLI   @LN00,C'+'          SUPPRESS SKIP?\n         BE    PUTS0               YES\n         CLI   @LN00,C'-'          TRIPLE SPACE?\n         BE    PUTS3               YES\n         MVI   @LN00,C' '          ELSE FORCE SINGLE\n         B     PUTS1               AND COUNT ONE\nPUTS3    BCTR  R0,0\nPUTS2    BCTR  R0,0\nPUTS1    BCTR  R0,0\nPUTS0    LTR   R0,R0               ANYTHING LEFT ON PAGE?\n         BNP   PUTPG               NO, EJECT\n         STH   R0,XLNNO            SAVE NEW LINE COUNTER\n         NI    XFLAGS,255-XIOERR   TURN OFF FLAG\n        PUT    XDCBP,@LINE         PRINT THE LINE NOW\n         MVI   @LINE,C' '          RESET CC\n         TM    XFLAGS,XIOERR       IO ERROR?\n         BZ    PUTLX               NO\nPUTERR   LA    R1,IOEMSG           ELSE SET I/O ERROR MESSAGE\n         B     PUTLMS\nPUTLX    LM    R14,R12,@SVPUTL\n         BR    R14\n*- - - - PUT OUT A TITLE IF AT TOP OF PAGE.\nPUTPG    MVI   @LN00,C'-'          TRIPLE SPACE FROM TITLE\n         MVC   XLNNO(2),=H'60'     RESET LINE COUNTER\n         LH    R1,XPGNO            GET PAGE COUNTER\n         LA    R1,1(R1)            COUNT LAST PAGE\n         STH   R1,XPGNO            SAVE FOR LATER\n         CVD   R1,DBLWRD           CONVERT THE PAGE NUMBER\n         MVC   @HEAD,HEADING       MOVE IN THE MASK\n         ED    @HEAD+HEADPGN(L'HEADPGN),DBLWRD+5 EDIT IT\n         L     R1,AWADT\n         USING WADATA,R1\n         MVC   @HEAD+HEADUSR(L'HEADUSR),IZUSRID PICK UP USER-ID\n         DROP  R1\n         LA    R1,VUSWA            -> FORMAT DATE AND TIME WORK-AREA\n         XC    0(FDTWAL,R1),0(R1)  CLEAR\n         L     R15,ARFDTE          GET CURRENT DATE/TIME\n*- - - - ETPSFDTE PARM.LIST : \"FDTWA\" ADDRESS\n        CALL   (15)\n         USING FDTWA,R1\n         LTR   R15,R15             HOW COMPLETE?\n         BNZ   *+L'*+12            ERROR, SKIP\n         AIF   ('&TXV' NE 'EUROPE').SK1\n         MVC   @HEAD+HEADDAY(L'FXDD),FXDD PICK UP DAY (DD)\n         MVC   @HEAD+HEADDAY+3(L'FXMONTH),FXMONTH MONTH (MMM)\n         MVC   @HEAD+HEADDAY+7(L'FXYY),FXYY AND YEAR (YY)\n         AGO   .SK2\n.SK1     MVC   @HEAD+HEADDAY+7(L'FXDD),FXDD PICK UP DAY (DD)\n         MVC   @HEAD+HEADDAY+3(L'FXMONTH),FXMONTH MONTH (MMM)\n         MVC   @HEAD+HEADDAY(L'FXYY),FXYY AND YEAR (YY)\n.SK2     MVC   @HEAD+HEADHOUR(L'FTHH),FTHH SET TIME HH:MM\n         MVI   @HEAD+HEADHOUR+L'FTHH,C':'\n         MVC   @HEAD+HEADHOUR+L'FTHH+1(L'FTMM),FTMM\n         DROP  R1\n         NI    XFLAGS,255-XIOERR   TURN OFF FLAG\n        PUT    XDCBP,@HEAD         PRINT THE TITLE\n         TM    XFLAGS,XIOERR       IO ERROR?\n         BO    PUTERR              YES\n         B     PUTLN               GO PRINT THE LINE NOW\n         SPACE 1\n         CNOP  0,8\n*------- SYNAD : AN I/O ERROR HAS OCCURED.\nPSYNAD   OI    XFLAGS,XIOERR       SIGNAL ERROR\n         BR    R14                 AND RETURN\n         SPACE 1\n*------- EXECUTED INSTRUCTIONS\nLOGMVC   MVC   @LN01(*-*),0(R14)\nPUTMSGM  MVC   @LN01(*-*),1(R14)\nPARBLNK  MVC   0(*-*,R14),=CL72' '\nPARMVC   MVC   0(*-*,R11),0(R7)\nHPRTRT   TRT   XHW(*-*),0(R14)\nMVREPDT  MVC   0(*-*,R11),XHS\nPUTM8MV  MVC   @LN16(*-*),1(R14)\nVERCLC   CLC   0(*-*,R11),XHS\nZAPXC    XC    XHS(*-*),XHS\nORPROT   OI    0(R9),*-*\n         SPACE 1\n*------- CONSTANTS\nONE      DC    F'1'\nMASKFFFF DC    XL4'0000FFFF'\nMASKPAGE DC    XL4'FFFFF000'       PAGE BOUNDARY MASK\nMASKPGDP DC    XL4'00000FFF'       PAGE DISPLACEMENT MASK\nMASKSTOX DC    XL4'7FFFF000'       XZ-MODE STO REG MASK\nMASKSTE  DC    XL4'7FFFFFC0'       SEG TBL ENTRY MASK\nMASKPPBT DC    XL4'00000200'       PAGE PROT BIT MASK\nHIORDBIT DC    XL4'80000000'       HI-ORDER BIT MASK\n         SPACE 1\n*- - - - MESSAGES\nAPFMSG   MSG   'ALLOC \"PRT\" FAILED'\nOPFMSG   MSG   'OPEN \"PRT\" FAILED'\nFPFMSG   MSG   'FREE \"PRT\" FAILED'\nIOEMSG   MSG   'I/O \"PRT\" ERROR'\nWHEREMSG DC    CL46'         = IN-CORE ADDRESS OF PRECEDING SYMBOL'\nIGNORED  DC    CL36'OPERATION IGNORED - NO GO SWITCH SET'\nREJECT   DC    CL32'VERIFY REJECT - SET NO GO SWITCH'\nOLDWAS   DC    CL13'OLD DATA WAS '\nEQRC     DC    CL16'   = RETURN CODE'\nSYNTAX   DC    CL15'SYNTAX ERROR - '\nWARNMSG  DC    CL57'WARNING -- LOCAL MODE IS PROBABLY INVALID FOR THIS X\n               MODULE'\nHEADING  DS    0CL121\n         DC    CL1'1',CL40'E T P S - MAIN STORAGE ZAP'\n         DC    CL7'USER : '\nHEADUSR  EQU   *-HEADING,8\n         DC    CL20' ',CL7'****** '\nHEADDAY  EQU   *-HEADING,9\n         AIF   ('&TXV' NE 'EUROPE').SK3\n         DC    CL9'?? ??? YY'\n         AGO   .SK4\n.SK3     DC    CL9'YY ??? ??'\n.SK4     DC    CL5' --- '\nHEADHOUR EQU   *-HEADING,5\n         DC    CL18'HH:MM ****** PAGE '\nHEADPGN  EQU   *-HEADING-1,6\n         DC    XL5'2020202120',CL9' '\nMSG01    DC    AL1(L'MSG01T-1)\nMSG01T   DC    C'FIELD IS TOO LONG'\nMSG02    DC    AL1(L'MSG02T-1)\nMSG02T   DC    C'OFFSET FIELD IS TOO LONG'\nMSG03    DC    AL1(L'MSG03T-1)\nMSG03T   DC    C'INVALID HEXADECIMAL CHARACTER'\nMSG04    DC    AL1(L'MSG04T-1)\nMSG04T   DC    C'MODULE NOT FOUND IN MAIN STORAGE'\nMSG05    DC    AL1(L'MSG05T-1)\nMSG05T   DC    C'CSECT MUST BE SUPPLIED FOR NUCLEUS LOAD MODULE'\nMSG06    DC    AL1(L'MSG06T-1)\nMSG06T   DC    C'OPEN OF PROGRAM LIBRARY HAS FAILED'\nMSG07    DC    AL1(L'MSG07T-1)\nMSG07T   DC    C'MEMBER NOT FOUND ON PROGRAM LIBRARY'\nMSG08    DC    AL1(L'MSG08T-1)\nMSG08T   DC    C'SYMBOL NOT FOUND IN LOAD MODULE'\nMSG09    DC    AL1(L'MSG09T-1)\nMSG09T   DC    C'OPERATION REQUESTED IS INVALID'\nMSG10    DC    AL1(L'MSG10T-1)\nMSG10T   DC    C'REQUIRED FIELD MISSING'\nMSG11    DC    AL1(L'MSG11T-1)\nMSG11T   DC    C'UNEVEN NUMBER OF HEXADECIMAL DIGITS'\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R5,R6,R10,R12,R13\n         SPACE 1\n*------- UPPER LIMIT OF BASE REGISTERS USE --------------------------*\n         EJECT\n*- - - - FLAG MAPPINGS\nXFEOD    EQU   X'80'     XFLAGS  - END-OF-DATA\nXFNOGO   EQU   X'40'               NO-GO SWITCH\nXFOAL    EQU   X'08'               OUTPUT DATA-SET ALLOCATED\nXFOOP    EQU   X'04'               OUTPUT DATA-SET OPENED\nXFERR    EQU   X'02'               OUTPUT DATA-SET ERROR\nXIOERR   EQU   X'01'               OUTPUT DATA-SET I/O ERROR\nXFSYMSKP EQU   X'80'     @SWB    - SKIP SYMBOLS (WRONG CSECT)\nXFSYMGO  EQU   X'40'               SW FOR SYMREC PROCESSING\nXFSKIP1  EQU   X'20'               SKIP 1ST CESD (NUC MOD)\nXFLOCSW  EQU   X'08'               LOCAL(ON)/GLOBAL(OFF) SWITCH\n         SPACE 1\n*- - - - VERB NAMES TABLE\nOPCODES  DC    CL3'VER'            01\n         DC    CL3'REP'            02\n         DC    CL3'NAM'            03\n         DC    CL3'DUM'            04\n         DC    CL3'RES'            05\n         DC    CL3'   '            06\n         DC    CL3'*  '            07\n         DC    CL3'RC '            08\n         DC    CL3'ZAP'            09\n         DC    CL3'GLO'            10\n         DC    CL3'LOC'            11\n         DC    CL3'BAS'            12\n         DC    CL3'IDR'            13\n         DC    CL3'SET'            14\nOPNUM    EQU   (*-OPCODES)/L'OPCODES\n         SPACE 1\n*- - - - VERB ROUTINES ADDRESS TABLE\nOPENTRY  DC    A(VER)              01\n         DC    A(REP)              02\n         DC    A(NAM)              03\n         DC    A(DUM)              04\n         DC    A(REP)              05\n         DC    A(COMMENT)          06\n         DC    A(COMMENT)          07\n         DC    A(RC)               08\n         DC    A(ZAP)              09\n         DC    A(GLO)              10\n         DC    A(LOC)              11\n         DC    A(GETOFF)           12\n         DC    A(COMMENT)          13\n         DC    A(COMMENT)          14\n         SPACE 1\nLIBDCB  DCB    DSORG=PO,MACRF=R,DDNAME=L\nLIBDCBL  EQU   *-LIBDCB\nPRTDCB  DCB    DSORG=PS,MACRF=PM,DDNAME=P,LRECL=121,SYNAD=PSYNAD\nPRTDCBL  EQU   *-PRTDCB\n         SPACE 1\nHEXTR    DC    193X'00'            00-C0\n         DC    X'0A0B0C0D0E0F'\n         DC    41X'00'             C7-EF\n         DC    X'00010203040506070809'\n         DC    6X'00'              FA-FF\nHEXTRT   DC    193X'01'            00-C0          HEXADECIMAL\n         DC    6X'00'              C1-C6 (A-F)         VALIDATION\n         DC    41X'01'             C7-EF                    TRANSLATE\n         DC    10X'00'             F0-F9                         TABLE\n         DC    6X'01'              FA-FF\nEBCDIC   DC    74C' '              00-49\n         DC    X'4A4B4C4D4E4F50'\n         DC    C'         '        51-59\n         DC    X'5A5B5C5D5E5F6061'\n         DC    C'        '         62-69\n         DC    X'6A6B6C6D6E6F'\n         DC    C'         '        70-78\n         DC    X'797A7B7C7D7E7F'\n         DC    C' '                80\n         DC    C'ABCDEFGHI'        81-89\n         DC    C' '                8A\n         DC    X'8B8C8D8E8F'\n         DC    C' '                90\n         DC    C'JKLMNOPQR'        91-99\n         DC    C' '                9A\n         DC    X'9B9C9D9E9FA0A1'\n         DC    C'STUVWXYZ'         A2-A9\n         DC    X'AAABACADAEAF'     AA-AF\n         DC    X'B0B1B2B3B4B5B6B7B8B9'\n         DC    C' '                BA\n         DC    X'BBBCBDBEBFC0'\n         DC    C'ABCDEFGHI'        C1-C9\n         DC    C'      '           CA-CF\n         DC    X'D0'\n         DC    C'JKLMNOPQR'        D1-D9\n         DC    C'      '           DA-DF\n         DC    X'E0'\n         DC    C' '                E1\n         DC    C'STUVWXYZ'         E2-E9\n         DC    C'      '           EA-EF\n         DC    C'0123456789'       F0-F9\n         DC    X'FA'\n         DC    C'     '            FB-FF\n         EJECT\n*------- MAP OF GETMAINED WORK-AREA ---------------------------------*\n         SPACE 1\nWADATA   DSECT\nEYECATCH DS    CL8                 \"INCORZAP\"\nIZUSRID  DS    CL8                 USER-ID\nIZLIBDDN DS    CL8                 \"LIB\" DD-NAME\nIZLIBDSN DS    CL44                \"LIB\" DATA-SET NAME\nIZPRTDDN DS    CL8                 \"PRT\" DD-NAME\nIZPRTDSN DS    CL44                \"PRT\" DATA-SET NAME\nIZPRTVOL DS    CL6                 \"PRT\" VOLUME SERIAL NUMBER\nISZAC    DS    CL1                 CURRENT ACCESS-CODE\nISZSW    DS    XL1\nZPRVIEW  EQU   X'80'               VIEW \"PRT\" DATA-SET REQUESTED\nZPRDEL   EQU   X'40'               DELETE \"PRT\" DATA-SET REQUESTED\nZPRALT   EQU   X'08'               ALTERNATE CURSOR POSITION\nZPRPOC   EQU   X'04'               PANEL OPTION CHANGED\nSTTXENT  EQU   X'01'               STATEMENT TEXT-ENTERED\nIZMSGWA  DS    XL1,CL20            MESSAGE WORK-AREA\n         DS    0D\nSTMLNES  DS    8CL80\nNBRSTTS  EQU   (*-STMLNES)/L'STMLNES\nWALEN    EQU   (((*-WADATA)+7)/8)*8\n         SPACE 1\n@DATA    DSECT\n@SVVER   DS    15F                 LOCAL SAVE-AREAS\n@SVREP   DS    15F\n@SVNAM   DS    15F\n@SVDUM   DS    15F\n@SVRC    DS    15F\n@SVZAP   DS    15F\n@SVBASE  DS    15F\n@SVGTRC  DS    15F\n@SVGLRC  DS    15F\n@SVVSCN  DS    15F\n@SVGHEX  DS    15F\n@SVDMP   DS    15F\n@SVFXR   DS    15F\n@SVMOD   DS    15F\n@SVGFLD  DS    15F\n@SVSCMD  DS    15F\n@SVSCLP  DS    15F\n@SVPRAD  DS    15F\n@SVHXCV  DS    15F\n@SVFIND  DS    15F\n@SVSCHK  DS    15F\n@SVSFCH  DS    15F\n@SVSNEW  DS    15F\n@SVRDLB  DS    15F\n@SVSCTM  DS    15F\n@SVMST1  DS    15F\n@SVMST2  DS    15F\n@SVGNRR  DS    15F\n@SVSNRR  DS    15F\n@SVPUTL  DS    15F\n         SPACE 1\nAWADT    DS    F                   \"WADATA\" POINTER\nXINSTAC  DS    2F                  INPUT STATEMENT ADDRESS-COUNT\n@ESDSUB  DS    0F\nI        DS    F                   WORK VARIABLE\nXACCUM   DS    F                   ACCUMULATED CSECT LENGTH\nXBASE    DS    F                   BASE VALUE FOR OFFSET ADJ\nXCESDN   DS    F                   CESD NUMBER\nXCSECNO  DS    F                   CSECT NO. FOR 'XEBLBL'\nXCESDX   DS    F                   INDEX TO CESD ENTRY\nXCRSW    DS    F                   CESD RECORD SCAN SW\nXCSADDR  DS    F                   ADDRESS OF CSECT\nXCSDADR  DS    F                   REL ADDR OF CSECT ON DISK\nXCSOFF   DS    F                   OFFSET TO CSECT IN LOAD MOD\nXCODE    DS    F                   RETURN CODE\nXMSGA    DS    F                   RETURN MESSAGE ADDRESS\nXDUMPEND DS    F                   END OF DUMP\nXDP      DS    F                   DUMP POINTER\nXEBAD    DS    F                   ADDR OF EBCDIC DATA\nXENDREC  DS    F                   ADDR OF END OF LOGICAL DATA\nXFLDCUR  DS    F                   CURRENT CHARACTER POINTER\nXRCVADDR DS    F                   ADDR OF RECEIVING FIELD\nXFLDALEN DS    F                   ACTUAL FIELD LENGTH\nXFLDSTRT DS    F                   START OF FIELD\nXGOS     DS    F                   'GET OFFSET' ROUTINE SW\nXHEX     DS    F                   ADDR OF HEX DATA\nXHEXL    DS    F                   LENGTH OF HEX DATA\nXHL      DS    F                   LENGTH OF HEX STRING\nXHP      DS    F                   POINTER TO HEX STRING\nXHSPTR   DS    F                   HEX STRING POINTER\nXHSW     DS    F                   SWITCH\nXHWPTR   DS    F                   HEX WORK-AREA POINTER\nXLMADDR  DS    F                   IN-CORE ADDR OF LOAD MOD\nXLOC     DS    F                   LOCATION TO BE DISPLAYED\nXMSE     DS    F                   ADDR OF SYNTAX ERR MSG\nXNUMCESD DS    F                   NO. OF ENTRIES IN CESD REC\nXOFFSET  DS    F                   OFFSET TO CESD IN LOAD MOD\nXPECB    DS    F\nXPENDREC DS    F                   POINTER TO END OF PHYSICAL REC\nXPS      DS    F                   LOOP SWITCH\nXPSRC    DS    F                   PAGE SERVICE RETURN CODE\nXRCVLEN  DS    F                   RECEIVING FIELD LEN\nXSCANSW  DS    F                   SW TO CONTROL SCAN\nXSDCNT   DS    F                   COUNT OF CSECTS IN MODULE\nXSDX     DS    F                   ARRAY INDEX FOR XSD\nXSMCSD   DS    F\nXSYMCPT  DS    F\nXSYMFAD  DS    F\nXSYMFPT  DS    F\nXSYMOFF  DS    F\nXSYMRECX DS    F\nXSYMTOTX DS    F\nXVX      DS    F                   VERB INDEX\nXVXSW    DS    F\nXWECB    DS    F\nXWORK    DS    F\nXX       DS    F\nXZADDR   DS    F                   IN-CORE STORAGE ADDR\nY        DS    F\nXCSLEN   DS    F\nXCARD    DS    CL80\n         DS    0F\nXDCBL    DS    XL100\n         DS    0F\nXDCBP    DS    XL100\nXDCBA    DS    F                   ADDR. OF DCB (OPEN-CLOSE LIST)\n         DS    F\n@DECB    DS    5F\nXEBLM    DS    CL8\nXEBCS    DS    CL8\n         DS    CL8\nXEBLBL   DS    CL8\nXEBV     DS    CL8\nXPGNO    DS    H                   PAGE COUNTER\nXLNNO    DS    H                   LINE COUNTER\nXFLAGS   DS    XL1\n@SWB     DS    XL1\nXGOC     DS    C\n         DS    C                   XHOP-1\nXHOP     DS    F\nXHPW     DS    CL9\nXHS      DS    CL40\n         DS    C                   XHW-1\nXHW      DS    CL80\n         SPACE 1\n@LINE    DS    0CL121\n@LN00    DS    C\n@LN01    DS    C\n@LN02    DS    C\n@LN03    DS    CL11\n@LN14    DS    C\n@LN15    DS    C\n@LN16    DS    C\n@LN17    DS    C\n@LN18    DS    CL15\n@LN33    DS    C\n@LN34    DS    CL3\n@LN37    DS    C\n@LN38    DS    CL3\n@LN41    DS    CL6\n@LN47    DS    C\n@LN48    DS    CL10\n@LN58    DS    C\n@LN59    DS    CL28\n@LN87    DS    C\n@LN88    DS    CL26\n         DS    CL6\n@LN120   DS    C\n         SPACE 1\n@HEAD    DS    CL121\n         SPACE 1\nXLREC    DS    0F,XL248\n@WAY08   DS    CL1\n@WAY08Z  DS    CL3\n@WAY08A  DS    CL5\n         SPACE 1\n*- - - - CSECT MAPPING ARRAY (2000 ENTRIES)\n         DS    0F\nXSDNO    DS    C                   CSECT NUMBER (2 BYTES)\n         DS    C\nXSDLEN   DS    C                   CSECT LENGTH (3 BYTES)\n@WAY08B  DS    C\n@WAY08C  DS    C\nXSD@L    EQU   *-XSDNO             ONE ENTRY LENGTH\n         DS    1000CL(XSD@L)\n         DS    1000CL(XSD@L)\n@DATAL   EQU   (((*-@DATA)+7)/8)*8\n         SPACE 1\n@SIZE    EQU   WALEN+@DATAL\n         EJECT\n*------- CONTROL BLOCK MAPPINGS -------------------------------------*\n         SPACE 1\nRITPFT   EQU   X'D0'               POINTER TO APPARENT PFT (XA-IARRIT)\nPFTVSA   EQU   X'14'               VIRT STORAGE ADDR (XA-IARPFTE)\n         PRINT &PRS\n        SPLTAREA\n         SPACE 1\n        MYSAVE\n         SPACE 1\n        PARMLIST\n         SPACE 1\n        FDATE\n         PRINT &PRF\n        DCBD   DSORG=(PS,PO),DEVD=DA\n        IEFZB4D0\n        IEZIOB\n        IHAPSA ,\n        CVT    DSECT=YES,LIST=YES\n        IHAPVT ,\n        IKJTCB ,\n         PRINT GEN\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPSMACS": {"ttr": 14849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x07?\\x00\\x96\\x07?\\x10\\t\\x02\\xd0\\x02\\xd0\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-03-13T00:00:00", "modifydate": "1996-03-13T10:09:00", "lines": 720, "newlines": 720, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n         CKSCF &A,&B\n         LCLC  &X\n&X       SETC  'IHB'.'&SYSNDX'\n&X.A     EQU   &A-&B\n&X.B     EQU   &B-&A\n         DS    (&X.A)H\n         DS    (&X.B)H\n         MEND\n         MACRO\n         FDATE\n*------- ETPS - FORMAT DATE AND TIME ---------------------------------*\nFDTWA    DSECT\n         DS    18F                 SAVE-AREA OF \"ETPSFDTE\"\nFDTWK    DS    D\nFXYEAR   DS    0CL4,CL2            'YY'\nFXYY     DS    CL2                 'YY'\nFXMM     DS    CL2                 'MM'\nFXDD     DS    CL2                 'DD'\nFTM      DS    0CL6\nFTHH     DS    CL2                 'HH'\nFTMM     DS    CL2                 'MM'\nFTSS     DS    CL2                 'SS'\nFXDDD    DS    CL3                 'DDD'\nFXMONTH  DS    CL3                 'MMM' (NAME)\nFXDAY    DS    CL3                 'DDD' (NAME)\nFDTWAL   EQU   (((*-FDTWA)+7)/8)*8\n         MEND\n         MACRO\n         DIRMASK\n*------- ETPS - DIRECTORY SCREEN FORMAT ------------------------------*\nDIRMASK  DSECT\nDIRLGTH  DS    XL1                 LENGTH CODE\nDIRSUN1  DS    XL1                 UNPROTECTED\nDIRCODE  DS    XL1                 SELECT CODE\nDIRSUN2  DS    XL1                 PROTECTED\n         DS    CL2\nDIRNAME  DS    CL9                 MEMBER NAME\n         DS    CL1\nDIRSUN3  DS    XL1                 UNPROTECTED\nDIRNWNM  DS    CL10                NEW NAME FOR COPY OR RENAME\n         DS    XL1                 PROTECTED\n         DS    0CL50 - - - - - - - DIRECTORY INFO\nDIRLEVEL DS    CL6                  \" \"\nDIRCREAT DS    CL10                 \" \"\nDIRMOD   DS    CL16                 \" \"\nDIRLINES DS    CL6                  \" \"\nDIRUSER  DS    CL8                  \" \"\n         DS    CL4                  \" \" (GAS)\n         MEND\n         MACRO\n         MIDENT\n         PRINT OFF\n         GBLC  &PRS,&PRF\n         COPY  ETPSDEFS            \"ETPS\" DEFINITIONS\n         PRINT ON\n         AIF   ('&SYSECT' EQ 'ETPSZAP').MZAP\n         AIF   ('&SYSECT' EQ 'ETPSIZAP').IZAP\n         AIF   ('&SYSECT' EQ 'ETPSDSST').DSST\n*------- ORIGIN : BRIAN COOK (CBT TAPE 94 DEC, FILE 353).\n         AGO   .MDEF\n.MZAP    ANOP\n*------- ORIGIN : THE FAMOUS UCLA/OAC 'ZAP' TSO-COMMAND\n*                 (CBT TAPE 84 JUN, FILE 300),\n         AGO   .ADEF\n.IZAP    ANOP\n*------- ORIGIN : THE WELL-KNOWN 'INCORZAP' PROGRAM\n*                 (CBT TAPE 86 FEB, FILE 421),\n         AGO   .ADEF\n.DSST    ANOP\n*------- ORIGIN : THE DISK DATA-SET STATISTICS PROGRAM\n*                 (DON'T REMEMBER FROM WHICH OLD CBT TAPE\n*                 IT HAS BEEN EXTRACTED, NAMED 'STATDS'),\n.ADEF    ANOP\n*                 ADAPTED TO RUN UNDER 'ETPS', AND THUS,\n.MDEF    ANOP\n*        RE-WORKED BY : MOINIL P.A.\n*                       COMPUTING CENTRE (TP 361)\n*                       J.R.C. - ISPRA ESTABLISHMENT\n*                       21020 ISPRA (VA), ITALY\n         SPACE 1\n         AIF   ('&SYSECT' NE 'ETPSCOMP').NOT1\n         MNOTE 0,' ETPSCOMP : IEBCOPY - SYSPRINT DEFINITIONS '\n         MNOTE 0,' UNIT NAME . . . . . . . . &CUNME '\n         MNOTE 0,' SPACE UNIT  . . . . . . . &CSPUN '\n         MNOTE 0,' PRIMARY QUANTITY  . . . . &CPRIQ '\n         MNOTE 0,' SECONDARY QUANTITY  . . . &CSECQ '\n         MNOTE 0,' RECORD FORMAT . . . . . . &CRCFM '\n         MNOTE 0,' BLOCK SIZE  . . . . . . . &CBLSZ '\n         MNOTE 0,' LOGICAL RECORD LENGTH . . &CLRCL '\n         AGO   .MEND\n.NOT1    AIF   ('&SYSECT' NE 'ETPSEDIT').NOT2\n         MNOTE 0,' ETPSEDIT : THRESHOLD LIMIT DEFINITION '\n         MNOTE 0,' CARDS (MAXIMUM) . . . . . &ELIMT '\n         AGO   .MEND\n.NOT2    AIF   ('&SYSECT' NE 'ETPSIDCA').NOT3\n         MNOTE 0,' ETPSIDCA : IDCAMS - SYSPRINT DEFINITIONS '\n         MNOTE 0,' UNIT NAME . . . . . . . . &IUNME '\n         MNOTE 0,' SPACE UNIT  . . . . . . . &ISPUN '\n         MNOTE 0,' PRIMARY QUANTITY  . . . . &IPRIQ '\n         MNOTE 0,' SECONDARY QUANTITY  . . . &ISECQ '\n         MNOTE 0,' RECORD FORMAT . . . . . . &IRCFM '\n         MNOTE 0,' BLOCK SIZE  . . . . . . . &IBLSZ '\n         MNOTE 0,' LOGICAL RECORD LENGTH . . &ILRCL '\n         AGO   .MEND\n.NOT3    AIF   ('&SYSECT' NE 'ETPSZAP').NOT4\n         MNOTE 0,' ETPSZAP : ZAP LOG DATA-SET DEFINITIONS '\n         MNOTE 0,' UNIT NAME . . . . . . . . &ZUNME '\n         MNOTE 0,' VOLUME SERIAL NUMBER  . . &ZVLSR '\n         MNOTE 0,' SPACE UNIT  . . . . . . . &ZSPUN '\n         MNOTE 0,' PRIMARY QUANTITY  . . . . &ZPRIQ '\n         MNOTE 0,' SECONDARY QUANTITY  . . . &ZSECQ '\n         AGO   .MEND\n.NOT4    AIF   ('&SYSECT' NE 'ETPSIZAP').NOT5\n         MNOTE 0,' ETPSINCZ : INCORZAP - SYSPRINT DEFINITIONS '\n         MNOTE 0,' UNIT NAME . . . . . . . . &IZUNM '\n         MNOTE 0,' VOLUME SERIAL NUMBER  . . &IZVSN '\n         MNOTE 0,' SPACE UNIT  . . . . . . . &IZSPU '\n         MNOTE 0,' PRIMARY QUANTITY  . . . . &IZPRQ '\n         MNOTE 0,' SECONDARY QUANTITY  . . . &IZSCQ '\n         AGO   .MEND\n.NOT5    AIF   ('&SYSECT' NE 'ETPSDSST').MEND\n         MNOTE 0,' ETPSDSST : STATDS - PARTITIONED DATA-SETS LIMITS '\n         MNOTE 0,' MAX. \"REAL\" MEMBERS . . . &STTMM '\n         MNOTE 0,' MAX. \"GAS\" MEMBERS  . . . &STTMG '\n         MNOTE 0,'                     OUTPUT PRINT DEFINITIONS '\n         MNOTE 0,' UNIT NAME . . . . . . . . &DPUNM '\n         MNOTE 0,' VOLUME SERIAL NUMBER  . . &DPVSN '\n         MNOTE 0,' SPACE UNIT  . . . . . . . &DPSPU '\n         MNOTE 0,' PRIMARY QUANTITY  . . . . &DPPRQ '\n         MNOTE 0,' SECONDARY QUANTITY  . . . &DPSCQ '\n         MNOTE 0,'                     OUTPUT TRACE DEFINITIONS '\n         MNOTE 0,' UNIT NAME . . . . . . . . &DTUNM '\n         MNOTE 0,' VOLUME SERIAL NUMBER  . . &DTVSN '\n         MNOTE 0,' SPACE UNIT  . . . . . . . &DTSPU '\n         MNOTE 0,' PRIMARY QUANTITY  . . . . &DTPRQ '\n         MNOTE 0,' SECONDARY QUANTITY  . . . &DTSCQ '\n.MEND    PRINT &PRF\n*------- ETPS - GENERAL REGISTERS DEFINITION -------------------------*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10                  SPLIT-SCREEN WORK-AREA POINTER\nR11      EQU   11                  2ND BASE REGISTER\nR12      EQU   12                  1ST BASE REGISTER\nR13      EQU   13                  WORK-AREA POINTER\nR14      EQU   14                  LINK REGISTER\nR15      EQU   15                  ENTER / RETURN CODE REGISTER\n         PRINT &PRS\nVLB      EQU   X'80'               \"VL\" BIT\nEOS      EQU   X'80'               END-OF-SCREEN\nEOL      EQU   X'80'               END-OF-LIST\nEML      EQU   X'80000000'         END-MARK-LIST\nKB       EQU   1024                ONE K BYTES\nINFMOD   EQU   X'08'               INPUT FIELD \"MODIFIED\" BIT\n         MEND\n         MACRO\n&NAME    MSG  &TX,&H=N\n         LCLA  &L\n         AIF   ('&TX' NE '').A\n         MNOTE 8,' MESSAGE TEXT MISSING **************************** '\n         MEXIT\n.A       AIF   ('&TX'(1,1) EQ '''').B\n         MNOTE 8,' STARTING QUOTE MISSING ************************** '\n         MEXIT\n.B       ANOP\n&L       SETA  K'&TX\n         AIF   ('&TX'(&L,1) EQ '''').C\n         MNOTE 8,' ENDING QUOTE MISSING **************************** '\n         MEXIT\n.C       ANOP\n&L       SETA  &L-2\n         AIF   (&L NE 0).D\n         MNOTE 8,' NO MESSAGE TEXT PROVIDED ************************ '\n         MEXIT\n.D       AIF   (&L LE 20).E\n         MNOTE 8,' MESSAGE TEXT TOO LONG (20 MAX. ALLOWED) ********* '\n         MEXIT\n.E       ANOP\n&NAME    DC    AL1(&L),CL&L.&TX\n         AIF   ('&H'(1,1) NE 'Y').END\n         DS    0H\n.END     MEND\n         MACRO\n         MYSAVE\n         GBLC  &PRS,&PRF\n*------- ETPS - MAIN SAVE-AREA DSECT ---------------------------------*\nMYSAVE   DSECT\nSAVE1    DS    18F                 MAIN SAVE-AREA\nSAVE2    DS    18F                 SELECT SAVE-AREA\nSAVE3    DS    18F                 EXECUTE SAVE-AREA\nSAVE4    DS    18F                 TERMINAL I/O SAVE-AREA\nSAVLEN   EQU   *-MYSAVE\nSPLITWRK DS    XL(SPLTLEN)\nAREALEN  EQU   *-MYSAVE\nPRISPLIT DS    4F                  R10-R13 TO BEGIN SPLIT-SCREEN\nSPLOFF1  DS    F                   1ST OFFSET TO SPLIT AREA\nSPLOFF2  DS    F                   2ND OFFSET TO SPLIT AREA\nTERMOUT  DS    44F                 (\"OUTPTBUF\")\nTERMINPT DS    44F                 (\"INPTBUF\")\nPARMVL   DS    10F\nSAVETOP  DS    F                   ADDRESS OF GETMAINED AREA\nARPOPS   DS    F                   EPA OF \"ETPSPOPS\"\nARCOMM   DS    F                   EPA OF \"ETPSCOMM\"\nARLIBM   DS    F                   EPA OF \"ETPSLIBM\"\nARDYNAM  DS    F                   EPA OF \"ETPSDYNA\"\nARFDTE   DS    F                   EPA OF \"ETPSFDTE\"\nARMESS   DS    F                   EPA OF \"ETPSMESS\"\nARBROWSE DS    F                   EPA OF \"ETPSBROW\"\nAREDIT   DS    F                   EPA OF \"ETPSEDIT\"\nARMEMC   DS    F                   EPA OF \"ETPSMEMC\"\nARCOMP   DS    F                   EPA OF \"ETPSCOMP\"\nARIDCA   DS    F                   EPA OF \"ETPSIDCA\"\nARZAP    DS    F                   EPA OF \"ETPSZAP\"\nARIZAP   DS    F                   EPA OF \"ETPSIZAP\"\nARSTAT   DS    F                   EPA OF \"ETPSDSST\"\nDYNWORKP DS    2F                  (\"DYNWORKS\",\"DYNRCODE\")\nDYNRCODE DS    2F\n         PRINT &PRF\nTUBE    DCB    DSORG=PS,MACRF=E,DDNAME=SCREEN,BUFL=4*KB,RECFM=U    <X>\n         PRINT &PRS                                                <X>\nTUBEL    EQU   *-TUBE                                              <X>\n         DS    0F                                                  <X>\nIOBLEN   EQU   (IOBUCBX-IOBSTDRD)+8                                <X>\nTUBEIOB  DS    XL(IOBLEN)                                          <X>\nRECB     DS    F                                                   <X>\nXWAPTR   DS    F                   ATTENTION-ESTAE WORK-AREA PTR.  <X>\nCCW1     DS    D                                                   <X>\nCCW2     DS    D                                                   <X>\nDBLWRD   DS    D\nTERMSNME DS    CL8                 TERMINAL SYMBOLIC NAME\nUSERID   DS    CL8                 USER-ID\nUSERPASS DS    CL8                 PASSWORD\nRACGROUP DS    CL8                 RACF GROUP-ID\nSUBACB   DS    F\nSUBRPL   DS    F\nSUBSUBP  DS    F\nSUBRB    DS    XL(S99RBEND-S99RB)  S99RB SPACE\nSUBTXP   DS    4F\n         PRINT &PRF\n*                                  WORK AREA FOR GENCB ACB\nACBWORK GENCB  BLK=ACB,AM=VSAM,MACRF=(ADR,SEQ,OUT),                    X\n               DDNAME=SUBJOB,MF=L\n*                                  WORK AREA FOR GENCB RPL\nRPLWORK GENCB  BLK=RPL,AM=VSAM,ACB=*-*,OPTCD=(ADR,SEQ,SYN,NUP),        X\n               RECLEN=80,MF=L\n*                                  WORK AREA FOR MODCB RPL\nMODWORK MODCB  RPL=*-*,AREA=*-*,ACB=*-*,MF=L\n         PRINT &PRS\nBUFF     DS    F                   OUTPUT BUFFER ADDRESS (\"SCREENIO\")\nREPLY    DS    F                   INPUT BUFFER ADDRESS (\"REPLYARE\")\nSUPRMOD  DS    F\nPROBMOD  DS    F\nHELPADD  DS    F                   ADDRESS OF HELP SCREEN\nMSGADD   DS    F                   ADDRESS OF SCREEN SHORT MESSAGE\nMESSNO   DS    H                   MESSAGE USE : NUMBER\nMESSRC   DS    H                   MESSAGE USE : RC\nMESSPL   DS    2F                  MESSAGE USE : EVENTUAL PARAMETERS\nMSGBUFF  DS    CL20                MESSAGE BUILD BUFFER\nSBAWORK  DS    0XL2\nSBAROW   DS    XL1\nSBACOL   DS    XL1\nSPLIT    DS    XL1       1=TOP, 2=BOTTOM, 0=NOT IN SPLIT-SCREEN MODE\nSTATSW   DS    XL1                 STATUS SWITCHES\nSPCLFLG  EQU   X'80'               RACF-USER HAS SPECIAL ATTRIBUTE\nINITFLG  EQU   X'08'               SPLIT-SCREEN REGISTERS SET\nTESTFLG  EQU   X'01'               TSO TEST (TEST LOGON PANEL)\nCOMMSW   DS    XL1\nHELPFLG  EQU   X'80'               PROCESSING HELP\nPERMERR  EQU   X'40'               PROCESSING PERM. IO-ERROR\nINTERR   EQU   X'20'               PROCESSING INT. IO-ERROR\nPFKFLAG  EQU   X'10'               RECEIVED PFK/ATTN ON READ\nEXTSBP   EQU   X'01'               EXTERNAL SCREEN BUFFER PROCESS\nWCCFLAG  DS    CL1                 A = ALARM, N = NO ALARM\nWRITECC  DS    XL1                 WRITE CCW COMMAND CODE          <X>\nATTNSW   DS    XL1                 ATTENTION SWITCHES              <X>\nATTRSET  EQU   X'80'               ATTENTION ROUTINE SET           <X>\nATTWAIT  EQU   X'08'               ATTENTION WAIT                  <X>\n*- - - - - - - - - - - - - - - - - SPLIT-SCREEN STUFF  - - - - - - - -\nBUFFL1   DS    F                   LENGTH OF OUTPUT BUFFER1\nSCREENSZ DS    F                   SIZE OF SCREEN\nSCROWS   DS    F                   NUMBER OF ROWS ON SCREEN\nSCROWS1  DS    F                   NUMBER OF ROWS ON SCREEN 1\nSCROWS2  DS    F                   NUMBER OF ROWS ON SCREEN 2\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nOPCLPL   DS    F                   OPEN-CLOSE PARM LIST\nDYNPARM  DS    F                                                   <X>\nDYNTEXT1 DS    F                   POINTER TO DYNDDNAM             <X>\nDYNTEXT2 DS    F                   POINTER TO DYNDISP              <X>\nDYNTEXT3 DS    F                   POINTER TO DYNUNIT              <X>\nDYNRB    DS    AL1                 LENGTH = 20                     <X>\nVERBCODE DS    AL1                 DSNAME ALLOCATION-UNALLOCATION  <X>\n         DS    2AL1                FLAGS                           <X>\nERRINFRC DS    2XL2                ERROR-INFORMATION REASON CODES  <X>\nTEXTPTRS DS    F                   POINTER TO TEXT POINTERS        <X>\n         DS    F                   RESERVED                        <X>\n         DS    F                   FLAGS                           <X>\nDYNDDNAM DS    3H                  DDNAME=TUBE                     <X>\nTUBEDDNM DS    CL8                 CL4'ETPS'/CL1'T'/CL3'CUU'       <X>\nTERMTYPE EQU   TUBEDDNM+4,1        T = 2=3278M2, 3=3279M3,         <X>\n*                                      4=3278M4, A=3278-2A         <X>\nTERMADDR EQU   TUBEDDNM+5,3        CUU = UNIT ADDRESS              <X>\nDYNDISP  DS    3H                  DISP=OLD                        <X>\n         DS    XL1                                                 <X>\nDYNUNIT  DS    3H                  UNIT=CUU                        <X>\nUNITADDR DS    CL3                                                 <X>\nDYNLENG  EQU   *-DYNRB             LENGTH FOR MOVE                 <X>\nSVRTR14  DS    F\nVCMLST  CAMLST NAME,*-*,*-*,*-*    OR CAMLST SEARCH,*-*,*-*,*-*\n         DS    0F\nVUSWA    DS    XL256,XL16          USED AS WORK-AREA\nXQSNAP   DS    0F,XL8              CALL SNAP                       <T>\nARSNAP   DS    F                   SNAP ADDRESS                    <T>\n*-- -- -- -- -- -- -- -- -- -->> END OF R13 NORMAL ADDRESSABILITY <<--\nLIB1DCB  DS    0F,XL(DCBLNGQS)\nMEM1DCB  DS    0F,XL(DCBLNGQS)\nCOP1DCB  DS    0F,XL(DCBLNGQS)\nLIB2DCB  DS    0F,XL(DCBLNGQS)\nMEM2DCB  DS    0F,XL(DCBLNGQS)\nCOP2DCB  DS    0F,XL(DCBLNGQS)\nSPLIT1   DS    0D,XL(AREALEN) SAVE-AREAS 1-4 FOR SCREEN 1 OF BUFFERS\nSPLIT2   DS    0D,XL(AREALEN) SAVE-AREAS 1-4 FOR SCREEN 2 OF BUFFERS\nSPMSGWA  DS    0D,XL256       SPACE FOR \"ETPSMESS\" WORK-AREA\nSTBIGWA  DS    0D  - - - - - - - - START OF BIG WORK AREAS - - - - - -\nSCREENIO DS    XL(2*KB)  THIS IS THE PHYSICAL I/O AREA BUFFER, BUILT\n         DS    XL(2*KB)       BY COMM FROM THE TERMOUT AREAS, AND USED\n*                             IN THE \"WRITE\" CCW (\"BUFF\")\nREPLYARE DS    XL(2*KB)  THIS IS THE PHYSICAL INPUT AREA USED BY COMM\n         DS    XL(2*KB)       IN THE \"READ\" CCW (\"REPLY\")\nINPTBUF  DS    XL(2*KB)  THIS IS THE INTERMEDIATE AREA, BUILT BY COMM\n         DS    XL(2*KB)       TO REFLECT THE RESULTS OF THE READ IN\n*                             PSEUDO FULL-SCREEN FORMAT (\"TERMINPT\")\nOUTPTBUF DS    XL(2*KB)  THIS IS THE INTERMEDIATE AREA, CONSTRUCTED\n         DS    XL(2*KB)       BY COMM FROM CALLING ROUTINE'S PARAMETER\n*                             LIST (\"TERMOUT\")\nDYNWORKS DS    XL(2*KB)  THIS IS \"DYNAM\" WORK-AREA\n         DS    0F\nGMSIZE   EQU   (((*-MYSAVE)+((4*KB)-1))/(4*KB))*(4*KB) ROUND UP TO 4K\n         MEND\n         MACRO\n         PARMLIST\n*------- ETPS - DYNAMIC ALLOCATION PARAMETER LIST --------------------*\nPARMLIST DSECT\nDDNAME   DS    CL8\nDSNAME   DS    CL44\nDSMEMBER DS    CL8\nPASSWORD DS    CL8\nDSSTATUS DS    CL8\nDSNDISP  DS    CL8\nDSADISP  DS    CL8\nDSUNIT   DS    CL8\n$RESERV1 DS    CL8\nDSVOLSER DS    CL6\n$RESERV2 DS    CL40\nDSVOLREF DS    CL44\nDSFREE   DS    CL8\nDSLABEL  DS    CL4\nDSINOUT  DS    CL4\n$RESERV3 DS    CL16\nDSPWDLBL DS    CL8\nDSDATE   DS    CL12\nDSALLOC  DS    CL5\nDSPRI    DS    CL6\nDSSEC    DS    CL6\nDSDIR    DS    CL5\nDSRLSE   DS    CL8\nDSCONTIG DS    CL8\nDSROUND  DS    CL8\n$RESERV4 DS    CL24\nDSBLKSI  DS    CL5\nDSORG    DS    CL8\nDSKEYLEN DS    CL3\nDSLRECL  DS    CL5\nDSRECFM  DS    0CL8                RECORD FORMAT\nDSRECFM1 DS    CL1                  \" \"\nDSRECFM2 DS    CL1                  \" \"\nDSRECFM3 DS    CL1                  \" \"\nDSRECFM4 DS    CL1                  \" \"\nDSRECFM5 DS    CL1                  \" \"\nDSRECFM6 DS    CL1                  \" \"\nDSRECFM7 DS    CL1                  \" \"\nDSRECFM8 DS    CL1                  \" \"\nDSDCBDS  DS    CL44\n$RESERV5 DS    CL24\nPARMLLEN EQU   *-PARMLIST\nSAVEAREA DS    18F                 SAVE-AREA OF \"ETPSDYNA\"\nREQBKPTR DS    F\nWKRTNVOL DS    F\nWKRTDSRG DS    F\n         DS    F\nDBLWORD  DS    D\n         DS    4F\nDYNWORK  DS    XL((2*KB)-((*-SAVEAREA)+(((PARMLLEN+3)/4)*4)))\nDYNWRKSZ EQU   *-SAVEAREA\n         MEND\n         MACRO\n&NAME    SETRF &RF\n         LCLA  &L,&N\n         LCLC  &S\n         AIF   ('&RF' NE '').A\n         MNOTE 8,' RECORD FORMAT MISSING *************************** '\n         MEXIT\n.A       ANOP\n&L       SETA  K'&RF\n         AIF   ('&RF'(1,1) EQ 'F').B\n         AIF   ('&RF'(1,1) EQ 'V').B\n.ERR     MNOTE 8,' RECORD FORMAT INVALID *************************** '\n         MEXIT\n.B       ANOP\n&S       SETC  'DCBREC'.'&RF'(1,1)\n         AIF   (&L EQ 1).X\n&N       SETA  2\n         AIF   ('&RF'(2,1) NE 'B').C\n&S       SETC  '&S'.'+DCBRECBR'\n         AIF   (&L EQ &N).X\n&N       SETA  3\n.C       AIF   ('&RF'(&N,1) NE 'A').ERR\n&S       SETC  '&S'.'+DCBRECCA'\n         AIF   (&L NE &N).ERR\n.X       ANOP\n&NAME    DC    AL1(&S)\n         MEND\n         MACRO\n         SPFMT\n*------- ETPS - SPF USER DATA ----------------------------------------*\nSPFMT    DSECT\nSPFVER   DS    XL1\nSPFMOD   DS    XL1\n         DS    XL2\n         DS    XL1\nSPFCRDT  DS    PL3\n         DS    XL1\nSPFMODT  DS    PL3\nSPFMODTM DS    XL2\nSPFSIZE  DS    XL2\nSPFSIZEI DS    XL2\nSPFMOD2  DS    XL2\nSPFUID   DS    CL7\n         DS    CL3\n         MEND\n         MACRO\n         SPLTAREA\n         GBLC  &PRS,&PRF\n*------- ETPS - SPLIT-AREA DSECT -------------------------------------*\nSPLTAREA DSECT\n*- - - - - - - - - - - - - - - - - - - - - - ETPS GENERAL WORK-AREAS\nCURADDR  DS    0XL2                CURSOR POSITION\nCURROW   DS    XL1\nCURCOL   DS    XL1\nHOMEADDR DS    XL2                 SAVE CURSOR POSITION (HELP USE)\nALIBDCB  DS    F                   DCB'S WORK-AREAS\nAMEMDCB  DS    F                    \" \"   \" \"\nACOPDCB  DS    F                    \" \"   \" \"\nNLDCB    EQU   (*-ALIBDCB)/4\n*- - - - - - - - - - - - - - - - - - - - - - - - ETPSBROW WORK-AREAS\nBRDBLW   DS    D\nDYNEXLST DS    2F\n         PRINT &PRF\n        READ   DYNDECBW,SF,*-*,*-*,'S',MF=L\n         PRINT &PRS\nDYNDECBL EQU   *-DYNDECBW\nBRRANGE  DS    2F\nBRANSWER DS    2F\nSAVBLKSI DS    F\nSAVSPANL DS    F\nSAVLRECL DS    F\nSAVHOLDL DS    F\nBLOCKPTR DS    F                   START OF GETMAINED AREA\nENDPTR   DS    F                   END OF GETMAINED AREA\nSPANPTR  DS    F                   START OF SPANNED REC. SEGMENTS AREA\nHOLDPTR  DS    F                   START OF RECORDS AREA\nHOLDTOP  DS    F                   FIRST \"HOLDDIR\" (TOP) POINTER\nHOLDEND  DS    F                   LAST \"HOLDDIR\" (END) POINTER\nTERMTOP  DS    F                   START \"TERMOUT\" POINTER (HEAD LINE)\nCHKPTTOP DS    F                   TOP OF CHECKPOINT TABLE\nCHKPTBOT DS    F                   BOTTOM OF CHECKPOINT TABLE\nBRCOUNT  DS    F                   RECORD NUMBER\nBRTTR    DS    F                   TTR\nBRTTRZ   DS    F                   TTR + 0 FOR POINT\nDOWNAMT  DS    F\nLISTNUM  DS    F\nFNDNUM   DS    F\nHOLDR14  DS    F\nREADR14  DS    F\nDOWNR14  DS    F\nTOPXR14  DS    F\nDEBLOCKS DS    0F                  DEBLOCKING INFO\n         DS    A                        END OF BLOCK ADDRESS\n         DS    F                        SEGMENT LENGTH\n         DS    A                        SEGMENT ADDRESS\nCHKPTDUM DS    0F                  DUMMY CHECKPOINT ENTRY\n         DS    F                        \"BRCOUNT\"\n         DS    F                        \"BRTTR\"\n         DS    3F                       \"DEBLOCKS\"\nCHKPTLEN EQU   *-CHKPTDUM          LENGTH OF A CHECKPOINT ENTRY\nHOLDDIR  DS    0F                  \"HOLDDIR\" DESCRIPTION\nDIRNUM   EQU   0                        REC. NUMBER\nDIRLEN   EQU   4                        DATA LENGTH\nDIRREC   EQU   8                        DATA RECORD\nDIRNXT   EQU   12                       NEXT \"HOLDDIR\"\nDIRSIZE  EQU   16                  \"HOLDDIR\" ELEMENT LENGTH\n         DS    51XL(DIRSIZE)       \"HOLDDIR\" RESERVATION\n         PRINT &PRF\nGMVCW   GETMAIN VC,MF=L\n         PRINT &PRS\nGMVCL    EQU   *-GMVCW\nRECSIZE  DS    H\nBROFFSET DS    H\nBRSCROLL DS    H\nBRSTRNGL DS    H\nFNDOFF   DS    H\nCOLNUM   DS    CL6\nBRSTRNG  DS    CL20\nWRKRECFM DS    XL1\nTSTRECFM DS    XL1\nBRSTSW   DS    XL1                 STATUS\nSTOPEN   EQU   X'80'\nSTGMVC   EQU   X'40'\nSTNOMEM  EQU   X'08'\nBRMODE   DS    XL1                 MODES\nMODEX    EQU   X'80'\nBRFSSW   DS    XL1                 TESTS\nFPFKSW   EQU   X'80'\nMAXUSW   EQU   X'40'\nMAXDSW   EQU   X'20'\nBRINSW   EQU   X'08'\nFINDSW   EQU   X'04'\nFSTRSW   EQU   X'02'\nSYNADSW  EQU   X'01'\nBRFUSW   DS    XL1                 FUNCTIONS\nBRASSW   EQU   X'80'                    ON = ASIS, OFF = CAPS\nBRHLSW   EQU   X'40'                    ON = HALF, OFF = PAGE\nBRCRSW   EQU   X'20'                    ON = CURSOR, OFF = PAGE\nBROWMSG  DS    CL22\nBRHDLN   DS    CL54\n*- - - - - - - - - - - - - - - - - - - - - - - - ETPSEDIT WORK-AREAS\nEDDBLW   DS    D\nEDTDCB   DS    F\nEDTRECS  DS    F                   INITIAL NUMBER OF CARDS\nEDTNOWL  DS    F                   CURRENT NUMBER OF CARDS\nEDTGASL  DS    F                   CURRENT NUMBER OF FREE CARDS\nEDTMAIN  DS    F                   START OF GETMAINED AREA\nEDTLENG  DS    F                   LENGTH OF GETMAINED AREA\nEDTFIRST DS    F                   POINTER TO FIRST CARD\nEDTLAST  DS    F                   POINTER TO LAST CARD\nEDTCURR  DS    F                   POINTER TO CURRENT CARD\nEDTPOOL  DS    F                   POINTER TO FREE CARDS POOL\nEDTABLOC DS    F                   OPERATION \"AFTER/BEFORE\" LOCATION\nEDTOFLOC DS    F                   OPERATION \"FROM\" LOCATION\nEDTOTLOC DS    F                   OPERATION \"UP TO\" LOCATION\nEDTFCCP  DS    F                   FIND/CHANGE CURRENT POINTER\nEDSCROLL DS    H\nEDTFOFF  DS    H\nEDTMEM   DS    CL8\nEDTPASS  DS    CL8\nEDTDSNM  DS    CL44\nEDTVOL   DS    CL6\nEDTNUM   DS    CL7\nEDTORG   DS    CL3\nEDADDR   DS    0XL2                REQUESTED CURSOR POSITION\nEDROW    DS    XL1\nEDCOL    DS    XL1\nEDFSSW   DS    XL1                 STATUS - REQUESTS\nFNDSSW   EQU   X'80'                    FIND STRING DEFINED\nCHGSSW   EQU   X'40'                    CHANGE STRING DEFINED\nEDDTSW   EQU   X'20'                    ORIGINAL INPUT DATA = ASIS\nRNUMSW   EQU   X'10'                    RENUMBER ALL CARDS REQUEST\nSVDTSW   EQU   X'01'                    DATA HAS BEEN CHANGED\nEDPNSW   DS    XL1                 PENDING ACTIONS\nAFBESW   EQU   X'80'                    AFTER/BEFORE LOCATION\nRNGESW   EQU   X'40'                    RANGE COMPLETE\nCPABSW   EQU   X'20'                    COPY LINE\nMVABSW   EQU   X'10'                    MOVE LINE\nCPRGSW   EQU   X'08'                    COPY RANGE\nMVRGSW   EQU   X'04'                    MOVE RANGE\nDLRGSW   EQU   X'02'                    DELETE RANGE\nRPRGSW   EQU   X'01'                    REPEAT RANGE\nEDTQST   DS    XL1                 TESTS\nGTSYFLG  EQU   X'80'                    ON = ERROR ON GET DATA\nPTSYFLG  EQU   X'40'                    ON = ERROR ON PUT DATA\nEODIFLG  EQU   X'20'                    ON = EODAD ON SAVE IN-PLACE\nNQSTSW   EQU   X'02'                    SUPPRESS STRING QUOTE TEST\nQSTRSW   EQU   X'01'                    SCAN STRING QUOTE TEST\nEDFUSW   DS    XL1                 FUNCTIONS\nEDASSW   EQU   X'80'                    ON = ASIS, OFF = CAPS\nEDHLSW   EQU   X'40'                    ON = HALF, OFF = PAGE\nEDCRSW   EQU   X'20'                    ON = CURSOR, OFF = PAGE\nEXTCPY   EQU   X'01'                    EXTERNAL COPY REQUEST\nEDTCMND  DS    CL7\nEDFINDL  DS    XL1\nEDFINDS  DS    XL24\nEDCHNGL  DS    XL1\nEDCHNGS  DS    XL24\nEDTMSG   DS    XL24\n*- - - - - - - - - - - - - - - - - - - - - - - - - ETPSLIBM WORK-AREAS\nDRDBLW   DS    D\nDIRPOINT DS    F                   TTR0 TO POINT A DIR. RECORD\nDIRNOTE  DS    XL1                 MAX. R OF TTR'S DIR. TRACK\nDIRTOP   DS    XL3                 TTR OF TOP SCREEN MEMBER NAME\nDIRBOT   DS    F                   TTR0 OF BOTTOM SCREEN MEMBER NAME\nDIRSR14  DS    F\nDIRPASS  DS    CL8                 PASSWORD, IF ANY\nFIRSTMEM DS    CL8                 TOP SCREEN MEMBER NAME\nLASTMEM  DS    CL8                 BOTTOM SCREEN MEMBER NAME\nLOCNAME  DS    CL8                 LOCATE MEMBER NAME\nDIRDSNM  DS    CL44                DATA-SET NAME\nDRSCROLL DS    H\nDIRVOL   DS    CL6                 VOLUME SERIAL NUMBER\nDIRORG   DS    CL3                 DSORG\nSELFUNC  DS    CL1                 SELECT CODE = B/C/D/E/R/S/U\nDRFLSW   DS    XL1                 TESTS\nDIREOFLG EQU   X'80'                    ON = EOF ON LIB. DIR.\nSYNADFLG EQU   X'40'                    ON = ERROR ON LIB. DIR.\nDRFUSW   DS    XL1                 FUNCTIONS\nDRRCSW   EQU   X'80'                    DIR. RECORD STILL IN \"PDSKEY\"\nDRHLSW   EQU   X'40'                    ON = HALF, OFF = PAGE\nDRCRSW   EQU   X'20'                    ON = CURSOR, OFF = PAGE\nDRUPSW   EQU   X'01'                    ON = UP, OFF = DOWN\nDIRADDR  DS    XL2                 REQUESTED CURSOR (ROW,COLUMN)\nNWNMFLD  DS    CL10                SCREEN NEW MEMBER NAME\nDRLBMSG  DS    CL22\nSEQRNUM  DS    F\n         PRINT &PRF\n        READ   DIRDECBW,SF,*-*,*-*,'S',MF=L\n         PRINT &PRS\nDIRDECBL EQU   *-DIRDECBW\nFNDWA    DS    CL24\nCRDWA    DS    CL80\nPDSKEY   DS    CL8,XL256\n*- - - - - - - - - - - - - - - - - - - - - - - - - ETPSZAP WORK-AREAS\n         DS    0D\nZAPDSNM  DS    CL44                DATA-SET NAME\nZAPPASS  DS    CL8                 PASSWORD, IF ANY\nZAPVOL   DS    CL6                 VOLUME SERIAL NUMBER\nZAPLGDSN DS    CL44                \"LOG\" DATA-SET NAME\nZAPLGVOL DS    CL6                 \"LOG\" VOLUME SERIAL NUMBER\nZLGSW    DS    XL1\nZLGVIEW  EQU   X'80'               VIEW \"LOG\" DATA-SET REQUESTED\nZLGDEL   EQU   X'40'               DELETE \"LOG\" DATA-SET REQUESTED\nZLGALT   EQU   X'08'               ALTERNATE CURSOR POSITION\nZLGPOC   EQU   X'04'               PANEL OPTION CHANGED\n*- - - - - - - - - - - - - - - - - - - - - - - - - -  ETPS WORK-AREAS\n         DS    0D\nN#IN     DS    CL8                 DDNAME FOR SYSIN\nN#PRINT  DS    CL8                  \" \"       SYSPRINT\nN#UT1    DS    CL8                  \" \"       SYSUT1\nN#UT2    DS    CL8                  \" \"       SYSUT2\nN#UT3    DS    CL8                  \" \"       SYSUT3\nN#UT4    DS    CL8                  \" \"       SYSUT4\nLIBPASS  DS    CL8                 LAST PASSWORD IN SCREEN\nLIBDSNM  DS    CL44                LAST DSNAME IN SCREEN\nLIBVOL   DS    CL6                 LAST VOLSER IN SCREEN\nLIBORG   DS    CL3                 LAST DSORG IN SCREEN\nLIBFUNC  DS    CL1                 FUNCTION CODE = B, E OR U\nPRIMEFLG DS    XL1                 1 = DOING PRIMARY OPTION MENU\nPRCSSW   DS    XL1                 VARIOUS PROCESSING SWITCHES\nVSRFC    EQU   X'80'               VOLSER RETRIEVED FROM CATALOG\nASISFLG  EQU   X'01'               INPUT PROCESSED ASIS\nSPLTLEN  EQU   (((*-SPLTAREA)+7)/8)*8\n         MEND\n         MACRO\n         XAREA\n*------- ETPS - EXCP ATTENTION WORK AREA DSECT ------------------* <X>\nXWAREA   DSECT ,                                                   <X>\n*- - - - DS    0D                  ATTENTION ENTRY                 <X>\nXWATTN   DS    (XASKLL)X           SHORT ENTRY CODE                <X>\nXWAREP   DS    F                   \"XATTN\" ADDRESS                 <X>\nXWARPT   DS    F                   \"XWAREA\" ADDRESS                <X>\n*- - - - DS    0D                  ABEND ENTRY                     <X>\nXWABND   DS    (XXSKLL)X           SHORT ENTRY CODE                <X>\nXWXAEP   DS    F                   \"XABEND\" ADDRESS                <X>\nXWXAPT   DS    F                   \"XWAREA\" ADDRESS                <X>\nXWXSVR   DS    16F                 ABEND EXIT REGISTERS SAVE-AREA  <X>\n*- - - - DS    0D                  COMMON DATA SECTION             <X>\nXWMYSV   DS    F                   \"MYSAVE\" ADDRESS                <X>\nXWUCB    DS    F                   UCB ADDRESS                     <X>\nXWATP    DS    F                   ATTENTION TABLE ENTRY ADDRESS   <X>\nXWAIX    DS    F                   ATTENTION INDEX                 <X>\nXWRST    DS    2F                  RESTORE VALUES                  <X>\nXWSET    DS    2F                  SET VALUES                      <X>\nXWLIST   DS    0F,(XSKELL)X        ESTAE LIST                      <X>\nXWTOKEN  DS    F                   ESTAE TOKEN                     <X>\n         DS    ((4*KB)-(*-XWATTN))X SKIP SPACE                     <X>\nXWAREAL  EQU   *-XWAREA            ONE PAGE WORK-AREA LENGTH       <X>\n         MEND\n         MACRO\n&NAME    XMESS &NO,&RC\n         LCLC  &N\n&N       SETC  '&NAME'\n         AIF   ('&NO' EQ '').A\n&N       MVC   MESSNO,=H'&NO'      SET MESSAGE NUMBER\n&N       SETC  ''\n.A       AIF   ('&RC' EQ '').B\n&N       STH   &RC,MESSRC          STORE RETURN CODE\n&N       SETC  ''\n.B       ANOP\n&N       L     R0,SAVETOP\n         L     R15,ARMESS\n         BALR  R14,R15             GO SEND MESSAGE\n         MEND\n         MACRO\n&NAME    XSNAP &ID\n&N       SETC  '&ID'\n         AIF   ('&ID' NE '').A\n&N       SETC  '0'\n.A       ANOP\n&NAME    TM    ARSNAP+3,X'01'      SNAP ACTIVE?\n         BO    *+L'*+14            NO, SKIP\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         BAL   R14,XQSNAP          EXECUTE SNAP\n         DC    H'&N'          <=== SNAP-ID NUMBER ================ SNAP\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPSMEMC": {"ttr": 15108, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x05\\x9f\\x00\\x96\\x05\\x9f\\x17#\\x014\\x014\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-02-28T00:00:00", "modifydate": "1996-02-28T17:23:00", "lines": 308, "newlines": 308, "modlines": 0, "user": "SYSPAJA"}, "text": "MEMC     TITLE '--- E T P S -- ETPSMEMC - MEMBER COPY ---'\n         PRINT OFF\n         COPY  ETPS$O1             \"ETPS\" SYSPARM SELECTION\n         COPY  ETPSMACS            \"ETPS\" MACROS\n         COPY  ETPSDEFS            \"ETPS\" DEFINITIONS\n         PRINT ON\nETPSMEMC START 0\n         SPACE 1\nETPSMEMC AMODE 24\nETPSMEMC RMODE 24\n        MIDENT\n         EJECT\n*------- AT ENTRY, R1 = A(PARM.LIST) -> (I.DS-NAME,\n*                                        I.MEMBER-NAME,\n*                                        I.VOL-SER,\n*                                        I.PASSWORD,\n*                                        O.DS-NAME,\n*                                        O.MEMBER-NAME,\n*                                        O.VOL-SER,\n*                                        O.PASSWORD,\n*                                        SHORT-MSG-AREA)\n         SPACE 1\n         PRINT GEN\n         USING *,R12\n         B     32(,R15)\n         DC    CL28'  ETPSMEMC &SYSDATE &SYSTIME'\n         PRINT &PRF\n         STM   R14,R12,12(R13)     SAVE INPUT REGISTERS\n         LR    R12,R15             SET BASE REGISTER\n         LR    R2,R1               RETAIN PARM ADDRESS\n         L     R10,8*4(R2)         SHORT-MSG-AREA ADDRESS\n         L     R11,=A(WKLEN)\n        GETMAIN RC,LV=(R11)        GET LOCAL SA-WA\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    *+L'*+14            OK\n         LR    R5,R15              ERROR\n         LA    R4,16               SET ERROR RC\n         LA    R9,MSG1\n         B     QUIT\n         LR    R0,R1\n         LR    R1,R11\n         LR    R11,R0\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R0,R14              CLEAR ALL TO BINARY ZEROS\n         ST    R13,4(R11)          STORE BACKWARD POINTER\n         ST    R11,8(R13)          STORE FORWARD POINTER\n         LR    R13,R11\n         USING WKAREA,R11\n         LM    R3,R6,0(R2)\n         MVC   INDSNAME(SKLTUL),SKLTU\n         MVC   INDS(L'INDS),0(R3)  R3  = INPUT DS-NAME\n         MVC   INM(L'INM),0(R4)    R4  = INPUT MEMBER-NAME\n         MVC   INV(L'INV),0(R5)    R5  = INPUT VOL-SER\n         MVC   INP(L'INP),0(R6)    R6  = INPUT PASSWORD\n         LM    R3,R6,4*4(R2)\n         MVC   OUDSNAME(SKLTUL),SKLTU\n         MVC   OUDS(L'OUDS),0(R3)  R3  = OUTPUT DS-NAME\n         MVC   OUM(L'OUM),0(R4)    R4  = OUTPUT MEMBER-NAME\n         MVC   OUV(L'OUV),0(R5)    R5  = OUTPUT VOL-SER\n         MVC   OUP(L'OUP),0(R6)    R6 = OUTPUT PASSWORD\n         MVC   RB99TU(SKLLEN),SKL  ALLOCATE LIBRARY AS INPUT\n         LA    R0,INDSNAME\n         ST    R0,INNADDR\n         OI    INV,C' '\n         CLI   INV,C' '\n         BE    *+L'*+8\n         LA    R0,INMEM\n         ST    R0,INMADDR\n         LA    R0,INVOLSER\n         ST    R0,INVADDR\n         OI    INP,C' '\n         CLI   INP,C' '\n         BE    *+L'*+8\n         LA    R0,INPASS\n         ST    R0,INPADDR\n         LA    R0,INDDNAME\n         O     R0,INRADDR\n         ST    R0,INRADDR\n         BAL   R8,DYNALL\n         B     ALLERR              +0 - ERROR RETURN\n         MVC   RB99TU(SKLLEN),SKL  ALLOCATE LIBRARY AS OUTPUT\n         LA    R0,OUDSNAME\n         ST    R0,OUNADDR\n         OI    OUV,C' '\n         CLI   OUV,C' '\n         BE    *+L'*+8\n         LA    R0,OUMEM\n         ST    R0,OUMADDR\n         LA    R0,OUVOLSER\n         ST    R0,OUVADDR\n         OI    OUP,C' '\n         CLI   OUP,C' '\n         BE    *+L'*+8\n         LA    R0,OUPASS\n         ST    R0,OUPADDR\n         LA    R0,OUDDNAME\n         O     R0,OURADDR\n         ST    R0,OURADDR\n         BAL   R8,DYNALL\n         B     DEALL               +0 - ERROR RETURN\n         LR    R5,R4\n         MVC   SYSUT1(UT1L),UT1    MOVE IN DCB'S\n         MVC   SYSUT1+DCBDDNAM-IHADCB(L'DCBDDNAM),INDD INPUT DDNAME\n         LA    R1,ALLDONE\n         STCM  R1,B'0111',SYSUT1+DCBEODA-IHADCB\n         LA    R1,ERRSYN\n         STCM  R1,B'0111',SYSUT1+DCBSYNA-IHADCB\n         MVC   SYSUT2(UT2L),UT2\n         MVC   SYSUT2+DCBDDNAM-IHADCB(L'DCBDDNAM),OUDD OUTPUT DDNAME\n         LA    R1,ERRSYN\n         STCM  R1,B'0111',SYSUT2+DCBSYNA-IHADCB\n         MVC   OPENEM(OPNL),OPN    MOVE IN OPEN LIST\n        OPEN   (SYSUT1,(INPUT),SYSUT2,(OUTPUT)),MF=(E,OPENEM)\n         TM    SYSUT1+DCBOFLGS-IHADCB,DCBOFOPN TEST FOR GOOD OPEN\n         BO    *+L'*+8             OK, GOOD\n         LA    R9,MSG4\n         B     ERRDONE             NO GOOD, GO BACK\n         TM    SYSUT2+DCBOFLGS-IHADCB,DCBOFOPN TEST FOR GOOD OPEN\n         BO    GETLOOP             OK, GOOD\n         LA    R9,MSG5\n         B     ERRDONE             NO GOOD, GO BACK\nGETLOOP  LA    R6,SYNIFL\n        GET    SYSUT1\n         TM    WKFLGS,SYNIFL       WAS SYNAD EXIT TAKEN?\n         BO    STERRM              YES, BRANCH\n         LA    R6,SYNOFL\n         LR    R2,R1\n        PUT    SYSUT2,(R2)\n         TM    WKFLGS,SYNOFL       WAS SYNAD EXIT TAKEN?\n         BZ    GETLOOP             NO, BRANCH\nSTERRM   LA    R9,ERRMSG           YES, ERROR\nERRDONE  LA    R4,16               SET ERROR RC\nALLDONE CLOSE  (SYSUT1,,SYSUT2),MF=(E,OPENEM)\n         B     LEAVE\nDEALL    MVC   RB99TU(SKDLEN),SKD  FREE PREVIOUS INPUT ALLOCATION\n         MVC   INDDNAME(2),=AL2(DUNDDNAM)\n         LA    R0,INDDNAME\n         ST    R0,RB99TU\n         BAL   R8,UNALL\n         LA    R9,MSG3\n         B     LEAVE\nALLERR   LA    R9,MSG2\nLEAVE    L     R13,4(,R13)         PICK UP CALLING SAVE-AREA\n         L     R0,=A(WKLEN)\n        FREEMAIN R,LV=(0),A=(R11)  FREE LOCAL SA-WA\nQUIT     STM   R4,R5,16(R13)       PASS BACK R15-R0\n         LTR   R4,R4               RC = 0?\n         BZ    *+L'*+14            YES, SKIP\n         XR    R15,R15             ELSE SET SHORT-MSG\n         IC    R15,0(R9)\n         LA    R15,1(R15)\n         EX    R15,*+L'*+6\n         LM    R14,R12,12(R13)     RESTORE CALLING REGISTERS\n         BR    R14\n         MVC   0(*-*,R10),0(R9)    <<EXECUTED>>\n         EJECT\nUNALL    LA    R0,S99VRBUN         UNALL ROUTINE --------------------*\n         B     DYNALL+L'DYNALL\nDYNALL   LA    R0,S99VRBAL         DYNALL ROUTINE -------------------*\n         MVC   RB99P(SKRLEN),SKR\n         STC   R0,RB99VR\n         LA    R0,RB99TU\n         ST    R0,RB99TUP\n         LA    R0,RB99\n         O     R0,RB99P\n         ST    R0,RB99P\n         LA    R1,RB99P\n        DYNALLOC\n         CLI   RB99VR,S99VRBAL     DYNALL?\n         BNER  R8                  NO, ALWAYS RETURN\n         L     R5,RB99RC           CHECK ANY ERROR\n         LTR   R4,R15\n         BNZR  R8                  ERROR, RETURN +0\n         LTR   R5,R5\n         BNZR  R8                  ERROR, RETURN +0\n         B     4(R8)               NORMAL, RETURN +4\n         SPACE 1\n*------- SYNAD EXITS - ENTERED DURING I/O IF AN ERROR OCCURS.\n         CNOP  0,4\nERRSYN  SYNADAF ACSMETH=QSAM\n         MVI   ERRMSG,15\n         MVC   ERRMSG+1(15),91(R1) ERROR DESCRIPTION ONLY\n         EX    R6,SETFLG\n        SYNADRLS\n         BR    R14\nSETFLG   OI    WKFLGS,*-*          <<EXECUTED>>\n         EJECT\nUT1     DCB    DSORG=PS,MACRF=(GL),DDNAME=XXXXXXXX,EODAD=*-*,SYNAD=*-*\nUT1L     EQU   (((*-UT1)+3)/4)*4\nUT2     DCB    DSORG=PS,MACRF=(PM),DDNAME=XXXXXXXX,SYNAD=*-*\nUT2L     EQU   (((*-UT2)+3)/4)*4\nOPN     OPEN   (UT1,(INPUT),UT2,(OUTPUT)),MF=L\nOPNL     EQU   (((*-OPN)+3)/4)*4\n         SPACE 1\nSKR      DC    0F'0',AL1(S99RBPND),AL3(*-*)\nSKRP     DC    AL1(S99RBEND-S99RB)\n         DC    AL1(S99VRBAL)       VERB CODE\n         DC    AL1(0,0)            FLAGS\n         DC    2XL2'0'             ERROR-INFORMATION REASON CODES\n         DC    A(*-*)\nSKRL     EQU   (S99RBEND-S99RB)-(*-SKRP)\n         DC    (SKRL)X'0'\nSKRLEN   EQU   *-SKR\nSKL      DC    A(*-*)\n         DC    A(*-*)\n         DC    A(*-*)\n         DC    A(*-*)\n         DC    A(DISPSHR)\n         DC    A(DISPKEEP)\n         DC    A(FREECLOS)\n         DC    AL1(S99TUPLN),AL3(*-*)\nSKLLEN   EQU   *-SKL\nSKD      DC    A(*-*)\n         DC    AL1(S99TUPLN),AL3(UNCOND)\nSKDLEN   EQU   *-SKD\nSKLTU    DC    AL2(DALDSNAM),AL2(1),AL2(44)\n         DC    CL44' '\n         DC    AL2(DALMEMBR),AL2(1),AL2(8)\n         DC    CL8' '\n         DC    AL2(DALVLSER),AL2(1),AL2(6)\n         DC    CL6' '\n         DC    AL2(DALPASSW),AL2(1),AL2(8)\n         DC    CL8' '\n         DC    AL2(DALRTDDN),AL2(1),AL2(8)\n         DC    CL8' '\nSKLTUL   EQU   *-SKLTU\n         SPACE 1\nDISPSHR  DC    AL2(DALSTATS),AL2(1),AL2(1),XL1'08'\nDISPKEEP DC    AL2(DALNDISP),AL2(1),AL2(1),XL1'08'\nFREECLOS DC    AL2(DALCLOSE),AL2(0)\nUNCOND   DC    AL2(DUNUNALC),AL2(0)\n         SPACE 1\nMSG1     MSG   'GETMAIN FAILED'\nMSG2     MSG   'ALLOC \"IN\" FAILED'\nMSG3     MSG   'ALLOC \"OUT\" FAILED'\nMSG4     MSG   'OPEN \"IN\" FAILED'\nMSG5     MSG   'OPEN \"OUT\" FAILED'\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R11,R12\n         EJECT\nWKAREA   DSECT ,                   LOCAL SA-WA\n         DS    18F\nSYSUT1   DS    (UT1L)X\nSYSUT2   DS    (UT2L)X\nOPENEM   DS    (OPNL)X\nRB99P    DS    A\nRB99     DS    AL1\nRB99VR   DS    AL1                 VERB CODE\n         DS    AL2                 FLAGS\nRB99RC   DS    XL4                 ERROR-INFORMATION REASON CODES\nRB99TUP  DS    A\nRB99L    EQU   (S99RBEND-S99RB)-(*-RB99)\n         DS    (RB99L)X\nRB99TU   DS    8A\n         ORG   RB99TU\nINNADDR  DS    A\nINMADDR  DS    A\nINVADDR  DS    A\nINPADDR  DS    A\n         DS    A\n         DS    A\n         DS    A\nINRADDR  DS    A\n         ORG   RB99TU\nOUNADDR  DS    A\nOUMADDR  DS    A\nOUVADDR  DS    A\nOUPADDR  DS    A\n         DS    A\n         DS    A\n         DS    A\nOURADDR  DS    A\n         ORG   ,\nINDSNAME DS    3AL2\nINDS     DS    CL44\nINMEM    DS    3AL2\nINM      DS    CL8\nINVOLSER DS    3AL2\nINV      DS    CL6\nINPASS   DS    3AL2\nINP      DS    CL8\nINDDNAME DS    3AL2\nINDD     DS    CL8\nOUDSNAME DS    3AL2\nOUDS     DS    CL44\nOUMEM    DS    3AL2\nOUM      DS    CL8\nOUVOLSER DS    3AL2\nOUV      DS    CL6\nOUPASS   DS    3AL2\nOUP      DS    CL8\nOUDDNAME DS    3AL2\nOUDD     DS    CL8\nERRMSG   DS    CL22\nWKFLGS   DS    XL1                 TESTS\nSYNIFL   EQU   X'80'                    ON = ERROR ON SYSUT1\nSYNOFL   EQU   X'40'                    ON = ERROR ON SYSUT2\nWKLEN    EQU   (((*-WKAREA)+7)/8)*8\n         SPACE 1\n        IEFZB4D0\n        IEFZB4D2\n        DCBD   DSORG=(PS,PO),DEVD=DA\n        IEZIOB\n         PRINT GEN\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPSMESS": {"ttr": 15114, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x07?\\x00\\x96\\x07?\\x10\\t\\x04\\x18\\x04\\x18\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-03-13T00:00:00", "modifydate": "1996-03-13T10:09:00", "lines": 1048, "newlines": 1048, "modlines": 0, "user": "SYSPAJA"}, "text": "MESS     TITLE '--- E T P S -- ETPSMESS - MESSAGES SENDER ---'\n         PRINT OFF\n         COPY  ETPS$O1             \"ETPS\" SYSPARM SELECTION\n         MACRO\n&NAME    @MSG  &NO,&FLGS,&R=N\n         LCLC  &F,&W\n         AIF   ('&NO' NE '').A\n         MNOTE 8,' MESSAGE NUMBER MISSING ************************** '\n         AGO   .END\n.A       AIF   ('&FLGS' EQ '').B\n&F       SETC  '&FLGS'\n         AGO   .C\n.B       ANOP\n&F       SETC  '0'\n.C       AIF   ('&R'(1,1) EQ 'Y').D\n&W       SETC  '0'\n         AGO   .E\n.D       ANOP\n&W       SETC  'RMS&NO'\n.E       ANOP\n&NAME    DC    AL2(&NO),AL1(&F,L'MSG&NO-1),AL4(MSG&NO,&W)\n.END     MEND\n         MACRO\n&NAME    @PHN  &NO,&NM\n&NAME    DC    CL2'&NO',CL4'&NM'\n.END     MEND\n         COPY  ETPSMACS            \"ETPS\" MACROS\n         COPY  ETPSDEFS            \"ETPS\" DEFINITIONS\n         PRINT ON\nETPSMESS START 0\n         SPACE 1\nETPSMESS AMODE 24\nETPSMESS RMODE 24\n        MIDENT\n         EJECT\n*---------------------------- AT ENTRY : R0 MUST POINT TO \"MYSAVE\"\n         SPACE 1\n         PRINT GEN\n         USING *,R12\n         B     32(,R15)\n         DC    CL28'  ETPSMESS &SYSDATE &SYSTIME'\n         PRINT &PRF\n         STM   R14,R12,12(R13)     SAVE INPUT REGISTERS\n         LR    R12,R15             SET BASE REGISTER\n         LR    R9,R0               SET \"MYSAVE\" ADDRESSABILITY\n         USING MYSAVE,R9\n         L     R11,=A(SPMSGWA-MYSAVE) GET LOCAL SA-WA\n         AR    R11,R0\n         LR    R0,R11\n         L     R1,=A(MWKLG)\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R0,R14              CLEAR ALL TO BINARY ZEROS\n         ST    R13,4(R11)          STORE BACKWARD POINTER\n         ST    R11,8(R13)          STORE FORWARD POINTER\n         LR    R13,R11\n         USING MWKA,R11\n         LA    R10,SPLITWRK        SET DSECT BASE OF SPLIT-SCREEN\n         USING SPLTAREA,R10\n         MVC   MWKID(L'MWKID+L'MWKPH),=CL18'ETPS.... - .... : '\n         XR    R2,R2\n         ICM   R2,B'0011',MESSNO   GET MESSAGE NUMBER\n         BZ    *+L'*+8             INVALID NUMBER\n         CH    R2,=H'9999'\n         BNH   *+L'*+8             VALID NUMBER\n         L     R3,=A(MSGTINV)\n         B     MSTCKT\n         L     R3,=A(MSGTBS)\nSCTBMS   CLC   MSGTBSN(L'MSGTBSN,R3),=H'0' SEARCH MESSAGE IN TABLE\n         BE    MSTFND              UNKOWN NUMBER\n         CLM   R2,B'0011',MSGTBSN(R3) IS IT THIS NUMBER?\n         BE    MSTFND              YES\n         LA    R3,L'MSGTBS(R3)     NO, POINT TO NEXT\n         B     SCTBMS\nMSTFND   LR    R0,R2\n         BAL   R14,DSCRC\n         MVC   MWKIN(L'MWKIN),MWKWC-L'MWKIN+7\nMSTCKT   TM    MSGTBSF(R3),ALTT    HOW TEST TERMINAL ACCESS TYPE?\n         BZ    STDWAY              BY STANDARD WAY\n         MVC   MWKXT(XTRCTL),XTRCT ELSE BY EXTRACT WAY\n         XC    MWKTSO,MWKTSO\n        EXTRACT MWKTSO,'S',FIELDS=(TSO),MF=(E,MWKXT)\n         L     R1,MWKTSO\n         TM    0(R1),X'80'         TSO FOREGROUND RUNNING?\n         BO    TSOENV              YES\nSYSENV   LA    R6,MSGS1            NO\n         B     SETMSG\nSTDWAY   CLI   TUBEDDNM,C'T'       TSO TERMINAL?\n         BNE   SYSENV              NO\nTSOENV   LA    R6,MSGS2            YES\nSETMSG   MVC   MWKPX(L'MSGI),MSGI(R6) SET WTO-PARM-LIST PREFIX\n         XR    R4,R4               MOVE MESSAGE\n         IC    R4,MSGTBSL(R3)\n         TM    MSGTBSF(R3),NPHN    PHASE NAME SUPPRESS?\n         BO    SPCLMS              YES\n         L     R2,=A(MSGTBN)       ELSE SET IT\nSCTBNL   CLC   0(2,R2),=AL2(0)\n         BE    STPHNM+L'STPHNM     END OF TABLE, MISSING\n         CLC   MWKIN(2),MSGTBNO(R2)\n         BE    STPHNM              THIS ONE\n         LA    R2,L'MSGTBN(R2)\n         B     SCTBNL\nSTPHNM   MVC   MWKPN(L'MWKPN),MSGTBNM(R2)\n         LA    R1,L'MWKPX+L'MWKID+L'MWKPH+1(R4)\n         STH   R1,MWKPX\n         ICM   R5,B'1111',MSGTBST(R3)\n         EX    R4,MVFTXT\n         LA    R1,MWKMSG+L'MWKPX+L'MWKID+L'MWKPH+1(R4)\n         B     STWPLS\nSPCLMS   LA    R1,L'MWKPX+L'MWKID+1(R4)\n         STH   R1,MWKPX\n         ICM   R5,B'1111',MSGTBST(R3)\n         EX    R4,MVFPHN\n         LA    R1,MWKMSG+L'MWKPX+L'MWKID+1(R4)\nSTWPLS   MVC   0(L'MSGD,R1),MSGD(R6) SET WTO-PARM-LIST SUFFIX\n         ICM   R8,B'1111',MSGTBSR(R3) IS THERE A MESSAGE ROUTINE?\n         BZ    SNDMSG              NO\n         BR    R8                  YES, GO DO IT\nSNDMSG  WTO    MF=(E,MWKMSG)       SEND MESSAGE\n         L     R13,4(,R13)         PICK UP CALLING SAVE-AREA\n         LM    R14,R12,12(R13)     RESTORE CALLING REGISTERS\n         XR    R15,R15             SET RC=0\n         BR    R14                 RETURN\nMVFTXT   MVC   MWKTX(*-*),0(R5)    <<EXECUTED>>\nMVFPHN   MVC   MWKPH(*-*),0(R5)    <<EXECUTED>>\n         SPACE 1\n*- - - - DISPLAY RC ROUTINE\n*              R14 = LINK REGISTER\n*              AT EXIT : DISPLAY RC IN \"MWKWC\" FIELD (LENGTH=7)\nDSPRC    LH    R0,MESSRC           GET RC IN R0\nDSCRC    CVD   R0,MWKDW            CONVERT R0\nDSERC    UNPK  MWKWC(7),MWKDW+L'MWKDW-4(4) DISPLAY RC\n         OI    MWKWC+6,C'0'\n         BR    R14                 RETURN\n*- - - - EDIT RC ROUTINE\n*              R14 = LINK REGISTER\n*              AT ENTRY : R0 = RC\n*              AT EXIT : EDITED RC IN \"MWKWC\" FIELD\nEDTRC    CVD   R0,MWKDW\n         MVC   MWKWC,=XL8'4020202020202120'\n         ED    MWKWC,MWKDW+L'MWKDW-4\n         BR    R14                 RETURN\n*- - - - HEXADECIMAL DISPLAY RC ROUTINE\n*              R14 = LINK REGISTER\n*              R1-R15 = WORK REGISTERS\n*              AT EXIT : HEX RC IN \"MWKWC\" FIELD\nHEXRC    L     R0,DYNRCODE         GET RC IN R0\nHXDRC    LA    R1,MWKWC+L'MWKWC-1  HEX DISPLAY IT\n         LA    R15,L'MWKWC\n         STC   R0,0(R1)\n         NI    0(R1),X'0F'\n         SRL   R0,4\n         BCTR  R1,0\n         BCT   R15,*-14\n         TR    MWKWC,HEXTB\n         BR    R14                 RETURN\n         EJECT\nXTRCT   EXTRACT ,'S',,MF=L\nXTRCTL   EQU   *-XTRCT\nMSGS1   WTO    '  ',ROUTCDE=2,DESC=3,MF=L\nMSGS2   WTO    '  ',ROUTCDE=11,DESC=7,MF=L\nMSGI     EQU   0,4\nMSGD     EQU   6,4\nHEXTB    DC    CL16'0123456789ABCDEF'\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         SPACE 1\n*- - - - R12 BASE REGISTER HIGH LIMIT  - - - - - - - - - - - - - <===*\n         EJECT\n*------- MESSAGE ROUTINES\n         SPACE 1\n         USING *,R8\nRMSINV   XR    R0,R0\n         ICM   R0,B'0011',MESSNO\n         BAL   R14,DSCRC\n         MVC   MWKPH+MSGINVN(L'MSGINVN),MWKWC-L'MSGINVN+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS0099  ICM   R15,B'1111',MESSPL  SAVED R0 (MODULE NAME POINTER)\n         BZ    *+L'*+6             NONE, SKIP\n         MVC   MWKPH+MSG0099N(L'MSG0099N),0(R15)\n         BAL   R14,DSPRC\n         MVC   MWKPH+MSG0099R(L'MSG0099R),MWKWC-L'MSG0099R+7\n         L     R0,MESSPL+4         SAVED R1 (ABEND CODE)\n         BAL   R14,HXDRC\n         MVC   MWKPH+MSG0099C(L'MSG0099C),MWKWC+L'MWKWC-L'MSG0099C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1003  BAL   R14,DSPRC\n         MVC   MWKTX+MSG1003R(L'MSG1003R),MWKWC-L'MSG1003R+7\n         ICM   R0,B'1111',ERRINFRC\n         BAL   R14,HXDRC\n         MVC   MWKTX+MSG1003C(L'MSG1003C),MWKWC+L'MWKWC-L'MSG1003C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1005  BAL   R14,DSPRC\n         MVC   MWKTX+MSG1005R(L'MSG1005R),MWKWC-L'MSG1005R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1007  BAL   R14,DSPRC\n         MVC   MWKTX+MSG1007R(L'MSG1007R),MWKWC-L'MSG1007R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1010  BAL   R14,DSPRC\n         MVC   MWKTX+MSG1010R(L'MSG1010R),MWKWC-L'MSG1010R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1011  BAL   R14,DSPRC\n         MVC   MWKTX+MSG1011R(L'MSG1011R),MWKWC-L'MSG1011R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1101  BAL   R14,DSPRC\n         MVC   MWKTX+MSG1101R(L'MSG1101R),MWKWC-L'MSG1101R+7\n         ICM   R0,B'1111',ERRINFRC\n         BAL   R14,HXDRC\n         MVC   MWKTX+MSG1101C(L'MSG1101C),MWKWC+L'MWKWC-L'MSG1101C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1102  BAL   R14,DSPRC\n         MVC   MWKTX+MSG1102R(L'MSG1102R),MWKWC-L'MSG1102R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1201  XR    R0,R0\n         IC    R0,RECB\n         BAL   R14,HXDRC\n         MVC   MWKTX+MSG1201C(L'MSG1201C),MWKWC+L'MWKWC-L'MSG1201C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1202  XR    R0,R0\n         IC    R0,RECB\n         BAL   R14,HXDRC\n         MVC   MWKTX+MSG1202C(L'MSG1202C),MWKWC+L'MWKWC-L'MSG1202C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1205  CLC   CCW1(1),WRITECC     WAS WRITE OPERATION?\n         BE    SNDMSG              YES\n         MVI   MWKTX+MSG1205O,C'R' NO, SAY READ\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1206  CLC   CCW1(1),WRITECC     WAS WRITE OPERATION?\n         BE    SNDMSG              YES\n         MVI   MWKTX+MSG1206O,C'R' NO, SAY READ\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1207  BAL   R14,DSPRC\n         MVC   MWKTX+MSG1207R(L'MSG1207R),MWKWC-L'MSG1207R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1208  BAL   R14,DSPRC\n         MVC   MWKTX+MSG1208R(L'MSG1208R),MWKWC-L'MSG1208R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1301  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG1301R(L'MSG1301R),MWKWC-L'MSG1301R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG1301C(L'MSG1301C),MWKWC+L'MWKWC-L'MSG1301C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1303  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG1303R(L'MSG1303R),MWKWC-L'MSG1303R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG1303C(L'MSG1303C),MWKWC+L'MWKWC-L'MSG1303C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1305  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG1305R(L'MSG1305R),MWKWC-L'MSG1305R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG1305C(L'MSG1305C),MWKWC+L'MWKWC-L'MSG1305C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1306  LA    R0,NLDCB+1\n         S     R0,MESSPL           COMPUTE FILE PROCESS NUMBER\n         STC   R0,MWKTX+MSG1306N\n         OI    MWKTX+MSG1306N,C'0'\n         L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG1306R(L'MSG1306R),MWKWC-L'MSG1306R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG1306C(L'MSG1306C),MWKWC+L'MWKWC-L'MSG1306C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1307  BAL   R14,DSPRC\n         MVC   MWKTX+MSG1307R(L'MSG1307R),MWKWC-L'MSG1307R+7\n         L     R0,MESSPL           SAVED R0 (ERR-INF/CODE)\n         BAL   R14,HXDRC\n         MVC   MWKTX+MSG1307C(L'MSG1307C),MWKWC+L'MWKWC-L'MSG1307C\n         ICM   R15,B'1111',MESSPL+4\n         BZ    SNDMSG\n         XR    R14,R14\n         IC    R14,0(R15)\n         LTR   R14,R14\n         BNP   SNDMSG\n         EX    R14,*+L'*+4\n         B     SNDMSG\n         MVC   MWKTX+MSG1307D(*-*),1(R15)\n         DROP  R8\n         USING *,R8\nRMS1308  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG1308R(L'MSG1308R),MWKWC-L'MSG1308R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG1308C(L'MSG1308C),MWKWC+L'MWKWC-L'MSG1308C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1401  BAL   R14,DSPRC\n         MVC   MWKTX+MSG1401R(L'MSG1401R),MWKWC-L'MSG1401R+7\n         L     R0,MESSPL           SAVED R0 (ERROR CODE OR INFO)\n         BAL   R14,HXDRC\n         MVC   MWKTX+MSG1401C(L'MSG1401C),MWKWC+L'MWKWC-L'MSG1401C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1501  BAL   R14,DSPRC\n         MVC   MWKTX+MSG1501R(L'MSG1501R),MWKWC-L'MSG1501R+7\n         L     R0,MESSPL           SAVED R0 (ERROR CODE OR INFO)\n         BAL   R14,HXDRC\n         MVC   MWKTX+MSG1501C(L'MSG1501C),MWKWC+L'MWKWC-L'MSG1501C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS1601  BAL   R14,DSPRC\n         MVC   MWKTX+MSG1601R(L'MSG1601R),MWKWC-L'MSG1601R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2003  BAL   R14,DSPRC\n         MVC   MWKTX+MSG2003R(L'MSG2003R),MWKWC-L'MSG2003R+7\n         L     R0,MESSPL           REASON CODE\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG2003C(L'MSG2003C),MWKWC+L'MWKWC-L'MSG2003C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2004  L     R0,MESSPL           MAX. CARDS\n         BAL   R14,EDTRC\n         MVC   MWKTX+MSG2004L(L'MSG2004L),MWKWC+L'MWKWC-L'MSG2004L\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2005  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG2005R(L'MSG2005R),MWKWC-L'MSG2005R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG2005C(L'MSG2005C),MWKWC+L'MWKWC-L'MSG2005C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2006  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG2006R(L'MSG2006R),MWKWC-L'MSG2006R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG2006C(L'MSG2006C),MWKWC+L'MWKWC-L'MSG2006C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2007  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG2007R(L'MSG2007R),MWKWC-L'MSG2007R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG2007C(L'MSG2007C),MWKWC+L'MWKWC-L'MSG2007C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2008  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG2008R(L'MSG2008R),MWKWC-L'MSG2008R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG2008C(L'MSG2008C),MWKWC+L'MWKWC-L'MSG2008C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2009  BAL   R14,DSPRC\n         MVC   MWKTX+MSG2009R(L'MSG2009R),MWKWC-L'MSG2009R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2010  BAL   R14,DSPRC\n         MVC   MWKTX+MSG2010R(L'MSG2010R),MWKWC-L'MSG2010R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2011  BAL   R14,DSPRC\n         MVC   MWKTX+MSG2011R(L'MSG2011R),MWKWC-L'MSG2011R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2012  BAL   R14,DSPRC\n         MVC   MWKTX+MSG2012R(L'MSG2012R),MWKWC-L'MSG2012R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2013  BAL   R14,DSPRC\n         MVC   MWKTX+MSG2013R(L'MSG2013R),MWKWC-L'MSG2013R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2015  BAL   R14,DSPRC\n         MVC   MWKTX+MSG2015R(L'MSG2015R),MWKWC-L'MSG2015R+7\n         L     R0,MESSPL           REASON CODE\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG2015C(L'MSG2015C),MWKWC+L'MWKWC-L'MSG2015C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2016  BAL   R14,DSPRC\n         MVC   MWKTX+MSG2016R(L'MSG2016R),MWKWC-L'MSG2016R+7\n         L     R0,MESSPL           REASON CODE\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG2016C(L'MSG2016C),MWKWC+L'MWKWC-L'MSG2016C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2017  BAL   R14,DSPRC\n         MVC   MWKTX+MSG2017R(L'MSG2017R),MWKWC-L'MSG2017R+7\n         L     R0,MESSPL           REASON CODE\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG2017C(L'MSG2017C),MWKWC+L'MWKWC-L'MSG2017C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2018  BAL   R14,DSPRC\n         MVC   MWKTX+MSG2018R(L'MSG2018R),MWKWC-L'MSG2018R+7\n         L     R0,MESSPL           REASON CODE\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG2018C(L'MSG2018C),MWKWC+L'MWKWC-L'MSG2018C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2019  BAL   R14,DSPRC\n         MVC   MWKTX+MSG2019R(L'MSG2019R),MWKWC-L'MSG2019R+7\n         L     R0,MESSPL           REASON CODE\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG2019C(L'MSG2019C),MWKWC+L'MWKWC-L'MSG2019C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2020  BAL   R14,DSPRC\n         MVC   MWKTX+MSG2020R(L'MSG2020R),MWKWC-L'MSG2020R+7\n         L     R0,MESSPL           REASON CODE\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG2020C(L'MSG2020C),MWKWC+L'MWKWC-L'MSG2020C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2021  BAL   R14,DSPRC\n         MVC   MWKTX+MSG2021R(L'MSG2021R),MWKWC-L'MSG2021R+7\n         L     R0,MESSPL           REASON CODE\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG2021C(L'MSG2021C),MWKWC+L'MWKWC-L'MSG2021C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS2022  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG2022R(L'MSG2022R),MWKWC-L'MSG2022R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG2022C(L'MSG2022C),MWKWC+L'MWKWC-L'MSG2022C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS3001  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG3001R(L'MSG3001R),MWKWC-L'MSG3001R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG3001C(L'MSG3001C),MWKWC+L'MWKWC-L'MSG3001C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS3002  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG3002R(L'MSG3002R),MWKWC-L'MSG3002R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG3002C(L'MSG3002C),MWKWC+L'MWKWC-L'MSG3002C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS3003  XR    R0,R0\n         IC    R0,RECB\n         BAL   R14,HXDRC\n         MVC   MWKTX+MSG3003C(L'MSG3003C),MWKWC+L'MWKWC-L'MSG3003C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS3004  XR    R0,R0\n         IC    R0,RECB\n         BAL   R14,HXDRC\n         MVC   MWKTX+MSG3004C(L'MSG3004C),MWKWC+L'MWKWC-L'MSG3004C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS3005  BAL   R14,DSPRC\n         MVC   MWKTX+MSG3005R(L'MSG3005R),MWKWC-L'MSG3005R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS3006  BAL   R14,DSPRC\n         MVC   MWKTX+MSG3006R(L'MSG3006R),MWKWC-L'MSG3006R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS3008  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG3008R(L'MSG3008R),MWKWC-L'MSG3008R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG3008C(L'MSG3008C),MWKWC+L'MWKWC-L'MSG3008C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS3009  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG3009R(L'MSG3009R),MWKWC-L'MSG3009R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG3009C(L'MSG3009C),MWKWC+L'MWKWC-L'MSG3009C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS3010  BAL   R14,DSPRC\n         MVC   MWKTX+MSG3010R(L'MSG3010R),MWKWC-L'MSG3010R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS3011  BAL   R14,DSPRC\n         MVC   MWKTX+MSG3011R(L'MSG3011R),MWKWC-L'MSG3011R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS4001  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG4001R(L'MSG4001R),MWKWC-L'MSG4001R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG4001C(L'MSG4001C),MWKWC+L'MWKWC-L'MSG4001C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS4002  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG4002R(L'MSG4002R),MWKWC-L'MSG4002R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG4002C(L'MSG4002C),MWKWC+L'MWKWC-L'MSG4002C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS4003  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG4003R(L'MSG4003R),MWKWC-L'MSG4003R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG4003C(L'MSG4003C),MWKWC+L'MWKWC-L'MSG4003C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS4004  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG4004R(L'MSG4004R),MWKWC-L'MSG4004R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG4004C(L'MSG4004C),MWKWC+L'MWKWC-L'MSG4004C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS4005  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG4005R(L'MSG4005R),MWKWC-L'MSG4005R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG4005C(L'MSG4005C),MWKWC+L'MWKWC-L'MSG4005C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS4006  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG4006R(L'MSG4006R),MWKWC-L'MSG4006R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG4006C(L'MSG4006C),MWKWC+L'MWKWC-L'MSG4006C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS4007  BAL   R14,DSPRC\n         MVC   MWKTX+MSG4007R(L'MSG4007R),MWKWC-L'MSG4007R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS5001  BAL   R14,DSPRC\n         MVC   MWKTX+MSG5001R(L'MSG5001R),MWKWC-L'MSG5001R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS5002  L     R0,MESSPL           MAX. MEMBERS TABLE\n         BAL   R14,EDTRC\n         MVC   MWKTX+MSG5002L(L'MSG5002L),MWKWC+L'MWKWC-L'MSG5002L\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS5003  BAL   R14,DSPRC\n         MVC   MWKTX+MSG5003R(L'MSG5003R),MWKWC-L'MSG5003R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS5004  BAL   R14,DSPRC\n         MVC   MWKTX+MSG5004R(L'MSG5004R),MWKWC-L'MSG5004R+7\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS5005  L     R0,MESSPL           ECB CONTENTS\n         BAL   R14,HXDRC\n         MVC   MWKTX+MSG5005E(L'MSG5005E),MWKWC+L'MWKWC-L'MSG5005E\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS5008  L     R0,MESSPL           MAX. MEMBERS TABLE\n         BAL   R14,EDTRC\n         MVC   MWKTX+MSG5008L(L'MSG5008L),MWKWC+L'MWKWC-L'MSG5008L\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS5009  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG5009R(L'MSG5009R),MWKWC-L'MSG5009R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG5009C(L'MSG5009C),MWKWC+L'MWKWC-L'MSG5009C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS5010  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG5010R(L'MSG5010R),MWKWC-L'MSG5010R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG5010C(L'MSG5010C),MWKWC+L'MWKWC-L'MSG5010C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS5011  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG5011R(L'MSG5011R),MWKWC-L'MSG5011R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG5011C(L'MSG5011C),MWKWC+L'MWKWC-L'MSG5011C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS5012  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG5012R(L'MSG5012R),MWKWC-L'MSG5012R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG5012C(L'MSG5012C),MWKWC+L'MWKWC-L'MSG5012C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS5013  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG5013R(L'MSG5013R),MWKWC-L'MSG5013R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG5013C(L'MSG5013C),MWKWC+L'MWKWC-L'MSG5013C\n         B     SNDMSG\n         DROP  R8\n         USING *,R8\nRMS5014  L     R0,DYNRCODE+4\n         BAL   R14,DSCRC\n         MVC   MWKTX+MSG5014R(L'MSG5014R),MWKWC-L'MSG5014R+7\n         BAL   R14,HEXRC\n         MVC   MWKTX+MSG5014C(L'MSG5014C),MWKWC+L'MWKWC-L'MSG5014C\n         B     SNDMSG\n         DROP  R8\n         SPACE 1\n         DROP  R9,R10,R11,R12\n         EJECT\n*------- MESSAGES TABLE SELECTION\n         SPACE 1\nMSGTBS   EQU   *,12                TABLE (START/LENGTH)\nMSGTBSN  EQU   0,2                      MESSAGE NUMBER\nMSGTBSF  EQU   2,1                      MESSAGE FLAGS BYTE\nALTT     EQU   X'80'                    ALTERNATE TEST FLAG\nNPHN     EQU   X'40'                    NO PHASE NAME\nMSGTBSL  EQU   3,1                      MESSAGE LENGTH\nMSGTBST  EQU   4,4                      MESSAGE TEXT POINTER\nMSGTBSR  EQU   8,4                      MESSAGE ROUTINE OR ZERO (NONE)\n         @MSG  0099,NPHN,R=Y\n         @MSG  1001,ALTT\n         @MSG  1002,ALTT\n         @MSG  1003,,R=Y\n         @MSG  1004\n         @MSG  1005,,R=Y\n         @MSG  1006\n         @MSG  1007,,R=Y\n         @MSG  1008\n         @MSG  1009\n         @MSG  1010,,R=Y\n         @MSG  1011,,R=Y\n         @MSG  1012\n         @MSG  1013\n         @MSG  1101,,R=Y\n         @MSG  1102,,R=Y\n         @MSG  1201,,R=Y\n         @MSG  1202,,R=Y\n         @MSG  1203\n         @MSG  1204\n         @MSG  1205,,R=Y\n         @MSG  1206,,R=Y\n         @MSG  1207,,R=Y\n         @MSG  1208,,R=Y\n         @MSG  1301,,R=Y\n         @MSG  1302\n         @MSG  1303,,R=Y\n         @MSG  1304\n         @MSG  1305,,R=Y\n         @MSG  1306,,R=Y\n         @MSG  1307,,R=Y\n         @MSG  1308,,R=Y\n         @MSG  1309\n         @MSG  1401,,R=Y\n         @MSG  1501,,R=Y\n         @MSG  1601,,R=Y\n         @MSG  2001\n         @MSG  2002\n         @MSG  2003,,R=Y\n         @MSG  2004,,R=Y\n         @MSG  2005,,R=Y\n         @MSG  2006,,R=Y\n         @MSG  2007,,R=Y\n         @MSG  2008,,R=Y\n         @MSG  2009,,R=Y\n         @MSG  2010,,R=Y\n         @MSG  2011,,R=Y\n         @MSG  2012,,R=Y\n         @MSG  2013,,R=Y\n         @MSG  2014\n         @MSG  2015,,R=Y\n         @MSG  2016,,R=Y\n         @MSG  2017,,R=Y\n         @MSG  2018,,R=Y\n         @MSG  2019,,R=Y\n         @MSG  2020,,R=Y\n         @MSG  2021,,R=Y\n         @MSG  2022,,R=Y\n         @MSG  3001,,R=Y\n         @MSG  3002,,R=Y\n         @MSG  3003,,R=Y\n         @MSG  3004,,R=Y\n         @MSG  3005,,R=Y\n         @MSG  3006,,R=Y\n         @MSG  3007\n         @MSG  3008,,R=Y\n         @MSG  3009,,R=Y\n         @MSG  3010,,R=Y\n         @MSG  3011,,R=Y\n         @MSG  4001,,R=Y\n         @MSG  4002,,R=Y\n         @MSG  4003,,R=Y\n         @MSG  4004,,R=Y\n         @MSG  4005,,R=Y\n         @MSG  4006,,R=Y\n         @MSG  4007,,R=Y\n         @MSG  5001,,R=Y\n         @MSG  5002,,R=Y\n         @MSG  5003,,R=Y\n         @MSG  5004,,R=Y\n         @MSG  5005,,R=Y\n         @MSG  5006\n         @MSG  5007\n         @MSG  5008,,R=Y\n         @MSG  5009,,R=Y\n         @MSG  5010,,R=Y\n         @MSG  5011,,R=Y\n         @MSG  5012,,R=Y\n         @MSG  5013,,R=Y\n         @MSG  5014,,R=Y\n*- - - - END OF TABLE (LET'S STAY HERE AS IT IS)\n         DC    AL2(0),AL1(ALTT+NPHN,L'MSGUNK-1),AL4(MSGUNK,0)\nMSGTINV  DC    AL2(0),AL1(ALTT+NPHN,L'MSGINV-1),AL4(MSGINV,RMSINV)\n         SPACE 1\n*------- MESSAGES TABLE PHASE NAMES\n         SPACE 1\nMSGTBN   EQU   *,6                 TABLE (START/LENGTH)\nMSGTBNO  EQU   0,2                      MESSAGE NUMBER\nMSGTBNM  EQU   2,4                      MESSAGE FLAGS BYTE\n         @PHN  10,INIT\n         @PHN  11,EXIT\n         @PHN  12,COMM\n         @PHN  13,LIBM\n         @PHN  14,COMP\n         @PHN  15,IDCA\n         @PHN  16,BROW\n         @PHN  20,EDIT\n         @PHN  30,ZAP\n         @PHN  40,IZAP\n         @PHN  50,DSST\n         DC    AL2(0)              END OF TABLE\n         EJECT\n*------- MESSAGES LIST (SEE \"MWKA\" DSECT FOR LENGTH)\n         SPACE 1\nMSGINV   DC    C'INVALID MESSAGE NUMBER (.....)'\nMSGINVN  EQU   24,5\nMSGUNK   DC    C'UNKNOWN MESSAGE (UNDEFINED NUMBER)'\nMSG0099  DC    C'LOAD \"........\" FAILED / RC = .. / ABEND CODE = ......X\n               .. '\nMSG0099N EQU   6,8\nMSG0099R EQU   30,2\nMSG0099C EQU   48,8\nMSG1001  DC    C'INVALID PARM LENGTH'\nMSG1002  DC    C'INVALID PARM FIELD'\nMSG1003  DC    C'TUBE ALLOCATION (RC = .../........)'\nMSG1003R EQU   22,3\nMSG1003C EQU   26,8\nMSG1004  DC    C'COULD NOT OPEN TUBE'\nMSG1005  DC    C'GTSIZE FAILED (RC = ...)'\nMSG1005R EQU   20,3\nMSG1006  DC    C'NOT DISPLAY TERMINAL'\nMSG1007  DC    C'STFSMODE ON,INITIAL=YES (RC = ...)'\nMSG1007R EQU   30,3\nMSG1008  DC    C'NOT TSO (NO TSB)'\nMSG1009  DC    C'CANNOT CHANGE USER-ID'\nMSG1010  DC    C'CHANGE GROUP-ID (RACINIT RC = ...)'\nMSG1010R EQU   30,3\nMSG1011  DC    C'EXCP ATT. GETMAIN FAILED (RC = ...)'\nMSG1011R EQU   31,3\nMSG1012  DC    C'EXCP ATT. DUMMY ROUTINE NOT FOUND'\nMSG1013  DC    C'EXCP ATT. FREE/DUMMY ENTRY NOT FOUND'\nMSG1101  DC    C'FREE TUBE (RC = .../........)'\nMSG1101R EQU   16,3\nMSG1101C EQU   20,8\nMSG1102  DC    C'STFSMODE OFF (RC = ...)'\nMSG1102R EQU   19,3\nMSG1201  DC    C'BAD ECB CODE ON WRITE (..)'\nMSG1201C EQU   23,2\nMSG1202  DC    C'BAD ECB CODE ON READ (..)'\nMSG1202C EQU   22,2\nMSG1203  DC    C'INVALID SBA CODE'\nMSG1204  DC    C'INCOMPLETE SBA CODE'\nMSG1205  DC    C'PERMANENT I/O ERROR (W)'\nMSG1205O EQU   21,1\nMSG1206  DC    C'I/O INTERCEPTED (W)'\nMSG1206O EQU   17,1\nMSG1207  DC    C'BAD WRITE RETURN CODE FROM TPUT (RC = ...)'\nMSG1207R EQU   38,3\nMSG1208  DC    C'BAD READ RETURN CODE FROM TGET (RC = ...)'\nMSG1208R EQU   37,3\nMSG1301  DC    C'ALLOC \"LIB\" FAILED (RC = .../........)'\nMSG1301R EQU   25,3\nMSG1301C EQU   29,8\nMSG1302  DC    C'OPEN \"LIB\" FAILED'\nMSG1303  DC    C'ALLOC \"LIB(MEM)\" FAILED (RC = .../........)'\nMSG1303R EQU   30,3\nMSG1303C EQU   34,8\nMSG1304  DC    C'OPEN \"LIB(MEM)\" FAILED'\nMSG1305  DC    C'FREE \"LIB(MEM)\" FAILED (RC = .../........)'\nMSG1305R EQU   29,3\nMSG1305C EQU   33,8\nMSG1306  DC    C'FREE FILE (N = .) FAILED (RC = .../........)'\nMSG1306N EQU   15,1\nMSG1306R EQU   31,3\nMSG1306C EQU   35,8\nMSG1307  DC    C'COPY MEMBER FAILED (RC = .../......../................X\n               ....)'\nMSG1307R EQU   25,3\nMSG1307C EQU   29,8\nMSG1307D EQU   38,20\nMSG1308  DC    C'FREE \"LIB\" FAILED (RC = .../........)'\nMSG1308R EQU   24,3\nMSG1308C EQU   28,8\nMSG1309  DC    C'END-OF-FILE READ ON \"LIB\" DIRECTORY'\nMSG1401  DC    C'COMPRESS FAILED (RC = .../R0=........)'\nMSG1401R EQU   22,3\nMSG1401C EQU   29,8\nMSG1501  DC    C'IDCAMS FAILED (RC = .../R0=........)'\nMSG1501R EQU   20,3\nMSG1501C EQU   27,8\nMSG1601  DC    C'BROWSE GETMAIN FAILED (RC = ...)'\nMSG1601R EQU   28,3\nMSG2001  DC    C'OPEN INPUT FAILED'\nMSG2002  DC    C'OPEN OUTPUT FAILED'\nMSG2003  DC    C'SUBMIT \"OPEN\" FAILED (RC = .../CODE = ..)'\nMSG2003R EQU   27,3\nMSG2003C EQU   38,2\nMSG2004  DC    C'CANNOT SUPPORT OVER ....... CARDS'\nMSG2004L EQU   20,7\nMSG2005  DC    C'ALLOC \"DIR\" FAILED (RC = .../........)'\nMSG2005R EQU   25,3\nMSG2005C EQU   29,8\nMSG2006  DC    C'FREE \"DIR\" FAILED (RC = .../........)'\nMSG2006R EQU   24,3\nMSG2006C EQU   28,8\nMSG2007  DC    C'ALLOC \"CPY\" FAILED (RC = .../........)'\nMSG2007R EQU   25,3\nMSG2007C EQU   29,8\nMSG2008  DC    C'FREE \"CPY\" FAILED (RC = .../........)'\nMSG2008R EQU   24,3\nMSG2008C EQU   28,8\nMSG2009  DC    C'SPF STATISTICS FAILED (RC = ...)'\nMSG2009R EQU   28,3\nMSG2010  DC    C'\"CPY\" GETMAIN FAILED (RC = ...)'\nMSG2010R EQU   27,3\nMSG2011  DC    C'INITIAL DATA GETMAIN FAILED (RC = ...)'\nMSG2011R EQU   34,3\nMSG2012  DC    C'NEXT DATA GETMAIN FAILED (RC = ...)'\nMSG2012R EQU   31,3\nMSG2013  DC    C'COPY DATA GETMAIN FAILED (RC = ...)'\nMSG2013R EQU   31,3\nMSG2014  DC    C'END-OF-FILE READ ON \"CPY\" DIRECTORY'\nMSG2015  DC    C'SUBMIT \"GENCB-ACB\" FAILED (RC = .../........)'\nMSG2015R EQU   32,3\nMSG2015C EQU   36,8\nMSG2016  DC    C'SUBMIT \"GENCB-RPL\" FAILED (RC = .../........)'\nMSG2016R EQU   32,3\nMSG2016C EQU   36,8\nMSG2017  DC    C'SUBMIT \"MODCB\" FAILED (RC = .../........)'\nMSG2017R EQU   28,3\nMSG2017C EQU   32,8\nMSG2018  DC    C'SUBMIT \"PUT\" FAILED (RC = .../........)'\nMSG2018R EQU   26,3\nMSG2018C EQU   30,8\nMSG2019  DC    C'SUBMIT \"ENDREQ\" FAILED (RC = .../........)'\nMSG2019R EQU   29,3\nMSG2019C EQU   33,8\nMSG2020  DC    C'SUBMIT \"CLOSE\" FAILED (RC = .../CODE = ..)'\nMSG2020R EQU   28,3\nMSG2020C EQU   39,2\nMSG2021  DC    C'SUBMIT \"ALLOC\" FAILED (RC = .../........)'\nMSG2021R EQU   28,3\nMSG2021C EQU   32,8\nMSG2022  DC    C'SUBMIT \"FREE\" FAILED (RC = .../........)'\nMSG2022R EQU   27,3\nMSG2022C EQU   31,8\nMSG3001  DC    C'ALLOC \"ZAP\" FAILED (RC = .../........)'\nMSG3001R EQU   25,3\nMSG3001C EQU   29,8\nMSG3002  DC    C'FREE \"ZAP\" FAILED (RC = .../........)'\nMSG3002R EQU   24,3\nMSG3002C EQU   28,8\nMSG3003  DC    C'BAD ECB CODE ON WRITE (..)'\nMSG3003C EQU   23,2\nMSG3004  DC    C'BAD ECB CODE ON READ (..)'\nMSG3004C EQU   22,2\nMSG3005  DC    C'BAD WRITE RETURN CODE FROM TPUT (RC = ...)'\nMSG3005R EQU   38,3\nMSG3006  DC    C'BAD READ RETURN CODE FROM TGET (RC = ...)'\nMSG3006R EQU   37,3\nMSG3007  DC    C'RESPONSE IS TOO LONG ...'\nMSG3008  DC    C'ALLOC \"LOG\" FAILED (RC = .../........)'\nMSG3008R EQU   25,3\nMSG3008C EQU   29,8\nMSG3009  DC    C'FREE \"LOG\" FAILED (RC = .../........)'\nMSG3009R EQU   24,3\nMSG3009C EQU   28,8\nMSG3010  DC    C'X-ZAP GETMAIN FAILED (RC = ...)'\nMSG3010R EQU   27,3\nMSG3011  DC    C'GETMAIN BUFFER FAILED (RC = ...)'\nMSG3011R EQU   28,3\nMSG4001  DC    C'ALLOC \"LIB\" FAILED (RC = .../........)'\nMSG4001R EQU   25,3\nMSG4001C EQU   29,8\nMSG4002  DC    C'FREE \"LIB\" FAILED (RC = .../........)'\nMSG4002R EQU   24,3\nMSG4002C EQU   28,8\nMSG4003  DC    C'ALLOC \"PRT\" FAILED (RC = .../........)'\nMSG4003R EQU   25,3\nMSG4003C EQU   29,8\nMSG4004  DC    C'FREE \"PRT\" FAILED (RC = .../........)'\nMSG4004R EQU   24,3\nMSG4004C EQU   28,8\nMSG4005  DC    C'IN-ZAP ALLOC \"PRT\" FAILED (RC = .../........)'\nMSG4005R EQU   32,3\nMSG4005C EQU   36,8\nMSG4006  DC    C'IN-ZAP FREE \"PRT\" FAILED (RC = .../........)'\nMSG4006R EQU   31,3\nMSG4006C EQU   35,8\nMSG4007  DC    C'IN-ZAP GETMAIN FAILED (RC = ...)'\nMSG4007R EQU   28,3\nMSG5001  DC    C'STATDS GETMAIN FAILED (RC = ...)'\nMSG5001R EQU   28,3\nMSG5002  DC    C'STATDS CANNOT SUPPORT OVER ....... REAL-MEMBERS'\nMSG5002L EQU   27,7\nMSG5003  DC    C'STATDS RDJFCB FAILED (RC = ...)'\nMSG5003R EQU   27,3\nMSG5004  DC    C'STATDS OBTAIN FAILED (RC = ...)'\nMSG5004R EQU   27,3\nMSG5005  DC    C'STATDS READ FAILED (ECB=........)'\nMSG5005E EQU   24,8\nMSG5006  DC    C'STATDS OUTPUT FILE OPEN FAILED'\nMSG5007  DC    C'STATDS TRACE FILE OPEN FAILED'\nMSG5008  DC    C'STATDS CANNOT SUPPORT OVER ....... GAS-MEMBERS'\nMSG5008L EQU   27,7\nMSG5009  DC    C'ALLOC \"LIB\" FAILED (RC = .../........)'\nMSG5009R EQU   25,3\nMSG5009C EQU   29,8\nMSG5010  DC    C'ALLOC \"PRT\" FAILED (RC = .../........)'\nMSG5010R EQU   25,3\nMSG5010C EQU   29,8\nMSG5011  DC    C'ALLOC \"TRC\" FAILED (RC = .../........)'\nMSG5011R EQU   25,3\nMSG5011C EQU   29,8\nMSG5012  DC    C'FREE \"LIB\" FAILED (RC = .../........)'\nMSG5012R EQU   24,3\nMSG5012C EQU   28,8\nMSG5013  DC    C'FREE \"PRT\" FAILED (RC = .../........)'\nMSG5013R EQU   24,3\nMSG5013C EQU   28,8\nMSG5014  DC    C'FREE \"TRC\" FAILED (RC = .../........)'\nMSG5014R EQU   24,3\nMSG5014C EQU   28,8\n         EJECT\n*------- ETPSMESS - WORK-AREA DESCRIPTION ----------------------------*\nMWKA     DSECT ,                   LOCAL SA-WA\n         DS    18F                 SAVE-AREA\nMWKDW    DS    D                   WORK DOUBLE-WORD\nMWKWC    DS    CL8                 WORK FIELD\nMWKXT   EXTRACT ,'S',,MF=L         AREA FOR LIST FORM OF EXTRACT\nMWKTSO   DS    A                   TSO FLAG ADDRESS\nMWKMSG   DS    0XL88               MESSAGE WORK-AREA\nMWKPX    DS    XL4                 WTO-PARM-LIST PREFIX\nMWKID    DS    XL11                MESSAGE ID ('ETPS.... - ')\nMWKIN    EQU   MWKID+4,4           MESSAGE ID NUMBER\nMWKPH    DS    XL7                 MESSAGE PHASE ('.... : ')\nMWKPN    EQU   MWKPH+0,4           MESSAGE PHASE NAME\nMWKTX    DS    XL66                MESSAGE TEXT / WTO-PARM-LIST SUFFIX\nMWKLG    EQU   (((*-MWKA)+7)/8)*8\nMWKLGT   EQU   (STBIGWA-SPMSGWA)-MWKLG\n         DS    0XL(MWKLGT)         \"MWKLG\" VALIDITY CHECK\n         PRINT &PRS\n        SPLTAREA\n         SPACE 1\n        MYSAVE\n         PRINT &PRF\n        IEFZB4D0\n        IEFZB4D2\n        DCBD   DSORG=(PS,PO),DEVD=DA\n        IEZIOB\n         PRINT GEN\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPSTSO": {"ttr": 15621, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x06\\x7f\\x00\\x96\\x06\\x7f\\x17\\x16\\x01u\\x01u\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-03-07T00:00:00", "modifydate": "1996-03-07T17:16:00", "lines": 373, "newlines": 373, "modlines": 0, "user": "SYSPAJA"}, "text": "TSO      TITLE '--- E T P S -- ETPSTSO - TSO INVOKER ---'\n         PRINT OFF\n         COPY  ETPS$O1             \"ETPS\" SYSPARM SELECTION\n         COPY  ETPSMACS            \"ETPS\" MACROS\n         COPY  ETPSDEFS            \"ETPS\" DEFINITIONS\n         PRINT ON\nETPSTSO  START 0\n         SPACE 1\nETPSTSO  AMODE 24\nETPSTSO  RMODE 24\n        MIDENT\n         EJECT\n*---------------------------------------------------------------------*\n*        TSO \"ETPSTSO\" COMMAND                                        *\n*---------------------------------------------------------------------*\n*              COMMAND SYNTAX : ETPSTSO T(EST)\n*                  WHERE EVENTUAL OPERAND \"T\" OR \"TEST\" ALLOWS TO\n*                  VERIFY IN TSO THE LOGON PANEL DISPLAY (USED BY\n*                  SUB-SYSTEM OR STARTED TASK).\n         PRINT GEN\n         USING *,R12\n         B     32(,R15)\n         DC    CL28'  ETPSTSO  &SYSDATE &SYSTIME'\n         PRINT &PRF\n         STM   R14,R12,12(R13)     SAVE INPUT REGISTERS\n         LR    R12,R15             SET BASE REGISTER\n         LR    R2,R1               GET ENTRY REGISTER\n         L     R11,=A(WKLEN)\n        GETMAIN RC,LV=(R11)        GET LOCAL SA-WA\n         LTR   R8,R15              HOW COMPLETE?\n         BNZ   LEAVE               ERROR, GO BACK\n         LR    R0,R1\n         LR    R1,R11\n         LR    R11,R0\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R0,R14              CLEAR ALL TO BINARY ZEROS\n         ST    R13,4(R11)          STORE BACKWARD POINTER\n         ST    R11,8(R13)          STORE FORWARD POINTER\n         LR    R13,R11\n         USING WKAREA,R11\n         MVC   WXTRCT(XTRCTL),XTRCT\n         XC    WATIOT(L'WATIOT+L'WATSO+L'WAPSCB),WATIOT\n        EXTRACT WATIOT,'S',FIELDS=(TIOT,TSO,PSB),MF=(E,WXTRCT)\n         L     R1,WATSO\n         TM    0(R1),X'80'         TSO FOREGROUND RUNNING?\n         BO    XTSCMD              YES\nXTERR   WTO    MF=(E,ERRMSG)       NO, REJECT\n         B     QUIT\n         USING CPPL,R2             SET CPPL ADDRESSABILITY\nXTSCMD   L     R1,WAPSCB           PSCB ADDRESS\n         LTR   R1,R1\n         BZ    XTERR               WE ARE NOT IN TSO\n         USING PSCB,R1\n         CLC   PSCBUPT,CPPLUPT     CPPL+4 = UPT ADDRESS?\n         BNE   *+L'*+10            NO\n         DROP  R1\n         CLC   WAPSCB(L'WAPSCB),CPPLPSCB  CPPL+8 = PSCB ADDRESS?\n         BE    XTCMDOK             YES, TSO COMMAND\n         LR    R1,R2\n         USING IKJEBECA,R1\n         L     R2,CAPTTMP          CPPL ADDRESS\n         DROP  R1\n         CLC   WAPSCB(L'WAPSCB),CPPLPSCB  CPPL+8 = PSCB ADDRESS?\n         BNE   XTERR               NO, NOT TSO SUB-COMMAND\nXTCMDOK  L     R6,CPPLCBUF         COMMAND BUFFER ADDRESS\n         DROP  R2\n         XR    R7,R7\n         IC    R7,=C' '\n         LH    R1,0(R6)            GET LENGTH\n         SH    R1,=H'4'            -4 (PREFIX)\n         CH    R1,2(R6)            ANY OPERAND?\n         BNH   XTSCSNP             NO, NONE\n         SH    R1,2(R6)            LENGTH OF OPERAND(S)\n         LA    R1,31(R1)           BUMP SO SCAN COMPARE DON'T ABEND\n         SRL   R1,3\n         SLL   R1,3\n         ST    R1,WAOPLG           SAVE LENGTH OF OPERANDS AREA\n         LR    R3,R1\n        GETMAIN RC,LV=(1)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    XGTMNOK             OK\n        TPUT   GMERR,L'GMERR       ERROR\n         B     XTSCSNP             IGNORE ANY OPERAND(S)\nXGTMNOK  ST    R1,WAOPAD           SAVE ADDRESS OF OPERANDS AREA\n         LR    R2,R1\n         LR    R4,R1\n         XR    R5,R5\n         ICM   R5,B'1000',=C' '\n         MVCL  R2,R4               SET AREA TO BLANKS\n         LH    R1,0(R6)            GET LENGTH\n         SH    R1,=H'4'            -4 (PREFIX)\n         LH    R2,2(R6)            OFFSET TO OPERANDS\n         LA    R3,4(R6,R2)         START OF OPERANDS\n         SR    R1,R2               LENGTH OF OPERANDS\n         BCTR  R1,0\n         XR    R0,R0\n         SLDL  R0,24\n         SRL   R1,24\n         L     R2,WAOPAD\n         LTR   R0,R0               COPY AND UPPER CASE OPERANDS\n         BZ    *+L'*+18\n         OC    0(256,R2),0(R3)\n         LA    R2,256(R2)\n         LA    R3,256(R3)\n         BCT   R0,*-14\n         B     *+L'*+6\n         OC    0(*-*,R2),0(R3)     <<EXECUTED>>\n         EX    R1,*-6\n         L     R3,WAOPAD\n         L     R5,WAOPLG\n         ALR   R5,R3\n         BCTR  R5,0\n         LA    R4,1\n         CLI   0(R3),C' '          ANALYZE COMMAND OPERAND(S)\n         BNE   XOPFND\nXOPLOOP  BXLE  R3,R4,*-8\n         B     XTCMDFR\nXOPNEXT  BXLE  R3,R4,*+L'*+4\n         B     XTCMDFR\n         CLI   0(R3),C' '\n         BNE   XOPNEXT\n         B     XOPLOOP\nXOPFND   CLC   0(2,R3),=CL2'T'\n         BE    *+L'*+10\n         CLC   0(5,R3),=CL5'TEST'\n         BNE   XOPNEXT\n         IC    R7,0(R3)\nXTCMDFR  LM    R0,R1,WAOPLG\n        FREEMAIN R,LV=(0),A=(1)\nXTSCSNP  MVI   SNAPSW,0\n         XC    SNAPCC,SNAPCC\n         LA    R0,SNAPDCB\n         L     R1,=A(ZSNAPL)\n         LA    R14,ZSNAP\n         LR    R15,R1\n         MVCL  R0,R14\n         XR    R0,R0\n         L     R1,WATIOT           START TIOT POINTER\n         USING TIODSECT,R1\n         LA    R2,SNAPDCB\n         USING IHADCB,R2\n         XR    R3,R3\nXTSLOOP  CLC   TIOELNGH(4),=XL4'0' END OF TIOT?\n         BE    XTSFRUN             YES, NOT FOUND\n         CLC   TIOEDDNM(L'TIOEDDNM),DCBDDNAM DDNAME MATCH?\n         BE    XTSFND              YES, FOUND\n         IC    R0,TIOELNGH         LENGTH OF CURRENT DD-ENTRY\n         ALR   R1,R0               NEXT DD-ENTRY IN TIOT\n         B     XTSLOOP\n         DROP  R1,R2\nXTSFND   MVC   DOSNAP(STSNPL),STSNP\n         ST    R11,SNPRGS\n         L     R0,=A(GOSNAP)\n         ST    R0,SNPRGS+4\n         LA    R3,DOSNAP\nXTSFRUN LOAD   EP=ETPS,ERRET=XLDERR\n         LR    R15,R0              SET EPA\n         ST    R15,ADETPS          SET EPA\n         MVC   PARMFLD(FLDDATAL),FLDDATA\n         STC   R7,PARMFLT\n         LA    R1,PARMADD          SET PARM REGISTER\n         LA    R0,PARMFLD\n         ST    R0,0(R1)\n         LR    R0,R3               PASS SNAP PROCESS ADDRESS\n        CALL   (15)                GO TO ETPS\n        DELETE EP=ETPS\n         TM    SNAPSW,OPSN         SNAP FILE IS OPENED?\n         BZ    CKSERR              NO\n        CLOSE  ((R2)),MF=(E,SNAPCL)\nCKSERR   TM    SNAPSW,SKSN         SNAP FILE IS IN ERROR?\n         BZ    QUIT                NO\n         MVC   MSGWA(L'SNAPMSG),SNAPMSG\n         XR    R0,R0\n         IC    R0,SNAPID\n         CVD   R0,WDBLW\n         MVC   WDBLW(4),=XL4'40202120'\n         ED    WDBLW(4),WDBLW+L'WDBLW-2\n         MVC   MSGWA+SNMS1(L'SNMS1),WDBLW+1\n         L     R0,SNAPCC\n         LTR   R0,R0\n         BNM   *+L'*+10\n         MVC   MSGWA+SNMS2(L'SNMS2),=CL2'-1'\n         B     SDMSG\n         CVD   R0,WDBLW\n         MVC   WDBLW(4),=XL4'40202120'\n         ED    WDBLW(4),WDBLW+L'WDBLW-2\n         MVC   MSGWA+SNMS2(L'SNMS2),WDBLW+2\nSDMSG   TPUT   MSGWA,L'SNAPMSG\nQUIT     L     R13,4(,R13)         PICK UP CALLING SAVE-AREA\n         L     R0,=A(WKLEN)\n        FREEMAIN R,LV=(0),A=(R11) FREE LOCAL SA-WA\nLEAVE    ST    R8,16(R13)          SET RETURN CODE\n         LM    R14,R12,12(R13)\n         XR    R15,R15\n         BR    R14\nXLDERR   MVC   MSGWA(L'LOADMSG),LOADMSG\n         CVD   R15,WDBLW\n         MVC   WDBLW(4),=XL4'40202120'\n         ED    WDBLW(4),WDBLW+L'WDBLW-2\n         MVC   MSGWA+LDMS1(L'LDMS1),WDBLW+1\n         L     R0,L'LDMS2\n         LA    R15,MSGWA+LDMS2+L'LDMS2-1\n         STC   R1,0(R15)\n         BCTR  R15,0\n         SRL   R1,4\n         BCT   R0,*-10\n         NC    MSGWA+LDMS2(L'LDMS2),=XL8'0F0F0F0F0F0F0F0F'\n         TR    MSGWA+LDMS2(L'LDMS2),=CL16'0123456789ABCDEF'\n        TPUT   MSGWA,L'LOADMSG\n         B     QUIT\n         EJECT\nSTSNP    LM    R11,R12,6(R15)      SET ENTRY REGISTERS\n         BR    R12                 GO TO \"GOSNAP\"\nSTSNPL   EQU   *-STSNP\n         SPACE 1\n         PRINT &PRS\nXTRCT   EXTRACT ,'S',,MF=L\nXTRCTL   EQU   *-XTRCT\nFLDDATA  DC    H'8',CL8'TSO'\nFLDDATAL EQU   *-FLDDATA\nGMERR    DC    C'--- ETPSTSO : GETMAIN FAILED / OPERAND(S) IGNORED ---'\nSNAPMSG  DC    C'--- ETPS : SNAP ERROR ON ID = ... / RC = .. ---'\nSNMS1    EQU   30,3\nSNMS2    EQU   41,2\nLOADMSG  DC    C'--- ETPSTSO : LOAD \"ETPS\" FAILED / RC = .. / ABEND CODX\n               E = ........ ---'\nLDMS1    EQU   40,2\nLDMS2    EQU   58,8\nERRMSG  WTO    '--- ETPSTSO : ONLY TSO-FOREGROUND COMMAND ALLOWED ---',X\n               ROUTCDE=11,DESC=7,MF=L\n         PRINT &PRF\nZSNAP    DS    0F                  SNAP WORK-AREAS INITIALIZATION\nXSDCB    DCB   DSORG=PS,RECFM=VBA,MACRF=(W),                           X\n               BLKSIZE=1632,LRECL=125,DDNAME=SYSSNAP\nXSDCBL   EQU   *-XSDCB\nXSOP     OPEN  (*-*),MF=L\nXSOPL    EQU   *-XSOP\nXSCL     CLOSE (*-*),MF=L\nXSCLL    EQU   *-XSCL\nXSCTL    SNAP  MF=L\nXSCTLL   EQU   *-XSCTL\n         PRINT &PRS\nZSNAPL   EQU   *-ZSNAP             SNAP WORK-AREAS LENGTH\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R12\n         EJECT\n*---------------------------------------------------------------------*\n*        SNAP ROUTINE (\"ETPS\" TEST UTILITY)                           *\n*---------------------------------------------------------------------*\n*              AT ENTRY : R11 - \"WKAREA\" ADDRESS\n*                         R12 - \"GOSNAP\" ADDRESS\n*                         R13 - CALLER SAVE-AREA POINTER (ORIGINAL\n*                               R14-R12 ARE ALREADY STORED IN IT)\n*                         R14 - LINK REGISTER\n*              NOTE - THE FOLLOWING ALLOCATION IS NEEDED TO OBTAIN\n*              ====   THE SNAP DUMP :\n*                         ALLOC F(SYSSNAP) SYSOUT(A)\n*                     OR A PRE-ALLOCATED DATA-SET (THE CHARACTERISTICS\n*                     WILL BE FORCED RECFM=VBA,BLKSIZE=1632,LRECL=125)\n*              HOW TO USE : IN ANY ETPS MODULE, AT ALL POINTS WHERE YOU\n*              ============ WANT HAVE A DUMP OF THE DATA-AREAS CONTENTS\n*                           CODE IN THE SOURCE THE ASSEMBLER MACRO\n*                               XSNAP N    (WHERE N IS A SNAP-ID NUMBER\n*                                           IN THE RANGE 0-255).\n*                           MANDATORY : THE \"MYSAVE\" WORK-AREA MUST BE\n*                           ----------- ADDRESSABLE AT CHOSEN POINTS.\n*                           REMARK : YOU MAY RETRIEVE ALL REGISTERS\n*                           -------- CONTENTS (AT SNAP TIME) THROUGH\n*                                    THE SAVE-AREAS BACK CHAIN.\n         CNOP  0,8\n         USING *,R12\nGOSNAP   LR    R3,R13\n         LA    R13,SAVES           SAVE-AREA ADDRESS\n         ST    R3,4(R13)           STORE BACKWARD POINTER\n         ST    R13,8(R3)           STORE FORWARD POINTER\n         TM    SNAPSW,SKSN         SNAP FILE IN ERROR?\n         BO    GOSNAPX             YES, SKIP\n         ST    R14,R14LINK         SAVE RETURN TO CALLER\n         LH    R1,0(R14)           GET ID NUMBER\n         LTR   R3,R1               TEST AND SAVE ID NUMBER\n         BM    *+L'*+8             IGNORE IF ERRONEOUS\n         CH    R1,=H'255'          ID IS VALID RANGE?\n         BNH   *+L'*+2             IGNORE IF ERRONEOUS\n         XR    R3,R3               FORCE ID NUMBER = 0\n         LA    R2,SNAPDCB\n         USING IHADCB,R2\n         TM    SNAPSW,OPSN         SNAP FILE ALREADY OPENED?\n         BO    GOSNAPS             YES\n        OPEN   ((R2),OUTPUT),MF=(E,SNAPOP)\n         TM    DCBOFLGS,DCBOFOPN   OPEN SUCCESSFULL?\n         BO    *+L'*+8             YES, OPEN OK\n         XR    R15,R15             NO, OPEN ERROR\n         BCTR  R15,0               SET RC = -1\n         B     GOSNAPZ\n         OI    SNAPSW,OPSN         SET SNAP FILE OPENED\n         L     R1,ADETPS           SET LIST\n         ST    R1,SNAPLST          DISPLAY MODULE START + VERSION\n         LA    R1,32(R1)\n         ST    R1,SNAPLST+4\n         LA    R1,HDSNP            SET HEADER\n         ST    R1,SNAPHD\n         OI    SNAPHD,X'80'\nGOSNAPS  XR    R15,R15             CLEAR ALL UNUSED REGISTERS\n         LR    R4,R15                (UNLESS CALLER R10)\n         LR    R5,R15\n         LR    R6,R15\n         LR    R7,R15\n         LR    R8,R15\n         LR    R9,R15\n        SNAP   DCB=(R2),TCB='S',ID=(R3),PDATA=(REGS,SA,SPLS),          X\n               LIST=SNAPLST,STRHDR=SNAPHD,MF=(E,SNAPCTL)\n         LTR   R15,R15             TEST COMPLETION CODE\n         BZ    GOSNAPY             BRANCH IF SNAP OK\nGOSNAPZ  ST    R15,SNAPCC          SAVE COMPLETION CODE\n         STC   R3,SNAPID           RETAIN SNAP ID NUMBER\n         OI    SNAPSW,SKSN         SET SNAP FILE IN ERROR\n         DROP  R2\nGOSNAPY  L     R14,R14LINK         RESTORE CALLER LINK REGISTER\nGOSNAPX  L     R13,4(,R13)         PICK UP CALLING SAVE-AREA\n         LA    R14,2(R14)          SKIP ID NUMBER\n         BR    R14                 BACK TO CALLER\n         SPACE 1\nHDSNP    DC    AL1(L'HDSNPT)\nHDSNPT   DC    C'---  E  T  P  S  - DUMP OF ALL WORK-AREAS ---'\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R11,R12\n         EJECT\nWKAREA   DSECT ,                   LOCAL SA-WA\n         DS    18F                 \"ETPSTSO\" SAVE-AREA\nSAVES    DS    18F                 \"GOSNAP\" SAVE-AREA\nWDBLW    DS    D\nWXTRCT   DS    XL(XTRCTL)          AREA FOR LIST FORM OF EXTRACT\nWATIOT   DS    A - - - - - - - - - +\nWATSO    DS    A                   +\nWAPSCB   DS    A                   + - EXTRACT PARM LIST\nWAOPLG   DS    F - - - - - - - - - +\nWAOPAD   DS    A                   + - OPERAND(S) AREA\nPARMADD  DS    F\nPARMFLD  DS    H,CL8\nPARMFLT  EQU   *-1,1               TSO TEST LOGON PANEL REQUEST\nMSGWA    DS    CL78                MESSAGE WORK-AREA\nSNAPID   DS    XL1                 SNAP ID NUMBER\nSNAPSW   DS    XL1                 SNAP WORKING SWITCHES\nOPSN     EQU   X'01'               SNAP FILE OPENED FLAG\nSKSN     EQU   X'10'               SNAP FILE IN ERROR FLAG\n         CNOP  2,4\nDOSNAP   DS    XL(STSNPL)\nSNPRGS   DS    2F                  R11-R12 TO ENTER \"GOSNAP\"\nR14LINK  DS    F                   RETURN TO CALLER\nADETPS   DS    F                   EPA OF \"ETPS\"\nSNAPDCB  DS    0F,XL(XSDCBL)       SNAP WORK-AREAS\nSNAPOP   DS    0F,XL(XSOPL)         \" \"\nSNAPCL   DS    0F,XL(XSCLL)         \" \"\nSNAPCTL  DS    0F,XL(XSCTLL)        \" \"\n         PRINT &PRS\nSNAPLST  DS    2F                  SNAP LIST POINTERS\nSNAPHD   DS    F                   SNAP HEADER POINTER\nSNAPCC   DS    F                   SNAP COMPLETION CODE\nWKLEN    EQU   (((*-WKAREA)+7)/8)*8\n         PRINT &PRF\n        IKJCPPL\n        IKJPSCB\n        IKJEBECA\nTIODSECT DSECT\n        IEFTIOT1\n        DCBD   DSORG=PS,DEVD=DA\n         PRINT GEN\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPSTSO$": {"ttr": 15628, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95)\\x8f\\x00\\x95)\\x8f\\x16E\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-10-25T00:00:00", "modifydate": "1995-10-25T16:45:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "//ETPSTSO  JOB (........),'INSTALL   ETPSTSO',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=30\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* MANDATORY : BEFORE YOU EXECUTE THIS JOB, READ THE INSTALLATION    *\n//*             DOCUMENTATION IN MEMBER \"ETPS@\".                      *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* AT ASSEMBLY STEP BELOW, YOU MAY USE THE SYSPARM TO SELECT THE     *\n//* PRINT OPTION AS FOLLOWS :                                         *\n//*            NONE OR OMITTED = NO LIST OF MACROS DEVELOPMENT        *\n//*            SHORT = REDUCED LIST OF MACROS DEVELOPMENT             *\n//*            FULL = LIST ALL MACROS DEVELOPMENT                     *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ4AS6,MBR=ETPSTSO,OPT=',RENT'\n//LNK     EXEC PAJILKC,OPT=',NCAL,RENT'\n//SYSIN     DD *\n  ENTRY   ETPSTSO\n  SETCODE AC(1)\n  NAME    ETPSTSO(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPSUTIL": {"ttr": 15873, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x06\\x7f\\x00\\x96\\x06\\x7f\\x17\\x16\\x03\\xd2\\x03\\xd2\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-03-07T00:00:00", "modifydate": "1996-03-07T17:16:00", "lines": 978, "newlines": 978, "modlines": 0, "user": "SYSPAJA"}, "text": "UTIL     TITLE '--- E T P S -- ETPSUTIL - UTILITY ROUTINES ---'\n         PRINT OFF\n         COPY  ETPS$O1             \"ETPS\" SYSPARM SELECTION\n         COPY  ETPSMACS            \"ETPS\" MACROS\n         COPY  ETPSDEFS            \"ETPS\" DEFINITIONS\n         PRINT ON\nETPSUTIL START 0\n         SPACE 1\nETPSUTIL AMODE 24\nETPSUTIL RMODE 24\n        MIDENT\n         SPACE 1\n*------- ROUTINES ADDRESSES VECTOR\n         SPACE 1\n         DC    A(ETPSDYNA,ETPSFDTE)\n         EJECT\n*------- DYNAMIC ALLOCATION ROUTINE\n*        AT ENTRY : R1 = PARM.LIST ADDRESS = A(DYNWORKP)\n*                        DYNWORKP = A(DYNWORKS)\n*                                   A(DYNRCODE+X'80000000')\n*        AT EXIT : R15 = 0 + R0 = 0  - ALL OK\n*                  R15 = 15 + R0 = POINTER ON ERROR IN DYNAMIC\n*                                  ALLOCATION T.U. LIST\n*                  R15 = NON-ZERO RETURN CODE OF SVC 99 + R0 =\n*                        ERROR/INFORMATION REASON CODES\n*                  AND \"DYNRCODE\" +0 = R0 REASON CODES\n*                                 +4 = R15 RETURN CODE\n         CNOP  0,4\n         PRINT GEN\n         USING *,R12\nETPSDYNA B     32(,R15)\n         DC    CL28'  ETPSDYNA &SYSDATE &SYSTIME'\n         PRINT &PRF\n         STM   R14,R12,12(R13)     SAVE INPUT REGISTERS\n         LR    R12,R15             SET PROGRAM BASE REGISTER\n         L     R11,0(R1)           PICK UP PARAMETER LIST ADDRESS\n         USING PARMLIST,R11\n         LR    R2,R13\n         LA    R13,SAVEAREA\n         USING SAVEAREA,R13\n         LR    R0,R13\n         L     R1,=A(DYNWRKSZ)\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R0,R14              CLEAR WORK AREA TO BINARY ZEROS\n         ST    R2,SAVEAREA+4       STORE FORWARD POINTER\n         ST    R13,8(R2)           STORE BACKWARD POINTER\n         LA    R10,DYNWORK\n         USING S99RB,R10\n         ST    R10,REQBKPTR        POINT TO REQUEST BLOCK\n         OI    REQBKPTR,S99RBPND\n         LA    R1,S99RBEND-S99RB   LENGTH OF REQUEST BLOCK\n         STC   R1,S99RBLN\n         CLC   DSNAME,=XL44'0'     CHECK FOR UNALLOCATION REQUEST\n         BNE   *+L'*+8\n         MVI   S99VERB,S99VRBUN    REQUEST UNALLOCATION\n         B     *+L'*+8\n         MVI   S99VERB,S99VRBAL    REQUEST ALLOCATION\n         OI    S99FLG11,S99NOCNV+S99NOMNT\n         LA    R8,S99RBEND         PICK UP ADDRESS FOR TEXT POINTERS\n         ST    R8,S99TXTPP\n         L     R9,=A(4*40)         RESERVE SPACE FOR 40 TEXT POINTERS\n         ALR   R9,R8               POINT TO FIRST TEXT UNIT\n         USING S99TUNIT,R9\n*- - - - DDNAME\n         LA    R7,DDNAME-PARMLIST  INITIALIZE 'OFFSET' REGISTER\n         CLI   S99VERB,S99VRBUN    HAS UNALLOCATION BEEN REQUESTED?\n         BNE   *+L'*+8\n         LA    R1,DUNDDNAM\n         B     *+L'*+4\n         LA    R1,DALDDNAM\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         LA    R14,DDNAME          FIND OUT ACTUAL LENGTH OF DDNAME\n         LA    R15,L'DDNAME\n         BAL   R1,RR1\n         LTR   R15,R15\n         BNP   LL1\n         STH   R15,S99TULNG\n         BCTR  R15,0\n         EX    R15,MVCPARM         MOVE DDNAME\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+1(R15)  NEXT TEXT UNIT\n         CLI   S99VERB,S99VRBUN    HAS UNALLOCATION BEEN REQUESTED?\n         BE    MM1                 GO DO REQUEST\n*- - - - DSNAME\n         LA    R7,DSNAME-PARMLIST  OFFSET\n         CLC   DSNAME,=CL44'NULLFILE ' CHECK FOR DUMMY ALLOCATION\n         BNE   AA1\n         LA    R1,DALDUMMY         S99TUNUM SET TO X'0000' BY WORKAREA\n         STH   R1,S99TUKEY           CLEAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUENT         NEXT TEXT UNIT\n         B     AA10\nAA1      LA    R14,DSNAME\n         LA    R15,L'DSNAME\n         BAL   R1,RR1              GET DS-NAME LENGTH\n         LTR   R15,R15\n         BNP   AA2\n         LA    R1,DALDSNAM\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         STH   R15,S99TULNG\n         BCTR  R15,0\n         EX    R15,MVCPARM         MOVE DS-NAME\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+1(R15)  NEXT TEXT UNIT\n*- - - - DSMEMBER\nAA2      LA    R7,DSMEMBER-PARMLIST\n         LA    R14,DSMEMBER\n         LA    R15,L'DSMEMBER\n         BAL   R1,RR1              GET DSMEMBER LENGTH\n         LTR   R15,R15\n         BNP   AA3\n         LA    R1,DALMEMBR\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         STH   R15,S99TULNG\n         BCTR  R15,0\n         EX    R15,MVCPARM         MOVE DSMEMBER\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+1(R15)  NEXT TEXT UNIT\n*- - - - PASSWORD\nAA3      LA    R7,PASSWORD-PARMLIST\n         LA    R14,PASSWORD\n         LA    R15,L'PASSWORD\n         BAL   R1,RR1              GET PASSWORD LENGTH\n         LTR   R15,R15\n         BNP   AA4\n         LA    R1,DALPASSW\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         STH   R15,S99TULNG\n         BCTR  R15,0\n         EX    R15,MVCPARM         MOVE PASSWORD\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+1(R15)  NEXT TEXT UNIT\n*- - - - DSSTATUS\nAA4      LA    R7,DSSTATUS-PARMLIST\n         LA    R14,DSSTATUS\n         LA    R15,L'DSSTATUS\n         BAL   R1,RR1              GET DSSTATUS LENGTH\n         LTR   R15,R15\n         BNP   AA5\n         LA    R1,DALSTATS\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,1\n         CLC   DSSTATUS,=CL8'OLD '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'01'\n         B     AA4A\n         CLC   DSSTATUS,=CL8'MOD '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'02'\n         B     AA4A\n         CLC   DSSTATUS,=CL8'NEW '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'04'\n         B     AA4A\n         CLC   DSSTATUS,=CL8'SHR '\n         BNE   LL1\n         MVI   S99TUPAR,X'08'\nAA4A     ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+1       NEXT TEXT UNIT\n*- - - - DSNDISP\nAA5      LA    R7,DSNDISP-PARMLIST\n         LA    R14,DSNDISP\n         LA    R15,L'DSNDISP\n         BAL   R1,RR1              GET DSNDISP LENGTH\n         LTR   R15,R15\n         BNP   AA6\n         LA    R1,DALNDISP\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,1\n         CLC   DSNDISP,=CL8'UNCATLG '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'01'\n         B     AA5A\n         CLC   DSNDISP,=CL8'CATLG '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'02'\n         B     AA5A\n         CLC   DSNDISP,=CL8'DELETE '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'04'\n         B     AA5A\n         CLC   DSNDISP,=CL8'KEEP '\n         BNE   LL1\n         MVI   S99TUPAR,X'08'      ASSUME KEEP\nAA5A     ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+1       NEXT TEXT UNIT\n*- - - - DSADISP\nAA6      LA    R7,DSADISP-PARMLIST\n         LA    R14,DSADISP\n         LA    R15,L'DSADISP\n         BAL   R1,RR1              GET DSADISP LENGTH\n         LTR   R15,R15\n         BNP   AA7\n         LA    R1,DALCDISP\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,1\n         CLC   DSADISP,=CL8'UNCATLG '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'01'\n         B     AA6A\n         CLC   DSADISP,=CL8'CATLG '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'02'\n         B     AA6A\n         CLC   DSADISP,=CL8'DELETE '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'04'\n         B     AA6A\n         CLC   DSADISP,=CL8'KEEP '\n         BNE   LL1\n         MVI   S99TUPAR,X'08'      ASSUME KEEP\nAA6A     ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+1       NEXT TEXT UNIT\n*- - - - DSUNIT\nAA7      LA    R7,DSUNIT-PARMLIST\n         LA    R14,DSUNIT\n         LA    R15,L'DSUNIT\n         BAL   R1,RR1              GET DSUNIT LENGTH\n         LTR   R15,R15\n         BNP   AA8\n         LA    R1,DALUNIT\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         STH   R15,S99TULNG\n         BCTR  R15,0\n         EX    R15,MVCPARM         MOVE DSUNIT\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+1(R15)  NEXT TEXT UNIT\n*- - - - $RESERV1\n*- - - - DSVOLSER\nAA8      LA    R7,DSVOLSER-PARMLIST\n         CLC   DSVOLSER,=XL44'0'\n         BNE   AA8A\n         LA    R1,DALRTVOL         SET UP TO GET VOL-SER RETURNED TO US\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,6\n         MVC   S99TUPAR(6),=CL24' '\n         LA    R1,S99TUPAR\n         ST    R1,WKRTNVOL         SAVE ADDRESS OF PARAMETER FIELD\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+6       NEXT TEXT UNIT\n         B     AA9\nAA8A     LA    R14,DSVOLSER\n         LA    R15,L'DSVOLSER\n         BAL   R1,RR1              GET VOL-SER LENGTH\n         LTR   R15,R15\n         BNP   AA9\n         LA    R1,DALVLSER\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         STH   R15,S99TULNG\n         BCTR  R15,0\n         EX    R15,MVCPARM         MOVE VOL-SER\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+1(R15)  NEXT TEXT UNIT\n*- - - - $RESERV2\n*- - - - DSVOLREF\nAA9      LA    R7,DSVOLREF-PARMLIST\n         LA    R14,DSVOLREF\n         LA    R15,L'DSVOLREF\n         BAL   R1,RR1              GET DSVOLREF LENGTH\n         LTR   R15,R15\n         BNP   AA10\n         CLC   DSVOLSER,=CL24' '   CHECK TO SEE THAT DSVOLREF DOES NOT\n         BE    AA9A                  CONFLICT WITH DSVOLSER\n         CLC   DSVOLSER,=XL44'0'\n         BNE   LL1\nAA9A     LA    R1,DALVLRDS\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         STH   R15,S99TULNG\n         BCTR  R15,0\n         EX    R15,MVCPARM         MOVE DSVOLREF\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+1(R15)  NEXT TEXT UNIT\n*- - - - DSFREE\nAA10     LA    R7,DSFREE-PARMLIST\n         LA    R14,DSFREE\n         LA    R15,L'DSFREE\n         BAL   R1,RR1              GET DSFREE LENGTH\n         LTR   R15,R15\n         BNP   AA11\n         CLC   DSFREE,=CL8'END   '\n         BE    AA11\n         CLC   DSFREE,=CL8'CLOSE '\n         BNE   LL1\n         LA    R1,DALCLOSE         S99TUNUM SET TO X'0000' BY WORKAREA\n         STH   R1,S99TUKEY           CLEAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUENT         NEXT TEXT UNIT\nAA11     CLC   DSNAME,=CL44'NULLFILE ' CHECK FOR DUMMY ALLOCATION\n         BE    CC1                 GO DO DCB PARAMETERS\n*- - - - DSLABEL\n         LA    R7,DSLABEL-PARMLIST\n         LA    R14,DSLABEL\n         LA    R15,L'DSLABEL\n         BAL   R1,RR1              GET DSLABEL LENGTH\n         LTR   R15,R15\n         BNP   AA12\n         LA    R1,DALLABEL\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,1\n         CLC   DSLABEL,=CL4'SL  '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'02'\n         B     AA11A\n         CLC   DSLABEL,=CL4'SUL '\n         BNE   LL1\n         MVI   S99TUPAR,X'08'\nAA11A    ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+1       NEXT TEXT UNIT\n*- - - - DSINOUT\nAA12     LA    R7,DSINOUT-PARMLIST\n         LA    R14,DSINOUT\n         LA    R15,L'DSINOUT\n         BAL   R1,RR1              GET DSINOUT LENGTH\n         LTR   R15,R15\n         BNP   AA13\n         LA    R1,DALINOUT\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,1\n         CLC   DSINOUT,=CL4'IN '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,VLB        SET \"VL\" BIT\n         B     AA12A\n         CLC   DSINOUT,=CL4'OUT '\n         BNE   LL1\n         MVI   S99TUPAR,X'40'\nAA12A    ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+1       NEXT TEXT UNIT\n*- - - - $RESERV3\nAA13     LA    R7,$RESERV3-PARMLIST\n         CLC   $RESERV3,=CL24' '\n         BNE   LL1\n         CLC   DSSTATUS,=CL24' '   CHECK FOR NEW ALLOCATION\n         BE    BB1\n         CLC   DSSTATUS,=CL8'NEW '\n         BNE   CC1                 GO DO DCB PARAMETERS\n*- - - - DSPWDLBL\nBB1      LA    R7,DSPWDLBL-PARMLIST\n         LA    R14,DSPWDLBL\n         LA    R15,L'DSPWDLBL\n         BAL   R1,RR1              GET DSPWDLBL LENGTH\n         LTR   R15,R15\n         BNP   BB2\n         LA    R1,DALPASPR\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,1\n         CLC   DSPWDLBL,=CL8'PASSWORD'\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'10'\n         B     BB1A\n         CLC   DSPWDLBL,=CL8'NOPWREAD'\n         BNE   LL1\n         MVI   S99TUPAR,X'30'\nBB1A     ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+1       NEXT TEXT UNIT\n*- - - - DSDATE\nBB2      LA    R7,DSDATE-PARMLIST\n         LA    R14,DSDATE\n         LA    R15,L'DSDATE\n         BAL   R1,RR1              GET DSDATE LENGTH\n         LTR   R15,R15\n         BNP   BB3\n         CLC   DSDATE(6),=CL6'EXPDT=' CHECK FOR DATE TYPE\n         BNE   BB2A\n         SH    R15,=H'6'\n         CH    R15,=H'5'           CHECK FOR VALID LENGTH\n         BNE   LL1\n         LA    R14,6(0,R14)        BUMP POINTER FOR MVCPARM\n         LA    R1,DALEXPDT\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         STH   R15,S99TULNG\n         BCTR  R15,0\n         EX    R15,MVCPARM         MOVE EXPDT DATE\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+1(R15)  NEXT TEXT UNIT\n         B     BB3\nBB2A     CLC   DSDATE(6),=CL6'RETPD='\n         BNE   LL1                 ERROR\n         SH    R15,=H'6'\n         BNP   LL1\n         CH    R15,=H'4'\n         BH    LL1\n         LA    R14,6(0,R14)        BUMP POINTER TO START OF NUMBER\n         BAL   R1,RR2              EDIT AND CONVERT RETPD\n         LA    R1,DALRETPD\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,2\n         STH   R15,S99TUPAR        PLACE RETPD VALUE IN TEXT UNIT\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+2       NEXT TEXT UNIT\n*- - - - DSALLOC\nBB3      LA    R7,DSALLOC-PARMLIST\n         LA    R14,DSALLOC\n         LA    R15,L'DSALLOC\n         BAL   R1,RR1              GET DSALLOC LENGTH\n         LTR   R15,R15\n         BNP   LL1                 ERROR\n         CLC   DSALLOC,=CL5'TRK '  CHECK FOR TRACK ALLOCATION\n         BNE   BB3A\n         LA    R1,DALTRK           S99TUNUM SET TO X'0000' BY WORKAREA\n         STH   R1,S99TUKEY           CLEAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUENT         NEXT TEXT UNIT\n         B     BB4\nBB3A     CLC   DSALLOC,=CL5'CYL '  CHECK FOR CYLINDER ALLOCATION\n         BNE   BB3B\n         LA    R1,DALCYL           S99TUNUM SET TO X'0000' BY WORKAREA\n         STH   R1,S99TUKEY           CLEAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUENT         NEXT TEXT UNIT\n         B     BB4\nBB3B     BAL   R1,RR2              CHECK FOR AVERAGE BLOCK ALLOCATION\n         LA    R1,DALBLKLN\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,3\n         STCM  R15,B'0111',S99TUPAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+3       NEXT TEXT UNIT\n*- - - - DSPRI\nBB4      LA    R7,DSPRI-PARMLIST\n         LA    R14,DSPRI\n         LA    R15,L'DSPRI\n         BAL   R1,RR1              GET DSPRI LENGTH\n         LTR   R15,R15\n         BNP   LL1\n         BAL   R1,RR2              CHECK FOR PRIMARY QUANTITY\n         LA    R1,DALPRIME\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,3\n         STCM  R15,B'0111',S99TUPAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+3       NEXT TEXT UNIT\n*- - - - DSSEC\n         LA    R7,DSSEC-PARMLIST\n         LA    R14,DSSEC\n         LA    R15,L'DSSEC\n         BAL   R1,RR1              GET DSSEC LENGTH\n         LTR   R15,R15\n         BNP   BB5\n         BAL   R1,RR2              CHECK FOR SECONDARY QUANTITY\n         LA    R1,DALSECND\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,3\n         STCM  R15,B'0111',S99TUPAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+3       NEXT TEXT UNIT\n*- - - - DSDIR\nBB5      LA    R7,DSDIR-PARMLIST\n         LA    R14,DSDIR\n         LA    R15,L'DSDIR\n         BAL   R1,RR1              GET DSDIR LENGTH\n         LTR   R15,R15\n         BNP   BB6\n         BAL   R1,RR2              CHECK FOR DIRECTORY QUANTITY\n         LA    R1,DALDIR\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,3\n         STCM  R15,B'0111',S99TUPAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+3       NEXT TEXT UNIT\n*- - - - DSRLSE\nBB6      LA    R7,DSRLSE-PARMLIST\n         LA    R14,DSRLSE\n         LA    R15,L'DSRLSE\n         BAL   R1,RR1              GET DSRLSE LENGTH\n         LTR   R15,R15\n         BNP   BB7\n         CLC   DSRLSE,=CL8'RLSE '\n         BNE   LL1\n         LA    R1,DALRLSE          S99TUNUM SET TO X'0000' BY WORKAREA\n         STH   R1,S99TUKEY           CLEAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUENT         NEXT TEXT UNIT\n*- - - - DSCONTIG\nBB7      LA    R7,DSCONTIG-PARMLIST\n         LA    R14,DSCONTIG\n         LA    R15,L'DSCONTIG\n         BAL   R1,RR1              GET DSCONTIG LENGTH\n         LTR   R15,R15\n         BNP   BB8\n         LA    R1,DALSPFRM\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,1\n         CLC   DSCONTIG,=CL8'CONTIG '\n         BNE   LL1\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+1       NEXT TEXT UNIT\n*- - - - DSROUND\nBB8      LA    R7,DSROUND-PARMLIST\n         LA    R14,DSROUND\n         LA    R15,L'DSROUND\n         BAL   R1,RR1              GET DSROUND LENGTH\n         LTR   R15,R15\n         BNP   BB9\n         CLC   DSROUND,=CL8'ROUND '\n         BNE   LL1\n         LA    R1,DALROUND         S99TUNUM SET TO X'0000' BY WORKAREA\n         STH   R1,S99TUKEY           CLEAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUENT         NEXT TEXT UNIT\n*- - - - $RESERV4\nBB9      LA    R7,$RESERV4-PARMLIST\n         CLC   $RESERV4,=CL24' '\n         BNE   LL1\n*- - - - DSBLKSI\nCC1      CLC   DSSTATUS(3),=CL3'NEW' IF ALLOCATION IS NOT NEW\n         BNE   MM1\n         LA    R7,DSBLKSI-PARMLIST\n         LA    R14,DSBLKSI\n         LA    R15,L'DSBLKSI\n         BAL   R1,RR1              GET DSBLKSI LENGTH\n         LTR   R15,R15\n         BNP   CC2\n         BAL   R1,RR2              CHECK FOR BLKSIZE VALUE\n         CH    R15,=H'32767'       CHECK FOR MAXIMUM BLOCKSIZE\n         BH    LL1                 ERROR\n         LA    R1,DALBLKSZ\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,2\n         STH   R15,S99TUPAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+2       NEXT TEXT UNIT\n*- - - - DSORG\nCC2      LA    R7,DSORG-PARMLIST\n         CLC   DSORG,=XL44'0'\n         BNE   CC2A\n         LA    R1,DALRTORG         SET UP TO HAVE DSORG RETURNED TO US\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,2\n         MVC   S99TUPAR(2),=XL44'0'\n         LA    R1,S99TUPAR\n         ST    R1,WKRTDSRG         SAVE ADDRESS OF PARAMETER FIELD\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+2       NEXT TEXT UNIT\n         B     CC3\nCC2A     LA    R14,DSORG\n         LA    R15,L'DSORG\n         BAL   R1,RR1              GET DSORG LENGTH\n         LTR   R15,R15\n         BNP   CC3\n         LA    R1,DALDSORG\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,2\n         CLC   DSORG,=CL8'VSAM '\n         BNE   *+L'*+10\n         MVC   S99TUPAR(2),=AL1(0,DS1ORGAM)\n         B     CC2B\n         CLC   DSORG,=CL8'PO   '\n         BNE   *+L'*+10\n         MVC   S99TUPAR(2),=AL1(DS1DSGPO,0)\n         B     CC2B\n         CLC   DSORG,=CL8'POU  '\n         BNE   *+L'*+10\n         MVC   S99TUPAR(2),=AL1(DS1DSGPO+DS1DSGU,0)\n         B     CC2B\n         CLC   DSORG,=CL8'DA   '\n         BNE   *+L'*+10\n         MVC   S99TUPAR(2),=AL1(DS1DSGDA,0)\n         B     CC2B\n         CLC   DSORG,=CL8'DAU  '\n         BNE   *+L'*+10\n         MVC   S99TUPAR(2),=AL1(DS1DSGDA+DS1DSGU,0)\n         B     CC2B\n         CLC   DSORG,=CL8'PS   '\n         BNE   *+L'*+10\n         MVC   S99TUPAR(2),=AL1(DS1DSGPS,0)\n         B     CC2B\n         CLC   DSORG,=CL8'PSU  '\n         BNE   LL1                 ERROR\n         MVC   S99TUPAR(2),=AL1(DS1DSGPS+DS1DSGU,0)\nCC2B     ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+2       NEXT TEXT UNIT\n*- - - - DSKEYLEN\nCC3      LA    R7,DSKEYLEN-PARMLIST\n         LA    R14,DSKEYLEN\n         LA    R15,L'DSKEYLEN\n         BAL   R1,RR1              GET DSKEYLEN LENGTH\n         LTR   R15,R15\n         BNP   CC4\n         BAL   R1,RR2              CHECK FOR KEYLENGTH QUANTITY\n         CH    R15,=H'255'         CHECK FOR MAX KEYLENGTH\n         BH    LL1                 ERROR\n         LA    R1,DALKYLEN\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,1\n         STC   R15,S99TUPAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+1       NEXT TEXT UNIT\n*- - - - DSLRECL\nCC4      LA    R7,DSLRECL-PARMLIST\n         LA    R14,DSLRECL\n         LA    R15,L'DSLRECL\n         BAL   R1,RR1              GET DSLRECL LENGTH\n         LTR   R15,R15\n         BNP   CC5\n         LA    R1,DALLRECL\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,2\n         CLC   DSLRECL,=CL5'X '    CHECK FOR SPANNED RECORDS\n         BNE   *+L'*+10\n         MVC   S99TUPAR(2),=AL2(32768)\n         B     CC4A\n         BAL   R1,RR2              CHECK FOR LRECL QUANTITY\n         CH    R15,=H'32767'\n         BH    LL1\n         STH   R15,S99TUPAR\nCC4A     ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+2       NEXT TEXT UNIT\n*- - - - DSRECFM1 THRU DSRECFM8\nCC5      LA    R7,DSRECFM1-PARMLIST\n         CLC   DSRECFM,=CL24' '    CHECK FOR NO INFORMATION\n         BE    CC6\n         LA    R1,DALRECFM\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,1\n         CLI   DSRECFM1,C' '\n         BE    CC5A\n         CLI   DSRECFM1,C'V'\n         BNE   *+L'*+8\n         OI    S99TUPAR,DS1RECFV\n         B     CC5A\n         CLI   DSRECFM1,C'F'\n         BNE   *+L'*+8\n         OI    S99TUPAR,DS1RECFF\n         B     CC5A\n         CLI   DSRECFM1,C'U'\n         BNE   LL1                 ERROR\n         OI    S99TUPAR,DS1RECFU\nCC5A     LA    R7,DSRECFM2-PARMLIST\n         CLI   DSRECFM2,C' '\n         BE    CC5B\n         CLI   DSRECFM2,C'B'\n         BNE   LL1                 ERROR\n         OI    S99TUPAR,DS1RECFB\nCC5B     LA    R7,DSRECFM3-PARMLIST\n         CLI   DSRECFM3,C' '\n         BE    CC5C\n         CLI   DSRECFM3,C'S'\n         BNE   LL1                 ERROR\n         OI    S99TUPAR,DS1RECFS\nCC5C     LA    R7,DSRECFM4-PARMLIST\n         CLI   DSRECFM4,C' '\n         BE    CC5D\n         CLI   DSRECFM4,C'T'\n         BNE   LL1                 ERROR\n         OI    S99TUPAR,DS1RECFT\nCC5D     LA    R7,DSRECFM5-PARMLIST\n         CLI   DSRECFM5,C' '\n         BE    CC5E\n         CLI   DSRECFM5,C'M'\n         BNE   *+L'*+8\n         OI    S99TUPAR,DS1RECMC\n         B     CC5E\n         CLI   DSRECFM5,C'A'\n         BNE   LL1                 ERROR\n         OI    S99TUPAR,DS1RECFA\nCC5E     LA    R7,DSRECFM6-PARMLIST\n         CLI   DSRECFM6,C' '\n         BNE   LL1                 ERROR\n         LA    R7,DSRECFM7-PARMLIST\n         CLI   DSRECFM7,C' '\n         BNE   LL1                 ERROR\n         LA    R7,DSRECFM8-PARMLIST\n         CLI   DSRECFM8,C' '\n         BNE   LL1                 ERROR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+1       NEXT TEXT UNIT\n*- - - - DSDCBDS\nCC6      LA    R7,DSDCBDS-PARMLIST\n         LA    R14,DSDCBDS\n         LA    R15,L'DSDCBDS\n         BAL   R1,RR1              GET DSDCBDS LENGTH\n         LTR   R15,R15\n         BNP   CC7\n         LA    R1,DALDCBDS\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         STH   R15,S99TULNG\n         BCT   R15,MVCPARM+L'MVCPARM\nMVCPARM  MVC   S99TUPAR(*-*),0(R14) <<EXECUTED>>\n         EX    R15,MVCPARM\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS\n         LA    R8,4(0,R8)          NEXT TEXT POINTER\n         LA    R9,S99TUPAR+1(R15)  NEXT TEXT UNIT\n*- - - - $RESERV5\nCC7      LA    R7,$RESERV5-PARMLIST\n         CLC   $RESERV5,=CL24' '\n         BE    MM1\nLL1      LR    R0,R7               SET UP RETURN CODES ----------------\n         LA    R15,15              R15 = 15, R0 = DISPL. (PARMLIST) <==\n         B     ZZ1\nMM1      SH    R8,=H'4'            BACK UP TO LAST USED TEXT POINTER\n         OI    0(R8),S99TUPLN      INDICATE END OF LIST\n         LA    R1,REQBKPTR\n        DYNALLOC\n         L     R0,S99RSC           PICK UP REASON CODES\n         LTR   R15,R15             CHECK FOR ERRORS\n         BNZ   ZZ1\n         L     R1,WKRTNVOL         CHECK FOR VOL-SER RETURN REQUEST\n         LTR   R1,R1\n         BZ    MM1A\n         MVC   DSVOLSER,0(R1)      GIVE CALLER INFO\nMM1A     L     R1,WKRTDSRG         CHECK FOR DSORG RETURN REQUEST\n         LTR   R1,R1\n         BZ    ZZ1\n         CLC   0(2,R1),=AL1(0,DS1ORGAM)\n         BNE   *+L'*+10\n         MVC   DSORG,=CL8'VSAM '\n         B     ZZ1\n         CLC   0(2,R1),=AL1(DS1DSGPO,0)\n         BNE   *+L'*+10\n         MVC   DSORG,=CL8'PO   '\n         B     ZZ1\n         CLC   0(2,R1),=AL1(DS1DSGPO+DS1DSGU,0)\n         BNE   *+L'*+10\n         MVC   DSORG,=CL8'POU  '\n         B     ZZ1\n         CLC   0(2,R1),=AL1(DS1DSGDA,0)\n         BNE   *+L'*+10\n         MVC   DSORG,=CL8'DA   '\n         B     ZZ1\n         CLC   0(2,R1),=AL1(DS1DSGDA+DS1DSGU,0)\n         BNE   *+L'*+10\n         MVC   DSORG,=CL8'DAU  '\n         B     ZZ1\n         CLC   0(2,R1),=AL1(DS1DSGPS,0)\n         BNE   *+L'*+10\n         MVC   DSORG,=CL8'PS   '\n         B     ZZ1\n         CLC   0(2,R1),=AL1(DS1DSGPS+DS1DSGU,0)\n         BNE   *+L'*+10\n         MVC   DSORG,=CL8'PSU  '\n         B     ZZ1\n         CLC   0(2,R1),=AL1(DS1DSGIS,0)\n         BNE   *+L'*+10\n         MVC   DSORG,=CL8'IS   '\n         B     ZZ1\n         CLC   0(2,R1),=AL1(DS1DSGIS+DS1DSGU,0)\n         BNE   ZZ1\n         MVC   DSORG,=CL8'ISU  '\nZZ1      LR    R1,R13              PREPARE FOR FREEMAIN\n         L     R13,SAVEAREA+4\n         LTR   R11,R11             CHECK TO SEE IF PARM.LIST IS ONLY\n         BNP   ZZ1A                  ENTRY IN CALLER'S ADDRESS LIST\n         L     R2,24(0,R13)        GET R1 ENTRY REGISTER\n         L     R2,4(0,R2)          GET SECOND ADDRESS IN PARM.LIST\n         ST    R0,0(0,R2)          PUT REGISTER INFORMATION IN LIST\n         ST    R15,4(0,R2)          \" \"\nZZ1A     L     R14,12(R13)         PRESERVE R15\n         LM    R1,R12,24(R13)      RESTORE CALLING REGISTERS\n         BR    R14                 NORMAL RETURN\n*- - - - ROUTINE TO DETERMINE LENGTH OF NON-BLANK CHARACTERS IN FIELD\nRR1      LTR   R15,R15             AT ENTRY, R1 CONTAINS THE RETURN\n         BNPR  R1                  ADDRESS, R14 CONTAINS FIELD ADDRESS,\n         ALR   R15,R14             R15 CONTAINS LENGTH OF FIELD.\nRR1A     BCTR  R15,0               AT EXIT, R15 WILL BE ALTERED TO\n         CLI   0(R15),C' '         CONTAIN LENGTH OF NON-BLANK\n         BNE   RR1B                CHARACTERS IN FIELD.\n         CLR   R15,R14\n         BH    RR1A\n         XR    R15,R15\n         BR    R1\nRR1B     SLR   R15,R14\n         LA    R15,1(0,R15)\n         BR    R1\n*- - - - ROUTINE TO EDIT EBCDIC NUMERIC DATA AND, IF VALID, TO CONVERT\nRR2      LTR   R15,R15             IT TO BINARY\n         BNPR  R1                  AT ENTRY, R1 CONTAINS THE RETURN\n         ST    R15,DBLWORD         ADDRESS, R14 CONTAINS DATA ADDRESS,\n         ALR   R15,R14             R15 CONTAINS LENGTH OF DATA.\nRR2A     BCTR  R15,0               AT NORMAL EXIT, R15 WILL BE ALTERED\n         CLI   0(R15),C'0'         TO CONTAIN THE BINARY EQUIVALENT OF\n         BL    LL1                 THE NUMBER.\n         CLI   0(R15),C'9'         AN ABNORMAL EXIT WILL BE TAKEN TO\n         BH    LL1                 THE COMMON ERROR ROUTINE IF DATA IS\n         CLR   R15,R14             NOT NUMERIC.\n         BH    RR2A\n         L     R15,DBLWORD\n         BCT   R15,*+L'*+6\n         PACK  DBLWORD,0(*-*,R14)  <<EXECUTED>>\n         EX    R15,*-6\n         CVB   R15,DBLWORD\n         BR    R1\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\n         DROP  R9,R10,R11,R12,R13\n         EJECT\n*------- FORMATS DATE AND TIME ROUTINE\n*        AT ENTRY : R1  = POINTER ON WORK-AREA (SEE \"FDTWA\" DSECT)\n*                   R13 = CALLER SAVE AREA\n*                   R14 = CALLER RETURN ADDRESS\n*                   R15 = ENTRY ADDRESS\n*        AT EXIT : R15 = RETURN CODE +0 - OK\n*                                    +4 - ERROR\n         CNOP  0,4\n         PRINT GEN\n         USING *,R12\nETPSFDTE B     32(,R15)\n         DC    CL28'  ETPSFDTE &SYSDATE &SYSTIME'\n         PRINT &PRF\n         STM   R14,R12,12(R13)     SAVE CALLER REGISTER\n         LR    R12,R15             SET BASE REGISTER\n         ST    R13,4(R1)           STORE BACKWARD POINTER\n         ST    R1,8(R13)           STORE FORWARD POINTER\n         LR    R13,R1\n         USING FDTWA,R13\n        TIME   ,\n         LA    R15,X'0F'           R0 = HHMMSSTH\n         SRL   R0,4                R0 = 0HHMMSST\n         OR    R0,R15              R0 = 0HHMMSSF\n         ST    R0,FDTWK+4\n         UNPK  FTM,FDTWK+4(4)\n         XR    R0,R0               R1 = 0CYYDDDF\n         ST    R0,FDTWK\n         SLDL  R0,16               R0 = 00000CYY\n         SRL   R1,16               R1 = 0000DDDF\n         SLL   R0,4                R0 = 0000CYY0\n         OR    R0,R15              R0 = 0000CYYF\n         ST    R0,FDTWK+4\n         AP    FDTWK,=PL3'+1900'   ADD BASE CENTURY\n         OI    FDTWK+L'FDTWK-1,X'0F'\n         UNPK  FXYEAR(L'FXYEAR),FDTWK+5(3) SET YEAR IN PLACE\n         CVB   R0,FDTWK            R0 = YEAR IN BINARY\n         ST    R1,FDTWK+4\n         OI    FDTWK+L'FDTWK-1,X'0F'\n         UNPK  FXDDD(L'FXDDD),FDTWK+6(2) SET SERIAL DAY IN PLACE\n         CVB   R1,FDTWK            R1 = SERIAL DAY IN BINARY\n         LR    R4,R1\n         CH    R1,=Y(31+28)        DAY PAST FEBRUARY?\n         BNH   FDTS3               NO\n         LR    R15,R0              LOOK TO SEE\n         XR    R14,R14               IF WE ARE\n         D     R14,=F'100'             ON A\n         LTR   R14,R14                   CENTURY?\n         BNZ   FDTS1               NO\n         LR    R14,R15             YES, LOOK IF\n         SRL   R14,2                 THE CENTURY\n         SLL   R14,2                   MUST BE\n         CLR   R14,R15                   A LEAP YEAR?\n         BE    FDTS3               YES\n         B     FDTS2               ELSE ADJUST DAYS\nFDTS1    LR    R15,R0              LOOK TO SEE\n         SRL   R15,2                 IF FEBRUARY\n         SLL   R15,2                   OF THIS YEAR\n         CLR   R15,R0                    MUST BE 29 DAYS?\n         BE    FDTS3               YES\nFDTS2    LA    R1,1(R1)            NO, ADJUST DAYS\nFDTS3    LA    R2,12               NOW COMPUTE MONTH\n         XR    R3,R3\nFDTS4    IC    R3,TMONTH-1(R2)\n         SR    R1,R3\n         BNP   FDTS5\n         BCT   R2,FDTS4\n         LA    R15,4 ------------- WRONG YYYYDDD\n         B     FDTS99\nFDTS5    AR    R1,R3               R1 IS THE DAY IN THE MONTH\n         CVD   R1,FDTWK\n         OI    FDTWK+7,X'0F'\n         UNPK  FXDD(L'FXDD),FDTWK+6(2)\n         LA    R3,13\n         SR    R3,R2               R3 IS THE MONTH\n         CVD   R3,FDTWK\n         OI    FDTWK+7,X'0F'\n         UNPK  FXMM(L'FXMM),FDTWK+6(2)\n         LR    R2,R3\n         SLA   R2,1\n         AR    R2,R3\n         LA    R3,MONTHT-L'MONTHT(R2)\n         MVC   FXMONTH(L'FXMONTH),0(R3)\n         LR    R3,R0               R3 = YEAR IN BINARY\n         LR    R1,R3\n         XR    R0,R0\n         BCTR  R1,0\n         D     R0,=F'100'\n         LR    R2,R1\n         SRL   R1,2\n         SR    R2,R1\n         LR    R1,R3\n         LR    R0,R1\n         BCTR  R1,0\n         SRL   R1,2\n         AR    R1,R0\n         AR    R1,R4               R4 = SERIAL DAY IN BINARY\n         SR    R1,R2\n         XR    R0,R0\n         D     R0,=F'7'\n         A     R0,=F'6'            ADJUST SO SUNDAY IS INDEX 0\n         CL    R0,=F'7'\n         BL    *+L'*+4\n         S     R0,=F'7'            ONE DIGIT DAY INDEX\n         LR    R2,R0\n         SLA   R2,1\n         AR    R2,R0\n         LA    R2,DAYT(R2)\n         MVC   FXDAY(L'FXDAY),0(R2)\n         XR    R15,R15             RC = OK\nFDTS99   L     R13,4(R13)          GET CALLER SAVE-AREA\n         ST    R15,16(R13)         SET RETURN CODE\n         LM    R14,R12,12(R13)     RESTORE ALL REGISTERS\n         BR    R14                 RETURN TO CALLER\n         SPACE 1\nTMONTH   DC    AL1(31,30,31,30,31,31,30,31,30,31,29,31)\nMONTHT   DC    CL3'JAN',C'FEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC'\nDAYT     DC    CL3'SUN',C'MONTUEWEDTHUFRISAT'\n         PRINT &PRS\n        LTORG\n         DROP  R12,R13\n         EJECT\n        PARMLIST\n         SPACE 1\n        FDATE\n         PRINT &PRF\n        IECSDSL1 (1)\n        IEFZB4D0\n        IEFZB4D2\n         PRINT GEN\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ETPSZAP": {"ttr": 16135, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x07?\\x00\\x96\\x07?\\x14Y\\x14O\\x14O\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-03-13T00:00:00", "modifydate": "1996-03-13T14:59:00", "lines": 5199, "newlines": 5199, "modlines": 0, "user": "SYSPAJA"}, "text": "ZAP      TITLE '--- E T P S -- ETPSZAP - DATA-SET DISPLAY/MODIFY ---'\n         PRINT OFF\n         COPY  ETPS$O2A            \"ETPS\" SYSPARM SELECTION\n         MACRO\n&NAME   @CMD   &CN,&CA\n         LCLA  &L\n         AIF   ('&CN' NE '').A\n         MNOTE 8,' COMMAND NAME MISSING **************************** '\n         MEXIT\n.A       AIF   ('&CA' NE '').B\n         MNOTE 8,' COMMAND ADDRESS MISSING ************************* '\n         MEXIT\n.B       AIF   ('&CN'(1,1) NE '''').C\n&L       SETA  K'&CN-2\n         AIF   (&L GT 8).ERR\n&NAME    DC    AL1(&L-1),CL8&CN,AL3(&CA)\n         MEXIT\n.C       ANOP\n&L       SETA  K'&CN\n         AIF   (&L GT 8).ERR\n&NAME    DC    AL1(&L-1),CL8'&CN',AL3(&CA)\n         MEXIT\n.ERR     MNOTE 8,' COMMAND NAME TOO LONG (MAX.=8) ****************** '\n         MEND\n         MACRO\n&NAME   @IML   &TX\n         GBLA  &##\n         LCLA  &L,&N,&M\n         AIF   ('&TX' EQ 'END').J\n&##      SETA  &##+1\n         AIF   ('&TX' NE '').A\n         MNOTE 8,' LINE IMAGE - TEXT MISSING *********************** '\n         MEXIT\n.A       ANOP\n&N       SETA  1\n&L       SETA  K'&TX\n         AIF   ('&TX'(&N,1) EQ '''').B\n         MNOTE 8,' TEXT - INITIAL QUOTE MISSING ******************** '\n         MEXIT\n.B       AIF   (&L LT 2).C\n         AIF   ('&TX'(&L,1) EQ '''').D\n.C       MNOTE 8,' TEXT - FINAL QUOTE MISSING ********************** '\n         MEXIT\n.D       AIF   (&L GT 2).E\n&NAME    DC    XL1'80'\n         MEXIT\n.E       ANOP\n&L       SETA  &L-1\n&M       SETA  0\n.F       ANOP\n&N       SETA  &N+1\n&M       SETA  &M+1\n         AIF   (&M LE 60).G\n         MNOTE 8,' TEXT TOO LONG (MAX. = 60) *********************** '\n         MEXIT\n.G       AIF   ('&TX'(&N,1) NE '''').I\n&N       SETA  &N+1\n         AIF   (&N GT &L).H\n         AIF   ('&TX'(&N,1) EQ '''').F\n.H       MNOTE 8,' QUOTE IN TEXT MUST BE DOUBLED ******************* '\n         MEXIT\n.I       AIF   (&N LT &L).F\n&NAME    DC    AL1(&M-1),CL&M&TX\n         MEXIT\n.J       ANOP\n&NAME    DC    XL1'FF'\n.* ---> HELP LINES : FROM LINE 6 TO LINE 18 INCLUDED = 13.\n         AIF   (&## LE 13).K\n         MNOTE 8,' TOO MANY LINES IN THIS HELP IMAGE *************** '\n.K       ANOP\n&##      SETA  0\n         MEND\n         MACRO\n&NAME   @HEX   &TO,&FROM,&L,&LEN=,&HEXTAB=,&BYTE=C' ',&DIGITS=\n         GBLC  &HEXTAB#\n         LCLA  &LT                 UNPK \"TO\" LENGTH\n         LCLA  &LF                 UNPK \"FROM\" LENGTH\n         LCLA  &LTR                TR \"TO\" LENGTH\n         LCLA  &LL                 &LEN ONE WAY OR ANOTHER\n         LCLC  &F1,&F2,&T1,&T2,&LX\n&HEXTAB# SETC  'HEXTAB'\n&F1      SETC  '&FROM(1)'          FOR SHORTER STRING LATER\n&F2      SETC  '&FROM(2)'          FOR SHORTER STRING LATER\n&T1      SETC  '&TO(1)'            FOR SHORTER STRING LATER\n&T2      SETC  '&TO(2)'            FOR SHORTER STRING LATER\n&LX      SETC  '&L&LEN'            GET LENGTH USING EITHER METHOD\n         AIF   ('&LX' EQ '').DEFLEN LENGTH WILL DEFAULT TO 4\n&LL      SETA  &LX                 GET IT\n         AGO   .OKLEN\n.DEFLEN  ANOP\n&LL      SETA  4                   SET THE DEFAULT LENGTH\n.OKLEN   AIF   ('&HEXTAB' EQ '').OKHEX1\n&HEXTAB# SETC  '&HEXTAB'\n.OKHEX1  AIF   ('&HEXTAB#' NE '').OKHEX2\n&HEXTAB# SETC  'HEXTAB'\n.OKHEX2  ANOP\n&LT      SETA  &LL*2\n         AIF   ('&DIGITS' EQ '').OKDIGIT\n&LT      SETA  &DIGITS\n.OKDIGIT AIF   (N'&TO NE 2).TO1\n         AIF   (N'&FROM NE 2).T2F1\n&NAME    UNPK  &T1.(&LT+1,&T2),&F1.(&LL+1,&F2)\n         TR    &T1.(&LT,&T2),&HEXTAB#\n         MVI   &T1+&LT.(&T2),&BYTE\n         MEXIT\n.T2F1    AIF   (N'&FROM NE 1).ERRF\n&NAME    UNPK  &T1.(&LT+1,&T2),&FROM.(&LL+1)\n         TR    &T1.(&LT,&T2),&HEXTAB#\n         MVI   &T1+&LT.(&T2),&BYTE\n         MEXIT\n.TO1     AIF   (N'&TO NE 1).ERRT\n         AIF   (N'&FROM NE 2).T1F1\n&NAME    UNPK  &TO.(&LT+1),&F1.(&LL+1,&F2)\n         TR    &TO.(&LT),&HEXTAB#\n         MVI   &TO+&LT,&BYTE\n         MEXIT\n.T1F1    AIF   (N'&FROM NE 1).ERRF\n&NAME    UNPK  &TO.(&LT+1),&FROM.(&LL+1)\n         TR    &TO.(&LT),&HEXTAB#\n         MVI   &TO+&LT,&BYTE\n         MEXIT\n.ERRF    MNOTE 8,' ERROR IN \"FROM\" PARAMETER *********************** '\n         MEXIT\n.ERRT    MNOTE 8,' ERROR IN \"TO\" PARAMETER ************************* '\n         MEND\n         MACRO\n&NAME   @OP    &M,&F,&O\n         GBLA  &#\n         LCLC  &F$\n&F$      SETC  '&F'\n         AIF   ('&F'(1,1) NE '''').OK\n&F$      SETC  '&F'(2,1)\n.OK      ANOP\n&#       SETA  &#+1\n@&O      EQU   &#\n&NAME    DC    CL4'&M',C'&F$',X'&O'\n         MEND\n         MACRO\n        @SST   &DUMMY\nSSTAB    DS    0F                  START SENSITIVE PREFIXES TABLE\n         GBLA  &ZSSN\n         GBLC  &ZSSE(1)\n         LCLA  &L,&M,&N\n         AIF   (&ZSSN EQ 0).B\n&N       SETA  1\n.A       AIF   (&N GT &ZSSN).B\n&M       SETA  K'&ZSSE(&N)\n&L       SETA  &M-1\n         DC    AL1(&L),CL&M'&ZSSE(&N)'\n&N       SETA  &N+1\n         AGO   .A\n.B       DC    XL1'FF'             END OF TABLE\n         SPACE 1\n         MEND\n         COPY  ETPSMACS            \"ETPS\" MACROS\n         COPY  ETPSDEFS            \"ETPS\" DEFINITIONS\n         PRINT ON\nETPSZAP  START 0\n         SPACE 1\nETPSZAP  AMODE 24\nETPSZAP  RMODE 24\n        MIDENT\n         EJECT\n*------- ZAP SELECT DATA-SET PROCESS --------------------------------*\n         PRINT GEN\n         USING *,R12,R11\n         USING SAVE2,R13      ************************** R13 ==> SAVE2\n         USING SPLTAREA,R10   AT ENTRY : R10 MUST POINT TO \"SPLTAREA\"\n         B     32(,R15)\n         DC    CL28'  ETPSZAP  &SYSDATE &SYSTIME'\n         PRINT &PRF\n         STM   R14,R12,12(R13)     SAVE INPUT REGISTERS\n         LR    R12,R15             SET PROGRAM BASE REGISTER 1\n         LA    R3,1\n         LA    R11,4*KB-1(R3,R12)  SET PROGRAM BASE REGISTER 2\n         LR    R3,R10              SPLIT-SCREEN DSECT\n         SH    R3,=Y(SPLITWRK-SAVE2) POINT TO SAVE2\n         ST    R13,4(,R3)          STORE BACKWARD POINTER\n         ST    R3,8(R13)           STORE FORWARD POINTER\n         LR    R13,R3              SET DSECT BASE\n         OI    ZAPPASS,C' '\n         CLI   ZAPPASS,C' '        IS THERE A GIVEN PASSWORD?\n         BNE   ZSCRBLD             YES\n         MVC   ZAPPASS,USERPASS    ELSE SET IT TO LOGON PASSWORD\n*- - - - BUILD ZAP SELECT ENTRY SCREEN\nZSCRBLD  L     R5,=A(ZAPSCR)\n         L     R4,SCROWS1          NUMBER OF ROWS IN SCREEN 1\n         LA    R3,TERMOUT+4        POINT TO FIRST LINE OF SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2\n         BNE   ZSCRBLD1            NOPE, I'M ALL SET\n         SLL   R4,2                MULTIPLY OFFSET BY 4\n         LA    R3,TERMOUT+4(R4)    POINT TO ROW 1 OF SCREEN 2\n         L     R4,SCROWS2          NUMBER OF ROWS IN SCREEN 2\nZSCRBLD1 NI    0(R3),255-EOS       CLEAR END-OF-SCREEN\n         L     R2,0(,R5)           ADDRESS OF FROM FIELD\n         L     R6,0(,R3)           ADDRESS OF \"TO\" FIELD\n         XR    R1,R1\n         IC    R1,0(,R2)           PICK UP LENGTH\n         EX    R1,ZSCRMVL          MOVE IT\n         CLC   ZAOFF1(10,R6),=CL10'FULLY-QUAL' DS-NAME?\n         BNE   ZSCRBLD2            NO\n         OI    ZAPDSNM,C' '\n         CLI   ZAPDSNM,C' '        IS THERE A DATA-SET NAME SPECIFIED?\n         BE    ZSCRBLD4            NO\n         MVC   ZASCF1(L'ZAPDSNM,R6),ZAPDSNM COPY CURRENT DATA-SET NAME\n         B     ZSCRBLD4            DO THE REST\nZSCRMVL  MVC   0(*-*,R6),0(R2)     <<EXECUTED>>\nZSCRBLD2 CLC   ZAOFF2(13,R6),=CL13'VOLUME SERIAL' VOL-SER?\n         BNE   ZSCRBLD3            NO\n         OC    ZAPVOL,=CL6' '\n         CLI   ZAPVOL,C' '         IS THERE A VOL-SER SPECIFIED?\n         BE    ZSCRBLD4            NO\n         MVC   ZASCF2(L'ZASCF2,R6),ZAPVOL  COPY CURRENT VOL-SER\n         B     ZSCRBLD4            DO THE REST\nZSCRBLD3 CLC   ZAOFF3(17,R6),=CL17'DATA-SET PASSWORD' PASSWORD?\n         BNE   ZSCRBLD4            NO\n         MVC   ZASCF3(L'ZASCF3,R6),ZAPPASS COPY CURRENT PASSWORD\n         CLI   ZAPPASS,C' '        IS THERE A PASSWORD SPECIFIED?\n         BE    ZSCRBLD4            NO\n         MVC   ZAOFF4(L'ZAOFF4,R6),=CL3'(I)' SAY IN\n         MVI   ZAOFF4-1(R6),X'05'  SET INTENS\nZSCRBLD4 TM    0(R5),EOL           END-OF-LIST?\n         BO    ZSCRBLD5            YUP\n         BCT   R4,*+L'*+4          END OF SCREEN ROWS?\n         B     ZSCRBLD6            YUP\n         LA    R5,4(R5)            BUMP TO NEXT PARM\n         LA    R3,4(R3)            BUMP TO NEXT PARM\n         B     ZSCRBLD1            KEEP LOOPING\nZSCRBLD5 BCT   R4,*+L'*+4          END OF SCREEN ROWS?\n         BZ    ZSCRBLD6            YUP\n         LA    R3,4(R3)            BUMP TO NEXT PARM\n         L     R6,0(,R3)           ADDRESS OF \"TO\" FIELD\n         NI    0(R3),255-EOS       CLEAR END-OF-SCREEN\n         MVC   0(ZDUMMYL,R6),ZDUMMY MOVE IN A DUMMY ROW\n         B     ZSCRBLD5            KEEP LOOPING\nZSCRBLD6 CLI   SPLIT,1             AM I IN SPLIT-SCREEN, SCREEN 1?\n         BE    *+L'*+4             YES\n         OI    0(R3),EOS           SET END-OF-SCREEN\n         L     R15,=A(ZAPHLP)      HELP SCREEN\n         ST    R15,HELPADD\n         MVI   CURROW,CRZASC       CURSOR ROW\n         MVI   CURCOL,CCZASC       CURSOR COLUMN\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         LTR   R15,R15             BAD RC?\n         BNZ   ZEXIT               YUP\n         TM    COMMSW,PFKFLAG      IS IT A PF KEY/ATTN?\n         BZ    ZACKINPT            NOPE, GO CHECK THE INPUT\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    ZEXIT               YUP, I'M DONE\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BE    ZEXIT               YUP, I'M DONE\n         CLI   0(R2),X'6C'         IS IT PA1?\n         BE    ZEXIT               YUP, I'M DONE\n         CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    ZSCRBLD             YUP, RESHOW SCREEN\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    ZSCRBLD             YUP, RESHOW SCREEN\n         LA    R1,ZINVPFK\nZASTMSG  ST    R1,MSGADD\n         B     ZSCRBLD             RESHOW SCREEN\n*- - - - CHECK ENTERED ZAP SELECTIONS\nZACKINPT L     R5,TERMINPT+ZIZ1    PICK UP DS-NAME FIELD\n         L     R6,TERMINPT+ZIZ2    PICK UP VOL-SER FIELD\n         L     R7,TERMINPT+ZIZ3    PICK UP PASSWORD FIELD\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   ZACKINPC            NOPE\n         L     R3,SCROWS1          PICK UP SIZE OF SCREEN 1\n         SLL   R3,2                MULTIPLY BY 4\n         L     R5,TERMINPT+ZIZ1(R3) PICK UP DS-NAME FIELD\n         L     R6,TERMINPT+ZIZ2(R3) PICK UP VOL-SER FIELD\n         L     R7,TERMINPT+ZIZ3(R3) PICK UP PASSWORD FIELD\nZACKINPC CLI   0(R5),0             DS-NAME ENTERED (OR CHANGED)?\n         BNE   *+L'*+16            YES\n         OI    ZAPDSNM,C' '\n         CLI   ZAPDSNM,C' '        DS-NAME ALREADY IN?\n         BNE   ZACVLSR             YES\n         B     ZSCRBLD             ELSE RETRY THE SCREEN\n         LA    R0,L'ZASCF1-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   ZASCF1(R5),C' '\n         BNE   ZADSNMV\n         MVC   ZASCF1(L'ZASCF1-1,R5),ZASCF1+1(R5)\n         MVI   ZASCF1+L'ZASCF1-1(R5),C' '\n         BCT   R0,*-18\n         MVC   ZAPDSNM(L'ZAPDSNM),ZASCF1(R5)\n         B     ZSCRBLD             RETRY THE SCREEN\nZADSNMV  MVI   ZAPDSNM,C' '        RESET DS-NAME FIELD\n         MVC   ZAPDSNM+1(L'ZAPDSNM-1),ZAPDSNM\n         LA    R0,L'ZAPDSNM        MAX. LENGTH FOR A DS-NAME\n         LA    R14,ZASCF1(R5)      START ADDRESS FOR DSN LENGTH CALC\n         XR    R15,R15             SET COUNTER\nZADSNLOP CLI   0(R14),C' '         BLANK IS END OF DSN?\n         BE    ZADSNEND            GOT END\n         CLI   0(R14),C'('         LEFT PAREN INDICATES MEMBER?\n         BE    ZADSNEND            YES, GOT END\n         LA    R14,1(R14)          BUMP ADDRESS\n         LA    R15,1(R15)          BUMP COUNTER\n         BCT   R0,ZADSNLOP         TEST NEXT BYTE IF ANY\n         LA    R1,ZBADDSN          ELSE ERROR\n         B     ZASTMSG\nZADSNEND BCT   R15,*+L'*+6         SUBTRACT 1\n         MVC   ZAPDSNM(*-*),ZASCF1(R5) <<EXECUTED>>\n         EX    R15,*-6\nZACVLSR  CLI   0(R6),0             VOL-SER ENTERED?\n         BE    ZACPSWD             NO\n         MVC   ZAPVOL,=CL6' '\n         LA    R0,L'ZASCF2-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   ZASCF2(R6),C' '\n         BNE   *+L'*+14\n         MVC   ZASCF2(L'ZASCF2-1,R6),ZASCF2+1(R6)\n         MVI   ZASCF2+L'ZASCF2-1(R6),C' '\n         BCT   R0,*-18\n         MVC   ZAPVOL(6),ZASCF2(R6) MOVE IN THE VOL-SER\nZACPSWD  CLI   0(R7),0             PASSWORD ENTERED?\n         BE    ZAGOCHK             NO\n         LA    R0,L'ZASCF3-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   ZASCF3(R7),C' '\n         BNE   *+L'*+14\n         MVC   ZASCF3(L'ZASCF3-1,R7),ZASCF3+1(R7)\n         MVI   ZASCF3+L'ZASCF3-1(R7),C' '\n         BCT   R0,*-18\n         MVC   ZAPPASS(L'ZAPPASS),ZASCF3(R7) MOVE IN THE PASSWORD\nZAGOCHK  CLC   ZAPDSNM(5),=CL5'VTOC '\n         BNE   ZAGOXEQ\n         OC    ZAPVOL,=CL6' '\n         CLI   ZAPVOL,C' '         IS THERE A VOL-SER SPECIFIED?\n         BNE   *+L'*+8             YES, OK\n         LA    R1,ZVLMISS          NO, MISSING\n         B     ZASTMSG\n         MVC   ZAPDSNM(12),=CL12'FORMAT4.DSCB'\nZAGOXEQ  MVI   ZAPLGDSN,C' '       CLEAR \"LOG\" DS-NAME\n         MVC   ZAPLGDSN+1(L'ZAPLGDSN-1),ZAPLGDSN\n         MVC   ZAPLGVOL(L'ZAPLGVOL),ZAPLGDSN CLEAR \"LOG\" VOL-SER\n         L     R15,=A(ETPSXZAP)\n*- - - - ETPSXZAP PARM.LIST : DS-NAME, VOL-SER, PASSWORD, LOG.DS-NAME,\n*                             LOG.VOL-SER\n        CALL   (15),(ZAPDSNM,ZAPVOL,ZAPPASS,ZAPLGDSN,ZAPLGVOL),VL,     X\n               MF=(E,PARMVL)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    ZOKRST              OK\n        XMESS  3010,R15            ERROR\n         LA    R1,ZGMMSG\n         ST    R1,MSGADD\nZOKRST   CLC   ZAPDSNM(12),=CL12'FORMAT4.DSCB'\n         BNE   ZLGTST\n         MVI   ZAPDSNM,C' '        CLEAR VTOC REQUEST\n         MVC   ZAPDSNM+1(L'ZAPDSNM-1),ZAPDSNM\n         MVC   ZAPVOL,=CL6' '\nZLGTST   CLI   ZAPLGDSN,C' '       IS THERE A \"LOG\" DS-NAME?\n         BE    ZSCRBLD             NO\n*- - - - BUILD ZAP LOG ENTRY SCREEN\n         NI    ZLGSW,255-ZLGVIEW-ZLGDEL-ZLGALT RESET ALL\nZLGSBLD  L     R5,=A(ZLGSCR)\n         L     R4,SCROWS1          NUMBER OF ROWS IN SCREEN 1\n         LA    R3,TERMOUT+4        POINT TO FIRST LINE OF SCREEN 1\n         CLI   SPLIT,2             AM I ON SCREEN 2\n         BNE   ZLGSBLD1            NOPE, I'M ALL SET\n         SLL   R4,2                MULTIPLY OFFSET BY 4\n         LA    R3,TERMOUT+4(R4)    POINT TO ROW 1 OF SCREEN 2\n         L     R4,SCROWS2          NUMBER OF ROWS IN SCREEN 2\nZLGSBLD1 NI    0(R3),255-EOS       CLEAR END-OF-SCREEN\n         L     R2,0(,R5)           ADDRESS OF FROM FIELD\n         L     R6,0(,R3)           ADDRESS OF \"TO\" FIELD\n         XR    R1,R1\n         IC    R1,0(,R2)           PICK UP LENGTH\n         EX    R1,ZLGSMVL          MOVE IT\n         CLC   ZLOFF1(8,R6),=CL8'LOG VIEW' VIEWING?\n         BNE   ZLGSBLD2            NO\n         TM    ZLGSW,ZLGVIEW       YES\n         BO    *+L'*+10\n         MVC   ZLSCF1(2,R6),=CL2'NO' SET \"NO\"\n         B     ZLGSBLD3            DO THE REST\n         MVC   ZLSCF1(3,R6),=CL3'YES' SET \"YES\"\n         B     ZLGSBLD3            DO THE REST\nZLGSMVL  MVC   0(*-*,R6),0(R2)     <<EXECUTED>>\nZLGSBLD2 CLC   ZLOFF2(8,R6),=CL8'AND / OR' DELETE?\n         BNE   ZLGSBLD3            NO\n         TM    ZLGSW,ZLGDEL        YES\n         BO    *+L'*+10\n         MVC   ZLSCF2(2,R6),=CL2'NO' SET \"NO\"\n         B     ZLGSBLD3            DO THE REST\n         MVC   ZLSCF2(3,R6),=CL3'YES' SET \"YES\"\nZLGSBLD3 TM    0(R5),EOL           END-OF-LIST?\n         BO    ZLGSBLD4            YUP\n         BCT   R4,*+L'*+4          END OF SCREEN ROWS?\n         B     ZLGSBLD5            YUP\n         LA    R5,4(R5)            BUMP TO NEXT PARM\n         LA    R3,4(R3)            BUMP TO NEXT PARM\n         B     ZLGSBLD1            KEEP LOOPING\nZLGSBLD4 BCT   R4,*+L'*+4          END OF SCREEN ROWS?\n         B     ZLGSBLD5            YUP\n         LA    R3,4(R3)            BUMP TO NEXT PARM\n         L     R6,0(,R3)           ADDRESS OF \"TO\" FIELD\n         NI    0(R3),255-EOS       CLEAR END-OF-SCREEN\n         MVC   0(ZDUMMYL,R6),ZDUMMY MOVE IN A DUMMY ROW\n         B     ZLGSBLD4            KEEP LOOPING\nZLGSBLD5 CLI   SPLIT,1             AM I IN SPLIT-SCREEN, SCREEN 1?\n         BE    *+L'*+4             YES\n         OI    0(R3),EOS           SET END-OF-SCREEN\n         L     R15,=A(ZLGHELP)     HELP SCREEN\n         ST    R15,HELPADD\n         TM    ZLGSW,ZLGALT        ALTERNATE POSITION?\n         BO    *+L'*+12            YES\n         MVI   CURROW,CRZLSC       CURSOR ROW\n         MVI   CURCOL,CCZLSC       CURSOR COLUMN\n         B     *+L'*+8\n         MVI   CURROW,CRALSC       ALTERNATE CURSOR ROW\n         MVI   CURCOL,CCALSC       ALTERNATE CURSOR COLUMN\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         LTR   R15,R15             BAD RC?\n         BNZ   ZEXIT               YUP\n         TM    COMMSW,PFKFLAG      IS IT A PF KEY/ATTN?\n         BZ    ZLCKINPT            NOPE, GO CHECK THE INPUT\n         L     R2,TERMINPT         PICK UP AID ADDRESS\n         CLI   0(R2),X'F3'         IS IT PF3?\n         BE    ZLCKINPT            YUP, LIKE ENTER\n         CLI   0(R2),X'C3'         IS IT PF15?\n         BE    ZLCKINPT            YUP, LIKE ENTER\n         CLI   0(R2),X'6C'         IS IT PA1?\n         BE    ZSCRBLD             YUP, FORCE LIKE NO VIEW / NO DELETE\n         CLI   0(R2),X'6D'         IS IT \"CLEAR\"?\n         BE    ZLGSBLD             YUP, RESHOW SCREEN\n         CLI   0(R2),X'6E'         IS IT PA2?\n         BE    ZLGSBLD             YUP, RESHOW SCREEN\n         LA    R1,ZINVPFK\nZLSTMSG  ST    R1,MSGADD\n         B     ZLGSBLD             RESHOW SCREEN\n*- - - - CHECK ENTERED ZAP LOG SELECTIONS\nZLCKINPT NI    ZLGSW,255-ZLGALT-ZLGPOC RESET ALTERNATE AND CHANGED\n         L     R5,TERMINPT+ZLZ1    PICK UP VIEWING FIELD\n         L     R6,TERMINPT+ZLZ2    PICK UP DELETE FIELD\n         CLI   SPLIT,2             AM I ON SCREEN 2?\n         BNE   ZLCKINPV            NOPE\n         L     R3,SCROWS1          PICK UP SIZE OF SCREEN 1\n         SLL   R3,2                MULTIPLY BY 4\n         L     R5,TERMINPT+ZLZ1(R3) PICK UP VIEWING FIELD\n         L     R6,TERMINPT+ZLZ2(R3) PICK UP DELETE FIELD\nZLCKINPV CLI   0(R5),0             VIEWING ENTERED (OR CHANGED)?\n         BE    ZLCKINPD            NO\n         OI    ZLGSW,ZLGPOC        YES, SAY PANEL OPTION CHANGED\n         LA    R0,L'ZLSCF1-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   ZLSCF1(R5),C' '\n         BNE   ZLSTVW\n         MVC   ZLSCF1(L'ZLSCF1-1,R5),ZLSCF1+1(R5)\n         MVI   ZLSCF1+L'ZLSCF1-1(R5),C' '\n         BCT   R0,*-18\nZRSTVW   NI    ZLGSW,255-ZLGVIEW   RESET VIEW REQUEST\n         B     ZLCKINPD\nZLSTVW   CLI   ZLSCF1(R5),C'N'\n         BE    ZRSTVW\n         CLI   ZLSCF1(R5),C'Y'\n         BE    *+L'*+8\n         LA    R1,ZINVOPT\n         B     ZLSTMSG\n         OI    ZLGSW,ZLGVIEW       SET VIEW REQUESTED\nZLCKINPD CLI   0(R6),0             DELETE ENTERED?\n         BE    ZLGOCHK             NO\n         OI    ZLGSW,ZLGPOC        YES, SAY PANEL OPTION CHANGED\n         LA    R0,L'ZLSCF2-1       LEFT JUSTIFY FIELD IF NEEDED\n         CLI   ZLSCF2(R6),C' '\n         BNE   ZLSTDL\n         MVC   ZLSCF2(L'ZLSCF2-1,R6),ZLSCF2+1(R6)\n         MVI   ZLSCF2+L'ZLSCF2-1(R6),C' '\n         BCT   R0,*-18\nZRSTDL   NI    ZLGSW,255-ZLGDEL    RESET DELETE REQUEST\n         B     ZLGOCHK\nZLSTDL   CLI   ZLSCF2(R6),C'N'\n         BE    ZRSTDL\n         CLI   ZLSCF2(R6),C'Y'\n         BE    *+L'*+12\n         OI    ZLGSW,ZLGALT\n         LA    R1,ZINVOPT\n         B     ZLSTMSG\n         OI    ZLGSW,ZLGDEL        SET VIEW REQUESTED\nZLGOCHK  TM    ZLGSW,ZLGPOC        ANY OPTION CHANGED?\n         BO    ZLGSBLD             YES, RESHOW\n         TM    ZLGSW,ZLGVIEW+ZLGDEL HOW SELECTION IS?\n         BZ    ZMKEPT              NO VIEW / NO DELETE\n         TM    ZLGSW,ZLGVIEW       VIEW REQUESTED?\n         BZ    ZBROWOK             NO\n         ICM   R15,B'1111',ARBROWSE YES, VERIFY BROWSE AVAILABLE?\n         BNZ   ZBROWOK             YES, OK\n        LOAD   EP=ETPSBROW,ERRET=ZLDBRERR\n         ST    R0,ARBROWSE         LOADED, OK\n*- - - - PROCESS THE ZAP LOG DATA-SET\nZBROWOK  L     R7,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R2,R7\n         LH    R3,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R2,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R7\n         MVC   DSNAME,ZAPLGDSN     DS-NAME\n         MVC   DSVOLSER,ZAPLGVOL   VOL-SER\n         MVC   DSSTATUS,=CL8'SHR'  SET DISP=SHR\n         TM    ZLGSW,ZLGDEL        DELETE REQUESTED?\n         BZ    *+L'*+12            NO\n         MVC   DSNDISP,=CL8'UNCATLG' YES, SET DISP=(SHR,UNCATLG,KEEP)\n         MVC   DSADISP,=CL8'KEEP'\n         L     R4,ACOPDCB          PICK UP LIBRARY ADDRESS\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DDNAME\n         MVC   0(ZSQDCBL,R4),ZSQDCB MOVE DCB SKELETON\n         MVC   DCBDDNAM-IHADCB(L'DCBDDNAM,R4),DDNAME SET BACK DDNAME\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    ZALLOK              OK\n        XMESS  3008\n         TM    ZLGSW,ZLGVIEW       VIEW REQUESTED?\n         BZ    *+L'*+8             NO\n         LA    R1,ZALVMSG          YES\n         B     ZASTMSG             YUP - ALL DONE\n         LA    R1,ZALUMSG\n         B     ZASTMSG             YUP - ALL DONE\nZALLOK   TM    ZLGSW,ZLGVIEW       VIEW REQUESTED?\n         BZ    ZFREEDS             NO\n         LA    R2,ZAPLGDSN         YES\n         LA    R3,=CL8' '\n         L     R15,ARBROWSE\n*- - - - ETPSBROW PARM.LIST : DCB, DS-NAME, MEMBER-NAME\n        CALL   (15),((R4),(R2),(R3)),VL,MF=(E,PARMVL)\nZFREEDS  LR    R0,R7               INITIALIZE DYNAMIC ALLOCATION WORK\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DDNAME\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    ZFREEOK             OK\n        XMESS  3009\n         TM    ZLGSW,ZLGVIEW       VIEW REQUESTED?\n         BZ    *+L'*+8             NO\n         LA    R1,ZFLVMSG          YES\n         B     ZASTMSG             YUP - ALL DONE\n         LA    R1,ZFLUMSG\n         B     ZASTMSG             YUP - ALL DONE\nZFREEOK  TM    ZLGSW,ZLGDEL        DELETE REQUESTED?\n         BO    ZDELDS              YES\nZMKEPT   LA    R1,ZLKMSG           NO, KEPT\n         B     ZASTMSG\nZDELDS   LR    R2,R7               INITIALIZE DYNAMIC ALLOCATION WORK\n         LH    R3,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R2,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R7\n         MVC   DSNAME,ZAPLGDSN     DS-NAME\n         MVC   DSVOLSER,ZAPLGVOL   VOL-SER\n         MVC   DSSTATUS,=CL8'SHR'  SET DISP=SHR\n         MVC   DSNDISP,=CL8'DELETE' SET DISP=(SHR,DELETE,DELETE)\n         MVC   DSADISP,=CL8'DELETE'\n         L     R4,ACOPDCB          PICK UP LIBRARY ADDRESS\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) GET DDNAME FOR USE\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    ZDLAOK              OK\n        XMESS  3008\n         LA    R1,ZALDMSG\n         B     ZASTMSG             YUP - ALL DONE\nZDLAOK   LR    R0,R7               INITIALIZE DYNAMIC ALLOCATION WORK\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',=CL8' '\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DDNAME\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BNZ   *+L'*+8             WITH ERROR\n         LA    R1,ZLDMSG           OK\n         B     ZASTMSG             YUP - ALL DONE\n        XMESS  3009\n         LA    R1,ZFLDMSG\n         B     ZASTMSG             YUP - ALL DONE\n         DROP  R7\nZLDBRERR STM   R0,R1,MESSPL        BROWSE IS UNAVAILABLE\n        XMESS  99,R15\n         LA    R1,ZBUMSG\n         B     ZASTMSG             YUP - ALL DONE\n*- - - - TERMINATE ZAP PROCESSING\nZEXIT    L     R13,4(R13)          PICK UP CALLING SAVE-AREA\n         LM    R14,R12,12(R13)     RESTORE CALLING REGISTERS\n         XR    R15,R15             SET RETRUN CODE\n         BR    R14                 NORMAL RETURN\n         SPACE 1\nZDUMMY   DC    AL1(ZDUMMYL-1),X'04',CL9' '\nZDUMMYL  EQU   *-ZDUMMY\nZBADDSN  MSG   'DS-NAME ERROR'\nZVLMISS  MSG   'VOLUME MISSING'\nZINVPFK  MSG   'INVALID PF-KEY'\nZLKMSG   MSG   'ZAP \"LOG\" KEPT'\nZGMMSG   MSG   'ZAP GETMAIN ERROR'\nZLDMSG   MSG   'ZAP \"LOG\" DELETED'\nZBUMSG   MSG   'BROWSE UNAVAILABLE'\nZFLVMSG  MSG   'FREE \"LOG\"/V FAILED'\nZFLUMSG  MSG   'FREE \"LOG\"/U FAILED'\nZFLDMSG  MSG   'FREE \"LOG\"/D FAILED'\nZALVMSG  MSG   'ALLOC \"LOG\"/V FAILED'\nZALUMSG  MSG   'ALLOC \"LOG\"/U FAILED'\nZALDMSG  MSG   'ALLOC \"LOG\"/D FAILED'\nZINVOPT  MSG   'INVALID OPTION (N/Y)'\n         PRINT &PRS\n        LTORG\n         PRINT &PRF\nZSQDCB  DCB    DSORG=PS,MACRF=(GM,PM),DDNAME=DUMMY,EODAD=*-*,SYNAD=*-*\nZSQDCBL  EQU   *-ZSQDCB\n         SPACE 1\n         DROP  R10,R11,R12,R13\n         EJECT\n*- - - - ZAP ENTRY SCREEN\n         CNOP  0,4\nZAPSCR   DC    A(ZAROW1)\n         DC    A(ZAROW2)\nCRZASC   EQU   (*-ZAPSCR)/4        CURSOR ROW ON LINE BELOW\nZIZ1     EQU   (*-ZAPSCR)+4        \"TERMINPT\" DISPLACEMENT\n         DC    A(ZAROW3)\nZIZ2     EQU   (*-ZAPSCR)+4        \"TERMINPT\" DISPLACEMENT\n         DC    A(ZAROW4)\n         DC    A(LNEBLK)\nZIZ3     EQU   (*-ZAPSCR)+4        \"TERMINPT\" DISPLACEMENT\n         DC    A(EML+ZAROW5)\n         SPACE 1\nZAROW1   DC    AL1(ZAROW1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL19' ZAP - ENTRY PANEL ',50CL1'-'\nZAROW1L  EQU   *-ZAROW1\nZAROW2   DC    AL1(ZAROW2L-1)\n         DC    XL1'05',CL30'ENTER/VERIFY PARAMETERS BELOW:'\n         DC    XL1'04',CL1' '\nZAROW2L  EQU   *-ZAROW2\nZAROW3   DC    AL1(ZAROW3L-1)\nZAOFF1   EQU   (*-ZAROW3)+1,10\n         DC    XL1'04',CL20'FULLY-QUALIFIED NAME',XL1'05',CL3'==>'\nCCZASC   EQU   (*-ZAROW3)          CURSOR COLUMN ON FIELD BELOW\nZASCF1   EQU   (*-ZAROW3)+1,54     INPUT FIELD 1\n         DC    XL1'02',CL54' '\nZAROW3L  EQU   *-ZAROW3\nZAROW4   DC    AL1(ZAROW4L-1)\nZAOFF2   EQU   (*-ZAROW4)+10,13\n         DC    XL1'04',CL22'         VOLUME SERIAL'\n         DC    XL1'05',CL3'==>'\nZASCF2   EQU   (*-ZAROW4)+1,6      INPUT FIELD 2\n         DC    XL1'02',CL6' '\n         DC    XL1'04',CL45'          (IF NOT CATALOGED)'\nZAROW4L  EQU   *-ZAROW4\nZAROW5   DC    AL1(ZAROW5L-1)\nZAOFF3   EQU   (*-ZAROW5)+6,17\n         DC    XL1'04',CL22'     DATA-SET PASSWORD'\n         DC    XL1'05',CL3'==>'\nZASCF3   EQU   (*-ZAROW5)+1,8      INPUT FIELD 3\n         DC    XL1'03',CL8' '      NO DISPLAY\n         DC    XL1'04',CL37'        (IF PASSWORD PROTECTED)'\nZAOFF4   EQU   (*-ZAROW5)+1,3\n         DC    XL1'04',CL3'(N)',XL1'04',CL1' '\nZAROW5L  EQU   *-ZAROW5\nLNEBLK   DC    AL1(LNEBLKL-1),XL1'04',CL9' ' SF = PROT\nLNEBLKL  EQU   *-LNEBLK\n         EJECT\n*- - - - ZAP ENTRY HELP SCREEN\n         CNOP  0,4\nZAPHLP   DC    A(ZAPHL1)\n         DC    A(HLPENT)\n         DC    A(ZAPHL2)\n         DC    A(ZAPHL3)\n         DC    A(ZAPHL4)\n         DC    A(LNEBLK)\n         DC    A(ZAPHL5)\n         DC    A(ZAPHL6)\n         DC    A(LNEBLK)\n         DC    A(EML+ZAPHL7)\n         SPACE 1\nZAPHL1   DC    AL1(ZAPHL1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL19' ZAP - ENTRY PANEL ',50CL1'-'\nZAPHL1L  EQU   *-ZAPHL1\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\nZAPHL2   DC    AL1(ZAPHL2L-1),XL1'05'\n         DC    C'THE ZAP PANEL PROVIDES FOR ENTERING THE DATA-SET NAME,X\n                WHICH MUST BE A'\nZAPHL2L  EQU   *-ZAPHL2\nZAPHL3   DC    AL1(ZAPHL3L-1),XL1'05'\n         DC    C'    FULLY-QUALIFIED DS-NAME (NEVER DELIMITED BY QUOTESX\n               ).'\nZAPHL3L  EQU   *-ZAPHL3\nZAPHL4   DC    AL1(ZAPHL4L-1),XL1'05'\n         DC    C'    A SPECIFIC VOL-SER MAY ALSO BE ENTERED, AND A PASSX\n               WORD.'\nZAPHL4L  EQU   *-ZAPHL4\nZAPHL5   DC    AL1(ZAPHL5L-1),XL1'05'\n         DC    C'TO ACCESS A VOLUME VTOC, TYPE AS DATA-SET NAME THE WORX\n               D \"VTOC\" AND FILL IN THE'\nZAPHL5L  EQU   *-ZAPHL5\nZAPHL6   DC    AL1(ZAPHL6L-1),XL1'05'\n         DC    C'    VOLUME SERIAL NUMBER YOU WANT.'\nZAPHL6L  EQU   *-ZAPHL6\nZAPHL7   DC    AL1(ZAPHL7L-1),XL1'05'\n         DC    C'PF3 RETURNS TO THE PRIMARY OPTION MENU PANEL.'\nZAPHL7L  EQU   *-ZAPHL7\nHLPENT   DC    AL1(HLPENTL-1),XL1'01',CL1' ',XL1'05',CL7' '\nHLPENTL  EQU   *-HLPENT\n         EJECT\n*- - - - ZAP LOG ENTRY SCREEN\n         CNOP  0,4\nZLGSCR   DC    A(ZLROW1)\n         DC    A(ZLROW2)\n         DC    A(LNEBLK)\nCRZLSC   EQU   (*-ZLGSCR)/4        CURSOR ROW ON LINE BELOW\nZLZ1     EQU   (*-ZLGSCR)+4        \"TERMINPT\" DISPLACEMENT\n         DC    A(ZLROW3)\n         DC    A(LNEBLK)\nCRALSC   EQU   (*-ZLGSCR)/4        ALTERNATE CURSOR ROW ON LINE BELOW\nZLZ2     EQU   (*-ZLGSCR)+4        \"TERMINPT\" DISPLACEMENT\n         DC    A(EML+ZLROW4)\n         SPACE 1\nZLROW1   DC    AL1(ZLROW1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL23' ZAP - ENTRY LOG PANEL ',46CL1'-'\nZLROW1L  EQU   *-ZLROW1\nZLROW2   DC    AL1(ZLROW2L-1)\n         DC    XL1'05',CL34'ENTER/VERIFY ZAP LOG REQUIREMENTS:'\n         DC    XL1'04',CL1' '\nZLROW2L  EQU   *-ZLROW2\nZLROW3   DC    AL1(ZLROW3L-1)\nZLOFF1   EQU   (*-ZLROW3)+11,8\n         DC    XL1'04',CL21'          LOG VIEWING',XL1'05',CL3'==>'\nCCZLSC   EQU   (*-ZLROW3)          CURSOR COLUMN ON FIELD BELOW\nZLSCF1   EQU   (*-ZLROW3)+1,3      INPUT FIELD 1\n         DC    XL1'02',CL3' ',XL1'04',C'(NO/N/YES/Y) '\nZLROW3L  EQU   *-ZLROW3\nZLROW4   DC    AL1(ZLROW4L-1)\nZLOFF2   EQU   (*-ZLROW4)+3,8\n         DC    XL1'04',CL21'  AND / OR LOG DELETE',XL1'05',CL3'==>'\nCCALSC   EQU   (*-ZLROW4)          ALTERNATE CURSOR COL. ON FIELD BELOW\nZLSCF2   EQU   (*-ZLROW4)+1,3      INPUT FIELD 2\n         DC    XL1'02',CL3' ',XL1'04',C'(NO/N/YES/Y) '\nZLROW4L  EQU   *-ZLROW4\n         EJECT\n*- - - - ZAP LOG ENTRY HELP SCREEN\n         CNOP  0,4\nZLGHELP  DC    A(ZLGHL1)\n         DC    A(HLPENT)\n         DC    A(ZLGHL2)\n         DC    A(ZLGHL3)\n         DC    A(LNEBLK)\n         DC    A(ZLGHL4)\n         DC    A(ZLGHL5)\n         DC    A(ZLGHL6)\n         DC    A(EML+ZLGHL7)\n         SPACE 1\nZLGHL1   DC    AL1(ZLGHL1L-1)\n         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT\n         DC    CL23' ZAP - LOG ENTRY PANEL ',46CL1'-'\nZLGHL1L  EQU   *-ZLGHL1\n*                ----+----1----+----2----+----3----+----4----+----5----\n*              +----6----+----7----+----\nZLGHL2   DC    AL1(ZLGHL2L-1),XL1'05'\n         DC    C'THE ZAP LOG PANEL ALLOWS TO VIEW THE SESSION LOGGING DX\n               ATA-SET (WHEN IT HAS'\nZLGHL2L  EQU   *-ZLGHL2\nZLGHL3   DC    AL1(ZLGHL3L-1),XL1'05'\n         DC    C'    BEEN CREATED), AND / OR DELETE IT (IF NEEDED, ELSEX\n                IT IS KEPT).'\nZLGHL3L  EQU   *-ZLGHL3\nZLGHL4   DC    AL1(ZLGHL4L-1),XL1'05'\n         DC    C'THE ZAP LOG DATA-SET IS ALWAYS NAMED AS FOLLOWS:'\nZLGHL4L  EQU   *-ZLGHL4\nZLGHL5   DC    AL1(ZLGHL5L-1),XL1'05'\n         DC    C'         <USER-ID>.ETPS.ZAPLOG.DYYDDD.THHMMSS.LIST'\nZLGHL5L  EQU   *-ZLGHL5\nZLGHL6   DC    AL1(ZLGHL6L-1),XL1'05'\n         DC    C'    WHERE \"YYDDD\" IS THE YEAR AND SERIAL DAY, AND'\nZLGHL6L  EQU   *-ZLGHL6\nZLGHL7   DC    AL1(ZLGHL7L-1),XL1'05'\n         DC    C'          \"HHMMSS\" IS THE TIME OF DAY.'\nZLGHL7L  EQU   *-ZLGHL7\n         EJECT\n*------- DISPLAY AND MODIFY DATA-SET --------------------------------*\n*        AT ENTRY, R1 = A(PARM.LIST) -> (DS-NAME,\n*                                        VOL-SER,\n*                                        PASSWORD,\n*                                        LOG.DS-NAME,\n*                                        LOG.VOL-SER)\n*                  AND R10 MUST POINT TO \"SPLTAREA\"\n         SPACE 1\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* REGISTERS USAGE : R0-R7...WORK REGISTERS                           *\n*                   R8......LOCAL LINK REGISTER                      *\n*                   R9......TS WORK-AREA POINTER                     *\n*                   R10.....3RD BASE REGISTER                        *\n*                   R11.....2ND BASE REGISTER                        *\n*                   R12.....1ST BASE REGISTER                        *\n*                   R13.....\"ETPS\" SAVE-AREA, ETC... POINTER         *\n*                   R14.....WORK AND RETURN ADDRESS                  *\n*                   R15.....WORK AND ENTRY POINT ADDRESS             *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nFPR0     EQU   0                   DEFINE FLOATING-POINT REGISTERS\nFPR2     EQU   2\nFPR4     EQU   4\nFPR6     EQU   6\n         SPACE 1\n         CNOP  0,4\n         USING *,R12,R11,R10\n         USING SAVE3,R13      ************************** R13 ==> SAVE3\nETPSXZAP STM   R14,R12,12(R13)     SAVE INPUT REGISTERS\n         LR    R12,R15             SET PROGRAM BASE REGISTER 1\n         LA    R2,1\n         LA    R11,4*KB-1(R2,R12)  SET PROGRAM BASE REGISTER 2\n         LR    R7,R10              SPLIT-SCREEN DSECT\n         USING SPLTAREA,R7\n         LR    R3,R7\n         LA    R10,4*KB-1(R2,R11)  SET PROGRAM BASE REGISTER 3\n         SH    R3,=Y(SPLITWRK-SAVE3) POINT TO SAVE3\n         ST    R13,4(,R3)          STORE BACKWARD POINTER\n         ST    R3,8(R13)           STORE FORWARD POINTER\n         LR    R13,R3              SET DSECT BASE\n         LR    R2,R1               RETAIN PARM ADDRESS\n         L     R9,=A(TSDSECTL)\n        GETMAIN RC,LV=(R9)         GET LOCAL WORK-AREA\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    *+L'*+14            OK\n         L     R13,4(,R13)         ERROR\n         ST    R15,16(R13)         SET ERROR RETURN CODE\n         LM    R14,R12,12(R13)     RESTORE ALL REGISTERS\n         BR    R14                 BYE BYE\n         LR    R0,R1\n         LR    R1,R9\n         LR    R9,R0\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R0,R14              CLEAR ALL TO BINARY ZEROS\n         USING TSDSECT,R9\n         MVC   EYECATCH,=CL8'EXEC.ZAP'\n         MVC   DDNALL,N#IN         DD-NAME'S TO BE USED\n         MVC   DDPALL,N#PRINT\n         DROP  R7\n         ST    R7,ASPLTA           SAVE IT FOR TERMINAL COMMUNICATION\n         LM    R3,R5,0(R2)         PICK UP FIRST THREE PARMS\n*                                  R3=DS-NAME ADDRESS\n*                                  R4=VOL-SER ADDRESS\n*                                  R5=PASSWORD ADDRESS\n         MVC   ZDSNME(L'ZDSNME),0(R3) GET THE DS-NAME\n         MVC   ZVOLSER(L'ZVOLSER),0(R4) GET THE VOL-SER\n         MVC   ZPSSWRD(L'ZPSSWRD),0(R5) GET THE PASSWORD\n*                                  COPY LAST TWO PARMS ADDRESSES\n         MVC   ZLGDSN(2*4),3*4(R2) \"LOG\" DS-NAME/VOL-SER ADDRESSES\n         NI    ZLGVOL,255-VLB      CLEAR \"VL\" BIT\n*- - - - DO INITIALIZATION.\n         MVC   ZUSRID,USERID       GET THE USER-ID\n         MVI   BLANKS,C' '\n         MVC   BLANKS+1(L'BLANKS-1),BLANKS\n         MVC   DISPDSN,ZDSNME      COPY FOR DISPLAYING\n         CLI   TUBEDDNM,C'T'       TSO TERMINAL?\n         BNE   *+L'*+4             NO\n         OI    FLAGSX,RUNTSO       YES\n         XC    CURPOS,CURPOS       CLEAR CURSOR POSITION\n         LA    R1,JFCB             -> JFCB\n         ST    R1,EXLST\n         MVI   EXLST,VLB+X'07'     CALL IT A JFCB\n         LA    R6,4095(,R9)        TEMPORARY POINT TO EXTRA\n         USING TSDSECT+4095,R6\n         LA    R0,IDEFTAB\n         ST    R0,AIDEFTAB\n         LA    R1,ITRTAB\n         ST    R1,AITRCTAB\n         MVI   0(R1),X'FE'         SET TO INITIAL VALUE\n         MVC   1((24*L'ITRTAB)-1,R1),0(R1) SET THE WHOLE THING\n         ST    R1,ITRAVAL          -> FIRST POS\n         ST    R1,CURRITR          -> CURRENT POS\n         MVI   ENDITAB,X'FF'       MARK THE END OF THE TABLE\n         MVI   ITREND,X'FF'        DITTO\n         LA    R0,ITREND           POINT TO IT\n         ST    R0,AITREND          SAVE\n         LA    R1,CSAREA           -> \"CSOUT\" WORK-AREA\n         ST    R1,CSALOC           SET ADDRESS\n         USING CSDATA,R1\n         LA    R0,CSOBUFF          LINE ADDRESS\n         ST    R0,CSLLOC           STORE IT\n         MVC   CSOBUFF,BLANKS      AND CLEAR LINE BEFORE ANY USE\n         DROP  R1\n         LA    R0,WSCREEN          SCREEN BUFFER ADDRESS\n         ST    R0,REGS3270         SET FOR COMMUNICATIONS\n         DROP  R6\n         L     R1,=A(DCBMSK)       GET ADDRESS OF PATTERN DCB\n         MVC   DCBU(DCBUL),0(R1)   SET UP DCB FOR INPUT\n         XC    ZIOB(IOBLEN),ZIOB   INIT. IOB\n         MVI   ZIOB,IOBCMDCH+IOBUNREL IOBFLAGS\n         LA    R0,ZECB             -> EXCP ECB\n         STCM  R0,B'0111',ZIOB+(IOBECBPB-IOBSTDRD)\n         LA    R0,DCBU\n         STCM  R0,B'0111',ZIOB+(IOBDCBPB-IOBSTDRD)\n         L     R1,=A(CCWLIST)      INIT. CCWS\n         MVC   CCWS(CCWL),0(R1)\n         LA    R0,CCHHR            POINTER FOR SEARCH ID EQ\n         STCM  R0,B'0111',CCW#R#S+1 SET ADRRESS\n         STCM  R0,B'0111',CCW#W#S+1 HERE TOO\n         STCM  R0,B'0111',CCW#F#S+1 HERE TOO\n         LA    R1,CCW#R#S          GET TIC ADDRESS\n         STCM  R1,B'0111',CCW#R#T+1 SET IT\n         LA    R1,CCW#W#S          GET TIC ADDRESS\n         STCM  R1,B'0111',CCW#W#T+1 SET IT\n         LA    R1,ZNAME            -> KEY\n         STCM  R1,B'0111',CCW#D#S+1 SET IT\n         LA    R1,CCW#D#S          GET TIC ADDRESS\n         STCM  R1,B'0111',CCW#D#T+1 SET IT\n         LA    R1,CCW#F#S          GET TIC ADDRESS\n         STCM  R1,B'0111',CCW#F#T+1 SET IT\n         MVC   WIDTHD(4),MAXWIDTH  SET WINDOW DOWN STANDARD VALUE\n         MVC   WIDTHU(4),MAXWIDTH  SET WINDOW UP STANDARD VALUE\n*- - - - CHECK WHICH KIND OF DATA-SET THE USER HAS SELECTED.\n         L     R1,=A(SSTAB)        SENSITIVE PREFIXES TABLE\nSSLOOP   CLI   0(R1),X'FF'\n         BE    CHKVTOC             NO MORE\n         XR    R15,R15\n         IC    R15,0(R1)\n         EX    R15,SSCHECK         IT IS THIS ONE?\n         BE    STSNSF              IF YES MARK IT\n         LA    R1,2(R1,R15)        ELSE BUMP TO NEXT\n         B     SSLOOP\nSSCHECK  CLC   ZDSNME(*-*),1(R1)   <<EXECUTED>>\nCHKVTOC  CLC   ZDSNME(12),=CL12'FORMAT4.DSCB' VTOC?\n         BNE   NOTVTOCR            NO\n         MVI   ZDSNME,X'04'        YES, CHANGE DS-NAME TO ALL X'04'\n         MVC   ZDSNME+1(L'ZDSNME-1),ZDSNME\n         MVC   DISPDSN,BLANKS      RESET FIELD\n         MVC   DISPDSN(8),=CL8'VTOC FOR' SHOW SOMETHING GOOD\n         MVC   DISPDSN+9(6),ZVOLSER MOVE IN VOLUME NAME\nSTSNSF   OI    FLAGSX,SENSF        MARK AS SENSITIVE\nNOTVTOCR OI    FLAGSG,GODUP        ASSUME HE CAN UPDATE\n*- - - - SET UP DEFAULTS AND INITIALS COND'S.\n         L     R1,=A(TRCHARE)      INITIALIZE POINTER TO...\n         ST    R1,TRTABADD         TR TABLE (THE EBCDIC ONE)\n         XC    TRTXTAB,TRTXTAB\n         LA    R1,LINE06           POINT TO FIRST AVAIL SCREEN LOC\n         ST    R1,FIRSTSCR         SAVE IT\n         LA    R1,MSGLINE          POINT TO LAST AVAIL SCREEN LOC\n         ST    R1,MAXSCR           SAVE IT\n         XC    LOOKFOR(3*18),LOOKFOR CLEAR SCAN STRING WORK-AREA\n         XC    MEMTTR,MEMTTR       NO MEMBER YET\n         XC    TXTTTR,TXTTTR       NO TEXT FOR MEMBER YET\n         XC    ESDTTR,ESDTTR       NO ESD POINTER YET\n         MVC   ESDID(2),=H'1'      ESDID DEFAULTS TO 1 FOR IBM\n         MVI   TCONT,0             NO SCAN, STORES OR SETS YET\n         NI    FLAGSR,255-YESCSERR \"CSOUT\" WILL WORK FOR SURE\n         BAL   R8,CLEARDEF         INITIALIZE IDEF TABLE AND PTRS\n         MVC   TTR,=XL4'00000100' INITIALIZE TTRN\n*- - - - ALLOCATE THE DATA-SET AND OPEN IT, UPDAT RIGHT OFF THE BAT.\n         L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',BLANKS\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         MVC   DDNAME,DDNALL       DDNAME\n         CLI   ZDSNME,X'04'        VTOC?\n         BNE   ALLDSN              NO\n         MVC   DSUNIT,=CL8'SYSALLDA' YES, SET UNIT= (A DIRECT ACCESS)\n         MVC   DSSTATUS,=CL8'OLD ' SET DISP=OLD (JUST ALLOC. VOLUME)\n         B     DODSALL\nALLDSN   MVC   DSNAME,ZDSNME       DS-NAME\n         MVC   PASSWORD,ZPSSWRD    PASSWORD\n         MVC   DSSTATUS,=CL8'SHR ' SET DISP=(SHR,KEEP,KEEP)\n         MVC   DSNDISP,=CL8'KEEP '\n         MVC   DSADISP,=CL8'KEEP '\nDODSALL  MVC   DSVOLSER,ZVOLSER    VOL-SER\n         DROP  R2\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    OKDSN               OK\n         CH    R15,=H'4'\n         BNE   ERRDYN\n         CL    R0,=A(X'17080000')\n         BNE   ERRDYN\n         LA    R1,NFDMSG           DS-NAME NOT FOUND (NOT ALLOCATED)\n         B     XCSIO\nERRDYN  XMESS  3001                ERROR\n         LA    R1,AZFMSG\n         B     XCSIO\nOKDSN    OI    FLAGSG,GODALL       SET ALLOCATED\n         LA    R0,DCBU             POINT TO DCB\n         ST    R0,DCBLIST          PUT IN OPEN/CLOSE LIST\n         MVI   DCBLIST,VLB+0       MARK \"VL\" & INPUT\n         MVC   DCBU+DCBDDNAM-IHADCB(L'DCBDDNAM),DDNALL DDNAME\n         LA    R0,EXLST            SET UP FOR RDJFCB\n         STCM  R0,B'0111',DCBU+DCBEXLSA-IHADCB SET IN DCB\n        RDJFCB MF=(E,DCBLIST)      GET THE JFCB\n         L     R1,EXLST            -> JFCB\n         USING JFCDSECT,R1\n         MVC   JFCBDSNM,ZDSNME     MAYBE CHANGE THE DSN\n         CLI   JFCBDSNM,X'04'      VTOC?\n         BNE   *+L'*+4             NO\n         OI    JFCBTSDM,JFCNWRIT   YES, INHIBIT WRITE BACK\n         DROP  R1\n        OPEN   MF=(E,DCBLIST),TYPE=J OPEN THE DATA-SET\n         TM    DCBU+DCBOFLGS-IHADCB,DCBOFOPN DID IT OPEN?\n         BO    OKOPN               YES\n         LA    R1,OZFMSG           NO\n         B     XCSIO\n*- - - - GET VOLUME SERIAL NUMBER.\nOKOPN    OI    FLAGSG,GODOPN       SET OPENED\n         XR    R3,R3\n         ICM   R3,B'0111',DCBU+DCBDEBA-IHADCB GET THE DEB POINTER\n         L     R3,(DEBBASND-DEBBASIC)+(DEBUCBAD-DEBDASD)(R3) UCB\n         MVC   ZVOLSER(L'ZVOLSER),SRTEVOLI-UCB(R3) SAVE VOL=SER OF DS\n         CLI   ZDSNME,X'04'        VTOC?\n         BNE   OKVOLSER            NO, OK\n         CLI   DISPDSN+9,C' '      HAVE THE VOL ALREADY?\n         BNE   OKVOLSER            YES, SKIP\n         MVC   DISPDSN+9(L'ZVOLSER),ZVOLSER NO, FILL IT IN\n*- - - - FIND THE LAST TTR FROM THE FORMAT 1 DSCB OF THE DATA-SET,\n*              OBTAINED, CLEVERLY ENOUGH, BY AN 'OBTAIN' (ASSUMING\n*              IT'S NOT A VTOC).\nOKVOLSER XC    ENDTTR,ENDTTR       SAY NO LAST TTR FOR DEFAULT\n         XC    DSCB(256),DSCB      CLEAR OUT DEFAULT DSCB\n         MVI   ZDSORG,0            SAY NOT PARTITIONED FOR NOW\n         MVC   DSCBLIST(OBTLISTL),OBTLIST\n         LA    R14,ZDSNME          DS-NAME FOR OBTAIN\n         LA    R15,ZVOLSER         POINT TO VOL-SER\n         LA    R0,DS1FMTID         DSCB BUFFER\n         STM   R14,R0,DSCBLIST+4   STORE ALL 3 POINTERS\n        OBTAIN DSCBLIST            GET THE FMT1 DSCB\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    GETLTTR             IF OK, USE INFO\n         LA    R1,OBTMSG           ELSE ERROR\n         B     XCSIO\nGETLTTR  CLI   ZDSNME,X'04'        VTOC?\n         BE    GOTVTOC             YES, GET INFO\n         MVC   VBLKSZ,DS1BLKL      NO, SET BLKSIZE OF DATA-SET\n         MVC   VLRECL,DS1LRECL     SET LRECL OF DATA-SET\n         XR    R0,R0\n         IC    R0,DS1KEYL\n         STH   R0,KEYLEN           SET KEY-LENGTH OF DATA-SET\n         MVC   ZDSORG(1),DS1DSORG  SAVE DSORG FOR M\n         MVC   ENDTTR,DS1LSTAR     SAVE IT\n         CLI   DS1NOEPV,0          ANY EXTENTS?\n         BNE   OKACC               YES\n         LA    R1,DSNXMSG          NO, CAN'T ACCESS\n         B     XCSIO\nOKACC    TM    DS1OPTCD,DS1OPTIC   YES, ICF DATA-SET?\n         BZ    NOLAST              NO\n         TM    FLAGSX,SENSF        SENSITIVE DATA-SET?\n         BO    NOLAST              YES\n         OI    FLAGSX,SENSF        NO, MARK AS SENSITIVE\n         B     NOLAST\nGOTVTOC  MVC   VBLKSZ,=AL2((DS4END-DSCB)-L'DS1DSNAM) SET VTOC BLKSIZE\n         LA    R0,L'DS1DSNAM\n         STH   R0,KEYLEN           SET KEY-LENGTH OF VTOC\n         MVI   ZDSORG,0            NO DSORG\n         MVC   LASTFMT1(5),DS4HPCHR SAVE POINTER TO LAST FMT1 USED\nNOLAST   LH    R0,VBLKSZ           PICK UP BLKSIZE\n         LTR   R0,R0               IS IT ZERO (LIKE JOBQ)?\n         BP    *+L'*+4             NO, GO ON\n         LH    R0,=AL2(20*KB)      USE 20K FOR DEFAULT IN CASE\n         CH    R0,=H'264'          BELOW MIN (ESP PDS DIRECTORY)\n         BNL   *+L'*+4             NO, LEAVE BLKSIZE AS IS\n         LH    R0,=H'264'          YES, SET MIN=PDS DIRECTORY SIZE\n         AH    R0,KEYLEN           ADD TO BUFFER SIZE\n         AH    R0,=Y(8+1)          GET ROOM FOR COUNT\n*              THE +1 IS SO WILL ALWAYS HAVE RESIDUAL.\n         LR    R1,R0               COPY VALUE\n         STH   R1,BUFFSIZE         STORE AWAY FOR LATER USE\n         STH   R1,CCW#R#R+6        SET FOR MAX READ\n         STH   R1,CCW##R0+6        DITTO FOR R0\n         AH    R0,=H'57'           SO NO 0C4'S NEAR BUFF. END\n         SRL   R0,3                ROUND UP TO DOUBLE-WORD\n         SLL   R0,3\n         ST    R0,ZBUFFL           SAVE BUFFER AREA LENGTH\n        GETMAIN R,LV=(0)           GET BUFFER AREA\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    GOTBUFF             OK\n        XMESS  3011,R15            ERROR\n         LA    R1,GMBMSG\n         B     XCSIO\nGOTBUFF  ST    R1,ZBUFFA           SAVE BUFFER AREA ADDRESS FOR LATER\n         ST    R1,ADDRCNT          SAVE ADDRESS OF COUNT\n         STCM  R1,B'0111',CCW#R#R+1\n         STCM  R1,B'0111',CCW##R0+1\n         STCM  R1,B'0111',CCW#F#W+1\n         LA    R1,8(,R1)           -> KEY FIELD\n         ST    R1,ADDRKEY          SAVE ADDRESS OF KEY\n         ST    R1,ADDRBUFF         DEFAULT DISPLAY IS KEY\n         STCM  R1,B'0111',CCW#W#W+1\n         STCM  R1,B'0111',CCW#D#R+1\n*- - - - NOW CHECK OUT THE USER. IF HE CAN'T GET IN, OR\n*              CAN'T TOUCH THE DATA-SET, KICK HIM OUT.\n         TM    FLAGSX,SENSF        SENSITIVE DATA-SET?\n         BZ    GETFDTS             NO\n         TM    FLAGSX,RUNTSO       YES, TSO TERMINAL?\n         BO    *+L'*+12            YES\n         OI    FLAGSL,LOGFS        NO, LOGGING FORCED\n         BAL   R8,LOGTEST          OPEN \"LOG\", WE MUST LOGGING\n         B     GETFDTS\n         TM    STATSW,SPCLFLG      USER HAS SPECIAL ATTRIBUTE?\n         BO    GETFDTS             YES, OK\n         NI    FLAGSG,255-GODUP    NO, KILL HE CAN UPDATE\n*- - - - GET FREE DEFINE TABLE SYMBOLS FOR\n*              'LRECL', 'KEY-LENGTH' AND 'BLKSIZE'.\nGETFDTS  L     R3,AIDEFTAB         POINT TO DEFINE TABLE\n         MVI   DEFSYM(R3),C'L'     GIVE SYMBOL 'L' FOR 'LRECL'\n         MVC   DEFOFF(L'DEFOFF,R3),VLRECL GET LRECL, PUT IN TAB\n         LA    R3,L'IDEFTAB(R3)    UPDATE DEFINE TABLE POINTER\n         MVC   DEFSYM(2,R3),=CL2'BL' GIVE 'BL' FOR 'BLKSIZE' (MAX)\n         MVC   DEFOFF(L'DEFOFF,R3),VBLKSZ GET BLKSIZE, PUT IN TAB\n         LA    R3,L'IDEFTAB(R3)    UPDATE DEFINE TABLE POINTER\n         MVI   DEFSYM(R3),C'K'     GIVE 'K' FOR KEY-LENGTH' SYMBOL\n         MVC   DEFOFF(L'DEFOFF,R3),KEYLEN GET KEY-LENGTH, PUT IN TAB\n         LA    R3,L'IDEFTAB(R3)    UPDATE DEFINE TABLE POINTER\n         ST    R3,IDEFAVAL         SAVE IT AS POINTER TO CURR ENTRY\n         MVC   REPLINE,BLANKS      CLEAR REPLY OUT\n         MVC   ICREP,REPLINE\n         MVI   CAPSFLG,YESCAPS\n         MVC   MSGLINE,BLANKS      CLEAR ERR-MSG PART OF SCREEN\n         XC    BASEVAL,BASEVAL     BASE = 0\n*- - - - CREATE THE SCREEN DISPLAY AND GET COMMAND.\n*              HERE IF A NEW BLOCK IS TO BE READ AND\n*              THE SCREEN IS TO BE BUILT FROM IT.\nNEW$READ XC    NOWSTUFF(NOWLEN-L'BASEVAL),NOWSTUFF RESET BUFFER OFF\n         BAL   R8,READBLK          GET A BLOCK FROM DATA-SET (BDAM)\n         B     NEW$DISP            SKIP AROUND\n*- - - - HERE IF BUILD SCREEN WITHOUT READING A NEW BUFFER IN.\nNEWDSPNT NI    FLAGSR,255-YESTRACE SET NOTRACE\nNEW$DISP BAL   R8,CLEAR            CLEAR THE SCREEN\n         OC    BLKLEN(2),BLKLEN    NO READ BEFORE?\n         BZ    DISPLYT             YES, THERE'S NOTHING TO DISP\n         LH    R8,OLDPOINT         GET CARET OFFSET\n         N     R8,=F'-16'          GET HIGH PART\n         LR    R5,R8               COPY\n         SH    R8,=H'96'           BACK UP TO SCREEN START (6*16)\n         BNM   *+L'*+2             CONTINUE IF OK\n         XR    R8,R8               SCREEN START = BLOCK START\n         A     R8,ADDRBUFF         GET ADDRESS INTO BUFFER\n         A     R5,ADDRBUFF         GET DBLW ADDRESS INTO BUFFER\n         L     R15,FIRSTSCR        POINT TO FIRST AVAIL SCREEN POS\n*- - - - FORMAT ONE LINE OF SCREEN DISPLAY.\nFORMAT   LR    R0,R8               COPY BUFFER POINTER\n         S     R0,ADDRBUFF         OFFSET INTO BUFFER FOR SCREEN\n         ST    R0,TEMP2            SAVE FOR UNPK\n        @HEX   (0,R15),TEMP2+1,LEN=3,DIGITS=5\n         MVC   TEMP2(16),0(R8)     COPY CHAR FORM OF DATA\n         UNPK  TEMP3+00(14+1),TEMP2+00(7+1) BYTES 01-07\n         UNPK  TEMP3+14(14+1),TEMP2+07(7+1) BYTES 08-14\n         UNPK  TEMP3+28(04+1),TEMP2+14(2+1) BYTES 15-16\n         TR    TEMP3(32),HEXTAB    MAKE EBCDIC\n         L     R1,TRTABADD         GET RIGHT TRTAB POINTER\n         TR    TEMP2(16),0(R1)     MAKE IT VALID CHARS\n         LR    R1,R0               COPY BLK OFFSET\n         AH    R1,=H'16'           GET NEXT OFFSET\n         SH    R1,BLKLEN           COMPUTE AMOUNT SHORT\n         BNP   FORMATOK            SKIP IF THIS LINE FULL\n         LA    R14,TEMP3           -> AREA\n         AH    R14,=H'32'          -> PAST END\n         LA    R2,0(R1,R1)         GET LENGTH OF HEX GARBAGE\n         SR    R14,R2              -> GARBAGE HEX\n         EX    R2,FMTBLANK         BLANK THE GARBAGE HEX\n*              NOTE THAT TEMP3 IS LONG ENOUGH THAT BLANKING\n*              1 CHAR TOO MANY DOESN'T HURT ANYTHING.\n         LA    R14,TEMP2           -> CHARS\n         AH    R14,=H'16'          -> PAST END\n         SR    R14,R1              -> GARBAGE CHARS\n         BCTR  R1,0                -1 FOR EX\n         EX    R1,FMTBLANK         CHARS ALSO GET TREATMENT\nFORMATOK MVC   TEMP3+32(2),=CL2' |' MOVE IN CONSTANTS FOR TR\n         MVC   7(DSPTRTL,R15),DSPTRT MOVE IN \"TRANSLATE\" TABLE\n         TR    7(DSPTRTL,R15),TEMP2 DISTRIBUTE HEX TO SCREEN\n         CLR   R8,R5               BUFFER POINTER = DATA POINTER?\n         BNE   NO$CARET            NO, SKIP CARET\n         LR    R1,R15              COPY LINE ADDRESS\n         BCTR  R1,0                BACK UP TO ATTR BYTE\n         MVI   0(R1),X'F8'         HIGH INTENSITY PROTECTED\n         LH    R1,OLDPOINT         GET CARET OFFSET\n         N     R1,=F'15'           GET LOW ORDER PART\n         LA    R3,TBYTES(R1)       POINT TO COLUMN OF SCREEN\n         IC    R1,0(,R3)           GET SCREEN COL FOR CARET\n         LA    R14,0(R15,R1)       POINT TO WHERE IT GOES\n         MVI   0(R14),C'>'         ASSUME EVEN\n         TM    OLDPOINT+1,X'01'    IS IT?\n         BZ    *+L'*+4             YES, SKIP\n         MVI   0(R14),C'<'         ODD POINTS THE OTHER WAY\n         ST    R14,MIDLINE         SAVE POINTER TO CARET LINE\nNO$CARET AH    R8,=H'16'           UPDATE BUFFER POINTER\n         LA    R15,$I(,R15)        UPDATE SCREEN POINTER\n         AH    R0,=H'16'           NEXT OFFSET\n         CH    R0,BLKLEN           PAST END OF BLOCK?\n         BNL   DISPLYT             YES, GO DISPLAY\n         CL    R15,MAXSCR          OUT OF SCREEN?\n         BL    FORMAT              NO, DO ANOTHER LINE\n         B     DISPLYT             SKIP (WE WILL TRACE)\nFMTBLANK MVC   0(*-*,R14),BLANKS   <<EXECUTED>>\nDISPLYNT NI    FLAGSR,255-YESTRACE SET NOTRACE\nDISPLYT  MVI   TTR+3,NOSEQRD       TURN OFF SEQ READ\n         OI    FLAGSR,YESEOF       SAY EOF'S WILL BE RECOGNIZED\n         MVC   LINE03(40),=CL40'ENTER VALID COMMAND ABOVE OR ? FOR HELPX\n                '\n         MVC   LINE03+L'LINE03-24(24),=CL24'VERSION : ETPS &VNUM..&VMODX\n                (&VIDT)'\nWHEREAMI MVC   LINE20+00(4),=CL4'OFF:'\n         LH    R15,OLDPOINT        GET OFFSET IN BUFFER\n         BAL   R14,NUMCONV         CONVERT IT\n         MVC   LINE20+05(4),TEMP3+12+4 MOVE IN HEX PART\n         MVI   LINE20+10,C'('\n         MVC   LINE20+11(6),TEMP3+6 DECIMAL PART\n         MVC   LINE20+17(7),=CL7') ADDR:'\n         L     R15,OFFSET          GET IT\n         BAL   R14,NUMCONV         CONVERT\n         MVC   LINE20+25(5),TEMP3+12+3 HEX PART\n         MVI   LINE20+31,C'('\n         MVC   LINE20+32(8),TEMP3+4 DECIMAL PART\n         MVC   LINE20+40(6),=CL6') DSN:'\n         MVC   LINE20+47($L-47),DISPDSN DATA-SET NAME\n         MVC   LINE21+00(4),=CL4'LEN:'\n         LH    R15,BLKLEN          GET LENGTH OF BLOCK\n         BAL   R14,NUMCONV         CONVERT\n         MVC   LINE21+05(4),TEMP3+12+4 HEX PART\n         MVI   LINE21+10,C'('\n         MVC   LINE21+11(6),TEMP3+6 DECIMAL PART\n         MVC   LINE21+17(7),=CL7') BASE:'\n         L     R15,BASEVAL         BASE\n         BAL   R14,NUMCONV         CONVERT\n         MVC   LINE21+25(5),TEMP3+12+3 HEX PART\n         MVI   LINE21+31,C'('\n         MVC   LINE21+32(8),TEMP3+4 DECIMAL PART\n         MVC   LINE21+40(8),=CL8') CCHHR:'\n         UNPK  LINE21+49(10+1),CCHHR\n         TR    LINE21+49(10),HEXTAB MAKE IT EBCDIC\n         MVC   LINE21+59(5),=CL5' TTR:'\n        @HEX   LINE21+66,TTR,LEN=3\n*- - - - DISPLAY SCREEN JUST MADE.\n*              (CREATE TRACE TABLE ENTRY IF NECESSARY)\n         MVC   PREVREP,REPLINE     SAVE FOR TWICE TEST\n         TM    FLAGSR,YESTRACE     TRACE FOR THIS GUY?\n         BZ    NOTRACIT            NO, SO DONT\n*              MAKE THE TRACE TABLE ENTRY.\n         L     R1,ITRAVAL          PICK UP NEXT SPOT IN TABLE\n         CLI   0(R1),X'FF'         END?\n         BNE   MORETAB             NO, THERE'S MORE\n         L     R1,AITRCTAB         YES, START OVER AT TOP\n         ST    R1,ITRAVAL          AND RESET AVAIL POS POINTER\nMORETAB  MVC   ITRTTR(L'ITRTTR,R1),TTR MOVE TTR TO TABLE\n         MVC   ITROFF(L'ITROFF,R1),OLDPOINT AND OFFSET TOO\n         ST    R1,CURRITR          SAVE POINTER TO CURR TRACE ENTRY\n         LA    R1,L'ITRTAB(R1)     UPDATE AVAIL POINTER\n         ST    R1,ITRAVAL          SAVE IT\nNOTRACIT OI    FLAGSR,YESTRACE     MAKE IT TRACE AGAIN\n*              THIS HUNK OF CODE MOVE DOWN HERE\n*              FROM SOMEWHERE IN \"DISPLAY\".\n         MVI   LINE01,C'-'         BUILD THE TOPLINE\n         MVC   LINE01+1(L'LINE01-1),LINE01\n         MVC   LINE01+34(11),=CL11'  Z  A  P  '\n         L     R0,REGS3270         CLEAR THE SCREEN BUFFER\n         L     R1,=A(WSCREENL)\n         LR    R4,R0               RETAIN SCREEN BUFFER START ADDRESS\n         LA    R2,*\n         XR    R3,R3\n         MVCL  R0,R2\n         TM    FLAGSX,RUNTSO       ARE WE RUNNING IN TSO?\n         BZ    *+L'*+8             NO\n         MVI   0(R4),X'27'         YES, SET TSO WRITE SEQUENCE\n         LA    R4,1(R4)            BUMP BUFFER POINTER\n         MVI   0(R4),X'7E'         ERASE-WRITE-ALTERNATE\n         MVI   1(R4),X'C3'         WCC = RESET KB + RESET MDT\n         LA    R4,2(R4)            BUMP BUFFER POINTER\n         LA    R3,CTL3270          SBA'S ADDRESS TABLE\n         LA    R2,NL3270           NUMBER OF SCREEN LINES TO BUILD\n         LA    R1,LINE01-2         POINT TO FIRST LINE\nSCLOOP   MVI   0(R4),X'11'         SET SBA ORDER\n         MVC   1(L'CTL3270,R4),0(R3) SET ADDRESS OF THIS LINE\n         MVC   1+L'CTL3270($I,R4),0(R1) COPY LINE\n         LA    R1,$I(R1)           BUMP POINTER TO NEXT LINE\n         LA    R4,$I+L'CTL3270(R4) POINT TO END OF LINE TEXT IN BUFFER\n         LA    R0,$L               LINE TEXT LENGTH\n         CLI   0(R4),C' '          ELIMINE FINAL BLANKS\n         BNE   *+L'*+6\n         BCTR  R4,0\n         BCT   R0,*-10\n         LA    R4,1(R4)            ADJUST BUFFER POINTER\n         LA    R3,L'CTL3270(R3)    BUMP SBA POINTER\n         BCT   R2,SCLOOP\n         MVC   0(L'END3270,R4),END3270 FINISH IT\n         LA    R4,L'END3270(R4)    BUMP BUFFER POINTER\n         SL    R4,REGS3270         COMPUTE WRITE TUBE LENGTH\n         ST    R4,REGS3270+4       STORE IT\nIOFULL   LM    R0,R1,REGS3270      GET THE WRITE TUBE REGISTERS\n         L     R10,ASPLTA          SET R10 = NEEDED ADDRESS\n         OI    COMMSW,EXTSBP       SAY I PROCESS MYSELF\n         L     R15,ARCOMM          GO COMMUNICATE\n*- - - - ETPSCOMM PARM.LIST : NONE\n        CALL   (15)\n         NI    COMMSW,255-EXTSBP   RESET IMMEDIATELY\n         LA    R10,2*KB(,R11)      RESTORE PROGRAM BASE REGISTER 3\n         LA    R10,2*KB(,R10)\n         B     *+L'*(R15)          HOW COMPLETE?\n         B     IODONE               0 - OK\n         B     IOWRER               4 - WRITE ERROR\n         B     IORDER               8 - READ ERROR\n         B     IOTPER              12 - TPUT ERROR\n         B     IOTGER              16 - TGET ERROR\nIOWRER  XMESS  3003\n         LA    R1,IOWRMSG\n         B     XCSIO\nIORDER  XMESS  3004\n         LA    R1,IORDMSG\n         B     XCSIO\nIOTPER  XMESS  3005,R0\n         LA    R1,IOTPMSG\n         B     XCSIO\nIOTGER  XMESS  3006,R0\n         LA    R1,IOTGMSG\n         B     XCSIO\nIODONE   LA    R15,L'REPX          MAX. INPUT BUFFER LENGTH\n         CLR   R0,R15\n         BNH   OKIODO\n        XMESS  3007                RESPONSE IS TOO LONG...\n         TM    FLAGSX,RUNTSO       TSO TERMINAL?\n         BZ    *+L'*+2             NO\n         DC    H'0'                YUP, TAKE AN S0C1 <------------ DUMP\n         LA    R2,RTLMSG           POINT TO MESSAGE\n         B     BOTCH               RESUME IF \"GO\" FROM TEST\nOKIODO   LTR   R0,R0               IF 0 SET AT LEAST 1\n         BP    *+L'*+4\n         LA    R0,1\n         LA    R14,REPX\n         LR    R15,R0\n         LR    R2,R1\n         LR    R3,R0\n         MVCL  R14,R2              MOVE RESPONSE IN BUFFER\n         LR    R1,R0\n         CLI   REPX,X'6C'          PA1? (CANCEL?)\n         BE    CANEX               YUP, LEAVE IMMEDIATELY\n         CLI   REPX,X'6D'          CLEAR? (RESHOW?)\n         BE    IOFULL              YES, GO DO IT\n         CLI   REPX,X'6E'          PA2? (RESHOW?)\n         BE    IOFULL              YES, GO DO IT\n         CLI   REPX,X'7D'          ENTER?\n         BE    ENTKEY              YES, BYPASS PFK\n         OI    REPX,X'30'          PFK 13-24 LIKE 1-12\n         CLI   REPX,X'F1'          PF1-PF13? (H?)\n         BE    PFKHELP             YES, GO DO IT\n         CLI   REPX,X'F5'          PF5-PF17? (L?)\n         BE    PFKLOC              YES, GO DO IT\n         CLI   REPX,X'F7'          PF7-PF19? (U?)\n         BE    PFKUP               YES, GO DO IT\n         CLI   REPX,X'F8'          PF8-PF20? (D?)\n         BE    PFKDOWN             YES, GO DO IT\n         CLI   REPX,X'F3'          PF3-PF15? (END?)\n         BE    PFKEND              YES, GO DO IT\n         LA    R2,INVMSG           NO, IGNORE ANY OTHER, SET MESSAGE\n         B     BOTCH               DISPLAY MESSAGE\nPFKEND   CLI   REPLINE,C'?'        YES, BUT WAS IN HELP?\n         BNE   ENDPFK              NO, GO DO IT\n         MVC   REPLINE,BLANKS      YES, CLEAR REMEMBERED INPUT\n         LA    R2,REPLINE          FORCE NULL INPUT\n         B     ASIS6               AND GO BACK\nENTKEY   LA    R2,REPLINE          THIS IS WHERE IT WILL GO\n         LA    R3,REPX+3           POINT SRC PAST CURSOR ADDRESS\n         LA    R4,REPX-1(R1)       END OF REPLY DATA\nASIS1    CLR   R3,R4               TOO FAR?\n         BH    ASIS6               YES, NO DATA CAME IN\n         CLI   0(R3),X'11'         SBA SEQUENCE?\n         BNE   ASIS4               NO, DON'T WORRY ABOUT IT\n         CLC   1(2,R3),=XL2'C1D1'  FIRST LINE INPUT (2,1)?\n         BE    ASIS3               YES, ALL'S COOL SO FAR\n         CLC   1(2,R3),=XL2'C3F1'  SECOND LINE INPUT (4,1)?\n         BE    ASIS2               YES, GO CLEAR REP LINE\n         TM    FLAGSX,RUNTSO       TSO TERMINAL?\n         BZ    *+L'*+2             NO\n         DC    H'0'                YUP, TAKE AN S0C1 <------------ DUMP\n         LA    R2,SFEMSG           POINT TO MESSAGE\n         B     BOTCH               RESUME IF \"GO\" FROM TEST\nASIS2    MVC   REPLINE,BLANKS      CLEAR REMEMBERED INPUT\nASIS3    LA    R3,3(,R3)           SKIP THE SBA SEQUENCE\n         B     ASIS1               AND TRY SOME MORE\nASIS4    CLI   0(R3),C' '          LEADING BLANK?\n         BNE   *+L'*+8             NO, FOUND DATA\n         LA    R3,1(,R3)           SKIP THE BLANK\n         B     ASIS1               GO LOOK FOR MORE\n         MVC   REPLINE,BLANKS      FORCE CLEAR REPLY\nASIS5    CLR   R3,R4               TOO FAR?\n         BH    ASIS6               YES, FILL IT UP NOW\n         CLI   0(R3),X'11'         SBA?\n         BE    ASIS6               YES, IGNORE THE 2ND LINE\n         MVC   0(1,R2),0(R3)       MOVE ONE MORE BYTE\n         LA    R2,1(,R2)           OK, UP THIS ONE\n         LA    R3,1(,R3)           AND THE FROM POINTER, TOO\n         B     ASIS5               CONTINUE THIS TRAVESTY\nASIS6    LA    R4,REPLINE          COMPUTE THE REAL\n         SR    R2,R4               LENGTH OF THE REPLY\n         STH   R2,READLEN          AND SAVE IT FOR LATER\n         MVC   MSGLINE,BLANKS      CLEAR THE ERR-MSG IF ANY\n*------- COMMAND CHECKING AND EXECUTION. ----------------------------*\n*              FIND REPLY LENGTH AND COPY IT TO TEMP3.\n         MVC   ICREP,REPLINE       HANDLE A COPY\n         OC    REPLINE,BLANKS      MAKE IT UPPER CASE\n         LH    R1,READLEN          GET READ LENGTH\n         LA    R1,REPLINE(R1)      POINT TO LAST CHAR + 1\n         BCTR  R1,0                DECREMENT POINTER\n         CLI   0(R1),C' '          END OF STRING?\n         BE    *-6                 NO, GO TEST ANOTHER CHAR\n         LA    R0,REPLINE-1        GET LENGTH...\n         SR    R1,R0               ... OF DATA\n         BNP   NEWDSPNT            ZERO, IGNORE WITH NO TRACE\n         STH   R1,REALRDLN         PHONY UP THE ACTUAL READ LENGTH\n         MVC   TEMP3(40),REPLINE   COPY START OF COMMAND\n*              (SOME ROUTINES MODIFY THE COMMAND IN TEMP3).\n*              SEE IF THE COMMAND IS IN THE COMMAND TABLE.\n         LR    R0,R1               GET THE TRUE READ LENGTH\n         XR    R1,R1               CLEAR REGISTER FOR IC'S\n         L     R2,=A(COMTAB)       POINT TO COMMAND TABLE\n         BAL   R14,*+L'*+4         SET LOOP ADDRESS & SKIP\n         LA    R2,CMTBEL(,R2)      -> NEXT TABLE ENTRY\n         CLI   CMTBL(R2),X'FF'     END OF TABLE\n         BE    EXPR                YES, NOT IN TAB, AN EXPRESS?\n         IC    R1,CMTBL(,R2)       NO, PICK UP LENGTH OF COMMAND\n         EX    R1,COMCLC           COMMAND MATCH?\n         BNER  R14                 NO, CHECK NEXT\n         XR    R14,R14             CLEAR REGISTER FOR ICM'S\n         ICM   R14,B'0111',CMTBA(R2) PICK UP COMMAND ADDRESS\n         BCTR  R0,0                COMPUTE LENGTH OF ...\n         SR    R0,R1               ... REMAINING INPUT\n*              NOTE : CC IS SET FOR OPERAND LENGTH 0 OR NOT 0.\n         LA    R1,TEMP3+1(R1)      -> START OF OPERANDS\n         BR    R14                 GO DO IT\nCOMCLC   CLC   REPLINE(*-*),CMTBN(R2) <<EXECUTED>>\n*- - - - EXPRESSION ***** NO COMMAND (EXPRESSION) *****          <===*\nEXPR     LA    R1,REPLINE          GET EXPRESSION POINTER\n         LH    R0,REALRDLN         GET EXPRESSION LENGTH\nPARSE    L     R15,OFFSET          GET '*' (CURRENT VALUE)\n         MVI   EXPOPT,YESSYMB      SAY 'LOOK AT THE SYMBOL TABLE'\n         BAL   R8,CALLEXP          GO PARSE\n         S     R15,BASEVAL         GET OFFSET IN BUFFER\n         BNM   SETPOINT            IT'S NON-NEG, SO WE'RE OK\nSETPNT00 XR    R15,R15             CAN'T HAVE NEGATIVE\n         CLC   ADDRBUFF,ADDRCNT    DISPLAYING COUNT FIELD?\n         BNE   SETPOINT            NO, OK\n         LA    R15,8               YES, PUT CARET AT KEY\nSETPOINT LH    R2,BLKLEN           GET BLOCK LENGTH\n         BCTR  R2,0                -1 FOR COMPARE\n         CLR   R15,R2              ARE WE STILL WITHIN THE BLK?\n         BNH   *+L'*+2             YES, WE'RE OK\n         LR    R15,R2              NO, MAKE IT THE END OF BLK\n         STH   R15,OLDPOINT        SAVE OFFSET FOR CURR LOC\n         A     R15,BASEVAL         RELOCATE IT\n         ST    R15,OFFSET          SAVE ADDRESS\n         B     NEW$DISP            GO DO IT\nINVEXPER LA    R2,INVEXP           YES, SAY INVALID SYNTAX\n*                                  AND GO TELL HIM WITH NO TRACE\n*- - - - DISPLAY ERROR MESSAGES.\n*              MOVE IN MESSAGE AND HYPHENS AROUND IT TO ERROR MESSAGE\n*              LINE ON SCREEN. TRACE WILL BE DISABLED. IF SYNTAX ERROR\n*              MESSAGE IS TO BE DISPLAYED, THE COLUMN IN QUESTION IS\n*              COMPUTED AND DISPLAYED WITH THE MESSAGE.\n*              R2 = POINTER TO MESSAGE.\n*              R1 = POINTER TO THE COLUMN OF THE ERROR (ONLY WHEN\n*                   INVALID LOC IN EXPRESSION).\nBOTCH    XR    R15,R15             CLEAR R15\n         IC    R15,0(,R2)          GET LENGTH\n         CH    R15,=H'20'          SEE IF WE ARE USING MESSAGE\n         BH    BOTCHX              IF NOT ASSUME LENGTH OF 20\n         MVC   TEMP3(20),BLANKS    CLEAR AN AREA\n         BCT   R15,*+L'*+6         DECREMENT FOR EXECUTE\n         MVC   TEMP3(*-*),1(R2)    <<EXECUTED>>\n         EX    R15,*-6             MOVE IN MESSAGE\n         LA    R2,TEMP3            POINT TO MESSAGE\n         CLC   INVEXP+1(16),TEMP3  IS THIS AN INV EXPR MSG?\n         BNE   BOTCHX              NO, GO ON\n         LA    R3,TEMP3            POINT TO COPY OF REPLY\n         CLR   R3,R1               IS THIS AREA USED FOR SCAN?\n         BNH   *+L'*+4             YES\n         LA    R3,REPLINE          NO, POINT TO REPLY\n         SR    R1,R3               GET OFFSET TO BAD HEX\n         LA    R1,1(R1)            MAKE THE OFFSET A COLUMN #\n         CVD   R1,TEMP2            YES, GET OFFSET OF ERROR INTO\n         UNPK  TEMP3+18(2),TEMP2+6(2) THE EXPRESSION AND\n         OI    TEMP3+19,C'0'       MOVE IT TO THE SCREEN\n         BCTR  R1,0                GET CURSOR POSITION\n         STH   R1,CURPOS           SET IT\nBOTCHX   LR    R1,R2               GET MESSAGE ADDRESS\n         LA    R8,NEWDSPNT-2       FAKE THE RETURN POINT\n         B     SETMSGX             SPECIAL ENTRY POINT\n*- - - - HELP.                                                   <===*\n*              (?, ?1, ?2, ?3, ?4, ?5, ?6, ?7, HELP, H, H1,...,H7).\nPFKHELP  MVC   MSGLINE,BLANKS      CLEAR THE ERR-MSG IF ANY\nHELPHELP XR    R3,R3               HE WANTS HELP #1 (\"HELP\")\n         B     HELPOK              AND PROCESS\nHELP     BNP   HELPHELP            JUST \"?\" - GIVE HIM \"?1\"\n         XR    R15,R15             * = 0\n         BAL   R8,CALLEXP          PARSE OPERAND\n         BNP   INVEXPER            NO GOOD\n         LR    R3,R15              GET THE ANSWER\n         BCTR  R3,0                -1 FOR OFFSET\n         CH    R3,=H'15'           GREATER THAN 9?\n         BL    HELPOK              NO, SKIP\n         SH    R3,=H'6'            \"EXP\" THOUGHT IT WAS HEX\nHELPOK   LA    R2,1+C'1'(,R3)      GET NEXT PROMPT\n         CH    R3,=Y(NUMHLP-1)     TOO BIG?\n         BH    INVEXPER            YES, BYE BYE\n         BL    *+L'*+4             NO, USE IT, WE HAVE PROMPT\n         LA    R2,C'1'             AT END, WRAP TO BEGIN\n         BAL   R8,CLEAR            CLEAR THE SCREEN FIRST\n         MVI   REPLINE-1,X'C9'     UNPROT HIGH MDT\n         MVC   REPLINE,BLANKS      BLANK THE PROMPT\n         MVI   REPLINE,C'?'        SET UP PROMPT\n         STC   R2,REPLINE+1        DO IT\n         CLI   REPLINE+1,X'FA'     TOO BIG?\n         BL    *+L'*+12 >========+ NO, OK\n         MVI   REPLINE+1,C'1'    | SET FIRST DIGIT\n         SH    R2,=H'10'         | FIX OTHER DIGIT\n         STC   R2,REPLINE+2      | SET IT\n         LTR   R3,R3 <===========+\n         BNP   *+L'*+4             SKIP IF NULL\n         MH    R3,=Y(L'ZAPHELP)    * LENGTH OF EACH HELP IMAGE POINTER\n         AL    R3,=A(ZAPHELP)      ADD START TABLE POINTER\n         XR    R1,R1\n         L     R2,0(R3)            POINT TO HELP IMAGE\n         LA    R3,LINE06           FIRST SCREEN LINE FOR HELP\nHELPFILL CLI   0(R2),X'FF'         END OF HELP IMAGE?\n         BE    DISPLYNT            YES, GIVE HIM SCREEN (NOTRACE)\n         CLI   0(R2),X'80'         NULL LINE?\n         BNE   *+L'*+8             NO\n         LA    R2,1(R2)            YES, SKIP TO NEXT\n         B     *+L'*+12\n         IC    R1,0(R2)            GET TEXT LENGTH OF THIS HELP LINE\n         EX    R1,HELPMOVE         MOVE TEXT LINE (CENTERED)\n         LA    R2,2(R1,R2)         INCREMENT SOURCE POINTER\n         LA    R3,$I(R3)           INCREMENT TARGET POINTER\n         B     HELPFILL\nHELPMOVE MVC   ($L-LENHLL)/2(*-*,R3),1(R2) <<EXECUTED>>\n*- - - - LOG, DISP.                                              <===*\nLOG      OI    FLAGSL,LOGRQ        LOGGING REQUESTED\n         BAL   R8,LOGTEST          OPEN THE DATA-SET IF NOT OPEN\n         LA    R2,LOGMSG           POINT TO MESSAGE\n         B     BOTCH               DISPLAY MESSAGE\nDISPC    MVC   ADDRBUFF,ADDRCNT    -> COUNT\n         LH    R14,CCW#W#W+6       GET KL+DL\n         LA    R14,8(,R14)         INCLUDE LENGTH OF COUNT\n         STH   R14,BLKLEN          SET DISPLAY BLOCK LENGTH\n         LA    R15,8               DISPLAY OFFSET\n         B     SETPOINT            RE-DISPLAY NEAR TOP\nDISPK    MVC   ADDRBUFF,ADDRKEY    -> KEY\n         MVC   BLKLEN,CCW#W#W+6    SET DISPLAY BLOCK LENGTH\n         B     SETPNT00            RE-DISPLAY AT TOP\nDISPD    MVC   ADDRBUFF,ADDRDATA   -> DATA\n         LH    R14,CCW#W#W+6       GET KL+DL\n         SH    R14,KEYLEN          DON'T DISPLAY KEY\n         STH   R14,BLKLEN          SET DISPLAY BLOCK LENGTH\n         B     SETPNT00            RE-DISPLAY AT TOP\n*- - - - END.                                                    <===*\nCANEX    LA    R1,CEXMSG           CANCEL MESSAGE\nXCSIO    ST    R1,MSGADD           STORE MESSAGE ADDRESS\n         B     XEND+L'XEND         AND SCRAMBLE EXIT\nENDPFK   MVC   REPLINE,BLANKS\n         MVC   REPLINE(3),=CL3'END'\nXEND     BAL   R8,CHKPT            CHECK TO SEE IF ZAP REQ\n         TM    FLAGSG,GODOPN       DATA-SET OPENED?\n         BZ    XFRDS               NO\n        CLOSE  MF=(E,DCBLIST)      YES, CLOSE IT\n         NI    FLAGSG,255-GODOPN\nXFRDS    TM    FLAGSG,GODALL       DATA-SET ALLOCATED?\n         BZ    ENDALL              NO\n         L     R2,DYNWORKP         YES, INIT. DYNAMIC ALLOC. WORK-AREA\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',BLANKS\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         MVC   DDNAME,DDNALL       DDNAME\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         DROP  R2\n         NI    FLAGSG,255-GODALL\n         L     R15,ARDYNAM         FREE IT\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    ENDALL              OK\n        XMESS  3002                ERROR\n         OC    MSGADD,MSGADD       STILL A MESSAGE IN?\n         BNZ   ENDALL              YES\n         LA    R1,FZFMSG           NO, SET THIS ONE\n         ST    R1,MSGADD\nENDALL   LA    R1,5                MESSAGE NUMBER\n         BAL   R8,SETLINE          SET UP A LINE\n         B     XLEAVE              NOT LOGGING?\n         MVC   20(32,R2),=CL32'LOG CLOSED - PROCESSING COMPLETE'\n         MVI   0(R2),C'-'          TRIPLE SPACE IT\n         BAL   R8,CPUT             OUTPUT IT\nXLEAVE   L     R1,CSALOC           GET WORK-AREA POINTER\n         L     R0,=XL4'FFFFFFFF'   (+) FLAG AS CLOSE CALL\n         L     R15,=A(CSOUT)       (+) POINT TO ROUTINE\n        CALL   (15)                (+) CALL IT\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    *+L'*+14            OK\n         OC    MSGADD,MSGADD       FAILED, STILL A MESSAGE IN?\n         BNZ   *+L'*+4             YES\n         ST    R1,MSGADD           NO, SET THIS ONE\n         ICM   R1,B'1111',ZBUFFA   GET BUFFER AREA ADDRESS\n         BZ    XQUIT               NONE\n         L     R0,ZBUFFL           GET BUFFER AREA LENGTH\n        FREEMAIN R,LV=(0),A=(1)    FREE BUFFER AREA\nXQUIT    L     R0,=A(TSDSECTL)\n         LR    R1,R9\n        FREEMAIN R,LV=(0),A=(1)    FREE LOCAL WORK-AREA\n         L     R13,4(,R13)         RESTORE ALL REGISTERS\n         LM    R14,R12,12(R13)\n         XR    R15,R15             RC=0\n         BR    R14                 BYE BYE\n*- - - - EBCDIC, ASCII, ZCODE.                                   <===*\nEBCDIC   L     R1,=A(TRCHARE)      PICK UP POINTER TO EBCDIC TRTAB\n         LA    R2,EBCDCMSG         TELL HIM WHAT JUST HAPPENED\n         XR    R15,R15\nEBCDIC#  ST    R1,TRTABADD         SAVE FOR LATER DISPLAYS\n         ST    R15,TRTXTAB\n         B     BOTCH               GO DO IT AND DISPLAY\nASCII    L     R1,=A(IECTRASA)     PICK UP POINTER TO ASCII TRTAB\n         LA    R2,ASCIIMSG         TELL HIM WHAT JUST HAPPENED\n         L     R15,=A(IECTSASA)\n         B     EBCDIC#             GO FINISH THE JOB\nZCODE    L     R1,=A(TRCHARZ)      PICK UP POINTER TO ZCODE TRTAB\n         LA    R2,ZCODEMSG         SAY WHAT TYPE OF TRANS\n         L     R15,=A(TRCHRZ)\n         B     EBCDIC#             AND DO IT FROM NOW ON\n*- - - - *****  //DEBUG  *****                                   <===*\nDIEFAST  TM    FLAGSX,RUNTSO       TSO TERMINAL?\n         BZ    *+L'*+2             NO\n         DC    H'0'                YUP, TAKE AN S0C1 <------------ DUMP\n         LA    R2,OUCH             POINT TO MESSAGE\n         B     BOTCH               RESUME IF \"GO\" FROM TEST\n*- - - - # (CALC), LAST, LASTDS1.\nCALC     L     R15,OFFSET          GET '*' = CURRENT OFFSET\n         MVI   EXPOPT,YESSYMB      TELL HIM SCAN SYMBOL TABLE\n         BAL   R8,CALLEXP          PARSE & CHECK\n         MVC   MSGLINE+17(20),=CL20'CALCULATE VALUE:' MOVE IN MASK\n         BAL   R14,NUMCONV         CONVERT\n         MVC   MSGLINE+34(12),TEMP3 DECIMAL PART\n         MVC   MSGLINE+48(8),TEMP3+12 HEX PART\n         B     NEWDSPNT            GIVE IT TO HIM\nLAST     BAL   R8,CHKPT            CHECK TO SEE IF ZAP REQ\n         CLI   ZDSNME,X'04'        IS THERE A LAST TTR (NOT VTOC)?\n         LA    R2,LASTINV          POINT TO MESSAGE IN CASE\n         BE    BOTCH               NO, TELL HIM\n         MVC   TTR(L'TTR-1),ENDTTR PICK UP LAST TTR\n         B     NEW$READ            GO GIVE IT TO HIM\nLASTDS1  BAL   R8,CHKPT            CHECK TO SEE IF ZAP REQ\n         CLI   ZDSNME,X'04'        IS THIS THE VTOC?\n         LA    R2,NOTVMSG          POINT TO MESSAGE IN CASE\n         BNE   BOTCH               NO, TELL HIM\n         XC    ZDBLW,ZDBLW         CLEAR AREA FOR 'ABS'\n*              ASSUME VTOC IS 1 EXTENT ==> M=0.\n         MVC   ZDBLW+3(L'LASTFMT1),LASTFMT1 SET CCHHR OF LAST FMT1\n         B     ABSGOT1             GO FAKE AN 'ABS' COMMAND\n*- - - - D, U.                                                   <===*\nPFKDOWN  MVC   REPLINE,BLANKS\n         MVI   REPLINE,C'D'\n         MVC   MSGLINE,BLANKS      CLEAR THE ERR-MSG IF ANY\n         XR    R0,R0\nDISPLAY# BNZ   PARSE               MORE THAN A 'D'\n         BAL   R8,DU$COM           GET # OF BYTES\n         AR    R15,R14             WHERE TO POINT TO NOW (OFFSET)\n         CH    R15,BLKLEN          PAST BLK?\n         BL    SETPOINT            NO, GO ON\n         SRL   R14,1               TRY HALF WAY THEN\n         SR    R15,R14             MAY BE NOW?\n         CH    R15,BLKLEN          STILL ICKY?\n         BNL   *+L'*+8             YES, GIVE UP AND NEXT BLK\n         LH    R15,BLKLEN          NO, POINT TO END OF BLK + 1\n         B     SETPOINT            GO GIVE IT TO HIM\n         BAL   R8,CHKPT            CHECK TO SEE IF ZAP REQ\n         BAL   R8,READNBLK         GET THE NEXT BLOCK\n         B     SETPNT00            GO GIVE HIM OFFSET 0\nPFKUP    MVC   REPLINE,BLANKS\n         MVI   REPLINE,C'U'\n         MVC   MSGLINE,BLANKS      CLEAR THE ERR-MSG IF ANY\n         XR    R0,R0\nUP       BAL   R8,DU$COM           GET # OF BYTES\n         SR    R15,R14             BACK UP\n         BNM   SETPOINT            USE IT IF OK\n         B     SETPNT00            TOO FAR, USE 0\nDU$COM   L     R14,WIDTHD          GET # OF LINES BELOW\n         A     R14,WIDTHU          ADD NUMBER OF LINES ABOVE\n         LA    R14,1(,R14)         ADD CARET LINE\n         MH    R14,=H'16'          GET # OF BYTES DISPLAYED\n         LH    R15,OLDPOINT        GET CURRENT OFFSET\n         BR    R8                  RETURN TO \"D\" OR \"U\"\n*- - - - =, NODEF.                                               <===*\nEQUALS   BNP   INVEXPER            ERROR IF JUST '='\n         LR    R7,R1               -> STRING\n         LR    R1,R0               LENGTH\n         BAL   R8,HEXCHECK         SEE IF VALID NUMBER\n         B     EQUALBAD            CAN'T USE #'S FOR SYMBOLS\n         L     R4,IDEFAVAL         GET POINTER TO 1ST AVAIL TABLE POS\n         CLI   0(R4),X'FF'         END OF TABLE?\n         LA    R2,TABFULL          GET MESSAGE ADDRESS IN CASE\n         BE    BOTCH               NO ROOM...\n         L     R3,AIDEFTAB         POINT TO BEGINNING\n*              SEE IF THE SYMBOL IS ALREADY DEFINED.\nICLOOP   CLR   R3,R4               UP TO FIRST AVAIL POS YET?\n         BNL   OKIDEF              YES, NO DUPLICATE, SO DEFINE\n         CLC   DEFSYM(L'DEFSYM,R3),REPLINE+1 NO, SYMBOL ALREADY HERE?\n         BE    REDEF               YES, SO REDEFINE IT\n         LA    R3,L'IDEFTAB(R3)    NO, POINT TO NEXT SPOT IN TABLE\n         B     ICLOOP              KEEP GOING TILL OUT\nREDEF    MVC   DEFSYM(L'DEFSYM,R3),REPLINE+1 MOVE IN THE SYMBOL\n         MVC   DEFOFF(L'DEFOFF,R3),OFFSET+2 MOVE IN THE OFFSET\n         LA    R2,REDEFMSG         PT TO MESSAGE SAYING REDEFINED SYM\n         B     BOTCH               DONT RESET FIRST AVAIL - LEAVE\nOKIDEF   MVC   DEFSYM(L'DEFSYM,R4),REPLINE+1 MOVE IN THE SYMBOL TO TAB\n         MVC   DEFOFF(L'DEFOFF,R4),OFFSET+2 MOVE IN THE OFFSET\n         LA    R4,L'IDEFTAB(R4)    POINT TO NEXT AVAIL\n         ST    R4,IDEFAVAL         SAVE FOR NEXT TIME\n         B     NEWDSPNT            DISPLAY (NOTRACE)\nEQUALBAD LA    R2,BADEQUAL         POINT TO MESSAGE\n         B     BOTCH               MAS CAN'T COMPLAIN ANYMORE\nNODEF    BAL   R8,CLEARDEF         YES, LET HIM HAVE IT\n         LA    R2,DEFRESET         TELL HIM WE RESET THE TABLE\n         B     BOTCH               GO BACK TO DISPLAY (NOTRACE)\n*- - - - IDEF.                                                   <===*\nIDEF     BAL   R8,CLEAR            CLEAR THE SCREEN\n         MVC   LINE06(16),=CL16' SYMBOL   OFFSET' MOVE MASK FOR COL 1\n         MVC   LINE06+20(3*20-4),LINE06 MAKE 3 MORE COLUMNS\n         LA    R1,LINE08           POINT TO DISPLAY\n         L     R2,IDEFAVAL         POINT PAST LAST LOC TO FMT\n         L     R3,AIDEFTAB         POINT TO TABLE\nIDEFNEWL LA    R4,4                MAKE IT 4 COLUMNS\nIFMTLOOP CLR   R3,R2               DONE WITH FORMATTABLE STUFF?\n         BNL   DISPLYNT            YES, DISPLAY WITH NO TRACE\n         MVC   0(L'DEFSYM,R1),DEFSYM(R3) MOVE SYMBOL TO DISPLAY\n        @HEX   (11,R1),(DEFOFF,R3),LEN=2    MOVE IN OFFSET\n         LA    R1,20(,R1)          UPDATE DISPLAY POINTER\n         LA    R3,L'IDEFTAB(R3)    UPDATE TABLE POINTER\n         BCT   R4,IFMTLOOP         DO ANOTHER\n         LA    R1,$I-4*20(,R1)     INCREMENT A LITTLE MORE\n         B     IDEFNEWL            AND DO ANOTHER LINE\n*- - - - ITRACE.                                                 <===*\nITRACE   L     R2,AITRCTAB         POINT TO BEGINNING OF TABLE\n         BAL   R8,CLEAR            CLEAR THE SCREEN\n         MVC   LINE06+1(11),=CL11' TTR   OFFS' MOVE IN TITLE FOR COL 1\n         MVC   LINE06+14(13*5-2),LINE06+1 MAKE 5 MORE COLUMNS\n         LA    R3,LINE08           FIRST AVAIL SCREEN POSIT\nNEWLINE  LA    R4,3                CNT FOR GOOD OFFSET DISP LOOP\n         AR    R4,R4               YES, MAKE IT 6\nITRFMTLP CLI   0(R2),X'FF'         END OF TABLE\n         BE    DISPLYNT            GO DISPLAY (NOTRACE & NO REBLD)\n        @HEX   (1,R3),(ITRTTR,R2),LEN=3 MOVE IN TTR\n        @HEX   (8,R3),(ITROFF,R2),LEN=2 MOVE IN OFFSET\n         CL    R2,CURRITR          IS THIS THE CURRENT TRACE TAB\n         BNE   *+L'*+4             NO, GO ON WITH FORMATTING\n         MVI   0(R3),C'>'          MOVE IN THE POINTER TO CURR ENTRY\n         LA    R3,13(R3)           UPDATE SCREEN POINTER\n         LA    R2,L'ITRTAB(R2)     UPDATE TABLE POINTER\n         BCT   R4,ITRFMTLP         DO IT THRICE (OR 6)\n         LA    R3,$I-6*13(,R3)     MAKE UP FOR ODDBALL SCREEN\n         B     NEWLINE             AND DO NEXT LINE\n*- - - - >, <.                                                   <===*\nFORWARD  L     R3,ITRAVAL          PICK UP POINTER TO NEXT TRACE\n         NI    FLAGSR,255-YESTRACE DON'T TRACE > FOR PETE'S SAKE\n         CLI   0(R3),X'FF'         END OF TABLE?\n         BNE   *+L'*+4             NO, NO PROBLEM\n         L     R3,AITRCTAB         YES, SO WRAP TO TOP\n         CLI   0(R3),X'FE'         EXIST YET?\n         LA    R2,INVFMSG          GET MESSAGE ADDRESS IN CASE\n         BE    BOTCH               NO - TELL HIM NO GOOD\n         LA    R2,L'ITRTAB(R3)     POINT TO NEXT ONE AFTER THAT\n         LR    R4,R2               SAVE NEXT CURRENT ONE\n         B     CARET               FINISH ALL THE REST\nBACKWARD NI    FLAGSR,255-YESTRACE DON'T TRACE A < EITHER\n         L     R2,AITRCTAB         POINT TO TRACE TABLE\n         L     R3,ITRAVAL          POINT TO NEXT CURRENT ENTRY\n         CLR   R3,R2               CURRENT ENTRY = FIRST ENTRY?\n         BNE   *+L'*+4             NO, NO PROBLEM (YET)\n         L     R3,AITREND          YES, MUST LOOP TO TAB END\n         SH    R3,ITRTBL           BACK TRACK ONE ENTRY\n         LR    R4,R3               SAVE FOR LATER ITRAVAL\n         CLR   R3,R2               IS THAT THE BEGINNING NOW?\n         BNE   *+L'*+4             NO, NO MORE WORRIES\n         L     R3,AITREND          YES, WE LOOP TO ENDTAB\n         SH    R3,ITRTBL           BACKTRACK ONE ENTRY\n         CLI   0(R3),X'FE'         DOES THAT ENTRY EXIST?\n         BNE   CARET               YES, WE'RE OK\n         LA    R2,INVBMSG          NO, TELL HIM SO AND\n         B     BOTCH               GO TELL HIM\n*              DO THE CARET.\n*              IF LEAVING BLOCK, CHECK TO SEE OF BLK REPLACED.\nCARET    CLC   TTR(L'ITRTTR),ITRTTR(R3) NEW BLOCK NEEDED?\n         BE    RDNOTNEC            NO, DON'T BOTHER WITH CHECK\n         BAL   R8,CHKPT            YES, MAKE SURE THIS ONES OK\n         MVC   TTR(L'ITRTTR),ITRTTR(R3) NEW BLK, GET CORRECT TTR\n         ST    R3,TEMP2            SAVE POINTER TO THE ENTRY\n         BAL   R8,READBLK          READ THE BLOCK IN\n         L     R3,TEMP2            PICK UP THE POINTER BACK\nRDNOTNEC ST    R4,ITRAVAL          NEW TRACE TABLE POINTER\n         ST    R3,CURRITR          SAVE CURRENT TRACE TAB ENTRY\n         MVC   TEMP2(L'ITROFF),ITROFF(R3) NOW GET OFFSET FROM TRACE TAB\n         LH    R15,TEMP2           INTO RIGHT REGISTER\n         B     SETPOINT            GO FAKE A '+' COMMAND\n*- - - - T, P, J, %.                                             <===*\nTRACK    BAL   R8,CHKPT            ANY ZAP NEEDED?\n         LTR   R0,R0               TEST OPERAND LENGTH\n         BNZ   MORET               NOT JUST 'T'\n         LH    R15,TTR             JUST A T (T=T+1)\n         LA    R15,1(R15)          POINT TO NEXT TRACK\n         B     POSTRACK            GO DO IT\nMORET    LH    R15,TTR             PICK UP '*' TRACK\n         BAL   R8,CALLEXP          PARSE & CHECK\n         BM    TTRLT1              NEGATIVE IS BAD\nPOSTRACK STH   R15,TTR             SAVE TRACK #\n         MVI   TTR+2,X'01'         GIVE HIM REC=01\n         B     NEW$READ            READ AND DISPLAY\nPOINT    BAL   R8,CHKPT            ANY ZAP NEEDED?\n         LTR   R0,R0               TEST OPERAND LENGTH\n         BNZ   MOREP               MORE THAN P - GET TTR\n         MVC   TTR,=XL4'00000100'  JUST 'P',GIVE HIM TTRN\n         B     NEW$READ            DO IT\nMOREP    BAL   R6,TTRPARSE         GET THE TTR SPECIFIED\n         MVC   TTR(L'TTR-1),TEMP2+1 MOVE IN TTR\n         B     NEW$READ            GO GET IT\n*              (TTR FROM BEGINING OF VOLUME - FOR JES HASPACE)\nPOINT$J  BAL   R8,CHKPT            ANY ZAP NEEDED?\n         LTR   R0,R0               TEST OPERAND LENGTH\n         BNZ   POINT$J1            MORE THAN P, GET TTR\n         MVC   TTR,=XL4'00000100'  JUST 'P',GIVE HIM TTRN\n         B     NEW$READ            DO IT\nPOINT$J1 BAL   R6,TTRPARSE         GET THE TTR SPECIFIED\n         MVC   TTR(L'TTR-1),TEMP2+1 MOVE IN TTR\n         XR    R14,R14\n         ICM   R14,B'0111',DCBU+DCBDVTBA-IHADCB @ DEV.CHAR TABLE ENTRY\n         XR    R15,R15\n         ICM   R15,B'0111',DCBU+DCBDEBA-IHADCB @ DEB\n         LH    R0,32+6(,R15)       1ST EXTENT CYL BEGIN\n         MH    R0,2(,R14)          * # OF TRKS/CYL\n         AH    R0,32+8(,R15)       + 1ST EXTENT TRK BEGIN\n         LH    R1,TTR              GET TRACK SPECIFIED\n         SR    R1,R0               ON VOLUME\n         STH   R1,TTR              (FOR JES/VTOC TTRS)\n         B     NEW$READ            GO GET IT\nINDPOINT LH    R15,OLDPOINT        GET BUFFER OFFSET\n         MVI   EXPOPT,YESSYMB      WANT SYMBOL TABLE LOOKUP\n         BAL   R8,CALLEXP          EVALUATE OPERAND\n         BM    INVEXPER            NEG IS INVALID\n         LH    R0,BLKLEN           GET BLOCK LENGTH\n         SH    R0,=H'3'            LAST POSSIBLE TTR\n         CLR   R15,R0              PAST END?\n         BH    INVEXPER            YES, ERROR\n         A     R15,ADDRBUFF        GET ADDRESS IN BUFFER\n         BAL   R8,CHKPT            CAN HE LEAVE?\n         MVC   TTR(L'TTR-1),0(R15) SET NEW TTR\n         B     NEW$READ            GO READ IT & DISPLAY\n*- - - - ABS.                                                    <===*\nABS      BAL   R8,CHKPT            SEE IF HE CAN LEAVE\n         LTR   R15,R0              TEST OPERAND LENGTH\n         BNP   INVEXPER            IT'S BAD\n         CH    R15,=H'10'          CCHHR TOO LONG?\n         BNH   *+L'*+4             NO, OK\n         LH    R15,=H'10'          YES, TRUNCATE\n         EX    R15,ABSTR           TRANSLATE TO \"HEX\", NO EX LENGTH\n         EX    R15,ABSPACK         GET 000CCHHR\n*              FIND 'M'.\n         XR    R15,R15\n         ICM   R15,B'0111',DCBU+DCBDEBA-IHADCB GET DEB\n         XR    R1,R1               START WITH M=0\n         XR    R0,R0               FOR IC\n         IC    R0,DEBNMEXT-DEBBASIC(,R15) GET NUMBER OF EXTENTS\nABSLOOP  CLC   ZDBLW+3(4),(DEBBASND-DEBBASIC)+(DEBSTRCC-DEBDASD)(R15)\n         BL    ABSNEXT             NOT IN THIS EXTENT\n         CLC   ZDBLW+3(4),(DEBBASND-DEBBASIC)+(DEBENDCC-DEBDASD)(R15)\n         BNH   ABSGOT              NOT IN THIS EXTENT\nABSNEXT  LA    R15,16(,R15)        NEXT EXTENT\n         LA    R1,1(,R1)           NEXT 'M'\n         BCT   R0,ABSLOOP          NEXT EXTENT\n         BAL   R8,CLEAR            CLEAR THE SCREEN FIRST\n         MVC   TTR(L'TTR-1),=XL5'FFFFFFFFFF' SET UP A BAD TTR\n         MVC   CCHHR(L'CCHHR),=XL5'FFFFFFFFFF' HERE TOO\n         OI    FLAGSR,YESSYN       SAY \"IOERROR\"\n         XC    BLKLEN,BLKLEN       NOTHING TO DISPLAY\n         MVC   IOMLINE+17(40),IOERRMSG MOVE IN MASK\n         MVC   IOMLINE+35(15),=CL15'NOT IN DATA-SET'\n         B     DISPLYNT            GO SAY BOTCHED\nABSGOT   STC   R1,ZDBLW            SET 'M'\nABSGOT1  STM   R9,R12,20+R9*4(R13) SAVE REGS CONVERT KILLS\n         XR    R1,R1\n         ICM   R1,B'0111',DCBU+DCBDEBA-IHADCB GET DEB AGAIN\n         LA    R2,ZDBLW            GET 'MBBCCHHR'\n         LR    R3,R13              SAVE R13 TOO\n         L     R15,CVTPTR          CVT\n         L     R15,CVTPRLTV-CVT(,R15) GET ABS=>REL CONVERT\n        CALL   (15)                GO GET TTRZ\n         LR    R13,R3              RESTORE R13\n         LM    R9,R12,20+R9*4(R13) RESTORE OTHER REGS\n         ST    R0,TTR              SAVE TTR\n         B     NEW$READ            GO READ/DISPLAY\nABSTR    TR    TEMP3+3(*-*),HEXTAB <<EXECUTED>>\nABSPACK  PACK  ZDBLW(9),TEMP3+3(0) <<EXECUTED>>\n*- - - - B, R.                                                   <===*\nBACK     BAL   R8,CHKPT            ANY ZAP NEEDED?\n         NI    FLAGSR,255-YESEOF   TREAT EOF'S AS DATA BLKS\n         XR    R15,R15             CLEAR FOR IC\n         IC    R15,TTR+2           GET R\n         SH    R15,=H'1'           BACK IT UP 1\n         B     RBACK               GO CHECK IT\nRECORD   BAL   R8,CHKPT            ANY ZAP NEEDED?\n         CLI   ZDSORG,DCBDSGPO     ARE WE IN A PDS?\n         BNE   *+L'*+4             NO, TELL HIM ABOUT EOF'S\n         NI    FLAGSR,255-YESEOF   YES, TREAT EOF'S AS DATA BLKS\n         LTR   R0,R0               TEST OPERAND LENGTH\n         BP    MORER               NOT JUST 'R'\n         MVI   TTR+3,SEQREAD       GO TO NEXT RECORD\n         B     NEW$READ            READ AND DISPLAY\nMORER    XR    R15,R15             CLEAR FOR IC\n         IC    R15,TTR+2           GET CURRENT RECORD\n         BAL   R8,CALLEXP          PARSE & CHECK\nRBACK    XR    R1,R1               CLEAR FOR IC\n         IC    R1,TTR+2            GET CURRENT RECORD\n         LR    R3,R15              PRESERVE ABSOLUTE FOR BACK\n         SR    R3,R1               FIND OFFSET\n         LR    R5,R15              SAVE IT\n*              R3 IS RELATIVE OFFSET, R5 IS ABSOLUTE VALUE.\n         BZ    NEW$READ            IF STILL HERE, REREAD\n         BM    RGOBACW             IF NEGATIVE, BACK UP\n*              OFFSET IS POSITIVE : READ FORWARD ENOUGH TIMES.\nRGOFORW  OI    FLAGSR,YESEOF       WE WANT TO STOP AT EOF FOR +\n         BAL   R8,READNBLK         READ NEXT BLOCK\n         TM    FLAGSR,YESSYN       WAS THERE AN I/O ERROR?\n         BO    NEWDSPNT            YES, CUT THIS OUT\n         BCT   R3,RGOFORW          GO FORWARD\n         B     NEW$READ            WHEN DONE, DISPLAY IT\n*              OFFSET IS NEGATIVE : READ BACKWARD ENOUGH TIMES.\nRGOBACW  LTR   R5,R5               WAS ABSOLUTE ON THIS TRACK?\n         STC   R5,TTR+2            ASSUME YES, SET NEW RECORD\n         BP    NEW$READ            YES, READ IT\n*              BACK UP A TRACK.\n         LH    R0,TTR              GET TRACK NUMBER\n         BCTR  R0,0                MINUS ONE\n         LTR   R0,R0               BACK TO ZERO?\n         BNM   RCOUNT              ITS GOOD, COUNT TRACK\n         MVC   TTR,=XL4'00000100'  BACKED UP TOO FAR\n         BAL   R8,SETMSG           MOVE MESSAGE TO RIGHT PLACE\n         DC    Y(TTRSMALL+1-ETPSXZAP) 'TTR < 000001 INVALID'\n         B     NEW$READ            DISPLAY FIRST RECORD\nRCOUNT   STH   R0,TTR              SAVE FOR COUNT\n         MVI   TTR+2,0             IT WILL INCREMENT\n         MVC   TEMP2(L'TTR-1),TTR  SAVE TTR\nBCKCNT   BAL   R8,READNBLK         GET NEXT BLOCK\n         CLC   TEMP2(2),TTR        STILL THIS TRACK?\n         BNE   RNEWTRK             NO\n         TM    FLAGSR,YESSYN       I/O ERROR?\n         BO    NEWDSPNT            GET OUTA HERE\n         MVC   TEMP2+2(1),TTR+2    SAVE THIS RECORD\n         B     BCKCNT              CONTINUE DOWN TRACK\nRNEWTRK  MVC   TTR(2),TEMP2        RESTORE PREVIOUS TRACK\n         XR    R1,R1               CLEAR FOR PICKUP\n         IC    R1,TEMP2+2          GET NUMBER OF RECS\n         AR    R5,R1               WE NOW ARE THIS FAR BACK\n         B     RGOBACW             GO SEE IF ITS ON THIS TRK\n*- - - - CAPSON, CAPSOFF.                                        <===*\nCAPSON   MVI   CAPSFLG,YESCAPS     SET CAPS ON\n         LA    R2,CONMSG           TELL STATUS DONE\n         B     BOTCH               GO BACK TO DISPLAY\nCAPSOFF  MVI   CAPSFLG,NOCAPS      SET CAPS OFF\n         LA    R2,COFFMSG          TELL STATUS DONE\n         B     BOTCH               GO BACK TO DISPLAY\n*- - - - L, F.                                                   <===*\nPFKLOC   MVC   REPLINE,BLANKS\n         MVI   REPLINE,C'L'\n         MVC   MSGLINE,BLANKS      CLEAR THE ERR-MSG IF ANY\n         XR    R0,R0\n         STH   R0,REALRDLN              FAKE THE READ LENGTH\n         MVI   REALRDLN+1,1\nFIND     NI    FLAGSR,255-YESEOF   SET SO EOF'S COME BACK\nLOCATE   LTR   R3,R0               TEST OPERAND LENGTH\n         BZ    LGO                 JUST L, GO CONTINUE\n         LR    R4,R1               POINT TO STRING\n         LA    R5,LOOKFOR          POINT TO STRING WORK-AREA\n         BAL   R6,GETSTRNG         GET THE HEX OR CHAR STRING\n         B     AROUND1\n*              CONTINUE SCAN.\nLGO      TM    TCONT,YESCONTL      CAN WE CONTINUE SCAN?\n         LA    R2,LINMSG           ASSUME NO, POINT TO MESSAGE\n         BZ    BOTCH               NO, NO SCAN WAS STARTED\n         LH    R3,LOOKFOR          YES, GET THE SCAN LENGTH\n*              SET UP SCAN.\nAROUND1  LA    R14,LOOKFOR         GET THE STRING ADDRESS\n         BAL   R8,STRCNV           GO APPLY CONVERSION\n         XR    R2,R2               CLEAR REGISTER FOR IC (WHAT ELSE?)\n         IC    R2,WKSTR            GET 1ST CHAR TO FIND\n         LA    R2,TEMPTRT(R2)      POINT TO OFFSET IN TRTAB\n         XC    TEMPTRT(256),TEMPTRT CLEAR TRTAB\n         MVI   0(R2),X'FF'         MOVE IN FF THERE\n         OI    TCONT,YESCONTL      SAY HE CAN CONTINUE SCAN NOW\n         LH    R1,OLDPOINT         GET CURRENT OFFSET\n         CLI   REALRDLN+1,1        JUST 'L' ENTERED?\n         BNE   LOOKSC              NO, START FROM HERE\n         LA    R1,1(,R1)           YES, START FROM NEXT BYTE\n*              BLOCK SCAN LOOP.\nLOOKSC   A     R1,ADDRBUFF         POINT TO OFFSET IN BUFFER\n         BCTR  R1,0                -1\n         LH    R5,BLKLEN           GET BLK LENGTH\n         A     R5,ADDRBUFF         POINT TO END OF BLK\n*              DO THE SCAN.\nLOOKLOOP LR    R2,R5               GET END\n         SR    R2,R1               COMPUTE LENGTH\n         SH    R2,=H'2'            GET LENGTH OF REMAINDER\n         BM    TOOFAR              NOT ENOUGH\n         EX    R2,SCANTRT          FIND INTERESTING STRING\n         BZ    LOOKT               NOT YET, KEEP TRYING\n         CLR   R1,R5               YES, BUT IS IT PAST THE BLK?\n         BNL   TOOFAR              YES, SO GET A NEW ONE\n         EX    R3,SCANCLC          NO, IS ALL OF IT THERE?\n         BNE   LOOKLOOP            NO, KEEP CHECKING\n         MVC   MSGLINE+17(40),=CL40'        *****  SCAN MATCH  *****'\n         S     R1,ADDRBUFF         YES, GET WHERE IT IS AND...\n         LR    R15,R1              INTO RIGHT REGISTER\n         B     SETPOINT            FAKE A '+' COMMAND TO IT\nSCANTRT  TRT   1(*-*,R1),TEMPTRT   <<EXECUTED>>\nSCANCLC  CLC   0(*-*,R1),WKSTR     <<EXECUTED>>\nLOOKT    N     R2,=XL4'000000FF'   GET CLEAN SINGLE BYTE\n         LA    R1,1(R1,R2)         SET LOCATION TO TRY AGAIN\n         CLR   R1,R5               PAST BLK?\n         BL    LOOKLOOP            NO, KEEP SCANNING\nTOOFAR   BAL   R8,CHKPT            ANY ZAP NEEDED?\nTOOFNXT  BAL   R8,READNBLK         GET NEXT BLOCK FOR SCANNING\n         TM    FLAGSR,YESSYN       I/O ERROR?\n         BO    NEWDSPNT            YES, GET OUT\n         CLI   ZDSNME,X'04'        VTOC?\n         BE    TOOFVTC             YES, DIFFERENT CHECK\n         CLC   TTR(L'TTR-1),ENDTTR HAVE WE ARRIVED?\n         BNE   NOTFAR              NO\n         MVC   MSGLINE+22(33),=CL33'*****  HOLDING AT DS1LSTAR  *****'\n         B     SETPNT00            DISP OFF 0, CURR BLK\nTOOFVTC  CLC   CCHHR,LASTFMT1      IS THIS THE LAST FMT1?\n         BNE   NOTFAR              NO, CONTINUE SCAN\n         MVC   MSGLINE+22(33),=CL33'*****  HOLDING AT LASTFMT1  *****'\n         B     SETPNT00            DISP OFF 0, CURR BLK\nNOTFAR   OC    BLKLEN,BLKLEN       ANYTHING HERE? (EOF IF 'F')\n         BE    TOOFNXT             NO, GET NEXT BLOCK\n         XR    R1,R1               RESET BUFFER POINTER\n         B     LOOKSC              GO SCAN IT THEN\n*- - - - S, X, O, N.                                             <===*\nAND      BAL   R2,SXON             POINT TO EX INSTR, GO DO IT\n         NC    0(*-*,R5),WKSTR     <<EXECUTED>>\nOR       BAL   R2,SXON             POINT TO EX INSTR, GO DO IT\n         OC    0(*-*,R5),WKSTR     <<EXECUTED>>\nEXOR     BAL   R2,SXON             POINT TO EX INSTR, GO DO IT\n         XC    0(*-*,R5),WKSTR     <<EXECUTED>>\nSTORE    BAL   R2,SXON             POINT TO EX INSTR, GO DO IT\n         MVC   0(*-*,R5),WKSTR     <<EXECUTED>>\n*              ALLOW HIM TO USE PREVIOUS STRING IF HE JUST ENTERS\n*              THE COMMAND WITH NO SUBSEQUENT STRING OPERAND.\nSXON     ST    R2,TEMP1            SAVE THE EX INSTR POINTER\n         LTR   R3,R0               TEST OPERAND LENGTH\n         BP    SXONNEW#            HAVE AN OPERAND - USE IT\n*              USE AN OLD STRING FOR S,X,O,N WITH NO OPERANDS.\n         TM    TCONT,YESCONTS      JUST 'S'.  OLD STRING YET?\n         BO    SXONNEW             YES, GO ON\n         B     INVEXPER            SAY SYNTAX ERROR COL 2\nINVALCOM LA    R2,INVCOM           POINT TO MESSAGE\n         B     BOTCH               AND TELL HIM\n*              USE SPECIFIED STRING.\nSXONNEW# LR    R4,R1               POINT TO STRING OPERAND\n         LA    R5,ZAPSTRNG         POINT TO STRING WORK-AREA\n         BAL   R6,GETSTRNG         GET AL2(LEN),C'STRING'\n*              AT THIS POINT, ZAPSTRNG CONTAINS THE INFO NECESSARY\n*              TO STORE : AL2(STRING_LENGTH),C'STRING'\nSXONNEW  OC    BLKLEN(2),BLKLEN    ANYTHING TO CHANGE HERE?\n         BZ    INVALCOM            NO, TELL HIM\n         TM    FLAGSG,GODUP        CAN HE EVER UPDATE?\n         BO    LETSTORE            YES, SO GO ON\n         BAL   R8,SETMSG           MOVE MESSAGE TO RIGHT PLACE\n         DC    Y(STORMSG-ETPSXZAP) TELL HIM NOT UPDATING\nLETSTORE LA    R14,ZAPSTRNG        GET THE STRING ADDRESS\n         BAL   R8,STRCNV           GO APPLY CONVERSION\n         LH    R4,ZAPSTRNG         GET LENGTH\n         LH    R5,OLDPOINT         POINT TO ZAPPED OFFSET\n*              CHECK TO SEE IF STRING WILL FIT IN THE REMAINING\n*              PART OF THE BLK WHERE HE IS POINTING.\n         LH    R6,BLKLEN           GET LENGTH OF BLK\n         SR    R6,R5               GET LENGTH OF PIECE REMAINING\n         CLR   R6,R4               IS IT SMALLER THAN THE STRING?\n         LA    R2,LENERR           ASSUME STRING IS INVALID LENGTH\n         BNH   BOTCH               YES, SO GO TELL HIM\n*              STRING WILL FIT.\n         A     R5,ADDRBUFF         POINT TO ACTUAL ZAPPED DATA\n         OI    TCONT,YESCONTS      SAY HE CAN DO 'SXON' NO OPRND\n         LA    R1,1                MESSAGE NUMBER\n         BAL   R8,SETLINE          SET UP THE LINE\n         B     NOMSGEX             NOT LOGGING\n         CLI   CHNGED,0            VIRGIN BUFFER?\n         BNE   *+L'*+4             NO, SINGLE SPACE\n         MVI   0(R2),C'0'          ELSE, DOUBLE SPACE FIRST CHANGE\n         MVC   30(16,R2),=CL16'OFFSET XXXX DATA'\n        @HEX   (37,R2),OLDPOINT,LEN=2 CONVERT OFFSET TO THE LINE\n         LA    R1,48(R2)           POINT TO SPOT\n         BAL   R8,SETSTRNG         CONVERT STRING TO LINE AS WAS\n         MVC   104(5,R2),=CL5'CCHHR' MOVE IN IDENTIFIER\n        @HEX   (110,R2),CCHHR,LEN=5 GET THE CCHHR\n         BAL   R8,CPUT\n         LA    R1,1                MESSAGE NUMBER\n         BAL   R8,SETLINE\n         B     NOMSGEX             NOT LOGGING\n         MVC   30(16,R2),=CL16'TO BE CHANGED TO'\n         LA    R1,48(,R2)\n         L     R2,TEMP1            RESTORE EX INSTRUCTION POINTER\n         EX    R4,0(R2)            CHANGE DATA IN BUFFER\n         BAL   R8,SETSTRNG         RECORD THE CHANGE\n         BAL   R8,CPUT             PUT THE LINE\n         MVI   CHNGED,255          MARK AS CHANGED FOR LATER\n         OI    FLAGSX,MUSTZAP      BLOCK NEEDS A ZAP NOW\n         MVC   OLDTTR(L'TTR-1),TTR COPY FOR PRINTING\n         B     NEWDSPNT            THEN RETURN TO HIM\nNOMSGEX  L     R2,TEMP1            RESTORE EX INSTRUCTION POINTER\n         EX    R4,0(R2)            MAKE THE APPROPRIATE CHANGE\n         OI    FLAGSX,MUSTZAP      BLOCK NEEDS A ZAP NOW\n         B     NEWDSPNT            GIVE IT TO HIM\n*- - - - SET.                                                    <===*\nSET      LTR   R3,R0               TEST OPERAND LENGTH\n         BP    SETNEW#             THERE IS ONE\n*              USE OLD STRING FOR SET NO OPERANDS.\n         TM    TCONT,YESCONTT      IS THERE AN OLD ONE TO USE?\n         BO    SETNEW              YES, USE IT\n         B     INVEXPER            INVALID SYNTAX COL 4\n*              USE SPECIFIED STRING.\nSETNEW#  LR    R4,R1               -> TO THE STRING OPERAND\n         LA    R5,SETZSTR          WHERE TO SAVE THE INFO\n         BAL   R6,GETSTRNG         GET AL2(LEN),C'STRING'\n*              NOW SETZSTR CONTAINS : AL2(SET_LEN),C'SET_STRING'\nSETNEW   OC    BLKLEN(2),BLKLEN    IS THERE ANYTHING TO SET?\n         BZ    INVALCOM            NO, SO DON'T AND TELL HIM\n         TM    FLAGSG,GODUP        CAN HE EVER UPDATE?\n         BO    LETSET              YES, WE HAVE NOTHING TO SAY\n         BAL   R8,SETMSG           MOVE MESSAGE TO RIGHT PLACE\n         DC    Y(STORMSG-ETPSXZAP) TELL HIM NOT UPDATING\nLETSET   LA    R14,SETZSTR         GET THE STRING ADDRESS\n         BAL   R8,STRCNV           GO APPLY CONVERSION\n         LH    R4,SETZSTR          GET BCTR'D STRING LENGTH\n         LA    R5,WKSTR            POINT TO STRING\n         LA    R1,2                MESSAGE NUMBER\n         BAL   R8,SETLINE          SET UP LINE\n         B     NOSETMSG            OOPS, NOT LOGGING\n         CLI   CHNGED,0            VIRGIN BUFFER?\n         BNE   *+L'*+4             NO, SINGLE SPACE\n         MVI   0(R2),C'0'          ELSE, DOUBLE SPACE FIRST CHANGE\n         MVC   30(28,R2),=CL28'FOLLOWING BLOCK TO BE SET TO'\n         LA    R1,30+28+1(,R2)     POINT WHERE IT GOES\n         BAL   R8,SETSTRNG         CONVERT THE STRING\n         BAL   R8,CPUT             DUMP THE LINE NOW\n         MVI   CHNGED,255          ITS CHANGED NOW\n         MVC   OLDTTR(L'TTR-1),TTR SAVE TTR\n         BAL   R6,PREPDMPX         GET READY FOR THE DUMP\n         BAL   R6,DUMPER           DUMP THE BLOCK\n         LH    R4,SETZSTR          RESTORE LENGTH\nNOSETMSG OI    TCONT,YESCONTT      SAY HE CAN SET NO OPRND NOW\n         OI    FLAGSX,MUSTZAP      BLK NEEDS A ZAP NOW\n         L     R5,ADDRBUFF         POINT TO BUFFER\n         XR    R8,R8               CLEAR REM REGISTER FOR DIVIDE\n         LH    R7,BLKLEN           GET LENGTH OF BLK IN BUFFER\n         LA    R1,1(R4)            GET REAL STRING LENGTH\n         DR    R8,R1               HOW MANY STRINGS FIT IN BLK\n         LTR   R7,R7               BLK SHORTER THAN STRING?\n         BZ    JUSTSPEW            YES, JUST MOVE IN REMAINDER\n*              R7 HAS BCT COUNT OF HOW MANY STRINGS CAN FIT\n*              IN THIS PARTICULAR BLK, WHILE R8 HAS THE LENGTH\n*              OF THE PIECE LEFT OVER.\nSETLOOP  EX    R4,SETMVC           MOVE 1 STRING IN\n         LA    R5,1(R4,R5)         UPDATE BUFFER POINTER FOR NEXT\n         BCT   R7,SETLOOP          FILL AS MUCH OF BUFFER AS CAN\nJUSTSPEW LTR   R8,R8               IS THERE A SMALL PIECE LEFT?\n         BZ    NEWDSPNT            NO, WE ARE ALL DONE\n         BCTR  R8,0                YES, GET EXECUTE LENGTH\n         EX    R8,SETMVC           MOVE AS MUCH AS WILL FIT IN\n         B     NEWDSPNT            AND GO DISPLAY WHAT WE DID\nSETMVC   MVC   0(*-*,R5),WKSTR     <<EXECUTED>>\n*- - - - ZAP/SAVE.                                               <===*\nREPLACE  TM    FLAGSR,YESSYN       WAS THERE AN I/O ERROR ON BLK?\n         BO    WRTNONO             YES, CAN'T ZAP THAT\n         OC    BLKLEN(2),BLKLEN    NO, BUT IS THERE A BLK TO ZAP?\n         BZ    WRTNONO             NO, SO DON'T ZAP ALREADY\n         TM    DCBLIST,X'0F'       UPDATING ALREADY?\n         BNZ   THERE               YES, CONTINUE\n         TM    FLAGSG,GODUP        CAN HE CHANGE FROM INPUT TO UP\n         BZ    WRTNONO             NO, TOUGH BEANS FOR HIM\n         MVC   REPLINE,BLANKS      CLEAR REPLY\n         MVC   REPLINE(3),=CL3'ZAP' RE-PROMPT THE RIGHT THING\n        CLOSE  MF=(E,DCBLIST)      CLOSE THE DATA-SET SO THAT...\n         MVI   DCBLIST,VLB+4       WE CAN OPEN FOR UPDATE\n        OPEN   MF=(E,DCBLIST),TYPE=J THEN DO IT ALREADY\n         TM    DCBU+DCBOFLGS-IHADCB,DCBOFOPN OPEN?\n         BO    THERE#              YES, OK\n         BCR   0,1                 DRAIN PIPELINE\n         EX    0,*                 THIS BETTER NEVER HAPPEN\nTHERE#   TM    FLAGSL,LOGOPN       SEE IF LOGGING\n         BZ    THERE               IF NOT, THEN NO MESSAGE\n         BAL   R8,OPENMSG          GO WRITE THE MESSAGE\nTHERE    BAL   R8,WRITE            WRITE THE BUFFER OUT\n         TM    FLAGSR,YESSYN       I/O ERROR?\n         BO    NEWDSPNT            YES, IGNORE TELLING HIM OK\n         MVI   CHNGED,0            BUFFER HAS BEEN CHECKPOINTED\n         NI    FLAGSX,255-MUSTZAP  BLK NO LONGER NEEDS ZAP\n*              UPDATE THE IDR IF APPLICABLE.\n*              IDR FOR SUPERZAP (AND THEREFORE ZAP) TAKES THE\n*              FOLLOWING FORM :\n*                BYTE  0.....'80' FOR ID\n*                BYTE  1.....LENGTH OF IDR (USUALLY X'FA' = 250.)\n*                BYTE  2.....WHO'S IDR IT IS (X'01' FOR SUPERZAP AND\n*                            AND ZAP)\n*                BYTE  3.....NUMBER OF 13-BYTE IDR DATA ENTRIES (BITS\n*                            2-7)\n*                BYTES 4-16, 17-29,... IDR DATA ENTRY AS FOLLOWS :\n*                  BYTES 0-1 --- ESD ID (DEFAULT 1)\n*                  BYTES 2-4 --- DATE ('YYDDDF')\n*                  BYTES 5-12 -- INFO ('TSO--UUU, WHERE UUU=ZAPPER'S\n*                                UID)\n         CLI   ZDSORG,DCBDSGPO     IS THIS A PDS?\n         BNE   FINZAP              NO, FORGET THE IDR\n         CLI   DCBU+DCBRECFM-IHADCB,DCBRECU IS THIS A LIBRARY?\n         BNE   FINZAP              NO, DON'T UPDATE THE 'IDR'\n         CLI   IDRFLAG,CHGIDR      ALREADY UPDATED THIS IDR\n         BE    FINZAP              YES, DON'T DO IT AGAIN NOW\n         MVC   TEMP1(L'TTR-1),TTR  LET'S SAVE WHERE HE WAS FIRST\n         OC    MEMTTR,MEMTTR       WAS THERE A 'M' COMMAND?\n         BZ    ENDIDR              NO, FORGET IT\n         MVC   TTR(L'TTR-1),MEMTTR PICK UP MEMBER POINTER\n         BAL   R8,READBLK          READ 1ST BLOCK OF MEMBER\nIDRFIND  L     R1,ADDRBUFF         GET BUFFER POINTER\n         TM    0(R1),X'01'         CONTROL RECORD OF SOME SORT?\n         BO    ENDIDR              YES, WE ARE ALL DONE LOOKING\n         CLI   0(R1),X'80'         IDR?\n         BNE   NEWBLK              NO, GET ANOTHER BLK\n         TM    2(R1),X'01'         YES, BUT DONE BY SUPERZAP?\n         BZ    NEWBLK              NO, FORGET THIS ONE\n         XR    R2,R2               CLEAR WORK REGISTER\n         IC    R2,3(R1)            PICK UP # OF IDR DATA ENTRIES\n         LR    R4,R2               SAVE IT FOR LATER\n         N     R2,=XL4'0000003F'   WE JUST WANT BITS 2-7\n         MH    R2,=H'13'           EACH ENTRY IS 13 BYTES LONG\n         LA    R2,3(R2)            IDR HDR IS 3 BYTES LONG\n*              SO NOW R2 HAS AN OFFSET TO THE NEXT\n*              AVAILABLE POSITION IN THE IDR.\n         XR    R3,R3               CLEAR WORK REGISTER\n         IC    R3,1(R1)            PICK UP IDR LENGTH\n         CLR   R3,R2               ARE WE AT END OF IDR?\n         BH    UPDATIDR            NO, SO UPDATE THE IDR\nNEWBLK   NI    FLAGSR,255-YESEOF   TREAT EOF'S AS DATA BLKS\n         BAL   R8,READNBLK         READ ON ANOTHER BLOCK\n         CLC   IOMLINE+27(20),EOFMSG DID I HIT END OF FILE?\n         BE    ENDIDR              YES, STOP THIS STUPID THING\n         TM    FLAGSR,YESSYN       I/O ERROR?\n         BO    ENDIDR              YES, LEAVE\n         B     IDRFIND             NO, CHECK THIS BLK\nUPDATIDR AR    R2,R1               R2 PTS TO NEXT IDR SPOT\n         LA    R4,1(R4)            INCREMENT # OF IDR ENTRIES...\n         STC   R4,3(R1)            AND PUT IT BACK\n         MVC   1(2,R2),ESDID       MOVE IN ESDID (IF ANY)\n        TIME   ,                   GET THE DATE IN R1 (0CYYDDDF)\n         ST    R1,ZDBLW            SAVE IT IN TEMPORARY WORD\n         MVC   3(3,R2),ZDBLW+1     MOVE YYDDDF TO IDR\n         MVI   6(R2),C'/'          INDICATE TSO USERID\n         MVC   7(7,R2),ZUSRID      MOVE IN THE CULPRIT\n         BAL   R8,WRITE            GO WRITE THE RECORD BACK\n         TM    FLAGSR,YESSYN       I/O ERROR?\n         BO    ENDIDR              YES, SAY WE DIDN'T UPDATE\n         MVI   IDRFLAG,CHGIDR      NO, SO WE DID UPDATE THE IDR\nENDIDR   LA    R1,6                ASSUME NOT UPDATED\n         CLI   IDRFLAG,CHGIDR      WAS THE IDR UPDATED?\n         BNE   *+L'*+4             NO, WE WERE RIGHT\n         LA    R1,7                DID UPDATE, MESSAGE NUMBER\n         BAL   R8,SETLINE          SET UP OUTPUT LINE\n         B     PUTBACK             NO \"LOG\" FILE, LEAVE\n         MVI   0(R2),C'0'          DOUBLE SPACE\n         MVC   20(25,R2),=CL25'IDR FOR CSECT NOT UPDATED'\n         CLI   IDRFLAG,CHGIDR      WAS IT UPDATED?\n         BNE   PUTITOUT            NO, MESSAGE IS OK\n         MVC   34(3,R2),EDMASK+9   YES, SO GIVE ESDID\n         LH    R0,ESDID            GET ESDID (USUALLY)\n         CVD   R0,ZDBLW            IN DEC\n         ED    33(4,R2),ZDBLW+6    ESDID TO MESSAGE\nPUTITOUT BAL   R8,CPUT             PUT MESSAGE OUT\nPUTBACK  CLC   TTR(L'TTR-1),TEMP1  HAS HE MOVED ANY?\n         BE    FINZAP              YES, DON'T BOTHER PUTTING BACK\n         MVI   TTR+3,NOSEQRD       GET THE RIGHT ONE, NOT THE NEXT\n         MVC   TTR(L'TTR-1),TEMP1  LET'S PUT HIM BACK WHERE HE WAS\n         BAL   R8,READBLK          HE'LL NEVER KNOW WHAT HAPPENED\nFINZAP   MVC   MSGLINE+17(40),=CL40'      *****  BLOCK REPLACED  *****'\n         LA    R1,3                MESSAGE NUMBER\n         BAL   R8,SETLINE          SETUP THE LINE\n         B     NEWDSPNT            NOT LOGGING\n         MVC   30(14,R2),=CL14'BLOCK REPLACED'\n         MVI   0(R2),C'0'          DOUBLE SPACE THIS ONE\n         BAL   R8,CPUT             DUMP THE LINE\n*              TRUNCATE CURRENT LOG BLOCK, IN CASE OF\n*              SYSTEM/PROGRAM FAILURE.\n         L     R1,CSALOC           IT'S GOTTA BE HERE\n         LA    R0,1                (+) SET AS TRUNCATE CALL\n         L     R15,=A(CSOUT)       (+) POINT TO ROUTINE\n        CALL   (15)                (+) CALL IT\n         B     NEWDSPNT            THEN DISPLAY WITH NO TRACE\nWRTNONO  LA    R2,WRITERR          TELL HIM WRITE NOT ALLOWED\n         MVC   REPLINE,BLANKS      CLEAR OUT REPLY BUFFER AND SO DON'T\n*                                  TEMPT HIM TO RE-'ZAP'\n         B     BOTCH               AND DISPLAY\n*- - - - DISASM, ASM.                                            <===*\nDISASM   LH    R15,OLDPOINT        CURR OFFSET\n         MVI   EXPOPT,YESSYMB      WANT SYMBOL TABLE LOOKUP\n         BAL   R8,CALLEXP          PARSE & CHECK\n         BM    INVEXPER            NEG IS BAD\n         LH    R0,BLKLEN           GET LENGTH BLK\n         SH    R0,=H'2'            LAST POSS INSTRUCTION\n         CLR   R15,R0              PAST END OF BLK?\n         BH    INVEXPER\n         A     R15,ADDRBUFF        GET ADDRESS IN BUFFER\n         LNR   R1,R15              NEG FOR 'DISASM'\n         LA    R0,MSGLINE+24       GIVE HIM 33 BYTES TO WORK WITH\n         LA    R2,TEMP3            GIVE HIM SOME WORK-AREA TOO\n         L     R15,=A(ASMGASM)     POINT TO 'ASSEMBLER' HAR HAR\n        CALL   (15)                DISASSEMBLE IT\n         LA    R2,INVOPCOD         ASSUME BOTCHUP\n         LTR   R15,R15\n         BNZ   BOTCH               YUP\n         MVC   MSGLINE+17(7),=CL7'INSTR:' NO, MOVE MASK\n         B     NEWDSPNT            AND SHOW IT OFF\nASM      BNP   INVEXPER            NO OPERAND - BAD\n         L     R15,=A(ASMGASM)     POINT TO SUB\n        CALL   (15)                GET OBJECT\n         LA    R2,INVOPCOD         ASSUME NO\n         LTR   R15,R15\n         BNZ   BOTCH               YUP\n         MVC   MSGLINE+17(8),=CL8'OP CODE:' MASK\n        @HEX   MSGLINE+27,(0,R1),LEN=1\n         B     NEWDSPNT            SHOW IT\n*- - - - V, BASE.                                                <===*\nINDIRECT LH    R15,OLDPOINT        * = CURRENT OFFSET\n         MVI   EXPOPT,YESSYMB      WANT SYMBOL TABLE LOOKUP\n         BAL   R8,CALLEXP          PARSE & CHECK\n         BM    INVEXPER            NEG IS INVALID\n         LH    R0,BLKLEN           GET BLOCK LENGTH\n         SH    R0,=H'2'            LAST POSSIBLE RDW\n         CLR   R15,R0              PAST END?\n         BH    INVEXPER            YES, BYE\n         A     R15,ADDRBUFF        GET ADDRESS IN BUFFER\n         MVC   TEMP1(2),0(R15)     REC LENGTH TO ALIGNED PLACE\n         LH    R15,TEMP1           GET RECORD LENGTH\n         AH    R15,OLDPOINT        BUMP OFFSET\n         B     SETPOINT            GO SET IT\n*              DO WE WANT TO GO TO THE NEXT BLK IF NECESSARY?\nBASE     L     R15,OFFSET          * = CURRENT OFFSET\n         MVI   EXPOPT,YESSYMB      WANT SYMBOL TABLE LOOKUP\n         BAL   R8,CALLEXP          PARSE & CHECK\n         ST    R15,BASEVAL         SET NEW BASE VALUE\n         AH    R15,OLDPOINT        ADD OLD BUFFER OFFSET\n         ST    R15,OFFSET          SET NEW OFFSET\n         B     NEWDSPNT            GO SHOW IT OFF\n*- - - - WHERE.                                                  <===*\nWHERE    NI    FLAGSR,255-YESTRACE DONT TRACE\n         BAL   R8,CLEAR            CLEAR SCREEN\n         B     WHEREAMI            FORMAT LINE\n*- - - - WINDOW.                                                 <===*\n*              W\n*              WFULL\n*              W<DOWN>,<UP>\nWINDOW   BP    OKWIND              GO PROCESS OPERANDS\n         XC    WIDTHS(4+4),WIDTHS  ONLY 'W', SET DEFAULTS\n         B     NEWDSPNT            AND QUIT\nOKWIND   CLC   REPLINE+1(4),=CL4'FULL' FULL WINDOW SPECIFIED?\n         BNE   OKWIND#             NO, GO ON\n         L     R6,MAXWIDTH         YES, SAY FULL\n         LR    R7,R6               SAY FULL HERE TOO\n         B     WINDSAVE            WE ARE DONE\nOKWIND#  LM    R6,R7,WIDTHS        ASSUME WIND=CURR WIND\n         LR    R4,R0               SAVE LENGTH OP(S)\n         LR    R5,R1               SAVE POINTER TO OPERANDS\nWINDLOOP CLI   0(R5),C','          END 1ST OP?\n         LA    R5,1(,R5)           ASSUME YES\n         BE    *+L'*+4             RIGHT, DO 1ST\n         BCT   R4,WINDLOOP         TRY TRY\n         SR    R0,R4               LENGTH 1ST\n         BZ    *+L'*+6             NO 1ST, DO 2ND\n         BAL   R3,WINDEXP          PARSE, R1 SET, *=0\n         LR    R6,R15              ALL OK, SAVE FOR <DOWN>\n         LR    R0,R4               LENGTH LEFT = LENGTH 2ND (ALMOST)\n         SH    R0,=H'1'            -1 FOR COMMA (IF ANY)\n         BNP   WINDSAVE            NO 2ND OP, LEAVE ALONE\n         LR    R1,R5               SET OP POINTER FOR \"EXP\"\n         BAL   R3,WINDEXP          GO PARSE 2\n         LR    R7,R15              ALL OK, SAVE <UP>\nWINDSAVE STM   R6,R7,WIDTHS        SAVE THE 2 WIDTHS\n         B     NEWDSPNT\nWINDEXP  XR    R15,R15             * = 0\n         BAL   R8,CALLEXP          PARSE & CHECK\n         BM    INVEXPER            NEGATIVE IS BAD\n         CL    R15,MAXWIDTH        TOO BIG?\n         BNHR  R3                  NO, RETURN\n         B     INVEXPER            YES, COMPLAIN\n*- - - - FLOAT.                                                  <===*\n*              (ORIGINAL INTX SVCX 6 CODE WRITTEN BY STEVE SILVER.\n*              MODIFIED FOR ZAP USE BY JCJ AND VIC\n*              - IE : WE DON'T UNDERSTAND).\nFLOAT    LTR   R2,R0               TEST OPERAND LENGTH\n         BP    FLOAT$              GO USE IT\n         LH    R15,OLDPOINT        GET CURRENT OFFSET\n         LR    R14,R15             COPY\n         AH    R14,=H'8'           POINT PAST END OF OPERAND\n         CH    R14,BLKLEN          IN BLOCK?\n         BNL   INVEXPER            NO, ERROR\n         A     R15,ADDRBUFF        -> OPERAND\n         MVC   TEMP2(8),0(R15)     GET IN ALIGNED PLACE\n         B     FLOAT#              CONTINUE WITH IT\nFLOAT$   BCTR  R2,0                GET EXECUTE LENGTH\n         CH    R2,=H'15'           WAS THE OPERAND TOO LONG?\n         BH    LENERROR            YES, TELL HIM AND QUIT\n         LR    R7,R1               POINT TO THE STRING\n         LA    R1,1(,R2)           PICK UP LENGTH OF STRING\n         BAL   R8,HEXCHECK         IS IT VALID HEX?\n         B     OKFLOAT             YES, SO LET'S DO IT\n         LR    R1,R7               NO, POINT TO THE ERROR\n         B     INVEXPER            AND SAY SYNTAX ERROR\nOKFLOAT  EX    R2,TRFLOAT          START TRANSLATE TO REAL HEX\n         PACK  TEMP2(8),TEMP3+5(15) MAKE IT HONEST-TO-GOODNESS HEX\n         MVN   TEMP2+7(1),TEMP3+20 GET THE LAST NIBBLE TOO\nFLOAT#   LD    FPR0,TEMP2          LOAD IT IN FLOAT REGISTER 0\n         LA    R7,MSGLINE+36       POINT TO START OF SCREEN RESULT AREA\n*              SET THE PROGRAM MASK TO MASK OUT FIX POINT OFLO,\n*              DEC OFLO, EXPON UNFLO, AND SIGNIFICANCE.\n*              SAVE IT IN R6 TO RESET IT LATER.\n         XR    R2,R2               0 R2 FOR SPM\n         BALR  R6,0                SAVE PGM MASK FOR RESTORE\n         SPM   R2                  0 THE PGM MASK (NO INTERR)\n         MVI   16(R7),C'0'         ASSUME ANSWER IS 0\n         AD    FPR0,=D'0'          NORMALIZE BY ADDING 0\n         LTDR  FPR0,FPR0           CHECK THE SIGN\n         BZ    CVFCI3              ZERO (WE'RE ALMOST DONE)\n         BP    CVFC00              PLUS, GO ON\n         LPDR  FPR0,FPR0           MINUS, MAKE IT PLUS ...\n         MVI   0(R7),C'-'          INSERT SIGN AND GO ON LIKE PLUS\nCVFC00   LA    R7,1(R7)            UPDATE OUTPUT POINTER EITHER CASE\n         CD    FPR0,=X'7FFFFFFFFFFFFF00' DATA WILL CAUSE EXP OVERFLOW?\n         BNH   *+L'*+4             NO - SKIP PREVENT LOAD\n         LD    FPR0,=X'7FFFFFFFFFFFFF00' ELSE GET MAX ALLOWABLE\n*              MAX ALLOWABLE IS X'7FFFFFFFFFFFFF00'\n         MD    FPR0,=X'4110000000000010' MULT BY FUDGE FACTOR\n*              GENERATE THE NUMBER IN D-FORMAT.\n         XR    R2,R2               INITIALIZE EXPON REGISTER\n         LD    FPR4,=D'10'         SET FP-R4 TO 10\n         LD    FPR6,=D'1'          SET FP-R6 TO 1\n         LD    FPR2,=X'401999999999999A' SET FP-R2 TO .1\n         MVI   0(R7),C'.'          SET UP OUTPUT\n         LA    R7,1(R7)            INCREMENT LINE POINTER\n         MVI   14(R7),C'D'         FORM THE OUTLINE OF EXPONENT\n         MVI   15(R7),C'+'         MOVE IN EXPONENT SIGN\n*              GET THE EXPONENT IN R2 (>=1).\nCVFC1A   CDR   FPR0,FPR6           SEE IF # < 1\n         BL    CVFC2               IF SO, GO TO NEXT PART\n         DDR   FPR0,FPR4           NO, DIVIDE BY 10\n         LA    R2,1(R2)            INCREMENT EXPONENT\n         B     CVFC1A              CONTINUE\n*              GET THE EXPONENT (<.1).\nCVFC2    CDR   FPR0,FPR2           SEE IF >= .1\n         BNL   CVFC3               IF SO, GO TO NEXT PART\n         BCTR  R2,0                DECREMENT EXPONENT\n         MDR   FPR0,FPR4           MULT NUMBER BY 10\n         B     CVFC2               CONTINUE\n*              GET EXPONENT SIGN.\nCVFC3    LTR   R2,R2               SEE IF EXPONENT +\n         BNM   CVFC3A              IF SO, SKIP CODE\n         LPR   R2,R2               MAKE IT PLUS BUT ...\n         MVI   15(R7),C'-'         WRITE OUT A MINUS\nCVFC3A   LA    R0,10               DIVISER FOR BELOW\n         SRDL  R2,32               SET UP FOR DIVIDE\n         DR    R2,R0               DO THE DIVIDE\n         LA    R2,C'0'(R2)         GET THE EBCDIC VALUE\n         LA    R3,C'0'(R3)         GET THE EBCDIC VALUE\n         STC   R2,17(R7)           AND STORE IT\n         STC   R3,16(R7)           AND STORE IT\n         LA    R0,14               GET NUMBER OF DIGITS FOR BCT\n         LD    FPR6,=X'4100000000000000' LOAD FP-R6 WITH UN-NORMALIZER\n*              GET THE MANTISSA.\nCVFC4    MDR   FPR0,FPR4           MULT NUMBER BY 10\n         AWR   FPR0,FPR6           UN-NORMALIZE\n         STD   FPR0,TEMP2          STORE RESULT\n         XR    R4,R4               ZERO FOR IC\n         IC    R4,TEMP2+1          GET FIRST HEX DIGIT\n         SRA   R4,4                KILL LOW NIBBLE (LAST HEX DIG)\n         LA    R3,C'0'(R4)         CONVERT TO CHAR\n         STC   R3,0(R7)            MOVE RESULT TO OUTPUT\n         XC    TEMP2(8),TEMP2      SET UP DBLW\n         LA    R7,1(R7)            POINT TO NEXT OUTPUT COL\n         LTR   R4,R4               IS R4 0?\n         BZ    CVFC4#              YES, WE HAVE NOTHING TO DO\n         MVI   TEMP2,X'41'         MAKE DBLW INTERNAL FLOATING POINT\n         SLL   R4,4                MOVE NUMBER TO HIGH ORDR NIBBLE\n         STC   R4,TEMP2+1          AND MOVE IT TO DBLW\n*              WE HAVE NOW BUILT A DBLW WHICH MAY CONTAIN D'0'\n*              THROUGH D'10'.\n         SD    FPR0,TEMP2          SUBTRACT THE INTEGER PART\nCVFC4#   BCT   R0,CVFC4            DO TILL END\n         B     CVFCI3              CLEAN UP AND GO AWAY\n*              IF NUMBER IS ZERO TO BEGIN WITH, THERE'S NOTHING\n*              TO DO BUT ...\n         MVI   16(R7),C'0'         SET UP ZERO RESULT\n*              RESTORE PROGRAM MASK TO WHAT IT WAS.\nCVFCI3   SPM   R6                  RESET PROGRAM MASK\n         MVC   MSGLINE+17(15),=CL15'FLOATING POINT:'\n         B     NEWDSPNT            RETURN TO CALLER\nTRFLOAT  TR    TEMP3+5(*-*),HEXTAB <<EXECUTED>>\n*- - - - DUMP, DUMPE, DUMPF.                                     <===*\nDUMP     OI    FLAGSL,LOGRQ        LOGGING REQUESTED\n         BAL   R8,LOGTEST\n         BAL   R8,CHKPT            SEE IF HE CAN LEAVE\n         TM    FLAGSR,YESCSERR     \"CSOUT\" CAN RECORD?\n         BO    BADCSOUT            NO, WHY BOTHER TO DUMP THEN?\n         ICM   R7,B'1111',=XL4'7FFFFFFF' NUMBER OF BLOCKS TO READ (HAH)\n         MVC   TEMP1(L'TTR-1),TTR  SAVE WHERE WE ARE\n         CLI   REPLINE+4,C'E'      IS THIS REALLY DUMPE?\n         BE    PREPDMPF            YES, DUMP FROM HERE\n         MVC   TTR,=XL4'00000100'  POINT TO BEGINNING OF DATA-SET\n         B     PREPDMPF            START DUMPING TILL END OF DS\nDUMPF    OI    FLAGSL,LOGRQ        LOGGING REQUESTED\n         BAL   R8,LOGTEST\n         BAL   R8,CHKPT            SEE IF HE CAN LEAVE\n         TM    FLAGSR,YESCSERR     \"CSOUT\" CAN RECORD?\n         BO    BADCSOUT            NO, SO WHY DUMP MAY I ASK?\n         LH    R0,REALRDLN         GET LENGTH OF COMMAND\n         SH    R0,=H'5'            -5 FOR 'DUMPF' ACTUAL LENGTH\n         BNZ   DUMPFOR             HE GAVE AN OPERAND, PROCESS IT\nJUSTDUMP LA    R7,1                DUMP R* ONLY - R7 = # TO DUMP\n         B     STARTDF             ALL SET, START THE DUMP-FOR\n*              PROCESS OPERAND OF DUMPF COMMAND (NUMBER OF BLOCKS\n*              TO DUMP).\nDUMPFOR  XR    R15,R15             LOAD *, CURRENT LOC FOR 'EXP'\n         LA    R1,REPLINE+5        POINT TO OPERAND TO PARSE\n         BAL   R8,CALLEXP          GO PARSE\n         BM    NOBACK              NEG, WE CAN'T DUMP BACKWARDS\n         BZ    INVEXPER            ZERO, INVALID SYNTAX\n         LR    R7,R15              NUMBER OF BLOCKS TO DUMP\nSTARTDF  MVC   TEMP1(L'TTR-1),TTR  SAVE WHERE WE ARE\nPREPDMPF MVI   TTR+3,NOSEQRD       1ST BLK, READ IT BEFORE DUMP\nDMPFLOOP BAL   R6,PREPDUMP         GET READY FOR THE DUMP\n         BAL   R6,DUMPER           DUMP A BLOCK\n         MVI   TTR+3,SEQREAD       SAY NEXT PASS, NOW READ BLK\n         BCT   R7,DMPFLOOP         DO ALL THE BLOCKS HE WANTS\nDUMPEND  MVC   TTR(L'TTR-1),TEMP1  PICK UP WHERE WE WERE\n         MVI   TTR+3,NOSEQRD       DON'T PUT HIM IN NEXT BLOCK\n         BAL   R8,READBLK          SO THAT HE'LL NEVER KNOW\n         LA    R2,DUMPWMSG         IT WORKED SO TELL HIM\n         B     BOTCH               DISPLAY (NOT REALLY A BOTCH)\nDUMPT    OI    FLAGSL,LOGRQ        LOGGING REQUESTED\n         BAL   R8,LOGTEST\n         BAL   R8,CHKPT            SEE IF HE CAN LEAVE\n         TM    FLAGSR,YESCSERR     \"CSOUT\" CAN RECORD?\n         BO    BADCSOUT            NO, DON'T BOTHER WITH DUMP\n         LH    R0,REALRDLN         GET LENGTH OF READ\n         SH    R0,=H'5'            -5 FOR 'DUMPT' ACTUAL LENGTH\n         BZ    JUSTDUMP            NO OPERAND, JUST DUMP THIS BLK\n*              PARSE OUT THE TTR OPERAND OF THE DUMPT COMMAND.\n         LA    R1,REPLINE+5        POINT TO THE OPERAND\n         BAL   R6,TTRPARSE         GO PARSE (USE POINT'S RTN)\n         CLC   TEMP2+1(L'TTR-1),TTR RESULT (TEMP2+1) < CURRENT TTR?\n         BNL   OKDUMPT             NO, HIS WISH IS MY COMMAND\nNOBACK   LA    R2,BACKDUMP         YES, WE CAN'T DUMP BACKWARDS\n         B     BOTCH               WHAT DOES HE THINK WE ARE?\nOKDUMPT  MVC   STOPDUMP(L'STOPDUMP),TEMP2+1 TTR TO STOP AT\n         MVC   TEMP1(L'TTR-1),TTR  SAVE WHERE WE ARE\n         MVI   TTR+3,NOSEQRD       1ST BLK, READ 1ST BLK FOR DUMP\nDMPTLOOP BAL   R6,PREPDUMP         NO, SO PREPARE TO DUMP\n         BAL   R6,DUMPER           AND DUMP WHAT WE HAVE\n         MVI   TTR+3,SEQREAD       NOW WE CAN READ SEQ BLKS\n         CLC   TTR(L'TTR-1),STOPDUMP ARE WE THERE OR PAST YET?\n         BNL   DUMPEND             YES, WE ARE ALL DONE THEN\n         B     DMPTLOOP            GO TILL WE ARE AT HIS TTR\n*- - - - WHATMEM.                                                <===*\nWHATMEM  BAL   R8,CHKPT            SEE IF HE CAN LEAVE\n         CLI   ZDSORG,DCBDSGPO     IS IT PARTITIONED?\n         LA    R2,NOMCOM           GET MESSAGE ADDRESS IN CASE\n         BNE   BOTCH               NO, ERROR\n         MVC   TEMP1(L'TTR-1),TTR  SAVE CURRENT TTR\n         XC    STOPDUMP(3),STOPDUMP SAVE CLOSEST TTR HERE\n         XC    TTR(L'TTR-1),TTR    START AT BEGINNING OF DIR\nWHATLOOP BAL   R8,READNBLK         GET NEXT DIRECTORY BLOCK\n         TM    FLAGSR,YESSYN       DID IT WORK?\n         BO    NEWDSPNT            NO, ABORT\n         L     R3,ADDRDATA         -> BUFFER\n         LH    R2,0(,R3)           BLK LENGTH USED\n         LA    R3,2(,R3)           -> REAL BEGIN LOC\n         BCTR  R2,0                -1\n         BCTR  R2,0                AND -2 FOR REAL LENGTH USED\nWMLOOP2  CLC   0(4,R3),=XL4'FFFFFFFF' END OF DIRECTORY?\n         BE    WMEND               YES\n         CLC   8(3,R3),TEMP1       THIS MEM PAST CURRENT LOC?\n         BH    WMNEXT              YES, TRY NEXT\n         CLC   8(3,R3),STOPDUMP    NO, HIGHER THAN PREVIOUS?\n         BL    WMNEXT              NO, PREVIOUS IS CLOSER\n         MVC   STOPDUMP(L'TTR-1),8(R3) SAVE THIS TTR\n         MVC   MSGLINE+35(8),0(R3) SAVE MEMBER NAME\nWMNEXT   BAL   R8,NXTDIRNT         INCR TO NEXT ENTRY\n         BP    WMLOOP2             CHECK NEXT\n         B     WHATLOOP            GET ANOTHER DIR BLK\nWMEND    MVC   TTR(L'TTR-1),TEMP1  RESTORE WHERE HE WAS\n         OC    STOPDUMP(3),STOPDUMP DID I FIND ANYTHING?\n         BNZ   WMENDOK             YES, DISPLAY IT\n         MVC   MSGLINE,BLANKS      RESET THE LINE\n         BAL   R8,SETMSG           MOVE IN MESSAGE\n         DC    Y(NOMEMFND-ETPSXZAP) 'NONE FOUND'\n         B     WMDONE              SKIP OTHER\nWMENDOK  MVC   MSGLINE+17(17),=CL17'CLOSEST MEMBER IS'\n         MVC   MSGLINE+44(6),=CL6'AT TTR'\n        @HEX   MSGLINE+51,STOPDUMP,LEN=3 GIVE HIM THE START\nWMDONE   BAL   R8,READBLK          PUT HIM BACK WHERE HE WAS\n         B     NEWDSPNT            AND GO DISPLAY\n*              SEE NOTE AT END OF MLOOP2 (NEXT PAGE).\n*- - - - M.                                                      <===*\nMEMBER#  BAL   R8,CHKPT            NEED ZAP?\n         CLI   ZDSORG,DCBDSGPO     IS IT PARTITIONED?\n         LA    R2,NOMCOM           -> MESSAGE IN CASE\n         BNE   BOTCH               THE DATA-SET ISNT PARTITIONED\n         MVC   TEMP1(L'TTR-1),TTR  SAVE TTR IN CASE NO FIND\n         LTR   R0,R0               TEST OPERAND LENGTH\n         BNP   JUSTM               NONE, USE LAST MEM\n         MVC   ZMEMBER(8),REPLINE+1 MOVE MEMBER TO FIELD\n         XC    TTR(L'TTR-1),TTR    POINT TO BEGINNING OF DIRECT -1\n*              FIND THE MEMBER IN THE DIRECTORY.\n*              READ A DIRECTORY BLOCK.\nMLOOP    BAL   R8,READNBLK         GET NEXT BLOCK\n         TM    FLAGSR,YESSYN       I/O ERROR?\n         BO    NEWDSPNT            YES, GET OUT\n         L     R3,ADDRKEY          GET BUFFER POINTER\n         CLC   ZMEMBER,0(R3)       IN THIS BLOCK?\n         BH    MLOOP               NO, GET NEXT\n         LH    R2,8+0(,R3)         GET BLK LENGTH USED\n         BCTR  R2,0                -1\n         BCTR  R2,0                AND -2 FOR REAL LENGTH USED\n         LA    R3,8+2(,R3)         POINT TO REAL BEGIN LOC\n*              MEMBER SCAN LOOP WITHIN BLK.\nMLOOP2   CLC   0(4,R3),=XL4'FFFFFFFF' END OF DIRECTORY?\n         BNE   NOTEND              NO, THERE'S MORE TO LOOK\nMNF      MVC   TTR(L'TTR-1),TEMP1  PICK UP WHERE HE WAS\n         BAL   R8,SETMSG           MOVE MESSAGE TO RIGHT PLACE\n         DC    Y(INVMEM-ETPSXZAP)  SAY INV MEMBER (NOT FOUND)\n         BAL   R8,READBLK          PUT HIM BACK WHERE HE WAS\n         B     NEWDSPNT            AND GO DISPLAY\n*              NOTE : READBLK WILL RETURN ONLY IF THE USER IS NOT\n*              AT AN EOF. IF EOF, SYNAD==>EODAD==>DISPLAY GET\n*              EXECUTED, SO THE MESSAGE MUST BE PRE-SET.\nNOTEND   CLC   0(8,R3),ZMEMBER     MEMBER HERE?\n         BE    FOUNDM              YES, GO WORK ON IT\n         BH    MNF                 IF PAST ALPHA SEQ GIVE UP\n         BAL   R8,NXTDIRNT         INCR TO NEXT ENTRY\n         BNP   MLOOP               NEG, END BLK - READ ANOTHER\n         B     MLOOP2              MORE TO GO - KEEP LOOKING\nFOUNDM   MVC   TTR(L'TTR-1),8(R3)  PICK UP MEMBER'S TTR\n         MVC   MEMTTR(L'MEMTTR),8(R3) SAVE IT FOR LATER USE\n         MVC   ESDID,=H'1'         RESET ESDID TO DEFAULT\n         MVI   IDRFLAG,NOCHGIDR    HAVEN'T CHANGED IDR YET\n         XC    TXTTTR,TXTTTR       ASSUME NOT A LOAD MOD\n         XC    CTL1TTR,CTL1TTR     NO 1ST CTL REC YET\n         MVC   TEMP1+3(1),11(R3)   FLAGS/LEN FROM DIR ENTRY\n         NI    TEMP1+3,B'01100000' # TTR'S IN USER DATA FILED\n         CLI   TEMP1+3,B'00100000' AT LEAST ONE USER TTR?\n         BL    FOUNDM1             BRANCH IF NOT LOAD MODULE\n         MVC   TEMP1+3(1),11(R3)   FLAGS/LEN FROM DIR ENTRY\n         NI    TEMP1+3,B'00011111' # H-WORDS USER DATA\n         CLI   TEMP1+3,12          AT LEAST 12 H-WORDS?\n         BL    FOUNDM1             BRANCH IF NOT LOAD MODULE\n         CLI   DCBU+DCBRECFM-IHADCB,DCBRECU A LOAD MODULE?\n         BNE   FOUNDM1             NO, NO TEXT THEN\n         MVC   TXTTTR(L'TXTTTR),12(R3) YES, SAVE 1ST TEXT BLK TTR\nFOUNDM1  XR    R1,R1               MESSAGE NUMBER\n         BAL   R8,SETLINE          SET UP LINE TO PUT\n         B     NEW$READ            NOT LOGGING, EXIT\n         MVI   0(R2),C'0'          DOUBLE SPACE IT\n         MVC   20(24,R2),=CL24'MEMBER XXXXXXXX SELECTED'\n         MVC   27(8,R2),ZMEMBER    FILL IN THE MEMBER IN QUESTION\n         BAL   R8,CPUT             NOW DUMP THE LINE OUT\n         B     NEW$READ            GO DO IT\nJUSTM    MVC   TTR(L'TTR-1),MEMTTR RESTORE START OF MEMBER\n         B     NEW$READ            GET IT\nNXTDIRNT IC    R4,11(,R3)          GET INDICATORS\n         N     R4,=XL4'0000001F'   JUST # USER DATA HALFWORDS\n         LA    R4,12(R4,R4)        ENTRY LENGTH\n         AR    R3,R4               -> NEXT ENTRY\n         SR    R2,R4               DECR LENGTH REMAINING\n         BR    R8                  RETURN WITH CC SET\n*- - - - NAME.                                                   <===*\nNAME#    BAL   R8,CHKPT            NEED CHKPT?\n         OC    TXTTTR,TXTTTR       IS THERE ANY TEXT?\n         BZ    NAMENFN#            NO, CAN'T HAVE ESD'S THEN\n         MVC   ZNAME,ZMEMBER       ASSUME CSECT IS MODULE\n         LTR   R0,R0               IS THERE AN ARGUMENT?\n         BNP   *+L'*+6             NO, OK THEN\n         MVC   ZNAME(L'ZNAME),0(R1) MOVE NAME TO FIELD\n         MVI   FLAGESD,0           NO FLAGS YET\n*              FIND THE ESD'S FIRST.\n         MVC   TEMP1(L'TTR-1),TTR  REMEMBER WHERE WE ARE NOW\n         MVC   TTR(L'TTR-1),MEMTTR START LOOKING AT BEGIN MEMB\n         BAL   R8,READBLK          GET 1ST BLOCK\nNAMEFIND L     R1,ADDRDATA         POINT TO RECORD\n         TM    0(R1),X'01'         CONTROL REC?\n         BZ    NAMECHKE            NO, POSSIBLE ESD OR SYM\nNAMENFND CLC   TTR(L'TTR-1),TEMP1  NOT FOUND. HAVE WE MOVED?\n         BE    NAMENFN#            NO, NO RE-POSITION NECESSRY\n         MVI   TTR+3,NOSEQRD       YES, NO SEQUENTIAL READ\n         MVC   TTR(L'TTR-1),TEMP1  RESET WHERE WE WERE\n         BAL   R8,READBLK          PUT US BACK\nNAMENFN# LA    R2,NAMEMNF          'INVALID' MESSAGE\n         B     BOTCH               OH WELL\nNAMECHKE CLI   0(R1),X'20'         ESD?\n         BE    NAMEESD             YES, HAVE ONE, TRY IT\nNAMEENXT NI    FLAGSR,255-YESEOF   EOF'S ARE DATA NOW\n         BAL   R8,READNBLK         GET NEXT BLOCK\n         CLC   IOMLINE+27(20),EOFMSG HIT EOF HERE?\n         BE    NAMENFND            YES, NOT FOUND\n         TM    FLAGSR,YESSYN       I/O ERROR\n         BO    NAMENFND            YES, NOT FOUND\n         B     NAMEFIND            NONE, KEEP LOOKING\nNAMEESD  LH    R15,6(,R1)          GET LENGTH ESD DATA THIS BLK\n         LA    R1,8(,R1)           POINT PAST ESD PREFIX TO DATA\n         AR    R15,R1              POINT PAST LAST ESD DATA\n         USING ESDDATA,R1          ESD ENTRIES\nNAMECHK  CLR   R1,R15              PAST END THIS BLK?\n         BNL   NAMEENXT            YES, NEXT ESD BLK\n         CLC   ESDDNAME,ZNAME      NO, NAME MATCH?\n         BE    NAMEGOT             YES, WE MIGHT HAVE IT\nNAMEBNXT LA    R1,ESDDL(,R1)       NEXT ENTRY IN BLK\n         B     NAMECHK             KEEP SCANNING BLK\n*              THE ENTRY POINT EXISTS.\n*              FIND THE PLACE IN THE MODULE TEXT.\nNAMEGOT  NI    ESDDTYPE,255-X'F0'  JUST WANT LOW NIBBLE\n         CLI   ESDDTYPE,X'02'      EXT REF ENTRY (ER)?\n         BE    NAMEBNXT            YES, IGNORE, NEXT ENTRY\n         CLI   ESDDTYPE,X'0A'      WEAK EXT REF? (WEX)?\n         BE    NAMEBNXT            YES, IGNORE, NEXT ENTRY\n         L     R3,ESDDADDR-1       NO, GET LKED ADDRESS OF EP\n         LA    R3,0(,R3)           GET RID OF TYPE BYTE\n         DROP  R1                  NO MORE ENTRIES\n         L     R15,ADDRDATA        POINT TO ESD BLK PREFIX\n         LH    R14,4(,R15)         GET ESDID 1ST NTRY THIS BLK\n         LA    R15,8(,R15)         POINT PAST PRFX TO 1ST ENTRY\n         SR    R1,R15              OFFSET MTHC ENTRY FROM PRFX\n         XR    R0,R0               FOR DIVIDE\n         D     R0,=A(ESDDL)        GET ESDID REL THIS BLK\n         AR    R1,R14              GET ESDID MATCH ENTRY POINT\n         STH   R1,ESDID            SAVE FOR IDR UPDATE\n         MVI   TTR+3,NOSEQRD       NO MORE SEQ READ\n         MVC   TTR(L'TTR-1),CTL1TTR START AT 1ST CTL RECORD\n         OC    TTR(L'TTR-1),TTR    ANY 1ST CTL TTR?\n         BNZ   *+L'*+6             YES, HAVE TTR 1ST CTL REC\n         MVC   TTR(L'TTR-1),MEMTTR ELSE START AT MEMBER\n         BAL   R8,READBLK          GET ESD, CTL, IDR RECORD\n         NI    FLAGESD,255-FESDTEXT NEXT BLK IS NOT TEXT\nNAME$L1  TM    FLAGESD,FESDTEXT    IS THIS TEXT BLOCK?\n         BO    NAME$T1             BRANCH IF IS TEXT RECORD\n         L     R1,ADDRDATA         @ NON-TEXT RECORD\n         TM    0(R1),X'01'         CONTROL RECORD?\n         BZ    NAME$NX             NOT CTL REC, TRY NEXT\n         OI    FLAGESD,FESDTEXT    NEXT BLK IS TEXT\n         OC    CTL1TTR,CTL1TTR     HAVE SAVED 1ST CTL TTR?\n         BNZ   *+L'*+6\n         MVC   CTL1TTR(L'TTR-1),TTR SAVE TTR 1ST CTL REC\n         MVC   TXTORIG(4),8(R1)    LKED ORIG NXT BLK (TEXT)\n         MVI   TXTORIG,0           CLEAR HIGH BYTE\nNAME$NX  NI    FLAGSR,255-YESEOF   EOF'S ARE DATA\n         BAL   R8,READNBLK         GET NEXT LOADMOD BLOCK\n         CLC   IOMLINE+27(20),EOFMSG EOF?\n         BE    NAMENFND            OOPS, CAN'T HAPPEN\n         B     NAME$L1             CONTINUE SEARCH\nNAME$T1  NI    FLAGESD,255-FESDTEXT NEXT BLK IS NOT TEXT\n         LR    R0,R3               COPY ENTRY ORIGIN\n         S     R0,TXTORIG          ENTRY - TXT BLOCK ORIG?\n         BM    NAME$NX             NOT IN NEXT TXT BLK\n         CH    R0,BLKLEN           OFFSET IN BLOCK = BLKLEN\n         BNL   NAME$NX             NOT IN NEXT TXT BLK\n*              WE HAVE THE BLOCK AND OFFSET OF THE ENTRY POINT.\n*              NOTIFY/DISPLAY.\n         MVI   TTR+3,NOSEQRD       NO MORE SEQ READS\n         LR    R3,R0               OFFSET INTO BLOCK\n         LA    R1,8                MESSAGE NUMBER\n         BAL   R8,SETLINE          SET IT UP\n         B     NAMEDONE            NOT LOGGING\n         MVI   0(R2),C'0'          DOUBLE SPACE\n         MVC   20(24,R2),=CL24'MEMBER XXXXXXXX SELECTED' FOR SPACE\n         MVC   20(6,R2),=CL6'ENTRY' MEMBER=ENTRY\n         MVC   27(L'ZNAME,R2),ZNAME MOVE ENTRY NAME IN\n         BAL   R8,CPUT             DO IT\nNAMEDONE LR    R15,R3              GET OFFSET INTO BLOCK\n         MVI   IDRFLAG,NOCHGIDR    HAVEN'T CHANGED IDR YET\n         B     SETPOINT            SIMULATE A '+' COMMAND\n* - - -  NOTE, EJECT.                                            <===*\nNOTE     OI    FLAGSL,LOGRQ        LOGGING REQUESTED\n         BAL   R8,LOGTEST\n         L     R2,CSLLOC           GET THE NEXT LINE IMAGE\n         MVC   1($L-4,R2),REPLINE+4 COPY NOTATION TO BUFFER\n         MVI   0(R2),C'0'          DOUBLE SPACE NOTES\n         BAL   R8,CPUT             DUMP THIS LINE NOW\n         B     NEWDSPNT            THEN CONTINUE ON MERRY WAY\nBADCSOUT LA    R2,NOCSOUT          TELL HIM CAN'T RECORD\n         B     BOTCH               BYE\nEJECT    OI    FLAGSL,LOGRQ        LOGGING REQUESTED\n         BAL   R8,LOGTEST\n         L     R2,CSLLOC           GET THE NEXT LINE IMAGE\n         MVI   0(R2),C'1'          PAGE EJECT\n         BAL   R8,CPUT             DO IT\n         B     NEWDSPNT            ALL DONE\n         EJECT\n*------- UTILITY ROUTINES. ------------------------------------------*\n         SPACE 1\n*  NAME     ... DESCRIPTION\n*  ------------ ---------------------------------------------------\n*  CALLEXP  ... CALL \"EXP\" TO PARSE EXPR, CHECK ERROR RETURNS\n*  CHKPT    ... CHECK IF ZAP NEEDED (IF SO IGNORE COMMAND PENDING)\n*  CLEAR    ... CLEAR SCREEN\n*  CLEARDEF ... RESET DEFINE TABLE\n*  CPUT     ... WRITE A \"LOG\" OUTPUT LINE (IF OPENED)\n*  ... CPUTOP   FORCE OPEN OF \"LOG\" DATA-SET (AND WRITE)\n*  DUMPER   ... DUMP A BLOCK IN DUMP FORMAT\n*  GETSTRNG ... VALIDITY CHECK AND PARSE HEX/CHAR STRING\n*  HEXCHECK ... VALIDITY CHECK HEX\n*  LOGTEST  ... CHECK IF THE \"LOG\" MUST BE OPENED, AND\n*  ... OPENMSG  OUTPUT MESSAGE OF \"LOG\" DATA-SET OPENED\n*  NUMCONV  ... CONVERT A NUMBER TO HEX AND SIGNED DECIMAL\n*  PREPDUMP ... PREPARE FOR DUMP - GET BLOCK, PRINT HEADER LINE\n*  READBLK  ... GET A DATA BLOCK\n*  SETLINE  ... SET UP LINE MESSAGE NUMBER FOR \"CPUT\"\n*  SETMSG   ... MOVE INFO MESSAGE TO CORRECT PLACE ON SCREEN\n*  SETSTRNG ... CONVERT VARIOUS CONSTANTS FOR \"CPUT\"\n*  STRCNV   ... STRING CONVERSION\n*  TTRPARSE ... PARSE OUT SPECIFIED TTR\n*  WRITE    ... EXCP WRITE OUT A BLOCK\n         EJECT\n*------- CALLEXP.                                                <===*\n*        CALL EXP, CHECK ERROR RETURNS.\n*              R1 -> STRING.\n*              R0  = LENGTH.\n*              R8  = LINK RESGITER.\n*                    NOTE : CC IS SET ACCORDING RESULT'S SIGN.\nCALLEXP  LR    R2,R15              COPY \"*\" VALUE\n         L     R15,=A(EXPANAL)     -> ROUTINE \"EXP\"\n        CALL   (15)                CALL IT\n         LTR   R1,R1               WORK?\n         BNM   INVEXPER            NO\n         SLL   R1,1                YES\n         SRL   R1,1                NEGATIVE BIT CLEARED\n         LTR   R15,R15             SET CC\n         BR    R8                  RETURN TO CALLER\n*------- CHKPT.                                                  <===*\n*              CHECK IF ZAP NEEDED.\n*              R8 = LINK REGISTER.\nCHKPT    TM    FLAGSX,MUSTZAP      BLOCK NEED A ZAP 1ST?\n         BZR   R8                  NO, LET COMMAND THRU\n         CLC   REPLINE,PREVREP     SAME CMD TWICE IN A ROW?\n         BER   R8                  YES, LET HIM DO IT\n         MVC   MSGLINE+11(58),=CL58'******** ENTER \"ZAP\" OR RE-ENTER PRX\n               EVIOUS COMMAND ********'\n         B     NEWDSPNT            TELL HIM HE CAN'T LEAVE\n*------- CLEAR.                                                  <===*\n*        CLEAR THE SCREEN BUFFER EXCEPT FOR ERROR AND I/O ERROR LINES.\n*              R8 = LINK REGISTER.\nCLEAR    LA    R15,LINE01-2        -> START\n         LA    R0,3                NUMBER OF LINES\n         BAL   R14,CLEARX          CLEAR 1-3\n         LA    R15,LINE06-2        -> START\n         LA    R0,13               NUMBER OF LINES\n         BAL   R14,CLEARX          CLEAR 6-18\n         LA    R15,LINE20-2        -> START\n         LA    R0,2                NUMBER OF LINES\n         BAL   R14,CLEARX          CLEAR 20-21\n         MVI   LINE01-1,X'F8'      PROT HIGH\n         MVI   CMDLINE-1,X'C8'     UNPROT HIGH\n         MVC   IOMLINE-2(2),=XL2'1DF8' I/O ERR.MSG LINE (PROT HIGH)\n         MVC   MSGLINE-2(2),=XL2'1DF8' AND OTHER ERR.MSG LINE\n         MVC   REPLINE-2(2),CMDLINE-2  UNPROT HIGH\n         BR    R8                  RETURN TO CALLER\n*        LOCAL ROUTINE (USED ONLY BY \"CLEAR\") - R14 = LINK REGISTER.\n*              X... ....  SET TO MAKE VALID CHAR\n*              .1.. ....  MUST BE 1\n*              ..1. ....  PROT\n*              ...1 ....  NUMERIC\n*              ..11 ....  AUTOSKIP\n*              .... 00..  DISPLAY / NOT SELECTOR PEN DETECTABLE\n*              .... 01..  DISPLAY / DETECTABLE\n*              .... 10..  HIGH INTENSITY / DETECTABLE\n*              .... 11..  NO DISPLAY / NOT DETECTABLE\n*              .... ..0.  MUST BE 0\n*              .... ...1  MDT FLAG\nCLEARX   MVC   0(2,R15),=XL2'1DF0' PROT AUTOSKIP LOW\n         MVC   2($L,R15),BLANKS    BLANK THE LINE\n         LA    R15,$I(,R15)        -> NEXT LINE\n         BCT   R0,CLEARX           CONTINUE\n         BR    R14                 DONE THIS SECTION\n*------- CLEARDEF.                                               <===*\n*        RESET AND/OR INITIALIZE THE DEFINE TABLE.\n*              R8 = LINK REGISTER.\nCLEARDEF L     R2,AIDEFTAB         POINT TO BEGINNING OF TABLE\n         ST    R2,IDEFAVAL         MAKE THAT THE 1ST AVAIL POSIT\n         LR    R0,R2\n         LH    R1,=Y(24*L'IDEFTAB) LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',BLANKS\n         MVCL  R0,R14              CLEAR OUT THE TABLE ALSO\n         BR    R8                  BACK TO CALLER\n*------- CPUT.                                                   <===*\n*              CPUT = WRITE A \"LOG\" OUTPUT LINE (IF OPENED).\n*              CPUTOP = FORCE OPEN OF \"LOG\" DATA-SET (AND THEN WRITE).\n*              R8 = LINK REGISTER.\nCPUT     TM    FLAGSL,LOGOPN       SEE IF LOGGING\n         BZR   R8                  IF NOT RETURN TO CALLER\nCPUTOP   TM    FLAGSR,YESCSERR     WAS THERE AN ERROR?\n         BOR   R8                  YES, ACT LIKE I DO IT\n         L     R1,CSALOC           GET WORK-AREA ADDRESS\n         XR    R0,R0               (+) SET AS PUT CALL\n         L     R15,=A(CSOUT)       (+) POINT TO ROUTINE\n        CALL   (15)                (+) CALL IT\n         B     *+L'*(R15)          DID IT WORK?\n         B     0(R8)               YES, RETURN TO CALLER\n         B     *+L'*+8             NO, ALLOC. OR OPEN ERROR\n         OI    FLAGSR,YESCSERR     OR RECORD THAT THERE WAS AN ERROR\n         B     BADCSOUT            AND TELL THE USER OF HIS FATE\n         LR    R2,R1               PASS MESSAGE ADDRESS\n         B     BOTCH               AND BYE\n*------- DUMPER.                                                 <===*\n*        DUMP A BLOCK IN DUMP FORMAT.\n*              THIS ROUTINE DUMPS ANY SIZE BLOCK WHICH IS IN THE\n*              BUFFER TO THE OUTPUT RECORDING FILE. THE HEX OFFSETS,\n*              THE ACTUAL HEX DATA, AND THE TRANSLATION OF THAT IS\n*              IS PRINTED OUT.\n*              NOTE : (1) GARBAGE DATA IS NOT PRINTED. THAT IS, DATA\n*                         IS DISPLAYED ONLY UP TO THE LAST BYTE, AND\n*                         NO FARTHER.\n*                     (2) TRANSLATED DATA IS EITHER IN EBCDIC OR IN\n*                         ASCII TRANSLATION, DEPENDING ON WHICH\n*                         COMMAND IS IN EFFECT AT THE TIME OF THE\n*                         DUMP, 'EBCDIC' OR 'ASCII'.\n*                     (3) THE 'PRE-PROCESSOR' ROUTINE 'PREPDUMP' MUST\n*                         BE CALLED FIRST TO GET THE BLOCK, WRITE\n*                         OUT THE BLOCK HEADER LINE, AND TO CHECK FOR\n*                         SYNAD AND EODAD ON THE BLOCK.\n*              R6 = LINK REGISTER.\nDUMPER   L     R3,ADDRBUFF         POINT TO INPUT BUFFER (THE BLOCK)\n         ST    R6,TEMP3+20         SAVE RETURN ADDRESS\n         XR    R4,R4               CLEAR REM REGISTER FOR DIVIDE\n         LH    R5,BLKLEN           GET LENGTH OF BLK\n         D     R4,=F'32'           HOW MANY 4 DBLW LINES IN BLK\n*              R4 HAS THE LENGTH OF THE OFLO 'SHORT' LINE. R5 HAS THE\n*              NUMBER OF LINES TO DUMP OUT (THE NUMBER OR 1 SHORT).\n         LTR   R4,R4               IS THERE A SHORT LAST LINE?\n         BZ    *+L'*+4             NO, HAVE NUMBER OF LINES NOW\n         LA    R5,1(R5)            YES, CORRECT NUM OF LINES\n         XC    TEMP2(4),TEMP2      INITIALIZE OFFSET COUNTER\nDMPFMTLP TM    FLAGSL,LOGOPN       ARE WE LOGGING\n         BZ    BADCSOUT\n         L     R2,CSLLOC           PICK UP BUFFER POINTER\n         MVI   0(R2),C' '          CARRIAGE CONTROL\n        @HEX   (1+0,R2),TEMP2+1,LEN=3 GET OFFSET\n         MVC   1+91(32,R2),0(R3)   MOVE DATA TO DUMP SECTION\n         L     R15,TRTABADD        PICK UP CURRENT TRANSLATE TAB\n         TR    1+91(32,R2),0(R15)  TRANSLATE IT IN PLACE\n         MVI   1+90(R2),C'*'       MOVE IN DELIMITER\n         MVI   1+123(R2),C'*'      MOVE IN DELIMITER\n*              FORMAT THE LINE. THE LINE IS COMPOSED OF 4 COMPLETE\n*              DOUBLE-WORDS. EACH DOUBLE-WORD IS FORMATTED INTO\n*              FULLWORDS SEPARATED BY A BLANK, AND EACH PAIR OF\n*              DOUBLE-WORDS IS SEPARATED BY 3 BLANKS. THUS DUMPER\n*              LOOPS TWICE A LOOP OF 4 PASSES, ONE PER FULLWORD.\n         LA    R14,1+9(R2)         POINT TO 1ST AVAIL LINE POS\n         LA    R6,2                BCT OUTER LOOP (2 PAIRS DBLW'S)\nLINELP1  LA    R4,4                BCT INNER LOOP (4 FULLWORDS)\nLINELP2 @HEX   (0,R14),(0,R3),LEN=4 GET ONE FULLWORD\n         LA    R3,4(,R3)           UPDATE INPUT BUFFER POINTER\n         LA    R14,9(,R14)         UPDATE OUTPUT LINE POINTER\n         BCT   R4,LINELP2          DO IT FOR 4 FULLWORDS\n         LA    R14,3(,R14)         FOR NEXT PAIR OF DBLW'S, SPACE\n         BCT   R6,LINELP1          DO IT FOR 2 PAIRS OF DBLW'S\n         CH    R5,=H'1'            LAST LINE NOW?\n         BE    LASTLINE            YES, CHECK FOR SHORT LAST LINE\n         L     R15,TEMP2           NO, UPDATE OFFSET BY GETTING\n         LA    R15,X'20'(R15)      IT IN THE REG, ADDING INCR,\n         ST    R15,TEMP2           AND PUTTING IT BACK\n         BAL   R8,CPUT             WRITE IT OUT\n         BCT   R5,DMPFMTLP         DO ALL THE LINES EXCEPT LAST\n*              LAST LINE ROUTINE. IF THE LINE IS A SHORT LAST LINE,\n*              ONLY WRITE OUT THE CORRECT AMOUNT OF DATA.\nLASTLINE LH    R1,BLKLEN           GET LENGTH OF BLK\n         N     R1,=F'31'           TURN OFF ALL BUT LOW ORDR BITS\n         LTR   R1,R1               ARE THERE ANY LOW ORDER BITS?\n         BZ    BYELAST             NO, FULL LAST LINE, DUMP IT\n*              GET RID OF THE JUNK IN THE DUMP (TRANSLATED) PART FIRST.\n         LA    R14,32-1-1          MAX WIDTH -1 FOR MVI -1 EX LENGTH\n         SR    R14,R1              GET LENGTH OF JUNK\n         LA    R3,1+91(R2,R1)      POINT TO BEGINNING OF JUNK\n         MVI   0(R3),C' '          KILL THE FIRST BYTE\n         LTR   R14,R14             ANY MORE STUFF TO BLANK?\n         BM    *+L'*+4             NO, GO ON AND FIX THE LINE NOW\n         EX    R14,DMPBKMVC        KILL THAT JUNK\n         XR    R0,R0               CLEAR REM REGISTER FOR DIVIDE\n         D     R0,=F'4'            HOW MANY FLWRD GRPS ARE THERE?\n*              R0 HAS SLOPOVER WITHIN 1 FULLWORD, R1 HAS NUMBER OF\n*              FULLWORDS ON THE LAST LINE.\n         LA    R4,DUMPOFFS(R1)     POINT TO THE TAB TABLE OFFSET\n         XR    R3,R3               CLEAR REGISTER FOR IC\n         IC    R3,0(R4)            GET THE TAB TO THE COLUMN\n         SLL   R0,1                *2 SLOPOVER FOR CHARACTER BYTES\n         AR    R3,R0               OFFSET TO FIRST GARBAGE CHAR\n         LA    R4,86-1             GET MAX LENGTH  OF LINE (-1 MVI)\n         SR    R4,R3               GET LENGTH OF GARBAGE TO BLANK\n         LA    R3,1(R3,R2)         POINT TO 1ST GARBAGE BYTE\n         MVI   0(R3),C' '          BLANK OUT AT LEAST ONE\n         BCTR  R4,0                GET EXECUTE LENGTH\n         LTR   R4,R4               IS THERE ANY MORE TO GET RID OF\n         BM    BYELAST             NO, GOOD BYE LAST LINE\n         EX    R4,DMPBKMVC         GET RID OF THE REST\nBYELAST  BAL   R8,CPUT             WRITE OUT LAST LINE\n         L     R6,TEMP3+20         RESTORE RETURN ADDRESS\n         BR    R6                  RETURN TO CALLER\nDMPBKMVC MVC   1(*-*,R3),0(R3)     <<EXECUTED>>\n*              THUS UNDER CERTAIN CIRCUMSTANCES EOF'S ARE COUNTED\n*              AS RECORDS.\n*------- GETSTRNG.                                               <===*\n*        PARSE OUT HEX OR CHARACTER STRING FOR S, X, O, N, L AND\n*              SET COMMS. DETERMINE STRING LENGTH AND STRING ITSELF,\n*              AND SAVE BOTH IN AREA.\n*              IF DECIMAL - A FULLWORD IS STORED (< 2147483647.).\n*              IF HEXADECIMAL - UP TO 16 DIGITS (DOUBLE-WORD) MAY BE\n*                               STORED.\n*              IF CHARACTER - ANY DELIMITERS MAY SURROUND THE STRING\n*                             EXCEPT STRING EXCEPT HEX DIGITS) AND\n*                             UP TO 16 CHAR (2 DOUBLE-WORDS) MAY BE\n*                             STORED.\n*              R3 = ACTUAL LENGTH OF STRING TO BE PARSED.\n*              R4 = POINTER TO THE STRING ITSELF.\n*              R5 = POINTER TO STRING WORK-AREA (1ST BYTE = LEN).\n*              R6 = LINK REGISTER.\nGETSTRNG LA    R1,1                LENGTH OF HEX TO BE CHECKED\n         LR    R7,R4               LOC OF HEX TO BE CHECKED\n         BAL   R8,HEXCHECK         DO IT\n         B     HEXSTR              FIRST CHAR HEX - SO HEX STRING\n*              CHARACTER STRING.\n         CH    R3,=H'18'           STRING LONGER THAN 16 CHARS?\n         BH    LENERROR            YES, SAY LENGTH ERROR\n         XC    TEMPTRT(256),TEMPTRT CLEAR OUT TRTAB\n         XR    R1,R1               CLEAR OUT WORK REGISTER\n         IC    R1,0(,R4)           GET DELIM FOR CHAR STRING\n         STC   R1,TEMPTRT(R1)      PUT IT IN RIGHT PLACE IN TRTAB\n         SH    R3,=H'2'            GET ADJUST STRING LENGTH (DELIMS)\n         BNP   LENERROR            HE ENTERED S'' OR LESS - ERROR\n         EX    R3,DELIMTRT         FIND THE OTHER DELIMITER\n         LA    R2,=CL20'NO ENDING DELIMITER' GET MESSAGE ADDR. IN CASE\n         BZ    BOTCH               NO, TELL HIM\n         LA    R3,1(,R4)           POINT TO BEGINNING OF STRING\n         SR    R1,R3               GET STRING LENGTH (NO DELIMS)\n         LR    R3,R1               PUT IN RIGHT REGISTER\n         BCTR  R3,0\n         LTR   R3,R3               NULL INPUT?\n         BM    LENERROR            YES, SAY LENGTH ERROR\n         LR    R1,R4\n         CLI   CAPSFLG,YESCAPS\n         BE    SKCAPS\n         LA    R0,TEMP3\n         SLR   R4,R0\n         LA    R4,ICREP(R4)\nSKCAPS   EX    R3,CHARMVC          MOVE STRING CHARS TO AREA\n         LR    R4,R1\n         B     FINSTR              GO FINISH THE JOB\nDELIMTRT TRT   1(*-*,R4),TEMPTRT   <<EXECUTED>>\nCHARMVC  MVC   2(*-*,R5),1(R4)     <<EXECUTED>>\nLENERROR LA    R2,LENERR           YES, SAY LENGTH ERROR\n         B     BOTCH               GO TELL HIM\n*              HEX STRING.\nHEXSTR   CH    R3,=H'16'           HEX STRING LONGER THAN 16?\n         BH    LENERROR            YES, SAY LENGTH ERROR\n         LR    R1,R3               PUT IT IN RIGHT REGISTER FOR CHECK\n         LR    R7,R4               POINT TO LOC TO CHECK\n         BAL   R8,HEXCHECK         CHECK THE HEX\n         B     OK1#                ITS GOOD\n         CLI   0(R7),C' '          IS IT HEX?\n         BE    OK1#                YES, GO DO IT\n         CLI   0(R7),C'.'          DECIMAL?\n         BE    DECMAYBE            MAY BE SO\n         LA    R2,=CL20'INVALID HEXADECIMAL' IT'S BAD, POINT TO MESSAGE\n         B     BOTCH               TELL HIM\nOK1#     TR    0(16,R4),HEXTAB     YES, START TO CONVERT TO HEX\n         CH    R3,=H'15'           IS THIS THE MAX CASE?\n         BL    HEXPACK             NO, DO JUST ENOUGH\n         PACK  TEMP2(5),0(9,R4)    PACK FIRST GROUP\n         PACK  TEMP2+4(5),8(9,R4)  PACK SECOND GROUP\n         BH    HEX16               SKIP IF 16 DIGITS\n         LM    R14,R15,TEMP2       GET THE RESULT\n         SRDL  R14,4               DOWN 1 NIBBLE\n         STM   R14,R15,TEMP2       RESTORE IT CORRECTLY\nHEX16    LA    R3,7                NUMBER OF BYTES (EX LEN)\n         MVC   2(8,R5),TEMP2       GET HEX\n         B     FINSTR              AND THEN RETURN TO CALLER\n*              R3 IS NOT BCTRED BECAUSE WE NEED A FLIP BYTE ON THE END.\n         PACK  TEMP2(8),0(0,R4)    <<EXECUTED>>\nHEXPACK  EX    R3,*-6              PACK TO MAKE REAL HEX\n         LA    R3,1(,R3)           ROUND UP ...\n         SRL   R3,1                AND FIND NUMBER OF BYTES\n         LA    R15,TEMP2+7         POINT TO GORF BYTE\n         SR    R15,R3              POINT TO FIRST BYTE\n         BCTR  R3,0                GET EXECUTE LENGTH\n         EX    R3,MOVEHEX          MOVE HEX TO OUTPUT LOCATION\nFINSTR   STH   R3,0(,R5)           SAVE THE LENGTH IN SCAN AREA\n         BR    R6                  RETURN TO CALLER\nMOVEHEX  MVC   2(*-*,R5),0(R15)    <<EXECUTED>>\n*              DECIMAL STRING.\nDECMAYBE BXLE  R15,R15,*+L'*+8     IF REALLY DECIMAL - JUMP\n         LA    R2,INVDEC           NO, TELL HIM SO BECAUSE...\n         B     BOTCH               ITS GOT A-F IN IT\n         CH    R3,=H'10'           APPROACHING LENGTH ERR (BCTR'D)?\n         BL    *+L'*+10            NO, DON'T WORRY ABOUT IT\n         CLC   0(11,R4),=CL11'2147483647.' TOO BIG FOR FULLWORD?\n         BH    LENERROR            YES, TELL HIM AND GET OUT\n         LA    R0,1(R4)            POINT TO STRING + 1 FOR TO....\n         SR    R7,R0               GET EXECUTE LENGTH\n         EX    R7,DECPACK          PACK UP YOUR DECIMALS IN ...\n         CVB   R1,TEMP2            AND CONVERT, CONVERT, CONVERT\n         ST    R1,TEMP2            SAVE IN ALIGNED PLACE\n         MVC   2(4,R5),TEMP2       COPY TO OUTPUT STRING\n         MVI   1(R5),3             EXECUTE LENGTH\n         BR    R6                  RETURN\nDECPACK  PACK  TEMP2(8),0(0,R4)    <<EXECUTE>>\n*------- HEXCHECK.                                               <===*\n*        VALIDITY CHECK FOR HEXADECIMAL, DECIMAL, OR CHARACTER.\n*              R7 = POINTER TO STRING.\n*              R1 = LENGTH OF STRING.\n*              R8 = LINK REGISTER.\n*                   NOTE : 0(R8)=GOOD HEX, 4(R8)=BAD HEX AT 0(R7).\n*              R15 = 0 IF PURE DECIMAL UP TO EXIT, 4 IF HEX.\nHEXCHECK XR    R15,R15             ASSUME DECIMAL\nHEXCHK   TM    0(R7),X'F0'         NUMBER?\n         BO    OKHEX               YES, ITS OK\n         CLI   0(R7),C'A'          LESS THAN ALPHA?\n         BL    4(R8)               YES, MUST BE CHARACTER\n         CLI   0(R7),C'F'          'F' OR SMALLER?\n         BH    4(R8)               NO, MUST BE CHARACTER\n         LA    R15,4               INDICATE HEX (NOT DECIMAL)\nOKHEX    LA    R7,1(R7)            SO FAR SO GOOD, UPDATE HEX POINTER\n         BCT   R1,HEXCHK           DO THE WHOLE STRING\n         BR    R8                  WE'RE OK - ALL DONE\n*------- LOGTEST, OPENMSG.                                       <===*\n*              LOGTEST = CHECK IF WE MUST OPEN THE \"LOG\", AND THEN\n*              OPENMSG = OUTPUT MESSAGE OF \"LOG\" DATA-SET OPENED.\n*              R8 = LINK REGISTER.\nLOGTEST  TM    FLAGSL,LOGOPN       ALREADY LOGGING?\n         BOR   R8                  YES, ALL DONE\n         TM    FLAGSL,LOGFS+LOGRQ  NO, WE MUST LOGGING?\n         BZR   R8                  NO, ALL DONE\n         MVI   CHNGED,0            VIRGIN BUFFER\nOPENMSG  ST    R8,ZDBLW            SAVE FOR LATER\n         L     R1,CSLLOC           -> LINE TO USE\n         MVC   0(L'OPNMSG,R1),OPNMSG\n         CLI   ZDSNME,X'04'        VTOC?\n         BNE   *+L'*+4             NO, INFORMATION ONLY\n         MVI   OPNMS1(R1),C'A' (ACTION) MAKE OP. SIT UP AND TAKE NOTICE\n         TM    DCBLIST,X'0F'       NOW, WAS IT OPEN FOR INPUT?\n         BZ    *+L'*+10            YES, SO THERE'S NOTHING TO DO\n         MVC   OPNMS3(6,R1),=CL6'UPDATE' IF UPDATING, SAY UPDATE\n         MVI   OPNMS1(R1),C'A'     ACTION MESSAGE\n         MVC   OPNMS2(L'ZUSRID,R1),ZUSRID CULPRIT\n         MVC   OPNMS4(44,R1),DISPDSN MOVE IN DISPLAYABLE DS-NAME\n         CLI   ZDSNME,X'04'        VTOC HERE?\n         BE    *+L'*+12            YES, VOL-SER ALREADY SET\n         MVC   OPNMS5(2,R1),=CL2'ON' ADD\n         MVC   OPNMS6(6,R1),ZVOLSER VOL-SER\n         BAL   R8,CPUTOP           FORCE OPEN AND OUTPUT THE LINE\n         L     R8,ZDBLW            PICK UP RETURN ADDRESS\n         BR    R8                  ALL OK - RETURN NORMALLY\n*------- NUMCONV.                                                <===*\n*              R15 = NUMBER TO BE CONVERTED.\n*              R14 = LINK REGISTER.\n*                    NUMBER IS CONVERTED TO 12 SIGNED DECIMAL\n*                    DIGITS AT TEMP3, AND TO HEX AT TEMP3+12\n*                    (8 CHARS).\nNUMCONV  ST    R15,TEMP2           SET FOR UNPK\n         UNPK  TEMP3+12(8+1),TEMP2(4+1)\n         TR    TEMP3+12(8),HEXTAB  MAKE EBCDIC\n         CVD   R15,TEMP2           GET IN PACKED FORM\n         LA    R1,TEMP3+11         INIT. LOC FOR FLOATING SIGN\n         MVC   TEMP3(12),EDMASK    MOVE IN EDIT MASK\n         EDMK  TEMP3(12),TEMP2+2   GET 11 DECIMAL DIGITS\n         LTR   R15,R15             IS IT NEGATIVE?\n         BNMR  R14                 NO, ALL DONE\n         BCTR  R1,0                YES, SO BACK UP AND...\n         MVI   0(R1),C'-'          ...PUT IN THE SIGN\n         BR    R14                 NOW DONE\n*------- PREPDUMP.                                               <===*\n*        THIS ROUTINE IS THE 'PRE-PROCESSOR' TO THE DUMPER.\n*              IT GETS THE BLOCK TO BE DUMPED, PREPARES AND WRITES\n*              OUT THE BLOCK HEADER LINE (WITH TTR, LENGTH, AND\n*              CCHHR), AND IF THERE IS AN EOF OR I/O ERROR AT THE\n*              BLOCK, AND MESSAGE IS PUT OUT TO THE RECORDING FILE\n*              AND THE 'BLOCK' IS NOT DUMPED.\n*              R6 = LINK REGISTER.\n*              RETURNS : 0(R6) - NORMAL RETURN WITH DUMP OF BLOCK\n*                                TO FOLLOW.\n*                        4(R6) - I/O ERROR OR EOF, RETURN WITH NO\n*                                DUMP, OR EXIT FROM ENTIRE DUMPING\n*                                LOOP IF I/O ERROR WAS 'OUT OF\n*                                DATA-SET', MEANING THERE IS NO\n*                                MORE DATA-SET, NO MORE EXTENT.\nPREPDUMP NI    FLAGSR,255-YESEOF   SAY ALSO EOF'S ARE DATA BLOCKS\n         BAL   R8,READBLK          GET THE BLOCK, SUCH AS IT IS\nPREPDMPX TM    FLAGSL,LOGOPN       ARE WE LOGGING?\n         BZ    NEWDSPNT            IF NOT FORGET THIS\n         L     R2,CSLLOC           GET LINE ADDRESS\n         MVC   1+0(40,R2),=CL40'LENGTH=XXXXX TTR=XXXXXX CCHHR=XXXXXXXXXX\n               X'\n         LH    R1,BLKLEN           GET THE LENGTH OF THE BLK\n         CVD   R1,TEMP2            PACKED DEC\n         UNPK  1+7(5,R2),TEMP2+5(3) PUT LENGTH INTO MESSAGE\n         OI    1+11(R2),X'F0'      FIX FLIP BYTE\n        @HEX   (1+17,R2),TTR,LEN=3 CONVERT TTR\n        @HEX   (1+30,R2),CCHHR,LEN=5 CONVERT CCHHR\n         MVI   0(R2),C'-'          TRIPLE SPACE BEFORE HDR PRINTED\n         BAL   R8,CPUT             PUT OUT THE LINE\n         TM    FLAGSR,YESSYN       I/O ERROR IN READ BEFORE?\n         BO    OOPSDUMP            YES, DON'T DUMP, JUST MESSAGE\n         CLC   IOMLINE+27(20),EOFMSG NO, BUT WAS THERE AN EOF?\n         BNER  R6                  NO, RETURN NORMALLY AND DUMP\n*              EITHER THE BLOCK HAS AN I/O ERROR WAS AN END-OF-FILE,\n*              SO WE CANNOT DUMP. INSTEAD, PRINT OUT, IF POSSIBLE, THE\n*              TYPE OF CONDITION WHICH HAS OCCURRED, AND RETURN BEYOND\n*              DUMP CODE - 4(R6). IF THE I/O ERROR 'NOT IN DATA-SET'\n*              HAS OCCURRED, THEN STOP THE PROCESS ALL TOGETHER. WE\n*              ARE AT THE REAL END OF THE DATA-SET.\nOOPSDUMP TM    FLAGSL,LOGOPN       ARE WE LOGGING\n         BZ    NEWDSPNT            IF NOT FORGET IT\n         L     R2,CSLLOC           GET ADDRESS OF BUFFER\n         MVC   1+0(40,R2),IOMLINE+17 COPY EXACTLY WHAT IS ON THE SCREEN\n         MVI   0(R2),C' '          CARRIAGE CONTROL\n         BAL   R8,CPUT             WRITE IT OUT\n         CLC   IOMLINE+35(15),=CL15'NOT IN DATA-SET' END OF EXTENT?\n         BE    NEW$DISP            YES, GET OUT OF LOOP AND DISP\n         CLC   IOMLINE+27(20),EOFMSG WAS IT EOF?\n         BE    NEW$DISP            YES, GET OUT AND DISPLAY LOC\n         B     4(R6)               NO, BUT DON'T DUMP THIS 'BLK'\n*------- READBLK.                                                <===*\n*        EXCP READ A BLOCK (PHYSICAL RECORD) INCLUDING KEY (IF ANY).\n*              IF TTR+3 CONTAINS A 1 (FLAG) THEN READ SEQUENTIALLY,\n*              SIMULATING BSAM.\n*              R8 = LINK REGISTER (SAVED IN \"ZDBLW\").\nREADNBLK MVI   TTR+3,SEQREAD       SET NEXT BLOCK FLAG\nREADBLK  NI    FLAGSR,255-YESSYN   START WITH NO I/O ERROR\n         ST    R8,ZDBLW            SAVE RETURN ADDRESS\n         BAL   R8,CHKPT            SEE IF HE CAN LEAVE\n         CLI   TTR+3,SEQREAD       DO BLOCK +1?\n         BNE   READBLK#            NO\n         IC    R15,TTR+2           GET RECORD NO\n         LA    R15,1(R15)          NEXT RECORD\n         STC   R15,TTR+2           NEXT ONE\nREADBLK# MVC   IOMLINE,BLANKS      CLEAR I/O ERR-MSG IF ANY\n         CLI   CHNGED,0            BUFFER TAMPERED WITH W/O CHKPT?\n         BE    NORDBMSG            NO, ITS OK TO READ THEN\n         MVI   CHNGED,0            WELL IT'LL BE CLEAN NOW\n         NI    FLAGSX,255-MUSTZAP  NEW BLOCK, NO ZAP NEEDED YET\n         LA    R1,4                MESSAGE NUMBER\n         BAL   R8,SETLINE          SETUP THE LINE\n         B     NORDBMSG            NOT LOGGING\n         MVC   30(18,R2),=CL18'BLOCK NOT REPLACED'\n         MVI   0(R2),C'0'          DOUBLE SPACE\n        @HEX   (24,R2),OLDTTR,LEN=3 DIFF TTR THIS TIME\n         BAL   R8,CPUT             DUMP THE LINE\nNORDBMSG L     R8,ZDBLW            RESTORE RETURN REGISTER\n         XC    BLKLEN(2),BLKLEN    ASSUME NOTHING READ\n         LA    R15,CCW##R          -> CCW CHAIN\n         CLI   TTR+2,0             R0?\n         BNE   *+L'*+4             NO, OK\n         LA    R15,CCW##R0         READ R0\n         STCM  R15,B'0111',ZIOB+(IOBSTRTB-IOBSTDRD) SET IN IOB\n         L     R0,TTR              GIVE HIM THE TTRN\n         N     R0,=XL4'FFFFFF00'     MAKE IT A TTRN\n         XR    R1,R1\n         ICM   R1,B'0111',DCBU+DCBDEBA-IHADCB GIVE HIM THE DEB\n         LA    R2,ZIOB+(IOBSEEK-IOBSTDRD) GIVE HIM A WORK-AREA FOR IT\n         STM   R8,R12,20+R8*4(R13) SAVE SOME REGISTERS\n         LR    R8,R13              SAVE POINTER TO SAVE-AREA\n         L     R15,CVTPTR          CVT POINTER\n         L     R15,CVTPCNVT-CVT(,R15) POINT TO THE ROUTINE\n        CALL   (15)                GO DO IT\n         LR    R13,R8              RESTORE POINTER TO SAVE-AREA\n         LM    R8,R12,20+R8*4(R13) RESTORE THE DEAD REGS\n         LTR   R15,R15             OUT OF DS?\n         BNZ   EXCP42              YES, DON'T BOTHER READING\n         IC    R1,CCHHR+4          GET \"R\"\n         BCTR  R1,0                -1 FOR SEARCH ID\n         STC   R1,CCHHR+4          SET BACK\n        EXCP   ZIOB\n        WAIT   ECB=ZECB\n         MVC   CCHHR+4(1),TTR+2    RESTORE \"R\"\n         LH    R2,BUFFSIZE         GET BUFSIZ (MAX READ=BLKSI)\n         SH    R2,ZIOB+(IOBCSW-IOBSTDRD)+5 = AMOUNT READ\n         LR    R0,R2               COPY 8+KL+DL\n         SH    R0,=H'8'            GET KEY-LENGTH + DATA-LENGTH\n         STH   R0,CCW#W#W+6        SAVE IT FOR LATER USE\n         L     R1,ADDRCNT          -> COUNT\n         MVC   KEYLEN+1(1),5(R1)   SET UP KEY-LENGTH\n         LH    R15,KEYLEN          GET KEY-LENGTH\n         LA    R0,8(R1,R15)        -> DATA\n         ST    R0,ADDRDATA         SET ADDRESS OF DATA\n         CLC   ADDRBUFF,ADDRKEY    HOW MUCH DO WE DISPLAY?\n         BL    SAVE$LEN            COUNT + KEY + DATA\n         BE    *+L'*+2             KEY + DATA\n         SR    R2,R15              JUST DATA\n         SH    R2,=H'8'            NOT COUNT FIELD\nSAVE$LEN STH   R2,BLKLEN           SAVE IT FINALLY\n*              NOW CHECK THE READ, FINALLY...\n         CLI   ZECB,ECBNORM        OK?\n         BE    EXCPOK\n         CLI   ZECB,ECBDAEA        END OF EXTENT\n         BE    EXCP42\n         CLI   ZECB,ECBPERR        PERM ERROR?\n         BE    EXCP41\nREALERR  LA    R1,=CL15' TYPE UNKNOWN  ' GET MESSAGE ADDRESS\nEXCPERR  XR    R0,R0               GET A ZERO\n         STH   R0,BLKLEN           NOTHING WAS READ\n         STH   R0,CCW#W#W+6        AND NOTHING TO WRITE\nEXCPERR$ OI    FLAGSR,YESSYN       AND IT WAS IN ERROR\n         MVC   IOMLINE+17(40),IOERRMSG MOVE IN MASK\n         MVC   IOMLINE+35(15),0(R1) MOVE IN ERROR MESSAGE\n         MVI   TTR+3,NOSEQRD       TURN OFF SEQ READ FLAG\n         BR    R8\nEXCP42   LA    R1,=CL15'NOT IN DATA-SET' GET MESSAGE ADDRESS\n         B     EXCPERR\nEXCP41   TM    ZIOB+(IOBUSTAT-IOBSTDRD),IOBUSB7 UNIT EXCEPTION?\n         BO    EODAD               YES, EOF\n         TM    ZIOB+(IOBSENS1-IOBSTDRD),IOBS1B4 NRF?\n         BZ    NOT$NRF             NO\nEXCP$NRF CLI   TTR+3,SEQREAD       NEXT BLOCK REQ?\n         LA    R1,=CL15'NO RECORD FOUND' GET MESSAGE ADDRESS IN CASE\n         BNE   EXCPERR\n         LH    R15,TTR             GET TRACK\n         LA    R15,1(,R15)         NEXT TRACK\n         STH   R15,TTR             SAVE IT\n         MVI   TTR+2,1             RECORD 1\n         MVI   TTR+3,NOSEQRD       RESET SEQ READ FLAG\n         B     READBLK             GO REREAD\nNOT$NRF  TM    ZIOB+(IOBCSTAT-IOBSTDRD),IOBCSB1 INCORRECT LENGTH?\n         BZ    REALERR             NO, SOMETHING ELSE\n         LA    R1,=CL15'INCORR. LENGTH ' GET MESSAGE ADDRESS\n         B     EXCPERR             GO SAY INCORRECT LENGTH\nEXCPOK   L     R15,ADDRCNT         -> COUNT\n         CLC   CCHHR(L'CCHHR),0(R15) RIGHT RECORD?\n         BE    EXCPOK$             YES, CONTINUE\n         LA    R1,=CL15'CCHHR INCORRECT' GET MESSAGE ADDRESS IN CASE\n         CLC   CCHHR(4),0(R15)     RIGHT CCHH?\n         BNE   EXCPERR$            NO, ARRGH\n         CLI   4(R15),1            IS IT R1?\n         BE    EXCP$NRF            YES, IT'S REALLY NRF\n         B     EXCPERR$            NO, ARRGH\nEXCPOK$  MVI   TTR+3,NOSEQRD       TURN OFF SEQ READ FLAG\n         OC    ZIOB+(IOBCSW-IOBSTDRD)+5(2),ZIOB+(IOBCSW-IOBSTDRD)+5 ANYX\n                                   RESIDUAL?\n         LA    R1,=CL15'BLKLEN > BUFFSZ'   -> MESSAGE IN CASE\n         BZ    EXCPERR$            NO, ERROR\n         BR    R8                  ALL DONE, RETURN BLOCK\n*- - - - END-OF-FILE (EODAD EXIT).\n*              IF EOF'S ARE NOT COUNTED AS BLOCKS (AS IN A PDS),\n*              THEN DISPLAY END OF FILE. OTHERWISE HOP THEM.\nEODAD    LR    R2,R8               SAVE RETURN TO READ\n         BAL   R8,CLEAR            CLEAR SCREEN\n         MVC   IOMLINE,BLANKS      CLR TOP ERR-MSG SO CAN SAY EOF\n*              LENGTH OF EOF RECORD IS ALREADY SET.\n         MVC   IOMLINE+27(20),EOFMSG TELL HIM END-OF-FILE\n         MVI   TTR+3,NOSEQRD       TURN OFF SEQ READ\n         TM    FLAGSR,YESEOF       EOF ALLOWED HERE?\n         BO    NEW$DISP            YES, SO EOF ALREADY\n         BR    R2                  NO, EXIT FROM READBLK (EOF)\n*------- SETLINE.                                                <===*\n*        SET UP LINE MESSAGE NUMBER FOR \"CPUT\".\n*              INPUT : R1 IS THE SINGLE MESSAGE NUMBER IN CHAR. FORM.\n*                      R8 = LINK REGISTER.\n*                      RETURNS : 0(R8) - IF NOT LOGGING,\n*                                4(R8) - IF LOGGING.\n*              OUTPUT : R2 POINTS TO LINE (ONLY ON 4(R8) RETURN).\nSETLINE  TM    FLAGSL,LOGOPN       ARE WE LOGGING?\n         BZR   R8                  IF NOT RETURN\n         L     R2,CSLLOC           GET THE LINE\n         MVC   1(7,R2),=CL7'ZAP010I' MOVE IN MESSAGE NUMBER\n         MVC   9(L'ZUSRID,R2),ZUSRID CULPRIT\n         LTR   R1,R1               IS NUMBER 0?\n         BNP   4(R8)               YES, OK\n         STC   R1,6(R2)            BUILD DIGIT NUMBER\n         OI    6(R2),C'0'\n         CH    R1,=H'4'            IS TTR NEEDED?\n         BH    4(R8)               NO, GO BACK TO CALLER\n         MVC   18(3,R2),=CL3'TTR'\n        @HEX   (22,R2),TTR,LEN=3   GET THIS TTR\n         B     4(R8)               NOW RETURN TO CALLER\n*------- SETMSG.                                                 <===*\n*        MOVE MESSAGE AND HYPHENS TO CORRECT POSITION ON SCREEN.\n*              INPUT : R1 = POINTS TO CL20'...MESSAGE...'.\n*                      R8 = LINK REGISTER.\nSETMSG   LH    R1,0(,R8)           GET MESSAGE OFFSET\n         AR    R1,R12              GET ADDRESS\nSETMSGX  MVC   MSGLINE+27(20),0(R1) MOVE IT TO CENTER\n         MVC   MSGLINE+17(9),=9C'=' MAKE IT FANCY\n         MVC   MSGLINE+48(9),=9C'=' BUT DON'T GET CARRIED AWAY\n         B     2(,R8)              RETURN PAST OFFSET\n*------- SETSTRNG.                                               <===*\n*        CONVERT STRING FOR \"CPUT\".\n*              INPUT : R1 = POINTER TO OUTPUT LINE.\n*                      R4 = EXECUTE LENGTH OF STRING.\n*                      R5 = ADDRESS OF DATA TO BE CONVERTED.\n*                      R8 = LINK REGISTER.\nSETSTRNG UNPK  TEMPW(9),0(5,R5)    CONVERT FIRST WORD\n         UNPK  TEMPW+8(9),4(5,R5)  CONVERT SECOND\n         UNPK  TEMPW+16(9),8(5,R5) CONVERT THIRD\n         UNPK  TEMPW+24(9),12(5,R5) CONVERT FOURTH AND LAST\n         TR    TEMPW(32),HEXTAB    FIX UP HEX\n         LTR   R4,R4               ANY?\n         BMR   R8                  NO, LEAVE IT BLANK\n         LA    R15,1(R4,R4)        GET EXECUTE LENGTH OF HEX\n         EX    R15,CPMVC           MOVE CONVERTED DATA\n         MVI   35(R1),C''''\n         EX    R4,SETSTRMV         MOVE CHAR FORM TO BUFFER\n         L     R15,TRTABADD        GET RIGHT TRTAB POINTER\n         EX    R4,SETSTRTR         TRANSLATE TO RIGHT CHARSET\n         LA    R15,36+1(R4,R1)\n         MVI   0(R15),C''''\n         BR    R8                  RETURN\nCPMVC    MVC   0(*-*,R1),TEMPW     <<EXECUTED>>\nSETSTRMV MVC   36(*-*,R1),0(R5)    <<EXECUTED>>\nSETSTRTR TR    36(*-*,R1),0(R15)   <<EXECUTED>>\n*------- STRCNV.                                                 <===*\n*        STRING CONVERSION ROUTINE.\n*              R8 = LINK REGISTER.\n*              R14 = STRING ADDRESS.\nSTRCNV   LH    R1,0(R14)           GET STRING LENGTH\n         EX    R1,STRCNVM          TARGET OUTPUT STRING\n         ICM   R15,B'1111',TRTXTAB\n         BZR   R8\n         EX    R1,STRCNVT          TRANSLATE STRING\n         BR    R8                  RETURN TO CALLER\nSTRCNVM  MVC   WKSTR(*-*),2(R14)   <<EXECUTED>>\nSTRCNVT  TR    WKSTR(*-*),0(R15)   <<EXECUTED>>\n*------- TTRPARSE.                                               <===*\n*        DETERMINES AND VALIDITY CHECKS TTR SPECIFIED.\n*              R1 = POINTS TO THE TTR.\n*              R0 = HAS ITS LENGTH - OUTPUT IS IN TEMP2+1(3).\n*              R6 = LINK REGISTER.\nTTRPARSE L     R15,TTR             GET '*' = CURRENT TTR\n         SRL   R15,8               RIGHT JUSTIFY\n         BAL   R8,CALLEXP          GO PARSE\n         BNP   TTRLT1              NOT POSITIVE IS INVALID\n         ST    R15,TEMP2           SAVE THE VALUE RETURNED\n         CLI   TEMP2+3,0           REC 0?\n         BNZR  R6                  NO, GIVE IT\n         LA    R2,REC0INV          YES, TELL HIM\n         B     BOTCH               WITH A MESSAGE\nTTRLT1   LA    R2,TTRSMALL         POINT TO ERROR MESSAGE\n         B     BOTCH               DISPLAY ERROR STYLE\n*------- WRITE.                                                  <===*\n*        EXCP WRITE OUT A BLOCK.\n*              R8 = LINK REGISTER.\nWRITE    LA    R14,CCW##W          -> CCW CHAIN\n         STCM  R14,B'0111',ZIOB+(IOBSTRTB-IOBSTDRD) SET IN IOB\n        EXCP   ZIOB\n        WAIT   ECB=ZECB\n         CLI   ZECB,ECBNORM\n         BER   R8\n         B     REALERR\n         EJECT\n*------- CONSTANTS --------------------------------------------------*\n         SPACE 1\nOBTLIST CAMLST SEARCH,*-*,*-*,*-*\nOBTLISTL EQU   *-OBTLIST\n         DC    XL6'0A0B0C0D0E0F',41C'.' FOR CHAR TO HEX   |CONTIGUOUS|\n         DC    CL16'0123456789ABCDEF'                     |CONTIGUOUS|\nHEXTAB   EQU   *-256\n         SPACE 1\nEDMASK   DC    XL12'402020202020202020202120'\nITRTBL   DC    0H'0',AL2(L'ITRTAB)\nDUMPOFFS DC    AL1(9,18,27,36,48,57,66,75)\nMAXWIDTH DC    A((MSGLINE-LINE06-$I)/$I/2)\n         SPACE 1\nCTL3270  DC    XL2'4040'           SBA (1,1)\n         DC    XL2'C150'               (2,1)\n         DC    XL2'C260'               (3,1)\n         DC    XL2'C3F0'               (4,1)\n         DC    XL2'C540'               (5,1)\n         DC    XL2'C650'               (6,1)\n         DC    XL2'C760'               (7,1)\n         DC    XL2'C8F0'               (8,1)\n         DC    XL2'4A40'               (9,1)\n         DC    XL2'4B50'               (10,1)\n         DC    XL2'4C60'               (11,1)\n         DC    XL2'4DF0'               (12,1)\n         DC    XL2'4F40'               (13,1)\n         DC    XL2'5050'               (14,1)\n         DC    XL2'D160'               (15,1)\n         DC    XL2'D2F0'               (16,1)\n         DC    XL2'D440'               (17,1)\n         DC    XL2'D550'               (18,1)\n         DC    XL2'D660'               (19,1)\n         DC    XL2'D7F0'               (20,1)\n         DC    XL2'D940'               (21,1)\nNL3270   EQU   (*-CTL3270)/L'CTL3270\nEND3270  DS    0XL4\n         DC    XL3'11C1D1'         SBA (2,2)\n         DC    XL1'13'             IC\n         SPACE 1\n*- - - - CONSTANTS FOR DISPLAY ROUTINE (TRTAB FOR CARET).\nTBYTES   DC    AL1(7,12,12,17,18,23,23,28,30,35,35,40,41,46,46,51)\nDSPTRT   DC    AL1(48)                  BLANK               +08\n         DC    AL1(16,17,18,19,48)      BYTES 01, 02        +09\n         DC    AL1(20,21,22,23,48,48)   BYTES 03, 04        +14\n         DC    AL1(24,25,26,27,48)      BYTES 05, 06        +20\n         DC    AL1(28,29,30,31,48,48,48)      07, 08        +25\n         DC    AL1(32,33,34,35,48)            09, 10        +32\n         DC    AL1(36,37,38,39,48,48)         11, 12        +37\n         DC    AL1(40,41,42,43,48)            13, 14        +43\n         DC    AL1(44,45,46,47)               15, 16        +48\n         DC    AL1(48,48,48,49)         '   |'              +52\n         DC    AL1(0,1,2,3,4,5,6,7)     FIRST 8 CHARS       +56\n         DC    AL1(8,9,10,11,12,13,14,15)  LAST 8 CHARS     +64\n         DC    AL1(49)                                      +72\nDSPTRTL  EQU   *-DSPTRT            LENGTH\n         SPACE 1\nINVMEM   DC    CL20'MEMBER NOT FOUND    '\nSTORMSG  DC    CL20'NOTE: NOT UPDATING  '\nEOFMSG   DC    CL20'*** END OF FILE *** '\nNOMEMFND DC    CL20'*NO DIRECTORY ENTRY*'\nIOERRMSG DC    CL40' ***** I/O ERROR: XXXXXXXXXXXXXXX ***** '\nOPNMSG   DC    CL41'0ZAP009I XXXXXXXX HAS OPENED FOR INPUT '\nOPNMS1   EQU   7,1                 (ACTION)\nOPNMS2   EQU   9,8                 (USER-ID)\nOPNMS3   EQU   33,6                (INPUT/UPDATE)\nOPNMS4   EQU   40,44               (DATA-SET NAME)\nOPNMS5   EQU   85,2                (\"ON\")\nOPNMS6   EQU   88,6                (VOLUME)\nLOGMSG   MSG   'LOGGING'\nNAMEMNF  MSG   'NAME INVALID'\nOBTMSG   MSG   'OBTAIN FAILED'\nCONMSG   MSG   '<STR> CAPS ON'\nINVMSG   MSG   'INVALID PK-KEY'\nCOFFMSG  MSG   '<STR> CAPS OFF'\nLENERR   MSG   'LENGTH INVALID'\nBADEQUAL MSG   'INVALID SYMBOL'\nINVCOM   MSG   'INVALID COMMAND'\nNOMCOM   MSG   'NOT PARTITIONED'\nINVDEC   MSG   'INVALID DECIMAL'\nLASTINV  MSG   'INVALID IN VTOC'\nDUMPWMSG MSG   'DUMP SUCCESSFUL'\nINVOPCOD MSG   'INVALID OP CODE'\nREC0INV  MSG   'RECORD 0 INVALID'\nINVFMSG  MSG   'NO FORWARD CHAIN'\nREDEFMSG MSG   'SYMBOL REDEFINED'\nNOCSOUT  MSG   'UNABLE TO RECORD'\nNOTVMSG  MSG   'DATA-SET NOT VTOC'\nWRITERR  MSG   'WRITE NOT ALLOWED'\nASCIIMSG MSG   'ASCII TRANSLATION'\nZCODEMSG MSG   'ZCODE TRANSLATION'\nINVBMSG  MSG   'NO BACKWARD CHAIN'\nTABFULL  MSG   'DEFINE TABLE FULL'\nOZFMSG   MSG   'OPEN \"ZAP\" FAILED'\nFZFMSG   MSG   'FREE \"ZAP\" FAILED'\nINVEXP   MSG   'SYNTAX ERROR COL. '\nIOTPMSG  MSG   'TSO-TPUT I/O ERROR'\nIOTGMSG  MSG   'TSO-TGET I/O ERROR'\nEBCDCMSG MSG   'EBCDIC TRANSLATION'\nLINMSG   MSG   'SCAN NOT IN EFFECT'\nDEFRESET MSG   'DEFINE TABLE RESET'\nNFDMSG   MSG   'DATA-SET NOT FOUND'\nAZFMSG   MSG   'ALLOC \"ZAP\" FAILED'\nIORDMSG  MSG   'EXCP-READ I/O ERROR'\nCEXMSG   MSG   'PA1 PRESSED = CANCEL'\nIOWRMSG  MSG   'EXCP-WRITE I/O ERROR'\nTTRSMALL MSG   'TTR < 000001 INVALID'\nBACKDUMP MSG   'REVERSE DUMP INVALID'\nDSNXMSG  MSG   'DATA-SET : NO EXTENT'\nGMBMSG   MSG   'GETMAIN BUFFER ERROR'\n         AIF   ('&TXV' NE 'EUROPE').SK1\nOUCH     MSG   '... OUCH|||'\nRTLMSG   MSG   'RESPONSE TOO LONG|||'\nSFEMSG   MSG   'SCREEN FORMAT ERROR|'\n         AGO   .SK2\n.SK1     ANOP\nOUCH     MSG   '... OUCH!!!'\nRTLMSG   MSG   'RESPONSE TOO LONG!!!'\nSFEMSG   MSG   'SCREEN FORMAT ERROR!'\n.SK2     SPACE 1\n*------- LITERAL POOL. ----------------------------------------------*\n         PRINT &PRS\n        LTORG\n         SPACE 1\n         DROP  R9,R10,R11,R12,R13\n         EJECT\nCCWLIST  CCW   X'03',0,X'40',1     NOP FOR NOW\n         CCW   X'31',*-*,X'40',L'CCHHR SEARCH ID EQ\n         CCW   X'08',*-*,X'00',0   TIC *-8\n         CCW   X'1E',*-*,X'20',*-* READ CKD\n         CCW   X'31',*-*,X'40',L'CCHHR SEARCH ID EQ\n         CCW   X'08',*-*,X'00',0   TIC *-8\n         CCW   X'0D',*-*,X'20',*-* WRITE KD\n         CCW   X'16',*-*,X'20',*-* READ R0\n         CCW   X'16',0,X'70',1     READ R0 TO ORIENT\n         CCW   X'E9',*-*,X'40',L'ZNAME  SEARCH KEY EQ/HI MT\n         CCW   X'08',*-*,X'00',0   TIC *-8\n         CCW   X'0E',*-*,X'00',8+256 READ KD\n         CCW   X'31',*-*,X'40',L'CCHHR SEARCH ID EQ\n         CCW   X'08',*-*,X'00',0   TIC *-8\n         CCW   X'1D',*-*,X'20',*-* WRITE CKD\nCCWL     EQU   *-CCWLIST           LENGTH OF CCW PATTERNS\n         PRINT &PRF\nDCBMSK  DCB    MACRF=E,DDNAME=SYSLIB,DEVD=DA\n         DC    5F'0'               STUPID MACRO & SYSTEM\nDCBUL    EQU   *-DCBMSK            TURKEY SYSTEM (NEED 72 BYTES)\n         SPACE 1\n*------- COMMAND TABLE ----------------------------------------------*\nCMTBL    EQU   0,1                 ELEMENT = COMMAND NAME LENGTH\nCMTBN    EQU   1,8                           COMMAND NAME\nCMTBA    EQU   9,3                           COMMAND ADDRESS\nCMTBEL   EQU   12                  ELEMENT LENGTH\nCOMTAB   DS    0F                  START OF COMMANDS TABLE\n        @CMD   WHATMEM,WHATMEM\n        @CMD   //DEBUG,DIEFAST\n        @CMD   CAPSOFF,CAPSOFF\n        @CMD   LASTDS1,LASTDS1\n        @CMD   CANCEL,CANEX\n        @CMD   CAPSON,CAPSON\n        @CMD   DISASM,DISASM\n        @CMD   EBCDIC,EBCDIC\n        @CMD   ITRACE,ITRACE\n        @CMD   ASCII,ASCII\n        @CMD   DISPC,DISPC\n        @CMD   DISPD,DISPD\n        @CMD   DISPK,DISPK\n        @CMD   DUMPF,DUMPF\n        @CMD   DUMPT,DUMPT\n        @CMD   EJECT,EJECT\n        @CMD   FLOAT,FLOAT\n        @CMD   NODEF,NODEF\n        @CMD   WHERE,WHERE\n        @CMD   ZCODE,ZCODE\n        @CMD   BASE,BASE\n        @CMD   DUMP,DUMP\n        @CMD   HELP,HELPHELP\n        @CMD   IDEF,IDEF\n        @CMD   LAST,LAST\n        @CMD   NAME,NAME#\n        @CMD   NOTE,NOTE\n        @CMD   SAVE,REPLACE\n        @CMD   ZSYM,ZCODE\n        @CMD   ABS,ABS\n        @CMD   ASM,ASM\n        @CMD   CAN,CANEX\n        @CMD   END,XEND\n        @CMD   LOG,LOG\n        @CMD   SET,SET\n        @CMD   ZAP,REPLACE\n        @CMD   WM,WHATMEM\n        @CMD   <,BACKWARD\n        @CMD   %,INDPOINT\n        @CMD   >,FORWARD\n        @CMD   ?,HELP\n        @CMD   #,CALC\n        @CMD   =,EQUALS\n        @CMD   B,BACK\n        @CMD   D,DISPLAY#\n        @CMD   E,NAME#\n        @CMD   F,FIND\n        @CMD   H,HELP\n        @CMD   J,POINT$J\n        @CMD   L,LOCATE\n        @CMD   M,MEMBER#\n        @CMD   N,AND\n        @CMD   O,OR\n        @CMD   P,POINT\n        @CMD   R,RECORD\n        @CMD   S,STORE\n        @CMD   T,TRACK\n        @CMD   U,UP\n        @CMD   V,INDIRECT\n        @CMD   W,WINDOW\n        @CMD   X,EXOR\n        @CMD   'X X X X',INVEXPER  ZAP SPACE\n         DC    XL1'FF'\n         PRINT &PRS\n*------- SENSITIVE PREFIXES TABLE -----------------------------------*\n        @SST\n*------- TRANSLATE TABLES -------------------------------------------*\n         SPACE 1\n         DS    0F\n*- - - - DUMP FORMAT TRTAB (*** ASCII ***).\n*        (THIS IS A MODIFIED VERSION OF ASMTRTAB RASA,\n*        INTO WHICH ALL HEXADECIMAL VALUES LESS THAN X'3F'\n*        HAVE BEEN REPLACED BY A PERIOD CHARACTER X'4B')\n         SPACE 1\nIECTRASA EQU   *  0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' 0\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' 1\n         DC    X'404F7F7B5B6C507D4D5D5C4E6B604B61' 2\n         DC    X'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F' 3\n         DC    X'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6' 4\n         DC    X'D7D8D9E2E3E4E5E6E7E8E94AE05A5F6D' 5\n         DC    X'79818283848586878889919293949596' 6\n         DC    X'979899A2A3A4A5A6A7A8A9C06AD0A14B' 7\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' 8\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' 9\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' A\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' B\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' C\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' D\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' E\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' F\n         SPACE 1\n*- - - - CONVERT STRING TRTAB (*** ASCII ***).\n*        (THIS IS THE VERSION OF ASMTRTAB SASA)\n         SPACE 1\nIECTSASA EQU   *  0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    X'000102031A091A7F1A1A1A0B0C0D0E0F' 0\n         DC    X'101112131A0A080018191A1A1C1D1E1F' 1\n         DC    X'1A1A1A1A1A0A171B1A1A1A1A1A050607' 2\n         DC    X'1A1A161A1A1A1A041A1A1A1A14151A1A' 3\n         DC    X'201A1A1A1A1A1A1A1A1A5B2E3C282B21' 4\n         DC    X'261A1A1A1A1A1A1A1A1A5D242A293B5E' 5\n         DC    X'2D2F1A1A1A1A1A1A1A1A7C2C255F3E3F' 6\n         DC    X'1A1A1A1A1A1A1A1A1A603A2340273D22' 7\n         DC    X'1A6162636465666768691A1A1A1A1A1A' 8\n         DC    X'1A6A6B6C6D6E6F7071721A1A1A1A1A1A' 9\n         DC    X'1A7E737475767778797A1A1A1A1A1A1A' A\n         DC    X'1A1A1A1A1A1A1A1A1A1A1A1A1A1A1A1A' B\n         DC    X'7B4142434445464748491A1A1A1A1A5C' C\n         DC    X'7D4A4B4C4D4E4F5051521A1A1A1A1A1A' D\n         DC    X'5C1A535455565758595A1A1A1A1A1A1A' E\n         DC    X'303132333435363738391A1A1A1A1A1A' F\n         SPACE 1\n*- - - - DUMP FORMAT TRTAB (*** ZCODE ***).\n         SPACE 1\nTRCHARZ  DC    256C'.'\n         ORG   TRCHARZ+X'18'\n         DC    X'C0D0'\n         ORG   TRCHARZ+X'25'\n         DC    C'$'\n         ORG   TRCHARZ+X'40'\n         DC    C' ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n         DC    C'_ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n         DC    C'=0123456789'\n         ORG   TRCHARZ+X'90'\n         DC    C'+-'\n         ORG   TRCHARZ+X'9E'\n         DC    C'<'\n         ORG   TRCHARZ+X'A0'\n         DC    C'='\n         ORG   TRCHARZ+X'A2'\n         DC    C'>'\n         ORG   TRCHARZ+X'A4'\n         DC    C'-',X'5A'          EXCLAIM POINT\n         ORG   TRCHARZ+X'B5'\n         DC    C',?'\n         ORG   TRCHARZ+X'C4'\n         DC    C';:'\n         ORG   TRCHARZ+X'F9'\n         DC    C'#'\n*        ORG   TRCHARZ+4\n*        DC    C'$'\n*        ORG   TRCHARZ+14\n*        DC    C'??();/'\n*        ORG   TRCHARZ+26\n*        DC    C'+-*/*...?V<.=.>'\n*        ORG   TRCHARZ+47\n*        DC    C',?'\n*        ORG   TRCHARZ+54\n*        DC    C'\u00ac'\n*        ORG   TRCHARZ+61\n*        DC    C'_'\n*        ORG   TRCHARZ+82\n*        DC    C'??'\n*        ORG   TRCHARZ+86\n*        DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ-'\n*        ORG   TRCHARZ+113\n*        DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ='\n*        ORG   TRCHARZ+140\n*        DC    C'0123456789.. '':'\n         ORG   ,\n         SPACE 1\n*- - - - CONVERT STRING TRTAB (*** ZCODE ***).\n*        (THIS IS THE PREVIOUS TABLE IN REVERSE ORDER JUST\n*        BECAUSE I DIDN'T FOUND WHAT 'ZCODE' MEANS) MOINIL P.A.\n         SPACE 1\nTRCHRZ   DC    256X'3F'\n         ORG   TRCHRZ+X'40'\n         DC    X'40'\n         ORG   TRCHRZ+X'4C'        <\n         DC    X'9E'\n         ORG   TRCHRZ+X'4E'        +\n         DC    X'90'\n         ORG   TRCHRZ+X'5A'        !$\n         DC    X'A525'\n         ORG   TRCHRZ+X'5E'        ;\n         DC    X'C4'\n         ORG   TRCHRZ+X'60'        -\n         DC    X'91' OR X'A4'\n         ORG   TRCHRZ+X'6B'        ,\n         DC    X'B5'\n         ORG   TRCHRZ+X'6D'        _>?\n         DC    X'5BA2B6'\n         ORG   TRCHRZ+X'7A'        :#\n         DC    X'C5F9'\n         ORG   TRCHRZ+X'7E'        =\n         DC    X'76' OR X'A0'\n         ORG   TRCHRZ+X'81'        ABCDEFGHI\n         DC    X'5C5D5E5F6061626364'\n         ORG   TRCHRZ+X'91'        JKLMNOPQR\n         DC    X'65666768696A6B6C6D'\n         ORG   TRCHRZ+X'A2'        STUVWXYZ\n         DC    X'6E6F707172737475'\n         ORG   TRCHRZ+X'C0'        {ABCDEFGHI\n         DC    X'18414243444546474849'\n         ORG   TRCHRZ+X'D0'        }JKLMNOPQR\n         DC    X'194A4B4C4D4E4F505152'\n         ORG   TRCHRZ+X'E2'        STUVWXYZ\n         DC    X'535455565758595A'\n         ORG   TRCHRZ+X'F0'        0123456789\n         DC    X'7778797A7B7C7D7E7F80'\n         ORG   ,\n         SPACE 1\n*- - - - DUMP FORMAT TRTAB (*** EBCDIC ***).\n         SPACE 1\nTRCHARE  DC    256C'.'\n         ORG   TRCHARE+C' '\n         DC    C' '\n         ORG   TRCHARE+X'4A'       CENT SIGN\n         DC    X'4A',C'.<(+|&&'\n         ORG   TRCHARE+X'5A'       EXCLAMATION POINT\n         DC    X'5A',C'$*);\u00ac-/'\n         ORG   TRCHARE+C','\n         DC    C',%_>?'\n         ORG   TRCHARE+C':'\n         DC    C':#@''=',X'7F'     DOUBLE QUOTE\n         ORG   TRCHARE+X'81'\n         DC    9AL1(*-TRCHARE)     LOWER CASE A-I\n         ORG   TRCHARE+X'91'\n         DC    9AL1(*-TRCHARE)     LOWER CASE J-R\n         ORG   TRCHARE+X'A2'\n         DC    8AL1(*-TRCHARE)     LOWER CASE S-Z\n         ORG   TRCHARE+C'A'\n         DC    9AL1(*-TRCHARE)     UPPER CASE A-I\n         ORG   TRCHARE+C'J'\n         DC    9AL1(*-TRCHARE)     UPPER CASE J-R\n         ORG   TRCHARE+C'S'\n         DC    8AL1(*-TRCHARE)     UPPER CASE S-Z\n         ORG   TRCHARE+C'0'\n         DC    10AL1(*-TRCHARE)    NUMERICS 0-9\n         ORG   ,\n         PRINT &PRF\n         EJECT\n*--- E X P A N A L --- EXPRESSION ANALYZER (\"EXP\") ------------------*\n*              THIS ROUTINE WILL ANALYZE AN EXPRESSION PASSED TO IT  *\n*              AND RETURN ITS VALUE CONCATENATED WITH A STARTING     *\n*              VALUE. IF \"EXPOPT\" IS \"NOSYMB\", TABLE IS NOT SCANNED, *\n*              ELSE SYMBOL TABLE IS SCANNED.                         *\n*               INPUT : R0  - LENGTH OF EXPRESSION TO PARSE.         *\n*                       R1  - ADDRESS OF EXPRESSION TO PARSE.        *\n*                       R2  - STARTING VALUE OF '*'.                 *\n*                       R13 - SAVE-AREA.                             *\n*                       R14 - RETURN ADDRESS.                        *\n*              OUTPUT : R1  - RETURN CODE.                           *\n*                             IF NEGATIVE : NO ERRORS DETECTED.      *\n*                             IF ZERO OR POSITIVE AN ERROR OCCURED   *\n*                             AT ADDRESS GIVEN IN R1.                *\n*                       R15 - IF NO ERROR, THE NEW VALUE CALCULATED. *\n*--------------------------------------------------------------------*\n         CNOP  0,4\n         USING TSDSECT,R9\nEXPANAL  STM   R14,R1,EXPARMS      SAVE CALLER'S REGS ONE PLACE\n         STM   R2,R12,20+R2*4(R13) SAVE REST IN OTHER PLACE\n         LR    R12,R15             GET BASE\n         USING EXPANAL,R12\n         LR    R4,R2               ALWAYS BEGIN WITH *\n         ST    R2,EXPSTART         SAVE VALUE OF \"*\"\n         LR    R3,R1               START SCAN\n         BCTR  R3,0                HE WILL ADD ONE FIRST\n         LR    R2,R0               BCT INDEX\n         MVI   EXPFLAG+1,0         RESET FLAGS\n         LA    R2,1(R2)            ALLOW FOR FIRST PASS\n         ST    R1,GORF             FIRST BAD SPOT\n         B     EXPBACK             START AFTER ITEM\n*              SEE WHAT NEXT ITEM IS.\nEXPITEM  LTR   R2,R2               ANYTHING LEFT?\n         BP    EXPON               YES\n         ST    R4,EXPSTART         NEW STARTER\n         OI    EXPPTR,X'80'        NO ERROR\n         B     EXPRET              RETURN\nEXPON    CLI   0(R3),C' '          BLANK?\n         BNE   EXPCHECK            NO, WE CAN USE IT\nEXPNEXT  LA    R3,1(R3)            NEXT SPOT TO CHECK\n         BCT   R2,EXPITEM          CONTINUE\n         MVI   EXPFLAG+1,0         NOTHING FOR NEXT TIME\n         B     EXPCONV             WHEN AT END, USE LAST IF ANY\nEXPCHECK ST    R3,GORF             KEEP TRACK OF WHERE WE ARE\n         CLI   0(R3),C'*'          CURRENT LOC OR MULT?\n         BE    EXPSTAR             YES, GO DECIDE WHICH\n         CLI   0(R3),C'+'          ADD?\n         BE    EXPADD              YES\n         CLI   0(R3),C'-'          SUBTRACT?\n         BE    EXPSUB              YES\n         CLI   0(R3),C'.'          DECIMAL DONE?\n         BE    EXPDEC              YES\n         CLI   0(R3),C'/'          DIVIDE?\n         BE    EXPDIV              YES\n         OI    EXPFLAG+1,EXPEXOPR  EXPECTING OPERATOR NOW\n*              IF NO TERMINATOR IS FOUND, SAVE UP FOR LATER.\n         LA    R0,EXPWORK+8        POINT PAST IT\n         CLR   R0,R5               TOO FAR?\n         BNH   EXPERR              YES\n         MVC   0(1,R5),0(R3)       COPY IT TO WORK-AREA\n         LA    R5,1(R5)\n         B     EXPNEXT             CONTINUE\n*              IF AN ERROR IS DETECTED, PASS BACK ADDRESS OF IT.\nEXPERR   MVC   EXPPTR,GORF         SAVE POINTER FOR RETURN\nEXPRET   MVI   EXPOPT,NOSYMB       SET NO SYMBOL TABLE LOOKUP\n         LM    R14,R1,EXPARMS      GET RETURN REGS\n         LM    R2,R12,20+R2*4(R13) RESTORE REST OF REGS FROM SAVE\n         BR    R14\n*              '*' WAS ENTERED, DECIDE IF CURRENT LOC OR MULTIPLY.\nEXPSTAR  TM    EXPFLAG+1,EXPEXOPR  WHICH IS THIS?\n         BO    EXPMULT             MULTIPLY\n*              USE CURRENT VALUE.\nEXPCURR  L     R15,EXPSTART        GET STARTING VALUE\n         MVI   EXPFLAG+1,EXPEXOPR  EXPECTING OPERATOR NOW\n         B     EXPUSE              AND GO USE IT\n*              IF '+' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG.\nEXPADD   MVI   EXPFLAG+1,EXPFPLUS  INDICATE ADD NEXT TIME\n         B     EXPCONV             GO CONVERT IT\n*              IF '-' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG.\nEXPSUB   MVI   EXPFLAG+1,EXPFMINS  INDICATE ADD NEXT TIME\n         B     EXPCONV             GO CONVERT IT\n*              IF '*' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG.\nEXPMULT  MVI   EXPFLAG+1,EXPFMULT  INDICATE MULT NEXT TIME\n         B     EXPCONV             GO CONVERT IT\n*              IF '/' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG.\nEXPDIV   MVI   EXPFLAG+1,EXPFDIV   INDICATE DIV NEXT TIME\n         B     EXPCONV             GO CONVERT IT\n*              IF '.' WAS ENTERED, TERMINATE PREVIOUS AS DECIMAL.\nEXPDEC   OI    EXPFLAG,EXPFDEC     INDICATE DECIMAL THIS TIM\n*              WHEN UP TO 8 CHARS SCANNED OUT,\n*              CONVERT THEM APPROPRIATELY.\nEXPCONV  LA    R15,EXPWORK+1       POINT TO START\n         SR    R5,R15              FIND EXECUTE LENGTH\n         LR    R15,R5              SAVE IT\n         BNM   EXPCOK+L'EXPCOK     IF SOMETHINGS THERE, CONTINUE\n         TM    EXPFLAG,EXPFTERM    SOMETHING EXPECTED?\n         BZ    EXPBACK             NO, IGNORE THIS TIME\n         B     EXPERR              OTHERWISE ITS NO GOOD\nEXPCOK   MVC   ZDBLW(*-*),EXPWORK  <<EXECUTED>>\n         MVI   ZDBLW,C' '\n         MVC   ZDBLW+1(7),ZDBLW    CLEAR AN AREA\n         EX    R15,EXPCOK          MOVE TO IT\n*              IF SYMBOL TABLE SCAN REQUESTED, DO SO.\n         CLI   EXPOPT,NOSYMB       SCAN SYMBOL TABLE?\n         BE    EXPNTAB             NO, GO ON\n         TM    EXPFLAG,EXPFDEC     DECIMAL?\n         BO    EXPNTAB             THEN CAN'T BE THIS\n         L     R14,AIDEFTAB        POINT TO TABLE\nEXPIDSCN CLI   0(R14),X'FF'        END OF TABLE?\n         BE    EXPNTAB             THEN WE DIDN'T FIND IT\n         CLC   DEFSYM(L'DEFSYM,R14),ZDBLW SEE IF THIS IS HIS LABEL\n         BE    EXPGLAB             YES, IT IS\n         LA    R14,L'IDEFTAB(R14)  NEXT ENTRY IN TABLE\n         B     EXPIDSCN            GO ON\nEXPGLAB  LH    R15,DEFOFF(R14)     GET VALUE OF IT\n         B     EXPUSE              AND USE IT\n*              VALIDITY CHECK FOR NUMERICS.\nEXPNTAB  LA    R0,1(R15)           GET LENGTH OF THINGY\n         LA    R14,EXPWORK         FIND IT\nEXPCCHK  CLI   0(R14),C'0'         IF ITS NUMERIC I ALWAYS LIKE IT\n         BNL   EXPCGOOD            GO\n         TM    EXPFLAG,EXPFDEC     DECIMAL?\n         BO    EXPERR              THEN NO GOOD\n         CLI   0(R14),C'A'         OTHERWISE NOT LESS THAN A\n         BL    EXPERR              GO\n         CLI   0(R14),C'F'         OR GREATER THAN F\n         BH    EXPERR              GO\n         IC    R1,0(R14)           GET IT\n         AH    R1,EXPFUDGE         MAKE FA-FF\n         STC   R1,0(R14)           REPLACE IT\nEXPCGOOD LA    R14,1(R14)          NEXT\n         BCT   R0,EXPCCHK          CONTINUE CHECKING\n*              CONVERT DECIMAL.\n         TM    EXPFLAG,EXPFDEC     DECIMAL?\n         BZ    EXPNDEC             NO\n         EX    R15,EXPPACK         PACK IT\n         CVB   R15,ZDBLW           CONVERT IT\n         B     EXPUSE              AND USE IT\nEXPPACK  PACK  ZDBLW(8),EXPWORK(0) <<EXECUTED>>\n*              CONVERT FOR HEX.\nEXPNDEC  LA    R15,1(R15)          DO AN EXTRA CHAR\n         EX    R15,EXPPACK         PACK IT\n         LM    R14,R15,ZDBLW       GET OFFSET\n         SRDL  R14,8               SHIFT OUT BAD BYTE (FLIP)\n*              WHEN VALUE OBTAINED, ADD, SUB OR WHATEVER.\nEXPUSE   TM    EXPFLAG,EXPFPLUS    ADDING?\n         BO    EXPUADD             YES\n         TM    EXPFLAG,EXPFMINS    SUBTRACTING?\n         BO    EXPUSUB             YES\n         TM    EXPFLAG,EXPFMULT    MULTIPLYING?\n         BO    EXPUMULT            YES\n         TM    EXPFLAG,EXPFDIV     DIVIDING?\n         BO    EXPUDIV             YES\n         LR    R4,R15              ELSE, OVERLAY\nEXPBACK  LA    R5,EXPWORK          START AGAIN\n         MVC   EXPFLAG(1),EXPFLAG+1 NEW FLAGS\n         MVI   EXPFLAG+1,0         NO MORE\n         B     EXPNEXT             SKIP LAST ONE\nEXPUADD  AR    R4,R15\n         B     EXPBACK             GO ON\nEXPUSUB  SR    R4,R15              SUBTRACT\n         B     EXPBACK             GO\nEXPUMULT LR    R5,R4               GET INTO ODD REGISTER\n         MR    R5-1,R15            DO THE MULTIPLY\n         LR    R4,R5               GET RESULT IN CORRECT REGISTER\n         B     EXPBACK             GO ON\nEXPUDIV  LR    R5,R4               GET INTO ODD REGISTER\n         XR    R4,R4               CLEAR FOR DIVIDE\n         LTR   R15,R15             DIVIDE BY 0?\n         BZ    EXPERR              YES, ERROR\n         DR    R5-1,R15            DO THE MULTIPLY\n         LR    R4,R5               GET RESULT IN CORRECT REGISTER\n         B     EXPBACK             GO ON\n* - - -  EXP'S DATA.\nEXPFUDGE DC    0H'0',XL2'0039'\n         SPACE 1\n         DROP  R9,R12\n         EJECT\n*--- C S O U T --- LOG PROCESS --------------------------------------*\n*        CSOUT : THIS ROUTINE ALLOCATES A LOG FILE (DATA-SET, IF IT  *\n*              IS NEEDED), AND WRITES OUTPUT LINES INTO IT.          *\n*              NOTE : THE LINE BUFFER IS CLEARED AFTER EACH CALL.    *\n*           INPUT : R1 ===> \"CSOUT\" WORK-AREA ADDRESS                *\n*           THE SELECTION OF THE FUNCTION IS DONE BY THE REGISTER 0  *\n*              (ZERO, POSITIVE OR NEGATIVE) :                        *\n*           1. R0 ZERO : THE FILE IS ALLOCATED AND OPENED IF NEEDED, *\n*                      THEN THE LINE BUFFER IS OUTPUTED.             *\n*                   RETURN : R15 = 0 - OK                            *\n*                                  4 - ALLOCATION OR OPEN ERROR      *\n*                                      (R1 = MESSAGE ADDRESS)        *\n*                                  8 - PUT ERROR                     *\n*           2. R0 POSITIVE : THE CURRENT FILE BUFFER IS TRUNCATED.   *\n*                   RETURN : R15 = 0 - OK (ALWAYS)                   *\n*           3. R0 NEGATIVE : THE FILE IS CLOSED AND DE-ALLOCATED.    *\n*                   RETURN : R15 = 0 - OK                            *\n*                                  4 - DE-ALLOCATION ERROR           *\n*                                      (R1 = MESSAGE ADDRESS)        *\n*--------------------------------------------------------------------*\n         CNOP  0,4\n*- - - - MAIN ENTRY, HOUSEKEEPING.\n         USING TSDSECT,R9\n         USING *,R12\nCSOUT    STM   R14,R12,12(R13)     SAVE REGISTERS\n         LR    R12,R15             SET BASE REGISTER\n         ST    R13,4(R1)           STORE BACKWARD POINTER\n         ST    R1,8(R13)           STORE FORWARD POINTER\n         LR    R11,R13             PREVIOUS WORK-AREA\n         USING SAVE3,R11\n         LR    R13,R1              GET WORK-AREA ADDRESS\n         USING CSDATA,R13\n         LTR   R0,R0               WHAT?\n         BP    CSTRUNC             GO TRUNCATE\n         BM    CSCLOSE             GO CLOSE\n         TM    FLAGSL,LOGALL+LOGOPN IS DATA-SET ALLOCATED AND OPENED?\n         BO    CSPUT               IF SO, GO PUT\n*- - - - PREPARE FOR LOGGING, CREATE AND OPEN THE DATA-SET.\n         L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',BLANKS\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         MVC   DDNAME,DDPALL       DDNAME\n         MVC   DSNAME(L'ZUSRID),ZUSRID BUILD DS-NAME\n         LA    R3,DSNAME+L'ZUSRID-1\n         CLI   0(R3),C' '\n         BNE   *+L'*+4\n         BCT   R3,*-8\n         MVC   1(14,R3),=CL14'.ETPS.ZAPLOG.D'\n         LA    R3,15(R3)\n         LA    R1,VUSWA            -> FORMAT DATE AND TIME WORK-AREA\n         XC    0(FDTWAL,R1),0(R1)  CLEAR\n         L     R15,ARFDTE          GET CURRENT DATE/TIME\n*- - - - ETPSFDTE PARM.LIST : \"FDTWA\" ADDRESS\n        CALL   (15)\n         USING FDTWA,R1\n         MVC   0(L'FXYY,R3),FXYY   SET YEAR (YY)\n         MVC   0+L'FXYY(L'FXDDD,R3),FXDDD SET DAY (DDD)\n         MVC   0+L'FXYY+L'FXDDD(2,R3),=CL2'.T'\n         LA    R3,2+L'FXYY+L'FXDDD(R3)\n         MVC   0(L'FTM,R3),FTM     SET TIME HHMMSS\n         MVC   0+L'FTM(5,R3),=CL5'.LIST'\n         DROP  R1\n         MVC   DSUNIT,=CL8'&ZUNME'\n         MVC   DSVOLSER,=CL6'&ZVLSR' VOL-SER\n         MVC   DSALLOC,=CL5'&ZSPUN' SPACE UNIT (TRK/CYL)\n         MVC   DSPRI,=CL6'&ZPRIQ'  PRIMARY QUANTITY\n         MVC   DSSEC,=CL6'&ZSECQ'  SECONDARY QUANTITY\n         MVI   DSRECFM1,C'F'       SET RECFM=FBA\n         MVI   DSRECFM2,C'B'\n         MVI   DSRECFM5,C'A'\n         MVC   DSBLKSI,=CL5'3990 ' SET BLKSIZE\n         MVC   DSLRECL,=CL5'133 '  SET LRECL\n         MVC   DSSTATUS,=CL8'NEW ' SET DISP=(NEW,CATLG,CATLG)\n         MVC   DSNDISP,=CL8'CATLG '\n         MVC   DSADISP,=CL8'CATLG '\n         L     R1,ZLGDSN           PASS BACK \"LOG\" DS-NAME\n         MVC   0(L'DSNAME,R1),DSNAME COPY IT\n         L     R1,ZLGVOL           PASS BACK \"LOG\" VOL-SER\n         MVC   0(L'DSVOLSER,R1),DSVOLSER COPY IT\n         DROP  R2\n         L     R15,ARDYNAM\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    CSALS               OK\n        XMESS  3008                ERROR\n         LA    R1,ALFMSG\n         B     CSRSB\nCSALS    OI    FLAGSL,LOGALL       SAY ALLOCATED\nCSALL    XC    CSPGNO(4),CSPGNO    OK, CLEAR PAGE AND LINE\n         LA    R0,CSODCB           POINT TO DCB\n         ST    R0,CSDBLW           STORE IN DCB LIST\n         MVI   CSDBLW,VLB+X'0F'    \"VL\" & OUTPUT\n         MVC   CSODCB(ODCBLEN),ODCBMSK COPY IN MASK\n         MVC   CSODCB+DCBDDNAM-IHADCB(L'DCBDDNAM),DDPALL COPY IN DDNAME\n        OPEN   MF=(E,CSDBLW)\n         TM    CSODCB+DCBOFLGS-IHADCB,DCBOFOPN SEE IF OPEN?\n         BO    CSOPN               IF SO, GO PUT\n         LA    R1,OLFMSG           ELSE IF NOT, ERROR\nCSRSB    L     R15,ZLGDSN          ADDRESS TO PASS BACK \"LOG\" DS-NAME\n         MVC   0(L'DSNAME,R15),BLANKS CLEAR IT\n         L     R15,ZLGVOL          ADDRESS TO PASS BACK \"LOG\" VOL-SER\n         MVC   0(L'DSVOLSER,R15),BLANKS CLEAR IT\n         B     CSRC4\nCSOPN    OI    FLAGSL,LOGOPN       SAY OPENED\n*- - - - WRITE OUT A LINE.\nCSPUT    LH    R0,CSLNNO           GET LINE NUMBER\n         CLI   CSOBUFF,C'1'        SKIP TO PAGE?\n         BE    CSPAGE              YES, FORCE PAGE SKIP\n         CLI   CSOBUFF,C'0'        DOUBLE SPACE?\n         BE    CSSKP2              YES\n         CLI   CSOBUFF,C'+'        SUPPRESS SKIP?\n         BE    CSSKP0              YES\n         CLI   CSOBUFF,C'-'        TRIPLE SPACE?\n         BE    CSSKP3              NO, ANYTHING ELSE IS ONE SPACE\n         MVI   CSOBUFF,C' '        ELSE FORCE SINGLE\n         B     CSSKP1              AND COUNT ONE\nCSSKP3   BCTR  R0,0\nCSSKP2   BCTR  R0,0\nCSSKP1   BCTR  R0,0\nCSSKP0   LTR   R0,R0               ANYTHING LEFT ON PAGE?\n         BNP   CSPAGE              NO, EJECT\n         STH   R0,CSLNNO           SAVE NEW LINE COUNTER\n         NI    CSFLAGS,255-CSIOERR TURN OFF FLAG\n        PUT    CSODCB,CSOBUFF      PRINT THE LINE NOW\n         TM    CSFLAGS,CSIOERR     IO ERROR?\n         BZ    CSRCOK              NO\n         B     CSRC8\n*- - - - PUT OUT A TITLE IF AT TOP OF PAGE.\nCSPAGE   MVI   CSOBUFF,C'-'        TRIPLE SPACE FROM TITLE\n         MVC   CSLNNO(2),=H'60'    RESET LINE COUNTER\n         LH    R1,CSPGNO           GET PAGE COUNTER\n         LA    R1,1(R1)            COUNT LAST PAGE\n         STH   R1,CSPGNO           SAVE FOR LATER\n         CVD   R1,CSDBLW           CONVERT THE PAGE NUMBER\n         MVC   CSTBUFF,TMSK        MOVE IN THE MASK\n         ED    CSTBUFF+TMSKPGN(L'TMSKPGN),CSDBLW+5 EDIT IT\n         MVC   CSTBUFF+TMSKUSR(L'TMSKUSR),ZUSRID PICK UP USER-ID\n         LA    R1,VUSWA            -> FORMAT DATE AND TIME WORK-AREA\n         XC    0(FDTWAL,R1),0(R1)  CLEAR\n         L     R15,ARFDTE          GET CURRENT DATE/TIME\n*- - - - ETPSFDTE PARM.LIST : \"FDTWA\" ADDRESS\n        CALL   (15)\n         USING FDTWA,R1\n         LTR   R15,R15             HOW COMPLETE?\n         BNZ   *+L'*+12            ERROR, SKIP\n         AIF   ('&TXV' NE 'EUROPE').SK3\n         MVC   CSTBUFF+TMSKDAY(L'FXDD),FXDD PICK UP DAY (DD)\n         MVC   CSTBUFF+TMSKDAY+3(L'FXMONTH),FXMONTH MONTH (MMM)\n         MVC   CSTBUFF+TMSKDAY+7(L'FXYY),FXYY AND YEAR (YY)\n         AGO   .SK4\n.SK3     MVC   CSTBUFF+TMSKDAY+7(L'FXDD),FXDD PICK UP DAY (DD)\n         MVC   CSTBUFF+TMSKDAY+3(L'FXMONTH),FXMONTH MONTH (MMM)\n         MVC   CSTBUFF+TMSKDAY(L'FXYY),FXYY AND YEAR (YY)\n.SK4     MVC   CSTBUFF+TMSKHOUR(L'FTHH),FTHH SET TIME HH:MM\n         MVI   CSTBUFF+TMSKHOUR+L'FTHH,C':'\n         MVC   CSTBUFF+TMSKHOUR+L'FTHH+1(L'FTMM),FTMM\n         DROP  R1\n         NI    CSFLAGS,255-CSIOERR TURN OFF FLAG\n        PUT    CSODCB,CSTBUFF      PRINT THE TITLE\n         TM    CSFLAGS,CSIOERR     IO ERROR?\n         BZ    CSPUT               NO, NOW TRY THAT AGAIN\nCSRC8    LA    R15,8               YES, INDICATE IT, RC=8\n         B     CSEXIT              LEAVE\n*- - - - WRITE OUT A SHORT BLOCK.\nCSTRUNC  TM    FLAGSL,LOGOPN       SEE IF OPENED?\n         BZ    CSRCOK              IF NOT, GO BACK AS WELL DONE\n        TRUNC  CSODCB\n         B     CSRCOK              THAT WAS EASY\n*- - - - CLOSE AND DE-ALLOCATE THE OUTPUT DATA-SET.\nCSCLOSE  TM    FLAGSL,LOGOPN       SEE IF OPENED?\n         BZ    CSFREE              IF NOT, GO FREE IT\n         LA    R0,CSODCB           FIND DCB\n         ST    R0,CSDBLW           SAVE IT\n         MVI   CSDBLW,VLB          CLOSE JUST THIS ONE\n        CLOSE  MF=(E,CSDBLW)       CLOSE THE DS\n         NI    FLAGSL,255-LOGOPN\nCSFREE   TM    FLAGSL,LOGALL       SEE IF ALLOCATED?\n         BZ    CSRCOK              IF NOT, GO BACK AS WELL DONE\n         L     R2,DYNWORKP         INIT. DYNAMIC ALLOC. WORK-AREA\n         LR    R0,R2\n         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',BLANKS\n         MVCL  R0,R14              CLEAR TO ALL BLANKS\n         USING PARMLIST,R2\n         MVC   DDNAME,DDPALL       DDNAME\n         MVI   DSNAME,0            INDICATE FREE REQUEST\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         DROP  R2\n         NI    FLAGSL,255-LOGALL\n         L     R15,ARDYNAM         FREE IT\n*- - - - ETPSDYNA PARM.LIST : \"DYNWORKP\" ADDRESS\n        CALL   (15),MF=(E,DYNWORKP)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    CSRCOK              OK\n        XMESS  3009                ERROR\n         LA    R1,FLFMSG\nCSRC4    L     R15,4(R13)          GET CALLER SAVE-AREA\n         ST    R1,24(R15)          PASS MESSAGE ADDRESS\n         LA    R15,4               SET RC=4\n         B     CSEXIT\nCSRCOK   XR    R15,R15             SAY ALL IS WELL, RC=0\n*- - - - WHEN DONE WITH WHATEVER, CLEAR LINE, AND GO BACK.\nCSEXIT   MVC   CSOBUFF,BLANKS      CLEAR LINE BEFORE RETURN\n         L     R13,4(R13)          GET CALLER SAVE-AREA\n         ST    R15,16(R13)         SET RETURN CODE\n         LM    R14,R12,12(R13)     RESTORE ALL REGISTERS\n         BR    R14                 RETURN TO CALLER\n         CNOP  0,8\n*------- SYNAD : AN I/O ERROR HAS OCCURED.\nOSYNAD   OI    CSFLAGS,CSIOERR     SIGNAL ERROR\n         BR    R14                 AND RETURN\n         SPACE 1\n*- - - - CONSTANTS.\nTMSK     DS    0CL133\n         DC    CL1'1',CL50'E T P S - ZAP SESSION RECORD'\n         DC    CL7'USER : '\nTMSKUSR  EQU   *-TMSK,8\n         DC    CL22' ',CL7'****** '\nTMSKDAY  EQU   *-TMSK,9\n         AIF   ('&TXV' NE 'EUROPE').SK5\n         DC    CL9'?? ??? YY'\n         AGO   .SK6\n.SK5     DC    CL9'YY ??? ??'\n.SK6     DC    CL5' --- '\nTMSKHOUR EQU   *-TMSK,5\n         DC    CL18'HH:MM ****** PAGE '\nTMSKPGN  EQU   *-TMSK-1,6\n         DC    XL5'2020202120',CL9' '\n         SPACE 1\nALFMSG   MSG   'ALLOC \"LOG\" FAILED'\nOLFMSG   MSG   'OPEN \"LOG\" FAILED'\nFLFMSG   MSG   'FREE \"LOG\" FAILED'\nODCBMSK DCB    DSORG=PS,MACRF=PM,DDNAME=XXXXXXXX,SYNAD=OSYNAD,BUFNO=1\nODCBLEN  EQU   *-ODCBMSK\n         PRINT &PRS\n*- - - - LITERAL POOL.\n        LTORG\n         SPACE 1\n         DROP  R9,R11,R12,R13\n         PRINT &PRF\n         EJECT\n*--- A S M G A S M --- ASSEMBLE OR DISASSEMBLE ----------------------*\n*        THE SELECTION OF THE FUNCTION IS DONE BY THE REGISTER 1     *\n*              POINTER (NEGATIVE OR NOT).                            *\n*--------------------------------------------------------------------*\n         CNOP  0,4\n         USING *,R12\nASMGASM  STM   R14,R12,12(R13)     SAVE REGISTERS\n         LR    R12,R15             SET BASE\n         LTR   R1,R1               ASM OR DISASM?\n         BM    DISASMIT            GUESS...\n*- - - - ASM (ASSEMBLE).\n*              INPUT : R1 = POINTER TO CL4'MNEMONIC'\n*              OUTPUT : R1 = VALID HEX-OPCODE ADDRESS (IF R15=0) OR\n*                            ZERO IF NON-VALID OPCODE.\n*                       R15 = 0 - OK / 4 - ERROR\n         L     R2,=A(OPCODES)      TABLE\n         L     R15,=A(OPEND)       END BXLE\n         LA    R14,L'OPCODES       LENGTH\nOPLOOP   CLC   0(4,R1),0(R2)       THIS ONE (KLUGE)\n         BE    GOTOP               YES\n         BXLE  R2,R14,OPLOOP       TRY ALL POSSIBLES\nBADRET   LA    R15,4               INVALID OP CODE\n         XR    R1,R1               NULLIFY POINTER\n         B     ASMXRET             BYE\nGOTOP    LA    R1,5(,R2)           POINT TO OP IN HEX\nGOODRET  XR    R15,R15             RC=0\nASMXRET  L     R14,12(,R13)        RESTORE R14 (NOTE R0 NOT)\n         LM    R2,R12,20+R2*4(R13) RESTORE REGISTERS\n         BR    R14                 BYE\n*- - - - DISASM (DISASSEMBLE).\n*              INPUT : R0 = POINTER TO OUTPUT BUFFER (33 BYTES)\n*                      R1 = POINTER TO BUFFER LOC OF OBJECT CODE\n*                      R2 = POINTER TO 5 DOUBLE-WORDS WORK-AREA\n*              OUTPUT : R1 = LENGTH OF INSTRUCTION (IF R15=0) OR ZERO\n*                            IF NON-VALID OPCODE. FILLED IN SCREEN\n*                            BUFFER IF OPCODE WAS VALID.\n*                       R15 = 0 - OK / 4 - ERROR\n*              NOTE : WE GO THROUGH SOME CONTORTIONS IN ORDER TO BE\n*                     ABLE TO SPECIFY THE OPCODE FLAG FIELDS IN\n*                     EBCDIC CHARACTER FORM (IMAGE-ENTERABLE).\nDISASMIT LPR   R1,R1               GET POS 1ST\n         LR    R7,R2               SAVE WORK-BASE\n         LR    R9,R0               SAVE OUTPUT BUFFER POINTER\n         USING JCJWORK,R7\n         MVC   JCJDW2(8),0(R1)     ALIGN POSSIBLE INSTRUCTION\n         LA    R6,JCJDW2           POINT TO INSTR\n         XR    R15,R15             READY FOR IC\n         XR    R2,R2               CLEAR TRT REGISTER\n         TRT   0(1,R6),OPTAB       TRANSLATE THE OPCODE\n         BZ    BADRET              BRANCH IF NON-VALID OPCODE\n         LA    R4,1                GET F'1' FOR LATER\n         SLR   R2,R4               FIX FOR PROPER TABLE INDEX\n         MH    R2,=Y(L'OPCODES)    GET OFFSET INTO TABLE\n         L     R1,=A(OPCODES)      TABLE\n         AR    R1,R2               POINT TO PROPER MNENOMIC\n         MVC   0(4,R9),0(R1)       MOVE IN MNENOMIC\n         MVC   JCJFLAGS(1),4(R1)   GET THE FLAG BYTE\n         IC    R15,1(,R6)          GET THE REGISTER BYTE\n         LR    R2,R15              GET IT IN R2 FOR LATER\n*              NOW CHECK IF IT IS AN EXTENDED MNENOMIC INSTRUCTION.\n         TM    JCJFLAGS,X'04'      EXTENDED MNENOMIC FLAG ON?\n         BZ    GETTYPE             NO, GO ON WITH THE REST\n         TM    JCJFLAGS,X'02'      INDEX REGISTER FLAG ON?\n         BZ    GETMNE              NO, GO GET THE MMENOMIC\n*              GETMNE RETURNS TO GETINST - WE DON'T CARE IF WE GO\n*              THROUGH THIS CODE FOR NON-MNENOMICS THOUGH.\nGETINST  CLI   1(R9),C'C'          GOT AN EXTENDED MNENOMIC?\n         BNE   GETTYPE             YES, SKIP THE BIT RESET\n         OI    JCJFLAGS,X'02'      NO, FAKE OUT A RR(OR RX) TYPE\nGETTYPE  L     R14,=A(OPCODES)\n         CLC   0(4,R9),0(R14)      IS IT SPM?\n         LA    R9,7(,R9)           INCREMENT LINE PNTR\n         BNE   GETTYPE#            NO, SKIP FLAG RESET/BRANCH\n         MVI   JCJFLAGS,C'<'       RESET FLAG FOR LATER TEST\n         B     GETRR#              AND GO PROCESS SPM\nGETTYPE# TM    JCJFLAGS,X'90'      IS LENGTH FOUR BYTES?\n         BZ    GETRR               NO, GET 2 BYTE INSTRUCTION\n         BM    GETSS               NO, GET 6 BYTE INSTRUCTION\n*              HAVE AN FOUR BYTE TYPE WHEN WE FALL THROUGH TO HERE.\n         CLI   JCJFLAGS,C'M'       (GETRX) DO WE WANT A REGISTER?\n         BNH   RXDISP              NO, GO GET DISP FIELD\n         LR    R2,R15              GET REGISTER BYTE BACK\n         SRDL  R2,4                SHIFT TO GET FIRST REGISTER\n         BAL   R14,GETNUM          PUT CHAR VALUE IN SCREEN\n         BAL   R14,COMMA           PUT IN A COMMA\n         CLI   JCJFLAGS,C'R'       TWO REGISTERS NEEDED?\n         BNE   RXDISP              NO, GET DISPLACEMENT\n         SLDL  R2,4                GET THE OTHER REGISTER\n         BAL   R14,GETNUM          AND PUT IT IN SCREEN\n         BAL   R14,COMMA           MOVE IN A COMMA\nRXDISP   BAL   R5,GETDISP          GET THE DISP FIELD\n         TM    JCJFLAGS,X'04'      NEED AN INDEX REG?\n         BZ    RXNOIND             NO, GET THE BASE ONLY\n         SLDL  R2,4                AND PICK UP THE INDEX REGISTER\n         BAL   R14,GETNUM          PUT IT IN SCREEN\n         BAL   R14,COMMA           MOVE IN A COMMA\nRXNOIND  BAL   R5,GETBASE          GET THE BASE BYTE\n         CLI   JCJFLAGS,C'L'       IMMEDIATE TYPE?\n         BNE   DISLEAVE            NO, LEAVE\n*              WE HAVE AN SI TYPE HERE.\n         MVC   0(3,R9),SICHAR      MOVE IN ,X'\n        @HEX   (3,R9),(1,R6),LEN=1,HEXTAB=HXTB,BYTE=C''''\n         B     DISLEAVE            AND LEAVE\n*              TWO BYTE INSTRUCTIONS.\nGETRR    LR    R2,R15              GET REGISTER BYTE BACK\n         CLI   JCJFLAGS,C'+'       SVC?\n         BE    RRSVC               YES, GO PROCESS IT\n         BL    MNENT               EXTENDED MNENOMIC HERE\nGETRR#   SRDL  R2,4                GET FIRST REGISTER VALUE\n         BAL   R14,GETNUM          MOVE IN THE CHAR VALUE\n         CLI   JCJFLAGS,C'<'       SPM INST?\n         BE    DISLEAVE            YES, LEAVE\n         BAL   R14,COMMA           MOVE IN A COMMA\nMNENT    XR    R2,R2               ZERO PARM REGISTER\n         SLDL  R2,4                GET OTHER REGISTER\nRRSVC    BAL   R14,GETNUM          MOVE IN THE CHAR AGAIN\n         B     DISLEAVE            GO AWAY\n*              THIS SECTION HANDLES 6 BYTE INSTRUCTIONS.\nGETSS    LR    R0,R2               SAVE THE REGISTER BYTE (LENGTH)\n         BAL   R5,GETDISP          GEN FIRST DISPLACEMENT\n         LR    R2,R0               GET THE REGISTER BYTE BACK\n         TM    JCJFLAGS,X'01'      ONLY ONE LENGTH FIELD?\n         BO    *+L'*+4             YES, SKIP THE REGISTER SHIFT\n         SRDL  R2,4                GET THE FIRST LENGTH FIELD\n         BAL   R14,GETNUMI         MOVE IN THE CHAR VALUE\n         BAL   R14,COMMA           MOVE IN A COMMA\n         BAL   R5,GETBASE          GET THE BASE FIELD\n         BAL   R14,COMMA           MOVE IN A COMMA\n         LH    R2,4(,R6)           GET SECOND DISP FIELD\n         BAL   R5,GETDISP#         MOVE IT TO THE SCREEN\n         TM    JCJFLAGS,X'01'      SINGLE LENGTH?\n         BO    SSL1                YES, SKIP 2ND LENGTH PROCESSING\n         SLDL  R2,4                GET 2ND LENGTH\n         BAL   R14,GETNUMI         AND MOVE IT TO SCREEN\n         BAL   R14,COMMA           A DELIMITER OR TWO\nSSL1     IC    R2,4(,R6)           GET SECOND BASE FIELD\n         BAL   R5,GETBASE#         GET THE BASE IN SCREEN\nDISLEAVE TM    JCJFLAGS,X'10'      DO WE HAVE A BAD LENGTH?\n         BZ    *+L'*+4             NO, HOP OVER THE BIT RESET\n         NI    JCJFLAGS,255-X'40'  FIX FOR CORRECT LENGTH\n         XR    R1,R1               SET UP FOR IC\n         IC    R1,JCJFLAGS         GET THE LENGTH\n         SRL   R1,5                WIPE OUT FLAG BITS  = LENGTH\n         B     GOODRET             EXIT OK\n*              EXTENDED MNENOMIC ROUTINE.\nGETMNE   SRDL  R2,4                SHIFT TO CLEAR OUT REGISTER NIBBLE\n         MH    R2,=Y(L'MNEOPS)     INDEX INTO TABLE\n         L     R1,=A(MNEOPS)       TABLE\n         AR    R1,R2               PNT TO TABLE ENTRY\n         MVC   0(3,R9),0(R1)       MOVE IN PRIMARY MNEMONIC\n         CLI   3(R1),C' '          SECONDARY MNENOMIC PRESENT?\n         BE    GETMNE#             NO, CONTINUE ON\n         MVC   5(3,R9),3(R1)       GET SECONDARY ONE\n         LR    R14,R9              SAVE CURR BUFFER PNTR\n         AH    R9,=Y(L'MNEOPS)     AND UP WORK BUFFER PNTR\nGETMNE#  TM    JCJFLAGS,X'80'      NON 2 BYTE INSTRUCTION?\n         BO    GETINST             YES, LEAVE\n         CLI   3(R1),C' '          TWO MNENOMICS NEEDED?\n         BE    ONEMNE              NO, SO DO ONE DUMMY...\n         BAL   R5,RLOOP            PUT IN A 'R' (RR TYPE)\nONEMNE   LR    R14,R9              PNT TO CURR MNEMONIC\n         LA    R5,GETINST          FAKE OUT A BAL AND RETURN\nRLOOP    ALR   R14,R4              PNT TO NEXT CHAR\n         CLI   0(R14),C' '         A BLANK WAITING FOR 'R'?\n         BNE   RLOOP               NO, INCREMENT\n         MVI   0(R14),C'R'         YES, PUT IN THE 'R'\n         BR    R5                  AND GO HOME\n         SPACE 1\n*- - - - DISASSEMBLER ROUTINES (USED TO SAVE BYTES HERE AND THERE).\n*              THIS ROUTINE GETS THE BASE REGISTER.\n*              R5 = LINK REGISTER.\nGETBASE  IC    R2,2(,R6)           GET THE BASE\nGETBASE# SRL   R2,4                SHIFT OUT GARBAGE\n         BAL   R14,GETNUM          GO MOVE TO SCREEN\n         MVI   0(R9),C')'          PUT IN A R-PAREN\n         ALR   R9,R4               INCREMENT LINE PNTR\n         BR    R5                  GO TO CALLER\n*              THIS ROUTINE GETS THE DISPLACEMENT FIELD.\n*              R5 = LINK REGISTER.\nGETDISP  LH    R2,2(,R6)           LOAD THE DISPLACEMENT\nGETDISP# N     R2,DISPMASK         WIPE OUT BASE BITS\n         BAL   R14,GETNUM          DO THE MOVE TO SCREEN\n         CLI   JCJFLAGS,C'J'       IS IT SVCX OR DIAGNOSE?\n         BE    DISLEAVE            YES, GO AWAY\n         MVI   0(R9),C'('          ELSE MOVE IN A L-PAREN\n         ALR   R9,R4               INCREMENT LINE PNTR\n         BR    R5                  GO TO CALLER\n*              THIS ROUTINE SETS A COMMA.\n*              R14 = LINK REGISTER.\nCOMMA    MVI   0(R9),C','          MOVE IN A COMMA\n         ALR   R9,R4               INCREMENT PNTR\n         BR    R14                 GO TO CALLER\n*              THIS ROUTINE PUTS THE CHAR VALUE OF THE CONTENTS OF\n*              R2 INTO THE SCREEN (VIA R9) AND UPDATES R9 (POINT TO\n*              THE NEXT AVAILABLE POSITION).\n*              R14 = LINK REGISTER.\nGETNUMI  ALR   R2,R4               INCREMENT FOR A LENGTH FIX\nGETNUM   CVD   R2,JCJDW1           GET IT IN DECIMAL\n         MVC   JCJEDIT,EDITMASK    SET UP FOR EDIT\n         LA    R15,JCJEDIT+L'JCJEDIT-1 PNT TO END OF AREA\n         LR    R1,R15              SET UP R1 FOR EDMK\n         EDMK  JCJEDIT,JCJDW1+5    DO THE EDIT\n         SR    R15,R1              GET THE EXECUTE LENGTH\n         EX    R15,NUMMOVE         MOVE THE VALUE TO THE SCREEN\n         LA    R9,1(R15,R9)        UPDATE THE SCREEN PNTR\n         XR    R2,R2               ZERO OUR WORK REGISTER\n         BR    R14                 GO HOME\nNUMMOVE  MVC   0(*-*,R9),0(R1)     <<EXECUTED>>\n         SPACE 1\n*- - - - CONSTANTS.\nDISPMASK DC    0F'0',XL4'00000FFF'\nEDITMASK DC    XL6'402020202120'\nSICHAR   DC    CL3',X'''\n         DC    CL16'0123456789ABCDEF'\nHXTB     EQU   *-256\n         PRINT &PRS\n*- - - - LITERAL POOL.\n        LTORG\n         SPACE 1\n         DROP  R7,R12\n*------- E X T E N D E D   M N E N O M I C   T A B L E --------------*\nMNEOPS   DC    CL6'NOP   '\n         DC    CL6'BO    '\n         DC    CL6'BH BP '\n         DC    CL6'BC    '\n         DC    CL6'BL BM '\n         DC    CL6'BC    '\n         DC    CL6'BC    '\n         DC    CL6'BNEBNZ'\n         DC    CL6'BE BZ '\n         DC    CL6'BC    '\n         DC    CL6'BC    '\n         DC    CL6'BNLBNM'\n         DC    CL6'BC    '\n         DC    CL6'BNHBNP'\n         DC    CL6'BNO   '\n         DC    CL6'B     '\n         SPACE 1\n*------- O P C O D E   T R A N S L A T E   T A B L E ----------------*\nOPTAB    DC    AL1(@00,@00,@00,@00,@04,@05,@06,@07)\n         DC    AL1(@08,@09,@0A,@0B,@00,@0D,@0E,@0F)\n         DC    AL1(@10,@11,@12,@13,@14,@15,@16,@17)\n         DC    AL1(@18,@19,@1A,@1B,@1C,@1D,@1E,@1F)\n         DC    AL1(@20,@21,@22,@23,@24,@25,@26,@27)\n         DC    AL1(@28,@29,@2A,@2B,@2C,@2D,@2E,@2F)\n         DC    AL1(@30,@31,@32,@33,@34,@35,@36,@37)\n         DC    AL1(@38,@39,@3A,@3B,@3C,@3D,@3E,@3F)\n         DC    AL1(@40,@41,@42,@43,@44,@45,@46,@47)\n         DC    AL1(@48,@49,@4A,@4B,@4C,@4D,@4E,@4F)\n         DC    AL1(@50,@51,@00,@00,@54,@55,@56,@57)\n         DC    AL1(@58,@59,@5A,@5B,@5C,@5D,@5E,@5F)\n         DC    AL1(@60,@00,@00,@00,@00,@00,@00,@67)\n         DC    AL1(@68,@69,@6A,@6B,@6C,@6D,@6E,@6F)\n         DC    AL1(@70,@00,@00,@00,@00,@00,@00,@00)\n         DC    AL1(@78,@79,@7A,@7B,@7C,@7D,@7E,@7F)\n         DC    AL1(@80,@00,@82,@83,@84,@85,@86,@87)\n         DC    AL1(@88,@89,@8A,@8B,@8C,@8D,@8E,@8F)\n         DC    AL1(@90,@91,@92,@93,@94,@95,@96,@97)\n         DC    AL1(@98,@00,@00,@00,@9C,@9D,@9E,@9F)\n         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)\n         DC    AL1(@00,@00,@00,@00,@AC,@AD,@AE,@AF)\n         DC    AL1(@00,@B1,@B2,@00,@00,@00,@B6,@B7)\n         DC    AL1(@00,@00,@BA,@BB,@00,@BD,@BE,@BF)\n         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)\n         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)\n         DC    AL1(@00,@D1,@D2,@D3,@D4,@D5,@D6,@D7)\n         DC    AL1(@00,@00,@00,@00,@DC,@DD,@DE,@DF)\n         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)\n         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)\n         DC    AL1(@F0,@F1,@F2,@F3,@00,@00,@00,@00)\n         DC    AL1(@F8,@F9,@FA,@FB,@FC,@FD,@00,@00)\n         SPACE 1\n*------- O P C O D E   T A B L E ------------------------------------*\n* TABLE FORMAT : CL4'MNEMONIC',CL1'FLAG',XL1'OPCODE'\n*      RR TYPE : C'(',X'4D' - EXTENDED MNEMONIC\n*                C'+',X'4E' - SVC       IMED\n*                C'|',X'4F' - NORMAL RR TYPE\n*                C'&',X'50' - SPM TYPE\n*      RX TYPE : C'O',X'D6' - INDEX REGISTER USED   R1,D2(X2,B2)\n*                C'M',X'D4' - EXTENDED MNENOMIC     D2(X2,B2)\n*                C'L',X'D3' - SI TYPE               D1(B1),I2\n*                C'J',X'D1' - DIAGNOSE,SVCX   IMED  I\n*                C'K',X'D2' - DISP(BASE) TYPE       D1(B1)\n*                C'R',X'D9' - BXLE,BXH,STM,LM       R1,R3,D2(B2)\n*                C'Q',X'D8' - REGISTER SHIFT TYPE   R1,D2(B2)\n*      SS TYPE : C'S',X'E2' - TWO LENGTHS REQUIRED\n*                C'T',X'E3' - ONLY ONE LENGTH\n         PRINT &PRF\nOPCODES  DS    0XL6\n@00      EQU   0                   FOR UNDEFINED OPCODES\n        @OP    SPM,|,04\n        @OP    BALR,|,05\n        @OP    BCTR,|,06\n        @OP    BCR,'(',07\n        @OP    SSK,|,08\n        @OP    ISK,|,09\n        @OP    SVC,+,0A\n        @OP    BSM,|,0B\n        @OP    BASR,|,0D\n        @OP    MVCL,|,0E\n        @OP    CLCL,|,0F\n        @OP    LPR,|,10\n        @OP    LNR,|,11\n        @OP    LTR,|,12\n        @OP    LCR,|,13\n        @OP    NR,|,14\n        @OP    CLR,|,15\n        @OP    OR,|,16\n        @OP    XR,|,17\n        @OP    LR,|,18\n        @OP    CR,|,19\n        @OP    AR,|,1A\n        @OP    SR,|,1B\n        @OP    MR,|,1C\n        @OP    DR,|,1D\n        @OP    ALR,|,1E\n        @OP    SLR,|,1F\n        @OP    LPDR,|,20\n        @OP    LNDR,|,21\n        @OP    LTDR,|,22\n        @OP    LCDR,|,23\n        @OP    HDR,|,24\n        @OP    LRDR,|,25\n        @OP    MXR,|,26\n        @OP    MXDR,|,27\n        @OP    LDR,|,28\n        @OP    CDR,|,29\n        @OP    ADR,|,2A\n        @OP    SDR,|,2B\n        @OP    MDR,|,2C\n        @OP    DDR,|,2D\n        @OP    AWR,|,2E\n        @OP    SWR,|,2F\n        @OP    LPER,|,30\n        @OP    LNER,|,31\n        @OP    LTER,|,32\n        @OP    LCER,|,33\n        @OP    HER,|,34\n        @OP    LRER,|,35\n        @OP    AXR,|,36\n        @OP    SXR,|,37\n        @OP    LER,|,38\n        @OP    CER,|,39\n        @OP    AER,|,3A\n        @OP    SER,|,3B\n        @OP    MER,|,3C\n        @OP    DER,|,3D\n        @OP    AUR,|,3E\n        @OP    SUR,|,3F\n        @OP    STH,O,40\n        @OP    LA,O,41\n        @OP    STC,O,42\n        @OP    IC,O,43\n        @OP    EX,O,44\n        @OP    BAL,O,45\n        @OP    BCT,O,46\n        @OP    BC,M,47\n        @OP    LH,O,48\n        @OP    CH,O,49\n        @OP    AH,O,4A\n        @OP    SH,O,4B\n        @OP    MH,O,4C\n        @OP    BAS,O,4D\n        @OP    CVD,O,4E\n        @OP    CVB,O,4F\n        @OP    ST,O,50\n        @OP    SVCX,J,51\n        @OP    N,O,54\n        @OP    CL,O,55\n        @OP    O,O,56\n        @OP    X,O,57\n        @OP    L,O,58\n        @OP    C,O,59\n        @OP    A,O,5A\n        @OP    S,O,5B\n        @OP    M,O,5C\n        @OP    D,O,5D\n        @OP    AL,O,5E\n        @OP    SL,O,5F\n        @OP    STD,O,60\n        @OP    MXD,O,67\n        @OP    LD,O,68\n        @OP    CD,O,69\n        @OP    AD,O,6A\n        @OP    SD,O,6B\n        @OP    MD,O,6C\n        @OP    DD,O,6D\n        @OP    AW,O,6E\n        @OP    SW,O,6F\n        @OP    STE,O,70\n        @OP    LE,O,78\n        @OP    CE,O,79\n        @OP    AE,O,7A\n        @OP    SE,O,7B\n        @OP    ME,O,7C\n        @OP    DE,O,7D\n        @OP    AU,O,7E\n        @OP    SU,O,7F\n        @OP    SSM,K,80\n        @OP    LPSW,K,82\n        @OP    DIAG,J,83\n        @OP    WRD,L,84\n        @OP    RDD,L,85\n        @OP    BXH,R,86\n        @OP    BXLE,R,87\n        @OP    SRL,Q,88\n        @OP    SLL,Q,89\n        @OP    SRA,Q,8A\n        @OP    SLA,Q,8B\n        @OP    SRDL,Q,8C\n        @OP    SLDL,Q,8D\n        @OP    SRDA,Q,8E\n        @OP    SLDA,Q,8F\n        @OP    STM,R,90\n        @OP    TM,L,91\n        @OP    MVI,L,92\n        @OP    TS,K,93\n        @OP    NI,L,94\n        @OP    CLI,L,95\n        @OP    OI,L,96\n        @OP    XI,L,97\n        @OP    LM,R,98\n        @OP    SIO,K,9C\n        @OP    TIO,K,9D\n        @OP    HIO,K,9E\n        @OP    TCH,K,9F\n        @OP    STNSM,L,AC\n        @OP    STOSM,L,AD\n        @OP    SIGP,R,AE\n        @OP    MC,L,AF\n        @OP    LRA,O,B1\n        @OP    S370,K,B2\n        @OP    STCTL,R,B6\n        @OP    LCTL,R,B7\n        @OP    CS,R,BA\n        @OP    CDS,R,BB\n        @OP    CLM,R,BD\n        @OP    STCM,R,BE\n        @OP    ICM,R,BF\n        @OP    MVN,C,D1\n        @OP    MVC,C,D2\n        @OP    MVZ,C,D3\n        @OP    NC,C,D4\n        @OP    CLC,C,D5\n        @OP    OC,C,D6\n        @OP    XC,C,D7\n        @OP    TR,C,DC\n        @OP    TRT,C,DD\n        @OP    ED,C,DE\n        @OP    EDMK,C,DF\n        @OP    SRP,S,F0\n        @OP    MVO,B,F1\n        @OP    PACK,B,F2\n        @OP    UNPK,B,F3\n        @OP    ZAP,B,F8\n        @OP    CP,B,F9\n        @OP    AP,B,FA\n        @OP    SP,B,FB\n        @OP    MP,B,FC\n        @OP    DP,B,FD\nOPEND    EQU   *-L'OPCODES\n         EJECT\n*------- ZAP HELP PANELS --------------------------------------------*\n         PRINT &PRF\nZAPHELP  DC    A(ZAPHP1)\n         DC    A(ZAPHP2)\n         DC    A(ZAPHP3)\n         DC    A(ZAPHP4)\n         DC    A(ZAPHP5)\n         DC    A(ZAPHP6)\n         DC    A(ZAPHP7)\n         DC    A(ZAPHP8)\n         DC    A(ZAPHP9)\n         DC    A(ZAPHP10)\n         DC    A(ZAPHP11)\n         DC    A(ZAPHP12)\nNUMHLP   EQU   (*-ZAPHELP)/L'ZAPHELP    NUMBER OF HELP PANELS\nLENHLL   EQU   60        MAX. LENGTH OF A HELP LINE (AS IN @IML MACRO)\nZAPHP1   EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 1\n*        ----+----1----+----2----+----3----+----4----+----5----+----6\n  @IML  'CONTENTS :  ?1 - THIS SCREEN'\n  @IML  '            ?2 - GENERAL INFORMATION'\n  @IML  '            ?3 - INPUT/OUTPUT COMMANDS'\n  @IML  '            ?4 - INPUT/OUTPUT COMMANDS (CONTINUED)'\n  @IML  '            ?5 - SESSION CONTROL COMMANDS'\n  @IML  '            ?6 - DUMP COMMANDS'\n  @IML  '            ?7 - BYTE COMMANDS'\n  @IML  '            ?8 - STRING COMMANDS'\n  @IML  '            ?9 - MISCELLANEOUS COMMANDS'\n  @IML  '           ?10 - MISCELLANEOUS COMMANDS (CONTINUED)'\n  @IML  '           ?11 - EXPLANATION OF SYMBOLS'\n  @IML  '           ?12 - SAMPLE ZAP SESSION'\n  @IML  END\nZAPHP2   EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 2\n  @IML  '                     GENERAL INFORMATION'\n  @IML  '-- THE OPERANDS ARE ENTERED AFTER THE COMMAND, WITH NO'\n  @IML  '   INTERVENING BLANKS.'\n  @IML  '-- THE BLOCK IS READ INTO A WORK BUFFER, WHERE YOU MODIFY'\n  @IML  '   IT. WHEN YOU ENTER A \"ZAP\" COMMAND, THE BLOCK IS WRITTEN'\n  @IML  '   BACK TO THE DATA-SET FROM THE BUFFER. IF ANY OTHER JOB'\n  @IML  '   OR USER HAS UPDATED THAT BLOCK IN BETWEEN WHEN YOU FIRST'\n  @IML  '   DISPLAYED IT AND WHEN YOU \"ZAPPED\" IT, THE OTHER CHANGES'\n  @IML  '   WILL BE LOST.'\n  @IML  '-- IF YOU MAKE CHANGES TO A BLOCK, TO GO TO ANOTHER BLOCK'\n  @IML  '   YOU MUST EITHER \"ZAP\" THE BLOCK (RE-WRITE IT TO THE'\n  @IML  '   DATA-SET), OR ENTER THE COMMAND TWICE IN A ROW WHICH WILL'\n  @IML  '   CAUSE YOU TO LEAVE TO CURRENT MODIFIED BLOCK.'\n  @IML  END\nZAPHP3   EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 3\n  @IML  '                   INPUT/OUTPUT COMMANDS'\n  @IML  ''\n  @IML  'P<EXP>      - POINT TO RECORD WHOSE TTR=EXP'\n  @IML  'P           - POINT TO BEGINNING OF DATA-SET'\n  @IML  'T<EXP>      - POINT TO TRACK <EXP>, RECORD 1'\n  @IML  'T           - POINT TO NEXT TRACK, RECORD 1'\n  @IML  'R<EXP>      - SHOW BLOCK <EXP> RELATIVE TO CURRENT'\n  @IML  'R           - POINT TO NEXT PHYSICAL RECORD'\n  @IML  'B           - POINT TO PREVIOUS RECORD'\n  @IML  'LAST        - POINT TO LAST RECORD (DS1LSTAR)'\n  @IML  'LASTDS1     - POINT TO LAST FORMAT 1 IN VTOC'\n  @IML  END\nZAPHP4   EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 4\n  @IML  '             INPUT/OUTPUT COMMANDS (CONTINUED)'\n  @IML  ''\n  @IML  'ABS<EXP>    - POINT TO REC. WITH CCHHR=EXP'\n  @IML  '%<EXP>      - POINT TO TTR @ LOC <EXP> IN BLOCK'\n  @IML  'M<NAME>     - FOR PDS, POINT TO MEMBER <NAME>'\n  @IML  'M           - POINT TO START OF THE CURRENT MEMBER'\n  @IML  'NAME<N>     - AFTER \"M\", SHOW ENTRY POINT <N>'\n  @IML  'NAME        - SELECT ENTRY POINT NAMED MEMBER'\n  @IML  'E<N>        - SAME AS NAME<N>'\n  @IML  'E           - SAME AS NAME'\n  @IML  'ZAP         - REPLACE BLOCK FROM THE CURRENT BUFFER'\n  @IML  END\nZAPHP5   EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 5\n  @IML  '                  SESSION CONTROL COMMANDS'\n  @IML  ''\n  @IML  'LOG         - START LOGGING THIS SESSION'\n  @IML  'NOTE<COMNT> - WRITE A COMMENT <COMNT> INTO LOG FILE'\n  @IML  'EJECT       - EJECT A PAGE IN THE LOG FILE'\n  @IML  'W           - SET WINDOW SINGLE LINE DOWN/UP'\n  @IML  'WFULL       - SET WINDOW DEFAULTS DOWN/UP SIZES'\n  @IML  'W<D>,<U>    - SET WINDOW DOWN/UP SIZE(S)'\n  @IML  'END         - TERMINATE, NORMAL EXIT OF ZAP / PFK 3-15'\n  @IML  'CAN/CANCEL  - CANCEL, IMMEDIATE EXIT OF ZAP / PA1 KEY'\n  @IML  END\nZAPHP6   EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 6\n  @IML  '                       DUMP COMMANDS'\n  @IML  ''\n  @IML  'DUMP        - DUMP ALL RECORDS IN THE DATA-SET IN ABDUMP'\n  @IML  '              FORMAT'\n  @IML  'DUMPT<EXP>  - DUMP TO TTR <EXP> FROM CURRENT RECORD'\n  @IML  'DUMPT       - DUMP CURRENT RECORD ONLY'\n  @IML  'DUMPF<EXP>  - DUMP FOR <EXP> RECORDS FROM CURRENT RECORD'\n  @IML  'DUMPF       - DUMP CURRENT RECORD'\n  @IML  'DUMPE       - DUMP CURRENT RECORD TO EOF'\n  @IML  ''\n  @IML  '-- ON ANY EOF, I/O ERROR OR END-OF-DS : HALT DUMP '\n  @IML  END\nZAPHP7   EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 7\n  @IML  '                       BYTE COMMANDS'\n  @IML  ''\n  @IML  'D<EXP>      - DISPLAY BYTE AT OFFSET <EXP>'\n  @IML  '<EXP>       - SAME AS D<EXP>'\n  @IML  'D           - PAGE TO NEXT SCREEN (D+#SCREEN) / PFK 8-20'\n  @IML  'U           - PAGE TO PREV SCREEN (D-#SCREEN) / PFK 7-19'\n  @IML  '>           - GO FORWARD IN TRACE TABLE'\n  @IML  '<           - GO BACKWARD IN TRACE TABLE'\n  @IML  'EBCDIC      - EBCDIC TRANSLATION (DEFAULT)'\n  @IML  'ASCII       - ASCII-8 TRANSLATION'\n  @IML  'ZCODE       - ZCODE TRANSLATION'\n  @IML  '=<LAB>      - DEFINE <LAB> TO CURRENT LOC'\n  @IML  'NODEF       - CLEAR ALL DEFINED LABELS FROM ='\n  @IML  END\nZAPHP8   EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 8\n  @IML  '                      STRING COMMANDS'\n  @IML  ''\n  @IML  'S<STR>      - STORE <STR> AT CURRENT LOC'\n  @IML  'X<STR>      - EXCLUSIVE OR AT CURRENT LOC'\n  @IML  'O<STR>      - OR AT CURRENT LOC'\n  @IML  'N<STR>      - AND AT CURRENT LOC'\n  @IML  'SET<STR>    - SET ENTIRE RECORD TO <STR>'\n  @IML  'L<STR>      - LOOK FOR <STR> FROM NEXT BYTE'\n  @IML  'L           - CONTINUE LOOKING FOR <STR> / PFK 5-17'\n  @IML  'F<STR>      - LIKE L<STR>, CONT''S PAST EOFS'\n  @IML  'F           - LIKE L, CONTINUES PAST EOFS'\n  @IML  ''\n  @IML  '-- S,X,O,N,SET MAY BE ENTERED ALONE TO USE PREVIOUS <STR>'\n  @IML  END\nZAPHP9   EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 9\n  @IML  '                   MISCELLANEOUS COMMANDS'\n  @IML  ''\n  @IML  '#<EXP>      - FIND HEX/DECIMAL VALUE OF <EXP>'\n  @IML  'FLOAT<F>    - FIND FLOATING POINT VALUE OF <F>'\n  @IML  'IDEF        - DISPLAY DEFINE LABEL TABLE'\n  @IML  'ITRACE      - DISPLAY TRACE TABLE'\n  @IML  '?N          - VIEW NTH HELP DISPLAY (1-12)'\n  @IML  'WHERE       - GIVE CURRENT LOCATION ETC...'\n  @IML  'ASM<OP>     - GIVE OBJECT CODE FOR MNEMONIC'\n  @IML  'DISASM<EXP> - DISASSEMBLE INSTRUCTION AT <EXP>'\n  @IML  'CAPSON      - FOR STRING COMMANDS'\n  @IML  'CAPSOFF     - FOR STRING COMMANDS'\n  @IML  END\nZAPHP10  EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 10\n  @IML  '             MISCELLANEOUS COMMANDS (CONTINUED)'\n  @IML  ''\n  @IML  'WHATMEM     - FIND DIRECTORY ENTRY CLOSEST TO CURRENT RECORD'\n  @IML  'WM          - SAME AS WHATMEM              '\n  @IML  'V<EXP>      - ADD CONTENTS OF 2 BYTES AT <EXP> TO CURRENT'\n  @IML  '              VALUE OF LOC'\n  @IML  'BASE<EXP>   - ADD <EXP> TO BUFFER OFFSET WHEN COMPUTING'\n  @IML  '              ADDRESS'\n  @IML  'DISP<TYPE>  - SET RECORD DISPLAY START POSITION, <TYPE> IS'\n  @IML  '              IS COUNT-KEY-DATA'\n  @IML  'J<TTR>      - REL. TO BEGINING OF VOLUME'\n  @IML  END\nZAPHP11  EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 11\n  @IML  '                   EXPLANATION OF SYMBOLS'\n  @IML  ''\n  @IML  '<EXP> IS COMPOSED OF OPERATORS (+,-,*,/), DEFINE SYMBOLS'\n  @IML  '    (''='' COMMAND) AND HEX OR DEC CONSTANTS.'\n  @IML  '    THE FOLLOWING SYMBOLS ARE PREDEFINED :'\n  @IML  '    * = CURRENT OFFSET       L = LOGICAL RECORD LENGTH'\n  @IML  '    K = KEY LENGTH           BL = MAX. BLKSIZE'\n  @IML  '<STR> MAY BE EITHER UP TO 16 CHARACTERS ENCLOSED IN ANY'\n  @IML  '    DELIMITER, OR UP TO 16 HEX DIGITS, OR A DECIMAL VALUE'\n  @IML  '    ENDING WITH \".\" (LENGTH IS 4 BYTES).'\n  @IML  '<LAB> MAY ANY 1 TO 8 CHARACTERS.'\n  @IML  '<F> IS ANY FLOATING POINT CONSTANT IN INTERNAL FORM (IE :'\n  @IML  '    40800000 IS .5 VALUE).'\n  @IML  END\nZAPHP12  EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 12\n  @IML  '                     SAMPLE ZAP SESSION'\n  @IML  ''\n  @IML  'ZAP LOAD    READY LEVEL COMMAND ENTERED'\n  @IML  'MTEST       SELECT MEMBER \"TEST\"'\n  @IML  'EFIRST      SELECT ENTRY POINT \"FIRST\"'\n  @IML  '4C          GO TO OFFSET X''4C'' IN RECORD'\n  @IML  'S00         STORE ONE BYTE HEXADECIMAL'\n  @IML  '+4          ADVANCE POINTER 4 BYTES IN BLOCK'\n  @IML  'NFF0F       TURN OFF ONE NIBBLE'\n  @IML  'ZAP         RE-WRITE THAT BLOCK'\n  @IML  'R+3         GO TO THIRD BLOCK FROM HERE'\n  @IML  'L/HELLO/    FIND SOME TEXT'\n  @IML  'END         ALL DONE - EXIT ZAP'\n  @IML  END\n         PRINT &PRS\n         EJECT\nESDDATA  DSECT , ----------------- ESD DATA ENTRY --------------------\nESDDNAME DS    CL8                 ENTRY POINT NAME OF 8X'00'\nESDDTYPE DS    X                   TYPE\nESDDADDR DS    AL3                 LKED ADDRESS OF ENTRY POINT\nESDDSEG  DS    AL1                 SEGMENT NUMBER\nESDDLEN  DS    AL3                 LENGTH OF ENTRY\nESDDL    EQU   *-ESDDATA           LENGTH ESD DATA ENTRY\n         SPACE 1\nJCJWORK  DSECT , -----------------------------------------------------\nJCJDW1   DS    D\nJCJDW2   DS    D\nJCJEDIT  DS    CL6\nJCJFLAGS DS    XL1\n         SPACE 1\nCSDATA   DSECT , -----------------------------------------------------\n         DS    18F                 SAVE-AREA OF \"CSOUT\"\nCSDBLW   DS    D                   SCRATCH DOUBLE-WORD\nCSODCB   DS    0F,XL(ODCBLEN)\nCSPGNO   DS    H                   PAGE COUNTER\nCSLNNO   DS    H                   LINE COUNTER\nCSFLAGS  DS    XL1\nCSIOERR  EQU   X'01'               AN I/O ERROR HAS OCCURED\nCSOBUFF  DS    CL133               BUFFER ITSELF\nCSTBUFF  DS    CL133               BUFFER FOR TITLE LINE\nLCSOUT   EQU   (((*-CSDATA)+7)/8)*8\n         SPACE 1\nTSDSECT  DSECT , ----------------- DYNAMIC STORAGE DEFINITIONS -------\nEYECATCH DS    CL8                 \"EXEC.ZAP\"\nZUSRID   DS    CL8                 USER-ID\nDDNALL   DS    CL8                 SAVE DDNAME TO FREE IT\nDDPALL   DS    CL8                 SAVE DDNAME TO FREE IT\nFLAGSX   DS    XL1                 MISCELLANEOUS CONTROL FLAGS\nRUNTSO   EQU   X'80'               WE ARE RUNNING IN TSO\nSENSF    EQU   X'40'               SYSTEM DATA-SET\nMUSTZAP  EQU   X'01'               BLOCK NOT REPLACED, ENTER SAVE/END\nFLAGSG   DS    XL1                 \"GOD\" DATA-SET STATUS FLAGS\nGODALL   EQU   X'80'               DATA-SET IS ALLOCATED\nGODOPN   EQU   X'40'               DATA-SET IS OPENED\nGODUP    EQU   X'01'               ONLY HE CAN CHANGE HIS MIND\nFLAGSL   DS    XL1                 \"LOG\" DATA-SET STATUS FLAGS\nLOGALL   EQU   X'80'               DATA-SET ALLOCATED\nLOGOPN   EQU   X'40'               DATA-SET OPENED\nLOGFS    EQU   X'08'               LOGGING FORCED\nLOGRQ    EQU   X'04'               LOGGING REQUESTED\n*- - - - ZAP'S DATA AREA FOR \"EXP\"\nEXPOPT   DS    XL1                 WHETHER TO SCAN SYMBOL TABLE\nYESSYMB  EQU   X'FF'               \"EXP\" LOOK AT SYMBOL TABLE\nNOSYMB   EQU   X'00'               NO SYMBOL TABLE LOOK-UP\nGORF     DS    F                   SAVE POINTER\nZDBLW    DS    D\nEXPWORK  DS    D\nEXPFLAG  DS    3F\nEXPFPLUS EQU   X'80'               ADD NEXT VALUE\nEXPFMINS EQU   X'40'               SUBTRACT NEXT VALUE\nEXPFDEC  EQU   X'20'\nEXPFMULT EQU   X'10'               MULT NEXT VALUE\nEXPFDIV  EQU   X'08'               DIV NEXT VALUE\nEXPEXOPR EQU   X'04'               EXPECTING OPERATOR NEXT\n*              SOMETHING REQUIRED FLAG :\nEXPFTERM EQU   EXPFPLUS+EXPFMINS+EXPFDEC+EXPFMULT+EXPFDIV\n*                                  \"EXP\" SAVE REGISTERS\nEXPARMS  DS    A                    \"\" -R14\nEXPSTART DS    A                    \"\" -R15\n         DS    F                    \"\" -R0 (LENGTH)\nEXPPTR   DS    A                    \"\" -R1\n*- - - - ZAP'S DATA AREA\nNOWSTUFF DS    0F             FOLLOWING 3 LINES *MUST*BE*TOGETHER*\nOLDPOINT DS    H                   OFFSET INTO BUFFER\nOFFSET   DS    F                   (OLDPOINT + BASEVAL)\nBASEVAL  DS    F                   BASE VALUE\nNOWLEN   EQU   *-NOWSTUFF\nAIDEFTAB DS    A                   ADDRESS OF DEFINE TABLE\nAITRCTAB DS    A                   ADDRESS OF TRACE TABLE\nAITREND  DS    A                   -> END OF TRACE TABLE\nFIRSTSCR DS    A                   ADDRESS OF FIRST SCREEN LOC\nMAXSCR   DS    A                   ADDRESS OF END OF AVAIL SCREEN\nASPLTA   DS    F                   ADDRESS OF \"SPLTAREA\"\nZBUFFA   DS    F                   BUFFER AREA ADDRESS\nZBUFFL   DS    F                   BUFFER AREA LENGTH\nCSALOC   DS    F                   ADDRESS OF \"CSOUT\" WORK-AREA\nCSLLOC   DS    A                   ADDRESS OF LINE BUFFER (\"CSOBUFF\")\nTEMPTRT  DS    XL256               TEMPORARY TRTAB FOR STRING ANAL\n$L       EQU   79                  LENGTH OF DISPLAY LINE\n$I       EQU   81                  LINE INCREMENT (AS IN SCREEN)\n         DS    XL2                 SCREEN LINES ...\nLINE01   DS    CL79,XL2             -> 1\nCMDLINE  DS    CL79,XL2             -> 2\nLINE03   DS    CL79,XL2             -> 3\nREPLINE  DS    CL79,XL2             -> 4\nIOMLINE  DS    CL79,XL2             -> 5\nLINE06   DS    CL79,XL2             -> 6\nLINE07   DS    CL79,XL2             -> 7\nLINE08   DS    CL79,XL2             -> 8\n         DS    CL79,XL2             -> 9\n         DS    CL79,XL2             -> 10\n         DS    CL79,XL2             -> 11\n         DS    CL79,XL2             -> 12\n         DS    CL79,XL2             -> 13\n         DS    CL79,XL2             -> 14\n         DS    CL79,XL2             -> 15\n         DS    CL79,XL2             -> 16\n         DS    CL79,XL2             -> 17\n         DS    CL79,XL2             -> 18\nMSGLINE  DS    CL79,XL2             -> 19\nLINE20   DS    CL79,XL2             -> 20\nLINE21   DS    CL79                 -> 21\n         DS    0D                  THEN ALIGN\n         ORG   LINE07              BACK TO THERE, MOMENTARILY\n         PRINT &PRF\nDSCB     DS    0D\n        IECSDSL1 (1)               FORMAT 1 DSCB EXPANSION\n         ORG   DS1FMTID\n        IECSDSL1 (4)               FORMAT 4 DSCB EXPANSION\n         PRINT &PRS\n         ORG   ,\nREGS3270 DS    2A                  A(SCREEN,SCREENL)\nREPX     DS    CL(1+2+(3+79)*2)    REPLY BUFFER (READ TUBE)\nPREVREP  DS    CL79                THE PREVIOUS REPLY\nCURPOS   DS    H                   CURSOR POSITION\nZDSNME   DS    CL44                DATA-SET NAME\nZPSSWRD  DS    CL8                 GUESS WHAT?\nDISPDSN  DS    CL44                DISPLAYABLE DSN\nTTR      DS    F                   TTR OF BLK\nNOSEQRD  EQU   X'00'               READ THIS RECORD\nSEQREAD  EQU   X'01'               READ NEXT RECORD\n*        THE LAST BYTE OF \"TTR\" IS USED FOR A SEQUENTIAL READ FLAG\nOLDTTR   DS    F                   TTR OF LAST STORE OR SET CMD\nSTOPDUMP DS    XL3                 TTR WHERE TO STOP DUMP\nZDSORG   DS    XL1                 DSORG OF CURRENT DATA-SET\nIDEFAVAL DS    A                   1ST AVAL POSIT IN DEFINE TAB\nITRAVAL  DS    A                   1ST AVAIL TRACE TAB POSIT\nCURRITR  DS    F                   CURRENT TRACE TABLE ENTRY POINTER\nTEMPW    DS    9F                  WORK-AREA\nTEMP1    DS    F                   WORK-AREA\nTEMP2    DS    2D                  WORK-AREA\nTEMP3    DS    5D                  WORK-AREA\nDSCBLIST EQU   TEMP3+16,OBTLISTL\nTRTABADD DS    A                   POINTER TO TRTAB FOR DUMP DISPLAY\nTRTXTAB  DS    A                   POINTER TO TRTAB FOR STRING\nMIDLINE  DS    A                   CARET\nWIDTHS   DS    0F                  FOR WINDOWS            |CONTIGUOUS|\nWIDTHD   DS    F                   FOR DOWN               |CONTIGUOUS|\nWIDTHU   DS    F                   FOR UP                 |CONTIGUOUS|\nZLGDSN   DS    F                   \"LOG\" DATA-SET NAME ADDRESS\nZLGVOL   DS    F                   \"LOG\" VOL-SER ADDRESS\nREALRDLN DS    H                   ACTUAL COMND READ LENGTH\nREADLEN  DS    H                   READ LENGTH FROM READ TUBE\nFLAGSR   DS    XL1                 RUNNING STATUS FLAGS\nYESTRACE EQU   X'80'               TRACE IN EFFECT\nYESSYN   EQU   X'40'               SYNAD I/O ERROR HAS OCCURRED\nYESCSERR EQU   X'20'               \"CSOUT\" HAD PROBLEMS\nYESEOF   EQU   X'10'               DO NOT IGNORE EOF'S\n*                                  ELSE, TREAT EOF'S AS DATA BLK\nTCONT    DS    XL1                 STORES, SCAN, SET IN EFFECT\nYESCONTL EQU   X'80'               SCAN CONTINUE IS OK\nYESCONTS EQU   X'40'               S,X,O,N NO OPERANDS OK\nYESCONTT EQU   X'20'               SET NO OPERAND OK\nCAPSFLG  DS    XL1\nYESCAPS  EQU   X'FF'               CAPS ON\nNOCAPS   EQU   X'00'               CAPS OFF\nCHNGED   DS    XL1                 SET IF BUFFER NEEDS CHKPOINTING\nIDRFLAG  DS    XL1                 WHETHER IDR WAS UPDATED OR NOT\nCHGIDR   EQU   X'FF'               WE HAVE CHANGED THE IDR\nNOCHGIDR EQU   X'00'               WE HAVE NOT UPDATED IT YET\nZVOLSER  DS    CL6                 VOL=SER OF DSN\nZMEMBER  DS    CL8                 MEMBER FOR PDS SEARCH\nZNAME    DS    CL8                 ENTRY NAME FOR EPA SEARCH\nLOOKFOR  DS    H,CL16              SCAN WORK-AREA (LEN+STRING)\nZAPSTRNG DS    H,CL16              S,X,O,N WORK-AREA (LEN+STRING)\nSETZSTR  DS    H,CL16              SET WORK-AREA (LEN+STRING)\nWKSTR    DS    CL16                WORK STRING AREA\nADDRCNT  DS    A                   ADDRESS OF RECORD COUNT\nADDRKEY  DS    A                   ADDRESS OF RECORD KEY\nADDRDATA DS    A                   ADDRESS OF RECORD DATA\nADDRBUFF DS    A                   ONE OF THE ABOVE 3 ADDRESSES\nBUFFSIZE DS    H                   MAX BUFFER SIZE\nKEYLEN   DS    H                   CURRENT KEY-LENGTH\nVBLKSZ   DS    H                   VALUE OF DS1BLKL\nVLRECL   DS    H                   VALUE OF DS1LRECL\nBLKLEN   DS    H                   ACTUAL BLOCK LENGTH AFTER READ\nESDID    DS    H                   ESD ID\nMEMTTR   DS    XL3                 SAVE MEMBER'S TTR\nTXTTTR   DS    XL3                 LOAD MOD'S FIRST TEXT BLK\nCTL1TTR  DS    XL3                 TTR OF 1ST CTL REC OR 0\nENDTTR   DS    XL3                 TTR OF LAST BLK IN DATA-SET\nLASTFMT1 DS    XL5                 CCHHR OF LAST FMT1 DSCB\nESDTTR   DS    XL3                 START OF ESD\nTXTORIG  DS    F                   ORIG OF NXT TXT BLOCK\nDCBLIST  DS    F                   DCB POINTER MF=L OPEN AND CLOSE\nDCBU     DS    0F,XL(DCBUL)\nZIOB     DS    0F,XL(IOBLEN)\nCCHHR    EQU   ZIOB+(IOBCC-IOBSTDRD),5 INTERESTING PART\nZECB     DS    A                   ECB FOR ECXP\nCCWS     DS    0D                  HANDLE FOR ALL CCWS\nCCW##R   CCW   X'16',0,X'70',1     READ R0 TO ORIENT\nCCW#R#S  CCW   X'31',*-*,X'40',*-* SEARCH ID EQ\nCCW#R#T  CCW   X'08',*-*,X'00',0   TIC *-8\nCCW#R#R  CCW   X'1E',*-*,X'20',*-* READ CKD\nCCW##W   DS    0D\nCCW#W#S  CCW   X'31',*-*,X'40',*-* SEARCH ID EQ\nCCW#W#T  CCW   X'08',*-*,X'00',0   TIC *-8\nCCW#W#W  CCW   X'0D',*-*,X'00',*-* WRITE KD\nCCW##R0  CCW   X'16',*-*,X'20',*-* READ R0\nCCW##D   CCW   X'16',0,X'70',1     READ R0 TO ORIENT\nCCW#D#S  CCW   X'E9',*-*,X'40',*-* SEARCH KEY EQ/HI MT\nCCW#D#T  CCW   X'08',*-*,X'00',0   TIC *-8\nCCW#D#R  CCW   X'0E',*-*,X'00',8+256 READ KD\nCCW##F   DS    0D\nCCW#F#S  CCW   X'31',*-*,X'40',5   SEARCH ID EQ\nCCW#F#T  CCW   X'08',*-*,X'00',0   TIC *-8\nCCW#F#W  CCW   X'1D',*-*,X'20',*-* WRITE CKD\n         SPACE 1\nEXLST    DS    A                   OBVIOUS\nJFCB     DS    44F                 OBVIOUS\nFLAGESD  DS    XL1                 FLAGS\nFESDTEXT EQU   X'80'               NEXT BLOCK IS TEXT\nICREP    DS    CL79                INTEGRAL COPY OF RESPONSE FIELD\nBLANKS   DS    CL256               CONSTANT FOR CLEARING\n*- - - - - - - - - - - - - - - - END OF \"TSDSECT\" BASE REGISTER - - -*\nIDEFTAB  DS    24XL10              24 ENTRIES DEFINE TABLE\n*        EACH ENTRY (SYMBOL,OFFSET) IS OF THE FORM (8C,2X) AS BELOW :\nDEFSYM   EQU   0,8                 SYMBOL\nDEFOFF   EQU   8,2                 OFFSET\nENDITAB  DS    XL1                 END OF TABLE (X'FF')\nITRTAB   DS    24XL5               TRACE TABLE\n*        EACH ENTRY (TTR,OFFSET) IS OF THE FORM (3X,2X) AS BELOW :\nITRTTR   EQU   0,3                 TTR\nITROFF   EQU   3,2                 OFFSET\nITREND   DS    XL1                 END OF TABLE (X'FF')\n         DS    0D                  REQUESTED ALIGNMENT\nCSAREA   DS    (LCSOUT)X           \"CSOUT\" WORK-AREA\nWSCREEN  DS    (2*KB)X             SCREEN BUFFER\nWSCREENL EQU   *-WSCREEN           LENGTH\n         SPACE 1\nTSDSECTL EQU   (((*-TSDSECT)+7)/8)*8 LENGTH OF DYNAMIC AREA\n         SPACE 1\n        SPLTAREA\n         SPACE 1\n        MYSAVE\n         SPACE 1\n        PARMLIST\n         SPACE 1\n        FDATE\n         EJECT\n         PRINT &PRF\n        CVT    DSECT=YES,LIST=YES\nJFCDSECT DSECT\n        IEFJFCBN LIST=YES\n        DCBD  DSORG=(DA,PS),DEVD=DA\nUCB      DSECT\n        IEFUCBOB\n        IEZIOB\n        IEZDEB LIST=YES\n        IHAECB\n        IEFZB4D0\n         PRINT GEN\n         SPACE 1\n         END\n", "mimetype": "application/x-dosexec", "datatype": "ebcdic", "extension": ".x-dosexec"}, "FAKEGSAM": {"ttr": 18186, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882/\\x00\\x882/\\x17\\x00\\x04\\x1b\\x04\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-17T00:00:00", "modifydate": "1988-11-17T17:00:00", "lines": 1051, "newlines": 1051, "modlines": 0, "user": "SYSPAJA"}, "text": "FAKEGSAM TITLE 'SUBSTITUTE GSAM ROUTINE'\n         PRINT OFF                                                 -EU-\n         COPY  SCHEDMAC                                            -EU-\n         PRINT ON                                                  -EU-\nFAKEGSAM CSECT ,\n         PRINT NOGEN\n         SPACE 3\n*************************************************************\n*        PSA = PREFIXED STORAGE AREA                        *\n*        PSA = DSECT AND BASE                               *\n*************************************************************\n         SPACE 1\n         IHAPSA ,\n         SPACE 3\n*************************************************************\n*        TCB = TASK CONTROL BLOCK                           *\n*        TCBFIX = PREFIX AND BASIC SECTIONS DSECT           *\n*        TCBFIX = PREFIX SECTION BASE                       *\n*        TCB = BASIC SECTION BASE                           *\n*        TCBXTNT2 = COMMON EXTENSION DSECT AND BASE         *\n*************************************************************\n         SPACE 1\n         IKJTCB LIST=YES\n         SPACE 3\n*************************************************************\n*        TIOT = TASK INPUT/OUTPUT TABLE                     *\n*        DSECT CARD NOT GENERATED                           *\n*        TIOCNJOB = BASIC SECTION BASE                      *\n*        TIOENTRY = DD ENTRY BASE                           *\n*        TIOESTTB = DEVICE ENTRY BASE                       *\n*************************************************************\n         SPACE 1\nTIOT     DSECT ,\n         IEFTIOT1 ,\n         SPACE 3\n*************************************************************\n*        ACB = ACCESS METHOD CONTROL BLOCK (VSAM)           *\n*        IFGACB = DSECT AND BASE                            *\n*************************************************************\n         SPACE 1\n         IFGACB ,\n         SPACE 3\n*************************************************************\n*        RPL = REQUEST PARAMETER LIST (VSAM)                *\n*        IFGRPL = DSECT AND BASE                            *\n*************************************************************\n         SPACE 1\n         IFGRPL ,\n         SPACE 3\n*************************************************************\n*        STANDARD REGISTER NAMES                            *\n*************************************************************\n         SPACE 1\n         #REGS R,                  STANDARD REGISTER NAMES             *\n               (BASE1REG,R12),     PROGRAM BASE REGISTER               *\n               (GSBREG,R10),       GSAM REQUEST BLOCK POINTER          *\n               (FGGREG,R9),        GLOBAL DATA AREA POINTER            *\n               (FGLREG,R8)         LOCAL DATA AREA POINTER\n         SPACE 3\n         PRINT ON,GEN,NODATA\nFAKEGSAM CSECT ,\n         TITLE 'OCMA MAP -- VSAM OPEN/CLOSE/TCLOSE MESSAGE AREA HEADER'\nOCMA     DSECT ,\nOCMAFLAG DS    B                   FLAG BYTE\nOCMAFMAH EQU   B'10000000'         A COMPLETE MESSAGE HAEDER EXISTS\nOCMAMAHL DS    HL2                 L'MESSAGE AREA HEADER\nOCMARQT  DS    X                   REQUEST TYPE\nOCMARO   EQU   1                   OPEN REQUEST\nOCMARC   EQU   2                   CLOSE REQUEST\nOCMARTC  EQU   3                   TCLOSE REQUEST\nOCMADDN  DS    CL8                 DDNAME BEING OPENED/CLOSED\nOCMAECNT DS    H                   ERROR COUNT\nOCMAMCNT DS    H                   ERROR MESSAGE COUNT\nOCMAMADR DS    A                   --> 1ST ERROR MESSAGE\nOCMAHZ   DS    0X                  EO-OCMA HEADER\nOCMAHLEN EQU   OCMAHZ-OCMA         L'OCMA HEADER\n         TITLE 'GSB MAP -- GSAM REQUEST BLOCK'\n         GSB   ,\n         SPACE 3\n*************************************************************\n*        MODIFIED GSB FIELDS FOR FAKEGSAM SUPPORT           *\n*************************************************************\n         SPACE 1\nFGSBOFLG EQU   GSBFLG1             OPEN FLAGS\nFGSBOPEN EQU   B'01000000'         THE \"GSAM\" FILE HAS BEEN OPENED\nFGSBFGG  EQU   GSBINDX,4           AFTER OPEN: --> FFG\n         TITLE 'FGG MAP -- GLOBAL DATA AREA'\nFGG      DSECT ,\n         SPACE 3\n*************************************************************\n*        THE FOLLOWING AREA IS INITIALIZED AS A UNIT, SO IT *\n*        MUST CONFORM TO THE SHAPE OF THE STATIC DATA AREA  *\n*        NAMED \"FGREL\".                                     *\n*************************************************************\n         SPACE 1\nFGGREL   DS    0F                  START OF AREA\nFGGID    DC    CL8'FAKEGSAM'       AREA ID\n         SPACE 1\nFGGACB   ACB   AM=VSAM,                                                *\n               BUFND=4,                                                *\n               BUFNI=10,                                               *\n               DDNAME=FILLEDIN,    FROM GSBFILE                        *\n               MACRF=(DIR,SEQ,IN,OUT),                                 *\n               MAREA=*-*,                                              *\n               MLEN=L'FGLOCMA,                                         *\n               PASSWD=*-*          POINTS TO GSBPASSW\n         SPACE 1\nFGGRPL   RPL   ACB=FGGACB,                                             *\n               AM=VSAM,                                                *\n               AREA=*-*,           FROM GSBBUFA                        *\n               AREALEN=*-*,        FROM GSBBUFL                        *\n               ARG=*-*,            POINTS TO GSBBUFX                   *\n               ECB=*-*,            FROM GSBECB                         *\n               MSGAREA=*-*,        FROM GSBMSGA                        *\n               MSGLEN=L'GSBMSGX,                                       *\n               OPTCD=(KEY,SYN,KGE,NWAITX,MVE),                         *\n               RECLEN=*-*          FROM GSBRECL\n         SPACE 1\nFGGOPEN  OPEN  FGGACB,MF=L\n         SPACE 1\nFGGRELL  EQU   *-FGGREL            LENGTH OF AREA\n         SPACE 3\n*************************************************************\n*        SHOWCB PLIST AND SINKS                             *\n*************************************************************\n         SPACE 1\nSHOWPLST SHOWCB ACB=*-*,                                               *\n               AREA=SHOWAREA,      GSB FEEDBACK FIELDS                 *\n               LENGTH=SHOWALEN,    TOTAL FIELDS LENGTH                 *\n               FIELDS=(KEYLEN,     KEY KENGTH                          *\n               RKP,                RELATIVE KEY POSITION               *\n               LRECL,              MAX RECORD LENGTH                   *\n               CINV,               CONTROL INTERVAL LENGTH             *\n               ENDRBA),            HIGH RBA                            *\n               MF=L                LIST FORM\n         SPACE 1\nSHOWAREA DS    0F\nFGGKEYLN DS    F                   KEYLEN\nFGGKEYOF DS    F                   RKP\nFGGMAXRL DS    F                   LRECL\nFGGCISIZ DS    F                   CINV\nSHGSBNFO EQU   FGGKEYLN,*-FGGKEYLN FIELDS COPIED TO THE GSB\nFGGHIRBA DS    F                   ENDRBA\nSHOWALEN EQU   *-SHOWAREA\n         SPACE 3\n*************************************************************\n*        MISC DATA                                          *\n*************************************************************\n         SPACE 1\nFGGMKYLN DS    H                   KEY LENGTH-1\n         SPACE 1\nFGGPVKEY DS    CL256               PREVIOUS KEY (FOR CONTROLLING\n*                                  SEQUENTIAL GETS)\n         #TEST SIZE=(L'FGGPVKEY,EQ,L'FGLKEY)\n         SPACE 1\nFGGFLAG  DS    B                   FLAG BYTE\nFGGFPVKY EQU   B'10000000'         THE CONTENTS OF FGGPVKEY ARE VALID\n         SPACE 3\n*************************************************************\n*        END OF GLOBAL DATA AREA                            *\n*************************************************************\n         SPACE 1\nFGGEND   DS    0D\nFGGLEN   EQU   FGGEND-FGG\n         TITLE 'FGL MAP -- LOCAL DATA AREA'\n*************************************************************\n*        STANDARD REGISTER SAVE AREA                        *\n*************************************************************\n         SPACE 1\nFGL      #DSA  ,\n         SPACE 3\nSAVEVSIO DS    4A                  FGGET\nSAVESRCH DS    16A                 SRCH\n         SPACE 3\nFGLCALTP DS    AL1                 GSAM CALL TYPE\nFGLCTREA EQU   0                   READ\nFGLCTWRI EQU   1                   WRITE\nFGLCTREW EQU   2                   REWRITE\nFGLCTDEL EQU   3                   DELETE\nFGLCTREL EQU   4                   RELEASE\nFGLCTMON EQU   5                   MONITOR\nFGLCTMAI EQU   6                   MAINTAIN\nFGLCTFIN EQU   7                   FINISH\n         SPACE 3\nFGLKEYAD DS    A                   --> KEY IN RECORD BUFFER\nFGLKEY   DS    CL256               SEARCH KEY BUFFER\n         SPACE 3\nFGLOCMA  DS    CL512               VSAM OPEN/CLOSE/TCLOSE MSG AREA\n         SPACE 3\n*************************************************************\n*        DATA FOR CALLING IDCAMS WITH A VERIFY REQUEST.     *\n*************************************************************\n         SPACE 1\nAMSPLIST DS    4A                  PLIST\nAMSIOLST DS    7A                  I/O LIST\n         SPACE 1\nVERIFY   DC    C' VERIFY FILE('\nVERDDN   DS    CL(L'ACBDDNM),C') '\n         SPACE 3\n*************************************************************\n*        END OF LOCAL DATA AREA                             *\n*************************************************************\n         SPACE 1\nFGLEND   DS    0D\nFGLLEN   EQU   FGLEND-FGL\n         TITLE 'ERROR CODES CONTROL ENTRY MAP'\nERC      DSECT ,\nERCRETUR DS    FL1                 GSAM RETURN CODE\nERCREASO DS    FL1                 GSAM REASON CODE\n         SPACE 3\n*************************************************************\n*        NOTE, THE FOLLOWING FIELDS DO NOT APPEAR IN ALL    *\n*        ENTRIES. THEY MUST NOT BE REFERENCED BY THE CODE   *\n*        AT 'FGRETURN'.                                     *\n*************************************************************\n         SPACE 1\nERCVRETU DS    FL1                 MAPPED FROM VSAM RETURN CODE\nERCVREAL DS    FL1                  AND VSAM REASON CODE RANGE (LOW)\nERCVREAH DS    FL1                  AND VSAM REASON CODE RANGE (HIGH)\nERCELEN  EQU   *-ERC               ENTRY LENGTH\n         TITLE 'ENTRY PROCESSING'\n*************************************************************\n*        STANDARD REENTRANT ENTRY LINKAGE                   *\n*************************************************************\n         SPACE 1\nFAKEGSAM #ENTER BASES=(BASE1REG),SAVTYPE=(RENT,FGLLEN)\n         SPACE 1\n         LR    FGLREG,R13          LOAD FGL POINTER\n         USING FGL,FGLREG          DECLARE ITS BASE\n         STC   R0,FGLCALTP         SAVE THE CALL TYPE\n         SPACE 1\n         LR    GSBREG,R1           COPY GSB POINTER\n         USING GSB,GSBREG          DECLARE ITS BASE\n         XR    FGGREG,FGGREG       SIGNAL NO FGG POINTER (YET)\n         SPACE 3\n*************************************************************\n*        IF THIS IS THE FIRST CALL, THEN OBTAIN A GLOBAL    *\n*        DATA AREA, INITIALIZE IT, AND OPEN AN ACB FOR THE  *\n*        VSAM FILE TO BE PROCESSED.                         *\n*************************************************************\n         SPACE 1\nFGRETRY  TM    FGSBOFLG,FGSBOPEN   IS THE ACB ALREADY OPEN?\n         BNZ   FGOPENED            YES, NOT THE FIRST CALL\n         SPACE 1\n         LA    R0,FGGLEN           NO, GET L'FGG\n         GETMAIN R,LV=(0)          ALLOCATE AN FGG\n         LR    FGGREG,R1           COPY ITS POINTER\n         USING FGG,FGGREG          DECLARE ITS BASE\n         SPACE 1\n         LR    R0,FGGREG           CLEAR -\n         LA    R1,FGGLEN            THE -\n         MVCL  R0,R14                FGG (R15=0 FROM GETMAIN)\n         ST    FGGREG,FGSBFGG      SAVE THE FGG POINTER IN THE GSB\n         SPACE 3\n*************************************************************\n*        INITIALIZE AN ACB FOR THE FILE TO BE PROCESSED.    *\n*************************************************************\n         SPACE 1\n         MVC   FGGREL(FGGRELL),FGREL INITIALIZE ACB, ETC.\n         #TEST SIZE=(FGGRELL,EQ,FGRELL)\n         LA    R15,FGGACB          --> ACB\n         USING IFGACB,R15          DCL ACB BASE\n         ST    R15,RPLDACB-IFGRPL+FGGRPL LINK TO THE RPL\n         MVC   ACBDDNM,GSBFILE     GET THE DDNAME\n         TM    GSBPASSW,255-C' '   IS A PASSWORD PROVIDED?\n         BZ    FGOPNPWD            NO, PROCEED\n         LA    R0,GSBPASSW         YES, --> IT\n         ST    R0,ACBPASSW         STORE INTO THE ACB\nFGOPNPWD DS    0H\n         SPACE 3\n*************************************************************\n*        IF THIS IS ACTUALLY A FINISH REQUEST, THEN DON'T   *\n*        BOTHER TO ACTUALLY OPEN THEN VSAM FILE.            *\n*************************************************************\n         SPACE 1\n         CLI   FGLCALTP,FGLCTFIN   \"FINISH\" REQUEST?\n         BE    FGOPENED            YES, SKIP OPEN PROCESSING\n         SPACE 3\n*************************************************************\n*        SCAN THE TIOT TO SEE IF THE DESIRED FILE IS        *\n*        DEFINED.                                           *\n*************************************************************\n         SPACE 1\n         L     R1,PSATOLD-PSA      --> MY TCB\n         L     R1,TCBTIO-TCB(,R1)  --> MY TIOT\n         LA    R0,TIOENTRY-TIOT    OFFSET TO 1ST DD ENTRY\n         USING TIOENTRY,R1         DCL TIOT DD-ENTRY BASE\n         SPACE 1\n         BASR  R14,0               LOAD LOOP HEAD\n         AR    R1,R0               --> NEXT DD ENTRY\n         ICM   R0,1,TIOELNGH       GET ITS LENGTH; EO-TIOT?\n         BZ    FGERRUDF            YES, OPEN WILL FAIL; ERROR RETURN\n         CLC   ACBDDNM,TIOEDDNM    NO, DESIRED DDNAME FOUND?\n         BNER  R14                 NOT YET; KEEP SCANNING\n         DROP  R1                  YES, RELEASE TIOENTRY BASE\n         SPACE 3\n*************************************************************\n*        THE DESIRED FILE IS DEFINED. ATTEMPT TO OPEN IT.   *\n*************************************************************\n         SPACE 1\n         LA    R0,FGLOCMA          --> OCMA\n         ST    R0,ACBMSGAR         LINK TO THE ACB\n         OPEN  ((R15)),MF=(E,FGGOPEN) OPEN THE ACB\n         DROP  R15                 RELEASE ACB BASE\n         SPACE 1\n         TM    ACBOFLGS-IFGACB+FGGACB,ACBOPEN OK?\n         BNZ   FGOPENOK            YES, DONE HERE\n         SPACE 3\n*************************************************************\n*        THE OPEN HAS FAILED. ASSUMING THAT THE FAILURE CAN *\n*        BE CORRECTED, LINK TO IDCAMS WITH A \"VERIFY\"       *\n*        REQUEST, AND THEN REATTEMPT THE OPEN REQUEST.      *\n*************************************************************\n         SPACE 1\n         LA    R14,=H'0'           --> NULL PARMS\n         XR    R15,R15             NO DDNAMES SUBSTITUTE LIST\n         XR    R0,R0               NO PAGE NUMBER PARAMETER\n         LA    R1,AMSIOLST         --> I/O ROUTINES CONTROL LIST\n         STM   R14,R1,AMSPLIST     BUILD IDCAMS' PLIST\n         OI    AMSPLIST+12,B'10000000' SET EO-PLIST SIGNAL\n         SPACE 1\n         LA    R14,2               GET I/O LIST ENTRY COUNT\n         LA    R15,=CL10'DDSYSPRINT' 1ST ENTRY IS FOR SYSPRINT\n         L     R0,=A(SYSPRINT)     --> SYSPRINT HANDLER\n         XR    R1,R1               NO USER DATA\n         LA    R2,=CL10'DDSYSIN'   2ND ENTRY IS FOR SYSIN\n         L     R3,=A(SYSIN)        --> SYSIN HANDLER\n         LA    R4,FGL              LOAD USER DATA (--> FGL)\n         STM   R14,R4,AMSIOLST     BUILD I/O LIST FOR IDCAMS\n         SPACE 1\n         MVC   VERDDN,ACBDDNM-IFGACB+FGGACB MAKE DDNAME AVAIL TO\n*                                  THE 'SYSIN' HANDLER ROUTINE THAT\n*                                  IDCAMS WILL BE REQUIRED TO USE\n         LA    R1,AMSPLIST         --> PLIST\n         LINK  EP=IDCAMS           CALL IDCAMS\n         SPACE 1\n         OPEN  MF=(E,FGGOPEN)      REATTEMPT THE OPEN REQUEST\n         TM    ACBOFLGS-IFGACB+FGGACB,ACBOPEN OPEN OK NOW?\n         BNZ   FGOPENOK            YES, DONE HERE\n         SPACE 3\n*************************************************************\n*        THE OPEN FAILURE PERSISTS. SETUP AN ERROR MESSAGE  *\n*        FOR THE CALLER, AND THEN RETURN WITH AN ERROR      *\n*        INDICATION.                                        *\n*************************************************************\n         SPACE 1\n         LA    R1,GSBMSGX          --> POSSIBLE ERROR MSG RETURN BUFFER\n         TM    GSBBUFA,B'10000000' CONTIGUOUS BUFFERS PRESENT?\n         BNZ   FGOFGMSG            YES, PROCEED\n         ICM   R1,15,GSBMSGA       NO, --> NON-CONTIG MSG BUF; EXIST?\n         BZ    FGOFMSGZ            NO, FORGET RETURNING A MESSAGE\nFGOFGMSG DS    0H                  YES, PROCEED\n         SPACE 1\n         MVI   0(R1),C' '          INSURE AT LEAST ONE BLANK IN MSG\n         LA    R0,1(,R1)           COPY AND ADVANCE MSG SCANNER\n         LA    R1,L'GSBMSGX-1      GET L'MSG SINK\n         SPACE 1\n         L     R15,=AL1(C' ',0,0,0) ASSUME NO SOURCE MSG\n         ICM   R2,15,ACBMSGAR-IFGACB+FGGACB --> OCMA; EXIST?\n         BZ    FGOFCMSG            NO, CLEAR GSBMSGA W/O A SOURCE MSG\n         USING OCMA,R2             YES, DCL OCMA BASE\n         TM    OCMAFLAG,OCMAFMAH   IS THE OCMA LONG ENOUGH TO HOLD AN\n*                                  OMCA HEADER?\n         BZ    FGOFCMSG            NO, NO SOURCE MSG\n         ICM   R14,3,OCMAMCNT      YES, WAS AT LEAST ONE MSG BUFFERED?\n         BZ    FGOFCMSG            NO, NO SOURCE MSG\n         ICM   R14,15,OCMAMADR     YES, --> 1ST MSG; EXIST?\n         BZ    FGOFCMSG            NO, NO SOURCE MSG\n         ICM   R15,3,0(R14)        YES, GET ITS LENGTH+4\n         LA    R14,4(,R14)         --> MSG DATA\n         SH    R15,=H'4'           GET L'MSG\n         CLM   R15,3,=X'7FFF'      WAS THE LENGTH VALID?\n         BNH   FGOFCMSG            YES, PROCEED\n         L     R15,=AL1(C' ',0,0,0) NO, JUST PREPAER TO CLEAR SINK\n         DROP  R2                  RELEASE OCMA BASE\nFGOFCMSG MVCL  R0,R14              COPY MSG OR JUST CLAER SINK\nFGOFMSGZ B     FGERROPN            GO MAKE AN ERROR RETURN\n         SPACE 3\n*************************************************************\n*        THE OPEN HAS SUCCEEDED.                            *\n*************************************************************\n         SPACE 1\nFGOPENOK OI    FGSBOFLG,FGSBOPEN   REMEMBER THE GSB IS NOW OPEN\n         XC    ACBMSGAR-IFGACB+FGGACB,ACBMSGAR-IFGACB+FGGACB CLEAR PTR\n         SPACE 3\n*************************************************************\n*        EXTRACT SOME INFORMATION ABOUT THE VSAM FILE.      *\n*************************************************************\n         SPACE 1\n         SHOWCB ACB=(S,FGGACB),                                        *\n               AREA=(S,SHOWAREA),  GSB FEEDBACK FIELDS                 *\n               LENGTH=SHOWALEN,    LENGTH THEREOF                      *\n               FIELDS=(KEYLEN,     KEY KENGTH                          *\n               RKP,                RELATIVE KEY POSITION               *\n               LRECL,              MAX RECORD LENGTH                   *\n               CINV,               CONTROL INTERVAL LENGTH             *\n               ENDRBA),            HIGH RBA                            *\n               MF=(G,SHOWPLST)\n         SPACE 1\n         L     R0,FGGKEYLN         GET KEY LENGTH\n         CL    R0,=A(L'FGLKEY)     WITHIN LIMITS?\n         #DIE  H                   NO, DESIGN ERROR\n         BCTR  R0,0                YES, ADJUST FOR 'EX'\n         STH   R0,FGGMKYLN         STORE\n         SPACE 3\n*************************************************************\n*        USE THE EXTRACTED INFORMATION AND OTHER            *\n*        INFORMATION TO FILL IN THE GSB FEEDBACK FIELDS     *\n*************************************************************\n         SPACE 1\n         MVC   GSBFILKL(L'GSBFILKL+L'GSBFILKO+L'GSBFILRL+L'GSBFILCL),SH*\n               GSBNFO              COPY SOME OF IT TO THE GSB\n         #TEST SIZE=(L'GSBFILKL+L'GSBFILKO+L'GSBFILRL+L'GSBFILCL,EQ,L'S*\n               HGSBNFO)\n         SPACE 1\n         MVI   GSBFILAC,GSBACC2    SIGNAL \"UPDATE ACCESS PERMITTED\"\n         MVI   GSBFILFG,GSBRDWT    SIGNAL \"FULL ACCESS PERMITTED\"\n         SPACE 3\n*************************************************************\n*        RESUME COMMON CODE. THE FILE IS OPEN. VALIDATE THE *\n*        FGG.                                               *\n*************************************************************\n         SPACE 1\nFGOPENED DS    0H\n         DROP  FGGREG              RELEASE FGG BASE\n         L     FGGREG,FGSBFGG      --> FGG\n         USING FGG,FGGREG          DCL FGG BASE\n         CLC   FGGID,FGID          IS THE FGG POINTER VALID?\n         BNE   FGERRFGG            NO, ERROR EXIT\n         SPACE 3\n*************************************************************\n*        LOCATE AND EXTRACT A COPY OF THE CURRENT           *\n*        PROCESSING KEY.                                    *\n*************************************************************\n         SPACE 1\n         L     R1,GSBBUFA          --> RECORD BUFFER (MAYBE)\n         CH    R1,=H'-1'           BUFFER IN A SPECIAL PLACE?\n         BNE   FGBUFA              NO, PROCEED\n         LA    R1,GSBBUFX          YES, --> IT\nFGBUFA   A     R1,FGGKEYOF         --> RECORD'S KEY AREA\n         ST    R1,FGLKEYAD         SAVE FOR PROCESSING\n         SPACE 1\n         LH    R15,FGGMKYLN        GET KEY LENGTH-1\n         MVC   FGLKEY(*-*),0(R1)   (EXECUTED)\n         EX    R15,*-6             COPY KEY TO LOCAL BUFFER\n         #TEST SIZE=(L'FGLKEY,LE,256)\n         SPACE 3\n*************************************************************\n*        BRANCH ACCORDING TO THE GSAM CALL TYPE.            *\n*************************************************************\n         SPACE 1\n         XR    R1,R1               CLEAR FOR INSERT\n         IC    R1,FGLCALTP         GET THE CALL TYPE CODE\n         SLL   R1,2                CNVRT TO FWORD OFFSET\n         B     *+4(R1)             ENTER BRANCH VECTOR\n         SPACE 1\n         B     FGREAD              0 READ\n         B     FGWRITE             1 WRITE\n         B     FGREWRIT            2 REWRITE\n         B     FGDELETE            3 DELETE\n         B     FGRELEAS            4 RELEASE\n         #DIE  C,15,'GSAM MONITOR NOT SUPPORTED'\n         #DIE  C,15,'GSAM MAINTAIN NOT SUPPORTED'\n         B     FGFINISH            7 FINISH\n         TITLE 'FGREAD -- GSAM READ REQUESTS'\n*************************************************************\n*        IF THIS IS A SEQUENTIAL GET, THEN INSURE THAT      *\n*        VSAM'S NOTION OF THE CURRENT POSITION MATCHES THE  *\n*        USER'S NOTION. IF NOT, THEN USE THE USER'S NOTION. *\n*************************************************************\n         SPACE 1\nFGREAD   TM    GSBFLGS,GSBDIR      DIRECT REQUEST?\n         BNZ   FGRSEQOK            YES, IT'S OK; SKIP THIS JUNK\n         TM    FGGFLAG,FGGFPVKY    NO, SEQUENTIAL; IS MY RECORD OF THE\n*                                  PREVIOUSLY READ KEY VALID?\n         BZ    FGRPOSIT            PROBABLY NOT, GO ESTABLISH POSITION\n*                                  USING THE USER'S KEY\n         CLC   FGGPVKEY,FGLKEY     YES, IS THE USER PLAYING MUSICAL\n*                                  POSITIONING ON ME?\n         BNE   FGRPOSIT            YES, GO ESTABLISH POSITION USING THE\n*                                  USER'S KEY\nFGRSEQOK DS    0H                  NO, PROCEED\n         SPACE 3\n*************************************************************\n*        ATTEMPT \"JOE GET\" AND SEE WHAT HAPPENS             *\n*************************************************************\n         SPACE 1\n         XR    R15,R15             NO SPECIAL OPTCD OVERRIDES\n         BAS   R14,VSAMGET         ATTEMPT THE GET\n         CLM   R15,2,=AL1(0)       RETURN=0?\n         BNE   FGRCKEOD            NO, GO CHECK FOR EOD\n         SPACE 1\n         TM    GSBFLGS,GSBBACK+GSBDIR YES, BACKWARDS/DIRECT?\n         BNO   FGROKCHK            NO, GO SAVE MY NEW POSITION, IF ANY\n         SPACE 3\n*************************************************************\n*        A \"NORMAL RETURN\" HAS BEEN RECEIVED FOR A          *\n*        BACKWARDS/DIRECT READ REQUEST. SUCH A GSAM REQUEST *\n*        IMPLIES A \"KLE\" SEARCH. IF I GOT A \"KEQ\" RESULT,   *\n*        THEN FINE. IF NOT, THEN I GOT A \"KGT\" RESULT WHICH *\n*        I NOW HAVE TO CONVERT TO A \"KLT\" RESULT.           *\n*************************************************************\n         SPACE 1\n         LH    R15,FGGMKYLN        GET KEY LENGTH-1\n         L     R1,FGLKEYAD         --> KEY JUST READ\n         CLC   FGLKEY(*-*),0(R1)   (EXECUTED)\n         EX    R15,*-6             \"KEQ\" RESULT?\n         BE    FGROKCHK            YES, GO SAVE MY NEW POSITION, IF ANY\n*        FALL THROUGH              NO, RESULT WAS \"KGT\". I MUST NOW\n*                                  CONVERT THAT TO A \"KLT\" RESULT.\n         SPACE 3\n*************************************************************\n*        FORCED SEQUENTIAL READ (FORWARDS OR BACKWARDS)     *\n*************************************************************\n         SPACE 1\nFGRNPSEQ L     R15,=AL1(RPLDIR,RPLSEQ,0,0) FORCE \"SEQ\"\n         BAS   R14,VSAMGET         GET NEXT/PRIOR SEQUENTIAL RECORD\n         B     FGROKCHK            GO SAVE MY NEW POSITION, IF ANY\n         SPACE 3\n*************************************************************\n*        \"EOD\" HANDLING                                     *\n*************************************************************\n         SPACE 1\nFGRCKEOD CLM   R15,3,=AL1(8,4)     VSAM EOD ERROR?\n         BNE   FGRCKPOS            NO, SKIP\n         TM    GSBFLGS,GSBBACK+GSBDIR YES, BACKWARDS/DIRECT REQUEST?\n         BNO   FGROKCHK            NO, GO SAVE MY NEW POSITION, IF ANY\n         SPACE 3\n*************************************************************\n*        VSAM EOD HAS OCCURED DURING A GSAM                 *\n*        BACKWARDS/DIRECT REQUEST. THIS MEANS THAT THE USER *\n*        WANTS THE LAST RECORD IN THE FILE.                 *\n*************************************************************\n         SPACE 1\nFGRLASTR L     R15,=AL1(RPLSEQ,RPLDIR,0,RPLBWD+RPLLRD) FORCED OPTCDS\n         BAS   R14,VSAMGET         VSAM GET\n         B     FGROKCHK            GO SAVE MY NEW POSITION, IF ANY\n         SPACE 3\n*************************************************************\n*        \"POSITIONING ERROR\" HANDLING                       *\n*************************************************************\n         SPACE 1\nFGRCKPOS CLM   R15,3,=AL1(8,88)    VSAM POSITIONING ERROR?\n         BNE   FGROKCHK            NO, GO SAVE MY NEW POSITION, IF ANY\n         SPACE 1\nFGRPOSIT L     R15,=AL1(RPLSEQ,RPLDIR,0,0) YES, FORCE DIRECT GET\n         BAS   R14,VSAMGET         VSAM GET\n         CLM   R15,2,=AL1(0)       \"AOK\"?\n         BE    FGRCKPO2            PROBABLY, GO CHECK FOR FURTHER\n         CLM   R15,3,=AL1(8,4)     NO, \"EOD\"?\n         BNE   FGROKCHK            NO, GO SAVE MY NEW POSITION, IF ANY\n         TM    GSBFLGS,GSBBACK     YES, GSAM BACKWARDS REQUEST?\n         BNZ   FGRLASTR            YES, GO GET FILE'S LAST RECORD\n         B     FGROKCHK            NO, GO SAVE MY NEW POSITION, IF ANY\n         SPACE 3\n*************************************************************\n*        A DIRECT GET (AFTER A POSITIONING FAILURE ON A     *\n*        SEQUENTIAL GET) HAS SUCCEEDED. IF THIS IS A GSAM   *\n*        FORWARDS REQUEST, AND IF THE VSAM-GET RESULT WAS   *\n*        \"KGT\", THEN FINE. OTHERWISE, A VSAM SEQUENTIAL GET *\n*        (FORWARDS OR BACKWARDS) IS NOW NEEDED TO GET THE   *\n*        CORRECT RECORD.                                    *\n*************************************************************\n         SPACE 1\nFGRCKPO2 LH    R15,FGGMKYLN        GET KEY LENGTH-1\n         L     R1,FGLKEYAD         --> KEY JUST READ\n         CLC   FGLKEY(*-*),0(R1)   (EXECUTED)\n         EX    R15,*-6             \"KEQ\" RESULT?\n         BE    FGRNPSEQ            YES, NOW PERFORAM A SEQ-GET\n         TM    GSBFLGS,GSBBACK     NO, RESULT WAS \"KGT\"; GSAM-BACK?\n         BNZ   FGRNPSEQ            YES, CONVERT TO \"KLT\" RESULT\n         SPACE 3\n*************************************************************\n*        THE GET REQUEST HAS EITHER COMPLETED OR FAILED. IF *\n*        IT HAS COMPLETED SUCCESSFULLY, THEN SAVE THE       *\n*        CURRENT POSITIONING INFORMATION.                   *\n*************************************************************\n         SPACE 1\nFGROKCHK NI    FGGFLAG,255-FGGFPVKY ASSUME FAILURE\n         CLI   RPLRTNCD-IFGRPL+FGGRPL,0 RIGHT?\n         BNE   FGRCODES            YES, EXIT TO THE CALLER\n         MVC   FGGPVKEY,FGLKEY     YES, SAVE THIS NEW KEY\n         OI    FGGFLAG,FGGFPVKY    REMEMVER VALID POSITIONING INFO\n         B     FGRCODES            EXIT TO THE CALLER\n         TITLE 'FGWRITE -- GSAM WRITE REQUESTS'\n*************************************************************\n*        INSERT A NEW RECORD INTO THE FILE                  *\n*************************************************************\n         SPACE 1\nFGWRITE  TM    RPLOPT2-IFGRPL+FGGRPL,RPLUPD DO I OWN A RECORD?\n         BZ    FGWNOWN             NO, PROCEED\n         XR    R15,R15             YES, SIGNAL \"NO OPTCDS OVERRIDES\"\n         BAS   R14,VSAMENDR        RELEASE THE OWNED RECORD\nFGWNOWN  DS    0H\n         SPACE 1\n         L     R15,=AL1(0,0,RPLLRD+RPLUPD,RPLNSP)\n         BAS   R14,VSAMPUT         WRITE THE NEW RECORD\n         B     FGRCODES            EXIT TO CALLER\n         TITLE 'FGREWRIT -- GSAM REWRITE REQUESTS'\n*************************************************************\n*        IF THE CURRENT RECORD IS OWNED FOR UPDATE, THEN    *\n*        REWRITE IT.                                        *\n*************************************************************\n         SPACE 1\nFGREWRIT TM    RPLOPT2-IFGRPL+FGGRPL,RPLUPD DO I OWN THE CURRENT RCD?\n         BZ    FGERRPOS            NO, ERROR EXIT\n         SPACE 1\n         XR    R15,R15             YES, SET \"DO NOT MUCK -\n         BCTR  R15,0                WITH THE OPTCDS\" SIGNAL\n         BAS   R14,VSAMPUT         REWRITE THE CURRENT RECORD\n         B     FGRCODES            EXIT TO CALLER\n         TITLE 'FGDELETE -- GSAM DELETE REQUESTS'\n*************************************************************\n*        IF THE CURRENT RECORD IS OWNED, THEN DELETE IT.    *\n*************************************************************\n         SPACE 1\nFGDELETE TM    RPLOPT2-IFGRPL+FGGRPL,RPLUPD DO I OWN THE CRNT RCD?\n         BZ    FGERRPOS            NO, ERROR EXIT\n         SPACE 1\n         XR    R15,R15             YES, SET \"DON'T MUCK WITH -\n         BCTR  R15,0                THE OPTCDS\" SIGNAL\n         BAS   R14,VSAMERAS        DELETE THE CURRENT RECORD\n         B     FGRCODES            EXIT TO CALLER\n         TITLE 'FGRELEAS -- GSAM RELEASE REQUESTS'\n*************************************************************\n*        IF I OWN THE CURRENT RECORD, THEN RELEASE IT       *\n*************************************************************\n         SPACE 1\nFGRELEAS TM    RPLOPT2-IFGRPL+FGGRPL,RPLUPD DO I OWN THE CURRENT RCD?\n         BZ    FGERRPOS            NO, ERROR EXIT\n         XR    R15,R15             YES, SIGNAL \"NO OPTCDS OVERRIDES\"\n         BAS   R14,VSAMENDR        RELEASE THE CURRENT RECORD\n         B     FGRCODES            EXIT TO CALLER\n         TITLE 'FGFINISH -- GSAM FINISH REQUESTS'\n*************************************************************\n*        CLOSE THE VSAM FILE AND RETURN TO THE CALLER.      *\n*************************************************************\n         SPACE 1\nFGFINISH NI    FGSBOFLG,255-FGSBOPEN CLEAR GSB'S \"OPEN\" SIGNAL\n         TM    ACBOFLGS-IFGACB+FGGACB,ACBOPEN IS THE FILE OPEN?\n         BZ    FGFINRET            NO, DONE HERE\n         CLOSE MF=(E,FGGOPEN)      YES, CLOSE THE VSAM FILE\n         B     FGFINRET            EXIT TO CALLER\n         TITLE 'ERROR AND NORMAL RETURNS TO CALLER'\n*************************************************************\n*        MAP THE VSAM RETURN/REASON CODES INTO GSAM CODES.  *\n*************************************************************\n         SPACE 1\nFGRCODES LA    R15,ERCMAP          --> CODES MAP\n         LA    R0,ERCELEN          GET L'MAP ENTRY\n         LA    R1,ERCMAPZ          --> EO-MAP\n         BAS   R14,SRCH            SEARCH THE MAP; VSAM CODES FOUND?\n         LR    R2,R1               (COPY THE POSSIBLE ERC PTR)\n         BE    FGRETURN            YES, TO RETURN TO FAKEGSAM'S CALLER\n         #DIE  'UNANTICIPATED VSAM RETURN/REASON CODE' NO, LOGIC ERROR\n         SPACE 3\n*************************************************************\n*        DISTINGUISH VARIOUS RETURNS                        *\n*************************************************************\n         SPACE 1\nFGFINRET BAS   R2,FGRETURN         NORMAL FINISH PROCESSING RETURN\n         DC    AL1(0,0)\n         SPACE 1\nFGERRUDF BAS   R2,FGRETURN         UNDEFINED FILE\n         DC    AL1(GSAMEFIL,0)\n         SPACE 1\nFGERROPN BAS   R2,FGRETURN         OPEN FAILURE\n         DC    AL1(GSAMEFIL,-1)\n         SPACE 1\nFGERRPOS BAS   R2,FGRETURN         UPDATE SEQUENCE ERROR\n         DC    AL1(GSAMEPOS,8)\n         SPACE 1\nFGERRFGG BAS   R2,FGRETURN         BAD FGG ERROR\n         DC    AL1(GSAMEPRM,16)\n         SPACE 3\n*************************************************************\n*        DEVELOP THE VARIOUS GSAM RETURN AND REASON CODES.  *\n*************************************************************\n         SPACE 1\n         USING ERC,R2              DCL ERC BASE\nFGRETURN LH    R15,=H'-1'          ASSUME VSAM FUNCTION CODE N/A\n         CLI   ERCRETUR,GSAMEIO    VSAM PHYSICAL I/O ERROR?\n         BNE   FGFUNCTI            NO, ASSUMPTION CORRECT\n         XR    R15,R15             YES, CLEAR FOR INSERT\n         IC    R15,RPLCMPON-IFGRPL+FGGRPL GET VSAM FUNCTION CODE\nFGFUNCTI ST    R15,GSBVSFN         STORE INTO GSB\n         SPACE 1\n         XR    R15,R15             CLEAR FOR INSERT\n         IC    R15,ERCREASO        GET GSAM REASON CODE\n         CLI   ERCREASO,X'100'-1   USE VSAM REASON CODE?\n         BNE   FGREASON            NO, PROCEED\n         IC    R15,ACBERFLG-IFGACB+FGGACB YES, ASSUME OPEN/CLOSE ERROR\n         CLI   ERCRETUR,GSAMEFIL   RIGHT?\n         BE    FGREASON            YES, PROCEED\n         IC    R15,RPLERRCD-IFGRPL+FGGRPL NO, GET VSAM REASON CODE\nFGREASON ST    R15,GSBVSAM         STORE INTO GSB\n         SPACE 3\n*************************************************************\n*        IF THE VSAM FILE IS NOT OPEN, THEN RELEASE THE FGG *\n*        AND RESTORE THE GSB.                               *\n*************************************************************\n         SPACE 1\n         TM    ACBOFLGS-IFGACB+FGGACB,ACBOPEN IS THE FILE OPEN?\n         BNZ   KEEPFGG             YES, SKIP\n         NI    FGSBOFLG,255-FGSBOPEN NO, INSURE GSB \"OPEN-FILE\" SIGNAL\n*                                  IS OFF\n         LA    R0,FGGLEN           GET L'FGG\n         FREEMAIN R,LV=(0),A=(FGGREG) RELEASE THE FGG\n         PUSH  USING               SAVE STATUS\n         DROP  FGGREG              RELEASE THE FGG BASE\n         XR    FGGREG,FGGREG       CLEAR THE FGG PTR\n         ST    FGGREG,FGSBFGG      CLEAR THE GSB LINK TO THE FGG\nKEEPFGG  DS    0H\n         SPACE 3\n         MVI   GSBECB,X'7F'        INSURE THAT THE GSB ECB IS POSTED\n         SPACE 3\n*************************************************************\n*        EXIT TO MY CALLER                                  *\n*************************************************************\n         SPACE 1\n         IC    R15,ERCRETUR        GET GSAM RETURN CODE\n         #EXIT ((R14,R12)),RC=(R15) RETURN TO CALLER\n         POP   USING               RESTORE STATUS (FGG BASE)\n         DROP  R2                  RELEASE ERC BASE\n         TITLE 'FGVSAMIO -- VSAM I/O ROUTINE'\n*************************************************************\n*        DISTINGUISH VARIOUS CALL TYPES                     *\n*************************************************************\n         SPACE 1\nVSAMGET  ICM   R14,8,=AL1(VSIOVGET-VSIOVECT) LOAD \"GET\" SIGNAL\n         B     FGVSAMIO            PROCEED\n         SPACE 1\nVSAMPUT  ICM   R14,8,=AL1(VSIOVPUT-VSIOVECT) LOAD \"PUT\" SIGNAL\n         B     FGVSAMIO            PROCEED\n         SPACE 1\nVSAMERAS ICM   R14,8,=AL1(VSIOVERA-VSIOVECT) LOAD \"ERASE\" SIGNAL\n         B     FGVSAMIO            PROCEED\n         SPACE 1\nVSAMENDR ICM   R14,8,=AL1(VSIOVEND-VSIOVECT) LOAD \"ENDREQ\" SIGNAL\n         B     FGVSAMIO            PROCEED\n         SPACE 3\n*************************************************************\n*        COMMON ENTRY POINT                                 *\n*************************************************************\n         SPACE 1\nFGVSAMIO STM   R14,R1,SAVEVSIO     SAVE REGISTERS\n         LA    R1,FGGRPL           --> RPL\n         USING IFGRPL,R1           DCL RPL BASE\n         SPACE 3\n*************************************************************\n*        SET RPL OPTCD FLAGS ASSUMING ALL RELEVENT GSB      *\n*        FLAGS ARE OFF. THEN EXAMINE THE GSB FLAGS TO SEE   *\n*        HOW THE RPL OPTCD FLAGS SHOULD REALLY BE SET.      *\n*************************************************************\n         SPACE 1\n         CL    R15,=F'-1'          SHOULD I MUCK WITH THE OPTCDS?\n         BE    VSIOPTOK            NO, SKIP\n         SPACE 1\n         MVI   RPLOPT1,RPLSEQ+RPLKGE+RPLECBSW YES, LOAD OPTCD1\n         MVI   RPLOPT2,RPLNSP+RPLKEY LOAD OPTCD2\n         SPACE 1\n         TM    GSBFLGS,GSBUPD      UPDATE?\n         BZ    FGETNUPD            NO, SKIP\n         XI    RPLOPT2,RPLNSP+RPLUPD YES, FLIP FLAGS\nFGETNUPD DS    0H\n         SPACE 1\n         TM    GSBFLGS,GSBDIR      DIRECT?\n         BZ    FGETNDIR            NO, SKIP\n         XI    RPLOPT1,RPLSEQ+RPLDIR YES, FLIP FLAGS\n         B     FGETNBWD            SKIP NEXT\nFGETNDIR DS    0H\n         SPACE 1\n         TM    GSBFLGS,GSBBACK     BACKWARDS?\n         BZ    FGETNBWD            NO, SKIP\n         OI    RPLOPT2,RPLBWD      YES, FLIP FLAG\nFGETNBWD DS    0H\n         SPACE 3\n*************************************************************\n*        PROPAGATE OTHER INFORMATION FROM THE GSB TO THE    *\n*        RPL.                                               *\n*************************************************************\n         SPACE 1\n         L     R15,GSBBUFL         GET L'BUFFER\n         ST    R15,RPLBUFL\n         SPACE 1\n         ICM   R15,15,GSBBUFA      --> BUFFER; SPECIAL LOCATION?\n         BNM   FGETBUFA            NO, PROCEED\n         LA    R15,GSBBUFX         YES, --> IT\nFGETBUFA ST    R15,RPLAREA\n         SPACE 1\n         L     R15,GSBRECL         GET L'RECORD\n         ST    R15,RPLRLEN\n         SPACE 1\n         LA    R0,L'GSBMSGX        ASSUME MSG AREA; GET MANDATORY LEN\n         LA    R15,GSBMSGX         ASSUME SPECIALLY LOCATED\n         TM    GSBBUFA,B'10000000' SPECIALLY LOCATED BUFFERS?\n         BNZ   FGETMSGA            YES, PROCEED\n         ICM   R15,15,GSBMSGA      NO, LOAD MSG AREA PTR; EXIST?\n         BNZ   FGETMSGA            YES, PROCEED\n         XR    R0,R0               GET SET L'MSG=0 (==> NO MSG AREA)\nFGETMSGA ST    R15,RPLERMSA\n         STH   R0,RPLEMLEN\n         SPACE 1\n         LA    R15,GSBECB          --> ECB\n         ST    R15,RPLECB\n         SPACE 1\n         LA    R15,FGLKEY          --> POSSIBLE SEARCH KEY\n         ST    R15,RPLARG          STORE\n         SPACE 3\n*************************************************************\n*        NOW SET RPL OPTCD BITS ACCORDING TO THE MANDATORY  *\n*        REQUIREMENTS OF THIS SPECIFIC CALL.                *\n*************************************************************\n         SPACE 1\n         L     R15,SAVEVSIO+4      RESTORE REQUIRED SETTINGS CONTROL\n         X     R15,=X'FF00FF00'    FLIP THE ANDED BITS\n         OI    RPLOPT2,*-*         (EXECUTED)\n         EX    R15,*-4             TURN ON OPTCD2 BITS\n         SPACE 1\n         SRL   R15,8               SHIFT THE SOURCE\n         B     *+8                 SKIP EXECUTED STMT\n         NI    RPLOPT2,*-*         (EXECUTED)\n         EX    R15,*-4             TURN OFF OPTCD2 BITS\n         SPACE 1\n         SRL   R15,8               SHIFT THE SOURCE\n         OI    RPLOPT1,*-*         (EXECUTED)\n         EX    R15,*-4             TURN ON OPTCD1 BITS\n         SPACE 1\n         SRL   R15,8               SHIFT THE SOURCE\n         B     *+8                 SKIP EXECUTED STMT\n         NI    RPLOPT1,*-*         (EXECUTED)\n         EX    R15,*-4             TURN OFF OPTCD1 BITS\n         SPACE 1\nVSIOPTOK DS    0H\n         SPACE 3\n*************************************************************\n*        ISSUE THE VSAM I/O REQUEST                         *\n*************************************************************\n         SPACE 1\n         DROP  R1                  RELEASE RPL BASE\n         XR    R15,R15             CLEAR FOR INSERT\n         IC    R15,SAVEVSIO        LOAD CALL TYPE\n         B     VSIOVECT(R15)       ENTRY BRANCH VECTOR\n         SPACE 1\nVSIOVECT DS    0H\nVSIOVGET B     VSIOGET\nVSIOVPUT B     VSIOPUT\nVSIOVERA B     VSIOERAS\nVSIOVEND B     VSIOENDR\n         SPACE 1\nVSIOGET  GET   RPL=(1)             VSAM GET\n         MVC   GSBRECL,RPLRLEN-IFGRPL+FGGRPL FEEDBACK THE LRECL\n         MVC   GSBRBA,RPLDDDD-IFGRPL+FGGRPL RETURN CRNT RBA (IF ANY)\n         LTR   R15,R15             GET OK?\n         BZ    VSIOAFTR            YES, PROCEED\n         NI    RPLOPT2-IFGRPL+FGGRPL,255-RPLUPD NO, CLEAR OWNERSHIP\n         NI    FGGFLAG,255-FGGFPVKY SEQ-GET POSITION INFO NOW BAD\n         B     VSIOAFTR            RESUME COMMON CODE\n         SPACE 1\nVSIOPUT  PUT   RPL=(1)             VSAM PUT\n         MVC   GSBRBA,RPLDDDD-IFGRPL+FGGRPL RETURN CRNT RBA (IF ANY)\n         NI    RPLOPT2-IFGRPL+FGGRPL,255-RPLUPD DON'T OWN RCD NOW\n         NI    FGGFLAG,255-FGGFPVKY SEQ-GET POSITION INFO NOW BAD\n         LTR   R15,R15             I/O OK?\n         BNZ   VSIOAFTR            NO, DONE HERE\n         LA    R1,FGGRPL           YES, INSURE RPL PTR RESTORED\n         B     VSIOENDR            GO FLUSH BUFFER\n         SPACE 1\nVSIOERAS ERASE RPL=(1)             VSAM ERASE\n         MVC   GSBRBA,RPLDDDD-IFGRPL+FGGRPL RETURN CRNT RBA (IF ANY)\n         NI    RPLOPT2-IFGRPL+FGGRPL,255-RPLUPD DON'T OWN RCD NOW\n         NI    FGGFLAG,255-FGGFPVKY SEQ-GET POSITION INFO NOW BAD\n         LTR   R15,R15             I/O OK?\n         BNZ   VSIOAFTR            NO, DONE HERE\n         LA    R1,FGGRPL           YES, INSURE RPL PTR RESTORED\n         SPACE 1\nVSIOENDR ENDREQ RPL=(1)            VSAM ENDREQ\n         NI    RPLOPT2-IFGRPL+FGGRPL,255-RPLUPD DON'T OWN RCD NOW\n         NI    FGGFLAG,255-FGGFPVKY SEQ-GET POSITION INFO NOW BAD\nVSIOAFTR DS    0H\n         SPACE 3\n*************************************************************\n*        HANDLE ERRORS THAT RESULT FROM REQUESTS THAT ARE   *\n*        INVALID DURING THE CREATION OF VSAM DATASETS. IF   *\n*        THE FILE IS TRUELY STILL EMPTY, THEN PASS THE      *\n*        ERROR CONDITION BACK TO THE CALLER. IF THE FILE IS *\n*        NOT EMPTY, THEN CLOSE IT AND THEN RE-OPEN IT AND   *\n*        THEN RETRY THE REQUEST.                            *\n*************************************************************\n         SPACE 1\n         CLI   RPLRTNCD-IFGRPL+FGGRPL,8 DATA ERROR?\n         BNE   VSIONCRE            NO, FORGET IT\n         CLI   RPLERRCD-IFGRPL+FGGRPL,116 YES, INVALID REQUEST DURING\n*                                  FILE CREATION?\n         BNE   VSIONCRE            NO, SKIP\n         SHOWCB MF=(E,SHOWPLST)    YES, EXTRACT THE HIGH RBA\n         SPACE 1\n         ICM   R15,15,FGGHIRBA     IS THE FILE STILL EMPTY?\n         BZ    VSIONCRE            YES, JUST RETURN THE ERROR TO CALLER\n         SPACE 1\n         CLOSE MF=(E,FGGOPEN)      NO, CLOSE THE FILE\n         NI    FGSBOFLG,255-FGSBOPEN RESET THE GSB\n         SPACE 1\n         LA    R0,FGGLEN           GET L'FGG\n         FREEMAIN R,LV=(0),A=(FGGREG) FREE THE FGG\n         XR    FGGREG,FGGREG       CLEAR FGG POINTER\n         ST    FGGREG,FGSBFGG      CLEAR FGG POINTER\n         B     FGRETRY             GO RE-OPEN AND RETRY\nVSIONCRE DS    0H\n         SPACE 3\n*************************************************************\n*        LOAD RETURN CODES AND RETURN TO CALLER             *\n*************************************************************\n         SPACE 1\n         LM    R14,R1,SAVEVSIO     RESTORE REGISTERS\n         XR    R15,R15             CLEAR FOR INSERTS\n         ICM   R15,2,RPLRTNCD-IFGRPL+FGGRPL GET VSAM RETURN CODE\n         IC    R15,RPLERRCD-IFGRPL+FGGRPL GET REASON CODE\n         BR    R14                 RETURN TO CALLER\n         TITLE 'SRCH -- SORTED LIST SEARCH ROUTINE'\nSRCH     #SEARCH SVID=SAVESRCH,CMPRID=COMPARE\n         TITLE 'COMPARE -- ERROR CODES MAP SEARCH COMPARE ROUTINE'\n         USING ERC,R15             DCL ERC BASE\nCOMPARE  CLC   RPLRTNCD-IFGRPL+FGGRPL,ERCVRETU RIGHT RETURN CODE?\n         BNER  R14                 NO, RETURN TO SEARCH\n         CLC   RPLERRCD-IFGRPL+FGGRPL,ERCVREAL YES, REASON CODE WITHIN\n*                                  LOW LIMIT?\n         BNHR  R14                 NO, OR JUST BARELY; RETURN TO SEARCH\n         CLC   RPLERRCD-IFGRPL+FGGRPL,ERCVREAH YES, WITH HI LIMIT TOO?\n         BNLR  R14                 NO, OR JUST BARELY; RETURN TO SEARCH\n         CR    R14,R14             YES, SET \"FOUND\" SIGNAL\n         BR    R14                 RETURN TO SEARCH\n         DROP  R15                 RELEASE ERC BASE\n         TITLE 'STATIC DATA AREA'\n*************************************************************\n*        THE FOLLOWING DATA IS USED TO INITIALIZE A SECTION *\n*        OF THE FGG AS A UNIT, SO IT MUST CONFORM TO THE    *\n*        SHAPE OF \"FGGREL\" IN THE FGG.                      *\n*************************************************************\n         SPACE 1\nFGREL    DS    0F                  START OF AREA\nFGID     DC    CL8'FAKEGSAM'\n         SPACE 1\nFGACB    ACB   AM=VSAM,                                                *\n               BUFND=4,                                                *\n               BUFNI=10,                                               *\n               DDNAME=FILLEDIN,    FROM GSBFILE                        *\n               MACRF=(DIR,SEQ,IN,OUT),                                 *\n               MAREA=*-*,                                              *\n               MLEN=L'FGLOCMA,                                         *\n               PASSWD=*-*          POINTS TO GSBPASSW\n         SPACE 1\nFGRPL    RPL   ACB=*-*,                                                *\n               AM=VSAM,                                                *\n               AREA=*-*,           FROM GSBBUFA                        *\n               AREALEN=*-*,        FROM GSBBUFL                        *\n               ARG=*-*,            POINTS TO GSBBUFX                   *\n               ECB=*-*,            FROM GSBECB                         *\n               MSGAREA=*-*,        FROM GSBMSGA                        *\n               MSGLEN=L'GSBMSGX,                                       *\n               OPTCD=(KEY,SYN,KGE,NWAITX,MVE),                         *\n               RECLEN=*-*          FROM GSBRECL\n         SPACE 1\nFGOPEN   OPEN  *-*,MF=L\n         SPACE 1\nFGRELL   EQU   *-FGREL             LENGTH OF AREA\n         SPACE 2\n*************************************************************\n*        VSAM TO GSAM ERROR CODES MAP                       *\n*************************************************************\n         SPACE 1\nERCMAP   DS    0X\n         DC    AL1(0,-1,0,0,X'FF')\n         DC    AL1(GSAMEKEY,-1,8,4,8)\n         DC    AL1(GSAMEKEY,-1,8,16,16)\n         DC    AL1(GSAMEDS,-1,8,24,32)\n         DC    AL1(GSAMEKEY,-1,8,36,36)\n         DC    AL1(GSAMECOR,36,8,40,40)\n         DC    AL1(GSAMEREC,-1,8,44,44)\n         DC    AL1(GSAMEREC,-1,8,100,100)\n         DC    AL1(GSAMEREC,-1,8,108,108)\n         DC    AL1(GSAMEDS,-1,8,116,116)\n         DC    AL1(GSAMEREC,-1,8,140,140)\n         DC    AL1(GSAMEDS,-1,8,144,144)\n         DC    AL1(GSAMEKEY,-1,8,148,148)\n         DC    AL1(GSAMECOR,36,8,152,152)\n         DC    AL1(GSAMEKEY,-1,8,192,192)\n         DC    AL1(GSAMEIO,-1,12,0,X'FF')\n         DC    AL1(GSAMEBUG,0,X'FF',X'FF',X'FF')\nERCMAPZ  DS    0X                  END OF MAP\n         SPACE 2\n         LTORG ,\n         TITLE 'SYSPRINT -- DUMMY SYSPRINT I/O ROUTINE FOR IDCAMS'\nSYSPRINT XR    R15,R15             SET RC=0\n         BR    R14                 NOP BACK TO IDCAMS\n         TITLE 'SYSIN -- I/O ROUTINE FOR IDCAMS'\n*************************************************************\n*                                                           *\n*        SYSIN -- THIS ROUTINE HANDLES SYSIN I/O FOR        *\n*        IDCAMS. ESSENTIALLY ALL IT DOES IS RETURN A VERIFY *\n*        COMMAND TO IDCAMS. THIS ROUTINE IS USED ONLY WHEN  *\n*        AN OPEN ATTEMPT FOR A GIVEN \"GSAM\" FILE HAS        *\n*        FAILED.                                            *\n*                                                           *\n*************************************************************\n         SPACE 1\nSYSIN    STM   R14,R12,12(R13)     SAVE ALL REGISTERS\n         LR    R12,R15             LOAD A LOCAL BASE\n         USING SYSIN,R12           DECLARE IT\n         SPACE 1\n         L     R2,4(,R1)           --> CALL FLAGS\n         CLI   0(R2),X'0C'         IS THIS A PUT REQUEST?\n         #DIE  E                   YES, LOGIC ERROR\n         CLI   0(R2),X'08'         NO, IS THIS A GET REQUEST?\n         BNE   SYSIN0              NO, OPEN/CLOSE; RETURN AOK\n         SPACE 1\n         L     R11,0(,R1)          YES, --> THE FGL\n         USING FGL,R11             DCL THE FGL BASE\n         CLI   VERIFY,0            IS THIS THE FIRST GET REQUEST?\n         BNE   SYSIN4              NO, RETURN SIGNALLING \"NO MORE\n*                                  GETS, PLEASE\"\n         MVC   VERIFY,=C' VERIFY FILE(' YES, BUILD VERIFY COMMAND\n         #TEST SIZE=(L'VERIFY,EQ,13)\n         LA    R15,VERDDN+L'VERDDN  --> PAST PROBLEM DDNAME\n         BASR  R14,0               LOAD LOOP HEAD\n         BCTR  R15,0               BACK UP\n         TM    0(R15),255-C' '     TRAILING BLANK?\n         BER   R14                 YES, CONTINUE THE BACKSCAN\n         MVC   1(2,R15),=C') '     NO, APPEND TRAILER\n         LA    R14,VERIFY-3        --> SO COMMAND\n         SR    R15,R14             GET L'COMMAND\n         LA    R14,VERIFY          --> TRUE SO-COMMAND\n         L     R1,8(,R1)           --> RETURN DATA AREA\n         STM   R14,R15,0(R1)       RETURN COMMAND DESCRIPTOR TO IDCAMS\n         B     SYSIN0              RETURN AOK\n         SPACE 3\nSYSIN4   BAS   R0,SYSINRET         RETURN RC=4\nSYSIN0   BAS   R0,SYSINRET         RETURN RC=0\nSYSINRET LA    R15,SYSINRET        LOAD VECTOR BASE\n         SR    R15,R0              GET RC\n         LA    R15,0(,R15)         PURIFY\n         SPACE 1\n         L     R14,12(,R13)        RESTORE REGISTER\n         LM    R0,R12,20(R13)      RESTORE REGISTERS\n         DROP  R11                 RELEASE FGL BASE\n         DROP  R12                 RELEASE LOCAL BASE\n         BR    R14                 RETURN TO IDCAMS\n         SPACE 3\n         LTORG ,\n         SPACE 3\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTEMACS": {"ttr": 18696, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x16o\\x00\\x90\\x16o\\x13F\\x06\\x16\\x06\\x16\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-15T00:00:00", "modifydate": "1990-06-15T13:46:00", "lines": 1558, "newlines": 1558, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n&LABEL   GTEDADOC\n*\n*  +----------------------------------------------------------------+\n*  |  This is an explanation of the GTE Dynamic Allocation macros.  |\n*  |                                                                |\n*  |         Chuck Hoffman                                          |\n*  |         Systems Programming                                    |\n*  |         GTE Laboratories - Technical Computation Center        |\n*  |         40 Sylvan Road                                         |\n*  |         Waltham, MA  02254                                     |\n*  |                               617/466-2131  v/n 679-2131       |\n*  +----------------------------------------------------------------+\n*\n* PURPOSE:\n*     DAIR/IKJDAIR is now being maintained only for compatability with\n* older programs.  IBM states that all new applications should be\n* written using SVC-99 rather than DAIR.  The purpose of these macros\n* is to make the use of SVC-99 and IKJEFF18 (DAIRFAIL messages) easy\n* from assembler programs.\n*\n* REFERENCE:\n*     The user of these routines should have available the IBM manual:\n* 'GC28-0627, OS/VS2 MVS Systems Programming Library:  Job Management'\n* which describes SVC-99.  A detailed knowledge of SVC-99 is not\n* necessary.\n*\n* FUNCTION:\n*     GTEDADAT - Allocates space at assembly time for control blocks.\n*                Generates literals and constants.\n*     GTEDASET - Initializes control blocks at exection time.\n*     GTEDAALC - Invokes SVC-99 and IKJEFF18.\n*\n*\n* GTEDADAT - creating control blocks.\n*\n* 1.  The name of the control blocks is limited to three characters,\n*     because it is used as a prefix for data items in the generated\n*     control blocks.\n*                okay:  ABC      GTEDADAT ...\n*                  no:  ABCD     GTEDADAT ...\n*\n* 2.  The use of MAP=ONLY will produce DS entries without initializing\n*     the contents of the blocks.\n*          DC entries:  ABC      GTEDADAT ...\n*          DS entries:  ABC      GTEDADAT MAP=ONLY,...\n         EJECT ,                                                   -EU-\n* 3.  The names of text unit operands are the same as those used in the\n*     'Job Management' manual.  For instance, DSNAM and DDNAM rather\n*     than DSNAME and DDNAME.  By limiting operands to five characters,\n*     labels can be created using the 3-character block name as a\n*     prefix, followed by the 5-character (max) operand name.  The\n*     dataset name in the example in 2, above, would be labeled\n*     ABCDSNAM.\n*           -------------------------------------------------\n*           ---  There is one exception because IBM uses  ---\n*           ---  the same last 5 characters for infor-    ---\n*           ---  mation retrieval with two different      ---\n*           ---  SVC-99 verb codes.  If using the DSN     ---\n*           ---  Allocation SVC-99 verb (X'01') use the   ---\n*           ---  IBM names on the left.  If using the     ---\n*           ---  Information Retrieval SVC-99 verb (X'07')---\n*           ---  use the GTE names on the right:          ---\n*           ---                                           ---\n*           ---     DSN Alloc.        Info. Retrieval     ---\n*           ---      DALRTDDN          DINRTDDN           ---\n*           ---      DALRTDSN          DINRTDSN           ---\n*           ---      DALRTORG          DINRTORG           ---\n*           -------------------------------------------------\n*\n* 4.  Text unit operands come in three flavors (refer to 'Job\n*     Management')\n*\n*     A.  Those for which an explicit value is supplied, e.g. DDNAME.\n*\n*              code:  ADC      GTEDADAT DDNAM=FILEA\n*\n*         generated: +         DC     AL2(DALDDNAM,1,8)\n*                    +ADCDDNAM DC     CL8'FILEA'\n*\n*     B.  Those which are either on or off:  e.g. Space type TRK\n*\n*              code:  ADC      GTEDADAT DDNAM=FILEA,TRK=YES\n*\n*         generated: +         DC     AL2(DALDDNAM,1,8)\n*                    +ADCDDNAM DC     CL8'FILEA'\n*                    +ADCTRK   DC     AL2(DALTRK,0)\n*         ----------------------------------------------------------\n*         ---  Note.  Information retrieval is in this category. ---\n*         ----------------------------------------------------------\n*\n*     C.  Those for which there is a choice which can be coded,\n*         e.g. Dataset organization.\n*\n*              code:  ADC      GTEDADAT DDNAM=FILEA,TRK=YES,DSORG=PS\n*\n*         generated: +         DC     AL2(DALDDNAM,1,8)\n*                    +ADCDDNAM DC     CL8'FILEA'\n*                    +ADCTRK   DC     AL2(DALTRK,0)\n*                    +ADCDSORG DC     AL2(DALDSORG,1,2),X'4000'\n         EJECT ,                                                   -EU-\n*   NOTE 1. -\n*     Each operand generates a text unit which begins with a two-byte\n*     key.  Each operand generates a label.  The label may be at the\n*     key, as in ADCTRK and ADCDSORG, above, or it may be at the\n*     literal, as in ADCDDNAM, above.  Location of the label is based\n*     on a best guess of anticipated use of that text unit.\n*\n*   NOTE 2. -\n*     Setting a key value to X'0000' will cause SVC-99 to ignore that\n*     text unit.  After executing GTEDASET which builds a list of\n*     pointers to the text units, values in the text units can be\n*     changed at will.\n*\n*   NOTE 3. -\n*     At this time, not all operands generate executable code, and\n*     those which do may be in error.  If you discover errors or need\n*     new functions, call Systems Programming.\n*\n*\n* GTEDASET - setting addresses in control blocks\n*\n* 1.  This macro needs to be executed once before the GTEDAALC macro\n*     executes.  It simply links together the control blocks generated\n*     by GTEDADAT.  After this macro has been executed, there is no\n*     problem changing values in the control blocks.\n*\n* 2.  The CPPLPTR operand is the name of a fullword.  If the program is\n*     a TSO Command Processor, the fullword must contain the address of\n*     the Command Processor Parameter List (CPPL).  If the program is\n*     not a Command Processor, the fullword should contain the address\n*     of a fake CPPL, or ERRMSG=NO should be coded in the GTEDAALC\n*     macro (below).\n*\n*\n* GTEDAALC - executing SVC-99 and IKJEFF18\n*\n* 1.  This macro is executed once each time you want SVC-99 to\n*     execute.\n*\n* 2.  The choice of VERB= are as follows.  Again, keywords correspond\n*     to names in the 'Job Management' manual.\n*       VERB=AL  dsn allocation        VERB=UN  dsn or ddn unallocation\n*       VERB=CC  concatenation         VERB=DC  deconcatenation\n*       VERB=RI  remove in-use         VERB=DN  ddn allocation\n*       VERB=IN  information retrieveal\n*\n*     Concatenation and deconcatenation aren't yet supported, but they\n*     will be.\n         EJECT ,                                                   -EU-\n* 3.  This macro has the ERRMSG=NO operand to suppress creating code to\n*     return the SVC-99 failure messages to the TSO terminal.  Use this\n*     operand when the CPPLPTR operand of the GTEDASET macro points to\n*     a fullword which does not contain the address of a CPPL.  When\n*     this operand is used, the SVC-99 return code and the error and\n*     info codes are still available to your program.  Only the writing\n*     of an error message to the terminal is suppressed.  E.g.:\n*\n*                         GTEDAALC  ADC,VERB=AL,ERRMSG=NO\n*\n*     Places the return and error/info codes in these areas:\n*\n*               +ADCS99RC DS     F        SVC-99 RETURN CODE\n*\n*               +ADCERROR DS     H        SVC-99 ERROR CODE\n*               +ADCINFO  DS     H        SVC-99 INFO CODE\n*\n*     The error and info codes are contiguous, and the error code is\n*     aligned on a fullword boundry.\n*\n*\n* MAPPING MACROS:\n*     The following mapping macros must appear in the source.  Base\n* registers do not need to be assigned.\n*\n*     IEFZB4D0                             Maps SVC-99 blocks\n*     IEFZB4D2                             SVC-99 keys table       -EU-\n*     IKJEFFDF DFDSECT=YES,DFDSEC2=YES     Maps IKJEFF18 control blocks\n* ---------------------------------------------------------------------\n         EJECT\n* ---------------------------------------------------------------------\n*                        *** EXAMPLE ***\n*\n* We want to allocate member CURVES of CAH0.PDS.DATA to file FT12F001,\n* and we want to allocate member SPLINE of the same dataset to file\n* FT14F001.  Dataset status should be SHR, and sequential organization\n* will be used.  Further, we want the program to be reenterable, so all\n* variable data will be located in storage obtained with GETMAIN.\n*\n* Choose operands for the GTEDADAT macro by reference to the 'Job\n* Management' manual.\n*\n*             PRINT NOGEN\n*    EXMPL1   LINKSAVE BASE=12,GETMAIN=YES           LINKAGE CNVNTNS\n*             LR    5,1                              HOLD CPPL ADDRESS\n*             GETMAIN R,LV=1024                      GET WORK STORAGE\n*             LR    11,1                             ADDRESSABILITY OF\n*             USING AREA1,11                           WORK STORAGE\n*              .       .\n*             ST    5,CPPLADDR                       SAVE CPPL ADDRESS\n*              .       .\n*              .       .\n*             MVC   XYZ(XYZLEN),ABC                  COPY TO WORK AREA\n*             GTEDASET XYZ,CPPLPTR=CPPLADDR          SET POINTERS\n*              .       .\n*              .       .\n*             GTEDAALC XYZ,VERB=AL                   ALLOCATE FT12F001\n*              .       .\n*              .       .\n*             MVC   XYZMEMBR,=C'SPLINE  '            CHANGE MEMBER NME\n*             MVC   XYZDDNAM,=C'FT14F001'            CHANGE FILE NAME\n*             GTEDAALC XYZ,VERB=AL                   ALLOCATE FT14F001\n*              .       .\n*              .       .\n*    ENDUP    FREEMAIN R,LV=1024,A=(11)              FREE STORAGE\n*             XR    15,15                            ZERO R/C\n*             LINKBACK                               LINKAGE CNVNTNS\n*              .       .\n*              .       .\n*    ABC      GTEDADAT DSNAM=CAH0.PDS.DATA,MEMBR=CURVES,              X\n*                   DDNAM=FT12F001,STATS=SHR,CNVRT=YES\n*              .       .\n*              .       .\n*    AREA1    DSECT\n*    CPPLADDR DS    F\n*    XYZ      GTEDADAT MAP=ONLY,DSNAM=CAH0.PDS.DATA,MEMBR=CURVES,     X\n*                   DDNAM=FT12F001,STATS=SHR,CNVRT=YES\n*              .       .\n*              .       .\n*             IEFZB4D0\n*             IEFZB4D2 ,                                           -EU-\n*             IKJEFFDF DFDSECT=YES,DFDSEC2=YES\n*             END\n* ---------------------------------------------------------------------\n         MEND\n         MACRO\n&LABEL   GTEDAALC  &NM,&VERB=AL,&ERRMSG=YES\n.*\n.*          +-----------------------------------------------+\n.*          |  See macro GTEDADOC for documentation of the  |\n.*          |  use of this and other GTEDAxxx macros.       |\n.*          +-----------------------------------------------+\n.*\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n***   PERFORM DYNAMIC ALLOCATION USING A DATA AREA CREATED          ***\n***   BY MACRO GTEDADAT, AND POINTERS/DATA SET BY MACRO GTEDASET.   ***\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n***   SET VERB CODE INTO S99RB.                                     ***\n***   MAPPING MACRO IEFZB4D0 MUST APPEAR IN THE SOURCE.             ***\n***   KEYS TABLE MACRO IEFZB4D2 MUST APPEAR IN THE SOURCE.      -EU-***\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n&LABEL   LA    1,&NM.RB\n.VBAL    AIF   ('&VERB' NE 'AL').VBUN\n         MVI   (S99VERB-S99RB)(1),S99VRBAL   SET VERB, DSN ALLOC\n         AGO   .VBEND\n.VBUN    AIF   ('&VERB' NE 'UN').VBCC\n         MVI   (S99VERB-S99RB)(1),S99VRBUN   SET VERB, DSN UNALLOC\n         AGO   .VBEND\n.VBCC    AIF   ('&VERB' NE 'CC').VBDC\n         MVI   (S99VERB-S99RB)(1),S99VRBCC   SET VERB, CONCATENATE\n         AGO   .VBEND\n.VBDC    AIF   ('&VERB' NE 'DC').VBRI\n         MVI   (S99VERB-S99RB)(1),S99VRBDC   SET VERB, DECONCATENATE\n         AGO   .VBEND\n.VBRI    AIF   ('&VERB' NE 'RI').VBDN\n         MVI   (S99VERB-S99RB)(1),S99VRBRI   SET VERB, REMOVE IN-USE\n         AGO   .VBEND\n.VBDN    AIF   ('&VERB' NE 'DN').VBIN\n         MVI   (S99VERB-S99RB)(1),S99VRBDN   SET VERB, DDN ALLOC\n         AGO   .VBEND\n.VBIN    AIF   ('&VERB' NE 'IN').VBEND\n         MVI   (S99VERB-S99RB)(1),S99VRBIN   SET VERB, REQUEST INFO\n         AGO   .VBEND\n.VBEND   ANOP\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n***   DO DYNAMIC ALLOCATION.                                        ***\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n         LA    1,&NM.RBP                ADDRESS OF PTR TO SVC-99 RB\n         SVC   99                       DYNALLOC\n         ST    15,&NM.S99RC             SAVE RETURN CODE FROM SVC-99\n.********************************************************************\n.**   IF &ERRMSG=NO, DO NOT EVER GENERATE CODE FOR IKJEFF18.       **\n.********************************************************************\n         AIF   ('&ERRMSG' EQ 'NO').NOPR\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n***   IF R/C FROM DYNAMIC ALLOCATION NOT ZERO,                      ***\n***   EXECUTE THE IKJEFF18 (DAIRFAIL) PROGRAM TO PRODUCE            ***\n***   ERROR MESSAGES.                                               ***\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n         CNOP  2,4                      ALIGN FOR BRANCH INSTRUCTION\n         LTR   15,15                    IF RETURN CODE IS GOOD\n         BZ    EXZ&SYSNDX                 BRANCH TO END OF ROUTINE\n         BAS   1,EXA&SYSNDX  BRANCH AROUND LIST\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n***   EXCEPTIONS, DON'T USE IKJEFF18 FOR THESE VERB/ERROR COMBOS.   ***\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n         DC    H'1'          NUMBER OF MEMBERS IN THIS LIST         ***\n         DC    AL1(S99VRBUN) VERB 02 (UNALLOCATION)                 ***\n         DC    XL2'0438'     ERR 0438 DDNAME NOT FOUND              ***\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\nEXA&SYSNDX LA    2,2(0,1)               R2 IS POINTER TO COMBOS\n         LH    1,0(0,1)                 R1 IS COUNT OF COMBOS\n         LA    15,&NM.RB                R15 IS BASE OF RB\n         CLC   (S99VERB-S99RB)(1,15),0(2)  IF NO MATCH ON VERB\n         BNE   *+14                          BRANCH TO END OF LOOP\n         CLC   (S99ERROR-S99RB)(2,15),1(2) ELSE IF ERRCDE MATCHES\n         BE    EXZ&SYSNDX                    BRANCH TO ENDING\n         LA    2,6(0,2)                 POINT TO NEXT ENTRY\n         BCT   1,*-24                   LOOP BACK UP TIL EOL\n         LA    1,&NM.DFPRM              POINT TO IKJEFF18 PARM BLOCK\n         CNOP  0,4                      ALIGN FOR FOLLOWING BAS\n         BAS   15,*+20                  LOAD CONST ADDR AND BRANCH\n         DC    A(*+8)                   ADDR OF LINK PARM LIST\n         DC    A(0)                     ADDR OF DCB (NONE)\n         DC    CL8'IKJEFF18'            EP NAME\n         SVC   6                        LINK\n.NOPR    ANOP\nEXZ&SYSNDX NOPR  0                        END POINT\n         MEND\n         MACRO\n&LABEL   GTEDASET &NM,&CPPLPTR=\n.*\n.*          +-----------------------------------------------+\n.*          |  See macro GTEDADOC for documentation of the  |\n.*          |  use of this and other GTEDAxxx macros.       |\n.*          +-----------------------------------------------+\n.*\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n***   SET POINTERS AND DATA FOR DYNAMIC ALLOCATION IN DATA AREAS    ***\n***   CREATED BY MACRO GTEDADAT.                                    ***\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n***   PLACE ADDRESS OF S99RB INTO S99RBPTR.                         ***\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n&LABEL   LA    1,&NM.RB                       ==> R1 POINTS TO S99RB\n         ST    1,&NM.RBP                          FILL IN S99RBPTR\n         OI    &NM.RBP,X'80'                      TURN ON HI BIT\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n***   FILL IN S99RB REQUEST BLOCK.                                  ***\n***   MAPPING MACRO IEFZB4D0 MUST APPEAR IN SOURCE.                 ***\n***   KEYS TABLE MACRO IEFZB4D0 MUST APPEAR IN SOURCE.          -EU-***\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n         MVI   (S99RBLN-S99RB)(1),20              FILL IN LENGTH\n         MVI   (S99VERB-S99RB)(1),0               ZERO VERB CODE\n         XC    (S99FLAG1-S99RB)(4,1),(S99FLAG1-S99RB)(1)   ZERO FLAGS1\n         OI    (S99FLAG1-S99RB)(1),S99ONCNV       SET FLAGS1 OK CONVRT\n         OI    (S99FLAG1-S99RB)(1),S99NOMNT       SET FLAGS1 NO MOUNT\n         LA    2,&NM.TUPL                     ==> R2 POINTS TO TUPL\n         ST    2,(S99TXTPP-S99RB)(0,1)            TUPL ADDR INTO RB\n         XC    (S99FLAG2-S99RB)(4,1),(S99FLAG2-S99RB)(1)   ZERO FLAGS2\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n***   BUILD TUPL.                                                   ***\n***   KEY OF LAST TEXT UNIT MUST BE X'FF..'.                        ***\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n         LA    1,&NM.TU                       ==> R1 POINTS TO TUNITS\n         XR    0,0                                CLEAR R0 FOR COUNTER\n         XR    15,15                              CLEAR R15 WORK REG\nRBA&SYSNDX CLI (S99TUKEY-S99TUNIT)(1),X'FF'       IF KEY IS X'FF..'\n         BE    RBD&SYSNDX                           BRANCH OUT OF LOOP\n         ST    1,0(0,2)                           ADDR OF KEY TO TUPL\n         LA    2,4(0,2)                           INCR POINTER TO TUPL\n         ICM   0,3,(S99TUNUM-S99TUNIT)(1)         TU NUM TO R0\n         LA    1,4(0,1)                           R1 POINTS BEYOND NUM\n         LTR   0,0                                IF TU NUM IS 0\n         BZ    RBA&SYSNDX                         PROCESS NEXT TU\n         ICM   15,3,0(1)                          TU LEN TO R15\n         LA    1,2(15,1)                          PNT BEYND LEN & PARM\n         BCT   0,*-8                              DO FOR EACH LEN+PARM\n         B     RBA&SYSNDX                         PROCESS NEXT TU\nRBD&SYSNDX LA  15,4(0,0)                          POINT TO LAST\n         SR    2,15                                 TUPL ENTRY\n         OI    0(2),S99TUPLN                      MARK LAST TUPL ENTRY\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n***   FILL IN THE DAIRFAIL PARAMETER BLOCK.                         ***\n***   IKJEFFDF DFDSECT=YES,DFDSEC2=YES MUST APPEAR IN SOURCE.       ***\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n         MVC   &NM.DFPRM+(DFS99RBP-DFDSECTD)(4),&NM.RBP *PTR TO RB\n         LA    1,&NM.S99RC\n         ST    1,&NM.DFPRM+(DFRCP-DFDSECTD)             *PTR TO S99RC\n         LA    1,&NM.F02EP\n         ST    1,&NM.DFPRM+(DFJEFF02-DFDSECTD)          *PTR TO EP\n         LA    1,&NM.ID\n         ST    1,&NM.DFPRM+(DFIDP-DFDSECTD)             *PTR TO SW+ID\n         MVC   &NM.DFPRM+(DFCPPLP-DFDSECTD)(4),&CPPLPTR *PTR TO CPPL\n         XC  &NM.DFPRM+(DFBUFP-DFDSECTD)(4),&NM.DFPRM+(DFBUFP-DFDSECTD)\n*                                                       *ZERO BUFF ADDR\n         MEND\n         MACRO\n&NM      GTEDADAT  &MAP=,&DDNAM=,&DSNAM=,&MEMBR=,&STATS=,              X\n               &NDISP=,&CDISP=,                                        X\n               &TRK=,&CYL=,&BLKLN=,&PRIME=,&SECND=,&DIR=,&RLSE=,       X\n               &SPFRM=,&ROUND=,&VLSER=,&PRIVT=,&VLSEQ=,&VLCNT=,        X\n               &VLRDS=,&UNIT=,&UNCNT=,&PARAL=,&SYSOU=,&SPGNM=,&SFMNO=, X\n               &OUTLM=,&CLOSE=,&COPYS=,&LABEL=,&DSSEQ=,&PASPR=,        X\n               &INOUT=,&EXPDT=,&RETPD=,&DUMMY=,&FCBIM=,&FCBAV=,        X\n               &QNAME=,&TERM=,&UCS=,&UFOLD=,&UVRFY=,&DCBDS=,&DCBDD=,   X\n               &SUSER=,&SHOLD=,&MSVGP=,&SSNM=,&PROT=,&BFALN=,&BFTEK=,  X\n               &BLKSZ=,&BUFIN=,&BUFL=,&BUFMX=,&BUFNO=,&BUFOF=,&BUFOU=, X\n               &BUFRQ=,&BUFSZ=,&CODE=,&CPRI=,&DEN=,&DSORG=,&EROPT=,    X\n               &GNCP=,&INTVL=,&KYLEN=,&LIMCT=,&LRECL=,&MODE=,&NCP=,    X\n               &OPTCD=,&PCIR=,&PCIS=,&PRTSP=,&RECFM=,&RSRVF=,&RSRVS=,  X\n               &SOWA=,&STACK=,&THRSH=,&TRTCH=,&IPLTX=,&DIAGN=,&FUNC=,  X\n               &FRID=,&PASSW=,&PERMA=,&CNVRT=,                         X\n               &RTDDN=,&RTDSN=,&RTORG=,       <== FOR DSN ALLOCATION   X\n               &INDDN=,&INDSN=,&INORG=,       <== FOR INFO RETRIEVAL   X\n               &RTMEM=,&RTSTA=,&RTNDP=,&RTCDP=,&RTLIM=,&RTATT=,        X\n               &RTLST=,&RTTYP=,&RELNO=,                                X\n               &RTVOL=,&SSPRM=,&TCBAD=,&REMOV=,&UNALC=\n.*\n.*          +-----------------------------------------------+\n.*          |  See macro GTEDADOC for documentation of the  |\n.*          |  use of this and other GTEDAxxx macros.       |\n.*          +-----------------------------------------------+\n.*\n           LCLA  &TUPLEN\n&TUPLEN    SETA  0\n&NM        DS  0D                       ALIGN FOR GETMAIN\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n***   TEXT UNITS FOR SVC99.                                         ***\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n&NM.TU     DS  0F   TEXT UNITS FOR SVC99\n.********************************************************************\n.**   DSNAME ALLOCATION TEXT UNITS - VERB CODE 01.                 **\n.********************************************************************\n.TUDDNAM   AIF ('&DDNAM' EQ '').TUDSNAM\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUDDNA#\n           DS  XL6\n&NM.DDNAM  DS  CL8                      DDNAME\n           AGO .TUDSNAM\n.TUDDNA#   ANOP\n           DC  AL2(DALDDNAM,1,8)\n&NM.DDNAM  DC  CL8'&DDNAM'              DDNAME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUDSNAM   AIF ('&DSNAM' EQ '').TUMEMBR\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUDSNA#\n           DS  XL6\n&NM.DSNAM  DS  CL44                     DATASET NAME\n           AGO .TUMEMBR\n.TUDSNA#   ANOP\n           DC  AL2(DALDSNAM,1,44)       DATASET NAME (NEXT LINE)\n&NM.DSNAM  DC  CL44'&DSNAM'\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUMEMBR   AIF ('&MEMBR' EQ '').TUSTATS\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUMEMB#\n&NM.MEMKY  DS  XL6\n&NM.MEMBR  DS  CL8                      MEMBER NAME\n           AGO .TUSTATS\n.TUMEMB#   ANOP\n&NM.MEMKY  DC  AL2(DALMEMBR,1,8)\n&NM.MEMBR  DC  CL8'&MEMBR'              MEMBER NAME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSTATS   AIF ('&STATS' EQ '').TUNDISP\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUSTAT#\n&NM.STATS  DS  XL7                      STATUS\n           AGO .TUNDISP\n.TUSTAT#   AIF ('&STATS' NE 'OLD').TUSTAT2\n&NM.STATS  DC  AL2(DALSTATS,1,1),X'01'  STATUS=OLD\n           AGO .TUNDISP\n.TUSTAT2   AIF ('&STATS' NE 'MOD').TUSTAT4\n&NM.STATS  DC  AL2(DALSTATS,1,1),X'02'  STATUS=MOD\n           AGO .TUNDISP\n.TUSTAT4   AIF ('&STATS' NE 'NEW').TUSTAT8\n&NM.STATS  DC  AL2(DALSTATS,1,1),X'04'  STATUS=NEW\n           AGO .TUNDISP\n.TUSTAT8   AIF ('&STATS' NE 'SHR').TUNDISP\n&NM.STATS  DC  AL2(DALSTATS,1,1),X'08'  STATUS=SHR\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUNDISP   AIF ('&NDISP' EQ '').TUCDISP\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUNDIS#\n&NM.NDISP  DS  XL7                      NORMAL DISP\n           AGO .TUCDISP\n.TUNDIS#   AIF ('&NDISP' NE 'UNCATLG').TUNDIS2\n&NM.NDISP  DC  AL2(DALNDISP,1,1),X'01'  NORMAL DISP=UNCATLG\n           AGO .TUCDISP\n.TUNDIS2   AIF ('&NDISP' NE 'CATLG').TUNDIS4\n&NM.NDISP  DC  AL2(DALNDISP,1,1),X'02'  NORMAL DISP=CATLG\n           AGO .TUCDISP\n.TUNDIS4   AIF ('&NDISP' NE 'DELETE').TUNDIS8\n&NM.NDISP  DC  AL2(DALNDISP,1,1),X'04'  NORMAL DISP=DELETE\n           AGO .TUCDISP\n.TUNDIS8   AIF ('&NDISP' NE 'KEEP').TUCDISP\n&NM.NDISP  DC  AL2(DALNDISP,1,1),X'08'  NORMAL DISP=KEEP\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUCDISP   AIF ('&CDISP' EQ '').TUTRK\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUCDIS#\n&NM.CDISP  DS  XL7                      COND DISP\n           AGO .TUTRK\n.TUCDIS#   AIF ('&CDISP' NE 'UNCATLG').TUCDIS2\n&NM.CDISP  DC  AL2(DALCDISP,1,1),X'01'  COND DISP=UNCATLG\n           AGO .TUTRK\n.TUCDIS2   AIF ('&CDISP' NE 'CATLG').TUCDIS4\n&NM.CDISP  DC  AL2(DALCDISP,1,1),X'02'  COND DISP=CATLG\n           AGO .TUTRK\n.TUCDIS4   AIF ('&CDISP' NE 'DELETE').TUCDIS8\n&NM.CDISP  DC  AL2(DALCDISP,1,1),X'04'  COND DISP=DELETE\n           AGO .TUTRK\n.TUCDIS8   AIF ('&CDISP' NE 'KEEP').TUTRK\n&NM.CDISP  DC  AL2(DALCDISP,1,1),X'08'  COND DISP=KEEP\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUTRK     AIF ('&TRK' EQ '').TUCYL\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUTRKA\n&NM.TRK    DS  XL4                      TRK\n           AGO .TUCYL\n.TUTRKA    ANOP\n&NM.TRK    DC  AL2(DALTRK,0)            TRK\n           AGO .TUPRIME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUCYL     AIF ('&CYL' EQ '').TUBLKLN\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUCYLA\n&NM.CYL    DS  XL4                      CYL\n           AGO .TUBLKLN\n.TUCYLA    ANOP\n&NM.CYL    DC  AL2(DALCYL,0)            CYL\n           AGO .TUPRIME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBLKLN   AIF ('&BLKLN' EQ '').TUPRIME\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBLKL#\n           DS  XL6\n&NM.BLKLN  DS  AL3                      AVERAGE BLOCK LENGTH\n           AGO .TUPRIME\n.TUBLKL#   DC  AL2(DALBLKLN,1,3)\n&NM.BLKLN  DC  AL3(&BLKLN)              AVERAGE BLOCK LENGTH\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUPRIME   AIF ('&PRIME' EQ '').TUSECND\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUPRIM#\n           DS  XL6\n&NM.PRIME  DS  AL3                      PRIMARY SPACE QUANTITY\n           AGO .TUSECND\n.TUPRIM#   DC  AL2(DALPRIME,1,3)\n&NM.PRIME  DC  AL3(&PRIME)              PRIMARY SPACE QUANTITY\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSECND   AIF ('&SECND' EQ '').TUDIR\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUSECN#\n           DS  XL6\n&NM.SECND  DS  AL3                      SECONDARY SPACE QUANTITY\n           AGO .TUDIR\n.TUSECN#   DC  AL2(DALSECND,1,3)\n&NM.SECND  DC  AL3(&SECND)              SECONDARY SPACE QUANTITY\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUDIR     AIF ('&DIR' EQ '').TURLSE\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUDIRA\n           DS  XL6\n&NM.DIR    DS  AL3                      NUMBER OF DIRECTORY BLOCKS\n           AGO .TURLSE\n.TUDIRA    DC  AL2(DALDIR,1,3)\n&NM.DIR    DC  AL3(&DIR)                NUMBER OF DIRECTORY BLOCKS\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURLSE    AIF ('&RLSE' EQ '').TUSPFRM\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURLSEA\n&NM.RLSE   DS  XL4                      RLSE\n           AGO .TUSPFRM\n.TURLSEA   ANOP\n&NM.RLSE   DC  AL2(DALRLSE,0)           RLSE\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSPFRM   AIF ('&SPFRM' EQ '').TUROUND\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUSPFR#\n&NM.SPFRM  DS  XL7                      SPACE FORMAT\n           AGO .TUROUND\n.TUSPFR#   AIF ('&SPFRM' NE 'ALX').TUSPFR4\n&NM.SPFRM  DC  AL2(DALSPFRM,1,1),X'02'  ALX\n           AGO .TUROUND\n.TUSPFR4   AIF ('&SPFRM' NE 'MXIG').TUSPFR8\n&NM.SPFRM  DC  AL2(DALSPFRM,1,1),X'04'  MXIG\n           AGO .TUROUND\n.TUSPFR8   AIF ('&SPFRM' NE 'CONTIG').TUROUND\n&NM.SPFRM  DC  AL2(DALSPFRM,1,1),X'08'  CONTIG\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUROUND   AIF ('&ROUND' EQ '').TUVLSER\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUROUN#\n&NM.ROUND  DS  XL4                      ROUND\n           AGO .TUVLSER\n.TUROUN#   ANOP\n&NM.ROUND  DC  AL2(DALROUND,0)          ROUND\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUVLSER   AIF ('&VLSER' EQ '').TUPRIVT\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUVLSE#\n           DS  XL6\n&NM.VLSER  DS  CL6                      VOLUME SERIAL NUMBER\n           AGO .TUPRIVT\n.TUVLSE#   DC  AL2(DALVLSER,1,6)\n&NM.VLSER  DC  CL6'&VLSER'              VOLUME SERIAL NUMBER\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUPRIVT   AIF ('&PRIVT' EQ '').TUVLSEQ\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUPRIV#\n&NM.PRIVT  DS  XL4                      PVT\n           AGO .TUVLSEQ\n.TUPRIV#   ANOP\n&NM.PRIVT  DC  AL2(DALPRIVT,0)          PVT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUVLSEQ   AIF ('&VLSEQ' EQ '').TUVLCNT\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUVLSQ#\n           DS  XL6\n&NM.VLSEQ  DS  AL2                      VOLUME SEQUENCE NUMBER\n           AGO .TUVLCNT\n.TUVLSQ#   DC  AL2(DALVLSEQ,1,2)\n&NM.VLSEQ  DC  AL2(&VLSEQ)              VOLUME SEQUENCE NUMBER\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUVLCNT   AIF ('&VLCNT' EQ '').TUVLRDS\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUVLCN#\n           DS  XL6\n&NM.VLCNT  DC  AL1                      VOLUME COUNT\n           AGO .TUVLRDS\n.TUVLCN#   DC  AL2(DALVLCNT,1,1)\n&NM.VLCNT  DC  AL1(&VLCNT)              VOLUME COUNT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUVLRDS   AIF ('&VLRDS' EQ '').TUUNIT\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUVLRD#\n           DS  XL6\n&NM.VLRDS  DS  CL44                     VOLUME REF TO THIS DSN\n           AGO .TUUNIT\n.TUVLRD#   DC  AL2(DALVLRDS,1,44)       VOLUME REF TO DSN (BELOW)\n&NM.VLRDS  DC  CL44'&VLRDS'\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUUNIT    AIF ('&UNIT' EQ '').TUUNCNT\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUUNITA\n           DS  XL6\n&NM.UNIT   DS  CL6                      UNIT\n           AGO .TUUNCNT\n.TUUNITA   DC  AL2(DALUNIT,1,6)\n&NM.UNIT   DC  CL6'&UNIT'               UNIT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUUNCNT   AIF ('&UNCNT' EQ '').TUPARAL\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUUNCN#\n           DS  XL6\n&NM.UNCNT  DS  AL1                      UNIT COUNT\n           AGO .TUPARAL\n.TUUNCN#   DC  AL2(DALUNCNT,1,1)\n&NM.UNCNT  DC  AL1(&UNCNT)              UNIT COUNT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUPARAL   AIF ('&PARAL' EQ '').TUSYSOU\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUPARA#\n&NM.PARAL  DS  XL4                      PARALLEL MOUNT\n           AGO .TUSYSOU\n.TUPARA#   ANOP\n&NM.PARAL  DC  AL2(DALPARAL,0)          PARALLEL MOUNT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSYSOU   AIF ('&SYSOU' EQ '').TUSPGNM\n           AIF ('&SYSOU' NE '*').TUSYSO2\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUSYSO#\n&NM.SYSOU  DS  XL4                      SYSOUT=*\n           AGO .TUSPGNM\n.TUSYSO#   ANOP\n&NM.SYSOU  DC  AL2(DALSYSOU,0)          SYSOUT=*\n           AGO .TUSPGNM\n.TUSYSO2   ANOP\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUSYS##\n           DS  XL6\n&NM.SYSOU  DS  CL1                      SYSOUT CLASS\n           AGO .TUSPGNM\n.TUSYS##   DC  AL2(DALSYSOU,1,1)\n&NM.SYSOU  DC  CL1'&SYSOU'              SYSOUT CLASS\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSPGNM   AIF ('&SPGNM' EQ '').TUSFMNO\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUSPGN#\n           DS  XL6\n&NM.SPGNM  DS  CL8                      SYSOUT PROGRAM NAME\n           AGO .TUSFMNO\n.TUSPGN#   DC  AL2(DALSPGNM,1,8)\n&NM.SPGNM  DC  CL8'&SPGNM'              SYSOUT PROGRAM NAME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSFMNO   AIF ('&SFMNO' EQ '').TUOUTLM\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUSFMN#\n           DS  XL6\n&NM.SFMNO  DS  CL4                      SYSOUT FORM NAME/NUMBER\n           AGO .TUOUTLM\n.TUSFMN#   DC  AL2(DALSFMNO,1,4)\n&NM.SFMNO  DC  CL4'&SFMNO'              SYSOUT FORM NAME/NUMBER\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUOUTLM   AIF ('&OUTLM' EQ '').TUCLOSE\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUOUTL#\n           DS  XL6\n&NM.OUTLM  DS  AL3                      OUTLIM\n           AGO .TUCLOSE\n.TUOUTL#   DC  AL2(DALOUTLM,1,3)\n&NM.OUTLM  DC  AL3(&OUTLM)              OUTLIM\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUCLOSE   AIF ('&CLOSE' EQ '').TUCOPYS\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUCLOS#\n&NM.CLOSE  DS  XL4                      FREE=CLOSE\n           AGO .TUCOPYS\n.TUCLOS#   ANOP\n&NM.CLOSE  DC  AL2(DALCLOSE,0)          FREE=CLOSE\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUCOPYS   AIF ('&COPYS' EQ '').TULABEL\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUCOPY#\n           DS  XL6\n&NM.COPYS  DS  AL1                      COPIES\n           AGO .TULABEL\n.TUCOPY#   DC  AL2(DALCOPYS,1,1)\n&NM.COPYS  DC  AL1(&COPYS)              COPIES\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TULABEL   AIF ('&LABEL' EQ '').TUDSSEQ\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TULABE#\n&NM.LABEL  DS  XL7                      LABEL\n           AGO .TUDSSEQ\n.TULABE#   AIF ('&LABEL' NE 'NL').TULABE2\n&NM.LABEL  DC  AL2(DALLABEL,1,1),X'01'  LABEL=NL\n           AGO .TUDSSEQ\n.TULABE2   AIF ('&LABEL' NE 'SL').TULABE3\n&NM.LABEL  DC  AL2(DALLABEL,1,1),X'02'  LABEL=SL\n           AGO .TUDSSEQ\n.TULABE3   AIF ('&LABEL' NE 'NSL').TULABE4\n&NM.LABEL  DC  AL2(DALLABEL,1,1),X'04'  LABEL=NSL\n           AGO .TUDSSEQ\n.TULABE4   AIF ('&LABEL' NE 'SUL').TULABE5\n&NM.LABEL  DC  AL2(DALLABEL,1,1),X'0A'  LABEL=SUL\n           AGO .TUDSSEQ\n.TULABE5   AIF ('&LABEL' NE 'BLP').TULABE6\n&NM.LABEL  DC  AL2(DALLABEL,1,1),X'10'  LABEL=BLP\n           AGO .TUDSSEQ\n.TULABE6   AIF ('&LABEL' NE 'LTM').TULABE7\n&NM.LABEL  DC  AL2(DALLABEL,1,1),X'21'  LABEL=LTM\n           AGO .TUDSSEQ\n.TULABE7   AIF ('&LABEL' NE 'AL').TULABE8\n&NM.LABEL  DC  AL2(DALLABEL,1,1),X'40'  LABEL=AL\n           AGO .TUDSSEQ\n.TULABE8   AIF ('&LABEL' NE 'AUL').TUDSSEQ\n&NM.LABEL  DC  AL2(DALLABEL,1,1),X'48'  LABEL=AUL\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUDSSEQ   AIF ('&DSSEQ' EQ '').TUPASPR\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUDSSE#\n           DS  XL6\n&NM.DSSEQ  DS  AL2                      LABEL= DATASET SEQUENCE NUMBER\n           AGO .TUPASPR\n.TUDSSE#   DC  AL2(DALDSSEQ,1,2)\n&NM.DSSEQ  DC  AL2(&DSSEQ)              LABEL= DATASET SEQUENCE NUMBER\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUPASPR   AIF ('&PASPR' EQ '').TUINOUT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUINOUT   AIF ('&INOUT' EQ '').TUEXPDT\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUINOU#\n&NM.INOUT  DS  XL7                      LABEL=IN OR OUT\n           AGO .TUEXPDT\n.TUINOU#   AIF ('&INOUT' NE 'IN').TUINOU2\n&NM.INOUT  DC  AL2(DALINOUT,1,1),X'40'  LABEL=IN\n           AGO .TUEXPDT\n.TUINOU2   AIF ('&INOUT' NE 'OUT').TUEXPDT\n&NM.INOUT  DC  AL2(DALINOUT,1,1),X'80'  LABEL=OUT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUEXPDT   AIF ('&EXPDT' EQ '').TURETPD\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUEXPD#\n           DS  XL6\n&NM.EXPDT  DS  CL5                      EXPDT\n           AGO .TURETPD\n.TUEXPD#   DC  AL2(DALEXPDT,1,5)\n&NM.EXPDT  DC  CL5'&EXPDT'              EXPDT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURETPD   AIF ('&RETPD' EQ '').TUDUMMY\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURETP#\n           DS  XL6\n&NM.RETPD  DS  AL2                      RETPD\n           AGO .TUDUMMY\n.TURETP#   DC  AL2(DALRETPD,1,2)\n&NM.RETPD  DC  AL2(&RETPD)              RETPD\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUDUMMY   AIF ('&DUMMY' EQ '').TUFCBIM\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUDUMM#\n&NM.DUMMY  DS  XL4                      DD DUMMY / DSN=NULLFILE\n           AGO .TUFCBIM\n.TUDUMM#   ANOP\n&NM.DUMMY  DC  AL2(DALDUMMY,0)          DD DUMMY / DSN=NULLFILE\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUFCBIM   AIF ('&FCBIM' EQ '').TUFCBAV\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUFCBI#\n           DS  XL6\n&NM.FCBIM  DS  CL4                      FCB\n           AGO .TUFCBAV\n.TUFCBI#   DC  AL2(DALFCBIM,1,4)\n&NM.FCBIM  DC  CL4'&FCBIM'              FCB\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUFCBAV   AIF ('&FCBAV' EQ '').TUQNAME\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUFCBA#\n&NM.FCBAV  DS  XL7                      FCB VERIFY OR ALIGN\n           AGO .TUQNAME\n.TUFCBA#   AIF ('&FCBAV' NE 'VERIFY').TUFCBA2\n&NM.FCBAV  DC  AL2(DALFCBAV,1,1),X'04'  FCB VERIFY\n           AGO .TUQNAME\n.TUFCBA2   AIF ('&FCBAV' NE 'ALIGN').TUQNAME\n&NM.FCBAV  DC  AL2(DALFCBAV,1,1),X'08'  FCB ALIGN\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUQNAME   AIF ('&QNAME' EQ '').TUTERM\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUTERM    AIF ('&TERM' EQ '').TUUCS\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUTERMA\n&NM.TERM   DS  XL4                      TERM=TS / DSN(*)\n           AGO .TUUCS\n.TUTERMA   ANOP\n&NM.TERM   DC  AL2(DALTERM,0)           TERM=TS / DSN(*)\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUUCS     AIF ('&UCS' EQ '').TUUFOLD\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUUCSA\n           DS  XL6\n&NM.UCS    DS  CL4                      UCS CHARACTER SET\n           AGO .TUUFOLD\n.TUUCSA    DC  AL2(DALUCS,1,4)\n&NM.UCS    DC  CL4'&UCS'                UCS CHARACTER SET\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUUFOLD   AIF ('&UFOLD' EQ '').TUUVRFY\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUUFOL#\n&NM.UFOLD  DS  XL4                      UCS FOLD\n           AGO .TUUVRFY\n.TUUFOL#   ANOP\n&NM.UFOLD  DC  AL2(DALUFOLD,0)          UCS FOLD\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUUVRFY   AIF ('&UVRFY' EQ '').TUDCBDS\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUUVRF#\n&NM.UVRFY  DS  XL4                      UCS VERIFY\n           AGO .TUDCBDS\n.TUUVRF#   ANOP\n&NM.UVRFY  DC  AL2(DALUVRFY,0)          UCS VERIFY\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUDCBDS   AIF ('&DCBDS' EQ '').TUDCBDD\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUDCBS#\n           DS  XL6\n&NM.DCBDS  DS  CL44                     DCB REFERENCE TO DSN\n           AGO .TUDCBDD\n.TUDCBS#   DC  AL2(DALDCBDS,1,3)        DCB REFERENCE TO DSN (BELOW)\n&NM.DCBDS  DC  CL44'&DCBDS'\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUDCBDD   AIF ('&DCBDD' EQ '').TUSUSER\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUDCBD#\n           DS  XL6\n&NM.DCBDD  DS  CL8                      DCB REFERENCE TO DDNAME\n           AGO .TUSUSER\n.TUDCBD#   DC  AL2(DALDCBDD,1,8)\n&NM.DCBDD  DC  CL8'&DCBDD'              DCB REFERENCE TO DDNAME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSUSER   AIF ('&SUSER' EQ '').TUSHOLD\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUSUSE#\n           DS  XL6\n&NM.SUSER  DS  CL8                      SYSOUT DESTINATION\n           AGO .TUSHOLD\n.TUSUSE#   DC  AL2(DALSUSER,1,8)\n&NM.SUSER  DC  CL8'&SUSER'              SYSOUT DESTINATION\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSHOLD   AIF ('&SHOLD' EQ '').TUMSVGP\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUSHOL#\n&NM.SHOLD  DS  XL4                      SYSOUT HOLD=YES\n           AGO .TUMSVGP\n.TUSHOL#   ANOP\n&NM.SHOLD  DC  AL2(DALSHOLD,0)          SYSOUT HOLD=YES\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUMSVGP   AIF ('&MSVGP' EQ '').TUSSNM\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSSNM    AIF ('&SSNM' EQ '').TUSSPRM\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSSPRM   AIF ('&SSPRM' EQ '').TUPROT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUPROT    AIF ('&PROT' EQ '').TUBFALN\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.********************************************************************\n.**   DCB ATTRIBUTE TEXT UNITS - VERB CODE 01.                     **\n.********************************************************************\n.TUBFALN   AIF ('&BFALN' EQ '').TUBFTEK\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBFAL#\n&NM.BFALN  DS  XL7                      BFALN\n           AGO .TUBFTEK\n.TUBFAL#   AIF ('&BFALN' NE 'F').TUBFAL2\n&NM.BFALN  DC  AL2(DALBFALN,1,1),X'01'  BFALN=F\n           AGO .TUBFTEK\n.TUBFAL2   AIF ('&BFALN' NE 'D').TUBFTEK                        MI04303\n&NM.BFALN  DC  AL2(DALBFALN,1,1),X'02'  BFALN=D\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBFTEK   AIF ('&BFTEK' EQ '').TUBLKSZ\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBFTE#\n&NM.BFTEK  DS  XL7                      BFTEK\n           AGO .TUBLKSZ\n.TUBFTE#   AIF ('&BFTEK' NE 'D').TUBFTE2\n&NM.BFTEK  DC  AL2(DALBFTEK,1,1),X'08'  BFTEK=D\n           AGO .TUBLKSZ\n.TUBFTE2   AIF ('&BFTEK' NE 'E').TUBFTE3\n&NM.BFTEK  DC  AL2(DALBFTEK,1,1),X'10'  BFTEK=E\n           AGO .TUBLKSZ\n.TUBFTE3   AIF ('&BFTEK' NE 'R').TUBFTE4\n&NM.BFTEK  DC  AL2(DALBFTEK,1,1),X'20'  BFTEK=R\n           AGO .TUBLKSZ\n.TUBFTE4   AIF ('&BFTEK' NE 'S').TUBFTE5\n&NM.BFTEK  DC  AL2(DALBFTEK,1,1),X'40'  BFTEK=S\n           AGO .TUBLKSZ\n.TUBFTE5   AIF ('&BFTEK' NE 'A').TUBLKSZ\n&NM.BFTEK  DC  AL2(DALBFTEK,1,1),X'60'  BFTEK=A\n           AGO .TUBLKSZ\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBLKSZ   AIF ('&BLKSZ' EQ '').TUBUFIN\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBLKS#\n           DS  XL6\n&NM.BLKSZ  DS  AL2                      BLKSIZE\n           AGO .TUBUFIN\n.TUBLKS#   DC  AL2(DALBLKSZ,1,2)\n&NM.BLKSZ  DC  AL2(&BLKSZ)              BLKSIZE\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBUFIN   AIF ('&BUFIN' EQ '').TUBUFL\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBUFI#\n           DS  XL6\n&NM.BUFIN  DS  AL1                      BUFIN\n           AGO .TUBUFL\n.TUBUFI#   DC  AL2(DALBUFIN,1,1)\n&NM.BUFIN  DC  AL1(&BUFIN)              BUFIN\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBUFL    AIF ('&BUFL' EQ '').TUBUFMX\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBUFLA\n           DS  XL6\n&NM.BUFL   DC  AL2                      BUFL\n           AGO .TUBUFMX\n.TUBUFLA   DC  AL2(DALBUFL,1,2)\n&NM.BUFL   DC  AL2(&BUFL)               BUFL\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBUFMX   AIF ('&BUFMX' EQ '').TUBUFNO\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBUFM#\n           DS  XL6\n&NM.BUFMX  DS  AL1                      BUFMAX\n           AGO .TUBUFNO\n.TUBUFM#   DC  AL2(DALBUFMX,1,1)\n&NM.BUFMX  DC  AL1(&BUFMX)              BUFMAX\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBUFNO   AIF ('&BUFNO' EQ '').TUBUFOF\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBUFN#\n           DS  XL6\n&NM.BUFNO  DC  AL1                      BUFNO\n           AGO .TUBUFOF\n.TUBUFN#   DC  AL2(DALBUFNO,1,1)\n&NM.BUFNO  DC  AL1(&BUFNO)              BUFNO\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBUFOF   AIF ('&BUFOF' EQ '').TUBUFOU\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&BUFOF' NE 'L').TUBUFO2\n           AIF ('&MAP' NE 'ONLY').TUBUFF#\n&NM.BUFOF  DS  XL7                      BUFOFF=L\n           AGO .TUBUFOU\n.TUBUFF#   ANOP\n&NM.BUFOF  DC  AL2(DALBUFOF,1,1),X'80'  BUFOFF=L\n           AGO .TUBUFOU\n.TUBUFO2   AIF ('&MAP' NE 'ONLY').TUBUF##\n           DS  XL6\n&NM.BUFOF  DS  AL1                      BUFOFF\n           AGO .TUBUFOU\n.TUBUF##   DC  AL2(DALBUFOF,1,1)\n&NM.BUFOF  DC  AL1(&BUFOF)              BUFOFF\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBUFOU   AIF ('&BUFOU' EQ '').TUBUFRQ\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBUFO#\n           DS  XL6\n&NM.BUFOU  DS  AL1                      BUFOUT\n           AGO .TUBUFRQ\n.TUBUFO#   DC  AL2(DALBUFOU,1,1)\n&NM.BUFOU  DC  AL1(&BUFOU)              BUFOUT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBUFRQ   AIF ('&BUFRQ' EQ '').TUBUFSZ\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBUFR#\n           DS  XL6\n&NM.BUFRQ  DS  AL1                      BUFRQ\n           AGO .TUBUFSZ\n.TUBUFR#   DC  AL2(DALBUFRQ,1,1)\n&NM.BUFRQ  DC  AL1(&BUFRQ)              BUFRQ\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBUFSZ   AIF ('&BUFSZ' EQ '').TUCODE\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBUFS#\n           DS  XL6\n&NM.BUFSZ  DS  AL2                      BUFSIZE\n           AGO .TUCODE\n.TUBUFS#   DC  AL2(DALBUFSZ,1,2)\n&NM.BUFSZ  DC  AL2(&BUFSZ)              BUFSIZE\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUCODE    AIF ('&CODE' EQ '').TUCPRI\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUCPRI    AIF ('&CPRI' EQ '').TUDEN\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUDEN     AIF ('&DEN' EQ '').TUDSORG\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUDENA\n&NM.DEN    DS  XL7                      DEN\n           AGO .TUDSORG\n.TUDENA    AIF ('&DEN' NE '0').TUDE2\n&NM.DEN    DC  AL2(DALDEN,1,1),X'03'    DEN=0  (200 BPI, 7-TRACK)\n           AGO .TUDSORG\n.TUDE2     AIF ('&DEN' NE '1').TUDE3\n&NM.DEN    DC  AL2(DALDEN,1,1),X'43'    DEN=1  (556 BPI, 7-TRACK)\n           AGO .TUDSORG\n.TUDE3     AIF ('&DEN' NE '2').TUDE4\n&NM.DEN    DC  AL2(DALDEN,1,1),X'83'    DEN=2  (800 BPI, 7/9-TRACK)\n           AGO .TUDSORG\n.TUDE4     AIF ('&DEN' NE '3').TUDE5\n&NM.DEN    DC  AL2(DALDEN,1,1),X'C3'    DEN=3  (1600 BPI, 9-TRACK)\n           AGO .TUDSORG\n.TUDE5     AIF ('&DEN' NE '4').TUDSORG\n&NM.DEN    DC  AL2(DALDEN,1,1),X'D3'    DEN=4  (6250 BPI, 9-TRACK)\n           AGO .TUDSORG\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUDSORG   AIF ('&DSORG' EQ '').TUEROPT\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUDSOR#\n&NM.DSORG  DS  XL8                      DSORG\n           AGO .TUEROPT\n.TUDSOR#   AIF ('&DSORG' NE 'VS').TUDSOR2\n&NM.DSORG  DC  AL2(DALDSORG,1,2),X'0008'     DSORG=VS\n           AGO .TUEROPT\n.TUDSOR2   AIF ('&DSORG' NE 'TQ').TUDSOR3\n&NM.DSORG  DC  AL2(DALDSORG,1,2),X'0020'     DSORG=TQ\n           AGO .TUEROPT\n.TUDSOR3   AIF ('&DSORG' NE 'TX').TUDSOR4\n&NM.DSORG  DC  AL2(DALDSORG,1,2),X'0040'     DSORG=TX\n           AGO .TUEROPT\n.TUDSOR4   AIF ('&DSORG' NE 'GS').TUDSOR5\n&NM.DSORG  DC  AL2(DALDSORG,1,2),X'0080'     DSORG=GS\n           AGO .TUEROPT\n.TUDSOR5   AIF ('&DSORG' NE 'PO').TUDSOR6\n&NM.DSORG  DC  AL2(DALDSORG,1,2),X'0200'     DSORG=PO\n           AGO .TUEROPT\n.TUDSOR6   AIF ('&DSORG' NE 'POU').TUDSOR7\n&NM.DSORG  DC  AL2(DALDSORG,1,2),X'0300'     DSORG=POU\n           AGO .TUEROPT\n.TUDSOR7   AIF ('&DSORG' NE 'MQ').TUDSOR8\n&NM.DSORG  DC  AL2(DALDSORG,1,2),X'0400'     DSORG=MQ\n           AGO .TUEROPT\n.TUDSOR8   AIF ('&DSORG' NE 'CQ').TUDSOR9\n&NM.DSORG  DC  AL2(DALDSORG,1,2),X'0800'     DSORG=CQ\n           AGO .TUEROPT\n.TUDSOR9   AIF ('&DSORG' NE 'CX').TUDSORA\n&NM.DSORG  DC  AL2(DALDSORG,1,2),X'1000'     DSORG=CX\n           AGO .TUEROPT\n.TUDSORA   AIF ('&DSORG' NE 'DA').TUDSORB\n&NM.DSORG  DC  AL2(DALDSORG,1,2),X'2000'     DSORG=DA\n           AGO .TUEROPT\n.TUDSORB   AIF ('&DSORG' NE 'DAU').TUDSORC\n&NM.DSORG  DC  AL2(DALDSORG,1,2),X'2100'     DSORG=DAU\n           AGO .TUEROPT\n.TUDSORC   AIF ('&DSORG' NE 'PS').TUDSORD\n&NM.DSORG  DC  AL2(DALDSORG,1,2),X'4000'     DSORG=PS\n           AGO .TUEROPT\n.TUDSORD   AIF ('&DSORG' NE 'PSU').TUEROPT\n&NM.DSORG  DC  AL2(DALDSORG,1,2),X'4100'     DSORG=PSU\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUEROPT   AIF ('&EROPT' EQ '').TUGNCP\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUEROP#\n&NM.EROPT  DS  XL7                      EROPT\n           AGO .TUGNCP\n.TUEROP#   AIF ('&EROPT' NE 'T').TUEROP2\n&NM.EROPT  DC  AL2(DALEROPT,1,1),X'10'  EROPT=T\n           AGO .TUGNCP\n.TUEROP2   AIF ('&EROPT' NE 'ABE').TUEROP3\n&NM.EROPT  DC  AL2(DALEROPT,1,1),X'20'  EROPT=ABE\n           AGO .TUGNCP\n.TUEROP3   AIF ('&EROPT' NE 'SKP').TUEROP4\n&NM.EROPT  DC  AL2(DALEROPT,1,1),X'40'  EROPT=SKP\n           AGO .TUGNCP\n.TUEROP4   AIF ('&EROPT' NE 'ACC').TUGNCP\n&NM.EROPT  DC  AL2(DALEROPT,1,1),X'80'  EROPT=ACC\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUGNCP    AIF ('&GNCP' EQ '').TUINTVL\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUGNCPA\n           DS  XL6\n&NM.GNCP   DC  AL1                      GNCP\n           AGO .TUINTVL\n.TUGNCPA   DC  AL2(DALGNCP,1,1)                                MI04303\n&NM.GNCP   DC  AL1(&GNCP)               GNCP\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUINTVL   AIF ('&INTVL' EQ '').TUKYLEN\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUKYLEN   AIF ('&KYLEN' EQ '').TULIMCT\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUKYLE#\n           DS  XL6\n&NM.KYLEN  DS  AL1                      KEYLEN\n           AGO .TULIMCT\n.TUKYLE#   DC  AL2(DALKYLEN,1,1)\n&NM.KYLEN  DC  AL1(&KYLEN)              KEYLEN\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TULIMCT   AIF ('&LIMCT' EQ '').TULRECL\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TULRECL   AIF ('&LRECL' EQ '').TUMODE\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TULREC#\n           DS  XL6\n&NM.LRECL  DS  AL2                      LRECL\n           AGO .TUMODE\n.TULREC#   DC  AL2(DALLRECL,1,2)\n&NM.LRECL  DC  AL2(&LRECL)              LRECL\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUMODE    AIF ('&MODE' EQ '').TUNCP\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUNCP     AIF ('&NCP' EQ '').TUOPTCD\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUNCPA\n           DS  XL6\n&NM.NCP    DS  AL1                      NCP\n           AGO .TUOPTCD\n.TUNCPA    DC  AL2(DALNCP,1,1)\n&NM.NCP    DC  AL1(&NCP)                NCP\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUOPTCD   AIF ('&OPTCD' EQ '').TUPCIR\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUOPTC#\n&NM.OPTCD  DS  XL7                      OPTCD\n           AGO .TUPCIR\n.TUOPTC#   AIF ('&OPTCD' NE 'W').TUPCIR\n&NM.OPTCD  DC  AL2(DALOPTCD,1,1),X'80'  OPTCD=W\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUPCIR    AIF ('&PCIR' EQ '').TUPCIS\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUPCIS    AIF ('&PCIS' EQ '').TUPRTSP\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUPRTSP   AIF ('&PRTSP' EQ '').TURECFM\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUPRTS#\n&NM.PRTSP  DS  XL7                      PRTSP\n           AGO .TURECFM\n.TUPRTS#   AIF ('&PRTSP' NE '0').TUPRTS2\n&NM.PRTSP  DC  AL2(DALPRTSP,1,1),X'01'  PRTSP=0\n           AGO .TURECFM\n.TUPRTS2   AIF ('&PRTSP' NE '1').TUPRTS3\n&NM.PRTSP  DC  AL2(DALPRTSP,1,1),X'09'  PRTSP=1\n           AGO .TURECFM\n.TUPRTS3   AIF ('&PRTSP' NE '2').TUPRTS4\n&NM.PRTSP  DC  AL2(DALPRTSP,1,1),X'11'  PRTSP=2\n           AGO .TURECFM\n.TUPRTS4   AIF ('&PRTSP' NE '3').TURECFM\n&NM.PRTSP  DC  AL2(DALPRTSP,1,1),X'19'  PRTSP=3\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURECFM   AIF ('&RECFM' EQ '').TURSRVF\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURECF#\n&NM.RECFM  DS  XL7                      RECFM=F\n           AGO .TURSRVF\n.TURECF#   AIF ('&RECFM' NE 'F').TURECF2\n&NM.RECFM  DC  AL2(DALRECFM,1,1),X'80'  RECFM=F\n           AGO .TURSRVF\n.TURECF2   AIF ('&RECFM' NE 'FA').TURECF3\n&NM.RECFM  DC  AL2(DALRECFM,1,1),X'84'  RECFM=FA\n           AGO .TURSRVF\n.TURECF3   AIF ('&RECFM' NE 'FB').TURECF4\n&NM.RECFM  DC  AL2(DALRECFM,1,1),X'90'  RECFM=FB\n           AGO .TURSRVF\n.TURECF4   AIF ('&RECFM' NE 'FBA').TURECF5\n&NM.RECFM  DC  AL2(DALRECFM,1,1),X'94'  RECFM=FBA\n           AGO .TURSRVF\n.TURECF5   AIF ('&RECFM' NE 'V').TURECF6\n&NM.RECFM  DC  AL2(DALRECFM,1,1),X'40'  RECFM=V\n           AGO .TURSRVF\n.TURECF6   AIF ('&RECFM' NE 'VB').TURECF7\n&NM.RECFM  DC  AL2(DALRECFM,1,1),X'50'  RECFM=VB\n           AGO .TURSRVF\n.TURECF7   AIF ('&RECFM' NE 'U').TURSRVF\n&NM.RECFM  DC  AL2(DALRECFM,1,1),X'C0'  RECFM=U\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURSRVF   AIF ('&RSRVF' EQ '').TURSRVS\n.TURSRVS   AIF ('&RSRVS' EQ '').TUSOWA\n.TUSOWA    AIF ('&SOWA' EQ '').TUSTACK\n.TUSTACK   AIF ('&STACK' EQ '').TUTHRSH\n.TUTHRSH   AIF ('&THRSH' EQ '').TUTRTCH\n.TUTRTCH   AIF ('&TRTCH' EQ '').TUIPLTX\n.TUIPLTX   AIF ('&IPLTX' EQ '').TUDIAGN\n.TUDIAGN   AIF ('&DIAGN' EQ '').TUFUNC\n.TUFUNC    AIF ('&FUNC' EQ '').TUFRID\n.TUFRID    AIF ('&FRID' EQ '').TUPASSW\n.********************************************************************\n.**   NON-JCL DYNAMIC ALLOCATION FUNCTIONS - VERB CODE 01.         **\n.********************************************************************\n.TUPASSW   AIF ('&PASSW' EQ '').TUPERMA\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUPERMA   AIF ('&PERMA' EQ '').TUCNVRT\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUPERM#\n&NM.PERMA  DS  XL4                      PERMANENT ALLOCATION\n           AGO .TUCNVRT\n.TUPERM#   ANOP\n&NM.PERMA  DC  AL2(DALPERMA,0)          PERMANENT ALLOCATION\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUCNVRT   AIF ('&CNVRT' EQ '').TURTDDN\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUCNVR#\n&NM.CNVRT  DS  XL4                      CONVERTABLE ALLOCATION\n           AGO .TURTDDN\n.TUCNVR#   ANOP\n&NM.CNVRT  DC  AL2(DALCNVRT,0)          CONVERTABLE ALLOCATION\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTDDN   AIF ('&RTDDN' EQ '').TURTDSN\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTDD#\n           DS  XL4\n           DS  XL2                      LEN OF RETURNED DDNAME\n&NM.RTDDN  DS  CL8                      RETURNED DDNAME\n           AGO .TURTDSN\n.TURTDD#   DC  AL2(DALRTDDN,1)\n           DC  AL2(8)                   LEN OF RETURNED DDNAME\n&NM.RTDDN  DC  CL8' '                   RETURNED DDNAME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTDSN   AIF ('&RTDSN' EQ '').TURTORG\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTDS#\n           DS  XL4\n           DS  AL2                      LEN OF RETURNED DSNAME\n&NM.RTDSN  DS  CL44                     RETURNED DSNAME\n           AGO .TURTORG\n.TURTDS#   DC  AL2(DALRTDSN,1)\n           DC  AL2(44)                  LEN OF RETURNED DSNAME\n&NM.RTDSN  DC  CL44' '                  RETURNED DSNAME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTORG   AIF ('&RTORG' EQ '').TURTVOL\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTOR#\n           DS  XL6\n&NM.RTORG  DS  XL2                      RETURNED DSORG\n           AGO .TURTVOL\n.TURTOR#   DC  AL2(DALRTORG,1,2)\n&NM.RTORG  DC  AL2(0)                   RETURNED DSORG\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTVOL   AIF ('&RTVOL' EQ '').TUREMOV\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTVO#\n           DS  XL4\n           DS  XL2                      LEN OF RETURNED VOLSER\n&NM.RTVOL  DS  CL6                      RETURNED VOLSER\n           AGO .TUREMOV\n.TURTVO#   DC  AL2(DALRTVOL,1)\n           DC  AL2(6)                   LEN OF RETURNED VOLSER\n&NM.RTVOL  DC  CL6' '                   RETURNED VOLSER\n.********************************************************************\n.**   UNALLOCATE - VERB CODE 02.                                   **\n.********************************************************************\n.TUREMOV   AIF ('&REMOV' EQ '').TUUNALC\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUREMO#\n&NM.REMOV  DS  XL4                      REMOVE INUSE EVEN IF PERMANENT\n           AGO .TUUNALC\n.TUREMO#   ANOP\n&NM.REMOV  DC  AL2(DUNREMOV,0)          REMOVE INUSE EVEN IF PERMANENT\n.*\n.TUUNALC   AIF ('&UNALC' EQ '').TUTCBAD\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUUNAL#\n&NM.UNALC  DS  XL4                      UNALLOCATE EVEN IF PERMANENT\n           AGO .TUTCBAD\n.TUUNAL#   ANOP\n&NM.UNALC  DC  AL2(DUNUNALC,0)          UNALLOCATE EVEN IF PERMANENT\n.********************************************************************\n.**   REMOVE IN-USE ATTRIBUTE - VERB CODE 05.                      **\n.********************************************************************\n.TUTCBAD   AIF ('&TCBAD' EQ '').TUINDDN\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUTCBA#\n           DS  XL6\n&NM.TCBAD  DS  XL4                      TCB ADDRESS\n           AGO .TUINDDN\n.TUTCBA#   DC  AL2(DRITCBAD,1,4)\n&NM.TCBAD  Dc  AL4(0)                   TCB ADDRESS\n.********************************************************************\n.**   RETURN INFORMATION - VERB CODE 07.                           **\n.********************************************************************\n.TUINDDN   AIF ('&INDDN' EQ '').TUINDSN\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUINDD#\n           DS  XL4\n           DS  XL2                      LEN OF RETURNED DDNAME\n&NM.INDDN  DS  CL8                      RETURNED DDNAME\n           AGO .TUINDSN\n.TUINDD#   DC  AL2(DINRTDDN,1)\n           DC  AL2(8)                   LEN OF RETURNED DDNAME\n&NM.INDDN  DC  CL8' '                   RETURNED DDNAME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUINDSN   AIF ('&INDSN' EQ '').TUINORG\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUINDS#\n           DS  XL4\n           DS  AL2                      LEN OF RETURNED DSNAME\n&NM.INDSN  DS  CL44                     RETURNED DSNAME\n           AGO .TUINORG\n.TUINDS#   DC  AL2(DINRTDSN,1)\n           DC  AL2(44)                  LEN OF RETURNED DSNAME\n&NM.INDSN  DC  CL44' '                  RETURNED DSNAME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUINORG   AIF ('&INORG' EQ '').TURTMEM\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUINOR#\n           DS  XL6\n&NM.INORG  DS  XL2                      RETURNED DSORG\n           AGO .TURTMEM\n.TUINOR#   DC  AL2(DINRTORG,1,2)\n&NM.INORG  DC  XL2'0'                   RETURNED DSORG\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTMEM   AIF ('&RTMEM' EQ '').TURTSTA\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTME#\n           DS  XL6\n&NM.RTMEM  DS  CL8                      RETURNED MEMBER NAME\n           AGO .TURTSTA\n.TURTME#   DC  AL2(DINRTMEM,1,8)\n&NM.RTMEM  DC  CL8' '                   RETURNED MEMBER NAME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTSTA   AIF ('&RTSTA' EQ '').TURTNDP\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTST#\n           DS  XL6\n&NM.RTSTA  DS  XL1                      RETURNED DATASET STATUS\n           AGO .TURTNDP\n.TURTST#   DC  AL2(DINRTSTA,1,1)\n&NM.RTSTA  DC  XL1'0'                   RETURNED DATASET STATUS\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTNDP   AIF ('&RTNDP' EQ '').TURTCDP\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTND#\n           DS  XL6\n&NM.RTNDP  DS  XL1                      RETURNED NORMAL DISP\n           AGO .TURTCDP\n.TURTND#   DC  AL2(DINRTNDP,1,1)\n&NM.RTNDP  DC  XL1'0'                   RETURNED NORMAL DISP\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTCDP   AIF ('&RTCDP' EQ '').TURTLIM\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTCD#\n           DS  XL6\n&NM.RTCDP  DS  XL1                      RETURNED CONDITIONAL DISP\n           AGO .TURTLIM\n.TURTCD#   DC  AL2(DINRTCDP,1,1)\n&NM.RTCDP  DC  XL1'0'                   RETURNED CONDITIONAL DISP\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTLIM   AIF ('&RTLIM' EQ '').TURTATT\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTLI#\n           DS  XL6\n&NM.RTLIM  DS  XL2                      RETURNED LIMIT SPECIFICATION\n           AGO .TURTATT\n.TURTLI#   DC  AL2(DINRTLIM,1,2)\n&NM.RTLIM  Dc  XL2'0'                   RETURNED LIMIT SPECIFICATION\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTATT   AIF ('&RTATT' EQ '').TURTLST\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTAT#\n           DS  XL6\n&NM.RTATT  DS  XL1                      RETURNED D.A. ATTRIBUTE\n           AGO .TURTLST\n.TURTAT#   DC  AL2(DINRTATT,1,1)\n&NM.RTATT  DC  XL1'0'                   RETURNED D.A. ATTRIBUTE\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTLST   AIF ('&RTLST' EQ '').TURTTYP\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTLS#\n           DS  XL6\n&NM.RTLST  DS  XL1                      RETURNED LAST ENTRY SPEC.\n           AGO .TURTTYP\n.TURTLS#   DC  AL2(DINRTLST,1,1)\n&NM.RTLST  DC  XL1'0'                   RETURNED LAST ENTRY SPEC.\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTTYP   AIF ('&RTTYP' EQ '').TURELNO\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTTY#\n           DS  XL6\n&NM.RTTYP  DS  XL1                      RETURNED DATASET TYPE\n           AGO .TURELNO\n.TURTTY#   DC  AL2(DINRTTYP,1,1)\n&NM.RTTYP  DC  XL1'0'                   RETURNED DATASET TYPE\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURELNO   AIF ('&RELNO' EQ '').TUENDM\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURELN#\n           DS  XL6\n&NM.RELNO  DS  XL2                      RETURNED RELATIVE REQUEST NO.\n           AGO .TUENDM\n.TURELN#   DC  AL2(DINRELNO,1,2)\n&NM.RELNO  DC  XL2'0'                   RETURNED RELATIVE REQUEST NO.\n.********************************************************************\n.**   MARK END OF LIST OF TEXT UNITS.                              **\n.********************************************************************\n.TUENDM    AIF ('&MAP' NE 'ONLY').TUENDU#\n           DS  XL1                      END OF LIST MARKER\n           AGO .TUEND\n.TUENDU#   ANOP\n           DC  XL1'FF'                  END OF LIST MARKER\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUEND     ANOP\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n***   REQUEST BLOCKS FOR SVC99.                                     ***\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n&NM.RBP    DS  A                        POINTER TO REQUEST BLOCK\n&NM.RB     DS  5A                       REQUEST BLOCK\n&NM.TUPL   DS  &TUPLEN.A                TEXT UNIT POINTER LIST\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n***   DAIRFAIL PARAMETER BLOCK & MISCELLANEOUS STORAGE.             ***\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n&NM.DFPRM  DS  6F                       PARM BLOCK FOR IKJEFF18\n&NM.S99RC  DS  F                        STORAGE AREA FOR SVC 99 R/C\n           AIF ('&MAP' NE 'ONLY').DF2\n&NM.F02EP  DS  F                        STORGE AREA FOR EP OF IKJEFF18\n&NM.ID     DS  XL2                      DAIRFAIL SWITCHES & CALLER ID\n           AGO .DF3\n.DF2       ANOP\n&NM.F02EP  DC  F'0'                     STORGE AREA FOR EP OF IKJEFF18\n&NM.ID     DC  X'0032'                  DAIRFAIL SWITCHES & CALLER ID\n.DF3       ANOP\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n***   EQUATE FOR TOTAL LENGTH.                                      ***\n*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ***\n           DS  0D                       ALIGN FOR GETMAIN\n&NM.LEN    EQU *-&NM                    TOTAL LENGTH\n           MEND\n         MACRO\n&CSNAME  LINKSAVE &BASE=,&GETMAIN=NO,&GETAMT=136\n.*********************************************************************\n.*  MACRO FOR STANDARD LINKAGE CONVENTIONS AT PROGRAM ENTRY.       ***\n.*  USED IN CONJUNCTION WITH THE LINKBACK MACRO.                   ***\n.*                                                                 ***\n.*  BASE=NN     REGISTER NUMBER OF BASE REGISTER.                  ***\n.*                                                                 ***\n.*  GETMAIN=YES WILL DO A GETMAIN FOR STORAGE SPACE. THIS          ***\n.*              STORAGE WILL BE POINTED TO BY R13, AND WILL BE     ***\n.*              FREED AUTOMATICALLY BY THE LINKBACK MACRO.         ***\n.*                                                                 ***\n.*  GETAMT=NNNN (VALID ONLY IF GETMAIN=YES) DEFAULT AMOUNT OF      ***\n.*              SPACE OBTAINED WILL BE 72 BYTES FOR SAVE AREA,     ***\n.*              PLUS 64 BYTES FOR PROGRAMMER'S USE. R13 WILL BE    ***\n.*              THE BASE ADDRESS OF THE STORAGE AREA. THIS         ***\n.*              AMOUNT WILL BE FREED BY THE LINKBACK MACRO.        ***\n.*                                                                 ***\n.*  CHUCK HOFFMAN, SYSTEMS PROGRAMMING, GTEL COMPUTING CENTER      ***\n.*********************************************************************\n         GBLC  &GMN,&GAMT\n         LCLA  &C,&D\n&GAMT    SETC  '&GETAMT'\n&GMN     SETC  '&GETMAIN'\n         AIF   ('&GMN' EQ 'YES').FORM2\n&CSNAME  CSECT\n&C       SETA  K'&CSNAME\n&D       SETA  ((20+&C)/2)*2\n         B     &D.(0,15)           BRANCH AROUND ID\n         DC    AL1(&C)             LENGTH\n         DC    CL&C'&CSNAME'       ID\n         DC    CL8'&SYSDATE'       SYSTEM DATE MM/DD/YY\n         DC    CL6' &SYSTIME'      SYSTEM TIME HH.MM\n         STM   14,12,12(13)        SAVE R0-R12, R14-R15\n         LR    &BASE,15            LOAD BASE ADDRESS\n         USING &CSNAME,&BASE       ASSIGN BASE REGISTER\n         ST    13,MYSV&SYSNDX+4    STORE ADDR OF PREV SAVE AREA\n*                                    INTO MY SAVE AREA\n         LA    14,MYSV&SYSNDX      LOAD ADDR OF MY SAVE AREA\n         ST    14,8(0,13)          STORE IT INTO PREV SAVE AREA\n         LR    13,14               ALSO LOAD IT INTO R13\n         B     MYSV&SYSNDX+72      BRANCH AROUND MY SAVE AREA\nMYSV&SYSNDX DC 18F'0'              MY SAVE AREA\n         MEXIT\n.FORM2   ANOP\n&CSNAME  CSECT\n&C       SETA  K'&CSNAME\n&D       SETA  ((20+&C)/2)*2\n         B     &D.(0,15)           BRANCH AROUND ID\n         DC    AL1(&C)             LENGTH\n         DC    CL&C'&CSNAME'       ID\n         DC    CL8'&SYSDATE'       SYSTEM DATE MM/DD/YY\n         DC    CL6' &SYSTIME'      SYSTEM TIME HH.MM\n         STM   14,12,12(13)        SAVE R0-R12, R14-R15\n         LR    &BASE,15            LOAD BASE ADDRESS\n         USING &CSNAME,&BASE       ASSIGN BASE REGISTER\n        GETMAIN R,LV=&GETAMT       GET STORAGE FOR S.A. + WORK\n         ST    13,4(0,1)           STORE ADDR OF PREV SAVE AREA\n*                                    INTO MY SAVE AREA\n         ST    1,8(0,13)           ADDR OF MY SA TO PREV SAVE AREA\n         LM    0,1,20(13)          RESTORE R0-R1 TO ORIGINAL VALUE\n         L     13,8(0,13)          POINT R13 TO MY SAVE AREA\n         MEND\n         MACRO\n&ENDNAME LINKBACK &RCADDR=\n.*********************************************************************\n.*  MACRO FOR STANDARD LINKAGE CONVENTIONS AT PROGRAM EXIT.        ***\n.*  USED IN CONJUNCTION WITH THE LINKSAVE MACRO.                   ***\n.*                                                                 ***\n.*  RCADDR=NAME   NAME OF FULLWORD RETURN CODE TO BE LOADED        ***\n.*                INTO R15. IF THIS OPERAND IS NOT USED, THE       ***\n.*                RETURN CODE WILL BE THE VALUE CONTAINED IN R15   ***\n.*                JUST PRIOR TO ENTERING THE CODE GENERATED BY     ***\n.*                THIS MACRO.                                      ***\n.*                                                                 ***\n.* NOTE -                                                          ***\n.*  IF GETMAIN=YES WAS USED WITH LINKSAVE, THIS MACRO WILL         ***\n.*  FREEMAIN THE STORAGE AREA WHICH LINKSAVE GOTMAINED.            ***\n.*                                                                 ***\n.*  CHUCK HOFFMAN, SYSTEMS PROGRAMMING, GTEL COMPUTING CENTER      ***\n.*********************************************************************\n         GBLC  &GMN,&GAMT\n         LCLA  &RCLEN\n&RCLEN   SETA  K'&RCADDR           LENGTH OF NAME OF RETURN CODE\n         AIF ('&GMN' EQ 'YES').FORM2   IF LINKSAVE USED A GETMAIN, GO\n&ENDNAME L     13,4(0,13)          RESTORE R13 FROM MY SAVE AREA\n         AIF (&RCLEN EQ 0).FORM1A\n         L     15,&RCADDR          SET RETURN CODE\n.FORM1A  LM    0,12,20(13)         RESTORE R0-12\n         L     14,12(0,13)         RESTORE R14\n         MVI   12(13),X'FF'        RETURN INDICATOR\n         BR    14                  RETURN TO CALLING PROGRAM\n         MEXIT\n.FORM2   ANOP\n&ENDNAME LR    1,13                COPY MY SA ADDR FOR FREEMAIN\n         AIF (K'&RCADDR EQ 0).FORM2C\n         L     14,&RCADDR          SAVE RETURN CODE\n         AGO .FORM2A\n.FORM2C  LR    14,15               SAVE RETURN CODE\n.FORM2A  L     13,4(0,13)          RESTORE R13 FROM MY SAVE AREA\n        FREEMAIN R,LV=&GAMT,A=(1)  FREE STORAGE\n         LR    15,14               SET RETURN ADDRESS\n.FORM2B  LM    0,12,20(13)         RESTORE R0-12\n         L     14,12(0,13)         RESTORE R14\n         MVI   12(13),X'FF'        RETURN INDICATOR\n         BR    14                  RETURN TO CALLING PROGRAM\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HEL": {"ttr": 19460, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x04\\x0f\\x00\\x90\\x04\\x0f\\x12\\x02\\x0f=\\x0f=\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-02-09T00:00:00", "modifydate": "1990-02-09T12:02:00", "lines": 3901, "newlines": 3901, "modlines": 0, "user": "SYSPAJA"}, "text": "HEL      TITLE 'H E L -- A FULL-SCREEN HELP COMMAND.'\n***********************************************************************\n*                                                                     *\n*        HEL - TSO COMMAND FOR DISPLAYING A HELP MEMBER               *\n*              ON A 3270 DISPLAY STATION SCREEN                       *\n*                                                                     *\n*        WRITTEN BY A. BRUCE LELAND AT HITACHI AMERICA, LTD.          *\n*                ON JUNE 18, 1984                                     *\n*                                                                     *\n*                                                                     *\n* PLEASE REPORT ANY PROBLEMS, ENHANCEMENTS, SUGGESTIONS OR COMMENTS   *\n* CONCERNING THE HEL COMMAND TO BRUCE LELAND AT:                      *\n*                                                                     *\n*     HITACHI AMERICA, LTD.    OR          6084 CRIMSON DRIVE         *\n*     2210 O'TOOLE AVENUE                  SAN JOSE, CALIF 95120      *\n*     SAN JOSE, CALIF. 95131                                          *\n*     (408) 435-2143                       (408) 997-2366             *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* BASED ON THE REVIEW COMMAND:                                        *\n*        WRITTEN BY. BILL GODFREY, PRC (PLANNING RESEARCH CORPORATION)*\n*        INSTALLATION. AIR FORCE DATA SERVICES CENTER, PENTAGON.      *\n*        DATE WRITTEN. JANUARY 19 1981.                               *\n*        DATE UPDATED. MARCH 18 1982.                                 *\n*        ATTRIBUTES. RE-ENTRANT.                                      *\n*        LOCAL MACROS USED. DCS. (DEFINE CONSTANTS FOR SCREEN).       *\n*        DESCRIPTION.                                                 *\n*         THIS TSO COMMAND DISPLAYS A DATA-SET ON A 3270 TERMINAL     *\n*         IN FULLSCREEN MODE.                                         *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* IBM HELP MODULE INTERFACE:                                          *\n*                                                                     *\n*   HEL WILL PASS CONTROL TO THE IBM HELP COMMAND (&IBMHELP) IN       *\n*   ANY OF THE FOLLOWING SITUATIONS:                                  *\n*     . THE TERMINAL HAS LESS THAN 24 LINES.                          *\n*     . THE TERMINAL SCREEN IS NOT 80 CHARACTERS WIDE.                *\n*     . THE XCTL TESTING SUBCOMMAND IS ENTERED.                       *\n*     . THE MSG OPERAND IS USED.                                      *\n*     . THE POSIT OPERAND IS USED (FOR TSO/E PARSE HELP).             *\n*     . THE SUBCOMMAND IS NOT H OR HELP (FOR TSO/E PARSE HELP).       *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* NAMING RESTRICTION:                                                 *\n*                                                                     *\n*   DUE TO THE METHOD USED TO INVOKE HELP COMMANDS AND THE USE OF     *\n*   THE ECTPCMD AND ECTSCMD FIELDS, THIS COMMAND MUST BE NAMED AS     *\n*   H OR ANY NAME BEGINNING WITH THE LETTERS HE.                      *\n*                                                                     *\n***********************************************************************\n          EJECT\n***********************************************************************\n*                                                                     *\n* INSTALLATION CONSIDERATIONS:                                        *\n*                                                                     *\n*   THIS COMMAND MAY BE INSTALLED WITH OR WITHOUT ALIASES             *\n*   (HELP AND/OR H) AS FOLLOWS:                                       *\n*                                                                     *\n*     1.  TO INSTALL THIS COMMAND WITH NO ALIASES, THE FOLLOWING      *\n*         STEPS ARE RECOMMENDED:                                      *\n*         A.  EDIT THIS MEMBER, INSURING &IBMHELP IS SET TO 'H'       *\n*         B.  ASSEMBLE AND LINK HEL INTO ANY LINKLIST LIBRARY         *\n*                                                                     *\n*     2.  TO INSTALL THIS COMMAND WITH AN ALIAS OF HELP, THE          *\n*         FOLLOWING STEPS ARE RECOMMENDED:                            *\n*         A.  EDIT THIS MEMBER, INSURING &IBMHELP IS SET TO 'H'       *\n*         B.  ASSEMBLE AND LINK HEL INTO A LINKLIST LIBRARY           *\n*             IN FRONT OF 'SYS1.CMDLIB' ('SYS1.LINKLIB'?)             *\n*         C.  USING THE PDS COMMAND IN THIS LINKLIST LIBRARY,         *\n*             ENTER:  ALIAS HEL HELP                                  *\n*                                                                     *\n*     3.  TO INSTALL THIS COMMAND WITH AN ALIAS OF H, THE             *\n*         FOLLOWING STEPS ARE RECOMMENDED:                            *\n*         A.  EDIT THIS MEMBER, CHANGING &IBMHELP TO 'HELP'           *\n*         B.  ASSEMBLE AND LINK HEL INTO A LINKLIST LIBRARY           *\n*             IN FRONT OF 'SYS1.CMDLIB' ('SYS1.LINKLIB'?)             *\n*         C.  USING THE PDS COMMAND IN THIS LINKLIST LIBRARY,         *\n*             ENTER:  ALIAS HEL H                                     *\n*                                                                     *\n*     4.  TO INSTALL THIS COMMAND WITH ALIASES HELP AND H, THE        *\n*         FOLLOWING STEPS ARE RECOMMENDED:                            *\n*         A.  EDIT THIS MEMBER, CHANGING &IBMHELP TO 'HELPOLD'        *\n*         B.  ASSEMBLE AND LINK HEL INTO A LINKLIST LIBRARY           *\n*             IN FRONT OF 'SYS1.CMDLIB' ('SYS1.LINKLIB'?)             *\n*         C.  USING THE PDS COMMAND IN THIS LINKLIST LIBRARY,         *\n*             ENTER:  ALIAS HEL H                                     *\n*                     ALIAS HEL HELP                                  *\n*         D.  USING THE PDS COMMAND IN 'SYS1.CMDLIB', ENTER:          *\n*             ALIAS  HELP HELPOLD                                     *\n*             NOTE: THIS STEP SHOULD BE REDONE AFTER ANY              *\n*                   SYSTEM MAINTENANCE TO THE HELP COMMAND.           *\n*                                                                     *\n*                                                                     *\n*   SINCE MOST MVS SYSTEMS HAVE A BLDL FOR MEMBER NAMES H AND HELP,   *\n*   ANY ASSIGNED ALIAS(ES) CAN NOT BE TESTED UNTIL AN IPL HAS BEEN    *\n*   COMPLETED.                                                        *\n*                                                                     *\n*   THE COMMAND NAME HELP IS USED BY ACCOUNT, EDIT, OPER, REVIEW AND  *\n*   SUBCOMMAND PARSE FOR TSO/E; THE COMMAND NAME H IS USED BY EDIT;   *\n*   AND THE COMMAND NAME HEL IS USED BY PDS AND HEL ITSELF.           *\n*                                                                     *\n***********************************************************************\n          EJECT\n***********************************************************************\n*                                                                     *\n*   LOG OF CHANGES.                                                   *\n*         27MAR81 - ALLOW PFK DEFINITIONS TO BE CHANGED.              *\n*         10JUL81 - IKJRLSA SOON AFTER PARSE.                         *\n*                   FIXED BUG OF IKJEFF18 BEING CALLED TWICE.         *\n*                   MISCELLANEOUS INTERNAL RESTRUCTURING OF CODE TO   *\n*                   TO ALLOW FUTURE CHANGES. OLD CODE HAD USED UP     *\n*                   ALL 3 BASE REGISTERS.                             *\n*         14JUL81 - HEX SUBCOMMAND WITHOUT OPERANDS WILL FLIP-FLOP    *\n*                   BETWEEN HEX ON AND HEX OFF. PFK9 IS NOW HEX       *\n*                   INSTEAD OF HEX ON. PFK12 IS NO LONGER HEX OFF.    *\n*         29SEP81 - ACCEPT PFK 13-24 CORRESPONDING TO 1-12.           *\n*         29JAN82 - SET UP IOPL BEFORE DOING GTSIZE/ERRTERM.          *\n*         29JAN82 - ALLOW MEMBER TO BE SPECIFIED WITH DDNAME, SO USER *\n*                   CAN DO THINGS LIKE REVIEW SYSPROC(MEMBER) FILE    *\n*                   (AND SHOW DDNAME+NNN IF CONCATENATED).            *\n*                   REPLACE 'POINT' WITH 'FIND' TO SUPPORT            *\n*                   CONCATENATED PDS'S.                               *\n*                                                                     *\n*         21MAY84 - CONVERTED REVIEW TO DO FULL-SCREEN HELP FUNCTIONS *\n*                 - ADDED SUBCOM SUBCOMMAND                           *\n*                 - ADDED HELP SUBCOMMAND AND CHANGED PFK 1 DEFAULT   *\n*                 - ADDED TSO SUBCOMMAND                              *\n*                 - ADDED F1 SUBCOMMAND FOR SUBCOMMAND POSITIONING    *\n*                 - ADDED M SUBCOMMAND FOR USE WITH PFK'S             *\n*                 - MODIFIED FIND TO REPOSITION THE SCREEN            *\n*                 - CHANGED DEFAULT TRANSLATION TO ASIS               *\n*                 - DELETED SMF PROCESSING                            *\n*                 - MODIFIED DEBUG TO OUTPUT THE LAST TGET INFO       *\n*                 - MODIFIED THE SCREEN HEADER FOR FOUR INPUT FIELDS  *\n*                 - MODIFIED BLANK ROUTINE TO CLEAR LAST SCREEN BYTE  *\n*                 - MODIFIED FOR TERMINALS WITH MORE THAN 24 LINES    *\n*                                                                     *\n*                                                                     *\n*         11JUL84 - TSO SUBCOMMAND: IF QUOTED, BACK UP ONE CHARACTER  *\n*                 - TSO SUBCOMMAND: TURN FULLSCREEN OFF AND ON AGAIN  *\n*                                                                     *\n*         20NOV84 - ADDED SUPPORT FOR 3278-3, 3278-4 AND 3278-5       *\n*                 - CHANGED DEFAULT PF KEYS (PF2 AND PF4)             *\n*                                                                     *\n*         06JAN85 - CHANGED 3278-5 SUPPORT TO PERFORM A STSIZE MACRO  *\n*                 - DUE TO SPF INTERFACE ERRORS.                      *\n*                                                                     *\n*         08APR85 - CHANGED 3278-5 SUPPORT TO ALWAYS PERFORM A WRITE  *\n*                 - ALTERNATE IF A WRITE WAS PERFORMED.               *\n*                                                                     *\n*         19SEP85 - MODIFIED PFK SUPPORT TO NOT BLANK THE TOP LINE    *\n*                 - OF THE DISPLAY WHEN PFK12 IS SET.                 *\n*                                                                     *\n***********************************************************************\n          EJECT\n*=====================================================================*\n*                                                                     *\n*   EXTRACTED FROM THE CBT 89 FEB TAPE, FILE 296.                     *\n*   CHANGES MADE BY MOINIL P.A.                                       *\n*         31JAN90 - ALL PFK DEFINITIONS MOVED IN A SEPARATE MODULE    *\n*                   TO ALLOW THE USE OF UPPER-LOWER CASE CHARACTERS.  *\n*         01FEB90 - NOW THE PFK DEFINITIONS CHANGES ARE REFLECTED     *\n*                   IN THE HELP SCREEN.                               *\n*         02FEB90 - SNAP SUBCOMMAND RESTORED (USE DD-NAME 'SYSSNAP'   *\n*                   WHICH MUST BE PRE-ALLOCATED).                     *\n*                 - NEW CSECT 'HELEXT' CREATED TO EXTENT THE BASE     *\n*                   REGISTERS USE OF CSECT 'HELXEQ'.                  *\n*         07FEB90 - ADJUST THE SET UP OF THE HEXADECIMAL COLUMN       *\n*                   HEADER DISPLAY.                                   *\n*         08FEB90 - AFTER HELP MESSAGES DISPLAY INTERPRET THE END     *\n*                   COMMAND AS A REFRESH (ENTER) AND NOT AS EXIT.     *\n*   INSTALLED AT OUR SITE AS EXPLAINED IN NOTE 1 OF 'INSTALLATION     *\n*                   CONSIDERATIONS' (SEE ABOVE).                      *\n*                                                                     *\n*=====================================================================*\n         EJECT\n***********************************************************************\n*\n*         SYNTAX -   HEL COMMAND\n*\n*         THE SCREEN WILL NORMALLY CONTAIN 20 RECORDS, ONE PER LINE,\n*         80 CHARACTERS PER LINE.\n*\n*      SUBCOMMANDS :\n*         ASIS     - LEAVE LOWER CASE LETTERS IN LOWER CASE\n*         BOTTOM   - DISPLAY THE LAST RECORDS\n*         CAPS     - TRANSLATE LOWER CASE LETTERS TO CAPS\n*         COMMAND  - DISPLAY A DIFFERENT HELP COMMAND\n*         DOWN     - DISPLAY RECORDS BELOW THOSE ON THE SCREEN\n*         END      - END THE COMMAND\n*         FIND     - DISPLAY A RECORD CONTAINING A SPECIFIED STRING\n*         HELP     - DISPLAY HELP INFORMATION\n*         HEX      - SWITCH HEXADECIMAL FORMATTING ON/OFF.\n*         LEFT     - DISPLAY DATA TO THE LEFT\n*         LIST     - DISPLAY A SPECIFIED RECORD NUMBER\n*         MEMBER   - DISPLAY A DIFFERENT HELP COMMAND\n*         PFKNN    - CHANGE DEFINITION OF PF KEY NN.\n*         RIGHT    - DISPLAY DATA TO THE RIGHT\n*         SUBCOM   - DISPLAY A SUBCOMMAND OF THE CURRENT MEMBER\n*         TOP      - DISPLAY THE FIRST RECORDS\n*         TSO      - ISSUE A TSO COMMAND\n*         UP       - DISPLAY RECORDS ABOVE THOSE ON THE SCREEN\n*\n*         WHEN 'UP' OR 'DOWN' DOES NOT SPECIFY HOW FAR UP OR DOWN,\n*         THE 'RANGE' VALUE IS USED.  THIS VALUE IS ALWAYS DISPLAYED\n*         NEAR THE TOP OF THE SCREEN AND CAN BE CHANGED BY MOVING\n*         THE CURSOR OVER THE VALUE AND TYPING IN A NEW VALUE.\n*         THE NEW VALUE WILL REMAIN IN EFFECT UNTIL THE COMMAND\n*         ENDS OR UNTIL YOU CHANGE IT AGAIN.\n*\n*\n*\n***********************************************************************\n         EJECT\n***********************************************************************\n*\n*         PROGRAM FUNCTION KEYS\n*\n*         SOME OF THE SUBCOMMANDS DO NOT HAVE TO BE TYPED IN\n*         IF THE TERMINAL IS EQUIPPED WITH PROGRAM FUNCTION KEYS.\n*         FOR EXAMPLE, HITTING KEY 'PF8' IS EQUIVALENT TO\n*         TYPING IN 'DOWN' AND HITTING THE 'ENTER' KEY.\n*\n*         HERE ARE THE MEANINGS ASSIGNED TO EACH PF KEY.\n*\n*         ----------------------------------------------------\n*         I                I                I                I\n*         I      PF1       I      PF2       I      PF3       I\n*         I                I                I                I\n*         I      HELP      I                I      END       I\n*         I                I                I                I\n*         ----------------------------------------------------\n*         I                I                I                I\n*         I      PF4       I      PF5       I      PF6       I\n*         I                I                I                I\n*         I      END       I      FIND      I                I\n*         I                I                I                I\n*         ----------------------------------------------------\n*         I                I                I                I\n*         I      PF7       I      PF8       I      PF9       I\n*         I                I                I                I\n*         I      UP        I      DOWN      I      HEX       I\n*         I                I                I                I\n*         ----------------------------------------------------\n*         I                I                I                I\n*         I      PF10      I      PF11      I      PF12      I\n*         I                I                I                I\n*         I      LEFT      I      RIGHT     I                I\n*         I                I                I                I\n*         ----------------------------------------------------\n*\n*         THE SCREEN IS WRITTEN USING THE 'EXPANDED FULLSCREEN'\n*         (EXPFLS=YES) FEATURE OF TCAM, WHICH REQUIRES THAT THE\n*         FIRST ORDER IN THE BUFFER BE 'SBA,24,80' OR 'SBA,24,79'.\n*         THE FIRST IS USED TO SUPPRESS LINE COUNTING, AND THE\n*         LATTER IS USED TO RESET THE LINE COUNTER.\n*\n***********************************************************************\n         EJECT\n         PRINT OFF\n         MACRO\n&NAME    MSG   &MSG\n&NAME    DC    AL2(&NAME.L-2),C&MSG\n&NAME.L  EQU   *-&NAME\n         MEND\n         MACRO\n&NAME    DCS\n.**********************************************************************\n.*                                                                    *\n.*        DCS  -  DEFINE CONSTANT FOR SCREEN                          *\n.*                                                                    *\n.*        WRITTEN BY BILL GODFREY                                     *\n.*        PLANNING RESEARCH CORPORATION                               *\n.*        PRC COMPUTER CENTER, MCLEAN VA 22101                        *\n.*        DATE WRITTEN. JANUARY 8 1981.                               *\n.*        DATE UPDATED. MARCH 18 1982. (ROW AND COL IN PARENS)        *\n.*                                                                    *\n.*        THIS MACRO IS USED FOR CODING A FULLSCREEN 3270 DISPLAY.    *\n.*                                                                    *\n.*        SAMPLE                                                      *\n.*           DCS    AL1(WCC),SBA,(1,1),RTA,(7,1),X'00',IC             *\n.*                                                                    *\n.*        IT SIMPLIFIES THE CODING OF A SCREEN IN THE FOLLOWING WAYS. *\n.*        .  BUFFER ADDRESSES ARE SPECIFIED AS ROW AND COLUMN NUM-    *\n.*           BER.  THE MACRO TRANSLATES THEM INTO THE 3270 CODE.      *\n.*        .  ORDERS ARE SPECIFIED BY NAME, SUCH AS 'SBA' AND 'SF',    *\n.*           SO YOU DONT HAVE TO KNOW THE HEX CODES FOR THEM,         *\n.*        .  COMMONLY USED ATTRIBUTE BYTES ARE SPECIFIED BY NAME      *\n.*           (A SET OF RESERVED NAMES) SO YOU DONT HAVE TO KNOW       *\n.*           THE HEX CODES FOR THEM.                                  *\n.*        .  IT SAVES A LOT OF DOCUMENTATION WORK, AND MAKES          *\n.*           THE CODE EASIER FOR OTHERS TO UNDERSTAND.                *\n.*                                                                    *\n.*        THE USER OF THE MACRO MUST STILL UNDERSTAND HOW A SCREEN    *\n.*        IS CONSTRUCTED BEFORE USING IT. THE MACRO MERELY MAKES IT   *\n.*        EASIER TO SPECIFY THE VALUES.  IT DOES VERY LITTLE ERROR    *\n.*        CHECKING.  FOR INSTANCE, IT DOES NOT CHECK TO SEE IF        *\n.*        YOU FOLLOW AN 'SBA' WITH A BUFFER ADDRESS.  IT IS POSSIBLE  *\n.*        TO CODE A THOROUGHLY INVALID SCREEN.                        *\n.*                                                                    *\n.*        THE MACRO MAY HAVE ANY NUMBER OF OPERANDS, CONSISTING OF    *\n.*        ANY COMBINATION OF THE FOLLOWING.                           *\n.*                                                                    *\n.*        .  AN ORDER.                                                *\n.*           VALID ORDERS ARE: SBA, SF, RTA, IC, PT, EUA.             *\n.*        .  A BUFFER ADDRESS IN PARENTHESES.                         *\n.*           IF AN OPERAND IS IN PARENTHESES, IT IS ASSUMED THAT      *\n.*           THE ROW AND COLUMN NUMBER ARE BETWEEN THE PARENS,        *\n.*           SEPARATED BY A COMMA.  EXAMPLE: (1,1)                    *\n.*           THIS FORM OF BUFFER ADDRESS IS NEW AS OF MARCH 18 1982.  *\n.*        .  A ROW OR COLUMN NUMBER OF A BUFFER ADDRESS (OLD FORMAT). *\n.*           IF AN OPERAND IS NUMERIC, IT IS ASSUMED TO BE            *\n.*           A ROW OR COLUMN NUMBER.  IT TAKES 2 OPERANDS TO          *\n.*           SPECIFY THE BUFFER ADDRESS (ROW AND COLUMN) SO NUMERIC   *\n.*           OPERANDS MUST ALWAYS BE SPECIFIED IN PAIRS, THE          *\n.*           FIRST BEING THE ROW AND THE SECOND BEING THE COLUMN.     *\n.*           THIS FORMAT IS SUPPORTED ONLY FOR COMPATIBILITY WITH     *\n.*           THE ORIGINAL VERSION OF THIS MACRO.                      *\n.*        .  AN ATTRIBUTE BYTE.                                       *\n.*           VALID ATTRIBUTE BYTES ARE:                               *\n.*           UNPLO -  UNPROTECTED NORMAL INTENSITY                    *\n.*           UNPHI  - UNPROTECTED HIGH INTENSITY                      *\n.*           UNPNP  - UNPROTECTED NO-DISPLAY                          *\n.*           PROLO  - PROTECTED NORMAL INTENSITY                      *\n.*           PROLOS - PROTECTED NORMAL INTENSITY AUTO-SKIP            *\n.*           PROHI  - PROTECTED HIGH INTENSITY                        *\n.*           PROHIS - PROTECTED HIGH INTENSITY AUTO-SKIP              *\n.*        .  A HEX, CHARACTER, OR ADDRESS CONSTANT.                   *\n.*           FOR EXAMPLE, X'00', OR C'ENTER SIGNON'                   *\n.*           THIS CAN BE USED FOR DATA WITHIN FIELDS OR FOR           *\n.*           ATTRIBUTE BYTES, ORDERS, THE 'WCC', OR BUFFER            *\n.*           ADDRESSES (IF YOU WANT TO FIGURE THEM OUT).              *\n.*                                                                    *\n.*        IF THE OPERANDS DO NOT ALL FIT ON ONE LINE, YOU CAN         *\n.*        EITHER CONTINUE THE LINE IN THE STANDARD ASSEMBLER WAY      *\n.*        OR CODE THE MACRO AGAIN ON THE NEXT LINE WITH THE           *\n.*        REMAINING OPERANDS.  THE RESULT IS THE SAME EITHER WAY.     *\n.*                                                                    *\n.*        THE BUFFER ADDRESS CONVERSIONS ARE FOR A                    *\n.*        SCREEN SIZE OF 24 ROWS BY 80 COLUMNS. FOR SCREENS           *\n.*        OF OTHER DIMENSIONS (43 BY 80, 12 BY 40) THE MACRO          *\n.*        NEEDS ONLY A FEW CHANGES.                                   *\n.*                                                                    *\n.*        WARNING: IF YOU CODE THE MACRO WITH A LABEL IN COLUMN 1,    *\n.*        AND YOU LIKE USING LENGTH ATTRIBUTES, BEWARE THAT THE       *\n.*        LENGTH ATTRIBUTE OF THE LABEL IS NOT NECESSARILY THE        *\n.*        TOTAL LENGTH OF THE DATA GENERATED BY THE MACRO.            *\n.*                                                                    *\n.**********************************************************************\n.*\n         LCLA  &R,&C,&P,&Q\n         LCLA  &AN,&AS,&AL\n         LCLB  &B,&NUMERIC,&INTEGER\n         LCLC  &T(64)\n         LCLC  &N,&ROW,&COL\n         LCLC  &CS,&STRING\n&T(1)    SETC  '40'\n&T(2)    SETC  'C1'\n&T(3)    SETC  'C2'\n&T(4)    SETC  'C3'\n&T(5)    SETC  'C4'\n&T(6)    SETC  'C5'\n&T(7)    SETC  'C6'\n&T(8)    SETC  'C7'\n&T(9)    SETC  'C8'\n&T(10)   SETC  'C9'\n&T(11)   SETC  '4A'\n&T(12)   SETC  '4B'\n&T(13)   SETC  '4C'\n&T(14)   SETC  '4D'\n&T(15)   SETC  '4E'\n&T(16)   SETC  '4F'\n.*\n&T(17)   SETC  '50'\n&T(18)   SETC  'D1'\n&T(19)   SETC  'D2'\n&T(20)   SETC  'D3'\n&T(21)   SETC  'D4'\n&T(22)   SETC  'D5'\n&T(23)   SETC  'D6'\n&T(24)   SETC  'D7'\n&T(25)   SETC  'D8'\n&T(26)   SETC  'D9'\n&T(27)   SETC  '5A'\n&T(28)   SETC  '5B'\n&T(29)   SETC  '5C'\n&T(30)   SETC  '5D'\n&T(31)   SETC  '5E'\n&T(32)   SETC  '5F'\n.*\n&T(33)   SETC  '60'\n&T(34)   SETC  '61'\n&T(35)   SETC  'E2'\n&T(36)   SETC  'E3'\n&T(37)   SETC  'E4'\n&T(38)   SETC  'E5'\n&T(39)   SETC  'E6'\n&T(40)   SETC  'E7'\n&T(41)   SETC  'E8'\n&T(42)   SETC  'E9'\n&T(43)   SETC  '6A'\n&T(44)   SETC  '6B'\n&T(45)   SETC  '6C'\n&T(46)   SETC  '6D'\n&T(47)   SETC  '6E'\n&T(48)   SETC  '6F'\n.*\n&T(49)   SETC  'F0'\n&T(50)   SETC  'F1'\n&T(51)   SETC  'F2'\n&T(52)   SETC  'F3'\n&T(53)   SETC  'F4'\n&T(54)   SETC  'F5'\n&T(55)   SETC  'F6'\n&T(56)   SETC  'F7'\n&T(57)   SETC  'F8'\n&T(58)   SETC  'F9'\n&T(59)   SETC  '7A'\n&T(60)   SETC  '7B'\n&T(61)   SETC  '7C'\n&T(62)   SETC  '7D'\n&T(63)   SETC  '7E'\n&T(64)   SETC  '7F'\n.*\n&N       SETC  '&NAME'\n&AN      SETA  N'&SYSLIST          NUMBER OF OPERANDS\n&AS      SETA  0\n&B       SETB  0 FALSE\n.EACH    AIF   (&AN EQ 0).EPILOG\n&AS      SETA  &AS+1\n&CS      SETC  '&AS'\n&AL      SETA  K'&SYSLIST(&AS)\n         AIF   (T'&SYSLIST(&AS) EQ 'O').NEXT\n         AIF   ('&SYSLIST(&AS)'(1,1) EQ '(').PAIR\n&NUMERIC SETB  (T'&SYSLIST(&AS) EQ 'N')\n&INTEGER SETB  ('&SYSLIST(&AS)'(1,1) GE '0')\n         AIF   (&NUMERIC AND &INTEGER).ROWCOL\n         AIF   (NOT &B).ROWCOLX\n         MNOTE 4,'             &CS.) MISSING COLUMN NUMBER'\n&B       SETB  0 FALSE\n.ROWCOLX ANOP\n&STRING  SETC  '&SYSLIST(&AS)'\n.*             ORDERS\n         AIF   ('&STRING' EQ 'SBA').SBA\n         AIF   ('&STRING' EQ 'SF').SF\n         AIF   ('&STRING' EQ 'RTA').RTA\n         AIF   ('&STRING' EQ 'IC').IC\n         AIF   ('&STRING' EQ 'PT').PT\n         AIF   ('&STRING' EQ 'EUA').EUA\n.*             ATTRIBUTES\n         AIF   ('&STRING' EQ 'UNPLO').UNPLO\n         AIF   ('&STRING' EQ 'UNPHI').UNPHI\n         AIF   ('&STRING' EQ 'UNPNP').UNPNP\n         AIF   ('&STRING' EQ 'PROLO').PROLO\n         AIF   ('&STRING' EQ 'PROLOS').PROLOS\n         AIF   ('&STRING' EQ 'PROHI').PROHI\n         AIF   ('&STRING' EQ 'PROHIS').PROHIS\n.*             CONSTANTS\n.*             IF THE OPERAND IS NONE OF THE ABOVE, IT IS\n.*             PRESUMED TO BE ANY VALID 'DC' CONSTANT.\n.DC      ANOP\n&N       DC    &STRING\n         AGO   .NEXT\n.SBA     ANOP\n&N       DC    X'11'               SET BUFFER ADDRESS\n         AGO   .NEXT\n.SF      ANOP\n&N       DC    X'1D'               START FIELD\n         AGO   .NEXT\n.RTA     ANOP\n&N       DC    X'3C'               REPEAT TO ADDRESS\n         AGO   .NEXT\n.IC      ANOP\n&N       DC    X'13'               INSERT CURSOR\n         AGO   .NEXT\n.PT      ANOP\n&N       DC    X'05'               PROGRAM TAB\n         AGO   .NEXT\n.EUA     ANOP\n&N       DC    X'12'               ERASE UNPROTECTED TO ADDRESS\n         AGO   .NEXT\n.UNPLO   ANOP\n&N       DC    X'40'               UNPROTECTED NORMAL INTENSITY\n         AGO   .NEXT\n.UNPHI   ANOP\n&N       DC    X'C8'               UNPROTECTED HIGH INTENSITY\n         AGO   .NEXT\n.UNPNP   ANOP\n&N       DC    X'4C'               UNPROTECTED NO-DISPLAY\n         AGO   .NEXT\n.PROLO   ANOP\n&N       DC    X'60'               PROTECTED NORMAL INTENSITY\n         AGO   .NEXT\n.PROLOS  ANOP\n&N       DC    X'F0'               PROTECTED NORMAL INTENSITY SKIP\n         AGO   .NEXT\n.PROHI   ANOP\n&N       DC    X'E8'               PROTECTED HIGH INTENSITY\n         AGO   .NEXT\n.PROHIS  ANOP\n&N       DC    X'F8'               PROTECTED HIGH INTENSITY SKIP\n         AGO   .NEXT\n.**********************************************************************\n.PAIR    ANOP\n         AIF   (N'&SYSLIST(&AS) NE 2).PERR1\n&NUMERIC SETB  (T'&SYSLIST(&AS,1) EQ 'N')\n&INTEGER SETB  ('&SYSLIST(&AS,1)'(1,1) GE '0')\n         AIF   (NOT &NUMERIC OR NOT &INTEGER).PERR2\n&R       SETA  &SYSLIST(&AS,1)\n&NUMERIC SETB  (T'&SYSLIST(&AS,2) EQ 'N')\n&INTEGER SETB  ('&SYSLIST(&AS,2)'(1,1) GE '0')\n         AIF   (NOT &NUMERIC OR NOT &INTEGER).PERR2\n&C       SETA  &SYSLIST(&AS,2)\n         AIF   (&R LT 1 OR &R GT 43).ROWERR *** WAS 24\n         AIF   (&C LT 1 OR &C GT 80).COLERR\n&P       SETA  (&R-1)*80+&C-1\n&Q       SETA  &P/64               QUOTIENT\n&R       SETA  &P-&Q*64+1          REMAINDER+1\n&Q       SETA  &Q+1                QUOTIENT+1\n&N       DC    X'&T(&Q)&T(&R)'     ROW AND COLUMN\n         AGO   .NEXT\n.PERR1   MNOTE 4,'             &CS.) PARENS FOUND BUT NOT 2 NUMBERS'\n         MEXIT\n.PERR2   MNOTE 4,'             &CS.) NON NUMERIC ROW/COLUMN'\n         MEXIT\n.**********************************************************************\n.ROWCOL  ANOP\n         AIF   (&B).COL            BRANCH IF ROW HAS BEEN CAPTURED\n&R       SETA  &SYSLIST(&AS)\n&B       SETB  1 TRUE              SET ROW-HAS-BEEN-CAPTURED\n         AGO   .NEXTR\n.COL     ANOP\n&C       SETA  &SYSLIST(&AS)\n&B       SETB  0 FALSE             RESET SWITCH\n         AIF   (&R LT 1 OR &R GT 43).ROWERR *** WAS 24\n         AIF   (&C LT 1 OR &C GT 80).COLERR\n&P       SETA  (&R-1)*80+&C-1\n&Q       SETA  &P/64               QUOTIENT\n&R       SETA  &P-&Q*64+1          REMAINDER+1\n&Q       SETA  &Q+1                QUOTIENT+1\n&N       DC    X'&T(&Q)&T(&R)'     ROW AND COLUMN\n         AGO   .NEXT\n.ROWERR  MNOTE 4,'             &CS.) VALUE &R INVALID, MUST BE 1 TO 43'\n         AGO   .NEXT\n.COLERR  MNOTE 4,'             &CS.) VALUE &C INVALID, MUST BE 1 TO 80'\n.NEXT    ANOP\n&N       SETC  ''                  TURN OFF NAME\n.NEXTR   ANOP\n&AN      SETA  &AN-1\n         AGO   .EACH\n.EPILOG  ANOP\n         MEND\n         PRINT ON\n         SPACE 1\n*   THE NAME OF THE IBM HELP COMMAND (&IBMHELP) IS SET IN THE\n*   FOLLOWING STATEMENT:\n         SPACE 1\n         GBLC  &IBMHELP\n&IBMHELP SETC  'H'                 'H', 'HELP' OR 'HELPOLD'\n         SPACE 1\n* SEE THE DISCUSSION IN THE INITIAL PROGRAM COMMENTS FOR DIRECTIONS\n         SPACE 1\nHEL      START\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=(R10,R11,R12),LV=@DATAL,SP=1,TYPE=RENT\n         LR    R2,R1\n         USING CPPL,R2\n         LR    R9,R13\n         USING @DATA,R9\n         EJECT\n         STM   R10,R12,BASE1\n         L     R14,=A(HELXEQ)\n         ST    R14,BASE2\n         LA    R15,1\n         LA    R14,4095(R15,R14)   BASE\n         ST    R14,BASE2+4\n         LA    R14,4095(R15,R14)   BASE\n         ST    R14,BASE2+8\n         ST    R2,CPPLPTR\n         MVC   HELCBUF(16),0(R2)   HELCBUF, HELUPT, HELPSCB, HELECT\n         L     R1,0(,R2)           START OF COMMAND TEXT\n         MVC   COMMND(2),2(R1)     OFFSET TO START OF OPERANDS\n         MVI   STATUS,0\n         MVI   MDFL,0\n         XC    LINKAREA(8),LINKAREA\n         XR    R15,R15\n         STH   R15,RC              SET RC = 0\n         ST    R15,TTRZ            SET Z = 0\n         XC    MSG(2),MSG\n         XC    MYANS,MYANS         IN CASE IKJRLSA BEFORE PARSE\n         LA    R1,PFKTAB-2048\n         LA    R1,2048(,R1)\n         ST    R1,APFKTB           POINT TO PFK TABLE START\n         LA    R1,SCREENW-PFKTAB(R1)\n         ST    R1,SCREENH          POINT TO SCREEN START\n         SPACE 1\n*----------------------------------------------------------*\n*        SET UP IOPL FOR PUTLINE                           *\n*----------------------------------------------------------*\n         SPACE 1\n         LA    R15,MYIOPL\n         USING IOPL,R15\n         MVC   IOPLUPT(4),CPPLUPT\n         MVC   IOPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,IOPLECB\n         XC    MYECB,MYECB\n         LA    R0,MYPTPB\n         ST    R0,IOPLIOPB\n         DROP  R15                 IOPL\n         L     R15,CVTPTR          CVT POINTER\n         USING CVT,R15\n         TM    CVTPUTL,X'80'       IS PUTLINE LOADED? (VS2)\n         BNO   PUTLOAD             NO - BRANCH TO LOAD\n         L     R0,CVTPUTL          YES - USE CVTPUTL\n         B     PUTLOADX            BRANCH AROUND LOAD\n         DROP  R15\nPUTLOAD  LA    R0,=CL8'IKJPUTL '\n        LOAD   EPLOC=(0)\nPUTLOADX LR    R15,R0              GET ENTRY ADDRESS\n         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE\n         ST    R15,MYPUTLEP        SAVE PUTLINE ENTRY ADDRESS\n         SPACE 1\n*----------------------------------------------------------*\n*        CHECK IF COMMAND AND SUBCOMMAND CAN BE PROCESSED  *\n*----------------------------------------------------------*\n         SPACE 1\n         L     R1,HELECT           START OF ECT\n         USING ECT,R1\n         MVI   FILEKV,C'N'         ASSUME COMMAND, NO SUBCOMMAND\n         MVC   PCMD,ECTPCMD        SAVE COMMAND NAME\n         MVC   SCMD,ECTSCMD        SAVE SUBCOMMAND NAME\n         CLC   ECTPCMD(2),=CL8'HELP    ' HELP COMMAND?\n         BE    GTSZE               YES, BRANCH\n         CLC   ECTPCMD(2),=C'H '   H COMMAND?\n         BE    GTSZE               YES, BRANCH\n         MVI   FILEKV,C'S'         COMMAND WITH SUBCOMMANDS\n         CLC   ECTSCMD(2),=CL20' ' NULL SUBCOMMAND?\n         BE    GTSZE               YES, BRANCH\n         CLC   ECTSCMD(2),=C'H '   H SUBCOMMAND?\n         BE    GTSZE               YES, BRANCH\n         CLC   ECTSCMD(2),=CL8'HELP    ' HELP SUBCOMMAND?\n         BNE   ERRTERM             NO, CANNOT PROCESS\n         CLI   ECTSCMD+4,C'X'      HELPX SUBCOMMAND?\n         BNE   GTSZE               NO, BRANCH\n         OI    MDFL,HELPX          YES, SET A FLAG\n         DROP  R1\n         SPACE 1\n*----------------------------------------------------------*\n*        CHECK TERMINAL SCREEN SIZE                        *\n*----------------------------------------------------------*\n         SPACE 1\nGTSZE   GTSIZE\n         CH    R0,=H'24'           AT LEAST 24 ROWS (LINES)\n         BL    ERRTERM             NO, TERMINATE\n         SPACE 1\n*----------------------------------------------------------*\n*        SET UP PFK DEFAULTS                               *\n*----------------------------------------------------------*\n         SPACE 1\n         LA    R1,PFKDEF\n         L     R15,APFKTB\n         LA    R0,PFKDEFN\nPFKINIT  MVI   0(R15),C' '\n         MVC   1(L'PFKTAB-1,R15),0(R15) PAD WITH BLANKS\n         MVC   0(L'PFKDEF,R15),0(R1) INSERT DEFAULT\n         LA    R1,L'PFKDEF(,R1)    POINT TO NEXT DEFAULT\n         LA    R15,L'PFKTAB(,R15)  POINT TO NEXT PFK ENTRY\n         BCT   R0,PFKINIT          11 MORE TIMES\n         MVI   0(R15),0            END OF TABLE\n         SPACE 1\n*----------------------------------------------------------*\n*        SET UP PPL FOR PARSE                              *\n*----------------------------------------------------------*\n         SPACE 1\n         LA    R15,MYPPL\n         USING PPL,R15\n         MVC   PPLUPT(4),CPPLUPT\n         MVC   PPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,PPLECB\n         XC    MYECB,MYECB\n         L     R0,=A(HELCL)\n         ST    R0,PPLPCL\n         LA    R0,MYANS\n         ST    R0,PPLANS\n         MVC   PPLCBUF(4),CPPLCBUF\n         ST    R9,PPLUWA\n         DROP  R15                 PPL\n         SPACE 1\n*----------------------------------------------------------*\n*        CALL THE PARSE SERVICE ROUTINE                    *\n*----------------------------------------------------------*\n         SPACE 1\n         LR    R1,R15              POINT TO PPL\n         L     R15,CVTPTR          CVT POINTER\n         USING CVT,R15\n         TM    CVTPARS,X'80'       IF HI ORDER BIT NOT ON\n         BNO   PARSLNK             THEN DO LINK, NOT CALL\n         L     R15,CVTPARS         CVTPARS\n         DROP  R15\n         BALR  R14,R15             CALL IKJPARS\n         B     PARSEEXT            SKIP AROUND LINK\nPARSLNK LINK   EP=IKJPARS,SF=(E,LINKAREA)\nPARSEEXT LTR   R15,R15\n         BZ    PARSEOK\n         LA    R1,MSG01\n         LA    R0,L'MSG01\n         BAL   R14,PUTMSG1\n         LA    R15,12\n         B     EXIT\nPARSEOK  L     R3,MYANS\n         USING IKJPARMD,R3\n         SPACE 1\n*----------------------------------------------------------*\n*        FILL IN ALL INFO FROM PARSE                       *\n*----------------------------------------------------------*\n         SPACE 1\n         MVI   DEBUGSW,0           NO DEBUG MESSAGES YET\n         MVI   FILEKV,C'N'         ASSUME COMMAND WITH NO SUBCOMMANDS\n         MVI   FILEKV+1,X'01'      ASSUME FILE(SYSHELP)\n         MVC   $SUBLINE,=F'0'\n         MVI   $SUBLINE,C'Y'       SUBCOMMAND IS SATISFIED\n         MVC   $SUBCOM(L'$SUBCOM),=CL20' '\n         MVC   $MEMBER,=CL8'COMMANDS'\n         LA    R6,MEMBRPO\n         TM    6(R6),X'80'         MEMBER SPECIFIED?\n         BZ    PARSEMX             NO, BRANCH\n         MVC   $MEMBER(L'$MEMBER),=CL20' '\n         L     R14,0(,R6)          POINT TO MEMBER VALUE\n         LH    R1,4(,R6)           GET LENGTH\n         BCT   R1,*+L'*+6          LENGTH MINUS 1 FOR EX\n         MVC   $MEMBER(*-*),0(R14) <<EXECUTED>>\n         EX    R1,*-6              MOVE VOLUME\nPARSEMX  L     R1,HELECT           START OF ECT\n         USING ECT,R1\n         MVC   TGETREGS(8),ECTSWS2\n         MVC   REPLY(8),ECTSWS2\n         MVC   TGETREGS+8(4),=F'8'\n         CLC   ECTPCMD(2),=CL8'HELP    ' HELP COMMAND?\n         BE    PARSEO              YES, BRANCH\n         CLC   ECTPCMD(2),=C'H '   HELP COMMAND?\n         BE    PARSEO              YES, BRANCH\n         MVI   FILEKV,C'S'         COMMAND WITH SUBCOMMANDS\n         MVI   $SUBLINE,C'N'       SUBCOMMAND IS NOT SATISFIED\n         MVC   $SUBCOM(8),$MEMBER  SUBCOMMAND IS MEMBER NAME\n         MVC   $MEMBER(8),ECTPCMD  CHANGE MEMBER NAME\n         DROP  R1\n         CLC   $MEMBER(8),=C'HLHL    ' HELP FOR HEL?\n         BNE   *+L'*+6             NO, BRANCH\n         MVC   $MEMBER(8),=CL8'HEL' YES, CONVERT TO HEL\n         CLC   $SUBCOM(8),$MEMBER  COMMAND NAME=SUBCOMMAND?\n         BE    PARSEX              YES, BRANCH\n         TM    6(R6),X'80'         SUBCOMMAND SPECIFIED?\n         BO    PARSEO              YES, BRANCH\nPARSEX   MVI   $SUBLINE,C'Y'       SUBCOMMAND IS SATISFIED\n         MVC   $SUBCOM(L'$SUBCOM),=CL20' ' NO SUBCOMMAND NAME\nPARSEO   LA    R0,7\n         LA    R15,$SUBCOM+8\nPARSEO1  BCTR  R15,0               SCAN\n         CLI   0(R15),C' '           FOR\n         BNE   PARSEO2                 LAST\n         BCT   R0,PARSEO1                NON-BLANK\nPARSEO2  STH   R0,$SUBLEN          MACHINE LENGTH OF SUBCOMMAND\n         LA    R4,$OPERAND\n         LA    R6,OPLIST\nPARSELP  MVC   0(20,R4),=CL20' '   CLEAR THIS ELEMENT\n         LA    R1,0(,R6)           ADDRESS OF PARAMETER START\n         LTR   R1,R1               ANY PARAMETER?\n         BZ    PARSEOX             NO, BRANCH\n         TM    6(R6),X'80'         OPERAND SPECIFIED?\n         BZ    PARSEOX             NO, BRANCH\n         L     R14,0(,R6)          POINT TO MEMBER VALUE\n         LH    R1,4(,R6)           GET LENGTH\n         BCT   R1,*+L'*+6          LENGTH MINUS 1 FOR EX\n         MVC   0(*-*,R4),0(R14)    <<EXECUTED>>\n         EX    R1,*-6              MOVE VOLUME\n         LA    R4,20(,R4)          NEXT OPERAND OUTPUT LOCATION\n         L     R6,8(,R6)           NEXT OPERAND PARAMETER LOCATION\n         B     PARSELP\nPARSEOX  MVC   FKV,FKW             GET FUNCTION KEYWORD\n         MVC   SKV,SKW             GET SYNTAX KEYWORD\n         MVC   OKV,OKW             GET OPERANDS KEYWORD\n         MVC   AKV,AKW             GET ALL KEYWORD\n         MVC   MKV,MKW             GET MSGS KEYWORD\n         MVC   MKV(1),PKW+1        GET POSIT KEYWORD\n         CLC   PCMD(8),=C'HLHL    ' HEL HELP?\n         BNE   *+L'*+6             NO, BRANCH\n         XC    MKV(2),MKV          IGNORE MSGS AND POSIT KEYWORDS\n         MVI   HELPFLG,0           NO HELP YET\n         MVI   MEMBFLG,0           NO MEMBER OR SUBCOMMAND YET\n         DROP  R3                  IKJPARMD\n        IKJRLSA MYANS\n         XC    MYANS,MYANS\n         CLI   MKV,0               ANY POSIT KEYWORD?\n         BH    ERRTERM             YES, INVOKE HELP INSTEAD\n         CLI   MKV+1,0             ANY MSGS KEYWORD?\n         BH    ERRTERM             YES, INVOKE HELP INSTEAD\n         MVI   $DSNAME+1,7\n         MVC   $DSNAME+2(8),=CL8'SYSHELP'\n         DEVTYPE $DSNAME+2,DEVDATA GET DEVICE TYPE\n         LTR   R15,R15             FILENAME VALID?\n         BZ    GOTFILE             YES, BRANCH\n         MVI   FILEKV+1,0\n         MVI   $DSNAME+1,9\n         MVC   $DSNAME+2(9),=CL9'SYS1.HELP'\n         B     NOFILE              NO, TRY SYS1.HELP\nGOTFILE  TM    DEVDATA+2,X'20'     DIRECT ACCESS\n         BZ    FILERR              NO, BRANCH\n         LA    R4,DYNDCBW\n         L     R1,=A(SEQDCB)\n         MVC   0(SEQDCBL,R4),0(R1)\n         USING IHADCB,R4\n         LA    R0,JFCB\n         LA    R1,DYNEXLST\n         ST    R0,0(,R1)\n         MVI   0(R1),X'87'\n         ST    R1,DCBEXLST\n         MVC   DCBDDNAM(L'DCBDDNAM),$DSNAME+2\n         MVC   $DDNAML(46),$DSNAME\n         DROP  R4\n         LA    R0,4                ADD 4\n         AH    R0,$DDNAML            TO LENGTH OF DDNAME\n         STH   R0,$DDNAML              FOR +NNN (CONCAT NUMBER)\n         MVI   OPEND,X'80'\n        RDJFCB ((R4)),MF=(E,OPEND)\n         MVC   $DSNAME+2(44),JFCB\n         LA    R1,$DSNAME+45       LAST CHAR OF DSNAME\n         LA    R0,44               INITIAL LENGTH\nFILEA    CLI   0(R1),C' '          IS THIS LAST NONBLANK\n         BNE   FILEB               YES, BRANCH\n         BCTR  R1,0                BACK UP 1 CHARACTER\n         BCT   R0,FILEA            DECREMENT LENGTH AND BRANCH\nFILEB    STH   R0,$DSNAME          STORE LENGTH OF DSNAME\n         MVI   DSORG,DCBDSGPS      DSORG PS\n         CLI   $MEMBER,C' '        DDNAME(MEMBER)\n         BE    FILEC               NO\n         MVI   DSORG,DCBDSGPO      YES, INDICATE PARTITIONED\n         B     OKDSORG             DONT LOOK AT JFCB\nFILEC    CLI   JFCB+44,C' '        DDNAME ALLOCATED TO A MEMBER\n         BE    OKDSORG             NO\n         MVC   $MEMBER,JFCB+44     YES, SAVE THE MEMBER NAME\n         MVI   DSORG,DCBDSGPO      DSORG PO\n         B     OKDSORG\nFILERR   LA    R0,MSG14C\n         MVC   MSG(L'MSG14),MSG14\n         LA    R15,MSG+L'MSG14\n         LA    R14,$DSNAME\n         LH    R1,0(,R14)\n         BCT   R1,*+L'*+6\n         MVC   MSG+L'MSG14(*-*),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         LR    R14,R0              POINTS TO MSG14C\n         MVC   0(L'MSG14C,R15),0(R14)\n         LA    R0,L'MSG14+L'MSG14C+1(,R1)\n         LA    R1,MSG\n         BAL   R14,PUTMSG1\n         B     EXITA12\n         SPACE 1\n*----------------------------------------------------------*\n*        ALLOCATE THE DATASET                              *\n*----------------------------------------------------------*\n         SPACE 1\nNOFILE   LA    R1,MYDAPL\n         USING DAPL,R1\n         MVC   DAPLUPT(4),CPPLUPT\n         MVC   DAPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB(4),CPPLPSCB\n         LA    R15,MYDAPB\n         ST    R15,DAPLDAPB\n         DROP  R1                  DAPL\n         USING DAPB08,R15\n         XC    0(84,R15),0(R15)\n         MVI   DA08CD+1,X'08'\n         LA    R0,$DSNAME\n         ST    R0,DA08PDSN\n         MVC   DA08DDN(L'DA08DDN),=CL20' '\n         MVC   DA08UNIT(L'DA08UNIT),=CL20' '\n         MVC   DA08SER(L'DA08SER),=CL20' '\n         MVC   DA08MNM(L'DA08MNM),=CL20' ' NEVER ALLOCATE WITH MEMBER\n         MVC   DA08PSWD(L'DA08PSWD),=CL20' '\n         MVI   DA08DSP1,DA08SHR\n         MVI   DA08DPS2,DA08KEEP\n         MVI   DA08DPS3,DA08KEP\n         LA    R1,MYDAPL\n         BAL   R14,CALLDAIR\n         LTR   R15,R15\n         BZ    OKDAIR\n         BAL   R14,DAIRFAIL\n         B     EXITA12\nOKDAIR   OI    STATUS,STALLOC      TELL CLEANUP TO FREE IT\n         LA    R15,MYDAPB\n         MVC   $DDNAME,DA08DDN\n         MVC   DSORG,DA08DSO\n         TM    DA08DSO,DCBDSGPO    IS DSORG PARTITIONED?\n         BO    OKDSORG             YES, BRANCH\nERRDSORG LA    R1,MSG06            DSORG IS NOT PO\n         LA    R0,L'MSG06            ISAM=X'80' DA=X'20'\n         BAL   R14,PUTMSG1           VSAM=X'00' NONE=X'00'\n         B     EXITA12\n         DROP  R15                 DAPB08\n         SPACE 1\n*----------------------------------------------------------*\n*        GET THE UCB ADDRESS AND VOLUME SERIAL             *\n*----------------------------------------------------------*\n         SPACE 1\nOKDSORG  L     R1,CVTPTR           CVT POINTER\n         USING CVT,R1\n         L     R1,CVTTCBP          TCB WORDS\n         DROP  R1\n         L     R1,4(,R1)           CURRENT TCB\n         USING TCB,R1\n         L     R1,TCBTIO           TIOT\n         DROP  R1\n         XR    R15,R15\n         USING TIODSECT,R1\nDDLOOP   CLI   TIOENTRY,0          TIOENTRY - END OF TIOT?\n         BE    EXITA12             YES, BRANCH (NEVER HAPPENS)\n         CLC   TIOEDDNM,$DDNAME    DOES DDNAME MATCH\n         BE    DDFOUND\n         IC    R15,TIOELNGH\n         ALR   R1,R15\n         B     DDLOOP\nDDFOUND  ICM   R15,B'0111',TIOEFSRT\n         DROP  R1\n         ST    R15,$UCBAD\n         USING UCBDSECT,R15\n         TM    UCBTBYT3,UCB3DACC   DIRECT ACCESS DEVICE?\n         BZ    *+L'*+6             NO, BYPASS VOLSER\n         MVC   $VOLSER,UCBVOLI\n         SPACE 1\n*----------------------------------------------------------*\n*        OBTAIN THE DSCB FROM THE VTOC                     *\n*----------------------------------------------------------*\n         SPACE 1\n         CLI   FILEKV+1,1          'FILE' SPECIFIED?\n         BNE   OBTX                NO, BYPASS OBTAIN\n         L     R15,$UCBAD          POINT TO UCB\n         TM    UCBTBYT3,UCB3DACC   DIRECT ACCESS DEVICE?\n         BZ    OBTX                NO, BYPASS OBTAIN\n         DROP  R15\n         LA    R1,OBTAINW\n         MVC   0(OBTAINL,R1),OBTAIN\n         LA    R0,$DSNAME+2        DSN FOR OBTAIN\n         ST    R0,4(,R1)\n         LA    R0,$VOLSER          VOLUME FOR OBTAIN\n         ST    R0,8(,R1)\n         LA    R0,MYDSCB           ANSWER AREA FOR OBTAIN\n         ST    R0,12(,R1)\n        OBTAIN (1)\n         LTR   R15,R15             WAS OBTAIN SUCCESSFUL\n         BZ    OKDSCB              YES, BRANCH\n         LA    R1,MSG09            UNABLE TO OBTAIN DSCB\n         LA    R0,L'MSG09\n         BAL   R14,PUTMSG1\n         B     EXITA12\nOKDSCB   MVC   DSORG,MYDSCB-44+X'52'\n         TM    DSORG,DCBDSGPS      DSORG = PS\n         BO    OBTX\n         TM    DSORG,DCBDSGPO      DSORG = PO\n         BNO   ERRDSORG\n         SPACE 1\n*----------------------------------------------------------*\n*        CALL PHASE 2 FOR MAIN PROCESSING                  *\n*----------------------------------------------------------*\n         SPACE 1\nOBTX     L     R15,=A(HELXEQ)      GET ADDRESS OF PHASE 2\n         BALR  R14,R15             GO TO PHASE 2\n         B     EXITARC             PHASE 2 HAS SET RC\n         SPACE 1\n*----------------------------------------------------------*\n*        RETURN FROM PHASE 2 TO TERMINATE                  *\n*----------------------------------------------------------*\n         SPACE 1\nEXITA12  LA    R15,12\n         STH   R15,RC\nEXITARC  TM    STATUS,STALLOC      FREE REQUIRED?\n         BZ    NOFREE\n         LA    R1,MYDAPL\n         LA    R15,MYDAPB\n         USING DAPB18,R15\n         XC    0(40,R15),0(R15)\n         MVI   DA18CD+1,X'18'\n         MVC   DA18DDN,$DDNAME\n         MVC   DA18MNM(L'DA18MNM),=CL20' '\n         MVC   DA18SCLS(L'DA18SCLS),=CL20' '\n         BAL   R14,CALLDAIR        UNALLOCATE\n         NI    STATUS,255-STALLOC  UNALLOCATED\n         DROP  R15                 DAPB18\nNOFREE  IKJRLSA MYANS\n         CLI   RC+1,16             IS RC 16?\n         BZ    ERRTERM             YES, XCTL TO HELP\n         CLI   RC+1,0              IS RC ZERO?\n         BZ    STACKDX             YES, BRANCH\n         MVC   MYSTPB(STACKDL),STACKD\n        STACK  DELETE=ALL,PARM=MYSTPB,MF=(E,MYIOPL)\n        TCLEARQ\nSTACKDX  LH    R15,RC\n         SPACE 1\n*----------------------------------------------------------*\n*        EXIT TO CALLER                                    *\n*----------------------------------------------------------*\n         SPACE 1\nEXIT    $XRET  CC=(R15),LV=@DATAL,SP=1,TYPE=RENT\n         SPACE 1\n*----------------------------------------------------------*\n*        XCTL TO THE IBM HELP COMMAND                      *\n*----------------------------------------------------------*\nERRTERM  L     R1,HELECT\n         USING ECT,R1\n         CLI   FILEKV,C'S'         COMMAND WITH SUBCOMMANDS\n         BE    *+L'*+6             YES, BRANCH\n         MVC   ECTPCMD,IBMHELP     NO, HELP REQUEST ONLY\n         MVC   ECTSCMD,SCMD        RESTORE SECONDARY COMMAND\n         DROP  R1\n         LR    R1,R13\n         L     R0,@SIZE\n         L     R13,4(,R13)\n         ICM   R13,B'1000',COMMND+1 GET OFFSET TO OPERANDS\n        FREEMAIN R,A=(1),LV=(0)\n         LM    0,12,20(R13)\n         L     R14,12(,R13)\n         L     R14,0(,R1)\n         STCM  R13,B'1000',3(R14)  RESET OFFSET TO OPERANDS\n         L     R14,12(,R13)\n         BALR  R15,0\n         USING *,R15\n        XCTL   ,EPLOC=IBMHELP\n         DROP  R15\n         SPACE 1\n*----------------------------------------------------------*\n*        CALL IKJDAIR SERVICE ROUTINE                      *\n*----------------------------------------------------------*\n         SPACE 1\nCALLDAIR ST    R14,DAIRREGS\n         L     R15,CVTPTR\n         USING CVT,R15\n         TM    CVTDAIR,X'80'       CVTDAIR\n         BNO   DAIRLNK\n         L     R15,CVTDAIR\n         DROP R15\n         BALR  R14,R15\n         B     DAIRFIN\nDAIRLNK LINK   EP=IKJDAIR,SF=(E,LINKAREA)\nDAIRFIN  L     R14,DAIRREGS\n         BR    R14\n         SPACE 1\n*----------------------------------------------------------*\n*        DYNAMIC ALLOCATION FAILURE ROUTINE                *\n*----------------------------------------------------------*\n         SPACE 1\nDAIRFAIL ST    R14,MYDFREGS\n         LA    R1,MYDFPARM\n         USING DFDSECTD,R1\n         ST    R15,MYDFRC\n         LA    R15,MYDFRC\n         ST    R15,DFRCP\n         LA    R15,MYDAPL\n         ST    R15,DFDAPLP\n         XR    R15,R15\n         ST    R15,MYJEFF02\n         LA    R15,MYJEFF02\n         ST    R15,DFJEFF02\n         LA    R15,DFDAIR\n         STH   R15,MYDFID\n         LA    R15,MYDFID\n         ST    R15,DFIDP\n         MVC   DFCPPLP,CPPLPTR\n         DROP  R1\n        LINK   EP=IKJEFF18,SF=(E,LINKAREA)\n         L     R15,MYDFRC\n         L     R14,MYDFREGS\n         BR    R14\n         SPACE 1\n*----------------------------------------------------------*\n*        PHASE 1 INTERFACES TO PHASE 2                     *\n*----------------------------------------------------------*\n         SPACE 1\nPUTMSG1  ST    R14,BASE1+12\n         L     R15,=A(PUTMSG)\n         LM    R10,R12,BASE2       SWITCH BASE REGS\n         BALR  R14,R15\n         LM    R10,R12,BASE1       RESTORE BASE REGS\n         L     R14,BASE1+12\n         BR    R14\n         EJECT\n*----------------------------------------------------------*\n*        PHASE 1 CONSTANTS                                 *\n*----------------------------------------------------------*\n         SPACE 1\n         CNOP  0,4\nPFKDEF   DS    0CL16               INITIAL VALUES OF PF KEYS\n         DC    X'F1',CL15'HELP '   1\n         DC    X'F2',CL15' '       2\n         DC    X'F3',CL15'END '    3\n         DC    X'F4',CL15'END '    4\n         DC    X'F5',CL15'FIND '   5\n         DC    X'F6',CL15' '       6\n         DC    X'F7',CL15'UP '     7\n         DC    X'F8',CL15'DOWN '   8\n         DC    X'F9',CL15'HEX '    9\n         DC    X'7A',CL15'LEFT '   10\n         DC    X'7B',CL15'RIGHT '  11\n         DC    X'7C',CL15' '       12\nPFKDEFN  EQU   (*-PFKDEF)/L'PFKDEF\n         SPACE 1\nOBTAIN  CAMLST SEARCH,2,3,4\nOBTAINL  EQU   *-OBTAIN\n         SPACE 1\nSTACKD  STACK  DELETE=ALL,MF=L\nSTACKDL  EQU   *-STACKD\n         SPACE 1\n@SIZE    DC    0F'0',AL1(1),AL3(@DATAL) SIZE OF WORK AREAS\nIBMHELP  DC    CL8'&IBMHELP'\n         SPACE 1\nMSG01    DC    C'ERROR IN PARSE SERVICE ROUTINE'\nMSG06    DC    C'DATA-SET ORGANIZATION MUST BE PARTITIONED'\nMSG09    DC    C'UNABLE TO OBTAIN DSCB FOR DATA-SET'\nMSG14    DC    C'FILENAME '\nMSG14C   DC    C' NOT ALLOCATED TO A DASD DATA-SET '\n         EJECT\n*------- LITERAL POOL\n         SPACE 1\n        LTORG\n         SPACE 1\n*        DC    (((*-C-1)/N)*N+N+C-*)X'00'\n*                        WHERE N IS BOUNDARY (I.E. 256, 4096, ...)\n*                        AND C IS THE BEGINNING OF THE CSECT.\n         DC    (((*-HEL-1)/256)*256+256+HEL-*)X'00'\n         DC    0D'0'\n         SPACE 1\n         DROP  R2\n         SPACE 1\n         DROP  R10,R11,R12\n*= = = = END OF CSECT ADDRESSABILITY = = = = = = = = = = = = = = = = =*\n         EJECT\n*----------------------------------------------------------*\n*        PHASE 2 INITIALIZATION                            *\n*----------------------------------------------------------*\n*\n*        FROM THIS POINT ON, PROCESSING IS THE SAME\n*        FOR BOTH DSNAME AND DDNAME OPTIONS.\n*\n*        $DSNAME  - CONTAINS THE FULLY QUALIFIED DSNAME,\n*                   FROM THE USER OR FROM THE JFCB.\n*        $MEMBER  - CONTAINS THE MEMBER NAME, IF SPECIFIED,\n*                   FROM THE USER OR FROM THE JFCB.\n*        $DDNAME  - CONTAINS THE DDNAME, FROM IKJDAIR OR\n*                   FROM THE USER.\n         SPACE 1\nHELXEQ   CSECT\n         USING *,R10,R11,R12\n         LR    R10,R15             RESET BASE REGISTER\n         LA    R15,1\n         LA    R11,4095(R15,R10)   BASE\n         LA    R12,4095(R15,R11)   BASE\n         ST    R14,RETSV\n        GTSIZE\n         CH    R0,=H'27'           3278-5 TERMINAL?\n         BNE   GTSZEX              NO, BRANCH\n         OI    MDFL,STSIZEX        SET A FLAG FOR LATER\n        STSIZE SIZE=80,LINE=24    SET SIZE TO 24X80\n         LA    R1,INWRT            INITIAL WRITE\n         LA    R0,INWRTL           LENGTH\n        TPUT   (1),(0),FULLSCR     WRITE FULL SCREEN\n        GTSIZE ,                   AT LEAST 24 ROWS (LINES)\nGTSZEX   SH    R0,=H'4'            LESS HEADER INFORMATION\n         STH   R0,PAGESIZE         SAVE THE PAGE SIZE\n         ST    R1,SCROLL           SET NEW RANGE\n         STH   R1,PAGEWIDT         SAVE THE LINE WIDTH\n         SPACE 1\n*----------------------------------------------------------*\n*        SET UP THE DCB                                    *\n*----------------------------------------------------------*\n         SPACE 1\n        STFSMODE ON,INITIAL=YES    TURN ON FULLSCREEN MODE\n         MVC   DYNDCBW(SEQDCBL),SEQDCB\n         TM    DSORG,DCBDSGPO\n         BZ    *+L'*+6\n         MVC   DYNDCBW(PDSDCBL),PDSDCB\n         LA    R4,DYNDCBW\n         USING IHADCB,R4\n         MVC   DCBDDNAM(8),$DDNAME\n         LA    R15,DYNEOD\n         IC    R0,DCBEODAD\n         ST    R15,DCBEODAD\n         STC   R0,DCBEODAD\n         LA    R15,DYSYNAD\n         IC    R0,DCBSYNAD\n         ST    R15,DCBSYNAD\n         STC   R0,DCBSYNAD\n         LA    R15,DYNEXLST\n         IC    R0,DCBEXLSA-1\n         ST    R15,DCBEXLSA-1\n         STC   R0,DCBEXLSA-1\n         LA    R1,DYNDCBEX\n         ST    R1,0(,R15)\n         MVI   0(R15),X'05'\n         LA    R1,DYNABEND\n         ST    R1,4(,R15)\n         MVI   4(R15),128+X'11'    OPEN ABEND EXIT (MVS)\n         OI    STATUS,STOPEN       TELL CLEANUP TO CLOSE DCB\n         MVI   OPEND,X'80'\n        OPEN   ((R4),INPUT),MF=(E,OPEND)\n         TM    DCBOFLGS,DCBOFOPN\n         BO    OKOPEN\n         LA    R1,MSG08\n         LA    R0,L'MSG08\n         TM    STATUS,STABEND      MEMBER NOT FOUND?\n         BO    DYNOPENM            YES, BRANCH\n         LA    R1,MSG04\n         LA    R0,L'MSG04\nDYNOPENM BAL   R14,PUTMSG\n         B     EXIT12\n         SPACE 1\n*----------------------------------------------------------*\n*        DCB EXITS ROUTINES                                *\n*----------------------------------------------------------*\n         CNOP  0,4\n*------- DCB OPEN EXIT\n*              NOTE - TESTING THE RECFM FOR RECFM V OR F\n*                     REQUIRES AT LEAST 2 TESTS BECAUSE BOTH THE\n*                     V AND F BITS ARE ON WHEN RECFM IS U.\n*                     THIS ROUTINE MAKES A COPY OF THE RECFM BITS\n*                     AND ZEROES BOTH THE V AND F BITS IN THE COPY\n*                     IF THE RECFM IS U. NOW WE CAN DETERMINE\n*                     RECFM V OR F IN ONE TEST INSTEAD OF TWO.\nDYNDCBEX MVC   TSTRECFM,DCBRECFM   COPY RECFM\n         TM    DCBRECFM,DCBRECU    RECFM U\n         BNOR  R14                 NO, BRANCH\n         NI    TSTRECFM,255-DCBRECU YES, SET BOTH BITS OFF\n         BR    R14\n         CNOP  0,4\n*------- DCB ABEND EXIT\nDYNABEND L     R8,0(,R1)           GET COMPLETION CODE\n         N     R8,=A(X'FFF0FF00')\n         CL    R8,=A(X'01301800')  IS IT AN 013-18 ABEND\n         BE    *+L'*+6             YES, BRANCH\n         MVI   4(R1),0             ABNORMALLY TERMINATE\n         BR    R14\n         OI    STATUS,STABEND      INDICATE MEMBER NOT FOUND\n         MVI   3(R1),4             IGNORE THE ABEND\n         BR    R14\n         CNOP  0,4\n*------- DCB SYNAD EXIT\n*        THIS ROUTINE IS ENTERED DURING THE 'CHECK' MACRO\n*        IF AN I/O ERROR OCCURS.\nDYSYNAD SYNADAF ACSMETH=BSAM\n         MVC   SYNADMSG(78),50(R1)\n         MVI   SYNADSW,255\n        SYNADRLS\n         BR    R14\n         CNOP  0,4\n*------- DCB EODAD EXIT\nDYNEOD   L     R1,=F'-1'           EOF\n         ST    R1,0(,R5)           SAVE EOF IN CHKPT TABLE\n         XR    R2,R2\n         L     R14,READR\n         BR    R14\n         SPACE 1\n*----------------------------------------------------------*\n*        SET UP THE BUFFER AREA                            *\n*----------------------------------------------------------*\n         SPACE 1\nOKOPEN   MVC   DYNDECBW(DYNDECBL),DYNDECB\n         LH    R0,DCBBLKSI\n         AH    R0,=H'7'            ROUND\n         N     R0,=A(X'FFFFFFF8')  UPWARDS TO MULTIPLE OF 8\n         ST    R0,SAVBLKSI         SAVE FOR PARTITIONING\n         XR    R0,R0\n         TM    TSTRECFM,DCBRECV+DCBRECSB VS OR VBS\n         BNO   NOTSPAN             NO, BRANCH\n         LH    R0,DCBLRECL         YES, GET LRECL\n         AH    R0,=H'7'            ROUND\n         N     R0,=A(X'FFFFFFF8')  UPWARDS TO MULTIPLE OF 8\n         LTR   R0,R0               WAS LRECL ZERO\n         BNZ   *+L'*+4             NO, SKIP NEXT INSTR\n         L     R0,SAVBLKSI         YES, USE BLKSIZE ROUNDED\n         A     R0,=A(2048)         ADD 2K IN CASE LRECL IS WRONG\nNOTSPAN  ST    R0,SAVSPANL         SAVE FOR PARTITIONING\n         LH    R0,DCBLRECL\n         LTR   R0,R0\n         BNZ   *+L'*+4\n         LH    R0,DCBBLKSI\n         STH   R0,RECSIZE\n         AH    R0,=H'7'            ROUND\n         N     R0,=A(X'FFFFFFF8')  UPWARDS TO MULTIPLE OF 8\n         CH    R0,=H'1000'         IS LRECL GREATER THAN MAX\n         BNH   *+L'*+4             NO, SKIP NEXT INSTR\n         LH    R0,=H'1000'         YES, HELD RECORDS MUST BE TRUNCATED\n         ST    R0,SAVLRECL         SAVE FOR HOLD AREA DIVISION\n         MH    R0,PAGESIZE\n         ST    R0,SAVHOLDL         SAVE FOR PARTITIONING\n         A     R0,SAVSPANL         COMBINE LENGTHS FOR GETMAIN\n         A     R0,SAVBLKSI         COMBINE LENGTHS FOR GETMAIN\n         A     R0,=A(20*200)       PLUS ROOM FOR 200 CHECKPOINTS\n         LA    R7,RANGE\n         ST    R0,0(,R7)\n         A     R0,=A(20*824)       OPTIONAL ROOM FOR 1024 CHECKPOINTS\n         ST    R0,4(,R7)\n         LA    R8,ANSWER\n         MVC   GMVUW(GMVUL),GMVU\n         GETMAIN VU,LA=(R7),A=(R8),MF=(E,GMVUW)\n         OI    STATUS,STGMVU\n         L     R1,ANSWER\n         LR    R0,R1\n         A     R0,ANSWER+4\n         ST    R0,ENDPTR           END OF GETMAINED AREA\n         ST    R1,BLOCKPTR\n         A     R1,SAVBLKSI         POINT PAST BLOCK AREA\n         ST    R1,SPANPTR\n         A     R1,SAVSPANL         POINT PAST SPANNED RECORD AREA\n         ST    R1,HOLDPTR\n         A     R1,SAVHOLDL         POINT PAST HOLD AREA\n         ST    R1,CHKPTTOP\n         XC    0(16,R1),0(R1)      FIRST ENTRY IN TABLE\n         XC    DEBLOCKS(12),DEBLOCKS\n         XC    OFFSET,OFFSET\n         LH    R0,PAGESIZE         LINES PER PAGE\n         ST    R0,SCROLL\n         XR    R0,R0\n         ST    R0,FNDNUM\n         STH   R0,FNDOFF\n         ST    R0,CHKPTBOT\n         MVC   PERIODS,ASIST\n         SPACE 1\n*----------------------------------------------------------*\n*        INITIALIZE HOLD AREA DIRECTORY                    *\n*----------------------------------------------------------*\n         SPACE 1\n         LA    R7,HOLDDIR\n         XR    R0,R0\n         L     R15,HOLDPTR\n         TM    TSTRECFM,DCBRECV    RECFM V\n         BZ    *+L'*+4             NO\n         LA    R15,4(,R15)         YES, POINT 4 BYTES INTO EACH RECORD\n         LH    R8,PAGESIZE         LINES PER PAGE\nHOLDINIT ST    R0,DIRNUM(,R7)      PUT ZERO IN RECORD LENGTH\n         ST    R0,DIRLEN(,R7)      PUT ZERO IN RECORD NUMBER\n         ST    R15,DIRREC(,R7)     STORE ADDRESS OF HELD RECORD\n         A     R15,SAVLRECL        POINT TO NEXT HELD RECORD\n         LA    R1,DIRSIZ(,R7)      POINT TO NEXT ENTRY\n         ST    R1,DIRNXT(,R7)      STORE ITS ADDRESS IN THIS ENTRY\n         LR    R14,R7              SAVE LAST ENTRY\n         LR    R7,R1               MAKE NEXT ENTRY THIS ENTRY\n         BCT   R8,HOLDINIT         DO IT FOR ALL BUT LAST ENTRY\n         LA    R1,HOLDDIR          ADDRESS OF FIRST ENTRY\n         ST    R1,DIRNXT(,R14)     CLOSE THE CIRCLE\n         ST    R1,HOLDTOP          START WITH FIRST AS TOP\n         SPACE 1\n*----------------------------------------------------------*\n*        POINT TO MEMBER                                   *\n*----------------------------------------------------------*\n         SPACE 1\n         MVC   BLDL(4),=AL2(1,76)\n         MVC   BLDL+4(8),$MEMBER\n        BLDL   (R4),BLDL\n         LTR   R15,R15             WAS BLDL SUCCESSFUL\n         BNZ   NOMEM               NO, BRANCH\n         MVC   TTR,BLDL+12\n         MVC   TTRK,BLDL+12\n        FIND   (R4),TTRK,C\n         B     NEWNAME\nNOMEM    MVC   MSG(MSG36L),MSG36   MEMBER NOT FOUND\n         CH    R15,=H'4'\n         BE    *+L'*+6\n         MVC   MSG(MSG37L),MSG37   BLDL FAILED\n         OI    STATUS,STNOMEM\n         SPACE 1\n*----------------------------------------------------------*\n*        BUILD TOP LINE                                    *\n*----------------------------------------------------------*\n         SPACE 1\nNEWNAME  L     R1,SCREENH\n         MVC   0(SCREENL,R1),SCREEN\n         LA    R15,SCRRTA+3-SCREEN(R1)\n         CLI   PAGESIZE+1,23       3278-5?\n         BNE   *+L'*+6             NO, BRANCH\n         MVC   0(2,R15),=X'C2CA'   YES, ADD ADDRESS FOR 27X132\n         LA    R15,SCRMEM+2-SCREEN(R1)\n         MVC   0(8,R15),$MEMBER\n         LA    R15,SCRSUB+2-SCREEN(R1)\n         MVC   0(8,R15),$SUBCOM\n         BAL   R14,FILLHOLD\n         B     FILLSCR\n         SPACE 1\n*----------------------------------------------------------*\n*        READ ENOUGH RECORDS TO FILL HOLD AREA ROUTINE     *\n*----------------------------------------------------------*\n         SPACE 1\nFILLHOLD ST    R14,HOLDR\n         L     R6,HOLDPTR\n         LR    R0,R6\n         L     R1,SAVHOLDL\n         XR    R14,R14\n         L     R15,=A(X'40000000')\n         MVCL  R0,R14              FILL HOLD AREA WITH BLANKS\n         L     R7,HOLDTOP          POINT TO HOLD AREA DIRECTORY\n         LH    R8,PAGESIZE         NUMBER OF DATA LINES PER SCREEN\nHILLOOP  BAL   R14,GET\n         LA    R0,1                COMPUTE\n         A     R0,COUNT              THE\n         ST    R0,COUNT                RECORD NUMBER\n         ST    R0,DIRNUM(,R7)      STORE THE RECORD NUMBER\n         ST    R1,DIRLEN(,R7)      LENGTH IN DIRECTORY\n         LTR   R1,R1               END OF FILE\n         BM    HILLED              YES BRANCH\n         C     R1,SAVLRECL         IS RECORD LONGER THAN MAX\n         BNH   *+L'*+4             NO, SKIP NEXT INSTR\n         L     R1,SAVLRECL         YES, TRUNCATE TO MAX\n         LR    R0,R2               ADDRESS TO MOVE FROM\n         L     R14,DIRREC(,R7)     ADDRESS TO MOVE TO\n         TM    TSTRECFM,DCBRECV    RECFM V\n         BZ    HILLNOTV            NO\n         SH    R14,=H'4'           YES, MOVE TO PTR MINUS 4\n         L     R15,DIRLEN(,R7)\n         SH    R15,=H'4'\n         ST    R15,DIRLEN(,R7)\nHILLNOTV LR    R15,R1              LENGTH FOR MOVE\n         MVCL  R14,R0\n         LR    R1,R7               SAVE PTR TO MOST CURRENT ENTRY\n         L     R7,DIRNXT(,R7)      POINT TO NEXT DIRECTORY ENTRY\n         BCT   R8,HILLOOP\n         LR    R7,R1               GET MOST CURRENT ENTRY\nHILLED   ST    R7,HOLDEND          SAVE LAST RECORD ENTRY\n         L     R14,HOLDR\n         BR    R14\n         SPACE 1\n*----------------------------------------------------------*\n*        SET UP THE SCREEN HEADER PRIOR TO DISPLAY         *\n*----------------------------------------------------------*\n         SPACE 1\nFILLSCR  L     R1,SCREENH\n         LA    R15,SCRERR+2-SCREEN(,R1)\n         MVC   0(31,R15),SCRERR+2  RESET THE HEADER DATA\n         L     R1,SCREENH\n         LA    R1,SCRRGE+2-SCREEN(,R1)\n         L     R0,SCROLL           DEFAULT SCROLL\n         CVD   R0,DOUBLE\n         OI    DOUBLE+7,X'0F'\n         UNPK  0(2,R1),DOUBLE+6(2)\n         L     R1,SCREENH\n         LA    R15,SCRCOL-SCREEN(,R1)\n         MVC   0(8,R15),BLANKS\n         LH    R1,OFFSET\n         LA    R1,1(,R1)\n         LA    R0,79(,R1)\n         TM    MDFL,MODEX\n         BZ    *+L'*+4\n         SH    R0,=H'40'\n         CH    R0,RECSIZE\n         BNH   *+L'*+4\n         LH    R0,RECSIZE\n         CVD   R1,DOUBLE\n         OI    DOUBLE+7,X'0F'\n         CH    R1,=H'1000'\n         BL    FILL3DIG\n         UNPK  0(4,R15),DOUBLE+5(3)\n         CVD   R0,DOUBLE\n         OI    DOUBLE+7,X'0F'\n         UNPK  5(3,R15),DOUBLE+6(2)\n         B     FILLCOLX\nFILL3DIG UNPK  0(3,R15),DOUBLE+6(2)\n         CVD   R0,DOUBLE\n         OI    DOUBLE+7,X'0F'\n         UNPK  4(3,R15),DOUBLE+6(2)\n         SPACE 1\n*----------------------------------------------------------*\n*        SET UP THE COLUMN HEADER PRIOR TO DISPLAY         *\n*----------------------------------------------------------*\n         SPACE 1\n*              IT WOULD BE MORE EFFICIENT TO DO MOST OF THIS WORK\n*              ONLY WHEN THE OFFSET IS INITIALIZED OR CHANGED\n*              AND SAVE THE RESULTS.\nFILLCOLX L     R1,SCREENH\n         LA    R6,SCRDATA-SCREEN(,R1)\n         MVC   0(52,R6),BLANKS     BLANK THE FOLLOWING AREA\n         CLI   PAGESIZE+1,23       3278-5?\n         BNE   *+L'*+4             NO, BRANCH\n         LA    R6,52(,R6)          YES, ADD 52 BLANKS\n         MVC   0(132,R6),BLANKS    ADD 132 BLANKS\n         MVC   132(132,R6),BLANKS  ADD 132 BLANKS\n         LH    R1,OFFSET\n         LTR   R1,R1               IS OFFSET ZERO\n         BNZ   FILLCOLS            NO\n         TM    MDFL,MODEX          YES, SPECIAL CASE, 1\n         BZ    *+L'*+8\n         MVI   1(R6),C'1'\n         B     FILLCOLS\n         MVI   0(R6),C'1'\nFILLCOLS XR    R0,R0\n         LA    R14,10\n         DR    R0,R14\n         SR    R14,R0              10 MINUS REMAINDER\n         LTR   R0,R0               WAS REMAINDER 0\n         BZ    *+L'*+2             YES, USE 0, NOT 10\n         LR    R0,R14\n         LR    R14,R6\n         TM    MDFL,MODEX\n         BZ    *+L'*+2\n         ALR   R14,R0\n         ALR   R14,R0              ADD (0 TO 9) TO LINE\n         BCTR  R14,0               START AT LINE-1 FOR OFFSET 0\n*                                  LINE+8 FOR OFFSET 1\n*                                  LINE+7 FOR OFFSET 2\n*                                  LINE+6 FOR OFFSET 3\n*                                  LINE+0 FOR OFFSET 9\n         LH    R1,OFFSET\n         AR    R1,R0               ADD (0 TO 9) TO OFFSET\n         LA    R0,9\nCOLNUML  CH    R1,RECSIZE\n         BH    COLNUMX\n         CVD   R1,DOUBLE\n         MVC   COLNUM,=X'402020202120'\n         ED    COLNUM,DOUBLE+5\n         CH    R1,=H'10000'        10000-32768\n         BNL   COLNUMN             YES, USE NNNNN\n         MVC   COLNUM(5),COLNUM+1\n         MVI   COLNUM+5,C' '\n         CH    R1,=H'100'          100-999\n         BNL   COLNUMN             YES, USE XNNNX\n         MVC   COLNUM(5),COLNUM+1  USE XNNXX\n         MVI   COLNUM+5,C' '\nCOLNUMN  SH    R14,=H'2'\n         CR    R14,R6\n         BL    *+L'*+6\n         MVC   0(5,R14),COLNUM+1\n         LA    R14,12(,R14)\n         TM    MDFL,MODEX\n         BZ    *+L'*+8\n         AH    R1,=H'5'\n         B     *+L'*+4\n         AH    R1,=H'10'\n         BCT   R0,COLNUML\nCOLNUMX  AH    R6,PAGEWIDT\n         LH    R1,OFFSET\n         CH    R1,RECSIZE\n         BL    MARKC\n         MVI   0(R6),C' '\n         MVC   1(79,R6),0(R6)\n         B     MARKX\nMARKC    XR    R0,R0\n         LA    R14,10\n         DR    R0,R14\n         TM    MDFL,MODEX\n         BZ    MARKD\n         L     R14,=A(MARKHS)\n         ALR   R14,R0\n         ALR   R14,R0\n         LH    R1,RECSIZE\n         SH    R1,OFFSET\n         SLL   R1,1\n         B     MARKL\nMARKD    L     R14,=A(MARKS)\n         ALR   R14,R0\n         LH    R1,RECSIZE\n         SH    R1,OFFSET\nMARKL    CH    R1,=H'80'\n         BL    MARKE\n         MVC   0(80,R6),0(R14)\n         B     MARKX\nMARKE    MVI   0(R6),C' '\n         MVC   1(79,R6),0(R6)\n         BCT   R1,*+L'*+6\n         MVC   0(*-*,R6),0(R14)\n         EX    R1,*-6\nMARKX    AH    R6,PAGEWIDT\n         SPACE 1\n*----------------------------------------------------------*\n*        FILL IN THE DATA AREA OF THE SCREEN               *\n*----------------------------------------------------------*\n         SPACE 1\n         XR    R5,R5\n         L     R7,HOLDTOP\n         L     R1,SCREENH\n         LA    R15,SCRLINE-SCREEN(,R1)\n         L     R1,DIRNUM(,R7)      GET NUMBER OF FIRST LINE\n         CVD   R1,DOUBLE\n         OI    DOUBLE+7,X'0F'\n         UNPK  0(5,R15),DOUBLE+5(3)\n         L     R1,SCREENH\n         LA    R1,SCRERR+2-SCREEN(,R1)\n         MVC   SAVELINE(31),0(R1)  SAVE LINE AND COLUMN\n         LH    R8,PAGESIZE         NUMBER OF DATA LINES\n         CLI   HELPFLG,C'H'        HELP REQUESTED?\n         BNE   FILBUG              NO, BRANCH\n         L     R15,=V(HELMSGS)     START OF HELP MESSAGES MODULE\n         L     R1,0(R15)           HELP MESSAGES ADDRESS\n         L     R14,APFKTB\nFILHEL1  MVC   0(132,R6),BLANKS    INITIALIZE WITH BLANKS\n         CLI   0(R1),X'FF'         END OF MESSAGES?\n         BE    FILHEL3             YES, BRANCH\n         MVC   0(80,R6),0(R1)      MOVE IN THE NEXT MESSAGE\n         CL    R1,12(R15)          ARE WE PROCESSING PFK'S?\n         BL    FILHEL2             NO\n         CLC   1(L'PFKTAB-1,R14),BLANKS YES, FILL IN PFK'S VALUES\n         BE    *+L'*+10\n         MVC   6(L'PFKTAB-1,R6),1(R14)\n         B     *+L'*+6\n         MVC   6(8,R6),4(R15)      INSERT (NONE)\n         LA    R14,L'PFKTAB(R14)\n         CLC   1(L'PFKTAB-1,R14),BLANKS YES, FILL IN PFK'S VALUES\n         BE    *+L'*+10\n         MVC   46(L'PFKTAB-1,R6),1(R14)\n         B     *+L'*+6\n         MVC   46(8,R6),4(R15)      INSERT (NONE)\n         LA    R14,L'PFKTAB(R14)\nFILHEL2  LA    R1,80(,R1)          NEXT HELP TEXT\nFILHEL3  AH    R6,PAGEWIDT         ADD LINE WIDTH\n         LA    R5,1(,R5)           COUNT LINES FILLED IN\n         BCT   R8,FILHEL1          DO ALL HELP MESSAGES\n         B     FILLED\nFILBUG   CLI   HELPFLG,C'D'        DEBUG REQUESTED?\n         BNE   FILLOOP             NO, BRANCH\n*------- DEBUG - TGET REGISTERS 15-1\n         MVC   0(132,R6),BLANKS    INITIALIZE WITH BLANKS\n         LA    R5,1(,R5)           COUNT LINES FILLED IN\n         MVC   0(9,R6),=C'TGET R15:'\n         LA    R1,TGETREG2         POINT TO R15, R0, R1\n         LA    R0,4                FIRST 4 BYTES (R15)\n         LA    R15,9(,R6)\n         BAL   R14,HEX\n         MVC   1(3,R15),=C'R0:'\n         LA    R15,4(,R15)\n         LA    R0,4                SECOND 4 BYTES (R0)\n         BAL   R14,HEX\n         MVC   1(3,R15),=C'R1:'\n         LA    R15,4(,R15)\n         LA    R0,4                THIRD 4 BYTES (R1)\n         BAL   R14,HEX\n         CLC   TGETREG2+8(4),=F'128'\n         BNH   *+L'*+6\n         MVC   1(10,R15),=C'/ TOO LONG'\n*------- DEBUG - REPLY AREA (CHARACTERS)\n         AH    R6,PAGEWIDT         ADD LINE WIDTH\n         MVC   0(132,R6),BLANKS    INITIALIZE WITH BLANKS\n         LA    R5,1(,R5)           COUNT LINES FILLED IN\n         LA    R1,REPLY+128        REPLY AREA\n         L     R14,TGETREG2+8      REPLY LENGTH RETURNED BY TGET\n         CL    R14,=F'128'\n         BNH   *+L'*+4\n         L     R14,=F'128'\n         LA    R15,0(,R6)\n         S     R14,=F'1'\n         BM    FILLED\n         MVC   0(5,R15),=C'R-C.:'  CHARACTER HEADER\n         CL    R14,=F'63'\n         BNH   FILBUG1\n         MVC   5(64,R15),0(R1)     MOVE IN THE CHARACTER VERSION\n         TR    5(64,R15),ASIST     TRANSLATE UNPRINTABLES\n         MVC   70(6,R15),=C'<<<-C-'\n         AH    R6,PAGEWIDT         ADD LINE WIDTH\n         MVC   0(132,R6),BLANKS    INITIALIZE WITH BLANKS\n         LA    R5,1(,R5)           COUNT LINES FILLED IN\n         LA    R1,64(R1)           FURTHER IN REPLY AREA\n         S     R14,=F'63'\n         LA    R15,0(,R6)\nFILBUG1  EX    R14,FILBUGM         MOVE IN THE CHARACTER VERSION\n         EX    R14,FILBUGT         TRANSLATE UNPRINTABLES\n         LA    R15,7(R15,R14)\n         MVC   0(6,R15),=C'<<<-E-'\n*------- DEBUG - REPLY AREA (HEXADECIMAL)\n         AH    R6,PAGEWIDT         ADD LINE WIDTH\n         MVC   0(132,R6),BLANKS    INITIALIZE WITH BLANKS\n         MVC   0(5,R6),=C'R-H.:'   HEXADECIMAL HEADER\n         LA    R5,1(,R5)           COUNT LINES FILLED IN\n         LA    R1,REPLY+128        REPLY AREA\n         L     R2,TGETREG2+8       REPLY LENGTH RETURNED BY TGET\n         CL    R2,=F'128'\n         BNH   FILBUG2\n         L     R2,=F'128'\nFILBUG2  L     R0,=F'32'\n         LA    R15,5(,R6)\n         CLR   R2,R0\n         BH    *+L'*+2\n         LR    R0,R2\n         BAL   R14,HEX             CONVERT REPLY TO HEX\n         AH    R6,PAGEWIDT         ADD LINE WIDTH\n         S     R2,=F'32'\n         BNP   FILLED\n         MVC   0(132,R6),BLANKS    INITIALIZE WITH BLANKS\n         LA    R5,1(,R5)           COUNT LINES FILLED IN\n         B     FILBUG2\nFILBUGM  MVC   5(*-*,R15),0(R1)    <<EXECUTED>>\nFILBUGT  TR    5(*-*,R15),ASIST    <<EXECUTED>>\nFILLOOP  MVI   HELPFLG,0           REFRESH OF SCREEN NO LONGER REQUIRED\n         LM    R1,R2,DIRLEN(R7)    GET LENGTH AND ADDRESS\n         LTR   R1,R1\n         BM    FILBOT\n         MVC   0(132,R6),BLANKS    FILL LINE WITH BLANKS\n         BZ    FILNUL              BRANCH IF R1 ZERO\n         SH    R1,OFFSET           IS OFFSET BEYOND END OF RECORD\n         BNP   FILLNEXT            YES, LEAVE LINE BLANK\n         AH    R2,OFFSET\n         TM    MDFL,MODEX\n         BO    FILLHEX\n         LA    R0,80\n         CR    R1,R0\n         BNH   *+L'*+2\n         LR    R1,R0\n         CR    R1,R0\n         BNE   FILLN80\n         CH    R1,RECSIZE          IF LRECL=80, USE ONLY 72\n         BNE   FILLN80\n         LA    R1,72\nFILLN80  BCT   R1,*+L'*+6\n         MVC   0(*-*,R6),0(R2)\n         EX    R1,*-6\n         TR    0(80,R6),PERIODS\n         B     FILLNEXT\nFILLHEX  CH    R1,=H'40'\n         BNH   *+L'*+4\n         LA    R1,40\n         LR    R0,R1\n         LR    R1,R2\n         LR    R15,R6\n         BAL   R14,HEX\n         B     FILLNEXT\nFILNUL   MVC   0(6,R6),=C'(NULL)'\n         B     FILLNEXT\nFILLNEXT LA    R5,1(,R5)           COUNT LINES FILLED IN\n         AH    R6,PAGEWIDT         ADD LINE WIDTH\n         L     R7,DIRNXT(,R7)\n         BCT   R8,FILLOOP\n         B     FILLED\nFILBOT   MVI   0(R6),C'*'\n         MVC   1(79,R6),0(R6)\n         MVC   32(16,R6),=C' BOTTOM OF DATA '\n         AH    R6,PAGEWIDT         ADD LINE WIDTH\n         LA    R5,1(,R5)           COUNT LINES FILLED IN\nFILLED   CH    R5,PAGESIZE         IS SCREEN FILLED UP\n         BNL   NOPAD\n         MVC   0(4,R6),SCRPAD      FILL REMAINING LINES WITH BLANKS\n         LA    R6,4(,R6)\nNOPAD    MVC   0(4,R6),SCRSUF      SET CURSOR ADDRESS\n         CLI   PAGESIZE+1,23       3278-5?\n         BNE   *+L'*+6             NO, BRANCH\n         MVC   1(2,R6),=X'C2D4'    YES, ADD ADDRESS FOR 02X17\n         LA    R6,4(,R6)\n         ST    R6,SCREENF          STORE END-OF-SCREEN FOR TPUT\nPROMPT   NI    MDFL,255-HELPFX\n         CLI   HELPFLG,C'H'        HELP?\n         BE    PROMPT1             YES, BRANCH\n         CLI   HELPFLG,C'R'        REFRESH REQUIRED?\n         BNL   FILLSCR             YES, BRANCH\n         CLI   HELPFLG,C'D'        DEBUG?\n         BNE   PROMPT2             NO, BRANCH\n         MVI   HELPFLG,C'S'        REFRESH REQUIRED (NEXT TIME)\n         B     PROMPT2\nPROMPT1  MVI   HELPFLG,C'R'        REFRESH REQUIRED (NEXT TIME)\n         OI    MDFL,HELPFX\nPROMPT2  L     R1,SCREENH\n         LA    R15,SCRMEM+2-SCREEN(R1)\n         MVC   0(8,R15),$MEMBER    MOVE IN MEMBER NAME\n         L     R1,SCREENH\n         LA    R15,SCRSUB+2-SCREEN(R1)\n         MVC   0(8,R15),$SUBCOM    MOVE IN SUBCOMMAND NAME\n         L     R1,SCREENH\n         LA    R15,SCRERR+2-SCREEN(,R1)\n         MVC   0(31,R15),SAVELINE  RESET LINE AND COLUMN\n         LH    R1,MSG              GET LENGTH OF MESSAGE\n         LTR   R1,R1               IS THERE A MESSAGE\n         BZ    PROMPT3             NO, BRANCH\n         CH    R1,=H'28'           MSG TOO LONG?\n         BNH   *+L'*+4             NO, BRANCH\n         LA    R1,28               YES, TRUNCATE IT\n         MVI   0(R15),C'-'\n         MVC   1(30,R15),0(R15)\n         BCT   R1,*+L'*+6          LENGTH-1 FOR EX\n         MVC   2(*-*,R15),MSG+2\n         EX    R1,*-6              PROPAGATE THE DASHES\n         LA    R15,3(R1,R15)\n         MVI   0(R15),C' '\n         XC    MSG(2),MSG          SET OFF MESSAGE FLAG\nPROMPT3  TM    MEMBFLG,MEMBFLGM+MEMBFLGS NEW COMMAND OR SUBCOMMAND?\n         MVI   MEMBFLG,0\n         BNZ   PARSED              YES, CONTINUE WITH PARSE\n         L     R1,SCREENH\n         L     R0,SCREENF\n         SR    R0,R1               COMPUTE SIZE OF SCREEN\n         CLI   SKV,X'FF'           INITIALIZATION PROCESSING COMPLETED?\n         BE    PROMPT5             NO, BRANCH\n         MVI   SKV,X'FF'\n         TM    STATUS,STNOMEM      MEMBER FOUND?\n         BO    PROMPT5             NO, BRANCH\n         LA    R14,13\n         LA    R15,REPLY           START OF REPLY AREA\n         MVC   0(13,R15),=X'7DC16111C160C6F1405D4040F1'\n         CLI   OKV+1,1             OPERAND CODED?\n         BNE   *+L'*+4             NO, BRANCH\n         MVI   REPLY+10,C'O'       YES, SUBSTITUTE THE SEARCH CHARACTER\n         CLI   SKV+1,1             OPERAND CODED?\n         BNE   *+L'*+4             NO, BRANCH\n         MVI   REPLY+10,C'X'       YES, SUBSTITUTE THE SEARCH CHARACTER\n         CLI   FKV+1,1             OPERAND CODED?\n         BNE   *+L'*+4             NO, BRANCH\n         MVI   REPLY+10,C'F'       YES, SUBSTITUTE THE SEARCH CHARACTER\n         CLI   AKV+1,1             OPERAND CODED?\n         BNE   *+L'*+4             NO, BRANCH\n         MVI   REPLY+10,C'F'       YES, SUBSTITUTE THE SEARCH CHARACTER\n         CLI   REPLY+10,C'O'       \"O\" OPERAND ONLY?\n         BNE   PROMPT4             NO, BRANCH\n         CLI   $OPERAND,C' '       ANY OPERANDS?\n         BE    SKIPTGET            NO, BRANCH\n         MVI   REPLY+10,C')'       YES, SUBSTITUTE THE SEARCH CHARACTER\nPROMPT4  CLI   REPLY+10,C' '       ANY SEARCH CHARACTER?\n         BH    SKIPTGET            YES, BRANCH\n         CLI   $SUBLINE,C'Y'       ANY SUBCOMMAND?\n         BNE   SKIPTGET            YES, BRANCH\n         CLI   FILEKV,C'S'         COMMAND WITH SUBCOMMANDS?\n         BNE   SKIPTGET            NO, BRANCH\n         MVI   REPLY+10,C'S'       LIST THE SUBCOMMANDS\n         B     SKIPTGET\nPROMPT5 TPUT   (1),(0),FULLSCR\n         SPACE 1\n*----------------------------------------------------------*\n*        READ REPLY FROM THE TERMINAL                      *\n*----------------------------------------------------------*\n         SPACE 1\n         MVC   REPLY+128(128),REPLY FOR DEBUG\n         MVC   TGETREG2(12),TGETREGS FOR DEBUG\n         XC    REPLY(128),REPLY    TO SIMPLIFY DEBUGGING\n         LA    R1,REPLY\n         LA    R0,128\n        TGET   (1),(0),ASIS        GET REPLY\n         STM   R15,R1,TGETREGS\n         CH    R15,=H'12'          WAS REPLY AREA LONG ENOUGH\n         BNE   TGETOK              YES, BRANCH\n        TCLEARQ INPUT\nTGETOK   LA    R15,REPLY\n*        REPLY AREA CONTENTS :\n*              OFFSET 0 LENGTH 1  -  ID OF KEY\n*              OFFSET 1 LENGTH 2  -  ADDRESS OF CURSOR\n*              OFFSET 3 LENGTH 1  -  X'11' IF ANY FIELDS MODIFIED\n*              OFFSET 4 LENGTH 2  -  SCREEN ADDRESS OF FIELD\n*              OFFSET 6 LENGTH V  -  DATA FROM FIELD\n*              DATA EXTENDS TO END OF BUFFER OR NEXT X'11'\n         OI    REPLY,X'30'         MAKE PFK 13-24 LOOK LIKE 1-12\n         L     R14,TGETREGS+8      GET LENGTH OF REPLY\n         CH    R14,=H'3'           ANYTHING BEYOND CURSOR ADDRESS\n         BNH   CMDNULL             NO, BRANCH\n         CLI   3(R15),X'11'        SBA (SHOULD ALWAYS BE PRESENT)\n         BNE   CMDNULL             NO\n         SPACE 1\n*----------------------------------------------------------*\n*        PROCESS FIELDS IN TGET BUFFER                     *\n*----------------------------------------------------------*\n         SPACE 1\nSKIPTGET MVI   MEMBFLG,0           CLEAR THE MEMBER FLAGS\n         XR    R0,R0\n         ST    R0,CMDPTR           START WITH COMMAND-NOT-PRESENT\n         BCT   R14,TRTSBA+L'TRTSBA LENGTH-1 FOR EX\nTRTSBA   TRT   0(*-*,R15),FINDSBA\n         EX    R14,TRTSBA\n         BZ    CMDNULL             NO FIELDS PRESENT\n         LR    R0,R1               ADDRESS OF SBA\n         SR    R0,R15              LENGTH OF PRECEDING DATA\n         SR    R14,R0              LENGTH CODE OF REMAINING DATA\n         BZ    PARSED              BRANCH IF NOTHING FOLLOWS SBA\nLOOP     ST    R1,FLDPTR\n         LA    R15,1(,R1)          POINT PAST SBA\n         BCTR  R14,0               REDUCE LENGTH ACCORDINGLY\n         EX    R14,TRTSBA          LOOK FOR SECOND SBA\n         BZ    LAST                BRANCH IF NONE PRESENT\n         LR    R0,R1               POINT TO NEXT SBA\n         SR    R0,R15              GET LENGTH OF THIS DATA\n         ST    R0,FLDLEN\n         STM   R14,R1,SBASAVE\n         BAL   R2,FIELD\n         LM    R14,R1,SBASAVE\n         SR    R14,R0              LENGTH CODE OF REMAINING DATA\n         BNZ   LOOP                SOMETHING FOLLOWS SECOND SBA\n         B     PARSED              NOTHING FOLLOWS SECOND SBA\nLAST     LA    R0,1(,R14)          GET LENGTH OF THIS DATA\n         ST    R0,FLDLEN\n         BAL   R2,FIELD\n         B     PARSED\n         SPACE 1\n*----------------------------------------------------------*\n*        ANALYZE A TGET FIELD ROUTINE                      *\n*----------------------------------------------------------*\n         SPACE 1\nFIELD    L     R15,FLDPTR          POINT TO SBA FOR FIELD\n         L     R1,FLDLEN           GET LENGTH CODE\n         SH    R1,=H'3'            GET LENGTH CODE OF DATA\n         BMR   R2                  NO DATA PRESENT\n         CLC   1(2,R15),FLD1AA     NEW MEMBER?\n         BE    FLDA\n         CLC   1(2,R15),FLD2AA     NEW SUBCOMMAND?\n         BE    FLDB\n         CLC   1(2,R15),FLD1BA     IS IT COMMAND?\n         BE    FLD1\n         CLC   1(2,R15),FLD1BB     IS IT COMMAND ON 3278-5?\n         BE    FLD1\n         CLC   1(2,R15),FLD2BA     IS IT RANGE?\n         BE    FLD2\n         CLC   1(2,R15),FLD2BB     IS IT RANGE ON 3278-5?\n         BE    FLD2\n         BR    R2                  USER MUST HAVE USED CLEAR KEY\nFLDA     LA    R15,3(,R15)         POINT TO MEMBER NAME\nFLDABL   MVC   DOUBLE(8),BLANKS\n         EX    R1,FLDOC            MOVE AND UPPER-CASE\n         CLC   DOUBLE(8),BLANKS    ALL BLANKS?\n         BER   R2                  YES, BRANCH\n         LA    R15,1(,R15)         NEXT CHARACTER\n         SH    R1,=H'1'            ANY CHARACTERS?\n         BMR   R2                  NO, BRANCH\n         CLI   DOUBLE,C' '         BLANK FIRST CHARACTER?\n         BE    FLDABL              YES, BRANCH\n         MVC   BLDL+4(8),DOUBLE    NEW COMMAND NAME\n         OI    MEMBFLG,MEMBFLGM    NEW MEMBER NAME\n         BR    R2                  RETURN\nFLDOC    OC    DOUBLE(*-*),0(R15)  <<EXECUTED>>\nFLDB     LA    R15,3(,R15)         POINT TO SUBCOMMAND\nFLDBBL   MVC   DOUBLE(8),BLANKS\n         EX    R1,FLDOC            MOVE AND UPPER-CASE\n         CLC   DOUBLE(8),BLANKS    ALL BLANKS?\n         BER   R2                  YES, BRANCH\n         LA    R15,1(,R15)         NEXT CHARACTER\n         SH    R1,=H'1'            ANY CHARACTERS?\n         BMR   R2                  NO, BRANCH\n         CLI   DOUBLE,C' '         BLANK FIRST CHARACTER?\n         BE    FLDBBL              YES, BRANCH\n         MVC   $SUBCOM(8),DOUBLE   NEW SUBCOMMAND NAME\n         OI    MEMBFLG,MEMBFLGS    NEW SUBCOMMAND\n         MVI   $SUBLINE,C'N'       NOT YET SATISFIED\n         BR    R2                  RETURN\nFLD1     LA    R15,3(,R15)         POINT TO COMMAND\n         ST    R15,CMDPTR          SAVE FOR LATER\n         ST    R1,CMDLEN           SAVE LENGTH CODE FOR LATER\n         BR    R2                  RETURN\nFLD2     LA    R15,3(,R15)         POINT TO RANGE\n         CH    R1,=H'1'            IS IT 2 BYTES\n         BNE   FLD2A               NO, BRANCH\n         CLC   0(2,R15),BLANKS     BLANK\n         BER   R2                  YES, IGNORE\n         CLI   0(R1),C' '          LEADING BLANK\n         BNE   *+L'*+4             NO, BRANCH\n         MVI   0(R1),C'0'          CHANGE TO LEADING ZERO\n         CLI   1(R15),C' '         TRAILING BLANK\n         BNE   FLD2A               NO, BRANCH\n         BCTR  R1,0                YES, REDUCE LENGTH BY 1\nFLD2A    LR    R14,R2              SAVE R2\n         EX    R1,TRTNUM           IS DATA NUMERIC\n         LR    R2,R14              RESTORE R2\n         BNZR  R2                  NOT NUMERIC, BRANCH\n         EX    R1,FLD2PACK         PACK IT\n         CVB   R1,DOUBLE           CONVERT TO BINARY\n         LTR   R1,R1               IS IT ZERO\n         BZ    0(,R2)              YES, IGNORE\n         CH    R1,PAGESIZE         IT IT GREATER THAN SCREEN SIZE\n         BHR   R2                  YES, IGNORE\n         ST    R1,SCROLL           SET NEW RANGE\n         LR    R0,R1\n         L     R1,SCREENH\n         LA    R1,SCRRGE+2-SCREEN(,R1)\n         CVD   R0,DOUBLE\n         OI    DOUBLE+7,X'0F'\n         UNPK  0(2,R1),DOUBLE+6(2)\n         BR    R2\nTRTNUM   TRT   0(*-*,R15),NUMERIC  <<EXECUTED>>\nFLD2PACK PACK  DOUBLE(8),0(*-*,R15) <<EXECUTED>>\n         SPACE 1\n*----------------------------------------------------------*\n*        PREPARE THE COMMAND FOR PARSE                     *\n*----------------------------------------------------------*\n         SPACE 1\nPARSED   TM    MEMBFLG,MEMBFLGM    NEW MEMBER?\n         BO    MEMBER1             YES, BRANCH\n         TM    MEMBFLG,MEMBFLGS    NEW SUBCOMMAND?\n         BO    SUBCOMO             YES, BRANCH\n         L     R15,CMDPTR          POINT TO COMMAND\n         LTR   R15,R15             IS THERE A COMMAND\n         BZ    CMDNULL             NO, BRANCH TO CHECK PFK\n         L     R14,CMDLEN          GET LENGTH CODE\n         LA    R1,CMDAREA\n         MVI   0(R1),C' '\n         MVC   1(62,R1),0(R1)\n         EX    R14,CMDMOVE\n         LA    R0,30\nCMDJUST  CLI   0(R1),C' '          IS COMMAND LEFT JUSTIFIED\n         BNE   CMDJUSTX            YES, BRANCH\n         MVC   0(62,R1),1(R1)      SHIFT IT LEFT\n         MVI   62(R1),C' '         APPEND BLANK\n         BCT   R0,CMDJUST          REPEAT\nCMDJUSTX OC    0(63,R1),BLANKS     UPPER CASE\n         B     CMDSCAN\nCMDMOVE  MVC   0(*-*,R1),0(R15)    <<EXECUTED>>\nCMDNULL  CLI   REPLY,X'7D'         ENTER\n         BE    PROMPT              YES, NO ACTION\n         SPACE 1\n*----------------------------------------------------------*\n*        INTERPRET PROGRAM FUNCTION KEY                    *\n*----------------------------------------------------------*\n         SPACE 1\n*              NOTE - IF A COMMAND IS TYPED IN THEN\n*                     IT OVERRIDES THE PF KEY.\n         L     R1,APFKTB\nPFKSRCH  CLI   0(R1),0             END OF PFK TABLE\n         BE    NOTPFK              YES, NOT IN TABLE\n         CLC   0(1,R1),REPLY       DOES PFK CODE MATCH\n         BE    PFKMOVE             YES, BRANCH\n         LA    R1,L'PFKTAB(,R1)    NO, POINT TO NEXT ENTRY IN TABLE\n         B     PFKSRCH             KEEP SEARCHING THE TABLE\nPFKMOVE  CLI   1(R1),C' '          IS PFK DEFINITION EMPTY\n         BE    NOTPFK              YES, BRANCH\n         MVC   CMDAREA(63),BLANKS  BLANK THE AREA\n         MVC   CMDAREA(L'PFKTAB-1),1(R1) MOVE IN THE TEXT\n         LA    R1,CMDAREA          POINT TO ASSOCIATED COMMAND\n         SPACE 1\n*----------------------------------------------------------*\n*        PARSE THE COMMAND AND OPERANDS                    *\n*----------------------------------------------------------*\n         SPACE 1\nCMDSCAN  LR    R15,R1              POINT TO COLUMN 1\n         LA    R3,39               LENGTH CODE OF STATEMENT\n         LA    R6,OPDL             POINT TO OPERAND DESCRIPTOR LIST\n         XC    0(OPDLL,R6),0(R6)   ZERO THE OPDL\n         XR    R1,R1               INSURE HI ORDER BYTE ZERO\n         LA    R0,OPDLL/8-1        NUMBER OF ENTRIES IN O.D.L.\n*                                  MINUS 1 (LAST ODE WILL REMAIN ZERO)\nPARLOOP  XC    0(8,R6),0(R6)       ZERO THE OPERAND DESCRIPTOR ENTRY\n         EX    R3,TRTNONBL         FIND A NONBLANK\n         BZ    PARDONE             BRANCH IF ALL BLANKS\n         LR    R14,R1              GET ADDRESS OF STRING\n         SR    R14,R15             GET LENGTH OF PRECEDING BLANKS\n         SR    R3,R14              GET LENGTH OF REMAINING TEXT\n         LR    R15,R1              GET ADDRESS OF NONBLANK\n         CLI   0(R15),C''''        DOES OPERAND BEGIN WITH A QUOTE\n         BE    PARQUOTE            YES, BRANCH\n         EX    R3,TRTBLANK         FIND A BLANK\n         BZ    PARLAST             BRANCH IF NOT FOUND\n         LR    R14,R1              GET ADDRESS OF BLANK\n         SR    R14,R15             GET LENGTH OF FIELD\n         OI    6(R6),PRESENT       OPERAND PRESENT\n         ST    R15,0(,R6)          ADDRESS OF OPERAND\n         STH   R14,4(,R6)          LENGTH OF OPERAND\n         SR    R3,R14              GET LENGTH CODE OF REMAINING TEXT\n         BZ    PARDONE             BRANCH IF ONE TRAILING BLANK\n         LR    R15,R1              POINT TO BLANK\nPARNEXT  LA    R6,8(,R6)           POINT TO NEXT O.D.E.\n         BCT   R0,PARLOOP          GO PROCESS NEXT OPERAND\n         B     PARDONE             MAX OPERANDS PROCESSED\nTRTNONBL TRT   0(*-*,R15),TABNONBL <<EXECUTED>>\nTRTBLANK TRT   0(*-*,R15),TABBLANK <<EXECUTED>>\nTRTQUOTE TRT   0(*-*,R15),TABQUOTE <<EXECUTED>>\nPARQUOTE LA    R15,1(,R15)         POINT PAST QUOTE\n         LA    R1,1                VALUE 1\n         SR    R3,R1               REDUCE LENGTH CODE BY 1\n         BM    PARDONE             IGNORE QUOTE IN LAST COLUMN\n         EX    R3,TRTQUOTE         FIND THE NEXT QUOTE\n         BZ    PARLASTQ            NOT FOUND, USE ALL REM TEXT\n         LR    R14,R1              GET ADDRESS OF QUOTE\n         SR    R14,R15             GET LENGTH OF FIELD\n         OI    6(R6),PRESENT+QUOTED OPERAND PRESENT AND IN QUOTES\n         ST    R15,0(,R6)          ADDRESS OF OPERAND\n         STH   R14,4(,R6)          LENGTH OF OPERAND\n         SR    R3,R14              GET LENGTH CODE OF REM TEXT\n         BZ    PARDONE             BRANCH IF QUOTE WAS FINAL CHAR\n         LA    R15,1(,R1)          POINT TO CHAR AFTER ENDING QUOTE\n         BCTR  R3,0                REDUCE LENGTH CODE BY 1\n         B     PARNEXT             SET UP FOR NEXT OPERAND\nPARLASTQ OI    6(R6),QUOTED        OPERAND IN QUOTES\nPARLAST  LA    R14,1(,R3)          GET LENGTH\n         OI    6(R6),PRESENT       OPERAND PRESENT\n         ST    R15,0(,R6)          ADDRESS OF OPERAND\n         STH   R14,4(,R6)          LENGTH OF OPERAND\nPARDONE  L     R1,OPD0             POINT TO COMMAND\n         CLC   0(2,R1),=C'M '      MAX + PFK UP-DOWN-LEFT RIGHT\n         BE    PFALSO\n         CLI   0(R1),C'0'          NN + PFK UP-DOWN-LEFT-RIGHT\n         BNL   PFALSO\n         CLC   0(5,R1),=C'XCTL '\n         BE    XCTL\n         CLC   0(5,R1),=C'LEFT '\n         BE    LEFT\n         CLC   0(2,R1),=C'< '\n         BE    LEFT\n         CLC   0(6,R1),=C'RIGHT '\n         BE    RIGHT\n         CLC   0(2,R1),=C'> '\n         BE    RIGHT\n         CLC   0(3,R1),=C'UP '\n         BE    UP\n         CLC   0(2,R1),=C'- '\n         BE    UP\n         CLC   0(5,R1),=C'DOWN '\n         BE    DOWN\n         CLC   0(2,R1),=C'+ '\n         BE    DOWN\n         CLC   0(4,R1),=C'TOP '\n         BE    TOP\n         CLC   0(7,R1),=C'BOTTOM '\n         BE    BOTTOM\n         CLC   0(4,R1),=C'BOT '\n         BE    BOTTOM\n         CLC   0(5,R1),=CL8'HELP    '\n         BE    HELP\n         CLC   0(4,R1),=C'HEL '\n         BE    HELP\n         CLC   0(2,R1),=C'H '\n         BE    HELP\n         CLC   0(5,R1),=C'LIST '\n         BE    LIST\n         CLC   0(2,R1),=C'L '\n         BE    LIST\n         CLC   0(5,R1),=C'FIND '\n         BE    FIND\n         CLC   0(2,R1),=C'F '\n         BE    FIND\n         CLC   0(3,R1),=C'F1 '\n         BE    FND1\n         CLC   0(7,R1),=C'MEMBER '\n         BE    MEMBERP\n         CLC   0(4,R1),=C'MEM '\n         BE    MEMBERP\n         CLC   0(8,R1),=C'COMMAND '\n         BE    MEMBERP\n         CLC   0(4,R1),=C'COM '\n         BE    MEMBERP\n         CLC   0(7,R1),=C'SUBCOM '\n         BE    SUBCOMP\n         CLC   0(4,R1),=C'SUB '\n         BE    SUBCOMP\n         CLC   0(4,R1),=C'END '\n         BE    END0\n         CLC   0(5,R1),=C'ASIS '\n         BE    ASIS\n         CLC   0(5,R1),=C'CAPS '\n         BE    CAPS\n         CLC   0(4,R1),=C'HEX '\n         BE    HEXMODE\n         CLC   0(3,R1),=C'PFK'\n         BE    PFKSET\n         CLC   0(6,R1),=C'DEBUG '\n         BE    DEBUG\n         L     R8,=A(HELEXT)\n         CLC   0(4,R1),=C'TSO '\n         BER   R8\n         CLC   0(5,R1),=C'SNAP '\n         BE    4(R8)\n         MVC   MSG(MSG20L),MSG20\n         B     PROMPT\nNOTPFK   CLI   REPLY,X'7E'         RESHOW?\n         BE    FILLSCR             YES, BRANCH\n         MVC   MSG(MSG21L),MSG21\n         CLI   DEBUGSW,C'D'\n         BE    DEBUG\n         B     PROMPT\n         SPACE 1\n*----------------------------------------------------------*\n*        INTERPRET AMOUNT AND POSSIBLE PF KEY              *\n*----------------------------------------------------------*\n         SPACE 1\nPFALSO   CLI   REPLY,X'7D'         ENTER ONLY?\n         BE    PFABAD              YES, ERROR\n         L     R15,APFKTB\nPFASRCH  CLI   0(R15),0            END OF PFK TABLE\n         BE    PFABAD              YES, NOT IN TABLE\n         CLC   0(1,R15),REPLY      DOES PFK CODE MATCH\n         BE    PFAMOVE             YES, BRANCH\n         LA    R15,L'PFKTAB(,R15)  NO, POINT TO NEXT ENTRY IN TABLE\n         B     PFASRCH             KEEP SEARCHING THE TABLE\nPFAMOVE  CLI   1(R15),C' '         IS PFK DEFINITION EMPTY\n         BE    PFABAD              YES, BRANCH\n         LA    R15,1(,R15)         POINT TO ASSOCIATED COMMAND\n         CLI   0(R1),C'M'          MAXIMUM?\n         BNE   PFAMOUNT            NO, BRANCH\n         CLC   0(3,R15),=C'UP '\n         BE    TOP\n         CLC   0(5,R15),=C'DOWN '\n         BE    BOTTOM\n         CLC   0(5,R15),=C'LEFT '\n         BE    LEFTALL\n         CLC   0(6,R15),=C'RIGHT '\n         BE    RIGHTALL\n         B     PFABAD\nPFAMOUNT MVC   OPD1(8),OPD0        MOVE THE OPERANDS UP ONE\n         LR    R1,R15              POINT TO THE PFK TEXT\n         ST    R1,OPD0             POINT TO THE SUBCOMMAND\n         CLC   0(3,R1),=C'UP '\n         BE    PARDONE\n         CLC   0(5,R1),=C'DOWN '\n         BE    PARDONE\n         CLC   0(5,R1),=C'LEFT '\n         BE    PARDONE\n         CLC   0(6,R1),=C'RIGHT '\n         BE    PARDONE\nPFABAD   MVC   MSG(MSG20L),MSG20\n         B     PROMPT\n         SPACE 1\n*----------------------------------------------------------*\n*        XCTL                                              *\n*----------------------------------------------------------*\n         SPACE 1\nXCTL     LA    R15,16\n         STH   R15,RC              SET RETURN CODE TO 16\n         B     END1\n         SPACE 1\n*----------------------------------------------------------*\n*        RIGHT                                             *\n*----------------------------------------------------------*\n         SPACE 1\nRIGHT    LA    R15,OPD1            GET FIRST OPERAND ENTRY\n         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS\n         BZ    RIGHTDEF            NO, USE DEFAULT\n         TM    6(R15),QUOTED       IS OPERAND QUOTED\n         BO    ERRINV              YES, INVALID\n         LH    R1,4(,R15)          GET LENGTH\n         LTR   R1,R1               IS IT NULL STRING\n         BZ    ERRINV              YES, ERROR\n         CH    R1,=H'7'            IS LENGTH MORE THAN 7\n         BH    ERRINV              YES, ERROR\n         L     R14,0(,R15)         GET ADDRESS OF DATA\n         BCT   R1,*+L'*+6\n         TRT   0(*-*,R14),NUMERIC\n         EX    R1,*-6              IS IT NUMERIC\n         BNZ   ERRINV              NO, ERROR\n         B     *+L'*+6\n         PACK  DOUBLE(8),0(*-*,R14)\n         EX    R1,*-6\n         CVB   R1,DOUBLE\n         LTR   R15,R1\n         BZ    PROMPT\n         B     RIGHTR15\nRIGHTALL MVI   OFFSET,X'7F'\n         MVI   OFFSET+1,X'AF'      AFTER ADDING 80, VALUE IS X'7FFF'\nRIGHTDEF LA    R15,40\n         TM    MDFL,MODEX\n         BZ    RIGHTR15\n         LA    R15,20\nRIGHTR15 LH    R0,OFFSET\n         AR    R0,R15\n         LH    R1,RECSIZE\n         CH    R1,=H'1000'\n         BNH   *+L'*+4\n         LH    R1,=H'1000'         LIMIT OFFSET TO 1000 CHARACTERS\n         CR    R0,R1               IF NEW OFFSET > RECSIZE, USE RECSIZE\n         BNH   *+L'*+2\n         LR    R0,R1\n         STH   R0,OFFSET\n         B     FILLSCR\n         SPACE 1\n*----------------------------------------------------------*\n*        LEFT                                              *\n*----------------------------------------------------------*\n         SPACE 1\nLEFT     LA    R15,OPD1            GET FIRST OPERAND ENTRY\n         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS\n         BZ    LEFTDEF             NO, USE DEFAULT\n         TM    6(R15),QUOTED       IS OPERAND QUOTED\n         BO    ERRINV              YES, INVALID\n         LH    R1,4(,R15)          GET LENGTH\n         LTR   R1,R1               IS IT NULL STRING\n         BZ    ERRINV              YES, ERROR\n         CH    R1,=H'7'            IS LENGTH MORE THAN 7\n         BH    ERRINV              YES, ERROR\n         L     R14,0(,R15)         GET ADDRESS OF DATA\n         BCT   R1,*+L'*+6\n         TRT   0(*-*,R14),NUMERIC\n         EX    R1,*-6              IS IT NUMERIC\n         BNZ   ERRINV              NO, ERROR\n         B     *+L'*+6\n         PACK  DOUBLE(8),0(*-*,R14)\n         EX    R1,*-6\n         CVB   R1,DOUBLE\n         LTR   R15,R1\n         BZ    PROMPT\n         B     LEFTR15\nLEFTDEF  LA    R15,40\n         TM    MDFL,MODEX\n         BZ    LEFTR15\n         LA    R15,20\nLEFTR15  LH    R0,OFFSET\n         SR    R0,R15              REDUCE OFFSET BY 80\n         BNM   LEFTALL+L'LEFTALL   IF RESULT IS NEGATIVE\nLEFTALL  XR    R0,R0                 THEN MAKE IT ZERO\n         STH   R0,OFFSET\n         B     FILLSCR\n         SPACE 1\n*----------------------------------------------------------*\n*        DOWN                                              *\n*----------------------------------------------------------*\n         SPACE 1\nDOWN     L     R0,SCROLL\n         LA    R15,OPD1            GET FIRST OPERAND ENTRY\n         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS\n         BZ    DOWNRGE             NO, USE RANGE\n         TM    6(R15),QUOTED       IS OPERAND QUOTED\n         BO    ERRINV              YES, INVALID\n         LH    R1,4(,R15)          GET LENGTH\n         LTR   R1,R1               IS IT NULL STRING\n         BZ    ERRINV              YES, ERROR\n         CH    R1,=H'7'            IS LENGTH MORE THAN 7\n         BH    ERRINV              YES, ERROR\n         L     R14,0(,R15)         GET ADDRESS OF DATA\n         BCT   R1,*+L'*+6\n         TRT   0(*-*,R14),NUMERIC\n         EX    R1,*-6              IS IT NUMERIC\n         BNZ   ERRINV              NO, ERROR\n         B     *+L'*+6\n         PACK  DOUBLE(8),0(*-*,R14)\n         EX    R1,*-6\n         CVB   R1,DOUBLE\n         LTR   R0,R1\n         BZ    PROMPT\nDOWNRGE  ST    R0,DOWNAMT\n         BAL   R14,DOWNER\n         LTR   R15,R15             ACTION TAKEN\n         BNZ   PROMPT              NO, BRANCH\n         B     FILLSCR             YES, BRANCH\n         SPACE 1\n*----------------------------------------------------------*\n*        EXECUTE DOWN ROUTINE                              *\n*----------------------------------------------------------*\n         SPACE 1\n*                                  SEE IF EOF IS ON SCREEN AND\nDOWNER   LA    R15,4                 WOULD BE FORCED OFF\n         L     R7,HOLDEND          POINT TO ENTRY FOR LAST RECORD\n         TM    DIRLEN(R7),X'80'    IS EOF ON SCREEN\n         BZ    DOWNNEOF            NO, DOWN IS POSSIBLE\n         L     R7,HOLDTOP\n         L     R0,DOWNAMT          GET DOWN AMOUNT\n         CH    R0,PAGESIZE         OR SCREEN SIZE IF SMALLER\n         BNH   DOWNTEST\n         LH    R0,PAGESIZE\nDOWNTEST TM    DIRLEN(R7),X'80'    IS THIS END OF DATA\n         BOR   R14                 YES, CANT GO DOWN\n         L     R7,DIRNXT(,R7)      GET ENTRY FOR NEXT RECORD\n         BCT   R0,DOWNTEST\n         L     R7,HOLDEND          POINT TO ENTRY FOR LAST RECORD\nDOWNNEOF ST    R14,DOWNR\n         L     R8,DOWNAMT          GET NUMBER OF LINES TO GO DOWN\nDOWNLOOP L     R15,HOLDTOP         POINT TO TOP ENTRY\n         L     R15,DIRNXT(,R15)    GET ADDRESS OF ENTRY AFTER TOP\n         ST    R15,HOLDTOP         MAKE IT NEW TOP\n         TM    DIRLEN(R7),X'80'    IS EOF ON SCREEN\n         BO    DOWNNXT             YES, BYPASS GET\n         L     R7,DIRNXT(,R7)      POINT TO NEXT ENTRY\n         BAL   R14,GET\n         LA    R0,1                COMPUTE\n         A     R0,COUNT              THE\n         ST    R0,COUNT                RECORD NUMBER\n         ST    R0,DIRNUM(,R7)      STORE THE RECORD NUMBER\n         ST    R1,DIRLEN(,R7)      STORE LENGTH\n         LTR   R1,R1               END OF FILE\n         BM    DOWNX               YES BRANCH\n         C     R1,SAVLRECL         IS RECORD LONGER THAN MAX\n         BNH   *+L'*+4             NO, SKIP NEXT INSTR\n         L     R1,SAVLRECL         YES, TRUNCATE TO MAX\n         LR    R0,R2               ADDRESS TO MOVE FROM\n         L     R14,DIRREC(,R7)     ADDRESS TO MOVE TO\n         TM    TSTRECFM,DCBRECV    RECFM V\n         BZ    DOWNNOTV            NO\n         SH    R14,=H'4'           YES, MOVE TO PTR MINUS 4\n         L     R15,DIRLEN(,R7)\n         SH    R15,=H'4'\n         ST    R15,DIRLEN(,R7)\nDOWNNOTV L     R15,SAVLRECL        LENGTH OF RECEIVING FIELD\n         O     R1,=A(X'40000000')  PAD WITH BLANKS\n         MVCL  R14,R0\nDOWNNXT  BCT   R8,DOWNLOOP\nDOWNX    ST    R7,HOLDEND          NEW END POINTER\n         XR    R15,R15\n         L     R14,DOWNR\n         BR    R14\n         SPACE 1\n*----------------------------------------------------------*\n*        UP                                                *\n*----------------------------------------------------------*\n         SPACE 1\nUP       L     R0,SCROLL\n         LA    R15,OPD1            GET FIRST OPERAND ENTRY\n         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS\n         BZ    UPRANGE             NO, USE RANGE\n         TM    6(R15),QUOTED       IS OPERAND QUOTED\n         BO    ERRINV              YES, INVALID\n         LH    R1,4(,R15)          GET LENGTH\n         LTR   R1,R1               IS IT NULL STRING\n         BZ    ERRINV              YES, ERROR\n         CH    R1,=H'7'            IS LENGTH MORE THAN 7\n         BH    ERRINV              YES, ERROR\n         L     R14,0(,R15)         GET ADDRESS OF DATA\n         BCT   R1,*+L'*+6\n         TRT   0(*-*,R14),NUMERIC\n         EX    R1,*-6              IS IT NUMERIC\n         BNZ   ERRINV              NO, ERROR\n         B     *+L'*+6\n         PACK  DOUBLE(8),0(*-*,R14)\n         EX    R1,*-6\n         CVB   R1,DOUBLE\n         LTR   R0,R1\n         BZ    PROMPT\nUPRANGE  ST    R0,DOWNAMT\n         L     R7,HOLDTOP\n         CLC   DIRNUM(4,R7),=F'1'  ARE WE AT TOP ALREADY\n         BNH   PROMPT              YES, BRANCH\n         TM    DIRLEN(R7),X'80'    IS FIRST LINE EOF\n         BZ    UPTOP               NO, BRANCH\n         NC    COUNT,COUNT         IS DATA-SET EMPTY\n         BZ    PROMPT              YES, BRANCH\nUPTOP    L     R0,DIRNUM(,R7)      GET RECORD NUMBER OF TOP LINE\n         S     R0,DOWNAMT          GET RECORD NUMBER TO GO BACK TO\n         BP    LISTAT\n         LA    R0,1                IF NEGATIVE THEN MAKE IT 1\n         B     LISTAT\n         SPACE 1\n*----------------------------------------------------------*\n*        TOP                                               *\n*----------------------------------------------------------*\n         SPACE 1\nTOP      L     R1,CHKPTTOP\n         MVC   TTR,4(R1)           TTR OF FIRST BLOCK\n         MVC   TTRZ(3),TTR         TTR OF FIRST BLOCK\n        POINT  (R4),TTRZ\n         XC    COUNT,COUNT\n         XC    DEBLOCKS(12),DEBLOCKS\n         L     R14,SPANPTR\n         XR    R0,R0\n         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH\n         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER\n         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET\n         BAL   R14,FILLHOLD\n         B     FILLSCR\n         SPACE 1\n*----------------------------------------------------------*\n*        BOTTOM                                            *\n*----------------------------------------------------------*\n         SPACE 1\nBOTTOM   L     R0,BOTNINES\n         B     LISTAT\nBOTRET   L     R0,SCROLL\n         BCTR  R0,0\n         B     UPRANGE\n         SPACE 1\n*----------------------------------------------------------*\n*        HELP                                              *\n*----------------------------------------------------------*\n         SPACE 1\nHELP     LA    R15,OPD1            FIRST PARAMETER\n         TM    6(R15),PRESENT      ANY OPERANDS?\n         BO    HELP1               YES, BRANCH\n         CLI   HELPFLG,C'R'        PREVIOUS HELP SCREEN?\n         BE    HELP1               YES, PERFORM HELP CALL\n         MVI   HELPFLG,C'H'        NEED HELP SCREEN\n         B     FILLSCR\nHELP1    LA    R1,CMDAREA          START OF HELP PARAMETERS\n         LA    R0,63               LENGTH OF PARSE STRING\n         SLL   R0,16               SHIFT AS REQUIRED\n         STCM  R0,B'1111',0(R1)    SAVE FOR PARSE\n         TM    6(R15),QUOTED       QUOTED?\n         BO    ERRINV              YES, INVALID\n         LA    R15,OPD1            START OF FIRST ODL\n         L     R14,0(,R15)         START OF PARAMETER\n         LH    R15,4(,R15)         LENGTH OF PARAMETER\n         L     R6,HELECT           ECT ADDRESS\n         USING ECT,R6\n         OI    ECTSWS,ECTNOPD      ASSUME NO OPERAND\n         MVC   ECTSCMD,=CL8'HELP    ' SUBCOMMAND IS HELP\n         LTR   R15,R15             NULL STRING?\n         BZ    HELP3               YES, BRANCH\n         CH    R15,=H'8'           IS LENGTH MORE THAN 8\n         BH    ERRINV              YES, ERROR\n         MVC   BLDL+4(8),BLANKS\n         BCT   R15,*+L'*+6         MACHINE LENGTH\n         MVC   BLDL+4(*-*),0(R14)  <<EXECUTED>>\n         EX    R15,*-6             COMMAND NAME\n         LA    R15,OPD1            START OF FIRST ODL\n         L     R14,0(,R15)         START OF FIRST PARAMETER\n         LA    R14,0(,R14)         DROP TOP BYTE\n         SR    R14,R1              OFFSET TO SECOND PARAMETER\n         SH    R14,=H'4'           LESS TEXT LENGTH FIELDS\n         NI    ECTSWS,255-ECTNOPD  ASSUME OPERANDS\n         TM    6(R15),PRESENT      ANY OPERANDS?\n         BO    HELP2               YES, BRANCH\n         LA    R14,63              NO, USE DEFAULT\n         OI    ECTSWS,ECTNOPD      ASSUME NO OPERAND\nHELP2    STH   R14,2(,R1)          OFFSET TO OPERANDS\nHELP3    MVC   ECTPCMD,=CL8'HLHL    ' COMMAND NAME IS CHANGED\n         DROP  R6\n         ST    R1,HELCBUF          START OF COMMAND TEXT\n         LA    R1,HELCBUF          CPPL START\n        LINK   EP=HEL\n         L     R1,HELECT           START OF ECT\n         USING ECT,R1\n         MVC   ECTPCMD(3),PCMD     HELP COMMAND NAME\n         B     FILLSCR\n         DROP  R1\n         SPACE 1\n*----------------------------------------------------------*\n*        LIST                                              *\n*----------------------------------------------------------*\n         SPACE 1\nLIST     LA    R15,OPD1            GET FIRST OPERAND ENTRY\n         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS\n         BZ    ERRMISS             NO, MISSING OPERAND\n         TM    6(R15),QUOTED       IS OPERAND QUOTED\n         BO    ERRINV              YES, INVALID\n         LH    R1,4(,R15)          GET LENGTH\n         LTR   R1,R1               IS IT NULL STRING\n         BZ    ERRINV              YES, ERROR\n         CH    R1,=H'7'            IS LENGTH MORE THAN 7\n         BH    ERRINV              YES, ERROR\n         L     R14,0(,R15)         GET ADDRESS OF DATA\n         BCT   R1,*+L'*+6\n         TRT   0(*-*,R14),NUMERIC\n         EX    R1,*-6              IS IT NUMERIC\n         BNZ   ERRINV              NO, ERROR\n         B     *+L'*+6\n         PACK  DOUBLE(8),0(*-*,R14)\n         EX    R1,*-6\n         CVB   R1,DOUBLE\n         LTR   R0,R1\n         BZ    TOP\nLISTAT   ST    R0,LISTNUM\n         AH    R0,PAGESIZE         GET RECORD NUMBER TO READ UP TO\n         BCTR  R0,0\n         ST    R0,AIMFOR           SAVE FOR DOWNTO\n         LA    R15,20              LENGTH OF CHKPT ENTRY\n         L     R1,CHKPTBOT\n         TM    0(R1),X'80'         IS IT EOF\n         BZ    LISTNB\n         C     R1,CHKPTTOP         IS DATA-SET EMPTY\n         BE    PROMPT              YES\n         SR    R1,R15              NO, BACK UP ONE ENTRY\nLISTNB   L     R0,LISTNUM\nLISTCK   C     R0,0(,R1)           DOES THIS BLOCK PRECEDE OUR RECORD\n         BH    LISTPNT             YES, GO POINT TO IT\n         SR    R1,R15              NO, BACK UP ONE BLOCK ENTRY\n         B     LISTCK\nLISTPNT  MVC   COUNT,0(R1)\n         MVC   DEBLOCKS(12),8(R1)\n         MVC   TTR,4(R1)           TTR OF FIRST BLOCK\n         MVC   TTRZ(3),TTR\n        POINT  (R4),TTRZ\n         L     R14,SPANPTR\n         XR    R0,R0\n         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH\n         CLC   MSG(8),MSG31        FOUND STRING MESSAGE?\n         BE    LISTFIN             YES, BRANCH\n         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER\n         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET\nLISTFIN  BAL   R14,FILLHOLD        READ NEXT 20 RECORDS\nLISTFINE L     R7,HOLDTOP          GET ENTRY FOR TOP OF HOLD AREA\n         TM    DIRLEN(R7),X'80'    IS EOF ON TOP OF SCREEN\n         BO    LISTRDY             YES, WE ARE FINISHED\n         CLC   LISTNUM,DIRNUM(R7)  IS REQUESTED NUMBER AT TOP\n         BNH   FILLSCR             YES, BRANCH\n         MVC   DOWNAMT,=F'1'       DOWN 1\n         BAL   R14,DOWNER\n         B     LISTFINE\nLISTRDY  CLC   LISTNUM,BOTNINES    WAS THIS A LIST 99999999\n         BE    BOTRET              YES, BRANCH\n         B     FILLSCR\nERRMISS  MVC   MSG(MSG35L),MSG35\n         B     PROMPT\n         SPACE 1\n*----------------------------------------------------------*\n*        FND1 (POSITION TO SUBCOMMAND AND ANY OPERAND)     *\n*----------------------------------------------------------*\n         SPACE 1\nFND1     L     R1,CHKPTTOP\n         MVC   TTR,4(R1)           TTR OF FIRST BLOCK\n         MVC   TTRZ(3),TTR         TTR OF FIRST BLOCK\n        POINT  (R4),TTRZ\n         XC    COUNT,COUNT\n         XC    DEBLOCKS(12),DEBLOCKS\n         L     R14,SPANPTR\n         XR    R0,R0\n         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH\n         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER\n         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET\n         BAL   R14,FILLHOLD        ** PERFORMS A TOP OPERATION\n         MVI   FINDSW,0\n         LA    R15,OPD1            GET FIRST OPERAND ENTRY\n         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS\n         BZ    FND1SAME            NO, USE PREVIOUS STRING\n         XC    STRING,STRING       ERASE OLD STRING\n         XR    R0,R0\n         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER\n         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET\n         STH   R0,FINDCOL          RESET COLUMN\n         LH    R1,4(,R15)          GET LENGTH\n         LTR   R1,R1               IS IT NULL STRING\n         BZ    FINDNULL            YES, ERROR\n         L     R14,0(,R15)         GET ADDRESS OF DATA\n         BCT   R1,*+L'*+6\n         MVC   STRING(*-*),0(R14)\n         EX    R1,*-6\n         STH   R1,STRINGL          SAVE LENGTH CODE\n         LA    R15,OPD2\n         TM    6(R15),PRESENT      IS THERE A SECOND OPERAND\n         BZ    FND1SAME            NO, LEAVE FINDCOL NULL\n         TM    6(R15),QUOTED       IS OPERAND QUOTED\n         BO    ERRINV              YES, INVALID\n         LH    R1,4(,R15)          GET LENGTH\n         LTR   R1,R1               IS IT NULL STRING\n         BZ    ERRINV              YES, ERROR\n         CH    R1,=H'3'            IS LENGTH MORE THAN 3\n         BH    ERRINV              YES, ERROR\n         L     R14,0(,R15)         GET ADDRESS OF DATA\n         BCT   R1,*+L'*+6\n         TRT   0(*-*,R14),NUMERIC\n         EX    R1,*-6              IS IT NUMERIC\n         BNZ   ERRINV              NO, ERROR\n         B     *+L'*+6\n         PACK  DOUBLE(8),0(*-*,R14)\n         EX    R1,*-6\n         CVB   R1,DOUBLE\n         LTR   R1,R1               IS IT ZERO\n         BZ    ERRINV              YES, ERROR\n         C     R1,SAVLRECL         IS IT GREATER THAN LRECL\n         BH    ERRINV              YES, ERROR\n         STH   R1,FINDCOL\nFND1SAME NC    STRING,STRING       HAS A STRING BEEN ENTERED\n         BZ    FINDNULL            NO, ERROR\n         LH    R6,FINDCOL\n         L     R7,HOLDTOP          GET INFO FOR FIRST HELD RECORD\n         L     R0,DIRNUM(,R7)      GET RECORD NUMBER OF FIRST HELD\n         L     R1,FNDNUM           GET RECORD NUMBER WHERE LAST FOUND\n         LTR   R1,R1               HAS IT BEEN FOUND\n         BNP   FND1SCR             NO, START WITH HELD RECORDS\n         CR    R0,R1               ARE WE PAST LAST FOUND REC\n         BH    FND1SCR             YES, START WITH HELD RECORDS\n         L     R14,HOLDEND\n         L     R15,DIRNUM(,R14)    GET RECORD NUMBER OF LAST HELD\n         CR    R1,R15              IS LAST FOUND REC ON SCREEN\n         BH    FND1DOWN            NO, BRANCH\nFND1PREV C     R1,DIRNUM(,R7)      IS THIS RECORD WHERE LAST FOUND\n         BE    FND1PCOL            YES, BRANCH\n         C     R7,HOLDEND          IS THIS LAST RECORD ON SCREEN\n         BE    FND1DOWN            SHOULD NOT HAPPEN\n         L     R7,DIRNXT(,R7)      POINT TO NEXT RECORD\n         B     FND1PREV\nFND1PCOL L     R15,DIRREC(,R7)     POINT TO RECORD\n         LTR   R6,R6               WAS A COLUMN SPECIFIED\n         BZ    FND1POFF            NO, LOOK AT SAME RECORD\n         C     R7,HOLDEND          IS THIS LAST RECORD ON SCREEN\n         BE    FND1DOWN            YES, BRANCH\n         L     R7,DIRNXT(,R7)      NO, POINT TO NEXT RECORD\n         B     FND1SCR             GO EXAMINE RECORD\nFND1POFF AH    R15,FNDOFF          POINT TO LAST FOUND STRING\n         LA    R15,1(,R15)         POINT PAST LAST FOUND STRING\n         B     FND1STR\nFND1CLC  CLC   0(*-*,R15),STRING   <<EXECUTED>>\nFND1CLK  CLC   0(*-*,R15),$SUBCOM  <<EXECUTED>>\nFND1SCR  TM    DIRLEN(R7),X'80'    ARE WE AT EOF?\n         BO    FND1BOT             YES, BRANCH\n         L     R15,DIRREC(,R7)     POINT TO FIRST BYTE TO EXAMINE\n         CLI   $SUBLINE,C'Y'       ANY SUBCOMMAND NAME?\n         BE    FND1COL1            NO, BRANCH\n         CLI   0(R15),C'='         START OF A SUBCOMMAND?\n         BNE   FND1NEXT            NO, BRANCH\n         LH    R14,$SUBLEN         MACHINE LENGTH OF SUBCOMMAND NAME\nFND1CHK  LA    R15,1(,R15)         NEXT CHARACTER\n         EX    R14,FND1CLK         THIS SUBCOMMAND IDENTIFIER?\n         BNE   FND1CHK1            NO, BRANCH\n         LA    R1,1(R14,R15)       POINT TO END OF STRING\n         CLI   0(R1),C'='          ANOTHER SUBCOMMAND NAME?\n         BE    FND1COL             YES, BRANCH\n         CLI   0(R1),C' '          END OF SUBCOMMAND NAMES?\n         BE    FND1COL             YES, BRANCH\nFND1CHK1 LA    R15,1(,R15)         NEXT CHARACTER?\n         CLI   0(R15),C'='         SEPARATOR CHARACTER?\n         BE    FND1CHK             YES, BRANCH\n         CLI   0(R15),C' '         SEPARATOR CHARACTER?\n         BE    FND1NEXT            YES, NOT ON THIS CARD IMAGE\n         B     FND1CHK1            NO, BRANCH\nFND1COL  L     R15,DIRNUM(,R7)     CURRENT SUBCOMMAND POSITION\n         ST    R15,$SUBLINE        SUBCOMMAND IS SATISFIED\n         MVI   $SUBLINE,C'Y'       POSITIONING FOR SUBCOMMAND COMPLETED\n         B     FND1NEXT            NOT ON THIS CARD IMAGE\nFND1COL1 L     R15,DIRREC(,R7)     POINT TO FIRST BYTE TO EXAMINE\n         CLI   0(R15),C'='         SUBCOMMAND DIVIDER?\n         BE    FND1BOT             YES, DATA NOT FOUND\n         LTR   R6,R6               WAS A COLUMN SPECIFIED\n         BZ    FND1STR             NO, BRANCH\n         AR    R15,R6              YES, POINT TO COLUMN PLUS 1\n         BCTR  R15,0               POINT TO COLUMN\n         LH    R14,STRINGL\n         EX    R14,FND1CLC         THIS RECORD IMAGE?\n         BNE   FND1NEXT            NO, LOOP FOR NEXT RECORD\n         CLI   1(R15),C')'         \"O\" OPERAND IDENTIFIER?\n         BNE   FND1FND             NO, FOUND IT\n         LA    R1,$OPERAND         FIRST OPERAND START\nFND1O1   LA    R0,19\n         LA    R14,20(,R1)\n         CLI   0(R1),C' '          ANY OPERAND?\n         BE    FND1NEXT            NO, NOT THIS OPERAND\nFND1O2   BCTR  R14,0               SCAN\n         CLI   0(R14),C' '           FOR\n         BNE   *+L'*+4                 LAST\n         BCT   R0,FND1O2                 NON-BLANK\n         LR    R14,R0              LENGTH\n         EX    R14,FND1CKL         THIS OPERAND?\n         LA    R1,20(,R1)\n         BNE   FND1O1              NO, BRANCH FOR NEXT OPERAND\n         B     FND1FND\nFND1CKL  CLC   2(*-*,R15),0(R1)    <<EXECUTED>>\nFND1STR  L     R0,DIRLEN(,R7)      GET LENGTH OF RECORD\n         C     R0,SAVLRECL         IS RECORD TRUNCATED\n         BNH   *+L'*+4             NO, SKIP NEXT INSTR\n         L     R0,SAVLRECL         YES, USE TRUNCATED LENGTH\n         L     R1,DIRREC(,R7)      GET ADDRESS OF RECORD\n         AR    R0,R1               POINT PAST LAST BYTE OF RECORD\n         LH    R14,STRINGL         GET LENGTH CODE OF STRING\n         AR    R15,R14             POINT TO LAST BYTE TO BE COMPARED\n         SR    R0,R15              GET NUMBER OF COMPARISONS\n         BNP   FND1NEXT            STRING TOO LONG FOR REMAINING TEXT\n         SR    R15,R14             PUT STRING ADDRESS BACK\nFND1COMP EX    R14,FND1CLC         COMPARE STRING TO DATA\n         BE    FND1FND\n         LA    R15,1(,R15)         INCREMENT DATA POINTER\n         BCT   R0,FND1COMP         GO COMPARE AGAIN\nFND1NEXT C     R7,HOLDEND          WAS THAT LAST HELD RECORD\n         BE    FND1DOWN            YES, BRANCH\n         L     R7,DIRNXT(,R7)      POINT TO NEXT RECORD\n         B     FND1SCR             GO PROCESS NEXT RECORD\nFND1BOT  MVI   MEMBFLG,0           DO NOT CONTINUE PARSE\n         MVC   MSG(MSG32L),MSG32F\n         CLI   STRING+1,C'X'\n         BNE   *+L'*+6\n         MVC   MSG(MSG32L),MSG32X\n         CLI   STRING+1,C'S'\n         BNE   *+L'*+6\n         MVC   MSG(MSG32L),MSG32SS\n         CLI   STRING+1,C'O'\n         BNE   *+L'*+6\n         MVC   MSG(MSG32L),MSG32O\n         CLI   STRING+1,C')'\n         BNE   *+L'*+6\n         MVC   MSG(MSG32L),MSG32OO\n         CLI   $SUBLINE,C'Y'\n         BE    *+L'*+6\n         MVC   MSG(MSG32L),MSG32S\nFND1DONE L     R1,$SUBLINE\n         LA    R0,1(,R1)\n         B     LISTAT\nFND1DOWN LA    R1,1\n         ST    R1,DOWNAMT\n         BAL   R14,DOWNER\n         L     R7,HOLDEND\n         OI    FINDSW,1\n         B     FND1SCR\nFND1FND  TM    FINDSW,1\n         BZ    FILLSCR\n         LH    R6,PAGESIZE\n         SH    R6,=H'1'\nFND1LN2  LA    R1,1\n         ST    R1,DOWNAMT\n         BAL   R14,DOWNER\n         BCT   R6,FINDLN\n         B     FILLSCR\n         SPACE 1\n*----------------------------------------------------------*\n*        FIND                                              *\n*----------------------------------------------------------*\n         SPACE 1\nFIND     MVI   FINDSW,0\n         LA    R15,OPD1            GET FIRST OPERAND ENTRY\n         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS\n         BZ    FINDSAME            NO, USE PREVIOUS STRING\n         XC    STRING,STRING       ERASE OLD STRING\n         XR    R0,R0\n         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER\n         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET\n         STH   R0,FINDCOL          RESET COLUMN\n         LH    R1,4(,R15)          GET LENGTH\n         LTR   R1,R1               IS IT NULL STRING\n         BZ    FINDNULL            YES, ERROR\n         L     R14,0(,R15)         GET ADDRESS OF DATA\n         BCT   R1,*+L'*+6\n         MVC   STRING(*-*),0(R14)\n         EX    R1,*-6\n         STH   R1,STRINGL          SAVE LENGTH CODE\n         LA    R15,OPD2\n         TM    6(R15),PRESENT      IS THERE A SECOND OPERAND\n         BZ    FINDSAME            NO, LEAVE FINDCOL NULL\n         TM    6(R15),QUOTED       IS OPERAND QUOTED\n         BO    ERRINV              YES, INVALID\n         LH    R1,4(,R15)          GET LENGTH\n         LTR   R1,R1               IS IT NULL STRING\n         BZ    ERRINV              YES, ERROR\n         CH    R1,=H'3'            IS LENGTH MORE THAN 3\n         BH    ERRINV              YES, ERROR\n         L     R14,0(,R15)         GET ADDRESS OF DATA\n         BCT   R1,*+L'*+6\n         TRT   0(*-*,R14),NUMERIC\n         EX    R1,*-6              IS IT NUMERIC\n         BNZ   ERRINV              NO, ERROR\n         B     *+L'*+6\n         PACK  DOUBLE(8),0(*-*,R14)\n         EX    R1,*-6\n         CVB   R1,DOUBLE\n         LTR   R1,R1               IS IT ZERO\n         BZ    ERRINV              YES, ERROR\n         C     R1,SAVLRECL         IS IT GREATER THAN LRECL\n         BH    ERRINV              YES, ERROR\n         STH   R1,FINDCOL\nFINDSAME NC    STRING,STRING       HAS A STRING BEEN ENTERED\n         BZ    FINDNULL            NO, ERROR\n         LH    R6,FINDCOL\n         L     R7,HOLDTOP          GET INFO FOR FIRST HELD RECORD\n         L     R0,DIRNUM(,R7)      GET RECORD NUMBER OF FIRST HELD\n         L     R1,FNDNUM           GET RECORD NUMBER WHERE LAST FOUND\n         LTR   R1,R1               HAS IT BEEN FOUND\n         BNP   FINDSCR             NO, START WITH HELD RECORDS\n         CR    R0,R1               ARE WE PAST LAST FOUND REC\n         BH    FINDSCR             YES, START WITH HELD RECORDS\n         L     R14,HOLDEND\n         L     R15,DIRNUM(,R14)    GET RECORD NUMBER OF LAST HELD\n         CR    R1,R15              IS LAST FOUND REC ON SCREEN\n         BH    FINDDOWN            NO, BRANCH\nFINDPREV C     R1,DIRNUM(,R7)      IS THIS RECORD WHERE LAST FOUND\n         BE    FINDPCOL            YES, BRANCH\n         C     R7,HOLDEND          IS THIS LAST RECORD ON SCREEN\n         BE    FINDDOWN            SHOULD NOT HAPPEN\n         L     R7,DIRNXT(,R7)      POINT TO NEXT RECORD\n         B     FINDPREV\nFINDPCOL L     R15,DIRREC(,R7)     POINT TO RECORD\n         LTR   R6,R6               WAS A COLUMN SPECIFIED\n         BZ    FINDPOFF            NO, LOOK AT SAME RECORD\n         C     R7,HOLDEND          IS THIS LAST RECORD ON SCREEN\n         BE    FINDDOWN            YES, BRANCH\n         L     R7,DIRNXT(,R7)      NO, POINT TO NEXT RECORD\n         B     FINDSCR             GO EXAMINE RECORD\nFINDPOFF AH    R15,FNDOFF          POINT TO LAST FOUND STRING\n         LA    R15,1(,R15)         POINT PAST LAST FOUND STRING\n         B     FINDSTR\nFINDCLC  CLC   0(0,R15),STRING     <<EXECUTED>>\nFINDSCR  TM    DIRLEN(R7),X'80'    ARE WE AT EOF\n         BO    FINDBOT             YES, BRANCH\n         L     R15,DIRREC(,R7)     POINT TO FIRST BYTE TO EXAMINE\n         LTR   R6,R6               WAS A COLUMN SPECIFIED\n         BZ    FINDSTR             NO, BRANCH\n         AR    R15,R6              YES, POINT TO COLUMN PLUS 1\n         BCTR  R15,0               POINT TO COLUMN\n         LH    R14,STRINGL\n         EX    R14,FINDCLC\n         BE    FOUND\n         B     FINDNEXT\nFINDSTR  L     R0,DIRLEN(,R7)      GET LENGTH OF RECORD\n         C     R0,SAVLRECL         IS RECORD TRUNCATED\n         BNH   *+L'*+4             NO, SKIP NEXT INSTR\n         L     R0,SAVLRECL         YES, USE TRUNCATED LENGTH\n         L     R1,DIRREC(,R7)      GET ADDRESS OF RECORD\n         AR    R0,R1               POINT PAST LAST BYTE OF RECORD\n         LH    R14,STRINGL         GET LENGTH CODE OF STRING\n         AR    R15,R14             POINT TO LAST BYTE TO BE COMPARED\n         SR    R0,R15              GET NUMBER OF COMPARISONS\n         BNP   FINDNEXT            STRING TOO LONG FOR REMAINING TEXT\n         SR    R15,R14             PUT STRING ADDRESS BACK\nFINDCOMP EX    R14,FINDCLC         COMPARE STRING TO DATA\n         BE    FOUND\n         LA    R15,1(,R15)         INCREMENT DATA POINTER\n         BCT   R0,FINDCOMP         GO COMPARE AGAIN\nFINDNEXT C     R7,HOLDEND          WAS THAT LAST HELD RECORD\n         BE    FINDDOWN            YES, BRANCH\n         L     R7,DIRNXT(,R7)      POINT TO NEXT RECORD\n         B     FINDSCR             GO PROCESS NEXT RECORD\nFINDBOT  MVC   MSG(MSG32L),MSG32\n         B     FILLSCR\nFINDDOWN LA    R1,1\n         ST    R1,DOWNAMT\n         BAL   R14,DOWNER\n         L     R7,HOLDEND\n         OI    FINDSW,1\n         B     FINDSCR\nFINDNULL MVC   MSG(MSG33L),MSG33\n         B     PROMPT\nERRINV   MVC   MSG(MSG34L),MSG34\n         B     PROMPT\nFOUND    MVC   MSG(MSG31L),MSG31\n         MVC   FNDNUM,DIRNUM(R7)   SAVE RECORD NUMBER\n         S     R15,DIRREC(,R7)     GET OFFSET TO FOUND LOCATION\n         STH   R15,FNDOFF          SAVE OFFSET\n         LA    R15,1(,R15)         MAKE IT COLUMN NUMBER\n         CVD   R15,DOUBLE\n         OI    DOUBLE+7,X'0F'\n         LA    R15,MSG+26\n         UNPK  0(3,R15),DOUBLE+6(2)\n         L     R15,FNDNUM\n         CVD   R15,DOUBLE\n         OI    DOUBLE+7,X'0F'\n         LA    R15,MSG+16\n         UNPK  0(5,R15),DOUBLE+5(3)\n         L     R1,DIRNUM(,R7)\n         LA    R0,0(,R1)\n         TM    FINDSW,1\n         BZ    LISTAT\n         LH    R6,PAGESIZE\n         SH    R6,=H'2'\nFINDLN   LA    R1,1\n         ST    R1,DOWNAMT\n         BAL   R14,DOWNER\n         BCT   R6,FINDLN\n         B     FILLSCR\n         SPACE 1\n*----------------------------------------------------------*\n*        HEX                                               *\n*----------------------------------------------------------*\n         SPACE 1\nHEXMODE  LA    R15,OPD1            GET FIRST OPERAND ENTRY\n         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS\n         BZ    HEXFLIP             NO, FLIP FLOP\n         L     R14,0(,R15)         POINT TO OPERAND\n         CLI   5(R15),2            IS LENGTH 2\n         BNE   HEXOFF              NO, TRY OFF\n         CLC   0(2,R14),=C'ON'     YES, IS IT 'ON'\n         BNE   ERRKW               NO, INVALID OPERAND\n         OI    MDFL,MODEX\n         B     FILLSCR\nHEXOFF   CLI   5(R15),3            IS LENGTH 3\n         BNE   ERRKW\n         CLC   0(3,R14),=C'OFF'\n         BNE   ERRKW\n         NI    MDFL,255-MODEX\n         B     FILLSCR\nHEXFLIP  XI    MDFL,MODEX          FLIP FLOP THE SWITCH\n         B     FILLSCR\nERRKW    MVC   MSG(MSG34L),MSG34\n         B     PROMPT\n         SPACE 1\n*----------------------------------------------------------*\n*        PFK SET                                           *\n*----------------------------------------------------------*\n         SPACE 1\nPFKSET   LA    R15,3(,R1)          POINT TO NN AFTER PFK\n         TRT   0(1,R15),NUMERIC    PFKN\n         BNZ   PFKSET2             ERROR, N NOT NUMERIC\n         PACK  DOUBLE,0(1,R15)\n         CLI   1(R15),C' '         SINGLE DIGIT\n         BE    PFKSET1             YES, BRANCH\n         TRT   1(1,R15),NUMERIC\n         BNZ   PFKSET2             SECOND DIGIT NOT NUMERIC\n         CLI   2(R15),C' '\n         BNE   PFKSET2             MORE THAN 2 DIGITS\n         PACK  DOUBLE,0(2,R15)\nPFKSET1  CVB   R1,DOUBLE           GET VALUE OF N OR NN\n         CH    R1,=H'1'\n         BL    PFKSET2             ERROR, LESS THAN 1\n         CH    R1,=H'12'\n         BH    PFKSET2             ERROR, GREATER THAN 12\n         BCTR  R1,0                CHANGE 1-12 TO 0-11\n         LA    R0,L'PFKTAB         LENGTH OF EACH PFK ENTRY\n         MR    R0,R0               COMPUTE OFFSET INTO TABLE\n         L     R15,APFKTB\n         ALR   R15,R1              POINT TO TABLE ENTRY\n         LA    R1,OPD1             GET FIRST OPERAND ENTRY\n         TM    6(R1),PRESENT       ARE THERE ANY OPERANDS\n         BZ    PFKSETF             NO, BLANK IT\n         CLI   5(R1),0             IS IT NULL LENGTH\n         BE    PFKSETF             YES, BLANK IT\n         L     R1,0(,R1)           POINT TO OPERAND\n         CLC   0(3,R1),=C'PFK'     IS OPERAND ANOTHER PFK COMMAND\n         BE    PFKSET2             YES, ERROR\n         LA    R0,CMDAREA+30       POINT TO END OF COMMAND AREA\n         SR    R0,R1               GET LENGTH CODE OF COMMAND\n         BM    PFKSET2\n         LR    R14,R0\n         MVI   1(R15),C' '\n         MVC   2(L'PFKTAB-2,R15),1(R15)\n         B     *+L'*+6\n         MVC   1(*-*,R15),0(R1)    <<EXECUTED>>\n         EX    R14,*-6             MOVE COMMAND INTO PFK TABLE\n         CLI   DEBUGSW,C'D'\n         BNE   NOPFDB\n         LA    R14,1(,R14)         BUILD DEBUG OF PFK (MSG)     D\n         CVD   R14,DOUBLE          DISPLAY LENGTH               E    P\n         OI    DOUBLE+7,X'0F'                                   B    F\n         UNPK  MSG+2(3),DOUBLE+6(2)                             U    K\n         MVI   MSG+5,C' '                                       G\n         MVC   MSG+6(10),1(R15)    DISPLAY 10 CHARS OF VALUE         S\n         LA    R0,14                                                 E\n         STH   R0,MSG                                                T\nNOPFDB   CLI   DEBUGSW,C'D'\n         BNE   PFKSETX\n         B     PROMPT              DEBUG REQUESTED\nPFKSETF  MVI   1(R15),C' '\n         MVC   2(L'PFKTAB-2,R15),1(R15)\nPFKSETX  MVC   MSG(MSG40L),MSG40   HAS BEEN RESET\n         B     PROMPT\nPFKSET2  MVC   MSG(MSG41L),MSG41   INVALID PFK COMMAND\n         B     PROMPT\n         SPACE 1\n*----------------------------------------------------------*\n*        CAPS / ASIS                                       *\n*----------------------------------------------------------*\n         SPACE 1\nCAPS     MVC   PERIODS,CAPST\n         B     FILLSCR\nASIS     MVC   PERIODS,ASIST\n         B     FILLSCR\n         SPACE 1\n*----------------------------------------------------------*\n*        MEMBER                                            *\n*----------------------------------------------------------*\n         SPACE 1\nMEMBERP  TM    DSORG,DCBDSGPO      IS DSORG PO\n         BZ    MEMPDS              NO, BRANCH\n         LA    R15,OPD1            GET FIRST OPERAND ENTRY\n         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS\n         BZ    TOP                 NO, GO TO THE TOP OF THE SCREEN\n         TM    6(R15),QUOTED       IS OPERAND QUOTED\n         BO    ERRINV              YES, INVALID\n         LH    R1,4(,R15)          GET LENGTH\n         LTR   R1,R1               IS IT NULL STRING\n         BZ    ERRMISS             YES, ERROR\n         CH    R1,=H'8'            IS LENGTH MORE THAN 8\n         BH    ERRINV              YES, ERROR\n         MVC   BLDL+4(8),BLANKS\n         L     R14,0(,R15)         GET ADDRESS OF DATA\n         BCT   R1,*+L'*+6\n         MVC   BLDL+4(*-*),0(R14)\n         EX    R1,*-6\nMEMBER1  MVC   BLDL(4),=AL2(1,76)\n        BLDL   (R4),BLDL\n         LTR   R15,R15\n         BNZ   MEMERR\n         NI    STATUS,255-STNOMEM\n         MVC   $MEMBER,BLDL+4\n         L     R1,CHKPTTOP\n         MVC   4(4,R1),BLDL+12     COPY TTR\n         ST    R15,CHKPTBOT        ZERO CHKPT TABLE\n         MVC   TTR,BLDL+12         TTR OF FIRST BLOCK\n         MVC   TTRK,BLDL+12        TTR OF FIRST BLOCK\n        FIND   (R4),TTRK,C\n         TM    MEMBFLG,MEMBFLGS    SUBCOMMAND CHANGE TOO?\n         BO    SUBCOMO             YES, BRANCH\n         MVC   $SUBLINE,=F'0'\n         MVI   $SUBLINE,C'Y'\n         MVC   $SUBCOM(8),BLANKS\n         XC    COUNT,COUNT\n         XC    DEBLOCKS(12),DEBLOCKS\n         L     R14,SPANPTR\n         XR    R0,R0\n         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH\n         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER\n         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET\n         B     NEWNAME\nMEMERR   MVI   MEMBFLG,0           DO NOT CONTINUE PARSE\n         CH    R15,=H'4'\n         BNE   MEMERR1\n         MVC   MSG(MSG36L),MSG36   MEMBER NOT FOUND\n         B     PROMPT\nMEMERR1  MVC   MSG(MSG37L),MSG37   BLDL FAILED\n         B     PROMPT\nMEMPDS   MVC   MSG(MSG38L),MSG38   NOT PARTITIONED\n         B     PROMPT\n         SPACE 1\n*----------------------------------------------------------*\n*        SUBCOMMAND                                        *\n*----------------------------------------------------------*\n         SPACE 1\nSUBCOMP  TM    DSORG,DCBDSGPO      IS DSORG PO\n         BZ    MEMPDS              NO, BRANCH\n         LA    R15,OPD1            GET FIRST OPERAND ENTRY\n         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS\n         BZ    FND1DONE            NO, REPOSITION TO SUBCOMMAND\n         TM    6(R15),QUOTED       IS OPERAND QUOTED\n         BO    ERRINV              YES, INVALID\n         LH    R1,4(,R15)          GET LENGTH\n         LTR   R1,R1               IS IT NULL STRING\n         BZ    ERRMISS             YES, ERROR\n         CH    R1,=H'8'            IS LENGTH MORE THAN 8\n         BH    ERRINV              YES, ERROR\n         MVC   $SUBCOM(8),BLANKS\n         L     R14,0(,R15)         GET ADDRESS OF DATA\n         BCT   R1,*+L'*+6\n         MVC   $SUBCOM(*-*),0(R14)\n         EX    R1,*-6              MOVE IN THE SUBCOMMAND NAME\n         MVI   $SUBLINE,C'N'       NOT YET SATISFIED\nSUBCOMO  LA    R0,7\n         LA    R15,$SUBCOM+8\nSUBCOMO1 BCTR  R15,0               SCAN\n         CLI   0(R15),C' '           FOR\n         BNE   *+L'*+4                 LAST\n         BCT   R0,SUBCOMO1               NON-BLANK\n         STH   R0,$SUBLEN          MACHINE LENGTH OF SUBCOMMAND\n         SPACE 1\n         XC    COUNT,COUNT\n         XC    DEBLOCKS(12),DEBLOCKS\n         L     R14,SPANPTR\n         XR    R0,R0\n         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH\n         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER\n         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET\n         LA    R15,OPD1            GET FIRST OPERAND ENTRY\n         LA    R1,=C')'            ONLY A PARENTHESIS\n         ST    R1,0(,R15)          FIRST OPERAND\n         LA    R1,1                LENGTH OF OPERAND\n         STH   R1,4(,R15)          LENGTH OF OPERAND\n         MVI   6(R15),PRESENT      OPERANDS ARE PRESENT\n         LA    R15,OPD2            GET SECOND OPERAND ENTRY\n         LA    R1,=C'1'            IN THE FIRST DATA POSITION\n         ST    R1,0(,R15)          FIRST OPERAND\n         LA    R1,1                LENGTH OF OPERAND\n         STH   R1,4(,R15)          LENGTH OF OPERAND\n         MVI   6(R15),PRESENT      OPERANDS ARE PRESENT\n         B     FND1                CONTINUE WITH FND1\n         SPACE 1\n*----------------------------------------------------------*\n*        DEBUG (SHOW TGET RESULTS ON SCREEN)               *\n*----------------------------------------------------------*\n         SPACE 1\nDEBUG    MVI   DEBUGSW,C'D'        START DEBUG DISPLAYS IF ANY ERROR\n         MVI   HELPFLG,C'D'        REFRESH OF SCREEN NEEDED\n         B     FILLSCR\n         EJECT\n*----------------------------------------------------------*\n*        END OF PROGRAM                                    *\n*----------------------------------------------------------*\n         SPACE 1\nEND0     TM    MDFL,HELPFX\n         BZ    END1\n         NI    MDFL,255-HELPFX\n         B     FILLSCR\nEND1     LA    R1,ERAZE\n         LA    R0,ERAZEL\n        TPUT   (1),(0),FULLSCR     ERASE THE SCREEN\n         TM    MDFL,STSIZEX        TERMINAL SIZE RESET?\n         BNO   END2                NO, BRANCH\n        STSIZE SIZE=132,LINE=27    YES, CHANGE THE SIZE BACK\n         LA    R1,INWRTA           WRITE ALTERNATE\n         LA    R0,INWRTAL          LENGTH\n        TPUT   (1),(0),FULLSCR     WRITE FULL SCREEN\n         XI    MDFL,STSIZEX        RESET STSIZE BIT\nEND2    STLINENO LINE=1,MODE=OFF   TURN OFF FULL SCREEN MODE\n        TCLEARQ INPUT              CLEAR INPUT QUEUE FOR SYNCRONIZATION\n         XR    R15,R15\n         CLC   PCMD(2),=CL8'HELP    ' HELP COMMAND NAME?\n         BE    EXITRC              YES, BRANCH\n         CLC   PCMD(2),=C'H '      H COMMAND NAME?\n         BE    EXITRC              YES, BRANCH\n         TM    MDFL,HELPX          HELPX ENTRY?\n         BO    EXITRC              YES, BRANCH\n        TPUT   BLANKS,2            OUTPUT ONE BLANK LINE\n         XR    R15,R15\n         B     EXITRC\nIOERR    LA    R1,SYNADMSG\n         LA    R0,78\n         BAL   R14,PUTMSG\nEXIT12   LA    R15,12\nEXITRC   CH    R15,RC\n         BNH   *+L'*+4\n         STH   R15,RC              SET HIGHEST RC\n         TM    MDFL,STSIZEX        TERMINAL SIZE RESET?\n         BNO   EXITRCX             NO, BRANCH\n        STSIZE SIZE=132,LINE=27    YES, CHANGE THE SIZE BACK\n         LA    R1,INWRTA           WRITE ALTERNATE\n         LA    R0,INWRTAL          LENGTH\n        TPUT   (1),(0),FULLSCR     WRITE FULL SCREEN\nEXITRCX  TM    STATUS,STGMVU\n         BZ    NOGMVU\n         L     R0,ANSWER+4         LENGTH\n         L     R1,ANSWER           ADDRESS\n        FREEMAIN R,LV=(0),A=(1)\n         NI    STATUS,255-STGMVU\nNOGMVU   TM    STATUS,STOPEN\n         BZ    NOCLOSE\n         TM    DCBOFLGS,DCBOFOPN   IS IT OPEN?\n         BZ    NOCLOSE             NO, BRANCH\n         MVI   CLOSED,X'80'\n        CLOSE ((R4)),MF=(E,CLOSED)\n         NI    STATUS,255-STOPEN   CLOSED\nNOCLOSE  LM    R10,R12,BASE1\n         L     R14,RETSV\n         BR    R14                 RETURN TO PHASE 1\n         EJECT\n*----------------------------------------------------------*\n*        SUBROUTINE TO CONVERT DATA TO HEX                 *\n*----------------------------------------------------------*\n         SPACE 1\nHEX      MVC   1(1,R15),0(R1)      MOVE BYTE\n         UNPK  0(3,R15),1(2,R15)   UNPACK\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         INCREMENT OUTPUT PTR\n         LA    R1,1(,R1)           INCREMENT INPUT PTR\n         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP\n         MVI   0(R15),C' '         BLANK THE TRAILING BYTE\n         BR    R14                 RETURN TO CALLER\n         SPACE 1\n*----------------------------------------------------------*\n*        SUBROUTINE TO GET A LOGICAL RECORD                *\n*----------------------------------------------------------*\n*              INPUT\n*                R4 DCB ADDRESS\n*                CHKPTTOP  -  TOP OF CHECKPOINT TABLE\n*                CHKPTBOT  -  BOTTOM OF CHECKPOINT TABLE, ZERO 1ST TIME\n*                COUNT     -  LAST LOGICAL RECORD NUMBER READ\n*                BLOCKPTR  -  ADDRESS OF BUFFER\n*                DEBLOCKS  -  DEBLOCKING INFO (ZEROS FIRST TIME)\n*                SPANPTR   -  ADDRESS OF AREA TO COMBINE\n*                             SPANNED RECORD SEGMENTS\n*              OUTPUT\n*                R1 CONTAINS LENGTH OF RECORD (OR -1 IF END OF FILE)\n*                R2 CONTAINS ADDRESS OF RECORD (OR 0 IF END OF FILE)\n*\n         SPACE 1\nGET      ST    R14,READR\n         TM    DCBRECFM,DCBRECBR   BLOCKED\n         BZ    READI               NO, BRANCH\n         LM    R0,R2,DEBLOCKS      GET DEBLOCKING STATUS\n         AR    R2,R1               POINT TO NEXT RECORD\n         CR    R2,R0               END OF BLOCK (OR FIRST TIME)\n         BNL   READI               YES, BRANCH\n         TM    TSTRECFM,DCBRECV    VARIABLE LENGTH\n         BO    READVB              YES, BRANCH\n         ST    R2,DEBLOCKS+8       FIXED BLOCKED\n         B     READX\nREADI    L     R5,CHKPTBOT         GET LAST CHECKPOINT\n         LTR   R5,R5               IS THIS FIRST READ\n         BNZ   READNF              BRANCH IF NOT FIRST\n         L     R5,CHKPTTOP\n         B     READNEW             READING A RECORD NOT READ BEFORE\nREADNF   L     R1,0(,R5)           GET NUMBER OF HIGHEST RECORD READ\n         LTR   R1,R1               WAS IT EOF\n         BM    READOLD             YES, BRANCH\n         C     R1,COUNT            HAVE WE READ THIS RECORD BEFORE\n         BNH   READADD             NO, BRANCH\nREADOLD  LA    R5,CHKPTDUM         YES, DONT CHANGE CHKPT TABLE\n         B     READ\nREADADD  LA    R5,20(,R5)          ADD AN ENTRY TO THE CHKPT TABLE\n         C     R5,ENDPTR           IS TABLE FILLED UP\n         BL    READNEW             NO, SKIP NEXT INSTR\n*                                  YES, HALVE THE TABLE\n         LA    R0,20               LENGTH OF EACH ENTRY\n         L     R15,CHKPTTOP        POINT TO FIRST ENTRY\n         AR    R15,R0              POINT TO SECOND ENTRY\n         LR    R1,R15\n         AR    R1,R0               POINT TO THIRD ENTRY\nREADHMOV MVC   0(20,R15),0(R1)     MOVE 3RD TO 2ND\n*                                       5TH TO 3RD\n*                                       7TH TO 4TH, ETC\n         AR    R15,R0              RECEIVING FIELD DOWN 1\n         AR    R1,R0               SENDING FIELD DOWN 1\n         AR    R1,R0               SENDING FIELD DOWN 2\n         CR    R1,R5               ARE WE PAST THE LAST ENTRY\n         BL    READHMOV            NO, BRANCH\n         LR    R5,R15              YES, NEW CURRENT POINTER\nREADNEW  ST    R5,CHKPTBOT         SAVE NEW CURRENT CHECKPOINT POINTER\n         MVC   0(4,R5),COUNT\n         XC    4(4,R5),4(R5)\n         MVC   8(12,R5),DEBLOCKS\nREAD     TM    STATUS,STNOMEM      ARE WE IN MEMBER-NOT-FOUND STATUS\n         BO    DYNEOD              YES, JUST GO TO END OF FILE\n         L     R2,BLOCKPTR\n        READ   DYNDECBW,SF,(R4),(R2),'S',MF=E\n        CHECK  DYNDECBW\n         CLI   SYNADSW,0           WAS SYNAD EXIT TAKEN?\n         BNE   IOERR               YES, BRANCH\n         LH    R1,DCBBLKSI\n         L     R14,DYNDECBW+16\n         SH    R1,14(,R14)         SUBTRACT RESIDUAL COUNT\n         TM    TSTRECFM,DCBRECV    VARIABLE LENGTH RECORDS\n         BZ    *+L'*+4             NO, BRANCH\n         LH    R1,0(,R2)           YES, USE BLKSIZE IN BDW\n         LA    R0,0(R1,R2)         END OF BLOCK\n         STM   R0,R2,DEBLOCKS      SAVE STATUS INFO\n         CLC   4(4,R5),=F'0'       IS THIS 2ND READ PER GET\n         BNZ   NOTED               YES, BYPASS NOTE\n        NOTE   (R4)\n         ST    R1,4(,R5)           SAVE TTR IN TABLE\nNOTED    L     R1,DEBLOCKS+4       RESTORE LENGTH\n         TM    DCBRECFM,DCBRECBR   BLOCKED?\n         BO    READB               YES, BRANCH\n         TM    TSTRECFM,DCBRECV+DCBRECSB VARIABLE UNBLOCKED SPANNED\n         BNO   READX               NO\n         B     READVBS             YES, SAME AS BLOCKED\nREADB    TM    DCBRECFM,DCBRECU    UNDEFINED\n         BO    READX\n         TM    DCBRECFM,DCBRECV    VARIABLE LENGTH\n         BO    READVBI\n         LH    R1,DCBLRECL         FIXED BLOCKED\n         ST    R1,DEBLOCKS+4       SAVE STATUS INFO\n         B     READX\nREADVBI  LA    R2,4(,R2)           POINT PAST BDW                    $V\nREADVB   TM    DCBRECFM,DCBRECSB   SPANNED\n         BO    READVBS\nREADVBR  LH    R1,0(,R2)\n         STM   R1,R2,DEBLOCKS+4    SAVE STATUS INFO\n         B     READX\nREADVBS  CLI   2(R2),0             SEGMENT\n         BE    READVBR             NO, BRANCH\n*              THIRD BYTE IS X'01' FOR FIRST SEGMENT\n*                            X'03' FOR MIDDLE SEGMENT\n*                            X'02' FOR LAST SEGMENT\n         CLI   2(R2),1             FIRST SEGMENT\n         BNE   READSEG2\n         L     R14,SPANPTR         ADDRESS TO MOVE TO\n         LH    R15,0(,R2)          LENGTH TO MOVE\n         LR    R1,R15              LENGTH TO MOVE\n         LR    R0,R2               ADDRESS TO MOVE FROM\n         MVCL  R14,R0              MOVE SEGMENT RDW AND DATA\n         B     READSEGD            GO DEBLOCK NEXT SEGMENT\nREADSEG2 L     R14,SPANPTR         ADDRESS OF PRIOR SEGMENTS\n         LH    R0,0(,R14)          LENGTH OF PRIOR SEGMENTS\n         LH    R15,0(,R2)          LENGTH+4 OF NEW SEGMENT\n         SH    R15,=H'4'           LENGTH OF NEW SEGMENT\n         LR    R1,R15              LENGTH TO BE MOVED\n         AR    R15,R0              COMBINE LENGTHS\n         STH   R15,0(,R14)         STORE COMBINED LENGTHS\n         LR    R15,R1              LENGTH TO ME MOVED\n         AR    R14,R0              ADDRESS TO MOVE TO\n         LA    R0,4(,R2)           ADDRESS TO MOVE FROM\n         MVCL  R14,R0              MOVE SEGMENT DATA\n         CLI   2(R2),2             LAST SEGMENT\n         BNE   READSEGD            NO, GO DEBLOCK NEXT SEGMENT\n         LH    R1,0(,R2)           GET LENGTH OF THIS SEGMENT\n         STM   R1,R2,DEBLOCKS+4    SAVE LENGTH AND ADDRESS\n         L     R2,SPANPTR          POINT TO COMBINED RECORD\n         LH    R1,0(,R2)           GET COMBINED LENGTH\nREADX    L     R14,READR\n         BR    R14\nREADSEGD LH    R1,0(,R2)           LENGTH\n         AR    R2,R1               POINT TO NEXT SEGMENT\n         C     R2,DEBLOCKS         END OF BLOCK\n         BNL   READ                YES, BRANCH\n         B     READVBS             GO PROCESS NEW SEGMENT\n         DROP  R4                  IHADCB\n         SPACE 1\n*----------------------------------------------------------*\n*        SUBROUTINE TO PUT OUT A MESSAGE                   *\n*----------------------------------------------------------*\n         SPACE 1\nPUTMSG   STM   R14,R1,PUTLINS\n         XC    MYOLD(8),MYOLD\n         XC    MYSEG(4),MYSEG\n         MVC   MYPTPB(12),MODLPTM\n         LA    R14,1               NO. OF MESSAGE SEGMENTS\n         ST    R14,MYOLD\n         LA    R14,MYSEG           POINT TO 1ST SEGMENT\n         ST    R14,MYOLD+4\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         LA    R15,MYSEG+4\n         CLC   0(3,R1),=C'IKJ'     IS DATA PRECEEDED BY MESSAGE ID?\n         BE    *+L'*+12            YES - BRANCH\n         LA    R14,1(,R14)         ADD 1 TO LENGTH\n         MVI   0(R15),C' '         INSERT LEADING BLANK\n         LA    R15,1(,R15)         BUMP POINTER\n         STH   R14,MYSEG\n         LR    R14,R0\n         BCT   R14,*+L'*+6\n         MVC   0(*-*,R15),0(R1)    MOVE MESSAGE IN\n         EX    R14,*-6\n         L     R15,MYPUTLEP\n        PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),ENTRY=(15),MF=(E,MYIOPL)\n         LM    R14,R1,PUTLINS\n         BR    R14\n         EJECT\n*----------------------------------------------------------*\n*        CONSTANTS                                         *\n*----------------------------------------------------------*\n         SPACE 1\nMODLPTM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                          X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE 1\n         PRINT NOGEN\nSEQDCB  DCB    DDNAME=DYNAM,DSORG=PS,MACRF=(RP),                       X\n               EODAD=0,SYNAD=0\nSEQDCBL  EQU   *-SEQDCB\nPDSDCB  DCB    DDNAME=DYNAM,DSORG=PO,MACRF=(R),                        X\n               EODAD=0,SYNAD=0\nPDSDCBL  EQU   *-PDSDCB\n         PRINT GEN\n         SPACE 1\nDYNREAD READ   DYNDECB,SF,0,0,'S',MF=L\nDYNDECBL EQU   *-DYNDECB\n         SPACE 1\nGMVU    GETMAIN VU,MF=L\nGMVUL    EQU   *-GMVU\n         SPACE 1\nBOTNINES DC    F'99999999'\nHEXTAB   DC    C'0123456789ABCDEF' EDIT HEX TRANSLATE TABLE\nBLANKS   DC    CL132' '\n         EJECT\n*------- TRANSLATE TABLES\nASIST    DC    64X'4B',X'40',9X'4B'\n         DC    X'4A4B4C4D4E4F'     CENT,PERIOD,LESS,LPAREN,PLUS,BAR\n         DC    X'50',9X'4B'        AMPERSAND\n         DC    X'5A5B5C5D5E5F'     EXCL,$,DOT,RPAREN,SEMI,NOT\n         DC    X'6061',8X'4B'      HYPHEN,SLASH\n         DC    X'6A6B6C6D6E6F'     WHAT,COMMA,PERCENT,UNDLN,GT,QM\n         DC    9X'4B',X'79'        70-78\n         DC    X'7A7B7C7D7E7F'     COLON,POUND,AT,APOST,EQ,DBLQUOTE\n         DC    X'4B'\n         DC    X'818283848586878889',7X'4B'\n         DC    X'919293949596979899',8X'4B'\n         DC    X'A2A3A4A5A6A7A8A9',23X'4B'\n         DC    C'ABCDEFGHI',7X'4B'\n         DC    C'JKLMNOPQR',8X'4B'\n         DC    C'STUVWXYZ',06X'4B'\n         DC    C'0123456789',6X'4B'\nCAPST    DC    64X'4B',X'40',9X'4B'\n         DC    X'4A4B4C4D4E4F'     CENT,PERIOD,LESS,LPAREN,PLUS,BAR\n         DC    X'50',9X'4B'        AMPERSAND\n         DC    X'5A5B5C5D5E5F'     EXCL,$,DOT,RPAREN,SEMI,NOT\n         DC    X'6061',8X'4B'      HYPHEN,SLASH\n         DC    X'6A6B6C6D6E6F'     WHAT,COMMA,PERCENT,UNDLN,GT,QM\n         DC    9X'4B',X'79'        70-78\n         DC    X'7A7B7C7D7E7F'     COLON,POUND,AT,APOST,EQ,DBLQUOTE\n         DC    X'4B'\n         DC    C'ABCDEFGHI',7X'4B'\n         DC    C'JKLMNOPQR',8X'4B'\n         DC    C'STUVWXYZ',23X'4B'\n         DC    C'ABCDEFGHI',7X'4B'\n         DC    C'JKLMNOPQR',8X'4B'\n         DC    C'STUVWXYZ',06X'4B'\n         DC    C'0123456789',6X'4B'\nFINDSBA  DC    17X'00',X'11',238X'00'\nNUMERIC  DC    240X'FF',10X'00',6X'FF'\nTABNONBL DC    64X'FF'\n         DC    X'00'               BLANK\n         DC    42X'FF'\n         DC    X'FF'               COMMA\n         DC    148X'FF'\nTABBLANK DC    64X'00'\n         DC    X'40'               BLANK\n         DC    42X'00'\n         DC    X'00'               COMMA\n         DC    148X'00'\nTABQUOTE DC    125X'00',X'7D',130X'00'\n         EJECT\n*------- MESSAGES\nMSG04    DC    C'UNABLE TO OPEN DATASET'\nMSG08    DC    C'SPECIFIED MEMBER NOT FOUND IN DATASET'\nMSG20   MSG    'INVALID SUBCOMMAND'\nMSG21   MSG    'INVALID PF KEY'\nMSG31   MSG    'FOUND IN LINE XXXXX COL XXX'\nMSG32   MSG    'BOTTOM OF DATA REACHED '\nMSG32S  MSG    'SUBCOMMAND NOT FOUND'\nMSG32F  MSG    'FUNCTION DATA NOT FOUND'\nMSG32SS MSG    'SUBCOMMANDS NOT FOUND'\nMSG32X  MSG    'SYNTAX DATA NOT FOUND'\nMSG32O  MSG    'OPERAND DATA NOT FOUND'\nMSG32OO MSG    'OPERAND NOT FOUND'\nMSG33   MSG    'STRING NOT SPECIFIED'\nMSG34   MSG    'INVALID OPERAND'\nMSG35   MSG    'MISSING OPERAND'\nMSG36   MSG    'MEMBER NOT FOUND'\nMSG37   MSG    'BLDL FAILED'\nMSG38   MSG    'NOT A PDS'\nMSG40   MSG    'PFK HAS BEEN RESET'\nMSG41   MSG    'INVALID PFK COMMAND'\n         SPACE 2\n*------- SCREEN DATAS\nSCREEN  DCS    X'40',SBA,24,80,SBA,1,1\n        DCS    SF,PROHIS,C'HELP MEMBER==>'\nSCRMEM  DCS    SF,UNPHI,CL8' '\n        DCS    SF,PROHIS,C' SUBCOMMAND==>'\nSCRSUB  DCS    SF,UNPHI,CL8' '\nSCRERR  DCS    SF,PROHIS,C'        LINE '\nSCRLINE DCS    C'00000'\n        DCS    C' COL '\nSCRCOL  DCS    C'001 080 '\nSCRRTA  DCS    SF,PROHIS,RTA,02,07,X'40'\n        DCS    SF,PROHIS,C'INPUT==>'\n        DCS    SF,UNPHI,CL54' '\n        DCS    SF,PROHIS,C'RANGE'\nSCRRGE  DCS    SF,UNPHI,C'20'      START WITH RANGE EQUAL PAGE\n        DCS    SF,PROLOS\nSCREENL  EQU   *-SCREEN\nSCRDATA  EQU   *\nSCRPAD  DCS    RTA,1,1,C' '\nSCRSUF  DCS    SBA,02,17,IC\n         SPACE 1\nFLD1AA  DCS    1,17\nFLD2AA  DCS    1,41\nFLD1BA  DCS    2,17\nFLD2BA  DCS    2,78\nFLD1BB   DC    X'C2D4'             R2,C17 ON 3278-5\nFLD2BB   DC    X'C3D1'             R2,C78 ON 3278-5\n         SPACE 1\nINWRT    DC    X'27F5'                 CC = EW\n        DCS    X'C1'                   WCC = RMDT\n        DCS    SBA,1,1\n        DCS    RTA,1,1,X'00'\n        DCS    SF,UNPHI\n        DCS    IC\nINWRTL   EQU   *-INWRT\nINWRTA   DC    X'277E'                 CC = EWA\n        DCS    X'C1'                   WCC = RMDT\n        DCS    SBA,1,1\n        DCS    RTA,1,1,X'00'\n        DCS    SF,UNPHI\n        DCS    IC\nINWRTAL  EQU   *-INWRTA\nERAZE   DCS    X'40',SBA,24,79,SBA,1,1\n        DCS    RTA,7,1,X'00',RTA,13,1,X'00'\n        DCS    RTA,19,1,X'00',RTA,1,1,X'00',IC\nERAZEL   EQU   *-ERAZE\n         EJECT\n*------- LITERAL POOL\n         SPACE 1\n        LTORG\n         SPACE 1\n         DC    0D'0'               END OF CSECT\n         SPACE 1\n         DROP  R10,R11,R12\n*= = = = END OF CSECT ADDRESSABILITY = = = = = = = = = = = = = = = = =*\n         SPACE 1\n*------- COLUMN HEADER CONSTANTS\n         SPACE 1\nMARKS    DC    18C'----+'\nMARKHS   DC    18C' - - - - +'\n         EJECT\n*----------------------------------------------------------*\n*        HEL CSECT EXTENSIONS                              *\n*----------------------------------------------------------*\n         SPACE 1\nHELEXT   CSECT\n         USING *,R8\n         USING HELXEQ,R10,R11,R12\n         B     TSOE                +0 = TSO\n         B     SNAPE               +4 = SNAP\n         SPACE 1\n*----------------------------------------------------------*\n*        TSO                                               *\n*----------------------------------------------------------*\n         SPACE 1\nTSOE     LA    R1,CMDAREA          START OF TSO PARAMETERS\n         LA    R0,63               LENGTH OF PARSE STRING\n         STH   R0,0(,R1)           SAVE FOR PARSE\n         LA    R15,OPD1            FIRST PARAMETER\n         TM    6(R15),PRESENT      ANY OPERANDS?\n         BZ    FILLSCR             NO, IGNORE\n         TM    6(R15),QUOTED       QUOTED?\n         BO    ERRINV              YES, INVALID\n         L     R14,0(,R15)         START OF PARAMETER\n         LH    R15,4(,R15)         LENGTH OF PARAMETER\n         LTR   R15,R15             IS IT NULL STRING\n         BZ    ERRINV              YES, ERROR\n         CH    R15,=H'8'           IS LENGTH MORE THAN 8\n         BH    ERRINV              YES, ERROR\n         MVC   BLDL(4),=AL2(1,76)\n         MVC   BLDL+4(8),BLANKS\n         BCT   R15,*+L'*+6         MACHINE LENGTH\n         MVC   BLDL+4(*-*),0(R14)  <<EXECUTED>>\n         EX    R15,*-6             MOVE IN THE COMMAND NAME\n         L     R6,HELECT           ECT ADDRESS\n         USING ECT,R6\n         CLC   BLDL+4(2),=C'RX'    DUMPER?\n         BE    *+L'*+6             YES, BRANCH\n         MVC   ECTPCMD(L'ECTPCMD),BLDL+4 COMMAND NAME IS CHANGED\n         MVC   ECTSCMD(L'ECTSCMD),BLANKS NO SUBCOMMAND NAME\n         LA    R15,OPD2            START OF SECOND ODL\n         L     R14,0(,R15)         START OF SECOND PARAMETER\n         LA    R14,0(,R14)         DROP TOP BYTE\n         SR    R14,R1              OFFSET TO SECOND PARAMETER\n         SH    R14,=H'4'           LESS TEXT LENGTH FIELDS\n         NI    ECTSWS,255-ECTNOPD  ASSUME OPERANDS\n         TM    6(R15),PRESENT      ANY OPERANDS?\n         BO    TSO1                YES, BRANCH\n         LA    R14,63              NO, USE DEFAULT\n         OI    ECTSWS,ECTNOPD      ASSUME NO OPERAND\n         DROP  R6\nTSO1     TM    6(R15),QUOTED       QUOTED?\n         BNO   *+L'*+2             NO, BRANCH\n         BCTR  R14,0               YES, POINT TO FIRST QUOTE\n         STH   R14,2(,R1)          OFFSET TO OPERANDS\n         ST    R1,HELCBUF          START OF COMMAND TEXT\n         CLC   BLDL+4(5),=C'TIME ' TIME REQUEST?\n         BNE   *+L'*+6             NO, BRANCH\n         MVC   BLDL+4(8),=C'IKJEFT25' YES, USE IKJEFT25 INSTEAD\n        BLDL   0,BLDL\n         LTR   R15,R15             SUCCESSFUL BLDL?\n         BZ    TSO2                YES, BRANCH\n         MVC   MSG(MSG36L),MSG36   MEMBER NOT FOUND\n         B     TSO3\nTSO2    STLINENO LINE=1,MODE=OFF   TURN OFF FULLSCREEN MODE\n         LA    R1,HELCBUF          CPPL START\n         LA    R6,BLDL+4           START OF BLDL INFORMATION\n        LINK  DE=(6),SF=(E,LINKAREA)\n        STFSMODE ON,INITIAL=YES    TURN ON FULLSCREEN MODE\nTSO3     L     R1,HELECT           START OF ECT\n         USING ECT,R1\n         MVC   ECTPCMD(3),PCMD     HELP COMMAND NAME\n         DROP  R1\n         B     FILLSCR\n         SPACE 1\n*----------------------------------------------------------*\n*        SNAP                                              *\n*----------------------------------------------------------*\n         SPACE 1\nSNAPE   GETMAIN R,LV=SNAPWKL,SP=1\n         LR    R7,R1\n         USING SNAPWK,R7\n         LA    R0,@DATA\n         ST    R0,SNAPR\n         A     R0,=A(@DATAL)\n         BCTR  R0,0\n         ST    R0,SNAPR+4\n         L     R0,CHKPTTOP\n         ST    R0,SNAPR+8\n         L     R0,CHKPTBOT\n         AH    R0,=H'80'\n         C     R0,ENDPTR\n         BNH   *+L'*+4\n         LH    R0,ENDPTR\n         SH    R0,=H'4'\n         ST    R0,SNAPR+12\n         OI    SNAPR+12,X'80'\n         MVC   SNAPDW(SNAPDL),SNAPD\n         LA    R6,SNAPDW\n        OPEN   ((R6),OUTPUT),MF=(E,OPEND)\n         USING IHADCB,R6\n         TM    DCBOFLGS,DCBOFOPN\n         BO    SNAP1\n         MVC   MSG+2(10),=C'OPEN RC = '\n         CVD   R15,DOUBLE\n         OI    DOUBLE+7,X'0F'\n         UNPK  MSG+12(3),DOUBLE+6(2)\n         LA    R0,14\n         STH   R0,MSG\n         B     SNAPX\n         DROP  R6\nSNAP1    MVC   SNAPLW(SNAPLL),SNAPL\n        SNAP   DCB=(R6),ID=1,PDATA=(REGS),LIST=SNAPR,MF=(E,SNAPLW)\n         LTR   R15,R15\n         BZ    SNAP2\n         MVC   MSG+2(10),=C'SNAP RC = '\n         CVD   R15,DOUBLE\n         OI    DOUBLE+7,X'0F'\n         UNPK  MSG+12(3),DOUBLE+6(2)\n         LA    R0,14\n         STH   R0,MSG\nSNAP2   CLOSE  ((R6)),MF=(E,OPEND)\n         DROP  R7\n         LTR   R15,R15\n         BZ    SNAPX\n         CLC   MSG+2(10),=C'SNAP RC = '\n         BE    SNAPX\n         MVC   MSG+2(11),=C'CLOSE RC = '\n         CVD   R15,DOUBLE\n         OI    DOUBLE+7,X'0F'\n         UNPK  MSG+13(3),DOUBLE+6(2)\n         LA    R0,15\n         STH   R0,MSG\nSNAPX   FREEMAIN R,A=(R7),LV=SNAPWKL,SP=1\n         CLC   MSG+2(10),=C'OPEN RC = '\n         BE    PROMPT\n         CLC   MSG+2(10),=C'SNAP RC = '\n         BE    PROMPT\n         CLC   MSG+2(11),=C'CLOSE RC = '\n         BE    PROMPT\n         MVC   MSG+2(9),=C'SNAP DONE'\n         LA    R0,9\n         STH   R0,MSG\n         B     PROMPT\n         SPACE 1\n         PRINT NOGEN\nSNAPD   DCB   DSORG=PS,RECFM=VBA,MACRF=(W),BLKSIZE=1632,LRECL=125,     X\n               DDNAME=SYSSNAP\nSNAPDL   EQU   *-SNAPD\nSNAPL   SNAP   DCB=0,ID=1,PDATA=(REGS),LIST=0,STRHDR=SNAPHP,MF=L\nSNAPLL   EQU   *-SNAPL\n         PRINT GEN\n         SPACE 1\nSNAPHP   DC    A(X'80000000'+SNAPHD)\nSNAPHD   DC    AL1(L'SNAPHDT)\nSNAPHDT  DC    C'H E L - DUMP OF THE WORK-AREA.'\n         EJECT\n*------- LITERAL POOL\n         SPACE 1\n        LTORG\n         SPACE 1\n         DC    0D'0'               END OF CSECT\n         SPACE 1\n         DROP  R8,R10,R11,R12\n*= = = = END OF CSECT ADDRESSABILITY = = = = = = = = = = = = = = = = =*\n         EJECT\n*----------------------------------------------------------*\n*        PARSE PARAMETERS                                  *\n*----------------------------------------------------------*\n         SPACE 1\n         PRINT NOGEN\nHELCL   IKJPARM\nMEMBRPO IKJIDENT 'MEMBER OR SUBCOMMAND NAME',                          +\n               FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=8\nFKW     IKJKEYWD\n        IKJNAME 'FUNCTION'\nSKW     IKJKEYWD\n        IKJNAME 'SYNTAX'\nOKW     IKJKEYWD\n        IKJNAME 'OPERANDS',SUBFLD=OPLSTS\nAKW     IKJKEYWD\n        IKJNAME 'ALL'\nMKW     IKJKEYWD\n        IKJNAME 'MSGS',SUBFLD=MSGLSTS\nPKW     IKJKEYWD\n        IKJNAME 'POSIT',SUBFLD=POSITF\nPOSITF  IKJSUBF\nPOSITFF IKJIDENT 'HELP PARAMETER POSITION',                            +\n               FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=5\nOPLSTS  IKJSUBF\nOPLIST  IKJIDENT 'HELP OPERAND NAME',LIST,                             +\n               FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=20\nMSGLSTS IKJSUBF\nMSGLIST IKJIDENT 'HELP MSG IDENTIFIER',LIST,                           +\n               FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=20\n        IKJENDP\n         PRINT GEN\n         EJECT\n*----------------------------------------------------------*\n*        WORK AREAS DSECTS                                 *\n*----------------------------------------------------------*\n         SPACE 1\n@DATA    DSECT\n         DS    18F                 REGISTER SAVEAREA\nCPPLPTR  DS    F\nLINKAREA DS    2F\nBASE1    DS    4F\nBASE2    DS    3F\nRETSV    DS    F\nMYPPL    DS    7F\nMYANS    DS    F\nMYECB    DS    F                   USED BY PUTLINE ROUTINE\nHELCBUF  DS    F  ****             CPPL FOR CALLED ROUTINE\nHELUPT   DS    F  ****             CPPL FOR CALLED ROUTINE\nHELPSCB  DS    F  ****             CPPL FOR CALLED ROUTINE\nHELECT   DS    F  ****             CPPL FOR CALLED ROUTINE\nPCMD     DS    CL8                 PRIMARY COMMAND NAME\nSCMD     DS    CL8                 SUBCOMMAND NAME\nMYIOPL   DS    4F                  USED BY PUTLINE ROUTINE\nMYPTPB   DS    3F                  USED BY PUTLINE ROUTINE\nMYOLD    DS    2F                  USED BY PUTLINE ROUTINE\nMYSEG    DS    2H,CL256            USED BY PUTLINE ROUTINE\nPUTLINS  DS    4F                  USED BY PUTLINE ROUTINE\nMYPUTLEP DS    F                   ADDRESS OF IKJPUTL\nMYSTPB   DS    0F                  5 WORDS USED BY STACK DELETE\nMYDAPL   DS    5F\nMYDAPB   DS    21F\n$DSNAME  DS    H,CL44\n$MEMBER  DS    CL8\n$SUBLEN  DS    XL2\n$SUBCOM  DS    CL8\n$SUBLINE DS    CL4\n$OPERAND DS    21CL20              TWENTY OPERANDS (EACH MAX. 20 BYTES)\n$DDNAML  DS    H                   THESE\n$DDNAME  DS    CL8,CL36              THREE TOGETHER\n$VOLSER  DS    CL6\n$UCBAD   DS    F\nPAGESIZE DS    H                   LINES PER SCREEN-4\nPAGEWIDT DS    H                   CHARACTERS PER LINE (80 OR 132)\nOBTAINW  DS    4F\nMYDSCB   DS    CL140               96 BYTES OF DSCB, 5 BYTES CCHHR\nMSG      DS    CL128\nSTATUS   DS    X\nSTALLOC  EQU   X'80'\nSTOPEN   EQU   X'40'\nSTABEND  EQU   X'20'\nSTGMVU   EQU   X'02'\nSTNOMEM  EQU   X'01'\nMDFL     DS    X\nMODEX    EQU   X'80'\nHELPX    EQU   X'40'\nSTSIZEX  EQU   X'20'\nHELPFX   EQU   X'01'\nDSORG    DS    X\nTSTRECFM DS    X\nFINDSW   DS    X\nRC       DS    H\nFILEKV   DS    H\nFKV      DS    H\nSKV      DS    H\nOKV      DS    H\nAKV      DS    H\nMKV      DS    H\nCOMMND   DS    H\nHELPFLG  DS    X\nDEBUGSW  DS    X\nMEMBFLG  DS    X\nMEMBFLGM EQU   X'80'               NEW MEMBER\nMEMBFLGS EQU   X'08'               NEW SUBCOMMAND\nMYDFPARM DS    5F                  USED BY DAIRFAIL\nMYDFREGS DS    F                   USED BY DAIRFAIL\nMYDFRC   DS    F                   USED BY DAIRFAIL\nMYJEFF02 DS    F                   USED BY DAIRFAIL\nMYDFID   DS    H                   USED BY DAIRFAIL\nSVPFNA   DS    F\nDOUBLE   DS    D\nCOLNUM   DS    CL6,CL2\nDAIRREGS DS    F\nOPEND    DS    0F\nCLOSED   DS    F\nDYNEXLST DS    2F\nDYNDCBW  DS    0D,XL(SEQDCBL)\nDYNDECBW DS    0F,XL(DYNDECBL)\nRANGE    DS    2F\nANSWER   DS    2F\nGMVUW    DS    0F,XL(GMVUL)\nSAVSPANL DS    F\nSAVLRECL DS    F\nSAVBLKSI DS    F\nSAVHOLDL DS    F\nBLOCKPTR DS    F\nSPANPTR  DS    F\nHOLDPTR  DS    F\nCHKPTTOP DS    F\nCHKPTBOT DS    F\nCHKPTDUM DS    2F\nENDPTR   DS    F\nHOLDTOP  DS    F\nHOLDEND  DS    F\nHOLDDIR  DS    (16*66)X *** WAS 88F -- GOOD FOR UP TO 65 LINES\nDIRNUM   EQU   0\nDIRLEN   EQU   4\nDIRREC   EQU   8\nDIRNXT   EQU   12\nDIRSIZ   EQU   16\nOFFSET   DS    H\nRECSIZE  DS    H\nCOUNT    DS    F\nTTR      DS    F\nTTRZ     DS    F                   TTR + 0 FOR POINT\nTTRK     DS    F                   TTR + CONCAT FOR FIND\nSCROLL   DS    F\nDOWNAMT  DS    F\nLISTNUM  DS    F\nAIMFOR   DS    F\nFLDPTR   DS    F\nFLDLEN   DS    F\nCMDPTR   DS    F\nCMDLEN   DS    F\nCMDAREA  DS    CL63\nSAVELINE DS    CL33\nSBASAVE  DS    4F\nFINDCOL  DS    H\nFNDNUM   DS    F\nFNDOFF   DS    H\nSTRINGL  DS    H\nSTRING   DS    CL64\nOPDL     DS    0F                  OPERAND DESCRIPTOR LIST\nOPD0     DS    2F                  COMMAND DESCRIPTOR\nOPD1     DS    2F                  OPERAND DESCRIPTOR 1\nOPD2     DS    2F                  OPERAND DESCRIPTOR 2\nOPD3     DS    2F                  OPERAND DESCRIPTOR 3\nOPD4     DS    2F                  OPERAND DESCRIPTOR 4\nOPD5     DS    2F                  OPERAND DESCRIPTOR 5\nOPDLL    EQU   *-OPDL              LENGTH OF LIST\nPRESENT  EQU   X'80'\nQUOTED   EQU   X'40'\nHOLDR    DS    F\nREADR    DS    F\nDOWNR    DS    F\nDEBLOCKS DS    3F\nSCREENF  DS    F\nTGETREGS DS    3F\nTGETREG2 DS    3F                  FOR DEBUG\nSYNADSW  DS    F\nSYNADMSG DS    CL78\nDEVDATA  DS    2F\nJFCB     DS    0F,CL176\nAPFKTB   DS    F\nSCREENH  DS    F\nBLDL     DS    0H,CL80\n         DS    0D\nREPLY    DS    CL256\nPERIODS  DS    CL256\nPFKTAB   DS    12CL32,CL1\nSCREENW  DS    0D,5400C\n@DATAL   EQU   (((*-@DATA)+7)/8)*8\n         SPACE 1\nSNAPWK   DSECT\nSNAPDW   DS    0F,(SNAPDL)X\nSNAPLW   DS    0F,(SNAPLL)X\nSNAPR    DS    4F\nSNAPWKL  EQU   (((*-SNAPWK)+7)/8)*8\n         SPACE 1\n*----------------------------------------------------------*\n*        DSECTS                                            *\n*----------------------------------------------------------*\n         SPACE 1\n         PRINT NOGEN\n        CVT    DSECT=YES,LIST=YES\n        DCBD   DEVD=DA,DSORG=PO\nTIODSECT DSECT\n        IEFTIOT1\nUCBDSECT DSECT\n        IEFUCBOB LIST=YES\n        IKJTCB LIST=YES\n        IKJCPPL\n        IKJPPL\n        IKJECT\n        IKJIOPL\n        IKJDAPL\n        IKJDAP08\n        IKJDAP18\n        IKJEFFDF DFDSECT=YES\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HEL$": {"ttr": 20998, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15G\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:47:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SYSPAJA"}, "text": "//HEL      JOB (........),'INSTALL  - H E L-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=8\n//ASS     EXEC PAJ4AS3,OPT=',NORLD,RENT',MBR=HEL\n//ASH     EXEC PAJ4AS1,OPT=',NORLD,RENT',MBR=HELMSGS\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT,REUS,REFR'\n//SYSIN     DD *\n  ALIAS   HL\n  ENTRY   HEL\n  NAME    HEL(R)\n/*\n//HLP     EXEC PAJHELP,MBR=HELH,DSS='->.SOURCE.FILE4'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HEL@": {"ttr": 21000, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x04\\x0f\\x00\\x90\\x04\\x0f\\x14\\x16\\x01\\xad\\x01\\xad\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-02-09T00:00:00", "modifydate": "1990-02-09T14:16:00", "lines": 429, "newlines": 429, "modlines": 0, "user": "SYSPAJA"}, "text": "1   08/02/90\n                                                      HEL       1/10.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *   A TSO full-screen HELP command.   * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  CBT origin : Extracted from CBT tape 89 FEB, file 296.\n  ------------\n\n  Function :\n  ----------\n  The HEL command displays a HELP member on a 3270 terminal\n  in full screen mode (80 character wide screens only).\n  In the field labelled MEMBER==> _______, HEL displays the current\n  HELP member; if the cursor is positioned to this field and a command\n  name is entered, HEL will display that new member's HELP data.\n  In the field labelled SUBCOMMAND==> _______, HEL displays the current\n  subcommand of the HELP command; if the cursor is positioned to this\n  field and a name is entered, HEL will display the member's HELP data\n  for the entered subcommand.\n  The field labelled INPUT==> _______ is the primary input field for\n  HEL; any supported subcommand may be entered.\n  In the field labelled RANGE NN, HEL displays the default forward and\n  backward space quantity, if the cursor is positioned to this field\n  and a number is entered, that quantity will become the default\n  forward and backward space quantity.\n  Subcommands : COMMAND, MEMBER, SUBCOM, FIND, UP, DOWN, LEFT, RIGHT,\n                TOP, BOTTOM, CAPS, ASIS, PFK, HEX, TSO, HELP, LIST, END\n\n  Syntax :\n  --------\n         HEL    COMMAND  FUNCTION  SYNTAX\n                OPERANDS(KEYWORD-LIST)  ALL\n  Alias    - HL\n  Required - none.\n  Defaults - ALL if FUNCTION, SYNTAX, and OPERANDS not specified.\n  Note     - if HEL is entered without any OPERANDS a list of\n             available commands with a short description of each will\n             be displayed.\n  Note     - KEYWORD-LIST is optional when OPERANDS is used.\n1   08/02/90\n                                                      HEL       2/10.\n\n  Operands :\n  ----------\n  COMMAND  - name of the command to be explained.\n  FUNCTION - function data is to be displayed.\n  SYNTAX   - syntax data is to be displayed.\n  OPERANDS(KEYWORD-LIST)\n           - operand description is to be displayed. If\n             KEYWORD-LIST is present, positioning is to the first\n             operand in the list encountered.\n  KEYWORD-LIST\n           - keywords separated by commas, blanks, or tabs.\n  ALL      - function, syntax, and operand descriptions are to be\n             displayed.\n  POSITIONAL('OPERAND NUMBER')\n           - a description of the positional operand specified is to\n             be displayed.  This operand is not supported by HEL; if\n             it is present, the IBM HELP command is invoked instead.\n  MSG('MSGID')\n           - a description of the message identified by MSGID is to be\n             displayed.  This operand is not supported by HEL; if it is\n             present, the IBM HELP command is invoked instead.\n  PFK       - this is not an operand, but a description of\n              the program function keys used by this command :\n              PFK1  - HELP    PFK2  -            PFK3  - END\n              PFK4  - END     PFK5  - FIND       PFK6  -\n              PFK7  - UP      PFK8  - DOWN       PFK9  - HEX\n              PFK10 - LEFT    PFK11 - RIGHT      PFK12 -\n              These can be changed using the PFKn subcommand, but\n              the changes are in effect only until the command ends.\n              Example : PFK6 RIGHT 1 would make PFK6 'RIGHT 1'.\n1   08/02/90\n                                                      HEL       3/10.\n\n ======================  S U B C O M M A N D S  =======================\n  This is not an operand, but a list of the subcommands that can be\n  entered in the primary input field.\n    UP      - scroll forwards a specified number of records.\n              If no operand is specified, the range value is\n              used. This is displayed in the upper right corner.\n              Alias : -\n    DOWN    - scroll backwards a specified number of records.\n              If no operand is specified, the range value is\n              used. This is displayed in the upper right corner.\n              Alias : +\n    LEFT    - scroll to the left a specified number of columns.\n              If no operand is specified, 40 is used.\n              Alias : <\n    RIGHT   - scroll to the right a specified number of columns.\n              If no operand is specified, 40 is used.\n              Alias : >\n    TOP     - scroll up to the first record.\n    BOTTOM  - scroll down to the last record.\n              Alias : BOT\n    LIST    - display the specified record number.\n              Relative record number only, not sequence numbers.\n              Alias : L\n    HEX ON  - display the screen in hexadecimal.\n    HEX OFF - display the screen in EBCDIC.\n    HEX     - if HEX currently ON, turn it OFF. If OFF, turn it ON.\n    HELP    - displays HELP data.\n              Aliases : HEL, H\n    TSO     - issues the TSO command named and any operands.\n    FIND    - search forward until the specified string is found.\n              String does not have to be in quotes unless it\n              contains one or more imbedded blanks.\n              String may be followed by a column number.\n              If no operand, the string from previous FIND is used.\n              Alias : F\n    CAPS    - display lower case data in upper case.\n    ASIS    - display lower case data in lower case.\n    COMMAND - switch to the specified HELP member.\n              Aliases : MEMBER, COM, MEM\n    SUBCOM  - switch to a different subcommand in the same HELP member.\n              Alias : SUB\n    PFKn    - set program function key n.\n    END     - end the command.\n1   08/02/90\n                                                      HEL       4/10.\n\n ========================== HELP subcommand ===========================\n Function :\n ----------\n  The HELP subcommand provides FUNCTION, SYNTAX, and OPERAND\n  information on the currently processing command and its subcommands.\n Syntax :\n --------\n         HELP   'SUBCOMMAND NAME'/'CURRENT COMMAND NAME'\n                FUNCTION  SYNTAX  OPERANDS('KEYWORD LIST')  ALL\n  Aliases  - HELP, HEL, H\n  Required - none.\n  Defaults - ALL if FUNCTION, SYNTAX, and OPERANDS not specified.\n  Note     - if HELP is entered without any operands a list of\n             subcommands of the current command will be displayed.\n  Note     - 'KEYWORD LIST' is optional when OPERANDS is used.\n Operands :\n ----------\n  'SUBCOMMAND NAME'\n           - name of the subcommand of the current command to be\n             explained.\n  'CURRENT COMMAND NAME'\n           - entered if the currently processing command is to be\n             explained.\n  FUNCTION - function data is to be displayed.\n  SYNTAX   - format is to be displayed.\n  OPERANDS('KEYWORD LIST')\n           - operand description is to be displayed. If\n             'KEYWORD LIST' is present, only those keyword descriptions\n             are to be displayed.\n    'KEYWORD LIST'\n           - keywords separated by commas, blanks, or tabs.\n  ALL      - FUNCTION, SYNTAX, and OPERAND descriptions are to be\n             displayed.\n  POSITIONAL('OPERAND NUMBER')\n           - a description of the positional operand specified is to\n             be displayed. This operand is not supported by HEL; if\n             it is present, the IBM HELP command is invoked instead.\n  MSG('MSGID')\n           - a description of the message identified by MSGID is to be\n             displayed. This operand is not supported by HEL; if it is\n             present, the IBM HELP command is invoked instead.\n1   08/02/90\n                                                      HEL       5/10.\n\n ========================= COMMAND subcommand =========================\n Function :\n ----------\n  The COMMAND or MEMBER subcommand switches to a different HELP\n  member. This member must be present in the SYSHELP data-sets.\n Syntax :\n --------\n     COMMAND MEMBERNAME\n Aliases  - COMMAND, COM, MEMBER, MEM\n Defaults - same member.\n Required - none.\n Operands :\n ----------\n   MEMBERNAME - specifies the name of a HELP member to be displayed.\n\n ========================= SUBCOM subcommand ==========================\n Function :\n ----------\n  The SUBCOM subcommand switches to a different subcommand\n  description in the same MEMBER or COMMAND.\n Syntax :\n --------\n     SUBCOM SUBNAME\n Aliases  - SUBCOM, SUB\n Defaults - same subcommand.\n Required - none.\n Operands :\n ----------\n   SUBNAME  - specifies the name subcommand for this MEMBER or COMMAND.\n1   08/02/90\n                                                      HEL       6/10.\n\n ========================== FIND subcommand ===========================\n Function :\n ----------\n  The FIND subcommand positions the screen to a text string.\n  FIND notes :\n   1.  only upper case data is searched for.\n   2.  if no operand is entered, the previously used string is used.\n   3.  quotation marks are optional for the string unless it contains\n       blank characters.\n   4.  a second operand may be entered to search a single column;\n       otherwise, all 80 columns are searched.\n Syntax :\n --------\n     FIND STRING COLUMN\n Aliases  - FIND, F\n Defaults - same string.\n Required - none.\n Operands :\n ----------\n   STRING   - specifies the upper case data to locate.\n   COLUMN   - optional, specifies a column number to search.\n\n =========================== UP subcommand ============================\n Function :\n ----------\n  The UP subcommand moves the screen up the specified number of\n  lines; if no operand is entered, the range quantity is used.\n Syntax :\n --------\n     UP NUMBER\n Aliases  - UP, -\n Defaults - range quantity.\n Required - none.\n Operands :\n ----------\n   NUMBER   - specifies the number of lines to move the screen.\n\n ========================== DOWN subcommand ===========================\n Function :\n ----------\n  The DOWN subcommand moves the screen down the specified number\n  of lines; if no operand is entered, the range quantity is used.\n Syntax :\n --------\n     DOWN NUMBER\n Aliases  - DOWN, +\n Defaults - range quantity.\n Requierd - none.\n Operands :\n ----------\n   NUMBER   - specifies the number of lines to move the screen.\n1   08/02/90\n                                                      HEL       7/10.\n\n ========================== LEFT subcommand ===========================\n Function :\n ----------\n  The LEFT subcommand moves the screen left the specified number of\n  columns; if no operand is entered, 40 is used.\n Syntax :\n --------\n     LEFT NUMBER\n Aliases  - LEFT, <\n Defaults - 40.\n Requierd - none.\n Operands :\n ----------\n   NUMBER   - specifies the number of columns to move the screen.\n\n ========================== RIGHT subcommand ==========================\n Function :\n ----------\n  The RIGHT subcommand moves the screen right the specified number\n  of columns; if no operand is entered, 40 is used.\n Syntax :\n --------\n     RIGHT NUMBER\n Aliases  - RIGHT, >\n Defaults - 40.\n Required - none.\n Operands :\n ----------\n   NUMBER   - specifies the number of columns to move the screen.\n\n =========================== TOP subcommand ===========================\n Function :\n ----------\n  The TOP subcommand moves the screen to the first line of the\n  MEMBER.\n Syntax :\n --------\n     TOP\n Aliases  - none.\n Defaults - none.\n Required - none.\n Operands : none.\n ----------\n1   08/02/90\n                                                      HEL       8/10.\n\n ========================= BOTTOM subcommand ==========================\n Function :\n ----------\n  The BOTTOM subcommand moves the screen to the last line of the\n  MEMBER.\n Syntax :\n --------\n     BOTTOM\n Aliases  - BOTTOM, BOT\n Defaults - none.\n Required - none.\n Operands : none.\n ----------\n\n ========================== CAPS subcommand ===========================\n Function :\n ----------\n  The CAPS subcommand displays lower case data as upper case.\n Syntax :\n --------\n     CAPS\n Aliases  - none.\n Defaults - none.\n Required - none.\n Operands : none.\n ----------\n\n ========================== ASIS subcommand ===========================\n Function :\n ----------\n  The ASIS subcommand displays lower case data as lower case.\n Syntax :\n --------\n     ASIS\n Aliases  - none.\n Defaults - none.\n Required - none.\n Operands : none.\n ----------\n1   08/02/90\n                                                      HEL       9/10.\n\n =========================== PFK subcommand ===========================\n Function :\n ----------\n  The PFK subcommand changes PFK definitions for the duration of\n  the HEL session; to change a PFK, a subcommand such as\n  PFK6 RIGHT 1 is entered to change PFK6 to 'RIGHT 1'.\n  By default, the PF keys are defined as the following :\n              PFK1  - HELP    PFK2  -            PFK3  - END\n              PFK4  - END     PFK5  - FIND       PFK6  -\n              PFK7  - UP      PFK8  - DOWN       PFK9  - HEX\n              PFK10 - LEFT    PFK11 - RIGHT      PFK12 -\n Syntax :\n --------\n     PFKNN NEWPFDATA\n\n Aliases  - none.\n Defaults - none.\n Required - NN and NEWPFDATA\n Operands :\n ----------\n  NN        - specifies the PF key to be modified.\n  NEWPFDATA - specifies the new subcommand for this PF key.\n\n =========================== HEX subcommand ===========================\n Function :\n ----------\n  The HEX subcommand specifies the display mode (character or\n  hexadecimal) for HELP data. If HEX is entered without operands,\n  the current HEX mode is switched to the opposite HEX mode.\n Syntax :\n --------\n     HEX  ON / OFF\n Aliases  - none.\n Defaults - opposite mode.\n Required - none.\n Operands :\n ----------\n  ON       - specifies that data should be displayed in hex mode.\n  OFF      - specifies that data should be displayed in character mode.\n1   08/02/90\n                                                      HEL      10/10.\n\n =========================== TSO subcommand ===========================\n Function :\n ----------\n  The TSO subcommand specifies a TSO command to be issued from\n  the HEL processor.\n Syntax :\n --------\n     TSO  COMMAND OPERANDS\n Aliases  - none.\n Defaults - none.\n Required - COMMAND.\n Operands :\n ----------\n  COMMAND  - specifies a TSO command to be executed.\n  OPERANDS - specifies any desired operands for this TSO command.\n\n ========================== LIST subcommand ===========================\n Function :\n ----------\n  The LIST subcommand repositions the screen to the relative line\n  number entered.\n Syntax :\n --------\n     LIST LINENO\n Aliases  - LIST, L\n Defaults - none.\n Required - LINENO\n Operands :\n ----------\n  LINENO    -  specifies the relative line number to which the screen\n               is to be positioned.\n\n =========================== END subcommand ===========================\n Function :\n ----------\n  The END subcommand terminates the HEL command.\n Syntax :\n --------\n     END\n Aliases  - none.\n Defaults - none.\n Required - none.\n Operands : none.\n ----------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HELH": {"ttr": 21253, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x04\\x0f\\x00\\x90\\x04\\x0f\\x14\\x16\\x01I\\x01I\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-02-09T00:00:00", "modifydate": "1990-02-09T14:16:00", "lines": 329, "newlines": 329, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=HEL\n./     NUMBER  NEW1=100,INCR=100\n)S Subcommands :\n  COMMAND, MEMBER, SUBCOM, FIND, UP, DOWN, LEFT, RIGHT,\n  TOP, BOTTOM, CAPS, ASIS, PFK, HEX, TSO, HELP, LIST, END\n)F Function :\n  The HEL command displays a HELP member on a 3270 terminal\n  in full screen mode (80 character wide screens only).\n  In the field labelled MEMBER==> _______, HEL displays the current\n  HELP member; if the cursor is positioned to this field and a command\n  name is entered, HEL will display that new member's HELP data.\n  In the field labelled SUBCOMMAND==> _______, HEL displays the current\n  subcommand of the HELP command; if the cursor is positioned to this\n  field and a name is entered, HEL will display the member's HELP data\n  for the entered subcommand.\n  The field labelled INPUT==> _______ is the primary input field for\n  HEL; any supported subcommand may be entered.\n  In the field labelled RANGE NN, HEL displays the default forward and\n  backward space quantity, if the cursor is positioned to this field\n  and a number is entered, that quantity will become the default\n  forward and backward space quantity.\n)X Syntax :\n         HEL    COMMAND  FUNCTION  SYNTAX\n                OPERANDS(KEYWORD-LIST)  ALL\n  Alias    - HL\n  Required - none.\n  Defaults - ALL if FUNCTION, SYNTAX, and OPERANDS not specified.\n  Note     - if HEL is entered without any OPERANDS a list of\n             available commands with a short description of each will\n             be displayed.\n  Note     - KEYWORD-LIST is optional when OPERANDS is used.\n)O Operands :\n  COMMAND  - name of the command to be explained.\n))FUNCTION - function data is to be displayed.\n))SYNTAX   - syntax data is to be displayed.\n))OPERANDS(KEYWORD-LIST)\n           - operand description is to be displayed. If\n             KEYWORD-LIST is present, positioning is to the first\n             operand in the list encountered.\n  KEYWORD-LIST\n           - keywords separated by commas, blanks, or tabs.\n))ALL      - function, syntax, and operand descriptions are to be\n             displayed.\n))POSITIONAL('OPERAND NUMBER')\n           - a description of the positional operand specified is to\n             be displayed.  This operand is not supported by HEL; if\n             it is present, the IBM HELP command is invoked instead.\n))MSG('MSGID')\n           - a description of the message identified by MSGID is to be\n             displayed.  This operand is not supported by HEL; if it is\n             present, the IBM HELP command is invoked instead.\n))PFK       - this is not an operand, but a description of\n              the program function keys used by this command :\n              PFK1  - HELP    PFK2  -            PFK3  - END\n              PFK4  - END     PFK5  - FIND       PFK6  -\n              PFK7  - UP      PFK8  - DOWN       PFK9  - HEX\n              PFK10 - LEFT    PFK11 - RIGHT      PFK12 -\n              These can be changed using the PFKn subcommand, but\n              the changes are in effect only until the command ends.\n              Example : PFK6 RIGHT 1 would make PFK6 'RIGHT 1'.\n))Subcommands - this is not an operand, but a list of the subcommands\n              that can be entered in the primary input field.\n    UP      - scroll forwards a specified number of records.\n              If no operand is specified, the range value is\n              used. This is displayed in the upper right corner.\n              Alias : -\n    DOWN    - scroll backwards a specified number of records.\n              If no operand is specified, the range value is\n              used. This is displayed in the upper right corner.\n              Alias : +\n    LEFT    - scroll to the left a specified number of columns.\n              If no operand is specified, 40 is used.\n              Alias : <\n    RIGHT   - scroll to the right a specified number of columns.\n              If no operand is specified, 40 is used.\n              Alias : >\n    TOP     - scroll up to the first record.\n    BOTTOM  - scroll down to the last record.\n              Alias : BOT\n    LIST    - display the specified record number.\n              Relative record number only, not sequence numbers.\n              Alias : L\n    HEX ON  - display the screen in hexadecimal.\n    HEX OFF - display the screen in EBCDIC.\n    HEX     - if HEX currently ON, turn it OFF. If OFF, turn it ON.\n    HELP    - displays HELP data.\n              Aliases : HEL, H\n    TSO     - issues the TSO command named and any operands.\n    FIND    - search forward until the specified string is found.\n              String does not have to be in quotes unless it\n              contains one or more imbedded blanks.\n              String may be followed by a column number.\n              If no operand, the string from previous FIND is used.\n              Alias : F\n    CAPS    - display lower case data in upper case.\n    ASIS    - display lower case data in lower case.\n    COMMAND - switch to the specified HELP member.\n              Aliases : MEMBER, COM, MEM\n    SUBCOM  - switch to a different subcommand in the same HELP member.\n              Alias : SUB\n    PFKn    - set program function key n.\n    END     - end the command.\n=HELP=HEL=H\n)F Function :\n  The HELP subcommand provides FUNCTION, SYNTAX, and OPERAND\n  information on the currently processing command and its subcommands.\n)X Syntax :\n         HELP   'SUBCOMMAND NAME'/'CURRENT COMMAND NAME'\n                FUNCTION  SYNTAX  OPERANDS('KEYWORD LIST')  ALL\n  Aliases  - HELP, HEL, H\n  Required - none.\n  Defaults - ALL if FUNCTION, SYNTAX, and OPERANDS not specified.\n  Note     - if HELP is entered without any operands a list of\n             subcommands of the current command will be displayed.\n  Note     - 'KEYWORD LIST' is optional when OPERANDS is used.\n)O Operands :\n  'SUBCOMMAND NAME'\n           - name of the subcommand of the current command to be\n             explained.\n  'CURRENT COMMAND NAME'\n           - entered if the currently processing command is to be\n             explained.\n))FUNCTION - function data is to be displayed.\n))SYNTAX   - format is to be displayed.\n))OPERANDS('KEYWORD LIST')\n           - operand description is to be displayed. If\n             'KEYWORD LIST' is present, only those keyword descriptions\n             are to be displayed.\n    'KEYWORD LIST'\n           - keywords separated by commas, blanks, or tabs.\n))ALL      - FUNCTION, SYNTAX, and OPERAND descriptions are to be\n             displayed.\n))POSITIONAL('OPERAND NUMBER')\n           - a description of the positional operand specified is to\n             be displayed. This operand is not supported by HEL; if\n             it is present, the IBM HELP command is invoked instead.\n))MSG('MSGID')\n           - a description of the message identified by MSGID is to be\n             displayed. This operand is not supported by HEL; if it is\n             present, the IBM HELP command is invoked instead.\n=COMMAND=COM=MEMBER=MEM\n)F Function :\n  The COMMAND or MEMBER subcommand switches to a different HELP\n  member. This member must be present in the SYSHELP data-sets.\n)X Syntax :\n     COMMAND MEMBERNAME\n Aliases  - COMMAND, COM, MEMBER, MEM\n Defaults - same member.\n Required - none.\n)O Operands :\n   MEMBERNAME - specifies the name of a HELP member to be displayed.\n=SUBCOM=SUB\n)F Function :\n  The SUBCOM subcommand switches to a different subcommand\n  description in the same MEMBER or COMMAND.\n)X Syntax :\n     SUBCOM SUBNAME\n Aliases  - SUBCOM, SUB\n Defaults - same subcommand.\n Required - none.\n)O Operands :\n   SUBNAME  - specifies the name subcommand for this MEMBER or COMMAND.\n=FIND=F\n)F Function :\n  The FIND subcommand positions the screen to a text string.\n  FIND notes :\n   1.  only upper case data is searched for.\n   2.  if no operand is entered, the previously used string is used.\n   3.  quotation marks are optional for the string unless it contains\n       blank characters.\n   4.  a second operand may be entered to search a single column;\n       otherwise, all 80 columns are searched.\n)X Syntax :\n     FIND STRING COLUMN\n Aliases  - FIND, F\n Defaults - same string.\n Required - none.\n)O Operands :\n   STRING   - specifies the upper case data to locate.\n   COLUMN   - optional, specifies a column number to search.\n=UP=-\n)F Function :\n  The UP subcommand moves the screen up the specified number of\n  lines; if no operand is entered, the range quantity is used.\n)X Syntax :\n     UP NUMBER\n Aliases  - UP, -\n Defaults - range quantity.\n Required - none.\n)O Operands :\n   NUMBER   - specifies the number of lines to move the screen.\n=DOWN=+\n)F Function :\n  The DOWN subcommand moves the screen down the specified number\n  of lines; if no operand is entered, the range quantity is used.\n)X Syntax :\n     DOWN NUMBER\n Aliases  - DOWN, +\n Defaults - range quantity.\n Requierd - none.\n)O Operands :\n   NUMBER   - specifies the number of lines to move the screen.\n=LEFT=<\n)F Function :\n  The LEFT subcommand moves the screen left the specified number of\n  columns; if no operand is entered, 40 is used.\n)X Syntax :\n     LEFT NUMBER\n Aliases  - LEFT, <\n Defaults - 40.\n Requierd - none.\n)O Operands :\n   NUMBER   - specifies the number of columns to move the screen.\n=RIGHT=>\n)F Function :\n  The RIGHT subcommand moves the screen right the specified number\n  of columns; if no operand is entered, 40 is used.\n)X Syntax :\n     RIGHT NUMBER\n Aliases  - RIGHT, >\n Defaults - 40.\n Required - none.\n)O Operands :\n   NUMBER   - specifies the number of columns to move the screen.\n=TOP\n)F Function :\n  The TOP subcommand moves the screen to the first line of the\n  MEMBER.\n)X Syntax :\n     TOP\n Aliases  - none.\n Defaults - none.\n Required - none.\n)O Operands : none.\n=BOTTOM=BOT\n)F Function :\n  The BOTTOM subcommand moves the screen to the last line of the\n  MEMBER.\n)X Syntax :\n     BOTTOM\n Aliases  - BOTTOM, BOT\n Defaults - none.\n Required - none.\n)O Operands : none.\n=CAPS\n)F Function :\n  The CAPS subcommand displays lower case data as upper case.\n)X Syntax :\n     CAPS\n Aliases  - none.\n Defaults - none.\n Required - none.\n)O Operands : none.\n=ASIS\n)F Function :\n  The ASIS subcommand displays lower case data as lower case.\n)X Syntax :\n     ASIS\n Aliases  - none.\n Defaults - none.\n Required - none.\n)O Operands : none.\n=PFK\n)F Function :\n  The PFK subcommand changes PFK definitions for the duration of\n  the HEL session; to change a PFK, a subcommand such as\n  PFK6 RIGHT 1 is entered to change PFK6 to 'RIGHT 1'.\n  By default, the PF keys are defined as the following :\n              PFK1  - HELP    PFK2  -            PFK3  - END\n              PFK4  - END     PFK5  - FIND       PFK6  -\n              PFK7  - UP      PFK8  - DOWN       PFK9  - HEX\n              PFK10 - LEFT    PFK11 - RIGHT      PFK12 -\n)X Syntax :\n     PFKNN NEWPFDATA\n\n Aliases  - none.\n Defaults - none.\n Required - NN and NEWPFDATA\n)O Operands :\n  NN        - specifies the PF key to be modified.\n  NEWPFDATA - specifies the new subcommand for this PF key.\n=HEX\n)F Function :\n  The HEX subcommand specifies the display mode (character or\n  hexadecimal) for HELP data. If HEX is entered without operands,\n  the current HEX mode is switched to the opposite HEX mode.\n)X Syntax :\n     HEX  ON / OFF\n Aliases  - none.\n Defaults - opposite mode.\n Required - none.\n)O Operands :\n))ON       - specifies that data should be displayed in hex mode.\n))OFF      - specifies that data should be displayed in character mode.\n=TSO\n)F Function :\n  The TSO subcommand specifies a TSO command to be issued from\n  the HEL processor.\n)X Syntax :\n     TSO  COMMAND OPERANDS\n Aliases  - none.\n Defaults - none.\n Required - COMMAND.\n)O Operands :\n  COMMAND  - specifies a TSO command to be executed.\n  OPERANDS - specifies any desired operands for this TSO command.\n=LIST=L\n)F Function :\n  The LIST subcommand repositions the screen to the relative line\n  number entered.\n)X Syntax :\n     LIST LINENO\n Aliases  - LIST, L\n Defaults - none.\n Required - LINENO\n)O Operands :\n  LINENO    -  specifies the relative line number to which the screen\n               is to be positioned.\n=END\n)F Function :\n  The END subcommand terminates the HEL command.\n)X Syntax :\n     END\n Aliases  - none.\n Defaults - none.\n Required - none.\n)O Operands : none.\n./     ALIAS   NAME=HL\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HELMSGS": {"ttr": 21259, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x04\\x0f\\x00\\x90\\x04\\x0f\\x12\\x02\\x00Y\\x00Y\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-02-09T00:00:00", "modifydate": "1990-02-09T12:02:00", "lines": 89, "newlines": 89, "modlines": 0, "user": "SYSPAJA"}, "text": "HLH      TITLE 'H E L -- HELP FOR THE FULL-SCREEN HEL COMMAND.'\nHELMSGS  START 0\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        HELMSGS - HELP DEFINITIONS OF THE 'HEL' TSO COMMAND          *\n*                  FOR DISPLAYING A HELP MEMBER ON A 3270             *\n*                  DISPLAY STATION SCREEN                             *\n*                                                                     *\n*        WRITTEN BY A. BRUCE LELAND AT HITACHI AMERICA, LTD.          *\n*                ON JUNE 18, 1984                                     *\n*                                                                     *\n*        THIS SEPARATE MODULE HAS BEEN CREATED TO ALLOW A MORE        *\n*                EASY USE OF THE UPPER-LOWER CASE CHARACTERS          *\n*                (MOINIL P.A. - FEBRUARY 1, 1990)                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*------- HELP MESSAGES MODULE VECTOR.\n         SPACE 1\n         DC    A(HMSGS)           +0   HELP MESSAGES ADDRESS\n         DC    CL8'(none)'        +4   NONE CONSTANT\n         DC    A(PFKEYS)          +12  PF KEYS LINES START ADDRESS\n         SPACE 1\n*------- HELP MESSAGE LINE 5.\nHMSGS    DC    CL80' HEL ======================== Full-screen HELP commX\n               and ========================'\n*------- HELP MESSAGE LINE 6.\n         DC    CL80' Subcommands short list :                          X\n                                           '\n*------- HELP MESSAGE LINE 7.\n         DC    CL80'  -----------------------------------    ----------X\n               -------------------------     '\n*------- HELP MESSAGE LINE 8.\n         DC    CL80'  COMMAND newname (MEMBER/COM/MEM)       SUBCOM namX\n               e (SUB)                     '\n*------- HELP MESSAGE LINE 9.\n         DC    CL80'  FIND string col (F)                    CAPS/ASIS X\n                                           '\n*------- HELP MESSAGE LINE 10.\n         DC    CL80'  PFK# newsubcom                         HEX ON/OFFX\n                                           '\n*------- HELP MESSAGE LINE 11.\n         DC    CL80'  TSO anycommand                         HELP (HEL/X\n               H)                          '\n*------- HELP MESSAGE LINE 12.\n         DC    CL80'  TOP                                    BOTTOM (BOX\n               T)                          '\n*------- HELP MESSAGE LINE 13.\n         DC    CL80'  UP num (-)                             DOWN num (X\n               +)                          '\n*------- HELP MESSAGE LINE 14.\n         DC    CL80'  LEFT num (<)                           RIGHT num X\n               (>)                         '\n         EJECT\n*------- HELP MESSAGE LINE 15.\n         DC    CL80'  LIST num (L)                           END       X\n                                           '\n*------- HELP MESSAGE LINE 16.\n         DC    CL80'            N O T E : to view the full explanationsX\n                about the HEL command,     '\n*------- HELP MESSAGE LINE 17.\n         DC    CL80'            --------- enter the MEMBER HEL subcommaX\n               nd.                         '\n*------- HELP MESSAGE LINE 18.\n         DC    CL80' =========================== Current PF keys valuesX\n                ==========================='\n*------- HELP MESSAGE LINE 19.\nPFKEYS   DC    CL40'  1 = '\n         DC    CL40'  2 = '\n*------- HELP MESSAGE LINE 20.\n         DC    CL40'  3 = '\n         DC    CL40'  4 = '\n*------- HELP MESSAGE LINE 21.\n         DC    CL40'  5 = '\n         DC    CL40'  6 = '\n*------- HELP MESSAGE LINE 22.\n         DC    CL40'  7 = '\n         DC    CL40'  8 = '\n*------- HELP MESSAGE LINE 23.\n         DC    CL40'  9 = '\n         DC    CL40' 10 = '\n*------- HELP MESSAGE LINE 24.\n         DC    CL40' 11 = '\n         DC    CL40' 12 = '\n         DC    XL7'FFFFFFFFFFFFFF'\n         DC    0D'0'               END OF CSECT\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INCORZA$": {"ttr": 21262, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x942o\\x00\\x942o\\x16'\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-22T00:00:00", "modifydate": "1994-11-22T16:27:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//INCOZAP  JOB (........),'INSTALL - INCORZAP -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=6\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* NOTE : ASSEMBLER H IS MANDATORY.                                  *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ4AS3,OPT=',RENT',MBR=INCORZAP\n//LNK     EXEC PAJILKL,OPT=',MAP,RENT,AC=1'\n//SYSIN     DD *\n  ENTRY   INCORZAP\n  NAME    INCORZAP(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INCORZA@": {"ttr": 21505, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\t\\x7f\\x00\\x88\\t\\x7f\\x151\\x01Z\\x01Z\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-06T00:00:00", "modifydate": "1988-04-06T15:31:00", "lines": 346, "newlines": 346, "modlines": 0, "user": "SYSPAJA"}, "text": "1   06/04/88\n                                                      INCORZAP  1/7.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *           I N C O R Z A P           * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *  MAIN STORAGE SUPERZAP SERVICE AID  * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n CBT origin : Extracted from CBT tape FEB 86, file 421.\n ------------ (file 316 superseded)\n\n INTRODUCTION\n ------------\n\n INCORZAP inspects or modifies main storage in an MVS system, it\n functions on MVS/SP Version 2 (MVS/XA).\n\n INCORZAP offers the following advantages :\n       - Changes to the nucleus and link pack areas can be made\n         dynamically without the need for re-IPLing the system.\n       - Changes can be made at the CSECT level rather than just the\n         load module level.\n       - Changes to the Link Pack Area (LPA) are not lost when pages\n         are reused by the system, as is the case with modifications\n         made from the console.\n       - INCORZAP uses standard Superzap control statement formats,\n         and is therefore compatible with the AMASPZAP IBM Service Aid.\n\n In addition to compatibility with AMASPZAP, INCORZAP offers the\n following additional functions :\n       - Multiple control statements per line using the logical line\n         separator ('/').\n       - The option to supply control statements via a parameter list\n         rather than through a SYSIN data-set.\n       - The option to use program symbols instead of absolute hex\n         numbers to determine offsets within CSECTs.\n       - The option to localize program modifications by loading a\n         private version of a module into the Job Pack Area.\n\n FEATURES\n --------\n\n Main Storage Modification Without IPL.\n\n         INCORZAP is useful for applying fixes on a test basis without\n         IPLing the system. Since INCORZAP changes only main storage,\n         any modifications last only for the length of the IPL or until\n         backed out by a subsequent use of INCORZAP.\n         Without INCORZAP, applying a superzap to the Nucleus or LPA\n         involves zapping the appropriate system library with AMASPZAP,\n         then re-IPLing the system.\n1   13/05/86\n                                                      INCORZAP  2/7.\n\n CSECT Level Reference.\n\n         Once a module is loaded into main storage, CSECT information\n         is generally not available (the MVS/XA nucleus is an\n         exception). For this reason most other mechanisms to modify\n         main storage work with absolute addresses or load modules\n         only.\n         INCORZAP reads the library from which the main storage version\n         of the module was loaded in order to determine CSECT placement\n         information. This is then used by INCORZAP to permit CSECT\n         level references and changes.\n\n Keeping PLPA Modified.\n\n         Since the Pageable Link Pack Area (PLPA) is normally not\n         modified, the paging subsystem never performs a page-out\n         operation on pages in this area. This means that any normal\n         modification would be lost when the page was stolen for\n         re-use by the paging subsystem. When the contents of the page\n         were needed again, the paging subsystem would page-in a new,\n         unmodified page.\n         To overcome this problem, INCORZAP performs a page-fix\n         operation on any pages it modifies in the link pack areas.\n         This prevents the page being stolen by the paging subsystem,\n         and thus the modification remains.\n         If an installation wishes to back-out a modification made by\n         INCORZAP, this can be done with the RES statement which will\n         first make the reversing modification, then perform a page-free\n         operation to make the real page frame once more available to\n         the system.\n\n Overcoming Protection Schemes.\n\n         In order to make modifications to main storage, INCORZAP\n         must be installed as an authorized program in an authorized\n         library. INCORZAP uses this authorization to modify the\n         Nucleus and Link Pack Area as requested even though these\n         areas are in key-zero protected storage.\n         In MVS/SP systems, INCORZAP also temporarily bypasses segment\n         or page protection to allow modification of the Link Pack\n         Areas. Because of the authorized nature of this program,\n         special security provisions should be taken to control use of\n         this module. See the section \"Security Considerations\" later\n         in this document.\n         INCORZAP does not bypass the low storage protect feature of\n         MVS/SP, it does not modify the first 512 bytes of the Nucleus\n         (PSA). Modifications to critical low-storage areas should be\n         controlled  from the console.\n\n Using Job Pack Versions of Modules.\n\n         INCORZAP has the ability via the LOCAL control statement to\n         cause a module specified on a NAME control statement to be\n         loaded into the Job Pack Area. Modifications can then be made\n         to this localized version of the module.\n1   13/05/86\n                                                      INCORZAP  3/7.\n\n         Care must be taken, however, with this approach. The LOCAL\n         control statement would normally be used when calling INCORZAP\n         via a LINK rather than executing the program from JCL, where\n         the module would come and go with the INCORZAP program itself.\n         It should also be remembered that some system services (such\n         as OPEN/CLOSE) do not search the Job Pack Area for a copy of\n         a module they are loading, but go instead directly to the\n         Link Pack Area.\n\n Superzap Compatibility.\n\n         INCORZAP is generally compatible with the IBM Service Aid,\n         AMASPZAP. The purposes of the program differ, however.\n         INCORZAP inspects or modifies main storage, while AMASPZAP\n         inspects or modifies modules or data on direct access storage.\n         Nevertheless, JCL requirements and control statement syntax\n         are for the most part compatible. This means that in general,\n         fixes designed for application via AMASPZAP can be applied\n         to the Nucleus or Link Pack Area version of a CSECT by simply\n         changing the program name on the execute card in the JCL.\n\n         Specific differences between the two programs are :\n         - CCHHR and ABSDUMP control statements - not applicable to\n           INCORZAP.\n         - SETSSI and IDRDATA control statements - not applicable and\n           ignored by INCORZAP.\n         - CHECKSUM control statement - not supported by INCORZAP.\n         - Alternate DD names - are specified differently.\n         - Dump formats - are different. INCORZAP always includes\n           EBCDIC data in the right hand portion of the dump.\n           INCORZAP treats DUMP and DUMPT identically, providing\n           EBCDIC data for both and not attempting to provide op codes.\n         - Input via parameter list - not supported by AMASPZAP.\n         - \"/\" logical line separator - not supported by AMASPZAP.\n         - Symbolic offsets permitting use of program symbols in\n           VER and REP statements - not supported by AMASPZAP.\n         - LOCAL and GLOBAL control statements - are not applicable\n           to AMASPZAP.\n         - RES control statement - not applicable to AMASPZAP.\n         - RC control statement - not supported by AMASPZAP.\n\n         With the above exceptions, AMASPZAP and INCORZAP are\n         compatible. If the reader is unfamiliar with Superzap JCL\n         and control statements, he should consult the IBM manual\n         GC28-0674 OS/VS2 MVS System Programming Library : Service\n         Aids for details on the use of the programs.\n1   13/05/86\n                                                      INCORZAP  4/7.\n\n REFERENCE SUMMARY\n -----------------\n\n         The following provides a one-page summary of the operation of\n         INCORZAP. Additional information concerning Superzap control\n         statements can be found in the IBM manual GC28-0674 OS/VS2 MVS\n         System Programming Library : Service Aids.\n\n JCL Requirements.\n\n         //stepname EXEC PGM=INCORZAP,\n                         PARM='control statements' (optional).\n         //SYSLIB     DD DSN=...     Program Library from which the\n                                     in-core module was loaded\n                                     (required).\n         //SYSPRINT   DD SYSOUT=...  Printed output (optional).\n         //SYSIN      DD *           Control statements (required\n                                     unless PARM specified).\n\n Control Statements.\n\n         NAME loadmod csect          Specify module and or CSECT to\n                                     modify.\n         VER  offset  hexstring      Verify storage at offset within\n                                     module/CSECT matches hexstring.\n         REP  offset  hexstring      Change storage at offset within\n                                     module/CSECT to match hexstring\n                                     (Causes PGFIX if pageable).\n         RES  offset  hexstring      Like REP, but causes PGFREE.\n         DUMP loadmod csect          Print module or CSECT.\n         CONsole                     Read control statements from\n                                     console.\n         BASE hexvalue               Hexvalue will be subtracted\n                                     from numeric offsets.\n         RESET                       Clears NO-GO switch (set by VER\n                                     failure).\n         /                           Logical line separator.\n         ZAP offset hexstring        Zeroes storage if equal to\n                                     hexstring.\n         *                           Comment.\n         LOCAL                       Following NAME statements will\n                                     load modules into Job Pack Area.\n         GLOBAL                      Drop LOCAL mode.\n1   13/05/86\n                                                      INCORZAP  5/7.\n\n NOTES\n -----\n\n Alternate DD Names.\n\n         The following DD names are really the first choice of\n         INCORZAP : PROGLIB, PROGLIST, PROGIN.\n         These names are therefore reserved names and are unavailable\n         for use on any other DD's in the step (for example, if\n         INCORZAP were invoked via a call under TSO).\n         If one of these names is not present, the more traditional\n         name (SYSLIB, SYSPRINT, or SYSIN, respectively) is used.\n\n Offset specification.\n\n         Where \"offset\" is specified, this may be either a hex string\n         (with an even number of hex digits) or a program symbol in\n         single quotes (apostrophes). Entry point names may always be\n         used as symbolic offsets. Any symbol in a non-nucleus CSECT\n         may be used if the CSECT was compiled and linked with the TEST\n         attribute.\n\n OPERATIONAL CONSIDERATIONS\n --------------------------\n\n Avoiding Mismatched Modules.\n\n         INCORZAP may appear to operate incorrectly if the load module\n         copy on DASD does not match the copy in main storage.\n         INCORZAP reads the DASD copy to determine CSECT placement\n         within the load module, so the copies must match for correct\n         operation.\n         A mismatch could occur if :\n         - The module on DASD was re-linked since the last IPL.\n         - The module was loaded from a different library than the one\n           specified to INCORZAP (eg. an MLPA from SYS1.LINKLIB while\n           INCORZAP's SYSLIB points at SYS1.LPALIB).\n\n Security Considerations.\n\n         Because of its ability to change system modules, access to\n         INCORZAP must be strictly limited.\n         It should be placed in a library with both read and write\n         access restricted via a password or other security mechanism.\n         INCORZAP does open its SYSLIB file in update mode even though\n         it only accesses it on a read-only basis. However, since it is\n         main storage and not the library which is being modified,\n         protecting critical libraries against write access is not\n         sufficient protection with INCORZAP. A load module could be\n         copied to an unprotected library, where INCORZAP would be able\n         to open and process it, thereby allowing the main storage\n         alteration.\n         Authority : restricted to systems support personnel.\n1   13/05/86\n                                                      INCORZAP  6/7.\n\n EXAMPLES\n --------\n\n Example 1 - Zapping an LPA module :\n              //ZAP1    EXEC PGM=INCORZAP\n              //SYSLIB    DD DSN=SYS1.LPALIB,DISP=SHR\n              //SYSPRINT  DD SYSOUT=A\n              //SYSIN DD *\n               NAME IGC0010A IEDAY00\n               VER 03 C1E8\n               REP 03 81A8\n              /*\n\n Example 2 - Backing out a zap and unfixing the main storage :\n              //ZAP2    EXEC PGM=INCORZAP\n              //SYSLIB    DD DSN=SYS1.LPALIB,DISP=SHR\n              //SYSPRINT  DD SYSOUT=A\n              //SYSIN     DD *\n               NAME IGC0010A IEDAY00\n               VER 03 81A8\n               RES 03 C1E8\n              /*\n\n Example 3 - Using entry points as symbolic offsets :\n              //ZAP3    EXEC PGM=INCORZAP\n              //SYSLIB    DD DSN=SYS1.LPALIB,DISP=SHR\n              //SYSPRINT  DD SYSOUT=A\n              //SYSIN     DD *\n               NAME IGC0010A IEDAY00\n               VER 'QTIP0130' C5C0\n               REP 'QTIP0130' 00\n               NAME IGG0CLA1 IGG0CLA9\n               VER 'IGGPCMRR' 05C0\n               REP 'IGGPCMRR' 07FE\n              /*\n\n Example 4 - Dumping an in-core CSECT :\n              //ZAP4    EXEC PGM=INCORZAP\n              //SYSLIB    DD DSN=SYS1.NUCLEUS,DISP=SHR\n              //SYSPRINT  DD SYSOUT=A\n              //SYSIN DD *\n               DUMP IEANUC01 IGC018\n              /*\n\n Example 5 - Supplying input via the PARM field :\n              //ZAP5    EXEC PGM=INCORZAP,\n              //  PARM='NAME IEANUC01 IEAVFX00/VER 1023 F8/REP 1023 FF'\n              //SYSLIB    DD DSN=SYS1.NUCLEUS,DISP=SHR\n              //SYSPRINT  DD SYSOUT=A\n                   (Note use of / as a logical line separator. This can\n                   be used in SYSIN input and console replies as well)\n1   13/05/86\n                                                      INCORZAP  7/7.\n\n Example 6 - INCORZAP procedure for console zapping :\n              //IZAP     PROC LIB=LPALIB\n              //IZAP     EXEC PGM=INCORZAP,PARM=CONSOLE\n              //SYSLIB     DD DSN=SYS1.&LIB,DISP=SHR\n              //SYSPRINT   DD SYSOUT=A\n\n (The following examples use the console mode of operation)\n\n Example 7 - Finding the address of a load module :\n              *03 ENTER ZAP STATEMENTS, RC OR END\n               r 3, 'name igc0010a'\n               IEE600I REPLY TO 03 IS: SUPPRESSED\n               +00E44000 = IN-CORE ADDRESS OF PRECEDING SYMBOL\n\n Example 8 - Finding the address of a CSECT in the LINK PACK AREA :\n              *04 ENTER ZAP STATEMENTS, RC OR END\n               r 4,name igc0010a ieday00\n               IEE600I REPLY TO 04 IS: SUPPRESSED\n               +00E452B8 = IN-CORE ADDRESS OF PRECEDING SYMBOL\n\n Example 9 - Finding the address of an entry point :\n              *05 ENTER ZAP STATEMENTS, RC OR END\n               r 5,ver 'qtip0130' 00\n               IEE600I REPLY TO 05 IS: SUPPRESSED\n               +00E455EE = IN-CORE ADDRESS OF PRECEDING SYMBOL\n               +VERIFY REJECT - SET NO GO SWITCH\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INCORZAP": {"ttr": 21511, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91#O\\x00\\x91#O\\x15C\\t\\x06\\t\\x06\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-22T00:00:00", "modifydate": "1991-08-22T15:43:00", "lines": 2310, "newlines": 2310, "modlines": 0, "user": "SYSPAJA"}, "text": "INZP     TITLE '-- I N C O R Z A P -- MAIN STORAGE SUPERZAP FOR MVS.'\nINCORZAP START 0\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        I N C O R Z A P   PROGRAM.                                   *\n*                                                                     *\n*        MAIN STORAGE SUPERZAP PROGRAM FOR MVS/XA.                -EU-*\n*                                                                     *\n* --->>> NOTE : ASSEMBLER H IS MANDATORY.                         -EU-*\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*     -- MODULE HISTORY :\n*\n*        1974 - ORIGINAL WRITTEN BY R. BUDGE, IBM CORP.\n*        IN PL/S LANGUAGE.\n*\n*        1979-81 - ASSEMBLER SOURCE GENERATED AND COMMENTED BY\n*        BILL GODFREY, PRC (PLANNING RESEARCH CORPORATION), MCLEAN VA,\n*        ALSO MADE PARM FIELD INPUT INDEPENDENT OF ENTRY POINT NAME.\n*\n*        1983 - XA AND SP1.3 CHANGES ADDED, ALONG WITH ADDITIONAL\n*        COMMENTS BY R. BUDGE, NAS CORP.\n*\n*        1986 - LOCAL MODIFICATIONS BY MOINIL P.A.,                -EU-\n*                  COMPUTING CENTRE,                               -EU-\n*                  J.R.C. - ISPRA ESTABLISHMENT,                   -EU-\n*                  21020 ISPRA (VA), ITALY.                        -EU-\n*               - ONLY SYSTEM SUPPORT PERSONNEL ALLOWED.           -EU-\n*               - CONSOLE ACCEPTED IF STARTED SYSTEM TASK ONLY.    -EU-\n*         1988 - MVS/XA ONLY (NEW VERSION, CBT FILE 421).          -EU-\n         EJECT\n*     -- BRIEF DOCUMENTATION :\n*\n*        THIS PROGRAM MODIFIES LOAD MODULES IN THE NUCLEUS OR IN\n*        THE LINK PACK AREA. MODIFIED PAGES IN LPA WILL BE FIXED\n*        TO PREVENT PAGE-INS THAT WOULD UN-MODIFY THE MODIFIED PAGE.\n*        CONTROL STATEMENT INPUT IS COMPATIBLE WITH THE 'AMASPZAP'\n*        SERVICE AID PROGRAM, EXCEPT THE PRESENCE OF A SLASH ('/')\n*        ANYWHERE IN A CARD IS USED AS AN INDICATION OF MULTIPLE\n*        STATEMENTS PER CARD.\n*        A 'RES' IS LIKE A 'REP' EXCEPT IT FREES A FIXED LPA PAGE.\n*\n*        DDNAMES USED :\n*             SYSPRINT - MESSAGE AND DUMP OUTPUT.\n*             SYSLIB   - SYS1.LPALIB FOR LPA ZAPS,\n*                        SYS1.NUCLEUS FOR NUCLEUS ZAPS.\n*                        OPENED FOR UPDATE, BUT NOT ACTUALLY UPDATED.\n*             SYSIN    - CONTROL STATEMENT INPUT.\n*\n*             IF DDNAMES PROGLIST, PROGLIB, AND PROGIN ARE PRESENT,\n*             THEY WILL BE USED INSTEAD OF THE OTHERS.\n*\n*        CONTROL STATEMENTS MAY OPTIONALLY BE SPECIFIED IN THE PARM\n*        FIELD INSTEAD OF SYSIN.\n*\n*        'VER' 'REP' AND 'RES' COMMANDS MAY USE PROGRAM LABELS\n*        INSTEAD OF HEX OFFSETS IF DESIRED. ANY ENTRY POINT MAY BE\n*        USED AS A LABEL. OTHER LABELS CAN BE USED ONLY IF PROGRAM\n*        IS COMPILED AND LINKED WITH THE 'TEST' ATTRIBUTE (DOES NOT\n*        APPLY NUCLEUS MODULES IN MVS/XA).\n*        TELL INCORZAP YOU ARE USING A LABEL INSTEAD OF A HEX OFFSET\n*        BY ENCLOSING IT IN SINGLE QUOTES.\n*\n*        THE PROGRAM MUST BE LINK-EDITED AS AUTHORIZED IN ORDER TO\n*        MODIFY STORAGE, BUT OTHER FUNCTIONS WILL WORK EVEN IF IT\n*        IS NOT AUTHORIZED.\n         EJECT                                                     -EU-\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *  -EU-\n*        AUTHORITY LEVELS DEFINITIONS.                          *  -EU-\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *  -EU-\n         SPACE 1                                                   -EU-\nLV0      EQU   0         REJECT LEVEL.                             -EU-\n         SPACE 1                                                   -EU-\n        $MDL@IX ,        MODULE INDEX.                             -EU-\n         SPACE 2                                                   -EU-\n*        - REGISTERS EQUATES -\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5                   DATA BASE REG NO. 1             -EU-\nR6       EQU   6                   DATA BASE REG NO. 2             -EU-\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10                  PROG BASE REG NO. 2             -EU-\nR11      EQU   11\nR12      EQU   12                  PROG BASE REG NO. 1\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\nINCORZAP AMODE 24\nINCORZAP RMODE 24\n         SPACE 1\n         USING *,R15                                               -EU-\n         B     START                                               -EU-\n         DROP  R15                                                 -EU-\n         DC    AL1(L'IDNT)                                         -EU-\nIDNT     DC    C'INCORZAP  &SYSDATE '                              -EU-\nSTART    STM   R14,R12,12(R13)\n         BASR  R12,0               1ST BASE REGISTER\n         USING *,R12\n         USING *+4095,R10                                          -EU-\n         LA    R10,4095(,R12)      2ND BASE REGISTER               -EU-\n         LA    R12,0(,R12)         CLEAR STUFF FOR 31-BIT\n         L     R0,SIZE\n         GETMAIN R,LV=(0)\n         LR    R5,R1               1ST WORK-AREA BASE              -EU-\n         USING @DATA,R5                                            -EU-\n         LA    R6,4095(,R5)        2ND WORK-AREA BASE              -EU-\n         USING @DATA+4095,R6                                       -EU-\n         ST    R13,4(,R5)          PUT OLD ADDRESS IN NEW SAVE AREA-EU-\n         LM    R0,R1,20(R13)       RESTORE R0 AND R1\n         ST    R5,8(,R13)          PUT NEW ADDRESS IN OLD SAVE AREA-EU-\n         LR    R13,R5              SWITCH TO NEW SAVEAREA          -EU-\n         MVC   @PARMPTR,0(R1)      SAVE ADDRESS OF PARM FIELD\n         BAS   R14,INIT            INITIALIZE\n         B     DOTEST01\n         EJECT\n*        MAINLINE ROUTINE\n*\n*              DO WHILE XFEOD=0\n*                 CALL GETREC\n*                 IF XFEOD=0 THEN\n*                    CALL PRINTREC\n*                    CALL VERBSCN\n*                    END\n*                 END\n*              CLOSE FILES\n*              RETURN\n         SPACE 1\nDOLOOP01 BAS   R14,GETREC          GET A LOGICAL RECORD\n         TM    XFLAGS,XFEOD\n         BO    DOTEST01\n         MVI   @LINE+2,C' '\n         MVC   @LINE+3(118),@LINE+2\n         L     R14,XFLDSTRT        POINT TO DATA TO BE MOVED\n         L     R11,XENDREC         GET ADDRESS OF END OF DATA\n         SLR   R11,R14             COMPUTE LENGTH\n         EX    R11,LOGMVC          MOVE R14 TO @LINE01\n         OI    @SWB,XFNOWTO        FOR PRINT BUT NOT FOR XFCON\n         BAS   R14,PUTLINE         LOG THE STATEMENT\n         NI    @SWB,255-XFNOWTO\n         BAS   R14,VERBSCN\nDOTEST01 TM    XFLAGS,XFEOD\n         BZ    DOLOOP01\n         MVC   XDCBCLS(12),CLOSE\n         CLOSE (XDCBL,,XDCBIN,,XDCBO),MF=(E,XDCBCLS)   CLOSE       -EU-\n         L     R11,XCODE           SAVE RC ACROSS FREEMAIN\n         L     R13,4(,R13)         SWITCH TO OLD SAVEAREA\n         L     R0,SIZE             LENGTH FOR FREEMAIN\n         LR    R1,R5               ADDRESS FOR FREEMAIN            -EU-\n         FREEMAIN R,LV=(0),A=(1)\n         LR    R15,R11             RETURN CODE\n         L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14                 EXIT PROGRAM\n         EJECT\n*        ROUTINE TO DUMP MAIN STORAGE\n*\n*        INPUT : XCSADDR=ADDRESS OF CSECT TO BE DUMPED\n*                XCSLEN = LENGTH TO DUMP\n         SPACE 1\nDUMP     STM   R14,R12,@SAVE13\n         L     R14,XCSLEN          IS\n         LA    R14,0(,R14)          AN\n         LTR   R14,R14               ENDING ADDRESS SPECIFIED?\n         BNZ   *+L'*+6             YES, BRANCH\n         MVC   XCSLEN+1(3),ONE+1\n         L     R14,=F'-32'         FFFFFFE0\n         L     R11,XCSADDR         GET STARTING ADDRESS\n         L     R7,XCSLEN           GET LENGTH\n         LA    R7,0(,R7)\n         ALR   R7,R11              ADD TO START ADDRESS\n         BCTR  R7,0\n         NR    R7,R14              ROUND DOWN TO MULTIPLE OF 32\n         ST    R7,XDUMPEND         SAVE DUMP END ADDRESS\n         OI    @SWB,XFNOWTO        DON'T DUMP TO CONSOLE\n         MVI   @LINE02,C' '\n         MVC   @LINE03(118),@LINE02\n         MVI   @LINE01,C' '\n         MVC   XHEXL,=F'4'\n         NR    R11,R14             ROUND DOWN TO MULTIPLE OF 32\n         ST    R11,XDP             DUMP START ADDRESS\n         B     DUMPGO\nDUMPLP   LA    R14,@LINE01\n         ST    R14,XEBAD\n         LA    R14,XDP\n         ST    R14,XHEX\n         BAS   R14,HEXCV           PUT HEX ADDRESS IN LINE\n         L     R14,XDP\n         ST    R14,XHEX\n         LA    R14,1\n         ST    R14,I               SET SUBSCRIPT TO 1\nDUMPLLP  MH    R14,=H'9'           ADD SUBSCRIPT*9\n         LA    R14,@LINE03(14)      TO LINE+3\n         ST    R14,XEBAD           SAVE RESULT IN HEX TO ADDRESS\n         BAS   R14,HEXCV           PERFORM HEX CONVERSION\n         L     R14,XHEX            ADD\n         AL    R14,XHEXL            HEXLEN\n         ST    R14,XHEX              TO HEXFR\n         LA    R14,1               ADD 1\n         AL    R14,I                TO\n         ST    R14,I                 SUBSCRIPT\n         C     R14,=F'4'           IS SUBSCRIPT GT 4?\n         BNH   DUMPLLP             NO, LOOP (LEFT HALF OF PAGE)\n         LA    R14,1               YES,\n         ST    R14,I                RESET SUBSCRIPT TO 1\nDUMPRLP  MH    R14,=H'9'\n         LA    R14,@LINE41(14)\n         ST    R14,XEBAD\n         BAS   R14,HEXCV\n         L     R14,XHEX\n         AL    R14,XHEXL\n         ST    R14,XHEX\n         LA    R14,1\n         AL    R14,I\n         ST    R14,I\n         C     R14,=F'4'           IS SUBSCRIPT GT 4?\n         BNH   DUMPRLP             NO, LOOP (RIGHT HALF OF PAGE)\n         MVI   @LINE87,C'*'\n         MVI   @LIN120,C'*'\n         BAS   R14,MODESET1        GET INTO KEY 0\n         BAS   R14,BIT31           GET INTO 31-BIT MODE\n         L     R14,XDP\n         MVC   @LINE88(32),0(R14)  MOVE IN CHAR PORTION\n         BAS   R14,BIT24           GET BACK TO 24-BIT MODE\n         BAS   R14,MODESET2        GET BACK TO USER KEY\n         L     R14,=A(EBCDIC)\n         TR    @LINE88(32),0(R14)                                  -EU-\n         BAS   R14,PUTLINE\n         LA    R11,32              ADD 32\n         AL    R11,XDP              TO\n         ST    R11,XDP               DUMP ADDRESS\nDUMPGO   C     R11,XDUMPEND\n         BNH   DUMPLP\n         NI    @SWB,255-XFNOWTO\n         LM    R14,R12,@SAVE13\n         BR    R14\n         EJECT\n*        FIND MODULE ON PROGRAM LIBRARY\n         SPACE 1\nFIND     STM   R14,R12,@SAVE14\n         FIND  XDCBL,XEBLM,D       FIND                            -EU-\n         LTR   R15,R15             WAS MEMBER FOUND?\n         BZ    FINDOK              YES, BRANCH\n         LA    R14,MSG08           MEMBER NOT FOUND IN LIBRARY\n         ST    R14,XMSE\n         BAS   R14,GENERR\nFINDOK   LM    R14,R12,@SAVE14\n         BR    R14\n         EJECT\n*        PGFIX/FREE ROUTINE\n*\n*        INPUT : XZADDR = ADDR OF STORAGE TO BE CHANGED\n*                XHL = LENGTH OF STORAGE\n*                XEBV = VERB\n         SPACE 1\nFIXER    STM   R14,R12,@SAVE16\n         TM    XFLAGS,XFLOCSW\n         BO    PAGEX\n         CLC   XEBLM(6),=CL6'IEANUC'    IS THIS A NUCLEUS ZAP?\n         BE    PAGEX               YES, NO NEED TO FIX/FREE\n         BAS   R14,MODESET1        SUP STATE, KEY ZERO\n         AL    R13,=F'12'          CHANGE R13 FOR SETLOCK\n         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=SAVE,RELATED=X\n         SLR   R4,R4               NO TCB - PGFIX NOT TO BE OWNED\n         ST    R4,XPECB            CLEAR THE ECB\n         LA    R0,XPECB            ECB ADDRESS\n         L     R14,XZADDR          GET STARTING ADDRESS\n         LR    R1,R14              STARTING ADDRESS\n         AL    R14,XHL             COMPUTE ENDING ADDRESS\n         LR    R2,R14              ENDING ADDRESS+1\n         BCTR  R14,0               ENDING ADDRESS\n         CLC   XEBV(3),=CL8'RESET' IS THIS A RES?                  -EU-\n         BE    FREEPAGE            YES, FREE THE PAGE              -EU-\nFIXPAGE  PGSER R,FIX,A=(1),EA=(R14),TCB=0,ECB=(0),LONG=Y,BRANCH=Y,     1\n               RELATED=FREEPAGE                                    -EU-\n         B     SVPSRC                                              -EU-\nFREEPAGE PGSER R,FREE,A=(1),EA=(R14),TCB=0,BRANCH=Y,RELATED=FIXPAGE\nSVPSRC   ST    R15,XPSRC           SAVE RETURN CODE\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=SAVE,RELATED=X\n         SL    R13,=F'12'          PUT R13 BACK TO NORMAL\n         BAS   R14,MODESET2        PROBLEM STATE, KEY NZERO\n         CLC   XPSRC,=F'8'         DID PAGE SERVICES RETURN AN 8?\n         BNE   PAGEX               NO, NO NEED TO WAIT\n         WAIT  ECB=XPECB\nPAGEX    LM    R14,R12,@SAVE16\n         BR    R14\n         EJECT\n*        GENERAL ERROR ROUTINE\n*\n*        INPUT : XMSE = ADDR OF MESSAGE LIST\n         SPACE 1\nGENERR   STM   R14,R12,@SAVE15\n         MVI   @LINE02,C' '\n         MVC   @LINE03(118),@LINE02\n         L     R14,XMSE            GET ADDRESS OF MESSAGE\n         XR    R11,R11                                             -EU-\n         IC    R11,0(,R14)         GET LENGTH OF MESSAGE           -EU-\n         EX    R11,PUTMSGM         MOVE R14+4 TO @LINE01\n         BAS   R14,PUTLINE         WRITE THE MESSAGE\n         MVC   XCODE,=F'12'        SET RETURN CODE\n         OI    XFLAGS,XFEOD        XFEOD\n         LM    R14,R12,@SAVE15\n         BR    R14\n         EJECT\n*        FIELD FETCHING ROUTINE\n*\n*        INPUT : XRCVADDR = ADDR OF RECEIVING FIELD\n*                XRCVLEN = LENGTH OF RECEIVING FIELD\n*        OUTPUT : XFLDALEN = ACTUAL LENGTH OF FETCHED FIELD\n*                 (BLANKS ARE RETURNED IF NO FIELD IS FOUND)\n         SPACE 1\nGETFLD   STM   R14,R12,@SAVE19\n         L     R14,XFLDSTRT\n         ST    R14,XFLDCUR         SET CURRENT = STARTING\n         SLR   R14,R14             SET\n         ST    R14,XSCANSW         SW = 0\n*                                  SCAN PAST LEADING DELIMITERS\n         B     PARGO1              DO UNTIL SW NE 0\nPARLP1   CLC   XFLDCUR,XENDREC     STILL WITHIN STATEMENT?\n         BNH   PARIN1              YES, BRANCH\n*                                  IS BEYOND END OF STMT\n         LA    R14,1               SET\n         ST    R14,XSCANSW         SW = 1\n         B     PARGO1\nPARIN1   L     R14,XFLDCUR\n         CLI   0(R14),C' '         BLANK?\n         BE    PARNX1\n         CLI   0(R14),C''''        QUOTE?\n         BNE   PARFN1\nPARNX1   LA    R14,1               QUOTE OR BLANK\n         AL    R14,XFLDCUR         POINT TO\n         ST    R14,XFLDCUR          NEXT CHARACTER\n         B     PARGO1\n*                                  NEITHER QUOTE NOR BLANK\n*                                  SET TO EXIT LOOP\nPARFN1   LA    R14,1               SET\n         ST    R14,XSCANSW          SW = 1\nPARGO1   SLR   R14,R14\n         C     R14,XSCANSW\n         BE    PARLP1              END OF DO LOOP (SKIPPING LEADING\n*                                  DELIMITERS)\n*                                  SCAN FOR END OF FIELD\n         L     R11,XFLDCUR         GET TRUE START OF FIELD\n         ST    R11,XFLDSTRT\n         ST    R14,XSCANSW         SET SW = 0\n         B     PARGO2              DO UNTIL SW NE 0\nPARLP2   CLC   XFLDCUR,XENDREC     STILL WITHIN STATEMENT?\n         BNH   PARIN2              YES, BRANCH\n         LA    R14,1               SET\n         ST    R14,XSCANSW          SW = 1\n         B     PARGO2\nPARIN2   LA    R14,1               POINT XFLDCUR TO\n         AL    R14,XFLDCUR          NEXT\n         ST    R14,XFLDCUR           CHARACTER\n         CLI   0(R14),C' '         BLANK?\n         BE    PARFN2\n         CLI   0(R14),C''''        QUOTE?\n         BNE   PARGO2\nPARFN2   LA    R14,1               SET\n         ST    R14,XSCANSW          SW = 1\nPARGO2   L     R14,XSCANSW\n         LTR   R14,R14\n         BZ    PARLP2              END OF DO LOOP (FOUND END)\n*                                  CALCULATE LENGTH AND CHECK\n*                                   FOR A TOO LONG FIELD\n         L     R14,XFLDCUR         GET ADDRESS OF BLANK OR QUOTE\n         SL    R14,XFLDSTRT        COMPUTE LENGTH\n         ST    R14,XFLDALEN        SAVE LENGTH\n         C     R14,XRCVLEN         WILL IT FIT IN RESULT?\n         BNH   PAROKL              YES, BRANCH\n         LA    R14,MSG01           FIELD IS TOO LONG\n         ST    R14,XMSE\n         BAS   R14,SYNERR          SYNTAX ERROR\n         B     PARMOV              GO TRUNCATE MOVE\n*                                  MOVE IN FETCHED FIELD (IF ANY)\nPAROKL   L     R14,XRCVADDR        GET ADDRESS OF GETFLD RESULT\n         L     R11,XRCVLEN\n         BCTR  R11,0\n         EX    R11,PARBLNK         MOVE BLANKS TO GETFLD RESULT\nPARMOV   L     R14,XFLDALEN        IF LENGTH\n         LTR   R14,R14              GREATER THAN\n         BZ    PARNUL                ZERO\n         L     R11,XRCVADDR        GET ADDRESS OF GETFLD RESULT\n         BCTR  R14,0\n         L     R7,XFLDSTRT\n         EX    R14,PARMVC          MOVE R7 TO R11\nPARNUL   L     R14,XFLDCUR         GET ADDR OF TRAILING DELIMITER\n         ST    R14,XFLDSTRT        READY FOR NEXT CALL\n         CLI   0(R14),C''''        QUOTE?\n         BNE   PARX                BRANCH IF NOT QUOTED\n         AL    R14,ONE             POINT BEYOND QUOTE\n         ST    R14,XFLDSTRT\nPARX     LM    R14,R12,@SAVE19\n         BR    R14                 RETURN\n         EJECT\n*        HEXADECIMAL FIELD FETCHING ROUTINE\n*\n*        INPUT : XFLDSTRT = ADDR OF START OF FIELD\n*        OUTPUT : XHS = HEX STRING\n*                 XHSL = LENGTH OF HEX STRING\n         SPACE 1\nGETHEX   STM   R14,R12,@SAVE21\n         SLR   R14,R14\n         ST    R14,XHSW            SET SW = 0\n         ST    R14,XHL             SET LEN = 0\n         L     R14,XFLDSTRT\n         ST    R14,XHP\n*                                  MOVE FIELD TO 'XHW' AND\n*                                   STRIP OUT COMMAS\n         B     HPAGO1              DO UNTIL XHSW NE 0\nHPALP1   CLC   XHP,XENDREC         STILL WITHIN STATEMENT?\n         BNH   HPAIN1              YES, BRANCH\n         MVC   XHSW,ONE\n         B     HPAGO1\nHPAIN1   L     R14,XHP\n         CLI   0(R14),C' '         IS IT A BLANK?\n         BNE   HPANBK              NO, BRANCH\n         L     R14,XHL\n         LTR   R14,R14\n         BNP   *+L'*+10\n         MVC   XHSW,ONE\n         B     HPAGO1\n         LA    R14,1\n         AL    R14,XHP\n         ST    R14,XHP\n         B     HPAGO1\nHPANBK   L     R14,XHP             NOT A BLANK\n         CLI   0(R14),C','         IS IT A COMMA?\n         BE    HPAINCR             YES, GO IGNORE IT\n         LA    R11,1               ADD 1\n         AL    R11,XHL              TO\n         ST    R11,XHL               MODLEN\n         LA    R7,XHW-1(R11)\n         MVC   0(1,R7),0(R14)      COPY THE CHARACTER TO WORK AREA\nHPAINCR  LA    R14,1               POINT\n         AL    R14,XHP              TO\n         ST    R14,XHP               NEXT CHARACTER\nHPAGO1   SLR   R14,R14\n         C     R14,XHSW\n         BE    HPALP1\n         L     R11,XHP             CHECK FOR MISSING FIELD\n         ST    R11,XFLDSTRT\n         C     R14,XHL             IS LENGTH ZERO?\n         BNE   HPAOK1              NO, BRANCH\n         LA    R14,MSG11           REQUIRED FIELD MISSING\n         ST    R14,XMSE\n         BAS   R14,SYNERR          SYNTAX\n         B     HPAX\nHPAOK1   SLR   R2,R2               CHECK FOR INVALID (NON-HEX) CHARS\n         L     R1,XHL\n         BCTR  R1,0\n         L     R14,=A(HEXTRT)                                      -EU-\n         EX    R1,HPRTRT           TRT WORK AREA\n         LTR   R2,R2               ARE ALL CHARACTERS HEX?\n         BZ    HPAOK2              YES, BRANCH\n         LA    R14,MSG03           INVALID HEX CHARACTER\n         ST    R14,XMSE\n         BAS   R14,SYNERR          SYNTAX\n         B     HPAX\nHPAOK2   L     R14,=A(HEXTR)       TRANSLATE FROM EBCDIC TO HEX    -EU-\n         TR    XHW,0(R14)          TRANSLATE TO 'UNPACKED' HEX     -EU-\n         LA    R14,XHS\n         ST    R14,XHSPTR\n         LA    R14,XHW             SET\n         ST    R14,XHWPTR           PTR = ADDR(WORK AREA)\n         B     HPAGO2              DO WHILE PTR LE ADDR(WRK AREA)+LEN\nHPALP2   L     R14,XHWPTR\n         PACK  XHPW,0(16,R14)      PACK 16 BYTES AT A TIME\n         L     R11,XHSPTR\n         MVO   0(9,R11),XHPW       SHIFT TO GET RID OF SIGN\n         AL    R11,=F'8'           ADD 8 TO\n         ST    R11,XHSPTR           HEX RESULT ADDRESS\n         AL    R14,=F'16'          ADD 16 TO\n         ST    R14,XHWPTR           PTR\nHPAGO2   L     R14,XHL\n         LA    R11,XHW\n         ALR   R11,R14\n         C     R11,XHWPTR\n         BH    HPALP2              END OF DO LOOP\n*                                  CHECK FOR EVEN NUMBER OF\n*                                   HEX DIGITS\n         ST    R14,Y\n         LR    R2,R14              PREPARE TO DIVIDE\n         SRDA  R2,32               PREPARE TO DIVIDE\n         D     R2,=F'2'            HALVE THE LENGTH\n         ST    R3,XHL              SAVE LENGTH\n         ALR   R3,R3               DOUBLE IT\n         CR    R14,R3              AND COMPARE TO ORIGINAL\n         BE    HPAX                IF EQUAL, THERE WERE AN EVEN NUMBER\n         LA    R14,MSG12           UNEVEN NUMBER OF HEX DIGITS\n         ST    R14,XMSE\n         BAS   R14,SYNERR          SYNTAX\nHPAX     LM    R14,R12,@SAVE21\n         BR    R14\n         EJECT\n*        GET OFFSET ROUTINE\n*\n*        INPUT : XFLDSTRT\n*        OUTPUT : XZADDR = IN-CORE ADDR CORRESPONDING TO OFFSET\n         SPACE 1\nGETOFF   STM   R14,R12,@SAVE08\n         SLR   R14,R14\n         ST    R14,XGOS\n         MVI   XGOC,C' '\n         B     BASGO1              SCAN FOR 1ST CHAR OF OFFSET\nBASLP1   L     R14,XFLDSTRT\n         C     R14,XENDREC\n         BNH   BASOK1\n         ST    R14,XGOS\n         B     BASGO1\nBASOK1   L     R14,XFLDSTRT\n         CLI   0(R14),C' '\n         BNE   BASOK2\n         AL    R14,ONE\n         ST    R14,XFLDSTRT\n         B     BASGO1\nBASOK2   L     R14,XFLDSTRT\n         MVC   XGOC,0(R14)\n         ST    R14,XGOS\nBASGO1   L     R14,XGOS\n         LTR   R14,R14\n         BZ    BASLP1\n*                                  CHECK FIRST CHAR TO DETERMINE\n*                                   TYPE OF OFFSET (HEX OR LBL)\n         CLI   XGOC,C''''          QUOTE (LABEL OFFSET)?\n         BE    BASQOT              YES, BRANCH\n*                                  PROCESS A HEXADECIMAL OFFSET\n         BAS   R14,GETHEX          GET HEX OFFSET\n         L     R14,XHL\n         C     R14,=F'4'\n         BNH   BASOK3\n         LA    R14,MSG02           OFFSET FIELD IS TOO LONG\n         ST    R14,XMSE\n         BAS   R14,SYNERR          SYNTAX\n         B     BASX\nBASOK3   L     R14,XHL\n         SLR   R11,R11\n         CR    R14,R11             IS XHL ZERO?\n         BE    BASX                YES, GO EXIT                    -EU-\n         ST    R11,XHOP            LEADING ZEROES\n         LCR   R14,R14             1, 2, 3, OR 4 BECOME -1, -2, -3, -4\n         AL    R14,=F'5'           BECOME +4 +3 +2 +1\n         LA    R11,XHOP-1(R14)\n         LCR   R14,R14             BECOME -4 -3 -2 -1\n         AL    R14,=F'4'           BECOME 0 1 2 3 LENGTH CODE\n         EX    R14,MVREPDT         MOVE REPDATA TO R11\n         CLC   XEBV(3),=CL3'BAS'   IS THIS A BASE STATEMENT?\n         BNE   BASINN              NO, ITS A VER OR REP, BRANCH\n         L     R14,XHOP\n         ST    R14,XBASE           STORE BASE VALUE\n         B     BASX\nBASINN   L     R14,XCSADDR         GET ADDRESS OF CSECT\n         AL    R14,XHOP            ADD OFFSET\n         SL    R14,XBASE           SUBTRACT VALUE FROM 'BASE' VERB\n         ST    R14,XZADDR          SAVE THIS AS ADDRESS TO ZAP\n         B     BASX                GO EXIT\nBASQOT   MVI   XEBLBL+1,C' '       PROCESS A SYMBOLIC (LABEL) OFFSET\n         MVC   XEBLBL+2(6),XEBLBL+1\n         MVI   XEBLBL,C' '\n         LA    R14,XEBLBL\n         ST    R14,XRCVADDR\n         MVC   XRCVLEN,=F'8'\n         BAS   R14,GETFLD          GO GET LABEL\n         CLC   XEBLBL(8),BLANKS\n         BE    BASMISS\n         BAS   R14,SCANMOD         GO SCAN MOD FOR VALUE OF LABEL\n         L     R14,XLMADDR         GET ADDRESS OF MODULE\n         AL    R14,XOFFSET         ADD OFFSET TO CSECT\n         ST    R14,XZADDR          STORE ADDR TO ZAP\n         ST    R14,XLOC\n         TM    XFLAGS,XFEOD\n         BO    BASX                BRANCH IF NOT EOD\n         BAS   R14,PRADDR          GO PRINT ADDRESS\n         B     BASX                GO EXIT\nBASMISS  LA    R14,MSG11           REQUIRED FIELD MISSING\n         ST    R14,XMSE\n         BAS   R14,SYNERR          SYNTAX\nBASX     LM    R14,R12,@SAVE08\n         BR    R14\n         EJECT\n*        RECORD FETCHING ROUTINE\n         SPACE 1\nGETREC   STM   R14,R12,@SAVE10\n         TM    XFLAGS,XFCON        ARE WE IN CONSOLE MODE?\n         BZ    GETSIN              NO, BRANCH\n*                                  CONSOLE INPUT SECTION\n         BAS   R14,GLREC           TRY TO GET A LOGICAL RECORD\n         B     GETCGO1             DO WHILE LOGICAL REC NOT GOTTEN\n*                                  (USE WTOR TO GET ANOTHER PHYS REC)\nGETCLP1  SLR   R14,R14\n         ST    R14,XWECB           CLEAR ECB\n         MVI   XREPLY+1,C' '       CLEAR WTO AREA\n         MVC   XREPLY+2(128),XREPLY+1\n         MVI   XREPLY,C' '\n         LA    R1,XWTOR\n         LA    R15,XREPLY\n         ST    R15,0(R1)\n         MVI   0(R1),130           LENGTH OF REPLY\n         LA    R14,XWECB\n         ST    R14,4(R1)\n         WTOR  MF=(E,(1))                                          -EU-\n         WAIT  ECB=XWECB                                           -EU-\n         L     R14,=A(EBCDIC)                                      -EU-\n         TR    XREPLY(130),0(R14)  TRANSLATE TO UPPER CASE         -EU-\n         LA    R14,XREPLY\n         LR    R11,R14\n         BCTR  R11,0\n         ST    R11,XENDREC         SET END OF LAST LOGICAL\n         SL    R14,=F'-129'        REC TO BEGINNING OF REPLY AREA-1\n         ST    R14,XPENDREC        SET END OF PHYSICAL RECORD\n         BAS   R14,GLREC           NOW EXTRACT A LOGICAL REC\nGETCGO1  CLC   XENDREC,XPENDREC\n         BH    GETCLP1             END OF DO LOOP\n         B     GETCX\n*                                  PROCESS PARM FIELD INPUT\nGETSIN   TM    XFLAGS,XFMAIN       IS THERE PARM FIELD INPUT?\n         BO    GETCSYIN            NO, BRANCH\n         CLC   XENDREC,XPENDREC    MORE IN PARM\n         BL    GETCPARM            YES, BRANCH\n         OI    XFLAGS,XFEOD        XFEOD\n         B     GETCX\nGETCPARM BAS   R14,GLREC           EXTRACT LOGICAL REC FROM PARM\n         B     GETCX\n*                                  INPUT IS FROM SYSIN DD\nGETCSYIN BAS   R14,GLREC           TRY TO GET A LOGICAL RECORD\n         B     GETCGO2             DO WHILE NO LOGICAL REC GOTTEN\nGETCLP2  GET   XDCBIN,XCARD        READ A PHYSICAL RECORD\n         LA    R14,XCARD\n         LR    R11,R14\n         BCTR  R11,0\n         ST    R11,XENDREC         POINT TO BYTE PRECEDING COL 1\n         SL    R14,=F'-71'         POINT TO COLUMN 72\n         ST    R14,XPENDREC        THIS IS END OF PHYSICAL RECORD\n         BAS   R14,GLREC           NOW GO GET LOGICAL RECORD\nGETCGO2  CLC   XENDREC,XPENDREC    IS THERE MORE PHYS REC LEFT\n         BH    GETCLP2             BRANCH IF NOT\nGETCX    LM    R14,R12,@SAVE10\n         BR    R14\n*                                  END-OF-DATA (EODAD) FOR SYSIN\nCTLEOD   OI    XFLAGS,XFEOD        SET XFEOD\n         B     GETCX\n         EJECT\n*        LOGICAL RECORD EXTRACTION ROUTINE (CALLED BY 'GETREC')\n         SPACE 1\nGLREC    STM   R14,R12,12(R13)\n         L     R14,XENDREC\n         C     R14,XPENDREC\n         BH    SEPX\n         AL    R14,ONE             ADD 1 TO\n         ST    R14,XENDREC          END POINTER\n         ST    R14,XFLDSTRT        INITIALIZE GETFLD BEGIN ADDRESS\n         SLR   R14,R14             SET\n         ST    R14,XPS              SW = 0\n         B     SEPGO1              DO UNTIL SW NE 0\nSEPLP1   CLC   XENDREC,XPENDREC\n         BL    SEPOK1\n         LA    R14,1               SET\n         ST    R14,XPS              SW = 1\n         B     SEPGO1\nSEPOK1   L     R14,XENDREC\n         CLI   0(R14),C'/'         MULTIPLE STATEMENTS PER CARD?\n         BNE   SEPNXT              NO\n         MVI   0(R14),C' '         YES, CHANGE SLASH TO BLANK\n         LA    R14,1               SET\n         ST    R14,XPS              SW = 1\n         B     SEPGO1\nSEPNXT   LA    R14,1               ADD 1\n         AL    R14,XENDREC          TO\n         ST    R14,XENDREC           END POINTER\nSEPGO1   L     R14,XPS\n         LTR   R14,R14\n         BZ    SEPLP1\nSEPX     LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n*        HEX TO EBCDIC CONVERSION ROUTINE\n*\n*        INPUT : XHEX = ADDR OF HEX DATA TO BE CONVERTED\n*                XHEXL = LENGTH OF HEX DATA\n*                XEBAD = ADDR OF TARGET AREA TO RECEIVE EBCDIC DATA\n         SPACE 1\nHEXCV    STM   R14,R12,12(R13)\n         BAS   R14,MODESET1        GET INTO KEY 0\n         LA    R14,1               SET UP LOOP VARIABLE\n         B     HEXCT\nHEXLP    L     R11,XEBAD           GET ADDR OF TARGET EBCDIC AREA\n         L     R7,XHEX             GET ADDR OF 'FROM' FIELD\n         ALR   R7,R14\n         BCTR  R7,0                POINT AT CURRENT CHARACTER\n         LR    R4,R14              SAVE LOOP COUNTER\n         BAS   R14,BIT31           GET 31-BIT MODE IF XA\n         MVC   1(1,R11),0(R7)      MOVE CHARACTER TO TARGET AREA\n         BAS   R14,BIT24           GET BACK TO 24-BIT MODE\n         LR    R14,R4\n         UNPK  0(1,R11),1(1,R11)   GET FIRST NIBBLE INTO NEXT BYTE\n         NC    0(2,R11),=XL2'0F0F' STRIP ZONE BITS\n         TR    0(2,R11),=CL16'0123456789ABCDEF'   TRANSLATE TO EBCDIC\n         AL    R11,=F'2'           BUMP TARGET CHAR POINTER\n         ST    R11,XEBAD\n         AL    R14,ONE             INCREMENT LOOP COUNTER\nHEXCT    ST    R14,XX\n         C     R14,XHEXL           ARE THERE MORE CHAR'S TO CONVERT\n         BNH   HEXLP\n         BAS   R14,MODESET2        GET BACK TO USER KEY\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n*        HOUSEKEEPING ROUTINE (PERFORMS PROGRAM INITIALIZATION)\n         SPACE 1\nINIT     STM   R14,R12,@SAVE09\n         MVI   XWTO+127,C' '\n         MVC   XWTO+128(16),XWTO+127\n         MVC   XWTO(127),BLINE\n         MVC   XWTOR,WTORM\n         XC    XDCBCLS(12),XDCBCLS\n         XC    XHW,XHW\n         SLR   R14,R14\n         ST    R14,XCODE\n         XC    XFLAGS(2),XFLAGS\n         BAS   R14,CONTROL         LOOK WHO AND WHAT               -EU-\n         TM    XFLAGS,XFEOD        ACCEPTED?                       -EU-\n         BO    INITX               NO, REJECT                      -EU-\n*        L     R14,CVTPTR          CVTPTR                          -EU-\n*        USING CVT,R14                                             -EU-\n*        L     R14,CVTTCBP         TCB WORDS                       -EU-\n*        DROP  R14                                                 -EU-\n*        L     R14,4(,R14)         CURRENT TCB                     -EU-\n*        USING TCB,R14                                             -EU-\n*        L     R14,TCBRBP          CURRENT RB                      -EU-\n*        DROP  R14                                                 -EU-\n*        L     R14,12(,R14)        RBCDE                          .***.\n*        CLC   8(8,R14),=CL8'LINKZAP'   CDNAME LINKZAP            .***.\n*        BE    INIT1               YES, NO CONTROL XFMAIN         .***.\n         L     R14,@PARMPTR        PARM FIELD                     .PRC.\n         LH    R14,0(,R14)         LENGTH OF PARM                 .PRC.\n         LTR   R14,R14             IS THERE A PARM?               .PRC.\n         BNZ   INIT1               YES, NO CONTROL XFMAIN         .PRC.\n         OI    XFLAGS,XFMAIN       CONTROL XFMAIN\nINIT1    LA    R14,PRTDEF\n         ST    R14,XDDN\n         LA    R14,XDCBO\n         ST    R14,XDCBA\n         BAS   R14,OPEN            OPEN PRT\n         LTR   R15,R15             WAS OPEN SUCCESSFUL?\n         BNZ   INIT2\n         OI    XFLAGS,XFOOP        PRT IS OPEN\nINIT2    LA    R14,LIBDEF\n         ST    R14,XDDN\n         LA    R14,XDCBL\n         ST    R14,XDCBA\n         BAS   R14,OPEN            OPEN LIB\n         LTR   R15,R15\n         BZ    INIT3\n         LA    R14,MSG07           DD STATEMENT FOR LIBRARY NOT FOUND\n         ST    R14,XMSE\n         BAS   R14,GENERR\n         B     INITX\nINIT3    TM    XFLAGS,XFMAIN       IS INPUT FROM PARM FIELD?\n         BZ    INITPARM            YES, GO GET PARM FIELD\n         LA    R14,CTLDEF\n         ST    R14,XDDN\n         LA    R14,XDCBIN\n         ST    R14,XDCBA\n         BAS   R14,OPEN            OPEN SYSIN\n         LTR   R15,R15\n         BZ    INIT4\n         LA    R14,MSG06           INPUT DD STATEMENT NOT FOUND\n         ST    R14,XMSE\n         BAS   R14,GENERR\n         B     INITX\nINIT4    L     R14,XPENDREC\n         ST    R14,XENDREC\n         B     INITX\nINITPARM LA    R14,@PARMCPY\n         BCTR  R14,0\n         ST    R14,XENDREC\n         L     R11,@PARMPTR\n         LH    R7,0(,R11)          GET LENGTH OF PARM\n         ALR   R14,R7              GET ADDRESS OF LAST CHAR IN PARM\n         ST    R14,XPENDREC        SAVE IT\n         LTR   R7,R7               IS THERE A PARM?\n         BNP   INITX               NO, BRANCH\n         BCTR  R7,0                LENGTH MINUS 1 FOR EX\n         EX    R7,PARMMVC          MOVE PARM TO PARMCPY\nINITX    LM    R14,R12,@SAVE09\n         BR    R14\n         EJECT ,                                                   -EU-\n*        ROUTINE TO CONTROL CALLER AND HOW                         -EU-\n         SPACE 1                                                   -EU-\nCONTROL  STM   R14,R12,@SAVE01                                     -EU-\n         XC    EXTR(EXTRL+L'ANSWER),EXTR                           -EU-\n         EXTRACT ANSWER,'S',FIELDS=(COMM),MF=(E,EXTR)              -EU-\n         L     R2,ANSWER           COMMUNICATION AREA ADDRESS      -EU-\n         ICM   R3,B'1111',4(R2)    CIB ADDRESS?                    -EU-\n         BZ    NOTCON              NO, CURRENT CIB NOT SET UP      -EU-\n         USING CIBDSECT,R3                                         -EU-\n         CLI   CIBVERB,CIBSTART    START COMMAND (SYSTEM TASK)?    -EU-\n         BNE   NOTCON              NO                              -EU-\n         DROP  R3                                                  -EU-\n         OI    @SWB,CONACC         CONSOLE MAY BE ACCEPTED         -EU-\n         B     EXCON                                               -EU-\nNOTCON   XC    REQAUT(REQAUTL),REQAUT                              -EU-\n         MVC   REQAUT+1(L'REQ@IX),REQ@IX                           -EU-\n         LA    R1,AUTH                                             -EU-\n         ST    R1,REQAUT+4                                         -EU-\n        $EACM  REQAUT                                              -EU-\n         CLI   AUTH,LV0            AUTHORIZED?                     -EU-\n         BNE   EXCON               YES                             -EU-\n         LA    R14,MSG13           USER NOT AUTHORIZED             -EU-\n         ST    R14,XMSE                                            -EU-\n         OI    XFLAGS,XFCON        FORCE MESSAGE BY WTO            -EU-\n         BAS   R14,GENERR                                          -EU-\nEXCON    LM    R14,R12,@SAVE01                                     -EU-\n         BR    R14                                                 -EU-\n         EJECT\n*        ROUTINE TO OPEN FILES\n         SPACE 1\nOPEN     STM   R14,R12,@SAVE24\n         L     R14,XDCBA\n         L     R11,XDDN\n         L     R7,0(,R11)\n         MVC   0(100,R14),0(R7)    MOVE DCB PROTOTYPE\n         LR    R1,R11\n         LA    R1,8(,R1)           PRIMARY DDNAME\n         DEVTYPE (1),XCARD                                         -EU-\n         LTR   R15,R15             IS DDNAME PRESENT?\n         BNZ   OPEN1               NO, BRANCH\n         L     R14,XDCBA\n         L     R11,XDDN\n         MVC   40(8,R14),8(R11)    USE PRIMARY DDNAME\n         B     OPEN2\nOPEN1    L     R14,XDCBA\n         L     R11,XDDN\n         MVC   40(8,R14),16(R11)   USE SECONDARY DDNAME\nOPEN2    L     R14,XDDN\n         L     R14,4(,R14)         POINT TO OPEN MF=L IMAGE\n         L     R11,XDCBA\n         ICM   R7,B'1111',0(R14)   LOAD OPEN MF=L IMAGE\n         OR    R11,R7              OR IMAGE OVER R11\n         ST    R11,XDCBA           STORE COMBINED IMAGE IN OPEN MF=L\n         LA    R1,XDCBA\n         OPEN  MF=(E,(1))                                          -EU-\n         L     R14,XDCBA\n         USING IHADCB,R14                                          -EU-\n         TM    DCBOFLGS,DCBOFOPN   WAS OPEN SUCCESSFUL?            -EU-\n         BZ    OPENRC4             NO, BRANCH\n         DROP  R14                                                 -EU-\n         SLR   R14,R14\n         ST    R14,XOCODE\n         B     OPENRET\nOPENRC4  MVC   XOCODE,=F'4'\nOPENRET  L     R15,XOCODE\n         L     R14,@SAVE24\n         LM    R0,R12,@SAVE24+8\n         BR    R14\n         EJECT\n*        PRINT ADDRESS OF SYMBOL (CSECT, LABEL, ETC...)\n*\n*        INPUT : XLOC = FOUR-BYTE ADDRESS TO BE DISPLAYED\n         SPACE 1\nPRADDR   STM   R14,R12,@SAVE23\n         MVI   @LINE47,C' '\n         MVC   @LINE48(73),@LINE47\n         MVC   @LINE01(46),WHEREMSG\n         LA    R14,XLOC\n         ST    R14,XHEX            ADDR OF WHERE HEX IS COMING FROM\n         MVC   XHEXL,=F'4'\n         LA    R14,@LINE01\n         ST    R14,XEBAD           ADDR WHERE WE WANT EBCDIC ADDR\n         BAS   R14,HEXCV           CONVERT HEX ADDR TO EBCDIC\n         BAS   R14,PUTLINE         GO PRINT IT OUT\n         LM    R14,R12,@SAVE23\n         BR    R14\n         EJECT\n*        OUTPUT RECORD PRINTING ROUTINE\n         SPACE 1\nPUTLINE  STM   R14,R12,@SAVE11\n         TM    XFLAGS,XFOOP        PRT OPEN\n         BZ    PUTL3\n         TM    @SWB,XF1ST\n         BO    PUTL1\n         OI    @SWB,XF1ST\n         PUT   XDCBO,HEADING\n         MVI   @LINE,C'0'\n         B     PUTL2\nPUTL1    MVI   @LINE,C' '\nPUTL2    PUT   XDCBO,@LINE\nPUTL3    TM    XFLAGS,XFCON\n         BZ    PUTL4\n         TM    @SWB,XFNOWTO        FOR PRINT ONLY?\n         BO    PUTL4               YES, BYPASS WTO\n         MVC   XWTO+4(120),@LINE01\n         WTO   MF=(E,XWTO)\nPUTL4    LM    R14,R12,@SAVE11\n         BR    R14\n         EJECT\n*        READ RECORD FROM LIBRARY\n         SPACE 1\nREADLIB  STM   R14,R12,@SAVE25\n         READ  @DECB,SF,XDCBL,XLREC,248,MF=E\n         CHECK @DECB\n         LM    R14,R12,@SAVE25\n         BR    R14\n         EJECT\n*        SCAN LPA/JPA LOOKING FOR LOAD MODULE\n*\n*        INPUT : XEBLM = NAME OF LOAD MODULE\n*        OUTPUT : XLMADDR = ADDR OF LOAD MODULE\n         SPACE 1\nSCANLPA  STM   R14,R12,@SAVE26\n         TM    XFLAGS,XFLOCSW      IS IT LOCAL MODE?\n         BO    SCLPA1              YES, GO LOOK IN JPA\n         L     R8,CVTPTR           CVT ADDRESS                     -EU-\n         USING CVT,R8                                              -EU-\n         LA    R8,CVTQLPAQ         LINK PACK POINTER               -EU-\n         DROP  R8                                                  -EU-\n         B     SCLPA2\nSCLPA1   L     R14,CVTPTR          CVT ADDRESS                     -EU-\n         USING CVT,R14                                             -EU-\n         L     R14,CVTTCBP         TCB WORDS                       -EU-\n         DROP  R14                                                 -EU-\n         L     R14,4(,R14)         CURRENT TCB\n         USING TCB,R14                                             -EU-\n         L     R8,TCBJSTCB                                         -EU-\n         DROP  R14                                                 -EU-\n         USING TCB,R8                                              -EU-\n         LA    R14,TCBJPQ          LAST CDE                        -EU-\n         DROP  R8                                                  -EU-\n         LR    R8,R14\nSCLPA2   LA    R9,XEBLM\n         LR    R4,R9\n         SL    R4,=F'48'\n         L     R7,CVTPTR           CVT ADDRESS                     -EU-\n         USING CVT,R7                                              -EU-\n         L     R15,CVTQCDSR        CDE SEARCH RTN                  -EU-\n         DROP  R7                                                  -EU-\n         BASR  R14,R15             STD LINKAGE\n*                                  (RETURNS AT +4 IF NAME NOT FOUND)\n         LA    R0,0                INDICATE NAME WAS FOUND\n         LTR   R0,R0\n         BNZ   SCLPA3              BR IF NAME NOT FOUND\n         TM    28(R11),X'04'       IS THIS A MINOR CDE?\n         BZ    GETEXTL             NO, SKIP OBTAINING MAJOR CDE\n         L     R11,20(,R11)        GET ADDR OF MAJOR CDE\nGETEXTL  L     R14,20(,R11)        GET ADDR OF EXTENT LIST\n         L     R7,12(,R14)         GET ADDR OF LOAD MOD\n         ST    R7,XLMADDR          ADDRESS OF MODULE\n         L     R7,XCSLEN\n         LA    R7,0(,R7)\n         LTR   R7,R7               IS CSECT LENGTH CURRENTLY 0?\n         BNZ   SCLPA4              NO, SKIP\n         MVC   XCSLEN+1(3),9(R14)  USE LOAD MODULE LENGTH\n         B     SCLPA4\nSCLPA3   SLR   R14,R14\n         ST    R14,XLMADDR         INDICATE NO CDE FOUND\nSCLPA4   L     R14,XLMADDR         SCAN LPA DIRECTORY (LPDE'S)\n         LTR   R14,R14\n         BNZ   SCLPA7              BRANCH IF MODULE ALREADY FOUND\n         TM    XFLAGS,XFLOCSW\n         BO    SCLPA7              BR IF LOCAL MODE (SKIP SEARCH)\n         L     R14,CVTPTR          CVT ADDRESS                     -EU-\n         USING CVT,R14                                             -EU-\n         TM    CVTDCB,CVTMVS2      MVS BIT ON?                     -EU-\n         BZ    SCLPA7\n         SLR   R0,R0               SET\n         BCTR  R0,0                 R0 NEGATIVE\n         L     R1,CVTLPDIA         LPA DIRECTORY                   -EU-\n         LA    R1,0(,R1)\n         B     LOCATGO1            DO WHILE R0 NEGATIVE\n         DROP  R14                                                 -EU-\nLOCATLP1 CLC   8(8,R1),XEBLM\n         BNE   SCLPA6\n         TM    28(R1),X'04'        ALIAS?\n         BZ    SCLPA5              NO\n         MVC   XEBLM,32(R1)        YES, GET REAL NAME AND START OVER\n         L     R14,CVTPTR          CVT ADDRESS                     -EU-\n         USING CVT,R14                                             -EU-\n         L     R1,CVTLPDIA         LPA DIRECTORY                   -EU-\n         LA    R1,0(,R1)\n         B     LOCATINC\n         DROP  R14                                                 -EU-\nSCLPA5   L     R0,36(,R1)          SET R0 TO MODULE ADDRESS\n         L     R14,XCSLEN\n         LA    R14,0(,R14)\n         LTR   R14,R14             IS THERE A CSECT LENGTH YET?\n         BNZ   LOCATINC            YES, BRANCH\n         MVC   XCSLEN+1(3),33(R1)  USE LOAD MOD LEN AS CSECT LEN\n         B     LOCATINC\nSCLPA6   CLC   8(8,R1),=XL8'FFFFFFFFFFFFFFFF'  HAVE WE SEE ALL LPDE'S?\n         BNE   LOCATINC            NO, BRANCH\n         SLR   R0,R0               END OF DIRECTORY, SET R0 NON NEG\nLOCATINC AL    R1,=F'40'           POINT AT NEXT LPDE\nLOCATGO1 LTR   R0,R0\n         BM    LOCATLP1\n         ST    R0,XLMADDR          SAVE LOCATION OF MODULE\nSCLPA7   L     R14,XLMADDR\n         LTR   R14,R14             WAS END OF DIRECTORY HIT?\n         BNZ   SCANLPAX            NO, BRANCH\n         LA    R14,MSG04           MODULE NOT FOUND IN MAIN STORAGE\n         ST    R14,XMSE\n         BAS   R14,GENERR\nSCANLPAX LM    R14,R12,@SAVE26\n         BR    R14\n         EJECT\n*        ROUTINE TO CONTROL SCANNING OF A MODULE FOR A DESIRED LABEL\n*\n*        INPUT : XEBLM = LOAD MODULE TO SCAN\n*                XEBLBL = CESD LABEL WHOSE OFFSET IS TO BE RETURNED\n*                XEBCS = CSECT WHEREIN THE LABEL RESIDES\n*                        (BLANK MEANS FIRST CSECT)\n*        OUTPUT : XOFFSET = OFFSET IN LOAD MODULE TO LABEL\n*                 XCSLEN = LENGTH OF SPECIFIED CSECT\n         SPACE 1\nSCANMOD  STM   R14,R12,@SAVE22\n         BAS   R14,FIND            GO FIND MODULE ON LIBRARY\n         TM    XFLAGS,XFEOD\n         BO    SCMEXIT\n         SLR   R14,R14\n         BCTR  R14,0\n         ST    R14,XOFFSET         SHOW LABEL REMAINS TO BE FOUND\n         ST    R14,XSYMOFF         SHOW SYMBOL REMAINS TO BE FOUND\n         SLR   R14,R14\n         ST    R14,XCESDN\n*                                  PERFORM SPECIAL PROCESSING FOR\n*                                   THE NUCLEUS LOAD MODULE\n         CLC   XEBLM(6),=CL6'IEANUC'\n         BNE   SCNMD1\n         BAS   R14,BIT31           GET INTO 31-BIT MODE\n         CLC   XEBCS,=CL8'IEAVFX00'     IS THIS PSA CSECT?\n         BNE   PASTCS0             NO, SKIP\n         XR    R2,R2               CLEAR REGISTER\n         ST    R2,XLMADDR          ADDR IS ZERO\n         B     PASTLKU1            SKIP LOOKUP STUFF\nPASTCS0  NUCLKUP BYNAME,NAME='IEAVBK00',ADDR=(R2) ADDR OF 1ST CSECT\n         LA    R2,0(,R2)           CLEAR HI-ORDER BIT\n         ST    R2,XLMADDR          SAVE AS ADDR OF LOAD MOD\nPASTLKU1 NUCLKUP BYNAME,NAME=XEBLBL,ADDR=(R3)     GET ADDR OF LABEL\n         LTR   R15,R15\n         BNZ   LBLNTFND            BR IF LABEL NOT FOUND\n         LA    R3,0(,R3)           CLEAR HI-ORDER BIT\n         SLR   R3,R2               GET OFFSET INTO NUC LOAD MOD\n         ST    R3,XOFFSET          SAVE THIS OFFSET\n         NUCLKUP BYNAME,NAME=XEBCS,ADDR=(R3) GET LENGTH OF CSECT\n         LTR   R15,R15\n         BNZ   LBLNTFND            BR IF LABEL NOT FOUND\n         ST    R1,XCSLEN           SAVE CSECT LENGTH\n         BAS   R14,BIT24           GET BACK TO 24-BIT MODE\n         B     SCMEXIT             EXIT THIS ROUTINE\nSCNMD1   NI    XFLAGS,255-XFSKIP1\nSCNMD2   SLR   R14,R14             CLEAR THE CSECT DESCRIPTOR ARRAY\n         ST    R14,XSDCNT\n         LA    R14,1\n         ST    R14,@ESDSUB\nSCNMD3   LR    R11,R14\n         MH    R11,=Y(XSD@L)                                       -EU-\n         LA    R7,XSDNO(R11)\n         XC    0(XSD@L,R7),0(R7)                                   -EU-\n         AL    R14,ONE\n         ST    R14,@ESDSUB\n         C     R14,=F'400'\n         BNH   SCNMD3\n         SLR   R14,R14             READ AND PROCESS CESD RECORDS\n         ST    R14,XCRSW           CLEAR LOOP SWITCH\n         B     SCNMD10\nSCNMD4   BAS   R14,READLIB\n         CLI   XLREC,C' '          SYM RECORD?\n         BNE   SCNMD5              NO, BRANCH\n         BAS   R14,SYMCHK          GO PROCESS SYM RECORD\nSCNMD5   CLI   XLREC,X'20'         CESD RECORD?\n         BE    SCNMD6              YES, BRANCH\n         LA    R14,1\n         ST    R14,XCRSW\n         B     SCNMD10\n*                                  SCAN CESD ENTRIES ON CESD RECORD\nSCNMD6   LH    R2,XLREC+6          GET LENGTH OF ESD DATA\n         SRDA  R2,32\n         D     R2,=F'16'           GET NUMBER OF ENTRIES\n         ST    R3,XNUMCESD\n         LA    R14,1               START WITH ENTRY NUMBER 1\n         B     ESDGO\nSCNMD7   LA    R14,1\n         AL    R14,XCESDN\n         ST    R14,XCESDN\n         TM    XFLAGS,XFSKIP1\n         BZ    SCNMD8\n         NI    XFLAGS,255-XFSKIP1\n         B     ESDINCR\nSCNMD8   L     R14,@ESDSUB\n         SLA   R14,4               MULTIPLY BY 16\n         LA    R11,XLREC(R14)      ACTUALLY XLREC+16-16\n         TM    0(R11),X'0F'        IS IT AN SD?\n         BZ    GOTSD               YES, BRANCH\n         LA    R11,XLREC(R14)\n         TM    0(R11),X'03'        COULD IT BE AN LR?\n         BNO   ESDINCR             NO, BRANCH\n         TM    0(R11),X'0C'        MAY BE, IS IT AN LR?\n         BNZ   ESDINCR             NO, BRANCH\nGOTSD    L     R14,@ESDSUB\n         ST    R14,XCESDX          SET INDEX TO CESD ENTRY\n         BAS   R14,SECTMAP         USE THIS CESD TO MAP LOAD MODULE\n         L     R14,@ESDSUB\n         SLA   R14,4\n         LA    R11,XLREC-8(R14)    ACTUALLY BUFFER+8-16\n         CLC   0(8,R11),XEBLBL     IS THIS THE RIGHT LABEL?\n         BNE   SCNMD9              NO, BRANCH\n         L     R14,XLREC(R14)      ACTUALLY BUFFER+16-16\n         LA    R14,0(,R14)         ZERO HI ORDER BYTE OF ADDRESS\n         ST    R14,XOFFSET         SAVE CSECT ADDRESS\nSCNMD9   L     R14,@ESDSUB\n         SLA   R14,4\n         LA    R11,XLREC(R14)      ACTUALLY BUFFER+8-16\n         TM    0(R11),X'0F'        IS THIS AN SD?\n         BNZ   ESDINCR             NO, BRANCH\n         LA    R11,XLREC-8(R14)\n         CLC   0(8,R11),XEBCS      IS THIS THE REQUESTED CSECT?\n         BNE   ESDINCR             NO, BRANCH\n         L     R14,XLREC(R14)      ACTUALLY BUFFER+16-16\n         LA    R14,0(,R14)         ZERO HI ORDER BYTE OF ADDRESS\n         ST    R14,XCSDADR         SAVE CSECT ADDRESS\n         L     R14,XSDX\n         ST    R14,XCSECNO\nESDINCR  LA    R14,1               ADD 1 TO\n         AL    R14,@ESDSUB          ESD SUBSCRIPT\nESDGO    ST    R14,@ESDSUB\n         C     R14,XNUMCESD        HAS SUBSCRIPT HIT SIZE YET?\n         BNH   SCNMD7              NO, BRANCH\nSCNMD10  SLR   R14,R14             CHECK FOR SUCCESSFUL SCAN\n         C     R14,XCRSW\n         BE    SCNMD4\n         CLC   XEBCS,BLANKS\n         BNE   SCNMD11             IF NO CSECT SPECIFIED\n         MVC   XCSECNO,ONE         USE THE FIRST CSECT\n         ST    R14,XCSDADR          AND RELATIVE ADDRESS IS 0\nSCNMD11  L     R14,XSYMOFF\n         LTR   R14,R14             WAS LABEL FOUND IN A SYM REC?\n         BM    SCNMD12             NO, BR\n         AL    R14,XCSDADR         GET POSITION WITHIN LOAD MOD\n         ST    R14,XOFFSET         STORE SYM OFFSET + CSECT ADDR\nSCNMD12  SLR   R14,R14\n         C     R14,XSDCNT          WAS AT LEAST ONE CSECT FOUND?\n         BNL   LBLNTFND            BR IF NO\n         L     R11,XCSECNO\n         CR    R11,R14             WAS OWNING CSECT FOUND?\n         BNH   LBLNTFND            BR IF NO\n         C     R14,XOFFSET         WAS DESIRED LABEL FOUND?\n         BH    LBLNTFND            BR IF NO\n         MH    R11,=Y(XSD@L)                                       -EU-\n         LA    R7,XSDLEN(R11)\n         MVC   XCSLEN+1(3),0(R7)   MOVE IN CSECT LENGTH\n         SPACE 1\n*        SCATTER LOAD PROCESSING FOR NUCLEUS\n*\n*              GO THROUGH TABLE ADDING UP LENGTH OF EACH CSECT\n*              (ROUNDED UP TO NEAREST DOUBLE WORD) PREVIOUS\n*              TO DESIRED CSECT.\n         SPACE 1\n         CLC   XEBLM(6),=CL6'IEANUC'\n         BNE   SCNMD15\n         ST    R14,XACCUM          CLEAR ACCUMULATED LENGTH\n         LA    R14,1               SET CSECT COUNTER\n         B     SCNMD14             GO DO LOOP TEST\nSCNMD13  L     R11,XACCUM          GET ACCUMULATED LENGTH\n         ST    R11,XSMCSD          SAVE IT\n         LR    R7,R14              GET CSECT NUMBER\n         MH    R7,=Y(XSD@L)        GET OFFSET INTO TABLE           -EU-\n         XR    R4,R4               CLEAR REG.\n         LA    R7,XSDLEN(R7)       POINT AT CSECT LENGTH\n         ICM   R4,B'0111',0(R7)    LOAD CSECT LENGTH\n         LA    R4,7(,R4)           ADD IN ROUNDUP VALUE\n         N     R4,=F'-8'           GET DBL WORD ROUNDED UP VALUE\n         ST    R4,XWORK\n         ALR   R11,R4              ADD TO ACCUMULATED VALUE\n         ST    R11,XACCUM\n         AL    R14,ONE             INCREMENT CSECT COUNTER\nSCNMD14  ST    R14,@ESDSUB\n         C     R14,XCSECNO         ALL PREV CSECTS PROCESSED?\n         BNH   SCNMD13             NO, BRANCH\n         B     SCNMD16\nSCNMD15  L     R14,XCSDADR         NON-SCATTER-LOAD PROCESSING\n         ST    R14,XSMCSD          DISK ADDR IS SAME AS IN-CORE\nSCNMD16  L     R14,XOFFSET\n         SL    R14,XCSDADR         GET OFFSET WITHIN CSECT\n         ST    R14,XOFFSET\n         AL    R14,XSMCSD          GET OFFSET WITHIN LOAD MOD\n         ST    R14,XOFFSET\n         B     SCMEXIT\nLBLNTFND LA    R14,MSG09           SYMBOL NOT FOUND IN LOAD MODULE -EU-\n         ST    R14,XMSE\n         BAS   R14,BIT24           BE SURE WE ARE IN 24 BIT MODE   -EU-\n         BAS   R14,GENERR\nSCMEXIT  LM    R14,R12,@SAVE22\n         BR    R14\n         EJECT\n*        CSECT MAPPING ROUTINE\n*\n*        INPUT : XCESDX = INDEX INTO ARRAY OF CESD ENTRIES IN A\n*                         CESD REC\n*                XCESDN = CESD NO. OF CURRENT CESD ENTRY\n*                CESD = A CESD RECORD\n*                XEBLM = LOAD MODULE NAME\n*        OUTPUT : XSDNO = ARRAY OF CESD NO.S FRO CSECTS (SD'S) IN\n*                         LD MOD\n*                 XSDLEN = ARRAY OF CSECT LENGTHS\n*                 XSDCNT = COUNT OF CSECTS IN LOAD MODULE (THUS FAR)\n*                 XSDX = FOR A SD ENTRY, THE RELATIVE CSECT NUMBER\n*                        WITHIN THE IN-CORE VERSION OF THE LOAD MODULE\n         SPACE 1\nSECTMAP  STM   R14,R12,12(R13)\n         L     R14,XCESDX          GET ESD SUBSCRIPT\n         SLA   R14,4               MULTIPLY BY 16\n         LA    R11,XLREC(R14)      POINT TO ESD ENTRY + 8\n         TM    0(R11),X'03'        IS IT AN LR?\n         BNO   SCTMP4              NO, BRANCH\n         TM    0(R11),X'0C'        IS IT AN LR?\n         BNZ   SCTMP4              NO, BRANCH\n         SPACE 1\n*        IF CESD ENTRY IS A LABEL REFERENCE (ENTRY POINT) CHECK FOR\n*        SCATTER LOADING (IE. NUCLEUS). SINCE THE SCATTER-LOADED\n*        NUCLEUS IS LOADED AS CESD ENTRIES (SD'S OR LR'S) OCCUR IN THE\n*        CESD RECORDS, ADD THE CESD NUMBER OF THE LABEL'S CSECT TO\n*        THE SD (CSECT) ARRAY\n         SPACE 1\n         CLC   XEBLM(6),=CL6'IEANUC'    IS THIS A NUCLEUS ZAP?\n         BNE   SCTMP4              NO, BRANCH\n         MVC   XSDX,ONE\n         B     SCTMP3\nSCTMP1   L     R14,XSDX\n         L     R11,XSDCNT\n         CR    R14,R11\n         BNH   SCTMP2\n         AL    R11,ONE\n         ST    R11,XSDCNT\n         MH    R14,=Y(XSD@L)                                       -EU-\n         L     R11,XCESDX\n         SLA   R11,4\n         LH    R11,XLREC+6(R11)\n         N     R11,MASKFFFF\n         LA    R7,XSDNO(R14)\n         STCM  R11,B'0011',0(R7)\n         B     SCTMP3\nSCTMP2   LA    R14,1\n         AL    R14,XSDX\n         ST    R14,XSDX\nSCTMP3   L     R14,XSDX\n         MH    R14,=Y(XSD@L)                                       -EU-\n         L     R11,XCESDX\n         SLA   R11,4\n         LH    R11,XLREC+6(R11)\n         N     R11,MASKFFFF\n         LA    R7,XSDNO(R14)\n         ICM   R14,B'1100',0(R7)\n         SRA   R14,16\n         CR    R11,R14\n         BNE   SCTMP1\n         SPACE 1\n*        IF CESD ENTRY IS A SECTION DEFINITION (SD OR CSECT), ADD THE\n*        CESD NO. FOR THE CSECT TO THE ARRAY. IF LOAD MOD IS THE\n*        NUCLEUS CHECK FIRST THAT AN ENTRY MIGHT ALREADY BE IN THE\n*        ARRAY FOR THIS CESD NO. FROM AN EARLIER 'LR' ENTRY. ONCE THE\n*        PROPER CESD ENTRY HAS BEEN FOUND OR ADDED TO THE ARRAY, PUT\n*        IN THE LENGTH OF THIS CSECT.\n         SPACE 1\nSCTMP4   L     R14,XCESDX          GET ESD SUBSCRIPT\n         SLA   R14,4               MULTIPLY BY 16\n         LA    R11,XLREC(R14)      POINT TO ESD ENTRY + 8\n         TM    0(R11),X'0F'        IS IT AN SD?\n         BNZ   SCTMP10             NO, BRANCH\n         CLC   XEBLM(6),=CL6'IEANUC'    IS THIS A NUCLEUS ZAP?\n         BNE   SCTMP8              NO, BRANCH\n         MVC   XSDX,ONE\n         B     SCTMP7\nSCTMP5   L     R14,XSDX\n         L     R11,XSDCNT\n         CR    R14,R11\n         BNH   SCTMP6\n         AL    R11,ONE\n         ST    R11,XSDCNT\n         MH    R14,=Y(XSD@L)                                       -EU-\n         L     R11,XCESDN\n         LA    R7,XSDNO(R14)\n         STCM  R11,B'0011',0(R7)\n         B     SCTMP7\nSCTMP6   LA    R14,1\n         AL    R14,XSDX\n         ST    R14,XSDX\nSCTMP7   L     R14,XSDX\n         MH    R14,=Y(XSD@L)                                       -EU-\n         LA    R11,XSDNO(R14)\n         ICM   R14,B'1100',0(R11)\n         SRA   R14,16\n         C     R14,XCESDN\n         BNE   SCTMP5\n         B     SCTMP9\nSCTMP8   LA    R14,1\n         AL    R14,XSDCNT\n         ST    R14,XSDCNT\n         ST    R14,XSDX\n         MH    R14,=Y(XSD@L)                                       -EU-\n         L     R11,XCESDN\n         LA    R7,XSDNO(R14)\n         STCM  R11,B'0011',0(R7)\nSCTMP9   L     R14,XSDX\n         MH    R14,=Y(XSD@L)                                       -EU-\n         L     R11,XCESDX          GET SUBSCRIPT\n         SLA   R11,4               MULTIPLY BY 16\n         LA    R7,XSDLEN(R14)\n         LA    R14,XLREC+4+1(R11)\n         MVC   0(3,R7),0(R14)\nSCTMP10  LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n*        SYM REC PROCESSING ROUTINE\n*\n*        INPUT : XEBCS = CSECT CONTAINING LABEL\n*                XEBLBL = LABEL BEING SEARCHED FOR\n*                XLREC = FIRST SYMREC\n*        OUTPUT : XSYMOFF = OFFSET OF LABEL IN CSECT\n*                 XLREC = NEXT LIBRARY RECORD AFTER ALL SYMREC'S\n         SPACE 1\nSYMCHK   STM   R14,R12,@SAVE27\n         SLR   R14,R14\n         ST    R14,XSYMTOTX\n         LA    R14,XLREC+4\n         ST    R14,XSYMCPT\n         OI    @SWB,XFSYMSKP\n         OI    XFLAGS,XFSYMGO\n         BAS   R14,SYMNEW\n         B     SYMCHK12\nSYMCHK1  LA    R14,@WAY08\n         B     SYMCHK3\nSYMCHK2  BAS   R14,SYMFETCH\n         LA    R14,1\n         AL    R14,XSYMFAD\nSYMCHK3  ST    R14,XSYMFAD\n         LA    R11,@WAY08\n         SL    R11,=F'-3'\n         CR    R14,R11\n         BNH   SYMCHK2\n         TM    XFLAGS,XFSYMGO\n         BZ    SYMCHK12\n         TM    @WAY08,X'88'\n         BO    SYMCHK9\n         MVC   @WAY08A(8),BLANKS\n         LA    R14,@WAY08A\n         B     SYMCHK5\nSYMCHK4  BAS   R14,SYMFETCH\n         LA    R14,1\n         AL    R14,XSYMFAD\nSYMCHK5  ST    R14,XSYMFAD\n         LA    R11,@WAY08A\n         LA    R7,7\n         SLR   R4,R4\n         IC    R4,@WAY08\n         NR    R7,R4\n         ALR   R11,R7\n         CR    R14,R11\n         BNH   SYMCHK4\n         TM    @SWB,XFSYMSKP\n         BZ    SYMCHK7\n         TM    @WAY08,X'80'\n         BO    SYMCHK9\n         TM    @WAY08,X'10'\n         BZ    SYMCHK9\n         TM    @WAY08,X'60'\n         BNZ   SYMCHK9\n         CLC   @WAY08A(8),XEBCS\n         BE    SYMCHK6\n         CLC   XEBCS,BLANKS\n         BNE   SYMCHK9\nSYMCHK6  NI    @SWB,255-XFSYMSKP\n         B     SYMCHK9\nSYMCHK7  TM    @WAY08,X'80'\n         BO    SYMCHK8\n         TM    @WAY08,X'10'\n         BZ    SYMCHK8\n         TM    @WAY08,X'60'\n         BNZ   SYMCHK8\n         CLC   XEBCS,BLANKS\n         BE    SYMCHK9\n         OI    @SWB,XFSYMSKP\n         B     SYMCHK9\nSYMCHK8  CLC   @WAY08A(8),XEBLBL\n         BNE   SYMCHK9\n         SLR   R14,R14\n         ICM   R14,B'0111',@WAY08Z\n         ST    R14,XSYMOFF\nSYMCHK9  TM    @WAY08,X'80'\n         BZ    SYMCHK12\n         LA    R14,@WAY08B\n         ST    R14,XSYMFAD\n         BAS   R14,SYMFETCH\n         LA    R14,@WAY08C\n         ST    R14,XSYMFAD\n         BAS   R14,SYMFETCH\n         CLI   @WAY08B,X'10'\n         BNL   SYMCHK10\n         BAS   R14,SYMFETCH\nSYMCHK10 TM    @WAY08,X'40'\n         BZ    SYMCHK11\n         BAS   R14,SYMFETCH\n         BAS   R14,SYMFETCH\n         BAS   R14,SYMFETCH\nSYMCHK11 TM    @WAY08,X'10'\n         BZ    SYMCHK12\n         BAS   R14,SYMFETCH\n         BAS   R14,SYMFETCH\nSYMCHK12 TM    XFLAGS,XFSYMGO\n         BO    SYMCHK1\n         LM    R14,R12,@SAVE27\n         BR    R14\n         EJECT\n*        CHARACTER FETCHING ROUTINE FOR SYMREC PROCESSING\n*\n*        INPUT : XSYMFAD = ADDR OF BYTE TO RECEIVE FETCHED CHARACTER.\n*        OUTPUT : XSYMFAD -> BYTE = FETCHED CHARACTER\n*                 XSYMFGO = ON IF DATA IS EXHAUSTED\n         SPACE 1\nSYMFETCH STM   R14,R12,@SAVE29\n         L     R14,XSYMRECX\n         L     R11,XSYMCPT\n         ICM   R11,B'1100',10(R11)\n         SRA   R11,16\n         CR    R14,R11\n         BL    SYMFTCH1\n         BAS   R14,SYMNEW\nSYMFTCH1 TM    XFLAGS,XFSYMGO\n         BZ    SYMFTCH2\n         L     R14,XSYMFAD\n         L     R11,XSYMFPT\n         MVC   0(1,R14),0(R11)\n         LA    R14,1\n         L     R7,XSYMRECX\n         ALR   R7,R14\n         ST    R7,XSYMRECX\n         ALR   R11,R14\n         ST    R11,XSYMFPT\nSYMFTCH2 LM    R14,R12,@SAVE29\n         BR    R14\n         EJECT\n*        ROUTINE TO GET A NEW SYMREC LOGICAL RECORD\n         SPACE 1\nSYMNEW   STM   R14,R12,@SAVE28\n         SLR   R14,R14\n         ST    R14,XSYMRECX\n         ST    R14,XSYMFPT         SET PNTR = 0\n         B     SYMNEW5             DO WHILE PNTR = 0 AND XFSYMGO ON\nSYMNEW1  L     R14,XSYMTOTX\n         CH    R14,XLREC+2\n         BL    SYMNEW3\n         SLR   R14,R14\n         ST    R14,XSYMTOTX\n         BAS   R14,READLIB\n         CLI   XLREC,C' '          SYM?\n         BNE   SYMNEW2             NO, BRANCH\n         LA    R14,XLREC+4\n         ST    R14,XSYMCPT\n         B     SYMNEW3\nSYMNEW2  NI    XFLAGS,255-XFSYMGO  SET XFSYMGO OFF\nSYMNEW3  L     R14,XSYMTOTX\n         LTR   R14,R14\n         BZ    SYMNEW4\n         LA    R14,80\n         AL    R14,XSYMCPT\n         ST    R14,XSYMCPT\nSYMNEW4  LA    R14,80\n         AL    R14,XSYMTOTX\n         ST    R14,XSYMTOTX\n         L     R14,XSYMCPT\n         CLC   1(3,R14),=CL3'SYM'\n         BNE   SYMNEW5\n         L     R11,XSYMOFF\n         LTR   R11,R11\n         BNM   SYMNEW5\n         LA    R14,16(,R14)\n         ST    R14,XSYMFPT\nSYMNEW5  L     R14,XSYMFPT\n         LTR   R14,R14\n         BNZ   SYMNEW6\n         TM    XFLAGS,XFSYMGO\n         BO    SYMNEW1\nSYMNEW6  LM    R14,R12,@SAVE28\n         BR    R14\n         EJECT\n*        SYNTAX ERROR MESSAGE ROUTINE\n         SPACE 1\nSYNERR   STM   R14,R12,@SAVE20\n         MVI   @LINE02,C' '\n         MVC   @LINE03(118),@LINE02\n         MVI   @LINE01,C' '\n         MVC   @LINE01(15),SYNTAX\n         L     R14,XMSE\n         XR    R11,R11                                             -EU-\n         IC    R11,0(,R14)                                         -EU-\n         EX    R11,PUTM8MV         MOVE 1(R14) TO LINE+16          -EU-\n         BAS   R14,PUTLINE\n         MVC   XCODE,=F'8'\n         OI    XFLAGS,XFEOD        SET XFEOD\n         LM    R14,R12,@SAVE20\n         BR    R14\n         SPACE 2\n*        ROUTINE TO GAIN SUPERVISOR STATE, KEY ZERO\n         SPACE 1\nMODESET1 STM   R14,R12,@SAVE17\n         MODESET KEY=ZERO,MODE=SUP\n         LM    R14,R12,@SAVE17\n         BR    R14\n         SPACE 2\n*        ROUTINE TO RETURN TO PROBLEM STATE AND KEY\n         SPACE 1\nMODESET2 STM   R14,R12,@SAVE18\n         MODESET KEY=NZERO,MODE=PROB\n         LM    R14,R12,@SAVE18\n         BR    R14\n         EJECT\n*        VERB SCANNING AND ROUTING ROUTINE\n         SPACE 1\nVERBSCN  STM   R14,R12,@SAVE12\n         LA    R14,XEBV\n         ST    R14,XRCVADDR\n         MVC   XRCVLEN,=F'8'\n         BAS   R14,GETFLD\n         SLR   R14,R14\n         ST    R14,XVXSW           SET SW OFF\n         LA    R14,1\n         ST    R14,XVX             SET SUBSCRIPT TO 1\n         L     R8,=A(OPCODES)      ADDRESS OF VERB TABLE           -EU-\n         L     R9,=A(OPENTRY)      ADDRESS OF VERB ROUTINES TABLE  -EU-\nPROCLOOP L     R11,XVXSW\n         LTR   R11,R11             HAS SW BEEN SET ON?\n         BNZ   PROCDONE            YES, JUMP OUT\n         BCTR  R14,0                                               -EU-\n         LR    R11,R14\n         MH    R11,=Y(L'OPCODES)                                   -EU-\n         LA    R7,0(R8,R11)        GET ADDRESS OF VERB TABLE ENTRY -EU-\n         CLC   XEBV(3),0(R7)       IS THIS THE RIGHT VERB?\n         BNE   PROCINCR            NO, GO INCREMENT TO NEXT ONE\n         SLA   R14,2\n         L     R15,0(R9,R14)       GET VERB ROUTINE ADDRESS        -EU-\n         BASR  R14,R15             CALL THE ROUTINE FOR THIS OPERATION\n         TM    XFLAGS,XFEOD        EXIT REQUESTED?                 -EU-\n         BO    VERBSCNX            YES                             -EU-\n         LA    R14,1\n         ST    R14,XVXSW           SET SW ON\nPROCINCR LA    R14,1\n         AL    R14,XVX\n         ST    R14,XVX\n         CH    R14,=Y(OPNUM)       HAVE ALL VERBS BEEN CHECKED?    -EU-\n         BNH   PROCLOOP            NO, KEEP CHECKING\nPROCDONE L     R14,XVXSW           WAS SW EVER SET ON\n         LTR   R14,R14             YES, BRANCH\n         BNZ   VERBSCNX\n         LA    R14,MSG10           OPERATION REQUESTED IS INVALID\n         ST    R14,XMSE\n         BAS   R14,SYNERR          SYNTAX\nVERBSCNX LM    R14,R12,@SAVE12\n         BR    R14\n         EJECT\n*        ROUTINE TO HANDLE COMMENT STATEMENTS\n         SPACE 1\nCOMMENT  BR    R14\n         SPACE 2\n*        CONSOLE VERB ROUTINE\n         SPACE 1\nCON      STM   R14,R12,@SAVE31                                     -EU-\n         TM    @SWB,CONACC         MAY BE ACCEPTED?                -EU-\n         BO    CONALL              YES                             -EU-\n         LA    R14,MSG14           NO, NOT ALLOWED                 -EU-\n         ST    R14,XMSE                                            -EU-\n         BAS   R14,GENERR                                          -EU-\n         B     CONEX                                               -EU-\nCONALL   OI    XFLAGS,XFCON                                        -EU-\nCONEX    L     R14,XENDREC                                         -EU-\n         ST    R14,XCSER\n         L     R14,XPENDREC\n         ST    R14,XCSPER\n         ST    R14,XENDREC\n         LM    R14,R12,@SAVE31                                     -EU-\n         BR    R14\n         SPACE 2\n*        END VERB ROUTINE\n         SPACE 1\nEND      STM   R14,R12,@SAVE32                                     -EU-\n         NI    XFLAGS,255-XFCON\n         L     R14,XCSER\n         ST    R14,XENDREC\n         L     R14,XCSPER\n         ST    R14,XPENDREC\n         LM    R14,R12,@SAVE32                                     -EU-\n         BR    R14\n         EJECT\n*        DUMP VERB ROUTINE\n         SPACE 1\nDUM      STM   R14,R12,@SAVE05\n         BAS   R14,NAM\n         BAS   R14,DUMP\n         LM    R14,R12,@SAVE05\n         BR    R14\n         SPACE 2\n*        GLOBAL VERB ROUTINE\n         SPACE 1\nGLO      NI    XFLAGS,255-XFLOCSW\n         BR    R14\n         SPACE 2\n*        LOCAL VERB ROUTINE\n         SPACE 1\nLOC      OI    XFLAGS,XFLOCSW\n         BR    R14\n         EJECT\n*        NAME VERB ROUTINE\n         SPACE 1\nNAM      STM   R14,R12,@SAVE04\n         NI    XFLAGS,255-XFNOGO\n         SLR   R14,R14\n         STCM  R14,B'0111',XCSLEN+1\n         ST    R14,XBASE           GET OPERANDS\n         MVC   XRCVLEN,=F'8'\n         LA    R14,XEBLM           PUT ADDRESS OF MEMBER\n         ST    R14,XRCVADDR        IN GETFLD RESULT POINTER\n         B     NAMGO1              DO UNTIL POINTER GT MEMBER+8\nNAMLP1   BAS   R14,GETFLD          CALL GETFLD TO GET NEXT OPERAND\n         LA    R14,8               ADD 8\n         AL    R14,XRCVADDR         TO\n         ST    R14,XRCVADDR          GETFLD RESULT ADDRESS\nNAMGO1   LA    R11,XEBCS           IF R14 GT MEMBER+8\n         CR    R14,R11              THEN\n         BNH   NAMLP1                EXIT DO LOOP\n*                                  CHECK FOR A GLOBAL MODULE IN\n         TM    XFLAGS,XFLOCSW       LOCAL MODE?\n         BZ    NAMOK1              NO, BRANCH\n         CLC   XEBLM(6),=CL6'IEANUC'    YES, DOES NAME LOOK GLOBAL\n         BE    NAMWARN             YES, ISSUE WARNING\n         CLC   XEBLM(5),=CL5'IGC00'     DOES NAME LOOK GLOBAL?\n         BNE   NAMOK1              NO, BRANCH\nNAMWARN  MVI   @LINE58,C' '        ISSUE WARNING\n         MVC   @LINE59(62),@LINE58\n         MVC   @LINE01(57),WARNMSG\n         BAS   R14,PUTLINE\n         SPACE 1\n*        IF A CSECT WAS SPECIFIED, GET THE OFFSET TO THIS\n*        CSECT FROM THE BEGINNING OF THE LOAD MODULE\n         SPACE 1\nNAMOK1   TM    XFLAGS,XFEOD\n         BO    NAMOK3\n         CLC   XEBCS,BLANKS\n         BNE   NAMOK2\n         SLR   R14,R14             CSECT OMITTED\n         ST    R14,XCSOFF          OFFSET ZERO INTO MODULE\n         B     NAMOK3\nNAMOK2   MVC   XEBLBL(8),XEBCS     MAKE CSECT THE LABEL TO LOOKUP\n         BAS   R14,SCANMOD         GO SCAN MODULE FOR THIS LABEL\n         L     R14,XOFFSET\n         ST    R14,XCSOFF          OFFSET INTO MODULE\nNAMOK3   TM    XFLAGS,XFEOD        GET IN-CORE ADDRESS OF LOAD MODULE\n         BO    NAMEX\n         TM    XFLAGS,XFLOCSW\n         BZ    NAMOK4              BR IF NOT LOCAL MODE\n         LOAD  EPLOC=XEBLM,DCB=XDCBL    LOAD A COPY FOR LOCAL MODE -EU-\n         BAS   R14,SCANLPA         GO FIND LOADED MODULE IN JPA\n         B     NAMEEOD\nNAMOK4   CLC   XEBLM(6),=CL6'IEANUC'\n         BNE   NAMSCNL\n         CLC   XEBCS,BLANKS        NUCLEUS, IS CSECT SPECIFIED ?\n         BNE   PASTNCSE            YES, BRANCH\n         LA    R14,MSG05           NO, CSECT REQUIRED WITH NUCLEUS\n         ST    R14,XMSE\n         BAS   R14,GENERR\n         B     NAMEX               EXIT\nPASTNCSE L     R14,CVTPTR          CVT ADDRESS                     -EU-\n         USING CVT,R14                                             -EU-\n         TM    CVTDCB,CVTMVSE      IS THIS MVS/XA?                 -EU-\n         DROP  R14                                                 -EU-\n         BO    NAMEEOD             YES, SKIP LM ADDR (SET BY SCANMOD)\n         SLR   R14,R14\n         ST    R14,XLMADDR         NUCLEUS LOCATION IS ZERO\n         B     NAMEEOD\nNAMSCNL  BAS   R14,SCANLPA\nNAMEEOD  TM    XFLAGS,XFEOD\n         BO    NAMEX\n         L     R14,XLMADDR\n         AL    R14,XCSOFF\n         ST    R14,XCSADDR         ADDRESS OF CSECT\n         ST    R14,XLOC\n         BAS   R14,PRADDR\nNAMEX    LM    R14,R12,@SAVE04\n         BR    R14\n         EJECT\n*        RETURN CODE ROUTINE\n         SPACE 1\nRC       STM   R14,R12,@SAVE06\n         MVI   @LINE17,C' '\n         MVC   @LINE18(103),@LINE17\n         MVC   @LINE01(16),EQRC    = RETURN CODE\n         LA    R14,XCODE\n         AL    R14,=F'3'\n         ST    R14,XHEX\n         LA    R14,@LINE01\n         ST    R14,XEBAD\n         MVC   XHEXL,ONE\n         BAS   R14,HEXCV\n         BAS   R14,PUTLINE\n         LM    R14,R12,@SAVE06\n         BR    R14\n         EJECT\n*        REP OR RES OR RESET\n         SPACE 1\nREP      STM   R14,R12,@SAVE03\n         CLC   XEBV,=CL8'RESET'    IS IT RESET?\n         BNE   REPIN               NO, BRANCH IF REP OR RES\n         NI    XFLAGS,255-XFNOGO   RESET, JUST SET XFNOGO OFF\n         B     REPX\nREPIN    TM    XFLAGS,XFNOGO       IS XFNOGO SWITCH ON?\n         BZ    REPGO               NO, BRANCH\n         MVI   @LINE37,C' '\n         MVC   @LINE38(83),@LINE37\n         MVC   @LINE01(36),IGNORED\n         BAS   R14,PUTLINE\n         B     REPX\nREPGO    BAS   R14,GETOFF\n         BAS   R14,GETHEX\n         TM    XFLAGS,XFEOD\n         BO    REPX\n         CLC   XEBV,=CL8'REP'      IS THIS A REP?\n         BNE   RESTOREX            NO, GO DO RESTORE PROCESSING\n         BAS   R14,FIXER           FIX PAGE IF REP\n         BAS   R14,MODIFY          GO MODIFY STORAGE\n         B     REPX                SKIP RESTORE PROCESSING\nRESTOREX BAS   R14,MODIFY          GO MODIFY STORAGE\n         BAS   R14,FIXER           GO UNFIX STORAGE\nREPX     LM    R14,R12,@SAVE03\n         BR    R14\n         EJECT\n*        VERIFY ROUTINE\n         SPACE 1\nVER      STM   R14,R12,@SAVE02\n         BAS   R14,GETOFF          GO GET VALUE OF OFFSET\n         BAS   R14,GETHEX          GO GET HEX STRING\n         TM    XFLAGS,XFEOD\n         BO    VERX\n         BAS   R14,BIT31           GET INTO 31-BIT MODE\n         L     R14,XHL\n         BCTR  R14,0\n         L     R11,XZADDR\n         EX    R14,VERCLC          VERIFY THE DATA\n         BNE   VERNO               BRANCH NOT VERIFIED             -EU-\n         BAS   R14,BIT24           INSURE BACK TO 24-BIT MODE\n         B     VERX                EXIT IF IT VERIFIES OK          -EU-\nVERNO    OI    XFLAGS,XFNOGO       SET XFNOGO SWITCH               -EU-\n         MVC   XCODE,=F'4'\n         MVI   @LINE33,C' '\n         MVC   @LINE34(87),@LINE33\n         MVC   @LINE01(32),REJECT\n         BAS   R14,BIT24           GET BACK TO 24-BIT MODE\n         BAS   R14,PUTLINE         ISSUE REJECT MESSAGE\n         BAS   R14,DUMP            DUMP THE MODULE\nVERX     LM    R14,R12,@SAVE02                                     -EU-\n         BR    R14\n         EJECT\n*        ZERO (AND PGFIX) STORAGE ROUTINE\n         SPACE 1\nZAP      STM   R14,R12,@SAVE07\n         BAS   R14,VER\n         TM    XFLAGS,XFEOD+XFNOGO\n         BNZ   ZAPX\n         BAS   R14,FIXER           FIX PAGE IF LPA\n         L     R14,XHL\n         BCTR  R14,0               LENGTH MINUS 1 FOR EX\n         EX    R14,ZAPXC           MAKE REP DATA ALL ZEROS\n         BAS   R14,MODIFY\nZAPX     LM    R14,R12,@SAVE07\n         BR    R14\n         SPACE 2\n*        ROUTINE TO OBTAIN 24-BIT ADDRESSING MODE\n         SPACE 1\nBIT24    LA    R14,0(,R14)         CLEAR HI-ORDER PORTION          -EU-\n         BSM   0,R14               RETURN IN 24-BIT MODE           -EU-\n         SPACE 2\n*        ROUTINE TO OBTAIN 31-BIT ADDRESSING MODE\n         SPACE 1\nBIT31    LA    R14,0(,R14)         CLEAR OUT BAL STUFF, ETC...     -EU\n         O     R14,HIORDBIT        TURN ON AMODE-31 BIT            -EU-\n         BSM   0,R14               RETURN IN 31-BIT MODE\n         EJECT\n*        ROUTINE TO MODIFY STORAGE\n*\n*        INPUT : XHS = HEX STRING\n*                XHL = LENGTH OF HEX STRING\n*                XZADDR = ADDRESS OF CORE TO BE OVERLAYED\n         SPACE 1\nMODIFY   STM   R14,R12,@SAVE30\n         MVI   @LINE14,C' '\n         MVC   @LINE15(106),@LINE14\n         MVC   @LINE01(13),OLDWAS\n         L     R14,XHL             LENGTH OF DATA TO BE MODIFIED\n         ST    R14,XHEXL\n         L     R14,XZADDR          ADDRESS OF DATA TO BE MODIFIED\n         ST    R14,XHEX\n         LA    R14,@LINE01\n         AL    R14,=F'13'\n         ST    R14,XEBAD           PUT HEX DUMP AT LINE+1+13\n         BAS   R14,HEXCV           CONVERT OLD DATA TO HEX\n         BAS   R14,PUTLINE         DISPLAY OLD DATA\n         BAS   R14,MODESET1        SUPV STATE KEY ZERO\n         BAS   R14,BIT31           GET 31-BIT MODE\n         L     R14,XZADDR          GET ADDRESS TO BE MODIFIED\n         L     R11,XHL             GET LENGTH OF DATA\n         B     MODLPTST            GO DO LOOP TEST\nMODLOOP  LA    R8,0(R11,R14)       POINT AT BYTE TO MOVE\n         USING PSA,R0                                              -EU-\n         L     R2,PSAAOLD          GET ADDR OF CURRENT ASCB\n         DROP  R0                                                  -EU-\n         N     R8,MASKPAGE         GET LOWER PAGE BOUNDARY\n         STCTL 1,1,I               GET SET TABLE ORIGIN\n         L     R2,I                GET CONTENTS OF STO REG\n*                                  TURN OFF PAGE PROTECTION FOR XA\n         XR    R9,R9               CLEAR SECOND REG OF PAIR\n         SRDL  R8,20               ISOLATE SX & PUT PX IN R9\n         SLL   R8,2                GET SEG TBL OFFSET (SX*4)\n         N     R2,MASKSTOX         ISOLATE ADDR OF SEG TABLE\n         BAS   R15,REAL2VIR        GET VIRTUAL ADDR\n         ALR   R2,R8               GET ADDR OF SEG TBL ENTRY\n         SRL   R9,22               GET PAGE TABLE OFFSET (PX*2)\n         L     R2,0(,R2)           GET CONTENT OF SEG TBL ENTRY\n         N     R2,MASKSTE          ISOLATE ADDR OF PAGE TBL ORIGIN\n         BAS   R15,REAL2VIR        GET VIRTUAL ADDR\n         ALR   R9,R2               GET ADDR OF PAGE TBL ENTRY\n         L     R8,0(,R9)           GET CONTENTS OF PAGE TABLE ENTRY\n         N     R8,MASKPPBT         ISOLATE PAGE PROT BIT\n         BZ    MODIT               BR IF NO PAGE PROT\n         SRL   R8,8                SHIFT BYTE TO LO-ORDER\n         LA    R9,2(,R9)           GET ADDR OF BYTE WITH PP BIT IN IT\n         NI    0(R9),X'FD'         TURN OFF PAGE PROT\n         PTLB  ,                   ELIM PROT BIT FROM TLB\n*                                  MODIFY STORAGE A BYTE AT A TIME\nMODIT    IC    R0,XHS(R11)         GET FROM BYTE\n         STC   R0,0(R11,R14)       MODIFY STORAGE\n         EX    R8,ORPROT           TURN PROT BIT BACK ON\nMODLPTST S     R11,ONE             DECREMENT\n         BNM   MODLOOP             BRANCH UNTIL DONE\n         BAS   R14,BIT24           GET BACK TO 24-BIT MODE\n         BAS   R14,MODESET2        PROBLEM STATE KEY NZERO\n         LM    R14,R12,@SAVE30\n         BR    R14\n         EJECT\n*        REAL TO VIRTUAL CONVERSION SUBROUTINE\n*\n*        INPUT : R2 - REAL ADDR\n*                R15 - RETURN ADDR\n*        OUTPUT : R1,R3 - ALTERED\n*                 R2 - CONVERTED VIRTUAL ADDRESS\n         SPACE 1\nREAL2VIR LR    R1,R2               COPY INPUT ADDR\n         SRL   R1,12               SHIFT OFF DISPLACEMENT\n         L     R3,CVTPTR           GET ADDR OF CVT                 -EU-\n         USING CVT,R3                                              -EU-\n         L     R3,CVTPVTP          GET ADDR OF PVT                 -EU-\n         DROP  R3                                                  -EU-\n         USING PVT,R3                                              -EU-\n         L     R3,PVTRIT           GET ADDR OF RIT                 -EU-\n         DROP  R3                                                  -EU-\n         L     R3,RITPFT(,R3)      GET ADDR OF PFT                 -EU-\n         SLL   R1,5                GET PFT DISPLACEMENT\n         L     R1,PFTVSA(R1,R3)    GET VIRT PAGE ADDR\nR2VB     N     R2,MASKPGDP         GET PAGE DISPLACEMENT\n         OR    R2,R1               COMBINE WITH VIRT PAGE NO.\n         BR    R15                 RETURN\n         EJECT\n*        EXECUTED INSTRUCTIONS\n         SPACE 1\nLOGMVC   MVC   @LINE01(*-*),0(R14)\nPUTMSGM  MVC   @LINE01(*-*),1(R14)                                 -EU-\nPARBLNK  MVC   0(*-*,R14),BLANKS\nPARMVC   MVC   0(*-*,R11),0(R7)\nHPRTRT   TRT   XHW(*-*),0(R14)                                     -EU-\nMVREPDT  MVC   0(*-*,R11),XHS\nPARMMVC  MVC   @PARMCPY(*-*),2(R11)\nPUTM8MV  MVC   @LINE16(*-*),1(R14)                                 -EU-\nVERCLC   CLC   0(*-*,R11),XHS\nZAPXC    XC    XHS(*-*),XHS\nORPROT   OI    0(R9),*-*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        CONSTANTS                                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nONE      DC    F'1'\nPGFIX    DC    XL4'42000000'\nPGFREE   DC    XL4'20000000'\nMASKFFFF DC    XL4'0000FFFF'\nMASKPAGE DC    XL4'FFFFF000'       PAGE BOUNDARY MASK\nMASKPGDP DC    XL4'00000FFF'       PAGE DISPLACEMENT MASK\nMASKSTO3 DC    XL4'00FFFFC0'       370-MODE STO REG MASK\nMASKSTOX DC    XL4'7FFFF000'       XZ-MODE STO REG MASK\nMASKSPBT DC    XL4'00000004'       SEG PROT BIT MASK\nMASKSTE  DC    XL4'7FFFFFC0'       SEG TBL ENTRY MASK\nMASKPPBT DC    XL4'00000200'       PAGE PROT BIT MASK\nHIORDBIT DC    XL4'80000000'       HI-ORDER BIT MASK\nSIZE     DC    A(@DATAL)           LENGTH OF GETMAINED AREA\n         SPACE 2\n*        LIBRARY DEFINITION TABLES\n         SPACE 1\nLIBDEF   EQU   *,24\n         DC    A(LIBDCB)           POINTER TO DCB IMAGE\n         DC    A(LIBOPEN)          POINTER TO OPEN MF=L\n         DC    CL8'PROGLIB '       PRIMARY DDNAME\n         DC    CL8'SYSLIB  '       SECONDARY DDNAME\nPRTDEF   EQU   *,24\n         DC    A(PRTDCB)           POINTER TO DCB IMAGE\n         DC    A(PRTOPEN)          POINTER TO OPEN MF=L\n         DC    CL8'PROGLIST'       PRIMARY DDNAME\n         DC    CL8'SYSPRINT'       SECONDARY DDNAME\nCTLDEF   EQU   *,24\n         DC    A(CTLDCB)           POINTER TO DCB IMAGE\n         DC    A(CTLOPEN)          POINTER TO OPEN MF=L\n         DC    CL8'PROGIN  '       PRIMARY DDNAME\n         DC    CL8'SYSIN   '       SECONDARY DDNAME\n         SPACE 1\nCLOSE    EQU   *,12\n         CLOSE (*-*,,*-*,,*-*),MF=L                                -EU-\n         SPACE 2\nWTORM    EQU   *,44\n         WTOR  'ENTER ZAP STATEMENTS, RC, OR END',*-*,,MF=L        -EU-\n         SPACE 2\nBLANKS   DC    CL8' '\nBLINE    DC    H'127,0',CL123' '                                   -EU-\nREQ@IX   DC    AL3(MDL@IX)                                         -EU-\n         EJECT\n*        MESSAGES\n         SPACE 1\nWHEREMSG DC    CL46'         = IN-CORE ADDRESS OF PRECEDING SYMBOL'\nIGNORED  DC    CL36'OPERATION IGNORED - NO GO SWITCH SET'\nREJECT   DC    CL32'VERIFY REJECT - SET NO GO SWITCH'\nOLDWAS   DC    CL13'OLD DATA WAS '\nEQRC     DC    CL16'   = RETURN CODE'\nSYNTAX   DC    CL15'SYNTAX ERROR - '\nWARNMSG  DC    CL57'WARNING -- LOCAL MODE IS PROBABLY INVALID FOR THIS 1\n               MODULE'\nHEADING  DC    CL121'1MAIN STORAGE ZAP SERVICE AID PROGRAM'\nMSG01    DC    AL1(L'MSG01T-1)                                     -EU-\nMSG01T   DC    C'FIELD IS TOO LONG'\nMSG02    DC    AL1(L'MSG02T-1)                                     -EU-\nMSG02T   DC    C'OFFSET FIELD IS TOO LONG'\nMSG03    DC    AL1(L'MSG03T-1)                                     -EU-\nMSG03T   DC    C'INVALID HEXADECIMAL CHARACTER'\nMSG04    DC    AL1(L'MSG04T-1)                                     -EU-\nMSG04T   DC    C'MODULE NOT FOUND IN MAIN STORAGE'\nMSG05    DC    AL1(L'MSG05T-1)                                     -EU-\nMSG05T   DC    C'CSECT MUST BE SUPPLIED FOR NUCLEUS LOAD MODULE'\nMSG06    DC    AL1(L'MSG06T-1)                                     -EU-\nMSG06T   DC    C'INPUT DD STATEMENT NOT FOUND'\nMSG07    DC    AL1(L'MSG07T-1)                                     -EU-\nMSG07T   DC    C'DD STATEMENT FOR PROGRAM LIBRARY NOT FOUND'\nMSG08    DC    AL1(L'MSG08T-1)                                     -EU-\nMSG08T   DC    C'MEMBER NOT FOUND ON PROGRAM LIBRARY'\nMSG09    DC    AL1(L'MSG09T-1)                                     -EU-\nMSG09T   DC    C'SYMBOL NOT FOUND IN LOAD MODULE'\nMSG10    DC    AL1(L'MSG10T-1)                                     -EU-\nMSG10T   DC    C'OPERATION REQUESTED IS INVALID'\nMSG11    DC    AL1(L'MSG11T-1)                                     -EU-\nMSG11T   DC    C'REQUIRED FIELD MISSING'\nMSG12    DC    AL1(L'MSG12T-1)                                     -EU-\nMSG12T   DC    C'UNEVEN NUMBER OF HEXADECIMAL DIGITS'\nMSG13    DC    AL1(L'MSG13T-1)                                     -EU-\nMSG13T   DC    C'NOT AUTHORIZED TO USE \"INCORZAP\" PROGRAM'         -EU-\nMSG14    DC    AL1(L'MSG14T-1)                                     -EU-\nMSG14T   DC    C'NOT ALLOWED TO ENTER BY OPERATOR CONSOLE'         -EU-\n         EJECT ,                                                   -EU-\n         LTORG ,                                                   -EU-\n         EJECT\nPATCH    DC    30S(*)              PATCH AREA\n         SPACE 2                                                   -EU-\n         DROP  R5,R6,R10,R12                                       -EU-\n         SPACE 1                                                   -EU-\n*- - - - UPPER LIMIT OF BASE REGISTERS USE - - - - - - - - - - - -*-EU-\n         SPACE 2\n*        FLAG MAPPINGS\n         SPACE 1\nXFMAIN   EQU   X'80'     XFLAGS  - INPUT NOT FROM PARM FIELD\nXFEOD    EQU   X'40'\nXFLOCSW  EQU   X'20'\nXFNOGO   EQU   X'10'\nXFCON    EQU   X'08'\nXFSKIP1  EQU   X'04'               SKIP 1ST CESD (NUC MOD)\nXFOOP    EQU   X'02'               OUTPUT DATASET OPEN\nXFSYMGO  EQU   X'01'               SW FOR SYMREC PROCESSING\n         SPACE 1\nXFSYMSKP EQU   X'80'     @SWB    - SKIP SYMBOLS (WRONG CSECT)\nXF1ST    EQU   X'40'               1ST TIME SW FOR PRINTING\nXFNOWTO  EQU   X'20'\nSWB10    EQU   X'10'\nCONACC   EQU   X'01'               CONSOLE ACCEPT                  -EU-\n         EJECT\n*        VERB NAME TABLE\n         SPACE 1\nOPCODES  DC    CL3'VER'            01\n         DC    CL3'REP'            02\n         DC    CL3'NAM'            03\n         DC    CL3'DUM'            04\n         DC    CL3'RES'            05\n         DC    CL3'   '            06\n         DC    CL3'*  '            07\n         DC    CL3'CON'            08\n         DC    CL3'END'            09\n         DC    CL3'RC '            10\n         DC    CL3'ZAP'            11\n         DC    CL3'GLO'            12\n         DC    CL3'LOC'            13\n         DC    CL3'BAS'            14\n         DC    CL3'IDR'            15\n         DC    CL3'SET'            16\nOPNUM    EQU   (*-OPCODES)/L'OPCODES                               -EU-\n         SPACE 1\n*        VERB ROUTINE ADDRESS TABLE\n         SPACE 1\nOPENTRY  DC    A(VER)              01\n         DC    A(REP)              02\n         DC    A(NAM)              03\n         DC    A(DUM)              04\n         DC    A(REP)              05\n         DC    A(COMMENT)          06\n         DC    A(COMMENT)          07\n         DC    A(CON)              08\n         DC    A(END)              09\n         DC    A(RC)               10\n         DC    A(ZAP)              11\n         DC    A(GLO)              12\n         DC    A(LOC)              13\n         DC    A(GETOFF)           14\n         DC    A(COMMENT)          15\n         DC    A(COMMENT)          16\n         EJECT\nLIBOPEN  OPEN  (*-*,UPDAT),MF=L                                    -EU-\nCTLOPEN  OPEN  (*-*),MF=L                                          -EU-\nPRTOPEN  OPEN  (*-*,OUTPUT),MF=L                                   -EU-\n         SPACE 1                                                   -EU-\n         PRINT NOGEN                                               -EU-\n         SPACE 1\nLIBDCB   DCB   DDNAME=L,DSORG=PO,MACRF=R\nLIBDCBL  EQU   100-(*-LIBDCB)                                      -EU-\n         DC    (LIBDCBL)X'0'                                       -EU-\n         SPACE 1\nPRTDCB   DCB   DDNAME=P,DSORG=PS,MACRF=PM,                             1\n               RECFM=FA,LRECL=121,BLKSIZE=121\nPRTDCBL  EQU   100-(*-PRTDCB)                                      -EU-\n         DC    (PRTDCBL)X'0'                                       -EU-\n         SPACE 1\nCTLDCB   DCB   DDNAME=C,DSORG=PS,MACRF=GM,EODAD=CTLEOD,LRECL=80\nCTLDCBL  EQU   100-(*-CTLDCB)                                      -EU-\n         DC    (CTLDCBL)X'0'                                       -EU-\n         SPACE 1                                                   -EU-\n         PRINT GEN                                                 -EU-\n         EJECT\nHEXTR    DC    193X'00'            00-C0                           -EU-\n         DC    X'0A0B0C0D0E0F'\n         DC    41X'00'             C7-EF\n         DC    X'00010203040506070809'\n         DC    6X'00'              FA-FF\n         SPACE 1\n*        HEXADECIMAL VALIDATION TRANSLATE TABLE\n         SPACE 1\nHEXTRT   DC    193X'01'            00-C0\n         DC    6X'00'              C1-C6 (A-F)\n         DC    41X'01'             C7-EF\n         DC    10X'00'             F0-F9\n         DC    6X'01'              FA-FF\n         SPACE 1\nEBCDIC   DC    74C' '              00-49\n         DC    X'4A4B4C4D4E4F50'\n         DC    C'         '        51-59\n         DC    X'5A5B5C5D5E5F6061'\n         DC    C'        '         62-69\n         DC    X'6A6B6C6D6E6F'\n         DC    C'         '        70-78\n         DC    X'797A7B7C7D7E7F'\n         DC    C' '                80\n         DC    C'ABCDEFGHI'        81-89\n         DC    C' '                8A\n         DC    X'8B8C8D8E8F'\n         DC    C' '                90\n         DC    C'JKLMNOPQR'        91-99\n         DC    C' '                9A\n         DC    X'9B9C9D9E9FA0A1'\n         DC    C'STUVWXYZ'         A2-A9\n         DC    X'AAABACADAEAF'     AA-AF\n         DC    X'B0B1B2B3B4B5B6B7B8B9'\n         DC    C' '                BA\n         DC    X'BBBCBDBEBFC0'\n         DC    C'ABCDEFGHI'        C1-C9\n         DC    C'      '           CA-CF\n         DC    X'D0'\n         DC    C'JKLMNOPQR'        D1-D9\n         DC    C'      '           DA-DF\n         DC    X'E0'\n         DC    C' '                E1\n         DC    C'STUVWXYZ'         E2-E9\n         DC    C'      '           EA-EF\n         DC    C'0123456789'       F0-F9\n         DC    X'FA'\n         DC    C'     '            FB-FF\n         EJECT\n***********************************************************************\n*                                                                     *\n*        MAP OF GETMAINED WORK AREA.                                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n@DATA    DSECT\n         SPACE 1\n         DS    18F                                                 -EU-\n@PARMPTR DS    F\n@SAVE01  DS    15F                 SUBROUTINE SAVE AREAS           -EU-\n@SAVE02  DS    15F\n@SAVE03  DS    15F\n@SAVE04  DS    15F\n@SAVE05  DS    15F\n@SAVE06  DS    15F\n@SAVE07  DS    15F\n@SAVE08  DS    15F\n@SAVE09  DS    15F\n@SAVE10  DS    15F\n@SAVE11  DS    15F\n@SAVE12  DS    15F\n@SAVE13  DS    15F\n@SAVE14  DS    15F\n@SAVE15  DS    15F\n@SAVE16  DS    15F\n@SAVE17  DS    15F\n@SAVE18  DS    15F\n@SAVE19  DS    15F\n@SAVE20  DS    15F\n@SAVE21  DS    15F\n@SAVE22  DS    15F\n@SAVE23  DS    15F\n@SAVE24  DS    15F\n@SAVE25  DS    15F\n@SAVE26  DS    15F\n@SAVE27  DS    15F\n@SAVE28  DS    15F\n@SAVE29  DS    15F\n@SAVE30  DS    15F\n@SAVE31  DS    15F                                                 -EU-\n@SAVE32  DS    15F                                                 -EU-\n@ESDSUB  DS    0F\nI        DS    F                   WORK VARIABLE\nXACCUM   DS    F                   ACCUMULATED CSECT LENGTH\nXBASE    DS    F                   BASE VALUE FOR OFFSET ADJ\nXCESDN   DS    F                   CESD NUMBER\nXCSECNO  DS    F                   CSECT NO. FOR 'XEBLBL'\nXCESDX   DS    F                   INDEX TO CESD ENTRY\nXCRSW    DS    F                   CESD RECORD SCAN SW\nXCSADDR  DS    F                   ADDRESS OF CSECT\nXCSDADR  DS    F                   REL ADDR OF CSECT ON DISK\nXCSER    DS    F                   LENGTH OF CSECT\nXCSPER   DS    F                   SAVE XPENDREC - CONSOLE MODE\nXCSOFF   DS    F                   OFFSET TO CSECT IN LOAD MOD\nXCODE    DS    F                   RETURN CODE\nXDCBA    DS    F                   ADDR OF DCB\nXDDN     DS    F                   PNTR TO DD NAME TABLE\nXDUMPEND DS    F                   END OF DUMP\nXDP      DS    F                   DUMP POINTER\nXEBAD    DS    F                   ADDR OF EBCDIC DATA\nXENDREC  DS    F                   ADDR OF END OF LOGICAL DATA\nXFLDCUR  DS    F                   CURRENT CHARACTER POINTER\nXRCVADDR DS    F                   ADDR OF RECEIVING FIELD\nXFLDALEN DS    F                   ACTUAL FIELD LENGTH\nXFLDSTRT DS    F                   START OF FIELD\nXGOS     DS    F                   'GET OFFSET' ROUTINE SW\nXHEX     DS    F                   ADDR OF HEX DATA\nXHEXL    DS    F                   LENGTH OF HEX DATA\nXHL      DS    F                   LENGTH OF HEX STRING\nXHP      DS    F                   POINTER TO HEX STRING\nXHSPTR   DS    F                   HEX STRING POINTER\nXHSW     DS    F                   SWITCH\nXHWPTR   DS    F                   HEX WORK AREA POINTER\nXLMADDR  DS    F                   IN-CORE ADDR OF LOAD MOD\nXLOC     DS    F                   LOCATION TO BE DISPLAYED\nXMSE     DS    F                   ADDR OF SYNTAX ERR MSG\nXNUMCESD DS    F                   NO. OF ENTRIES IN CESD REC\nXOCODE   DS    F\nXOFFSET  DS    F                   OFFSET TO CESD IN LOAD MOD\nXPECB    DS    F\nXPENDREC DS    F                   POINTER TO END OF PHYSICAL REC\nXPS      DS    F                   LOOP SWITCH\nXPSRC    DS    F                   PAGE SERVICE RETURN CODE\nXRCVLEN  DS    F                   RECEIVING FIELD LEN\nXSCANSW  DS    F                   SW TO CONTROL SCAN\nXSDCNT   DS    F                   COUNT OF CSECTS IN MODULE\nXSDX     DS    F                   ARRAY INDEX FOR XSD\nXSMCSD   DS    F\nXSYMCPT  DS    F\nXSYMFAD  DS    F\nXSYMFPT  DS    F\nXSYMOFF  DS    F\nXSYMRECX DS    F\nXSYMTOTX DS    F\nXVX      DS    F                   VERB INDEX\nXVXSW    DS    F\nXWECB    DS    F\nXWORK    DS    F\nXX       DS    F\nXZADDR   DS    F                   IN-CORE STORAGE ADDR\nY        DS    F\n@FILL01  DS    CL12\nXCSLEN   DS    F\nXCARD    DS    CL80\n         DS    0F\nXDCBL    DS    CL100\n         DS    0F\nXDCBO    DS    CL100\n         DS    0F\nXDCBIN   DS    CL100\nXDCBCLS  DS    3F\n         DS    F\n@DECB    DS    5F\nXEBLM    DS    CL8\nXEBCS    DS    CL8\n         DS    CL8\nXEBLBL   DS    CL8\nXEBV     DS    CL8\nXFLAGS   DS    C\n@SWB     DS    C\nXGOC     DS    C\n         DS    C                   XHOP-1\nXHOP     DS    F\nXHPW     DS    CL9\nXHS      DS    CL40\n         DS    C                   XHW-1\nXHW      DS    CL80\n         SPACE 1\n@LINE    DS    CL121\n         ORG   @LINE\n         DS    C\n@LINE01  DS    C\n@LINE02  DS    C\n@LINE03  DS    CL11\n@LINE14  DS    C\n@LINE15  DS    C\n@LINE16  DS    C\n@LINE17  DS    C\n@LINE18  DS    CL15\n@LINE33  DS    C\n@LINE34  DS    CL3\n@LINE37  DS    C\n@LINE38  DS    CL3\n@LINE41  DS    CL6\n@LINE47  DS    C\n@LINE48  DS    CL10\n@LINE58  DS    C\n@LINE59  DS    CL28\n@LINE87  DS    C\n@LINE88  DS    CL26\n         DS    CL6\n@LIN120  DS    C\n         SPACE 1\n         DS    C\nXLREC    DS    0F,CL248\n@PARMCPY DS    CL200\nXREPLY   DS    CL130\n@FILL9C  DS    CL2\nXWTO     DS    CL144\nXWTOR    DS    CL44\n@WAY08   DS    CL1\n@WAY08Z  DS    CL3\n@WAY08A  DS    CL5\n         SPACE 1                                                   -EU-\nEXTR     EXTRACT *-*,'S',MF=L                                      -EU-\nEXTRL    EQU   *-EXTR                                              -EU-\nANSWER   DS    F                                                   -EU-\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(*-*)            -EU-\nAUTH     DC    XL1'0'                                              -EU-\nREQAUTL  EQU   *-REQAUT                                            -EU-\n         DS    0F                                                  -EU-\n         SPACE 1\n*        CSECT MAPPING ARRAY (2000 ENTRIES)                        -EU-\n         SPACE 1\nXSDNO    DS    C                   CSECT NUMBER (2 BYTES)\n         DS    C\nXSDLEN   DS    C                   CSECT LENGTH (3 BYTES)\n@WAY08B  DS    C\n@WAY08C  DS    C\nXSD@L    EQU   *-XSDNO             ONE ENTRY LENGTH                -EU-\n         DS    1000CL(XSD@L)                                       -EU-\n         DS    1000CL(XSD@L)                                       -EU-\n         SPACE 1\n@DATAL   EQU   (((*-@DATA)+7)/8)*8                                 -EU-\n         EJECT\n*        CONTROL BLOCK MAPPINGS\n         SPACE 1\nRITPFT   EQU   X'D0'               POINTER TO APPARENT PFT (XA-IARRIT)\nPFTVSA   EQU   X'14'               VIRT STORAGE ADDR (XA-IARPFTE)\n         SPACE 2\n         PRINT NOGEN                                               -EU-\n         IHAPSA ,                                                  -EU-\n         CVT   DSECT=YES,LIST=YES                                  -EU-\n         IHAPVT ,                                                  -EU-\n         IKJTCB ,                                                  -EU-\nCIBDSECT DSECT ,                                                   -EU-\nCIB      IEZCIB ,                                                  -EU-\n         DCBD  DSORG=PS                                            -EU-\n         SPACE 2                                                   -EU-\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JCLFLOW": {"ttr": 22532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\"/\\x00\\x89\"/\\x11\\x18\\x03f\\x03f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-08-10T00:00:00", "modifydate": "1989-08-10T11:18:00", "lines": 870, "newlines": 870, "modlines": 0, "user": "SYSPAJA"}, "text": "JCLFLOW  TITLE 'ISPF V2 EDIT MACRO TO REFORMAT AND CHECK JCL.'\n         PRINT OFF\n         MACRO\n&NAME   $GENMSG  &M,&WH                                            -EU-\n&NDX     SETC  '&SYSNDX'\n&NAME    CLC   M&M.LNO,=F'-4'      MSG NEEDED?\n         BE    GENA&NDX            NO\n         L     R2,M&M.LNO          PICK UP HIGHEST OFFSET\n         LA    R2,4(0,R2)          PLUS 1\n         SRL   R2,2                DIVIDE BY 4, NUMBER TO INSERT\n         LA    R3,M&M.LNO+4        1ST LINE NUMBER\nGENB&NDX L     R1,0(0,R3)          PICK UP LINE NUMBER\n         ST    R1,ADDLINE          SAVE AS INSERT POINT\n         CALL  ISPLINK,(EDIT,LEN82,MSG&M),VL                       -EU-\n         LTR   R15,R15             CHECK RETURN CODE               -EU-\n         BNZ   &WH                 NOT ZERO, ERROR                 -EU-\n         LA    R3,4(0,R3)          SKIP TO NEXT LINE NUMBER\n         BCT   R2,GENB&NDX         COUNT OF NUMBER TO INSERT\nGENA&NDX DS    0H\n         MEND\n         MACRO\n&NAME   $NOTEMSG &M\n&NDX     SETC  '&SYSNDX'\n&NAME    L     R1,M&M.LNO          OFFSET INTO LINE NUMBER TBL\n         LA    R1,4(0,R1)          GET NEXT ENTRY\n         CH    R1,=Y(4*32)         TABLE FULL?\n         BH    TBF&NDX             YES\n         L     R14,ADDLINE         PICK UP CURRENT INSERT POINT\n         ST    R14,M&M.LNO+4(R1)   SAVE LINE# FOR MESSAGE INSERT\n         ST    R1,M&M.LNO          SAVE UPDATED OFFSET\nTBF&NDX  DS    0H\n         MEND\n         PRINT ON\n         SPACE 1\n***********************************************************************\n*   THIS PROGRAM WAS \"OBTAINED\" FROM FILE352 OF THE CBT TAPE. IN      *\n*   ITS ORIGINAL FORM IT WAS A BATCH UTILITY, READING JCL FROM        *\n*   SYSUT1 AND WRITING THE REFORMATTED STUFF ONTO SYSUT2. I           *\n*   CHANGED IT BY ALTERING THE I/O LOGIC TO USE ISPF EDIT MACRO       *\n*   SERVICES. THE BASIC LOGIC IS TO START AT THE TOP OF THE DECK      *\n*   ASSIGNING EACH LINE TO VARIABLE \"CARD\". ANYTHING OTHER THAN       *\n*   PART OF A DD STATEMENT IS LEFT AS IS. WHEN A DD STATEMENT IS      *\n*   FOUND EACH LINE IS DELETED AFTER BEING READ. THE LINE NUMBER      *\n*   AFTER WHICH TO INSERT REFORMATTED JCL IS REMEMBERED IN            *\n*   VARIABLE \"ADDLINE\". AN ENTIRE DD STATEMENT IS READ IN,            *\n*   CONTINUATION LINES AND ALL AND STORED IN \"TABLEIN\", EACH INPUT    *\n*   LINE BEING DELETED AFTER ASSIGNMENT. THE DD STATEMENT IS THEN     *\n*   FORMATTED BY BEING COPIED ONE PARAMETER AT A TIME OVER TO         *\n*   \"TABLEOUT\". FROM \"TABLEOUT\" NEW LINES ARE INSERTED INTO THE       *\n*   DATASET TO CONTAIN THE REFORMATTED DD STATEMENT. SINCE THE        *\n*   NUMBER OF LINES IN THE DATASET COULD HAVE INCREASED, THE LINE     *\n*   NUMBER OF THE LAST LINE IS RE-CALCULATED AS NECESSARY AND         *\n*   REMEMBERED IN VARIABLE \"LLINE\".                                   *\n***********************************************************************\n         SPACE 1                                                   -EU-\n*----------------------------------------------------------------* -EU-\n* CHANGES/UPDATES : MOINIL P.A.                                  * -EU-\n*  18/07/89 - EXTRACTED FROM CBT TAPE 89 FEB, FILE 047.          * -EU-\n*           - MACROS ISPF, ISREDIT AND VDEFINE (FROM SOMEWHERE   * -EU-\n*             ON THE CBT 89 FEB TAPE, FILE 435 OR 464) ARE NOW   * -EU-\n*             REPLACED BY THEIR CORRESPONDING CALL ISPLINK.      * -EU-\n*           - HELP PANEL DISPLAY ADDED.                          * -EU-\n*           - DISPLAY ERROR MESSAGES.                            * -EU-\n*           - DD PARAMETERS ADDED IN TABLES.                     * -EU-\n*----------------------------------------------------------------* -EU-\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*    THE FOLLOWING MACROS ARE USED IN JCLFLOW :                       *\n*                                                                     *\n*        LOCAL MACROS :                                               *\n*                                                                     *\n*   $GENMSG    - INSERT MESSAGE LINES INTO THE DATASET.               *\n*   $NOTEMSG   - UPDATE A TABLE OF LINE NUMBERS AFTER WHICH TO INSERT *\n*                A MESSAGE LINE.                                      *\n*                                                                     *\n*                                                                     *\n*        REGISTER USAGE :                                             *\n*                                                                     *\n*  R0    UNUSED.                                                      *\n*  R1    WORK REGISTER                                                *\n*  R2    CURRENT POSITION WITHIN INPUT TEXT (TABLEIN)                 *\n*  R3    LOOP COUNTER                                                 *\n*  R4    CURRENT POSITION WITHIN OUTPUT AREA (TABLEOUT)               *\n*        OR CURRENT ENTRY IN JCL PARAMETER TABLE.                     *\n*  R5    WORK REGISTER                                                *\n*  R6    WORK REGISTER                                                *\n*  R7    LOOP CONTROL (BXLE)                                          *\n*  R8    LOOP CONTROL (BXLE)                                          *\n*  R9    LOOP CONTROL (BXLE)                                          *\n*  R10   SUBROUTINE LINKAGE                                           *\n*  R11   PROGRAM BASE REGISTER 1                                      *\n*  R12   PROGRAM BASE REGISTER 2                                      *\n*  R13   SAVE AREA BASE ADDRESS.                                      *\n*  R14                                                                *\n*  R15                                                                *\n*                                                                     *\n***********************************************************************\n         EJECT ,\nJCLFLOW  START 0                                               -EU-@MLI\n         SPACE 1\n        $DEFREG ,                                                  -EU-\n         EJECT ,\n*------- SET UP BASE REGISTERS AND SAVE AREA POINTERS.\n         SPACE 1\n        $XENT  BASE=(R11,R12)                                      -EU-\n         EJECT ,                                                   -EU-\n*------- OBTAIN THE FUNCTION AND DEFINE THIS PROGRAM               -EU-\n*        AS AN EDIT MACRO.                                         -EU-\n         SPACE 1                                                   -EU-\n         CALL  ISPLINK,(VDEF,GNL0,FCDE,TYPEC,LEN8),VL              -EU-\n         LTR   R15,R15             CHECK RETURN CODE               -EU-\n         BNZ   ERR1                NOT ZERO, ERROR                 -EU-\n         CALL  ISPLINK,(EDIT,LEN16,PARM1),VL                       -EU-\n         LTR   R15,R15             CHECK RETURN CODE               -EU-\n         BNZ   ERR2                NOT ZERO, ERROR                 -EU-\n         OC    FCDE,=CL8' '        FOLD THE CODE TO UPPER CASE     -EU-\n         CLC   FCDE,=CL8'HELP    ' LOOK IF REQUEST IS HELP         -EU-\n         BE    DSHELP                                              -EU-\n         CLC   FCDE,=CL8'H       '                                 -EU-\n         BNE   PRCSS                                               -EU-\n         EJECT ,                                                   -EU-\n*------- DISPLAY THE HELP PANEL.                                   -EU-\n         SPACE 1                                                   -EU-\nDSHELP   CALL  ISPLINK,(DSPL,PNLH),VL                              -EU-\n         LTR   R15,R15             CHECK RETURN CODE               -EU-\n         BNZ   ERR3                NOT ZERO, ERROR                 -EU-\n         B     LEAVE                                               -EU-\n         SPACE 1                                                   -EU-\n         SPACE 1                                                   -EU-\n         SPACE 1                                                   -EU-\n         EJECT ,                                                   -EU-\n*------- SET AND OBTAIN ALL NECESSARY PARAMETERS.                  -EU-\n         SPACE 1                                                   -EU-\nPRCSS    CALL  ISPLINK,(EDIT,LEN8,PARM2),VL                        -EU-\n         LTR   R15,R15             CHECK RETURN CODE               -EU-\n         BNZ   ERR4                NOT ZERO, ERROR                 -EU-\n         CALL  ISPLINK,(VDEF,GNL1,CARD,TYPEC,LEN80),VL             -EU-\n         LTR   R15,R15             CHECK RETURN CODE               -EU-\n         BNZ   ERR5                NOT ZERO, ERROR                 -EU-\n         CALL  ISPLINK,(VDEF,GNL2,LINENO,TYPEF,LEN4),VL            -EU-\n         LTR   R15,R15             CHECK RETURN CODE               -EU-\n         BNZ   ERR6                NOT ZERO, ERROR                 -EU-\n         CALL  ISPLINK,(VDEF,GNL3,LLINE,TYPEF,LEN4),VL             -EU-\n         LTR   R15,R15             CHECK RETURN CODE               -EU-\n         BNZ   ERR7                NOT ZERO, ERROR                 -EU-\n         CALL  ISPLINK,(VDEF,GNL4,ADDLINE,TYPEF,LEN4),VL           -EU-\n         LTR   R15,R15             CHECK RETURN CODE               -EU-\n         BNZ   ERR8                NOT ZERO, ERROR                 -EU-\n         CALL  ISPLINK,(EDIT,LEN28,PARM3),VL                       -EU-\n         LTR   R15,R15             CHECK RETURN CODE               -EU-\n         BNZ   ERR9                NOT ZERO, ERROR                 -EU-\n         MVC   LINENO,=F'0'                                        @MLI\n         MVC   ADDLINE,=F'0'       INSERT AFTER ZERO TO START      @MLI\n         EJECT\n*------- MAINLINE OF THE PROGRAM -- BEGIN PROCESSING DATA.\n         SPACE 1\nGETUT1   L     R1,ADDLINE          GET NUMBER OF LAST INSERT       @MLI\n         LA    R1,1(0,R1)          PLUS 1                          @MLI\n         ST    R1,LINENO           GET NEXT NEW LINE               @MLI\n         CLC   LINENO,LLINE        END OF FILE ON INPUT?           @MLI\n         BH    ENDOFJOB            YES, GO TO END OF JOB\n         SPACE 1\n         CALL  ISPLINK,(EDIT,LEN28,PARM4),VL                       -EU-\n         LTR   R15,R15             CHECK RETURN CODE               -EU-\n         BNZ   ERR10               NOT ZERO, ERROR                 -EU-\n         CLC   CARD(2),=CL2'//'\n         BNE   GETUT1A                                             @MLI\n         CLC   CARD(3),=CL3'//*'\n         BNE   GETUT1B             PROCESS THIS ONE                @MLI\nGETUT1A  L     R1,ADDLINE          GET NUMBER OF LAST INSERT       @MLI\n         LA    R1,1(0,R1)          PLUS 1                          @MLI\n         ST    R1,ADDLINE          AND SAVE IT                     @MLI\n         CLC   ADDLINE,LLINE       DOES IT LOOK LIKE THE BOTTOM    @MLI\n         BL    GETUT1              NO, NEXT LINE                   @MLI\n         CALL  ISPLINK,(EDIT,LEN28,PARM3),VL                       -EU-\n         LTR   R15,R15             CHECK RETURN CODE               -EU-\n         BNZ   ERR11               NOT ZERO, ERROR                 -EU-\n         B     GETUT1              TRY NEXT LINE                   @MLI\n         SPACE 1\nGETUT1B  CALL  ISPLINK,(EDIT,LEN20,PARM5),VL                       -EU-\n         LTR   R15,R15             CHECK RETURN CODE               -EU-\n         BNZ   ERR12               NOT ZERO, ERROR                 -EU-\n         CLC   CARD+2(69),INITOUT+2\n         BE    ALLDONE\n         LA    R2,20\n         LA    R3,CARD+3\nCOMPARES CLC   0(5,R3),=CL5' JOB '\n         BE    JOBCARD\n         CLC   0(6,R3),=CL6' EXEC '\n         BE    EXECARD\n         CLC   0(4,R3),=CL4' DD '\n         BE    DDCARD\n         LA    R3,1(R3)\n         BCT   R2,COMPARES\n         SPACE 1\nALLDONE  MVC   CARD+72(8),INITOUT+2\n         BAL   R10,PUTUT2\n         B     GETUT1\n         SPACE 1\nJOBCARD  B     ALLDONE\nEXECARD  B     ALLDONE\n         EJECT\nDDCARD   MVC   0(4,R3),=CL4'    '\n         LA    R2,TINN\n         L     R3,=AL4(TABLEIN)\n         L     R4,=AL4(TABLEOUT)\nINITLOOP MVC   0(80,R3),INITIN     SET INPUT WORKAREA TO HEX FF'S\n         MVC   0(80,R4),INITOUT    SET OUTPUT WORKAREA TO '// '\n         LA    R3,80(R3)\n         LA    R4,80(R4)\n         BCT   R2,INITLOOP\n         MVC   CARD(2),INITOUT+2   BLANK OUT // FROM INPUT\n         MVC   CARD+72(8),INITOUT+2 BLANK OUT SEQ# FROM INPUT\n         L     R3,=AL4(TABLEIN)\n         MVC   0(80,R3),CARD       MOVE JCL CARD TO INPUT WORKAREA\n         L     R4,=AL4(TABLEOUT)\n         MVC   12(2,R4),=CL2'DD'                                   -EU-\n         BAL   R10,FINELOAD        LOAD ANY CONTINUATION CARDS\n         L     R2,=AL4(TABLEIN+2)\n         L     R3,=AL4(TABLEOUT+2)\n         LA    R4,8\nDDNAMEMV CLI   0(R2),C' '\n         BE    DDNAMOVR\n         MVC   0(1,R3),0(R2)       MOVE 1 CHAR OF DDNAME TO OUTPUT\n         MVI   0(R2),C' '\n         LA    R2,1(R2)\n         LA    R3,1(R3)\n         BCT   R4,DDNAMEMV\n         EJECT\nDDNAMOVR L     R6,=AL4(TABLEIN)\n         ST    R6,CURENTRY         SAVE ADDR OF CURRENT INPUT RECORD\n         LA    R6,72\n         ST    R6,COUNT            SAVE COUNTS OF COLUMNS TO SEARCH\nGOAGAIN  OI    NOPX+1,X'F0'\n         L     R2,CURENTRY         RECORD TO SEARCH IN R2\n         L     R3,COUNT            COLUMNS TO SEARCH IN R3\n         BAL   R10,SEARCH          FIND A JCL PARAMETER, IF POSSIBLE\n         CLI   HITSW,C'0'          WAS THERE ONE?\n         BE    NEWENTRY            NO, WRITE OUT A NON-JCL RECORD\nCONTINUE MVC   OUTADDR(4),TBTA(R4) SAVE ADDR IN TABLEOUT TO STORE PARM\n         ST    R2,START            SAVE START OF POSSIBLE NEXT PARM\n         NI    NOPX+1,X'0F'\n         LA    R2,1(R2)            DON'T RE-FIND THE SAME PARM\n         BCTR  R3,0                WHICH MEANS 1 FEWER COLUMNS TO SCAN\n         BAL   R10,SEARCH          RESUME SCAN OF INPUT RECORD\n         CLI   HITSW,C'0'          ANOTHER PARAMETER OR END OF CARD?\n         BE    NEWENTRY            NO, GOTO NEXT STATEMENT\n         ST    R2,STOP             SAVE END OF PREVIOUS PARAMETER\n         L     R9,START            START OF PARAMETER TEXT\n         L     R10,STOP            END OF PARAMETER TEXT\n         SR    R10,R9              END MINUS START\n         BCTR  R10,0               MINUS 1 IS LENGTH TO MOVE\n         CLI   0(R9),C' '          STARTS BY A BLANK?              -EU-\n         BNE   *+L'*+2             NO, OK                          -EU-\n         BCTR  R10,0               DON'T MOVE STARTING BLANK       -EU-\n         L     R9,OUTADDR          PICK UP PLACE TO SAVE IN TABLEOUT\n         STC   R10,MOVEPARM+1      SET LENGTH TO SAVE TEXT\n         STC   R10,CLEARPRM+1      SET LENGTH TO CLEAR INPUT\n         STC   R10,78(R9)          SAVE LENGTH IN OUTPUT AREA\n         L     R10,START           PICK UP START OF TEXT IN INPUT\n         CLI   0(R10),C' '         STARTS BY A BLANK?              -EU-\n         BNE   *+L'*+4             NO, OK                          -EU-\n         LA    R10,1(R10)          DON'T MOVE STARTING BLANK       -EU-\nMOVEPARM MVC   15(*-*,R9),0(R10)   SAVE IN TABLEOUT\nCLEARPRM MVC   0(*-*,R10),INITOUT+2 BLANK OUT EQUIVALENT IN TABEIN\n         MVI   79(R9),C'X'         FLAG THAT ONE AS GOOD\n         CLI   EODCSW,C'1'         ANYTHING MORE ON INPUT?\n         BNE   CONTINUE            YES, GO DO IT\n         MVI   EODCSW,C'0'\n         LR    R7,R10\n         BAL   R10,SAVECMNT\nNEWENTRY L     R6,CURENTRY\n         LA    R6,80(R6)\n         CLC   0(80,R6),INITIN\n         BE    WRITEIT\n         ST    R6,CURENTRY\n         B     GOAGAIN\n         EJECT\nWRITEIT  LA    R3,TOUTN\n         L     R4,=AL4(TABLEOUT)\n         MVC   CARDSAVE,CARD\n         BAL   R10,LASTLOOK\n         BAL   R10,ADCOMMAS\n         BAL   R10,ADCOMNTS\n         L     R1,=AL4(TABLEOUT)\n         CLI   79(R1),C'X'\n         BE    WRITLOOP\n         MVC   SLOTSAVE(L'SLOTSAVE),2(R1)\n         NI    BYSLOT+1,X'0F'\nWRITLOOP MVC   CARD(80),0(R4)\n         CLI   CARD+79,C'X'\n         BNE   BUMPWRIT\nBYSLOT   B     BLANKX\n         MVC   CARD+2(L'SLOTSAVE),SLOTSAVE\n         OI    BYSLOT+1,X'F0'\nBLANKX   MVC   CARD+78(2),INITOUT+2\n         BAL   R10,PUTUT2\nBUMPWRIT LA    R4,80(R4)\n         BCT   R3,WRITLOOP\n         CLI   ECSW,C'1'\n         BNE   WITEXIT\n         MVI   ECSW,C' '\n         MVC   CARD,ECARD\n         BAL   R10,PUTUT2\nWITEXIT  MVC   SLOTSAVE(L'SLOTSAVE),INITOUT+2\n         MVC   CARD,CARDSAVE\n         B     GETUT1                                              @MLI\n         EJECT\nENDOFJOB XR    R15,R15\n        $GENMSG 1,ERR17                                        -EU-@MLI\n        $GENMSG 2,ERR18                                        -EU-@MLI\n        $GENMSG 3,ERR19                                        -EU-@MLI\n        $GENMSG 4,ERR20                                        -EU-@MLI\nLEAVE   $XRET  CC=(R15)                                            -EU-\n         EJECT ,                                                   -EU-\n*------- SET LONG MESSAGE SPECIFIC TEXT FOR ERROR DIAGNOSE.        -EU-\n         SPACE 1                                                   -EU-\nERR1     MVC   MLOP,=CL8'FUNCTION'                                 -EU-\nERRA     MVC   MLFU,VDEF                                           -EU-\n         B     ERRET                                               -EU-\nERR2     MVC   MLOP,PARM1                                          -EU-\nERRB     MVC   MLFU,EDIT                                           -EU-\n         B     ERRET                                               -EU-\nERR3     MVC   MLOP,=CL8'HELP    '                                 -EU-\n         MVC   MLFU,DSPL                                           -EU-\n         B     ERRET                                               -EU-\nERR4     MVC   MLOP,PARM2                                          -EU-\n         B     ERRB                                                -EU-\nERR5     MVC   MLOP,=CL8'CARD    '                                 -EU-\n         B     ERRA                                                -EU-\nERR6     MVC   MLOP,=CL8'LINENO  '                                 -EU-\n         B     ERRA                                                -EU-\nERR7     MVC   MLOP,=CL8'LLINE   '                                 -EU-\n         B     ERRA                                                -EU-\nERR8     MVC   MLOP,=CL8'ADDLINE '                                 -EU-\n         B     ERRA                                                -EU-\nERR9     MVC   MLSQ,=CL3'(1)'                                      -EU-\nERRC     MVC   MLOP(L'MLOP),PARM3                                  -EU-\n         B     ERRB                                                -EU-\nERR10    MVC   MLSQ,=CL3'(1)'                                      -EU-\nERRD     MVC   MLOP,=CL8'(CARD)  '                                 -EU-\n         B     ERRB                                                -EU-\nERR11    MVC   MLSQ,=CL3'(2)'                                      -EU-\n         B     ERRC                                                -EU-\nERR12    MVC   MLSQ,=CL3'(1)'                                      -EU-\nERRE     MVC   MLOP,=CL8'DELETE  '                                 -EU-\n         B     ERRB                                                -EU-\nERR13    MVC   MLSQ,=CL3'(2)'                                      -EU-\n         B     ERRD                                                -EU-\nERR14    MVC   MLSQ,=CL3'(2)'                                      -EU-\n         B     ERRE                                                -EU-\nERR15    MVC   MLOP,=CL8'LINE_A  '                                 -EU-\n         B     ERRB                                                -EU-\nERR16    MVC   MLSQ,=CL3'(3)'                                      -EU-\n         B     ERRC                                                -EU-\nERR17    MVC   MLSQ,=CL3'(1)'                                      -EU-\nERRF     MVC   MLOP,=CL8'$GENMSG '                                 -EU-\n         B     ERRB                                                -EU-\nERR18    MVC   MLSQ,=CL3'(2)'                                      -EU-\n         B     ERRF                                                -EU-\nERR19    MVC   MLSQ,=CL3'(3)'                                      -EU-\n         B     ERRF                                                -EU-\nERR20    MVC   MLSQ,=CL3'(4)'                                      -EU-\n         B     ERRF                                                -EU-\n         SPACE 1                                                   -EU-\n*------- CALL ISPLINK TO SET SHORT/LONG MESSAGES.                  -EU-\n         SPACE 1                                                   -EU-\nERRET    CVD   R15,WORKD           EDIT RETURN CODE RECEIVED       -EU-\n         MVC   MSRC,=XL4'40202120'                                 -EU-\n         ED    MSRC,WORKD+6                                        -EU-\n         CALL  ISPLINK,(VREP,MS,MSL,MSV),VL                        -EU-\n         LR    R9,R15                                              -EU-\n         CALL  ISPLINK,(VREP,ML,MLL,MLV),VL                        -EU-\n         LTR   R9,R9                                               -EU-\n         BZ    *+L'*+6                                             -EU-\n         SLL   R15,8                                               -EU-\n         OR    R9,R15                                              -EU-\n         CALL  ISPLINK,(SETM,MSGID),VL                             -EU-\n         LTR   R9,R9                                               -EU-\n         BZ    *+L'*+8                                             -EU-\n         SLL   R15,16                                              -EU-\n         OR    R9,R15                                              -EU-\n         LR    R15,R9                                              -EU-\n         B     LEAVE                                               -EU-\n         EJECT\n*------- SUBROUTINE TO FINISH LOAD OF THE INPUT TABLE.\n         SPACE 1\nFINELOAD ST    R10,FINESAVE\n         MVI   FINEON,C'1'\n         L     R7,=AL4(TABLEIN)    DD CARD BEING SCANNED           @MLI\n         LA    R8,1                ONE COLUME AT A TIME            @MLI\n         L     R9,=AL4(TABLEIN+70) LAST COLUMN FOR ', '            @MLI\n         CLC   0(2,R7),=C', '      CONTINUATION INDICATED?         @MLI\n         BE    *+L'*+8             YES, READ IN MORE               @MLI\n         BXLE  R7,R8,*-10          SCAN ENTIRE CARD                @MLI\n         B     FINERTRN            NO, CONTINUE                    @MLI\n         LA    R8,24\n         L     R9,=AL4(TABLEIN+80)\nFINEGET  CLC   LINENO,LLINE        ANY MORE DATA LINES?            @MLI\n         BH    FINERTRN            NO                              @MLI\n         CALL  ISPLINK,(EDIT,LEN28,PARM4),VL                       -EU-\n         LTR   R15,R15             CHECK RETURN CODE               -EU-\n         BNZ   ERR13               NOT ZERO, ERROR                 -EU-\n         CALL  ISPLINK,(EDIT,LEN20,PARM5),VL                       -EU-\n         LTR   R15,R15             CHECK RETURN CODE               -EU-\n         BNZ   ERR14               NOT ZERO, ERROR                 -EU-\n         BAL   R10,CHECKER\n         MVC   CARD(2),=CL2' '\n         MVC   CARD+72(8),=CL8' '\n         MVC   0(80,R9),CARD\n         CLI   MOREDD,C'0'         END OF THIS DD STATEMENT?       @MLI\n         BE    FINERTRN            YES                             @MLI\n         LA    R9,80(R9)\n         BCT   R8,FINEGET\nFINERTRN MVI   FINEON,C'0'\n         L     R10,FINESAVE\n         BR    R10\n         EJECT\n*------- ROUTINE TO CHECK FOR CONTINUATION CARDS OF A DD CARD.\n         SPACE 1\nCHECKER  CLC   CARD(3),=CL3'//*'\n         BE    NOMODD\n         CLC   CARD(2),=CL2'//'\n         BNE   NOMODD\n         CLC   CARD+2(14),INITOUT+2\n         BE    NOMODD\n         LA    R2,CARD+2\n         LA    R3,68               CONTINUATION COULD BE 3-70      @MLI\nCHKLOOP  CLC   0(2,R2),=CL2', '    CONTINUATION                    @MLI\n         BE    MODD                YES, MORE TO THIS DD            @MLI\n         LA    R2,1(R2)\n         BCT   R3,CHKLOOP\nNOMODD   MVI   MOREDD,C'0'\n         BR    R10\nMODD     MVI   MOREDD,C'1'                                         @MLI\n         BR    R10\n         EJECT\n*------  ROUTINE TO SEARCH FOR PARAMETERS IN A DD CARD.\n*        SET R2 TO START OF DD STATEMENT PARAMETER TEXT,\n*        SET R4 TO CORRESPONDING ENTRY IN \"TABLE\".\n         SPACE 1\nSEARCH   LA    R4,TABLE\n         LA    R5,PTBNE\n         MVI   HITSW,C'0'\nSETLEN   MVC   COMPARE+1(L'TBFL),TBFL(R4)\n         CLI   0(R2),C''''\n         BE    QUOTE\nCOMPARE  CLC   0(*-*,R2),TBFN(R4)\n         BE    HIT\nNOPX     NOP   BUMP\n         CLI   0(R2),C' '\n         BE    EODCARD\nBUMP     LA    R4,L'TABLE(R4)\n         BCT   R5,SETLEN\nBUMPC    LA    R2,1(R2)\n         BCT   R3,SEARCH\n         BR    R10\nHIT      MVI   HITSW,C'1'\n         BR    R10\nEODCARD  MVI   EODCSW,C'1'\n         BE    HIT\nQUOTELUP CLI   0(R2),C''''\n         BE    BUMPC\nQUOTE    LA    R2,1(R2)\n         BCT   R3,QUOTELUP\n         B     EODCARD\n         EJECT\n*------- ROUTINE TO MARK INPUT AREA FOR SAVING COMMENTS.\n         SPACE 1\nSAVECMNT XR    R4,R4\n         IC    R4,78(R9)\n         AR    R7,R4\n         LA    R7,1(R7)\n         LR    R4,R3\n         BCT   R4,*+L'*+6\n         CLC   0(0,R7),INITOUT+2\n         EX    R4,*-6\n         BER   R10\n         L     R5,CURENTRY\n         MVI   0(R5),C'C'\n         BR    R10\n         EJECT\n*------- ROUTINE TO SCAN OUTPUT AREA AND INSERT COMMAS WHERE NECESSARY.\n         SPACE 1\nADCOMMAS CLI   79(R4),C'X'\n         BNE   ADCBUMP\n         CLC   15(3,R4),=CL3'DCB'\n         BNE   ADCCONT\n         CLI   ECSW,C'1'\n         BNE   ADCCONT\n         MVI   ADCMVCOM+1,C','\nADCCONT  LR    R5,R4\n         LA    R5,15(R5)\n         XR    R6,R6\n         IC    R6,78(R4)\n         LA    R6,1(R6)\n         AR    R5,R6\n         CLI   0(R5),C','\n         BE    ADCBUMP\n         BCTR  R5,0\n         CLI   0(R5),C','\n         BE    ADCBUMP\n         LA    R5,1(R5)\n         MVI   0(R5),C','\nADCBUMP  LA    R4,80(R4)\n         LR    R7,R5\n         BCT   R3,ADCOMMAS\nADCMVCOM MVI   0(R7),C' '\n         LA    R3,TOUTN\n         L     R4,=AL4(TABLEOUT)\n         MVI   ADCMVCOM+1,C' '\n         BR    R10\n         EJECT\n*------- ROUTINE TO MOVE COMMENTS FROM INPUT AREA TO OUTPUT AREA.\n         SPACE 1\nADCOMNTS L     R5,=AL4(TABLEIN)\n         LA    R6,TINN\nCLIC     CLI   0(R5),C'C'\n         BE    COMPUTE\nADCBUMP2 LA    R5,80(R5)\n         BCT   R6,CLIC\n         B     INCMNTS\nCOMPUTE  LA    R7,71\n         LR    R3,R5\n         LA    R3,1(R3)\nCLIBLANK CLI   0(R3),C' '\n         BNE   CMNTSTRT\n         LA    R3,1(R3)\n         BCT   R7,CLIBLANK\n         MVI   0(R5),C' '\n         B     ADCBUMP2\nCMNTSTRT ST    R3,FULLWORD\n         MVC   1(4,R5),FULLWORD\n         LR    R3,R5\n         LA    R3,71(R3)\nCLIBLNK2 CLI   0(R3),C' '\n         BNE   CMNTEND\n         BCTR  R3,0\n         BCT   R7,CLIBLNK2\n         MVI   0(R5),C' '\n         B     ADCBUMP2\nCMNTEND  STC   R7,5(R5)\n         B     ADCBUMP2\nINCMNTS  L     R5,=AL4(TABLEIN)\n         LA    R6,TINN\nINCSCLIC CLI   0(R5),C'C'\n         BE    INSERT\nINCSBUMP LA    R5,80(R5)\n         BCT   R6,INCSCLIC\n         B     ADCEXIT\nINSERT   MVC   FULLWORD,1(R5)\n         L     R1,FULLWORD\n         MVC   MVCX+1(1),5(R5)\n         MVC   MVCY+1(1),5(R5)\n         LR    R7,R4\n         XR    R15,R15\n         IC    R15,5(R5)\n         SR    R7,R15\n         SH    R7,=H'9'\n         LA    R7,80(R7)\n         CLI   0(R7),C' '\n         BE    MVCX\n         LA    R4,80(R4)\n         B     INSERT\nMVCX     MVC   0(*-*,R7),0(R1)\nMVCY     MVC   0(*-*,R1),INITOUT+2\n         MVC   0(6,R5),INITOUT+2\n         LA    R4,80(R4)\n         B     INCSBUMP\nADCEXIT  LA    R3,TOUTN\n         L     R4,=AL4(TABLEOUT)\n         BR    R10\n         EJECT\n*------- ROUTINE TO CHECK INPUT AREA FOR ANY DATA LEFT.\n         SPACE 1\nLASTLOOK CLI   DCBSW,C'1'\n         BNE   LLEXIT\n         L     R4,=AL4(TABLEIN)\nLLGOON   CLC   0(72,R4),INITOUT+2\n         BNE   CHKITOUT\nLLBUMP   LA    R4,80(R4)\n         BCT   R3,LLGOON\nLLEXIT   LA    R3,TOUTN\n         L     R4,=AL4(TABLEOUT)\n         BR    R10\nCHKITOUT MVC   CARD(80),0(R4)\n         LA    R5,72\n         LA    R6,CARD\nCIOCLI   CLI   0(R6),C' '\n         BNE   CIOCOMP\n         LA    R6,1(R6)\n         BCT   R5,CIOCLI\n         B     LLBUMP\nCIOCOMP  LA    R5,DCBTABL\n         LA    R7,TDCBN            REMOVED WEIRD DCB OPTIONS       @MLI\nMVCCLID  MVC   *+L'*+1(L'TDCBFL),TDCBFL(R5)\n         CLC   TDCBFN(*-*,R5),0(R6)\n         BE    DCBCONT\n         LA    R5,L'DCBTABL(R5)\n         BCT   R7,MVCCLID\n         B     LLBUMP\nDCBCONT  MVC   ECARD(80),INITOUT\n         MVC   ECARD+15(55),0(R6)\n         MVI   ECSW,C'1'\n         B     LLBUMP\n         EJECT\nPUTUT2   CLC   CARD+15(6),=C'SPACE=' SPACE PARAMETER?              @MLI\n         BNE   PUTUT2A             NO                              @MLI\n         L     R1,=AL4(TABLEOUT)   ADDR OF DSN= (MAYBE)            @MLI\n         CLC   15(4,R1),=C'DSN='   DSN PARAMETER?                  @MLI\n         BNE   PUTUT2A             NO, MUST BE TEMP                @MLI\n         CLI   19(R1),C'&&'        TEMP NAME?                      @MLI\n         BE    PUTUT2A             YES, LEAVE THEM                 @MLI\n         CLI   CARD+22,C'0'        QUANTITY IN BLOCKS?             @MLI\n         BNL   PUTUT2A             THAT'S GOOD                     @MLI\n        $NOTEMSG 1                                                 @MLI\n         LA    R7,CARD+21          START OF SPACE SUBPARMS         @MLI\n         LA    R8,1                1 COLUMN AT A TIME              @MLI\n         LA    R9,CARD+71          LAST VALID COLUMN               @MLI\nPUTUT20  CLC   0(5,R7),=C',RLSE'   RLSE PARAMETER?                 @MLI\n         BE    PUTUT2A             GOOD FOR YOU                    @MLI\n         BXLE  R7,R8,PUTUT20       SCAN REST OF INPUT              @MLI\n        $NOTEMSG 4                                                 @MLI\nPUTUT2A  CLC   CARD+15(4),=C'DCB=' DCB PARAMETER?                  @MLI\n         BNE   PUTUT2B             NO                              @MLI\n         L     R1,=AL4(TABLEOUT)   ADDR OF DSN= (MAYBE)            @MLI\n         CLC   15(4,R1),=C'DSN='   DSN PARAMETER?                  @MLI\n         BNE   PUTUT2B             IGNORE BAD DCB FOR DUMMY ETC... @MLI\n         LA    R7,CARD+19          START OF DCB SUBPARAMETERS      @MLI\n         LA    R8,1                1 COLUMN AT A TIME              @MLI\n         LA    R9,CARD+71          LAST VALID COLUMN               @MLI\nPUTUT2AA CLC   0(8,R7),=C'BLKSIZE=' BLKSIZE PARM                   @MLI\n         BE    PUTUT2AB            YES                             @MLI\n         BXLE  R7,R8,PUTUT2AA      SCAN OVER CARD                  @MLI\n         B     PUTUT2B             BLKSIZE= NOT MANDATORY          @MLI\nPUTUT2AB LA    R7,8(0,R7)          SKIP OVER BLKSIZE=              @MLI\n         LR    R1,R7               SAVE START OF BLKSIZE VALUE     @MLI\nPUTUT2AC CLI   0(R7),C','          END OF BLKSIZE VALUE            @MLI\n         BE    PUTUT2AD            YES                             @MLI\n         CLI   0(R7),C' '          BLANK IS THE END ALSO           @MLI\n         BE    PUTUT2AD            YES                             @MLI\n         CLI   0(R7),C')'          OR MAYBE A CLOSE BRACKET        @MLI\n         BE    PUTUT2AD            YES                             @MLI\n         BXLE  R7,R8,PUTUT2AC      SCAN UNTIL END OF BLKSIZE       @MLI\n         B     PUTUT2B             QUIT IF IT LOOKS WEIRD          @MLI\nPUTUT2AD SR    R7,R1               R7 = LENGTH OF BLKSIZE VALUE    @MLI\n         BCTR  R7,0                MINUS 1 FOR EXECUTE             @MLI\n         B     *+L'*+6             SKIP OVER EXECUTED INSTR        @MLI\n         PACK  DOUBLE,0(0,R1)      (EXECUTED)                      @MLI\n         EX    R7,*-6              PACK BLKSIZE VALUE              @MLI\n         CVB   R7,DOUBLE           PICK UP BLOCK SIZE              @MLI\n         CH    R7,=H'788'          COMPARE TO ARBITRARY SIZE   -EU-@MLI\n         BH    PUTUT2B             BIG IS GOOD                     @MLI\n        $NOTEMSG 2                                                 @MLI\nPUTUT2B  CLC   CARD+15(6),=C'DISP=(' DISP PARAMETER?               @MLI\n         BNE   PUTUT2C             NO                              @MLI\n         LA    R7,CARD+21          START OF DCB SUBPARAMETERS      @MLI\n         LA    R8,1                1 COLUMN AT A TIME              @MLI\n         LA    R9,CARD+71          LAST VALID COLUMN               @MLI\nPUTUT2BA CLC   0(11,R7),=C',CATLG,KEEP' BAD DISP                   @MLI\n         BE    PUTUT2BB            YES                             @MLI\n         BXLE  R7,R8,PUTUT2BA      SCAN REMAINDER OF RECORD        @MLI\n         B     PUTUT2C             NO NEWS IS GOOD NEWS            @MLI\nPUTUT2BB $NOTEMSG 3                                                @MLI\n         SPACE 1\n*------- INSERT A REFORMATTED LINE FROM VARIABLE CARD.\n*        ADDLINE IS THE LINE# OF THE LAST REFORMATTED LINE, THAT IS\n*        THE LINE AFTER WHICH TO INSERT NEW STUFF. SINCE THIS LOGIC\n*        MAY HAVE CHANGED THE NUMBER OF LINES IN THE DATASET, LLINE\n*        MUST BE RESET, IF WE SEEM TO BE AT THE BOTTOM.\n         SPACE 1\nPUTUT2C  CALL  ISPLINK,(EDIT,LEN32,PARM6),VL                       -EU-\n         LTR   R15,R15             CHECK RETURN CODE               -EU-\n         BNZ   ERR15               NOT ZERO, ERROR                 -EU-\n         L     R1,ADDLINE          PICK OLD INSERT POINT           @MLI\n         LA    R1,1(0,R1)          PLUS 1                          @MLI\n         ST    R1,ADDLINE          NEXT INSERT AFTER THE LAST      @MLI\n         CLC   ADDLINE,LLINE       DOES IT LOOK LIKE THE BOTTOM    @MLI\n         BLR   R10                 NO, GOBACK                      @MLI\n         CALL  ISPLINK,(EDIT,LEN28,PARM3),VL                       -EU-\n         LTR   R15,R15             CHECK RETURN CODE               -EU-\n         BNZ   ERR16               NOT ZERO, ERROR                 -EU-\n         BR    R10\n         EJECT\n*------- CONSTANTS AND WORK-AREAS.\n         SPACE 1\nFINESAVE DC    F'0'\nOUTADDR  DC    F'0'\nCURENTRY DC    F'0'\nNXTENTRY DC    F'0'\nCOUNT    DC    F'0'\nSTART    DC    F'0'\nSTOP     DC    F'0'\n         SPACE 1\nLINENO   DC    F'0'                 CURRENT LINE NUMBER            @MLI\nLLINE    DC    F'0'                 LAST LINE.                     @MLI\nADDLINE  DC    F'0'                 LINE AFTER WHICH TO INSERT.    @MLI\nFULLWORD DC    F'0'\nDOUBLE   DC    D'0'\nWORKD    DC    D'0'                                                -EU-\n         SPACE 1                                                   -EU-\nFCDE     DC    CL8' '               AREA FOR THE FUNCTION.         -EU-\nEDIT     DC    CL8'ISREDIT '                                       -EU-\nVDEF     DC    CL8'VDEFINE '                                       -EU-\nDSPL     DC    CL8'DISPLAY '                                       -EU-\nVREP     DC    CL8'VREPLACE'                                       -EU-\nSETM     DC    CL8'SETMSG  '                                       -EU-\nMSGID    DC    CL8'ISRZ001 '                                       -EU-\n         SPACE 1                                                   -EU-\nLEN4     DC    F'4'                                                -EU-\nLEN8     DC    F'8'                                                -EU-\nLEN16    DC    F'16'                                               -EU-\nLEN20    DC    F'20'                                               -EU-\nLEN28    DC    F'28'                                               -EU-\nLEN32    DC    F'32'                                               -EU-\nLEN80    DC    F'80'                                               -EU-\nLEN82    DC    F'82'                                               -EU-\nMSL      DC    A(MSVL)                                             -EU-\nMLL      DC    A(MLVL)                                             -EU-\n         SPACE 1                                                   -EU-\nPARM1    DC    CL16'MACRO (FCDE) '                                 -EU-\nPARM2    DC    CL8'RESET   '                                       -EU-\nPARM3    DC    CL28'(LLINE) = LINENUM .ZLAST '                     -EU-\nPARM4    DC    CL28'(CARD) = LINE &&LINENO '                       -EU-\nPARM5    DC    CL20'DELETE &&LINENO '                              -EU-\nPARM6    DC    CL32'LINE_AFTER &&ADDLINE = (CARD) '                -EU-\nTYPEC    DC    CL8'CHAR    '                                       -EU-\nTYPEF    DC    CL8'FIXED   '                                       -EU-\nPNLH     DC    CL8'PAJTJCLF'                                       -EU-\nGNL0     DC    C'(FCDE)'                                           -EU-\nGNL1     DC    C'(CARD)'                                           -EU-\nGNL2     DC    C'(LINENO)'                                         -EU-\nGNL3     DC    C'(LLINE)'                                          -EU-\nGNL4     DC    C'(ADDLINE)'                                        -EU-\nMS       DC    C'(ZEDSMSG)'                                        -EU-\nML       DC    C'(ZEDLMSG)'                                        -EU-\nMSV      DC    C'RC ='                                             -EU-\nMSRC     DC    CL4' '                                              -EU-\nMSVL     EQU   *-MSV                                               -EU-\nMLV      DC    C'-- ERROR AT FUNCTION : '                          -EU-\nMLFU     DC    CL8' ',C' / OPERATION : '                           -EU-\nMLOP     DC    CL8' ',C' --'                                       -EU-\nMLSQ     DC    CL3' '                                              -EU-\nMLVL     EQU   *-MLV                                               -EU-\n         SPACE 1\nPRNT1SW  DC    XL1'00'\nPRNT2SW  DC    XL1'00'\nUT2SW    DC    XL1'00'\nFINEON   DC    C'0'\nMOREDD   DC    C'0'\nHITSW    DC    C'0'\nEODCSW   DC    C'0'\nDCBSW    DC    C'1'\nECSW     DC    C' '\n         SPACE 1\nMSG1     DC    CL82'LINE_AFTER &&ADDLINE = MSGLINE '' SPACE SHOULD BE AX\n               LLOCATED IN BLOCKS.'''                              @MLI\nM1LNO    DC    F'-4',32F'0'                                        @MLI\nMSG2     DC    CL82'LINE_AFTER &&ADDLINE = MSGLINE '' BLOCK SIZE IS TOOX\n                SMALL.'''                                          @MLI\nM2LNO    DC    F'-4',32F'0'                                        @MLI\nMSG3     DC    CL82'LINE_AFTER &&ADDLINE = MSGLINE '' USE DISP=(,CATLG,X\n               DELETE) NOT DISP=(,CATLG,KEEP).'''                  @MLI\nM3LNO    DC    F'-4',32F'0'                                        @MLI\nMSG4     DC    CL82'LINE_AFTER &&ADDLINE = MSGLINE '' THE \"RLSE\" PARAMEX\n               TER SHOULD BE USED.'''                              @MLI\nM4LNO    DC    F'-4',32F'0'                                        @MLI\n         SPACE 1\nINITIN   DC    0XL80'0',80X'FF'\nINITOUT  DC    CL80'// '\n         SPACE 1\nCARD     DC    CL80' '\n         DC    CL40' '\nCARDSAVE DC    CL80' '\nECARD    DC    CL80' '\n         DC    CL40' '             SAFETY FILLER\n         SPACE 1\nSLOTSAVE DC    CL13' '\n         SPACE 1\n         LTORG\n         EJECT\nDCBTABL  DS    0CL9                                                -EU-\nTDCBFL   EQU   0,1                 NAME LENGTH                     -EU-\nTDCBFN   EQU   1,8                 PARM. NAME                      -EU-\n         DC    AL1(4),CL8'BFALN'                                   -EU-\n         DC    AL1(4),CL8'BFTEK'\n         DC    AL1(6),CL8'BLKSIZE'\n         DC    AL1(4),CL8'BUFIN'                                   -EU-\n         DC    AL1(3),CL8'BUFL'                                    -EU-\n         DC    AL1(5),CL8'BUFMAX'                                  -EU-\n         DC    AL1(4),CL8'BUFNO'\n         DC    AL1(5),CL8'BUFOFF'                                  -EU-\n         DC    AL1(5),CL8'BUFOUT'                                  -EU-\n         DC    AL1(6),CL8'BUFSIZE'                                 -EU-\n         DC    AL1(3),CL8'CPRI'                                    -EU-\n         DC    AL1(5),CL8'CYLOFL'                                  -EU-\n         DC    AL1(2),CL8'DEN'\n         DC    AL1(5),CL8'DIAGNS'                                  -EU-\n         DC    AL1(4),CL8'DSORG'\n         DC    AL1(4),CL8'EROPT'\n         DC    AL1(3),CL8'FUNC'\n         DC    AL1(3),CL8'GNCP'                                    -EU-\n         DC    AL1(4),CL8'INTVL'                                   -EU-\n         DC    AL1(6),CL8'IPLTXID'                                 -EU-\n         DC    AL1(5),CL8'KEYLEN'\n         DC    AL1(4),CL8'LIMCT'\n         DC    AL1(4),CL8'LRECL'\n         DC    AL1(3),CL8'MODE'                                    -EU-\n         DC    AL1(2),CL8'NCP'\n         DC    AL1(2),CL8'NTM'                                     -EU-\n         DC    AL1(4),CL8'OPTCD'\n         DC    AL1(2),CL8'PCI'                                     -EU-\n         DC    AL1(4),CL8'PRTSP'                                   -EU-\n         DC    AL1(4),CL8'RECFM'\n         DC    AL1(6),CL8'RESERVE'                                 -EU-\n         DC    AL1(2),CL8'RKP'\n         DC    AL1(4),CL8'STACK'                                   -EU-\n         DC    AL1(5),CL8'THRESH'                                  -EU-\n         DC    AL1(4),CL8'TRTCH'                                   -EU-\nTDCBN    EQU   ((*-DCBTABL)/L'DCBTABL)                             -EU-\n         SPACE 1\nTABLE    DS    0CL25                                           -EU-@MLI\nTBTA     EQU   0,4                 TARGET ADDRESS                  -EU-\nTBFL     EQU   4,1                 NAME LENGTH                     -EU-\nTBFN     EQU   5,20                PARM. NAME                      -EU-\n         DC    AL4(TABLEOUT),AL1(3),CL20'DSN='                     @MLI\n         DC    AL4(TABLEOUT),AL1(6),CL20'DSNAME='                  -EU-\n         DC    AL4(TABLEOUT),AL1(6),CL20'DDNAME='                  -EU-\n         DC    AL4(TABLEOUT),AL1(6),CL20'SYSOUT='                  @MLI\n         DC    AL4(TABLEOUT),AL1(4),CL20' DATA'                    @MLI\n         DC    AL4(TABLEOUT),AL1(1),CL20' *'                       @MLI\n         DC    AL4(TABLEOUT),AL1(5),CL20' DUMMY'                   @MLI\n         DC    AL4(TABLEOUT+80),AL1(4),CL20'DISP='                 @MLI\n         DC    AL4(TABLEOUT+(2*80)),AL1(4),CL20'UNIT='             @MLI\n         DC    AL4(TABLEOUT+(3*80)),AL1(5),CL20'SPACE='            @MLI\n         DC    AL4(TABLEOUT+(4*80)),AL1(5),CL20'LABEL='            @MLI\n         DC    AL4(TABLEOUT+(5*80)),AL1(3),CL20'VOL='              @MLI\n         DC    AL4(TABLEOUT+(5*80)),AL1(6),CL20'VOLUME='           -EU-\n         DC    AL4(TABLEOUT+(6*80)),AL1(3),CL20'AMP='              @MLI\n         DC    AL4(TABLEOUT+(7*80)),AL1(6),CL20'COPIES='           @MLI\n         DC    AL4(TABLEOUT+(8*80)),AL1(3),CL20'FCB='              @MLI\n         DC    AL4(TABLEOUT+(9*80)),AL1(5),CL20'CHARS='            @MLI\n         DC    AL4(TABLEOUT+(10*80)),AL1(5),CL20'BURST='           -EU-\n         DC    AL4(TABLEOUT+(11*80)),AL1(5),CL20'CHKPT='           -EU-\n         DC    AL4(TABLEOUT+(12*80)),AL1(4),CL20'CNTL='            -EU-\n         DC    AL4(TABLEOUT+(13*80)),AL1(4),CL20'DEST='            -EU-\n         DC    AL4(TABLEOUT+(14*80)),AL1(3),CL20'DLM='             -EU-\n         DC    AL4(TABLEOUT+(15*80)),AL1(4),CL20'DSID='            -EU-\n         DC    AL4(TABLEOUT+(16*80)),AL1(5),CL20'FLASH='           -EU-\n         DC    AL4(TABLEOUT+(17*80)),AL1(4),CL20'FREE='            -EU-\n         DC    AL4(TABLEOUT+(18*80)),AL1(4),CL20'HOLD='            -EU-\n         DC    AL4(TABLEOUT+(19*80)),AL1(6),CL20'MODIFY='          -EU-\n         DC    AL4(TABLEOUT+(20*80)),AL1(5),CL20'MSVGP='           -EU-\n         DC    AL4(TABLEOUT+(21*80)),AL1(6),CL20'OUTLIM='          -EU-\n         DC    AL4(TABLEOUT+(22*80)),AL1(6),CL20'OUTPUT='          -EU-\n         DC    AL4(TABLEOUT+(23*80)),AL1(7),CL20'PROTECT='         -EU-\n         DC    AL4(TABLEOUT+(24*80)),AL1(5),CL20'QNAME='           -EU-\n         DC    AL4(TABLEOUT+(25*80)),AL1(6),CL20'SUBSYS='          -EU-\n         DC    AL4(TABLEOUT+(26*80)),AL1(4),CL20'TERM='            -EU-\n         DC    AL4(TABLEOUT+(27*80)),AL1(3),CL20'UCS='             -EU-\n         DC    AL4(TABLEOUT+((TOUTN-1)*80)),AL1(3),CL20'DCB='  -EU-@MLI\nPTBNE    EQU   ((*-TABLE)/L'TABLE)                                 -EU-\n         SPACE 1                                                   -EU-\nTABLEIN  DS    50CL80                                              -EU-\nTINN     EQU   ((*-TABLEIN)/L'TABLEIN)                             -EU-\nTABLEOUT DS    50CL80                                              -EU-\nTOUTN    EQU   ((*-TABLEOUT)/L'TABLEOUT)                           -EU-\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JCLFLOW$": {"ttr": 22792, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x942o\\x00\\x942o\\x16'\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-22T00:00:00", "modifydate": "1994-11-22T16:27:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//JCLFLOW  JOB (........),'INSTALL -JCLFLOW-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=3\n//ASS     EXEC PAJ4AS2,MBR=JCLFLOW\n//LNK     EXEC PAJILKI\n//SYSIN     DD *\n  INCLUDE      SYSISP(ISPLINK)\n  ENTRY   JCLFLOW\n  NAME    JCLFLOW(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JCLFLOW@": {"ttr": 22794, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89 /\\x00\\x89 /\\x11D\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-07-21T00:00:00", "modifydate": "1989-07-21T11:44:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "1   18/07/89\n                                                      JCLFLOW   1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *    JCLFLOW ISPF/PDF EDIT command    * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro allows all the JCL DD statements to be\n  ----------   reformatted with one parameter by line.\n\n  Operation :  starting at the top of the data, all DD statements are\n  -----------  reformatted by beeing copied one parameter at a time\n               (new lines are inserted into the data to contain all\n               the reformatted DD statements). Anything other than\n               part of a DD statement is left as is.\n\n  Command syntax : !JCLFLOW\n  ---------------- !JCLFLOW HELP or H\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTICA$": {"ttr": 22796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x8f\\x00\\x942\\x8f\\x10D\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-24T00:00:00", "modifydate": "1994-11-24T10:44:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//LISTICAT JOB (........),'INSTALL -LISTICAT-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=2M,TIME=1\n/*JOBPARM L=8\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHSVC   DVTYUN                                   *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ4AS3,MBR=LISTICAT\n//LNK     EXEC PAJILKL\n//SYSIN     DD *\n  INCLUDE SYSADD(DVTYUN)\n  ENTRY   LISTICAT\n  NAME    LISTICAT(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTICA@": {"ttr": 22798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x884?\\x00\\x884?\\x12\\x19\\x00\\xc7\\x00\\xc7\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-08T00:00:00", "modifydate": "1988-12-08T12:19:00", "lines": 199, "newlines": 199, "modlines": 0, "user": "SYSPAJA"}, "text": "1   21/04/87\n                                                      LISTICAT  1/4.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *         LIST AN ICF CATALOG         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  CBT origin : extracted from CBT tape 87 FEB, file 425.\n  ------------\n\n  LISTICAT DISCLAIMER - INSTALLATION INSTRUCTIONS.\n\n      This program, developed at CONTINENTAL BANK of CANADA or\n      supplied by other users on a non-restrictive basis, is of\n      general interest and is submitted for unrestricted distribution.\n      The author has, since developing this program, moved to\n      MANUFACTURER'S LIFE INSURANCE. Users are invited to submit\n      suggestions or error documentation to MANULIFE. However, no\n      promise can be made that such suggestions will be implemented\n      or errors corrected. Submit comments to :\n\n               JIM LANE\n               HARDWARE MANAGEMENT\n               MANUFACTURER'S LIFE INSURANCE\n               200 BLOOR ST E.\n               TORONTO, ONTARIO M4W 1E5\n                    Phone : (416)-926-3076\n                    SHARE installation code : MLF\n\n      This program is made available by MLI without charge or\n      consideration. Recipients are free to make this program\n      available to others in like manner. It may not be sold.\n\n\n  NAME         LISTICAT\n\n  FUNCTION     List the contents of an ICF catalog and selected\n               DSCB and VVDS fields.\n\n  DESCRIPTION  The UCBs of all online DASD volumes are located and\n               an attempt is made to allocate SYS1.VVDS.VVOLSER.\n               If this works an ACB and RPL are generated and their\n               addresses are saved in a lookup table.\n               The BCS cluster is opened as a dataset and read\n               sequentially. The BCS records are scanned for cell\n               types and the following cells are listed :\n\n                   NONVSAM             AIX\n                   CLUSTER             PATH\n                   INDEX               GDG BASE\n                   DATA                GDG ENTRY\n1   08/12/88\n                                                      LISTICAT  2/4.\n\n               For NONVSAM entries the FORMAT 1 and, if it exists the\n               FORMAT 3, DSCB is \"OBTAINed\" to determine if the\n               object exists. If it does the LRECL, BLKSIZE and\n               total tracks allocated are extracted.\n               If the object is catalogued to VOLSER \"MIGRAT\" the\n               HSM MIGRATIONCONTROLDATASET is opened (SYSUT2) and\n               used instead of the VTOC.\n\n               For DATA and INDEX entries the VVDS of the volume in\n               question, if available, is scanned to determine the\n               LRECL, BLKSIZE and track allocation of the object.\n\n  ENVIRONMENT  MVS/XA 2.2.0                                        -EU-\n\n  INPUT        The BCS of the ICF catalog to be listed.\n\n  OUTPUT       Output consists of a listing of the catalog.\n\n                    DSNAME - the name of the component being listed.\n                         For GDG entries this is developed into the\n                         format that would be in a FORMAT1 DSCB.\n\n                    TYPE - the type of the cell being listed.\n\n                    VOLUME - the VOLSER of the volume to which the\n                         object is cataloged. Filled in only for\n                         NONVSAM, DATA, INDEX and GDG entries.\n\n                    UNIT - the name of the unit to which the\n                         object is cataloged. Filled in only for\n                         NONVSAM, DATA, INDEX and GDG entries.\n\n                    TRKS - the number of tracks allocated to a DASD\n                         resident object. Left blank for cataloged,\n                         NON-EXISTING and TAPE-RESIDENT objects.\n\n                    BLKSZ - the physical block size of the object.\n                         Left blank for cataloged,\n                         NON-EXISTING and TAPE-RESIDENT objects.\n\n                    LRECL - the logical record length of the object.\n                         Left blank for cataloged,\n                         NON-EXISTING and TAPE-RESIDENT objects.\n\n  CONSIDERATIONS - ABEND CODES :\n\n                    U0014 - BCS cluster failed to OPEN.\n                         Error code in register 2.\n                    U0015 - BCS GET failed.\n                    U0016 - VVDS GET error.                        @122\n                    U0017 - SYSUT1 is not an ICF catalog.          -EU-\n1   21/04/87\n                                                      LISTICAT  3/4.\n\n  PARAMETERS   PARM=DUMP produces a HEX-translated listing of\n                         BCS and VVDS cells.\n\n  EXECUTION    DDNAMEs\n\n               STEPCAT  defines the ICF catalog to be listed.\n               SYSUT1   defines the ICF catalog to be listed.\n               SYSUT2   defines the HSM MIGRATIONCONTROLDATASET.\n                        If you don't have HSM this can be left out.\n               SYSPRINT defines the output listing data set.\n               SYSLIST  defines the messages listing data set.\n\n  EXAMPLE      //LCAT   EXEC  PGM=LISTICAT\n               //STEPCAT  DD  DSN=ICF.CATALOG,DISP=OLD\n               //SYSUT1   DD  DSN=ICF.CATALOG,DISP=OLD\n               //SYSUT2   DD  DSN=HSM.MCDS,DISP=OLD\n               //SYSPRINT DD  SYSOUT=*\n               //SYSLIST  DD  SYSOUT=*\n               //SYSUDUMP DD  SYSOUT=*\n\n  AUTHOR       This portions of this program having to do with\n               passing the BCS and VVDS's were written by J. LANE\n               at CBOC. A lot of the rest of the code has been\n               borrowed from various sources, mostly off the CBT\n               tape. If something in here looks like you wrote it,\n               you probably did.\n\n\n  NOTES  A program must be APF-authorized in MVS to open a catalog\n         as a dataset. I do this with a user SVC. If you have such a\n         thing, change from SVC 232 to whatever number you have.\n\n         At the bank I was getting password prompts when I opened the\n         catalog. Rather than figure out why I turned on the\n         \"NO-PASSWORD\" bit in the JSCB. This may not be necessary in\n         your environment and, if so, you can take out the logic.\n\n         The HEX-DUMP listing can be a security exposure as written\n         because it prints out the \"SECURITY\" cell, if present, which\n         contains the passwords for protected objects. Security\n         officers may not take that in the nicest sort of way.\n\n         No attempt is made to discern whether SYSUT1 is actually an\n         ICF catalog or not. If, inadvertently, it isn't this code\n         will probably loop.\n\n         I wrote this code in the winter of 1983-1984 when CBOC was\n         converting to ICF catalogs. Since the conversion went more\n         smoothly than it might have done, I never had a broken\n         catalog to work with. Therefore, this code assumes a\n         validly structured catalog. I make no guarantees what might\n         happen otherwise.\n1   24/04/87\n                                                      LISTICAT  4/4.\n\n  CHANGE ACTIVITY SUMMARY :\n\n     @122    - Added extra diagnostic checking and messages to handle\n               problem reported by R. DIETES of H.E. BUTT GROCERY CO.\n               Situation was the case where the BCS info exists, the\n               VVDS exists but it doesn't contain anything to match\n               the dataset found in the BCS.\n               Fix was to sense END OF FILE reached while scanning\n               the VVDS for the VVR of a cluster component, produce\n               message about VVR not found when expected and pass a\n               return code to the caller.\n             - Add 3480 device type support.\n             - Test HSM logic with DFHSM 2.1.0\n             - Close MCDS at EOJ if it was opened.\n     @121    - Was assuming an 8-character catalog name for the\n               title line.\n     @120    - Changes for MVS/XA. Use scan routine instead of\n               UCB half-word lookup table.\n             - LENGTHEN PRINTLINE area used for printing totals to\n               correct formatting problem.\n             - Break out some parts of the code into copy members to\n               make it more editable.\n             - An RPL was not being created prior to I/O in the\n               HEX-PRINT part of the logic.\n             - Add cell type counting to HEX logic.\n     24APR25 - Bugs found after author's move to MANULIFE.\n             . 3380 missing from device type table.\n             . dont be so sure I know how many tracks there are in a\n               cylinder. At CBOC I had only 3375's.\n     24APR87 - Replaced the device code name table by routine     -EU-\n               DVTYUN which retrieves dynamically the unit name   -EU-\n               from the device type, and get through the CVTZDTAB -EU-\n               the number of tracks per cylinder info.            -EU-\n             . Test if opened SYSUT1 is an ICF catalog.           -EU-\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTICAT": {"ttr": 23043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x885\\x0f\\x00\\x885\\x0f\\x11)\\x05R\\x05R\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-15T00:00:00", "modifydate": "1988-12-15T11:29:00", "lines": 1362, "newlines": 1362, "modlines": 0, "user": "SYSPAJA"}, "text": "LICF     TITLE 'LISTICAT - LIST AN ICF CATALOG.'                   -EU-\n         PRINT OFF                                                 -EU-\n         COPY  LISTICMC                                            -EU-\n         PRINT ON                                                  -EU-\n         SPACE 2                                                   -EU-\nLISTICAT START 0                                                   -EU-\n         SPACE 2                                                   -EU-\n         COPY  LISTICDC                                            -EU-\n         SPACE 2                                                   -EU-\n&NAME    SETC  'LISTICAT'\n&VERSION SETC  '1.2.2'\n         EJECT ,                                                   -EU-\n         $REGS\n         EJECT ,                                                   -EU-\n*        LIST AN ICF CATALOG.                                      -EU-\n         SPACE 1                                                   -EU-\n         $PROLOG R10,R11,R12                                       -EU-\n         L     R4,=V(DATASECT)     COMMON DATA AREA\n         USING DATASECT,R4\n         L     R1,0(0,R1)          GET PARM POINTER\n         LH    R3,0(0,R1)          GET PARM SIZE\n         LTR   R3,R3               ANY PARM GIVEN?\n         BZ    NOPARM              NO, ASSUME LIST\n         CLC   2(4,R1),=C'DUMP'    HEX LISTING WANTED\n         BNE   NOPARM              NO, ASSUME LIST\n         B     HEXPRINT            DO A HEX LISTING\nNOPARM   DS    0H\n        $MESSAGE 1                                                 @122\n         XPROPEN PWA,                                                  X\n               PAGELEN=PAGELEN,                                        X\n               DDNAME=SYSPRINT     OPEN LISTING FILE.\n         LTR   R15,R15             DID SYSPRINT OPEN?\n         BNZ   EODICAT             IF NOT, NO REPORT.\n         BAS   R9,ALLVVDS          ALLOCATE ALL VVDS'S\n         BAS   R9,OPICAT           OPEN REQUESTED CATALOG (SYSUT1) -EU-\n         BAS   R9,GENRPL           GENERATE RPL FOR BCS.           @120\n         EJECT ,                                                   -EU-\n*        READ BCS RECORDS AND SCAN FOR CELL TYPES.                 -EU-\n         SPACE 1                                                   -EU-\nGETNEXT  L     R1,RPLICAT          PICK UP RPL ADDRESS.\n         GET   RPL=(1)             READ A BCS RECORD.\n         AP    BCSGETS,ONE         KEEP TRACK OF GETS ISSUED.\n         LTR   R15,R15             RECORD READ OK?\n         BZ    GETOK               GO PROCESS IT.\n         ABEND 15,DUMP             TOO BAD!\nGETOK    L     R3,BUFPTR           ADDR OF CATALOG RECORD\n         L     R1,RPLICAT          ADDR OF BCS RPL.\n         L     R1,48(0,R1)         LENGTH OF RECORD READ\n         AR    R1,R3               POINT TO END OF CATALOG RECORD\n         ST    R1,ENDBCS           SAVE END OF RECORD.\n         LA    R3,2(,R3)           SKIP OVER PREFIX\nNEXTCELL CLI   2(R3),C'A'          A = NONVSAM\n         BE    NONVSAM\n         CLI   2(R3),C'C'          C = CLUSTER\n         BE    CLUSTER\n         CLI   2(R3),C'D'          D = DATA\n         BE    DATA\n         CLI   2(R3),C'I'          I = INDEX\n         BE    INDEX\n         CLI   2(R3),C'B'          B = GDG BASE\n         BE    GDGBASE\n         CLI   2(R3),C'H'          H = GDG ENTRY\n         BE    GDGENT\n         CLI   2(R3),C'G'          G = ALTERNATE INDEX\n         BE    AIX\n         CLI   2(R3),C'R'          R = PATH\n         BE    PATH\nENDCELL  XC    BLKSIZE,BLKSIZE     RESET BLKSIZE\n         XC    LRECL,LRECL         RESET LRECL\n         XC    TRACKS,TRACKS       RESET TRACKS.\n         XR    R1,R1               CLEAR REGISTER.\n         ICM   R1,3,0(R3)          PICK UP CELL LENGTH\n         AR    R3,R1               POINT TO NEXT CELL\n         C     R3,ENDBCS           ANY MORE CELLS IN THIS RECORD?\n         BL    NEXTCELL            YES, KEEP GOING\n         B     GETNEXT             READ ANOTHER RECORD.\nEODICAT  EQU   *                   LAST BCS RECORD READ.\n         CLOSE ACBICAT\n         CLI   MCDSOPEN,255        DID WE OPEN THE MCDS?           @122\n         BNE   EODICAT1            NO.                             @122\n         CLOSE ACBMCDS             IF OPEN, CLOSE IT.              @122\nEODICAT1 BAS   R9,COUNTS           PRINT THE STATS.                @122\n         XPRCLOSE  PWA             CLOSE THE PRINT FILE.\n        $MESSAGE 0                                                 @122\n         $EPILOG ,                 AND GO HOME.\n         EJECT ,                                                   -EU-\n*- - - - LIST A NONVSAM RECORD.                                    -EU-\n         SPACE 1                                                   -EU-\n         USING NVNC,R3\nNONVSAM  AP    CNTNVSAM,ONE        COUNT OFF A NONVSAM.\n         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.\n         BNE   NONVSAM1            NO.\n         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.\n         MVI   BASESW,0            SWITCH OFF.\nNONVSAM1 MVC   L1DSNAME,NVNAME     SETUP DSNAME\n         MVC   L1TYPE,=C'NONVSAM'  SAY WHAT TYPE IT IS.\n         BAS   R9,SETCREDT         FORMAT CREATION DATE.\n         ICM   R0,1,=XL1'04'       VOLUME CELL TO BE FOUND.\n         BAS   R9,FINDBCS          SO GO LOOK FOR IT.\n         DROP  R3\n         USING VOLCELL,R3\n         MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER\n         LA    R5,VOLDEVTP         DEVICE TYPE                     -EU-\n        $DVTYUN (R5),L1UNIT        GET UNIT NAME                   -EU-\n         LTR   R15,R15             OK?                             -EU-\n         BZ    NONVSAM3            YES                             -EU-\n         MVC   L1UNIT(4),=C'????'  NO, CALL IT ???? (NOT FOUND)    -EU-\n         B     NONVSAM5                                            -EU-\nNONVSAM3 XR    R5,R5                                               -EU-\n         TM    VOLDEVTP+2,X'20'    IS IT A DASD DEVICE?            -EU-\n         BZ    NONVSAM4            NO                              -EU-\n         L     R1,CVTPTR           GET CVT ADDRESS                 -EU-\n         USING CVT,R1                                              -EU-\n         L     R1,CVTZDTAB         DEV. CONSTANT TABLE ADDRESS     -EU-\n         DROP  R1                                                  -EU-\n         XR    R14,R14                                             -EU-\n         LR    R15,R14                                             -EU-\n         IC    R14,VOLDEVTP+3      GET DEVICE TYPE                 -EU-\n         IC    R15,0(R14,R1)       GET DISPLACEMENT OF TABLE       -EU-\n         LA    R15,0(R15,R1)       COMPUTE ADDRESS OF TABLE        -EU-\n         CLR   R15,R1                                              -EU-\n         BE    NONVSAM4            DEVICE NOT IN 'IECZDTAB' TABLE  -EU-\n         ICM   R5,B'0011',2(R15)   NUMBER OF TRACKS PER CYLINDER   -EU-\nNONVSAM4 ST    R5,TRKCYL           SAVE FOR LATER CALCULATION      -EU-\n         TM    VOLDEVTP+2,X'20'    IS IT A DASD DEVICE?            -EU-\n         BZ    NONVSAM5            IF NOT, NO VTOC TO SEARCH.\n         BAS   R9,VTOC             GET DSCB FIELDS\nNONVSAM5 CLC   L1VOLUME,=C'MIGRAT' IS IT MIGRATED BY HSM\n         BNE   NONVSAM6            IF NOT, SKIP MCDS CHECK.\n         BAS   R9,CHKHSM           SETUP MCDS FIELDS.\nNONVSAM6 L     R1,LRECL            PICK UP LRECL VALUE.\n         CVD   R1,WORK             CONVERT LRECL TO PACKED\n         EDIT  L1LRECL,DWK3,ZZZZZ  FORMAT IT NICELY\n         L     R1,BLKSIZE          PICK UP BLOCK SIZE.\n         CVD   R1,WORK             CONVERT BLKSIZE TO PACKED\n         EDIT  L1BLKSIZ,DWK3,ZZZZZ FORMAT IT NICELY\n         L     R1,TRACKS           PICK UP ALLOCATED TRACKS\n         CVD   R1,WORK             CONVERT TRACKS TO PACKED\n         EDIT  L1TRACKS,DWK4,ZZZZZZZ    FORMAT IT NICELY.\n         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1\n         BAS   R9,PRINT            PRINT LINE DESCRIBING THIS DATASET.\n         B     ENDCELL             PROCESS NEXT BCS CELL.\n         DROP  R3\n         EJECT ,                                                   -EU-\n*- - - - LIST A CLUSTER RECORD.                                    -EU-\n         SPACE 1                                                   -EU-\n         USING VCNC,R3\nCLUSTER  AP    CNTCLUST,ONE        COUNT A CLUSTER.\n         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.\n         BNE   CLUSTER1            NO.\n         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.\n         MVI   BASESW,0            SWITCH OFF.\nCLUSTER1 MVC   L1DSNAME,CLNAME     SETUP CLUSTER NAME.\n         MVC   L1TYPE,=C'CLUSTER'  CALL IT A CLUSTER.\n         CLI   FIRST,0             FIRST CLUSTER CELL?\n         BNE   NOTCL00             NO\n         MVI   FIRST,255           THAT WAS THE ONE.\n         ST    R3,SAVECL           FIRST CLUSTER HAS BCS NAME.\nGETBCSD  XR    R1,R1               CLEAR A FEW BYTES.\n         ICM   R1,3,0(R3)          PICK UP CELL LENGTH\n         AR    R3,R1               POINT TO NEXT CELL\n         CLI   2(R3),C'D'          IS IT A DATA CELL?\n         BNE   GETBCSD             KEEP ON LOOKING.\n         DROP  R3\n**-EU-   USING DINC,R3\n**-EU-   XR    R1,R1                                               @121\n**-EU-   IC    R1,DIDKEYLN         GET LENGTH OF CATALOG NAME.     @121\n**-EU-   B     *+10                                                @121\n**-EU-   MVC   CATNAME(0),DIDKEY   SETUP CATNAME IN HEADING.       @121\n**-EU-   EX    R1,*-6                                              @121\n         BAS   R9,SETHEAD          DEFINE REPORT HEADING.\n         L     R3,SAVECL           RESTORE CELL ADDR TO CLUSTER.\nNOTCL00  BAS   R9,SETCREDT         FORMAT CREATION DATE.\n         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1\n         BAS   R9,PRINT            PRINT LINE.\n         B     ENDCELL             PROCESS NEXT BCS CELL.\n**-EU-   DROP  R3\n         USING DINC,R3\nDATA     MVC   L1TYPE,=CL7'DATA'   DATA CELL (PARDON THE EXPRESSION)\n         AP    CNTDATA,ONE         COUNT IT.\n         B     SKIPDATA            GOTO COMMON FORMATTING LOGIC.\nINDEX    MVC   L1TYPE,=CL7'INDEX'  CALL IT AN INDEX\n         AP    CNTINDEX,ONE        AND COUNT IT.\nSKIPDATA XR    R1,R1               CLEAR A REGISTER.\n         IC    R1,DIDKEYLN         LENGTH OF INDEX/DATA NAME\n         EX    R1,DIDMOVE          MOVE COMPONENT NAME FOR PRINT\n         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.\n         BNE   CLUSTER2            NO.\n         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.\n         MVI   BASESW,0            SWITCH OFF.\nCLUSTER2 BAS   R9,SETCREDT         FORMAT CREATION DATE.\n         ICM   R0,1,=XL1'04'       VOLUME CELL TO BE FOUND.\n         BAS   R9,FINDBCS          SO GO LOOK FOR IT.\n         DROP  R3\n         USING VOLCELL,R3\n         MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER\n         LA    R5,VOLDEVTP         DEVICE TYPE                     -EU-\n        $DVTYUN (R5),L1UNIT        GET UNIT NAME                   -EU-\n         LTR   R15,R15             OK?                             -EU-\n         BZ    CLUSTER3            YES                             -EU-\n         MVC   L1UNIT(4),=C'????'  NO, CALL IT ???? (NOT FOUND)    -EU-\n         B     CLUSTER5                                            -EU-\nCLUSTER3 XR    R5,R5                                               -EU-\n         TM    VOLDEVTP+2,X'20'    IS IT A DASD DEVICE?            -EU-\n         BZ    CLUSTER4            NO                              -EU-\n         L     R1,CVTPTR           GET CVT ADDRESS                 -EU-\n         USING CVT,R1                                              -EU-\n         L     R1,CVTZDTAB         DEV. CONSTANT TABLE ADDRESS     -EU-\n         DROP  R1                                                  -EU-\n         XR    R14,R14                                             -EU-\n         LR    R15,R14                                             -EU-\n         IC    R14,VOLDEVTP+3      GET DEVICE TYPE                 -EU-\n         IC    R15,0(R14,R1)       GET DISPLACEMENT OF TABLE       -EU-\n         LA    R15,0(R15,R1)       COMPUTE ADDRESS OF TABLE        -EU-\n         CLR   R15,R1                                              -EU-\n         BE    CLUSTER4            DEVICE NOT IN 'IECZDTAB' TABLE  -EU-\n         ICM   R5,B'0011',2(R15)   NUMBER OF TRACKS PER CYLINDER   -EU-\nCLUSTER4 ST    R5,TRKCYL           SAVE FOR LATER CALCULATION      -EU-\nCLUSTER5 MVC   RBASAVE,VOLVVRBA    SAVE RBA OF CI CONTAINING VVR CELL.\n         DROP  R3\n         L     R5,VVDSTAD          GET VVDSTAB START ADDR\n         USING VVDSTAB,R5\nCLUSTER8 CLI   VVDSVOL,255         LAST ENTRY?\n         BE    CLUSTER7            YES, OH WELL.\n         CLC   VVDSVOL,L1VOLUME    IS THIS THE VVDS?\n         BNE   CLUSTER6            NO, TRY AGAIN\n         ICM   R1,15,RBASAVE       GET VVR RBA\n         STCM  R1,15,VVDSARG       INSERT INTO ARG FIELD FOR RPL\n         ICM   R8,15,VVDSRPL       PICK UP RPL ADDR\n         POINT RPL=(R8)            POSITION TO DESIRED RECORD\n         GET   RPL=(R8)            READ IN RECORD\n         AP    VVDSGETS,ONE        KEEP A COUNT.\n         LTR   R15,R15             RECORD READ OK?\n         L     R6,VVDSBUF          ADDR OF CATALOG RECORD\n         L     R1,VVDSRPL          GET ADDR OF RPL\n         L     R1,48(0,R1)         LENGTH OF RECORD READ\n         AR    R1,R6               POINT TO END OF CATALOG RECORD\n         ST    R1,ENDVVD           SAVE END OF RECORD\n         LA    R6,2(,R6)           SKIP OVER PREFIX\n         BAS   R9,VVDS             PROCESS VVDS FIELDS.\n         C     R15,=F'8'           DID WE GET THEM?                @122\n         BNE   CLUSTER6            YES.                            @122\n        $MESSAGE 4,DATA=L1DSNAME                                   @122\n         B     CLUSTER9            PRINT WHAT WE GOT.              @122\nCLUSTER6 LA    R5,VVDSTLEN(0,R5)   NEXT ENTRY\n         B     CLUSTER8            TRY NEXT VVDS\n         DROP  R5\nCLUSTER7 L     R1,LRECL            PICK UP LOGICAL RECORD LENGTH.\n         CVD   R1,WORK             CONVERT LRECL TO PACKED\n         EDIT  L1LRECL,DWK3,ZZZZZ  FORMAT IT NICELY\n         L     R1,BLKSIZE          GET PHYSICAL BLOCK LENGTH.\n         CVD   R1,WORK             CONVERT BLKSIZE TO PACKED\n         EDIT  L1BLKSIZ,DWK3,ZZZZZ FORMAT IT NICELY.\n         L     R1,TRACKS           PICK UP ALLOCATED TRACKS.\n         CVD   R1,WORK             CONVERT TRACKS TO PACKED\n         EDIT  L1TRACKS,DWK4,ZZZZZZZ    FORMAT IT NICELY.\nCLUSTER9 LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1    @122\n         BAS   R9,PRINT            PRINT LINE.\n         B     ENDCELL             PROCESS NEXT BCS CELL.\n         USING DINC,R3\nDIDMOVE  MVC   L1DSNAME(0),DIDKEY  -> (EXECUTED) <-\n         DROP  R3\n         EJECT ,                                                   -EU-\n*- - - - LIST AN ALTERNATE INDEX RECORD.                           -EU-\n         SPACE 1                                                   -EU-\n         USING ANC,R3\nAIX      AP    CNTAIX,ONE          COUNT AN AIX ENTRY.\n         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.\n         BNE   AIX0                NO.\n         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.\n         MVI   BASESW,0            SWITCH OFF.\nAIX0     MVC   L1TYPE,=CL7'AIX'    CALL IT AN AIX.\n         XR    R1,R1               CLEAR A REGISTER.\n         ICM   R1,1,AIXKEYLN       PICK UP AIX NAME LENGTH\n         B     AIX1                BRANCH AROUND EXECUTED INSTRUCTION.\n         MVC   L1DSNAME(0),AIXKEY  EXECUTED\nAIX1     EX    R1,*-6              MOVE AIX NAME TO PRINT LINE.\n         HEX   RPTLINE1+75,                                            X\n               ANC,7,HEXTAB=TRHEX  HEX TRANSLATE AIX CELL CONTENTS.\n         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1\n         BAS   R9,PRINT            PRINT LINE.\n         B     ENDCELL             PROCESS NEXT CELL.\n         SPACE 2                                                   -EU-\n*- - - - LIST A PATH RECORD.                                       -EU-\n         SPACE 1                                                   -EU-\n         USING PNC,R3\nPATH     AP    CNTPATH,ONE         COUNT A PATH CELL.\n         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.\n         BNE   PATH0               NO.\n         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.\n         MVI   BASESW,0            SWITCH OFF.\nPATH0    MVC   L1TYPE,=CL7'PATH'   CALL IT A PATH.\n         XR    R1,R1               CLEAR A REGISTER.\n         ICM   R1,1,PATHKYLN       PICK UP PATH NAME LENGTH\n         B     PATH1               BRANCH AROUND EXECUTED INSTRUCTION.\n         MVC   L1DSNAME(0),PATHNAME  EXECUTED\nPATH1    EX    R1,*-6              MOVE PATH NAME TO PRINT LINE.\n         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1\n         BAS   R9,PRINT            PRINT LINE.\n         B     ENDCELL             PROCESS NEXT CELL.\n         EJECT ,                                                   -EU-\n*- - - - LIST A GDG BASE OR GDG ENTRY RECORD.                      -EU-\n         SPACE 1                                                   -EU-\n         USING GDGNC,R3\nGDGBASE  AP    CNTGDGB,ONE         COUNT A BASE.\n         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.\n         BNE   GDGBASE1            NO.\n         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.\nGDGBASE1 MVI   BASESW,255          IDENTIFY GDGBASE.\n         MVC   L1TYPE,=CL7'GDGBASE'  IDENTIFY RECORD TYPE\n         MVC   L1DSNAME,GDGNAME    SETUP GDGNAME.\n         MVC   GDGSAVE,GDGNAME     SAVE GDGNAME.\n         BAS   R9,SETCREDT         FORMAT CREATION DATE.\n         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1\n         BAS   R9,PRINT            PRINT LINE.\n         B     ENDCELL             PROCESS NEXT CELL.\n         DROP  R3\n         USING GDSNC,R3\nGDGENT   AP    CNTGDGE,ONE         COUNT IT.\n         CLI   BASESW,255          PRECEEDED BY GDGBASE?\n         BNE   GDGENT0             ???????\n         MVI   BASESW,0            SWITCH OFF\nGDGENT0  MVC   L1TYPE,=CL7'GDG ENT'  IDENTIFY RECORD TYPE\n         MVC   GDGWORK,GDGSAVE     START WITH BASE NAME.\n         LA    R1,GDGWORK          GET ADDRESS OF BASE NAME\n         LA    R8,44               44 BYTES AT MOST\nGDGENT1  CLI   0(R1),C' '          SCAN FOR A BLANK\n         BE    GDGENT2             YES.\n         LA    R1,1(0,R1)          TRY NEXT CHARACTER.\n         BCT   R8,GDGENT1          KEEP LOOKING\nGDGENT2  XR    R8,R8               CLEAR A REGISTER.\n         ICM   R8,3,GDSGENO        PICK UP GENERATION NUMBER.\n         CVD   R8,GWORD            PACK IT.\n         UNPK  2(4,R1),GWK3        UNPACK GENERATION NUMBER.\n         OI    5(R1),X'F0'         FIX SIGN\n         XR    R8,R8               CLEAR A REGISTER.\n         ICM   R8,1,GDSVERNO       PICK UP VERSION NUMBER.\n         CVD   R8,GWORD            PACK IT.\n         UNPK  7(2,R1),GWK2        UNPACK VERSION NUMBER.\n         OI    8(R1),X'F0'         FIX SIGN\n         MVC   0(2,R1),=C'.G'      SET G0000\n         MVI   6(R1),C'V'          G0000V00\n         MVC   L1DSNAME,GDGWORK    MOVE IN DEVELOPED NAME\n         BAS   R9,SETCREDT         FORMAT CREATION DATE.\n         ICM   R0,1,=XL1'04'       VOLUME CELL TO BE FOUND.\n         BAS   R9,FINDBCS          SO GO LOOK FOR IT.\n         DROP  R3\n         USING VOLCELL,R3\n         MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER\n         LA    R5,VOLDEVTP         DEVICE TYPE                     -EU-\n        $DVTYUN (R5),L1UNIT        GET UNIT NAME                   -EU-\n         LTR   R15,R15             OK?                             -EU-\n         BZ    GDGENT5             YES                             -EU-\n         MVC   L1UNIT(4),=C'????'  NO, CALL IT ???? (NOT FOUND)    -EU-\n         B     GDGENT7                                             -EU-\nGDGENT5  XR    R5,R5                                               -EU-\n         TM    VOLDEVTP+2,X'20'    IS IT A DASD DEVICE?            -EU-\n         BZ    GDGENT6             NO                              -EU-\n         L     R1,CVTPTR           GET CVT ADDRESS                 -EU-\n         USING CVT,R1                                              -EU-\n         L     R1,CVTZDTAB         DEV. CONSTANT TABLE ADDRESS     -EU-\n         DROP  R1                                                  -EU-\n         XR    R14,R14                                             -EU-\n         LR    R15,R14                                             -EU-\n         IC    R14,VOLDEVTP+3      GET DEVICE TYPE                 -EU-\n         IC    R15,0(R14,R1)       GET DISPLACEMENT OF TABLE       -EU-\n         LA    R15,0(R15,R1)       COMPUTE ADDRESS OF TABLE        -EU-\n         CLR   R15,R1                                              -EU-\n         BE    GDGENT6             DEVICE NOT IN 'IECZDTAB' TABLE  -EU-\n         ICM   R5,B'0011',2(R15)   NUMBER OF TRACKS PER CYLINDER   -EU-\nGDGENT6  ST    R5,TRKCYL           SAVE FOR LATER CALCULATION      -EU-\n         TM    VOLDEVTP+2,X'20'    IS IT A DASD DEVICE?            -EU-\n         BZ    GDGENT7             IF NOT, NO VTOC TO SEARCH.\n         BAS   R9,VTOC             GET DSCB FIELDS\nGDGENT7  CLC   L1VOLUME,=C'MIGRAT'  IS IT MIGRATED BY HSM?\n         BE    GDGENT8             IF SO, THAT'S IT.\n         L     R1,LRECL            PICK UP LOGICAL RECORD LENGTH\n         CVD   R1,WORK             CONVERT LRECL TO PACKED\n         EDIT  L1LRECL,DWK3,ZZZZZ  FORMAT IT NICELY\n         L     R1,BLKSIZE          PICK UP BLOCK SIZE.\n         CVD   R1,WORK             CONVERT BLKSIZE TO PACKED\n         EDIT  L1BLKSIZ,DWK3,ZZZZZ FORMAT WITH ZERO SUPPRESSION.\n         L     R1,TRACKS           PICK UP ALLOCATED TRACKS.\n         CVD   R1,WORK             CONVERT TRACKS TO PACKED\n         EDIT  L1TRACKS,DWK4,ZZZZZZZ    MAKE IT PRINTABLE.\n         DROP  R3\nGDGENT8  LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1\n         BAS   R9,PRINT            PRINT LINE.\n         B     ENDCELL             PROCESS NEXT BCS CELL.\n         EJECT ,                                                   -EU-\n*        READ FORMAT1 DSCB AND SETUP DCB AND SPACE INFO.           -EU-\n         SPACE 1                                                   -EU-\n* THIS CODE USES OBTAIN TO READ IN THE FORMAT 1 DSCB AND A FORMAT 3\n* DSCB IF ONE EXISTS. INFORMATION IS EXTRACTED AND PLACED INTO THE\n* FIELDS : LRECL, BLKSIZE AND TRACKS.\n         SPACE 1                                                   -EU-\nVTOC     $IN ,\n         XC    BLKSIZE,BLKSIZE     RESET BLKSIZE\n         XC    LRECL,LRECL         RESET LRECL\n         XC    TRACKS,TRACKS       RESET TRACKS.\n         MVC   CAMVOL,L1VOLUME     USE VOLSER FROM BCS VOLCELL.\n         CLC   CAMVOL,=C'MIGRAT'   IS IT MIGRATED?\n         BE    VTOC99              IF SO, WHY BOTHER.\n         MVC   CAMDSN,L1DSNAME     USE DSNAME FROM BCS.\n         OBTAIN  SEARCH            READ FORMAT 1 DSCB BY DSNAME.\n         ST    R15,OBTAINRC        SAVE OBTAIN RETURN CODE.\n         LTR   R15,R15             WAS IT THERE?\n         BZ    VTOC1               YES.\n         AP    CNTNF,ONE           OTHERWISE COUNT AN ORPHAN.\n         B     VTOC99              AND LEAVE IT BLANK.\nVTOC1    XR    R1,R1               CLEAR REGISTER 1.\n         ICM   R1,3,FORMAT1+42     PICK UP BLKSIZE\n         ST    R1,BLKSIZE          AND SAVE FOR PRINT OUT.\n         ICM   R1,3,FORMAT1+44     PICK UP LRECL\n         ST    R1,LRECL            AND SAVE FOR PRINT OUT.\n         MVC   SV1EXT1(30),FORMAT1+61  SAVE EXTENTS 1 TO 3\n         CLC   FORMAT1+91,=5X'00'  IS THERE A FORMAT 3?\n         BE    VTOC2A              NO, SKIP IT.\n         MVC   CCHHR3,FORMAT1+91   POINTER TO FORMAT 3 DSCB.\n         OBTAIN  F3CAMLST          READ FORMAT 3 BY DISK ADDRESS.\n         LTR   R15,R15             DID WE GET IT?\n         BNZ   VTOC2A              OH WELL\n         MVC   SV3EXT4(40),FORMAT3+4  EXTENTS 4,5,6 AND 7.\n         MVC   SV3EXT8(90),FORMAT3+45  EXTENTS 8 TO 16.\nVTOC2A   XR    R15,R15             ZERO LOOP REGISTER\n         XR    R7,R7               ZERO INDEX REGISTER\n         XR    R8,R8               ZERO COUNT OF TRACKS ALLOCATED.\n         IC    R15,FORMAT1+15      GET NUMBER OF EXTENTS\n         LTR   R15,R15             ARE THERE ANY EXTENTS?\n         BZ    VTOC5A              SKIP IT IF ZERO EXTENT\nVTOC5B   EX    R0,EXTLIST(R7)      GET AN EXTENT ADDR IN R5.\n         CLI   0(R5),X'00'         IS THIS AN ACTIVE EXTENT?\n         BE    VTOC5C              IF NOT, SKIP IT.\n         XR    R0,R0               CLEAR A REGISTER.\n         ICM   R0,3,2(R5)          STARTING CC\n         XR    R14,R14             CLEAR A REGISTER.\n         L     R14,TRKCYL          TRACKS PER CYLINDER\n         SRDA  R0,32               SETUP FOR MULTIPLY.\n         MR    R0,R14              R1 = TRKS IN FULL CYLINDERS.\n         ICM   R14,3,4(R5)         STARTING TT\n         AR    R1,R14              STARTING RELATIVE TRACK.\n         ST    R1,STARTTRK         SAVE IT.\n         XR    R0,R0               CLEAR A REGISTER.\n         ICM   R0,3,6(R5)          ENDING CC\n         XR    R14,R14             CLEAR A REGISTER.\n         L     R14,TRKCYL          TRACKS PER CYLINDER\n         SRDA  R0,32               SETUP FOR MULTIPLY.\n         MR    R0,R14              R1 = TRKS IN FULL CYLINDERS.\n         ICM   R14,3,8(R5)         ENDING TT\n         AR    R1,R14              STARTING RELATIVE TRACK.\n         S     R1,STARTTRK         TRACKS IN THIS EXTENT IN R1\n         LA    R1,1(,R1)           KEEP IT HONEST\n         AR    R8,R1               COUNT IT\n         LA    R7,4(,R7)           SKIP TO NEXT LA INSTRUCTION.\nVTOC5C   BCT   R15,VTOC5B          LOOP THROUGH ALL EXTENTS.\nVTOC5A   LA    R8,0(0,R8)          PURIFY A REGISTER.\n         STCM  R8,15,TRACKS        TRACKS ALLOCATED\nVTOC99   $OUT  ,                   RETURN\nEXTLIST  LA    R5,SV1EXT1\n         LA    R5,SV1EXT2\n         LA    R5,SV1EXT3\n         LA    R5,SV3EXT4\n         LA    R5,SV3EXT5\n         LA    R5,SV3EXT6\n         LA    R5,SV3EXT7\n         LA    R5,SV3EXT8\n         LA    R5,SV3EXT9\n         LA    R5,SV3EXT10\n         LA    R5,SV3EXT11\n         LA    R5,SV3EXT12\n         LA    R5,SV3EXT13\n         LA    R5,SV3EXT14\n         LA    R5,SV3EXT15\n         LA    R5,SV3EXT16\n         EJECT ,                                                   -EU-\n*        ALLOCATE ALL ONLINE VVDS'S.                               -EU-\n         SPACE 1                                                   -EU-\n* PASS THROUGH THE UCB LOOKUP TABLE. USING UCBVOLI DEVELOP A DSNAME OF\n* SYS1.VVDS.VVOLSER. TRY TO DYNAMICALLY ALLOCATE IT. IF SUCCESSFUL\n* GENERATE AN ACB AND AN RPL AND SAVE THEIR ADDRESSES. FINALLY OPEN\n* THE VVDS.\n         SPACE 1                                                   -EU-\nALLVVDS  $IN ,\n         LA    R0,VVDSGETL         LENGTH OF TABLE.\n         GETMAIN R,LV=(0)\n         ST    R1,VVDSTAD          SAVE TABLE START ADDRESS\n         LR    R5,R1               R5 AS BASE REG FOR VVDS TABLE.\n         USING VVDSTAB,R5\n         L     R3,CVTPTR          GET CVT ADDRESS                  @120\n         USING CVTMAP,R3          ADDRESS TO CVT                   @120\n         XC    UCBWORK,UCBWORK    CLEAR WORK AREA                  @120\n         LA    R1,UCBWORK         GET ADDRESS OF WORK AREA         @120\n         ST    R1,PARMWA          STORE ADDR IN PARMLIST           @120\n         LA    R1,DEVCLASS        ADDR OF DEVICE CLASS             @120\n         ST    R1,PARMDEVT        STORE ADDR IN PARMLIST           @120\n         MVI   DEVCLASS,UCB3DACC  SEARCH FOR DASD UCBS ONLY        @120\n         LA    R1,ADDRUCB         ADDR OF RETURNED UCB             @120\n         ST    R1,PARMUCB         STORE UCB IN PARMLIST            @120\n         OI    PARMUCB,X'80'      END OF PARMLIST                  @120\n         L     R1,CVTUCBSC        GET SCAN SERVICE ROUTINE         @120\n         DROP  R3                                                  @120\n         ST    R1,SCANSAVE        HOLD FOR LATER                   @120\nUCBLOOP  LA    R1,PARMLIST        PUT ADDR INTO REG 1              @120\n         L     R15,SCANSAVE       GET SCAN SERVICE RTN             @120\n         BASR  R14,R15            GO TO SCAN SERVICE INTERFACE     @120\n         LTR   R15,R15            WAS A UCB RETURNED?              @120\n         BNZ   LASTUCB            NO.                              @120\n         USING UCBOB,R2           ADDR TO UCB DSECT                @120\n         L     R2,ADDRUCB         GET RETURNED UCB ADDR            @120\n         TM    UCBSTAT,UCBONLI     IS IT ONLINE?                   @120\n         BZ    UCBLOOP             NO, KEEP GOING                  @120\n         B     ALLVVDS1            PROCESS DASD VOLUME.            @120\nLASTUCB  B     ALLVVDS9                                            @120\nALLVVDS1 MVC   VVDSNAME,UCBVOLI    SET UP VOLSER IN DSNAME\n         MVC   VVDDNAME,UCBVOLI    SET UP VOLSER IN DDNAME\n         MVC   VVDSVOL,UCBVOLI     SAVE VOLSER IN TABLE.\n         ALLOC DSN=LOCDSN,DISP=SHR,DDN=LOCDDN,ERROR=UCBLOOP\n         GENCB BLK=ACB,AM=VSAM,BUFSP=32768,DDNAME=(*,VVDDN),           X\n               MACRF=(ADR,SEQ)\n         LTR   R15,R15             ACB GENERATED?\n         BNZ   UCBLOOP             IF NOT, SKIP THIS VOLUME.\n         STCM  R1,15,VVDSACB       STORE ACB ADDRESS\n         GENCB BLK=RPL,AM=VSAM,ACB=(*,VVDSACB),AREA=(S,VVDSBUF),       X\n               OPTCD=(ADR,SEQ,LOC),ARG=(S,VVDSARG)\n         LTR   R15,R15             RPL GENERATED?\n         BNZ   UCBLOOP             IF NOT, SKIP THIS VOLUME.\n         STCM  R1,15,VVDSRPL       STORE RPL ADDRESS\n        SETAUTH ,                                                  -EU-\n**-EU-   LA    R0,1                AUTHORIZATION ON.\n**-EU-   SVC   232                 **** INSTALLATION DEPENDANT. ****\n         ICM   R8,15,VVDSACB       GET ACB ADDRESS\n         OPEN  ((R8))              OPEN VVDS\n         LTR   R15,R15             DID IT OPEN?                    @122\n         BZ    ALLVVDS2            YES.                            @122\n        RESAUTH ,                                                  -EU-\n**-EU-   XR    R0,R0                                               @122\n**-EU-   SVC   232                                                 @122\n        $MESSAGE 5,DATA=UCBVOLI                                    @122\n         B     UCBLOOP             TRY NEXT VOLUME.                @122\nALLVVDS2 RESAUTH ,                                             @122-EU-\n**-EU-   XR    R0,R0               AUTHORIZATION OFF.\n**-EU-   SVC   232                 **** INSTALLATION DEPENDANT. ****\n         LA    R5,VVDSTLEN(0,R5)   NEXT VVDSTAB ENTRY\n         B     UCBLOOP             TRY NEXT VOLUME                 @120\nALLVVDS9 MVI   0(R5),255           SET END OF TABLE.\n         $OUT  ,                   ALL DONE.\n         EJECT ,                                                   -EU-\n*        COLLECT DATA FROM VVDS CELLS.                             -EU-\n         SPACE 1                                                   -EU-\n* I ENTER AT THIS POINT HAVING READ IN THE 1ST RECORD IN THE CI\n* CONTAINING THE DATA I WANT. FIRSTLY I HAVE TO SKIP AHEAD TO FIND\n* THE VVR FOR THE OBJECT I AM LISTING (NB: THE FIRST VVR I FIND MAY\n* NOT BE IT, IE. A DATA VVR IF I'M LISTING AN INDEX).\n         SPACE 1\nVVDS     $IN ,\n         XR    R15,R15             RESET RETURN CODE.              @122\n         XC    BLKSIZE,BLKSIZE     RESET BLKSIZE\n         XC    LRECL,LRECL         RESET LRECL\n         XC    TRACKS,TRACKS       RESET TRACKS.\n         USING VVR,R6\nVVDS0    CLI   2(R6),C'Q'          Q = SECONDARY VVR\n         BE    VVDS0B              YES, IS IT THE RIGHT ONE?\n         CLI   2(R6),C'Z'          Z = PRIMARY VVR\n         BE    VVDS0B              YES, IS IT THE RIGHT ONE?\nVVDS0A   XR    R0,R0               NEXT CELL PLEASE\n         BAS   R9,FINDVVDS         ADVANCE R6 TO NEXT CELL.\n         C     R15,=F'8'           PROBLEMS?                       @122\n         BNE   VVDS0               NO. IS IT A VVR?                @122\n        $MESSAGE 3,DATA=L1DSNAME                                   @122\n         LA    R15,8               RC=8 FOR CALLER.                @122\n         B     VVDS99                                              @122\nVVDS0B   XR    R1,R1\n         ICM   R1,1,VVRCMPNL       PICK UP NAME LENGTH.\n         BCTR  R1,0\n         BCTR  R1,0\n         B     VVDS0C\n         CLC   L1DSNAME(0),VVRCMPNM  (EXECUTED)\nVVDS0C   EX    R1,*-6              COMPARE VVR NAME TO BCS NAME.\n         BNE   VVDS0A              NO, MUST BE A RELATED COMPONENT.\n         CLI   2(R6),C'Q'          Q = SECONDARY VVR\n         BE    VVDS1               YES, IS IT THE RIGHT ONE?\n         CLI   2(R6),C'Z'          Z = PRIMARY VVR\n         BE    VVDS2               YES, IS IT THE RIGHT ONE?\n         B     VVDS99              SHOULD NEVER HAPPEN!\nVVDS1    ICM   R0,1,=XL1'23'       VOLUME INFORMATION CELL\n         BAS   R9,FINDVVDS         FIND NEXT VVDS CELL.\n         USING VVRVOLIN,R6\n         MVC   BLKSIZE,VVRBLKSZ    SAVE BLOCK SIZE.\n         XR    R1,R1               COUNT OF TRACKS\n         XR    R8,R8\n         ICM   R8,1,VVRNOEXT       GET NUMBER OF EXTENTS\n         LA    R6,40(0,R6)         SKIP AHEAD TO EXTENT DESCR.\n         USING VVRXTENT,R6\nVVDS1B   AH    R1,VVRXNTRK         COUNT TRACKS THIS EXTENT\n         LA    R6,20(0,R6)         SKIP TO NEXT EXTENT DESCR.\n         BCT   R8,VVDS1B\n         ST    R1,TRACKS           SAVE ALLOCATED TRACKS.\n         B     VVDS99\n         DROP  R6\nVVDS2    ICM   R0,1,=XL1'21'       DATASET INFORMATION CELL.\n         BAS   R9,FINDVVDS         FIND NEXT VVDS CELL.\n         USING VVRDSINF,R6\n         MVC   LRECL,VVRLRECL      SAVE AVERAGE LRECL\n         B     VVDS1               LOOK FOR VOLUME INFORMATION CELL\n         DROP  R6\nVVDS99   $OUT  ,\n         EJECT ,                                                   -EU-\n*        PRINT A HEX LISTING.                                      -EU-\n         SPACE 1                                                   -EU-\nHEXPRINT XPROPEN PWA,PAGELEN=PAGELEN,DDNAME=SYSPRINT\n         LTR   R15,R15             DID SYSPRINT OPEN?\n         BNZ   EODICAT             IF NOT, NO REPORT.\n         XPRHEAD PWA,LIST=(HEADER1,HEADER3)\n         BAS   R9,ALLVVDS          ALLOCATE ALL VVDS'S\n         BAS   R9,OPICAT           OPEN REQUESTED CATALOG (SYSUT1) -EU-\n         BAS   R9,GENRPL           GENERATE RPL ADDR.              @120\nGETNEXTH L     R1,RPLICAT          GET RPL ADDR.\n         GET   RPL=(1)\n         LTR   R15,R15             RECORD READ OK?\n         L     R3,BUFPTR           ADDR OF CATALOG RECORD\n         L     R2,RPLICAT          GET RPL ADDR FROM LAST GET.\n         L     R2,48(0,R2)         LENGTH OF RECORD READ\n         AR    R2,R3               POINT TO END OF CATALOG RECORD\n         ST    R2,ENDBCS           SAVE FOR FINDBCS ROUTINE\n         LA    R3,2(,R3)           SKIP OVER PREFIX\nHEXNEXT  CLI   2(R3),C'A'          A = NONVSAM\n         BE    HEXNVSAM\n         CLI   2(R3),C'C'          C = CLUSTER\n         BE    HEXCLUST\n         CLI   2(R3),C'D'          D = DATA COMPONENT\n         BE    HEXDATA\n         CLI   2(R3),C'I'          I = INDEX COMPONENT\n         BE    HEXINDEX\nENDHEX   XR    R1,R1\n         ICM   R1,3,0(R3)          PICK UP CELL LENGTH\n         AR    R3,R1               POINT TO NEXT CELL\n         C     R3,ENDBCS           ANY MORE CELLS IN THIS RECORD?\n         BL    HEXNEXT             YES, KEEP GOING\n         B     GETNEXTH            READ ANOTHER RECORD.\n         EJECT ,                                                   -EU-\n*- - - - HEX PRINT A NONVSAM CELL.                                 -EU-\n         SPACE 1                                                   -EU-\n         USING NVNC,R3\nHEXNVSAM MVC   L2TYPE,=CL7'NONVSAM'\n         AP    CNTNVSAM,ONE        COUNT OFF A NONVSAM             @120\n         HEX   L2WORK,NVCELEN,2,HEXTAB=TRHEX      LENGTH OF NVNC\n         HEX   L2WORK+5,NVTYPE,1,HEXTAB=TRHEX     TYPE 'A' FOR NONVSAM\n         HEX   L2WORK+8,NVRESV,1,HEXTAB=TRHEX     RESERVED\n         HEX   L2WORK+11,NVOLCNT,                                      X\n               2,HEXTAB=TRHEX      NUMBER OF VOLUME CELLS (255 MAX)\n         HEX   L2WORK+16,NVKEYLN,                                      X\n               1,HEXTAB=TRHEX      LENGTH OF THE NONVSAM KEY\n         MVC   L2WORK+19(44),NVNAME\n         LM    R0,R1,PLINE2A       PARMS TO SKIP BEFORE RPTLINE2\n         BAS   R9,PRINT            PRINT LINE.\n         BAS   R9,HEXOWNER         OWNER CELL NEXT.\n         BAS   R9,HEXASSOC         ASSOCIATION (IF PRESENT).\n         BAS   R9,HEXVOL           VOLUME CELL(S).\n         B     ENDHEX\n         DROP  R3\n         EJECT ,                                                   -EU-\n*- - - - HEX PRINT A CLUSTER CELL.                                 -EU-\n         SPACE 1                                                   -EU-\n         USING VCNC,R3\nHEXCLUST MVC   L2TYPE,=CL7'CLUSTER'\n         AP    CNTCLUST,ONE        COUNT A CLUSTER                 @120\n         HEX   L2WORK,CLCELLN,                                         X\n               2,HEXTAB=TRHEX      LENGTH OF VCNC INCLUDING ITSELF\n         HEX   L2WORK+5,CLTYPE,1,HEXTAB=TRHEX     TYPE 'C' FOR CLUSTER\n         HEX   L2WORK+8,CLCOMPLN,                                      X\n               2,HEXTAB=TRHEX      LENGTH OF THE CLUSTER COMPONENT\n         HEX   L2WORK+13,CLNOEXT,                                      X\n               1,HEXTAB=TRHEX      NUMBER OF EXTENSION RECORDS\n         HEX   L2WORK+16,CLNMLEN,                                      X\n               1,HEXTAB=TRHEX      LENGTH OF THE CLUSTER KEY (45)\n         MVC   L2WORK+19(44),CLNAME\n         LM    R0,R1,PLINE2A       PARMS TO SKIP BEFORE RPTLINE2\n         BAS   R9,PRINT            PRINT LINE.\n         BAS   R9,HEXOWNER         OWNER CELL NEXT.\n         BAS   R9,HEXSECUR         SECURITY CELL (IF PRESENT).\n         BAS   R9,HEXASSOC         ASSOCIATION (IF PRESENT).\n         BAS   R9,HEXRELAT         RELATIONSHIP CELL (?)\n         B     ENDHEX\n         DROP  R3\n         EJECT ,                                                   -EU-\n*- - - - HEX PRINT A DATA OR INDEX CELL.                           -EU-\n         SPACE 1                                                   -EU-\n         USING DINC,R3\nHEXDATA  MVC   L2TYPE,=CL7'DATA'\n         AP    CNTDATA,ONE         COUNT IT                        @120\n         B     HEXDATA1\nHEXINDEX MVC   L2TYPE,=CL7'INDEX'\n         AP    CNTINDEX,ONE        COUNT IT.                       @120\nHEXDATA1 HEX   L2WORK,DIDLEN,2,HEXTAB=TRHEX  LENGTH OF DINC\n         HEX   L2WORK+5,DIDTYPE,                                       X\n               1,HEXTAB=TRHEX      TYPE 'D' FOR DATA OR INDEX\n         HEX   L2WORK+8,DIDCMPLN,                                      X\n               2,HEXTAB=TRHEX      LENGTH OF DINC COMPONENT\n         HEX   L2WORK+13,DIDIRFLG,                                     X\n               1,HEXTAB=TRHEX      INTERRUPT RECOGNITION FLAGS\n         HEX   L2WORK+16,DIDKEYLN,1,HEXTAB=TRHEX  CONDENSED KEYLENGTH\n         XR    R1,R1\n         ICM   R1,1,DIDKEYLN       GET LENGTH OF NAME KEY.\n         B     *+10\n         MVC   L2WORK+19(0),DIDKEY\n         EX    R1,*-6              MOVE IN NAME KEY.\n         B     *+10\n         MVC   SVCOMPN(0),DIDKEY   SAVE COMPONENT NAME\n         EX    R1,*-6              MOVE IN NAME KEY.\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         BAS   R9,PRINT            PRINT LINE.\n         BAS   R9,HEXOWNER         OWNER CELL NEXT.\n         BAS   R9,HEXSECUR         SECURITY CELL (IF PRESENT).\n         BAS   R9,HEXVOL           VOLUME CELL(S).\n         B     ENDHEX\n         DROP  R3\n         EJECT ,                                                   -EU-\n*        HEX AN OWNER CELL.                                        -EU-\n         SPACE 1                                                   -EU-\nHEXOWNER $IN ,\n         ICM   R0,1,=XL1'01'       OWNER CELL TYPE.\n         BAS   R9,FINDBCS          LOOK FOR IT.\n         USING OWNERC,R3\n         MVC   L2TYPE,=CL7' OWNER'\n         HEX   L2WORK,OWNCELLN,                                        X\n               2,HEXTAB=TRHEX      LENGTH OF OWNERSHIP CELL\n         HEX   L2WORK+5,OWNTYPE,1,HEXTAB=TRHEX    TYPE X'01' FOR OWNER\n         HEX   L2WORK+8,OWNID,4,HEXTAB=TRHEX      OWNER ID\n         HEX   L2WORK+16,OWNID+4,4,HEXTAB=TRHEX   OWNER ID\n         HEX   L2WORK+25,OWNFLAG,1,HEXTAB=TRHEX   FLAG\n         HEX   L2WORK+28,OWNCREDT,3,HEXTAB=TRHEX  CREATION DATE\n         HEX   L2WORK+35,OWNEXPDT,3,HEXTAB=TRHEX  EXPIRY DATE\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         BAS   R9,PRINT            PRINT LINE.\n         $OUT  ,                   GET OUT.\n         EJECT ,                                                   -EU-\n*        HEX AN ASSOCIATION CELL.                                  -EU-\n         SPACE 1                                                   -EU-\nHEXASSOC $IN ,\n         ICM   R0,3,=XL2'FF03'     TYPE X'03', OPTIONAL.\n         BAS   R9,FINDBCS          IS THERE ONE?\n         LTR   R0,R0               SO WAS THERE?\n         BZ    HEXASS99            NO.\n         USING ASSOCC,R3\n         MVC   L2TYPE,=CL7' ASSOC'\n         HEX   L2WORK,ASCLEN,                                          X\n               2,HEXTAB=TRHEX      ASSOCIATION CELL LENGTH\n         HEX   L2WORK+5,ASCTYPE,1,HEXTAB=TRHEX    TYPE X'03' FOR ASSOC\n         HEX   L2WORK+8,ASCOUNT,2,HEXTAB=TRHEX    COUNT OF ASSOCIATIONS\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         BAS   R9,PRINT            PRINT LINE.\nHEXASS99 $OUT  ,                   GET OUT\n         EJECT ,                                                   -EU-\n*        HEX A SECURITY CELL.                                      -EU-\n         SPACE 1                                                   -EU-\nHEXSECUR $IN ,\n         ICM   R0,3,=XL2'FF02'     TYPE X'02', OPTIONAL.\n         BAS   R9,FINDBCS          IS THERE ONE?\n         LTR   R0,R0               SO WAS THERE?\n         BZ    HEXSEC99            NO.\n         USING SECURITY,R3\n         MVC   L2TYPE,=CL7' SECUR'\n         HEX   L2WORK,SECELLN,                                         X\n               2,HEXTAB=TRHEX      LENGTH OF SECURITY CELL\n         HEX   L2WORK+5,SECTYPE,                                       X\n               1,HEXTAB=TRHEX      TYPE X'02' FOR SECURITY.\n         HEX   L2WORK+8,SECMSTR,4,HEXTAB=TRHEX    MASTER PASSWORD.\n         HEX   L2WORK+16,SECMSTR+4,4,HEXTAB=TRHEX MASTER PASSWORD.\n         HEX   L2WORK+27,SECCI,                                        X\n               4,HEXTAB=TRHEX      CONTROL INTERVAL PASSWORD.\n         HEX   L2WORK+35,SECCI+4,                                      X\n               4,HEXTAB=TRHEX      CONTROL INTERVAL PASSWORD.\n         HEX   L2WORK+44,SECUPDTE,4,HEXTAB=TRHEX  UPDATE PASSWORD.\n         HEX   L2WORK+52,SECUPDTE+4,4,HEXTAB=TRHEX     UPDATE PASSWORD.\n         HEX   L2WORK+61,SECREAD,4,HEXTAB=TRHEX   READ PASSWORD.\n         HEX   L2WORK+69,SECREAD+4,4,HEXTAB=TRHEX READ PASSWORD.\n         HEX   L2WORK+78,SECPMTCD,                                     X\n               4,HEXTAB=TRHEX      PASSWORD PROMPTING CODE.\n         HEX   L2WORK+86,SECPMTCD+4,                                   X\n               4,HEXTAB=TRHEX      PASSWORD PROMPTING CODE.\n         HEX   L2WORK+95,SECATMP,                                      X\n               2,HEXTAB=TRHEX      MAXIMUM NUMBER OF ATTEMPTS.\n         HEX   L2WORK+100,SECVRMOD,                                    X\n               4,HEXTAB=TRHEX      USER SECURITY VERIFICATION MOD.\n         HEX   L2WORK+108,SECVRMOD+4,                                  X\n               4,HEXTAB=TRHEX      USER SECURITY VERIFICATION MOD.\n         HEX   L2WORK+117,SECRCDLN,                                    X\n               2,HEXTAB=TRHEX      USER AUTHORIZATION RECORD LENGTH\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         BAS   R9,PRINT            PRINT LINE.\nHEXSEC99 $OUT  ,                   GET OUT\n         EJECT ,                                                   -EU-\n*        HEX A RELATION CELL.                                      -EU-\n         SPACE 1                                                   -EU-\nHEXRELAT $IN ,\n         ICM   R0,3,=XL2'FF06'     OPTIONAL RELAT CELL\n         BAS   R9,FINDBCS          LOOK FOR IT.\n         LTR   R0,R0               WAS IT THERE?\n         BZ    HEXREL99            NO.\n         USING RELCELL,R3\n         MVC   L2TYPE,=CL7' RELAT'\n         HEX   L2WORK,RELLEN,2,HEXTAB=TRHEX       CELL LENGTH.\n         HEX   L2WORK+5,RELTYPE,1,HEXTAB=TRHEX    TYPE X'06'\n         HEX   L2WORK+8,RELRESV,1,HEXTAB=TRHEX    RESERVED.\n         HEX   L2WORK+11,RELCNT,1,HEXTAB=TRHEX    COUNT OF RELKEYS.\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         BAS   R9,PRINT            PRINT LINE.\nHEXREL99 $OUT  ,                   GET OUT\n         EJECT ,                                                   -EU-\n*        HEX A VOLUME CELL.                                        -EU-\n         SPACE 1                                                   -EU-\n* THIS LOGIC IS ENTERED AT A POINT WHERE THERE MUST BE AT LEAST ONE\n* VOLUME CELL POINTED TO BY R3. HOWEVER THERE COULD BE MORE THAN ONE.\n* HENCE, AFTER THE FIRST NON-VOLUME CELL IS RECOGNIZED R3 MUST BE\n* BACKED UP TO THE LAST VOLUME CELL SO THAT THE GENERAL CODE AT\n* \"ENDHEX\" CAN SKIP OVER IT.\n         SPACE 1                                                   -EU-\nHEXVOL   $IN ,\nHEXVOL0  ICM   R0,3,=XL2'FF04'     VOLUME CELL\n         BAS   R9,FINDBCS\n         LTR   R0,R0               WAS THAT THE LAST ONE?\n         BZ    HEXVOL99            YES.\n         USING VOLCELL,R3\n         MVC   L2TYPE,=CL7' VOLUME'\n         HEX   L2WORK,VOLLEN,2,HEXTAB=TRHEX       LENGTH OF VOLCELL\n         HEX   L2WORK+5,VOLTYPE,                                       X\n               1,HEXTAB=TRHEX      TYPE X'04' FOR VOLUME CELL\n         HEX   L2WORK+8,VOLOFSET,1,HEXTAB=TRHEX   UNUSED\n         MVC   L2WORK+11(6),VOLSERN\n         HEX   L2WORK+18,VOLDEVTP,4,HEXTAB=TRHEX  DEVICE TYPE\n         HEX   L2WORK+27,VOLFLAG1,1,HEXTAB=TRHEX  FLAG\n         HEX   L2WORK+30,VOLFLAG2,1,HEXTAB=TRHEX  RESERVED\n         HEX   L2WORK+33,VOLVVRBA,                                     X\n               4,HEXTAB=TRHEX      RELATIVE BYTE ADDRESS OF VVR\n         HEX   L2WORK+42,VOLFLSEQ,                                     X\n               2,HEXTAB=TRHEX      NONVSAM FILE SEQUENCE NUMBER (TAPE)\n         HEX   L2WORK+47,VOLKRQL,                                      X\n               4,HEXTAB=TRHEX      KEYRANGE QUALIFIER (VSAM ONLY)\n         HEX   L2WORK+56,VOLLKYLN,                                     X\n               2,HEXTAB=TRHEX      LENGTH OF LOW KEY RANGE KEY\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         BAS   R9,PRINT            PRINT LINE.\n         TM    VOLFLAG1,VOLNVSAM   IS IT NONVSAM?\n         BO    HEXVOL99            IF SO, THAT'S ALL\n         TM    VOLFLAG1,VOLCANDI   IS IT A CANDIDATE VOLUME?\n         BO    HEXVOL99            IF SO, THAT'S ALL\n         MVC   RBASAVE,VOLVVRBA    SAVE RBA OF VVR\n         L     R5,VVDSTAD          GET VVDSTAB START ADDR\n         USING VVDSTAB,R5\nHEXVOL8  CLI   VVDSVOL,255         LAST ENTRY?\n         BE    HEXVOL99            YES, OH WELL.\n         CLC   VVDSVOL,VOLSERN     IS THIS THE VVDS?\n         BNE   HEXVOL6             NO, TRY AGAIN\n         ICM   R1,15,RBASAVE       GET VVR RBA\n         STCM  R1,15,VVDSARG       INSERT TO ARG FIELD FOR THIS RPL\n         ICM   R8,15,VVDSRPL       PICK UP RPL ADDR\n         POINT RPL=(R8)            POSITION TO DESIRED RECORD\n         GET   RPL=(R8)            READ IN RECORD\n         LTR   R15,R15             RECORD READ OK?\n         L     R6,VVDSBUF          ADDR OF CATALOG RECORD\n         L     R1,VVDSRPL          GET ADDR OF RPL\n         L     R1,48(0,R1)         LENGTH OF RECORD READ\n         AR    R1,R6               POINT TO END OF CATALOG RECORD\n         ST    R1,ENDVVD           SAVE END OF RECORD ADDR\n         LA    R6,2(,R6)           SKIP OVER PREFIX\n         BAS   R9,HEXVVR           PRIMARY OR 2NDARY VVR\n         BAS   R9,HEXDSINF         DATASET INFORMATION CELL (MAYBE)\n         BAS   R9,HEXAMDSB         AMDSB CELL (IF PRESENT)\n         BAS   R9,HEXVOLIN         VOLUME INFORMATION CELL.\n         B     HEXVOL0             COULD BE MORE THAN ONE.\nHEXVOL6  LA    R5,VVDSTLEN(0,R5)   NEXT ENTRY\n         B     HEXVOL8             WHAT IS IT JOHNNY?\nHEXVOL99 $OUT  ,                   GET OUT.\n         DROP  R3\n         EJECT ,                                                   -EU-\n*        HEX PRINT A VVR.                                          -EU-\n         SPACE 1                                                   -EU-\n* I ENTER AT THIS POINT HAVING READ IN THE 1ST RECORD IN THE CI\n* CONTAINING THE DATA I WANT. FIRSTLY I HAVE TO SKIP AHEAD TO FIND\n* THE VVR FOR THE OBJECT I AM LISTING (NB : THE FIRST VVR I FIND MAY\n* NOT BE IT, IE. A DATA VVR IF I'M LISTING AN INDEX).\n         SPACE 1                                                   -EU-\n         USING VVR,R6\nHEXVVR   $IN ,\n         MVC   L2TYPE,=CL7' VVR'\nHEXVVR0  CLI   2(R6),C'Q'          Q = SECONDARY VVR\n         BE    HEXVVR0B            YES, IS IT THE RIGHT ONE?\n         CLI   2(R6),C'Z'          Z = PRIMARY VVR\n         BE    HEXVVR0B            YES, IS IT THE RIGHT ONE?\nHEXVVR0A XR    R0,R0               NEXT CELL PLEASE.\n         BAS   R9,FINDVVDS\n         B     HEXVVR0             IS IT A VVR?\nHEXVVR0B XR    R1,R1\n         ICM   R1,1,VVRCMPNL       PICK UP NAME LENGTH.\n         BCTR  R1,0\n         BCTR  R1,0\n         B     HEXVVR0C\n         CLC   SVCOMPN(0),VVRCMPNM  (EXECUTED)\nHEXVVR0C EX    R1,*-6              COMPARE VVR NAME TO BCS NAME.\n         BNE   HEXVVR0A            NO, MUST BE A RELATED COMPONENT.\n         HEX   L2WORK,VVRHDLEN,2,HEXTAB=TRHEX\n         HEX   L2WORK+5,VVRTYPE,1,HEXTAB=TRHEX\n         HEX   L2WORK+8,VVRFLAG,1,HEXTAB=TRHEX\n         HEX   L2WORK+11,VVRKRQ,4,HEXTAB=TRHEX\n         HEX   L2WORK+20,VVRCMPNL,1,HEXTAB=TRHEX\n         XR    R1,R1\n         ICM   R1,1,VVRCMPNL       GET LENGTH OF COMPONENT KEY.\n         B     *+10\n         MVC   L2WORK+23(0),VVRCMPNM\n         EX    R1,*-6              MOVE IN COMPONENT KEY.\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         BAS   R9,PRINT            PRINT LINE.\n         $OUT  ,                   GET OUT.\n         DROP  R6\n         EJECT ,                                                   -EU-\n*        HEX A DATASET INFORMATION CELL.                           -EU-\n         SPACE 1                                                   -EU-\nHEXDSINF $IN ,\n         ICM   R0,3,=XL2'FF21'     DATASET INFORMATION CELL.\n         BAS   R9,FINDVVDS         LOOK FOR IT.\n         LTR   R0,R0               WAS THERE ONE?\n         BZ    HEXDSF99            NO.\n         USING VVRDSINF,R6\n         MVC   L2TYPE,=CL7' DSINFO'\n         HEX   L2WORK,VVRDSLEN,2,HEXTAB=TRHEX     CELL LENGTH.\n         HEX   L2WORK+5,VVRDSTYP,1,HEXTAB=TRHEX   TYPE CODE IS X'21'\n         HEX   L2WORK+8,VVRATTR1,1,HEXTAB=TRHEX   DATASET ATTRIBUTES\n         HEX   L2WORK+11,VVRATTR2,1,HEXTAB=TRHEX  DATASET ATTRIBUTES\n         HEX   L2WORK+14,VVROPIND,1,HEXTAB=TRHEX  OPEN INDICATOR\n         HEX   L2WORK+17,VVRBUFSZ,4,HEXTAB=TRHEX  MINIMUM BUFFER SIZE\n         HEX   L2WORK+26,VVRPRISP,3,HEXTAB=TRHEX  PRIMARY SPACE ALLOC.\n         HEX   L2WORK+33,VVRSECSP,3,HEXTAB=TRHEX  SECONDARY SPACE ALL.\n         HEX   L2WORK+40,VVRSPCFG,1,HEXTAB=TRHEX  SPACE FLAGS\n         HEX   L2WORK+43,VVRDSHU,4,HEXTAB=TRHEX   DATASET HIGH USED RBA\n         HEX   L2WORK+52,VVRDSHA,                                      X\n               4,HEXTAB=TRHEX      DATASET HIGH ALLOCATED RBA\n         HEX   L2WORK+61,VVRLRECL,                                     X\n               4,HEXTAB=TRHEX      AVERAGE LOGICAL RECORD LENGTH\n         HEX   L2WORK+70,VVREXCPX,4,HEXTAB=TRHEX  EXCEPTION EXIT.\n         HEX   L2WORK+78,VVREXCPX+4,4,HEXTAB=TRHEX     EXCEPTION EXIT.\n         HEX   L2WORK+87,VVRDSHK,4,HEXTAB=TRHEX   DATASET HIGH KEY RBA.\n         HEX   L2WORK+96,VVRCLSFG,                                     X\n               1,HEXTAB=TRHEX      CLUSTER ATTRIBUTE FLAG\n         HEX   L2WORK+99,VVRAIXFG,1,HEXTAB=TRHEX  AIX ATTRIBUTE FLAG\n         HEX   L2WORK+102,VVRTMSTP,                                    X\n               4,HEXTAB=TRHEX      TIMESTAMP (CATALOG ONLY).\n         HEX   L2WORK+110,VVRTMSTP+4,                                  X\n               4,HEXTAB=TRHEX      TIMESTAMP (CATALOG ONLY).\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         BAS   R9,PRINT            PRINT LINE.\nHEXDSF99 $OUT  ,                   GET OUT\n         EJECT ,                                                   -EU-\n*        HEX AN AMDSB CELL.                                        -EU-\n         SPACE 1                                                   -EU-\nHEXAMDSB $IN ,\n         ICM   R0,3,=XL2'FF60'     AMDSB CELL\n         BAS   R9,FINDVVDS         LOOK FOR IT.\n         LTR   R0,R0               WAS THERE ONE?\n         BZ    HEXAMD99            NO.\n         USING VVRAMDCL,R6\n         MVC   L2TYPE,=CL7' AMDSB'\n         HEX   L2WORK+00,VVRAMDCN,2,HEXTAB=TRHEX  LENGTH OF AMDSB CELL\n         HEX   L2WORK+05,VVRAMID,1,HEXTAB=TRHEX   TYPE CODE IS X'60'\n         HEX   L2WORK+08,VVRAMATR,1,HEXTAB=TRHEX  ATTRIBUTES:\n         HEX   L2WORK+11,VVRAMLEN,2,HEXTAB=TRHEX  LENGTH OF AMDSB\n         HEX   L2WORK+16,VVRAMNST,                                     X\n               2,HEXTAB=TRHEX      NUMBER OF ENTRIES IN INDEX SECTION\n         HEX   L2WORK+21,VVRAMRKP,2,HEXTAB=TRHEX  RKP\n         HEX   L2WORK+26,VVRAMKNL,2,HEXTAB=TRHEX  KEY LENGTH\n         HEX   L2WORK+31,VVRAMPCA,1,HEXTAB=TRHEX  % FREE CI IN CA\n         HEX   L2WORK+34,VVRAMPCI,1,HEXTAB=TRHEX  % FREE BYTES IN CI\n         HEX   L2WORK+37,VVRAMCCA,2,HEXTAB=TRHEX  CI'S PER CA\n         HEX   L2WORK+42,VVRAMFCA,2,HEXTAB=TRHEX  FREE CI'S PER CA\n         HEX   L2WORK+47,VVRAMFCI,4,HEXTAB=TRHEX  FREE BYTES PER CI\n         HEX   L2WORK+56,VVRAMCIV,4,HEXTAB=TRHEX  CONTROL INTERVAL SIZE\n         HEX   L2WORK+65,VVRAMLCL,4,HEXTAB=TRHEX  MAXIMUM RECORD SIZE\n         HEX   L2WORK+74,VVRAMSLT,4,HEXTAB=TRHEX  SLOTS PER CI\n         HEX   L2WORK+83,VVRAMMRR,                                     X\n               4,HEXTAB=TRHEX      MAXIMUM RELATIVE RECORD NUMBER\n         HEX   L2WORK+92,VVRAMARB,4,HEXTAB=TRHEX   POINTER TO 1ST ARDB\n         HEX   L2WORK+101,VVRAMAT3,1,HEXTAB=TRHEX  ATTRIBUTES\n         HEX   L2WORK+104,VVRAMSNO,                                    X\n               1,HEXTAB=TRHEX      NUMBER OF CONCURRENT REQUESTS\n         HEX   L2WORK+107,VVRAMBFD,2,HEXTAB=TRHEX  NO. OF DATA BUFFERS\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         BAS   R9,PRINT            PRINT LINE.\n         HEX   L2WORK+00,VVRAMSTS,4,HEXTAB=TRHEX  SYSTEM TIMESTAMP\n         HEX   L2WORK+08,VVRAMSTS+4,4,HEXTAB=TRHEX     SYSTEM TIMESTAMP\n         HEX   L2WORK+17,VVRAMNIL,2,HEXTAB=TRHEX  NO. OF INDEX LEVELS\n         HEX   L2WORK+22,VVRAMNXT,2,HEXTAB=TRHEX  NUMBER OF EXTENTS\n         HEX   L2WORK+27,VVRAMNLR,4,HEXTAB=TRHEX  LOGICAL RECORDS NO.\n         HEX   L2WORK+38,VVRAMDLR,4,HEXTAB=TRHEX  DELETED RECORDS NO.\n         HEX   L2WORK+47,VVRAMINR,4,HEXTAB=TRHEX  INSERTED RECORDS NO.\n         HEX   L2WORK+56,VVRAMUPR,4,HEXTAB=TRHEX  UPDATED RECORDS NO.\n         HEX   L2WORK+65,VVRAMRTR,4,HEXTAB=TRHEX  RETRIEVED RECORDS NO.\n         HEX   L2WORK+74,VVRAMASP,                                     X\n               4,HEXTAB=TRHEX      BYTES OF FREE SPACE IN DATASET\n         HEX   L2WORK+83,VVRAMCIS,4,HEXTAB=TRHEX  NUMBER OF CI SPLITS\n         HEX   L2WORK+92,VVRAMCAS,4,HEXTAB=TRHEX  NUMBER OF CA SPLITS\n         HEX   L2WORK+101,VVRAMEXC,4,HEXTAB=TRHEX NUMBER OF EXCPS\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         BAS   R9,PRINT            PRINT LINE.\nHEXAMD99 $OUT  ,                   GET OUT\n         EJECT ,                                                   -EU-\n*        HEX A VOLUME INFORMATION CELL.                            -EU-\n         SPACE 1                                                   -EU-\nHEXVOLIN $IN ,\n         ICM   R0,3,=XL2'FF23'     VOLUME INFORMATION CELL\n         BAS   R9,FINDVVDS         LOOK FOR IT.\n         LTR   R0,R0               WAS THERE ONE?\n         BZ    HEXVLN99            NO.\n         USING VVRVOLIN,R6\n         MVC   L2TYPE,=CL7' VOLINF'\n         HEX   L2WORK+00,VVRVOLLN,2,HEXTAB=TRHEX  LENGTH OF VOLUME CELL\n         HEX   L2WORK+05,VVRVOLTP,1,HEXTAB=TRHEX  TYPE CODE IS X'23'\n         HEX   L2WORK+08,VVRVOLFG,1,HEXTAB=TRHEX  VOLUME FLAGS\n         HEX   L2WORK+11,VVRNOEXT,                                     X\n               1,HEXTAB=TRHEX      NUMBER OF EXTENTS ON THIS VOLUME.\n         HEX   L2WORK+14,VVRHKRBA,4,HEXTAB=TRHEX  HIGH KEY RBA\n         HEX   L2WORK+23,VVRHURBA,4,HEXTAB=TRHEX  HIGH USED RBA\n         HEX   L2WORK+32,VVRHARBA,4,HEXTAB=TRHEX  HIGH ALLOCATED RBA\n         HEX   L2WORK+41,VVRBLKSZ,4,HEXTAB=TRHEX  BLOCK SIZE\n         HEX   L2WORK+50,VVRBLKTK,                                     X\n               2,HEXTAB=TRHEX      NUMBER OF BLOCKS PER TRACK\n         HEX   L2WORK+55,VVRTRKAU,                                     X\n               2,HEXTAB=TRHEX      NUMBER OF TRACKS PER ALLOCATION UNIT\n         HEX   L2WORK+60,VVRTPEXT,1,HEXTAB=TRHEX  EXTENT TYPE FLAG\n         HEX   L2WORK+63,VVRTKCYL,2,HEXTAB=TRHEX  TRACKS PER CYLINDER\n         HEX   L2WORK+68,VVRBYTTK,4,HEXTAB=TRHEX  BYTES PER TRACK.\n         HEX   L2WORK+77,VVRBYTAU,                                     X\n               4,HEXTAB=TRHEX      BYTES PER ALLOCATION UNIT\n         HEX   L2WORK+86,VVRLOKYL,2,HEXTAB=TRHEX  LOW KEY LENGTH\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         BAS   R9,PRINT            PRINT LINE.\n         ST    R5,HEXR5            SAVE VVDSTAB BASE REG\n         XR    R5,R5\n         ICM   R5,1,VVRNOEXT       GET NUMBER OF EXTENTS\n         LR    R8,R6\n         LA    R8,40(0,R8)         POINT TO EXTENT DESCR.\n         USING VVRXTENT,R8\nHEXVLN97 HEX   L2WORK+00,VVRXSEQN,2,HEXTAB=TRHEX  SEQUENCE NUMBER\n         HEX   L2WORK+05,VVRXSCH,4,HEXTAB=TRHEX   STARTING CCHH\n         HEX   L2WORK+14,VVRXECH,4,HEXTAB=TRHEX   ENDING CCHH\n         HEX   L2WORK+23,VVRXNTRK,2,HEXTAB=TRHEX  NUMBER OF TRACKS\n         HEX   L2WORK+28,VVRXSRBA,4,HEXTAB=TRHEX  STARTING RBA\n         HEX   L2WORK+37,VVRXERBA,4,HEXTAB=TRHEX  ENDING RBA\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         BAS   R9,PRINT            PRINT LINE.\n         LA    R8,20(0,R8)         POINT TO NEXT EXTENT DESCR.\n         BCT   R5,HEXVLN97         FORMAT ALL EXTENTS\n         L     R5,HEXR5            RESTORE VVDSTAB BASE REG\nHEXVLN99 $OUT  ,                   GET OUT\nHEXR5    DC    F'0'                I'M RUNNING OUT OF REGISTERS\n         DROP  R8\n         EJECT ,                                                   -EU-\n*        FINDBCS - ADVANCE R3 TO A SPECIFIED BCS CELL.             -EU-\n         SPACE 1                                                   -EU-\n* I ENTER HERE WITH R3 POINTING TO A CELL I HAVE JUST PROCESSED. THIS\n* CODE EITHER MOVES AHEAD TO THE NEXT CELL BE IT WHATEVER OR SEARCHES\n* FOR A PARTICULAR CELL TYPE.\n* ON ENTRY THE NEXT-TO-RIGHT-MOST BYTE OF R0 CONTAINS X'FF' IF THE\n* CELL TYPE THE CALLER WANTS IS OPTIONAL (IT'S EITHER THE NEXT ONE OR\n* IT'S NOT THERE AT ALL) OR X'00' IF THE DESIRED CELL TYPE IS REQUIRED\n* BUT MAY NOT BE THE NEXT ONE.\n* THE RIGHT-MOST BYTE OF R0 CONTAINS THE ID OF THE CELL TYPE THE\n* CALLER WANTS.\n* IF R0 IS ALL ZEROS THE CALLER JUST WANTS THE NEXT CELL.\n* IF THE REQUESTED CELL TYPE WAS FOUND R0 IS CLEARED.\n         SPACE 1                                                   -EU-\nFINDBCS  $IN ,\n         ST    R3,BCS2             SAVE CELL ADDRESS.\nFINDBCS1 XR    R1,R1               CLEAR REGISTER\n         ICM   R1,3,0(R3)          PICK UP LENGTH OF CURRENT CELL.\n         AR    R3,R1               AND SKIP OVER IT.\n         C     R3,ENDBCS           ANY MORE CELLS IN THIS RECORD?\n         BL    FINDBCS2            YES.\n         ST    R0,BCS0             SAVE CALLERS PARMS\n         L     R1,RPLICAT          GET RPL ADDR.\n         GET   RPL=(1)\n         AP    BCSGETS,ONE         COUNT OFF A GET.\n         L     R0,BCS0             RESTORE CALLERS PARMS\n         LTR   R15,R15             RECORD READ OK?\n         L     R3,BUFPTR           ADDRESS OF RECORD JUST READ.\n         L     R1,RPLICAT          GET RPL ADDR.\n         L     R1,48(0,R1)         RECORD LENGTH.\n         AR    R1,R3               END OF RECORD.\n         ST    R1,ENDBCS           SAVE FOR NEXT TIME.\n         LA    R3,2(0,R3)          SKIP OVER PREFIX.\nFINDBCS2 CLM   R0,1,2(R3)          CHECK FOR REQUESTED CELL TYPE\n         BE    FINDBCS9            YES.\n         CLM   R0,2,=XL1'FF'       IS THIS CELL TYPE OPTIONAL?\n         BNE   FINDBCS1            NO, SO KEEP LOOKING.\n         L     R3,BCS2             BACKUP TO WHERE WE STARTED.\n         XR    R0,R0               LET HIM KNOW ABOUT IT.\nFINDBCS9 $OUT  ,\nENDBCS   DC    F'0'                BCS RECORD END ADDRESS\nBCS2     DC    F'0'                SAVE R3 IN HERE.\nBCS0     DC    F'0'                SAVE R0 IN HERE.\n         EJECT ,                                                   -EU-\n*        FINDVVDS - ADVANCE R6 TO A SPECIFIED VVDS CELL.           -EU-\n         SPACE 1                                                   -EU-\n* I ENTER HERE WITH R6 POINTING TO A CELL I HAVE JUST PROCESSED. THIS\n* CODE EITHER MOVES AHEAD TO THE NEXT CELL BE IT WHATEVER OR SEARCHES\n* FOR A PARTICULAR CELL TYPE.\n* ON ENTRY THE NEXT-TO-RIGHT-MOST BYTE OF R0 CONTAINS X'FF' IF THE\n* CELL TYPE THE CALLER WANTS IS OPTIONAL (IT'S EITHER THE NEXT ONE OR\n* IT'S NOT THERE AT ALL) OR X'00' IF THE DESIRED CELL TYPE IS REQUIRED\n* BUT MAY NOT BE THE NEXT ONE.\n* THE RIGHT-MOST BYTE OF R0 CONTAINS THE ID OF THE CELL TYPE THE\n* CALLER WANTS.\n* IF R0 IS ALL ZEROS THE CALLER JUST WANTS THE NEXT CELL.\n* IF THE REQUESTED CELL TYPE WAS FOUND R0 IS CLEARED.\n         SPACE 1                                                   -EU-\nFINDVVDS $IN ,\n         ST    R6,VVD6             SAVE CELL ADDRESS\nFINDVVD1 XR    R1,R1               CLEAR REGISTER\n         XR    R15,R15             CLEAR PREVIOUS RETCODE.         @122\n         ICM   R1,3,0(R6)          PICK UP LENGTH OF CURRENT CELL.\n         AR    R6,R1               AND SKIP OVER IT.\n         C     R6,ENDVVD           ANY MORE CELLS IN THIS RECORD?\n         BL    FINDVVD2            YES.\n         ICM   R8,15,VVDSRPL       PICK UP RPL ADDRESS\n         ST    R0,VVD0             SAVE CALLERS PARM\n         GET   RPL=(R8)\n         LTR   R15,R15             GET OK?                         @122\n         BZ    FINDVVD3            YUP.                            @122\n         C     R15,=F'8'           LOGICAL ERROR?                  @122\n         BE    FINDVVD4            YES.                            @122\n         ABEND 16,DUMP             OTHERWISE CRASH AND BURN.       @122\nFINDVVD4 XR    R2,R2                                               @122\n         ICM   R2,1,RPLERRCD-IFGRPL(R1) GET REASON CODE.           @122\n         CVD   R2,DTWORK           PACK IT.                        @122\n         EDIT  FDBK,DWK3,ZZZ9      FORMAT NICELY.                  @122\n        $MESSAGE 2,DATA=FDBK       SAY LOGICAL ERROR.              @122\n         LA    R15,8                                               @122\n         B     FINDVVD9            GO BACK WITH RC IN R15          @122\nFINDVVD3 AP    VVDSGETS,ONE        COUNT IT.                       @122\n         L     R0,VVD0             RESTORE CALLERS PARM\n         L     R6,VVDSBUF          ADDRESS OF RECORD JUST READ.\n         L     R1,VVDSRPL          ADDR OF RPL\n         L     R1,48(0,R1)         LENGTH OF RECORD JUST READ.\n         AR    R1,R6               END OF RECORD.\n         ST    R1,ENDVVD           SAVE FOR NEXT TIME.\n         LA    R6,2(0,R6)          SKIP OVER PREFIX.\nFINDVVD2 LTR   R0,R0               IF ZERO, ANYTHING WILL DO.\n         BZ    FINDVVD9\n         CLM   R0,1,2(R6)          CHECK FOR REQUESTED CELL TYPE\n         BE    FINDVVD9            YES.\n         CLM   R0,2,=XL1'FF'       IS THIS CELL TYPE OPTIONAL?\n         BNE   FINDVVD1            NO, THEN KEEP LOOKING.\n         L     R6,VVD6             RESTORE INITIAL CELL ADDRESS\n         XR    R0,R0               GIVE HIM THE SAD NEWS.\nFINDVVD9 $OUT  ,\nENDVVD   DC    F'0'                BCS RECORD END ADDRESS\nVVD6     DC    F'0'                SAVE R6 IN HERE.\nVVD0     DC    F'0'                SAVE R0 IN HERE.\n         DROP  R5\n         EJECT ,                                                   -EU-\n*        PRINT LINE SUBROUTINE.                                    -EU-\n         SPACE 1                                                   -EU-\nPRINT    $IN ,\n         ST    R1,PRINT1\n         XPRNTLIN  PWA,TEXT=(R1),LENGTH=132,SPB=((R0)),SPA=1\n         L     R1,PRINT1\n         MVI   0(R1),C' '\n         MVC   1(132,R1),0(R1)\n         $OUT  ,\nPRINT1   DC    F'0'\n         EJECT ,                                                   -EU-\n*        DEFINE REPORT HEADING.                                    -EU-\n         SPACE 1                                                   -EU-\nSETHEAD  $IN ,\n         XPRHEAD PWA,LIST=(HEADER1,HEADER2)\n         $OUT\n         EJECT ,                                                   -EU-\n*        FORMAT THE CREATION DATE FROM AN OWNER CELL.              -EU-\n         SPACE 1                                                   -EU-\nSETCREDT $IN ,\n         ICM   R0,1,=XL1'01'       OWNER CELL TO BE FOUND.\n         BAS   R9,FINDBCS          SO GO LOOK FOR IT.\n         USING OWNERC,R3\n         XR    R0,R0               CLEAR R0.\n         ICM   R0,7,OWNCREDT       PICK UP CREATION DATE.\n         XC    DTWORK,DTWORK       CLEAR DOUBLE WORD\n         ST    R0,DTWORK+4         STORE FOR DATE CONVERSION\n         LA    R1,DTWORK           SETUP ADDRESS\n         ST    R1,DTPARM           OF PACKED FIELD\n         LA    R1,DTPARM           IN PARMLIST\n         L     R15,=V(XDATEDIT)    ADDRESS OF DATE CONVERT ROUTINE\n         BASR  R14,R15             CONVERT DATE\n         MVC   L1CREDT,DTWORK      SETUP CONVERTED DATE\n         $OUT\n         EJECT ,                                                   -EU-\n*        SETUP FIELDS FROM THE HSM MCD RECORD.                     -EU-\n         SPACE 1                                                   -EU-\nCHKHSM   CLI   MCDSOPEN,254        PREVIOUS OPEN FAILED?           @122\n         BER   R9                  YES. GIVE UP HOPE.              @122\n         CLI   MCDSOPEN,0          IS MCDS ALREADY OPEN?\n         BNE   CHKHSM1A\n         OPEN  (ACBMCDS)\n         LTR   R15,R15             DID IT OPEN.                    @122\n         BZ    CHKHSM1B            YES                             @122\n        $MESSAGE 6                 NO. SAY SO.                     @122\n         MVI   MCDSOPEN,254        FLAG NO SYSUT2.                 @122\n         BR    R9                  AND GO HOME.                    @122\nCHKHSM1B MVI   MCDSOPEN,255        FLAG IT OPEN                    @122\nCHKHSM1A MVC   MCDSKEY,L1DSNAME    DSN AS MCDS KEY.\n         GET   RPL=RPLMCDS\n         LTR   R15,R15             RECORD READ OK?\n         BNZR  R9                  RETURN\n         L     R1,MCDSPTR          GET ADDRESS OF HSM MCD RECORD.\n         USING MCD,R1\n         CLC   MCDSIZE,=F'32760'   DATA AND INDEX ENTRIES NO GOOD.\n         BH    CHKHSM2             SO LEAVE THEM AT ZERO\n         MVC   TRACKS,MCDSIZE      ORIGINAL SIZE IN TRACKS.\nCHKHSM2  MVC   BLKSIZE+2(2),MCDBLKSZ  ORIGINAL BLOCK SIZE.\n         DROP  R1\n         BR    R9                  EXIT\n         EJECT ,                                                   -EU-\n*        PRINT OUT STATISTICS AT EOD.                              -EU-\n         SPACE 1                                                   -EU-\nCOUNTS   $IN ,\n         XPREJECT  PWA\n         XPRHEAD PWA,LIST=(HEADER1)\n         EDIT  T1COUNT,CNTNVSAM,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1NVSAM),T1NVSAM\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=2,SPA=1\n         EDIT  T1COUNT,CNTCLUST,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1CLUST),T1CLUST\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         EDIT  T1COUNT,CNTINDEX,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1INDEX),T1INDEX\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         EDIT  T1COUNT,CNTDATA,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1DATA),T1DATA\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         EDIT  T1COUNT,CNTAIX,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1AIX),T1AIX\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         EDIT  T1COUNT,CNTPATH,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1PATH),T1PATH\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         EDIT  T1COUNT,CNTGDGB,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1GDGB),T1GDGB\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         EDIT  T1COUNT,CNTGDGE,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1GDGE),T1GDGE\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         EDIT  T1COUNT,BCSGETS,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1BCS),T1BCS\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         EDIT  T1COUNT,VVDSGETS,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1VVDS),T1VVDS\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         EDIT  T1COUNT,CNTNF,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1NF),T1NF\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         EDIT  T1COUNT,CNTNOENT,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1NOENT),T1NOENT\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         $OUT\n         EJECT ,                                                   -EU-\n*        GENERATE AN RPL TO ACCESS THE BCS CLUSTER.                -EU-\n         SPACE 1                                                   -EU-\nGENRPL   $IN ,                                                     @120\n         L     R0,BUFLEN           LENGTH TO GETMAIN\n         GETMAIN R,LV=(0)          INPUT BUFFER FOR BCS RECORDS.\n         ST    R1,BUFPTR           SAVE ADDRESS OF RECORD BUFFER.\n         GENCB BLK=RPL,ACB=(S,ACBICAT),AM=VSAM,AREA=(*,BUFPTR),        X\n               AREALEN=131072,OPTCD=(KEY,SEQ,MVE)\n         ST    R1,RPLICAT          SAVE GENERATED RPL ADDR.\n         $OUT                                                      @120\n         EJECT ,                                                   -EU-\n*        OPEN THE REQUESTED ICF CATALOG (SYSUT1).                  -EU-\n         SPACE 1                                                   -EU-\nOPICAT   $IN   ,                                                   -EU-\n         L     R2,CVTPTR           A(CVT)\n         L     R2,0(0,R2)          TCB WORDS\n         L     R5,0(0,R2)          MY TCB.                         -EU-\n         USING TCB,R5                                              -EU-\n         L     R2,TCBJSCB          TCB -> JSCB.\n         USING IEZJSCB,R2\n         L     R2,JSCBACT          ACTIVE JSCB.\n        SETAUTH ,                                                  -EU-\n**-EU-   LA    R0,1                INDICATE AUTHORIZATION ON.\n**-EU-   SVC   232                 ***** INSTALLATION DEPENDANT *******\n         MODESET KEY=ZERO          JSCB IS IN KEY ZERO.\n         SPACE 1\n* OPENING A CATALOG AS A DATASET SEEMS TO CAUSE PASSWORD PROMPTING\n* EVEN FOR READING. HERE I SET THE BYPASS PASSWORD BIT TO GIVE OPER\n* A BREAK.\n         SPACE 1\n         OI    JSCBSWT1,JSCBPASS   SAY, NO PASSWORDS PLEASE.\n         MODESET KEY=NZERO         BACK TO USER KEY.\n         OPEN  ACBICAT             OPEN THE BCS CLUSTER.\n         LR    R3,R15              SAVE OPEN R.C.                  -EU-\n         MODESET KEY=ZERO          KEY ZERO TO MODIFY JSCB.        -EU-\n         NI    JSCBSWT1,255-JSCBPASS  BYPASS PASSWORD OFF.\n         MODESET KEY=NZERO         BACK TO USER KEY.\n         DROP  R2\n        RESAUTH ,                                                  -EU-\n**-EU-   XR    R0,R0               INDICATE AUTHORIZATION OFF.\n**-EU-   SVC   232                 ***** INSTALLATION DEPENDANT *******\n         LTR   R3,R3               DID IT OPEN?                    -EU-\n         BZ    OPENOK              YES.\n         SHOWCB  ACB=ACBICAT,AREA=OPENERR,LENGTH=4,                    X\n               FIELDS=(ERROR)      STORE OPEN ERROR CODE.\n         L     R2,OPENERR          PICK ERROR CODE.                -EU-\n         ABEND 14,DUMP             AND DIE.\nOPENOK   LA    R2,ACBICAT                                          -EU-\n         USING IFGACB,R2                                           -EU-\n         TM    ACBINFL2,ACBCATX    CATX OPEN?                      -EU-\n         BO    OPICAT1             YES, OK                         -EU-\n         ABEND 17,DUMP             NO, DIE                         -EU-\nOPICAT1  L     R1,TCBTIO           A(TIOT)                         -EU-\n         DROP  R5                                                  -EU-\n         AH    R1,ACBTIOT          + OFFSET -> DD ENTRY            -EU-\n         DROP  R2                                                  -EU-\n         XR    R2,R2                                               -EU-\n         ICM   R2,B'0111',12(R1)   -> JFCB - SWA BLOCK             -EU-\n         MVC   CATNAME(44),ZB502L(R2)   SET CATALOG NAME IN HEADING-EU-\n         $OUT  ,                                                   -EU-\n         EJECT ,                                                   -EU-\n*        LITERAL POOL.                                             -EU-\n         SPACE 1                                                   -EU-\n         LTORG ,\n         SPACE 2\n         COPY  LISTICDS                                      @120  -EU-\n         SPACE 2                                                   -EU-\n         COPY  LISTICDA                                      @120  -EU-\n         SPACE 2                                                   -EU-\n         PRINT NOGEN                                               -EU-\n         COPY  LISTICPR                                      @120  -EU-\n         SPACE 2                                                   -EU-\n         PRINT NOGEN                                               -EU-\n         COPY  LISTICMS                                      @122  -EU-\n         SPACE 2                                                   -EU-\n         END   LISTICAT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTICDA": {"ttr": 23557, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\t\\x7f\\x00\\x88\\t\\x7f\\x15H\\x00\\xcf\\x00\\xcf\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-06T00:00:00", "modifydate": "1988-04-06T15:48:00", "lines": 207, "newlines": 207, "modlines": 0, "user": "SYSPAJA"}, "text": "         EJECT ,                                                   -EU-\n*        DATA AREAS.                                               -EU-\n*        -----------                                               -EU-\n         SPACE 1                                                   -EU-\nDATASECT CSECT\n         DS    0D\nDTWORK   DC    D'0'                WORK FIELD FOR DATE CONVERSION\nDTPARM   DC    AL4(0)\nDTL5     EQU   DTWORK+3,5          5 BYTES FOR EDIT MACRO\nDTL4     EQU   DTWORK+4,4          4 BYTES FOR EDIT MACRO\nDTL3     EQU   DTWORK+5,3          3 BYTES FOR EDIT MACRO\nDTL2     EQU   DTWORK+6,2          2 BYTES FOR EDIT MACRO\n         DS    0F\nBUFLEN   DC    AL4(1024*128)       128K RECORD BUFFER\nOPENERR  DC    AL4(0)              OPEN ERROR CODE.\nBUFPTR   DC    AL4(0)\nRPLICAT  DC    AL4(0)              MOVE MODE RPL FOR BCS ACCESS.\nACBICAT  ACB   AM=VSAM,DDNAME=SYSUT1,EXLST=EXLICAT,                    X\n               BUFNI=16,BUFND=16\nEXLICAT  EXLST EODAD=EODICAT\nPAGELEN  EQU   60\n         DS    0F\nMCDSPTR  DC    AL4(0)\nMCDSKEY  DC    CL44' '\nRPLMCDS  RPL   ACB=ACBMCDS,AM=VSAM,AREA=MCDSPTR,AREALEN=4,             X\n               ARG=MCDSKEY,                                            X\n               OPTCD=(KEY,DIR,LOC)\nACBMCDS  ACB   AM=VSAM,DDNAME=SYSUT2,BUFNI=16\nMCDSOPEN DC    X'00'\n         DS    0F\n         SPACE 1\n* THE FOLLOWING FIELDS ARE FILLED IN BY SUBROUTINES\n*   VVDS : FOR VSAM OBJECTS\n*   VTOC : FOR NONVSAM DATASETS\n         SPACE 1\nBLKSIZE  DC    F'0'\nLRECL    DC    F'0'\nTRACKS   DC    F'0'\n         SPACE 1\nFDBK     DC    CL4' '              RPL FEEDBACK CODE.              @122\n         SPACE 1\nCNTDATA  DC    PL4'0'              COUNT OF DATA CELLS READ.\nCNTINDEX DC    PL4'0'              COUNT OF INDEX CELLS READ.\nCNTNVSAM DC    PL4'0'              COUNT OF NVSAM CELLS READ.\nCNTCLUST DC    PL4'0'              COUNT OF CLUSTER CELLS READ.\nCNTGDGB  DC    PL4'0'              COUNT OF GDG BASE CELLS READ.\nCNTGDGE  DC    PL4'0'              COUNT OF GDG ENTRY CELLS READ.\nCNTPATH  DC    PL4'0'              COUNT OF PATH CELLS READ.\nCNTAIX   DC    PL4'0'              COUNT OF ALTERNATE INDEX CELLS READ.\nBCSGETS  DC    PL4'0'              GETS ISSUED AGAINST BCS.\nVVDSGETS DC    PL4'0'              GETS ISSUED AGAINST VVDS'S.\nCNTNF    DC    PL4'0'              NUMBER OF DATASETS NOT REALLY THERE.\nCNTNOENT DC    PL4'0'              NUMBER OF GDGBASES WITH NO ENTRIES.\nONE      DC    PL1'1'\n         SPACE 1\nWORK     DC    D'0'\nDWK1     EQU   WORK+7,1\nDWK2     EQU   WORK+6,2\nDWK3     EQU   WORK+5,3\nDWK4     EQU   WORK+4,4\n         SPACE 1\nTOTAL    DS    0CL133\n         DC    CL1' '\nT1COUNT  DC    CL7' '\n         DC    CL1' '\nT1TEXT   DC    CL124' '                                            @120\nT1NVSAM  DC    C'NONVSAM ENTRIES FOUND.'\nT1CLUST  DC    C'CLUSTER ENTRIES FOUND.'\nT1INDEX  DC    C'INDEX ENTRIES FOUND.'\nT1DATA   DC    C'DATA ENTRIES FOUND.'\nT1AIX    DC    C'ALTERNATE INDEX ENTRIES FOUND.'\nT1PATH   DC    C'PATH ENTRIES FOUND.'\nT1GDGB   DC    C'GENERATION DATA GROUP BASES FOUND.'\nT1GDGE   DC    C'GENERATION DATA GROUP ENTRIES FOUND.'\nT1BCS    DC    C'GETS ISSUED AGAINST THE BASIC CATALOG STRUCTURE.'\nT1VVDS   DC    C'GETS ISSUED AGAINST VVDS(S).'\nT1NF     DC    C'NONVSAM DATASETS CATALOGUED BUT NOT FOUND.'\nT1NOENT  DC    C'GENERATION DATA GROUP BASES FOUND WITH NO ENTRIES.'\n         SPACE 1\nSEARCH   CAMLST  SEARCH,CAMDSN,CAMVOL,FORMAT1\nCAMDSN   DC    CL44' '\nCAMVOL   DC    CL6' '\nFORMAT1  DC    XL148'00'\nOBTAINRC DC    F'0'\nF3CAMLST CAMLST  SEEK,CCHHR3,CAMVOL,FORMAT3\nCCHHR3   DC    XL5'00'\nFORMAT3  DC    XL148'00'\nSTARTTRK DC    F'0'\nR2SAVE   DC    F'0'                SAVE R2 WHEN CHECKING FOR OPTIONAL\n*                                  BCS CELLS\nR6SAVE   DC    F'0'                SAVE R6 WHEN CHECKING FOR OPTIONAL\n*                                  VVDS CELLS\nR9SAVE   DC    F'0'                SAVE R9 WHEN HEXING VVDS DATA\nSV1EXT1  DC    XL10'00'\nSV1EXT2  DC    XL10'00'\nSV1EXT3  DC    XL10'00'\nSV3EXT4  DC    XL10'00'\nSV3EXT5  DC    XL10'00'\nSV3EXT6  DC    XL10'00'\nSV3EXT7  DC    XL10'00'\nSV3EXT8  DC    XL10'00'\nSV3EXT9  DC    XL10'00'\nSV3EXT10 DC    XL10'00'\nSV3EXT11 DC    XL10'00'\nSV3EXT12 DC    XL10'00'\nSV3EXT13 DC    XL10'00'\nSV3EXT14 DC    XL10'00'\nSV3EXT15 DC    XL10'00'\nSV3EXT16 DC    XL10'00'\n         DS    0F\nLOCDSN   DC    AL4(VVDSN),Y(17)\nVVDSN    DC    C'SYS1.VVDS.V'\nVVDSNAME DC    CL6' '\n         DS    0F\nLOCDDN   DC    AL4(VVDDN),Y(8)\nVVDDN    DS    0CL8\n         DC    C'V'\nVVDDNAME DC    CL6' ',C' '\nVVDSGETL EQU   32*VVDSTLEN         32 VVDS'S AT MOST\nVVDSTAD  DC    A(0)                ADDRESS OF VVDSTAB\nHIGHUCB  DC    Y(0)                HIGHEST UCB ADDR FOUND\nRBASAVE  DC    F'0'                RBA ARG FOR VVDS GET\nSHOWRBA1 DC    F'0'\nSHOWRBA2 DC    F'0'\nSVCOMPN  DC    CL44' '             BCS NAME. FOR COMPARE TO VVRCOMP\nGDGSAVE  DC    CL44' '             GDG BASE NAME. SAVED TO DEVELOP\n*                                    ENTRY NAMES FROM NAME CELLS\nGDGWORK  DC    CL44' '             WORKAREA TO DEVELOP ENTRY NAME\nGWORD    DC    D'0'\nGWK3     EQU   GWORD+5,3\nGWK2     EQU   GWORD+6,2\n         SPACE 1\n* THIS SWITCH IS USED TO DETECT THE FIRST BCS CELL READ IN. THE THEORY\n* IS THAT THIS IS THE CLUSTER CELL FOR THE ICF CATALOG ITSELF. THE NAME\n* OF THE FOLLOWING DATA CELL IS THE CATALOG NAME (AS IT WERE) AND\n* IS INSERTED INTO THE HEADING FOR THE DELECTATION OF USERS WHO CAN'T\n* REMEMBER WHAT CATALOG THEY WERE LISTING.\n         SPACE 1\nFIRST    DC    XL1'00'\n* THIS SWITCH IS USED TO DETECT THE SITUATION OF A GDGBASE NOT BEING\n* FOLLOWED BY ANY ENTRIES FOR THE GDG.\nBASESW   DC    XL1'00'\n         DS    0F\nSAVECL   DC    AL4(0)              SAVE ADDR OF ICF CLUSTER CELL.\n         SPACE 1\nTRKCYL   DC    AL4(*-*)            TRACKS PER CYLINDER, CURRENT DS.\n         SPACE 1\nPWA      XPRDCB  DDNAME=SYSPRINT\nHEADER1  XPRLDEF TEXT=HTEXT1,LENGTH=L'HTEXT1,SPB=(0,ATHOF),SPA=1\nHTEXT1   DC    C'&NAME &VERSION -- LISTING OF ICF CATALOG --           X\n                                                   '           -EU-@121\nCATNAME  EQU   HTEXT1+44                                           @121\nHEADER2  XPRLDEF TEXT=HTEXT2,LENGTH=132,SPA=2\nHTEXT2   DS    0CL133\n         DC    CL44'DSNAME',CL2' '\n         DC    CL7'TYPE',CL2' '\n         DC    CL6'VOLUME',CL2' '\n         DC    CL6'UNIT',CL3' '\n         DC    CL5'TRKS',CL2' '\n         DC    CL5'BLKSZ',CL2' '\n         DC    CL5'LRECL',CL2' '\n         DC    CL8'CREATED ',CL33' '\nHEADER3  XPRLDEF TEXT=HTEXT3,LENGTH=132,SPA=2\nHTEXT3   DS    0CL133\n         DC    CL7'TYPE',CL2' '\n         DC    124C'-'\n         ORG   *-124\n         DC    C'CELL FORMATS '\n         ORG   HTEXT3+133\nRPTLINE1 DS    0CL133\n         DC    CL1' '\nL1DSNAME DC    CL44' ',CL2' '\nL1TYPE   DC    CL7' ',CL2' '\nL1VOLUME DC    CL6' ',CL2' '\nL1UNIT   DC    CL6' ',CL3' '\nL1TRACKS DC    CL5' ',CL2' '\nL1BLKSIZ DC    CL5' ',CL2' '\nL1LRECL  DC    CL5' ',CL2' '\nL1CREDT  DC    CL8' ',CL33' '\nRPTLINE2 DS    0CL133\n         DC    CL1' '\nL2TYPE   DC    CL7' ',CL2' '\nL2WORK   DC    CL124' '\nNUMBERS  DC    C'0123456789ABCDEF'\nTRHEX    EQU   *-256\nDEPTH    DC    F'0'\nENTRIES  DS    16F\nEXITS    DS    16F\n         SPACE 1                                                   @120\nPLINE1   DC    A(0,RPTLINE1+1)    PARMS TO PRINT RPTLINE1          @120\nPLINE2   DC    A(0,RPTLINE2+1)    PARMS TO PRINT RPTLINE2          @120\nPLINE2A  DC    A(1,RPTLINE2+1)    SKIP ONE, THEN PRINT RPTLINE2    @120\n         SPACE 1                                                   @120\nPARMLIST DS    3F                 PARMLIST MAPPING FOR UCB         @120\n         ORG   PARMLIST                                            @120\nPARMWA   DS    F                  ADDR OF 100-BYTE WORK AREA       @120\nPARMDEVT DS    F                  ADDR OF DEV TYPE TO SCAN FOR     @120\nPARMUCB  DS    F                  ADDR OF RETURNED UCB             @120\n         SPACE 1                                                   @120\nDEVCLASS DS    CL1                DEVICE CLASS TO SEARCH FOR       @120\nADDRUCB  DS    F                  RETURNED UCB ADDR                @120\nSCANSAVE DS    F                  ADDR OF SCAN SERVICE ROUTINE     @120\nXASWITCH DC    X'00'              INITIALIZE SWITCH                @120\n         DS    0D                 FOR ALIGNMENT                    @120\nUCBWORK  DS    CL100              UCB WORK AREA                    @120\n         SPACE 1                                                   @120\n         DYNSPACE  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTICDC": {"ttr": 23561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\t\\x7f\\x00\\x88\\t\\x7f\\x15S\\x01\\x15\\x01\\x15\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-06T00:00:00", "modifydate": "1988-04-06T15:53:00", "lines": 277, "newlines": 277, "modlines": 0, "user": "SYSPAJA"}, "text": "         EJECT ,                                                   -EU-\n*        DISCLAIMER - INSTALLATION INSTRUCTIONS.                   -EU-\n*        =======================================                   -EU-\n         SPACE 1                                                   -EU-\n***********************************************************************\n*                                                                     *\n*     THIS PROGRAM, DEVELOPED AT CONTINENTAL BANK OF CANADA OR        *\n*     SUPPLIED BY OTHER USERS ON A NON-RESTRICTIVE BASIS, IS OF       *\n*     GENERAL INTEREST AND IS SUBMITTED FOR UNRESTRICTED DISTRIBUTION.*\n*                                                                     *\n*     THE AUTHOR HAS, SINCE DEVELOPING THIS PROGRAM, MOVED TO         *\n*     MANUFACTURER'S LIFE INSURANCE.  USERS ARE INVITED TO SUBMIT     *\n*     SUGGESTIONS OR ERROR DOCUMENTATION TO MANULIFE. HOWEVER, NO     *\n*     PROMISE CAN BE MADE THAT SUCH SUGGESTIONS WILL BE IMPLEMENTED   *\n*     OR ERRORS CORRECTED.  SUBMIT COMMENTS TO:                       *\n*                                                                     *\n*              JIM LANE                                               *\n*              HARDWARE MANAGEMENT                                    *\n*              MANUFACTURER'S LIFE INSURANCE                          *\n*              200 BLOOR ST E.                                        *\n*              TORONTO, ONTARIO M4W 1E5                               *\n*                                                                     *\n*                PHONE: (416)-926-3076                                *\n*                                                                     *\n*                SHARE INSTALLATION CODE: MLF                         *\n*                                                                     *\n*     THIS PROGRAM IS MADE AVAILABLE BY MLI WITHOUT CHARGE OR         *\n*     CONSIDERATION.  RECIPIENTS ARE FREE TO MAKE THIS PROGRAM        *\n*     AVAILABLE TO OTHERS IN LIKE MANNER.  IT MAY NOT BE SOLD.        *\n*                                                                     *\n*                                                                     *\n* NAME         LISTICAT                                               *\n*                                                                     *\n* FUNCTION     LIST THE CONTENTS OF AN ICF CATALOG AND SELECTED       *\n*              DSCB AND VVDS FIELDS.                                  *\n*                                                                     *\n* DESCRIPTION  THE UCBS OF ALL ONLINE DASD VOLUMES ARE LOCATED AND    *\n*              AN ATTEMPT IS MADE TO ALLOCATE SYS1.VVDS.VVOLSER.      *\n*              IF THIS WORKS AN ACB AND RPL ARE GENERATED AND THEIR   *\n*              ADDRESSES ARE SAVED IN A LOOKUP TABLE.                 *\n*              THE BCS CLUSTER IS OPENED AS A DATASET AND READ        *\n*              SEQUENTIALLY. THE BCS RECORDS ARE SCANNED FOR CELL     *\n*              TYPES AND THE FOLLOWING CELLS ARE LISTED:              *\n*                                                                     *\n*                NONVSAM                                              *\n*                CLUSTER                                              *\n*                INDEX                                                *\n*                DATA                                                 *\n*                AIX                                                  *\n*                PATH                                                 *\n*                GDG BASE                                             *\n*                GDG ENTRY                                            *\n*                                                                     *\n*              FOR NONVSAM ENTRIES THE FORMAT1 AND, IF IT EXISTS THE  *\n*              FORMAT 3, DSCB IS \"OBTAINED\" TO DETERMINE IF THE       *\n*              OBJECT EXISTS. IF IT DOES THE LRECL, BLKSIZE AND       *\n*              TOTAL TRACKS ALLOCATED ARE EXTRACTED.                  *\n*              IF THE OBJECT IS CATALOGUED TO VOLSER \"MIGRAT\" THE     *\n*              HSM MIGRATIONCONTROLDATASET IS OPENED (SYSUT2) AND     *\n*              USED INSTEAD OF THE VTOC.                              *\n*                                                                     *\n*              FOR DATA AND INDEX ENTRIES THE VVDS OF THE VOLUME IN   *\n*              QUESTION, IF AVAILABLE, IS SCANNED TO DETERMINE THE    *\n*              LRECL, BLKSIZE AND TRACK ALLOCATION OF THE OBJECT.     *\n*                                                                     *\n* ENVIRONMENT  MVS/XA 2.1.7                                        -EU-\n*                                                                     *\n* INPUT        THE BCS OF THE ICF CATALOG TO BE LISTED.               *\n*                                                                     *\n* OUTPUT       OUTPUT CONSISTS OF A LISTING OF THE CATALOG.           *\n*                                                                     *\n*                                                                     *\n*                   DSNAME - THE NAME OF THE COMPONENT BEING LISTED.  *\n*                        FOR GDG ENTRIES THIS IS DEVELOPED INTO THE   *\n*                        FORMAT THAT WOULD BE IN A FORMAT1 DSCB.      *\n*                                                                     *\n*                   TYPE - THE TYPE OF THE CELL BEING LISTED.         *\n*                                                                     *\n*                   VOLUME - THE VOLSER OF THE VOLUME TO WHICH THE    *\n*                        OBJECT IS CATALOGED. FILLED IN ONLY FOR      *\n*                        NONVSAM, DATA, INDEX AND GDG ENTRIES.        *\n*                                                                     *\n*                   UNIT - THE NAME OF THE UNIT TO WHICH THE          *\n*                        OBJECT IS CATALOGED. FILLED IN ONLY FOR      *\n*                        NONVSAM, DATA, INDEX AND GDG ENTRIES.        *\n*                                                                     *\n*                   TRKS - THE NUMBER OF TRACKS ALLOCATED TO A DASD   *\n*                        RESIDENT OBJECT. LEFT BLANK FOR CATALOGED,   *\n*                        NON-EXISTING AND TAPE-RESIDENT OBJECTS.      *\n*                                                                     *\n*                   BLKSZ - THE PHYSICAL BLOCK SIZE OF THE OBJECT.    *\n*                        LEFT BLANK FOR CATALOGED,                    *\n*                        NON-EXISTING AND TAPE-RESIDENT OBJECTS.      *\n*                                                                     *\n*                   LRECL - THE LOGICAL RECORD LENGTH OF THE OBJECT.  *\n*                        LEFT BLANK FOR CATALOGED,                    *\n*                        NON-EXISTING AND TAPE-RESIDENT OBJECTS.      *\n*                                                                     *\n* CONSIDERATIONS                                                      *\n*                                                                     *\n*              ABEND CODES:                                           *\n*                                                                     *\n*                   U0014 - BCS CLUSTER FAILED TO OPEN.               *\n*                        ERROR CODE IN REGISTER 2.                    *\n*                                                                     *\n*                   U0015 - BCS GET FAILED.                           *\n*                                                                     *\n*                   U0016 - VVDS GET ERROR.                        @122\n*                                                                     *\n*                   U0017 - SYSUT1 NOT ICF CATALOG.                -EU-\n*                                                                     *\n* PARAMETERS   PARM=DUMP PRODUCES A HEX-TRANSLATED LISTING OF         *\n*                        BCS AND VVDS CELLS.                          *\n*                                                                     *\n* EXECUTION    DDNAMES                                                *\n*                                                                     *\n*              STEPCAT  DEFINES THE ICF CATALOG TO BE LISTED.         *\n*                                                                     *\n*              SYSUT1   DEFINES THE ICF CATALOG TO BE LISTED.         *\n*                                                                     *\n*              SYSUT2   DEFINES THE HSM MIGRATIONCONTROLDATASET.      *\n*                       IF YOU DON'T HAVE HSM THIS CAN BE LEFT OUT.   *\n*                                                                     *\n*              SYSPRINT DEFINES THE OUTPUT LISTING DATA SET.          *\n*                                                                     *\n*              SYSLIST  DEFINES THE MESSAGES LISTING DATA SET.        *\n*                                                                     *\n* EXAMPLE                                                             *\n*                                                                     *\n*              //LCAT   EXEC  PGM=LISTICAT                            *\n*              //STEPCAT  DD  DSN=ICF.CATALOG,DISP=OLD                *\n*              //SYSUT1   DD  DSN=ICF.CATALOG,DISP=OLD                *\n*              //SYSUT2   DD  DSN=HSM.MCDS,DISP=OLD                   *\n*              //SYSPRINT DD  SYSOUT=*                                *\n*              //SYSLIST  DD  SYSOUT=*                                *\n*              //SYSUDUMP DD  SYSOUT=*                                *\n*                                                                     *\n* NON-IBM MACROS USED (IN MAINLINE OR SUBROUTINES)                    *\n*              $EPILOG  - MAIN EXIT LINKAGE                           *\n*              $IN      - SUBROUTINE ENTRY LINKAGE                    *\n*              $OUT     - SUBROUTINE EXIT LINKAGE                     *\n*              $PROLOG  - MAIN ENTRY LINKAGE                          *\n*              $REGS    - REGISTER EQUATES                            *\n*              ALLOC    - DYNAMIC ALLOCATION                          *\n*              DYNSPACE - GENERATE PARMLIST FOR ALLOC                 *\n*              EDIT     - FORMAT A DISPLAY NUMERIC FIELD              *\n*              HEX      - CONVERT HEX TO PRINTABLE                    *\n*              XPRCLOSE - CLOSE A PRINT FILE                          *\n*              XPRDCB   - DEFINE A PRINT FILE                         *\n*              XPRHEAD  - DEFINE A REPORT HEADING                     *\n*              XPRLDEF  - DEFINE A REPORT LINE LAYOUT                 *\n*              XPRNTLIN - PRINT A REPORT LINE                         *\n*              XPROPEN  - OPEN A PRINT FILE                           *\n*                                                                     *\n* IBM MACROS USED  (IN MAINLINE OR SUBROUTINES)                       *\n*              ABEND    - ABNORMAL TERMINATION.                       *\n*              ACB      - DEFINE AN ACB                               *\n*              CAMLST   - DEFINE A PARMLIST FOR OBTAIN                *\n*              CLOSE    -                                             *\n*              CVT      - MAP THE CVT FOR UCB SCAN.                   *\n*              DCB      - DEFINE A DCB                                *\n*              EXLST    - DEFINE AN EXIT LIST FOR EOF                 *\n*              FREEPOOL - FREE BUFFERS                                *\n*              GENCB    - GENERATE A VSAM CONTROL BLOCK               *\n*              GET      - READ A VSAM LOGICAL RECORD                  *\n*              GETMAIN  - ALLOCATE VIRTUAL STORAGE                    *\n*              IEFUCBOB - MAP A UCB                                   *\n*              IEFZB4D0 - DYNALLOC DATA AREAS                         *\n*              IEFZB4D2 - DYNALLOC DATA AREAS                         *\n*              IEZJSCB  - MAP MY JOBSTEP CONTROL BLOCK                *\n*              IKJTCB   - MAP MY TCB                                  *\n*              MODESET  - GET INTO AND OUT OF SUPR STATE/KEY 0        *\n*              OBTAIN   - READ A DSCB                                 *\n*              OPEN     -                                             *\n*              POINT    - ESTABLISH POSITIONING WITHIN A VSAM FILE    *\n*              SHOWCB   - PICK VSAM ERROR CODES.                      *\n*              SYNADAF  - DIAGNOSE A NON-VSAM I/O ERROR               *\n*              SYNADRLS - RELEASE SYNADAF WORKAREAS                   *\n*              TIME                                                   *\n*              WTO      - GIVE OPER THE BAD NEWS.                     *\n*                                                                     *\n* AUTHOR       THIS PORTIONS OF THIS PROGRAM HAVING TO DO WITH        *\n*              PASSING THE BCS AND VVDS'S WERE WRITTEN BY J. LANE     *\n*              AT CBOC. A LOT OF THE REST OF THE CODE HAS BEEN        *\n*              BORROWED FROM VARIOUS SOURCES, MOSTLY OFF THE CBT      *\n*              TAPE. IF SOMETHING IN HERE LOOKS LIKE YOU WROTE IT,    *\n*              YOU PROBABLY DID.                                      *\n*                                                                     *\n* REGISTER USAGE                                                      *\n*                                                                     *\n*              R0  - WORK REGISTER.                                   *\n*              R1  - WORK REGISTER.                                   *\n*              R2  - WORK REGISTER.                                @122\n*              R3  - ADDRESS OF CURRENT BCS CELL.                  @122\n*              R4  - BASE ADDRESS OF DATASECT.                        *\n*              R5  - WORK REGISTER.                                   *\n*              R6  - ADDRESS OF CURRENT VVDS CELL.                    *\n*              R7  - WORK REGISTER.                                   *\n*              R8  - WORK REGISTER.                                   *\n*              R9  - SUBROUTINE LINKAGE.                              *\n*              R10 - PROGRAM BASE REGISTER 1                          *\n*              R11 - PROGRAM BASE REGISTER 2                          *\n*              R12 - PROGRAM BASE REGISTER 3                          *\n*              R13 - SAVE AREA ADDRESS                                *\n*              R14 - LINKAGE                                          *\n*              R15 - LINKAGE                                          *\n*                                                                     *\n***********************************************************************\n         EJECT ,                                                   -EU-\n***********************************************************************\n*                                                                     *\n* NOTES  A PROGRAM MUST BE APF-AUTHORIZED IN MVS TO OPEN A CATALOG    *\n*        AS A DATASET. I DO THIS WITH A USER SVC. IF YOU HAVE SUCH A  *\n*        THING, CHANGE FROM SVC 232 TO WHATEVER NUMBER YOU HAVE.      *\n*                                                                     *\n*        AT THE BANK I WAS GETTING PASSWORD PROMPTS WHEN I OPENED THE *\n*        CATALOG. RATHER THAN FIGURE OUT WHY I TURNED ON THE          *\n*        \"NO-PASSWORD\" BIT IN THE JSCB. THIS MAY NOT BE NECESSARY IN  *\n*        YOUR ENVIRONMENT AND, IF SO, YOU CAN TAKE OUT THE LOGIC.     *\n*                                                                     *\n*        THE HEX-DUMP LISTING CAN BE A SECURITY EXPOSURE AS WRITTEN   *\n*        BECAUSE IT PRINTS OUT THE \"SECURITY\" CELL, IF PRESENT, WHICH *\n*        CONTAINS THE PASSWORDS FOR PROTECTED OBJECTS. SECURITY       *\n*        OFFICERS MAY NOT TAKE THAT IN THE NICEST SORT OF WAY!        *\n*                                                                     *\n*        NO ATTEMPT IS MADE TO DISCERN WHETHER SYSUT1 IS ACTUALLY AN  *\n*        ICF CATALOG OR NOT. IF, INADVERTENTLY, IT ISN'T THIS CODE    *\n*        WILL PROBABLY LOOP.                                          *\n*                                                                     *\n*        I WROTE THIS CODE IN THE WINTER OF 1983-1984 WHEN CBOC WAS   *\n*        CONVERTING TO ICF CATALOGS. SINCE THE CONVERSION WENT MORE   *\n*        SMOOTHLY THAN IT MIGHT HAVE DONE, I NEVER HAD A BROKEN       *\n*        CATALOG TO WORK WITH. THEREFORE, THIS CODE ASSUMES A         *\n*        VALIDLY STRUCTURED CATALOG. I MAKE NO GUARANTEES WHAT MIGHT  *\n*        HAPPEN OTHERWISE.                                            *\n*                                                                     *\n***********************************************************************\n         EJECT ,                                                   -EU-\n***********************************************************************\n*                                                                     *\n* CHANGE ACTIVITY SUMMARY:                                            *\n*                                                                     *\n*    @122    - ADDED EXTRA DIAGNOSTIC CHECKING AND MESSAGES TO HANDLE *\n*              PROBLEM REPORTED BY R. DIETES OF H.E. BUTT GROCERY CO. *\n*              SITUATION WAS THE CASE WHERE THE BCS INFO EXISTS, THE  *\n*              VVDS EXISTS BUT IT DOESN'T CONTAIN ANYTHING TO MATCH   *\n*              THE DATASET FOUND IN THE BCS.                          *\n*              FIX WAS TO SENSE END OF FILE REACHED WHILE SCANNING    *\n*              THE VVDS FOR THE VVR OF A CLUSTER COMPONENT, PRODUCE   *\n*              MESSAGE ABOUT VVR NOT FOUND WHEN EXPECTED AND PASS A   *\n*              RETURN CODE TO THE CALLER.                             *\n*            - ADD 3480 DEVICE TYPE SUPPORT.                          *\n*            - TEST HSM LOGIC WITH DFHSM 2.1.0                        *\n*            - CLOSE MCDS AT EOJ IF IT WAS OPENED.                    *\n*    @121    - WAS ASSUMING AN 8-CHARACTER CATALOG NAME FOR THE       *\n*              TITLE LINE. OOPS!                                      *\n*    @120    - CHANGES FOR MVS/XA. USE SCAN ROUTINE INSTEAD OF        *\n*              UCB HALF-WORD LOOKUP TABLE.                            *\n*            - LENGTHEN PRINTLINE AREA USED FOR PRINTING TOTALS TO    *\n*              CORRECT FORMATTING PROBLEM.                            *\n*            - BREAK OUT SOME PARTS OF THE CODE INTO COPY MEMBERS TO  *\n*              MAKE IT MORE EDITABLE.                                 *\n*            - AN RPL WAS NOT BEING CREATED PRIOR TO I/O IN THE       *\n*              HEX-PRINT PART OF THE LOGIC.                           *\n*            - ADD CELL TYPE COUNTING TO HEX LOGIC.                   *\n*    24APR25 - BUGS FOUND AFTER AUTHOR'S MOVE TO MANULIFE.            *\n*            - 3380 MISSING FROM DEVICE TYPE TABLE.                   *\n*            - DONT BE SO SURE I KNOW HOW MANY TRACKS THERE ARE IN A  *\n*              CYLINDER. AT CBOC I HAD ONLY 3375'S.                   *\n*    24APR87 - REPLACED THE DEVICE CODE NAME TABLE BY ROUTINE     -EU-*\n*              'DVTYUN' WHICH RETRIEVES DYNAMICALLY THE UNIT      -EU-*\n*              NAME FROM THE DEVICE TYPE, AND GET THROUGH THE     -EU-*\n*              CVTZDTAB THE NUMBER OF TRACKS PER CYLINDER INFO.   -EU-*\n*            - TEST IF OPENED SYSUT1 IS AN ICF CATALOG.           -EU-*\n*    12MAY87 - FLAGS DEFINITIONS BITS CORRECTED IN DSECTS 'DINC', -EU-*\n*              'ANC' AND 'PNC'.                                   -EU-*\n***********************************************************************\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTICDS": {"ttr": 23811, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\t\\x7f\\x00\\x88\\t\\x7f\\x15H\\x01\\x99\\x01\\x99\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-06T00:00:00", "modifydate": "1988-04-06T15:48:00", "lines": 409, "newlines": 409, "modlines": 0, "user": "SYSPAJA"}, "text": "         EJECT ,                                                   -EU-\n*        DSECTS FOR CATALOG CELLS.                                 -EU-\n*        -------------------------                                 -EU-\n         SPACE 1                                                   -EU-\nVVDSTAB  DSECT ,\nVVDSVOL  DS    CL6                 VOLSER OF A VOLUME WITH A VVDS\nVVDSACB  DS    0F,AL4              ADDRESS OF A GENERATED ACB\nVVDSRPL  DS    AL4                 ADDRESS OF A GENERATED RPL\nVVDSBUF  DS    AL4                 ADDRESS OF A RECORD BUFFER\nVVDSARG  DS    AL4                 ADDRESS OF RBA TO READ THE VVDS\nVVDSTLEN EQU   *-VVDSTAB           LENGTH OF AN ENTRY\n         SPACE 2\nVCNC     DSECT                     VSAM CLUSTER NAME CELL\nCLCELLN  DS    XL2                 LENGTH OF VCNC INCLUDING ITSELF\nCLTYPE   DS    CL1                 TYPE 'C' FOR CLUSTER\nCLCOMPLN DS    XL2                 LENGTH OF THE CLUSTER COMPONENT\nCLNOEXT  DS    XL1                 NUMBER OF EXTENSION RECORDS\nCLNMLEN  DS    XL1                 LENGTH OF THE CLUSTER KEY (45)\nCLNAME   DS    CL44                CLUSTER NAME\nCLNMPAD  DS    XL1                 PAD VALUE, SET TO X'00'\n         SPACE 2\nDINC     DSECT                     DATA OR INDEX NAME CELL\nDIDLEN   DS    XL2                 LENGTH OF DINC\nDIDTYPE  DS    CL1                 TYPE 'D' FOR DATA OR INDEX\nDIDCMPLN DS    XL2                 LENGTH OF DINC COMPONENT\nDIDIRFLG DS    XL1                 INTERRUPT RECOGNITION FLAGS\nDIDELETE EQU   B'10000000'         DELETE IN PROGRESS\nDIDUPDAT EQU   B'01000000'         UPDATE-EXTEND IN PROGRESS\nDIDSRMU  EQU   B'00100000'         SUB-RECORD MOVE/UPDATE IN PROGRESS\nDIDKEYLN DS    XL1                 CONDENSED KEYLENGTH\nDIDKEY   DS    0XL1                CONDENSED KEY\n         SPACE 2\nANC      DSECT                     ALTERNAME INDEX CELL\nAIXLEN   DS    XL2                 LENGTH OF ANC\nAIXTYPE  DS    CL1                 TYPE 'G' FOR ANC\nAIXCMPLN DS    XL2                 LENGTH OF AIX COMPONENT\nAIXFLAG  DS    XL1                 FLAG BYTE\nAIXUPG   EQU   B'10000000'         AIX IS MEMBER OF UPGRADE SET\nAIXKEYLN DS    XL1                 CONDENSED KEYLENGTH\nAIXKEY   DS    0XL1                CONDENSED KEY 2-45 BYTES\n         SPACE 2\nPNC      DSECT                     PATH NAME CELL\nPATHCELN DS    XL2                 LENGTH OF PATH CELL\nPATHTYPE DS    CL1                 TYPE 'R' FOR PATH\n         DS    XL2\nPATHATTR DS    XL1                 PATH ATTRIBUTES\nPATHUPG  EQU   B'10000000'         UPGRADE IF RELATED TO AIX\nPATHUPD  EQU   B'10000000'         UPDATE IF RELATED TO CLUSTER.\nPATHREL  EQU   B'00100000'         0=RELATED TO AIX,1=RELATED TO\n*                                  CLUSTER\nPATHKYLN DS    XL1                 LENGTH OF PATH KEY\nPATHNAME DS    CL44                PATH NAME.\n         SPACE 2\nNVNC     DSECT                     NONVSAM DATASET CELL\nNVCELEN  DS    XL2                 LENGTH OF NVNC\nNVTYPE   DS    CL1                 TYPE 'A' FOR NONVSAM\nNVRESV   DS    XL1                 RESERVED\nNVOLCNT  DS    XL2                 NUMBER OF VOLUME CELLS (255 MAX)\nNVKEYLN  DS    XL1                 LENGTH OF THE NONVSAM KEY\nNVNAME   DS    CL44                DATASET NAME\nNVPAD    DS    XL1                 PAD VALUE X'00'\n         SPACE 2\nOWNERC   DSECT                     OWNERSHIP CELL FORMAT.\nOWNCELLN DS    XL2                 LENGTH OF OWNERSHIP CELL\nOWNTYPE  DS    XL1                 TYPE X'01' FOR OWNER\nOWNID    DS    XL8                 OWNER ID\nOWNFLAG  DS    XL1                 FLAG\nOWNRACF  EQU   B'10000000'         RACF PROTECTED\nOWNKSDS  EQU   B'01000000'         INDEX COMPONENT DATASET\nOWNREUS  EQU   B'00100000'         REUSABLE DATASET.\nOWNERASE EQU   B'00010000'         ERASE\nOWNSWAP  EQU   B'00000010'         SWAPSPACE\nOWNPAGE  EQU   B'00000001'         PAGESPACE\nOWNCREDT DS    XL3                 CREATION DATE\nOWNEXPDT DS    XL3                 EXPIRY DATE\n         SPACE 2\nSECURITY DSECT                     SECURITY CELL\nSECELLN  DS    XL2                 LENGTH OF SECURITY CELL\nSECTYPE  DS    XL1                 TYPE X'02' FOR SECURITY.\nSECMSTR  DS    CL8                 MASTER PASSWORD.\nSECCI    DS    CL8                 CONTROL INTERVAL PASSWORD.\nSECUPDTE DS    CL8                 UPDATE PASSWORD.\nSECREAD  DS    CL8                 READ PASSWORD.\nSECPMTCD DS    CL8                 PASSWORD PROMPTING CODE.\nSECATMP  DS    XL2                 MAXIMUM NUMBER OF ATTEMPTS.\nSECVRMOD DS    CL8                 USER SECURITY VERIFICATION MOD.\nSECRCDLN DS    XL2                 USER AUTHORIZATION RECORD LENGTH.\nSECRCD   DS    0XL1                USER AUTHORIZATION RECORD (256 MAX)\n         SPACE 2\nASSOCC   DSECT                     ASSOCIATION CELL\nASCLEN   DS    XL2                 ASSOCIATION CELL LENGTH\nASCTYPE  DS    XL1                 TYPE X'03' FOR ASSOC\nASCOUNT  DS    XL2                 COUNT OF ASSOCIATIONS\n* THE FOLLOWING FIELDS ARE REPEATED THE NUMBER OF TIMES IN ASCOUNT\nASCKEYS  DS    0XL2\nASCFLAG  DS    XL1                 FLAG\nASCREUS  EQU   B'10000000'         USED IN RELATION CELL ONLY.\nASCKYLEN DS    XL1                 LENGTH OF CONDENSED ASSOC KEY.\nASCKEY   DS    0XL1                2-45 BYTE CONDENSED KEY.\n         SPACE 2\nGDGNC    DSECT                     GDG BASE NAME CELL\nGDGCELLN DS    XL2                 LENGTH OF GDGNC INCLUDING ITSELF\nGDGTYPE  DS    CL1                 TYPE 'B' FOR GDG\nGDGCMPLN DS    XL2                 LENGTH OF THE GDG COMPONENT\nGDGNOEXT DS    XL1                 NUMBER OF EXTENSION RECORDS\nGDGKYLEN DS    XL1                 LENGTH OF THE GDG\nGDGNAME  DS    CL44                GDG NAME 1-35 BYTES BLANK PADDED\nGDGPAD   DS    XL1                 PAD VALUE, SET TO X'00'\n         SPACE 2\nGDSNC    DSECT                     GDG ENTRY NAME CELL\nGDSCELLN DS    XL2                 LENGTH OF GDSNC INCLUDING ITSELF\nGDSTYPE  DS    CL1                 TYPE 'H' FOR GDS\nGDSCMPLN DS    XL2                 LENGTH OF THE GDS COMPONENT\nGDSGENO  DS    XL2                 GENERATION NUMBER\nGDSVERNO DS    XL1                 VERSION NUMBER\nGDSVOLCT DS    XL2                 NUMBER OF VOLUME CELLS IN GDS\n         SPACE 2\nVOLCELL  DSECT                     VOLUME CELL\nVOLLEN   DS    XL2                 LENGTH OF VOLCELL\nVOLTYPE  DS    XL1                 TYPE X'04' FOR VOLUME CELL\nVOLOFSET DS    XL1                 UNUSED\nVOLSERN  DS    CL6                 VOLUME SERIAL NUMBER\nVOLDEVTP DS    XL4                 DEVICE TYPE\nVOLFLAG1 DS    XL1                 FLAG\nVOLPRIME EQU   B'10000000'         PRIME VOLUME-ALLOCATED SPACE\nVOLCANDI EQU   B'01000000'         CANDIDATE VOLUME NOSPACE\nVOLOFLOW EQU   B'00100000'         OVERFLOW KEYRANGE ONLY\nVOLCONV  EQU   B'00010000'         CONVERTED VSAM DATASET VOLUME\nVOLNVSAM EQU   B'00001000'         NONVSAM VOLUME CELL\nVOLKYRNG EQU   B'00000100'         KEYRANGE QUALIFIER PRESENT\nVOLVPCI  EQU   B'00000010'         PRIMARY VVR CI\nVOLSSQWD EQU   B'00000001'         SEQUENCE SET WITH DATA\nVOLFLAG2 DS    XL1                 RESERVED\nVOLVVRBA DS    0XL4                RELATIVE BYTE ADDRESS OF VVR\nVOLDSTTR DS    XL3                 NONVSAM FORMAT 1 DSCB TTR\n         DS    XL1                 RESERVED\nVOLFLSEQ DS    XL2                 NONVSAM FILE SEQUENCE NUMBER (TAPE)\nVOLKRQL  DS    XL4                 KEYRANGE QUALIFIER (VSAM ONLY)\nVOLLKYLN DS    XL2                 LENGTH OF LOW KEY RANGE KEY\n         SPACE 2\nRELCELL  DSECT                     RELATIONSHIP CELL.\nRELLEN   DS    XL2                 CELL LENGTH.\nRELTYPE  DS    XL1                 TYPE X'06'\nRELRESV  DS    XL1                 RESERVED.\nRELCNT   DS    XL1                 COUNT OF RELKEYS.\nRELKEYS  DS    0XL2\nRELFLAG  DS    XL1                 FLAG BYTE\nRELUPG   EQU   B'10000000'         UPGRADE AIX.\nRELGLEN  DS    XL1                 LENGTH OF AIX CONDENSED KEY.\nRELGKEY  DS    0XL1                AIX CONDENSED KEY.\n         SPACE 2\nVVR      DSECT\n*VVRLEN  DS    XL2                LENGTH OF ENTIRE VVR\nVVRHDLEN DS    XL2                 LENGTH OF VVR HEADER\nVVRTYPE  DS    CL1                 Z=PRIMARY VVR. Q=SECONDARY VVR\nVVRFLAG  DS    XL1                 HEADER FLAG\nVVRSELFD EQU   B'01000000'         SELF-DESCRIBING VVR FOR VVDS\nVVRCATDS EQU   B'00100000'         CATALOG SELF-DESCRIBING VVR\nVVRCOMTP EQU   B'00001000'         COMPONENT TYPE. 0='D' 1='I'\nVVRKRQ   DS    XL4                 KEY RANGE QUALIFIER\nVVRCMPNL DS    XL1                 COMPONENT NAME LENGTH\nVVRCMPNM DS    0CL44               COMPONENT NAME\n         SPACE 2\nVVRDSINF DSECT                     DATASET INFORMATION CELL\nVVRDSLEN DS    XL2                 CELL LENGTH.\nVVRDSTYP DS    XL1                 TYPE CODE IS X'21'\nVVRDSATR DS    0XL2                DATASET ATTRIBUTES\nVVRATTR1 DS    XL1\nVVRA1SPD EQU   B'10000000'         SPEED\nVVRA1UNQ EQU   B'01000000'         UNIQUE\nVVRA1REU EQU   B'00100000'         REUSE\nVVRA1ERS EQU   B'00010000'         ERASE\nVVRA1IUP EQU   B'00000100'         INHIBIT UPDATE\nVVRA1TEX EQU   B'00000010'         EXPORT TEMPORARY.\nVVRA1TKO EQU   B'00000001'         TRACK OVERFLOW\nVVRATTR2 DS    XL1\nVVRA2REG EQU   B'11000000'         CROSS-REGION SHROPTN\nVVRA2SYS EQU   B'00110000'         CROSS-SYSTEM SHROPTN\nVVRA2INT EQU   B'00000010'         INTERNAL DATASET\nVVRA2NUS EQU   B'00000001'         COMPONENT IS NOT USABLE.\nVVROPIND DS    XL1                 OPEN INDICATOR\nVVRBUFSZ DS    XL4                 MINIMUM BUFFER SIZE\nVVRPRISP DS    XL3                 PRIMARY SPACE ALLOCATION\nVVRSECSP DS    XL3                 SECONDARY SPACE ALLOCATION\nVVRSPCFG DS    XL1                 SPACE FLAGS\nVVRSPCOP EQU   B'11000000'         SPACE OPTIONS\nVVRDSHU  DS    XL4                 DATASET HIGH USED RBA\nVVRDSHA  DS    XL4                 DATASET HIGH ALLOCATED RBA\nVVRLRECL DS    XL4                 AVERAGE LOGICAL RECORD LENGTH\n         DS    XL2\nVVREXCPX DS    CL8                 EXCEPTION EXIT.\nVVRDSHK  DS    XL4                 DATASET HIGH KEY RBA.\nVVRCLSFG DS    XL1                 CLUSTER ATTRIBUTE FLAG\nVVRCFSWS EQU   B'00000010'         CLUSTER DESCRIBES A SWAP SPACE\nVVRCFPGS EQU   B'00000001'         CLUSTER DESCRIBES A PAGE SPACE\nVVRAIXFG DS    XL1                 AIX ATTRIBUTE FLAG\nVVRAIUPG EQU   B'00000001'         UPGRADE AIX.\nVVRTMSTP DS    XL8                 TIMESTAMP (CATALOG ONLY).\n         SPACE 2\nVVRVOLIN DSECT                     VVR VOLUME INFORMATION CELL\nVVRVOLLN DS    XL2                 LENGTH OF VOLUME CELL\nVVRVOLTP DS    XL1                 TYPE CODE IS X'23'\nVVRVOLFG DS    XL1                 VOLUME FLAGS\nVVRPRIME EQU   B'10000000'         PRIME VOLUME\nVVROVFLW EQU   B'00100000'         OVERFLOW VOLUME\nVVRNOEXT DS    XL1                 NUMBER OF EXTENTS ON THIS VOLUME.\nVVRHKRBA DS    XL4                 HIGH KEY RBA\nVVRHURBA DS    XL4                 HIGH USED RBA\nVVRHARBA DS    XL4                 HIGH ALLOCATED RBA\nVVRBLKSZ DS    XL4                 BLOCK SIZE\nVVRBLKTK DS    XL2                 NUMBER OF BLOCKS PER TRACK\nVVRTRKAU DS    XL2                 NUMBER OF TRACKS PER ALLOCATION UNIT\nVVRTPEXT DS    XL1                 EXTENT TYPE FLAG\nVVRSSDAT EQU   B'10000000'         SEQUENCE SET WITH DATA\nVVRNOPFM EQU   B'01000000'         EXTENTS NOT PRE-FORMATTED\nVVRCONV  EQU   B'00100000'         CONVERTED VSAM DATASET VOLUME.\nVVRTKCYL DS    XL2                 TRACKS PER CYLINDER\nVVRBYTTK DS    XL4                 BYTES PER TRACK.\nVVRBYTAU DS    XL4                 BYTES PER ALLOCATION UNIT\nVVRLOKYL DS    XL2                 LOW KEY LENGTH\nVVRLOKYV DS    0XL1                LOW KEY ON VOLUME\nVVRXTENT DS    0XL1                EXTENT SECTION. FOLLOWS LOW KEY\n*                                  VALUE\nVVRXTNTL DS    XL2                 TOTAL LENGTH OF EXTENT SECTION.\nVVRXTNT  DS    0XL20               20 BYTE EXTENT DESCRIPTION.\nVVRXSEQN DS    XL2                 SEQUENCE NUMBER\nVVRXSCH  DS    0XL4                STARTING CCHH\nVVRXSC   DS    XL2                 STARTING CC\nVVRXSH   DS    XL2                 STARTING HH\nVVRXECH  DS    0XL4                ENDING CCHH\nVVRXEC   DS    XL2                 ENDING CC\nVVRXEH   DS    XL2                 ENDING HH\nVVRXNTRK DS    XL2                 NUMBER OF TRACKS\nVVRXSRBA DS    XL4                 STARTING RBA\nVVRXERBA DS    XL4                 ENDING RBA\n         SPACE 2\nVVRAMDCL DSECT                     VVR AMDSB CELL\nVVRAMDCN DS    XL2                 LENGTH OF AMDSB CELL\nVVRAMCAT DS    0XL96               COPY OF AN AMDSB\nVVRAMID  DS    XL1                 TYPE CODE IS X'60'\nVVRAMATR DS    XL1                 ATTRIBUTES:\nVVRAMDST EQU   B'10000000'         1=KSDS, 0=ESDS\nVVRAMWCK EQU   B'01000000'         WRITE CHECK\nVVRAMSDT EQU   B'00100000'         SEQUENCE SET WITH DATA\nVVRAMREP EQU   B'00010000'         REPLICATION\nVVRAMORD EQU   B'00001000'         USE VOLUMES IN LIST ORDER\nVVRAMRGE EQU   B'00000100'         KEY RANGE DATASET\nVVRAMRDS EQU   B'00000010'         RRDS\nVVRAMRSN EQU   B'00000001'         SPANNED RECORDS ALLOWED\nVVRAMLEN DS    XL2                 LENGTH OF AMDSB\nVVRAMNST DS    0XL2                NUMBER OF ENTRIES IN INDEX SECTION\nVVRAMAKP DS    XL2                 ALTERNATE KEY RKP\nVVRAMRKP DS    XL2                 RKP\nVVRAMKNL DS    XL2                 KEY LENGTH\nVVRAMPCA DS    XL1                 % FREE CI IN CA\nVVRAMPCI DS    XL1                 % FREE BYTES IN CI\nVVRAMCCA DS    XL2                 CI'S PER CA\nVVRAMFCA DS    XL2                 FREE CI'S PER CA\nVVRAMFCI DS    XL4                 FREE BYTES PER CI\nVVRAMCIV DS    XL4                 CONTROL INTERVAL SIZE\nVVRAMLCL DS    XL4                 MAXIMUM RECORD SIZE\nVVRAMHLR DS    0XL4                RBA OF HI LEVEL INDEX RECORD\nVVRAMSLT DS    XL4                 SLOTS PER CI\nVVRAMSSR DS    0XL4                RBA OF FIRST SEQUENCE SET RECORD\nVVRAMMRR DS    XL4                 MAXIMUM RELATIVE RECORD NUMBER\nVVRAMARB DS    XL4                 POINTER TO 1ST ARDB\nVVRAMAT3 DS    XL1                 ATTRIBUTES\nVVRAMUNQ EQU   B'10000000'         UNIQUE OR NON-UNIQUE KEYS\nVVRAMFLT EQU   B'01000000'         CYLINDER FAULT MSS OR STAGE\nVVRAMBND EQU   B'00100000'         BIND OR DO NOT BIND ON MSS\nVVRAMWAT EQU   B'00010000'         WAIT OR DO NOT WAIT ON RELINQUISH\nVVRAMLM  EQU   B'00001000'         LOAD MODE OR DATASET LOADED.\nVVRAMSNO DS    XL1                 NUMBER OF CONCURRENT REQUESTS\n         DS    XL4\nVVRAMBFI DS    0XL2                NUMBER OF INDEX BUFFERS\nVVRAMBFD DS    XL2                 NUMBER OF DATA BUFFERS\nVVRAMSTS DS    XL8                 SYSTEM TIMESTAMP\nVVRAMNIL DS    XL2                 NUMBER OF INDEX LEVELS\nVVRAMNXT DS    XL2                 NUMBER OF EXTENTS\nVVRAMNLR DS    XL4                 NUMBER OF LOGICAL RECORDS\nVVRAMDLR DS    XL4                 NUMBER OF DELETED RECORDS\nVVRAMINR DS    XL4                 NUMBER OF INSERTED RECORDS\nVVRAMUPR DS    XL4                 NUMBER OF UPDATED RECORDS\nVVRAMRTR DS    XL4                 NUMBER OF RETRIEVED RECORDS\nVVRAMASP DS    XL4                 BYTES OF FREE SPACE IN DATASET\nVVRAMCIS DS    XL4                 NUMBER OF CI SPLITS\nVVRAMCAS DS    XL4                 NUMBER OF CA SPLITS\nVVRAMEXC DS    XL4                 NUMBER OF EXCPS\n         EJECT ,                                                   -EU-\n*        HSM - MCD DSECT.                                          -EU-\n*        ----------------                                          -EU-\n         SPACE 1                                                   -EU-\nMCD      DSECT\nMCDDSN   DS    CL44                DATASET NAME\nMCDMCK   DS    CL20                CDS RECORD HEADER\nMCDVSN   DS    CL6                 VOLSER OF MIGN. VOL HOLDING THE DS.\nMCDFLGS  DS    0XL2                FLAGS\nMCDFLG1  DS    X                   FLAGS - BYTE ONE\nMCDFASN  EQU   B'10000000'         A MIGRATED COPY EXISTS\nMCDFMIG  EQU   B'01000000'         DATA SET IS TO BE MIGRATED\nMCDFNOMG EQU   B'00100000'         DATA SET IS TO BE RETAINED FROM\n*                                  MIGRATION\nMCDFDEL  EQU   B'00010000'         DATA SET WAS DELETED\nMCDFSDP  EQU   B'00001000'         DATA SET IS SMALL-DATASET-PACKED\nMCDFFL2  EQU   B'00000100'         WHEN SET TO 1, DATASET IS ON ML2,\n*                                  ELSE ML1\nMCDFNSCR EQU   B'00000010'         DATASET RECALLED BUT MIGRATED COPY\n*                                  EXISTS\nMCDJES3  EQU   B'00000001'         RECORD PROCESSED BY HSM-JES3 SETUP.\nMCDFLG2  DS    X                   FLAGS - BYTE TWO\nMCDFSMVL EQU   B'00000100'         SPACE MGMT FLAGS (MCDRECAL) ARE\n*                                  VALID\nMCDFDUMD EQU   B'00000010'         WHEN SET TO 1, THIS IS A DUMMY\n*                                  RECORD\nMCDJR3   EQU   B'00000001'         THIS RECORD WAS CREATED BY RELEASE\n*                                  3.\nMCDCOMPR DS    X                   PERCENT OF SPACE SAVED BY COMPACTION\n         DS    XL3\nMCDDLC   DS    CL4                 X'00YYDDDS' - DATE DS WAS CREATED.\nMCDDLC3  EQU   MCDDLC+1,3,C'P'\nMCDTLR   DS    CL4                 X'HHMMSSTH' - TIME DS WAS LAST USED.\nMCDDLR   DS    CL4                 X'00YYDDDS' - DATE DS WAS LAST\n*                                  REFERENCED.\nMCDDLR3  EQU   MCDDLR+1,3,C'P'\nMCDTLU   DS    CL4                 X'HHMMSSTH' - TIME DS WAS LAST\n*                                  UPDATED.\nMCDDLU   DS    CL4                 X'00YYDDDS' - DATE DS WAS LAST\n*                                  UPDATED.\nMCDDLU3  EQU   MCDDLU+1,3,C'P'\nMCDTMIG  DS    CL4                 X'HHMMSSTH' - TIME DS WAS LAST\n*                                  MIGRATED.\nMCDDMIG  DS    CL4                 X'00YYDDDS' - DATE DS WAS LAST\n*                                  MIGRATED.\nMCDDMIG3 EQU   MCDDMIG+1,3,C'P'\nMCDDSORG DS    XL2                 DSORG FROM THE DSCB.\nMCDBLKSZ DS    XL2                 MAXIMUM BLOCK SIZE OF THE DATASET.\nMCDKEYLN DS    XL1                 KEY LENGTH OF THE DATASET.\nMCDRECFM DS    XL1                 RECORD FORMAT\nMCDRFTYP EQU   B'11000000'         FLAGS FOR A V,B, OR F FORMAT ???\nMCDRFTO  EQU   B'01000000'         TRACK OVERFLOW IS PRESENT\nMCDDSIND DS    XL1                 INDICATORS FROM THE FORMAT 1 DSCB.\nMCDFRACF EQU   B'01000000'         DS IS RACF-PROTECTED\nMCDFSCTY EQU   B'00010000'         DS IS PASSWORD PROTECTED.\nMCDFWSEC EQU   B'00000100'         DS IS WRITE-PASSWORD PROTECTED\nMCDFCHNG EQU   B'00000010'         OPENED FOR OTHER THAN READ-ONLY\nMCDHID   DS    XL1                 ID OF THE PROCESSOR USING THIS\n*                                  RECORD\nMCDSIZE  DS    XL4                 SIZE ALLOCATED IN TRACKS, ON THE\n*                                  USERS VOL\nMCDSIZEB DS    XL4                 SIZE USED IN BYTES, ON THE USERS VOL\nMCDCSZ   DS    XL4                 SIZE OF THE DS IN 2K BLKS ON MIG\n*                                  VOLUME\nMCDNMIG  DS    XL2                 COUNT OF TIME DS WAS MIGRATED.\nMCDDAYS  DS    XL2                 NUMBER OF DAYS BEFORE DS WILL BE\n*                                  MIGRATED\nMCDFRVSN DS    CL6                 VOLSER OF PRIMARY WHERE DATASET WAS\n         ORG   MCDFRVSN\nMCDOVSN  DS    CL6                 VOLSER TO WHICH DS WAS RECALLED\n         DS    XL1\nMCDMCL43 DS    XL1\nMCDCTID3 DS    CL4                 NAME OF COMPACTION TABLE USED ON\n*                                  THIS DS\nMCDUCBTY DS    XL4                 UCBTYP OF \"FROM\" PRIMARY VOLUME.\nMCDTRES  DS    CL4                 X'HHMMSSTH' - TIME DS WAS\n*                                  RECALLED/DELETED\nMCDDRES  DS    CL4                 X'00YYDDDS' - DATE DS WAS\n*                                  RECALLED/DELETED\nMCDMDEVT DS    XL4                 DEVICE TYPE OF MIGRATION VOLUME\nMCDJDAYS DS    XL1\nMCDJDATE DS    XL3                 LAST DATE TO WHICH HSM WILL DELAY\n*                                  MIG\nMCDJVEXD DS    XL3\nMCDPDEP  DS    XL1\nMCDJCT   DS    XL1                 COUNT OF VOLS ELIGIBLE FOR DIRECTED\n*                                  RECALL\nMCDJVOLS DS    0CL10               5 SLOTS - VOLUMES FOR DATASET RECALL\nMCDJVSN  DS    CL6                 VOLSER TO WHICH DS CAN BE RECALLED\nMCDJDEVT DS    XL4                 DEVICE TYPE OF ABOVE\n         DS    4CL10\nMCDRECAL DS    X                   FLAGS\nMCDFDBA  EQU   B'10000000'         WHEN 0, DS MUST BE RECALLED TO MIG\n*                                  VOL\nMCDFRBU  EQU   B'01000000'\nMCDFBDCS EQU   B'00100000'         DS MIGRATED FROM A BACKED-UP VOLUME\nMCDFBDCT EQU   B'00010000'\nMCDFAM   EQU   B'00001000'         DS MUST BE RECALLED TO AUTOMIG\n*                                  VOLUME\nMCDFAB   EQU   B'00000100'         DS MUST BE RECALLED TO AUTOBACKUP\n*                                  VOL\nMCDEXPDT DS    CL4                 X'00YYDDDS' - EXPDT WHEN MIGRATED\nMCDMCANM DS    CL44                DATASET NAME OF MIGRATED VERSION\n         EJECT ,                                                   -EU-\n*        DSECTS FOR SYSTEM DATA AREAS.                             -EU-\n*        -----------------------------                             -EU-\n         SPACE 1                                                   -EU-\n         PRINT NOGEN                                               -EU-\n         CVT   DSECT=YES\nUCB      DSECT ,\n         IEFUCBOB  ,\n         IEFZB4D0  ,\n         IEFZB4D2  ,\n         IEFZB502  ,                                               -EU-\nZB502L   EQU     *-ZB502                                           -EU-\n         IEZJSCB ,\n         IKJTCB  DSECT=YES\n         IFGACB  ,                                                 -EU-\n         IFGRPL  ,                                                 @122\n         SPACE 1                                                   -EU-\n         PRINT GEN                                                 -EU-\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTICMC": {"ttr": 23818, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x885\\x0f\\x00\\x885\\x0f\\x11)\\x05\\x1a\\x05\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-15T00:00:00", "modifydate": "1988-12-15T11:29:00", "lines": 1306, "newlines": 1306, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n&LABEL   $EPILOG &RC\n&LABEL   LR    R1,R13              GET SAVEAREA ADDRESS\n         L     R13,4(R13)          GET BACK CHAIN POINTER\n         L     R0,16(R13)          GET SAVEAREA LENGTH\n         ST    R15,16(R13)         SAVE REGISTER 15 (RETCODE)\n         FREEMAIN R,LV=(0),A=(1)   FREE SAVEAREA\n         LM    R14,R12,12(R13)     RESTORE CALLERS REGS\n         AIF   (T'&RC EQ 'O').SPEC\n         LA    R15,&RC             SET RETURN CODE\n.SPEC    BR    R14                 RETURN TO CALLER\n         MEND\n         MACRO\n&LABEL   $IN   &REG1=R14,&REG2=R15,&DEPTH=DEPTH,                       X\n               &ENTRIES=ENTRIES,&EXITS=EXITS,&LREG=R9\n         AIF   (T'&LABEL EQ 'O').ERR1   MUST HAVE A LABEL\n&LABEL   LA    &REG1,&LABEL             GET SUBROUTINE ENTRY ADDR\n         L     &REG2,&DEPTH             GET CURRENT NESTING DEPTH\n         ST    &REG1,&ENTRIES.(&REG2)   SAVE ENTRY ADDR IN ENTRY TABLE\n         ST    &LREG,&EXITS.(&REG2)     SAVE RETURN ADDR\n         LA    &REG2,4(0,&REG2)         UPDATE NESTING FOR NEXT CALL\n         ST    &REG2,&DEPTH              AND SAVE IT...\n         MEXIT\n.ERR1    MNOTE 8,'---> $IN MUST BE LABELLED'\n.MEND    MEND\n         MACRO\n&LAB    $MESSAGE &MSGNO,&SKIP=0,&DATA=\n         PUSH  PRINT\n         PRINT GEN\n         AIF   (T'&DATA EQ 'O').NODATA\n         LA    R2,&DATA\n.NODATA  LM    R15,R1,=A(MESGRTN,&SKIP,&MSGNO)\n         BASR  R14,R15\n         POP   PRINT\n         MEND\n         MACRO\n&LABEL   $OUT  &REG1=R14,&DEPTH=DEPTH,                                 X\n               &EXITS=EXITS,&LREG=R9\n&LABEL   L     &REG1,&DEPTH             GET CURRENT NESTING DEPTH\n         S     &REG1,=F'4'              BACKUP TO OUR CALLER\n         ST    &REG1,&DEPTH             AND SAVE NEW DEPTH\n         L     &LREG,&EXITS.(&REG1)     PICK UP OUR RETURN ADDR\n         BR    &LREG                    AND GO THERE.\n         MEND\n         MACRO\n&NAME    $PROLOG &LV=0\n.**********************************************************************\n.*\n.*       THIS MACRO WILL PROVIDE ENTRY LINKAGE AND OPTIONALLY\n.*       MULTIPLE BASE REGISTERS.  ALSO, VIA THE 'LV=' KEYWORD\n.*       PROVIDE ADDITIONAL USER STORAGE (APPENDED TO THE\n.*       SAVE AREA) ADDRESSABLE FROM REG 13.  IF NO OPERANDS\n.*       ARE CODED, REG 12 IS ASSUMED THE BASE. EXAMPLE:\n.*              SECTNAME $PROLOG          = STANDARD REG 12 BASE\n.*              SECTNAME $PROLOG 5        = STANDARD, REG 5 BASE\n.*              SECTNAME $PROLOG 10,LV=20 = ADD 20 BYTES TO SAVE AREA\n.*                                             REG 10 IS BASE\n.*              SECTNAME $PROLOG R10,R11  = REGS 10 AND 11 ARE BASES\n.*\n.**********************************************************************\n         LCLA  &AA,&AB,&AC\n         LCLC  &LABEL                                              -EU-\n         GBLB  &PRORG\n&AC      SETA  4096\n         AIF   ('&NAME' NE '').EU1                                 -EU-\n&LABEL   SETC  '&SYSECT'                                           -EU-\n         AGO   .EU2                                                -EU-\n.EU1     ANOP  ,                                                   -EU-\n&LABEL   SETC  '&NAME'                                             -EU-\n&LABEL   CSECT\n.EU2     B     32(R15)             BRANCH AROUND                   -EU-\n         DC    AL1(26)\n         DC    CL8'&LABEL'         CSECT NAME\n         DC    C'-'\n         DC    CL8'&SYSDATE'       COMPILE DATE\n         DC    C'-'\n         DC    CL8'&SYSTIME'       COMPILE TIME\n         CNOP  0,4                 ALIGNMENT\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         LR    R12,R15             LOAD BASE REG\n         USING &LABEL,R12          INFORM ASSEMBLER\n         AIF   (&LV GT 4023).MERR\n         LA    R0,&LV+72           LOAD REG 0 WITH LENGTH VARIABLE\n         GETMAIN R,LV=(0)          GET CORE FOR SAVEAREA AND USER\n         AIF   (&LV+72 LE 256).XC2\n         AIF   (&LV+72 LE 512).XC1\n         MVI   0(R1),X'00'         MOVE X'00' TO FIRST BYTE\n         LR    R2,R1               SAVE POINTER IN EVEN REG\n         LA    R4,1(R1)            SET RECEIVING POINTER\n         LR    R5,R0               SET RECEIVING LENGTH\n         BCTR  R5,R0               DECREMENT LENGTH\n         LA    R5,0(R5)            CLEAR HIGH ORDER BYTE\n         LA    R3,1                SET SENDING LENGTH\n         MVCL  R4,R2               INSTRUCTION PADS WITH X'00'\n         AGO   .STORE\n.XC1     XC    256(&LV-184,R1),256(R1)  CLEAR SAVE AREA\n         XC    0(256,R1),0(R1)          CLEAR SAVE AREA\n         AGO   .STORE\n.XC2     XC    0(&LV+72,R1),0(R1)       CLEAR SAVE AREA\n.STORE   ST    R13,4(R1)           SAVE BACK CHAIN\n         ST    R1,8(R13)           SET FORWARD CHAIN\n         LR    R11,R1              SAVE NEW SAVEAREA ADDRESS\n         L     R15,16(R13)         RESTORE REG 15\n         ST    R0,16(R13)          SAVE SAVEAREA LENGTH\n         LM    R0,R1,20(R13)       RESTORE REGS USED IN GETMAIN\n         LR    R13,R11             SET SAVEAREA POINTER\n         AIF   (N'&SYSLIST EQ 0).MEND\n         AIF   ('&SYSLIST(1)' EQ 'R12').SKIPIT\n         AIF   ('&SYSLIST(1)' EQ '12').SKIPIT\n         LA    &SYSLIST(1),&LABEL  LOAD REQUESTED BASE REG\n         DROP  R12                 DROP ASSUMED BASE REG\n         USING &LABEL,&SYSLIST(1)  INFORM ASSEMBLER\n.SKIPIT  ANOP\n&AA      SETA  2\n.LOOP    AIF   (&AA GT N'&SYSLIST).MEXIT\n&AB      SETA  &AA-1\n         LA    &SYSLIST(&AA),2048(&SYSLIST(&AB))  LOAD NEXT BASE REG\n         LA    &SYSLIST(&AA),2048(&SYSLIST(&AA))  LOAD NEXT BASE REG\n         USING &LABEL+&AC,&SYSLIST(&AA) INFORM ASSEMBLER\n&AC      SETA  &AC+4096\n&AA      SETA  &AA+1\n         AGO   .LOOP\n.MEXIT   AIF   (&PRORG).MEX2\n         SPACE\n         $REGS\n         SPACE\n.MEX2    ANOP\n&AA      SETA  &LV+72\n         MNOTE *,'---> TOTAL STORAGE AREA RECEIVED = &AA'\n         MEXIT\n.MEND    MNOTE *,'---> NO REGISTER SPECIFIED - R12 ASSUMED'\n         AGO   .MEXIT\n.MERR    MNOTE 12,'---> LV > 4023 - REQUEST IGNORED'\n         AGO   .MEXIT\n         MEND\n         MACRO\n         $REGS\n         GBLB  &PRORG\n         AIF   (&PRORG).MEX2\n&PRORG   SETB  1\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nREG0     EQU   0\nREG1     EQU   1\nREG2     EQU   2\nREG3     EQU   3\nREG4     EQU   4\nREG5     EQU   5\nREG6     EQU   6\nREG7     EQU   7\nREG8     EQU   8\nREG9     EQU   9\nREG10    EQU   10\nREG11    EQU   11\nREG12    EQU   12\nREG13    EQU   13\nREG14    EQU   14\nREG15    EQU   15\n.MEX2    SPACE 1\n         MEND\n         MACRO\n&NAME    ALLOC &DUMMY,&PERM,&DSN=,&DDN=,&DDNRET=,&MEMBER=,&DISP=,      X\n               &TERM=,                                       CBOC      X\n               &VOL=,&UNIT=,&SYSOUT=,&FREE=,&COPIES=,&LABEL=,          X\n               &BLKSIZE=,&DEN=,&DSORG=,&KEYLEN=,&LRECL=,&RECFM=,       X\n               &PASWORD=,&DSNRET=,&MF=AUTO,&PREFIX=,&ERROR=,           X\n               &SPACE=,&F=,&FILE=,&DA=,&QNAME=,&DSORGRT=,              X\n               &VOLRET=,&DCBDSN=,&DCBDDN=,&SPECIAL=,&DDNTO=,           X\n               &FORMS=,&DEST=,&SSREQ=,&FORUSER=,&TU=,&DSNPDE=\n.**********************************************************************\n.*                                                                    *\n.*    THIS MACRO PROVIDES A DYNAMIC ALLOCATION FUNCTION BY BUILDING   *\n.*    A DYNAMIC ALLOCATION PARAMETER LIST AND INVOKING SVC 99.        *\n.*    IT FIRST SETS UP A WORKAREA ENVIRONMENT FOR THE PARAMETER LIST  *\n.*    AND THEN TESTS THE KEYWORDS SUPPLIED AND INVOKES INNER MACROS   *\n.*    TO BUILD THE TEXT UNITS. THE INNER MACROS THEMSELVES USE INNER  *\n.*    MACROS TO UPDATE GLOBAL VARIABLES, STORE TEXT UNIT POINTERS ETC *\n.*    THERE ARE THREE WAYS OF SPECIFYING THE WORK AREA ADDRESS.       *\n.*    A) MF=AUTO, MF=G, MF=(E,ADDRESS,LNTHSYMB).                      *\n.*    IN THE FIRST FORM, AN INNER MACRO DYNSPACE IS CALLED TO NAME    *\n.*    A WORK AREA, THE NAME BEING RETURNED IN THE GLOBAL SETC         *\n.*    VARIABLE &DYNSP. A DSECT IS CREATED TO MAP THIS AREA.           *\n.*    THE GLOBAL VARIABLES &DTUO (TEXT UNIT OFFSET COUNTER) AND       *\n.*    &DTUPO (TEXT UNIT POINTER OFFSET ACCUMULATOR) ARE SET TO ZERO.  *\n.*    THESE ACCUMULATORS ARE UPDATED AS EACH TEXT UNIT PROCESSOR      *\n.*    AQUIRES STORAGE. AFTER ALL TEXT UNITS HAVE BEEN BUILT, THE      *\n.*    AMOUNT OF SPACE USED IS CALCULATED, AND THE DYNSPACE MACRO IS   *\n.*    THEN CALLED AGAIN TO LOG THE AMOUNT NEEDED. DYNSPACE SETS A     *\n.*    GLOBAL VARIABLE &DYNSPQ TO THE HIGHEST AMOUNT ANY ALLOC OR      *\n.*    FREE MACRO REQUESTED, AND WHEN CALLED WITH THE EXPAND OPTION,   *\n.*    (NO OPERANDS OR NAME FIELD SUPPLIED), EXPANDS INTO A DS FOR     *\n.*    THAT QUANTITY. (SEE DYNSPACE)                                   *\n.*    MF=G SPECIFIES THAT THE ALLOC MACRO ENTER THE BEGIN MACRO       *\n.*    WORKAREA TO ACQUIRE THE STORAGE NECESSARY. IT DOES THIS VIA     *\n.*    THE RCPDS MACRO. (SEE RCPDS). HOWEVER, IF THE ALLOC MACRO IS    *\n.*    CALLED SEVERAL TIMES WITH THIS OPTION, A LOT OF STORAGE WILL BE *\n.*    USED UP, AS THE STORAGE WILL NOT BE SHARED. THUS, THIS FORM     *\n.*    SHOULD ONLY BE USED IF THE ALLOC/FREE MACRO IS ONLY TO BE USED  *\n.*    ONCE OR TWICE DURING AN ASSEMBLY.                               *\n.*    MF=E CAUSES THE MACRO TO USE A USER SPECIFIED WORK AREA. THE    *\n.*    SECOND PARAMETER GIVES THE NAME OF THE WORKAREA, AND AN         *\n.*    OPTIONAL THIRD PARAMETER IS THE NAME OF A SYMBOL TO BE EQUATED  *\n.*    TO THE LENGTH OF THE REQUIRED WORK AREA.                        *\n.*                                                                    *\n.*    DYNAMIC ALLOCATION FUNCTIONS ARE SIMILAR TO THOSE AVAILABLE    *\n.*    WITH JCL, USING THE SAME KEYWORDS. HOWEVER, CERTAIN FORMATS    *\n.*    ARE SLIGHTLY DIFFERENT. FOR INSTANCE, CERTAIN KEYWORDS CAN     *\n.*    HAVE VARYING PARAMETERS, EG DATASET NAME, DDNAME, VOLSER ETC.  *\n.*    PROVISION IS MADE FOR BOTH VARIABLE SPECIFICATION.             *\n.*    IN THE ABSOLUTE FORM, THE PARAMETER IS ENTERED IN QUOTES,      *\n.*    E.G.   ALLOC DSN='SYS1.LINKLIB',DISP=SHR                       *\n.*    HOWEVER, THIS NAME REMAINS FIXED FOR THE ASSEMBLY.             *\n.*    IN THE VARIABLE FORMAT, THE ADDRESS OF A LOCATOR IS SPECIFIED, *\n.*    WHERE THE LOCATOR CONSISTS OF A SIX BYTE FIELD, THE FIRST 4    *\n.*    BYTES OF WHICH POINT TO THE PARAMETER, WHILE THE NEXT TWO      *\n.*    CONTAIN THE LENGTH.                                            *\n.*    EG          ALLOC DSN=LOCATOR                                  *\n.*       LOCATOR  DC    A(DSN),Y(12)                                 *\n.*       DSN      DC    C'SYS1.LINKLIB'                              *\n.*                                                                   *\n.*       NUMERIC QUANTITIES E.G. COPIES= FOR SYSOUT, SHOULD EITHER   *\n.*       SPECIFY A NUMERIC VALUE, COPIES=3,                          *\n.*       A VALUE IN A REGISTER, COPIES=(R3),                         *\n.*       OR THE NAME OFF A FULLWORD CONTAINING THE VALUE,            *\n.*          COPIES=NUMCOPYS, WHERE NUMCOPYS IS THE NAME OF A         *\n.*       FULLWORD FIELD.                                             *\n.*                                                                   *\n.*       OTHER KEYWORDS SUCH AS DISP= CAN ONLY HAVE THE ABSOLUTE     *\n.*       FORM, AND VALUES SHOULD NOT BE ENTERED WITHIN QUOTES.       *\n.*       ADDITIONAL FACILITIES NOT AVAILABLE WITH JCL ARE THE        *\n.*       RETURN BY THE SYSTEM OF INFORMATION ON THE DATASET, EG      *\n.*       DSORG. THIS IS DONE BY SPECIFYING DSORGRT=SYMBOL, WHERE     *\n.*       SYMBOL IS A SYMBOL WHICH WILL BE EQUATED TO A TWO BYTE      *\n.*       FIELD CONTAINING THE DSORG TYPE (SEE JOB MANAGEMENT,        *\n.*       SUPERVISOR AND TSO).                                        *\n.*       THE SYSTEM CAN ALSO GENERATE AND RETURN A DDNAME. THIS IS   *\n.*       CARRIED OUT BY ENTERING DDNTO=(ADDR1,ADDR2,,...)            *\n.*       WHERE ADDR1,ADDR2 ETC ARE THE NAMES OF 8 BYTE FIELDS WHICH  *\n.*       ARE TO RECEIVE THE DDNAME.                                  *\n.*       FOR FURTHER INFORMATION ON DYNAMIC ALLOCATION, SEE          *\n.*       JOB MANAGEMENT, SUPERVISOR AND TSO.                         *\n.*                                                                   *\n.**********************************************************************\n         GBLA  &RCPDYN            COUNTER FOR NO ENTRIES TO MACRO\n         GBLA  &DTUO              OFFSET TO TEXT UNITS\n         GBLA  &DTUPO             OFFSET TO TEXT UNIT POINTERS\n         GBLB  &RCPS99(2)         TELL RCPDSECT NEED DSECTS\n         GBLC  &DYNP              PREFIX FOR LABELS FOR THIS CALL\n         GBLC  &DYNSP         NAME FOR AUTOMATIC STORAGE ALLOC\n         LCLA  &DDNRTO,&DSNRTO         FOR EQUATES FOR RETURNED FLDS\n         LCLA  &VOLRTO,&DSRGRTO        FOR EQUATES FOR RETURNED FIELDS\n         LCLA  &I                 COUNTER\n         LCLB  &DSECT             DSECT NEEDED FOR STORAGE, MF=E\n         LCLC  &C,&T,&PAR\n.*\n.*   THE ALLOC MACRO PROVIDES A DYNAMIC ALLOCATION FUNCTION,\n&RCPS99(1)     SETB           1\n&RCPDYN  SETA  &RCPDYN+1          INCEREMENT COUNTER\n&DYNP    SETC  'DYN&RCPDYN' SET DEFAULT PREFIX\n&NAME    DS    0H\n         AIF   ('&PREFIX' EQ '').TMF\n         AIF   (K'&PREFIX LT 4).POK\n         MNOTE 4,'---> PREFIX TOO LONG, 1ST 4 CHARS USED'\n&DYNP    SETC  '&PREFIX'(1,4)\n         AGO   .TMF\n.POK     ANOP\n&DYNP    SETC  '&PREFIX'\n.TMF     AIF   ('&MF(1)' EQ 'G').GEN\n         AIF   ('&MF' NE 'AUTO').TMFE\nNAME     DYNSPACE             GET NAME FOR SPACE\n         LA    R1,&DYNSP               LOAD ADDRESS OF PARAM LIST\n         USING &DYNP.DS,R1             USE GENERATED DSECT\n&T       SETC  'A'\n&PAR     SETC  '&DYNSP+4'\n&DSECT   SETB  1\n         AGO   .START\n.TMFE    AIF   ('&MF(2)' NE '').E2OK\n         MNOTE 4,'---> PLIST ADDRESS OMITTED, MF=G USED'\n         AGO   .GEN\n.E2OK    ANOP\n&DSECT   SETB  1\n         AIF   ('&MF(2)' EQ '(').RMFE\n         LA    R1,&MF(2)               LOAD PARAM LIST ADDRESS\n         USING &DYNP.DS,R1             USE GENERATED DSECT\n         AGO   .START\n.RMFE    AIF   ('&MF(2)' EQ '(R1)' OR '&MF(2)' EQ '(1)').START\n         LR    R1,&PAR                 LOAD S99 PARAM LIST ADDRESS\n         AGO   .START\n.GEN     LA    R1,&DYNP.RBP            LOAD ADDRESS OF S99 RBP\n.START   LA    R15,&DYNP.RB            LOAD ADDRESS OF S99 RB\n         USING S99RB,R15\n         ST    R15,0(R1)               AND STORE IN RB POINTER\n         XC    4(&DYNP.LEN-4,R1),4(R1) ZERO PARAMETER LIST\n         MVI   S99RBLN,20              MOVE IN LIST LENGTH\n         MVI   S99VERB,S99VRBAL        MOVE IN VERB CODE\n         LA    R14,&DYNP.TUP           LOAD ADDRESS OF TU POINTERS\n         ST    R14,S99TXTPP            STORE ADDRESS IN S99 RB\n         LA    R15,&DYNP.TU            POINT TO SPACE FOR TEXT UNITS\n         USING S99TUNIT,R15\n&DTUO    SETA  0\n&DTUPO   SETA  0\n         AIF   ('&SSREQ' EQ 'YES').SSREQ\n.TDSN    AIF   ('&DSN&DA' NE '').DSN\n         AIF   ('&DSNPDE' NE '').DSNPDE\n         AIF   ('&DSNRET' NE '').DSNRT\n         AIF   ('&TERM' NE '').TERM             CBOC......\n         AIF   ('&SYSOUT' NE '').SYSOUT\n         AIF   ('&DUMMY' NE '').DUMMY\n         AIF   ('&QNAME' NE '').QNAME\n.TDDN    AIF   ('&DDN&FILE&F' NE '').DDN\n         AIF   ('&DDNRET&DDNTO' NE '').DDNRT\n.TUNIT   AIF   ('&UNIT&VOL' NE '').UNIT\n.TVOLRET AIF   ('&VOLRET' NE '').VOLRET\n.TDSRGO  AIF   ('&DSORGRT' NE '').DSORGRT\n.TLABEL  AIF   ('&LABEL' NE '').LABEL\n.TPSWD   AIF   ('&PASWORD' NE '').PASWORD\n.TFORUSE AIF   ('&FORUSER' NE '').FORUSER\n.TTU     AIF   ('&TU' NE '').TU\n.TDISP   AIF   ('&DISP' NE '').DISP\n.TSPACE  AIF   ('&SPACE' NE '').SPACE\n.TLRECL  AIF   ('&LRECL' NE '').DCB\n         AIF   ('&DEN' NE '').DCB\n         AIF   ('&RECFM' NE '').DCB\n         AIF   ('&BLKSIZE' NE '').DCB\n         AIF   ('&DSORG' NE '').DCB\n         AIF   ('&KEYLEN' NE '').DCB\n.TDCBDSN AIF   ('&DCBDSN' NE '').DCBDSN\n.TDCBDDN AIF   ('&DCBDDN' NE '').DCBDDN\n.TFREE   AIF   ('&FREE' EQ 'CLOSE').FREE                         TE7343\n.TPERM   AIF   ('&PERM' EQ 'PERM' OR '&PERM' EQ 'PERMANENT').PERM\n         AIF   ('&DUMMY' EQ 'PERM' OR '&DUMMY' EQ 'PERMANENT').PERM\n.TSPECI  AIF   ('&SPECIAL' NE '').SPECIAL\n         AGO   .SVC99\n.SSREQ   RCPSSREQ\n         AGO   .TDSN\n.DSN     RCPDSN &DSN&DA,&MEMBER\n         AGO   .TDDN\n.DSNPDE  RCPDSNPD &DSNPDE\n         AGO   .TDDN\n.DSNRT   RCPDSNRT &DSNRET\n&DSNRTO  SETA  &DTUO-46\n         AGO   .TDDN\n.SYSOUT  RCPSYSOU &SYSOUT,COPIES=&COPIES,FREE=&FREE,DEST=&DEST,        X\n               FORMS=&FORMS\n         AGO   .TDDN\n.TERM    RCPTERM &TERM           CBOC....\n         AGO   .TDDN             CBOC..\n.DUMMY   RCPDUMMY &DUMMY\n         AGO   .TDDN\n.QNAME   RCPQNAME &QNAME\n         AGO   .TDDN\n.DDN     RCPDDN &DDN&F&FILE\n         AGO   .TUNIT\n.DDNRT   RCPDDNRT &DDNRET\n&DDNRTO  SETA  &DTUO-10\n         AGO   .TUNIT\n.UNIT    RCPUNIT &UNIT,&VOL\n         AGO   .TVOLRET\n.VOLRET  RCPVOLRT &VOLRET\n&VOLRTO  SETA  &DTUO-8\n         AGO   .TDSRGO\n.DSORGRT RCPDSRGR\n&DSRGRTO SETA  &DTUO-2\n         AGO   .TLABEL\n.LABEL   RCPLABEL &LABEL\n         AGO   .TPSWD\n.PASWORD RCPPSWD &PASWORD\n         AGO   .TFORUSE\n.FORUSER RCPFORUS &FORUSER\n         AGO   .TTU\n.TU      RCPTU &TU\n         AGO   .TDISP\n.DISP    RCPDISP &DISP\n         AGO   .TSPACE\n.SPACE   RCPSPACE &SPACE\n         AGO   .TLRECL\n.DCB     RCPDDCB LRECL=&LRECL,DEN=&DEN,RECFM=&RECFM,BLKSIZE=&BLKSIZE,  X\n               DSORG=&DSORG,KEYLEN=&KEYLEN\n         AGO .TDCBDSN\n.DCBDSN  RCPDCBDS &DCBDSN\n         AGO .TDCBDDN\n.DCBDDN  RCPDCBDD &DCBDDN\n         AGO .TFREE                                              TE7343\n.FREE    RCPFREE  &FREE                                          TE7343\n         AGO   .TPERM\n.PERM    RCPPERM\n         AGO   .TSPECI\n.SPECIAL RCPSPEC &SPECIAL\n.SVC99   ANOP\n&DTUPO   SETA  &DTUPO-4\n         SPACE\n         MVI   &DYNP.TUP+&DTUPO,X'80'  SET HIGH ORDER BIT ON TEXT PTRS\n         MVI   &DYNP.RBP,X'80'         SET HIGH ORDER BIT ON RB PTR\n         RCPSR2 UNSAVE\n&DTUPO   SETA  &DTUPO+4\n         AIF   (NOT &DSECT).DYNA\n         DROP  R1,R15                  DEACTIVATE ADDRESSABILITY\n         LA    R14,4(R1)               POINT TO REQUEST BLOCK\n.DYNA    DYNALLOC\n         AIF   (NOT &DSECT).LTR\n         USING &DYNP.RB,R14            SET UP ADDRESSABILITY\n**       NOTE  R14 HAS RB ADDRESS, R15 HAS SVC 99 RETURN CODE        **\n.LTR     AIF   ('&ERROR' EQ '').TDDTO\n         LTR   R15,R15                 TEST RETURN CODE\n         BNZ   &ERROR                  BRANCH IF NON ZERO\n.TDDTO   AIF   ('&DDNTO' EQ '').RESERVE\n&I       SETA  0\n.DDNTOL  ANOP\n&I       SETA  &I+1\n         AIF   ('&DDNTO(&I)' EQ '').RESERVE\n         AIF   ('&DDNTO(&I)'(1,1) EQ '(').DDNTOR\n         MVC   &DDNTO(&I).(8),&DYNP.TU+&DDNRTO+2\n         AGO   .DDNTOL\n.DDNTOR  ANOP\n&C       SETC  '&DDNTO(&I)'(2,K'&DDNTO(&I)-2)\n         MVC   0(8,&C),&DYNP.TU+&DDNRTO+2\n         AGO   .DDNTOL\n.RESERVE AIF   (&DSECT).RESDS\n         SPACE 1\n***********************************************************************\n**       RESERVE SPACE FOR DYNALLOC PARAMETER LIST                   **\n***********************************************************************\n         RCPDS\n.SSP     ANOP\n&DYNP.RBP DS   F                       SVC 99 REQ BLOCK POINTER\n&DYNP.RB  DS   5F                      SVC 99 REQUEST BLOCK\n&DYNP.TUP DS   CL&DTUPO                SPACE FOR TEXT POINTERS\n         AIF   (&DTUO EQ 0).DTU21\n&DYNP.TU  DS   CL&DTUO                 SPACE FOR TEXT UNITS\n         AIF   (&DSNRTO EQ 0).TDDNRTO\n&DSNRET  EQU   &DYNP.TU+&DSNRTO        OFFSET TO RETURNED DSN\n.TDDNRTO AIF   ('&DDNRET' EQ '').DTU11\n&DDNRET  EQU   &DYNP.TU+&DDNRTO        OFFSET TO RETURNED DDNAME\n.DTU11   AIF   (&VOLRTO EQ 0).DTU12\n&VOLRET  EQU   &DYNP.TU+&VOLRTO        OFFSET TO RETURNED VOLSER\n.DTU12   AIF   (&DSRGRTO EQ 0).DTU10\n&DSORGRT EQU   &DYNP.TU+&DSRGRTO       OFFSET TO RETURNED DSORG\n         AGO   .DTU10\n.DTU21   ANOP\n&DYNP.TU  DS   0C                      NO SPACE NEEDED FOR TEXT UNITS\n.DTU10   ANOP\n&DYNP.LEN EQU  *-&DYNP.RBP             LENGTH OF SPACE USED\n         AIF   (&DSECT).DSP\n         RCPDS\n         SPACE 2\n         AGO   .EXIT\n.RESDS   ANOP\n         AIF   ('&DYNSP' EQ '').SP3\n         DYNSPACE ADD\n.SP3     SPACE 1\n&DYNP.DS DSECT                         DSECT TO MAP SVC 99 DATA\n         AGO   .SSP\n.DSP     AIF   ('&MF(3)' EQ '').END1\n&MF(3)   EQU   &DYNP.LEN               LENGTH OF AREA\n.END1    ANOP\n&SYSECT  CSECT\n         SPACE 2\n.EXIT    MEND\n         MACRO\n&NAME    DYNSPACE &TYPE\n.*\n.*    THIS IS AN INNER MACRO TO ALLOC/FREE.\n.*    IT IS CALLED TO   A) NAME AN AREA FOR THE PARMLIST\n.*                      B) LOG THE VARIOUS AMOUNTS NEEDED BY\n.*                         EACH, REMEMBERING THE LARGEST.\n.*                      C) GENERATING A DS FOR THE LARGEST AMOUNT.\n.*    THE FIRST TWO FUNCTIONS ARE INVOKED BY ALLOC/FREE MACROS ONLY,\n.*    AND THE THIRD IS USED BY THE PROGRAMMER, EITHER EXPLICITLY,\n.*    OR BY BEGINWKA, IF THE LATTER IS USED.\n.*\n.*     TO INVOKE THE NAMING FUNCTION, ALLOC/FREE GENERATE\n.*     NAME DYNSPACE\n.*     NOTE. THE NAMING OPERATION ONLY GENERATES A NAME ON THE\n.*     FIRST CALL IN THE ASSEMBLY. THE NAME REMAINS THE SAME UNTIL\n.*     DYNSPACE IS CALLED TO EXPAND INTO A DS.\n.*\n.*     THE SECOND FUNCTION IS INVOKED BY THE MACRO CALL\n.*          DYNSPACE ADD\n.*     (NO NAME FIELD AND ONE OPERAND)\n.*     IT USES THE GLOBAL VARIABLES &DTUO AND &DTUPO TO CALCULATE\n.*     THE SPACE FOR THIS REQUEST, AND UPDATES &DYNSPQ ONLY IF THE\n.*     CURRENT REQUEST IS FOR A GREATER AMOUNT\n.*\n.*     THE THIRD FUNCTION IS INVOKED BY CALLING DYNSPACE WITH NO\n.*     NAME OR OPERAND FIELD.\n.*     THIS EXPANDS INTO A DEFINE STORAGE, CLEARS THE DYNSPACE NAME\n.*     GLOBAL SETC, AND THE &DYNSPQ GLOBAL SETA.\n.*     THUS, THE MACRO IS SERIALLY REUSABLE IN ALL FUNCTIONS.\n.*\n         GBLA  &DYNSPQ,&DTUO,&DTUPO,&RCPDYN\n         GBLC  &DYNP,&DYNSP\n         LCLA  &I\n         AIF   ('&NAME' NE '').NAME\n         AIF   ('&TYPE' EQ '').ALLOC\n.*       THE ACCUMULATE FUNCTION IS REQUIRED\n&I       SETA  24+&DTUO+&DTUPO         GET AMOUNT FOR THIS REQUEST\n         AIF   (&I LE &DYNSPQ).EXIT    IF CURRENT < MAX, EXIT\n&DYNSPQ  SETA  &I                      ELSE UPDATE CURRENT MAXIMUM\n         MEXIT\n.NAME    AIF   ('&DYNSP' NE '').EXIT   IF NAME ALREADY EXISTS, EXIT\n&DYNSP   SETC  'DYNSP&RCPDYN'          ELSE GENERATE A NAME\n.EXIT    MEXIT\n.ALLOC   AIF   ('&DYNSP' EQ '').EXIT\n*\n***      RESERVE SPACE FOR ALLOC/FREE MACRO WORK AREA\n*\n&DYNSP   DS    0F,CL&DYNSPQ            RESERVE SPACE\n&DYNSP   SETC  ''                      SET MAX QUANTITY TO 0\n&DYNSPQ  SETA 0\n         MEND\n         MACRO\n&NAME    EDIT  &PR,&NUM,&ED\n         LCLA  &A1,&A2,&A3,&A4\n         LCLB  &B1,&B2\n         LCLC  &C1,&C2,&C3\n         ACTR  200\n         AIF   (N'&SYSLIST EQ 2 AND K'&ED EQ 0).ANOP1\n         AIF   (N'&SYSLIST NE 3).MNOTE1\n         AIF   ('&ED'(1,1) EQ '-' OR '&ED'(1,1) EQ '$').EDMK\n.ANOP1   ANOP\n&A1      SETA  &A1+1\n         AIF   (K'&ED LT &A1).CONT\n&A2      SETA  &A2+1\n&A4      SETA  &A4+1\n         AIF   ('&ED'(&A1,1) NE 'Z' AND '&ED'(&A1,1) NE '&C2').NINE\n.ANOP2   ANOP\n&C1      SETC  '&C1.20'\n         AGO   .ANOP1\n.NINE    AIF   ('&ED'(&A1,1) NE '9').PER\n         AIF   (&B1).ANOP2\n&B1      SETB  1\n         AIF   (&A1 EQ 1).SIGNIF\n         AIF   (&A1 EQ 2 AND &B2).SIGNIF\n&C3      SETC  '&C1'(&A4*2-3,2)\n         AIF   ('&C3' NE '20').NINE2\n&C1      SETC  '&C1'(1,&A4*2-4).'2120'\n         AGO   .ANOP1\n.NINE2   ANOP\n&C1      SETC  '&C1'(1,&A4*2-6).'21&C3.20'\n         AGO   .ANOP1\n.SIGNIF  ANOP\n&C1      SETC  '21'\n         AGO   .ANOP1\n.PER     AIF   ('&ED'(&A1,1) NE '.').COMMA\n&C1      SETC  '&C1.4B'\n&A2      SETA  &A2-1\n         AGO   .ANOP1\n.COMMA   AIF   ('&ED'(&A1,1) NE 'V').SLASH\n&C1      SETC  '&C1.6B'\n&A2      SETA  &A2-1\n         AGO   .ANOP1\n.SLASH   AIF   ('&ED'(&A1,1) NE '/').DBCR\n&C1      SETC  '&C1.61'\n&A2      SETA  &A2-1\n         AGO   .ANOP1\n.DBCR    AIF   (&A1+1 NE K'&ED).MNOTE2\n         AIF   ('&ED'(&A1,2) NE 'CR').DB\n&C1      SETC  '&C1.C3D9'\n&A2      SETA  &A2-1\n         AGO   .CONT\n.DB      AIF   ('&ED'(&A1,2) NE 'DB').MNOTE2\n&C1      SETC  '&C1.C4C2'\n&A2      SETA  &A2-1\n.CONT    ANOP\n&C3      SETC  '&PR'\n         AIF   (L'&NUM*2-1 NE &A2).EDSIZE\n.ENDCHEC ANOP\n&A2      SETA  0\n         AIF   (K'&C1/2+1 NE L'&PR).AREASIZ\n.LAST    AIF   (&B2).EDMKEND\n&NAME    MVC   &C3,=X'40&C1'\n         ED    &C3,&NUM\n         MEXIT\n.EDSIZE  AIF   (L'&NUM*2-1 LT &A2).LONG\n.SHORT   ANOP\n&C1      SETC  '20&C1'\n&A3      SETA  &A3+1\n         AIF   (L'&NUM*2-1 GT &A2+&A3).SHORT\n         AGO   .ENDCHEC\n.LONG    ANOP\n&C1      SETC  '&C1'(3,K'&C1-2)\n&A3      SETA  &A3+1\n         AIF   (L'&NUM*2-1 LT &A2-&A3).LONG\n         AGO   .ENDCHEC\n.AREASIZ AIF   (K'&C1/2+1 LT L'&PR).LESS\n&A2      SETA  K'&C1/2+1-L'&PR\n&A3      SETA  K'&C1/2+1\n&C3      SETC  '&C3-&A2.(&A3)'\n&B1      SETB  1\n         AGO   .LAST\n.LESS    ANOP\n&B1      SETB  0\n&A3      SETA  K'&C1/2+1\n         AIF   (K'&C1/2+5 GE L'&PR).PLUSET\n&C3      SETC  '&C3.(&A3)'\n         AGO   .LAST\n.PLUSET  ANOP\n&A2      SETA  L'&PR-K'&C1/2-1\n&C3      SETC  '&C3+&A2.(&A3)'\n         AGO   .LAST\n.EDMK    AIF   ('&ED'(1,1) EQ '-').NEG\n&C2      SETC  '$'\n         AGO   .C2SET\n.NEG     ANOP\n&C2      SETC  '-'\n.C2SET   ANOP\n&A1      SETA  1\n&B2      SETB  1\n         AGO   .ANOP1\n.EDMKEND ANOP\n&A1      SETA  -1\n.EDMKNOP ANOP\n&A1      SETA  &A1+2\n         AIF   (K'&C1 LT &A1).SETA\n         AIF   ('&C1'(&A1,2) EQ '21').SETAA\n         AIF   ('&C1'(&A1,2) NE '4B').EDMKNOP\n&A1      SETA  (&A1+1)/2\n         AGO   .LA\n.SETA    ANOP\n&A1      SETA  (&A1+1)/2-1\n         AGO   .LA\n.SETAA   ANOP\n&A1      SETA  (&A1+1)/2+1\n.LA      ANOP\n         AIF   (&B1).MINUS\n&A1      SETA  &A1+&A2\n         AGO   .MVC\n.MINUS   ANOP\n&A1      SETA  &A1-&A2\n.MVC     ANOP\n&NAME    MVC   &C3,=X'40&C1'\n         LA    1,&PR+&A1\n         EDMK  &C3,&NUM\n         AIF   ('&C2' EQ '$').DOLLAR\n         BNM   EDIT&SYSNDX\n         BCTR  1,0\n         MVI   0(1),C'-'\n&C3      SETC  '&SYSNDX'\nEDIT&C3  EQU   *\n         MEXIT\n.DOLLAR  BCTR  1,0\n         MVI   0(1),C'$'\n         MEXIT\n.MNOTE1  MNOTE 8,'---> THREE OPERANDS MUST BE SPECIFIED'\n         MEXIT\n.MNOTE2  MNOTE 8,'---> INVALID EDIT PATTERN'\n         MEND\n         MACRO\n&NFS     HEX   &TO,&FROM,&L,&LEN=,&HEXTAB=,&BYTE=C' ',&DIGITS=\n         GBLC  &HEXTAB#\n         LCLA  &LT                      UNPK \"TO\" LENGTH\n         LCLA  &LF                      UNPK \"FROM\" LENGTH\n         LCLA  &LTR                     TR \"TO\" LENGTH\n         LCLA  &LL                      &LEN ONE WAY OR ANOTHER\n         LCLC  &F1,&F2,&T1,&T2,&LX\n&F1      SETC  '&FROM(1)'               FOR SHORTER STRING LATER\n&F2      SETC  '&FROM(2)'               FOR SHORTER STRING LATER\n&T1      SETC  '&TO(1)'                 FOR SHORTER STRING LATER\n&T2      SETC  '&TO(2)'                 FOR SHORTER STRING LATER\n&LX      SETC  '&L&LEN'                 GET LENGTH USING EITHER METHOD\n         AIF   ('&LX' EQ '').DEFLEN     LENGTH WILL DEFAULT TO 4\n&LL      SETA  &LX                      GET IT\n         AGO   .OKLEN\n.DEFLEN  ANOP\n&LL      SETA  4                        SET THE DEFAULT LENGTH\n.OKLEN   AIF   ('&HEXTAB' EQ '').OKHEX1\n&HEXTAB# SETC  '&HEXTAB'\n.OKHEX1  AIF   ('&HEXTAB#' NE '').OKHEX2\n&HEXTAB# SETC  'HEXTAB'\n.OKHEX2  ANOP\n&LT      SETA  &LL*2\n         AIF   ('&DIGITS' EQ '').OKDIGIT\n&LT      SETA  &DIGITS\n.OKDIGIT AIF   (N'&TO NE 2).TO1\n         AIF   (N'&FROM NE 2).T2F1\n&NFS     UNPK  &T1.(&LT+1,&T2),&F1.(&LL+1,&F2)\n         TR    &T1.(&LT,&T2),&HEXTAB#\n         MVI   &T1+&LT.(&T2),&BYTE\n         AGO   .DONE\n.T2F1    AIF   (N'&FROM NE 1).ERRF\n&NFS     UNPK  &T1.(&LT+1,&T2),&FROM.(&LL+1)\n         TR    &T1.(&LT,&T2),&HEXTAB#\n         MVI   &T1+&LT.(&T2),&BYTE\n         AGO   .DONE\n.TO1     AIF   (N'&TO NE 1).ERRT\n         AIF   (N'&FROM NE 2).T1F1\n&NFS     UNPK  &TO.(&LT+1),&F1.(&LL+1,&F2)\n         TR    &TO.(&LT),&HEXTAB#\n         MVI   &TO+&LT,&BYTE\n         AGO   .DONE\n.T1F1    AIF   (N'&FROM NE 1).ERRF\n&NFS     UNPK  &TO.(&LT+1),&FROM.(&LL+1)\n         TR    &TO.(&LT),&HEXTAB#\n         MVI   &TO+&LT,&BYTE\n         AGO   .DONE\n.ERRF    MNOTE 8,'---> ERROR IN \"FROM\" PARAMETER, MACRO TERMINATED'\n         MEXIT\n.ERRT    MNOTE 8,'---> ERROR IN \"TO\" PARAMETER, MACRO TERMINATED'\n         MEXIT\n.DONE    ANOP\n         MEND\n         MACRO\n         MESG  &N,&F,&T\n&L       SETA  K'&SYSLIST(3)-2\n         AIF   (&SYSLIST(2) EQ 0).NOFILL\n&L       SETA  &L+&SYSLIST(2)\nMESG&N   DC    YL1(&L),YL1(&F),C&T,CL&F' '\n         MEXIT\n.NOFILL  ANOP\nMESG&N   DC    YL1(&L),YL1(&F),C&T\n         MEND\n         MACRO\n         RCPDDN &DDN\n         GBLC  &DYNP\n         SPACE 1\n***********************************************************************\n**   BUILD THE DDNAME TEXT UNIT                                      **\n***********************************************************************\n         AIF   ('&DDN'(K'&DDN,1) EQ '/').BTU\n         AIF   ('&DDN'(1,1) EQ '''').Q\n         RCPSR2\n         AIF   ('&DDN'(1,1) EQ '(').R\n         L     R14,&DDN                LOAD ADDRESS OF DDNAME\n         LH    R2,&DDN+4               LOAD LENGTH OF DDNAME\n         AGO   .STH\n.R       L     R14,0&DDN               LOAD ADDRESS OF DDNAME\n         LH    R2,4&DDN                LOAD LENGTH OF DDNAME\n.STH     STH   R2,S99TULNG             STORE DDNAME LENGTH\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE DDNAME\n         MVI   S99TUKEY+1,DALDDNAM     MOVE IN DDNAME KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 14\n         MEXIT\n.Q       RCPBTU DALDDNAM,1,&DDN\n         MEXIT\n.BTU     RCPTUBFR DALDDNAM,14,&DDN\n         MEND\n         MACRO\n         RCPDINC &L1\n         GBLA  &DTUO,&DTUPO\n         GBLC  &DYNP\n         AIF   ('&L1' EQ '').T2\n         ST    R15,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS\n         LA    R15,&L1.(R15)           BUMP TEXT UNIT PTR TO NEXT SLOT\n&DTUPO   SETA  &DTUPO+4\n&DTUO    SETA  &DTUO+&L1\n         MEXIT\n.T2      ST    R14,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS\n&DTUPO   SETA  &DTUPO+4\n         MEND\n         MACRO\n         RCPDISP &DISP\n         LCLA  &I\n         LCLB  &B(4)\n         AIF   ('&DISP(1)' EQ '').TD2\n         SPACE\n***********************************************************************\n**     DATA SET INITIAL STATUS                                       **\n***********************************************************************\n&B(1)    SETB  ('&DISP(1)' EQ 'SHR')\n&B(2)    SETB  ('&DISP(1)' EQ 'NEW')\n&B(3)    SETB  ('&DISP(1)' EQ 'MOD')\n&B(4)    SETB  ('&DISP(1)' EQ 'OLD')\n         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK1\n         MNOTE 8,'---> &DISP(1) IS INVALID, DISP=SHR USED'\n&B(1)    SETB  1\n.OK1     ANOP\n&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)\n         MVC   S99TUKEY(8),=Y(DALSTATS,1,1,X'0&I.00')\n         RCPDINC 8\n.TD2     AIF   ('&DISP(2)' EQ '').TD3\n         SPACE\n***********************************************************************\n**    DATA SET NORMAL DISPOSITION                                    **\n***********************************************************************\n&B(1)    SETB  ('&DISP(2)' EQ 'KEEP')\n&B(2)    SETB  ('&DISP(2)' EQ 'DELETE')\n&B(3)    SETB  ('&DISP(2)' EQ 'CATLG')\n&B(4)    SETB  ('&DISP(2)' EQ 'UNCATLG')\n         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK2\n         MNOTE 8,'---> &DISP(2) IS INVALID, DISP=(,KEEP) USED'\n&B(1)    SETB  1\n.OK2     ANOP\n&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)\n         MVC   S99TUKEY(8),=Y(DALNDISP,1,1,X'0&I.00')\n         RCPDINC 8\n.TD3     AIF   ('&DISP(3)' EQ '').EXIT\n         SPACE\n***********************************************************************\n**   DATASET CONDITIONAL DISPOSITION                                 **\n***********************************************************************\n&B(1)    SETB  ('&DISP(3)' EQ 'KEEP')\n&B(2)    SETB  ('&DISP(3)' EQ 'DELETE')\n&B(3)    SETB  ('&DISP(3)' EQ 'CATLG')\n&B(4)    SETB  ('&DISP(3)' EQ 'UNCATLG')\n         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK3\n         MNOTE 8,'---> &DISP(3) IS INVALID, DISP=(,,KEEP) USED'\n&B(1)    SETB  1\n.OK3     ANOP\n&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)\n         MVI   S99TUKEY(8),=Y(DALCDISP,1,1,X'0&I.00')\n         RCPDINC 8\n.EXIT    MEND\n         MACRO\n         RCPDSN &DSN,&MEM\n         LCLC  &MEMBER\n         GBLC  &DYNP\n         SPACE\n***********************************************************************\n**   BUILD THE DSNAME TEXT UNIT                                      **\n***********************************************************************\n         AIF   ('&DSN'(1,1) EQ '''').Q\n         AIF   ('&DSN'(K'&DSN,1) EQ '/').BD\n         AIF   ('&DSN'(1,1) EQ '(').REG\n         AIF   ('&DSN'  EQ '*').TERM\n         RCPSR2\n         L     R14,&DSN                LOAD ADDRESS OF DSNAME\n         LH    R2,&DSN+4               LOAD LENGTH OF DSNAME\n.STH     STH   R2,S99TULNG             STORE DSNAME LENGTH\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE DSNAME\n         MVI   S99TUKEY+1,DALDSNAM     MOVE IN DSNAME KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 50\n         AGO   .TMEMBER\n.REG     L     R14,0&DSN               LOAD ADDRESS OF DSNAME\n         RCPSR2\n         LH    R2,4&DSN                LOAD LENGTH OF DSNAME\n         AGO   .STH\n.TERM    MVI   S99TUKEY+1,DALTERM\n         RCPDINC 4\n         MEXIT\n.BD      RCPTUBFR DALDSNAM,50,&DSN\n         AGO   .TMEMBER\n.Q       RCPBTU DALDSNAM,1,&DSN\n.TMEMBER AIF   ('&MEM' EQ '').EXIT\n         SPACE\n***********************************************************************\n**   BUILD THE MEMBER NAME TEXT UNIT                                 **\n***********************************************************************\n&MEMBER  SETC  '&MEM'\n         AIF   ('&MEM' NE '*').MOK\n         AIF   ('&DSN'(1,1) NE '''').MAST\n         MNOTE 8,'---> MEMBER=* INVALID WITH QUOTED DSNAME'\n         MEXIT\n.MAST    ANOP\n&MEMBER  SETC  '8+&DSN'\n.MOK     ANOP\n         AIF   ('&MEMBER'(K'&MEMBER,1) EQ '/').BM\n         RCPSR2\n         AIF   ('&MEMBER'(1,1) EQ '(').RM\n         LH    R2,4+&MEMBER            LOAD LENGTH OF MEMBER NAME\n         LTR   R2,R2                   TEST FOR ZERO\n         BZ    *+30                    IF NO MEMBER, SKIP\n         L     R14,&MEMBER             LOAD ADDRESS OF MEMBER\n         AGO   .STHM\n.RM      LH    R2,4&MEMBER             LOAD LENGTH OF MEMBER\n         LTR   R2,R2                   AND TEST FOR ZERO\n         BZ    *+30                    IF NO MEMBER, SKIP\n         L     R14,0&MEMBER            LOAD ADDRESS OF MEMBER\n.STHM    STH   R2,S99TULNG             STORE LENGTH OF MEMBER\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE IN MEMBER NAME\n         MVI   S99TUKEY+1,DALMEMBR     MOVE IN MEMBER KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 14\n         MEXIT\n.BM      RCPTUBFR DALMEMBR,14,&MEMBER\n         MEXIT\n.QM      RCPBTU DALMEMBR,1,&MEMBER\n.EXIT    MEND\n         MACRO\n         RCPSR2 &A\n         GBLB  &RCPSR2\n         GBLC  &DYNP\n         LCLC  &C\n.*   TO SAVE REG 2 IN REG 0 FOR ALLOC INNER MACROS FIRST TIME ONLY\n.*    IF OPERAND SUPPLIED AND SAVE DONE, RESTORES REG 2 AND\n.*    GENERATES MOVE INSTRUCTION FOR EXECUTE\n         AIF   ('&A' NE '').UNSAVE\n         AIF   (&RCPSR2).EXIT\n&RCPSR2  SETB  1\n         LR    R0,R2                   SAVE CONTENTS OF REGISTER 2\n         MEXIT\n.UNSAVE  AIF   (NOT &RCPSR2).EXIT\n         B     *+10                    SKIP NEXT INSTRUCTION\n&C       SETC  '&DYNP.MVC'\n&C       MVC   S99TUPAR(0),0(R14)      EXECUTED MOVE\n         LR    R2,R0                   RESTORE CONTENTS OF REGISTER 2\n&RCPSR2  SETB  0\n.EXIT    MEND\n         MACRO\n&SYMBOL  XPRCLOSE  &WA\n.* MACRO TO EXECUTE A CLOSE CALL TO 'XPRNTSUB'.\n         CNOP  0,4\n&SYMBOL  B     *+8                     BRANCH AROUND ADDRESS\n         XPRINNRA  &WA,68\n         MEND\n         MACRO\n&SYMBOL  XPRDCB  &DDNAME=SYSPRINT,&BLKSIZE=0\n         LCLC  &TAG\n.* MACRO TO GENERATE A WORK AREA FOR A PRINTER DATA SET, CONTAINING\n.* A SAVE AREA, THE DCB, OPEN AND CLOSE PARAMETER LISTS, AND VARIOUS\n.* CELLS AND SWITCHES.\n&TAG     SETC  '&SYMBOL'\n         AIF   (T'&SYMBOL NE 'O').TOK  TEST IF NAME SUPPLIED\n&TAG     SETC  'XPRDCB01'              SUPPLY STANDARD PRDCB NAME\n.TOK     ANOP\n&TAG     DS    0D                      ALIGN ON DOUBLE-WORD BOUNDARY\n         DS    18F                     STANDARD SAVE AREA\n         SPACE\n*        DCB   DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,           X\n*              BLKSIZE=&BLKSIZE,MACRF=PL,BFTEK=S,BUFNO=2\nIHB&SYSNDX DCB DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,            X\n               BLKSIZE=&BLKSIZE,MACRF=PL,BFTEK=S,BUFNO=2\n         SPACE\n* PARAMETER LISTS FOR OPEN AND CLOSE:\n         SPACE\n         OPEN  (IHB&SYSNDX,(OUTPUT,LEAVE)),MF=L  PARM LIST FOR OPEN\n         SPACE\n         CLOSE (IHB&SYSNDX,LEAVE),MF=L PARM LIST FOR CLOSE\n         SPACE\n* WORK CELLS AND VARIABLE STORAGE:\n         SPACE\n         DS    1D                      WORK CELL\n         DS    3F                      WORK CELLS\n         DS    1A                      PAGE HEADING PARM LIST ADDRESS\n         DS    1F                      MAXIMUM NUMBER OF OUTPUT LINES\n         DS    1H                      PAGE WIDTH\n         DS    1H                      PAGE LENGTH\n         DS    1H                      PAGE NUMBER\n         DS    1H                      PAGE BALANCE\n         DS    1X                      SWITCHES\n         DS    CL24                    DATE & TIME FOR PAGE HEADING\n         SPACE 2\n         MEND\n         MACRO\n&SYMBOL  XPREJECT  &WA,&COND=\n.* MACRO TO EXECUTE AN EJECT CALL TO 'XPRNTSUB'.\n         LCLC  &TAG,&SYM,&OPT,&R\n         LCLA  &K\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n         CNOP  2,4\n.TST1    AIF   ('&COND' NE '').TST2\n&OPT     SETC  'F000'\n         AGO   .SIMPLE\n.TST2    AIF   ('&COND' NE 'ATHOF').TSTC\n&OPT     SETC  'F100'\n.SIMPLE  ANOP\n&SYM     BAS   1,&TAG.L                LOAD PARM ADDRESS\n         DC    XL2'&OPT'               OPTION BITS\n         AGO   .VCON\n.TSTC    AIF   ('&COND(1)' NE 'EQ').NE\n&OPT     SETC  '80'\n.NE      AIF   ('&COND(1)' NE 'NE').LT\n&OPT     SETC  '70'\n.LT      AIF   ('&COND(1)' NE 'LT').GT\n&OPT     SETC  '40'\n.GT      AIF   ('&COND(1)' NE 'GT').LE\n&OPT     SETC  '20'\n.LE      AIF   ('&COND(1)' NE 'LE').GE\n&OPT     SETC  'C0'\n.GE      AIF   ('&COND(1)' NE 'GE').NOT\n&OPT     SETC  'A0'\n.NOT     AIF   ('&OPT' NE '').COK\n         MNOTE 4,'---> COND OPERAND &COND(1) ILLEGAL'\n.COK     AIF   ('&COND(2)' NE '').C2OK\n         MNOTE 4,'---> TEST QUANTITY MISSING'\n         AGO   .NOTREG\n.C2OK    AIF   ('&COND(2)'(1,1) NE '(').NOTREG\n&K       SETA  K'&COND(2)-2\n&R       SETC  '&COND(2)'(2,&K)\n&SYM     STC   &R,&TAG.A               STORE INTO PARM LIST\n&SYM     SETC  ''\n.NOTREG  ANOP\n&SYM     BAS   1,&TAG.L                LOAD PARM ADDRESS\n         DC    XL1'&OPT'               CONDITION MASK\n         AIF   ('&COND(2)' EQ '').NOTREG2\n         AIF   ('&COND(2)'(1,1) NE '(').NOTREG2\n&TAG.A   DC    AL1(0)                  TEST QUANTITY\n         AGO   .VCON\n.NOTREG2 DC    AL1(&COND(2))           TEST QUANTITY\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,92\n         MEND\n         MACRO\n&SYMBOL  XPRHEAD  &WA,&LIST=\n.* MACRO TO PRESENT A LIST OF PRINT LINE DESCRIPTORS FOR PAGE HEADINGS\n.* TO 'XPRNTSUB'.\n&SYMBOL  XPRLIST  &WA,LIST=&LIST,IHBPARM=80\n         MEND\n         MACRO\n&TAG     XPRINNRA  &WA,&IHBPARM\n.* INNER MACRO USED IN CALLS TO 'XPRNTSUB'\n         DC    V(XPRNTSUB)             PRINTING SUBROUTINE ADDRESS\n&TAG     L     15,*-4                  LOAD ENTRY POINT\n         AIF   ('&WA' NE '').WOK\n         LA    0,XPRDCB01              LOAD STANDARD WORK AREA ADDRESS\n         AGO   .BAL\n.WOK     AIF   ('&WA' EQ '(0)').BAL\n         AIF   ('&WA'(1,1) EQ '(').REG\n         LA    0,&WA                   LOAD WORK AREA ADDRESS\n         AGO   .BAL\n.REG     LR    0,&WA(1)                LOAD WORK AREA ADDRESS\n.BAL     BAS   14,&IHBPARM.(15)        CALL PRINT SUBROUTINE\n         MEND\n         MACRO\n&SYMBOL  XPRLDEF  &TEXT=,&LENGTH=132,&OFFSET=0,&SPA=1,&SPB=0\n.* MACRO TO DEFINE PRINT LINE DESCRIPTOR BLOCKS (\"PLD\" BLOCKS) FOR\n.* THE PRINTING SUBROUTINE \"XPRNTSUB\".\n         LCLA  &N\n         LCLC  &B3,&B6,&B7\n         ACTR  25                      JUST IN CASE\n&B3      SETC  '0'\n&B6      SETC  '0'\n&B7      SETC  '0'\n.* PROCESS OPTIONS IN SPA OPERAND:\n.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1\n         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2\n&B3      SETC  '1'\n         AGO   .TSTB1\n.TSTA2   MNOTE 4,'---> OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'\n.* PROCESS OPTIONS IN SPB OPERAND:\n.TSTB1   ANOP\n&N       SETA  2\n.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2\n&B7      SETC  '1'\n         AGO   .TSTB4\n.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3\n&B6      SETC  '1'\n         AGO   .TSTB4\n.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4\n         MNOTE 4,'---> OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'\n.TSTB4   ANOP\n&N       SETA  &N+1\n         AIF   (&N LE 3).TSTB5\n.IFTEXT  AIF   ('&TEXT' NE '').TOK\n         MNOTE 4,'---> TEXT ADDRESS MISSING'\n.TOK     ANOP\n&SYMBOL  DS    0F                      ALIGN ON FULL-WORD BOUNDARY\n         DC    BL1'000&B3.00&B6&B7'    OPTION BITS\n         DC    AL3(&TEXT)              TEXT ADDRESS\n         DC    AL1(&LENGTH)            TEXT LENGTH\n         DC    AL1(&OFFSET)            MARGIN OFFSET\n.TESTB   AIF   ('&SPB(1)' EQ 'EJECT').BSKIP\n         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP\n         DC    AL1(&SPB(1))            PRE-SPACING\n         AGO   .TESTA\n.BSKIP   ANOP\n         DC    AL1(255)                EJECT BEFORE PRINTING\n.TESTA   AIF   ('&SPA(1)' EQ 'EJECT').ASKIP\n         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP\n         DC    AL1(&SPA(1))                 POST-SPACING\n         MEXIT\n.ASKIP   ANOP\n         DC    AL1(255)                EJECT AFTER PRINTING\n         MEND\n         MACRO\n&SYMBOL  XPRLIST  &WA,&LIST=,&IHBPARM=32\n.* MACRO TO DELIVER A LIST OF PRINT LINE DESCRIPTORS TO 'XPRNTSUB'.\n         LCLA  &N,&K,&D\n         LCLC  &TAG,&SYM,&R\n         ACTR  100\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n         AIF   ('&LIST' NE '').LOK\n         MNOTE 8,'---> LIST OPERAND MUST BE SUPPLIED'\n         MEXIT\n.LOK     CNOP  0,4\n         AIF   ('&LIST' NE '(1)').STLOOP\n&SYMBOL  B     &TAG.L                  BRANCH AROUND ADDRESS\n         AGO   .VCON\n.STLOOP  ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&LIST).STDONE\n         AIF   ('&LIST(&N)'(1,1) NE '(').STLOOP\n&K       SETA  K'&LIST(&N)-2\n&R       SETC  '&LIST(&N)'(2,&K)\n&D       SETA  4*(&N-1)\n&SYM     ST    &R,&TAG.A+&D            STORE INTO PARM LIST\n&SYM     SETC  ''\n         AIF   (&N NE N'&LIST).STLOOP\n         OI    &TAG.A+&D,X'80'         SET END-OF-LIST BIT\n.STDONE  ANOP\n&SYM     BAS   1,&TAG.L                LOAD PARM LIST ADDRESS\n&SYM     SETC  '&TAG.A'\n&N       SETA  0\n.LOOP    ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&LIST).VCON\n         AIF   ('&LIST(&N)'(1,1) NE '(').NOTREG\n&SYM     DC    A(0)\n&SYM     SETC  ''\n         AGO   .LOOP\n.NOTREG  AIF   (&N EQ N'&LIST).LAST\n&SYM     DC    A(&LIST(&N))\n&SYM     SETC  ''\n         AGO   .LOOP\n.LAST    ANOP\n&SYM     DC    X'80'                   END-OF-LIST BIT\n         DC    AL3(&LIST(&N))\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,&IHBPARM\n         MEND\n         MACRO\n&SYMBOL  XPRMOD  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,       X\n               &TIME=0,&DATE=0\n.* MACRO TO EXECUTE A MODIFY CALL TO 'XPRINTSUB'.\n&SYMBOL  XPROPEN  &WA,MAXLINE=&MAXLINE,PAGENO=&PAGENO,PAGEWID=&PAGEWID,X\n               PAGELEN=&PAGELEN,TIME=&TIME,DATE=&DATE,IHBPARM=104\n         MEND\n         MACRO\n&SYMBOL  XPRNTLIN  &WA,&TEXT=00,&LENGTH=132,&OFFSET=0,&SPB=0,&SPA=1\n         LCLA  &N\n         LCLC  &B3,&B6,&B7,&T,&R\n         ACTR  25\n&T       SETC  'IHB&SYSNDX'\n&B3      SETC  '0'\n&B6      SETC  '0'\n&B7      SETC  '0'\n.* PROCESS OPTIONS IN SPA OPERAND:\n.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1\n         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2\n&B3      SETC  '1'\n         AGO   .TSTB1\n.TSTA2   MNOTE 4,'---> OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'\n.* PROCESS OPTIONS IN SPB OPERAND:\n.TSTB1   ANOP\n&N       SETA  2\n.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2\n&B7      SETC  '1'\n         AGO   .TSTB4\n.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3\n&B6      SETC  '1'\n         AGO   .TSTB4\n.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4\n         MNOTE 4,'---> OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'\n.TSTB4   ANOP\n&N       SETA  &N+1\n         AIF   (&N LE 3).TSTB5\n.* GENERATE STORE INSTRUCTIONS IF REGISTER NOTATION IS USED:\n         CNOP  0,4\n         AIF   ('&SYMBOL' EQ '').IFR1\n&SYMBOL  DS    0H\n.IFR1    AIF   ('&TEXT' NE '00').TXTOK\n         MNOTE 4,'---> TEXT ADDRESS MUST BE SUPPLIED'\n.TXTOK   AIF   ('&TEXT'(1,1) NE '(').IFR2\n         ST    &TEXT(1),&T.A           STORE TEXT ADDRESS\n         MVI   &T.A,B'000&B3.00&B6&B7' INSERT OPTION BITS\n.IFR2    AIF   ('&LENGTH'(1,1) NE '(').IFR3\n         STC   &LENGTH(1),&T.A+4       STORE TEXT LENGTH\n.IFR3    AIF   ('&OFFSET'(1,1) NE '(').IFR4\n         STC   &OFFSET(1),&T.A+5       STORE MARGIN OFFSET\n.IFR4    AIF   ('&SPB(1)'(1,1) NE '(').IFR5\n&N       SETA  K'&SPB(1)-2\n&R       SETC  '&SPB(1)'(2,&N)\n         STC   &R,&T.A+6               STORE PRE-SPACING\n.IFR5    AIF   ('&SPA(1)'(1,1) NE '(').LOAD1\n&N       SETA  K'&SPA(1)-2\n&R       SETC  '&SPA(1)'(2,&N)\n         STC   &R,&T.A+7               STORE POST-SPACING\n.* LOAD REG 1 AND GENERATE PLD LIST ADDRESS:\n.LOAD1   BAS   1,&T.L                  LOAD PARM ADDRESS\n         DC    X'80'                   MARK END OF ADDRESS LIST\n         DC    AL3(&T.A)               ADDRESS OF PLD\n.* GENREATE PLD PARAMETERS TO DESCRIBE THE PRINT LINE:\n.IFR11   AIF   ('&TEXT'(1,1) NE '(').NOTR11\n&T.A     DC    A(0)                    TEXT ADDRESS & OPTION BITS\n         AGO   .IFR12\n.NOTR11  ANOP\n&T.A     DC    B'000&B3.00&B6&B7'      OPTION BITS\n         DC    AL3(&TEXT)              TEXT ADDRESS\n.IFR12   AIF   ('&LENGTH'(1,1) NE '(').NOTR12\n         DC    AL1(0)                  TEXT LENGTH\n         AGO   .IFR13\n.NOTR12  DC    AL1(&LENGTH)            TEXT LENGTH\n.IFR13   AIF   ('&OFFSET'(1,1) NE '(').NOTR13\n         DC    AL1(0)                  MARGIN OFFSET\n         AGO   .IFR14\n.NOTR13  DC    AL1(&OFFSET)            MARGIN OFFSET\n.IFR14   AIF   ('&SPB(1)'(1,1) NE '(').NOTR14\n         DC    AL1(0)                  PRE-SPACING\n         AGO   .IFR15\n.NOTR14  AIF   ('&SPB(1)' EQ 'EJECT').BSKIP\n         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP\n         DC    AL1(&SPB(1))            PRE-SPACING\n         AGO   .IFR15\n.BSKIP   DC    AL1(255)                SKIP BEFOR PRINTING\n.IFR15   AIF   ('&SPA(1)'(1,1) NE '(').NOTR15\n         DC    AL1(0)                  POST-SPACING\n         AGO   .VCON\n.NOTR15  AIF   ('&SPA(1)' EQ 'EJECT').ASKIP\n         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP\n         DC    AL1(&SPA(1))            POST-SPACING\n         AGO   .VCON\n.ASKIP   DC    AL1(255)                SKIP AFTER PRINTING\n.VCON    ANOP\n&T.L    XPRINNRA  &WA,32\n         MEND\n         MACRO\n&SYMBOL  XPROPEN  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,      X\n               &TIME=0,&DATE=0,&DDNAME=SYSPRINT,&IHBPARM=56\n.* MACRO TO EXECUTE AN 'OPEN' OR 'MODIFY' CALL TO 'XPRNTSUB'.\n         LCLC  &TAG\n&TAG     SETC  'IHB&SYSNDX'\n         AIF   ('&SYMBOL' EQ '').T1\n&SYMBOL  DS    0H\n.T1      AIF   ('&MAXLINE'(1,1) NE '(').T2\n         ST    &MAXLINE(1),&TAG.A      STORE IN PARM LIST\n.T2      AIF   ('&PAGENO'(1,1) NE '(').T3\n         STH   &PAGENO(1),&TAG.A+4     STORE IN PARM LIST\n.T3      AIF   ('&PAGEWID'(1,1) NE '(').T4\n         STC   &PAGEWID(1),&TAG.A+6    STORE IN PARM LIST\n.T4      AIF   ('&PAGELEN'(1,1) NE '(').T5\n         STC   &PAGELEN(1),&TAG.A+7    STORE IN PARM LIST\n.T5      AIF   ('&TIME'(1,1) NE '(').T6\n         ST    &TIME(1),&TAG.A+8       STORE IN PARM LIST\n.T6      AIF   ('&DATE'(1,1) NE '(').T7\n         ST    &DATE(1),&TAG.A+12      STORE IN PARM LIST\n.T7      AIF   ('&DDNAME'(1,1) NE '(').CNOP\n         MVC   &TAG.A+16(8),0(&DDNAME(1))  STORE IN PARM LIST\n.CNOP    CNOP  0,4\n         BAS   1,&TAG.L        LOAD PARM LIST ADDRESS\n.P1      AIF   ('&MAXLINE'(1,1) EQ '(').PR1\n&TAG.A   DC    A(&MAXLINE)             PRINT OUTPUT LIMIT\n         AGO   .P2\n.PR1     ANOP\n&TAG.A   DC    A(0)                    PRINT OUTPUT LIMIT\n.P2      AIF   ('&PAGENO'(1,1) EQ '(').PR2\n         DC    AL2(&PAGENO)            PAGE NUMBER\n         AGO   .P3\n.PR2     DC    AL2(0)                  PAGE NUMBER\n.P3      AIF   ('&PAGEWID'(1,1) EQ '(').PR3\n         DC    AL1(&PAGEWID)           PAGE WIDTH\n         AGO   .P4\n.PR3     DC    AL1(0)                  PAGE WIDTH\n.P4      AIF   ('&PAGELEN'(1,1) EQ '(').PR4\n         DC    AL1(&PAGELEN)           PAGE LENGTH\n         AGO   .P5\n.PR4     DC    AL1(0)                  PAGE LENGTH\n.P5      AIF   ('&TIME'(1,1) EQ '(').PR5\n         DC    A(&TIME)                ADDRESS OF TIME\n         AGO   .P6\n.PR5     DC    A(0)                    ADDRESS OF TIME\n.P6      AIF   ('&DATE'(1,1) EQ '(').PR6\n         DC    A(&DATE)                ADDRESS OF DATE\n         AGO   .P7\n.PR6     DC    A(0)                    ADDRESS OF DATE\n.P7      AIF   ('&IHBPARM' NE '56').VCON\n         AIF   ('&DDNAME'(1,1) EQ '(').PR7\n         DC    CL8'&DDNAME'            DDNAME FOR DATA SET\n         AGO   .VCON\n.PR7     DC    CL8' '                  DDNAME FOR DATA SET\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,&IHBPARM\n         MEND\n         MACRO\n&SYMBOL  XPRSPACE  &WA,&LINES=1,&COND=\n.* MACRO TO EXECUTE A SPACE CALL TO 'XPRNTSUB'.\n         LCLA  &N,&B6,&B7\n         LCLC  &TAG,&SYM\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n.LOOP    ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&COND).LDONE\n.TST1    AIF   ('&COND(&N)' NE 'NOEJ').TST2\n&B6      SETA  1\n         AGO   .LOOP\n.TST2    AIF   ('&COND(&N)' NE 'ATHOF').TST3\n&B7      SETA  1\n         AGO   .LOOP\n.TST3    MNOTE 4,'---> OPERAND &COND(&N) AFTER KEYWORD COND IS ILLEGAL'\n         AGO   .LOOP\n.LDONE   CNOP  2,4\n         AIF   ('&LINES'(1,1) NE '(').NOTREG1\n&SYM     STC   &LINES(1),&TAG.A+1      STORE INTO PARM LIST\n&SYM     SETC  ''\n.NOTREG1 ANOP\n&SYM     BAS   1,&TAG.L                LOAD PARM LIST ADDRESS\n&TAG.A   DC    B'000000&B6&B7'         OPTION BITS\n         AIF   ('&LINES'(1,1) NE '(').NOTREG2\n         DC    X'00'                   SPACING AMOUNT\n         AGO   .VCON\n.NOTREG2 DC    AL1(&LINES)             SPACING AMOUNT\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,44\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTICMS": {"ttr": 24330, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x885\\x0f\\x00\\x885\\x0f\\x11)\\x00F\\x00F\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-15T00:00:00", "modifydate": "1988-12-15T11:29:00", "lines": 70, "newlines": 70, "modlines": 0, "user": "SYSPAJA"}, "text": "         TITLE 'MESSAGE ROUTINE.'\nMESGRTN  $PROLOG R12\n         L     R4,=V(DATASECT)\n         USING DATASECT,R4\n         CLI   MALLOC,255        HAS SYSLIST BEEN ALLOCATED?\n         BE    MALLOC1           ONCE ONLY PLEASE.\n         MVI   MALLOC,255        MARK IT AS ALLOCATED.\n         ST    R1,MR1SAVE        FOLLOWING CODE BAGS R1\n         XPROPEN PWL,                                                  X\n               PAGELEN=PAGELEN,                                        X\n               DDNAME=SYSLIST    AND OPEN IT.\n         LTR   R15,R15           WELL......\n         BZ    MSGOK             YUP.\n         WTO   'SYSLIST NOT OPENED',ROUTCDE=11\n         ABEND 13\nMSGOK    XPREJECT PWL            SKIP TO A NEW PAGE.\n         XPRHEAD PWL,                                                  X\n               LIST=SLHEAD1      AND DEFINE THE HEADING.\n         L     R1,MR1SAVE        MESSAGE NUMBER FROM CALLER.\nMALLOC1  L     R3,=V(MESSAGES)   GET ADDRESS OF MESSAGE TABLE.\n         SLL   R1,1              TIMES 2 FOR HALFWORD INDEX\n         LH    R1,0(R1,R3)       PICKUP INDEX INTO MESSGAE TABLE.\n         AR    R1,R3             DEVELOP OFFSET OF MESSAGE TEXT.\n         XR    R3,R3             ZERO REGISTER.\n         IC    R3,0(,R1)         PICKUP TEXT LENGTH\n         XR    R4,R4             ZERO REGISTER.\n         IC    R4,1(,R1)         LENGTH TO BE INSERTED.\n         LTR   R4,R4             ANYTHING TO INSERT?\n         BZ    MSKIP2            NO, PRINT MESSAGE AS IS.\n         LR    R5,R3             MESSAGE LENGTH\n         SR    R5,R4             MINUS INSERT LENGTH\n         AR    R5,R1             PLUS START ADDR\n         LA    R5,2(,R5)         PLUS 2 IS INSERT POINT.\n         BCTR  R4,0              MINUS 1 FOR EX.\n         EX    R4,MINSERT        ADD INSERT TEXT.\nMSKIP2   LA    R1,2(,R1)         SKIP OVER LENGTH BYTES.\n         XPRNTLIN PWL,                                                 X\n               TEXT=(R1),                                              X\n               LENGTH=(R3),                                            X\n               SPB=((R0)),                                             X\n               SPA=1             PRINT THE MESSAGE TEXT.\nMSKIP1   EQU   *\n         $EPILOG ,\nNOSYSLST ABEND 130,DUMP\n         LTORG ,\nMINSERT  MVC   0(0,R5),0(R2)     CUSTOMIZE A MESSAGE.\nMALLOC   DC    A(*-*)            HAS SYSLIST BEEN ALLOCATED.\nMR1SAVE  DC    AL4(0)            SAVEAREA FOR REGISTER 1.\nPWL      XPRDCB DDNAME=SYSLIST\nSLHEAD1  XPRLDEF TEXT=SLHTXT1,                                         X\n               LENGTH=L'SLHTXT1,                                       X\n               SPB=(0,ATHOF),                                          X\n               SPA=2\nSLHTXT1  DC    C'&NAME &VERSION -- MESSAGES'\nMESSAGES CSECT\n         DC    Y(MESG0-MESSAGES)\n         DC    Y(MESG1-MESSAGES)\n         DC    Y(MESG2-MESSAGES)\n         DC    Y(MESG3-MESSAGES)\n         DC    Y(MESG4-MESSAGES)\n         DC    Y(MESG5-MESSAGES)\n         DC    Y(MESG6-MESSAGES)\n         SPACE ,\n         MESG  0,0,'&NAME &VERSION -- ENDED SUCCESSFULLY.'\n         MESG  1,0,'&NAME &VERSION -- STARTING.'\n         MESG  2,4,'VSAM LOGICAL ERROR ON VVDS GET. FDBK = '\n         MESG  3,44,'VVR NOT FOUND WHEN EXPECTED. DSN: '\n         MESG  4,44,'INCOMPLETE DATA FOR DSN: '\n         MESG  5,8,'OPEN FAILED FOR VVDS ON VOLUME: '\n         MESG  6,0,'OPEN FAILED FOR HSM MCDS, DDN: SYSUT2'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTICPR": {"ttr": 24577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x885\\x0f\\x00\\x885\\x0f\\x11)\\x04p\\x04p\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-15T00:00:00", "modifydate": "1988-12-15T11:29:00", "lines": 1136, "newlines": 1136, "modlines": 0, "user": "SYSPAJA"}, "text": "         TITLE 'XPRNTSUB - GENERAL PRINTING SUBROUTINE'\n         SPACE 1\n* FUNCTION/OPERATION : THIS IS A GENERAL PRINTING SUBROUTINE TO MANAGE\n*        THE DETAILS OF PAGINATION, HEADINGS, AND OUTPUT COMPRESSION\n*        FOR PRINTED OUTPUT. IT IS INVOKED FROM A PROBLEM PROGRAM VIA\n*        THE MACRO 'XPRNT', WHICH HAS THE FOLLOWING CALL MODES :\n*           OPEN - INITIALIZES PAGE SIZE PARAMETERS AND MAXIMUM NUMBER\n*              OF OUTPUT LINES, RESETS PAGE NUMBER, CLEARS HEADING\n*              LINES AND INSERTS CURRENT DATE AND TIME, INSERTS DDNAME\n*              IN DCB, AND OPENS THE DATA SET.\n*           MODIFY - ALTERS ANY OR ALL OF THE PARAMETERS LISTED UNDER\n*              'OPEN' EXCEPT THE DDNAME.\n*           SETHEAD - SUPPLIES TEXT FOR ONE OR MORE LINES TO BE USED\n*              PAGE HEADINGS.\n*           PRINT - DELIVERS ONE OR MORE LINES TO BE PRINTED.\n*           SPACE - MOVES THE PAGE VERTICALLY A GIVEN NUMBER OF LINES.\n*           EJECT - CONDITIONAL OR UNCONDITIONAL SKIP TO HEAD-OF-FORM.\n*           CLOSE - CLOSES THE DATA SET.\n         SPACE 1\n* ENTRY POINTS : EACH MODE HAS A SEPARATE ENTRY AT A FIXED OFFSET FROM\n*        THE BASE ADDRESS. ENTRIES ARE EFFECTED BY A  BAS  14,D(15)\n*        (WHERE D IS A DISPLACEMENT WHICH SELECTS THE DESIRED MODE) AND\n*        ASSUMES THAT REGISTER 13 ADDRESSES A STANDARD 18-WORD SAVE\n*        AREA.\n         SPACE 1\n* INPUT : ON ENTRY, REG 0 POINTS TO A WORK AREA FOR THE DATA SET, WHICH\n*        IS DESCRIBED IN THIS CODING BY THE DUMMY SECTION 'WORKAREA'.\n*        REG 1 POINTS TO A PARAMETER LIST OF A FORM APPROPRIATE TO THE\n*        CALL MODE. THESE LISTS ARE EITHER DESCRIBED BY DUMMY SECTIONS\n*        OR ARE STANDARD VARIABLE-LENGTH ADDRESS LISTS.\n         SPACE 1\n* OUTPUT : PRINT LINES AND SPACE CONTROL RECORDS ARE DELIVERED VIA QSAM\n*        TO A SEQUENTIAL DATA SET. EACH LINE IS REDUCED TO ITS MIN-\n*        IMUM LENGTH BY TRUNCATING TRAILING BLANKS.\n         SPACE 1\n* DATA SETS : THE OUTPUT DATA SET IS SEQUENTIAL, ARRANGED FOR BLOCKED\n*        FORMAT V RECORDS USING MACHINE CONTROL CHARACTERS APPROPRIATE\n*        TO 1403 OR 1404 PRINTERS. THE DDNAME IS SUPPLIED BY THE\n*        'OPEN' CALL; THE STANDARD VALUE IS 'SYSPRINT'.\n         SPACE 1\n* EXTERNAL ROUTINES : CALLS 'XDATEDIT' TO FORMAT THE DATE FOR THE\n*        PAGE HEADING LINE.\n         SPACE 1\n* EXITS - NORMAL : RETURNS VIA REG 14 WITH RETURN CODE 0 IN REG 15.\n*        THE CURRENT PAGE NUMBER (IN BINARY) IS IN REG 0 AND THE BINARY\n*        NUMBER OF LINES REMAINING ON THE CURRENT PAGE IS IN REG 1.\n*        IF AN OPEN CALL CANNOT OPEN THE DCB, THE RETURN CODE IS 4.\n         SPACE 1\n* EXITS - ERROR : ERRONEOUS CALLS RESULT IN AN 'ABEND' WITH ONE OF THE\n*        FOLLOWING COMPLETION CODES :\n*           4000 - ROUTINE WAS ILLEGALLY ENTERED AT ITS BASE ADDRESS.\n*           4002 - A CALL MODE OTHER THAN 'OPEN' WAS DIRECTED TO A DATA\n*              SET WHICH WAS NOT OPEN.\n*           4003 - 'OPEN' OR 'MODIFY' SPECIFIED TOO LARGE A PAGE WIDTH.\n*           4004 - 'OPEN' OR 'MODIFY' SPECIFIED TOO LONG A PAGE.\n*           4005 - 'PRINT' OR 'SETHEAD' SPECIFIED A LINE WHOSE TEXT\n*              LENGTH PLUS OFFSET EXCEEDED THE PAGE WIDTH.\n*           4006 - THE MAXIMUM NUMBER OF OUTPUT LINES WAS EXCEEDED.\n*           4007 - SYNCHRONOUS I/O ERROR.\n         SPACE 1\n* TABLES/WORK AREAS : THE CALL PARAMETER LISTS, WORK AREA, AND PRINT\n*        LINE DESCRIPTOR BLOCK ARE ALL DESCRIBED BY DUMMY SECTIONS\n*        AT THE END OF THE PROGRAM.\n         SPACE 1\n* ATTRIBUTES : REENTRANT, READ-ONLY.  WILL HANDLE ANY NUMBER OF DATA\n*        SETS SIMULTANEOUSLY, USING A SEPARATE WORK AREA FOR EACH.\n         SPACE 1\n* OPERATING ENVIRONMENT : RUNS UNDER OPERATING SYSTEM/360, USING\n*        QSAM DATA MANAGEMENT WITH LOCATE-MODE PUT MACROS AND SIMPLE\n*        BUFFERING.  ASSUMES OPTION 6A OR 6B FOR TIME OF DAY.\n         SPACE 1\n* NOTES : NONE.\n         EJECT\nXPRNTSUB CSECT\n         SPACE 2\n* REGISTER ASSIGNMENTS :\n         SPACE 2\n* N.B. - REGISTER GROUPS 'RWA,RWB,RWC,RWD' AND 'RLPEXIT,RPARM' MUST BE\n*        KEPT IN ORDER FOR LM AND STM ORDERS.\n         SPACE 1\nRWA      EQU   2                   GENERAL WORK REG\nRWB      EQU   3                   GENERAL WORK REG\nRWC      EQU   4                   GENERAL WORK REG\nRWD      EQU   5                   GENERAL WORK REG\nRSPACE   EQU   6                   NUMBER OF LINES TO SPACE\nRBAL     EQU   7                   NUMBER OF LINES LEFT ON PAGE\nRLPEXIT  EQU   8                   EXIT FROM LIST PROCESSING ROUTINE\nRPARM    EQU   9                   CALL PARAMETER LIST ADDR\nRPLD     EQU   10                  PLD BLOCK BASE\nRWKAREA  EQU   11                  BASE REGISTER FOR WORK AREA\nRBASE    EQU   12                  BASE REGISTER FOR CODING\nRRET     EQU   14                  STANDARD RETURN ADDR\n         SPACE 1\n*        MASKS FOR CONTROL BYTE \"SWITCHES\" :\n         SPACE 1\nHOFBIT   EQU   X'80'               PAGE IS AT PHYSICAL HEAD-OF-FORM\nNOSKBIT  EQU   X'40'               DISALLOW EJECT DURING HEAD PRINTING\nTXT1BIT  EQU   X'20'               ON FOR FIRST TEXT LINE ON PAGE\nHD1BIT   EQU   X'10'               ON FOR FIRST HEAD LINE WITH PAGE\n*                                  NO, ETC\nSP0BIT   EQU   X'08'               LAST LINE SPACED 0\n         SPACE 2\nEJFORCE  EQU   255                 SPACING QUANTITY TO FORCE PAGE EJECT\nOPENBIT  EQU   X'10'               TO TEST 'DCBOFLGS' FOR SUCCESSFUL\n*                                  OPEN\nMAXLNGTH EQU   254                 MAXIMUM PAGE LENGTH\nMAXWIDTH EQU   132                 MAXIMUM PAGE WIDTH\nDEFBLKSZ EQU   1692                DEFAULT DCB BLOCK SIZE\n         EJECT\n**********************\n* ENTRY AND PROLOGUE *\n**********************\n         SPACE 1\n* ENTER FROM THE CALLING SEQUENCE VIA THE INSTRUCTION \"BAS 14,X(0,15)\".\n* REGISTER 15 IS SET TO THE BASE OF THE ROUTINE AND THE DISPLACEMENT\n* \"X\" SELECTS THE ENTRY POINT. EACH ENTRY SAVES REGISTERS, LOADS THE\n* ADDRESS OF THE APPROPRIATE SUBROUTINE, AND GOES TO A COMMON\n* PROLOGUE. NOTE THAT AN ATTEMPT TO ENTER AT THE BASE RESULTS IN\n* AN ABEND.\n         SPACE 1\nBASEADDR B     20(0,R15)           BRANCH AROUND MODULE IDENTIFIER\n         DC    AL1(15)             LENGTH OF IDENTIFIER\n         DC    CL15'XPRNTSUB-028214'\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         XR    R1,R1               SET ABEND COMPLETION CODE\n         LR    RBASE,R15           SET BASE REG FOR ABEND ROUTINE\n         USING BASEADDR,RBASE\n         B     ABEND\n         DROP  RBASE\n         SPACE 1\n* ENTRY POINTS FOR VARIOUS FUNCTIONS, AT 12-BYTE INTERVALS BEGINNING\n* AT BASEADDR+32. EACH LOADS \"RWA\" WITH THE ADDRESS OF THE SUBROUTINE\n* TO GO TO AFTER EXECUTING \"PROLOGUE\".\n         SPACE 1\n         ORG   XPRNTSUB+32\n         USING BASEADDR,R15\n         SPACE 1\nPRENTRY  STM   R14,R12,12(R13)     PRINT\n         LA    RWA,PRPROC\n         B     PROLOGUE\nSPENTRY  STM   R14,R12,12(R13)     SPACE\n         LA    RWA,SPPROC\n         B     PROLOGUE\nOPENTRY  STM   R14,R12,12(R13)     OPEN\n         LA    RWA,OPPROC\n         B     PROLOGUE\nCLENTRY  STM   R14,R12,12(R13)     CLOSE\n         LA    RWA,CLPROC\n         B     PROLOGUE\nSHENTRY  STM   R14,R12,12(R13)     SETHEAD\n         LA    RWA,SHPROC\n         B     PROLOGUE\nEJENTRY  STM   R14,R12,12(R13)     EJECT\n         LA    RWA,EJPROC\n         B     PROLOGUE\nMDENTRY  STM   R14,R12,12(R13)     MODIFY\n         LA    RWA,MDPROC\n         B     PROLOGUE\n         EJECT\n* PROLOGUE. SET UP BASE REGISTERS FOR CODING AND WORK AREA.  CHAIN\n* SAVE AREAS IN STANDARD FASHION. LOAD \"RBAL\" WITH CURRENT PAGE\n* BALANCE AND \"RPARM\" WITH THE CALLING PARAMETER LIST ADDRESS.\n         SPACE 1\nPROLOGUE LR    RBASE,R15           LOAD CODING BASE REG\n         USING BASEADDR,RBASE\n         DROP  R15\n         LR    RWKAREA,R0          BASE REG FOR WORK AREA\n         USING WORKAREA,RWKAREA\n         LR    RWB,R13             ADDR OF CALLER'S SAVE AREA\n         LA    R13,SAVEAREA        ADDR OF OUR SAVE AREA\n         ST    R13,8(RWB)          CHAIN TO US FROM CALLER\n         ST    RWB,SAVEAREA+4      CHAIN TO CALLER FROM US\n         LR    RPARM,R1            LOAD PARAMETER LIST ADDR\n         LH    RBAL,PAGEBAL        LOAD PAGE LINE COUNT BALANCE\n         MVC   DCBSYNAD(3),=AL3(SYNAD)  PUT ERROR ROUTINE ADDRESS IN\n*                                  DCB\n         TM    DCBOFLGS,OPENBIT    MAKE SURE DATA SET IS OPEN\n         BCR   1,RWA               BRANCH IF OPEN\n         CL    RWA,=A(OPPROC)      IF NOT, ONLY OPEN CALL ALLOWED\n         BCR   8,RWA               BR IF OPEN CALL\n         LA    R1,2                ERROR CODE 2, GO TO ABEND\n         SPACE 1\n* ABEND ROUTINE FOR SERIOUS ERRORS.  ENTER WITH ERROR NUMBER IN R1.\n* ADD DECIMAL 4000 FOR USER CONPLETION CODE AND ISSUE 'ABEND' WITH DUMP\n         SPACE 1\n         CNOP  2,4                 ALIGN CONSTANT FOLLOWING SVC\nABEND    AL    R1,*+6              LOAD ABEND CODES\n         SVC   13                  ISSUE ABEND SVC\n         DC    X'80'               'DUMP' BIT FOR ABEND\n         DC    AL3(4000)           BASE FOR COMPLETION CODE\n         EJECT\n************\n* EPILOGUE *\n************\n         SPACE 1\n* ALL MODES RETURN TO THE CALLER VIA THIS ROUTINE. IT EXITS WITH\n* THE RETURN CODE IN REGISTER 15, THE PAGE NUMBER IN REGISTER 0, AND\n* THE NUMBER OF LINES REMAINING ON THE PAGE IN REGISTER 1.\n         SPACE 1\nEXIT4    LA    R15,4               SET RETURN CODE 4\n         B     EXIT\n         SPACE 1\nEXIT0    XR    R15,R15             SET RETURN CODE 0\n         SPACE 1\nEXIT     LH    R0,PAGENO           LOAD CURRENT PAGE NUMBER\n         LR    R1,RBAL             LOAD NUMBER OF LINES LEFT\n         STH   RBAL,PAGEBAL        SAVE PAGE BALANCE\n         XC    DCBSYNAD(3),DCBSYNAD  CLEAR ERROR ROUTINE ADDRESS\n         L     R13,SAVEAREA+4      ADDRESS OF CALLER'S SAVE AREA\n         L     R14,12(R13)         LOAD RETURN ADDRESS\n         LM    R2,R12,28(R13)      RESTORE CALLER'S REGISTERS\n         MVI   12(R13),X'FF'       SET RETURN INDICATION\n         BR    R14                 RETURN TO CALLER\n         SPACE 2\n******************\n* PRINT FUNCTION *\n******************\n         SPACE 1\n* PRINT LINE DELIVERY CALL. THE PARAMETER LIST IS A VARIABLE-LENGTH\n* LIST OF ADDRESSES, THE LAST OF WHICH IS NEGATIVE (I.E. BIT 0 IS A 1).\n* EACH ADDRESS POINTS TO A PLD DESCRIBING A LINE TO BE PRINTED. CALL\n* THE GENERAL LIST PROCESSING ROUTINE TO DO THE DIRTY WORK.\n         SPACE 1\nPRPROC   BAS   RLPEXIT,LISTPROC    INVOKE LIST PROCESSOR\n         B     EXIT0               EXIT TO CALLER\n         EJECT\n******************\n* SPACE FUNCTION *\n******************\n         SPACE 1\n* CALL TO MOVE THE PAPER A SPECIFIED NUMBER OF LINES. IF THE NUMBER\n* OF LINES EXCEEDS THE CURRENT PAGE BALANCE, AN EJECT RESULTS, UNLESS\n* SUPPRESSED BY THE 'SPNOEJ' BIT IN THE PARAMETER LIST. IF THE PAGE\n* IS AT HEAD-OF-FORM, SPACING IS SUPPRESSED UNLESS THE 'SPATHOF' BIT\n* IS SET IN THE PARAMETER LIST. IN THE LATTER CASE, THE PAGE HEADINGS\n* WILL BE PRINTED BEFORE THE SPACING IS EXECUTED.\n         SPACE 1\n         USING SPPARM,RPARM        ADDRESSING FOR PARM LIST\nSPPROC   TM    SWITCHES,HOFBIT     TEST IF AT HEAD-OF-FORM\n         BZ    SPSUBTR             BR IF NOT\n         TM    SPCOND,SPATHOF      IS SPACE ALLOWED AT HOF?\n         BZ    EXIT0               EXIT IF NOT\n         BAS   RRET,HEADPRNT       IF SO, PRINT HEADINGS FIRST\nSPSUBTR  XR    RSPACE,RSPACE\n         IC    RSPACE,SPQUAN       LOAD SPACING AMOUNT\n         SR    RBAL,RSPACE         COMPUTE NEW PAGE BALANCE\n         BP    SPMOVE              BRANCH IF BAS STILL > 0\n         TM    SPCOND,SPNOEJ       TEST IF EJECT ALLOWED\n         BO    SPMOVE              BRANCH IF NOT\n         LA    RSPACE,EJFORCE      IF ALLOWED, FORCE EJECT\nSPMOVE   BAS   RWA,MOVE            CALL PAPER MOVING SUB\n         B     EXIT0               EXIT TO CALLER\n         DROP  RPARM\n         EJECT\n******************\n* EJECT FUNCTION *\n******************\n         SPACE 1\n* CALL TO MOVE THE PAPER TO HEAD-OF-FORM. IF THE PAGE IS ALREADY\n* THERE, THE EJECT IS NOT EXECUTED UNLESS THE 'EJATHOF' BIT IN THE\n* PARAMETER LIST IS ON. IN THE LATTER CASE, A SKIP IS EXECUTED WITHOUT\n* PRINTING ANY HEADINGS, RESULTING IN A BLANK PAGE. IF THE MASK BITS\n* IN THE 'EJCOND' PARAMETER ARE NOT ALL ONES, A CONDITIONAL EJECT IS\n* REQUESTED. THE PAGE BALANCE IS COMPARED AGAINST THE TEST QUANTITY\n* 'EJQUAN' IN THE PARAMETER LIST, THEN THE DECISION TO EJECT OR NOT\n* IS MADE WITH A 'BC' ORDER USING THE 'EJCOND' BITS AS A MASK.\n         SPACE 1\n         USING EJPARM,RPARM        FOR PARM LIST ADDRESSING\nEJPROC   TM    SWITCHES,HOFBIT     TEST IF AT HOF\n         BZ    EJTEST              BR IF NOT\n         TM    EJCOND,EJATHOF      IF SO, IS EJECT ALLOWED?\n         BZ    EXIT0               IF NOT, EXIT\nEJTEST   XR    R0,R0\n         IC    R0,EJQUAN           LOAD TEST QUANTITY\n         IC    R1,EJCOND           GET CONDITIONAL TEST MASK\n         N     R1,=XL4'000000F0'   KEEP BITS 24-27 ONLY\n         CR    RBAL,R0             COMPARE BALANCE WITH TEST QUAN\n         EX    R1,EJBC             EXECUTE BC WITH MASK FROM PARM\n         B     EXIT0               EXIT IF CONDITION NOT MET\nEJMOVE   LA    RSPACE,EJFORCE      TO FORCE EJECT\n         BAS   RWA,MOVE            CALL PAPER MOVER SUB\n         B     EXIT0               EXIT TO CALLER\nEJBC     BC    0,EJMOVE            BRANCH IF EJECT REQUIRED\n         DROP  RPARM\n         EJECT\n*****************\n* OPEN FUNCTION *\n*****************\n         SPACE 1\n* THIS MUST BE THE FIRST CALL FOR A NEW DATA SET. IT SETS THE DDNAME\n* IN THE DCB AND OPENS THE DATA SET. ALL COUNTERS AND SWITCHES ARE\n* SET TO THEIR NOMINAL VALUES BEFORE PROCESSING ANY OPTIONS WHICH\n* MAY HAVE BEEN SUPPLIED WITH THE CALL. THE PAGE BALANCE IS SET TO\n* ZERO, BUT THE PAGE IS NOT MOVED. THE PROGRAMMER SHOULD NORMALLY\n* ISSUE AN 'EJECT' CALL BEFORE BEGINNING HIS OUTPUT.\n         SPACE 1\n* IF THE DATA SET IS ALREADY OPEN, THE DDNAME IS IGNORED, THE NOMINAL\n* OPTIONS ARE SET, THEN THIS CALL IS TREATED EXACTLY AS IF IT WERE A\n* 'MODIFY' CALL.\n         SPACE 1\n         USING OMPARM,RPARM\nOPPROC   MVC   PAPARMS(DEFSIZE),DEFAULTS  SET STANDARD OPTIONS\n         MVI   HLTEXT,C' '         CLEAR HEADING TEXT\n         MVC   HLTEXT+1(HLTXTLNG-1),HLTEXT\n         TIME  DEC                 GET CURRENT DATE & TIME\n         STM   R0,R1,HPRSAVE       SAVE TIME AND DATE\n         SPACE 1\n* NOW IF DATA SET IS ALREADY OPEN, GO TO 'MDPROC'. OTHERWISE, INSERT\n* DDNAME AND OPEN IT.\n         SPACE 1\n         TM    DCBOFLGS,OPENBIT    TEST IF OPEN\n         BO    OPJOIN              BR TO 'MDPROC' IF OPEN\n         MVC   DCBDDNAM(8),OMDDNAME  INSERT DDNAME INTO CLOSED DCB\n         MVC   DCBEXLST(3),=AL3(EXLST)  INSERT ADDRESS OF EXIT LIST\n         MVI   DWORK,X'80'         SET END-OF-LIST BIT\n         OPEN  (PRINTDCB,(OUTPUT,LEAVE)),MF=(E,DWORK)\n         XC    DCBEXLST(3),DCBEXLST  CLEAR ADDRESS OF EXIT LIST\n         TM    DCBOFLGS,OPENBIT    TEST FOR SUCCESSFUL OPEN\n         BO    OPJOIN              TO 'MDPROC' IF O.K.\n         B     EXIT4               EXIT WITH RC=4 IF OPEN FAILS\n         DROP  RPARM\n         EJECT\n* DCB EXIT ROUTINE FOR OPEN. SET BLOCK SIZE TO THE DEFAULT VALUE IF\n* NOT SPECIFIED IN DS LABEL OR DD CARD.\n         SPACE 1\nEXLST    DS    0F                  EXIT LIST, ON BOUNDARY\n         DC    X'85'\n         DC    AL3(DCBMOD)\n         SPACE 1\nDCBMOD   LH    RWA,DCBBLKSZ        LOAD BLOCK SIZE\n         LTR   RWA,RWA             TEST IF ZERO\n         BNZ   DCBNZ               BRANCH IF NOT ZERO\nSETDEF   LA    RWA,DEFBLKSZ        SET DEFAULT BLOCK SIZE\n         STH   RWA,DCBBLKSZ        STORE IN DCB\n         BR    R14                 RETURN TO OPEN ROUTINE\nDCBNZ    CH    RWA,=H'141'         TEST FOR MINIMUM BLOCKSIZE\n         BL    SETDEF              USE DEFAULT IF TOO LOW\n         BR    R14                 RETURN TO OPEN IF OK\n         EJECT\n*******************\n* MODIFY FUNCTION *\n*******************\n         SPACE 1\n* THIS CALL MAY ALTER ANY  OR ALL OF THE FOLLOWING : DATE, TIME, PAGE\n* NUMBER, PAGE LENGTH, PAGE WIDTH, MAXIMUM NUMBER OF OUTPUT LINES.\n* THE NEW VALUES ARE PRESENTED IN A PARAMETER LIST. IF A PARAMETER IS\n* ZERO, THE CORRESPONDING QUANTITY IS NOT ALTERED.\n         SPACE 1\n* THE DATE AND TIME FIELDS MAY BE SUPPLIED BY THE 'OPEN' ROUTINE,\n* WHICH JOINS THIS CODING AT 'OPJOIN'. IN THAT CASE, THE VALUES\n* INSERTED BY 'OPEN' ARE USED UNLESS OVERRIDDEN BY THE PARAMETER LIST.\n         SPACE 1\n         USING OMPARM,RPARM\nMDPROC   XR    R0,R0               GENERATE TWO ZERO WORDS\n         XR    R1,R1\n         STM   R0,R1,HPRSAVE       SET DATE & TIME FIELDS TO ZERO\n         SPACE 1\n* ENTER HERE FROM 'OPEN'. THE OBJECT OF THE FOLLOWING IS TO GET THE\n* ACTUAL TIME AND DATE (IN PACKED DECIMAL) INTO 'HPRSAVE' AND\n* 'HPRSAVE+4', RESPECTIVELY. THOSE FIELDS MAY HAVE BEEN FILLED IN BY\n* THE OPEN ROUTINE, OR THEY MAY HAVE BEEN SET TO ZEROS BY 'MDPROC'\n* ABOVE. NOW WE SEE IF ADDRESSES FOR TIME AND/OR DATE VALUES WERE\n* PROVIDED IN THE PARAMETER LIST, AND TRANSFER THE VALUES IF SO.\n         SPACE 1\nOPJOIN   LM    RWA,RWB,OMTIMEAD    LOAD TIME & DATE ADDRS FROM PARM\n         LTR   RWA,RWA             TEST FOR TIME ADDR SUPPLIED\n         BZ    NOTIME              BRANCH IF ZERO\n         MVC   HPRSAVE(4),0(RWA)   GET TIME AS DECIMAL 'HHMMSSTH'\nNOTIME   LTR   RWB,RWB             TEST IF DATE ADDR SUPPLIED\n         BZ    DATEEDIT            BR IF NOT\n         MVC   HPRSAVE+4(4),0(RWB)  GET DECIMAL DATE AS '00YYDDD+'\n         SPACE 1\n* IF THE DATE VALUE IS NOT ZERO, EDIT INTO THE HEADING LINE TEXT. BOTH\n* THE DAY NUMBER AND THE MONTH-DAY-YEAR FORM ARE USED.\n         SPACE 1\nDATEEDIT LM    RWA,RWB,HPRSAVE     LOAD TIME & DATE FOR TESTING\n         LTR   RWB,RWB             TEST IF DATE WAS GIVEN\n         BZ    TIMEEDIT            BRANCH IF ZERO\n         MVC   HLDAY(4),=C'DAY='   INSERT DAY NUMBER\n         UNPK  HLDAY+4(3),HPRSAVE+6(2)  UNPACK DAY NUMBER\n         OI    HLDAY+6,X'F0'       TIDY UP SIGN BITS\n         ST    RWB,DWORK+4         STORE DATE ARG FOR EDIT RTNE\n         LA    R1,DWORK            CONSTRUCT ONE-WORD PARM LIST\n         ST    R1,HPRSAVE+4        FOR XDATEDIT CALL\n         LA    R1,HPRSAVE+4        LOAD PARM LIST ADDRESS\n         L     R15,=V(XDATEDIT)    LOAD ADDRESS OF DATE EDIT RTNE\n         BASR  R14,R15             TO EDIT DATE AS 'MM/DD/YY'\n         MVC   HLDATE(8),DWORK     INSERT RESULT IN HL TEXT\n         SPACE 1\n* EDIT TIME IN HOURS AND MINUTES, IF SUPPLIED.\n         SPACE 1\nTIMEEDIT LTR   RWA,RWA             TEST IF TIME GIVEN\n         BZ    TSTPGNO             BR IF ZERO\n         SRL   RWA,4               ADD LEADING ZERO TO TIME\n         ST    RWA,HPRSAVE         STORE TIME IN WORK LOC\n         MVC   HLTIME(7),=X'402120207A2020'  EDIT CONTROL CHAR\n         ED    HLTIME(7),HPRSAVE   EDIT INTO ALPHA\n         SPACE 1\n* MODIFY PAGE NUMBER. VALUE GIVEN IS DECREMENTED BY ONE, SINCE IT IS\n* INCREMENTED BEFORE USE.\n         SPACE 1\nTSTPGNO  LH    RWA,OMPAGENO        GET VALUE FROM PARM LIST\n         LTR   RWA,RWA             TEST IF ZERO\n         BZ    TSTPGWID            BR IF ZERO\n         BCTR  RWA,0               DECREMENT BY 1\n         STH   RWA,PAGENO          STORE\n         SPACE 1\n* MODIFY PAGE WIDTH, TESTING FOR MAXIMUM ALLOWED.\n         SPACE 1\nTSTPGWID XR    RWA,RWA\n         IC    RWA,OMPAGWID        GET WIDTH FROM PARM LIST\n         LTR   RWA,RWA             TEST IF ZERO\n         BZ    TSTPGLNG            BRANCH IF SO\n         CLI   OMPAGWID,MAXWIDTH   TEST MAXIMUM SIZE\n         BNH   PGWIDOK\n         LA    R1,3                ERROR, TOO LARGE\n         B     ABEND\nPGWIDOK  STH   RWA,PAGWIDTH\n         SPACE 1\n* MODIFY PAGE LENGTH, TESTING FOR MAXIMUM VALUE.\n         SPACE 1\nTSTPGLNG XR    RWA,RWA\n         IC    RWA,OMPAGLNG        GET FROM PARM LIST\n         LTR   RWA,RWA             TEST IF SUPPLIED\n         BZ    TSTMAXLN            BR IF NOT\n         CLI   OMPAGLNG,MAXLNGTH   TEST FOR LEGAL VALUE\n         BNH   PGLNGOK\n         LA    R1,4                ERROR, ABORT\n         B     ABEND\nPGLNGOK  STH   RWA,PAGELNG         STORE\n         SPACE 1\n* MODIFY PRINT LINE LIMIT COUNTER.\n         SPACE 1\nTSTMAXLN L     RWA,OMMAXLIN        GET FROM PARM LIST\n         LTR   RWA,RWA             TEST IF SUPPLIED\n         BZ    EXIT0               EXIT IF NOT\n         ST    RWA,MAXLINES        STORE\n         B     EXIT0               EXIT TO CALLER\n         DROP  RPARM\n         EJECT\n********************\n* SETHEAD FUNCTION *\n********************\n         SPACE 1\n* THIS CALL PRESENTS A LIST OF LINES WHICH WILL BE USED AS PAGE HEADING\n* AND SUB-HEADING LINES. THE PARAMETER LIST IS A VARIABLE-LENGTH LIST\n* OF PLD ADDRESSES, EXACTLY AS FOR 'PRINT' CALLS. THE FIRST LINE WILL\n* HAVE ADDED TO ITS RIGHT END THE DATE, TIME, AND PAGE NUMBER.\n* HOWEVER, IF ITS LENGTH EXCEEDS 98 BYTES, IT WILL OVERLAY THOSE\n* FIELDS. THE SECOND AND SUBSEQUENT LINES WILL BE PRINTED NORMALLY.\n* NOTE THAT THESE LINES ARE NOT PRINTED WHEN THE PAGE IS EJECTED, BUT\n* WHEN THE LINE WHICH WILL BE FIRST ON THE NEW PAGE IS DELIVERED, THUS\n* ALLOWING THE HEADINGS TO BE ALTERED AFTER DELIVERY OF THE LAST LINE\n* ON THE PRECEDING PAGE. THE ADDRESS OF THE PARAMETER LIST IS SAVED\n* BY THE PRINTING ROUTINE, BUT THE PARAMETER LIST, THE PLD'S TO WHICH\n* IT POINTS, AND THE LINE TEXTS TO WHICH THEY POINT, MUST BE PRESERVED\n* BY THE PROBLEM PROGRAM FOR AS LONG AS THEY ARE IN USE, SINCE THEY\n* ARE REFERRED TO AT THE BEGINNING OF EACH NEW PAGE. EACH CALL TO\n* TO 'SETHEAD' SUPERSEDES THE EFFECT OF THE PREVIOUS CALL. A CALL WITH\n* A PARAMETER LIST ADDRESS OF ZERO INDICATES THAT NO HEADINGS ARE\n* PROVIDED BY THE PROBLEM PROGRAM, AND ONLY THE PAGE NUMBER, DATE, AND\n* TIME WILL BE PRINTED, WITH A STANDARD SPACING OF THREE.\n         SPACE 1\nSHPROC   LTR   RPARM,RPARM         TEST FOR NULL LIST ADDR\n         BNZ   SHOK                BRANCH IF NON-ZERO\n         LA    RPARM,NOHDLIST      ADDRESS OF PLD FOR BLANK LINE\nSHOK     ST    RPARM,HEADLIST      STORE ADDR OF HEADING PARMS\n         B     EXIT0               EXIT\n         EJECT\n******************\n* CLOSE FUNCTION *\n******************\n         SPACE 1\n* THIS CALL CLOSES THE PRINTER DATA SET. IT DOES NOT MOVE THE PAGE\n* OR ALTER ANY SWITCHES OR VARIABLES EXCEPT THE DCB ITSELF.\n* AFTER CLOSING THE DCB, IT RELEASES THE PRINT BUFFERS.\n         SPACE 1\nCLPROC   TM    DCBOFLGS,OPENBIT    IS DCB OPEN NOW?\n         BZ    EXIT0               EXIT IF ALREADY CLOSED\n         MVI   DWORK,X'80'         SET END-OF-LIST BIT\n         CLOSE (PRINTDCB,LEAVE),MF=(E,DWORK)\n         FREEPOOL  PRINTDCB        FREE THE BUFFER CORE\n         B     EXIT0               EXIT TO CALLER\n         EJECT\n************\n* LISTPROC *\n************\n         SPACE 1\n* THIS ROUTINE PROCESSES A LIST OF PLD ADDRESSES, FORMATTING EACH PRINT\n* LINE AND PERFORMING THE NECESSARY PRE- AND POST-SPACING OPERATIONS.\n* IT IS ENTERED WITH 'RPARM' POINTING TO THE LIST OF ADDRESSES AND\n* 'RLPEXIT' CONTAINING THE EXIT ADDRESS. IT MAY DISCOVER THAT ITS\n* SPACING OPERATIONS HAVE BROUGHT THE PAGE TO HEAD OF FORM, REQUIRING\n* THAT THE HEADING AND SUB-HEADING LINES BE PRINTED. WHEN THIS OCCURS,\n* IT BRANCHES TO 'HEADPRNT', WHICH SAVES 'RPARM' AND 'RLPEXIT' AND\n* REENTERS THIS ROUTINE WITH AN ADDRESS LIST FOR THE HEADING LINES.\n* (WHEN THIS SECOND-LEVEL CALL IS MADE, SWITCH 'NOSKPBIT' IS ON,\n* PREVENTING ANY FURTHER PAGE SKIPS AND ELIMINATING THE POSSIBILITY OF\n* YET ANOTHER CALL TO 'HEADPRNT'). AFTER THE HEADINGS ARE PRINTED,\n* THE ORIGINAL VALUES ARE RETURNED TO 'RPARM' AND 'RLPEXIT' AND\n* PROCESSING OF THE LIST OF TEXT LINES PROVIDED BY THE CALLER IS\n* CONTINUED.\n         SPACE 1\n         USING PLDBLOCK,RPLD       TO ADDRESS PLD BLOCKS\nLISTPROC L     RPLD,0(RPARM)       LOAD A PLD BLOCK ADDRESS\n         SPACE 1\n* IF PAGE IS NOW AT HEAD OF FORM, EXECUTE 'HEADPRNT'.\n         SPACE 1\n         LA    RRET,LISTPROC       EXIT FROM HEADPRNT STARTS AGAIN\n         TM    SWITCHES,HOFBIT     SEE IF HEAD-OF-FORM FLAG IS ON\n         BO    HEADPRNT            EXIT IF SO\n         SPACE 1\n* TEST WHETHER WE ARE AT THE FIRST TEXT LINE ON A PAGE, AND, IF SO,\n* WHETHER PRE-SPACING IS ALLOWED IN THAT POSITION. IF NOT, BYPASS\n* PRE-SPACING ALTOGETHER.\n         SPACE 1\n         TM    SWITCHES,TXT1BIT    TEST IF FIRST TEXT LINE\n         BZ    PRSUBTR             BRANCH IF NOT\n         TM    PLDFLAGS,PRHOFBIT   TEST IF ALLOW SKIP AT HOF\n         BZ    POSTSP              SKIP PRESPACING IF NOT\n         SPACE 1\n* DECREMENT THE PAGE BALANCE BY THE AMOUNT TO BE SPACED.\n         SPACE 1\nPRSUBTR  XR    RSPACE,RSPACE\n         IC    RSPACE,PLDSPB       LOAD AMOUNT TO SPACE\n         SR    RBAL,RSPACE         DECREMENT PAGE BALANCE\n         SPACE 1\n* IF SKIPPING IS ALLOWED BY BOTH THE SYSTEM AND THE USER, TEST THE\n* BALANCE AND FORCE A PAGE SKIP IF <= ZERO.\n         SPACE 1\n         TM    SWITCHES,NOSKBIT    TEST IF SYSTEM ALLOWS SKIP\n         BO    PREMOVE             BRANCH IF NOT\n         TM    PLDFLAGS,PRSKPBIT   TEST IF USER ALLOWS SKIP\n         BO    PREMOVE             BRANCH IF NOT\n         LTR   RBAL,RBAL           TEST PAGE BALANCE\n         BP    PREMOVE             BRANCH IF SOME LINES LEFT\n         LA    RSPACE,EJFORCE      FORCE A PAGE SKIP\n         SPACE 1\n* MOVE THE PAGE THE NUMBER OF LINES IN 'RSPACE'.\n         SPACE 1\nPREMOVE  BAS   RWA,MOVE            TO PAPER MOVING SUBROUTINE\n         SPACE 1\n* IF THAT MOVING PUT US AT HEAD-OF-FORM, PRINT THE HEADINGS.\n         SPACE 1\n         LA    RRET,LISTPROC       EXIT FROM HEADPRNT STARTS AGAIN\n         TM    SWITCHES,HOFBIT     TEST HEAD-OF-FORM BIT\n         BO    HEADPRNT            EXIT IF AT HEAD\n         SPACE 1\n* NOW CONSIDER THE SPACING TO BE PERFORMED WHEN THE TEXT OF THE LINE\n* IS PRINTED. BEGIN BY COMPUTING THE NEW PAGE BALANCE.\n         SPACE 1\nPOSTSP   XR    RSPACE,RSPACE\n         IC    RSPACE,PLDSPA       LOAD AMOUNT TO SPACE AFTER PRINT\n         SR    RBAL,RSPACE         COMPUTE NEW PAGE BALANCE\n         SPACE 1\n* IF THE SYSTEM AND USER BOTH ALLOW SKIPPING, TEST THE PAGE BALANCE,\n* AND FORCE A SKIP IF <= ZERO.\n         SPACE 1\n         TM    SWITCHES,NOSKBIT    TEST IF SYSTEM ALLOWS SKIPPING\n         BO    GETPRCC             BRANCH IF NOT\n         TM    PLDFLAGS,SPSKPBIT   TEST IF USER ALLOWS SKIPPING\n         BO    GETPRCC             BRANCH IF NOT\n         LTR   RBAL,RBAL           TEST FOR PAGE END\n         BP    GETPRCC             BRANCH IF SOME LINES LEFT\n         LA    RSPACE,EJFORCE      FORCE PAGE SKIP\n         SPACE 1\n* NOW CONSTRUCT THE PRINT LINE IN AN OUTPUT BUFFER. IN THE INTERESTS\n* OF SAVING BUFFER SPACE, THE CALLER'S TEXT IS SCANNED FROM THE RIGHT\n* TO REDUCE ITS NOMINAL LENGTH BY THE NUMBER OF RIGHT BLANKS. IN THE\n* EXTREME CASE THAT IT IS ENTIRELY BLANK, BYPASS PRINTING ALTOGETHER\n* AND MERELY SPACE. IF THIS IS TO BE THE FIRST HEADING LINE OF THE\n* PAGE ('HD1BIT' SET), SCANNING IS OMITTED, THE RECORD LENGTH IS SET TO\n* THE PAGE WIDTH, AND THE DATE, TIME, AND PAGE NUMBER ARE INSERTED.\n         SPACE 1\nGETPRCC  XR    RWA,RWA\n         IC    RWA,PLDLNGTH        LOAD NOMINAL LENGTH OF TEXT\n         XR    RWB,RWB\n         IC    RWB,PLDOFFST        LOAD LEFT MARGIN OFFSET\n         LA    R0,0(RWA,RWB)       LINE LENGTH = TEXT + OFFSET\n         CH    R0,PAGWIDTH         TEST AGAINST PAGE WIDTH\n         BNH   TSTHD1              BR IF OK\n         LA    R1,5                ERROR, LINE TOO LONG\n         B     ABEND\nTSTHD1   TM    SWITCHES,HD1BIT     TEST IF FIRST HEADING LINE\n         BZ    BLNKSCAN            BR IF NOT\n         LH    RWB,PAGWIDTH        SET RECORD LENGTH AS PAGE WIDTH\n         B     GETBUF              SKIP BLANK SCANNING\n         SPACE 1\n* SET UP A 'BXH' FOR SCAN. R0 IS INCREMENT, R1 IS COMPARAND, RWA\n* VARIABLE.\n         SPACE 1\nBLNKSCAN LH    R0,=H'-1'           INCREMENT IS MINUS 1\n         L     R1,PLDTXTAD-1       LOAD TEXT ADDRESS\n         LA    R1,0(R1)            ZERO HIGH-ORDER BYTE\n         BCTR  R1,0                DECREMENT BY ONE\n         AR    RWA,R1              SET RWA TO RIGHT-MOST TEXT BYTE\n         SPACE 1\n* SCAN THE LINE, SEARCHING FOR FIRST NON-BLANK. RESULT IS NEW TEXT\n* LENGTH IN RWA, WHICH WILL BE ZERO FOR BLANK LINES.\n         SPACE 1\nBLNKLOOP CLI   0(RWA),C' '         TEST FOR NON-BLANK CHAR\n         BNE   BLNKDONE            EXIT WHEN FOUND\n         BXH   RWA,R0,BLNKLOOP\nBLNKDONE SR    RWA,R1              NOW RWA IS NEW TEXT LENGTH\n         BC    13,POSTMOVE         NO PRINTING IF <= 0\n         SPACE 1\n* NOW ADD OFFSET TO LENGTH OF SURVIVING TEXT TO GET ACTUAL LINE LENGTH.\n         SPACE 1\n         AR    RWB,RWA             ADD TEXT LENGTH\n         SPACE 1\n* NOW RWA IS THE LENGTH OF THE CALLER'S TEXT, AND RWB IS THE LENGTH OF\n* THE LINE. THE RECORD LENGTH WILL BE FIVE MORE THAT THE LENGTH OF THE\n* LINE, TO INCLUDE FORMAT 'V'  AND PRINTER CONTROL CHARACTERS. GET\n* A BUFFER OF THE PROPER LENGTH, KEEPING ITS ADDRESS IN R1.\n         SPACE 1\nGETBUF   LA    RWC,5(RWB)          LOAD LENGTH OF RECORD IN RWC\n         STH   RWC,DCBLRECL        PUT LRECL IN DCB FOR PUT CALL\n         PUT   PRINTDCB            GET BUFFER ADDRESS IN R1\n         ST    R1,CCLAST           SAVE LOCATION OF THIS LINE\n         LR    RWD,R1              RWD BECOMES BUFFER BASE REG\n         MVI   3(RWD),C' '         CLEAR BUFFER TO BLANKS\n         EX    RWB,BLNKMOVE\n         SLL   RWC,16              SET UP 4-BYTE 'V' CONTROL FIELD\n         ST    RWC,DWORK           CAN'T ASSUME BUFFER ON ANY\n         MVC   0(4,RWD),DWORK      BOUNDARY\n         SPACE 1\n* IF THIS IS THE FIRST HEADING LINE, INSERT DATE AND TIME, AND EDIT\n* THE PAGE NUMBER.\n         SPACE 1\n         TM    SWITCHES,HD1BIT     TEST IF FIRST LINE\n         BZ    MOVETEXT            BRANCH IF NOT\n         LA    RWC,0(RWB,RWD)      ADDRESS RIGHT END -5\n         SH    RWC,=AL2(HLTXTLNG+10-5)  LOCATE PLACE FOR HEADING INFO\n         MVC   0(HLTXTLNG,RWC),HLTEXT  INSERT DATE & TIME\n         LH    R1,PAGENO           INCREMENT PAGE NUMBER\n         LA    R1,1(R1)\n         STH   R1,PAGENO\n         CVD   R1,DWORK            CONVERT TO DECIMAL\n         MVC   HLTXTLNG(10,RWC),=XL10'40404040402020202120'  EDIT CHARS\n         LA    R1,HLTXTLNG+9(RWC)  IN CASE SIGNIFIGANCE FORCED\n         EDMK  HLTXTLNG+4(6,RWC),DWORK+5  EDIT AND MARK SPOT FOR \"PAGE\"\n         SH    R1,=H'5'\n         MVC   0(4,R1),=C'PAGE'    INSERT WORD \"PAGE\"\n         SPACE 1\n* PUT PRINTER CONTROL CHARACTER AND CALLER'S TEXT INTO THE BUFFER.\n* REGISTER RWA CONTAINS THE LENGTH OF THE TEXT.\n         SPACE 1\nMOVETEXT BAS   RWB,CCGEN           GO GET CONTROL CHAR\n         STC   R0,4(RWD)           INSERT IN BUFFER\n         NI    4(RWD),B'11111101'  CHANGE SPACE IMMEDIATE TO WRITE\n         XR    RWB,RWB\n         IC    RWB,PLDOFFST        LOAD LEFT MARGIN OFFSET\n         LA    RWB,5(RWB,RWD)      ADDRESS FOR FIRST TEXT BYTE\n         BCTR  RWA,0               DECREMENT LENGTH BY 1 FOR MVC\n         L     RWC,PLDTXTAD-1      LOAD ADDRESS OF CALLER'S TEXT\n         EX    RWA,MOVEINST        MOVE TEXT\n         NI    SWITCHES,255-HD1BIT-TXT1BIT  RESET ONE-SHOT BITS\n         SPACE 1\n* DECREMENT PRINT LINE LIMIT COUNTER, ABORTING IF IT GOES NEGATIVE.\n         SPACE 1\n         L     R1,MAXLINES\n         S     R1,=F'1'            BCTR WOULD NOT SET COND CODE\n         ST    R1,MAXLINES\n         BP    POSTMOVE            BRANCH IF POSITIVE\n         LA    R1,6                ABORT, TOO MUCH OUTPUT\n         B     ABEND\n         SPACE 1\n* DO ANY ADDITIONAL SPACING NECESSARY. AMOUNT STILL IN 'RSPACE'.\n         SPACE 1\nPOSTMOVE BAS   RWA,MOVE            CALL PAPER MOVING SUBROUTINE\n         SPACE 1\n* NOW WE ARE FINISHED WITH THAT LINE. IF THE ADDRESS WHICH POINTED TO\n* ITS PLD WAS NEGATIVE, THE LIST IS EXHAUSTED AND THE ROUTINE EXITS.\n* OTHERWISE, INCREMENT THE LIST POINTER BY 4 AND START THE NEXT ONE.\n         SPACE 1\n         LTR   RPLD,RPLD           TEST CURRENT PLD ADDRESS\n         BCR   4,RLPEXIT           EXIT IF NEGATIVE\n         LA    RPARM,4(RPARM)      INCREMENT LIST POINTER\n         B     LISTPROC            TO PROCESS NEXT LINE\n         SPACE 1\n* EXECUTED INSTRUCTIONS :\n         SPACE 1\nBLNKMOVE MVC   4(0,RWD),3(RWD)     SPREAD BLANKS IN OUTPUT BUFFER\nMOVEINST MVC   0(0,RWB),0(RWC)     MOVE CALLER'S TEXT TO OUTPUT BUF\n         SPACE 1\n         DROP  RPLD\n         EJECT\n************\n* HEADPRNT *\n************\n         SPACE 1\n* ENTER THIS ROUTINE WHEN IT IS DISCOVERED THAT WE ARE AT\n* HEAD-OF-FORM AND ARE ABOUT TO PRINT A LINE. SAVE THE REGISTERS\n* DEFINING THE STATE OF 'LISTPROC' AND CALL IT WITH A LIST SPECIFYING\n* THE HEADING AND SUB-HEADING LINES.\n         SPACE 1\nHEADPRNT ST    RRET,HPREXIT        SAVE RETURN ADDRESS\n         STM   RLPEXIT,RPARM,HPRSAVE  STORE LISTPROC REGISTERS\n         SPACE 1\n* RESET HEAD-OF-FORM BIT AND SET NO-SKIP BIT TO SUPPRESS FORM SKIPS\n* AND HEADING LINE BIT TO INCLUDE THE PAGE NUMBER. RESET PAGE BALANCE.\n         SPACE 1\n         NI    SWITCHES,255-HOFBIT  RESET HOF BIT\n         OI    SWITCHES,HD1BIT+NOSKBIT  SET HEADING AND NOSKIP BITS\n         LH    RBAL,PAGELNG        RESET PAGE BALANCE\n         SPACE 1\n* LOAD ADDRESS OF HEADINGS LIST AND CALL LIST PROCESSOR.\n         SPACE 1\n         L     RPARM,HEADLIST      ADDRESS OF HEADINGS LIST\n         BAS   RLPEXIT,LISTPROC    CALL PROCESSING ROUTINE\n         SPACE 1\n* AFTER PRINTING THE HEADINGS, TURN SYSTEM SKIP-SUPPRESSION BIT OFF\n* AND SET 'TXT1BIT' TO INDICATE THAT THERE ARE NO TEXT LINES ON THE\n* PAGE YET. THEN RESTORE THE 'LISTPROC' REGISTERS AND RETURN TO\n* PROCESSING THE CALLER'S LINES.\n         SPACE 1\n         NI    SWITCHES,255-NOSKBIT  RESET NO-SKIP BIT\n         OI    SWITCHES,TXT1BIT    SET FIRST-TEXT-LINE BIT\n         LM    RLPEXIT,RPARM,HPRSAVE  RESTORE LISTPROC REGISTERS\n         L     RRET,HPREXIT        RECOVER EXIT ADDRESS AND\n         BR    RRET                RETURN TO CALLER\n         EJECT\n***********************************\n* MOVE - VERTICAL SPACING ROUTINE *\n***********************************\n         SPACE 1\n* SUBROUTINE TO MOVE THE PAPER BY THE NUMBER OF LINES IN REGISTER\n* 'RSPACE'. RETURN ADDRESS IS IN 'RWA'. IF THE CONTROL CHARACTER FOR\n* THE LAST LINE SPACED 0 LINES, REPLACE IT WITH A NEW ONE BEFORE\n* GENERATING ANY EXTRA LINES.\n         SPACE 1\nMOVE     LTR   RSPACE,RSPACE       TEST NUMBER OF LINES TO BE MOVED\n         BCR   13,RWA              EXIT IF <= ZERO\n         TM    SWITCHES,SP0BIT     DID PREVIOUS LINE SPACE 0?\n         BZ    PREVNOT0            BRANCH IF NOT\n         L     R1,CCLAST           GET ADDRESS OF PREVIOUS LINE\n         BAS   RWB,CCGEN           GENERATE NEW CONTROL CHAR\n         NI    4(R1),X'02'         TEST WRITE/SPACE BIT IN OLD CC\n         STC   R0,4(R1)            STORE NEW CC IN PREVIOUS LINE\n         BNZ   *+8                 BR IF WRITE/SPACE BIT WAS ON\n         NI    4(R1),255-X'02'     TURN WRITE/SPACE BIT OFF\nPREVNOT0 MVC   DCBLRECL(2),MOVELINE  SET LOGICAL RECORD LENGTH IN DCB\n         PUT   PRINTDCB            GET BUFFER ADDRESS IN R1\n         ST    R1,CCLAST           SAVE LOCATION OF THIS LINE\n         MVC   0(6,R1),MOVELINE    INSERT FORMAT 'V' CONTROL RECORD\n         BAS   RWB,CCGEN           GET PRINT CONTROL CHAR IN R0\n         STC   R0,4(R1)            INSERT IN RECORD\n         B     MOVE                LOOP UNTIL 'RSPACE' IS ZERO\n         SPACE 1\nMOVELINE DC    XL6'000600000340'   FORMAT 'V' CONTROL RECORD\n         EJECT\n*****************************************\n* CCGEN - GENERATE PRINTER CONTROL CHAR *\n*****************************************\n         SPACE 1\n* THIS ROUTINE GENERATES A PRINTER CONTROL CHARACTER TO SPACE OR EJECT\n* IMMEDIATELY (WITHOUT PRINTING). ENTER WITH THE TOTAL NUMBER OF\n* LINES TO BE MOVED IN 'RSPACE' AND RETURN ADDRESS IN 'RWB'. EXITS\n* WITH THE CONTROL CHARACTER IN BITS 24-31 OF REGISTER 0 AND THE COUNT\n* IN 'RSPACE' DECREMENTED BY THE AMOUNT WHICH THE CHARACTER WILL SPACE.\n* A SPACE VALUE OF 255 OR GREATER WILL GENERATE AN EJECT CONTROL\n* CHARACTER, SET 'RSPACE' AND 'RBAL' TO ZERO, AND SET THE HEAD-OF-FORM\n* BIT. NOTE : MUST NOT USE R1.\n         SPACE 1\nCCGEN    NI    SWITCHES,255-SP0BIT  RESET 'PREVIOUS SPACED 0' BIT\n         CH    RSPACE,=AL2(EJFORCE)  TEST FOR EJECT REQUEST\n         BL    CCNOEJ              BRANCH IF NOT\n         LA    R0,X'8B'            LOAD 'SKIP TO CHAN 1' CC\n         OI    SWITCHES,HOFBIT     SET HEAD-OF-PAGE BIT\n         XR    RBAL,RBAL           SET PAGE BALANCE TO ZERO\n         XR    RSPACE,RSPACE       SET REMAINING SPACING TO ZERO\n         BR    RWB                 EXIT\nCCNOEJ   LR    R15,RSPACE          LOAD WORK REGISTER\n         CH    RSPACE,=H'3'        TEST IF OVER THREE LINES\n         BNH   CCOK                BR IF <= 3\n         LA    R15,3               SET 3, MAXIMUM FOR 1 OPERATION\nCCOK     SR    RSPACE,R15          DECR RSPACE BY AMOUNT SPACED\n         SLL   R15,3               PUT AMOUNT IN BITS 2-4 OF BYTE\n         LA    R0,X'03'(R15)       ADD COMMAND BITS AND PUT IN R0\n         LTR   R15,R15             TEST FOR ZERO SPACING\n         BCR   7,RWB               EXIT IF NOT ZERO\n         OI    SWITCHES,SP0BIT     SET 'LINE SPACED 0' BIT\n         BR    RWB                 EXIT\n         EJECT\n***********************\n* SYNAD ERROR ROUTINE *\n***********************\n         SPACE 1\n* IF A PERMANENT I/O ERROR OCCURS, TYPE A DIAGNOSTIC MESSAGE AND ABORT.\n         SPACE 1\nSYNAD    SYNADAF ACSMETH=QSAM      GET ERROR MESSAGE FROM O/S\n         LR    RWA,R1              SAVE MESSAGE ADDRESS\n         GETMAIN R,LV=128          GET BUFFER FOR MESSAGE\n         MVC   0(LIOMSG,R1),IOMSG  INSERT MESSAGE BEGINNING\n         MVC   LIOMSG(79,R1),49(RWA)  ADD TEXT FROM O/S\n         LR    RWA,R1              SAVE MESSAGE ADDRESS\n         SYNADRLS                  FREE O/S MESSAGE\n         WTO   MF=(E,(RWA))        TYPE MESSAGE ON CONSOLE\n         LA    R1,7                LOAD ERROR CODE\n         B     ABEND               TO ABORT AND DUMP\n         SPACE 1\nIOMSG    DC    AL2(LIOMSG+78,0)    FORMAT V CONTROL FIELD\n         DC    C'XPRNTSUB I/O ERROR'\nLIOMSG   EQU   *-IOMSG\n         EJECT\n**************************\n* CONSTANTS AND LITERALS *\n**************************\n         SPACE 1\n* DUMMY PARAMETER LIST AND PLD FOR USE WHEN NO HEADING IS PROVIDED.\n         SPACE 1\nNOHDLIST DS    0F\n         DC    XL1'80'             VL LIST BIT\n         DC    AL3(NOHDPLD)        ADDRESS OF PLD BELOW\nNOHDPLD  DS    0F                  ALIGN ON FULL-WORD BOUNDARY\n         DC    BL1'00010000'       OPTION BITS\n         DC    AL3(BLANK1)         PRINT TEXT ADDRESS\n         DC    AL1(1)              PRINT TEXT LENGTH\n         DC    AL1(0)              LEFT MARGIN INDENTATION\n         DC    AL1(0)              SPACING BEFORE PRINTING\n         DC    AL1(3)              SPACING AFTER PRINTING\n         SPACE 1\n* CONSTANTS TO INITIALIZE PARAMETERS AND SWITCHES WHEN 'OPEN' CALL IS\n* RECEIVED. THE ORDER MUST MATCH THE 'PAPARMS' LIST IN THE WORK AREA.\n         SPACE 1\nDEFAULTS DS    0F\n         DC    A(NOHDLIST)         PAGE HEADING PARM LIST ADDRESS\n         DC    F'1000000'          MAXIMUM NUMBER OF OUTPUT LINES\n         DC    H'132'              PAGE WIDTH\n         DC    H'57'               PAGE LENGTH            ***TRW***\n         DC    H'0'                PAGE NUMBER (-1)\n         DC    H'0'                PAGE BALANCE\n         DC    X'00'               SWITCHES\nDEFSIZE  EQU   *-DEFAULTS\n         SPACE 1\n* MISCELLANEOUS CONSTANTS :\n         SPACE 1\nBLANK1   DC    C' '                TEXT OF DUMMY HEADING LINE\n         SPACE 1\n         LTORG\n         EJECT\n*******************\n* WORK AREA DSECT *\n*******************\n         SPACE 1\n* THIS DUMMY SECTION DEFINES THE WORK AREA PROVIDED BY THE PROBLEM\n* PROGRAM FOR EACH DATA SET. ITS ADDRESS IS PASSED IN PARAMETER\n* REGISTER 0 AT EACH CALL.\n         SPACE 1\nWORKAREA DSECT\n         SPACE 1\n* STANDARD 18-WORD SAVE AREA :\n         SPACE 1\nSAVEAREA DS    18F\n         SPACE 1\n* DATA CONTROL BLOCK FOR PRINTER DATA SET :\n         SPACE 1\n         PRINT NOGEN\nPRINTDCB DCB   DDNAME=SYSPRINT,                                        X\n               DSORG=PS,                                               X\n               RECFM=VBM,                                              X\n               LRECL=137,                                              X\n               MACRF=PL,                                               X\n               BFTEK=S,                                                X\n               BUFNO=2,                                                X\n               EROPT=ACC\n         PRINT GEN\n         SPACE 1\nDCBEXLST EQU   PRINTDCB+37         ADDRESS OF EXIT LIST\nDCBOFLGS EQU   PRINTDCB+48         CONTAINS 'OPENED SUCCESSFULLY' BIT\nDCBDDNAM EQU   PRINTDCB+40         DDNAME (WHEN CLOSED)\nDCBSYNAD EQU   PRINTDCB+57         ADDRESS OF SYNCHRONOUS ERROR ROUTINE\nDCBBLKSZ EQU   PRINTDCB+62         BLOCK SIZE\nDCBLRECL EQU   PRINTDCB+82         LOGICAL RECORD LENGTH\n         SPACE 1\n* ADDRESS OF LAST BUFFER OBTAINED BY \"PUT\" MACRO :\n         SPACE 1\nCCLAST   DS    1A\n         SPACE 1\n         DS    1F                  SPARE FULL WORD\n         SPACE 1\n* TEMPORARY WORK CELLS :\n         SPACE 1\nDWORK    DS    1D                  DOUBLE-WORD WORK CELL\nHPREXIT  DS    1F                  HEADPRNT EXIT SAVE\nHPRSAVE  DS    2F                  HEADPRNT REGISTER STORAGE\n         SPACE 1\n* PARAMETERS AND SWITCHES WHICH DEFINE THE PAGE SIZE AND STATUS.\n* SEQUENCE MUST MATCH THAT IN 'DEFAULTS', WHICH INITIALIZES THEM.\n         SPACE 1\nPAPARMS  DS    0F\nHEADLIST DS    1A                  PAGE HEADING PARM LIST ADDRESS\nMAXLINES DS    1F                  MAXIMUM NUMBER OF OUTPUT LINES\nPAGWIDTH DS    1H                  PAGE WIDTH\nPAGELNG  DS    1H                  PAGE LENGTH\nPAGENO   DS    1H                  PAGE NUMBER OF CURRENT PAGE\nPAGEBAL  DS    1H                  PAGE BALANCE\nSWITCHES DS    1X                  SWITCHES\n         SPACE 1\n* STORAGE FOR DATE AND TIME PORTION OF PAGE HEADING :\n         SPACE 1\nHLTXTLNG EQU   24\nHLTEXT   DS    CL(HLTXTLNG)\nHLDAY    EQU   HLTEXT\nHLTIME   EQU   HLTEXT+7\nHLDATE   EQU   HLTEXT+16\n         EJECT\n*************************\n* PARAMETER LIST DSECTS *\n*************************\n         SPACE 1\n* PARAMETER LIST FOR 'EJECT' CALL :\n         SPACE 1\nEJPARM   DSECT\n         SPACE 1\nEJCOND   DS    1X                  CONDITIONAL MASK AND SWITCHES\nEJQUAN   DS    1X                  CONDITIONAL TEST QUANTITY\n         SPACE 1\nEJATHOF  EQU   X'01'               MASK FOR 'EJCOND'\n         SPACE 1\n* PARAMETER LIST FOR 'SPACE' CALL :\n         SPACE 1\nSPPARM   DSECT\n         SPACE 1\nSPCOND   DS    1X                  CONDITIONAL BITS\nSPQUAN   DS    1X                  NUMBER OF LINES TO SPACE\n         SPACE 1\nSPATHOF  EQU   X'01'               MASK FOR 'SPCOND'\nSPNOEJ   EQU   X'02'               MASK FOR 'SPCOND'\n         SPACE 1\n* PARAMETER LIST FOR 'OPEN' AND 'MODIFY' CALLS :\n         SPACE 1\nOMPARM   DSECT\n         SPACE 1\nOMMAXLIN DS    1F                  MAXIMUM NUMBER OF OUTPUT LINES\nOMPAGENO DS    1H                  INITIAL PAGE NUMBER\nOMPAGWID DS    1X                  PAGE WIDTH\nOMPAGLNG DS    1X                  PAGE LENGTH\nOMTIMEAD DS    1A                  ADDRESS OF TIME\nOMDATEAD DS    1A                  ADDRESS OF DATE\nOMDDNAME DS    CL8                 DDNAME (OPEN CALL ONLY)\n         EJECT\n*************\n* PLD DSECT *\n*************\n         SPACE 1\n* PRINT LINE DESCRIPTOR DUMMY SECTION :\n         SPACE 1\n*        ******************************************************\n*        *            *                                       *\n*        *   OPTION   *                                       *\n*        *    BITS    *             TEXT ADDRESS              *\n*        *            *                                       *\n*        ******************************************************\n*        *            *            *            *             *\n*        *    TEXT    *    TEXT    *   SPACE    *    SPACE    *\n*        *   LENGTH   *   OFFSET   *   BEFORE   *    AFTER    *\n*        *            *            *            *             *\n*        ******************************************************\n         SPACE 1\nPLDBLOCK DSECT\n         SPACE 1\nPLDFLAGS DS    1X                  OPTION BITS\nPLDTXTAD DS    AL3                 TEXT ADDRESS\nPLDLNGTH DS    1X                  TEXT LENGTH\nPLDOFFST DS    1X                  TEXT OFFSET, OR LEFT MARGIN\nPLDSPB   DS    1X                  AMOUNT TO SPACE BEFORE PRINTING\nPLDSPA   DS    1X                  AMOUNT TO SPACE AFTER PRINTING\n         SPACE 1\nPRHOFBIT EQU   B'00000010'         MASK FOR 'PLDFLAGS'\nPRSKPBIT EQU   B'00000001'         MASK FOR 'PLDFLAGS'\nSPSKPBIT EQU   B'00010000'         MASK FOR 'PLDFLAGS'\n         TITLE 'DATE EDITING ROUTINE \"XDATEDIT\"'\n* STATUS : VERSION 0, MOD 2, 5 OCTOBER 1967.\n         SPACE 1\n* FUNCTION/OPERATION : EDITS A PACKED DECIMAL DATE IN YEAR-DAY FORM TO\n*        EBCDIC MONTH-DAY-YEAR FORM. CORRECTS FOR LEAP YEARS AND\n*        FOR THE TURN OF A CENTURY.\n         SPACE 1\n* ENTRY POINTS : ENTER AT \"XDATEDIT\" VIA BASR 14,15 WITH REG 13 SET\n*        TO A STANDARD 18-WORD SAVE AREA. REGISTER 1 POINTS TO A\n*        PARAMETER LIST CONTAINING ONE ADDRESS.\n         SPACE 1\n* INPUT : THE ADDRESS IN THE PARAMETER LIST IS THAT OF AN ALIGNED\n*        DOUBLE WORD CONTAINING THE ARGUMENT IN PACKED DECIMAL AS :\n*        X'0000000000YYDDD+'.\n         SPACE 1\n* OUTPUT : THE RESULT IS RETURNED IN THE SAME DOUBLE WORD IN EBCDIC AS\n*        C'MM/DD/YY'.\n         SPACE 1\n* DATA SETS : NONE.\n         SPACE 1\n* EXTERNAL ROUTINES : NONE.\n         SPACE 1\n* EXITS-NORMAL : RETURN VIA REG 14 WITH RETURN CODE 0 IN REG 15.\n         SPACE 1\n* EXITS-ERROR : IF THE DAY NUMBER IS ZERO OR EXCEEDS THE MAXIMUM VALUE\n*        APPROPRIATE TO THE YEAR, RETURN VIA REG 14 WITH RETURN CODE 4\n*        IN REG 15 AND THE RESULT FIELD SET TO C' YY.DDD '.\n         SPACE 1\n* TABLES/WORK AREAS : NONE.\n         SPACE 1\n* ATTRIBUTES : REENTRANT, READ ONLY.\n         SPACE 1\n* NOTES : NONE.\n         EJECT\n* DUMMY SECTION TO DEFINE THE ARGUMENT AND RETURN FIELD.\n         SPACE 1\nDUMMY    DSECT\nDWORD    DS    1D\n         SPACE 2\n* BEGIN CONTROL SECTION HERE. DEFINE REGISTER TAGS.\n         SPACE 1\nXDATEDIT CSECT\n         SPACE 1\nRDSECT   EQU   11                  BASE REG FOR ARGUMENT/RESULT\nRPARMD   EQU   1                   PARAMETER LIST POINTER\nRARGSAVE EQU   2                   TO SAVE ORIGINAL PACKED ARGUMENT\nRMONTH   EQU   3\nRDAY     EQU   4                   RDAY AND RYEAR ARE AN EVEN/ODD\nRYEAR    EQU   5                   PAIR FOR DIVISION\nRWORK    EQU   6\nRLIST    EQU   7\n         SPACE 2\n* ENTER HERE. SAVE GENERAL REGISTERS AND SET UP BASE REGISTERS.\n         SPACE 1\n         SAVE  (14,12),,*\n         BASR  RBASE,0\n         USING *,RBASE\n         L     RDSECT,0(RPARMD)    LOAD ARGUMENT ADDRESS\n         USING DWORD,RDSECT\n         EJECT\n* CONVERT YEAR AND DAY TO BINARY, AND SEPARATE BY DIVISION.\n         SPACE 1\n         MVI   DWORD,X'00'         CLEAR HIGH DECIMAL DIGITS\n         MVC   DWORD+1(4),DWORD    IN ARG TO ZEROS\n         OI    DWORD+7,X'0F'       FORCE PLUS SIGN\n         L     RARGSAVE,DWORD+4    SAVE ARGUMENT FOR 'BADDATE'\n         CVB   RYEAR,DWORD         CONVERT YYDDD TO BINARY\n         XR    RDAY,RDAY           CLEAR HIGH-ORDER DIVIDEND\n         D     RDAY,F1000          QUOTIENT=YEAR; REMAINDER=DAY\n         SPACE 1\n* CHECK FOR LEAP YEAR, AND LOAD RLIST WITH BASE ADDRESS OF APPROPRIATE\n* LIST OF MONTH SIZES.\n         SPACE 1\nDAYOK    LA    RLIST,STDLIST       POINT RLIST TO STANDARD MONTHS\n         LTR   RWORK,RYEAR         LOAD BINARY YEAR NUMBER\n         BZ    NOTLEAP             BR IF TURN OF CENTURY\n         N     RWORK,=F'3'         TEST LOW TWO BITS\n         BC    4,NOTLEAP           BR IF NON-ZERO\n         LA    RLIST,LPYLIST       POINT RLIST TO LEAP-YEAR MONTHS\n         SPACE 1\n* TEST DAY NUMBER AGAINST ZERO AND THE UPPER LIMIT DETERMINED BY\n* THE YEAR NUMBER.\n         SPACE 1\nNOTLEAP  LTR   RDAY,RDAY           TEST FOR ZERO\n         BZ    BADDATE             BR IF SO\n         CH    RDAY,0(0,RLIST)     TEST FOR UPPER LIMIT\n         BH    BADDATE             BR IF TOO LARGE\n         SPACE 1\n* REDUCE JULIAN DAY TO DAY-OF-MONTH, ACCUMULATING MONTH NUMBER.\n         SPACE 1\n         LA    RMONTH,1            INITIAL MONTH NUMBER\n         XR    RWORK,RWORK\nDAYLOOP  IC    RWORK,1(RMONTH,RLIST)  LENGTH OF MONTH INTO RWORK\n         CR    RDAY,RWORK          TEST IF DAY IN THIS MONTH\n         BNH   DAYDONE             BR IF DAY LESS THAN MONTH SIZE\n         SR    RDAY,RWORK          REDUCE DAY BY LENGTH OF MONTH\n         LA    RMONTH,1(RMONTH)    INCREMENT MONTH\n         B     DAYLOOP\n         SPACE 1\n* COMBINE MONTH, DAY, AND YEAR IN BINARY IN ONE REGISTER, MULTIPLYING\n* EACH BY A FACTOR TO PLACE IT PROPERLY IN THE DECIMAL RESULT.\n* THE TRICK IS THAT 1000(1000(MONTH)+DAY)+YEAR GIVES MM0DD0YY WHEN\n* CONVERTED TO DECIMAL. AFTER UNPACKING, THE ZEROS ARE REPLACED BY\n* SLASHES.\n         SPACE 1\nDAYDONE  MH    RMONTH,H1000\n         AR    RMONTH,RDAY\n         MH    RMONTH,H1000\n         AR    RMONTH,RYEAR\n         CVD   RMONTH,DWORD\n         MVC   DWORD(5),DWORD+3    MOVE OVER FOR UNPACKING\n         UNPK  DWORD(8),DWORD(5)   CONVERT TO ALPHA\n         OI    DWORD+7,X'F0'       COVER UP SIGN\n         MVI   DWORD+2,C'/'        INSERT SLASHES\n         MVI   DWORD+5,C'/'\n         XR    R15,R15             SET NORMAL RETURN CODE OF 0\nEXITD    RETURN  (14,12),T,RC=(15)  RETURN TO CALLER\n         SPACE 1\n* FOR ARGUMENTS WHOSE DAY NUMBER IS ZERO OR TOO LARGE, RETURN IN\n* 'DWORD' THE EDITED VALUE  C' YY.DDD ' AND SET A RETURN CODE OF 4.\n         SPACE 1\nBADDATE  ST    RARGSAVE,DWORD      RESTORE ORIGINAL PACKED ARGUMENT\n         UNPK  DWORD+2(5),DWORD+1(3)  UNPACK INTO ALPHA\n         MVC   DWORD+1(2),DWORD+2  SHIFT YEAR 1 LEFT\n         MVI   DWORD,C' '          APPLY COSMETICS\n         MVI   DWORD+3,C'.'\n         MVI   DWORD+7,C' '\n         LA    R15,4               SET RETURN CODE\n         B     EXITD\n         EJECT\n* LISTS OF MONTH SIZES FOR STANDARD AND LEAP YEARS :\n         SPACE 1\nSTDLIST  DC    H'365'              DAY LIMIT FOR STANDARD YEARS\n         DC    AL1(31)\n         DC    AL1(28)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         SPACE 1\nLPYLIST  DC    H'366'              DAY LIMIT FOR LEAP YEARS\n         DC    AL1(31)\n         DC    AL1(29)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         SPACE 1\nF1000    DC    F'1000'\nH1000    EQU   F1000+2\n         SPACE 1\n         LTORG\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MEMSTAT": {"ttr": 24842, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x94\\x13\\x0f\\x00\\x94\\x13\\x0f\\x17'\\x01H\\x01H\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-10T00:00:00", "modifydate": "1994-05-10T17:27:00", "lines": 328, "newlines": 328, "modlines": 0, "user": "SYSPAJA"}, "text": "MMST     TITLE 'M E M S T A T - MEMBER STATUS TSO COMMAND.'\nMEMSTAT  START 0\n         SPACE 1\n*        DATA SET 761KKMSTAT AT LEVEL 001 AS OF 10/13/80\n*        DATA SET SW2MEMSTAT AT LEVEL 001 AS OF 07/01/74\n         SPACE 1\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* PURPOSE :    THE 'MEMSTAT' COMMAND WELL GO OUT TO A LIBRARY AND     *\n* ---------    LOOK FOR A PARTICULAR MEMBER.                          *\n* SYNTAX :     MEMSTAT LIBRARY(MEMBER) LIST                           *\n* --------                             NOLIST                         *\n* ORIGIN :     EXTRACTED FROM CBT TAPE 89 FEB, FILE 270.              *\n* --------     COMMAND NAME : MEMSTAT (06/25/82)                      *\n*              SOURCE : KERMIT KISER                                  *\n*              AGENCY : WDPSC                                         *\n*              UPDATED BY MOINIL P.A.                                 *\n*                         COMPUTING CENTRE (TP 361)                   *\n*                         J.R.C. - ISPRA ESTABLISHMENT                *\n*                         21020 ISPRA (VA), ITALY                     *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\nMEMSTAT AMODE  24\nMEMSTAT RMODE  24\n         SPACE 1\n        $DEFREG\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* REGISTERS USE :                                                     *\n* ---------------                                                     *\n*        R0  = WORK                                                   *\n*        R1  = PARM. / WORK                                           *\n*        R2  = WORK                                                   *\n*        R3  = WORK                                                   *\n*        R4  = DA08 / DA18 POINTER                                    *\n*        R5  = PDE'S POINTER                                          *\n*        R6  = DCB POINTER                                            *\n*        R7  = DAPL POINTER                                           *\n*        R8  = PPL POINTER                                            *\n*        R9  = RETURN CODE                                            *\n*        R10 = CPPL POINTER                                           *\n*        R11 = WORK-AREAS POINTER                                     *\n*        R12 = BASE REGISTER                                          *\n*        R13 = SAVE AREA POINTER                                      *\n*        R14 = LINK / WORK                                            *\n*        R15 = CALL / WORK                                            *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\n        $XENT  BASE=R12,LV=WORKLEN,TYPE=RENT\n         LR    R11,R13             SET WORK-AREA REGISTER\n         LA    R2,18*4(R11)\n         L     R3,=A(WORKLEN-(18*4))\n         LR    R4,R2\n         XR    R5,R5\n         MVCL  R2,R4\n         USING WORKAREA,R11\n        $TEW$EC MSG=PUTMSG,ERR=SETERR,PUT=PUTLNE\n         LR    R10,R2\n         USING CPPL,R10\n         L     R1,CPPLUPT\n         USING UPT,R1\n         MVC   USID(L'UPTPREFX+L'UPTPREFL),UPTPREFX\n         DROP  R1\n        $TEW$PP PARM=PARMLST,REG=5\n         MVC   HOLDDSN,=CL44' '\n         L     R14,DSNPTR\n         LH    R1,DSNLEN\n         BCTR  R1,0\n         LA    R15,HOLDDSN\n         EX    R1,MOVIT\n         TM    DSNFLG,X'40'\n         BZ    APPENDID\n         TM    MEMFLG,X'80'\n         BO    ALLOCIT\n         B     NOMEM\nMOVIT    MVC   0(*-*,R15),0(R14)   <<EXECUTED>>\nAPPENDID MVC   HOLDDSN(L'USID),USID\n         XR    R1,R1\n         IC    R1,USIDL\n         LA    R0,C'.'\n         STC   R0,HOLDDSN(R1)\n         LH    R15,DSNLEN\n         LA    R15,1(R15,R1)\n         STH   R15,DSNLEN\n         LA    R15,HOLDDSN+1(R1)\n         L     R14,DSNPTR\n         LH    R1,DSNLEN\n         BCTR  R1,0\n         EX    R1,MOVIT\nALLOCIT STAX   DEFER=YES           DEFER ALL ATTENTIONS\n         LH    R1,DSNLEN\n         STH   R1,HOLDDSNL\n         LA    R4,DA08LIST\n         USING DAPB08,R4\n         MVC   DA08CD,=XL2'0008'\n         MVI   DA08DSP1,DA08SHR\n         MVI   DA08DPS2,DA08KEEP\n         MVI   DA08DPS3,DA08KEP\n         MVI   DA08DSO,DCBDSGPO\n         MVC   DA08DDN(L'DA08DDN),=CL44' '\n         MVC   DA08UNIT(L'DA08UNIT),=CL44' '\n         MVC   DA08SER(L'DA08SER),=CL44' '\n         MVC   DA08MNM(L'DA08MNM),=CL44' '\n         MVC   DA08PSWD(L'DA08PSWD),=CL44' '\n         LA    R1,HOLDDSNL\n         ST    R1,DA08PDSN\n         LA    R7,DAPLIST\n         USING DAPL,R7\n         LA    R1,DAPLECBS\n         ST    R1,DAPLECB\n         MVC   DAPLUPT,CPPLUPT\n         MVC   DAPLECT,CPPLECT\n         MVC   DAPLPSCB,CPPLPSCB\n         ST    R4,DAPLDAPB\n         BAS   R14,XDAIR\n         B     DAIRERR             RETURN +0\n         MVC   OPNLIST(DIRLGTH),DIROPN    +4\n         LA    R6,LIBDIR\n         USING IHADCB,R6\n         MVC   DCBDDNAM,DA08DDN\n         DROP  R4\n         MVC   HOLDMEM(L'HOLDMEM),=CL44' '\n         L     R14,MEMPTR\n         LH    R1,MEMLEN\n         BCTR  R1,0\n         LA    R15,HOLDMEM\n         EX    R1,MOVIT\n        OPEN   ((R6)),MF=(E,OPNLIST)\n         TM    DCBOFLGS,DCBOFOPN\n         BZ    OPNERR\n        FIND   (R6),HOLDMEM,D\n         LTR   R15,R15\n         BNZ   NOTFOUND\n         TM    KEYNUM,X'01'\n         BZ    SETRC\n         MVC   DIAG(21),=CL21'MEMBER          FOUND'\n         MVC   DIAG+7(L'HOLDMEM),HOLDMEM\n         LA    R1,DIAG\n         LA    R0,21\n         BAS   R14,PUTLNE\nSETRC    XR    R9,R9               MEMBER FOUND --------------------- 0\n         B     ENDIT\nNOTFOUND LA    R9,4                MEMBER NOT FOUND ----------------- 4\n         TM    KEYNUM,X'01'\n         BZ    ENDIT\n         MVC   DIAG(31),=CL31'MEMBER          NOT IN DATA-SET'\n         MVC   DIAG+7(L'HOLDMEM),HOLDMEM\n         LA    R1,DIAG\n         LA    R0,31\n         BAS   R14,PUTLNE\nENDIT   CLOSE  ((R6)),MF=(E,CLSLIST)\nLEAVE    MVC   DAPLUPT,CPPLUPT\n         MVC   DAPLECT,CPPLECT\n         MVC   DAPLPSCB,CPPLPSCB\n         LA    R4,DA18LIST\n         USING DAPB18,R4\n         MVC   DA18CD,=XL2'0018'\n         MVI   DA18DPS2,DA18KEEP\n         MVC   DA18DDN(L'DA18DDN),=CL44' '\n         MVC   DA18MNM(L'DA18MNM),=CL44' '\n         MVC   DA18SCLS(L'DA18SCLS),=CL44' '\n         MVC   DA18JBNM(L'DA18JBNM),=CL44' '\n         LA    R1,HOLDDSNL\n         ST    R1,DA18PDSN\n         DROP  R4\n         ST    R4,DAPLDAPB\n         BAS   R14,XDAIR\n         NOP   0                   RETURN +0\n        STAX   DEFER=NO                   +4 RESTORE ALL ATTENTIONS\nQUIT    IKJRLSA #TSANSW\n        $XRET  CC=(R9),LV=WORKLEN,TYPE=RENT\nNOMEM    LA    R1,MNME\n         LA    R0,L'MNME\nMSGERR   BAS   R14,PUTLNE\n         B     SETERR\nDAIRERR  LA    R1,MLNF\n         LA    R0,L'MLNF\n         BAS   R14,PUTLNE\n        STAX   DEFER=NO            RESTORE ALL ATTENTIONS\n         B     SETERR\nOPNERR   LA    R1,MLOE\n         LA    R0,L'MLOE\n         BAS   R14,PUTLNE\n         EX    0,SETERR\n         B     LEAVE\nSETERR   LA    R9,8                ERROR ---------------------------- 8\n         B     QUIT\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*        XDAIR - IKJDAIR ROUTINE                                      *\n*              R14 : LINK REGISTER                                    *\n*                    RETURN = +0 - IKJDAIR ERROR                      *\n*                             +4 - IKJDAIR OK                         *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\nXDAIR    STM   R0,R15,SAVEREGX     SAVE CALLER'S REGS\n         XC    DAPLECBS,DAPLECBS\n        CALLTSSR EP=IKJDAIR,MF=(E,(R7))\n         LTR   R15,R15             TEST RETURN CODE\n         BNZ   *+L'*+8             BRANCH IF ERROR\n         LM    R0,R15,SAVEREGX     OK, RESTORE CALLER'S REGS\n         B     4(R14)              NORMAL RETURN IS +4\n         ST    R15,RETC            STORE RETURN CODE\n         LA    R2,DFPLIST\n         USING DFDSECTD,R2\n         ST    R7,DFDAPLP\n         LA    R1,RETC\n         ST    R1,DFRCP\n         LA    R1,ZERO\n         ST    R1,DFJEFF02\n         LA    R1,DASW\n         ST    R1,DFIDP\n         DROP  R2\n         LR    R1,R2               PARM. ADDRESS\n        LINK   EP=IKJEFF18         ERROR MESSAGE ROUTINE\n         LTR   R15,R15             TEST RETURN CODE\n         BZ    XDAIRX              OK, GO BACK\n         MVC   DIAG(29),=CL29'DAIRFAIL ERROR. RETURN CODE :'\n         CVD   R15,WORKD\n         MVC   DIAG+29(6),=XL6'402020202120'\n         ED    DIAG+29(6),WORKD+5\n         LA    R1,DIAG\n         LA    R0,35\n         BAS   R14,PUTLNE\nXDAIRX   LM    R0,R15,SAVEREGX     RESTORE CALLER'S REGS\n         BR    R14                 ERROR RETURN IS +0\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*        CONTROL BLOCKS INITIALIZATION DATA                           *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\n        PRINT  NOGEN\nDIROPN  OPEN   (*-*),MF=L\nDIRCLS  CLOSE  (*-*),MF=L\nDIRDCB  DCB    DSORG=PO,DDNAME=XXXXXXXX,MACRF=R,EODAD=SETRC,           X\n               RECFM=F,BLKSIZE=256,KEYLEN=0\nDIRLGTH  EQU   *-DIROPN\n        PRINT  GEN\n         SPACE 1\nZERO     DC    F'0'\nDASW     DC    AL1(0,DFDAIR)\nMNME     DC    C'NO MEMBER ENTERED'\nMLNF     DC    C'LIBRARY NOT FOUND'\nMLOE     DC    C'LIBRARY OPEN ERROR'\n         SPACE 1\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*        LITERAL POOL                                                 *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\n        LTORG\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*        OPERANDS PARM. LIST                                          *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\n        PRINT  NOGEN\nPARMLST IKJPARM\nDSNME   IKJPOSIT DSNAME,LIST,PROMPT='ENTER LIBRARY(MEMBER) TO CHECK',  X\n               HELP='LIBRARY(MEMBER)'\nLOPTN   IKJKEYWD DEFAULT='LIST'\n        IKJNAME 'LIST'\n        IKJNAME 'NOLIST'\n        PRINT  GEN\nDSNPTR   EQU   DSNME,4             PDE'S ENTRIES DEFINITIONS\nDSNLEN   EQU   DSNME+4,2\nDSNFLG   EQU   DSNME+6,1\nMEMPTR   EQU   DSNME+8,4\nMEMLEN   EQU   DSNME+12,2\nMEMFLG   EQU   DSNME+14,1\nKEYNUM   EQU   LOPTN+1,1\n        PRINT  NOGEN\n        IKJENDP\n        PRINT  GEN\n         SPACE 1\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*        WORK-AREA                                                    *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\nWORKAREA DSECT\n         DS    18F                 SAVE AREA\nWORKD    DS    D\nSAVEREGX DS    16F            XDAIR - SAVE REGISTERS 0-15\n        $TEW$WA\n         SPACE 1\nDAPLIST  DS    0F                  DAIR PARM. LIST\n         DS    (DAPLLGTH)X'0'\nDAPLECBS DS    F\n         SPACE 1\nDA08LIST DS    0F                  DAIR ALLOC. PARM. LISTS\n         DS    (DA08LGTH)X'0'\nDA18LIST DS    0F\n         DS    (DA18LGTH)X'0'\n         SPACE 1\nDFPLIST  DS    0F                  DAIR FAILURE PARAMETER LIST\n         DS    (DFLEN)X'0'\nRETC     DS    F\n         SPACE 1\nOPNLIST OPEN   (*-*),MF=L\nCLSLIST CLOSE  (*-*),MF=L\nLIBDIR  DCB    DSORG=PO,DDNAME=XXXXXXXX,MACRF=R,EODAD=SETRC,           X\n               RECFM=F,BLKSIZE=256,KEYLEN=0\n         SPACE 1\nHOLDDSNL DS    H\nHOLDDSN  DS    CL44\nHOLDMEM  DS    CL8\nUSID     DS    CL7,XL1\nUSIDL    EQU   USID+L'USID,1\nDIAG     DS    CL60\n         SPACE 1\nWORKLEN  EQU   (((*-WORKAREA)+7)/8)*8\n         SPACE 1\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*        DSECTS CONTROL BLOCKS                                        *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\n        PRINT  NOGEN\n        $TEW$DS\n        IKJUPT\n        IKJDAPL\nDAPLLGTH EQU   *-DAPL\n        IKJDAP08\nDA08LGTH EQU   *-DAPB08\n        IKJDAP18\nDA18LGTH EQU   *-DAPB18\n        IKJEFFDF DFDSECT=YES\n        DCBD   DEVD=DA,DSORG=PO\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MEMSTAT$": {"ttr": 25094, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15G\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:47:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//MEMSTAT  JOB (........),'INSTALL  - MEMSTAT-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJ4AS3,OPT=',RENT',MBR=MEMSTAT\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT'\n//SYSIN     DD *\n  ENTRY   MEMSTAT\n  NAME    MEMSTAT(R)\n/*\n//HLP     EXEC PAJHELP,MBR=MEMSTATH,DSS='->.SOURCE.FILE4'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MEMSTAT@": {"ttr": 25096, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x13\\x1f\\x00\\x94\\x13\\x1f\\tI\\x00\"\\x00\"\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-11T00:00:00", "modifydate": "1994-05-11T09:49:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SYSPAJA"}, "text": "1   16/05/90\n                                                      MEMSTAT   1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      MEMBER STATUS TSO COMMAND      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  CBT origin : Extracted from CBT tape 89 FEB, file 270.\n  ------------\n\n  Purpose :   The MEMSTAT command is intended for use in CLISTs.\n  ---------   It allows conditional execution based on whether a\n              member exists in a given partitioned data-set (library).\n       Note - MEMSTAT returns a condition code of 0 if the member\n              exists in the library and, if not, a code of 4 is\n              returned. Other condition codes are :\n                8 = a severe error occurred (message is given).\n              The CLIST variable &LASTCC will contain the return code.\n\n  Syntax :    MEMSTAT  dsname(memname)  LIST\n  --------                              NOLIST\n              Example :  MEMSTAT  LIB.DATA(MEMBER)\n\n  OPERANDS :  Required - dsname(memname)\n  ----------  Default  - None\n  DSNAME :    The name of the library you wish to check.\n  MEMNAME :   The name of the member you wish to check for in the\n              library.\n  LIST :      A message will be given with the member's status.\n              This is the default if neither LIST nor NOLIST is\n              entered.\n  NOLIST :    No message will be given.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MEMSTATH": {"ttr": 25098, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x13\\x1f\\x00\\x94\\x13\\x1f\\tI\\x00\\x17\\x00\\x17\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-11T00:00:00", "modifydate": "1994-05-11T09:49:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=MEMSTAT\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  The MEMSTAT command is intended for use in CLISTs.\n               It allows conditional execution based on whether a\n               member exists in a given partitioned data-set (library).\n        Note - MEMSTAT returns a condition code of 0 if the member\n               exists in the library and, if not, a code of 4 is\n               returned. Other condition codes are :\n                 8 = a severe error occurred (message is given).\n               The CLIST variable &LASTCC will contain the return code.\n)X SYNTAX :    MEMSTAT  dsname(memname)  LIST\n                                         NOLIST\n               Example :  MEMSTAT  LIB.DATA(MEMBER)\n)O OPERANDS :  Required - dsname(memname)\n               Default  - None\n))DSNAME :     The name of the library you wish to check.\n))MEMNAME :    The name of the member you wish to check for in the\n               library.\n))LIST :       A message will be given with the member's status.\n               This is the default if neither LIST nor NOLIST is\n               entered.\n))NOLIST :     No message will be given.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MODLOOK": {"ttr": 25100, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00_\\x00\\x95\\x00_\\x12\\x10\\x057\\x057\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-05T00:00:00", "modifydate": "1995-01-05T12:10:00", "lines": 1335, "newlines": 1335, "modlines": 0, "user": "SYSPAJA"}, "text": "MDLK     TITLE '---   M O D L O O K   ---'\nMODLOOK  START 0\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*                            M O D L O O K                            *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*        THIS PROGRAM IS DESIGNED TO RUN AS A TSO COMMAND,            *\n*        STARTED TASK OR A BATCH JOB TO LOOK UP THE SELECTED          *\n*        MODULE(S) IN THE SYSTEM LINK LIST OR LINK PACK AREA.         *\n*        IF THE MODULE IS IN THE LINK LIST, THE LINK LIST             *\n*        LIBRARY NAME WILL BE DISPLAYED. IF THE MODULE IS             *\n*        IN THE LINK PACK AREA, ITS ADDRESS WILL BE DISPLAYED         *\n*        ALONG WITH NAME OF THE RESIDENT AREA IN WHICH IT IS          *\n*        LOCATED SUCH AS PLPA, FLPA, ECSA, ETC... THE FIRST           *\n*        PART OF EACH MODULE IS DISPLAYED ALSO SINCE IT MAY           *\n*        CONTAIN DATE, TIME, OR COPYRIGHT INFORMATION WHICH           *\n*        MAY BE OF INTEREST. IT IS OFTEN HARD TO DETERMINE            *\n*        WHICH LINK LIST LIBRARY CONTAINS A SPECIFIC MODULE.          *\n*                                                                     *\n*        WHEN THE PROGRAM IS RUN FROM TSO, THE USER WILL BE           *\n*        PROMPTED FOR A MODULE NAME AND THE RESPONSE WILL BE          *\n*        DISPLAYED ON THE TSO USER TERMINAL. WHEN IT IS RUN AS        *\n*        A STARTED TASK, A WTOR REQUEST WILL BE MADE FOR THE          *\n*        MODULE NAME AND THE RESPONSE WILL BE SENT TO THE             *\n*        CONSOLE. IF IT IS RUN AS A BATCH JOB, THE MODULE NAME        *\n*        WILL BE ENTERED AS THE FIRST 8 CHARACTERS OF A RECORD        *\n*        READ FROM THE SYSIN FILE AND THE RESPONSE WILL BE            *\n*        WRITTEN TO THE SYSPRINT FILE.                                *\n*                                                                     *\n*        THE PROGRAM WILL CONTINUE TO ASK FOR OTHER MODULE            *\n*        NAMES UNTIL END-OF-FILE IS REACHED ON THE SYSIN FILE         *\n*        FOR A BATCH JOB OR A 'STOP', 'END', OR '/ *' IS              *\n*        RECEIVED FROM A TSO USER OR THE OPERATOR CONSOLE.            *\n*                                                                     *\n*        THIS UTILITY PROGRAM WAS ORIGINALLY WRITTEN BY ANOTHER       *\n*        PERSON IN ANOTHER INSTALLATION SO I CANNOT TAKE CREDIT       *\n*        FOR IT. I HAVE CLEANED IT UP A LOT AND PROVIDED              *\n*        COMMENTS, BUT BECAUSE OF LACK OF PERMISSION, I CANNOT        *\n*        GIVE THE NAME OF THE ORIGINAL AUTHOR.                        *\n*                                                                     *\n*        WRITTEN BY : JOHN V. HOOPER                                  *\n*                     FOOD LION, INC.                                 *\n*                     2110 EXECUTIVE DRIVE                            *\n*                     SALISBURY, N.C.  28145-1330                     *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*                           DISCLAIMER                                *\n*                                                                     *\n*        THE AUTHORS INCLUDING FOOD LION, ITS OFFICERS,               *\n*        DIRECTORS, AND EMPLOYEES MAKE NO REPRESENTATION OR           *\n*        WARRANTY OF ANY KIND WHATSOEVER, INCLUDING, BUT NOT          *\n*        LIMITED TO, REPRESENTATIONS OR WARRANTIES, EXPRESS OR        *\n*        IMPLIED, OR MERCHANTABILITY, FITNESS FOR USE OR PURPOSE,     *\n*        ACCURACY OR COMPLETENESS OF PROCESSES, PROCEDURES,           *\n*        DESIGNS, DEFINITIONS, INSTRUCTIONS, INFORMATION, OR          *\n*        FUNCTIONING OF ANY PROGRAMS, DOCUMENTS, OR RELATED           *\n*        MATERIALS. THE AUTHORS FURTHER EXPRESSLY DISCLAIM ANY        *\n*        KNOWLEDGE OF PURPOSE FOR WHICH THESE PROGRAMS,               *\n*        DOCUMENTS, OR RELATED MATERIAL MAY BE UTILIZED OR THEIR      *\n*        APPLICABILITY FOR SUCH USE, NOR SHALL THE FACT OF MAKING     *\n*        THEM AVAILABLE CONSTITUTE ANY SUCH REPRESENTATION,           *\n*        WARRANTY, OR KNOWLEDGE, NOR DO THE AUTHORS ASSUME ANY        *\n*        LIABILITY, RESPONSIBILITY, OR OBLIGATION ARISING FROM        *\n*        THE USE OR MALFUNCTIONING OF OF THESE COMPUTER PROGRAMS,     *\n*        DOCUMENTATION, OR RELATED MATERIALS.                         *\n*                                                                     *\n*        USE : 1. BATCH JOB : //JOBNAME  JOB ...                      *\n*                             //MODLOOK  EXEC PGM=MODLOOK             *\n*                             //SYSPRINT  DD SYSOUT=*                 *\n*                             //SYSIN     DD *                        *\n*                             IDCAMS                                  *\n*                             IEFW21SD                                *\n*                             /*                                      *\n*              2. STARTED TASK : //MODLOOK PROC                       *\n*                                //MODLOOK EXEC PGM=MODLOOK           *\n*                 THE OPERATOR WILL BE PROMPTED FOR MODULE NAME AND   *\n*                 THE RESULTS WILL BE WRITTEN TO THE CONSOLE.         *\n*              3. TSO : JUST ENTER 'MODLOOK' AT THE READY PROMPT OR   *\n*                       UNDER OPTION 6 OF ISPF.                       *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*        ORIGIN : EXTRACTED FROM CBT 94 APR TAPE, FILE 019.           *\n*        ADAPTED BY : MOINIL P.A.                                     *\n*                     COMPUTING CENTRE (TP 361)                       *\n*                     J.R.C. - ISPRA ESTABLISHMENT                    *\n*                     21020 ISPRA (VA), ITALY                         *\n*        CHANGED : 1. MODULES NAMES LIST AS INPUT.                    *\n*                  2. FIRST INPUT NAMES LIST MAY BE SUPPLIED AS       *\n*                     COMMAND OPERANDS (TSO) OR EXEC PARAMETERS       *\n*                     FIELD (STARTED TASK OR BATCH).                  *\n*                  3. TPUT/TGET REPLACED BY PUTLINE/GETLINE (THIS     *\n*                     ALLOWS THE BATCH-TSO RUN AND THE SYSOUTTRAP).   *\n*                  4. DISPLAY JOB/STEP AND ISPF (WHEN AVAILABLE)      *\n*                     LIBRARY NAME.                                   *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\nMODLOOK  AMODE 24\nMODLOOK  RMODE 24\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT BASE=(R12,R11,R10)\n         LR    R2,R1               RETAIN R1 ENTRY ADDRESS\n        EXTRACT ANSWER,'S',FIELDS=(FRS,TIOT,COMM,TSO,PSB)\n         SPACE 1\n*------- SET REGISTER 7 TO POINT TO THE \"TCB\". IF THE LOAD IS\n*        SUCCESSFUL, \"TCBLLS\" SHOULD POINT TO THE \"LLE\" FOR THE\n*        MODULE. \"LLECDPT\" POINTS TO THE \"CDE\" FOR THE MODULE.\n*        THE \"CDE\" FIELDS ARE THEN FORMATED AND PRINTED.\n         SPACE 1\n         L     R7,ANSWER           -> TCBFRS (PREFIX)\n         LA    R7,L'TCBFRS(R7)     BEGINNING OF TCB\n         USING TCB,R7              SET ADDRESSABILITY TO TCB\n         SPACE 1\n*------- DETERMINE IF WE ARE RUNNING AS A BATCH JOB,\n*        A STARTED TASK, OR A TSO USER.\n         SPACE 1\n         ICM   R1,B'1111',ANSWER+16 CHECK PSCB ADDRESS\n         BZ    INTLZ1              ZERO, NOT TSO\n         USING CPPL,R2             VERIFY HOW INVOKED IN TSO\n         BAS   R14,VERHI           CHECK TSO COMMAND\n         LR    R3,R2\n         USING IKJEBECA,R3\n         L     R2,CAPTTMP\n         DROP  R3\n         BAS   R14,VERHI           CHECK TSO SUB-COMMAND\n        WTO    MF=(E,WTOM)         WRITE MESSAGE\n         B     LEAVE\n         USING PSCB,R1\nVERHI    CLC   PSCBUPT,CPPLUPT\n         BNER  R14\n         CL    R1,CPPLPSCB\n         BNER  R14\n         DROP  R1,R2\n         ST    R2,CPPLADDR\n         OI    SWPRCS,USTSO        TURN ON TSO INDICATOR\n         L     R1,ANSWER+12        ADDRESS OF TSO-FLAG\n         TM    0(R1),X'80'         HOW RUNNING?\n         BZ    *+L'*+4             BACKGROUND\n         OI    SWPRCS,TSOFU        SET FOREGROUND\n         SPACE 1\n*------- DETERMINE IF ISPF IS ACTIVE TO EXECUTE MODULES BLDL AND LOAD.\n*        SEE ALSO IF WE ARE A DIRECT SUBTASK OF ISPF (\"ISPTASK\"  OR\n*        \"ISRPTC\") OR TSO (\"IKJEFT..\"), OR OF ANY OTHER ONE BEFORE,\n*        AS I.E. \"DOCP\".\n         SPACE 1\n         LR    R5,R7               SAVE MY TCB\nSCTCB1   ICM   R7,B'1111',TCBOTC   MY ORIGINATING TASKS TCB'S\n         BZ    SCTCB3              END OF CHAIN (NEVER OCCURS IN TSO)\n         L     R2,TCBRBP           GET THE RB POINTER\n         USING RBSECT,R2\n         CLI   RBSTAB1,RBFTPRB     IS THIS A PRB?\n         BNE   SCTCB1              NO\n         XR    R3,R3               YES\n         ICM   R3,B'0111',RBCDE1   GET THE CDE POINTER\n         DROP  R2\n         USING CDENTRY,R3\n         CLC   CDNAME(6),=CL6'IKJEFT' TSO TASK?\n         BE    SCTCB3              YES\n         CLC   CDNAME(8),=CL8'ISPTASK' NO, ISPF TASK?\n         BE    SCTCB2              YES\n         CLC   CDNAME(8),=CL8'ISRPTC' NO, ISPF OPTION 6?\n         BE    SCTCB2              YES\n         OI    SWPRCS,SUBTSK       NO, SAY NOT DIRECT SUBTASK\n         B     SCTCB1\n         DROP  R3\nSCTCB2   OI    SWMISC,ISPFACT      YES, SET ISPF ACTIVE\n         LR    R7,R5               RESTORE MY TCB\n         MVC   ISPFDD,DCBISPF+(DCBDDNAM-IHADCB)\n         B     ASKDSN\nSCTCB3   LR    R7,R5               RESTORE MY TCB\n         SPACE 1\n*------- ISPF IS NOT ACTIVE, BUT IF THE ISPF LINK DD IS ALLOCATED,\n*        IT CAN BE OPENED AND USED.\n         SPACE 1\n         XR    R1,R1\n         L     R15,ANSWER+4\n         USING TIODSECT,R15\nSCISPF   CLC   TIOELNGH(4),=F'0'\n         BE    INTLZ3              NOT FOUND\n         CLC   TIOEDDNM(L'TIOEDDNM),DCBISPF+(DCBDDNAM-IHADCB)\n         BE    *+L'*+10            FOUND\n         IC    R1,TIOELNGH\n         ALR   R15,R1\n         B     SCISPF\n         DROP  R15\n         MVC   ISPFDD,DCBISPF+(DCBDDNAM-IHADCB)\n        OPEN   (DCBISPF,)\n         TM    DCBISPF+(DCBOFLGS-IHADCB),DCBOFOPN\n         BZ    INTLZ3              OPEN FAILED\n         OI    SWMISC,DDISPFO      SET FOUND AND OPENED\nASKDSN   LA    R1,PLISPF           NO, ASK ISPF LINK DSNAME(S)\n         L     R15,=V(DSNTAB)\n         BASR  R14,R15\n         LTR   R15,R15\n         BZ    INTLZ3              OK, OBTAINED\n         MVC   PUTAREA+17(3),=CL3'---'\n         MVC   PUTAREA+21(4),=CL4'ISPF'\n         MVC   PUTAREA+26(23),=CL23'DSNAME''S TABLE OVERFLOW'\n         BAS   R14,OUTLINE         WRITE MESSAGE\n         B     INTLZ3              GET OUT\n         SPACE 1\n*------- CHECK IF WE ARE A STARTED TASK.\n         SPACE 1\nINTLZ1   ST    R2,PADDR            SAVE R1 ENTRY ADDRESS\n         ICM   R15,B'1111',ANSWER+8 CHECK CSCB ADDRESS\n         BZ    INTLZ2              ZERO, NOT STC\n         ICM   R15,B'1111',4(R15)  LOAD CIB ADDRESS\n         BZ    INTLZ2              ZERO, NOT STC\n         OI    SWPRCS,STASK        TURN ON STC INDICATOR\n         B     INTLZ3              GET OUT\n         SPACE 1\n*------- WE ARE A BATCH JOB, SO OPEN THE SYSIN AND SYSPRINT DATA-SETS.\n         SPACE 1\nINTLZ2   OI    SWPRCS,JBATCH       TURN ON BATCH INDICATOR\n         XR    R1,R1\n         L     R2,ANSWER+4         SEARCH SYSIN-SYSPRINT DD'S\n         USING TIODSECT,R2\nSCLOOP   CLC   TIOELNGH(4),=F'0'\n         BE    CHKDDS\n         CLC   TIOEDDNM(L'TIOEDDNM),DCBIN+(DCBDDNAM-IHADCB)\n         BNE   *+L'*+4\n         OI    SWMISC,DDIN         SET SYSIN INPUT\n         CLC   TIOEDDNM(L'TIOEDDNM),DCBOUT+(DCBDDNAM-IHADCB)\n         BNE   *+L'*+4\n         OI    SWMISC,DDOUT        SET SYSPRINT OUTPUT\n         IC    R1,TIOELNGH\n         ALR   R2,R1\n         B     SCLOOP\n         DROP  R2\nCHKDDS   TM    SWMISC,DDIN         SYSIN INPUT?\n         BO    OKIN\n         MVC   WTOXDD(L'DCBDDNAM),DCBIN+(DCBDDNAM-IHADCB)\n        WTO    MF=(E,WTOX)         WRITE MESSAGE\n         B     LEAVE\nOKIN     TM    SWMISC,DDOUT        SYSPRINT OUTPUT?\n         BO    OKOUT\n         MVC   WTOXDD(L'DCBDDNAM),DCBOUT+(DCBDDNAM-IHADCB)\n        WTO    MF=(E,WTOX)         WRITE MESSAGE\n         B     LEAVE\nOKOUT    MVC   WTOZDD(L'DCBDDNAM),DCBIN+(DCBDDNAM-IHADCB)\n        OPEN   (DCBIN,)\n         TM    DCBIN+(DCBOFLGS-IHADCB),DCBOFOPN\n         BO    OPNIN\n        WTO    MF=(E,WTOZ)         WRITE MESSAGE\n         B     LEAVE\nOPNIN    OI    SWMISC,DDINO\n         MVC   WTOZDD(L'DCBDDNAM),DCBOUT+(DCBDDNAM-IHADCB)\n        OPEN   (DCBOUT,(OUTPUT))\n         TM    DCBOUT+(DCBOFLGS-IHADCB),DCBOFOPN\n         BO    OPNOUT\n        WTO    MF=(E,WTOZ)         WRITE MESSAGE\n         B     LEAVE\nOPNOUT   OI    SWMISC,DDOUTO\n         SPACE 1\n*------- LOOK FOR A STEPLIB OR JOBLIB DD.\n         SPACE 1\nINTLZ3   MVC   JSDDN,=CL8'STEPLIB' TRY TO GET STEPLIB DSNAME'S\n         LA    R1,PLDSN\n         L     R15,=V(DSNTAB)\n         BASR  R14,R15\n         LTR   R15,R15\n         BZ    GETNAME             OK, OBTAINED\n         CH    R15,=H'4'\n         BNE   INTLZ3A             TABLE OVERFLOW\n         MVC   JSDDN,=CL8'JOBLIB'  NOT FOUND, TRY WITH JOBLIB\n         LA    R1,PLDSN\n         L     R15,=V(DSNTAB)\n         BASR  R14,R15\n         LTR   R15,R15\n         BZ    GETNAME             OK, OBTAINED\n         CH    R15,=H'4'\n         BNE   INTLZ3A             TABLE OVERFLOW\n         MVI   JSDDN,C'?'          NOT FOUND, SET UNKNOWN\n         B     GETNAME\nINTLZ3A  MVC   PUTAREA+17(3),=CL3'---'\n         MVC   PUTAREA+21(8),=CL8'INTERNAL'\n         MVC   PUTAREA+30(23),=CL23'DSNAME''S TABLE OVERFLOW'\n         BAS   R14,OUTLINE         WRITE MESSAGE\n         SPACE 1\n*------- GET THE MODULE NAME FROM EITHER :\n*              THE SYSIN FILE FOR A BATCH JOB,\n*              A WTOR REQUEST FOR A STARTED TASK, OR\n*              A PUTLINE AND GETLINE REQUEST FOR A TSO USER.\n         SPACE 1\nGETNAME  MVI   GETAREA,C' '        BLANK THE INPUT BUFFER\n         MVC   GETAREA+1(L'GETAREA-1),GETAREA\n         MVC   SCANPTR(3*4),=A(GETAREA,1,GETAREA+L'GETAREA-1)\n         TM    SWPRCS,FLG1ST       1ST TIME HERE?\n         BO    SKINIT              NO, BRANCH\n         SPACE 1\n*------- INITIALIZE THE \"LSTWHERE\" INDICATORS.\n         SPACE 1\n         OI    SWPRCS,FLG1ST       SET 1ST TIME DONE\n         XR    R2,R2\n         TM    SWPRCS,SUBTSK       ARE WE DIRECT SUBTASK IF ISPF?\n         BO    SETWW1              YES\n         MVI   WTASK,0             NO, WE ARE NOT DIRECT\n         IC    R2,WJS\n         BCTR  R2,0\n         STC   R2,WJS\n         IC    R2,WISPF\n         BCTR  R2,0\n         STC   R2,WISPF\nSETWW1   TM    SWMISC,ISPFACT      IS ISPF ACTIVE?\n         BO    SETWW2              YES\n         MVI   WISPF,0             NO\n         IC    R2,WJS\n         BCTR  R2,0\n         BCTR  R2,0\n         STC   R2,WJS\nSETWW2   CLI   JSDDN,C'?'          ANY STEPLIB/JOBLIB?\n         BNE   *+L'*+4             YES\n         MVI   WJS,0               NO\n         SPACE 1\n*------- AT THE BEGINNING, THE EXEC PARM.FIELD OR TSO COMMAND\n*        OPERANDS MAY BE USED.\n         SPACE 1\n         TM    SWPRCS,USTSO        SEE IF TSO USER\n         BZ    DOINIT              NO, BRANCH\n         L     R2,CPPLADDR\n         USING CPPL,R2\n         L     R3,CPPLCBUF         COMMAND BUFFER ADDRESS\n         DROP  R2\n         LH    R2,0(R3)            BUFFER LENGTH\n         SH    R2,=H'4'            PREFIX LENGTH\n         LH    R1,2(R3)            OFFSET TO OPERAND(S)\n         SR    R2,R1               OPERAND(S) LENGTH\n         BNP   SKINIT              NONE, JUMP\n         LA    R1,4(R1,R3)         START OF OPERAND(S)\n         ST    R1,SCANPTR\n         BCTR  R2,0\n         LA    R1,0(R1,R2)         END OF OPERAND(S)\n         ST    R1,SCANPTR+8\n         B     GETNME3\nDOINIT   L     R2,PADDR\n         L     R3,0(R2)\n         LH    R1,0(R3)            PARM FIELD LENGTH\n         LTR   R1,R1\n         BNP   SKINIT              NONE, JUMP\n         LA    R2,2(R3)            START OF PARM FIELD TEXT\n         ST    R2,SCANPTR\n         BCTR  R1,0\n         LA    R1,0(R1,R2)         END OF PARM FIELD TEXT\n         ST    R1,SCANPTR+8\n         B     GETNME3\nSKINIT   TM    SWPRCS,JBATCH       SEE IF BATCH JOB\n         BZ    GETNME1             NO, BRANCH\n        GET    DCBIN,GETAREA       READ AN INPUT CARD\n         MVC   GETAREA+L'GETAREA-8(8),=CL8' ' RESET SEQ. NUM. COLUMNS\n         B     GETNME3             BRANCH\nGETEODAD MVC   GETAREA(8),=CL8'END' SET FOR END\n         B     GETNME3             BRANCH\nGETNME1  TM    SWPRCS,USTSO        SEE IF TSO USER\n         BZ    GETNME2             NO, BRANCH\n         TM    SWPRCS,FREEIB       INPUT BUFFER CONTINUATION?\n         BZ    GETNME1A            NO, BRANCH\n         NI    SWPRCS,255-FREEIB\n         L     R1,RESTCNT\n         L     R15,RESTPTR\n         LR    R14,R15\n         AR    R14,R1\n         B     GETCONT\nGETNME1A TM    SWPRCS,TSOFU        HOW RUNNING?\n         BZ    GETNME1B            BACKGROUND\n         SPACE 1\n*------- IN TSO FOREGROUND, IF TRAP ACTIVE INHIBIT NEXT INPUT.\n         SPACE 1\n         L     R1,CVTPTR           CVT\n         USING CVTMAP,R1\n         L     R14,CVTTVT          TSVT\n         DROP  R1\n         LA    R1,CT441PRM         PARM.LIST\n         USING TSVT,R14\n         L     R15,TSVTVACC        VARIABLE ACCESS ROUTINE\n         DROP  R14\n         BASR  R14,R15             GO TO IT\n         LTR   R15,R15             ANY ERROR?\n         BNZ   GETNME1B            YES, GO PROMPT\n         ICM   R15,B'1111',DATAADDR NO, CHECK VALUE RESPONSE\n         BZ    GETNME1B            NULL, GO PROMPT\n         ICM   R14,B'1111',DATALENG\n         BNP   GETNME1B            NULL, GO PROMPT\n         BCT   R14,*+L'*+6\n         PACK  DOUBLE,0(*-*,R15)   <<EXECUTED>>\n         EX    R14,*-6\n         CVB   R1,DOUBLE\n         LTR   R1,R1\n         BNP   GETNME1B            CAN GO PROMPT\n         MVC   PUTAREA+1(3),=CL3'---'\n         MVC   PUTAREA+5(30),=CL30'END FORCED (SYSOUTTRAP ACTIVE)'\n         BAS   R14,OUTLINE         GO WRITE THE MESSAGE\n         B     LEAVE\nGETNME1B XR    R1,R1               GET LENGTH OF MESSAGE\n         IC    R1,WTOQ+9\n         SH    R1,=H'4'\n         BCT   R1,*+L'*+6\n         MVC   PUTAREA+1(*-*),WTOQ+12 <<EXECUTED>>\n         EX    R1,*-6              MOVE THE MESSAGE TEXT\n         BAS   R14,OUTLINE         GO WRITE THE MESSAGE\n         L     R1,CPPLADDR         ADDRESS OF CPPL\n         USING CPPL,R1\n         L     R14,CPPLUPT         UPT ADDRESS\n         L     R15,CPPLECT         ECT ADDRESS\n         DROP  R1\n         XC    MYECB,MYECB         CLEAR ECB TO ZEROS\n         XC    GTPBZ(GTPBLEN),GTPBZ CLEAR GET PARMLIST TO ZEROS\n         XC    IOPLZ(IOPLLEN),IOPLZ CLEAR PARM LIST TO ZEROS\n         LA    R1,IOPLZ            ADDRESS OF LIST\n        GETLINE PARM=GTPBZ,UPT=(R14),ECT=(R15),ECB=MYECB,              X\n               TERMGET=(EDIT,WAIT),                                    X\n               INPUT=(TERM,LOGICAL),                                   X\n               MF=(E,(1))          GET MODULE(S) NAME(S) FROM USER\n         CH    R15,=H'4'           HOW COMPLETE?\n         BNH   *+L'*+10            SUCCESSFULLY ...\n         MVC   GETAREA(8),=CL8'END' FORCE END (ERROR)\n         B     SKALL\n         LA    R1,GTPBZ            ADDRESSABILITY FOR THE GTPB\n         USING GTPB,R1\n         L     R14,GTPBIBUF        GET ADDRESS OF INPUT BUFFER\n         DROP  R1\n         LH    R1,0(R14)           BUFFER LENGTH\n         SH    R1,=H'4'            PREFIX LENGTH\n         LH    R0,2(R14)           OFFSET TO START OF TEXT\n         SR    R1,R0               TEXT LENGTH\n         BNP   SKALL               NONE, FORCE REQUEST AGAIN\n         LA    R15,4(R14)          START ADDRESS OF BUFFER TEXT\n         AR    R15,R0              START ADDRESS OF TEXT\n         LR    R14,R15\n         AR    R14,R1              END+1 ADDRESS OF TEXT\nGETCONT  BCTR  R14,0\n         CLI   0(R14),C' '\n         BNE   *+L'*+8\n         BCT   R1,GETCONT\n         B     SKALL               BLANK LINE, FORCE REQUEST AGAIN\n         CL    R1,=A(L'GETAREA)\n         BNH   MVALL\n         LR    R0,R1\nCHKSH    BCT   R1,*+L'*+8\n         L     R1,=A(L'GETAREA)    WHAT'S THAT?\n         B     MVALL               A SYNTAX ERROR\n         BCTR  R14,0\n         CLI   0(R14),C' '\n         BNE   CHKSH\n         CL    R1,=A(L'GETAREA)\n         BH    CHKSH\n         SR    R0,R1\n         ST    R0,RESTCNT\n         ST    R14,RESTPTR\n         OI    SWPRCS,FREEIB\n         BCT   R1,*+L'*+6\n         MVC   GETAREA(*-*),0(R15) <<EXECUTED>>\n         EX    R1,*-6              MOVE PART OF TEXT\n         B     GETNME3             GET OUT\nMVALL    BCT   R1,*+L'*+6\n         MVC   GETAREA(*-*),0(R15) <<EXECUTED>>\n         EX    R1,*-6              MOVE TEXT\nSKALL    LA    R15,GTPBZ           ADDRESSABILITY FOR THE GTPB\n         USING GTPB,R15\n         L     R1,GTPBIBUF         GET ADDRESS OF INPUT BUFFER\n         DROP  R15\n         LH    R0,0(R1)            INPUT BUFFER LENGTH\n         AH    R0,=H'7'            ROUND UP TO 8\n         SRL   R0,3\n         SLL   R0,3\n        FREEMAIN RC,LV=(0),A=(1),SP=1\n         B     GETNME3             GET OUT\nGETNME2  XC    MYECB,MYECB         CLEAR MY ECB\n        WTOR   MF=(E,WTOQ)         WRITE ENTER MESSAGE\n        WAIT   ECB=MYECB           WAIT FOR OPERATOR REPLY\n         SPACE 1\n*------- CHECK THE RESPONSE FOR A TERMINATION REQUEST.\n         SPACE 1\nGETNME3  MVC   MODULNAM,=CL8' '    RESET\n         MVI   PUTAREA,C'0'        SET FOR DOUBLE SPACE\n         LM    R1,R3,SCANPTR\n         CLR   R1,R3\n         BH    GETNAME             NO MORE ENTERED\n         CLI   0(R1),C' '          SCAN FOR A MODULE NAME\n         BNE   *+L'*+8\n         BXLE  R1,R2,*-8\n         B     GETNAME             NONE OR NO MORE ENTERED\n         LR    R14,R1\n         BXLE  R1,R2,*+L'*+4\n         B     *+L'*+8\n         CLI   0(R1),C' '\n         BNE   *-12\n         STM   R1,R3,SCANPTR\n         SR    R1,R14\n         CH    R1,=H'8'\n         BNH   OKNAM\n         MVC   PUTAREA+1(3),=CL3'---'\n         MVC   PUTAREA+5(8),0(R14) SET MODULE NAME... IN MESSAGE\n         MVC   PUTAREA+13(26),=CL26'... - MODULE NAME TOO LONG'\n         BAS   R14,OUTLINE         GO WRITE THE MESSAGE\n         B     GETNME3             GO TRY NEXT MODULE NAME\nOKNAM    BCT   R1,*+L'*+6\n         OC    MODULNAM(*-*),0(R14) <<EXECUTED>>\n         EX    R1,*-6              MOVE AND MAKE UPPER CASE\n         CLC   MODULNAM,=CL8'END'  SEE IF END REQUESTED\n         BE    LEAVE               YES, BRANCH\n         CLC   MODULNAM,=CL8'STOP' SEE IF END REQUESTED\n         BE    LEAVE               YES, BRANCH\n         CLC   MODULNAM,=CL8'/*'   SEE IF END REQUESTED\n         BE    LEAVE               YES, BRANCH\n         CLC   MODULNAM,=CL8'T=ON' SEE IF T=ON REQUESTED\n         BNE   *+L'*+8             NO, BRANCH\n         OI    SWPRCS,STATUS       YES, SET STATUS ON\n         B     GETNME3             GO TRY NEXT MODULE NAME\n         CLC   MODULNAM,=CL8'T=OFF' SEE IF T=OFF REQUESTED\n         BNE   *+L'*+8             NO, BRANCH\n         NI    SWPRCS,255-STATUS   YES, SET STATUS OFF\n         B     GETNME3             GO TRY NEXT MODULE NAME\n         CLI   MODULNAM,C'$'\n         BE    OKVLD\n         CLI   MODULNAM,C'#'\n         BE    OKVLD\n         CLI   MODULNAM,C'@'\n         BE    OKVLD\n         CLI   MODULNAM,C'A'\n         BL    INVLD\n         CLI   MODULNAM,C'I'\n         BNH   OKVLD\n         CLI   MODULNAM,C'J'\n         BL    INVLD\n         CLI   MODULNAM,C'R'\n         BNH   OKVLD\n         CLI   MODULNAM,C'S'\n         BL    INVLD\n         CLI   MODULNAM,C'Z'\n         BNH   OKVLD\nINVLD    MVC   PUTAREA+1(3),=CL3'---'\n         MVC   PUTAREA+5(8),MODULNAM SET MODULE NAME IN MESSAGE\n         MVC   PUTAREA+14(34),=CL34' - INVALID MODULE NAME (1ST CHAR.)'\n         BAS   R14,OUTLINE         GO WRITE THE MESSAGE\n         B     GETNME3             GO TRY NEXT MODULE NAME\n         SPACE 1\n*------- SEE IF THE MODULE IS IN THE LINK LIST.\n         SPACE 1\nOKVLD    MVC   LSTNM,MODULNAM      SET UP FOR BLDL\n         XC    LSTTTR(LSTZ),LSTTTR\n        BLDL   0,LSTADDR           SEARCH LINK LIST FOR MODULE NAME\n         LTR   R15,R15             TEST BLDL RETURN CODE\n         BZ    PRTHD1              ZERO, BRANCH FOUND\n         STM   R15,R0,BLDLRC\n         CLC   BLDLRC,=F'4'\n         BNE   NOTTFU\n         TM    SWMISC,ISPFACT      IS ISPF ACTIVE?\n         BO    NOTTFU              YES\n         TM    SWMISC,DDISPFO      NO, ISPF LINK DD?\n         BZ    NOTTFU              NOT FOUND OR OPEN FAILED\n         SPACE 1\n*------- SEE IF THE MODULE IS IN THE ISPF LINK.\n         SPACE 1\n         XC    LSTTTR(LSTZ),LSTTTR\n        BLDL   DCBISPF,LSTADDR     SEARCH ISPF LINK FOR MODULE NAME\n         LTR   R15,R15             TEST BLDL RETURN CODE\n         BZ    OKISPF              ZERO, FOUND\n         XC    LSTTTR(LSTZ),LSTTTR\n         CL    R15,=F'4'\n         BE    NOTTFU              NOT FOUND\n        CLOSE  (DCBISPF)           ERROR, CLOSE ISPF LINK\n         NI    SWMISC,255-DDISPFO  AND CLOSE THIS WAY FOR EVER\n         B     NOTTFU\nOKISPF   MVC   HD2MNAM,MODULNAM    SET MODULE NAME\n         XR    R15,R15             CLEAR REGISTER FOR IC\n         IC    R15,LSTCONCT        LOAD CONCATENATION NUMBER\n         CVD   R15,DOUBLE          CONVERT TO PACKED\n         OI    DOUBLE+7,X'0F'      MAKE PRINTABLE\n         UNPK  HD2CONCT,DOUBLE+6(2) UNPACK TO MESSAGE\n         MVI   HD2WHERE,C' '\n         MVC   HD2WHERE+1(L'HD2WHERE-1),HD2WHERE\n         MVC   HD2WHERE(13),=CL13'THE ISPF LINK'\n         MVC   PUTAREA+1(L'HD2MSG),HD2MSG MOVE HEADING TO IOAREA\n         BAS   R14,OUTLINE         WRITE MESSAGE\n         LA    R4,ISPFTB+2         POINT TO FIRST DSN IN TABLE\n         XR    R2,R2               CLEAR REGISTER\n         XR    R3,R3               CLEAR REGISTER\n         OC    ISPFNR,ISPFNR       DSNAME(S) KNOWN?\n         BZ    LOADI               SKIP IF NOT\n         ICM   R3,B'0001',LSTCONCT LOAD CONCATENATION NUMBER\n         BZ    *+L'*+12\n         CLM   R3,B'0011',ISPFNR   CHECK IN CASE OF TABLE OVERFLOW\n         BNL   LOADI               SKIP IF YES\n         M     R2,=A(L'ISPFTB)     MULTIPLY TO DISPLACE FOR DSNAME\n         AR    R4,R3               DISPLACE INTO THE TABLE\n         MVC   HD2DSNAM(L'HD2DSNAM),0(R4) MOVE DSNAME TO MESSAGE\n         MVC   PUTAREA+10(L'HD2DSN),HD2DSN MOVE HEADING TO IOAREA\n         BAS   R14,OUTLINE         WRITE MESSAGE\n         B     LOADI               GO TRY TO LOAD THE MODULE\nNOTTFU   MVC   PUTAREA+1(L'MODULNAM),MODULNAM SET MODULE NAME\n         MVC   PUTAREA+10(3),=CL3'---'\n         MVC   PUTAREA+14(17),=CL17'BLDL FAILED - RC=' SET MSG TEXT\n         UNPK  WORK9,BLDLRC(L'BLDLRC+1) UNPACK HEX FIELD + 1\n         TR    WORK9(L'WORK9-1),TRTBL1 TRANSLATE TO PRINTABLE\n         MVC   PUTAREA+31(4),WORK9+4 SET RC IN MESSAGE\n         MVC   PUTAREA+36(9),=CL9'/ REASON=' SET MSG TEXT\n         UNPK  WORK9,BLDLRS(L'BLDLRS+1) UNPACK HEX FIELD + 1\n         TR    WORK9(L'WORK9-1),TRTBL1 TRANSLATE TO PRINTABLE\n         MVC   PUTAREA+45(4),WORK9+4 SET REASON IN MESSAGE\n         BAS   R14,OUTLINE         GO WRITE THE MESSAGE\n         CLC   BLDLRC,=F'4'\n         BNE   GETNAME\n         CLI   LSTWHERE,1\n         BH    GETNAME\n         B     LOADM               GO TRY TO LOAD THE MODULE\nPRTHD1   MVC   HD2MNAM,MODULNAM    SET MODULE NAME\n         XR    R15,R15             CLEAR REGISTER FOR IC\n         IC    R15,LSTCONCT        LOAD CONCATENATION NUMBER\n         CVD   R15,DOUBLE          CONVERT TO PACKED\n         OI    DOUBLE+7,X'0F'      MAKE PRINTABLE\n         UNPK  HD2CONCT,DOUBLE+6(2) UNPACK TO MESSAGE\n         MVI   HD2WHERE,C' '\n         MVC   HD2WHERE+1(L'HD2WHERE-1),HD2WHERE\n         CLI   LSTWHERE,0          IN PRIVATE AREA?\n         BE    PRTHD2              YES, GET OUT\n         CLI   LSTWHERE,1          IN LINK LIST?\n         BE    PRTHD3              YES, GO GET DSNAME\n         CLC   LSTWHERE,WTASK      NO, IN TASKLIB?\n         BE    PRTHD4              YES, GO GET DSNAME\n         CLC   LSTWHERE,WJS        NO, IN JOB/STEPLIB?\n         BE    PRTHD5              YES, GO GET DSNAME\n         CLC   LSTWHERE,WISPF      IN ISPF LIB?\n         BE    PRTHD6              YES, GO GET DSNAME\n         MVC   HD2WHERE(21),=CL21'A PARENT TASK LIBRARY'\n         B     PRTHD2+L'PRTHD2\nPRTHD2   MVC   HD2WHERE(17),=CL17'A PRIVATE LIBRARY'\n         MVC   PUTAREA+1(L'HD2MSG),HD2MSG MOVE HEADING TO IOAREA\n         BAS   R14,OUTLINE         WRITE MESSAGE\n         B     LOADM               GO TRY TO LOAD THE MODULE\nPRTHD3   MVC   HD2WHERE(13),=CL13'THE LINK LIST'\n         MVC   PUTAREA+1(L'HD2MSG),HD2MSG MOVE HEADING TO IOAREA\n         BAS   R14,OUTLINE         WRITE MESSAGE\n         L     R3,CVTPTR           LOAD ADDRESS OF CVT\n         USING CVT,R3              SET ADDRESSABILITY TO CVT\n         L     R3,CVTLLTA          LOAD ADDRESS OF LINKLIST DSNAME'S\n         DROP  R3                  DROP ADDRESSABILITY TO CVT\n         LA    R4,9(,R3)           POINT TO FIRST DSN IN LIST\n         XR    R2,R2               CLEAR REGISTER\n         XR    R3,R3               CLEAR REGISTER\n         ICM   R3,B'0001',LSTCONCT LOAD CONCATENATION NUMBER\n         BZ    PRTHD6A\n         M     R2,=A(L'HD2DSNAM+1) MULTIPLY TO DISPLACE FOR DSNAME\n         B     PRTHD6A\nPRTHD4   MVC   HD2WHERE(14),=CL14'A TASK LIBRARY'\n         MVC   PUTAREA+1(L'HD2MSG),HD2MSG MOVE HEADING TO IOAREA\n         BAS   R14,OUTLINE         WRITE MESSAGE\n         B     LOADM               GO TRY TO LOAD MODULE\nPRTHD5   CLI   JSDDN,C'S'          STEPLIB?\n         BNE   *+L'*+10            NO\n         MVC   HD2WHERE(16),=CL16'THE STEP LIBRARY'\n         B     *+L'*+6\n         MVC   HD2WHERE(15),=CL15'THE JOB LIBRARY'\n         MVC   PUTAREA+1(L'HD2MSG),HD2MSG MOVE HEADING TO IOAREA\n         BAS   R14,OUTLINE         WRITE MESSAGE\n         LA    R4,DSNTB+2          POINT TO FIRST DSN IN TABLE\n         XR    R2,R2               CLEAR REGISTER\n         XR    R3,R3               CLEAR REGISTER\n         ICM   R3,B'0001',LSTCONCT LOAD CONCATENATION NUMBER\n         BZ    PRTHD6A\n         CLM   R3,B'0011',NRDSN    CHECK IN CASE OF TABLE OVERFLOW\n         BNL   LOADM               SKIP IF YES\n         M     R2,=A(L'DSNTB)      MULTIPLY TO DISPLACE FOR DSNAME\n         B     PRTHD6A\nPRTHD6   MVC   HD2WHERE(13),=CL13'THE ISPF LINK'\n         MVC   PUTAREA+1(L'HD2MSG),HD2MSG MOVE HEADING TO IOAREA\n         BAS   R14,OUTLINE         WRITE MESSAGE\n         LA    R4,ISPFTB+2         POINT TO FIRST DSN IN TABLE\n         XR    R2,R2               CLEAR REGISTER\n         XR    R3,R3               CLEAR REGISTER\n         OC    ISPFNR,ISPFNR       DSNAME(S) KNOWN?\n         BZ    LOADM               SKIP IF NOT\n         ICM   R3,B'0001',LSTCONCT LOAD CONCATENATION NUMBER\n         BZ    PRTHD6A\n         CLM   R3,B'0011',ISPFNR   CHECK IN CASE OF TABLE OVERFLOW\n         BNL   LOADM               SKIP IF YES\n         M     R2,=A(L'ISPFTB)     MULTIPLY TO DISPLACE FOR DSNAME\nPRTHD6A  AR    R4,R3               DISPLACE INTO THE TABLE\n         MVC   HD2DSNAM(L'HD2DSNAM),0(R4) MOVE DSNAME TO MESSAGE\n         MVC   PUTAREA+10(L'HD2DSN),HD2DSN MOVE HEADING TO IOAREA\n         BAS   R14,OUTLINE         WRITE MESSAGE\n         SPACE 1\n*------- ATTEMPT TO LOAD THE MODULE.\n         SPACE 1\n        CNOP   0,4\nLOADM   LOAD   EPLOC=MODULNAM,ERRET=LOADERR\n         B     LOADX\n        CNOP   0,4\nLOADI   LOAD   EPLOC=MODULNAM,DCB=DCBISPF,ERRET=LOADERR\nLOADX    STM   R0,R1,EPA           ALL ABOUT LOAD MODULE\n         TM    SWPRCS,STATUS       STATUS TEST REQUESTED?\n         BZ    SKIPST              NO\n         MVC   PUTAREA+10(30),=CL30'-> STATUS : TASK=N ISPF=N JS=.'\n         TM    SWPRCS,SUBTSK\n         BZ    *+L'*+4\n         MVI   PUTAREA+27,C'Y'\n         TM    SWMISC,ISPFACT\n         BZ    *+L'*+4\n         MVI   PUTAREA+34,C'A'\n         MVC   PUTAREA+39(1),JSDDN\n         MVC   PUTAREA+41(11),=CL11'/ W=.. C=..'\n         XR    R1,R1\n         IC    R1,LSTWHERE\n         STC   R1,PUTAREA+46\n         SRL   R1,4\n         STC   R1,PUTAREA+45\n         OC    PUTAREA+45(2),=XL2'F0F0'\n         TR    PUTAREA+45(2),TRTBL1\n         IC    R1,LSTCONCT\n         STC   R1,PUTAREA+51\n         SRL   R1,4\n         STC   R1,PUTAREA+50\n         OC    PUTAREA+50(2),=XL2'F0F0'\n         TR    PUTAREA+50(2),TRTBL1\n         MVC   PUTAREA+53(17),=CL17'(T=.. I=.. JS=..)'\n         IC    R1,WTASK\n         STC   R1,PUTAREA+57\n         SRL   R1,4\n         STC   R1,PUTAREA+56\n         OC    PUTAREA+56(2),=XL2'F0F0'\n         TR    PUTAREA+56(2),TRTBL1\n         IC    R1,WISPF\n         STC   R1,PUTAREA+62\n         SRL   R1,4\n         STC   R1,PUTAREA+61\n         OC    PUTAREA+61(2),=XL2'F0F0'\n         TR    PUTAREA+61(2),TRTBL1\n         IC    R1,WJS\n         STC   R1,PUTAREA+68\n         SRL   R1,4\n         STC   R1,PUTAREA+67\n         OC    PUTAREA+67(2),=XL2'F0F0'\n         TR    PUTAREA+67(2),TRTBL1\n         BAS   R14,OUTLINE         WRITE STATUS MESSAGE\n         LM    R0,R1,EPA           RESTORE ALL ABOUT LOAD MODULE\nSKIPST   NI    EPA,X'7F'           TURN OFF HIGH ORDER BIT\n         L     R2,EPA              RELOAD ENTRY POINT ADDRESS\n         XR    R3,R3               CLEAR REGISTER\n         SPACE 1\n*------- FORMAT GENERAL INFORATION ABOUT THE MODULE.\n*              R1 -  BYTE 0 CONTAINS AUTHORIZATION CODE,\n*                    BYTES 1-3 CONTAINS MODULE LENGTH IN DOUBLE WORDS.\n*              EPA - BYTES 0-3 CONTAIN MODULE ENTRY POINT ADDRESS.\n         SPACE 1\n         STC   R1,WORK5            SAVE THE AUTH CODE\n         SLL   R1,8                CLEAR THE AUTH CODE PORTION\n         SRL   R1,8\n         MH    R1,=H'8'            MULTIPLY BY 8 FOR LENGTH IN BYTES\n         STCM  R1,B'0111',WORK5+1  SAVE LENGTH IN BYTES\n         MVC   HEXWL(L'HEXWL),WORK5+1 KEEP LENGTH FOR EYE-CATCHER CHECK\n         MVC   HD1MNAM,MODULNAM    SET MODULE NAME\n         UNPK  WORK9,EPA(5)        UNPACK HEX FIELD + 1\n         TR    WORK9(L'WORK9-1),TRTBL1 TRANSLATE TO PRINTABLE\n         MVC   HD1EPA,WORK9        MOVE EPA TO MESSAGE\n         UNPK  WORK9,WORK5(5)      UNPACK HEX FIELD + 1\n         TR    WORK9(L'WORK9-1),TRTBL1 TRANSLATE TO PRINTABLE\n         MVC   HD1LNGTH,WORK9+2    MOVE LENGTH TO MESSAGE\n         MVC   HD1AUTH,WORK9       MOVE AUTH CODE TO MESSAGE\n         SPACE 1\n*------- DETERMINES WHERE IN MEMORY THE MODULE IS LOCATED.\n*        THE ENTRY POINT ADDRESS IS COMPARED TO THE VIRTUAL STORAGE\n*        ADDRESSES OF THE STORAGE SUBPOOLS FOR THE LOCAL AND COMMON\n*        STORAGE AREAS AS DEFINED IN THE CVT AND THE GDA.\n         SPACE 1\n         LA    R15,*+L'*+6         SET BRANCH ADDRESS - - - -* AMODE31\n         O     R15,=A(X'80000000') SET AMODE 31 BIT ON  - - -*\n         BASSM R14,R15             GO TO AMODE 31 - - - - - -*\n         L     R2,CVTPTR           LOAD ADDRESS OF CVT\n         USING CVT,R2              SET ADDRESSABILITY TO CVT\n         L     R3,CVTGDA           LOAD ADDRESS OF GDA\n         USING GDA,R3              SET ADDRESSABILITY TO GDA\n         L     R4,CVTSMEXT         LOAD ADDRESS OF STORAGE MAP EXTENS\n         USING CVTVSTGX,R4         SET ADDRESSABILITY TO MAP EXTENS\n         MVC   WORK5,=CL5'USER '   ASSUME USER 'PRIVATE'\n         CLC   EPA,CVTSHRVM        COMPARE TO START OF CSA\n         BL    LOCATD              IF LESS THAN IT MUST BE GOOD\n         MVC   WORK5,=CL5'CSA  '   ASSUME CSA\n         CLC   EPA,CVTMLPAS        COMPARE TO START OF MLPA\n         BL    LOCATD              IF LESS THAN IT MUST BE GOOD\n         MVC   WORK5,=CL5'MLPA '   ASSUME MLPA\n         CLC   EPA,CVTFLPAS        COMPARE TO START OF FLPA\n         BL    LOCATD              IF LESS THAN IT MUST BE GOOD\n         MVC   WORK5,=CL5'FLPA '   ASSUME FLPA\n         CLC   EPA,CVTPLPAS        COMPARE TO START OF PLPA\n         BL    LOCATD              IF LESS THAN IT MUST BE GOOD\n         MVC   WORK5,=CL5'PLPA '   ASSUME PLPA\n         CLC   EPA,GDASQA          COMPARE TO START OF SQA\n         BL    LOCATD              IF LESS THAN IT MUST BE GOOD\n         MVC   WORK5,=CL5'EPLPA'   ASSUME E-PLPA\n         CLC   EPA,CVTEFLPS        COMPARE TO START OF EFLPA\n         BL    LOCATD              IF LESS THAN IT MUST BE GOOD\n         MVC   WORK5,=CL5'EFLPA'   ASSUME E-MLPA\n         CLC   EPA,CVTEMLPS        COMPARE TO START OF EFLPA\n         BL    LOCATD              IF LESS THAN IT MUST BE GOOD\n         MVC   WORK5,=CL5'EMLPA'   ASSUME E-MLPA\n         CLC   EPA,GDAECSA         COMPARE TO START OF E-CSA\n         BL    LOCATD              IF LESS THAN IT MUST BE GOOD\n         MVC   WORK5,=CL5'ECSA '   ASSUME E-CSA\n         CLC   EPA,GDAEPVT         COMPARE TO START OF E-PRIVATE\n         BL    LOCATD              IF LESS THAN IT MUST BE GOOD\n         MVC   WORK5,=CL5'EPVT '   ASSUME E-PRIVATE\nLOCATD   LA    R15,*+L'*+2         SET BRANCH ADDRESS - - - -* AMODE24\n         BASSM R14,R15             GO TO AMODE 24 - - - - - -*\n         DROP  R2,R3,R4            DROP CVT, GDA, MAP EXTENS\n         MVC   HD1AREA,WORK5       SAVE STORAGE NAME\n         MVC   PUTAREA+1(L'HD1MSG),HD1MSG MOVE HEADING TO IOAREA\n         BAS   R14,OUTLINE         PUT LINE\n         SPACE 1\n*------- FORMAT THE CDE INFORMATION.\n         SPACE 1\n         LA    R15,*+L'*+6         SET BRANCH ADDRESS - - - -* AMODE31\n         O     R15,=A(X'80000000') SET AMODE 31 BIT ON  - - -*\n         BASSM R14,R15             GO TO AMODE 31 - - - - - -*\n         L     R8,TCBLLS           LOAD LLE ADDRESS FROM TCB\n         USING LLE,R8              SET ADDRESSABILITY TO LLE\n         L     R8,LLECDPT          LOAD CDE ADDRESS FROM LLE\n         DROP  R8                  DROP ADDRESSABILITY TO LLE\n         USING CDENTRY,R8          SET ADDRESSABILITY TO CDE\n         LA    R15,*+L'*+2         SET BRANCH ADDRESS - - - -* AMODE24\n         BASSM R14,R15             GO TO AMODE 24 - - - - - -*\nCKCDNAME CLC   CDNAME,MODULNAM     SAME MODULE AS REQUESTED?\n         BE    CKATTR1             YES, CHECK ATTRIBUTES.\n         L     R8,CDCHAIN          NO, LOAD ADDRESS OF NEXT CDE\n         LTR   R8,R8               TEST ADDRESS\n         BNZ   CKCDNAME            NOT ZERO, CHECK CDNAME ENTRY.\n         SPACE 1\n*------- CORRECT CDE COULD NOT BE FOUND.\n         SPACE 1\n         MVC   PUTAREA+10(3),=CL3'---'\n         MVC   PUTAREA+14(L'CDEMSG),CDEMSG\n         BAS   R14,OUTLINE         GO WRITE ERROR MESSAGE\n         B     FMTEYE\n         SPACE 1\n*------- DETERMINE THE MODULE ATTRIBUTES.\n         SPACE 1\nCKATTR1  MVI   PCDATTR,C' '        CLEAR CDE ATTRIBUTES LINE\n         MVC   PCDATTR+1(3*(L'PCDATTR)-1),PCDATTR\n         LA    R9,PCDATTR-1        LOAD ADDRESS OF PRINT WORK AREA\n         TM    CDATTR,CDNIP        SEE IF NIP LOADED OR LPA?\n         BZ    *+L'*+10            NO, BRANCH\n         MVC   0(7,R9),=CL7',IN-LPA' SET IN LPA\n         LA    R9,7(R9)            INCREMENT TO NEXT MESSAGE AREA\n         TM    CDATTR,CDREN        SEE IF RE-ENTRANT MODULE?\n         BZ    *+L'*+10            NO, BRANCH\n         MVC   0(5,R9),=CL5',RENT'   SET RENT\n         LA    R9,5(R9)            INCREMENT TO NEXT MESSAGE AREA\n         TM    CDATTR,CDSER        SEE IF SERIALLY RE-USEABLE MODULE?\n         BZ    *+L'*+10            NO, BRANCH\n         MVC   0(5,R9),=CL5',REUS'   SET REUS\n         LA    R9,5(R9)            INCREMENT TO NEXT MESSAGE AREA\n         TM    CDATTR,CDNFN        SEE IF NOT FUNCTIONAL MODULE?\n         BZ    *+L'*+10            NO, BRANCH\n         MVC   0(10,R9),=CL10',NON-FUNCT' SET NON-FUNCT\n         LA    R9,10(R9)           INCREMENT TO NEXT MESSAGE AREA\n         TM    CDATTR,CDMIN        SEE IF ALIAS? (MINOR CDE)\n         BZ    TCDJPA              NO, BRANCH\n         MVC   0(10,R9),=CL10',ALIAS-OF ' SET ALIAS\n         LA    R9,10(R9)           INCREMENT TO NEXT MESSAGE AREA\n         L     R6,CDXLMJP          LOAD CDE OF MAJOR NAME\n         DROP  R8                  DROP ADDRESSABILITY TO MINOR CDE\n         USING CDENTRY,R6          SET ADDRESSABILITY TO MAJOR CDE\n         MVI   0(R9),C'\"'\n         MVC   1(L'CDNAME,R9),CDNAME SAVE MAJOR CDE NAME\n         MVI   1+L'CDNAME(R9),C'\"'\n         LA    R9,L'CDNAME+2(R9)   INCREMENT TO NEXT MESSAGE AREA\n         DROP  R6                  DROP ADDRESSABILITY TO MAJOR CDE\n         USING CDENTRY,R8          SET ADDRESSABILITY TO MINOR CDE\nTCDJPA   TM    CDATTR,CDJPA        IS MODULE IN JOB PACK AREA?\n         BZ    *+L'*+10            NO, BRANCH\n         MVC   0(7,R9),=CL7',IN-JPA' SET IN JPA\n         LA    R9,7(R9)            INCREMENT TO NEXT MESSAGE AREA\n         TM    CDATTR,CDNLR        SEE OF NOT LOAD-ONLY?\n         BZ    CKATTR2             NO, BRANCH\n         MVC   0(14,R9),=CL14',NOT-LOAD-ONLY' SET NOT LOAD-ONLY\n         LA    R9,14(R9)           INCREMENT TO NEXT MESSAGE AREA\nCKATTR2  TM    CDATTR2,CDSPZ       SEE IF SUBPOOL 0?\n         BZ    *+L'*+10            NO, BRANCH\n         MVC   0(5,R9),=CL5',SP=0'   SET SUBPOOL 0\n         LA    R9,5(R9)            INCREMENT TO NEXT MESSAGE AREA\n         TM    CDATTR2,CDRLC       SEE IF EPA RELOCATED?\n         BZ    *+L'*+10            NO, BRANCH\n         MVC   0(8,R9),=CL8',MIN-RLC' SET RELOCATED\n         LA    R9,8(R9)            INCREMENT TO NEXT MESSAGE AREA\n         TM    CDATTR2,CDOLY       SEE IF OVERLAY FORMAT?\n         BZ    *+L'*+10            NO, BRANCH\n         MVC   0(5,R9),=CL5',OVLY'   SET OVLY\n         LA    R9,5(R9)            INCREMENT TO NEXT MESSAGE AREA\n         TM    CDATTR2,CDSYSLIB    SEE IF FROM AUTH. LIBRARY?\n         BZ    *+L'*+10            NO, BRANCH\n         MVC   0(10,R9),=CL10',AUTH.-LIB' SET AUTHORIZED LIBRARY\n         LA    R9,10(R9)           INCREMENT TO NEXT MESSAGE AREA\n         LH    R0,CDUSE            LOAD USE COUNT\n         CVD   R0,PCDUSE           CONVERT TO DECIMAL\n         MVC   0(11,R9),=CL11',USE-COUNT=' SET TITLE\n         LA    R9,11(R9)           INCREMENT TO NEXT MESSAGE AREA\n         OI    PCDUSE+7,X'0F'      MAKE COUNT PRINTABLE\n         UNPK  0(3,R9),PCDUSE+6(2) UNPACK USE COUNT TO MESSAGE\n         MVI   PCDATTR-1,C' '      RESET 1ST COMMA\n         MVC   PUTAREA+1(L'PCDELIT),PCDE SET MESSAGE LINE\n         LA    R2,PCDE+L'PCDELIT-1\nCKNEXT   MVC   PUTAREA+L'PCDELIT+1(L'PCDATTR),1(R2)\n         LA    R2,L'PCDATTR(R2)\n         CLI   0(R2),C' '\n         BE    CKENDL\n         LA    R3,PUTAREA+L'PCDE\nCKLOOP   CLI   0(R2),C','\n         BE    *+L'*+10\n         MVI   0(R3),C' '\n         BCTR  R3,0\n         BCT   R2,CKLOOP\n         BAS   R14,OUTLINE         GO WRITE MESSAGE LINE\n         B     CKNEXT\nCKENDL   BAS   R14,OUTLINE         GO WRITE MESSAGE LINE\n         SPACE 1\n*------- FORMAT THE EYE-CATCHER IN THE BEGINNING OF THE MODULE.\n         SPACE 1\nFMTEYE   L     R2,CDXLMJP          LOAD POSSIBLE EXTENT LIST ADDRESS\n         TM    CDATTR,CDMIN        SEE IF ALIAS? (MINOR CDE)\n         BNO   FMTEYE1             NO, BRANCH\n         L     R6,CDXLMJP          LOAD CDE OF MAJOR NAME\n         DROP  R8                  DROP ADDRESSABILITY TO MINOR CDE\n         USING CDENTRY,R6          SET ADDRESSABILITY TO MAJOR CDE\n         L     R2,CDXLMJP          LOAD POSSIBLE EXTENT LIST ADDRESS\n         DROP  R6                  DROP ADDRESSABILITY TO MAJOR CDE\n         USING CDENTRY,R8          SET ADDRESSABILITY TO MINOR CDE\nFMTEYE1  TM    CDATTRB,CDELPDE     SEE IF LPDE\n         BO    DELMOD              YES, GET OUT\n         DROP  R8                  DROP ADDRESSABILITY TO MINOR CDE\n         LTR   R2,R2               SEE IF PRESENT\n         BZ    DELMOD              NO, GET OUT\n         LA    R15,*+L'*+6         SET BRANCH ADDRESS - - - -* AMODE31\n         O     R15,=A(X'80000000') SET AMODE 31 BIT ON  - - -*\n         BASSM R14,R15             GO TO AMODE 31 - - - - - -*\n         ICM   R2,B'1111',12(R2)   GET LOAD STORAGE BLOCK ADDRESS\n         LM    R4,R5,=A(HEXWK,HEXWKL)\n         LR    R3,R5\n         CLM   R3,B'0111',HEXWL\n         BNH   *+L'*+4\n         ICM   R3,B'0111',HEXWL\n         LR    R6,R3\n         MVCL  R4,R2               COPY EYE-CATCHER\n         LA    R15,*+L'*+2         SET BRANCH ADDRESS - - - -* AMODE24\n         BASSM R14,R15             GO TO AMODE 24 - - - - - -*\n         L     R2,=A(HEXWK,HEXWKL)\n         LR    R4,R2\n         LA    R5,L'DUEYEC\n         XR    R3,R3\n         LA    R3,1(R3)\n         SR    R6,R5\n         BP    *-6\n         BZ    *+L'*+2\n         LPR   R6,R6\nEYELOOP  MVC   DUEYEC(L'DUEYEC),0(R2)\n         TR    DUEYEC(L'DUEYEC),TRTBL2 SET UNPRINTABLE TO BLANKS\n         LR    R0,R2\n         SR    R0,R4\n         STC   R0,DUEYED+1\n         SRL   R0,4\n         STC   R0,DUEYED\n         OC    DUEYED,=XL2'F0F0'\n         TR    DUEYED(L'DUEYED),TRTBL1\n         LA    R1,DUEYEF1\n         BAS   R14,HEXPRT\n         LA    R1,DUEYEF2\n         BAS   R14,HEXPRT\n         LA    R1,DUEYEF3\n         BAS   R14,HEXPRT\n         LA    R1,DUEYEF4\n         BAS   R14,HEXPRT\n         MVC   PUTAREA+5(L'DUEYE),DUEYE\n         BAS   R14,OUTLINE         GO WRITE EYE-CATCHER LINE\n         BCT   R3,EYELOOP\n         SPACE 1\n*------- DELETE THE LOAD MODULE AFTER ALL PROCESSING HAS COMPLETED.\n         SPACE 1\nDELMOD  DELETE EPLOC=MODULNAM      DELETE LOADED MODULE\n         LTR   R15,R15             TEST RETURN CODE\n         BZ    GETNME3             ZERO, CONTINUE\n         MVC   PUTAREA+10(3),=CL3'---'\n         MVC   PUTAREA+14(L'DELMSG),DELMSG MOVE IN ERROR MSG\n         STCM  R15,B'1111',WORK5\n         UNPK  WORK9,WORK5(5)      UNPACK HEX FIELD + 1\n         TR    WORK9(L'WORK9-1),TRTBL1 TRANSLATE TO PRINTABLE\n         MVC   PUTAREA+15+L'DELMSG(4),WORK9+4 MOVE IN RC\n         BAS   R14,OUTLINE         WRITE OUT DELETE ERROR MESSAGE\n         B     GETNME3\n         SPACE 1\n*------- IF THE PROGRAM COULD NOT LOAD THE MODULE, CONTROL\n*        COMES HERE. AN ERROR MESSAGE IS WRITTEN GIVING THE\n*        ABEND AND REASON CODE.\n*              R1  = BYTES 2-3 CONTAIN THE ABEND CODE.\n*              R15 = BYTES 2-3 CONTAIN THE REASON CODE.\n         SPACE 1\nLOADERR  ST    R1,EPA              SAVE REGISTER 1\n         STCM  R15,B'1111',WORK5   SAVE REGISTER 15\n         UNPK  WORK9,EPA(5)        UNPACK HEX FIELD + 1\n         TR    WORK9(L'WORK9-1),TRTBL1 TRANSLATE TO PRINTABLE\n         MVC   LOADABND,WORK9+5    MOVE ABEND CODE TO MESSAGE\n         UNPK  WORK9,WORK5(5)      UNPACK HEX FIELD + 1\n         TR    WORK9(L'WORK9-1),TRTBL1 TRANSLATE TO PRINTABLE\n         MVC   LOADRSN,WORK9+4     MOVE REASON CODE TO MESSAGE\n         MVC   PUTAREA+10(3),=CL3'---'\n         MVC   PUTAREA+14(L'LOADMSG),LOADMSG MOVE MSG TO IOAREA\n         BAS   R14,OUTLINE         WRITE MESSAGE\n         B     GETNME3             GO GET NEXT REQUEST\n         SPACE 1\n*------- END OF PROCESSING.\n         SPACE 1\n         DROP  R7                  DROP ADDRESSABILITY TO TCB\nLEAVE    TM    SWPRCS,FREEIB       INPUT BUFFER TO BE FREED?\n         BZ    NOFRIB              NO, BRANCH\n         NI    SWPRCS,255-FREEIB\n         LA    R15,GTPBZ           ADDRESSABILITY FOR THE GTPB\n         USING GTPB,R15\n         L     R1,GTPBIBUF         GET ADDRESS OF INPUT BUFFER\n         DROP  R15\n         LH    R0,0(R1)            INPUT BUFFER LENGTH\n         AH    R0,=H'7'            ROUND UP TO 8\n         SRL   R0,3\n         SLL   R0,3\n        FREEMAIN RC,LV=(0),A=(1),SP=1\nNOFRIB   TM    SWMISC,ISPFACT      IS ISPF ACTIVE?\n         BO    NOISPF              YES\n         TM    SWMISC,DDISPFO      NO, ISPF LINK DD?\n         BZ    NOISPF              NOT FOUND OR NOT OPENED\n        CLOSE  (DCBISPF)           CLOSE ISPF LINK\nNOISPF   TM    SWPRCS,JBATCH       SEE IF BATCH JOB?\n         BZ    QUIT                NO, BRANCH\n         TM    SWMISC,DDINO        SEE IF INPUT OPENED?\n         BZ    QUIT                NO, BRANCH\n        CLOSE  (DCBIN)             CLOSE INPUT FILE\n         TM    SWMISC,DDOUTO       SEE IF OUTPUT OPENED?\n         BZ    QUIT                NO, BRANCH\n        CLOSE  (DCBOUT)            CLOSE OUTPUT FILE\nQUIT     XR    R15,R15\n        $XRET  CC=(R15)            RETURN TO CALLER\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*                  M O D L O O K     R O U T I N E S                  *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\n*------- ROUTINE TO EDIT IN HEXADECIMAL THE EYE-CATCHER DATA.\n*              (R14 SAVED IN \"SVRET\")\n         SPACE 1\nHEXPRT   ST    R14,SVRET           SAVE RETURN ADDRESS\n         UNPK  WORK9,0(5,R2)\n         TR    WORK9(L'WORK9-1),TRTBL1\n         CL    R3,=F'1'\n         BNE   HEXPRT1\n         SH    R5,=H'4'\n         CLR   R5,R6\n         BNL   HEXPRT1\n         LR    R15,R6\n         SR    R15,R5\n         SR    R6,R15\n         AR    R15,R15\n         LA    R14,WORK9+8\n         SR    R14,R15\n         BCT   R15,*+L'*+6\n         MVC   0(*-*,R14),=CL8' '  <<EXECUTED>>\n         EX    R15,*-6\nHEXPRT1  MVC   0(4,R1),WORK9\n         MVC   4(4,R1),WORK9+4\n         LA    R2,4(R2)\n         L     R14,SVRET           RESTORE RETURN ADDRESS\n         BR    R14                 GO BACK\n         SPACE 1\n*------- ROUTINE TO HANDLE ALL OUTPUT FOR THE PROGRAM.\n*        IF WE ARE : 1. RUNNING AS A STARTED TASK, A WTO IS ISSUED,\n*                    2. A BATCH JOB, PUT IS USED,\n*                    3. RUNNING UNDER TSO, PUTLINE IS ISSUED.\n*              (R14 SAVED IN \"SVRET\")\n         SPACE 1\nOUTLINE  ST    R14,SVRET           SAVE RETURN CODE\n         TM    SWPRCS,JBATCH       SEE IF BATCH JOB\n         BZ    OUTLINE1            NO, BRANCH\n        PUT    DCBOUT,PUTAREA      WRITE MESSAGE LINE\n         B     OUTLINE3            GET OUT\nOUTLINE1 TM    SWPRCS,USTSO        SEE IF TSO USER\n         BZ    OUTLINE2            NO, BRANCH\n         LA    R1,L'PUTAREA-1\n         LA    R14,PUTAREA+L'PUTAREA-1\n         CLI   0(R14),C' '\n         BNE   *+L'*+10\n         BCTR  R14,0\n         BCT   R1,*-10\n         LA    R1,10               NONE MEANS A BLANK LINE\n         MVI   MSGOUT,C' '         CLEAR BUFFER TO SPACES\n         MVC   MSGOUT+1(L'MSGOUT-1),MSGOUT\n         BCT   R1,*+L'*+6\n         MVC   MSGOUT(*-*),PUTAREA+1 <<EXECUTED>>\n         EX    R1,*-6\n         XC    MSGCNTL,MSGCNTL     SET IN PUTLINE LINE LENGTH\n         LA    R1,L'MSGCNTL+1(R1)\n         STH   R1,MSGCNTL\n         LA    R0,MSGWORK          ADDRESS OF MSG BUFFER\n         L     R1,CPPLADDR         ADDRESS OF CPPL\n         USING CPPL,R1\n         L     R14,CPPLUPT         UPT ADDRESS\n         L     R15,CPPLECT         ECT ADDRESS\n         DROP  R1\n         XC    MYECB,MYECB         CLEAR ECB TO ZEROS\n         XC    PTPB(PTPBLEN),PTPB  CLEAR PLIST TO ZEROS\n         XC    IOPLZ(IOPLLEN),IOPLZ CLEAR PARM LIST TO ZEROS\n         LA    R1,IOPLZ            ADDRESS OF LIST\n        PUTLINE PARM=PTPB,UPT=(R14),ECT=(R15),ECB=MYECB,               X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     X\n               OUTPUT=((R0),TERM,SINGLE,DATA),                         X\n               MF=(E,(1))          WRITE MESSAGE LINE\n         B     OUTLINE3            GET OUT\nOUTLINE2 MVC   WTOL+4(L'PUTAREA-1),PUTAREA+1 SET WTO LIST FORM\n        WTO    MF=(E,WTOL)         WRITE MESSAGE\nOUTLINE3 MVI   PUTAREA,C' '\n         MVC   PUTAREA+1(L'PUTAREA-1),PUTAREA\n         L     R14,SVRET           RESTORE RETURN ADDRESS\n         BR    R14                 GO BACK\n         SPACE 1\n*------- THIS ROUTINE IS THE DCB OPEN EXIT FOR THE OUTPUT FILE.\n*        IT WILL SET THE OUTPUT BLKSIZE TO 9044 IF IT HAS NOT\n*        BEEN SPECIFIED.\n         SPACE 1\nOUTEXIT  LA    R2,0(R1)            LOAD DCB ADDRESS\n         USING IHADCB,R2           SET ADDRESSABILITY TO DCB\n         CLC   DCBBLKSI,=XL2'0000' SEE IF OUTPUT BLKSIZE SPECIFIED\n         BNER  R14                 YES, RETURN TO OPEN\n         MVC   DCBBLKSI,=H'9040'   NO,  SET TO 9040\n         BR    R14                 RETURN TO OPEN\n         DROP  R2                  DROP ADDRESSABILITY TO DCB\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*        CONSTANTS AND WORK-AREAS                                     *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\n        CNOP   0,8\nDOUBLE   DC    D'0'                DOUBLE WORD WORK-AREA\nPCDUSE   DC    D'0'\nMODULNAM DC    CL8' '\nANSWER   DC    5F'0'               FRS, TIOT, COMM, TSO, PSB\nSCANPTR  DC    3F'0'               GETAREA SCAN POINTERS (R1-R2-R3)\nPADDR    DC    F'0'\nCPPLADDR DC    F'0'\nSVRET    DC    F'0'\nMYECB    DC    F'0'                USED BY WTOR, PUTLINE, GETLINE\nEPA      DC    2F'0'               R0-R1 FROM LOAD\nRESTCNT  DC    F'0'\nRESTPTR  DC    F'0'\n         SPACE 1\nBLDLRC   DC    F'0'                BLDL RETURN CODE (R15)\nBLDLRS   DC    F'0'                BLDL REASON CODE (R0)\nLSTADDR  DC    AL2(1)            # ENTRIES IN LIST - - - - - - ->*\n         DC    AL2(LSTL)           LENGTH OF EACH ENTRY          *\nLSTNM    DC    CL8' '              MEMBER NAME                   *\nLSTTTR   DC    XL3'0'              MEMBER TTR                    *\nLSTCONCT DC    XL1'0'              CONCATENATION NUMBER 00-FF    *\nLSTWHERE DC    XL1'0'              WHERE ENTRY WAS FOUND         *\n*                                    0 - PRIVATE LIB             *\n*                                    1 - LINK LIBRARY            *\n*                                    2 - JOB, TASK OR STEPLIB    *\n*                                    3-FF PARENT TASK LIB        *\nLSTTYPE  DC    XL1'0'              TYPE OF MEMBER                *\n*                                    X'80' OFF - MEMBER NAME     *\n*                                          ON  - ALIAS NAME      *\nLSTZ     EQU   *-LSTTTR                                          *\nLSTL     EQU   *-LSTNM <- - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\nWORK9    DC    XL9'0'              TEMPORARY WORK-AREA\nWORK5    DC    XL5'0'               \" \"       \" \"\nWTASK    DC    AL1(2)\nWISPF    DC    AL1(3)\nWJS      DC    AL1(5)\n         SPACE 1\nSWPRCS   DC    XL1'0' - - - - - -> PROCESSING SWITCHES\nSTASK    EQU   X'80'               THIS IS A STARTED TASK\nJBATCH   EQU   X'40'               THIS IS A BATCH JOB\nUSTSO    EQU   X'20'               THIS IS A TSO USER\nTSOFU    EQU   X'10'               THIS IS A TSO FOREGROUND USER\nSUBTSK   EQU   X'08'               TSO - NOT DIRECT SUBTASK OF ISPF\nFREEIB   EQU   X'04'               TSO GETLINE BUFFER MUST BE FREED\nSTATUS   EQU   X'02'               TEST - STATUS DISPLAY REQUESTED\nFLG1ST   EQU   X'01'               1ST TIME DONE\nSWMISC   DC    XL1'0' - - - - - -> MISCELLANEOUS SWITCHES\nDDIN     EQU   X'80'               BATCH - THERE IS A SYSIN DD\nDDINO    EQU   X'40'               BATCH - INPUT OPENED\nDDOUT    EQU   X'20'               BATCH - THERE IS A SYSPRINT DD\nDDOUTO   EQU   X'10'               BATCH - OUTPUT OPENED\nISPFACT  EQU   X'08'               TSO - ISPF IS ACTIVE\nDDISPFO  EQU   X'04'               TSO - ISPF LINK DD FOUND AND OPENED\n         SPACE 1\nTRTBL1   EQU   *-C'0'              HEX CONVERSION TRANSLATE TABLE\n         DC    C'0123456789ABCDEF'\nTRTBL2   DC    C'                ' 00 - 0F\n         DC    C'                ' 10 - 1F\n         DC    C'                ' 20 - 2F\n         DC    C'                ' 30 - 3F\n         DC    C'           .< + ' 40 - 4F\n         DC    C'           $*)  ' 50 - 5F\n         DC    C'-/         , (>?' 60 - 6F\n         DC    C'          :#@''=\"' 70 - 7F\n         DC    C'                ' 80 - 8F\n         DC    C'                ' 90 - 9F\n         DC    C'                ' A0 - AF\n         DC    C'                ' B0 - BF\n         DC    C' ABCDEFGHI      ' C0 - CF\n         DC    C' JKLMNOPQR      ' D0 - DF\n         DC    C'  STUVWXYZ      ' E0 - EF\n         DC    C'0123456789      ' F0 - FF\n         SPACE 1\nWTOQ    WTOR   '=== ENTER \"MODLOOK\" MODULE(S) NAME(S) OR ''END'' :',   X\n               GETAREA,L'GETAREA,MYECB,ROUTCDE=2,MF=L\nWTOL    WTO    '----+----1----+----2----+----3----+----4----+----5----+X\n               ----6----+----7----+----',ROUTCDE=2,MF=L\nWTOM    WTO    ' => \"MODLOOK\" (NOT INVOKED AS TSO COMMAND OR SUB-COMMANX\n               D)',ROUTCDE=11,DESC=7,MF=L\nWTOX    WTO    ' =>          : DD-CARD MISSING - EXIT -',              X\n               ROUTCDE=11,DESC=7,MF=L\nWTOXDD   EQU   WTOX+8\nWTOZ    WTO    ' =>          : OPEN FAILED - EXIT -',                  X\n               ROUTCDE=11,DESC=7,MF=L\nWTOZDD   EQU   WTOZ+8\n         SPACE 1\nPTPB    PUTLINE MF=L\nPTPBLEN  EQU   *-PTPB\nIOPLZ    DC    0F'0',(IOPLLEN)X'0' I-O PARM LIST FOR PUTLINE\nGTPBZ    DC    0F'0',(GTPBLEN)X'0' GETLINE PARM BLOCK\n        CNOP   0,4\nMSGWORK  DS    0CL84               PUTLINE WORK USE\nMSGCNTL  DC    F'0'                     CONTROL WORD FOR PUTLINE\nMSGOUT   DC    CL80' '                  PUTLINE TEXT\n         SPACE 1\nPUTAREA  DC    CL80' '\nGETAREA  DC    CL80' '\n         SPACE 1\nHD1MSG   DS    0CL72 - - - - - - - - - - - - - - - - - - - - - ->*\nHD1MNAM  DC    CL8'????????',CL5' EPA='                          *\nHD1EPA   DC    CL8' ',CL8',LENGTH='                              *\nHD1LNGTH DC    CL6' ',CL6',AUTH='                                *\nHD1AUTH  DC    CL2' ',CL24',AREA CONTAINING MODULE='             *\nHD1AREA  DC    CL5' '  <- - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\nHD2MSG   DS    0CL70 - - - - - - - - - - - - - - - - - - - - - ->*\nHD2MNAM  DC    CL8'????????',CL28' WAS FOUND IN CONCATENATION '  *\nHD2CONCT DC    CL2' ',CL4' OF '                                  *\nHD2WHERE DC    CL28' ' <- - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\nHD2DSN   DS    0CL60 - - - - - - - - - - - - - - - - - - - - - ->*\n         DC    CL16'DATA-SET NAME = '                            *\nHD2DSNAM DC    CL44' ' <- - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\nPCDE     DS    0CL(L'PUTAREA-1)  - - - - - - - - - - - - - - - ->*\nPCDELIT  DC    CL17'    ATTRIBUTES : '                           *\nPCDATTR  DC    3CL(L'PCDE-L'PCDELIT)' '  <- - - - - - - - - - - -*\n         SPACE 1\nLOADMSG  DS    0CL43 - - - - - - - - - - - - - - - - - - - - - ->*\n         DC    CL21'LOAD FAILED - ABEND S'                       *\nLOADABND DC    CL3' ',CL15' / REASON CODE='                      *\nLOADRSN  DC    CL4' '  <- - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\nDUEYE    DS    0CL70 - - - - - - - - - - - - - - - - - - - - - ->*\n         DC    CL1'+'                                            *\nDUEYED   DC    CL2' ',CL3' '                                     *\nDUEYEF1  DC    CL9' ',CL2' '                                     *\nDUEYEF2  DC    CL9' ',CL3' '                                     *\nDUEYEF3  DC    CL9' ',CL2' '                                     *\nDUEYEF4  DC    CL9' ',CL4'   *'                                  *\nDUEYEC   DC    CL16' ',CL1'*'  <- - - - - - - - - - - - - - - - -*\n         SPACE 1\nCDEMSG   DC    CL38'UNABLE TO LOCATE THE CDE OF THE MODULE'\nDELMSG   DC    CL24'ERROR IN DELETING THE MODULE - RC='\n         SPACE 1\nHEXWL    DC    XL3'0'\nHEXWK    DC    6XL(L'DUEYEC)'0'  <- - - - - - - - - EYE-CATCHER LENGTH\nHEXWKL   EQU   *-HEXWK\n         SPACE 1\n        PRINT  NOGEN\nDCBISPF DCB    DDNAME=ISPLLIB,DSORG=PO,DEVD=DA,MACRF=(R),BFALN=D\nDCBIN   DCB    DDNAME=SYSIN,DSORG=PS,MACRF=(GM),LRECL=80,              X\n               EODAD=GETEODAD,RECFM=FB\nDCBOUT  DCB    DDNAME=SYSPRINT,DSORG=PS,MACRF=(PM),LRECL=80,           X\n               RECFM=FBA,EXLST=EXLISTP\n        PRINT  GEN\nEXLISTP  DC    0F'0',XL1'85',AL3(OUTEXIT) EXIT LIST FOR OPEN\n         SPACE 1\nPLDSN    DC    A(JSDDN,DSNTB,TBSIZE,NRDSN+X'80000000')\nJSDDN    DC    CL8' '\nTBSIZE   DC    Y(DSNTBL)\nNRDSN    DC    Y(*-*)\nDSNTB    DC    20XL(2+L'HD2DSNAM)'0'  <- - - - - DSNAME'S TABLE LENGTH\nDSNTBL   EQU   *-DSNTB\n         SPACE 1\nPLISPF   DC    A(ISPFDD,ISPFTB,ISPFSZ,ISPFNR+X'80000000')\nISPFDD   DC    CL8' '\nISPFSZ   DC    Y(ISPFTBL)\nISPFNR   DC    Y(*-*)\nISPFTB   DC    20XL(2+L'HD2DSNAM)'0'  <- - - - - DSNAME'S TABLE LENGTH\nISPFTBL  EQU   *-ISPFTB\n         SPACE 1\nCT441PRM DC    A(ENTRYCDE)         IKJCT441 PARM.LIST\n         DC    A(NAMEADDR,NAMELENG,DATAADDR,DATALENG)\n         DC    A(TOKENPRM+X'80000000') SET VL=1\nENTRYCDE DC    A(TSVNOIMP)         ENTRY CODE\nNAMEADDR DC    A(VARINAME)         ADDRESS OF VARIABLE NAME\nNAMELENG DC    A(L'VARINAME)       LENGTH OF VARIABLE NAME\nDATAADDR DC    A(*-*)              ADDRESS OF VARIABLE DATA\nDATALENG DC    A(*-*)              LENGTH OF VARIABLE DATA\nTOKENPRM DC    F'0'                TOKEN TO VARIABLE ACCESS SERVICE\nVARINAME DC    C'SYSOUTTRAP'       VARIABLE NAME FIELD\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*        LITERAL POOL - DSECT'S.                                      *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\n         LTORG\n         SPACE 1\n        PRINT  NOGEN\n        CVT    DSECT=YES\n        IKJTCB\n        IKJRB  DSECT=YES,LIST=NO\nTIODSECT DSECT\n        IEFTIOT1\n        IKJCPPL\n        IKJPSCB\n        IKJEBECA\n        IKJIOPL\nIOPLLEN  EQU   *-IOPL\n        IKJGTPB\nGTPBLEN  EQU   *-GTPB\n        IKJTSVT\n        IHALLE\n        IHACDE\n        IHAGDA\n        DCBD   DSORG=PS,DEVD=DA\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MODLOOK$": {"ttr": 25610, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x943?\\x00\\x943?\\t'\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-29T00:00:00", "modifydate": "1994-11-29T09:27:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//MODLOOK  JOB (........),'INSTALL  -MODLOOK-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=5\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                DSNTAB                                             *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ4AS3,MBR=MODLOOK\n//LNK     EXEC PAJILKC,OPT=',MAP'\n//SYSIN     DD *\n  INCLUDE   SYSADD(DSNTAB)\n  ENTRY     MODLOOK\n  NAME      MODLOOK(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MODLOOK@": {"ttr": 25612, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94$\\x8f\\x00\\x94$\\x8f\\x14D\\x005\\x005\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-09-05T00:00:00", "modifydate": "1994-09-05T14:44:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "SYSPAJA"}, "text": "1   19/08/94                                          MODLOOK   1/1\n\n                             M O D L O O K\n\n  Purpose : This program is designed to run as a TSO command, started\n            task or a batch job to look up the selected module(s) in the\n            system link list or link pack area. If the module is in the\n            link list, the link list library name will be displayed. If\n            the module is in the link pack area, its address will be\n            displayed along with the name of the resident area in which\n            it is located such as PLPA, FLPA, ECSA, etc. The first part\n            of each module, unless it is in the LPA, is displayed also\n            since it can contain date, time, or copyright information\n            which may be of interest.\n\n            When the program is run from TSO, the user will be prompted\n            for module(s) name(s) and the response(s) will be displayed\n            on the TSO user terminal. When it is run as a started task,\n            a WTOR request will be made for the module(s) name(s) and\n            the response(s) will be sent to the console. If it is run\n            as a batch job, the module(s) name(s) will be entered in\n            record(s) read from the SYSIN file and the response(s) will\n            be written to the SYSPRINT file.\n\n            The program will continue to ask for any other module(s)\n            name(s) until end-of-file is reached on the SYSIN file for\n            a batch job or a 'STOP', 'END', or '/*' is received from\n            a TSO user or the operator console.\n\n\n  Use :     1. Batch job :\n                 //Jobname  JOB ...\n                 //MODLOOK EXEC PGM=MODLOOK\n                 //SYSPRINT  DD SYSOUT=*\n                 //SYSIN     DD *\n                 IDCAMS   ISPF\n                 IEFW21SD\n                 /*\n            2. Started task :\n                 //MODLOOK PROC\n                 //MODLOOK EXEC PGM=MODLOOK\n               After the operator entered the S MODLOOK command, he\n               will be prompted for module(s) name(s) and the results\n               will be written to the console.\n            3. TSO user :\n               Just enter MODLOOK at the READY prompt or under Option\n               6 of ISPF.\n               Message issued :\n                 === ENTER \"MODLOOK\" MODULE(S) NAME(S) OR 'END' :\n               This message prompts for any other module(s) name(s) to\n               be used to search the link list or link pack area.\n               If any response is 'STOP', 'END', or '/*', the program\n               will terminate.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NOTICE": {"ttr": 25857, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15H\\x04\\x9b\\x04\\x9b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:48:00", "lines": 1179, "newlines": 1179, "modlines": 0, "user": "SYSPAJA"}, "text": "NTCS     TITLE 'NOTICE - COMMAND PROCESSOR FOR NOTICES.'\n         PRINT OFF                                                 -EU-\n         COPY  GTEMACS                                             -EU-\n         PRINT ON                                                  -EU-\n         SPACE 1                                                   -EU-\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -EU-*\n* Origin : Extracted from CBT tape 86 FEB, file 160.              -EU-*\n*   Note : See original material for more details (BULLETIN).     -EU-*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -EU-*\n         SPACE 1                                                   -EU-\n*******************************************************************-EU-\n***                                                                -EU-\n*** EU modifications : MOINIL P.A. - Computing Centre              -EU-\n***                    J.R.C. - Ispra establishment                -EU-\n***                    21020 Ispra (VA), Italy                     -EU-\n***      1. Change the name BULLETIN by NOTICE to override a       -EU-\n***         confusion at our installation.                         -EU-\n***      2. Use of our local authorization SVC.                    -EU-\n***      3. Insert of our authority check routine to determine     -EU-\n***         which process may be allowed to the caller.            -EU-\n***      4. Reduce to minimum the instructions running supervisor  -EU-\n***         mode, key 0.                                           -EU-\n***      5. When NOCLEAR is specified, use SE '...',LOGON instead  -EU-\n***         of SE '...',SAVE command.                              -EU-\n***                                                                -EU-\n*******************************************************************-EU-\n         SPACE 1\n**********************************************************************\n***                                                                ***\n***  Set the following global variables before program assembly :  ***\n***                                                                ***\n***    &SYSBC   - The name of the system notices data-set, which   ***\n***               will be the default used with the BROADCAST      ***\n***               operand.                                         ***\n***                                                                ***\n***    &WAIT    - The number of hundredths of seconds to wait      ***\n***               between succeeding SEND commands.                ***\n***                                                                ***\n**********************************************************************\n         EJECT ,                                                   -EU-\nNOTICE   START 0                                                   -EU-\n         SPACE 1\n**********************************************************************\n***                                                                ***\n***  Syntax -                                                      ***\n***                                                                ***\n***  NOTICE  CLEAR(NN)  BROADCAST(dsname)                          ***\n***          CL(NN)     BC(DSNAME)                                 ***\n***          NOCLEAR    NOBROADCAST                                ***\n***          NOCL       NOBC                                       ***\n***          LIST                                                  ***\n***          TEST                                                  ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\n**********************************************************************\n***                                                                ***\n***  The NOTICE command is an interface between TSO and SVC-34,    ***\n***  the console operator SVC.                                     ***\n***                                                                ***\n***  NOTICE reads text from a data-set, then builds and executes   ***\n***  operator SEND 'text',SAVE commands. When reading entries from ***\n***  the input data-set, NOTICE will process start/stop dates      ***\n***  for individual items.                                         ***\n***                                                                ***\n***  The CLEAR and BROADCAST functions of NOTICE require special   ***\n***  privilege (OPERATOR). Only a scan of the input data-set is    ***\n***  allowed to all other users of 'NOTICE' (LIST or TEST).        ***\n***                                                                ***\n**********************************************************************\n         EJECT\n**********************************************************************\n***                                                                ***\n***  ASM options :  RENT                                           ***\n***                                                                ***\n***  LKED options : RENT                                           ***\n***                                                                ***\n***  Return codes : 04 - A. Error in parsing operands.             ***\n***                      B. Error in dynamic allocation.           ***\n***                      C. ABEND was trapped by the command.      ***\n***                 00 - Anything else.                            ***\n***                                                                ***\n***  Register Usage :                                              ***\n***      R0-R1 - Linkage conventions, macros, work registers.      ***\n***      R2-R3 - Macros, work registers.                           ***\n***      R4-R6 - Work registers.                                   ***\n***         R7 - (unused)                                          ***\n***         R8 - (unused)                                          ***\n***         R9 - Base of PARMPDL, returned by IKJPARS.             ***\n***        R10 - BAS register.                                     ***\n***        R11 - Second base register (NOTICE)                     ***\n***        R12 - First base register (NOTICE+4096)                 ***\n***        R13 - Linkage conventions, base of WORKD work area.     ***\n***    R14-R15 - Linkage conventions, macros, work registers.      ***\n***                                                                ***\n***                                                                ***\n***  Non-IBM macros used :                                         ***\n***    GTEDADAT - Creates dynamic allocation control blocks.       ***\n***    GTEDASET - Links together control blocks created by         ***\n***               GTEDADAT.                                        ***\n***    GTEDAALC - Executes dynamic allocation using control        ***\n***               blocks created by GTEDADAT and linked together   ***\n***               by GTEDASET.                                     ***\n***    GTEDADOC - Not actually used.  This macro is documentation  ***\n***               for the other GTEDAxxx macros.                   ***\n***                                                                ***\n**********************************************************************\n         EJECT ,                                                   -EU-\n         LCLC  &SYSBC,&WAIT        DEFINE LOCAL CONSTANTS\n         SPACE 1                                                   -EU-\n&SYSBC   SETC  '->.OPER.NOTICES.DATA'   SYSTEM NOTICES DSN (DSORG=PS)\n&WAIT    SETC  '020'               NO OF 100THS OF SECONDS WAIT\n         SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *  -EU-\n*        AUTHORITY LEVELS DEFINITIONS.                          *  -EU-\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *  -EU-\n         SPACE 1                                                   -EU-\nLVL10    EQU   10        OPERATORS LEVEL                           -EU-\n         SPACE 1                                                   -EU-\n        $MDL@IX ,                                                  -EU-\n         SPACE 2                                                   -EU-\n        $DEFREG ,                                                  -EU-\n         EJECT\n**********************************************************************\n***                                                                ***\n***   PROLOG                                                       ***\n***                                                                ***\n***     1.  Linkage conventions and addressability.                ***\n***     2.  Clear the completion code                              ***\n***     3.  Save the pointer to the CPPL.                          ***\n***     4.  Get caller authority value.                        -EU-***\n***                                                                ***\n**********************************************************************\n         SPACE 1\n        $XENT  BASE=(R11,R12),LV=WORKDLEN,TYPE=RENT                -EU-\n         EJECT ,                                                   -EU-\n         LR    R8,R13              ADDRESSABILITY                  -EU-\n         USING WORKD,R8              OF WORK AREA                  -EU-\n         USING PARMPDL,R9          ADDRESSABILITY OF PDE LIST\n         XC    COMPCODE,COMPCODE   CLEAR COMPLETION CODE TO ZERO\n         ST    R1,CPPLPTR          SAVE CPPL POINTER\n         XC    AUTH(REQAUTL),AUTH  get caller authority            -EU-\n         LA    R1,AUTH                                             -EU-\n         ST    R1,REQAUT+4                                         -EU-\n         MVC   REQAUT+1(3),MOD@IX                                  -EU-\n        $EACM  REQAUT                                              -EU-\n         EJECT\n**********************************************************************\n***                                                                ***\n***   MAIN LINE ROUTINE                                            ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\n         BAS   R10,ABEND           SET UP ABEND EXIT\n         BAS   R10,PPLSETUP        SET UP PARSE PARM LIST\n         BAS   R10,PARSE           PARSE THE INPUT PARAMETERS\n         CLC   RETCDE(4),F0        IF RETURN CODE IS BAD\n         BNE   ENDING04              GO TO CC=4 ENDING\n         BAS   R10,DSNALLOC        ALLOCATE THE INPUT DSNAME\n         CLC   RETCDE(4),F0        IF RETURN CODE IS BAD\n         BE    MACLEAR               THEN\n         MVC   COMPCODE(4),F4          SET CC=4\n         B     MAUNALC             GO TO UNALLOCATION\nMACLEAR  BAS   R10,CLEAR           CLEAR THE OLD MESSAGES\n         BAS   R10,BC              SEND BROADCAST MESSAGES\nMAUNALC  BAS   R10,UNALLOC         UNALLOCATE THE FILE NAMES\n         B     ENDING              BRANCH TO ENDING\n         EJECT\n**********************************************************************\n***                                                                ***\n***   EPILOG                                                       ***\n***                                                                ***\n***     1.  Release storage used by IKJPARS.                       ***\n***     2.  Linkage conventions.                                   ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\nENDING04 LA       R15,X'04'(0,0)   RETURN CODE TO R15\n         ST       R15,COMPCODE     SAVE IN COMPLETION CODE\n         SPACE 1\nENDING   LA       R2,MYPPL+(PPLANS-PPL) ADDRESS OF PTR TO PDL\n         L        R2,0(0,R2)       R4 POINTS TO PDL\n         IKJRLSA  (R2)             FREE STORAGE OF PDL\n         ESTAE    0                CANCEL THE ABEND EXIT\n         L        R2,COMPCODE      R2 TEMPORARILY HAS COMP CODE\n        $XRET     CC=(R2),LV=WORKDLEN,TYPE=RENT   RETURN           -EU-\n         EJECT\n**********************************************************************\n***                                                                ***\n***   SET UP EXIT FOR ABENDS                                       ***\n***                                                                ***\n***  Use ESTAE to set up an environment to trap ABENDs.            ***\n***                                                                ***\n***  1.  The exit is ESTXIT.                                       ***\n***  2.  The return point is at label ENDING04 in main routine.    ***\n***  3.  The parm list passed to the exit will be:                 ***\n***                                                                ***\n***         ESTUPL                                                 ***\n***         +-----------+                                          ***\n***         |           |==> Return point                          ***\n***         +-----------+                                          ***\n***         |           |==> User work area                        ***\n***         +-----------+    +-----------+                         ***\n***                          | Register  |                         ***\n***                          | save area |                         ***\n***                         ---         ---                        ***\n***                         ---         ---                        ***\n***                          |           |                         ***\n***                          +-----------+                         ***\n***                          | Other data|                         ***\n***                          +-----------+                         ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\nABEND    ST    R10,ABRBALSV        SAVE RETURN ADDRESS\n         XC    RETCDE,RETCDE       SET ERROR CODE TO ZERO\n         MVC   ESTAEL(ESTAELLN),ESTAED  INITIALIZE ESTAE PARM LIST\n         LA    R15,ENDING04        ADDRESS OF RETURN POINT\n         ST    R15,ESTUPL            INTO USER PARM LIST\n         LA    R15,ESTUWK          ADDRESS OF USER WORK AREA\n         ST    R15,ESTUPL+4          INTO USER PARM LIST\n         LA    R4,ESTUPL           R4 HAS ADDRESS OF USER PARM LST\n         L     R5,VESTXIT          R5 HAS ADDRESS OF ESTAE EXIT\n         ESTAE (R5),PARAM=(R4),MF=(E,ESTAEL) EXECUTE ESTAE\n         L     R10,ABRBALSV        RESTORE RETURN ADDRESS\n         BR    R10                 RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   CREATE PARSE PARAMETER LIST AND I/O PARM LIST                ***\n***                                                                ***\n***        PARSE                                                   ***\n***          1.  Copy addresses of UPT, ECT and CBUF from CPPL.    ***\n***          2.  Add addresses of own ECB, ANS and UWA, and        ***\n***              address of PCE List (PCL) created by macros.      ***\n***                                                                ***\n***        I/O                                                     ***\n***          1.  Copy addresses of UPT and ECT from CPPL.          ***\n***          2.  Add address of own I/O ECB.                       ***\n***          3.  Zero the IOPLIOPB pointer.  This will point to    ***\n***              the parm block for the appropriate I/O routine.   ***\n***              It will be filled in by the execute form of the   ***\n***              STACK, GETLINE, PUTLINE or PUTGET macro when      ***\n***              executed.                                         ***\n**********************************************************************\n         SPACE 1\nPPLSETUP ST    R10,PPRBALSV        SAVE RETURN ADDRESS\n         XC    RETCDE,RETCDE       SET ERROR CODE TO ZERO\n         L     R4,CPPLPTR          ADDRESS OF CMD PROC PARM LIST\n         USING CPPL,R4               ADDRESSABILITY\n         LA    R6,MYPPL            ADDRESS OF MY PARSE PARM LIST\n         USING PPL,R6                ADDRESSABILITY\n         MVC   PPLUPT(4),CPPLUPT   UPT  (CPPL)\n         MVC   PPLECT(4),CPPLECT   ECT  (CPPL)\n         LA    R5,MYECB\n         ST    R5,PPLECB           ECB  (MINE)\n         MVC   PPLPCL(4),VPARMPCL  PCL  (CSECT)\n         LA    R5,MYANS\n         ST    R5,PPLANS           ANS  (MINE)\n         MVC   PPLCBUF(4),CPPLCBUF      CBUF (CPPL)\n         LA    R5,MYUWA\n         ST    R5,PPLUWA           UWA  (MINE)\n         DROP  R6                  DROP ADDRESSABILITY\n         LA    R6,MYIOPL           ADDRESS OF MY IO PARM LIST\n         USING IOPL,R6               ADDRESSABILITY\n         MVC   IOPLUPT(4),CPPLUPT  UPT  (CPPL)\n         MVC   IOPLECT(4),CPPLECT  ECT  (CPPL)\n         LA    R15,MYIOECB\n         ST    R15,IOPLECB         ECB  (MINE)\n         XC    IOPLIOPB(4),IOPLIOPB     IOPB (0000)\n         DROP  R4,R6\n         L     R10,PPRBALSV        RESTORE RETURN ADDRESS\n         BR    R10                 RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   PARSE THE INPUT PARAMETER STRING                             ***\n***                                                                ***\n***      1.  Execute IKJPARS with CALLTSSR using own PPL.          ***\n***      2.  Load address of Parm Descriptor Element List (PDL)    ***\n***          from own ANS word into R9 for addressability.         ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\nPARSE    ST    R10,PARBALSV        SAVE RETURN ADDRESS\n         XC    RETCDE,RETCDE       SET ERROR CODE TO ZERO\n         XC    MYECB,MYECB         ZERO THE ECB FOR PARSE\n         CALLTSSR EP=IKJPARS,MF=(E,MYPPL)    PARSE THE PARMS\n         L     R9,MYPPL+(PPLANS-PPL)    POINTER TO PDL ADDRESS\n         L     R9,0(0,R9)          ADDRESSABILITY OF PDL\n         L     R10,PARBALSV        RESTORE RETURN ADDRESS\n         BR    R10                 RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   ALLOCATE THE INPUT DSNAME WITH GTEDAxxx                      ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\nDSNALLOC ST    R10,DSRBALSV        SAVE RETURN ADDRESS\n         XC    RETCDE,RETCDE       SET ERROR CODE TO ZERO\n         TM    KEYBC+1,X'01'       IF NOT USING BC KEYWORD\n         BNO   DSEND                 GO TO NEXT ROUTINE\n         MVC   DSDDNAM1(8),DSDDNAM DUMMY DDNAME TO SAVE AREA\n         MVC   MY1(MY1LEN),@M1     INITIALIZE SVC-99 CONTROL BLOCKS\n         GTEDASET MY1,CPPLPTR=CPPLPTR   LINK BLOCKS TOGETHER\n         L     R4,SBCDSN           R4 POINTS TO BC-DSN\n         LH    R5,SBCDSN+4         R5 HAS LENGTH\n         BCTR  R5,0                  MINUS 1 FOR EXEC\n         B     *+L'*+6             BRANCH AROUND MOVE\n         MVC   MY1DSNAM(*-*),0(R4) MOVE DSNAME TO T.U.\n         EX    R5,*-6              EXECUTE THE MOVE\n         TM    SBCDSN+14,X'80'     IF MEMBER NAME NOT USED\n         BNO   DSDSNBCX              BRANCH AROUND\n         L     R4,SBCDSN+8         R4 POINTS TO BC-MEMBNAME\n         LH    R5,SBCDSN+12        R5 HAS LENGTH\n         BCTR  R5,0                  MINUS 1 FOR EXEC\n         B     *+L'*+6             BRANCH AROUND MOVE\n         MVC   MY1MEMBR(*-*),0(R4) MOVE MEMBER NAME TO T.U.\n         EX    R5,*-6              EXECUTE THE MOVE\n         B     DSNALC1             BRANCH TO ALLOCATE\nDSDSNBCX XC    MY1MEMKY(2),MY1MEMKY     NO MEMBER, ZERO THE KEY\nDSNALC1  GTEDAALC MY1,VERB=AL,ERRMSG=YES     PERFORM SVC-99/DAIRFAIL\n         MVC   DSDDNAM1(8),MY1RTDDN     SAVE THE RETURNED DDNAME\n         CLC   MY1S99RC,F0         IF SVC-99 R/C ZERO\n         BE    DSEND                 GO TO END\n         LA    R15,X'04'(0,0)      SET ERROR VALUE\n         ST    R15,RETCDE            INTO INTERNAL RETURN CODE\nDSEND    L     R10,DSRBALSV        RESTORE RETURN ADDRESS\n         BR    R10                 RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   If the CLEAR keyword has been used, clear old messages.      ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\nCLEAR    ST    R10,CLRBALSV        SAVE RETURN ADDRESS\n         XC    RETCDE,RETCDE       SET ERROR CODE TO ZERO\n         LH    R1,KEYC             IF CLEAR/... KEYWORD            -EU-\n         LTR   R1,R1                 IS NOT USED                   -EU-\n         BZ    CLEND                   GO TO END OF ROUTINE        -EU-\n         BCT   R1,CLEND            IF NOT CLEAR, GO TO END         -EU-\n         CLI   AUTH,LVL10          OPERATOR LEVEL ?                -EU-\n         BNL   CLOPERXN              YES, BRANCH TO CONTINUE       -EU-\n         LA    R15,PU0003              ELSE SELECT MESSAGE #3      -EU-\n         BAS   R10,PUTLPROC              WRITE IT\n         B     CLRET04             GO TO R/C=4 ENDING\nCLOPERXN L     R3,SC               R3 POINTS TO CLEAR COUNT\n         L     R3,0(0,R3)          R3 CONTAINS BINARY COUNT\n         LTR   R3,R3               IF COUNT NOT POSITIVE\n         BP    CLMSGNO               THEN\n         LA    R15,PU0007              SELECT MESSAGE #7           -EU-\n         BAS   R10,PUTLPROC            WRITE THE MESSAGE\n         LA    R15,PU0000              SELECT BLANK LINE           -EU-\n         BAS   R10,PUTLPROC            WRITE THE MESSAGE\n         B     CLRET04                 GO TO RC=4 ENDING\nCLMSGNO  XR    R4,R4               CLEAR R4 MSG NUMBER\nCLLOOP1  LA    R4,1(0,R4)          INCR MSG NUMBER BY 1, BINARY\n         CVD   R4,CLDOUBLE         CLDOUBLE HAS MSG NUMBER PACK\n         OI    CLDOUBLE+7,X'0F'    KILL THE SIGN\n         UNPK  CLZONE(3),CLDOUBLE+6(2)  CLZONE HAS MSG NUMBER ZD\n         MVC   CLCMD(18),@CLCMD    INITIALIZE THE COMMAND\n         MVC   CLCMD+9(2),CLZONE+1 INSERT THE MSG NUMBER\n        ZEROKEY ,                                                  -EU-\n         LA    R1,CLCMD            POINT TO THE COMMAND FOR SVC-34\n         XR    R0,R0               CLEAR R0 FOR SVC-34\n         SVC   34                  OPERATOR\n        RESETKEY ,                                                 -EU-\n         STIMER WAIT,BINTVL=BIWAITIM    WAIT A LITTLE BIT\n         BCT   R3,CLLOOP1          LOOP BACK UP\n         LA    R15,PU0002          SELECT MESSAGE #2               -EU-\n         BAS   R10,PUTLPROC        WRITE THE MESSAGE\n         LA    R15,PU0000          SELECT BLANK LINE               -EU-\n         BAS   R10,PUTLPROC        WRITE THE MESSAGE\n         B     CLEND\nCLRET04  LA    R15,X'04'           RETURN CODE TO R15\n         ST    R15,RETCDE          SAVE IT\nCLEND    L     R10,CLRBALSV        RESTORE RETURN ADDRESS\n         BR    R10                 RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   Execute the operator SEND command.                           ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\nBC       ST    R10,BCRBALSV        SAVE RETURN ADDRESS\n         XC    RETCDE,RETCDE       SET ERROR CODE TO ZERO\n         TM    KEYBC+1,X'01'       IF BROADCAST KEYWORD NOT USED\n         BNO   BCEND                 BYPASS THE WHOLE ROUTINE\n         TIME  ,                   R1 GETS 00YYDDDF\n         ST    R1,BCYYDDD          SAVE IT\n         NI    BCYYDDD+3,X'FC'     SET POSITIVE SIGN\n         MVC   LOYYDDD,P0          INITIALIZE LOW YYDDD\n         MVC   HIYYDDD,P99365      INITIALIZE HIGH YYDDD\n         XC    BITEXTWK(8),BITEXTWK     INITIALIZE TEXT WORK SAVE AREA\n         MVC   BCDCB(BCDCBL),@BCDCB     INITIALIZE DCB\n         MVC   BCDCB+(DCBDDNAM-IHADCB)(8),DSDDNAM1 INITIALIZE DDN\n         MVC   OPENL(OPENLLEN),@OPENL   INITIALIZE OPEN PARM LIST\n         LA    R4,BCDCB            POINT TO DCB\n         OPEN  ((R4),INPUT),MF=(E,OPENL)     OPEN THE FILE\n         TM    (DCBRECFM-IHADCB)(R4),DCBRECF IF RECFM NOT FIXED\n         BNO   BCBADFIL                        OR\n         CLC   (DCBLRECL-IHADCB)(2,R4),H80   IF LRECL NOT 80\n         BNE   BCBADFIL                        GO TO ERROR ROUTINE\nBCIO     BAS   R10,BIO             PERFORM IO ROUTINE\n         TM    BISWITCH,X'80'      END OF FILE ?\n         BZ    BCIO                NO, LOOP UP TILL END OF FILE\n         MVC   CLOSL(CLOSLLEN),@CLOSL   INITIALIZE CLOSE PARM LIST\n         LA    R4,BCDCB            POINT TO DCB\n         CLOSE ((R4)),MF=(E,CLOSL) CLOSE THE FILE\n         B     BCEND\nBCBADFIL LA    R15,PU0004          SELECT MESSAGE #4               -EU-\n         BAS   R10,PUTLPROC        WRITE THE MESSAGE\nBCRET04  LA    R15,X'04'           RETURN CODE TO R15\n         ST    R15,RETCDE          SAVE IT\nBCEND    L     R10,BCRBALSV        RESTORE RETURN ADDRESS\n         BR    R10                 RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   UNALLOCATE FILE NAME                                         ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\nUNALLOC  ST    R10,UNRBALSV        SAVE RETURN ADDRESS\n         XC    RETCDE,RETCDE       SET ERROR CODE TO ZERO\n         TM    KEYBC+1,X'01'       IF BROADCAST KEYWORD NOT USED  -EU-\n         BNO   UNEND                 BYPASS THE WHOLE ROUTINE     -EU-\n         MVC   MY0(MY0LEN),@M0     INITIALIZE SVC-99 CONTROL BLOCKS\n         GTEDASET MY0,CPPLPTR=CPPLPTR   LINK BLOCKS TOGETHER\n         MVC   MY0DDNAM(8),DSDDNAM1     DDNAME TO T.U.\n         GTEDAALC MY0,VERB=UN,ERRMSG=NO PERFORM SVC-99/DAIRFAIL\nUNEND    L     R10,UNRBALSV        RESTORE RETURN ADDRESS\n         BR    R10                 RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   Transfer BROADCAST input to output.                          ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\nBIO      ST    R10,BIRBALSV        SAVE RETURN ADDRESS\n         XC    RETCDE,RETCDE       SET ERROR CODE TO ZERO\n         LA    R4,BCDCB            POINT TO DCB\n         NI    BISWITCH,X'7F'      INITIALIZE EOF SWITCH OFF\n         GET   (R4),BITEXT         GET INPUT\n         BAS   R10,ETEXT           EDIT THE INPUT\n         CLC   RETCDE(4),F0        IF NOT PRINT RETURN CODE\n         BNE   BIEND                 GO TO ENDING\n         B     BIMSG               BRANCH AROUND EOF ROUTINE\nBIEOF    OI    BISWITCH,X'80'      SET EOF SWITCH ON\n         CLC   BITEXTWK(5),ETENDE  IF PREV USED CARD WAS '-END '\n         BE    BIEND                 GO TO ENDING\n         CLI   BITEXTWK,X'00'      IF NO PREV CARD WAS USED\n         BE    BIEND                 GO TO ENDING\n         MVC   BIMAIN(85),@BIHYPH  INITIALIZE COMMAND\n         LA    R1,BIMAIN+81                                        -EU-\n         ST    R1,APPOS                                            -EU-\nBIMSG    MVC   MSG0001B(2),H73     SET MESSAGE SEGMENT LENGTH\n         MVC   MSG0001B+2(2),H9    SET MESSAGE SEGMENT OFFSET\n         CLC   ETTEXTWK(5),ETENDE  IF IT IS '-END' CARD            -EU-\n         BNE   *+L'*+10                                            -EU-\n         MVC   MSG0001B+4(69),BIDATA-2  SET HYPHENS                -EU-\n         B     *+L'*+18                                            -EU-\n         MVC   MSG0001B+4(2),BIDATA-2   OTHERWISE ORIGINAL TEXT    -EU-\n         MVC   MSG0001B+6(65),BITEXT+1    (BIDATA IS EXPANDED BY   -EU-\n         MVC   MSG0001B+71(2),APSENDSV      APOST IN ETEXT)        -EU-\n         LA    R15,PU0001          SELECT MESSAGE #1               -EU-\n         BAS   R10,PUTLPROC        WRITE THE MESSAGE\n         LH    R4,BIMAIN           R4 HAS LENGTH OF SEND COMMAND\n         C     R4,F133             IF LENGTH NOT GREATER THAN 133\n         BNH   BICMD                 GO EXECUTE THE COMMAND\n         LA    R15,PU0006          ELSE SELECT MESSAGE #6          -EU-\n         BAS   R10,PUTLPROC          WRITE IT\n         LA    R15,PU0000            SELECT BLANK LINE             -EU-\n         BAS   R10,PUTLPROC          WRITE IT\n         B     BIRET04               GO TO HIGH RETURN\nBICMD    CLI   AUTH,LVL10          OPERATOR LEVEL ?                -EU-\n         BL    BILIST                NO, JUST LIST                 -EU-\n         LH    R1,KEYC             IF CLEAR/... KEYWORD            -EU-\n         LTR   R1,R1                 IS NOT USED                   -EU-\n         BNZ   BITCMD                  YES, GO TO SEE WHAT         -EU-\nBILIST   MVC   BITEXTWK(8),ETTEXTWK     SAVE THE TEXT WORK AREA    -EU-\n         XC    BIRC,BIRC           SET ZERO RETURN CODE            -EU-\n         B     BIEND               GO TO ENDING                    -EU-\nBITCMD   BCT   R1,*+L'*+4          IS IT CLEAR REQUEST ?           -EU-\n         B     BISCMD                YES, GO TO SEND COMMAND       -EU-\n         BCT   R1,BILIST           GO TO JUST LIST IF NOT NOCLEAR  -EU-\n         L     R1,APPOS            WHEN NOCLEAR, CHANGE SAVE       -EU-\n         MVC   0(5,R1),APLOGON       BY LOGON TO SEND COMMAND      -EU-\n         LH    R1,BIMAIN           COMMAND LENGTH IS NOW +1        -EU-\n         LA    R1,1(R1)                                            -EU-\n         STH   R1,BIMAIN                                           -EU-\nBISCMD  ZEROKEY ,                                                  -EU-\n         LA    R1,BIMAIN           POINT TO COMMAND\n         XR    R0,R0               CLEAR R0 FOR SVC-34\n         SVC   34                  EXECUTE CONSOLE SVC\n         ST    R15,BIRC            SAVE THE RETURN CODE\n        RESETKEY ,                                                 -EU-\n         MVC   BITEXTWK(8),ETTEXTWK     SAVE THE TEXT WORK AREA\n         STIMER WAIT,BINTVL=BIWAITIM    WAIT FOR A LITTLE\n         B     BIEND               GO TO ENDING\nBIRET04  LA    R15,X'04'           RETURN CODE TO R15\n         ST    R15,RETCDE          SAVE IT\nBIEND    L     R10,BIRBALSV        RESTORE RETURN ADDRESS\n         BR    R10                 RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   Edit the text.                                               ***\n***                                                                ***\n***   1. Process control cards.                                    ***\n***                                                                ***\n***     The card type is designated by characters in the beginning ***\n***     of the card image. Types can be in lower/UPPER case.       ***\n***                                                                ***\n***     '*'      = Comment.                                        ***\n***     '-com'   = Comment.                                        ***\n***     '-dates' = DD/MM/YY dates for message to begin and end -EU-***\n***                or set the word 'current' to indicate the   -EU-***\n***                message(s) permanent status.                -EU-***\n***                (Default is the previous -dates card.)          ***\n***     blank    = Message text (65-bytes, beginning with col. 2). ***\n***     '-end'   = End of message text (causes line of hyphens).   ***\n***                                                                ***\n***   2. Expand apostrophes to double apostrophes in text.         ***\n***   3. Set RETCDE :                                              ***\n***        00 - Convert this to a SEND command.                    ***\n***        04 - Don't convert this to a SEND command.              ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\nETEXT    ST    R10,ETRBALSV        SAVE RETURN ADDRESS\n         XC    RETCDE,RETCDE       SET ERROR CODE TO ZERO\n         MVC   ETTEXTWK(8),BITEXT  GET FIRST 8 CHARACTERS TO WORK\n         OC    ETTEXTWK(8),BLANKS  SHIFT TO UPPER CASE\n         CLI   ETTEXTWK,C' '       IF IT BEGINS WITH A BLANK\n         BE    ETTEXT                GO PROCESS THE TEXT CARD\n         CLC   ETTEXTWK(7),ETDATES IF IT IS A '-DATES ' CARD\n         BE    ETDATE                GO PROCESS THE DATE CARD\n         CLC   ETTEXTWK(5),ETENDE  IF IT IS A '-END' CARD\n         BE    ETEOD                 GO PROCESS THE EOD CARD\n         CLI   ETTEXTWK,C'*'       IF IT IS A '*' CARD\n         BE    ETRET04               OR\n         CLC   ETTEXTWK(5),ETCOM   IF IT IS A '-COM ' CARD\n         BE    ETRET04               GO TO NO-SEND RETURN\n*                                  IF NO MATCH ABOVE\n         B     ETRET04               GO TO NO-SEND RETURN\nETTEXT   CP    LOYYDDD(4),BCYYDDD  IF LOW DATE HIGHER THAN CURRENT\n         BH    ETRET04               GO TO NO-SEND RETURN\n         CP    HIYYDDD(4),BCYYDDD  IF HIGH DATE LESS THAN CURRENT\n         BL    ETRET04               GO TO NO-SEND RETURN\n         MVC   BIMAIN(85),@BIMAIN  INITIALIZE COMMAND\n         MVC   BIDATA(65),BITEXT+1 MOVE TEXT TO OUTPUT AREA\n         BAS   R10,APOST           EXPAND TEXT APOSTROPHES\n         B     ETEND               ELSE GO TO SEND RETURN\nETEOD    CP    LOYYDDD(4),BCYYDDD  IF LOW DATE HIGHER THAN CURRENT\n         BH    ETRET04               GO TO NO-SEND RETURN\n         CP    HIYYDDD(4),BCYYDDD  IF HIGH DATE LESS THAN CURRENT\n         BL    ETRET04               GO TO NO-SEND RETURN\n         MVC   BIMAIN(85),@BIHYPH  INITIALIZE COMMAND\n         LA    R1,BIMAIN+81                                        -EU-\n         ST    R1,APPOS                                            -EU-\n         B     ETEND               GO TO SEND RETURN\nETDATE   LA    R5,BITEXT+50        MAX. RANGE FOR SEARCH DATES     -EU-\n         LA    R4,BITEXT+7         SEARCH START OF BEGIN DATE      -EU-\nETDATEBS CLI   0(R4),C' '                                          -EU-\n         BNE   ETDATEB                                             -EU-\n         LA    R4,1(R4)                                            -EU-\n         CLR   R4,R5                                               -EU-\n         BNH   ETDATEBS                                            -EU-\nETDATERS LA    R15,PU0000          SELECT BLANK LINE               -EU-\n         BAS   R10,PUTLPROC          WRITE IT                      -EU-\n         LA    R15,PU0008          SELECT MESSAGE #8               -EU-\n         BAS   R10,PUTLPROC          WRITE IT                      -EU-\n         LA    R15,PU0000          SELECT BLANK LINE               -EU-\n         BAS   R10,PUTLPROC          WRITE IT                      -EU-\n         B     ETRET04             BRANCH TO NO-SEND RETURN        -EU-\nETDATEB  MVC   DATEWORK(8),0(R4)   MOVE BEGIN DATE TO WORK AREA    -EU-\n         OC    DATEWORK(8),BLANKS  UPPERCASE                       -EU-\n         CLC   DATEWORK(8),DACURR  CURRENT DATE REQUESTED ?        -EU-\n         BNE   ETDATEBP            NO                              -EU-\n         MVC   LOYYDDD(4),BCYYDDD  MOVE THE CURRENT DATE           -EU-\n         MVC   HIYYDDD(4),BCYYDDD                                  -EU-\n         B     ETRET04             BRANCH TO NO-SEND RETURN        -EU-\nETDATEBP MVC   DATE(8),0(R4)       MOVE BEGIN DATE TO WORK AREA    -EU-\n         MVC   DADD(2),0(R4)         (BUT WE USE THE               -EU-\n         MVC   DAMM(2),3(R4)           EUROPEAN FORMAT - DD/MM/YY) -EU-\n         BAS   R10,DATECONV        CONVERT TO 00YYDDDC\n         CLC   RETCDE(4),F0        IF BAD RETURN\n         BNE   ETDATERR              GO TO ERROR ROUTINE\n         MVC   LOYYDDD(4),DATEPACK ELSE MOVE TO STORAGE\n         LA    R4,8(R4)            LOOK TO FIND ENDING DATE        -EU-\n         CLR   R4,R5                 (AT LEAST ONE BLANK           -EU-\n         BH    ETDATERS                MUST BE PRESENT AS          -EU-\n         CLI   0(R4),C' '                SEPARATOR)                -EU-\n         BNE   ETDATERS                                            -EU-\n         LA    R4,1(R4)                                            -EU-\nETDATEES CLI   0(R4),C' '                                          -EU-\n         BNE   ETDATEE                                             -EU-\n         LA    R4,1(R4)                                            -EU-\n         CLR   R4,R5                                               -EU-\n         BNH   ETDATEES                                            -EU-\n         B     ETDATERS                                            -EU-\nETDATEE  MVC   DATE(8),0(R4)       MOVE END DATE TO WORK AREA      -EU-\n         MVC   DADD(2),0(R4)         (BUT WE USE THE               -EU-\n         MVC   DAMM(2),3(R4)           EUROPEAN FORMAT - DD/MM/YY) -EU-\n         BAS   R10,DATECONV        CONVERT TO 00YYDDDC\n         CLC   RETCDE(4),F0        IF BAD RETURN\n         BNE   ETDATERR              GO TO ERROR ROUTINE\n         MVC   HIYYDDD(4),DATEPACK ELSE MOVE TO STORAGE\n         B     ETRET04             BRANCH TO NO-SEND RETURN\nETDATERR MVC   MSG0005B(13),WRK0005B    INITIALIZE MESSAGE SEGMENT\n         MVC   MSG0005B+4(8),DATE  MOVE BAD DATE INTO SEGMENT\n         MVC   MSG0005B+4(2),DADD    (BUT WE USE THE               -EU-\n         MVC   MSG0005B+7(2),DAMM      EUROPEAN FORMAT - DD/MM/YY) -EU-\n         MVC   LOYYDDD(4),BCYYDDD  MOVE CURRENT DATE TO START DATE\n         MVC   HIYYDDD(4),BCYYDDD    AND TO END DATE\n         LA    R15,PU0000          SELECT BLANK LINE               -EU-\n         BAS   R10,PUTLPROC          WRITE IT\n         LA    R15,PU0005          SELECT MESSAGE #5               -EU-\n         BAS   R10,PUTLPROC          WRITE IT\n         LA    R15,PU0000          SELECT BLANK LINE               -EU-\n         BAS   R10,PUTLPROC          WRITE IT\nETRET04  LA    R15,X'04'           RETURN CODE TO R15\n         ST    R15,RETCDE          SAVE IT\nETEND    L     R10,ETRBALSV        RESTORE RETURN ADDRESS\n         BR    R10                 RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   Expand single apostrophes to double apostrophes.             ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\nAPOST    ST    R10,APRBALSV        SAVE RETURN ADDRESS\n         XC    RETCDE,RETCDE       SET ERROR CODE TO ZERO\n         LA    R3,BIDATA-1         R3 POINTS TO TEXT-1\n         LA    R4,65(0,R3)         R4 POINTS TO LAST TEXT CHAR\n         LA    R1,65(0,0)          R1 IS COUNTER FOR OUTER LOOP\nAPLOOP1  LA    R3,1(0,R3)          R3 POINTS TO NEXT CHAR\n         CLI   0(R3),X'7D'         IF NOT APOSTROPHE\n         BNE   APLOOP1X              GO TO OUTER LOOP END\n         LR    R2,R1               R2 IS INNER LOOP COUNTER\n         LR    R5,R4               R5 IS INNER LOOP POINTER\n         LA    R4,1(0,R4)          R4 POINTS TO NEW LAST CHAR\nAPLOOP2  MVC   1(1,R5),0(R5)       COPY FROM CHAR TO CHAR+1\n         BCTR  R5,0                DECR POINTER BY ONE\n         BCT   R2,APLOOP2          LOOP BACK UP TO INNER LOOP\n         LA    R3,1(0,R3)          MOVE POINTER TO 'NEW' APOST\nAPLOOP1X BCT   R1,APLOOP1          LOOP BACK UP TO OUTER LOOP\n         LA    R1,5(R4)                                            -EU-\n         ST    R1,APPOS                                            -EU-\n         MVC   1(8,R4),APSENDSV    MOVE B-,'SAVE TO SEND COMMAND\n         LA    R4,9(0,R4)          R4 POINTS JUST BEYOND LAST CHAR\n         LA    R1,BIMAIN           R1 POINTS TO SEND COMMAND LEN\n         SR    R4,R1               R4 IS LENGTH OF COMMAND\n         STH   R4,BIMAIN           SAVE LEN IN COMMAND BUFFER\n         L     R10,APRBALSV        RESTORE RETURN ADDRESS\n         BR    R10                 RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   Convert MM/DD/YY (ZD) to 00YYDDDC (packed)                   ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\nDATECONV ST    R10,DARBALSV        SAVE RETURN ADDRESS\n         XC    RETCDE,RETCDE       SET ERROR CODE TO ZERO\n         XC    DATEPACK,DATEPACK   ZERO THE RETURN DATE\n         MVC   DATEWORK(8),DATE    COPY DATE TO TEST AREA\n         NC    DATEWORK(8),DATSTPAT     'AND' IT WITH TEST PATTERN\n         CLC   DATEWORK(8),DARESPAT     IF RESULT IS NOT '00/00/00'\n         BNE   DARET04                    GO TO HIGH RETURN\n         NI    DASWITCH,X'7F'      TURN OFF LEAP YEAR SWITCH\n         PACK  DADOUBLE(8),DAYY(2) CONVERT TO 00000000 00000YYF\n         MVC   DAYYPACK(4),DATEPACK     SAVE IT\n         CVB   R3,DADOUBLE         R3 HAS BINARY YEAR\n         XR    R2,R2               CLEAR R2 FOR DIVIDE\n         D     R2,F4               CHECK FOR LEAP YEAR\n         LTR   R2,R2               IF LEAP YEAR\n         BNZ   *+L'*+4               THEN\n         OI    DASWITCH,X'80'          TURN ON LEAP YEAR SWITCH\n         CLC   DAMM(2),ZD12        IF MM GREATER THAN 12\n         BNH   *+L'*+10              THEN\n         XC    DATEPACK,DATEPACK       ZERO THE RETURN DATE\n         B     DARET04                   AND GO TO HIGH RETURN\n         PACK  DADOUBLE(8),DAMM(2) CONVERT TO 00000000 00000MMF\n         CVB   R3,DADOUBLE         R3 HAS BINARY MONTH 1 TO 12\n         BCTR  R3,0                R3 IS BINARY 0 TO 11\n         SLL   R3,1                R3 IS OFFSET INTO TABLE\n         TM    DASWITCH,X'80'      IF LEAP YEAR\n         BNO   *+L'*+8               THEN\n         LA    R2,DALEAPTB             R2 HAS ADDR OF LEAP TABLE\n         B     *+L'*+4             ELSE\n         LA    R2,DAREGTB            R2 HAS ADDR OF REGULAR TBL\n         LH    R2,0(R3,R2)         R2 HAS DDD FOR DAY 0 OF MONTH\n         CLC   DADD(2),ZD31        IF DD GREATER THAN 31\n         BNH   *+L'*+10              THEN\n         XC    DATEPACK,DATEPACK       ZERO THE RETURN DATE\n         B     DARET04                   AND GO TO HIGH RETURN\n         PACK  DADOUBLE(8),DADD(2) CONVERT TO 00000000 00000DDF\n         CVB   R3,DADOUBLE         R3 HAS BINARY DAY OF MONTH\n         AR    R3,R2               R3 HAS BINARY DAY OF YEAR\n         CVD   R3,DADOUBLE         DADOUBLE HAS 00000000 0000DDDC\n         L     R3,DATEPACK         R3 HAS 0000DDDC\n         L     R2,DAYYPACK         R2 HAS 00000YYF\n         SRL   R2,4                R2 HAS 000000YY\n         SLL   R2,16               R2 HAS 00YY0000\n         OR    R2,R3               R2 HAS 00YYDDDC\n         ST    R2,DATEPACK         SAVE IT\n         B     DAEND\nDARET04  LA    R15,X'04'           RETURN CODE TO R15\n         ST    R15,RETCDE          SAVE IT\nDAEND    L     R10,DARBALSV        RESTORE RETURN ADDRESS\n         BR    R10                 RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   WRITE MESSAGE WITH PUTLINE                                   ***\n***                                                                ***\n***    1.  IOPL was initialized at beginning of program, IOPLIOPB  ***\n***        field will be filled in by PUTLINE execute macro.       ***\n***    2.  PTPB will be filled in by PUTLINE execute macro.        ***\n***    3.  OLD will be filled in by this procedure.                ***\n***                                                                ***\n***    R15 contains branch address for processing appropriate  -EU-***\n***    message.                                                -EU-***\n**********************************************************************\n         SPACE 1\nPUTLPROC ST    R10,PURBALSV        SAVE RETURN ADDRESS\n         XC    RETCDE,RETCDE       SET ERROR CODE TO ZERO\n         BR    R15                 GO TO APPROPRIATE PROCESSING\n         SPACE 1\nPU0000   LA    R15,1(0,0)               SEGMENTS = 1\n         ST    R15,MYOLD                  INTO O.L.D.\n         LA    R15,MSG0000              ADDR OF BLANK LINE\n         ST    R15,MYOLD+4                INTO O.L.D.\n         B     PUOUTPUT                 GO WRITE IT\nPU0001   LA    R15,2(0,0)               SEGMENTS = 2\n         ST    R15,MYOLD                  INTO O.L.D.\n         LA    R15,MSG0001A             ADDR OF BUL0001I, SEG #1\n         ST    R15,MYOLD+4                INTO O.L.D.\n         LA    R15,MSG0001B             ADDR OF BUL0001I, SEG #2\n         ST    R15,MYOLD+8                INTO OLD\n         B     PUOUTPUT                 GO WRITE IT\nPU0002   LA    R15,1(0,0)               SEGMENTS = 1\n         ST    R15,MYOLD                  INTO O.L.D.\n         LA    R15,MSG0002              ADDR OF BUL0002I\n         ST    R15,MYOLD+4                INTO O.L.D.\n         B     PUOUTPUT                 GO WRITE IT\nPU0003   LA    R15,1(0,0)               SEGMENTS = 1\n         ST    R15,MYOLD                  INTO O.L.D.\n         LA    R15,MSG0003              ADDR OF BUL0003E\n         ST    R15,MYOLD+4                INTO O.L.D.\n         B     PUOUTPUT                 GO WRITE IT\nPU0004   LA    R15,1(0,0)               SEGMENTS = 1\n         ST    R15,MYOLD                  INTO O.L.D.\n         LA    R15,MSG0004              ADDR OF BUL0004E\n         ST    R15,MYOLD+4                INTO O.L.D.\n         B     PUOUTPUT                 GO WRITE IT\nPU0005   LA    R15,2(0,0)               SEGMENTS = 2\n         ST    R15,MYOLD                  INTO O.L.D.\n         LA    R15,MSG0005A             ADDR OF BUL0005C, SEG #1\n         ST    R15,MYOLD+4                INTO O.L.D.\n         LA    R15,MSG0005B             ADDR OF BUL0005C, SEG #2\n         ST    R15,MYOLD+8                INTO OLD\n         B     PUOUTPUT                 GO WRITE IT\nPU0006   LA    R15,1(0,0)               SEGMENTS = 1\n         ST    R15,MYOLD                  INTO O.L.D.\n         LA    R15,MSG0006              ADDR OF BUL0006E\n         ST    R15,MYOLD+4                INTO O.L.D.\n         B     PUOUTPUT                 GO WRITE IT\nPU0007   LA    R15,1(0,0)               SEGMENTS = 1\n         ST    R15,MYOLD                  INTO O.L.D.\n         LA    R15,MSG0007              ADDR OF BUL0007C\n         ST    R15,MYOLD+4                INTO O.L.D.\n         B     PUOUTPUT                 GO WRITE IT\nPU0008   LA    R15,1(0,0)               SEGMENTS = 1               -EU-\n         ST    R15,MYOLD                  INTO O.L.D.              -EU-\n         LA    R15,MSG0008              ADDR OF BUL0008C           -EU-\n         ST    R15,MYOLD+4                INTO O.L.D.              -EU-\n         SPACE 1                                                   -EU-\nPUOUTPUT XC    MYPTPB(MYPTPBLN),MYPTPB  ZERO THE PUTLINE PARM BLOCK\n         XC    MYIOECB,MYIOECB     ZERO THE ECB\n         PUTLINE PARM=MYPTPB,OUTPUT=MYOLD,MF=(E,MYIOPL)\n         LTR   R15,R15             IF RETURN IS ZERO\n         BZ    PUEND                 GO TO END\n         LA    R15,X'04'(0,0)      SET ERROR VALUE\n         ST    R15,RETCDE            INTO INTERNAL RETURN CODE\nPUEND    L     R10,PURBALSV        RESTORE RETURN ADDRESS\n         BR    R10                 RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   DATA CONSTANTS                                               ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\n         DS    0D\nVPARMPCL DC    V(PARMPCL)               ADDR OF PARM CONTROL LIST\nVESTXIT  DC    V(ESTXIT)                ADDR OF ABEND EXIT\nF0       DC    F'0'                     CONSTANT\nF4       DC    F'4'                     CONSTANT\nF133     DC    F'133'                   CONSTANT\nH2       DC    H'2'                     CONSTANT\nH9       DC    H'9'                     CONSTANT\nH73      DC    H'73'                    CONSTANT\nH80      DC    H'80'                    CONSTANT\nP0       DC    PL4'+0'                  CONSTANT\nP99365   DC    PL4'+99365'              CONSTANT\nBLANKS   DC    CL80' '                  BLANK LINE\nDSDDNAM  DC    CL8'SYS99999'            DUMMY DDNAME\nZDZEROES DC    XL8'F0F0F0F0F0F0F0F0'    ZONE DECIMAL ZEROES\nZD12     DC    CL2'12'                  CONSTANT\nZD31     DC    CL2'31'                  CONSTANT\n         SPACE 1\n*                              0....+....1....+....2....+....3....+....\n*              4....+....5....+....6....+\nMSG0000  DC    H'06',H'00',CL02'  '\nMSG0001A DC    H'78',H'00',CL74'BUL0001I '\nMSG0002  DC    H'38',H'00',CL34'BUL0002I CLEAR operation complete.'\nMSG0003  DC    H'67',H'00',CL63'BUL0003E OPERATOR authority is requiredx\n                for CLEAR or BROADCAST.'\nMSG0004  DC    H'64',H'00',CL60'BUL0004E Input file must have 80-byte, X\n               fixed length records.'\nMSG0005A DC    H'60',H'00',CL56'BUL0005C Unable to process date :  CurrX\n               ent date assumed.'\nWRK0005B DC    H'13',H'34',CL09'        .'\nMSG0006  DC    H'58',H'00',CL54'BUL0006E Line ignored. Too many apostroX\n               phes (46, max).'\nMSG0007  DC    H'62',H'00',CL58'BUL0007C CLEAR function ignored. QuantiX\n               ty was less than 1.'\nMSG0008  DC    H'62',H'00',CL58'BUL0008C Invalid \"-dates \" : format errX\n               or or missing date.'                                -EU-\n         SPACE 1\nBIWAITIM DC    F'&WAIT'                 WAIT TIME (100THS OF SECONDS)\n         SPACE 1\n*                0-   --       -+--- -1----+----2----+----3----+----4--\n*              --+----5----+----6----+----7----+--- -8----+\n@BIMAIN  DC    H'85',H'0',CL81'SEND ''- ....+....1....+....2....+....3.X\n               ...+....4....+....5....+....6....+ -'',SAVE '\n@BIHYPH  DC    H'85',H'0',CL81'SEND ''---------------------------------X\n               ------------------------------------'',SAVE '\n@CLCMD   DC    H'18',H'0',CL14'SEND NN,DELETE'\n         SPACE 1\n@M0      GTEDADAT DDNAM=X,UNALC=YES\n@M1      GTEDADAT DSNAM=X,MEMBR=X,STATS=SHR,RTDDN=X\n         SPACE 1\nETDATES  DC    CL7'-DATES '             LITERAL\nETCOM    DC    CL5'-COM '               LITERAL\nETENDE   DC    CL5'-END '               LITERAL\nDACURR   DC    CL8'CURRENT'             LITERAL                    -EU-\nAPLOGON  DC    CL5'LOGON'               SUFFIX TO SEND TEXT (NOCL) -EU-\nAPSENDSV DC    CL8' -'',SAVE'           SUFFIX OF SEND TEXT\n         SPACE 1\nDAREGTB  DC    H'000,031,059,090,120,151,181,212,243,273,304,334'\nDALEAPTB DC    H'000,031,060,091,121,152,182,213,244,274,305,335'\nDATSTPAT DC    XL8'F0F0FFF0F0FFF0F0'    'AND' TEST FOR 'NN/NN/NN'\nDARESPAT DC    CL8'00/00/00'            RESULT OF GOOD TEST\n         SPACE 1\nESTAED   ESTAE MF=L\n@OPENL   OPEN  (),MF=L                  OPEN PARM LIST\n@CLOSL   CLOSE (),MF=L                  CLOSE PARM LIST\n         SPACE 1\n         PRINT NOGEN                                               -EU-\n@BCDCB   DCB   DSORG=PS,MACRF=(GM),EODAD=BIEOF,DDNAME=XXXXXXXX\n         PRINT GEN                                                 -EU-\n         SPACE 1                                                   -EU-\nMOD@IX   DC    AL3(MDL@IX)                                         -EU-\n         SPACE 1\n         DS    0D\n         EJECT\n**********************************************************************\n***                                                                ***\n***   COMMAND OPERANDS                                             ***\n***                                                                ***\n***    See syntax description at beginning of program.             ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\n         PRINT NOGEN                                               -EU-\nPARMPCL  IKJPARM  DSECT=PARMPDL\n         SPACE 1\nKEYC     IKJKEYWD DEFAULT='LIST'                                   -EU-\n         IKJNAME  'CLEAR',ALIAS=('CL'),SUBFLD=SUBC\n         IKJNAME  'NOCLEAR',ALIAS=('NOCL')\n         IKJNAME  'LIST',ALIAS=('TEST')                            -EU-\n         SPACE 1\nKEYBC    IKJKEYWD DEFAULT='NOBROADCAST'\n         IKJNAME  'BROADCAST',ALIAS=('BC'),SUBFLD=SUBBCDSN\n         IKJNAME  'NOBROADCAST',ALIAS=('NOBC')\n         SPACE 1\nSUBBCDSN IKJSUBF\nSBCDSN   IKJPOSIT DSNAME,                                              X\n               USID,                                                   X\n               DEFAULT='''&SYSBC''',                                   X\n               HELP=('1-44 CHARACTER DSNAME AND 1-8 CHARACTER MEMBER')\n         SPACE 1\nSUBC     IKJSUBF\nSC       IKJIDENT 'NUMBER OF MESSAGES',                                X\n               MAXLNTH=2,                                              X\n               FIRST=NUMERIC,OTHER=NUMERIC,                            X\n               INTEG,                                                  X\n               DEFAULT='30',                                           X\n               HELP=('NUMBER OF MESSAGES TO DELETE')\n         SPACE 1\n         IKJENDP\n         PRINT GEN                                                 -EU-\n         EJECT\n**********************************************************************\n***                                                                ***\n***   DATA AREA IN SUBPOOL 0                                       ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\nWORKD    DSECT                          AREA FOR VARIABLES\n         DS    18F                      REGISTER SAVE AREA\nCPPLPTR  DS    F                        INITIAL VALUE OF R1 (CPPLADDR)\nRETCDE   DS    F                        INTERNAL RETURN CODE\nCOMPCODE DS    F                        PROGRAM COMPLETION CODE\n         SPACE 1\nABRBALSV DS    F                        RETURN ADDRESS SAVE AREA\nPPRBALSV DS    F                        RETURN ADDRESS SAVE AREA\nPARBALSV DS    F                        RETURN ADDRESS SAVE AREA\nUNRBALSV DS    F                        RETURN ADDRESS SAVE AREA\nDSRBALSV DS    F                        RETURN ADDRESS SAVE AREA\nBCRBALSV DS    F                        RETURN ADDRESS SAVE AREA\nCLRBALSV DS    F                        RETURN ADDRESS SAVE AREA\nETRBALSV DS    F                        RETURN ADDRESS SAVE AREA\nAPRBALSV DS    F                        RETURN ADDRESS SAVE AREA\nDARBALSV DS    F                        RETURN ADDRESS SAVE AREA\nBIRBALSV DS    F                        RETURN ADDRESS SAVE AREA\nPURBALSV DS    F                        RETURN ADDRESS SAVE AREA\n         SPACE 1\nMYPPL    DS    7F                       PARSE PARAMETER LIST\nMYECB    DS    F                        ECB FOR PARSE\nMYANS    DS    F                        POINTER TO THE PDL\n         SPACE 1\nMYUWA    DS    0D                       WORK/SAVE AREA FOR PARSE EXITS\nMYUWASV  DS    18F                      SAVE AREA FOR EXITS\nMYUWAWRK DS    14F                      WORK AREA FOR EXITS\n         SPACE 1\nETTEXTWK DS    CL8                      WORK AREA FOR TEXT\nBCYYDDD  DS    PL4                      CURRENT 00YYDDDC\nLOYYDDD  DS    PL4                      LOW 00YYDDDC\nHIYYDDD  DS    PL4                      HIGH 00YYDDDC\n         SPACE 1\nDASWITCH DS    B'00000000'              SWITCHES\n*                1.......                 X'80' - IT IS A LEAPYEAR\n         SPACE 1\nDADOUBLE DS    0D\n         DS    PL4                      00YYDDDF\nDATEPACK DS    PL4                      WORK AREA FOR PACKED VALUES\nDAYYPACK DS    PL4                      PACKED YEAR\n         SPACE 1\nDATEWORK DS    CL8\n         SPACE 1\nDATE     DS    0CL8\nDAMM     DS    CL2\n         DS    CL1\nDADD     DS    CL2\n         DS    CL1\nDAYY     DS    CL2\n         SPACE 1\nMY0      GTEDADAT MAP=ONLY,DDNAM=X,UNALC=YES\nMY1      GTEDADAT MAP=ONLY,DSNAM=X,MEMBR=X,STATS=SHR,RTDDN=X\n         SPACE 1\nMSG0001B DS    H,H,CL69                 SEGMENT TWO OF MESSAGE\nMSG0005B DS    H,H,CL9                  SEGMENT TWO OF MESSAGE\n         SPACE 1\nMYIOPL   DS    4F                       IO PARM LIST\nMYIOECB  DS    F                        ECB FOR I/O ROUTINES\nMYPTPB   PUTLINE MF=L                   PUTLINE PARM BLOCK (PTPB)\nMYPTPBLN EQU   *-MYPTPB                   LENGTH OF PTPB\n         SPACE 1\n*                                       OUTPUT LINE DESCRIPTOR, 1 LEVEL\nMYOLD    DS    F                          NUMBER OF SEGMENTS\n         DS    5A                         ADDRS OF UP TO FIVE SEGMENTS\n         SPACE 1\nBIMAIN   DC    H'85',H'0'               LENGTH, OFFSET\n         DC    CL8'SEND ''- '           SEND '-B\nBIDATA   DS    CL65                     TEXT\n         DC    CL9' -'',SAVE'           B-',SAVE OR B-',LOGON      -EU-\n         DS    CL65                     EXPANSION AREA DUE TO APOST'S\n         SPACE 1\nBIRC     DS    F\nBISWITCH DS    B '00000000'             SWITCH AREA\n*                 1.......                X'80' - EOF\n*                 .1111111                      - NOT USED\nBITEXTWK DS    CL8                      SAVE WORK AREA FOR TEXT\n         SPACE 1\nCLCMD    DS    2H,CL14                  SEND DELETE COMMAND\nCLZONE   DS    CL3                      MESSAGE NUMBER, ZD\nCLDOUBLE DS    D                        MESSAGE NUMBER, PACKED\n         SPACE 1\nESTAEL   ESTAE MF=L\nESTAELLN EQU   *-ESTAEL\nESTUPL   DS    0D                       ESTAE USER PARM LIST\n         DS    A                          ADDRESS OF RETURN POINT\n         DS    A                          ADDRESS OF USER WORK AREA\nESTUWK   DS    0D                       ESTAE USER WORK AREA\n         DS    18F                        REGISTER SAVE AREA\n         DS    D                          DOUBLE WORD FOR UNPACK\n         DS    F                          BAS REGISTER SAVE AREA\n         WTO   '.+....1....+....2....+....3....+....4....+....5',      X\n               ROUTCDE=(11),DESC=(7),MF=L\n         SPACE 1\nDSDDNAM1 DS    CL8                      SAVE AREA FOR RETURNED DDNAME\nDSDDNAM2 DS    CL8                      SAVE AREA FOR RETURNED DDNAME\n         SPACE 1\nOPENL    OPEN  (),MF=L                  OPEN PARM LIST\nOPENLLEN EQU   *-OPENL\nCLOSL    CLOSE (),MF=L                  CLOSE PARM LIST\nCLOSLLEN EQU   *-CLOSL\n         SPACE 1\n         PRINT NOGEN                                               -EU-\nBCDCB    DCB   DSORG=PS,MACRF=(GM),EODAD=BIEOF,DDNAME=XXXXXXXX\n         PRINT GEN                                                 -EU-\nBCDCBL   EQU   *-BCDCB\n         SPACE 1\nBITEXT   DS    CL255                    BROADCAST TEXT WORK AREA\n         SPACE 1\nAUTH     DC    XL1'0'                                              -EU-\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(*-*)            -EU-\nREQAUTL  EQU   *-AUTH                                              -EU-\nAPPOS    DS    F                                                   -EU-\n         SPACE 1                                                   -EU-\nWORKDEND DS    0D\nWORKDLEN EQU   *-WORKD                  TOTAL LENGTH OF WORK AREA\n         EJECT\n**********************************************************************\n***                                                                ***\n***   MAPPING DSECTS                                               ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\n         PRINT NOGEN\n         SPACE 1\n         CVT   DSECT=YES,LIST=YES     , CVTMAP FOR IKJPARS\n         IKJCPPL                        COMMAND PROCESSOR PARM LIST\n         IKJPPL                         PARSE PARM LIST\n         IKJIOPL                        I/O PARM LIST\n         SPACE 1\n         IKJEFFDF DFDSECT=YES,DFDSEC2=YES  MAPS DAIRFAIL CONTROL BLOCKS\n         IEFZB4D0                       MAPS SVC99 CONTROL BLOCKS\n         IEFZB4D2 ,                     SVC99 KEYS TABLE           -EU-\n         SPACE 1\n         IHASDWA                      , SDWA FOR ESTAE EXIT\n         SPACE 1\n         DCBD  DSORG=PS,DEVD=DA         MAPS DCB\n         SPACE 1\n         PRINT GEN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   ESTAE (ABEND) EXIT                                           ***\n***                                                                ***\n***   This exit will receive control from RTM during ABEND         ***\n***   processing.  Data areas available to this exit will be       ***\n***   the System Diagnostic Work Area (SDWA) provided by the       ***\n***   RTM, and the user parm list and the areas it points to       ***\n***   which are provided by the main routine.                      ***\n***                                                                ***\n***   This exit will format an ABEND message, and write it         ***\n***   with a WTO.  It will then return to RTM.                     ***\n***                                                                ***\n***   The register save area used by this exit has already been    ***\n***   obtained by a GETMAIN by the main program, prior to the      ***\n***   execution of the ESTAE macro.                                ***\n***                                                                ***\n***   This exit is entered by RTM with standard MVS linkage        ***\n***   conventions.  Upon entry, the following relationships        ***\n***   exist:                                                       ***\n***                                                                ***\n*** R1              SDWA (IHASDWA)   ESTUSRPL                      ***\n*** +-----------+   +------------+   +-----------+                 ***\n*** |           |==>| SDWAPARM   |==>| ESURETA   |==> Return point ***\n*** +-----------+   +------------+   +-----------+                 ***\n***                 | SDWAABCC   |   | ESUWRKA   |==> ESUWKD       ***\n***                 +------------+   +-----------+   +-----------+ ***\n***                 |            |                   | Save area | ***\n***                ---          ---                 ---         ---***\n***                ---          ---                 ---         ---***\n***                 |            |                   |           | ***\n***                 +------------+                   +-----------+ ***\n***                 | SDWAGR15   |                   | Other work| ***\n***                 +------------+                   |   areas   | ***\n***                 |            |                   +-----------+ ***\n***                ---          ---                                ***\n***                ---          ---                                ***\n***                 |            |                                 ***\n***                 +------------+                                 ***\n***                                                                ***\n**********************************************************************\n         EJECT\nESTXIT   CSECT\n         STM   R14,R12,12(R13)     SAVE REGS INTO CALLER'S S.A.\n         LR    R12,R15             R12 HAS BASE ADDRESS\n         USING ESTXIT,R12            ADDRESSABILITY\n         LR    R11,R1              R11 POINTS TO SDWA\n         USING SDWA,R11              ADDRESSABILITY\n         L     R10,SDWAPARM        R10 POINTS TO USER PARM LIST\n         USING ESTUSRPL,R10          ADDRESSABILITY\n         L     R15,ESUSRWKA        R15 POINTS TO USER WORK AREA\n         ST    R13,4(0,R15)        CALLER'S S.A. ADDR TO OWN S.A.\n         ST    R15,8(0,R13)        OWN S.A. ADDR TO CALLER'S S.A.\n         LR    R13,R15             R13 POINTS TO OWN S.A.\n         USING ESUWKD,R13            ADDRESSABILITY\n         BAS   R9,ESMSG            FORMAT AND WRITE A MESSAGE\n         L     R4,ESURETA          R4 CONTAINS RETURN ADDRESS\n         SETRP WKAREA=(R11),RC=4,RETADDR=(R4),RETREGS=YES,FRESDWA=YES\n         XR    R15,R15             CLEAR RETURN CODE\n         L     R13,4(0,R13)        RESTORE R13, PNT TO CALLER'S SA\n         LM    R0,R12,20(R13)      RESTORE R0-R12 FROM CALLER'S SA\n         L     R14,12(0,R13)       RESTORE R14 FROM CALLER'S S.A.\n         BR    R14                 RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   WRITE ABEND MESSAGE                                          ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\nESMSG    ST    R9,ESUBALS1         SAVE BAS REGISTER\n         MVC   WTOL(WTOLLEN),WTOD  INITIALIZE WTO PARM LIST\n         L     R3,SDWAABCC         R3 HAS ABEND CODES\n         SLL   R3,8                LEFT JUSTIFY SYSTEM CODE\n         LA    R4,WTOL+26          R4 POINTS INTO MESSAGE\n         LA    R5,3                R5 COUNTER SET TO 3\n         BAS   R9,ESHEX            CONVERT TO DISPLAYABLE HEX\n         L     R3,SDWAGR15         R3 HAS ABEND R15 CONTENTS\n         LA    R4,WTOL+42          R4 POINTS INTO MESSAGE\n         LA    R5,8                R5 COUNTER SET TO 8\n         BAS   R9,ESHEX            CONVERT TO DISPLAYABLE HEX\n         L     R3,SDWAABCC         R3 HAS ABEND CODES\n         N     R3,ESXFFF           R3 HAS ONLY USER CODE\n         CVD   R3,ESUWKDBL         CONVERT TO DECIMAL\n         OI    ESUWKDBL+7,X'0F'    KILL THE SIGN\n         UNPK  WTOL+33(4),ESUWKDBL(8)   UNPACK INTO MESSAGE\n         WTO   MF=(E,WTOL)         WRITE THE MESSAGE\n         L     R9,ESUBALS1         RESTORE THE BAS REGISTER\n         BR    R9                  RETURN\n         SPACE 1\nESHEX    XR    R2,R2               CLEAR EVEN REG OF EVEN/ODD\n         SLDL  R2,4                R2 RECEIVES ONE HEX DIGIT\n         LA    R4,1(0,R4)          R4 POINTS TO NEXT MESSAGE CHAR\n         LA    R2,ESHEXTBL(R2)     R2 POINTS TO CHAR IN TABLE\n         MVC   0(1,R4),0(R2)       MOVE CHAR FROM TABLE TO MESSAGE\n         BCT   R5,ESHEX            LOOP BACK UP\n         BR    R9                  RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   DATA AREAS AND DSECTS FOR ESTAE EXIT                         ***\n***                                                                ***\n**********************************************************************\n         SPACE 1\nESHEXTBL DC    CL16'0123456789ABCDEF'   TRANSLATE TABLE\n         DS    0F                       ALIGN\nESXFFF   DC    X'00000FFF'              MASK TO CLEAR BITS 0-19\nWTOD     WTO   '*** ABEND ***  Codes: SXXX, U9999, R15=XXXXXXXX',      X\n               ROUTCDE=(11),DESC=(7),MF=L\n         SPACE 1\nESTUSRPL DSECT                          USER PARM LIST\nESURETA  DS    A                          RETURN ADDRESS FOR RTM\nESUSRWKA DS    A                          WORK AREA ADDRESS FOR ME\n         SPACE 1\nESUWKD   DSECT                          USER WORK AREA\nESUWKSAV DS    18F                        REGISTER SAVE AREA\nESUWKDBL DS    D                          DOUBLE WORD FOR UNPACK\nESUBALS1 DS    F                          BAS REGISTER SAVE AREA\nWTOL     WTO   '.+....1....+....2....+....3....+....4....+....5',      X\n               ROUTCDE=(11),DESC=(7),MF=L\nWTOLLEN  EQU   *-WTOL                     LENGTH OF WTO PARM LIST\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NOTICE$": {"ttr": 26122, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x943O\\x00\\x943O\\x15X\\x00%\\x00%\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-30T00:00:00", "modifydate": "1994-11-30T15:58:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "SYSPAJA"}, "text": "//NOTICE   JOB (........),'INSTALL  -NOTICE-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=5\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* INSTALLATION DOCUMENTATION : SEE MEMBER NOTICE$@.                 *\n//* BEFORE EXECUTION OF THIS JOB :                                    *\n//*    1. ADJUST \"->.OPER.NOTICES.DATA\" IN THE HELP MEMBER \"NOTICEHL\" *\n//*       (MOVED BY STEP \"HLP\" BELOW).                                *\n//*    2. ADJUST \"->.TARGET.TSO.CLISTS\" IN THE PROCEDURE \"NOTICEPI\"   *\n//*       (MOVED BY STEP \"PRC\" BELOW).                                *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ4AS3,OPT=',RENT',MBR=NOTICE\n//LNK     EXEC PAJILKC,OPT=',LET,NCAL,RENT'\n//SYSIN     DD *\n  ENTRY     NOTICE\n  NAME      NOTICE(R)\n/*\n//HLP     EXEC PAJHELP,MBR=NOTICEHL,DSS='->.SOURCE.FILE4'\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* EXECUTE THE STEP BELOW WITH PROCEDURE :                           *\n//*       \"PAJPROC\" IF YOUR ->.TARGET.PROCLIB DATA-SET                *\n//*                         IS RECFM=FB AND LRECL=80, ELSE            *\n//*       \"PAJPROV\" IF YOUR ->.TARGET.PROCLIB DATA-SET                *\n//*                         IS RECFM=VB AND LRECL=255.                *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//PRC     EXEC PAJPROC,MBR=NOTICEPI,DSS='->.SOURCE.FILE4'\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* EXECUTE THE STEP BELOW WITH PROCEDURE :                           *\n//*       \"PAJPROC\" IF YOUR ->.TARGET.TSO.CLISTS DATA-SET             *\n//*                         IS RECFM=FB AND LRECL=80, ELSE            *\n//*       \"PAJPROV\" IF YOUR ->.TARGET.TSO.CLISTS DATA-SET             *\n//*                         IS RECFM=VB AND LRECL=255.                *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//TCL     EXEC PAJPROC,MBR=NOTICECI,DSS='->.SOURCE.FILE4'\n//             DSP='->.TARGET.TSO.CLISTS'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NOTICE$@": {"ttr": 26124, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x04\\x7f\\x00\\x87\\x04\\x7f\\x12X\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-02-16T00:00:00", "modifydate": "1987-02-16T12:58:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "SYSPAJA"}, "text": "1   11/02/87\n                                                      NOTICE DOC. 1/1.\n\n        -----------------------------------------------------\n        N O T I C E   TSO Command - D O C U M E N T A T I O N\n        -----------------------------------------------------\n\n  Origin : Extracted from the CBT tape 86 FEB, file 160 (the original\n  -------- material was called BULLETIN).\n\n  Installation notes :\n  --------------------\n      1.  This command interfaces with SVC-34, the Console Operator\n          SVC, is done through the provided SVC (AUTHSVC).\n      2.  Set the local variables at the beginning of the source in\n          member NOTICE. Comments explaining the variables are further\n          up in the source. Assembly JCL is in member NOTICE$.\n          The name of the system notices data-set must be set in member\n          NOTICEHL, which is the HELP member.\n      3.  Allocate an input data-set to match the name selected\n          in the previous step. Attributes should be DSORG=FB,\n          LRECL=80, RECFM=PS. Sample input data is in member\n          NOTICESA. Copy the data into the new input data-set.\n      4.  The started task (member NOTICEPI) must be installed in a\n          PROCLIB (member NOTICE) available to JES, and use for input\n          member NOTICE00 (see member NOTICECI).\n      5.  Add the following automatic command in the system, in the\n          example below, at 3:00 a.m. the started task in PROCLIB\n          member NOTICE, which use the input member NOTICE00, to\n          to execute the NOTICE command :\n                    $TA,T=03.00,'$VS,''S NOTICE'''\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NOTICE@": {"ttr": 26370, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15H\\x00\\x82\\x00\\x82\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:48:00", "lines": 130, "newlines": 130, "modlines": 0, "user": "SYSPAJA"}, "text": "1   11/02/87\n                                                      NOTICE    1/3.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     N O T I C E    TSO COMMAND.     * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  CBT origin : Extracted from CBT tape 86 FEB, file 160.\n  ------------\n\n  Purpose :   The NOTICE command is used for maintenance of the\n  ---------   notices messages in the TSO BROADCAST data-set.\n\n  Syntax :    NOTICE   CLEAR(nn)  BROADCAST(dsn)\n  --------             NOCLEAR    NOBROADCAST\n                       LIST\n                       TEST\n         ALIASES  - none\n         DEFAULTS - LIST, NOBROADCAST\n                  - If CLEAR is used : CLEAR(30)\n                  - If BROADCAST is used :\n                    BROADCAST('->.OPER.NOTICES.DATA')\n         REQUIRED - none\n         RESTRICTION - only LIST, TEST and BROADCAST(dsn) is allowed\n                    to a normal user.\n         SUBCOMMANDS - The NOTICE command has no subcommands.\n\n  Operands :\n  ----------\n  CLEAR(nn) : The maximum number of messages to clear in the TSO\n              BROADCAST data-set. Restricted to OPERATOR privilege.\n              ALIAS : CL(nn)\n              DEFAULT : CLEAR(30)\n              NOTE : messages are entered by SE '...',SAVE command.\n  NOCLEAR :   Messages will not be cleared in the TSO BROADCAST\n              data-set. Restricted to OPERATOR privilege.\n              ALIAS : NOCL\n              NOTE : messages are entered by SE '...',LOGON command.\n  LIST or TEST : Messages are just scanned from the input data-set.\n              ALIAS : none\n  BROADCAST(dsn) : Messages from 'dsn' input data-set will be scanned,\n              and added to the TSO BROADCAST data-set if user allowed.\n              ALIAS : BC(dsn)\n              DEFAULT : BROADCAST('->.OPER.NOTICES.DATA')\n  NOBROADCAST : No messages to be added to the TSO BROADCAST data-set.\n              ALIAS : NOBC\n1   11/02/87\n                                                      NOTICE    2/3.\n\n  Examples :\n  ----------\n  A. Normal user :\n    1. - Test or list a prepared notice board, from a private\n         library member 'USERID.MYLIB.DATA(MEMO1)' :\n            NOTICE BC(MYLIB.DATA(MEMO1))\n    2. - List the system notices data-set :\n            NOTICE BC\n  B. OPERATOR privilege :\n    1. - Add an item temporarily to the bottom of the notices board,\n         from a private library member 'USERID.MYLIB.DATA(MEMO1)' :\n            NOTICE NOCL BC(MYLIB.DATA(MEMO1))\n    2. - Clear up to 15 lines in the TSO BROADCAST data-set :\n            NOTICE CL(15)\n    3. - Clear up to 30 lines in the TSO BROADCAST data-set, and\n         recreate the notices from the system notices data-set :\n            NOTICE CL BC\n\n  INPUT data-set cards description :\n  ----------------------------------\n         The messages are created from 80-byte card images.\n         The card type is designated by characters in the beginning\n         of the card image (col.1). Types can be in lower/UPPER case.\n         *        = Comment.\n         -com     = Comment.\n         -dates   = DD/MM/YY dates for message to begin and end, or\n                   set the word 'current' to indicate the message(s)\n                   permanent status.\n                   (Default is the previous -dates card.)\n         blank    = Message text (65-bytes, beginning with col. 2).\n         -end     = End of message text (causes line of hyphens).\n\n  This is an input, short example, for JRC notices board :\n\n  *....+....1....+....2....+....3....+....4....+....5....+....6....+\n  -dates  09/02/87  13/02/87\n   Happy Halloween!\n  -end\n1   11/02/87\n                                                      NOTICE    3/3.\n\n   Messages :\n   ----------\n   BUL0001I ...text...\n         This is the first 71 characters of text processed by the\n         NOTICE command. Apostrophes will be expanded to double\n         apostrophes.\n   BUL0002I CLEAR operation complete.\n         A number of messages have been cleared from the TSO BROADCAST\n         data-set through use of the CLEAR operand of the command.\n   BUL0003E OPERATOR authority is required for CLEAR or BROADCAST.\n         The CLEAR or BROADCAST operation was not performed because\n         you did not have OPERATOR authority.\n   BUL0004E Input file must have 80-byte, fixed length records.\n         The BROADCAST operation was not performed because the input\n         data-set was in a format which NOTICE could not process.\n         Copy the text to a data-set with fixed 80-bytes length\n         records and try again.\n   BUL0005C Unable to process date : xxxxxxxx. Current date assumed.\n         A date field on a '-DATES' input card image was not in the\n         format of DD/MM/YY. NOTICE assumed the current date for\n         both the start and stop dates. Check for two-digit DD, MM,\n         and YY. Check for DD less than 32, and MM less than 13.\n         Also check for a slash (/) in the third and sixth positions\n         (E.g., '-dates 04/07/86 05/07/86').\n   BUL0006E Line ignored. Too many apostrophes (46, max).\n         NOTICE must change apostrophes in your input into double\n         apostrophes before passing the text along to MVS. When more\n         than 46 apostrophes are used, the total line length is longer\n         than the operating system can accept, so the text line cannot\n         be placed into the TSO BROADCAST data-set.\n         Revise the text and try again.\n   BUL0007C CLEAR function ignored. Quantity less than 1.\n         CLEAR(n) was used, and the value of 'n' was less than 1.\n         Note that if you want to prevent clearing message lines, you\n         should use NOCLEAR (which is the default) instead of CLEAR(0).\n   BUL0008C Invalid \"-dates \" : format error or missing date.\n         Check for correct start-end dates (they must be separated by\n         at least one blank, and specified before card column 50).\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NOTICECI": {"ttr": 26373, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\t\\x7f\\x00\\x88\\t\\x7f\\x15W\\x00\\x05\\x00\\x05\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-06T00:00:00", "modifydate": "1988-04-06T15:57:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=NOTICE00\n./     NUMBER  NEW1=100,INCR=100\n  NOTICE  CL  BC\n  LOGOFF\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NOTICEHL": {"ttr": 26375, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15H\\x00e\\x00e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:48:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=NOTICE\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION : The NOTICE command is used for maintenance of the\n              notices messages in the TSO BROADCAST data-set.\n)X SYNTAX :   NOTICE   CLEAR(nn)  BROADCAST(dsn)\n                       NOCLEAR    NOBROADCAST\n                       LIST\n                       TEST\n         ALIASES  - none\n         DEFAULTS - LIST, NOBROADCAST\n                  - If CLEAR is used : CLEAR(30)\n                  - If BROADCAST is used :\n                    BROADCAST('->.OPER.NOTICES.DATA')\n         REQUIRED - none\n         RESTRICTION - only LIST, TEST and BROADCAST(dsn) is allowed\n                    to a normal user.\n)O OPERANDS -\n))CLEAR(nn) : The maximum number of messages to clear in the TSO\n              BROADCAST data-set. Restricted to OPERATOR privilege.\n              ALIAS : CL(nn)\n              DEFAULT : CLEAR(30)\n              NOTE : messages are entered by SE '...',SAVE command.\n))NOCLEAR :   Messages will not be cleared in the TSO BROADCAST\n              data-set. Restricted to OPERATOR privilege.\n              ALIAS : NOCL\n              NOTE : messages are entered by SE '...',LOGON command.\n))LIST or TEST : Messages are just scanned from the input data-set.\n              ALIAS : none\n))BROADCAST(dsn) : Messages from 'dsn' input data-set will be scanned,\n              and added to the TSO BROADCAST data-set if user allowed.\n              ALIAS : BC(dsn)\n              DEFAULT : BROADCAST('->.OPER.NOTICES.DATA')\n))NOBROADCAST : No messages to be added to the TSO BROADCAST data-set.\n              ALIAS : NOBC\n))EXAMPLES -\n  A. Normal user :\n    1. - Test or list a prepared notice board, from a private\n         library member 'USERID.MYLIB.DATA(MEMO1)' :\n            NOTICE BC(MYLIB.DATA(MEMO1))\n    2. - List the system notices data-set :\n            NOTICE BC\n  B. OPERATOR privilege :\n    1. - Add an item temporarily to the bottom of the notices board\n         from a private library member 'USERID.MYLIB.DATA(MEMO1)' :\n            NOTICE NOCL BC(MYLIB.DATA(MEMO1))\n    2. - Clear up to 15 lines in the TSO BROADCAST data-set :\n            NOTICE CL(15)\n    3. - Clear up to 30 lines in the TSO BROADCAST data-set, and\n         recreate the notices from the system notices data-set :\n            NOTICE CL BC\n))INPUT data-set cards description :\n         The messages are created from 80-byte card images.\n         The card type is designated by characters in the beginning\n         of the card image (col.1). Types can be in lower/UPPER case.\n         *        = Comment.\n         -com     = Comment.\n         -dates   = DD/MM/YY dates for message to begin and end, or\n                   set the word 'current' to indicate the message(s)\n                   permanent status.\n                   (Default is the previous -dates card.)\n         blank    = Message text (65-bytes, beginning with col. 2).\n         -end     = End of message text (causes line of hyphens).\n)S SUBCOMMANDS : The NOTICE command has no subcommands.\n)M MESSAGES -\n))BUL0001I ...text...\n         This is the first 71 characters of text processed by the\n         NOTICE command. Apostrophes will be expanded to double\n         apostrophes.\n))BUL0002I CLEAR operation complete.\n         A number of messages have been cleared from the TSO BROADCAST\n         data-set through use of the CLEAR operand of the command.\n))BUL0003E OPERATOR authority is required for CLEAR or BROADCAST.\n         The CLEAR or BROADCAST operation was not performed because\n         you did not have OPERATOR authority.\n))BUL0004E Input file must have 80-byte, fixed length records.\n         The BROADCAST operation was not performed because the input\n         data-set was in a format which NOTICE could not process.\n         Copy the text to a data-set with fixed 80-bytes length\n         records and try again.\n))BUL0005C Unable to process date : xxxxxxxx. Current date assumed.\n         A date field on a '-DATES' input card image was not in the\n         format of DD/MM/YY. NOTICE assumed the current date for\n         both the start and stop dates. Check for two-digit DD, MM,\n         and YY. Check for DD less than 32, and MM less than 13.\n         Also check for a slash (/) in the third and sixth positions\n         (E.g., '-dates 04/07/86 05/07/86').\n))BUL0006E Line ignored. Too many apostrophes (46, max).\n         NOTICE must change apostrophes in your input into double\n         apostrophes before passing the text along to MVS. When more\n         than 46 apostrophes are used, the total line length is longer\n         than the operating system can accept, so the text line cannot\n         be placed into the TSO BROADCAST data-set.\n         Revise the text and try again.\n))BUL0007C CLEAR function ignored. Quantity less than 1.\n         CLEAR(n) was used, and the value of 'n' was less than 1.\n         Note that if you want to prevent clearing message lines, you\n         should use NOCLEAR (which is the default) instead of CLEAR(0).\n))BUL0008C Invalid \"-dates \" : format error or missing date.\n         Check for correct start-end dates (they must be separated by\n         at least one blank, and specified before card column 50).\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NOTICEPI": {"ttr": 26378, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x943O\\x00\\x943O\\x15X\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-30T00:00:00", "modifydate": "1994-11-30T15:58:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=NOTICE\n./     NUMBER  NEW1=100,INCR=100\n//NOTICE  PROC MBR=00,C=Z\n//NOTICE  EXEC PGM=IKJEFT01,DYNAMNBR=10,REGION=1000K\n//*----------------------------------------------------------------*\n//*             L O A D    T S O    B R O A D C A S T              *\n//*      PROCEDURE TO LOAD EVERY DAYS THE TSO BROADCAST DATA-SET   *\n//*      FROM THE SYSTEM NOTICES DATA-SET (OPERATOR MAINTAIN IT).  *\n//*      NIGHTLY, DATA WILL BE SELECTED FROM THIS DATA-SET AND     *\n//*      COPIED INTO THE TSO BROADCAST DATA-SET (USING MBR=00).    *\n//*----------------------------------------------------------------*\n//SYSTSPRT  DD SYSOUT=&C\n//SYSTSIN   DD DSN=->.TARGET.TSO.CLISTS(NOTICE&MBR),DISP=SHR\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NOTICESA": {"ttr": 26380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x18\\x7f\\x00\\x88\\x18\\x7f\\x177\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-07-05T00:00:00", "modifydate": "1988-07-05T17:37:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SYSPAJA"}, "text": "******************************************************************\n*  This is the input for JRC notices board.                      *\n*  Nightly, data will be selected from this data-set and copied  *\n*  into the TSO BROADCAST system data-set.                       *\n*  The messages are created from 80-byte card images.            *\n*  The card type is designated by characters in the beginning    *\n*  of the card image (col.1). Types can be in lower/UPPER case.  *\n*  *       = Comment.                                            *\n*  -com    = Comment.                                            *\n*  -dates  = MM/DD/YY dates for message to begin and end, or     *\n*            set the word 'current' to indicate the message(s)   *\n*            permanent status.                                   *\n*            (Default is the previous -dates card.)              *\n*  blank   = Message text (65-bytes, beginning with col. 2).     *\n*  -end    = End of message text (causes break line of hyphens). *\n******************************************************************\n*....+....1....+....2....+....3....+....4....+....5....+....6....+\n-end\n   -  J.R.C. ISPRA  -  MVS/XA 2.1.7  -  T S O    N O T I C E S\n-end\n*....+....1....+....2....+....3....+....4....+....5....+....6....+\n-dates 13/11/86 16/11/86\n The System will be unavailable Monday, 17/11/86, 08:00-12:00,\n due to system testing.\n-end\n*....+....1....+....2....+....3....+....4....+....5....+....6....+\n-dates  09/02/87  13/02/87\n Happy Halloween!\n-end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "OACNOW": {"ttr": 26382, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882?\\x00\\x882?\\tU\\x01\\x0f\\x01\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1988-11-18T09:55:00", "lines": 271, "newlines": 271, "modlines": 0, "user": "SYSPAJA"}, "text": "OACN     TITLE 'O A C N O W  --  FORMATS DATE AND TIME.'\n*        O A C N O W\n*        -----------\n*\n* AUTHOR : BILL GODFREY, PRC (PLANNING RESEARCH CORPORATION).\n* -------- INSTALLATION : AIR FORCE DATA SERVICES CENTER, PENTAGON.\n*          DATE WRITTEN : OCTOBER 1 1981.\n*          ATTRIBUTES : REENTRANT.\n*\n* DESCRIPTION : THIS SUBPROGRAM FORMATS THE DATE AND TIME, THEN\n* ------------- RETURNS THE ADDRESS OF THE RESULTS IN REGISTER 1.\n*\n*          IT IS CALLED BY THE 'ZAP' TSO COMMAND FROM UCLA.\n*          THIS VERSION OF 'OACNOW' WAS WRITTEN AT AFDSC/PENTAGON\n*          AFTER WE INSTALLED THE ZAP COMMAND AND DISCOVERED THAT\n*          'OACNOW' WAS MISSING. THIS IS A VERSION OF THE 'JULSUB'\n*          SUBPROGRAM MODIFIED TO CONFORM TO 'OACNOW' PROTOCOL.\n*\n*          INPUT : NONE (CALLER SET R1 TO ZERO, BUT WE IGNORE IT).\n*          OUTPUT : REGISTER 1 POINTS TO\n*                       +0  HH:MM:SS\n*                      +14  MM/DD/YY\n*                      +24  CL9'WEEKDAY'                      '\n*                      +34  MMM(M) (D)D, 19YY\n*                   REGISTER 0 CONTAINS LENGTH OF DATA POINTED TO\n*                   BY REGISTER 1.\n*                   CALLER SHOULD ISSUE FREEMAIN R,LV=(0),A=(1).\n         EJECT\n         MACRO\n         STAMP\n         LCLC  &ASMTIME\n&ASMTIME SETC  '&SYSTIME'(1,5)\n         DC    CL16' &SYSDATE &ASMTIME '\n         MEND\n         SPACE 2\nOACNOW   START 0\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         USING *,R12\n         B     @PROLOG-*(,R15)\n         DC    AL1(11),CL11'OACNOW'\n         STAMP\n@SIZE    DC    A(@DATAL)           LENGTH OF WORKAREA\n@PROLOG  STM   R14,R12,12(R13)\n         LR    R12,R15\n         L     R0,@SIZE\n         GETMAIN R,LV=(0)          GET SAVEAREA ADDRESS\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING @DATA,R13\n         SPACE 1\n         LA    R0,RESULTL          GET LENGTH OF RESULTS\n         GETMAIN R,LV=(0)          GET AREA FOR RESULTS\n         ST    R1,RESULTA\n         XC    DOUBLE,DOUBLE\n         SLR   R14,R14             ZERO R14\n         ST    R14,FRSTLAST\n         ST    R14,TIMEB\n         TIME  BIN\n         ST    R0,TIMEB            SAVE TIME\n         SLR   R0,R0\n         STM   R0,R1,DOUBLE        SAVE DATE\n         CVB   R1,DOUBLE\n         ST    R1,JB\n         L     R14,DOUBLE+4        SAVE 00YYDDDF\n         LH    R1,DOUBLE+4         GET 00YY\n         SLL   R1,16               GET 00YY0000\n         SRL   R1,12               GET 00000YY0\n         ST    R1,DOUBLE+4         STORE BACK 00000YY0\n         OI    DOUBLE+7,X'0F'      SET SIGN\n         CVB   R1,DOUBLE\n         ST    R1,YYYYB\n         CH    R1,=H'99'\n         BH    *+L'*+4\n         AH    R1,=H'1900'\n         ST    R1,CENTB\n         UNPK  YYYYC,DOUBLE+5(3)   SAVE YYYY CHAR\n         MVC   YYC,YYYYC+2\n         ST    R14,DOUBLE+4        RESTORE 00YYDDDF\n         XC    DOUBLE(6),DOUBLE    00YYDDDF TO 0000DDDF\n         OI    DOUBLE+7,X'0F'      SET SIGN\n         UNPK  DDDC,DOUBLE+4(4)    SAVE DDD CHAR\n         CVB   R1,DOUBLE           CONVERT DDD TO BINARY\n         ST    R1,DDDB             SAVE DDD BINARY\n         BAS   R9,TODD\n         BAS   R9,TOMON\n         BAS   R9,TOTIME\n         BAS   R9,OUTPUT\n         B     EXIT0\n         SPACE 1\n*        CONVERT JULIAN DATE TO MONTH-DAY-YEAR.\n*\n*              INPUT : YYYYB AND DDDB (ALSO YYC).\n*              OUTPUT : MMB AND DDB, MMC AND DDC, FRSTLAST.\n         SPACE 1\nTODD     MVC   DPM(26),DAYSPMON\n         TM    YYYYB+3,B'00000011' IS YEAR A MULTIPLE OF 4?\n         BNZ   DPM365              NO, BRANCH\n         CLC   YYC,=C'00'          DIVISIBLE BY 100?\n         BNE   DPM366              NO, BRANCH\n         L     R15,CENTB\n         SLR   R14,R14\n         D     R14,=F'400'\n         LTR   R14,R14             EVENLY DIVISIBLE BY 400?\n         BNZ   DPM365              NO, NOT A LEAP YEAR\nDPM366   MVI   DPM+3,29            CHANGE FEB TO 29 DAYS\nDPM365   LA    R14,2               INDEX FOR DPM\n         LR    R0,R14              INDEX INCREMENT\n         L     R1,DDDB             DAY OF YEAR\nDPMLOOP  CH    R1,DPM-2(R14)       DAY LESS THAN OR EQ ENTRY?\n         BE    DPMEND              EQUAL, BRANCH\n         BL    DPMWIN              LESS, BRANCH\n         SH    R1,DPM-2(R14)       NO, SUBTRACT ENTRY FROM DAY\n         ALR   R14,R0              ADD 2 TO INDEX\n         B     DPMLOOP             LOOP\nDPMEND   MVI   FRSTLAST+3,2        LAST DAY OF MONTH\n         B     DPMCOMM\nDPMWIN   CH    R1,=H'1'            FIRST OF MONTH?\n         BNE   DPMCOMM             NO, BRANCH\n         MVI   FRSTLAST+3,1        FIRST DAY OF MONTH\nDPMCOMM  SRL   R14,1               HALVE INDEX TO GET MM\n         ST    R1,DDB              SAVE DD BINARY\n         CVD   R1,DOUBLE           CONVERT TO PACKED\n         OI    DOUBLE+7,X'0F'      SET SIGN\n         UNPK  DDC,DOUBLE+6(2)     SAVE DD CHAR\n         ST    R14,MMB             SAVE MM BINARY\n         CVD   R14,DOUBLE          CONVERT TO PACKED\n         OI    DOUBLE+7,X'0F'      SET SIGN\n         UNPK  MMC,DOUBLE+6(2)     SAVE MM CHAR\n         MVI   SLASH1,C'/'\n         MVI   SLASH2,C'/'\n         BR    R9\n         SPACE 1\n*        CONVERT MONTH NUMBER TO MONTH NAME.\n*\n*               INPUT : MMB (ALSO DDC AND YYC FOR MOVE).\n*               OUTPUT : MONTH AND ALPHA.\n         SPACE 1\nTOMON    L     R15,MMB\n         MH    R15,=H'9'           MULT BY 9\n         LA    R15,ALPHAMON-9(R15) ADDRESS OF ENTRY\n         MVC   MONTH,0(R15)        SAVE PROSE MONTH\n         MVC   ALPHA+2(3),0(R15)   SAVE ALPHA MONTH\n         MVC   ALPHA(2),DDC\n         MVC   ALPHA+5(2),YYC\n         MVI   ALPHA+7,C' '\n         BR    R9\n         SPACE 1\n*        CONVERT TIMEB TO TIMEC.\n*\n*              DIVIDE BY 10,10,10,6,10,6,10,6\n         SPACE 1\nTOTIME   L     R15,TIMEB\n         LA    R6,10               INITIAL DIVISOR\n         LA    R7,12               SET DIVISOR MASK\n         LA    R8,32               SHIFT COUNT\nDECLOOP  XR    R14,R14\n         DR    R14,R6\n         LR    R0,R14              SAVE REMAINDER\n         SRDL  R0,4                SHIFT INTO R1\n         SH    R8,=H'4'            DECREMENT SHIFT COUNT\n         LTR   R15,R15             QUOTIENT ZERO?\n         BZ    TOTIMX              YES, BRANCH\n         CL    R8,=F'24'           IF COUNT LT 24\n         BNL   DECLOOP             NO, BRANCH\n         XR    R6,R7               10 TO 6 TO 10 ETC\n         B     DECLOOP\nTOTIMX   SRL   R1,0(R8)            SHIFT REMAINING BITS\n         SRL   R1,4                GET 0HHMMSST\n         ST    R1,DOUBLE\n         OI    DOUBLE+3,X'0F'\n         MVC   DOUBLE+6(10),=X'402120204B20204B2020'\n         ED    DOUBLE+6(10),DOUBLE\n         MVC   TIMEC,DOUBLE+8\n         BR    R9\n         EJECT\nOUTPUT   L     R1,RESULTA\n         MVI   0(R1),C' '          FILL WITH BLANKS\n         MVC   1(RESULTL-1,R1),0(R1)\n         MVC   00(08,R1),TIMEC     HH.MM.SS\n         MVC   14(08,R1),MMC       MM/DD/YY\n         MVC   24(09,R1),WEEKC     THURSDAY\n         MVC   34(03,R1),MONTH     OCT\n         BR    R9\n         SPACE 1\nEXIT0    L     R2,RESULTA          GET ADDRESS OF RESULTS\n         L     R0,@SIZE            SET UP R0 FOR FREEMAIN\n         LR    R1,R13              SET UP R1 FOR FREEMAIN\n         L     R13,4(,R13)\n         ST    R2,24(,R13)         LM WILL PUT A(RESULTS) IN R1\n         LA    R2,RESULTL          GET LENGTH OF RESULTS\n         ST    R2,20(,R13)         LM WILL PUT L'RESULTS IN R0\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         XR    R15,R15\n         BR    R14\n         EJECT\n*        CONSTANTS.\n*        ----------\n         SPACE 1\nDAYSPMON DC    H'31,28,31,30,31,30,31,31,30,31,30,31,999'\nALPHAMON DC    CL36'JANUARY  FEBRUARY MARCH    APRIL    '\n         DC    CL36'MAY      JUNE     JULY     AUGUST   '\n         DC    CL36'SEPTEMBEROCTOBER  NOVEMBER DECEMBER '\n         DC    CL09'UNKNOWN  '\nWEEKDAYS DC    CL36'SATURDAY SUNDAY   MONDAY   TUESDAY  '\n         DC    CL27'WEDNESDAYTHURSDAY FRIDAY   '\nWEEKBLNK EQU   WEEKDAYS+15         3 BLANKS\n         SPACE 2\n         LTORG\n         EJECT\n*        DSECTS.\n*        -------\n         SPACE 1\n@DATA    DSECT\n         DS    18F\nDOUBLE   DS    D\nWORK     DS    8C\nSC       DS    0CL8\nMMC      DS    CL2\nSLASH1   DS    C\nDDC      DS    CL2\nSLASH2   DS    C\nYYC      DS    CL2\nYYYYC    DS    CL4\nDDB      DS    F\nMMB      DS    F\nYYYYB    DS    F\nCENTB    DS    F\nDDDB     DS    F\nJB       DS    F\nSB       DS    F\nWEEKB    DS    F\nFRSTLAST DS    F\nTIMEB    DS    F\nTIMEC    DS    CL8\nJC       DS    0CL5\n         DS    CL2\nDDDC     DS    CL3\nMONTH    DS    CL9\nALPHA    DS    0CL8\n         DS    CL2\nMON      DS    CL3\n         DS    CL2\n         DS    CL1                 BLANK FILLER LAST BYTE OF ALPHA\nWEEKC    DS    CL12\nPROSE    DS    CL20\nDPM      DS    13H\nRESULTA  DS    F\nRESULTL  EQU   72\n         DS    0D\n@DATAL   EQU   (((*-@DATA)+7)/8)*8\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PACKLIS$": {"ttr": 26625, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x8f\\x00\\x942\\x8f\\x10D\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-24T00:00:00", "modifydate": "1994-11-24T10:44:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//PACKLIST JOB (........),'INSTALL - PACKLIST -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=2\n/*JOBPARM L=6\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                GFDATE    TXPRINT   TXSNAP                         *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ4AS2,MBR=PACKLIST\n//LNK     EXEC PAJILKL\n//SYSIN     DD *\n  INCLUDE SYSADD(GFDATE,PRINT,SNAP)\n  ENTRY   PACKLIST\n  NAME    PACKLIST(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PACKLIS@": {"ttr": 26627, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\t\\x1f\\x00\\x88\\t\\x1f\\x12\\x13\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-03-31T00:00:00", "modifydate": "1988-03-31T12:13:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "1   31/03/88\n                                                      PACKLIST  1/3.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *          P A C K - L I S T          * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *          G E N E R A T O R          * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n CBT origin : Extracted from CBT tape FEB 85, file 270.\n ------------\n\n A set of two programs which performs the following functions :\n --------------------------------------------------------------\n\n 1. PSWSAMP  : is the sample taker program for PACKLIST. The technique\n               is to move the usefull trace table entries to an output\n               record. At start time, the sample rate is approximately\n               once every 2.5 seconds, then the program tries to adjust\n               it dynamically.\n               The program will run for a default time interval set of\n               15 minutes and then will automatically terminate. It may\n               be interrupted using the STOP (P) command.\n\n               The program (started task) is invoked as below :\n\n                    S SAMPLER,...eventual parameters change...\n\n               where SAMPLER (in the data-set EUR1.STC.PROCLIB) is the\n               following procedure :\n\n                    //SAMPLER PROC M=,V=USER01,P=10,S=10,US=SYS1,NX=0\n                    //SAMPLER EXEC PGM=PSWSAMP,PARM=&M\n                    //SYSDIR0   DD DSN=SYS1.LPALIB,DISP=SHR\n                    //SYSDIR1   DD DSN=.....LPALIB,DISP=SHR        (1)\n                    //SYSPSW    DD UNIT=SYSDA,VOLUME=SER=&V,       (2)\n                    //             DSN=&US..SAMPLER.DATA&NX,\n                    //             SPACE=(CYL,(&P,&S)),DISP=(NEW,CATLG)\n                    //SYSPRINT  DD UNIT=SYSDA,VOLUME=SER=&V,\n                    //             DSN=&US..SAMPLER.LLPA&NX,\n                    //             SPACE=(CYL,(1,1)),DISP=(NEW,CATLG),\n                    //             DCB=(RECFM=FBA,BLKSIZE=1210,\n                                                  LRECL=121)\n                    //SYSIN     DD DSN=EUR1.STC.PROCLIB(SAMPLIN),\n                    //             DISP=SHR\n                    //SYSDOU    DD UNIT=SYSDA,VOLUME=SER=&V,\n                    //             DSN=&US..SAMPLER.DLPA&NX,\n                    //             SPACE=(CYL,(1,1)),DISP=(NEW,CATLG),\n                    //             DCB=(RECFM=FBA,BLKSIZE=1210,\n                                                  LRECL=121)\n                    //SYSDIN    DD DSN=EUR1.STC.PROCLIB(SAMPDIN),\n                    //             DISP=SHR\n                    //SYSUDUMP  DD SYSOUT=A\n1   31/03/88\n                                                      PACKLIST  2/3.\n\n               the SAMPLIN member contains only the LISTLPA statement\n               as needed by AMBLIST (service aids program), and the\n               SAMPDIN member contains the following statements\n                 LISTPDS DSNAME=SYS1.LPALIB,DUMP\n                 LISTPDS DSNAME=.....LPALIB,VOL=DISK=......,DUMP   (1)\n               as needed by IEHLIST (utility program).\n\n               The parameter M=... may be used to set the desired time\n               interval limit, expressed in minutes (max. 1200).\n               At any moment during the run, through the MODIFY (F)\n               command, this time interval limit may be changed.\n               If PARM=NULL is specified, then only LISTLPA (AMBLIST)\n               and LISTPDS (IEHLIST) are executed.\n\n       Notes : (1) concatenated LPA libraries if any.\n               (2) omit if PARM=NULL is specified.\n\n    MANDATORY : to collect usefull information, the PSWSAMP program\n                needs the System Trace be active, so you must use\n                TRACE ST and TRACE ST,OFF start/stop system commands\n                (the defaults AS=ON BR=OFF EX=ON are the only options\n                needed). However, at the start time, when the trace\n                is found inactive, the program tries to start it for\n                his purposes. If successfully started, then it stops\n                the trace automatically at the end.\n1   30/03/88\n                                                      PACKLIST  3/3.\n\n 2. PACKLIST : is the program to build a new IEAPAK00 member for the\n               SYS1.PARMLIB. The data are obtained from the use of the\n               PSWSAMP taker. The construction is based on frequency\n               of interrupts in a given LPA module. Association by\n               frequency is possible, but is not enforced.\n               The interrupts in and to LPA are counted. Then the\n               counts for each module are divided by the length of\n               that module. This index value is sorted into descending\n               order. The Pack-list is then built, taking page\n               boundaries into account. When this is finished, the\n               individual records are reversed in order to place the\n               most active closest to the LPA page directory on the\n               LPA paging data-set. All members of LPALIB should be\n               included in the Pack-list at the front of IEAPAK00.\n               If a member is not included in the Pack-list, it goes\n               to the spot desired for the most active LPA members.\n\n               The program (batch task) may be invoked as below :\n\n                    //PACKLST EXEC PGM=PACKLIST\n                    //SYSLPA    DD ... data-set containig output of\n                                       LISTLPA / AMBLIST of PSWSAMP\n                    //SYSDIR    DD ... data-set containig output of\n                                       LISTPDS / IEHLIST of PSWSAMP\n                    //SYSPSW    DD ... data-set containing samples\n                                       gathered by PSWSAMP\n               or : //SYSPSW    DD DUMMY if PSWSAMP has run with\n                                       PARM=NULL\n                    //SYSPUNCH  DD ... output data-set for IEAPAK00\n                    //SYSPRINT  DD SYSOUT=A     report on activity\n                    //SYSLIST   DD SYSOUT=A     optional (see PARM)\n\n               The following options are selectable through the PARM\n               field of the EXEC statement :\n                    D - Abend with dump on error detection (need\n                        SYSUDUMP DD-card).\n                    L - List LISTLPA/LISTPDS output (need SYSLIST\n                        DD-card).\n                    P - List in place of punch IEAPAK00 (need SYSLIST\n                        DD-card).\n                    S - Snap internal table request (Debug aid, need\n                        SYSSNAP DD-card).\n                    T - Use 62 characters line print length for TSO\n                        viewing (SYSPRINT output file).\n               The single characters options may be specified in any\n               order, and must not be separated each from the other.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PACKLIST": {"ttr": 26630, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882o\\x00\\x882o\\x150\\x04u\\x04u\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-21T00:00:00", "modifydate": "1988-11-21T15:30:00", "lines": 1141, "newlines": 1141, "modlines": 0, "user": "SYSPAJA"}, "text": "PCKL     TITLE 'PACKLIST - BUILDER PROGRAM.'\nPACKLIST START 0\n         SPACE 1\n*        DATA SET CBT931 - AT LEVEL 001 AS OF 02/25/79\n*                          PACKLIST VERSION 1.0 (WDPSC)\n         SPACE 1\n*        NOT WRITTEN AT STATE OF WASHINGTON, BUT SUBSTANTIALLY ALTERED\n*        ON INPUT SIDE TO USE OUTPUT FROM TRACE TABLE SAMPLE ROUTINE.\n         SPACE 1\n* PURPOSE :    PACKLIST IS THE MODULE THAT BUILDS THE IEAPAK00 MEMBER\n*              OF SYS1.PARMLIB. THE DATA IS OBTAINED BY USING THE\n*              PSWSAMP ROUTINE. THE CONSTRUCTION IS BASED ON FREQUENCY\n*              OF INTERUPTS IN A GIVEN LPA MODULE. ASSOCIATION BY\n*              FREQUENCY IS POSSIBLE, BUT IS NOT ENFORCED.\n*\n*              THE INTERUPTS IN AND TO LPA ARE COUNTED. THEN THE COUNTS\n*              FOR EACH MODULE ARE DIVIDED BY THE LENGTH OF THAT\n*              MODULE. THIS INDEX VALUE IS SORTED INTO DESCENDING\n*              ORDER. THE PACK LIST IS THEN BUILT, TAKING PAGE\n*              BOUNDARIES INTO ACCOUNT. WHEN THIS IS FINISHED, THE\n*              INDIVIDUAL RECORDS ARE REVERSED IN ORDER TO PLACE\n*              THE MOST ACTIVE CLOSEST TO THE LPA PAGE DIRECTORY ON\n*              THE LPA PAGING DATA-SET.\n*\n*              ALL MEMBERS OF LPALIB SHOULD BE INCLUDED IN THE\n*              PACKLIST AT THE FRONT OF IEAPAK00. IF A MEMBER IS NOT\n*              INCLUDED IN THE PACK LIST, IT GOES TO THE SPOT DESIRED\n*              FOR THE MOST ACTIVE LPA MEMBERS.\n         SPACE 1\n* INVOKING JCL :\n* --------------\n*\n*        //PACKLIST EXEC PGM=PACKLIST\n*        //SYSLPA     DD DSN=... DATA-SET CONTAINING LISTLPA\n*                                OUTPUT / AMBLIST OF PSWSAMP\n*        //SYSDIR     DD DSN=... DATA-SET CONTAINING LISTPDS\n*                                OUTPUT / IEHLIST OF PSWSAMP\n*        //SYSPSW     DD DSN=... DATA-SET CONTAINING SAMPLES\n*                                GATHERED BY PSWSAMP\n*   OR : //SYSPSW     DD DUMMY   IF PSWSAMP HAS RUN WITH PARM=NULL\n*        //SYSPUNCH   DD DSN=... OUTPUT DATA-SET FOR IEAPAK00 MODEL\n*        //SYSPRINT   DD SYSOUT=A       REPORT ON ACTIVITY\n*        //SYSLIST    DD SYSOUT=A       OPTIONAL (SEE PARM. FIELD)\n         SPACE 2\n* CBT ORIGIN : EXTRACTED FROM CBT TAPE FEB 85, FILE 270.\n* ------------ ADAPTED BY : MOINIL P.A.\n*                           COMPUTING CENTRE\n*                           J.R.C. - ISPRA ESTABLISHMENT\n*                           21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG ,                                                  -EU-\n*        MISCELLANEOUS DEFINITIONS                                 -EU-\n*        -------------------------                                 -EU-\n         SPACE 1                                                   -EU-\nNLPA     EQU   3000                EST. NO. OF LPA MODULES ENTRIES -EU-\nPLNSZ    EQU   131                 POOL LINE SIZE                  -EU-\n         SPACE 1                                                   -EU-\nSZG      EQU   (((NLPA*TBL)+7)/8)*8     GETMAIN SIZE               -EU-\nPOOLSZ   EQU   (((61*PLNSZ)+7)/8)*8     GETMAIN SIZE               -EU-\nTMVSXA   EQU   X'01'               MVS/XA SYSTEM TYPE              -EU-\nSETNOP   EQU   X'0F'               SET NO-OPERATION                -EU-\nSETBR    EQU   X'F0'               SET BRANCH                      -EU-\nALL      EQU   X'FF'               SWITCH ALL VALUES ON            -EU-\n         SPACE 1                                                   -EU-\n*------- SEE IHAPDS MACRO FOR DEFINITION BELOW.                    -EU-\nPDS2PAGA EQU   X'20'     PAGE ALIGNMENT REQUIRED FOR LOAD MODULE   -EU-\n         EJECT\n        $XENT  BASE=(R11,R12)                                      -EU-\n         EJECT ,                                                   -EU-\n*        GET PARM.FIELD IF ANY SUPPLIED                            -EU-\n*        ------------------------------                            -EU-\n*        THE OPTIONS, SPECIFIED IN ANY ORDER, MAY BE :             -EU-\n*              D - ABEND WITH DUMP ON ERROR DETECTED               -EU-\n*                  (NEED SYSUDUMP-DD)                              -EU-\n*              L - LIST LISTLPA/LISTPDS OUTPUT (NEED SYSLIST-DD)   -EU-\n*              P - LIST IN PLACE OF PUNCH IEAPAK00                 -EU-\n*                  (NEED SYSLIST-DD)                               -EU-\n*              S - SNAP REQUEST (NEED SYSSNAP-DD)                  -EU-\n*              T - USE 62 CHARACTERS LINE PRINT LENGTH             -EU-\n*                  TO TSO VIEWING (SYSPRINT-DD)                    -EU-\n         SPACE 1                                                   -EU-\n         L     R2,0(R1)            GET PARM DATA AREA              -EU-\n         LH    R3,0(R2)            DATA LENGTH                     -EU-\n         LTR   R3,R3                                               -EU-\n         BNP   IT100               BR IF NO PARM                   -EU-\n         LA    R1,2(R2)                                            -EU-\n         LA    R3,1(R2,R3)                                         -EU-\n         LA    R2,1                                                -EU-\nSC100    CLI   0(R1),C'S'          SNAP REQUESTED ?                -EU-\n         BNE   SC110               NO                              -EU-\n         NI    SWSNAP+1,SETNOP     YES, SYSSNAP-DD ASSUMED         -EU-\n         B     SC200                                               -EU-\nSC110    CLI   0(R1),C'D'          DUMP REQUESTED ?                -EU-\n         BNE   SC120               NO                              -EU-\n         OI    ABEND+1,SETBR       YES, SYSUDUMP-DD ASSUMED        -EU-\n         B     SC200                                               -EU-\nSC120    CLI   0(R1),C'T'          TSO REQUESTED ?                 -EU-\n         BNE   SC130               NO                              -EU-\n         NI    SWPRNT+1,SETNOP     YES, USE 62 LENGTH              -EU-\n         B     SC200                                               -EU-\nSC130    CLI   0(R1),C'L'          LIST LISTLPA/LISTPDS REQUESTED ?-EU-\n         BNE   SC140               NO                              -EU-\n         NI    SWLIST+1,SETNOP     YES, SYSLIST-DD ASSUMED         -EU-\n         B     SC200                                               -EU-\nSC140    CLI   0(R1),C'P'          LIST IEAPAK00 REQUESTED ?       -EU-\n         BNE   SC200               NO                              -EU-\n         OI    SWITCH,SWPNP        YES, SYSLIST-DD ASSUMED         -EU-\nSC200    BXLE  R1,R2,SC100         LOOP IF ANY MORE...             -EU-\n         EJECT\n*        READ AMBLIST (LISTLPA) INFO FROM PSWSAMP                  -EU-\n*        ----------------------------------------                  -EU-\n         SPACE 1                                                   -EU-\nIT100    XR    R9,R9               SET R.C. = 0                    -EU-\n        OPEN   (SYSLPA,(INPUT))    INPUT IS AMBLIST OUTPUT\n         LA    R1,101              SET USER ABEND 101 ****************\n         TM    SYSLPA+(DCBOFLGS-IHADCB),DCBOFOPN  OPEN SUCCESSFUL ?\n         BZ    ABEND               NO\n         XR    R2,R2               JUST IN CASE...                 -EU-\n         SPACE 1                                                   -EU-\nIT110   GET    SYSLPA,PI           SEARCH FOR NUMERIC SECTION... GET\n         BAS   R8,SWLIST                                           -EU-\n         CLI   CC,C'1'             TITLE PAGE ?\n         BNE   IT110               NO... GET NEXT PRINT IMAGE\n         CLC   CC+15(L'LPMNUM),LPMNUM   START OF NUMERICAL LISTING ?\n         BE    IT120               YES                             -EU-\n         CLC   CC+1(L'LPMNEW),LPMNEW    NEW NUMERICAL LISTING ?    -EU-\n         BNE   IT110               NO... MUST STILL BE IN ALPHABETIC\n         OI    SWITCH,SWNEW        YES... NEW AMBLIST FORMAT       -EU-\nIT120   GETMAIN LU,LA=TBSZG,A=TAB  GET THE TABLE WORK AREA         -EU-\n         L     R2,TAB              POINT TO IT\n         USING TBS,R2              TABLE DSECT\n         L     R1,TBSZ             COMPUTE LAST TABLE ENTRY ADDR.  -EU-\n         ALR   R1,R2                                               -EU-\n         SL    R1,TAB+4                                            -EU-\n         ST    R1,TAB+8                                            -EU-\n         SPACE 1                                                   -EU-\nIT130   GET    SYSLPA,PI           READ PRINT IMAGE\n         BAS   R8,SWLIST                                           -EU-\n         CLI   CC,C' '             DETAIL LINE ?\n         BNE   IT130               NO... IGNORE\n         LA    R1,S1               POINT TO FIRST SEGMENT\n         BAS   R14,IT200           ADD TO TABLE\n         LA    R1,S2               POINT TO SECOND SEGMENT\n         BAS   R14,IT200           CONVERT\n         B     IT130               GET NEXT RECORD\n         SPACE 1\n         USING LPAE,R1             SEGMENT DSECT\nIT200    CLC   LL+1(4),=CL10' '    BLANK LENGTH (NOT MODULE NAME) ?-EU-\n         BER   R14                 YES... IGNORE\n         CLI   LN,C'A'             AMBLIST INVALID NAME ?    -ERROR-EU-\n         BLR   R14                 YES... IGNORE             -ERROR-EU-\n         CL    R2,TAB+8            TABLE OVERFLOW ?                -EU-\n         BNH   IT210               NO, OK                          -EU-\n         LA    R1,301              SET USER ABEND 301 *************-EU-\n         B     ABEND                                               -EU-\nIT210    XC    TN(TBL),TN          CLEAR                           -EU-\n         MVC   TN,LN               SAVE MODULE NAME\n         TM    SWITCH,SWNEW        NEW AMBLIST FORMAT ?            -EU-\n         BO    IT220               YES                             -EU-\n         TR    LX,TOBIN            CONVERT START AND LENGTH TO BIN\n         PACK  TS(L'TS+1),LS(L'LS+1)    SAVE START ADDRESS\n         PACK  TL(L'TL+1),LL(L'LL+1)    LENGTH\n         B     IT230                                               -EU-\nIT220    CLI   LXN,C' '            TWO BLANKS AFTER NAME ?         -EU-\n         BNE   *+L'*+4             NO, OK                          -EU-\n         LA    R1,1(R1)            YES, ADJUST LINE POINTER        -EU-\n         TR    LXN,TOBIN           CONVERT START AND LENGTH TO BIN -EU-\n         PACK  TS(L'TS+1),LSN(L'LSN+1)  SAVE START ADDRESS         -EU-\n         PACK  TL(L'TL+1),LLN(L'LLN+1)  LENGTH                     -EU-\n         DROP  R1                                                  -EU-\nIT230    NOP   IT240               ONE TIME SWITCH\n         OI    IT230+1,SETBR       CHANGE TO BRANCH\n         MVC   LPALOW,TS           SAVE LPA LOW ADDR\n         CLC   LPALOW,LPAUP        DOWN 16M LINE ?                 -EU-\n         BL    IT250               YES                             -EU-\n         OI    IT240+1,SETBR       NO... ONLY UP 16M LINE          -EU-\nIT240    NOP   IT250               16M LINE SWITCH                 -EU-\n         CLC   TS,LPAUP            DOWN 16M LINE ?                 -EU-\n         BL    IT250               YES                             -EU-\n         OI    IT240+1,SETBR       CHANGE TO BRANCH                -EU-\n         MVC   LPALOWX,TS          SAVE X-LPA LOW ADDR             -EU-\n         SL    R2,TAB+4            POINT TO PREVIOUS TABLE ENTRY   -EU-\n         ST    R2,TAB16M           16M LINE TABLE POINTER          -EU-\n         L     R1,TS               LAST MOD START ADDR             -EU-\n         AL    R1,TL               ADD LENGTH OF MOD               -EU-\n         ST    R1,LPAHI            SAVE LPA HIGH ADDR              -EU-\n         AL    R2,TAB+4            AGAIN TO CURRENT TABLE ENTRY    -EU-\nIT250    AL    R2,TAB+4            POINT TO NEXT TABLE ENTRY\n         BR    R14                 RETURN\n         SPACE 1                                                   -EU-\nSWLIST   BR    R8                                                  -EU-\n        $PRINT PI,,DDLIST                                          -EU-\n         LTR   R15,R15                                             -EU-\n         BZR   R8                                                  -EU-\n         LA    R1,310(R15)         SET USER ABEND 31X *************-EU-\n         B     ABEND                                               -EU-\n         SPACE 1\nIT900    CL    R2,TAB              TABLE EMPTY ?                   -EU-\n         BH    IT910               NO... OK, CONTINUE              -EU-\n         LA    R1,302              SET USER ABEND 302 *************-EU-\n         B     ABEND                                               -EU-\nIT910    SL    R2,TAB+4            SET END OF TABLE\n         ST    R2,TAB+8            EOD(SYSLPA)... SAVE TABLE END\n         L     R1,TS               LAST MOD START ADDR\n         AL    R1,TL               ADD LENGTH OF MOD\n         OC    LPAHI,LPAHI         ALREADY STORED ?                -EU-\n         BZ    IT920               NO... ONLY ONE LPA AREA         -EU-\n         ST    R1,LPAHIX           SAVE X-LPA HIGH ADDR            -EU-\n         OI    SWITCH,SW16M        INDICATE UP 16M ALSO            -EU-\n         B     IT990                                               -EU-\nIT920    ST    R1,LPAHI            SAVE LPA HIGH ADDR\n         DROP  R2                                                  -EU-\n         SPACE 1\nIT990   CLOSE  SYSLPA              DON'T NEED THIS ANYMORE\n         EJECT\n*        READ IEHLIST (LISTPDS) INFO FROM SAMPLER RUN              -EU-\n*        --------------------------------------------              -EU-\n         SPACE 1                                                   -EU-\n        OPEN   (SYSDIR,(INPUT))    INPUT IS IEHLIST OUTPUT         -EU-\n         LA    R1,102              SET USER ABEND 102 *************-EU-\n         TM    SYSDIR+(DCBOFLGS-IHADCB),DCBOFOPN OPEN SUCCESSFUL ? -EU-\n         BZ    ABEND               NO                              -EU-\n         LA    R4,CC+1             IEHLIST PRINT SEGMENT           -EU-\n         USING IEHL,R4                                             -EU-\n         SPACE 1                                                   -EU-\nDR100   GET    SYSDIR,PI           GET                             -EU-\n         BAS   R8,SWLIST                                           -EU-\n         CLI   CC,C'1'             TITLE PAGE ?                    -EU-\n         BE    DR100               YES... GET NEXT PRINT IMAGE     -EU-\n         CLC   MARGIN,=CL10' '     DETAIL LINE ?                   -EU-\n         BNE   DR100               NO... GET NEXT PRINT IMAGE      -EU-\n         CLC   MNAME(9),=CL9' MEMBERS ' SUBTITLE LINE ?            -EU-\n         BE    DR100               YES... GET NEXT PRINT IMAGE     -EU-\n         LM    R1,R3,TAB           SEARCH TABLE                    -EU-\n         USING TBS,R1              TABLE DSECT                     -EU-\nDR200    CLC   MNAME,TN            THIS MODULE NAME ?              -EU-\n         BE    DR300               YES                             -EU-\n         BXLE  R1,R2,DR200         CONTINUE SEARCH                 -EU-\n         B     DR100               NOT FOUND... GET NEXT           -EU-\nDR300    MVC   DWD(4),MATT1        GET MODULE ATTRIBUTES           -EU-\n         MVC   DWD+4(2),MATT2                                      -EU-\n         TR    DWD(6),TOBIN        CONVERT TO BINARY               -EU-\n         PACK  WORK,DWD(7)                                         -EU-\n         MVC   TMATTR1(3),WORK     SET MODULE ATTRIBUTES           -EU-\n         B     DR100               GET NEXT PRINT IMAGE            -EU-\n         DROP  R1,R4                                               -EU-\n         SPACE 1                                                   -EU-\nDR900   CLOSE  SYSDIR              DON'T NEED THIS ANYMORE         -EU-\n         EJECT\n*        READ SAMPLES GATHERED BY PSWSAMP                          -EU-\n*        --------------------------------                          -EU-\n         SPACE 1                                                   -EU-\n        OPEN   (SYSPSW,(INPUT))    PROCESS COUNT DATA\n         LA    R1,201              SET USER ABEND 201 ****************\n         TM    SYSPSW+(DCBOFLGS-IHADCB),DCBOFOPN  OPEN SUCCESSFULL ?\n         BZ    ABEND               NO\n         SPACE 1                                                   -EU-\nRS100   GET    SYSPSW\n         LA    R2,32               TTE LENGTH\n         SLR   R1,R2               COMPUTE SAMPLES SCANNING POINTERS\n         LH    R3,SYSPSW+(DCBBLKSI-IHADCB)\n         AR    R3,R1\nRS120    BXH   R1,R2,RS100         SCAN SAMPLES (TRACE TABLE)\n         CLC   0(4,R1),=F'-1'      PSW SAMPLER INFO ?              -EU-\n         BNE   RS130               BR IF NOT                       -EU-\n         MVC   PSI(PSIL),4(R1)     YES... PICK IT                  -EU-\n         B     RS120                                               -EU-\nRS130    CLI   2(R1),0             REAL TRACE TABLE ENTRY ?        -EU-\n         BE    RS120               BR IF NOT                       -EU-\n         AP    TTETOT,=PL1'+1'     BUMP COUNTER                    -EU-\n         TM    2(R1),X'F0'         CONTROL TYPE CODE ?             -EU-\n         BZ    RS120               BR IF NONE OF TYPE CODE\n         AP    TTEUSE,=PL1'+1'     BUMP COUNTER                    -EU-\n         L     R4,4(,R1)           GET ADDRESS FROM PSW            -EU-\n         CL    R4,LPALOW           IN LPA ?                        -EU-\n         BNL   RS150               YES... MAY BE\nRS140    AP    ASCTR,=PL1'+1'      BUMP A.S. COUNTER               -EU-\n         B     RS120               GET ANOTHER TRACE RECORD\nRS150    CL    R4,LPAHI            ABOVE LPA ?                     -EU-\n         BL    RS200               NO... IT IS IN LPA              -EU-\n         TM    SWITCH,SW16M        16M LINE ACTIVATED ?            -EU-\n         BZ    RS140               NO...                           -EU-\n         CL    R4,LPALOWX          IN X-LPA ?                      -EU-\n         BL    RS140               NO...                           -EU-\n         CL    R4,LPAHIX           ABOVE X-LPA ?                   -EU-\n         BNL   RS140               YES...                          -EU-\nRS200    LM    R5,R7,TAB           GET TABLE LIMITS\n         USING TBS,R5              TABLE DSECT                     -EU-\nRS250    CL    R4,TS               EXCEED MODULE START ?           -EU-\n         BL    RS260               YES                             -EU-\n         BXLE  R5,R6,RS250         CONTINUE SEARCH                 -EU-\n         B     RS270               IF HERE IT IS LAST MODULE       -EU-\nRS260    CL    R5,TAB              FIRST MODULE START ?            -EU-\n         BE    RS140               YES...                          -EU-\nRS270    SLR   R5,R6\n         L     R0,TF                                               -EU-\n         A     R0,=F'1'            BUMP COUNT COUNT BY ONE         -EU-\n         ST    R0,TF               STORE RESULT                    -EU-\n         AP    LPACTR,=PL1'+1'     BUMP LPA COUNTER\n         B     RS120               GET NEXT RECORD\n         DROP  R5                                                  -EU-\n         SPACE 1\nRS900   CLOSE  SYSPSW\n         SPACE 1\n         LM    R1,R3,TAB           GET TABLE LIMITS\n         USING TBS,R1              TABLE DSECT                     -EU-\n         SR    R1,R2\nRS910    BXH   R1,R2,ST100         POINT TO NEXT ENTRY\n         L     R5,TF               GET NUMBER OF FAULTS\n         LTR   R5,R5                                               -EU-\n         BNP   RS910                                               -EU-\n         M     R4,=F'100000'       ALLOW 5 DECIMAL PLACES\n         OC    TL,TL               JUST TO                         -EU-\n         BZ    RS920                 BYPASS                        -EU-\n         CL    R4,TL                   EVENTUAL                    -EU-\n         BL    RS930                     OVERFLOW                  -EU-\nRS920    MVC   TFL,=F'99999999'    SET MAXIMUM AS ANSWER           -EU-\n         B     RS910               DO FOR NEXT ENTRY\nRS930    D     R4,TL               CALC FAULTS / LENGTH\n         LTR   R5,R5               JUST TO                         -EU-\n         BNP   RS920                 BYPASS                        -EU-\n         CL    R5,=F'99999999'         EVENTUAL                    -EU-\n         BH    RS920                     TOO BIG VALUE             -EU-\n         ST    R5,TFL              SAVE ANSWER\n         B     RS910               DO FOR NEXT ENTRY\n         DROP  R1                                                  -EU-\n         EJECT\n*        ORDER TABLE BY DESCENDING FAULTS/BYTE (TFL)\n*        -------------------------------------------\n         SPACE 1\nST100    MVC   STT(3*4),TAB        SET TABLE BOUNDARIES TO SORT    -EU-\n         TM    SWITCH,SW16M        16M LINE ACTIVATED ?            -EU-\n         BZ    ST110               NO...                           -EU-\n         MVC   STT+8(4),TAB16M     YES... PROCESS DOWN 16M LINE    -EU-\n         BAS   R8,ST200            SORT                            -EU-\n         L     R1,TAB16M           PROCESS UP 16M LINE             -EU-\n         AL    R1,TAB+4                                            -EU-\n         ST    R1,STT                                              -EU-\n         MVC   STT+8(4),TAB+8                                      -EU-\nST110    BAS   R8,ST200            SORT                            -EU-\n         B     PL100                                               -EU-\n         SPACE 1                                                   -EU-\nST200    LM    R1,R3,STT           SET UP TO BEGIN THE SORT\n         MVI   SORTTEST,0          HAS-SOMETHING-BEEN-MOVED BYTE\n         USING TBS,R1              TABLE DSECT                     -EU-\nST210    LR    R4,R1\n         BXH   R1,R2,ST230         INCREMENT FOR NEXT ENTRY\n         CLC   TFL,TFL-TBS(R4)     COMPARE ON FAULTS PER BYTE\n         BH    ST220               EXCHANGE THE ENTRIES\n         BNE   ST210               LOW\n         CLC   TL,TL-TBS(R4)       EQUAL, COMPARE ON LENGTH\n         BNH   ST210\nST220    TS    SORTTEST       SET THE HAS-SOMETHING-BEEN-MOVED BYTE\n         XC    0(TBL,R1),0(R4)     EXCHANGE THE ENTRIES\n         XC    0(TBL,R4),0(R1)\n         XC    0(TBL,R1),0(R4)\n         B     ST210\nST230    SR    R3,R2               SHRINK THE TABLE FOR A TIME\n         ST    R3,STT+8\n         TS    SORTTEST\n         BNZ   ST200\n         BR    R8                  RETURN TO CALLER                -EU-\n         DROP  R1                                                  -EU-\n         EJECT\n*        COMPUTE PACK LIST (PAGE BOUNDARIES)                       -EU-\n*        -----------------------------------                       -EU-\n         SPACE 1\nPL100    TM    SWPRNT+1,SETBR                                      -EU-\n         BO    *+L'*+10                                            -EU-\n         MVC   SYSPRINT+(DCBLRECL-IHADCB)(L'DCBLRECL),=AL2(62)     -EU-\n         B     PL110                                               -EU-\n         L     R0,=A(POOLSZ)                                       -EU-\n         LR    R5,R0                                               -EU-\n        GETMAIN R,LV=(0)           GET THE POOL OF LINES           -EU-\n         ST    R1,APOOL                                            -EU-\n         LR    R4,R1               INITIALIZE IT                   -EU-\n         LA    R6,*                                                -EU-\n         XR    R7,R7                                               -EU-\n         ICM   R7,B'1000',=CL10' '                                 -EU-\n         MVCL  R4,R6                                               -EU-\n         MVI   0(R1),C'1'                                          -EU-\nPL110   OPEN   (SYSPRINT,(OUTPUT))\n         LA    R1,202              SET USER ABEND 202 ****************\n         TM    SYSPRINT+(DCBOFLGS-IHADCB),DCBOFOPN     OPEN OK ?\n         BZ    ABEND               NO\n         LM    R5,R7,TAB           RESET TABLE LIMITS\n         TM    SWITCH,SW16M        16M LINE ACTIVATED ?            -EU-\n         BZ    *+L'*+4             NO...                           -EU-\n         L     R7,TAB16M           YES... PROCESS DOWN 16M LINE    -EU-\n         USING TBS,R5              TABLE DSECT                     -EU-\n         SR    R5,R6\n         LR    R3,R5\n         XR    R2,R2               START PAGE-GROUPS BACKWARD CHAIN-EU-\n         XR    R4,R4               START PAGE-MODULES FORWARD CHAIN-EU-\n         B     PL350                                               -EU-\n         SPACE 1\nPL150    LR    R5,R3\n         NI    SWITCH,ALL-SWPPB\nPL160    BXH   R5,R6,PL200\n         CLI   TF,X'FF'            USED ENTRY ?\n         BE    PL160               YES\n         LTR   R4,R4               FIRST PAGE-MODULE ?             -EU-\n         BZ    *+L'*+8             YES                             -EU-\n         TM    TMATTR3,PDS2PAGA    NO, PAGE ALIGNMENT NEEDED ?     -EU-\n         BO    PL170               YES                             -EU-\n         LR    R3,R5               SAVE CURR LOC\n         L     R1,TL\n         LTR   R4,R4               FIRST PAGE-MODULE ?             -EU-\n         BNZ   *+L'*+4             NO                              -EU-\n         N     R1,=F'4095'\n         A     R1,PAGELEN\n         C     R1,=F'4096'         OVER A PAGE ?\n         BNH   NOTOVER\nPL170    SR    R5,R6               TRY TO FIND ENTRY WHICH WILL FIT\n         LR    R3,R5\n         OI    SWITCH,SWPPB\nPL180    BXH   R5,R6,PL250         TRY TO FIND A FIT               -EU-\n         CLI   TF,X'FF'            ALREADY USED FLAG ?\n         BE    PL180               YES... DO NOT USE\n         TM    TMATTR3,PDS2PAGA    NO, PAGE ALIGNMENT NEEDED ?     -EU-\n         BO    PL180               YES... DO NOT USE               -EU-\n         L     R1,PAGELEN          CURRENT PAGELEN\n         A     R1,TL               LENGTH OF MOD\n         C     R1,=F'4096'         FIT ?\n         BH    PL180               NO\n         B     NOTOVER             YES\nPL200    CL    R7,TAB16M           DOWN 16M LINE TABLE LIMIT ?     -EU-\n         BNE   PL900               NO... END OF PROCESS            -EU-\n         L     R7,TAB+8            YES... PROCESS UP 16M LINE NOW  -EU-\n         NI    SWTCH+1,SETNOP                                      -EU-\nPL250    XR    R4,R4                                               -EU-\n         UNPK  PGBSZ,TOTSZ(L'TOTSZ+1)   EDIT TOTAL PAGE(S) SPACE   -EU-\n         TR    PGBSZ,TOHEX-C'0'                                    -EU-\n         MVI   PGBSZ+L'PGBSZ-1,C' '                                -EU-\n         LA    R0,PGB                                              -EU-\n         BAS   R8,SWPRNT                                           -EU-\n         SP    CTR,=PL1'+1'\n         L     R1,TOTSZ            COMPUTE NEW LPA TOTAL           -EU-\n         A     R1,=F'4095'                                         -EU-\n         SRL   R1,12                                               -EU-\n         SLL   R1,12                                               -EU-\nSWTOT    NOP   *+L'*+12                                            -EU-\n         A     R1,TOTLSZ                                           -EU-\n         ST    R1,TOTLSZ                                           -EU-\n         B     *+L'*+8                                             -EU-\n         A     R1,TOTLSZX                                          -EU-\n         ST    R1,TOTLSZX                                          -EU-\n         XC    TOTSZ,TOTSZ                                         -EU-\n         XC    PAGELEN,PAGELEN                                     -EU-\nSWTCH    B     PL150                                               -EU-\n         OI    SWTCH+1,SETBR                                       -EU-\n         OI    SWTOT+1,SETBR                                       -EU-\n         OI    SWTLS+1,SETBR                                       -EU-\n         SP    CTR,CTR             FORCE NEW PAGE                  -EU-\n         B     PL150\nNOTOVER  ST    R1,PAGELEN          CURRENT PAGE LENGTH\n         LTR   R4,R4               FIRST PAGE-MODULE ?             -EU-\n         BNZ   *+L'*+10            NO                              -EU-\n         ST    R2,TPGBC            SET BACKWARD CHAIN              -EU-\n         LR    R2,R5                                               -EU-\n         B     *+L'*+4                                             -EU-\n         ST    R5,TPMFC-TBS(R4)    SET FORWARD CHAIN               -EU-\n         LR    R4,R5                                               -EU-\n         MVC   PN,TN               PRINT MODULE NAME\n         UNPK  PS,TS(L'TS+1)       START ADDRESS\n         UNPK  PL,TL(L'TL+1)       LENGTH\n         TR    PT,TOHEX-C'0'\n         MVI   PS+L'PS-1,C' '      BLANK GARBAGE\n         MVI   PL+L'PL-1,C' '      BLANK GARBAGE\n         MVC   PF(18),=XL18'40202020204B202120402021206B20202020'  -EU-\n         L     R1,TF               GET NUMBER FAULTS\n         MVI   TF,X'FF'\n         CVD   R1,DWD              IN DECIMAL\n         ED    PF,DWD+4            READABLE\n         L     R1,TFL              GET FACTOR\n         CVD   R1,DWD              IN DECIMAL\n         SRP   DWD+3(5),64-1,5                                     -EU-\n         ED    PFL,DWD+4           READABLE\n         L     R0,TOTSZ            COMPUTE TOTAL PAGE(S) SPACE     -EU-\n         A     R0,TL                                               -EU-\n         ST    R0,TOTSZ                                            -EU-\n         DROP  R5                                                  -EU-\n         SP    CTR,=PL1'+1'\n         BP    PL400\nPL350    ZAP   CTR,=PL2'+55'       LINES PER PAGE\n         MVC   T1PGN,=XL4'40202120'                                -EU-\n         ED    T1PGN,PGN           PAGE NUMBER                     -EU-\n         LA    R0,T1               TITLES                          -EU-\n         BAS   R8,SWPRNT                                           -EU-\n         LA    R0,T2                                               -EU-\n         BAS   R8,SWPRNT                                           -EU-\n         AP    PGN,=PL1'+1'                                        -EU-\n         LTR   R2,R2               INITIAL TIME ?                  -EU-\n         BZ    PL150               YES                             -EU-\nPL400    LA    R0,P                PRINT DETAIL LINE               -EU-\n         BAS   R8,SWPRNT                                           -EU-\n         L     R1,PAGELEN\n         N     R1,=F'4095'\n         BZ    PL250\n         ST    R1,PAGELEN\n         TM    SWITCH,SWPPB\n         BO    PL180\n         B     PL150               LOOK FOR NEXT ENTRY\n         SPACE 1                                                   -EU-\nSWPRNT   B     PL800               SYSPRINT PROCESS ROUTINE        -EU-\n         LTR   R0,R0                                               -EU-\n         BNPR  R8                                                  -EU-\n        PUT    SYSPRINT,(0)                                        -EU-\n         BR    R8                                                  -EU-\nPL800    STM   R2,R3,SVREGS        WORK REGISTERS                  -EU-\n         LTR   R2,R0                                               -EU-\n         BNP   PL880               BR IF LAST CALL                 -EU-\n         OC    CURPT,CURPT         PROCESSING STARTED ?            -EU-\n         BNZ   PLCNT               YES                             -EU-\n         CLI   0(R2),C'1'          NEW PAGE ?                      -EU-\n         BNER  R8                  NO... FLUSH                     -EU-\n         B     PLSTR                                               -EU-\nPLCNT    CLI   0(R2),C'1'          NEW PAGE ?                      -EU-\n         BNE   PL830               NO                              -EU-\n         TM    SWITCH,SWPRS        PAGE RIGHT SIDE PROCESSED ?     -EU-\n         BO    *+L'*+8             YES                             -EU-\n         OI    SWITCH,SWPRS        NO... START IT NOW              -EU-\n         B     PLSTR                                               -EU-\n         NI    SWITCH,ALL-SWPRS    RESET TO PAGE LEFT SIDE         -EU-\n         L     R3,APOOL                                            -EU-\nPL820   PUT    SYSPRINT,(R3)                                       -EU-\n         MVC   2(PLNSZ-2,R3),1(R3)                                 -EU-\n         AH    R3,=Y(PLNSZ)                                        -EU-\n         CL    R3,LSTPT                                            -EU-\n         BNH   PL820               PRINT AN ENTIRE PAGE            -EU-\n         XC    LSTPT,LSTPT                                         -EU-\nPLSTR    MVC   CURPT,APOOL                                         -EU-\nPL830    L     R1,CURPT            BUILD PAGE                      -EU-\n         CLI   0(R2),C'0'          DOUBLE SPACE ?                  -EU-\n         BNE   *+L'*+4             NO                              -EU-\n         AH    R1,=Y(PLNSZ)                                        -EU-\n         TM    SWITCH,SWPRS        RIGHT SIDE PROCESSING ?         -EU-\n         BO    *+L'*+10            YES                             -EU-\n         MVC   8(61,R1),1(R2)      MOVE TO LEFT SIDE               -EU-\n         B     *+L'*+14                                            -EU-\n         MVC   70(61,R1),1(R2)     MOVE TO RIGHT SIDE              -EU-\n         CL    R1,LSTPT                                            -EU-\n         BNH   *+L'*+4                                             -EU-\n         ST    R1,LSTPT            SET PRINT POINTER               -EU-\n         AH    R1,=Y(PLNSZ)                                        -EU-\n         ST    R1,CURPT            SET CURRENT POINTER             -EU-\nPL870    LM    R2,R3,SVREGS                                        -EU-\n         BR    R8                                                  -EU-\nPL880    NI    SWITCH,ALL-SWPRS    RESET ALL                       -EU-\n         XC    CURPT,CURPT                                         -EU-\n         OC    LSTPT,LSTPT         ANYTHING TO PRINT ?             -EU-\n         BZ    PL870               NO                              -EU-\n         L     R3,APOOL                                            -EU-\nPL890   PUT    SYSPRINT,(R3)                                       -EU-\n         MVC   2(PLNSZ-2,R3),1(R3)                                 -EU-\n         AH    R3,=Y(PLNSZ)                                        -EU-\n         CL    R3,LSTPT                                            -EU-\n         BNH   PL890               PRINT LAST PAGE                 -EU-\n         XC    LSTPT,LSTPT                                         -EU-\n         B     PL870                                               -EU-\n         EJECT\n*        REPORT FINAL STATISTICS.                                  -EU-\n*        ------------------------                                  -EU-\n         SPACE 1\nPL900    OC    PAGELEN,PAGELEN     ANYTHING COMPUTED ?             -EU-\n         BZ    PL920               NO                              -EU-\n         UNPK  PGBSZ,TOTSZ(L'TOTSZ+1)   EDIT TOTAL PAGE(S) SPACE   -EU-\n         TR    PGBSZ,TOHEX-C'0'                                    -EU-\n         MVI   PGBSZ+L'PGBSZ-1,C' '                                -EU-\n         LA    R0,PGB                                              -EU-\n         BAS   R8,SWPRNT                                           -EU-\n         L     R1,TOTSZ            COMPUTE NEW LPA TOTAL           -EU-\n         A     R1,=F'4095'                                         -EU-\n         SRL   R1,12                                               -EU-\n         SLL   R1,12                                               -EU-\nSWTLS    NOP   *+L'*+12                                            -EU-\n         A     R1,TOTLSZ                                           -EU-\n         ST    R1,TOTLSZ                                           -EU-\n         B     *+L'*+8                                             -EU-\n         A     R1,TOTLSZX                                          -EU-\n         ST    R1,TOTLSZX                                          -EU-\nPL920    MVC   T3PGN,=XL4'40202120'                                -EU-\n         ED    T3PGN,PGN           PAGE NUMBER                     -EU-\n         LA    R0,T3               TITLE                           -EU-\n         BAS   R8,SWPRNT                                           -EU-\n         LA    R0,T4                                               -EU-\n         BAS   R8,SWPRNT                                           -EU-\n         CP    LPACTR,=PL1'+0'                                     -EU-\n         BNE   *+L'*+10                                            -EU-\n         CP    ASCTR,=PL1'+0'                                      -EU-\n         BE    NTSMP                                               -EU-\n         ED    TLPACTR,LPACTR      SHOW LPA FAULTS\n         ED    TASCCTR,ASCTR       ADDRESS SPACE FAULTS\n         LA    R0,TSMP             PRINT INFO ABOUT SAMPLES        -EU-\n         BAS   R8,SWPRNT                                           -EU-\nNTSMP    TM    SWITCH,SW16M        16M LINE ACTIVE ?               -EU-\n         BZ    *+L'*+10            NO                              -EU-\n         MVI   LPASEP+1,C'+'                                       -EU-\n         MVC   LPASIZX(L'LPASIZE+6),LPASIZE                        -EU-\n         L     R1,LPAHI            INFO ABOUT CURRENT LPA          -EU-\n         S     R1,LPALOW                                           -EU-\n         A     R1,=F'4095'                                         -EU-\n         SRL   R1,12                                               -EU-\n         SLL   R1,12                                               -EU-\n         CVD   R1,DWD                                              -EU-\n         ED    LPASIZE,DWD+3                                       -EU-\n         TM    SWITCH,SW16M        16M LINE ACTIVE ?               -EU-\n         BZ    PL930               NO                              -EU-\n         ST    R1,WORK                                             -EU-\n         L     R1,LPAHIX                                           -EU-\n         S     R1,LPALOWX                                          -EU-\n         A     R1,=F'4095'                                         -EU-\n         SRL   R1,12                                               -EU-\n         SLL   R1,12                                               -EU-\n         CVD   R1,DWD                                              -EU-\n         ED    LPASIZX,DWD+3                                       -EU-\n         A     R1,WORK                                             -EU-\n         ST    R1,WORK                                             -EU-\nPL930    LA    R0,TLSZ             PRINT INFO                      -EU-\n         BAS   R8,SWPRNT                                           -EU-\n         TM    SWITCH,SW16M        16M LINE ACTIVE ?               -EU-\n         BZ    PL950               NO                              -EU-\n         L     R1,WORK             GET TOTAL LPA SIZE              -EU-\n         CVD   R1,DWD                                              -EU-\n         ED    LPASZT,DWD+3                                        -EU-\n         LA    R0,TLSZT            PRINT INFO                      -EU-\n         BAS   R8,SWPRNT                                           -EU-\nPL950    TM    SWITCH,SW16M        16M LINE ACTIVE ?               -EU-\n         BZ    *+L'*+10            NO                              -EU-\n         MVI   TLBDSEPT+1,C'/'                                     -EU-\n         MVC   TLBDLXT,TLBDLT                                      -EU-\n         LA    R0,TLBDT            PRINT BOUNDARIES TITLE          -EU-\n         BAS   R8,SWPRNT                                           -EU-\n         UNPK  TLBDLL,LPALOW(L'LPALOW+1)                           -EU-\n         UNPK  TLBDLH,LPAHI(L'LPAHI+1)                             -EU-\n         TR    TLBDLL(L'TLBDLL+L'TLBDLH),TOHEX-C'0'                -EU-\n         MVI   TLBDLL+L'TLBDLL-1,C' '                              -EU-\n         MVI   TLBDLH+L'TLBDLH-1,C' '                              -EU-\n         TM    SWITCH,SW16M        16M LINE ACTIVE ?               -EU-\n         BZ    *+L'*+26            NO                              -EU-\n         UNPK  TLBDLXL,LPALOWX(L'LPALOWX+1)                        -EU-\n         UNPK  TLBDLXH,LPAHIX(L'LPAHIX+1)                          -EU-\n         TR    TLBDLXL(L'TLBDLXL+L'TLBDLXH),TOHEX-C'0'             -EU-\n         MVI   TLBDLXL+L'TLBDLXL-1,C' '                            -EU-\n         MVI   TLBDLXH+L'TLBDLXH-1,C' '                            -EU-\n         LA    R0,TLBD             PRINT BOUNDARIES                -EU-\n         BAS   R8,SWPRNT                                           -EU-\n         TM    SWITCH,SW16M        16M LINE ACTIVE ?               -EU-\n         BZ    *+L'*+10            NO                              -EU-\n         MVI   NEWLSEP+1,C'+'                                      -EU-\n         MVC   NEWLPSX(L'NEWLPSZ+6),NEWLPSZ                        -EU-\n         L     R1,TOTLSZ           INFO ABOUT NEW LPA SIZE         -EU-\n         CVD   R1,DWD                                              -EU-\n         ED    NEWLPSZ,DWD+3                                       -EU-\n         TM    SWITCH,SW16M        16M LINE ACTIVE ?               -EU-\n         BZ    *+L'*+14            NO                              -EU-\n         L     R1,TOTLSZX          INFO ABOUT NEW LPA SIZE         -EU-\n         CVD   R1,DWD                                              -EU-\n         ED    NEWLPSX,DWD+3                                       -EU-\n         LA    R0,PSZ              PRINT INFO                      -EU-\n         BAS   R8,SWPRNT                                           -EU-\n         TM    SWITCH,SW16M        16M LINE ACTIVE ?               -EU-\n         BZ    PL960               NO                              -EU-\n         L     R1,TOTLSZ           GET TOTAL DOWN 16M LINE         -EU-\n         A     R1,TOTLSZX          ADD TOTAL UP 16M LINE           -EU-\n         CVD   R1,DWD                                              -EU-\n         ED    TOTLPSZ,DWD+3                                       -EU-\n         LA    R0,PSZT             PRINT INFO                      -EU-\n         BAS   R8,SWPRNT                                           -EU-\nPL960    XR    R0,R0               INFO ABOUT WORK AREA USE        -EU-\n         L     R1,TAB+8                                            -EU-\n         SL    R1,TAB                                              -EU-\n         AL    R1,TAB+4                                            -EU-\n         ST    R1,TABSNPL                                          -EU-\n         D     R0,TAB+4                                            -EU-\n         CVD   R1,DWD                                              -EU-\n         ED    TABSIZE,DWD+5                                       -EU-\n         LA    R0,TSZ              PRINT INFO                      -EU-\n         BAS   R8,SWPRNT                                           -EU-\n         CP    TTETOT,=PL1'+0'                                     -EU-\n         BNE   *+L'*+10                                            -EU-\n         CP    TTEUSE,=PL1'+0'                                     -EU-\n         BE    NTRU                                                -EU-\n         ED    TOTTTE,TTETOT                                       -EU-\n         ED    USETTE,TTEUSE                                       -EU-\n         LA    R0,TRU              PRINT SAMPLER USE INFO          -EU-\n         BAS   R8,SWPRNT                                           -EU-\nNTRU     UNPK  DWD(5),DAY          DAY OF RUN                      -EU-\n        $GDATE PDAY,,,DWD                                          -EU-\n         LTR   R15,R15                                             -EU-\n         BNZ   NOPSI                                               -EU-\n         LA    R0,PSWI1                                            -EU-\n         BAS   R8,SWPRNT                                           -EU-\n         MVC   PSID,SID            SYSTEM ID                       -EU-\n         TM    STY,TMVSXA          SYSTEM TYPE                     -EU-\n         BZ    *+L'*+6                                             -EU-\n         MVC   PSTY,=CL4'XA) '                                     -EU-\n         LA    R0,PSWI2                                            -EU-\n         BAS   R8,SWPRNT                                           -EU-\n         LA    R1,PSTME                                            -EU-\n         L     R5,STRTME           START TIME                      -EU-\n         LA    R14,PL980                                           -EU-\nPL970    CL    R5,=F'100'          EDIT HH.MM.SS                   -EU-\n         BLR   R14                                                 -EU-\n         XR    R4,R4                                               -EU-\n         D     R4,=F'100'                                          -EU-\n         CL    R5,=F'60'                                           -EU-\n         BNL   *+L'*+8                                             -EU-\n         LR    R4,R5                                               -EU-\n         XR    R5,R5                                               -EU-\n         B     *+L'*+12                                            -EU-\n         XR    R4,R4                                               -EU-\n         D     R4,=F'60'                                           -EU-\n         LTR   R4,R4                                               -EU-\n         BZ    *+L'*+18                                            -EU-\n         CVD   R4,DWD                                              -EU-\n         UNPK  DWD(3),DWD+6(2)                                     -EU-\n         OC    6(2,R1),DWD+1                                       -EU-\n         XR    R4,R4                                               -EU-\n         CL    R5,=F'60'                                           -EU-\n         BNL   *+L'*+8                                             -EU-\n         LR    R4,R5                                               -EU-\n         XR    R5,R5                                               -EU-\n         B     *+L'*+10                                            -EU-\n         D     R4,=F'60'                                           -EU-\n         LTR   R4,R4                                               -EU-\n         BZ    *+L'*+16                                            -EU-\n         CVD   R4,DWD                                              -EU-\n         UNPK  DWD(3),DWD+6(2)                                     -EU-\n         OC    3(2,R1),DWD+1                                       -EU-\n         LTR   R5,R5                                               -EU-\n         BZR   R14                                                 -EU-\n         CVD   R5,DWD                                              -EU-\n         UNPK  DWD(3),DWD+6(2)                                     -EU-\n         OC    0(2,R1),DWD+1                                       -EU-\n         BR    R14                                                 -EU-\nPL980    LA    R1,PETME                                            -EU-\n         L     R5,ENDTME           END TIME                        -EU-\n         BAS   R14,PL970                                           -EU-\n         LA    R0,PSWI3                                            -EU-\n         BAS   R8,SWPRNT                                           -EU-\n         TM    STY,TMVSXA          SYSTEM TYPE                     -EU-\n         BZ    PLNTTES                                             -EU-\n         CP    COUNTER,=PL1'+0'                                    -EU-\n         BE    NONTTES                                             -EU-\n         ED    PUEXTS,COUNTER                                      -EU-\n         LA    R0,PSWI4B                                           -EU-\n         B     PLPSWI4                                             -EU-\nPLNTTES  LH    R1,NTTESTT          NO. OF TTE'S                    -EU-\n         LTR   R1,R1                                               -EU-\n         BZ    NONTTES                                             -EU-\n         CVD   R1,DWD                                              -EU-\n         ED    PNTTES,DWD+5                                        -EU-\n         LA    R0,PSWI4A                                           -EU-\nPLPSWI4  BAS   R8,SWPRNT                                           -EU-\nNONTTES  L     R5,WTIME            LAST WAIT TIME                  -EU-\n         CL    R5,=F'100000'                                       -EU-\n         BNL   *+L'*+6                                             -EU-\n         XR    R5,R5                                               -EU-\n         B     *+L'*+6                                             -EU-\n         XR    R4,R4                                               -EU-\n         D     R4,=F'100000'                                       -EU-\n         CVD   R5,DWD                                              -EU-\n         ED    PLTME,DWD+6                                         -EU-\n         LA    R0,PSWI5                                            -EU-\n         BAS   R8,SWPRNT                                           -EU-\n         L     R5,MDMTME           WAIT TIME AVERAGE               -EU-\n         CL    R5,=F'100000'                                       -EU-\n         BNL   *+L'*+6                                             -EU-\n         XR    R5,R5                                               -EU-\n         B     *+L'*+6                                             -EU-\n         XR    R4,R4                                               -EU-\n         D     R4,=F'100000'                                       -EU-\n         CVD   R5,DWD                                              -EU-\n         ED    PMTME,DWD+6                                         -EU-\n         LA    R0,PSWI6                                            -EU-\n         BAS   R8,SWPRNT                                           -EU-\nNOPSI    XR    R0,R0                                               -EU-\n         BAS   R8,SWPRNT                                           -EU-\n         SPACE 1                                                   -EU-\n        CLOSE  SYSPRINT\n         TM    SWPRNT+1,SETBR                                      -EU-\n         BZ    SWSNAP                                              -EU-\n         L     R0,=A(POOLSZ)                                       -EU-\n         L     R1,APOOL                                            -EU-\n        FREEMAIN R,A=(1),LV=(0)    FREE THE POOL OF LINES          -EU-\n         EJECT\n*        DUMP TABLE IF REQUESTED (DEBUG AID)                       -EU-\n*        -----------------------------------                       -EU-\n         SPACE 1                                                   -EU-\nSWSNAP   B     SM100               SNAP SWITCH                     -EU-\n         L     R3,TAB                                              -EU-\n        $SNAP  (R3),TABSNPL,DDSNAP                                 -EU-\n         LTR   R15,R15                                             -EU-\n         BZ    SM100                                               -EU-\n         LA    R1,400(R15)         SET USER ABEND 4XX *************-EU-\n         B     ABEND                                               -EU-\n         EJECT\n*        OUTPUT IEAPAK00 MEMBER                                    -EU-\n*        ----------------------                                    -EU-\n         SPACE 1                                                   -EU-\nSM100    TM    SWITCH,SWPNP                                        -EU-\n         BO    SM110                                               -EU-\n        OPEN   (SYSPUNCH,(OUTPUT))\n         LA    R1,203              SET USER ABEND 203 ****************\n         TM    SYSPUNCH+(DCBOFLGS-IHADCB),DCBOFOPN  SUCCESSFULL OPEN ?\n         BZ    ABEND               NO\nSM110    LA    R6,CS+1             CARD IMAGE POINTER\n         USING TBS,R4              TABLE DSECT                     -EU-\n         LR    R4,R2               STARTING PAGE-GROUP             -EU-\n         SPACE 1                                                   -EU-\nSM120    MVC   0(8,R6),TN          MOVE MODULE NAME\nSM130    LA    R6,1(,R6)           NEXT CHAR (KNOW FIRST WASN'T BLANK)\n         CLI   0(R6),C' '          BLANK ?\n         BNE   SM130               NO... CONTINUE SEARCH\n         L     R3,TPMFC            YES... GET FORWARD CHAIN        -EU-\n         LTR   R4,R3               ANYONE ?                        -EU-\n         BZ    SM200               NO... END OF PAGE-GROUP         -EU-\n         MVI   0(R6),C','          YES... COMMA AFTER NAME\n         BAS   R8,SM500            GO TO CONTROL CARD STORE        -EU-\n         B     SM120               GO MOVE ANOTHER                 -EU-\nSM200    MVI   0(R6),C')'          MOVE IN CLOSE PAREN\n         LA    R6,1(R6)            POINT PAST PAREN\n         L     R2,TPGBC-TBS(R2)    GET BACKWARD CHAIN              -EU-\n         LTR   R4,R2               ANYONE ?                        -EU-\n         BZ    SM900               NO... END OF PROCESS            -EU-\n         MVI   0(R6),C','          YES... COMMA AFTER GROUP\n         BAS   R8,SM500            GO TO CONTROL CARD STORE        -EU-\n         MVI   0(R6),C'('          MOVE IN OPEN PAREN\n         LA    R6,1(R6)            POINT PAST PAREN\n         B     SM120               GO MOVE ANOTHER                 -EU-\n         DROP  R4                                                  -EU-\n         SPACE 1\nSM500    LA    R6,1(,R6)           POINT PAST LAST CHAR INSERTED\n         CL    R6,=A(CS+60)        CARD FILLED ?                   -EU-\n         BLR   R8                  NO... RETURN\n         BAS   R7,SM600            PUNCH OR LIST CARD              -EU-\n         MVI   CS,C' '             BLANK CARD IMAGE\n         MVC   CS+1(L'CS-1),CS\n         LA    R6,CS               RESET CARD POINTER\n         BR    R8                  RETURN\n         SPACE 1                                                   -EU-\nSM600    AP    CSCTR,=PL1'+1'      PUNCH OR LIST ROUTINE           -EU-\n         UNPK  CSN,CSCTR                                           -EU-\n         OI    CSN+L'CSN-1,C'0'                                    -EU-\n         TM    SWITCH,SWPNP                                        -EU-\n         BO    SM610                                               -EU-\n        PUT    SYSPUNCH,CS         PUNCH CARD\n         BR    R7                                                  -EU-\nSM610    CLC   CSN+L'CSN-2(2),=CL2'01'                             -EU-\n         BE    SM620                                               -EU-\n         CLC   CSN+L'CSN-2(2),=CL2'51'                             -EU-\n         BNE   SM630                                               -EU-\nSM620    MVI   CSL,C'1'                                            -EU-\nSM630   $PRINT CSL,,DDLIST         LIST CARD                       -EU-\n         LTR   R15,R15                                             -EU-\n         BZ    SM640                                               -EU-\n         LA    R1,210(R15)         SET USER ABEND 21X *************-EU-\n         B     ABEND                                               -EU-\nSM640    MVI   CSL,C' '                                            -EU-\n         BR    R7                                                  -EU-\n         SPACE 1\nSM900    BAS   R7,SM600            PUNCH OR LIST LAST CARD         -EU-\n         TM    SWITCH,SWPNP                                        -EU-\n         BO    EXIT                                                -EU-\n        CLOSE  SYSPUNCH\n         EJECT\n*        NORMAL TERMINATION                                        -EU-\n*        ------------------                                        -EU-\n         SPACE 1\nEXIT    $PCLOSE ,                                                  -EU-\n         OC    TAB,TAB                                             -EU-\n         BZ    RETURN                                              -EU-\n        FREEMAIN LU,LA=TBSZG,A=TAB                                 -EU-\n         SPACE 1\nRETURN  $XRET  CC=(R9)                                             -EU-\n         SPACE 2\n*        ABNORMAL TERMINATION                                      -EU-\n*        --------------------                                      -EU-\n         SPACE 1                                                   -EU-\nABEND    NOP   ABENDD                                              -EU-\n         LR    R9,R1               PASS R.C.                       -EU-\n         TM    SYSLPA+(DCBOFLGS-IHADCB),DCBOFOPN  OPENED ?         -EU-\n         BZ    ABEND1              NO                              -EU-\n        CLOSE  SYSLPA                                              -EU-\nABEND1   TM    SYSDIR+(DCBOFLGS-IHADCB),DCBOFOPN  OPENED ?         -EU-\n         BZ    ABEND2              NO                              -EU-\n        CLOSE  SYSDIR                                              -EU-\nABEND2   TM    SYSPSW+(DCBOFLGS-IHADCB),DCBOFOPN  OPENED ?         -EU-\n         BZ    ABEND3              NO                              -EU-\n        CLOSE  SYSPSW                                              -EU-\nABEND3   TM    SYSPRINT+(DCBOFLGS-IHADCB),DCBOFOPN  OPENED ?       -EU-\n         BZ    ABEND4              NO                              -EU-\n        CLOSE  SYSPRINT                                            -EU-\nABEND4   TM    SYSPUNCH+(DCBOFLGS-IHADCB),DCBOFOPN  OPENED ?       -EU-\n         BZ    EXIT                NO                              -EU-\n        CLOSE  SYSPUNCH                                            -EU-\n         B     EXIT                                                -EU-\nABENDD   ABEND (1),DUMP,STEP,USER\n         EJECT\n*        CONSTANTS AND WORK-AREAS\n*        ------------------------\n         SPACE 1\nDWD      DC    D'0'\nWORK     DC    F'0'                                                -EU-\nSVREGS   DC    2F'0'                                               -EU-\nTBSZG    DC    0F'0',XL1'80',AL3(SZG)                              -EU-\nTBSZ     DC    A(NLPA*TBL)                                         -EU-\nTAB      DC    A(*-*,TBL,*-*)\nSTT      DC    A(*-*,*-*,*-*)                                      -EU-\nTAB16M   DC    A(*-*)              16M LINE TABLE POINTER          -EU-\nTABSNPL  DC    A(*-*)                                              -EU-\nAPOOL    DC    A(*-*)                                              -EU-\nCURPT    DC    A(*-*)                                              -EU-\nLSTPT    DC    A(*-*)                                              -EU-\nPAGELEN  DC    F'0'\nTOTSZ    DC    F'0'                                                -EU-\nTOTLSZ   DC    F'0'                                                -EU-\nTOTLSZX  DC    F'0'                                                -EU-\nPSI      DS    0F  - - - - - - - - PSW SAMPLER INFO                -EU-\nSTY      DC    AL1(0)                ...                           -EU-\nDAY      DC    XL3'0'                ...                           -EU-\nSID      DC    CL4' '                ...                           -EU-\nSTRTME   DC    F'0'                  ...                           -EU-\nENDTME   DC    F'0'                  ...                           -EU-\nMDMTME   DC    F'0'                  ...                           -EU-\nWTIME    DC    F'0'                  ...                           -EU-\nNTTESTT  DC    0H'0'                 ...                           -EU-\nCOUNTER  DC    PL4'+0'               ...                           -EU-\nPSIL     EQU   *-PSI   - - - - - - - ---                           -EU-\nLPALOW   DC    0F'0',X'7FFFFFFF'\nLPAHI    DC    0F'0',X'00000000'\nLPALOWX  DC    0F'0',X'7FFFFFFF'                                   -EU-\nLPAHIX   DC    0F'0',X'00000000'                                   -EU-\nLPAUP    DC    A(16*1024*1024)     16M LINE                        -EU-\nTOBIN    DC    256X'0'\n         ORG   TOBIN+C'A'               POSITION TO 'A'\n         DC    X'0A0B0C0D0E0F'          TRANSLATE A-F\n         ORG   TOBIN+C'0'               POSITION AT '0'\n         DC    X'00010203040506070809'  TRANSLATE 0-9\n         ORG\nDDLIST   DC    CL8'SYSLIST'                                        -EU-\nDDSNAP   DC    CL8'SYSSNAP'                                        -EU-\nTOHEX    DC    CL16'0123456789ABCDEF'\nSORTTEST DC    H'0'\nTTETOT   DC    PL5'+0'                                             -EU-\nTTEUSE   DC    PL5'+0'                                             -EU-\nASCTR    DC    PL4'+0'\nLPACTR   DC    PL4'+0'\nCSCTR    DC    PL3'+0'                                             -EU-\nCTR      DC    PL2'+0'\nPGN      DC    PL2'+1'\nSWITCH   DC    X'0'\nSWPPB    EQU   X'01'               PROCESS PAGE BOUNDARIES         -EU-\nSWSRT    EQU   X'02'               SORT TABLE IN TWO PARTS (16M)   -EU-\nSWPNP    EQU   X'08'               LIST IN PLACE OF PUNCH IEAPAK00 -EU-\nSWPRS    EQU   X'10'               PROCESS RIGHT SIDE OF PAGE      -EU-\nSW16M    EQU   X'40'               PROCESS UP 16M LINE ALSO        -EU-\nSWNEW    EQU   X'80'               NEW FORMAT AMBLIST (LISTLPA)    -EU-\n         SPACE 1\n         DS    0F                                                  -EU-\nP        DS    0CL62               PRINT LINE - SINGLE SPACE\n         DC    C' '                SINGLE SPACE\nPN       DC    CL8' '              MODULE NAME\n         DC    CL1' '\nPT       DS    0CL18               TRANSLATE TO HEX\nPS       DC    CL9' '                   MODULE START ADDRESS\nPL       DC    CL9' '                   LENGTH OF MODULE\n         DS    0CL18               MOVE EDIT MASK HERE\nPF       DC    CL9' '                   NUMBER OF FAULTS\nPFL      DC    CL9' '                   FACTOR\n         DC    CL16' '\n         SPACE 1\nT1       DS    0CL62\n         DC    CL47'1 NAME     START    LENGTH    COUNTS   C/L     '\n         DC    CL6'  PAGE'                                         -EU-\nT1PGN    DC    CL4' ',CL5'. '                                      -EU-\n         SPACE 1\nT2       DS    0CL62\n         DC    CL47' -------- -------- --------  -------- -------- '\n         DC    CL15' '\n         SPACE 1                                                   -EU-\nT3       DS    0CL62                                               -EU-\n         DC    CL36'1 P A C K L I S T  -  P S W S A M P ',CL11' '  -EU-\n         DC    CL6'  PAGE'                                         -EU-\nT3PGN    DC    CL4' ',CL5'. '                                      -EU-\n         SPACE 1                                                   -EU-\nT4       DS    0CL62                                               -EU-\n         DC    CL36'  --------------------------------- '          -EU-\n         DC    CL26' '                                             -EU-\n         SPACE 1\nPGB      DS    0CL62\n         DC    19C' '                                              -EU-\n         DC    CL30'---------------- TOTAL SIZE :'                 -EU-\nPGBSZ    DC    CL9' ',CL4' '                                       -EU-\n         SPACE 1\nTSMP     DS    0CL62\n         DC    CL2'0 ',CL12'LPA FAULTS :'                          -EU-\nTLPACTR  DC    XL10'40204B2020204B202120'\n         DC    CL16' / A.S. FAULTS :'                              -EU-\nTASCCTR  DC    XL10'40204B2020204B202120',CL12' '\n         SPACE 1\nTLSZ     DS    0CL62\n         DC    CL2'0 ',CL10'LPA-SIZE :'\nLPASIZE  DC    XL12'402020204B2020204B202120',CL6' BYTES'\nLPASEP   DC    CL3' '                                              -EU-\nLPASIZX  DC    CL12' ',CL6' ',CL10' '                              -EU-\n         SPACE 1                                                   -EU-\nTLSZT    DS    0CL62                                               -EU-\n         DC    CL13' ',CL12'TOTAL SIZE :'                          -EU-\nLPASZT   DC    XL12'402020204B2020204B202120',CL25' BYTES'         -EU-\n         SPACE 1                                                   -EU-\nTLBDT    DS    0CL62                                               -EU-\n         DC    CL2' ',CL13'BOUNDARIES :'                           -EU-\nTLBDLT   DC    CL17'  LOW   -  HIGH  '                             -EU-\nTLBDSEPT DC    CL3' '                                              -EU-\nTLBDLXT  DC    CL17' ',CL10' '                                     -EU-\n         SPACE 1                                                   -EU-\nTLBD     DS    0CL62                                               -EU-\n         DC    CL15' '                                             -EU-\nTLBDLL   DC    CL9' '                                              -EU-\nTLBDLH   DC    CL9' ',CL2' '                                       -EU-\nTLBDLXL  DC    CL9' '                                              -EU-\nTLBDLXH  DC    CL9' ',CL9' '                                       -EU-\n         SPACE 1                                                   -EU-\nPSZ      DS    0CL62                                               -EU-\n         DC    CL2'0 ',CL14'NEW LPA-SIZE :'                        -EU-\nNEWLPSZ  DC    XL12'402020204B2020204B202120',CL6' BYTES'          -EU-\nNEWLSEP  DC    CL3' '                                              -EU-\nNEWLPSX  DC    CL12' ',CL6' ',CL7' '                               -EU-\n         SPACE 1                                                   -EU-\nPSZT     DS    0CL62                                               -EU-\n         DC    CL17' ',CL12'TOTAL SIZE :'                          -EU-\nTOTLPSZ  DC    XL12'402020204B2020204B202120',CL21' BYTES'         -EU-\n         SPACE 1                                                   -EU-\nTSZ      DS    0CL62                                               -EU-\n         DC    CL2'0 ',CL10'TAB-SIZE :'                            -EU-\nTABSIZE  DC    XL6'402020202120',CL44' (NLPA VALUE)'               -EU-\n         SPACE 1                                                   -EU-\nTRU      DS    0CL62                                               -EU-\n         DC    CL2'0 ',CL9'TOT-TTE :'                              -EU-\nTOTTTE   DC    XL12'402020204B2020204B202120'                      -EU-\n         DC    CL12' / USE-TTE :'                                  -EU-\nUSETTE   DC    XL12'402020204B2020204B202120',CL15' '              -EU-\n         SPACE 1                                                   -EU-\nPSWI1    DS    0CL62                                               -EU-\n         DC    CL2'0 ',CL23'PSWSAMP - DAY OF RUN :'                -EU-\nPDAY     DC    CL20' ',CL17' '                                     -EU-\n         SPACE 1                                                   -EU-\nPSWI2    DS    0CL62                                               -EU-\n         DC    CL12' ',CL17'RUNNING SYSTEM :'                      -EU-\nPSID     DC    CL4' ',CL6' (MVS/'                                  -EU-\nPSTY     DC    CL4'370)',CL19' '                                   -EU-\n         SPACE 1                                                   -EU-\nPSWI3    DS    0CL62                                               -EU-\n         DC    CL12'0 ',CL8'START :'                               -EU-\nPSTME    DC    CL8'00.00.00',CL10' / STOP :'                       -EU-\nPETME    DC    CL8'00.00.00',CL16' '                               -EU-\n         SPACE 1                                                   -EU-\nPSWI4A   DS    0CL62                                               -EU-\n         DC    CL12'0 ',CL31'DYNAMIC TRACE TABLE HAS HANDLED'      -EU-\nPNTTES   DC    XL6'402020202120',CL6' TTE''S',CL7' '               -EU-\nPSWI4B   DS    0CL62                                               -EU-\n         DC    CL12'0 ',CL30'UNKNOWN EX-TTE''S ENCOUNTERED :'      -EU-\nPUEXTS   DC    XL8'4020202020202120',CL12' (IN ''TBUF'')'          -EU-\n         SPACE 1                                                   -EU-\nPSWI5    DS    0CL62                                               -EU-\n         DC    CL17'0 ',CL16'LAST WAIT TIME :'                     -EU-\nPLTME    DC    XL5'4021206B20',CL24' SECONDS'                      -EU-\n         SPACE 1                                                   -EU-\nPSWI6    DS    0CL62                                               -EU-\n         DC    CL17' ',CL19'WAIT TIME AVERAGE :'                   -EU-\nPMTME    DC    XL5'4021206B20',CL21' SECONDS'                      -EU-\n         SPACE 1\n         DC    A(L'CSL+L'CS+L'CSN+4)                               -EU-\nCSL      DC    CL10' '                                             -EU-\nCS       DC    CL72'( '                                            -EU-\nCSN      DC    CL4' ',CL4'0000'                                    -EU-\n         SPACE 1\n         DC    A(L'PI)                                             -EU-\nPI       DS    0CL121              PRINT IMAGE FROM OUTPUT HERE\nCC       DC    CL1' '              PRINTER CARRIAGE CONTROL CHARACTER\nS1       DC    CL60' '             SEGMENT ONE\nS2       DC    CL60' '             SEGMENT TWO\n         SPACE 1\nLPMNUM   DC    C'LINK PACK MAP - NUMERICALLY BY'                   -EU-\nLPMNEW   DC    C'PAGEABLE LINK PACK AREA MAP -  NUMERICALLY BY'    -EU-\n         EJECT ,\n        LTORG  ,\n         SPACE 2\n         PRINT NOGEN\nSYSLPA   DCB   DDNAME=SYSLPA,DSORG=PS,MACRF=GM,EODAD=IT900\nSYSDIR   DCB   DDNAME=SYSDIR,DSORG=PS,MACRF=GM,EODAD=DR900\nSYSPSW   DCB   DDNAME=SYSPSW,DSORG=PS,MACRF=GL,RECFM=F,EODAD=RS900\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,RECFM=FA,LRECL=131\nSYSPUNCH DCB   DDNAME=SYSPUNCH,DSORG=PS,MACRF=PM,LRECL=80\n         EJECT\nTBS      DSECT                  -- TABLE ENTRY FOR LPA MODULE\nTN       DS    CL8                 NAME\nTS       DS    CL4                 START ADDRESS\nTL       DS    CL4                 LENGTH\nTF       DS    CL4                 NUMBER OF FAULTS\nTFL      DS    F                   FAULTS DIVIDED BY LENGTH\nTPGBC    DS    A                   PAGE-GROUPS BACKWARD CHAIN      -EU-\nTPMFC    DS    A                   PAGE-MODULES FORWARD CHAIN      -EU-\nTMATTR1  DS    X                   MODULE ATTR. BYTE 1 (PDS2ATR1)  -EU-\nTMATTR2  DS    X                   MODULE ATTR. BYTE 2 (PDS2ATR2)  -EU-\nTMATTR3  DS    X                   MODULE ATTR. BYTE 3 (PDS2FTB1)  -EU-\n         DS    X                   - NOT USED -                    -EU-\nTBL      EQU   *-TBS               LENGTH OF TABLE ENTRY\n         SPACE 1\nLPAE     DSECT                  -- LPA LIST PRINT SEGMENT\nLN       DS    CL8                 MODULE NAME\n         DS    C\nLX       DS    0CL17               TRANSLATE NEXT 17 BYTES\nLS       DS    CL6                      START ADDRESS\n         DS    CL4\nLL       DS    CL6                      LENGTH\n         DS    CL4                      ... ETC ...\n         ORG   LX                                                  -EU-\nLXN      DS    0CL19               TRANSLATE NEXT 19 BYTES         -EU-\nLSN      DS    CL8                      START ADDRESS              -EU-\n         DS    CL2                                                 -EU-\nLLN      DS    CL8                      LENGTH                     -EU-\n         DS    CL2                      ... ETC ...                -EU-\n         SPACE 1                                                   -EU-\nIEHL     DSECT                  -- IEHLIST PRINT SEGMENT           -EU-\nMARGIN   DS    CL10                                                -EU-\nMNAME    DS    CL8                 MODULE NAME                     -EU-\n         DS    CL2,CL8             TTRC                            -EU-\n         DS    CL2,CL10            VARIABLE USER DATA ...          -EU-\n         DS    CL1,CL6             ...                             -EU-\nMATT1    DS    CL4                 MODULE ATTRIBUTES               -EU-\n         DS    CL1,CL10            ...                             -EU-\n         DS    CL1,CL6             ...                             -EU-\nMATT2    DS    CL2                 MODULE ATTRIBUTES               -EU-\n         DS    CL2                 ... ETC ...                     -EU-\n         SPACE 1\n        DCBD   DSORG=PS,DEVD=TA\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDFINIT": {"ttr": 27140, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90 \\x8f\\x00\\x90 \\x8f\\x11\\x01\\x02\\x0e\\x02\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-07-27T00:00:00", "modifydate": "1990-07-27T11:01:00", "lines": 526, "newlines": 526, "modlines": 0, "user": "SYSPAJA"}, "text": "PDFI     TITLE 'PDFINIT - DYNAMIC ALLOCATION COMMAND FOR ISPF/PDF.'\nPDFINIT  START 0\n         SPACE 1\n* PURPOSE :    THIS COMMAND WILL ALLOCATE THE PDF PROFILE DATA-SET AT\n* ---------    LOGON TIME OR MAY BE INVOKED PRIOR TO INVOKING ISPF/PDF.\n*              THIS IS CONSIDERABLY FASTER THAN USING A CLIST TO\n*              ALLOCATE. THE PDF DATA-SET IS ALLOCATED AS OLD AND IF\n*              UNABLE TO ALLOCATE, TRIES TO ALLOCATE AND CATALOG A NEW\n*              PROFILE DATA-SET.\n*\n*              CURRENT ALLOCATION IS AS :                          -EU-\n*              ATTR FB3120 RECFM(F B) LRECL(80) BLKSIZE(3120)\n*              ALLOC F(ISPPROF) DA('USERID.SPF.PROF') -\n*                    UNIT(DISK) VOL(USER01) TRA SP(1 1) -\n*                    DSORG(PO) DIR(3) US(FB3120)\n*\n*              ALLOCATION DEFAULTS CAN BE CHANGED IN THE DC'S AS\n*              DESIRED. - I.E. : DSNAME, VOLSER, UNIT, ETC...\n*              CODE COULD BE ADDED TO TELL THE USER WHY THE ALLOCATION\n*              FAILED - BE MY GUEST. WE JUST FILTER OUT THE OBVIOUS\n*              ERROR AND RESPOND BACK WITH THE RETURN CODE, ERROR CODE\n*              AND INFO CODE IF A REAL ERROR OCCURS.\n*\n*              THIS MODULE MAY BE ASSEMBLED AND LINKED INTO A LINKLIST\n*              LIBRARY OR INTO LPALIB.\n*\n*              THE INVOCATION AT LOGON TIME IS BY USING THE PARM FIELD\n*              ON THE EXEC STATEMENT IN THE LOGON PROCEDURE.\n*\n* ALLOCATION CHANGE (BY MOINIL P.A.) :                             -EU-\n*              THE ALLOCATION HAS BEEN CHANGED FROM OLD TO SHR     -EU-\n*              TO PERMIT THE USE OF OUR SYSTEM SECTOR SHORT        -EU-\n*              COMMUNICATION FEATURE TO RUN.                       -EU-\n*\n* CBT ORIGIN : EXTRACTED FROM CBT TAPE FEB 85, FILE 361.\n* ------------ ADAPTED BY : MOINIL P.A.\n*                           COMPUTING CENTRE\n*                           J.R.C. - ISPRA ESTABLISHMENT\n*                           21020 ISPRA (VA), ITALY\n         EJECT\nPDFINIT AMODE  24                                                  -EU-\nPDFINIT RMODE  24                                                  -EU-\n         SPACE 1                                                   -EU-\n        $DEFREG ,                                                  -EU-\n         EJECT\n        $XENT  BASE=R12,LV=AREALEN,TYPE=RENT                       -EU-\n         LR    R10,R13        SAVE POINTER TO GOTTEN AREA\n         USING WORKAREA,R10   SET ADDRESSABILITY TO SAVE/WORK AREA\n         XC    DW(L'DW),DW    CLEAR GOTTEN AREAS TO ZERO           -EU-\n         XC    RBS99(RBS99L),RBS99                                 -EU-\n         XC    RBIP1(RBILSTL),RBIP1                                -EU-\n         XC    RBOP1(RBOLSTL),RBOP1                                -EU-\n         XC    RBAP1(RBALSTL),RBAP1                                -EU-\n         MVI   ERRMSG,C' '    SET MESSAGE AREA TO BLANKS           -EU-\n         MVC   ERRMSG+1(ERRMSGL-1),ERRMSG                          -EU-\n         MVC   ERRMSGAB,=CL3'***'                                  -EU-\n         MVC   ERRMSGAE,=CL3'***'                                  -EU-\n         XC    WK(L'WK+L'WKDSNL+L'WKDSN),WK                        -EU-\n         EJECT                                                     -EU-\n*        BUILD PROFILE DATA-SET NAME.                              -EU-\n         SPACE 1                                                   -EU-\n         L     R1,CVTPTR      LOAD CVT ADDR\n         USING CVT,R1                                              -EU-\n         L     R1,CVTTCBP     LOAD TCB/ASCB PTR\n         DROP  R1                                                  -EU-\n         L     R1,12(R1)      LOAD CURRENT ASCB ADDRESS\n         USING ASCB,R1                                             -EU-\n         L     R1,ASCBJBNS    LOAD USERID ADDRESS\n         DROP  R1                                                  -EU-\n         LA    R2,6(,R1)      GET THE TSO USERID TO USE AS PREFIX  -EU-\n         LA    R3,6                                                -EU-\n         CLI   0(R2),C' '                                          -EU-\n         BNE   *+L'*+6                                             -EU-\n         BCTR  R2,0                                                -EU-\n         BCT   R3,*-10                                             -EU-\n         LA    R4,WKDSN                                            -EU-\n         B     *+L'*+6                                             -EU-\n         MVC   0(*-*,R4),0(R1)     <<EXECUTED>>                    -EU-\n         EX    R3,*-6         MOVE USERID INTO NAME                -EU-\n         LA    R4,1(R3,R4)                                         -EU-\n         MVC   0(L'DSNAME,R4),DSNAME    MOVE SKELETON NAME         -EU-\n         LA    R3,L'DSNAME+1(,R3)                                  -EU-\n         STCM  R3,B'0011',WKDSNL                                   -EU-\n         EJECT\n*        BUILD SVC99 REQUEST BLOCKS IN GOTTEN AREA\n*        TO RETRIEVE THE PROFILE DDNAME EXISTANCY.                 -EU-\n         SPACE 1\n         LA    R7,RBS99       BUILD S99 RB PTR\n         ST    R7,RBPS99\n         OI    RBPS99,S99RBPND\n         USING S99RB,R7\n         MVI   S99RBLN,S99RBEND-S99RB   BUILD S99 RB\n         MVI   S99VERB,S99VRBIN\n         LA    R6,RBIP1\n         ST    R6,S99TXTPP\n         LA    R5,RBITU1      BUILD RBITU1 - DDNAME\n         ST    R5,RBIP1\n         USING S99TUNIT,R5\n         MVC   S99TUKEY,=AL2(DINDDNAM)\n         MVC   S99TUNUM,=XL2'1'\n         MVC   S99TULNG,=AL2(L'DDNAME)\n         MVC   S99TUPAR(L'DDNAME),DDNAME\n         LA    R5,RBITU5      BUILD RBITU5 - RETURN DSNAME         -EU-\n         ST    R5,RBIP5                                            -EU-\n         MVC   S99TUKEY,=AL2(DINRTDSN)                             -EU-\n         MVC   S99TUNUM,=XL2'1'                                    -EU-\n         MVC   S99TULNG,=AL2(44)                                   -EU-\n         MVI   S99TUPAR,C' '                                       -EU-\n         MVC   S99TUPAR+1(43),S99TUPAR                             -EU-\n         OI    RBIP5,S99TUPLN FLAG END OF LIST\n         DROP  R5\n         LA    R1,RBPS99      LOAD PARAMETER POINTER FOR SVC99\n        DYNALLOC ,            ISSUE SVC99\n         LTR   R15,R15        CHECK RETURN CODE\n         BNZ   ANRETRV                                             -EU-\n         LA    R5,RBITU5      ANALYZE RBITU5 - RETURN DSNAME       -EU-\n         USING S99TUNIT,R5                                         -EU-\n         CLC   S99TULNG,WKDSNL                                     -EU-\n         BNE   PREDEFN                                             -EU-\n         XR    R1,R1                                               -EU-\n         ICM   R1,B'0011',WKDSNL                                   -EU-\n         BCT   R1,*+L'*+6                                          -EU-\n         CLC   S99TUPAR(*-*),WKDSN <<EXECUTED>>                    -EU-\n         EX    R1,*-6                                              -EU-\n         BNE   PREDEFN                                             -EU-\n         BAS   R8,PERMDS      PERM. ALL.                           -EU-\n         B     RETURN                                              -EU-\n         EJECT                                                     -EU-\n*        AN OTHER PROFILE DATA-SET IS IN USE.                      -EU-\n         SPACE 1                                                   -EU-\nPREDEFN  MVI   WARNING,C' '   SET MESSAGE AREA TO BLANKS           -EU-\n         MVC   WARNING+1(WARNINGL-1),WARNING                       -EU-\n         MVC   WARNINGA,=CL3'---'                                  -EU-\n         MVC   WARNINGT,=CL23'ISPF PROFILE DATA-SET :'             -EU-\n         XR    R1,R1                                               -EU-\n         ICM   R1,B'0011',S99TULNG                                 -EU-\n         BCT   R1,*+L'*+6                                          -EU-\n         MVC   WARNINGN(*-*),S99TUPAR   <<EXECUTED>>               -EU-\n         EX    R1,*-6                                              -EU-\n         DROP  R5                                                  -EU-\n         BAS   R8,PERMDS      PERM. ALL.                           -EU-\n         LA    R1,WARNING                                          -EU-\n         LA    R0,WARNINGL                                         -EU-\n         B     TPUT                                                -EU-\nANRETRV  CLC   S99ERROR,=XL2'0438' SEE IF DDNAME NOT FOUND\n         BE    ALLOCSHR       ... OK, NO ERROR AFTER ALL\n         BAS   R8,ERRMSGPR    GO TELL USER OF ERROR\n         DC    CL8'AL.INF :'                                       -EU-\n         EJECT\n*        BUILD SVC99 REQUEST BLOCKS IN GOTTEN AREA\n*        TO ALLOCATE THE PROFILE DATA-SET AS 'SHR' WITH            -EU-\n*        PERMANENTLY ALLOCATED ATTRIBUTE (AGAINST FREE ALL).       -EU-\n         SPACE 1\nALLOCSHR XC    S99ERROR(L'S99ERROR+L'S99INFO),S99ERROR             -EU-\n         MVI   S99VERB,S99VRBAL    BUILD S99 RB\n         MVI   S99FLG11,S99NOCNV\n         LA    R6,RBOP1\n         ST    R6,S99TXTPP\n         LA    R5,RBOTU1      BUILD RBOTU1 - DDNAME\n         ST    R5,RBOP1\n         USING S99TUNIT,R5\n         MVC   S99TUKEY,=AL2(DALDDNAM)\n         MVC   S99TUNUM,=XL2'1'\n         MVC   S99TULNG,=AL2(L'DDNAME)\n         MVC   S99TUPAR(L'DDNAME),DDNAME\n         LA    R5,RBOTU2      BUILD RBOTU2 - DSNAME\n         ST    R5,RBOP2\n         MVC   S99TUKEY,=AL2(DALDSNAM)\n         MVC   S99TUNUM,=XL2'1'\n         XR    R1,R1                                               -EU-\n         ICM   R1,B'0011',WKDSNL                                   -EU-\n         STCM  R1,B'0011',S99TULNG                                 -EU-\n         BCT   R1,*+L'*+6                                          -EU-\n         MVC   S99TUPAR(*-*),WKDSN <<EXECUTED>>                    -EU-\n         EX    R1,*-6                                              -EU-\n         LA    R5,RBOTU4      BUILD RBOTU4 - STATUS\n         ST    R5,RBOP4\n         MVC   S99TUKEY,=AL2(DALSTATS)\n         MVC   S99TUNUM,=XL2'1'\n         MVC   S99TULNG,=XL2'1'\n         MVI   S99TUPAR,DA08SHR    SET FOR SHR\n         LA    R5,RBOTU5      BUILD RBOTU5 - DISPOSITION\n         ST    R5,RBOP5\n         MVC   S99TUKEY,=AL2(DALNDISP)\n         MVC   S99TUNUM,=XL2'1'\n         MVC   S99TULNG,=XL2'1'\n         MVI   S99TUPAR,DA08KEEP   SET FOR KEEP\n         LA    R5,RBOTU52     BUILD RBOTU52 - PERM. ALLOC. ATTR.\n         ST    R5,RBOP52\n         MVC   S99TUKEY,=AL2(DALPERMA)\n         MVC   S99TUNUM(L'S99TUNUM),=XL4'0'\n         OI    RBOP52,S99TUPLN     FLAG END OF LIST\n         DROP  R5\n         EJECT\n*        TRY TO ALLOCATE THE PROFILE DATA-SET AS SHR.              -EU-\n         SPACE 1\n         LA    R1,RBPS99      LOAD PARAMETER POINTER FOR SVC99\n        DYNALLOC ,            ISSUE SVC99\n         LTR   R15,R15        CHECK SVC99 RETURN CODE\n         BNZ   ANALSHR        GO ANALYZE IT                        -EU-\n         BAS   R8,PERMDS      PERM. ALL.                           -EU-\n         B     RETURN         WE ALLOCATED IT AS SHR - LETS GO HOME\nANALSHR  CLC   S99ERROR,=XL2'1708' SEE IF DSNAME NOT FOUND\n         BE    ALLOCNEW       ... OK, NO ERROR AFTER ALL\n         BAS   R8,ERRMSGPR    GO TELL USER OF ERROR\n         DC    CL8'AL.SHR :'                                       -EU-\n         EJECT\n*        OK - MUST NOT HAVE ONE SO LETS BUILD A NEW PROFILE\n*        DATA-SET. BUILD MORE SVC99 REQUEST BLOCKS IN GOTTEN\n*        AREA TO ALLOCATE THE PROFILE DATA-SET AS 'NEW,CATLG'\n*        WITH PERMANENTLY ALLOCATED ATTRIBUTE (AGAINST FREE ALL).  -EU-\n         SPACE 1\nALLOCNEW XC    S99ERROR(L'S99ERROR+L'S99INFO),S99ERROR             -EU-\n         LA    R6,RBAP1\n         ST    R6,S99TXTPP\n         LA    R5,RBATU1      BUILD RBATU1 - DDNAME\n         ST    R5,RBAP1\n         USING S99TUNIT,R5\n         MVC   S99TUKEY,=AL2(DALDDNAM)\n         MVC   S99TUNUM,=XL2'1'\n         MVC   S99TULNG,=AL2(L'DDNAME)\n         MVC   S99TUPAR(L'DDNAME),DDNAME\n         LA    R5,RBATU2      BUILD RBATU2 - DSNAME\n         ST    R5,RBAP2\n         MVC   S99TUKEY,=AL2(DALDSNAM)\n         MVC   S99TUNUM,=XL2'1'\n         XR    R1,R1                                               -EU-\n         ICM   R1,B'0011',WKDSNL                                   -EU-\n         STCM  R1,B'0011',S99TULNG                                 -EU-\n         BCT   R1,*+L'*+6                                          -EU-\n         MVC   S99TUPAR(*-*),WKDSN <<EXECUTED>>                    -EU-\n         EX    R1,*-6                                              -EU-\n         LA    R5,RBATU4      BUILD RBATU4 - STATUS\n         ST    R5,RBAP4\n         MVC   S99TUKEY,=AL2(DALSTATS)\n         MVC   S99TUNUM,=XL2'1'\n         MVC   S99TULNG,=XL2'1'\n         MVI   S99TUPAR,DA08NEW    SET FOR NEW\n         LA    R5,RBATU5      BUILD RBATU5 - DISPOSITION\n         ST    R5,RBAP5\n         MVC   S99TUKEY,=AL2(DALNDISP)\n         MVC   S99TUNUM,=XL2'1'\n         MVC   S99TULNG,=XL2'1'\n         MVI   S99TUPAR,DA08CAT    SET FOR CATLG\n         LA    R5,RBATU7      BUILD RBATU7 - TRACK ALLOCATION\n         ST    R5,RBAP7\n         MVC   S99TUKEY,=AL2(DALTRK)\n         MVC   S99TUNUM(L'S99TUNUM),=XL4'0'\n         LA    R5,RBATUA      BUILD RBATUA - PRIMARY SPACE\n         ST    R5,RBAPA\n         MVC   S99TUKEY,=AL2(DALPRIME)\n         MVC   S99TUNUM,=XL2'1'\n         MVC   S99TULNG,=XL2'3'\n         MVC   S99TUPAR(3),TRKS    SET FOR # TRACK\n         LA    R5,RBATUB      BUILD RBATUB - SECONDARY SPACE\n         ST    R5,RBAPB\n         MVC   S99TUKEY,=AL2(DALSECND)\n         MVC   S99TUNUM,=XL2'1'\n         MVC   S99TULNG,=XL2'3'\n         MVC   S99TUPAR(3),TRKS    SET FOR # TRACK\n         LA    R5,RBATUC      BUILD RBATUC - DIRECTORY BLKS\n         ST    R5,RBAPC\n         MVC   S99TUKEY,=AL2(DALDIR)\n         MVC   S99TUNUM,=XL2'1'\n         MVC   S99TULNG,=XL2'3'\n         MVC   S99TUPAR(3),DIRBLKS SET FOR # DIR BLK\n         LA    R5,RBATU10     BUILD RBATU10 - VOLSER\n         ST    R5,RBAP10\n         MVC   S99TUKEY,=AL2(DALVLSER)\n         MVC   S99TUNUM,=XL2'1'\n         MVC   S99TULNG,=XL2'6'\n         MVC   S99TUPAR(6),VOLSER  MOVE IN VOLSER\n         LA    R5,RBATU15     BUILD RBATU15 - UNIT\n         ST    R5,RBAP15\n         MVC   S99TUKEY,=AL2(DALUNIT)\n         MVC   S99TUNUM,=XL2'1'\n         MVC   S99TULNG,=AL2(L'UNIT)\n         MVC   S99TUPAR(L'UNIT),UNIT    MOVE IN UNIT\n         LA    R5,RBATU30     BUILD RBATU30 - BLKSIZE\n         ST    R5,RBAP30\n         MVC   S99TUKEY,=AL2(DALBLKSZ)\n         MVC   S99TUNUM,=XL2'1'\n         MVC   S99TULNG,=XL2'2'\n         MVC   S99TUPAR(2),BLKSIZE MOVE IN BLKSIZE\n         LA    R5,RBATU3C     BUILD RBATU3C - DSORG\n         ST    R5,RBAP3C\n         MVC   S99TUKEY,=AL2(DALDSORG)\n         MVC   S99TUNUM,=XL2'1'\n         MVC   S99TULNG,=XL2'2'\n         MVC   S99TUPAR(2),=AL1(DCBDSGPO,0)  MOVE IN DSORG=PO\n         LA    R5,RBATU42     BUILD RBATU42 - LRECL\n         ST    R5,RBAP42\n         MVC   S99TUKEY,=AL2(DALLRECL)\n         MVC   S99TUNUM,=XL2'1'\n         MVC   S99TULNG,=XL2'2'\n         MVC   S99TUPAR(2),LRECL   MOVE IN LRECL\n         LA    R5,RBATU49     BUILD RBATU49 - RECFM\n         ST    R5,RBAP49\n         MVC   S99TUKEY,=AL2(DALRECFM)\n         MVC   S99TUNUM,=XL2'1'\n         MVC   S99TULNG,=XL2'1'\n         MVI   S99TUPAR,DCBRECF+DCBRECBR     MOVE IN RECFM=FB\n         LA    R5,RBATU52     BUILD RBATU52 - PERM. ALLOC. ATTR.\n         ST    R5,RBAP52\n         MVC   S99TUKEY,=AL2(DALPERMA)\n         MVC   S99TUNUM(L'S99TUNUM),=XL4'0'\n         OI    RBAP52,S99TUPLN     FLAG END OF LIST\n         DROP  R5\n         EJECT\n*        TRY TO ALLOCATE THE PROFILE DATA-SET AS NEW.              -EU-\n         SPACE 1\n         LA    R1,RBPS99      LOAD PARAMETER POINTER FOR SVC99\n        DYNALLOC ,            ISSUE SVC99\n         LTR   R15,R15        CHECK SVC99 RETURN CODE\n         BZ    RETURN0        0 - WE ALLOCATED OK\n         BAS   R8,ERRMSGPR    GO TELL USER OF ERROR\n         DC    CL8'AL.NEW :'                                       -EU-\n         LA    R1,MSGBAD      UNABLE TO ALLOCATE - TELL THE USER\n         LA    R0,L'MSGBAD\n         B     TPUT\n         SPACE 2\nRETURN0  BAS   R8,PERMDS      PERM. ALL.                           -EU-\n         LA    R1,MSGGOOD     TELL THE USER WE CREATED A NEW ONE\n         LA    R0,L'MSGGOOD\n         SPACE 1\nTPUT    TPUT   (1),(0)        WRITE OUT RESULTS OF NEW ALLOCATION\n         SPACE 1\nRETURN  $XRET  CC=0                                                -EU-\n         EJECT\n*        MARK DATA-SET PERMANENTLY ALLOCATED SUBROUTINE.           -EU-\n*              R8 : LINK REGISTER.                                 -EU-\n         SPACE 1                                                   -EU-\nPERMDS   L     R1,CVTPTR      LOAD CVT ADDRESS                     -EU-\n         USING CVT,R1                                              -EU-\n         L     R1,CVTTCBP     LOAD TCB/TCB PTR                     -EU-\n         DROP  R1                                                  -EU-\n         L     R1,4(R1)       LOAD CURRENT TCB ADDRESS             -EU-\n         USING TCB,R1                                              -EU-\n         L     R1,TCBJSCB     JOB STEP CONTROL BLOCK ADDRESS       -EU-\n         DROP  R1                                                  -EU-\n         USING IEZJSCB,R1                                          -EU-\n         L     R2,JSCDSABQ    LOAD ADDRESS OF QDB FOR DSAB CHAIN   -EU-\n         DROP  R1                                                  -EU-\n         CLC   8(4,R2),=XL4'0'     NO DATA-SETS ?                  -EU-\n         BER   R8             IF DON'T HAVE ANY WE CAN'T PERM.ALL. -EU-\n         L     R2,12(R2)      LOAD ADDRESS OF FIRST DSAB           -EU-\n         USING DSAB,R2                                             -EU-\nINLOOP   TM    DSABFLG1,DSABDALC   DATA-SET DYN. ALL. ?            -EU-\n         BZ    NOPERM         NO, GO LOOK AT NEXT ONE              -EU-\n         L     R3,DSABTIOT    POINT TO TIOT                        -EU-\n         USING TIOELNGH,R3                                         -EU-\n         CLC   TIOEDDNM(L'TIOEDDNM),DDNAME   PROFILE DD-NAME ?     -EU-\n         BE    SETPERM        YES                                  -EU-\n         DROP  R3                                                  -EU-\nNOPERM   L     R2,DSABFCHN    NO, GET PTR TO NEXT DSAB ENTRY       -EU-\n         LTR   R2,R2          END OF CHAIN ?                       -EU-\n         BNZ   INLOOP         NO, KEEP LOOKING                     -EU-\n         BR    R8             NOT FOUND OR ALREADY DONE            -EU-\nSETPERM STAX   DEFER=YES      NO ATTN WHILE WE ARE AUTHORIZED      -EU-\n        ZEROKEY ,             ENTER AUTHORIZED                     -EU-\n         NI    DSABFLG1,255-DSABDALC    INDICATE NO DYN. ALL.      -EU-\n        RESETKEY ,            RE-ENTER TO PROBLEM STATE            -EU-\n        STAX   DEFER=NO       ACCEPT ATTN                          -EU-\n         BR    R8             RETURN                               -EU-\n         DROP  R2                                                  -EU-\n         EJECT\n*        ERROR MESSAGE DISPLAY ROUTINE.                            -EU-\n*              R7 : S99 REQUEST BLOCK ADDRESS                      -EU-\n*              R8 : LINK REGISTER, AT +0 - MESSAGE ID (8 CHAR)     -EU-\n*                                  RETURN TO +8                    -EU-\n         SPACE 1                                                   -EU-\nERRMSGPR ST    R15,DW         GET RETURN CODE AND MAKE READABLE\n         UNPK  WK,DW(5)\n         NC    WK(8),=XL8'0F0F0F0F0F0F0F0F'\n         TR    WK(8),=CL16'0123456789ABCDEF'\n         MVC   ERRMSGR1,WK\n         LH    R15,S99ERROR   GET ERROR CODE AND MAKE READABLE\n         ST    R15,DW\n         UNPK  WK,DW(5)\n         NC    WK(8),=XL8'0F0F0F0F0F0F0F0F'\n         TR    WK(8),=CL16'0123456789ABCDEF'\n         MVC   ERRMSGE1,WK+4\n         LH    R15,S99INFO    GET INFO CODE AND MAKE READABLE\n         ST    R15,DW\n         UNPK  WK,DW(5)\n         NC    WK(8),=XL8'0F0F0F0F0F0F0F0F'\n         TR    WK(8),=CL16'0123456789ABCDEF'\n         MVC   ERRMSGI1,WK+4\n         MVC   ERRMSGRC,=C'RC='\n         MVC   ERRMSGEC,=C'ERROR CODE='\n         MVC   ERRMSGIC,=C'INFO CODE='\n         MVC   ERRMSGID,0(R8)                                      -EU-\n         LA    R1,ERRMSG\n         LA    R0,ERRMSGL\n        TPUT   (1),(0)\n         B     8(R8)          BACK TO CALLER                       -EU-\n         DROP  R7\n         EJECT\n*        CURRENT ALLOCATION IS AS :                                -EU-\n*              ATTR FB3120 RECFM(F B) LRECL(80) BLKSIZE(3120)\n*              ALLOC F(ISPPROF) DA('USERID.SPF.PROF') -\n*                    UNIT(DISK) VOL(USER01) TRA SP(1 1) -\n*                    DSORG(PO) DIR(3) US(FB3120)\n         SPACE 1\nDDNAME   DC    C'ISPPROF',C' '          DDNAME  - MUST BE ISPPROF\nDSNAME   DC    C'.SPF.PROF'             DSNAME  - NAME OF PROFILE DS\nTRKS     DC    AL3(1)                   TRKS    - # OF TRKS TO ALLOC\nDIRBLKS  DC    AL3(3)                   DIRBLKS - # OF DIRECTORY BLKS\nUNIT     DC    C'DISK'                  UNIT    - UNIT TO ALLOC\nVOLSER   DC    C'USER01'                VOLSER  - VOLSER TO ALLOC\nLRECL    DC    AL2(80)                  LRECL   - MUST BE 80 FOR ISPF\nBLKSIZE  DC    AL2(3120)                BLKSIZE -\n         SPACE 2\nMSGGOOD  DC    C' *** ISPF PROFILE DATA-SET HAS BEEN CREATED ***'\nMSGBAD   DC    C' *** UNABLE TO ALLOCATE ISPF PROFILE DATA-SET ***'\n         EJECT\n        LTORG  ,              LITERAL POOL.                        -EU-\n         EJECT\nWORKAREA DSECT                DSECT FOR GOTTEN AREA\n         SPACE 1\n         DS    18F            REGISTER SAVE AREA\n         SPACE 1\nDW       DS    D\n         SPACE 1\nRBPS99   DS    F              POINTER TO SVC99 REQUEST BLOCKS\nRBS99    DS    5F             SVC 99 REQUEST BLOCK\nRBS99L   EQU   *-RBS99\n         SPACE 1\nRBIP1    DS    F              POINTER TO SVC99 TEXT UNIT 01\nRBIP5    DS    F              POINTER TO SVC99 TEXT UNIT 05\nRBITU1   DS    XL14                SVC99 TEXT UNIT 01 - DDNAME\nRBITU5   DS    XL6,CL44            SVC99 TEXT UNIT 05 - RETURN DSNAME\nRBILSTL  EQU   *-RBIP1\n         SPACE 1\nRBOP1    DS    F              POINTER TO SVC99 TEXT UNIT 01\nRBOP2    DS    F              POINTER TO SVC99 TEXT UNIT 02\nRBOP4    DS    F              POINTER TO SVC99 TEXT UNIT 04\nRBOP5    DS    F              POINTER TO SVC99 TEXT UNIT 05\nRBOP52   DS    F              POINTER TO SVC99 TEXT UNIT 52\nRBOTU1   DS    XL14                SVC99 TEXT UNIT 01 - DDNAME\nRBOTU2   DS    XL(13+L'DSNAME)     SVC99 TEXT UNIT 02 - DSNAME\nRBOTU4   DS    XL7                 SVC99 TEXT UNIT 04 - DS STATUS\nRBOTU5   DS    XL7                 SVC99 TEXT UNIT 05 - DS DISPOSITION\nRBOTU52  DS    XL4                 SVC99 TEXT UNIT 52 - PERM.ALL.ATTR.\nRBOLSTL  EQU   *-RBOP1\n         SPACE 1\nRBAP1    DS    F              POINTER TO SVC99 TEXT UNIT 01\nRBAP2    DS    F              POINTER TO SVC99 TEXT UNIT 02\nRBAP4    DS    F              POINTER TO SVC99 TEXT UNIT 04\nRBAP5    DS    F              POINTER TO SVC99 TEXT UNIT 05\nRBAP7    DS    F              POINTER TO SVC99 TEXT UNIT 07\nRBAPA    DS    F              POINTER TO SVC99 TEXT UNIT 0A\nRBAPB    DS    F              POINTER TO SVC99 TEXT UNIT 0B\nRBAPC    DS    F              POINTER TO SVC99 TEXT UNIT 0C\nRBAP10   DS    F              POINTER TO SVC99 TEXT UNIT 10\nRBAP15   DS    F              POINTER TO SVC99 TEXT UNIT 15\nRBAP30   DS    F              POINTER TO SVC99 TEXT UNIT 30\nRBAP3C   DS    F              POINTER TO SVC99 TEXT UNIT 3C\nRBAP42   DS    F              POINTER TO SVC99 TEXT UNIT 42\nRBAP49   DS    F              POINTER TO SVC99 TEXT UNIT 49\nRBAP52   DS    F              POINTER TO SVC99 TEXT UNIT 52\nRBATU1   DS    XL14                SVC99 TEXT UNIT 01 - DDNAME\nRBATU2   DS    XL(13+L'DSNAME)     SVC99 TEXT UNIT 02 - DSNAME\nRBATU4   DS    XL7                 SVC99 TEXT UNIT 04 - DS STATUS\nRBATU5   DS    XL7                 SVC99 TEXT UNIT 05 - DS DISPOSITION\nRBATU7   DS    XL4                 SVC99 TEXT UNIT 07 - TRACK ALLOC\nRBATUA   DS    XL9                 SVC99 TEXT UNIT 0A - PRIMARY SPACE\nRBATUB   DS    XL9                 SVC99 TEXT UNIT 0B - SECONDARY SPACE\nRBATUC   DS    XL9                 SVC99 TEXT UNIT 0C - DIRECTORY BLKS\nRBATU10  DS    XL12                SVC99 TEXT UNIT 10 - VOL SER\nRBATU15  DS    XL(6+L'UNIT)        SVC99 TEXT UNIT 15 - UNIT\nRBATU30  DS    XL8                 SVC99 TEXT UNIT 30 - BLKSIZE\nRBATU3C  DS    XL8                 SVC99 TEXT UNIT 3C - DSORG\nRBATU42  DS    XL8                 SVC99 TEXT UNIT 42 - LRECL\nRBATU49  DS    XL7                 SVC99 TEXT UNIT 49 - RECFM\nRBATU52  DS    XL4                 SVC99 TEXT UNIT 52 - PERM.ALL.ATTR.\nRBALSTL  EQU   *-RBAP1\n         SPACE 1\nERRMSG   DS    0C\n         DS    CL1\nERRMSGAB DS    CL3\n         DS    CL1\nERRMSGID DS    CL8\n         DS    CL1\nERRMSGRC DS    CL3\nERRMSGR1 DS    CL8\n         DS    CL1\nERRMSGEC DS    CL11\nERRMSGE1 DS    CL4\n         DS    CL1\nERRMSGIC DS    CL10\nERRMSGI1 DS    CL4\n         DS    CL1\nERRMSGAE DS    CL3\nERRMSGL  EQU   *-ERRMSG\n         SPACE 1\nWARNING  DS    0C\n         DS    CL1\nWARNINGA DS    CL3\n         DS    CL1\nWARNINGT DS    CL23\n         DS    CL1\nWARNINGN DS    CL44\nWARNINGL EQU   *-WARNING\n         SPACE 1\nWK       DS    CL9\nWKDSNL   DS    XL2                                                 -EU-\nWKDSN    DS    CL(L'DSNAME+7)                                      -EU-\n         SPACE 1\nAREALEN  EQU   (((*-WORKAREA)+7)/8)*8                              -EU-\n         EJECT\n         PRINT NOGEN                                               -EU-\n         SPACE 1                                                   -EU-\n        CVT    DSECT=YES,LIST=YES                                  -EU-\n        IHAASCB ,                                                  -EU-\n        IKJTCB ,                                                   -EU-\n        IEZJSCB ,                                                  -EU-\n        IEFZB4D0\n        IEFZB4D2\n        IKJDAP08\nDSAB    IHADSAB ,                                                  -EU-\nTIOT     DSECT  ,                                                  -EU-\n        IEFTIOT1 ,                                                 -EU-\n        DCBD   DEVD=DA,DSORG=PO                                    -EU-\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDFINIT$": {"ttr": 27393, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x944?\\x00\\x944?\\x13D\\x00\\x10\\x00\\x10\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-09T00:00:00", "modifydate": "1994-12-09T13:44:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "SYSPAJA"}, "text": "//PDFINIT  JOB (........),'INSTALL  - PDFINIT -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=5\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* THIS TSO-COMMAND IS NOW OBSOLETED AT OUR INSTALLATION, IT HAS     *\n//* BEEN INCLUDED IN THE \"DYLON/DYLOFF\" TSO-COMMAND.       (90/11/27) *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHSVC                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ4AS3,OPT=',RENT',MBR=PDFINIT\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   PDFINIT\n  NAME    PDFINIT(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDFINIT@": {"ttr": 27395, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/10/85\n                                                      PDFINIT   1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     DYNANIC ALLOCATION COMMAND      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *           FOR ISPF/PDF.             * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    This command will allocate the PDF profile data-set at\n  ---------    LOGON time or may be invoked prior to invoking ISPF/PDF.\n               This is considerably faster than using a CLIST to\n               allocate. The PDF data-set is allocated as OLD and if\n               unable to allocate, tries to allocate and catalog a NEW\n               profile data-set.\n\n               Current allocation is as :\n               ATTR FB3120 RECFM(F B) LRECL(80) BLKSIZE(3120)\n               ALLOC F(ISPPROF) DA('USERID.SPF.PROF') -\n                     UNIT(DISK) VOL(VOLSER) TRA SP(1 1) -\n                     DSORG(PO) DIR(3) US(FB3120)\n\n               This module may be assembled and linked into a LINKLIST\n               library or into LPALIB.\n\n               The invocation at LOGON time is by using the PARM field\n               on the EXEC statement in the LOGON procedure.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PDSMATC$": {"ttr": 27397, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942o\\x00\\x942o\\x16(\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-22T00:00:00", "modifydate": "1994-11-22T16:28:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//PDSMATCH JOB (........),'INSTALL  -PDSMATCH-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=5\n//ASS     EXEC PAJ4AS3,OPT=',RENT',MBR=PDSMATCH\n//LNK     EXEC PAJILKL,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   PDSMATCH\n  NAME    PDSMATCH(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSMATC@": {"ttr": 27399, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\to\\x00\\x93\\to\\x14$\\x002\\x002\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-04-06T00:00:00", "modifydate": "1993-04-06T14:24:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/11/85\n                                                      PDSMATCH  1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       P  D  S  M  A  T  C  H        * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  CBT origin : Extracted from CBT tape 84 JUN, file 316.\n  ------------\n\n  Description :\n  -------------\n           This program compares the directories of two partitioned\n           data-sets and prints a report showing which members\n           match and which members do not match or are not present\n           in both directories.\n           Members are said to match if their names are the same,\n           and (if PARM=USER) if all the other data in their\n           directory entries are equal (except fields containing\n           TTR track addresses).\n           Data records for the members are not compared.\n           Only the information in the directory is compared.\n\n  DDNAMEs :        SYSPRINT - Report output\n  ---------        SYSLIB1  - PDS 1 input\n                   SYSLIB2  - PDS 2 input\n\n  Options : - If PARM=USER : members that are present in both libraries\n  ---------        will be compared for matching USER-DATA.\n                   USER-DATA consists of up to 64 bytes of data\n                   in the directory entry which is put there by\n                   the linkage editor, SPF edit, and others.\n                   Note : with PARM=USER, if two members have the same\n                          name and neither has any USER-DATA, they are\n                          treated as unequal, with a unique message\n                          for this case.\n            - If PARM=EQO : only members that match will be listed.\n            - If PARM=NEO (or PARM=SHORT) : only members that don't\n                   match will be listed.\n            - If neither of the above, all members will be listed for\n                   both libraries.\n            - If PARM='SIZE=...' : set the 2 PDS directories core\n                   storage space size to ...K size (default is 128K).\n                   Usefull to avoid an abend S800 if big directories.\n\n            Note : when more PARM keywords must be specified in the\n                   PARM field, they must be separated by one blank.\n                   i.e. : PARM='SHORT SIZE=256'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PDSMATCH": {"ttr": 27401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882/\\x00\\x882/\\x15\"\\x03w\\x03w\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-17T00:00:00", "modifydate": "1988-11-17T15:22:00", "lines": 887, "newlines": 887, "modlines": 0, "user": "SYSPAJA"}, "text": "PDSM     TITLE 'P D S M A T C H  - PROGRAM.'\nPDSMATCH START 0\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*                      P  D  S  M  A  T  C  H                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n* DESCRIPTION :\n* -------------\n*          THIS PROGRAM COMPARES THE DIRECTORIES OF TWO PARTITIONED\n*          DATA-SETS AND PRINTS A REPORT SHOWING WHICH MEMBERS\n*          MATCH AND WHICH MEMBERS DO NOT MATCH OR ARE NOT PRESENT\n*          IN BOTH DIRECTORIES.\n*          MEMBERS ARE SAID TO MATCH IF THEIR NAMES ARE THE SAME,\n*          AND (IF PARM=USER) IF ALL THE OTHER DATA IN THEIR\n*          DIRECTORY ENTRIES ARE EQUAL (EXCEPT FIELDS CONTAINING\n*          TTR TRACK ADDRESSES).\n*          DATA RECORDS FOR THE MEMBERS ARE NOT COMPARED.\n*          ONLY THE INFORMATION IN THE DIRECTORY IS COMPARED.\n*\n* DDNAMES :        SYSPRINT - REPORT OUTPUT\n* ---------        SYSLIB1  - PDS 1 INPUT\n*                  SYSLIB2  - PDS 2 INPUT\n*\n* OPTIONS : - IF PARM=USER : MEMBERS THAT ARE PRESENT IN BOTH LIBRARIES\n* ---------        WILL BE COMPARED FOR MATCHING USER-DATA.\n*                  USER-DATA CONSISTS OF UP TO 64 BYTES OF DATA\n*                  IN THE DIRECTORY ENTRY WHICH IS PUT THERE BY\n*                  THE LINKAGE EDITOR, SPF EDIT, AND OTHERS.\n*                  NOTE - WITH PARM=USER, IF TWO MEMBERS HAVE THE SAME\n*                         NAME AND NEITHER HAS ANY USER-DATA, THEY ARE\n*                         TREATED AS UNEQUAL, WITH A UNIQUE MESSAGE\n*                         FOR THIS CASE.\n*           - IF PARM=EQO : ONLY MEMBERS THAT MATCH WILL BE LISTED.\n*           - IF PARM=NEO (OR PARM=SHORT) : ONLY MEMBERS THAT DON'T\n*                  MATCH WILL BE LISTED.\n*           - IF NEITHER OF THE ABOVE, ALL MEMBERS WILL BE LISTED FOR\n*                  BOTH LIBRARIES.\n*           - IF PARM='SIZE=...' : SET THE 2 PDS DIRECTORIES CORE\n*                  STORAGE SPACE SIZE TO ...K SIZE (DEFAULT IS 128K).\n*                  USEFULL TO AVOID AN ABEND S800 IF BIG DIRECTORIES.\n*\n*           NOTE : WHEN MORE PARM KEYWORDS MUST BE SPECIFIED IN THE\n*                  PARM FIELD, THEY MUST BE SEPARATED BY ONE BLANK.\n*                  I.E. : PARM='SHORT SIZE=256'\n         EJECT\n* AUTHOR : BILL GODFREY, PLANNING RESEARCH CORPORATION.\n* -------- INSTALLATION : PRC COMPUTER CENTER, MCLEAN VA.\n*          DATE WRITTEN : APRIL 20 1982.\n*          DATE UPDATED : APRIL 29 1982.\n*          ATTRIBUTES : RE-ENTRANT.\n*          MODIFIED BY : MOINIL P.A.\n*                        COMPUTING CENTRE\n*                        J.R.C. - ISPRA ESTABLISHMENT\n*                        21020 ISPRA (VA), ITALY\n*                        DATE MODIFY : JUNE 27 1984.\n*\n* FEATURES TO BE ADDED IN THE FUTURE :\n*\n*        - IF PARM=COPYNEW :\n*          A DECK OF IEBCOPY CONTROL CARDS WILL BE PUNCHED WHICH CAN BE\n*          USED TO COPY MEMBERS FROM SYSLIB1 TO SYSLIB2 IF THE MEMBERS\n*          ARE PRESENT IN SYSLIB1 BUT NOT IN SYSLIB2.\n*\n*        - IF PARM=COPYUPD :\n*          A DECK OF IEBCOPY CONTROL CARDS WILL BE PUNCHED WHICH CAN BE\n*          USED TO COPY MEMBERS FROM SYSLIB1 TO SYSLIB2 IF THE MEMBERS\n*          ARE PRESENT IN BOTH LIBRARIES BUT THE ONE IN SYSLIB2 HAS AN\n*          OLDER SPF DATE-OF-LAST-UPDATE.\n*\n* LOG OF CHANGES :\n*        27 APR 82 - WARN IF MEMBERS ARE EQUAL BUT NO USER-DATA.\n*                    FORMAT OF REPORT CHANGED.\n*        28 APR 82 - ADD RDJFCB AND PRINT THE DSNAMES.\n*                    MAKE THE DDNAMES SYSLIB1 AND SYSLIB2.\n*                    ZERO ANY TTR'S IN THE USER-DATA SO THAT THEY\n*                    WILL NOT BE USED WHEN COMPARING LOAD MODULES.\n*                    ADD PARM OPTIONS.\n*        28 APR 82 - SHOW CRITERIA.\n*        27 JUN 84 - ADD PARM='SIZE=...' TO ALLOW INCREMENT OF PDS\n*                    DIRECTORIES CORE STORAGE SPACE.\n         EJECT\nPDSMATCH AMODE  24                                                 -EU-\nPDSMATCH RMODE  24                                                 -EU-\n         SPACE 1                                                   -EU-\n        $DEFREG ,                                                  -EU-\n        $XENT  BASE=R10,LV=@DATAL,TYPE=RENT                        -EU-\n         EJECT\n************************************************************\n*                                                          *\n*        INITIALIZATION.                                   *\n*                                                          *\n************************************************************\n         SPACE 1\n         LR    R4,R1               SAVE PARM POINTER\n         LR    R11,R13\n         USING @DATA,R11\n         XC    RC,RC\n         MVI   STATUS,0\n         MVI   OPTIONS,0\n         MVC   DIRSIZE,DIRSZDF                                     -EU-\n         MVC   DDNAMEP,=CL8'SYSPRINT'\n         MVC   DDNAME1,=CL8'SYSLIB1'\n         MVC   DDNAME2,=CL8'SYSLIB2'\n         MVI   LINE-1,C' '\n         MVC   LINE,LINE-1\n         MVI   MESG-1,C' '\n         ZAP   REPORTPG,=P'0'\n         ZAP   REPORTLN,=P'0'\n         ZAP   REPORTMX,=P'60'\n         MVI   REPORTO-1,C' '\n         MVI   JFCB1,C' '\n         MVC   JFCB1+1(175),JFCB1\n         MVC   JFCB2(176),JFCB1\n         EJECT\n************************************************************\n*                                                          *\n*        OPEN THE PRINT FILE.                              *\n*                                                          *\n************************************************************\n         SPACE 1\n         MVC   PRTDCBW(PRTDCBL),PRTDCB\n         LA    R2,PRTDCBW\n         USING IHADCB,R2\n         MVC   DCBDDNAM,DDNAMEP\n         XC    OPEN,OPEN\n         OI    OPEN,X'80'\n        OPEN   ((R2),OUTPUT),MF=(E,OPEN)\n         TM    DCBOFLGS,DCBOFOPN\n         BZ    EXIT12\n         OI    STATUS,PRTOPEN\n         B     PRTX\n         DROP  R2\n         USING IHADCB,R1\nPRTEXITO CLC   DCBBLKSI,=H'0'      IS BLKSIZE ZERO?\n         BNER  R14                 NO\n         MVC   DCBBLKSI,DCBLRECL   YES, MAKE IT SAME AS LRECL\n         BR    R14\n         DROP  R1\n         EJECT\n************************************************************\n*                                                          *\n*        SCAN THE PARM FIELD.                              *\n*                                                          *\n************************************************************\n         SPACE 1\n*        REGISTERS USED :\n*              R14 - RETURN FROM PARSE.\n*              R15 - ADDRESS OF REMAINING PARM DATA.\n*              R0  - WORK.\n*              R1  - WORK.\n*              R3  - LENGTH OF REMAINING PARM DATA MINUS 1.\n*              R4  - PARM.FIELD START ADDRESS.                     -EU-\n*              R5  - NON-BLANK TABLE SCAN ADDRESS.                 -EU-\n*              R6  - BLANK TABLE SCAN ADDRESS.                     -EU-\n         SPACE 1\nPRTX     LM    R5,R6,=A(TABNONBL,TABBLANK)                         -EU-\n         L     R15,0(,R4)          POINT TO PARM\n         LH    R3,0(,R15)          GET LENGTH OF PARM\n         LTR   R3,R3               IS THERE A PARM?\n         BZ    PARMX               NO, BRANCH\n         LA    R15,2(,R15)         POINT TO PARM DATA\n         XR    R1,R1               INSURE HI ORDER BYTE ZERO\n         BCTR  R3,0                LENGTH CODE OF PARM DATA\n         B     PARMLOOP            SKIP EXECUTED INSTRUCTIONS\nTRTNONBL TRT   0(0,R15),0(R5)      << EXECUTED >>\nTRTBLANK TRT   0(0,R15),0(R6)      << EXECUTED >>\n*        NOTE : TRT CAN CHANGE 8 BITS OF R2 AND 24 BITS OF R1.\nPARMLOOP EX    R3,TRTNONBL         FIND A NONBLANK\n         BZ    PARMX               BRANCH IF ALL BLANKS\n         LR    R0,R1               GET ADDRESS OF STRING\n         SR    R0,R15              GET LENGTH OF PRECEDING BLANKS\n         SR    R3,R0               GET LENGTH OF REMAINING TEXT\n         LR    R15,R1              GET ADDRESS OF NONBLANK\n         EX    R3,TRTBLANK         FIND A BLANK\n         BZ    PARMLAST            BRANCH IF NOT FOUND\n         LR    R0,R1               GET ADDRESS OF BLANK\n         SR    R0,R15              GET LENGTH OF FIELD\n         BAS   R14,PARSE\n         SR    R3,R0               GET LENGTH CODE OF REMAINING TEXT\n         BZ    PARMX               BRANCH IF ONE TRAILING BLANK\n         LR    R15,R1              POINT TO BLANK\n         B     PARMLOOP\nPARMLAST LA    R0,1(,R3)           GET LENGTH\n         BAS   R14,PARSE\n         B     PARMX\n         EJECT\n************************************************************\n*                                                          *\n*        PROCESS EACH PARM KEYWORD.                        *\n*                                                          *\n************************************************************\n         SPACE 1\n*        NOTE : PARSE MUST NOT ALTER R3.\n         SPACE 1\nPARSE    STM   R14,R1,PARSES       SAVE REGS\n         CH    R0,=H'5'            IS KEYWORD LENGTH GT 5?         -EU-\n         BNH   PARSLNX             NO, BRANCH                      -EU-\n         CLC   0(5,R15),=C'SIZE='                                  -EU-\n         BNE   PARSX                                               -EU-\n         SH    R0,=H'5'                                            -EU-\n         LA    R15,5(,R15)                                         -EU-\n         LR    R14,R15                                             -EU-\nPARSLNL  CLI   0(R14),C'0'         SCAN TO FIND SIZE VALUE         -EU-\n         BL    PARSLNF                                             -EU-\n         CLI   0(R14),C'9'                                         -EU-\n         BH    PARSLNF                                             -EU-\n         LA    R14,1(,R14)                                         -EU-\n         BCT   R0,PARSLNL                                          -EU-\nPARSLNF  SR    R14,R15                                             -EU-\n         BNP   PARSX                                               -EU-\n         BCTR  R14,0                                               -EU-\n         EX    R14,PARSLNP         GET SIZE VALUE                  -EU-\n         CVB   R14,DOUBLE                                          -EU-\n         SLL   R14,10              COMPUTE SIZE-K VALUE            -EU-\n         STCM  R14,B'0111',DIRSIZE+1    STORE IT                   -EU-\n         B     PARSX                                               -EU-\nPARSLNP  PACK  DOUBLE,0(*-*,R15)   << EXECUTED >>                  -EU-\nPARSLNX  CH    R0,=H'5'            IS KEYWORD LENGTH 5?            -EU-\n         BNE   PARSL5X             NO, BRANCH\n         CLC   0(5,R15),=C'SHORT'\n         BNE   PARSX\n         OI    OPTIONS,OPTNEO      SHORT SAME AS NEO\n         B     PARSX\nPARSL5X  CH    R0,=H'4'            IS KEYWORD LENGTH 4?\n         BNE   PARSL4X             NO, BRANCH\n         CLC   0(4,R15),=C'USER'\n         BNE   PARSX\n         OI    OPTIONS,OPTUSER\n         B     PARSX\nPARSL4X  CH    R0,=H'3'            IS KEYWORD LENGTH 3?\n         BNE   PARSX               NO, BRANCH\n         CLC   0(3,R15),=C'EQO'    EQONLY\n         BNE   *+L'*+4\n         OI    OPTIONS,OPTEQO\n         CLC   0(3,R15),=C'NEO'    NEONLY\n         BNE   PARSX\n         OI    OPTIONS,OPTNEO\nPARSX    LM    R14,R1,PARSES\n         BR    R14\n         EJECT\n************************************************************\n*                                                          *\n*        SHOW CRITERIA.                                    *\n*                                                          *\n************************************************************\n         SPACE 1\nPARMX    TM    OPTIONS,OPTUSER\n         BO    PRTCRI2\n         LA    R1,MSGCRI1A\n         LA    R0,L'MSGCRI1A\n         BAS   R14,PRTMSG\n         LA    R1,MSGCRI1B\n         LA    R0,L'MSGCRI1B\n         BAS   R14,PRTMSG\n         B     PRTCRIX\nPRTCRI2  LA    R1,MSGCRI2A\n         LA    R0,L'MSGCRI2A\n         BAS   R14,PRTMSG\n         LA    R1,MSGCRI2B\n         LA    R0,L'MSGCRI2B\n         BAS   R14,PRTMSG\nPRTCRIX  LA    R1,=C' '\n         LA    R0,1\n         BAS   R14,PRTMSG\n         EJECT\n************************************************************\n*                                                          *\n*        OPEN THE FIRST PDS.                               *\n*                                                          *\n************************************************************\n         SPACE 1\n         MVC   DIRDCBW(DIRDCBL),DIRDCB\n         LA    R2,DIRDCBW          ADDRESS OF DCB\n         USING IHADCB,R2\n         MVC   DCBDDNAM,DDNAME1    CHANGE THE DDNAME\n         LA    R3,DCBDDNAM         POINT TO DDNAME FOR DEVTYPE\n        DEVTYPE (R3),DEVAREA\n         LTR   R15,R15             IS DDNAME ALLOCATED?\n         BNZ   EXIT12              NO, BRANCH\n         LA    R1,DIREXLST         PUT EXLST\n         IC    R0,DCBEXLST           ADDRESS\n         ST    R1,DCBEXLST             IN\n         STC   R0,DCBEXLST               DCB\n         LA    R0,JFCB1            PUT JFCB ADDRESS\n         ST    R0,0(,R1)             IN EXLST\n         MVI   0(R1),X'87'         AND INDICATE EXLST ENTRY TYPE\n         XC    RDJFCB,RDJFCB\n         OI    RDJFCB,X'80'\n        RDJFCB ((R2)),MF=(E,RDJFCB)\n         XC    OPEN,OPEN\n         OI    OPEN,X'80'\n        OPEN   ((R2),INPUT),MF=(E,OPEN)\n         TM    DCBOFLGS,DCBOFOPN\n         BZ    EXIT12\n         OI    STATUS,DIROPEN\n         MVC   LINE,LINE-1         BLANK LINE\n         MVC   LINE+1(10),=C'SYSLIB 1 -'\n         LA    R15,LINE+12\n         MVC   0(44,R15),JFCB1\n         LA    R15,44(,R15)\nAPPENDV1 CLI   0(R15),C' '\n         BNE   *+L'*+4\n         BCT   R15,APPENDV1\n         MVC   2(2,R15),=C'ON'\n         MVC   5(6,R15),JFCB1+118  VOLUME SERIAL\n         BAS   R14,REPORTL         PUT HEADING SYSLIB 1 DSN\n         L     R0,DIRSIZE\n        GETMAIN R,LV=(0)\n         ST    R1,DIRFREE          SAVE FOR FREEMAIN\n         LR    R3,R1\n         ST    R3,DIRPTR1          SAVE FOR WALKING THRU DIR 1\n         OI    STATUS,GOTMAIN\n         MVC   DIRDECBW(DIRDECBL),DIRDECB\n         MVI   DIRSW,0\n         BAS   R8,DIRIN\n        CLOSE  ((R2)),MF=(E,OPEN)\n         NI    STATUS,255-DIROPEN\n         DROP  R2\n         TM    DIRSW,DFVLD         WAS DIRECTORY VALID?\n         BZ    EXIT12              NO, QUIT\n         LA    R3,256(,R3)         SET START OF SECOND DIRECTORY\n         ST    R3,DIRPTR2          SAVE FOR WALKING THRU DIR 2\n         EJECT\n************************************************************\n*                                                          *\n*        OPEN THE SECOND PDS.                              *\n*                                                          *\n************************************************************\n         SPACE 1\n         MVC   DIRDCBW(DIRDCBL),DIRDCB\n         LA    R2,DIRDCBW          ADDRESS OF DCB\n         USING IHADCB,R2\n         MVC   DCBDDNAM,DDNAME2    CHANGE THE DDNAME\n         LA    R3,DCBDDNAM         POINT TO DDNAME FOR DEVTYPE\n        DEVTYPE (R3),DEVAREA\n         LTR   R15,R15             IS DDNAME ALLOCATED?\n         BNZ   EXIT12              NO, BRANCH\n         LA    R1,DIREXLST         PUT EXLST\n         IC    R0,DCBEXLST           ADDRESS\n         ST    R1,DCBEXLST             IN\n         STC   R0,DCBEXLST               DCB\n         LA    R0,JFCB2            PUT JFCB ADDRESS\n         ST    R0,0(,R1)             IN EXLST\n         MVI   0(R1),X'87'         AND INDICATE EXLST ENTRY TYPE\n         XC    RDJFCB,RDJFCB\n         OI    RDJFCB,X'80'\n        RDJFCB ((R2)),MF=(E,RDJFCB)\n         XC    OPEN,OPEN\n         OI    OPEN,X'80'\n        OPEN   ((R2),INPUT),MF=(E,OPEN)\n         TM    DCBOFLGS,DCBOFOPN\n         BZ    EXIT12\n         OI    STATUS,DIROPEN\n         MVC   LINE,LINE-1         BLANK LINE\n         MVC   LINE+1(10),=C'SYSLIB 2 -'\n         LA    R15,LINE+12\n         MVC   0(44,R15),JFCB2\n         LA    R15,44(,R15)\nAPPENDV2 CLI   0(R15),C' '\n         BNE   *+L'*+4\n         BCT   R15,APPENDV2\n         MVC   2(2,R15),=C'ON'\n         MVC   5(6,R15),JFCB2+118  VOLUME SERIAL\n         BAS   R14,REPORTL         PUT HEADING SYSLIB 2 DSN\n         MVC   LINE,LINE-1         BLANK LINE\n         BAS   R14,REPORTL         PUT HEADING BLANK LINE\n         L     R3,DIRPTR2\n         MVC   DIRDECBW(DIRDECBL),DIRDECB\n         MVI   DIRSW,0\n         BAS   R8,DIRIN\n        CLOSE  ((R2)),MF=(E,OPEN)\n         NI    STATUS,255-DIROPEN\n         DROP  R2\n         TM    DIRSW,DFVLD         WAS DIRECTORY VALID?\n         BZ    EXIT12              NO, QUIT\n         B     COMPARE\n         EJECT\n************************************************************\n*                                                          *\n*        READ THE DIRECTORY INTO STORAGE.                  *\n*                                                          *\n*              R2 ---> DCB ADDRESS                         *\n*                                                          *\n************************************************************\n         SPACE 1\nDIRIN    XC    DIRBLKS,DIRBLKS\n         XC    DIRBLKSU,DIRBLKSU\n         XC    MEMBERS,MEMBERS\n         XC    ALIASES,ALIASES\n         B     *+L'*+4\nDIRREAD  LA    R3,256(,R3)\n        READ   DIRDECBW,SF,(R2),(R3),256,MF=E\n        CHECK  DIRDECBW\n         TM    DIRSW,DFIOE         I/O ERROR?\n         BO    DIRERR              YES, BRANCH\n         LA    R1,1\n         A     R1,DIRBLKS\n         ST    R1,DIRBLKS\n***      TM    DIRSW,DFVLD         ARE WE PAST USED BLOCKS?\n***      BO    DIRREAD             YES, BRANCH\n         LR    R1,R3               POINT TO DATA JUST READ\n         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE\n         LTR   R0,R0               IS THIS NEGATIVE?\n         BM    DIRINV              YES, NOT A DIRECTORY BLOCK\n         CH    R0,=H'256'          IS THIS TOO LARGE?\n         BH    DIRINV              YES, NOT A DIRECTORY BLOCK\n         AR    R0,R1               POINT PAST LAST BYTE\n         LA    R1,2(,R1)           POINT TO FIRST MEMBER\nDIRENTRY CLC   0(8,R1),=8X'FF'     END OF MEMBERS?\n         BE    DIRUSED\n         TM    11(R1),X'80'        ALIAS?\n         BO    DIRALIAS\n         LA    R15,1               COUNT NON-ALIAS MEMBERS\n         A     R15,MEMBERS\n         ST    R15,MEMBERS\n         B     DIRNEXT\nDIRALIAS LA    R15,1               COUNT ALIAS MEMBERS\n         A     R15,ALIASES\n         ST    R15,ALIASES\nDIRNEXT  SLR   R15,R15\n         IC    R15,11(,R1)\n         N     R15,=F'31'          SET OFF ALL BUT LAST 5 BITS\n         SLL   R15,1               CHANGE HALFWORDS TO BYTES\n         LA    R1,12(R15,R1)       POINT PAST USER DATA\n         CR    R1,R0               END OF BLOCK?\n         BL    DIRENTRY            NO, BRANCH\n         B     DIRREAD             YES, READ NEXT BLOCK\nDIRUSED  OI    DIRSW,DFVLD         STOP COUNTING MEMBERS\n         MVC   DIRBLKSU,DIRBLKS    SAVE NUMBER OF USED BLOCKS\n***      B     DIRREAD             GO COUNT UNUSED BLOCKS\n         BR    R8\nDIRSYN  SYNADAF ACSMETH=BSAM\n         MVC   MESSAGE(72),50(R1)\n         OI    DIRSW,DFIOE\n        SYNADRLS\n         BR    R14\nDIRINV   LA    R1,MSGINV\n         LA    R0,L'MSGINV\n         BAS   R14,PRTMSG\n         OI    DIRSW,DFMSG\n         BR    R8\nDIRERR   LA    R1,MESSAGE\n         LA    R0,72\n         BAS   R14,PRTMSG\n         OI    DIRSW,DFMSG\n         BR    R8\nDIREOF   LA    R1,MSGEOF\n         LA    R0,L'MSGEOF\n         BAS   R14,PRTMSG\n         OI    DIRSW,DFMSG\n         BR    R8\n         EJECT\n************************************************************\n*                                                          *\n*        COMPARE ROUTINE.                                  *\n*                                                          *\n************************************************************\n         SPACE 1\nCOMPARE  L     R1,DIRPTR1          POINT TO FIRST BLOCK OF PDS1\n         ST    R1,PDSWORK1+8\n         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE\n         AR    R0,R1               POINT PAST LAST BYTE\n         LA    R1,2(,R1)           POINT TO FIRST MEMBER\n         LA    R2,PDSWORK1\n         BAS   R8,GETMEM1          GET FIRST MEMBER\n         L     R1,DIRPTR2          POINT TO FIRST BLOCK OF PDS2\n         ST    R1,PDSWORK2+8\n         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE\n         AR    R0,R1               POINT PAST LAST BYTE\n         LA    R1,2(,R1)           POINT TO FIRST MEMBER\n         LA    R2,PDSWORK2\n         BAS   R8,GETMEM1          GET FIRST MEMBER\n         SPACE 1\n************************************************************\n*                                                          *\n*        READY TO COMPARE.                                 *\n*                                                          *\n************************************************************\n         SPACE 1\n         LA    R3,PDSWORK1\n         LA    R4,PDSWORK2\nREADY    CLC   20(8,R3),20(R4)\n         BL    SHOW1\n         BH    SHOW2\n         CLC   20(8,R3),=8X'FF'\n         BE    EXIT                END OF BOTH DIRECTORIES\n         SPACE 1\n************************************************************\n*                                                          *\n*        MEMBER EXISTS IN BOTH LIBRARIES.                  *\n*                                                          *\n************************************************************\n         SPACE 1\n         MVC   LINE,LINE-1\n         MVC   LINE+01(8),20(R3)\n         MVC   LINE+22(8),20(R4)\n         TM    OPTIONS,OPTUSER    ARE WE COMPARING USERDATA?\n         BZ    MATCHP             NO, OMIT MESSAGE\n         CLC   19(73,R3),19(R4)   IS USERDATA THE SAME?\n         BE    SAME               YES, BRANCH\n         MVC   LINE+10(11),=C' ********* '\n         MVC   LINE+32(25),=C'NON-SPF USER DATA UNEQUAL'\n         SPACE 1\n*        SEE IF BOTH ARE SPF STATS.\n*        IF BOTH ARE SPF STATS, SHOW WHICH IS MORE RECENT.\n         SPACE 1\n         TM    12(R3),SPFFLAG      IS USERDATA SPF?\n         BNO   DIFF1               NO, BRANCH\n         TM    12(R4),SPFFLAG      IS USERDATA SPF?\n         BNO   DIFF2               NO, BRANCH\n         CLC   28+8(6,R3),28+8(R4) COMPARE YY.DDD HH.MM LAST UPDATED?\n         BH    RECENT1\n         BL    RECENT2\n         MVC   LINE+10(11),=C' ********* '\n         MVC   LINE+32(32),=C'SPF STATS DIFFER BUT NOT IN DATE'\n         B     MATCHP\nDIFF1    TM    12(R4),SPFFLAG      IS USERDATA SPF?\n         BNO   MATCHP              NO, NEITHER MEMBER IS SPF\n         MVC   LINE+32(27),=C'ONLY SYSLIB 2 HAS SPF STATS'\n         B     MATCHP\nDIFF2    MVC   LINE+32(27),=C'ONLY SYSLIB 1 HAS SPF STATS'\n         B     MATCHP\nRECENT1  MVC   LINE+10(11),=C' <-- NEWER '\n         MVC   LINE+32(25),=C'SYSLIB 1 IS MORE RECENT  '\n         B     MATCHP\nRECENT2  MVC   LINE+10(11),=C' NEWER --> '\n         MVC   LINE+32(25),=C'SYSLIB 2 IS MORE RECENT  '\n         B     MATCHP\n         SPACE 1\n************************************************************\n*                                                          *\n*        DIRECTORY DATA MATCHES.                           *\n*                                                          *\n************************************************************\n         SPACE 1\nSAME     CLI   15(R3),0            ZERO USERDATA IN BOTH?\n         BNE   SAME2               NO, BRANCH\n         MVC   LINE+10(11),=C' ********* '\n         MVC   LINE+32(27),=C'NEITHER MEMBER HAS USERDATA'\n         B     MATCHP\nSAME2    TM    12(R3),SPFFLAG      SPF STATS IN BOTH?\n         BO    MATCHP              YES, OMIT MESSAGE\n         MVC   LINE+10(11),=C' ********* '\n         MVC   LINE+32(23),=C'NON-SPF USER DATA EQUAL'\nMATCHP   CLI   LINE+32,C' '        IS THIS A MATCH?\n         BNE   MATCHNE             NO, BRANCH\n         TM    OPTIONS,OPTNEO      ARE WE PRINTING .NE. ONLY?\n         BO    MATCHX              YES, DONT PRINT THESE\n         B     MATCHPR\nMATCHNE  TM    OPTIONS,OPTEQO      ARE WE PRINTING .EQ. ONLY?\n         BO    MATCHX              YES, DONT PRINT THESE\nMATCHPR  BAS   R14,REPORTL\nMATCHX   LR    R2,R3\n         BAS   R8,GETMEM\n         LR    R2,R4\n         BAS   R8,GETMEM\n         B     READY\n         SPACE 1\n************************************************************\n*                                                          *\n*        MEMBER EXISTS ONLY IN SYSLIB 1.                   *\n*                                                          *\n************************************************************\n         SPACE 1\nSHOW1    TM    OPTIONS,OPTEQO      ARE WE PRINTING .EQ. ONLY?\n         BO    SHOW1X              YES, DONT PRINT THESE\n         MVC   LINE,LINE-1\n         MVC   LINE+01(8),20(R3)\n         MVC   LINE+32(23),=C'MEMBER IN SYSLIB 1 ONLY'\n         BAS   R14,REPORTL\nSHOW1X   LR    R2,R3\n         BAS   R8,GETMEM\n         B     READY\n         SPACE 1\n************************************************************\n*                                                          *\n*        MEMBER EXISTS ONLY IN SYSLIB 2.                   *\n*                                                          *\n************************************************************\n         SPACE 1\nSHOW2    TM    OPTIONS,OPTEQO      ARE WE PRINTING .EQ. ONLY?\n         BO    SHOW2X              YES, DONT PRINT THESE\n         MVC   LINE,LINE-1\n         MVC   LINE+22(8),20(R4)\n         MVC   LINE+32(23),=C'MEMBER IN SYSLIB 2 ONLY'\n         BAS   R14,REPORTL\nSHOW2X   LR    R2,R4\n         BAS   R8,GETMEM\n         B     READY\n         EJECT\n************************************************************\n*                                                          *\n*        SUBROUTINE TO GET NEXT MEMBER FROM DIRECTORY.     *\n*                                                          *\n************************************************************\n         SPACE 1\nGETMEM   LM    R0,R1,0(R2)\n         CLC   0(8,R1),=8X'FF'     END OF MEMBERS?\n         BER   R8\nGET1R    SLR   R15,R15\n         IC    R15,11(,R1)\n         N     R15,=F'31'          SET OFF ALL BUT LAST 5 BITS\n         SLL   R15,1               CHANGE HALFWORDS TO BYTES\n         LA    R1,12(R15,R1)       POINT PAST USER DATA\n         CR    R1,R0               END OF BLOCK?\n         BL    GETMEM1             NO, BRANCH\n         LA    R1,256              YES, READ NEXT BLOCK\n         A     R1,8(,R2)\n         ST    R1,8(,R2)\n         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE\n         AR    R0,R1               POINT PAST LAST BYTE\n         LA    R1,2(,R1)           POINT TO FIRST MEMBER\n***      B     GET1R\nGETMEM1  STM   R0,R1,0(R2)\n         MVC   20(8,R2),0(R1)      SAVE MEMBER NAME\n         CLC   0(8,R1),=8X'FF'     END OF MEMBERS?\n         BER   R8\n         MVC   16(4,R2),8(R1)      SAVE TTR, ALIAS BIT, ETC\n         XC    28(64,R2),28(R2)    ZERO USER DATA AREA\n         SPACE 1\n*        COPY USER DATA.\n         SPACE 1\n         SLR   R15,R15\n         IC    R15,11(,R1)\n         N     R15,=F'31'          SET OFF ALL BUT LAST 5 BITS\n         SLL   R15,1               CHANGE HALFWORDS TO BYTES\n         ST    R15,12(,R2)         SAVE LENGTH OF USER DATA\n         LTR   R15,R15\n         BZR   R8\n         TM    OPTIONS,OPTUSER     IS USERDATA TO BE COMPARED?\n         BZR   R8                  NO, BRANCH\n         CLI   15(R2),30           IS LENGTH 30?\n         BNE   *+L'*+4             NO\n         OI    12(R2),SPFFLAG      YES, INDICATE IT MAY BE SPF STATS\n         BCTR  R15,0               LENGTH MINUS 1 FOR EX\n         B     *+L'*+6\n         MVC   28(0,R2),12(R1)     << EXECUTED >>\n         EX    R15,*-6             MOVE THE USER DATA\n         TM    11(R1),B'01100000'  ANY TTR'S IN THE USER DATA?\n         BZR   R8                  NO, BRANCH\n         NI    12(R2),255-SPFFLAG  YES, CAN'T BE SPF\n         IC    R15,11(,R1)         YES, PREPARE TO ZERO THEM\n         N     R15,=A(X'0000007F') SET OFF ALIAS BIT\n         SRL   R15,5               SHIFT OUT RIGHT 5 BITS\n         LA    R14,28(,R2)         POINT TO FIRST TTR IN USER DATA\nGETUTTR  XC    0(3,R14),0(R14)     ZERO THE TTR IN THE USER DATA\n         LA    R14,4(,R14)         POINT TO NEXT TTR IN THE USER DATA\n         BCT   R15,GETUTTR         REPEAT UNTIL R15 ZERO\n         BR    R8\n         EJECT\n************************************************************\n*                                                          *\n*        MESSAGE ROUTINE.                                  *\n*                                                          *\n************************************************************\n         SPACE 1\nPRTMSG   STM   R14,R1,PRTMSGS\n         MVC   MESG,MESG-1\n         LR    R15,R0\n         BCTR  R15,0\n         B     *+L'*+6\n         MVC   MESG+1(0),0(R1)\n         EX    R15,*-6\n         LA    R1,MESG\n         LA    R0,L'MESG\n         BAS   R14,REPORT\n         LM    R14,R1,PRTMSGS\n         BR    R14\n         SPACE 1\n************************************************************\n*                                                          *\n*        REPORT WRITER.                                    *\n*                                                          *\n************************************************************\n         SPACE 1\nREPORTL  LA    R1,LINE\n         LA    R0,121\nREPORT   STM   R14,R3,REPORTS\n         LA    R3,PRTDCBW          POINT R3 TO DCB\n         CP    REPORTLN,REPORTMX   IS LINECOUNT LIMIT REACHED?\n         BL    *+L'*+6             NO\n         ZAP   REPORTLN,=P'0'      YES, FORCE NEW PAGE\n         CP    REPORTLN,=P'0'      IS NEW PAGE REQUESTED?\n         BE    REPORTH             YES, GO PRINT HEADING\nREPORTD  CH    R0,=H'121'          IS OUTPUT LINE LENGTH OK?\n         BNL   REPORTP             YES, BRANCH\n         MVC   REPORTO,REPORTO-1   BLANK THE WORK AREA\n         LTR   R14,R0              COPY LENGTH\n         BNP   REPORTB             BLANK LINE IF < 1\n         BCTR  R14,0               LENGTH MINUS 1\n         B     *+L'*+6\n         MVC   REPORTO(0),0(R1)    COPY OUTPUT LINE\n         EX    R14,*-6             EXECUTE MOVE\nREPORTB  LA    R1,REPORTO          POINT TO NEW OUTPUT LINE\nREPORTP  LR    R2,R1               POINT R2 TO OUTPUT LINE\n        PUT    (R3),(R2)           WRITE OUTPUT LINE\n         AP    REPORTLN,=P'1'      INCREMENT LINE COUNTER\nREPORTX  LM    R14,R3,REPORTS      RESTORE REGS\n         BR    R14                 RETURN\nREPORTH  AP    REPORTPG,=P'1'      INCREMENT PAGE COUNTER\n         MVC   REPORTO,REPORTO-1   BLANK HEADING\n         MVI   REPORTO,C'1'        CC = NEW PAGE\n         MVC   REPORTO+1(L'HEAD1),HEAD1\n         LA    R1,REPORTO+79-9     RIGHT EDGE PAGE NO\n         MVC   3(6,R1),=X'402020202020' EDIT MASK\n         ED    3(6,R1),REPORTPG    UNPACK PAGE NO\n         MVC   0(4,R1),=C'PAGE'    INSERT 'PAGE'\n        PUT    (R3),REPORTO        PUT HEADING LINE 1\n         MVC   REPORTO,REPORTO-1   BLANK LINE\n        PUT    (R3),REPORTO        PUT HEADING BLANK LINE\n         AP    REPORTLN,=P'2'      COUNT HEADING LINES\nREPORTHX LM    R0,R1,REPORTS+8     RESTORE R0 AND R1\n         B     REPORTD             GO PRINT DETAIL LINE\n         EJECT\n************************************************************\n*                                                          *\n*        TERMINATION.                                      *\n*                                                          *\n************************************************************\n         SPACE 1\nEXIT12   MVI   RC+1,12\nEXIT     TM    STATUS,GOTMAIN      IS DIRECTORY AREA GOTTEN?\n         BZ    EXITGOTX            NO, BYPASS FREEMAIN\n         L     R0,DIRSIZE\n         L     R1,DIRFREE\n        FREEMAIN R,LV=(0),A=(1)\nEXITGOTX TM    STATUS,PRTOPEN      IS SYSPRINT OPEN?\n         BZ    EXITPRTX            NO, BYPASS CLOSE\n         LA    R2,PRTDCBW\n         XC    CLOSE,CLOSE\n         OI    CLOSE,X'80'\n        CLOSE  ((R2)),MF=(E,CLOSE)\n        FREEPOOL (R2)\nEXITPRTX LH    R2,RC                                               -EU-\n        $XRET  CC=(R2),LV=@DATAL,TYPE=RENT                         -EU-\n         EJECT\n************************************************************\n*                                                          *\n*        LITERAL POOL.                                     *\n*                                                          *\n************************************************************\n         SPACE 1\n         LTORG\n         EJECT\n************************************************************\n*                                                          *\n*        CONSTANTS.                                        *\n*                                                          *\n************************************************************\n         SPACE 1\nDIRSZDF  DC    0F'0',AL1(1),AL3(128*1024)  128K FOR 2 DIRECTORIES\n         SPACE 1\nYMDNY    DC    AL2(334,304,273,243)\n         DC    AL2(212,181,151,120)\n         DC    AL2(90,59,31,0)\nYMDLY    DC    AL2(335,305,274,244)\n         DC    AL2(213,182,152,121)\n         DC    AL2(91,60,31,0)\n         SPACE 1\n         PRINT NOGEN\nPRTDCB   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,                      X\n               RECFM=FBA,LRECL=121,EXLST=PRTEXLST\nPRTDCBL  EQU   *-PRTDCB\nDIRDCB   DCB   DDNAME=DYNAM,DSORG=PO,MACRF=R,EODAD=DIREOF,SYNAD=DIRSYN,X\n               RECFM=U,BLKSIZE=256\nDIRDCBL  EQU   *-DIRDCB\n         PRINT GEN\n         SPACE 1\nPRTEXLST DC    0F'0',X'85',AL3(PRTEXITO)\nDIRREADM READ  DIRDECB,SF,MF=L\nDIRDECBL EQU   *-DIRDECB\n         SPACE 1\nHEXTAB   DC    C'0123456789ABCDEF'\nMSGINV   DC    C'INVALID DIRECTORY BLOCK'\nMSGEOF   DC    C'NO END-OF-DIRECTORY INDICATOR FOUND'\nMSGCRI1A DC    C'CRITERIA FOR MATCHING IS MEMBER NAME ONLY. USER-DATA IX\n               N THE DIRECTORY'\nMSGCRI1B DC    C'(SUCH AS SPF STATISTICS, LOAD ATTRIBUTES) IS NOT COMPAX\n               RED.'\nMSGCRI2A DC    C'CRITERIA FOR MATCHING IS MEMBER NAME AND ALL USER-DATAX\n                IN THE DIRECTORY'\nMSGCRI2B DC    C'(SUCH AS SPF STATISTICS, LOAD ATTRIBUTES) EXCEPT TTR FX\n               IELDS.'\nHEAD1    DC    C'--- PDSMATCH --- PDS DIRECTORY COMPARE UTILITY ---'\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*       -EU-\n* --->   END OF BASE REGISTER ADDRESSABILITY.              *       -EU-\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*       -EU-\n         SPACE 2                                                   -EU-\n         DC    0D'0'\nTABNONBL DC    64X'FF'\n         DC    X'00'               BLANK\n         DC    42X'FF'\n         DC    X'00'               COMMA\n         DC    148X'FF'\nTABBLANK DC    64X'00'\n         DC    X'40'               BLANK\n         DC    42X'00'\n         DC    X'6B'               COMMA\n         DC    148X'00'\n         DC    0D'0'\n         EJECT\n************************************************************\n*                                                          *\n*        DSECTS.                                           *\n*                                                          *\n************************************************************\n         SPACE 1\n@DATA    DSECT\n         DS    18F                 REGISTERS SAVE AREA\n         SPACE 1\nDOUBLE   DS    D\nDIRSIZE  DS    F                   DEFAULT IS 128K FOR 2 DIR.      -EU-\nDDNAMEP  DS    CL8\nDDNAME1  DS    CL8\nDDNAME2  DS    CL8\nDIRFREE  DS    F\nDIRPTR1  DS    F\nDIRPTR2  DS    F\nDIRBLKS  DS    F\nDIRBLKSU DS    F\nMEMBERS  DS    F\nALIASES  DS    F\nPRTDCBW  DS    0F,(PRTDCBL)X\nDIRDCBW  DS    0F,(DIRDCBL)X\nDIRDECBW DS    0F,(DIRDECBL)X\nDIREXLST DS    F\nDEVAREA  DS    2F\nCLOSE    DS    0F\nOPEN     DS    F\nRDJFCB   DS    F\nPARSES   DS    6F\nREPORTS  DS    6F\nPRTMSGS  DS    4F\n         SPACE 1\nPDSWORK1 DS    3F\n         DS    F                   USER DATA LENGTH\nSPFFLAG  EQU   X'80'               USER DATA CONTAINS SPF STATISTICS\n         DS    XL3                 TTR\n         DS    X                   ALIAS BIT AND USER DATA LENGTH\n         DS    CL8                 MEMBER NAME\n         DS    CL64                USER DATA\n         SPACE 1\nPDSWORK2 DS    3F\n         DS    F                   USER DATA LENGTH\n         DS    XL3                 TTR\n         DS    X                   ALIAS BIT AND USER DATA LENGTH\n         DS    CL8                 MEMBER NAME\n         DS    CL64                USER DATA\n         SPACE 1\nRC       DS    H\nREPORTPG DS    PL3\nREPORTLN DS    PL2\nREPORTMX DS    PL2\nSTATUS   DS    X\nPRTOPEN  EQU   X'80'\nDIROPEN  EQU   X'40'\nGOTMAIN  EQU   X'20'\nOPTIONS  DS    X\nOPTUSER  EQU   X'80'\nOPTEQO   EQU   X'40'\nOPTNEO   EQU   X'20'\nDIRSW    DS    X\nDFVLD    EQU   X'01'\nDFIOE    EQU   X'02'\nDFMSG    EQU   X'04'\n         SPACE 1\nLINEB    DS    C                   (LINE-1)\nLINE     DS    CL133\nMESGB    DS    C                   (MESG-1)\nMESG     DS    CL133\nMESSAGE  DS    CL72\nREPORTOB DS    C                   (REPORTO-1)\nREPORTO  DS    CL133\n         SPACE 1\nJFCB1    DS    0D,CL176\nJFCB2    DS    0D,CL176\n         SPACE 1\n@DATAL   EQU   (((*-@DATA)+7)/8)*8\n         SPACE 2\n        PRINT  NOGEN\n        DCBD   DSORG=PS,DEVD=DA\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "POF": {"ttr": 27657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(_\\x00\\x90(_\\x12\\x10\\x03F\\x03F\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-12T00:00:00", "modifydate": "1990-10-12T12:10:00", "lines": 838, "newlines": 838, "modlines": 0, "user": "SYSPAJA"}, "text": "VSPO     TITLE '* * *  POF - VTAM SECONDARY PROGRAM OPERATOR  * * *'\nPOF      START 0\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  PURPOSE -   PROVIDE VTAM SECONDARY PROGRAM OPERATOR FOR USE IN TSO *\n*              COMMAND OR AS A STAND ALONE VTAM APPLICATION PROGRAM.  *\n*                                                                     *\n*  OPERATION - POF OPENS ITS OWN ACB, AND USING TPUT/TGET AND         *\n*              SENDCMD/RCVCMD ALLOWS AN AUTHORIZED TSO USER TO        *\n*              BE A VTAM SECONDARY PROGRAM OPERATOR. THE COMMANDS     *\n*              AND RESPONSES ARE ALSO RECORDED ON SYSLOG.             *\n*                                                                     *\n*  WRITTEN BY DOUG MOORE - SEPTEMBER 1978                             *\n*                                                                     *\n*  MODIFIED BY DOUG MOORE - JANUARY 1980                              *\n*              SUPPORT ADDED FOR * = REPEAT LAST COMMAND              *\n*                                ? = SHOW LAST COMMAND                *\n*                                X = PCF EXIT                         *\n*                                                                     *\n*  MODIFIED BY DOUG MOORE - AUGUST 1980                               *\n*              SUPPORT ADDED FOR MULTIPLE POF'S. CURRENT MAX OF 3.    *\n*                                                                     *\n*  MODIFIED BY DOUG MOORE - JULY 1981                                 *\n*              SUPPORT ADDED FOR PFKEYS.                              *\n*                                                                     *\n*  MODIFIED BY MOINIL P.A.- AUGUST 1984                           -EU-*\n*              SUPPORT DELETED FOR X = PCF EXIT                   -EU-*\n*              SOLVE SOME ERRORS OCCURING AT END                  -EU-*\n*                                                                     *\n*  MODIFIED BY MOINIL P.A.- OCTOBER 1986                          -EU-*\n*              WAIT FOR END OF RECEIVE MESSAGES                   -EU-*\n*                                                                     *\n***********************************************************************\n         EJECT\nPOF     AMODE  24\nPOF     RMODE  24\n         SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        AUTHORITY LEVELS DEFINITIONS.                                *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nLV0      EQU   0         REJECT LEVEL.\n         SPACE 1\n        $MDL@IX\n         EJECT\n        $DEFREG\n         SPACE 2\n        IEZBITS\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        POF - MAIN PROGRAM.                                          *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\n        $XENT  BASE=R12\n         LR    R2,R1               GET ENTRY REGISTER\n         CNOP  0,4\n         L     R8,*+L'*+4          DATA AREA'S BASE REGISTER.\n         B     *+L'*+4\n         DC    A(DATA)\n         USING DATA,R8\n         SPACE 1\n         USING PSA,R0\n         L     R1,PSAAOLD          GET ASCB ADDRESS\n         DROP  R0\n         USING ASCB,R1\n         L     R0,ASCBTSB          GET TSB ADDRESS\n         DROP  R1\n         LTR   R0,R0               IS THIS TSO (A(TSB) NOT = 0) ?\n         BNZ   POFTSO              ...YES, OK\n        WTO    '* INVALID ENVIRONMENT *',ROUTCDE=11,DESC=7,MF=L\n         B     POFRTN              FORGET IT\n         USING CPPL,R2             SET CPPL ADDRESSABILITY\nPOFTSO  EXTRACT POFPSCB,'S',FIELDS=(PSB)\n         L     R1,POFPSCB          PSCB ADDRESS\n         USING PSCB,R1\n         CLC   PSCBUPT,CPPLUPT     CPPL+4 = UPT ADDRESS ?\n         BNE   *+L'*+10            NO\n         DROP  R1\n         CLC   POFPSCB(L'POFPSCB),CPPLPSCB CPPL+8 = PSCB ADDRESS ?\n         BE    OKCMD               YES, TSO COMMAND\n         LR    R1,R2\n         USING IKJEBECA,R1\n         L     R2,CAPTTMP          CPPL ADDRESS\n         DROP  R1\n         CLC   POFPSCB(L'POFPSCB),CPPLPSCB CPPL+8 = PSCB ADDRESS ?\n         BE    OKCMD               YES, TSO SUB-COMMAND\n         MVC   POFOUT(20),=C'* CALL NOT ALLOWED *'\n        TPUT   POFOUT,20\n         B     POFRTN              FORGET IT\nOKCMD    L     R1,CPPLPSCB         GET PSCB ADDRESS\n         USING PSCB,R1\n         MVC   POFUSRID,PSCBUSER   SAVE USERID\n         DROP  R1,R2\n        $EACM  REQAUT\n         CLI   AUTH,LV0            AUTHORIZED ?\n         BNE   POFAUTH             ...YES, OK TO PROCEED\n         MVC   POFOUT(24),=C'* UNAUTHORIZED COMMAND *'\n        TPUT   POFOUT,24\n         B     POFRTN              DON'T LET THEM PLAY\nPOFAUTH OPEN   (POFACB)            OPEN SPO ACB\n         LTR   R15,R15             OPEN OK ?\n         BZ    POFOPNK             ...YES, CONTINUE\n         LA    R2,POFACB           POINT TO ACB\n         USING IFGACB,R2\n         CLI   ACBOFLGS,X'02'      POSSIBLE ACB ALREADY OPEN ?\n         BNE   POFOPNF             ...NO, SOMETHING ELSE\n         CLI   ACBERFLG,X'58'      POSSIBLE ACB ALREADY OPEN ?\n         BNE   POFOPNF             ...NO, SOMETHING ELSE\n         CLC   =CL8'POF003',POFACBAI+1  IS THIS THE LAST ALTERNATE ?\n         BE    POFMAXU                  ...YES, THAT WAS THE LAST ACB\n         AP    POFACB#,=PL1'1'     GET NEXT ACB NUMBER\n         UNPK  POFACBAI+4(3),POFACB#(2)\n         OI    POFACBAI+6,X'F0'\n         B     POFAUTH             TRY AGAIN\nPOFMAXU  MVC   POFOUT(37),=C'* MAXIMUM POF USERS ALREADY STARTED *'\n        TPUT   POFOUT,37\n         B     POFRTN              GO AWAY\nPOFOPNF  MVC   POFOUT(39),=C'OPEN FAILED FOR VTAM SPO ACB - XXXXXXXX'\n         MVC   POFOUT+31(8),POFACBAI+1  INSERT ACB NAME\n        TPUT   POFOUT,39\n         MVC   POFDBLWK+1(1),ACBOFLGS   GET OPEN FLAGS\n         UNPK  POFDBLWK(1),POFDBLWK+1(1)     PREPARE FOR CONVERSION\n         MVC   POFDBLWK+3(1),ACBERFLG   GET ERROR FLAGS\n         UNPK  POFDBLWK+2(1),POFDBLWK+3(1)   PREPARE FOR CONVERSION\n         NC    POFDBLWK(4),=X'0F0F0F0F' PREPARE FOR TRANSLATE\n         TR    POFDBLWK(4),POFTRTBL     TRANSLATE\n         MVC   POFMSG1(4),POFDBLWK PUT IN MESSAGE\n        TPUT   POFMSG1,L'POFMSG1\n         B     POFRTN              OPEN FAILED SO GET OUT\n         DROP  R2\n         SPACE 1\nPOFOPNK GTSIZE ,                   GET SCREEN SIZE\n         STC   R0,GTSIZE0          SAVE FOR LATER TEST\n         STC   R1,GTSIZE1          SAVE FOR LATER TEST\n         MVC   WTOSLT,=AL2(33)     LENGTH OF MESSAGE\n         MVC   WTOSTX(7),POFUSRID  PUT USERID IN MESSAGE\n         MVC   WTOSTX+7(14),=C' LOGGED ON TO '\n         MVC   WTOSTX+21(8),POFACBAI+1  PUT ACB IN MESSAGE\n         MVC   POFOUT(40),=C'VTAM SPO FUNCTION ACTIVATED FOR XXXXXXXX'\n         MVC   POFOUT+32(8),POFACBAI+1  PUT ACB IN MESSAGE\n        TPUT   POFOUT,40\n        RCVCMD RPL=POFRPLRC        ISSUE FIRST RCVCMD\n         LTR   R15,R15             ACCEPTED ?\n         BZ    POFSTID             ...YES, GO SEND STATUS COMMAND\n         L     R10,=A(ABEND)       ...NO, GIVE UP\n         ICM   R1,B'1111',=CL4'ERR1' - - - - - - - - - - - - - ERROR 1\n         BR    R10\nPOFSTID  MVC   POFIN(20),=CL20'D NET,U,ID=....... '    SET COMMAND\n         MVC   POFIN+11(7),POFUSRID     PUT USERID IN COMMAND\n         LA    R1,20               COMMAND LENGTH\n         B     POFSTORE            GO SEND IT\nPOFRQCMD TM    POFSW,FREND         WAIT FOR END ?\n         BZ    POFEVC              ...NO\n         LA    R5,60               SET 1 MIN CONTROL\nPOFWAIT STIMER WAIT,,BINTVL=TIMESC WAIT A SEC, THEN\n         TM    POFSW,FREND         ALWAYS WAIT FOR END ?\n         BZ    POFEVC              ...NO\n         BCT   R5,POFWAIT          GO WAIT AGAIN\n         NI    POFSW,255-FREND-FRMSG    FORCE\n         MVC   POFOUT(12),=C'*END* FORCED'\n         B     POFENDF\nPOFEVC   TM    POFSW,FRMSG         END MESSAGE PENDING ?\n         BZ    POFEVCS             ...NO\n         NI    POFSW,255-FRMSG     RESET END MESSAGE PENDING\n         MVC   POFOUT(12),=C'IST314I  END'\nPOFENDF  MVC   POFOUT+12(3),=C' - '\n         MVC   POFOUT+15(20),=C'ENTER VTAM COMMAND :'\n         LA    R0,35\n         B     POFSEVC\nPOFEVCS  MVC   POFOUT(20),=C'ENTER VTAM COMMAND :'\n         LA    R0,20\nPOFSEVC TPUT   POFOUT,(0)          PUT IT OUT\n         CLI   GTSIZE0,X'00'       IS THIS 3270 INPUT ?\n         BNE   POF3270             ...YES, GO DO 3270 PROCESSING\n        TGET   POFIN,L'POFIN       GET THE COMMAND\n         LTR   R1,R1               ANY INPUT ?\n         BZ    POFRQCMD            ...NO, GO ASK AGAIN\nPOFRQCHK OC    POFIN,=CL80' '      MAKE UPPERCASE FOR WRITING TO SYSLOG\n         CLC   =CL3'END',POFIN     THE END ?\n         BE    POFEOJ              ...YES, GO TO EOJ\n         CLC   =CL4'HELP',POFIN    HELP WANTED ?\n         BE    POFHELP             ...YES, GO DO HELP\n         CLI   POFIN,C'*'          WANT TO DO SAME THING ?\n         BNE   POFCHKQ             ...NO, GO CHECK FOR QUESTION MARK\n         L     R1,SAVECMDL         RELOAD LENGTH\n         MVC   POFIN,SAVECMD       RELOAD COMMAND\n         B     POFDOCMD            GO DO COMMAND\nPOFCHKQ  CLI   POFIN,C'?'          WANT TO SEE LAST COMMAND ?\n         BNE   POFSTORE            ...NO, GO SAVE THIS INPUT\n         L     R1,SAVECMDL         RELOAD LENGTH\n        TPUT   SAVECMD,(1)         WRITE LAST COMMAND BACK OUT\n         B     POFRQCMD            GO SEE WHAT TO DO\nPOFSTORE ST    R1,SAVECMDL         SAVE LENGTH\n         MVC   SAVECMD,POFIN       SAVE COMMAND\nPOFDOCMD LA    R2,POFRPLSC         POINT TO SENDCMD RPL\n         USING IFGRPL,R2\n         AH    R1,=H'4'            ADD HEADER LENGTH TO COMMAND LENGTH\n         ST    R1,RPLRLEN          STORE LENGTH IN RPL\n         DROP  R2\n         STH   R1,WTOLTH           STORE LENGTH FOR WTO\n         MVC   WTOTXT(L'POFIN),POFIN    MOVE COMMAND TO WTO\n         OI    POFSW,FREND         SET WAIT FOR END\n         L     R10,=A(SNAP)        TRACE IF NEEDED\n         LA    R0,1                SNAP ID NUMBER - - - - - - - ID = 1\n         BASR  R9,R10\n        SENDCMD RPL=POFRPLSC       ISSUE THE COMMAND\n         LTR   R15,R15             SUCCESSFUL ?\n         BZ    POFLOG              ...YES, GO LOG COMMAND\n         L     R10,=A(ABEND)       ...NO, GIVE UP\n         ICM   R1,B'1111',=CL4'ERR2' - - - - - - - - - - - - - ERROR 2\n         BR    R10\nPOFLOG   TM    POFSW,FSLOG         LOG ALREADY ACTIVE ?\n         BO    POFLOGX             BRANCH IF YES\n        WTO    MF=(E,WTOSTRT)      WRITE LOGON TO SYSLOG\n         OI    POFSW,FSLOG         INDICATE LOG STARTED\nPOFLOGX WTO    MF=(E,WTOLIST)      WRITE COMMAND TO LOG\n         B     POFRQCMD            GO GET ANOTHER COMMAND\n         SPACE 1\nPOF3270 TGET   POFIN,L'POFIN,ASIS  GET THE COMMAND\n         LTR   R1,R1               ANY INPUT ?\n         BZ    POFRQCMD            ...NO, GO ASK AGAIN\n         L     R5,=A(AIDTABLE)     POINT TO AID TABLE\n         LA    R6,NUMAIDS          NUMBER OF AIDS I MIGHT SEE\nPOFAIDLP CLC   POFIN(1),0(R5)      IS THIS THE AID ?\n         BE    POFGAID             ...YES, PROCEED\n         LA    R5,4(0,R5)          POINT TO NEXT ENTRY\n         BCT   R6,POFAIDLP         LOOP UNTIL DONE\n*                                  NO HITS POINTS TO DEFAULT ENTRY\nPOFGAID  L     R2,0(0,R5)          GET ADDRESS OF AID FUNCTION TABLE\n         CLI   0(R2),X'FF'         ENTER KEY ?\n         BNE   POFNOTEN            ...NO, PROCEED\n         MVC   POFIN(74),POFIN+6   GET RID OF 3270 STUFF\n         SH    R1,=H'6'            FIX LENGTH\n         BNP   POFRQCMD            THERE WAS NO INPUT, GET NEW CMD\n         B     POFRQCHK            RETURN TO NORMAL FLOW\nPOFNOTEN MVC   WORKCMD,POFIN       SAVE INPUT TEMPORARILY\n         MVI   POFIN,C' '          BLANK OUT BUFFER\n         MVC   POFIN+1(L'POFIN-1),POFIN\n         CLI   0(R2),X'00'         ANY PROCESSING ?\n         BNE   POFAIDP             ...YES, PROCEED\nPOFNOOPS SLR   R3,R3               CLEAR REG FOR EXECUTE\n         IC    R3,1(0,R2)          GET LENGTH FOR EXECUTE MOVE\n         EX    R3,AIDMVC           MOVE IN COMMAND\n         LA    R1,1(0,R3)          PUT REAL LENGTH IN R1\n         B     POFRQCHK            RETURN TO NORMAL FLOW\nPOFAIDP  CLI   0(R2),X'01'         FURTHER PROCESSING REQUIRED ?\n         BNE   POFAIDF             ...NO, PROCEED\n         SH    R1,=H'6'            CORRECT LENGTH\n         BNP   POFNOOPS            BRANCH IF NO OPERANDS\n         SLR   R3,R3               CLEAR REG FOR EXECUTE\n         IC    R3,1(0,R2)          GET LENGTH FOR EXECUTE MOVE\n         EX    R3,AIDMVC           MOVE IN 1ST PART OF COMMAND\n         LA    R4,POFIN+1(R3)      POINT TO END OF THIS PIECE\n         BCTR  R1,0                DECREMENT FOR EXECUTED MOVE\n         EX    R1,BLDMVC           MOVE IN REMAINDER OF COMMAND\n         LA    R1,2(R1,R3)         ADD NEW PART TO TOTAL(+2 FOR EX MVC)\n         B     POFRQCHK            RETURN TO NORMAL FLOW\nPOFAIDF  L     R5,=A(BADAID)       POINT TO UNSUPPORTED AID\n         B     POFGAID             THROW IN THE TOWEL\nAIDMVC   MVC   POFIN(*-*),2(R2)    MOVE COMMAND TO BUFFER\nBLDMVC   MVC   0(*-*,R4),WORKCMD+6 BUILD NEW COMMAND\n         SPACE 1\nPOFHELP  L     R5,=A(PFK1)         POINT TO PFK1\n         L     R6,=A(PFK13)        POINT TO PFK13\n         LA    R4,12               12 * 2 PFKEYS\n         SLR   R2,R2               CLEAR REG\nPOFHLOOP MVI   POFOUT,C' '         CLEAR LINE\n         MVC   POFOUT+1(L'POFOUT-1),POFOUT\n         MVC   POFOUT(7),=C'PFKXX ='\n         MVC   POFOUT+30(7),=C'PFKXX ='\n         LA    R3,25               GET PFK NUMBER FROM LOOP COUNTER\n         SR    R3,R4\n         CVD   R3,POFDBLWK\n         UNPK  POFDBLWK(3),POFDBLWK+6(2)\n         MVC   POFOUT+33(2),POFDBLWK+1\n         OI    POFOUT+34,X'F0'\n         SP    POFDBLWK+6(2),=P'12'\n         UNPK  POFDBLWK(3),POFDBLWK+6(2)\n         MVC   POFOUT+3(2),POFDBLWK+1\n         OI    POFOUT+4,X'F0'\n         IC    R2,1(R5)            GET LENGTH OF MSG\n         EX    R2,HELPMVC1         MOVE TO BUFFER\n         LA    R5,3(R2,R5)         POINT TO NEXT MESSAGE\n         IC    R2,1(R6)            GET LENGTH OF MSG\n         EX    R2,HELPMVC2         MOVE TO BUFFER\n         LA    R6,3(R2,R6)         POINT TO NEXT MESSAGE\n         LA    R0,39(0,R2)         GET REAL LENGTH\n         LA    R1,POFOUT           POINT TO OUTPUT BUFFER\n         ICM   R1,B'1000',=X'20'   SET TPUT PARMS (LOWP)\n        TPUT   (1),(0),R           PUT OUT THE MESSAGE\n         BCT   R4,POFHLOOP         LOOP UNTIL DONE\n         B     POFRQCMD            RETURN\nHELPMVC1 MVC   POFOUT+8(0),2(R5)   MOVE IN MESSAGE\nHELPMVC2 MVC   POFOUT+38(0),2(R6)  MOVE IN MESSAGE\nPOFEOJ   OI    POFSW,FSEOJ         INDICATE END REQUESTED\n        CLOSE  (POFACB)            CLOSE THE ACB\n         LTR   R15,R15             CLOSE SUCCESSFUL ?\n         BZ    POFCLSOK            ...YES, PROCEED\n         MVC   POFOUT(29),=C'CLOSE FAILED FOR VTAM SPO ACB'\n        TPUT   POFOUT,29\n         LA    R2,POFACB           POINT TO ACB\n         USING IFGACB,R2\n         CLI   ACBERFLG,X'4C'      MORE MESSAGES OUSTANDING ?\n         BNE   POFCLSF             ...NO, PRESS ON\n         MVC   POFOUT(27),=C'OUTSTANDING MESSAGES PURGED'\n        TPUT   POFOUT,27\n         B     POFEOJ              TRY CLOSE AGAIN\nPOFCLSF  MVC   POFDBLWK+1(1),ACBOFLGS   GET OPEN FLAGS\n         UNPK  POFDBLWK(1),POFDBLWK+1(1)     PREPARE FOR CONVERSION\n         MVC   POFDBLWK+3(1),ACBERFLG   GET ERROR FLAGS\n         UNPK  POFDBLWK+2(1),POFDBLWK+3(1)   PREPARE FOR CONVERSION\n         NC    POFDBLWK(4),=X'0F0F0F0F' PREPARE FOR TRANSLATE\n         TR    POFDBLWK(4),POFTRTBL     TRANSLATE\n         MVC   POFMSG1(4),POFDBLWK PUT IN MESSAGE\n        TPUT   POFMSG1,L'POFMSG1\n         B     POFRTN              CLOSE FAILED SO GET OUT\n         DROP  R2\nPOFCLSOK TM    POFSW,FSLOG         LOG WAS ACTIVE ?\n         BZ    POFRTN              BRANCH IF NOT\n         MVC   WTOSLT,=AL2(34)     LENGTH OF MESSAGE\n         MVC   WTOSTX(7),POFUSRID  PUT USERID IN MESSAGE\n         MVC   WTOSTX+7(15),=C' LOGGED OFF OF '\n         MVC   WTOSTX+22(8),POFACBAI+1  PUT ACB IN MESSAGE\n        WTO    MF=(E,WTOSTRT)      WRITE LOGOFF TO SYSLOG\nPOFRTN   L     R10,=A(SNAPCL)\n         BASR  R9,R10\n        $XRET  CC=0\n         DROP  R12\n         SPACE 1\n        LTORG\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        POF - RCVCMD EXIT.                                           *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nPOFRCVEX LR    R12,R15             GET NEW BASE\n         USING POFRCVEX,R12\n         CNOP  0,4\n         L     R8,*+L'*+4          DATA AREA'S BASE REGISTER.\n         B     *+L'*+4\n         DC    A(DATA)\n         ST    R14,POFRCSV         SAVE RETURN REG\n         LR    R2,R1               SAVE RPL POINTER\n         USING IFGRPL,R2           ADDRESS RPL\n         LA    R13,POFRCVSA        POINT TO RSA\n        CHECK  RPL=POFRPLRC        CHECK RCVCMD RPL\n         LTR   R15,R15             SUCCESSFUL ?\n         BZ    POFRCVA             ...YES, PROCEED\n         L     R10,=A(ABEND)       ...NO, GIVE UP\n         ICM   R1,B'1111',=CL4'ERR3' - - - - - - - - - - - - - ERROR 3\n         BR    R10\nPOFRCVA  MVC   LRM(L'LRM),RPLRLEN+L'RPLRLEN-L'LRM\n         L     R10,=A(SNAP)        TRACE IF NEEDED\n         LA    R0,2                SNAP ID NUMBER - - - - - - - ID = 2\n         BASR  R9,R10\n         CLC   =XL2'100D',RPLRTNCD ACB CLOSED ?\n         BE    POFRCLD             ...YES, DONT DO ANY MORE\n         TM    POFCMDI+1,POHEND+POHDATA POSSIBLE NO DATA ?\n         BNM   POFRCVB             ...NO, CONTINUE (ONES OR ZEROS)\n         TM    POFCMDI+1,POHEND    END OF MULTI-LINE, NO DATA ?\n         BO    POFRCLD             ...YES, NO OUTPUT\nPOFRCVB  CLC   POFIMSG(12),=C'IST314I  END'  END OF RECEIVE ?\n         BE    POFEMSG             ...YES\n         ICM   R0,B'1111',RPLRLEN  GET LENGTH OF REPLY\n         BZ    POFRCLD             ...NONE\n         STH   R0,WTOLTH           STORE LENGTH FOR WTO\n         SH    R0,=H'4'            LESS HEADER LENGTH\n         LA    R1,POFIMSG          A(REPLY)\n        TPUT   (1),(0)             PUT OUT THE REPLY\n         B     POFRCTL\nPOFEMSG  OI    POFSW,FRMSG         SET END MESSAGE PENDING\nPOFRCTL  TM    POFSW,FSLOG         LOG ALREADY ACTIVE ?\n         BO    POFRCVC             BRANCH IF YES\n        WTO    MF=(E,WTOSTRT)      WRITE LOGON TO SYSLOG\n         OI    POFSW,FSLOG         INDICATE LOG STARTED\nPOFRCVC  MVC   WTOTXT(L'POFIMSG),POFIMSG     MOVE RESPONSE TO WTO\n        WTO    MF=(E,WTOLIST)      WRITE RESPONSE TO LOG\n         TM    POFCMDI+1,POHEND    END OF MULTI-LINE ?\n         BO    POFRCLD             ...YES\n         TM    POFCMDI+1,POHDATA   DATA LINE ?\n         BO    POFRCVI             ...YES\n         CLC   POFIMSG(26),=C'IST097I  DISPLAY  ACCEPTED'\n         BE    POFRCVI             ...YES, OTHERWISE ERROR MSG\nPOFRCLD  NI    POFSW,255-FREND     RESET WAIT FOR END\nPOFRCVI  XC    RPLRLEN,RPLRLEN     RESET LENGTH OF REPLY\n         XC    POFCMDI(4),POFCMDI  RESET COMMAND HEADER\n         MVI   POFIMSG,C' '        CLEAR MESSAGE\n         MVC   POFIMSG+1(L'POFIMSG-1),POFIMSG\n        RCVCMD RPL=POFRPLRC        ISSUE ANOTHER RCVCMD\n         LTR   R15,R15             ACCEPTED ?\n         BZ    POFRCRT             ...YES, RETURN\n         L     R10,=A(ABEND)       ...NO, GIVE UP\n         ICM   R1,B'1111',=CL4'ERR4' - - - - - - - - - - - - - ERROR 4\n         BR    R10\nPOFRCRT  L     R14,POFRCSV         RESTORE RETURN REG\n         BR    R14                 RETURN\n         SPACE 1\n         DROP  R2,R12\n         SPACE 1\n        LTORG\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        POF - LERAD/SYNAD EXIT.                                      *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nPOFLSAD  LR    R12,R15             SET UP BASE\n         USING POFLSAD,R12\n         CNOP  0,4\n         L     R8,*+L'*+4          DATA AREA'S BASE REGISTER.\n         B     *+L'*+4\n         DC    A(DATA)\n         LR    R2,R1               SAVE RPL POINTER\n         USING IFGRPL,R2\n         ST    R14,POFLSSV         SAVE RETURN ADDRESS\n         CLC   =XL2'100D',RPLRTNCD IS THIS PSEUDO ERROR (ACB CLSD) ?\n         BE    POFNOERR            ...YES, NOT REALLY AN ERROR\n         CLC   =XL2'146E',RPLRTNCD IS THIS PSEUDO ERROR ?\n         BE    POFNOERR            ...YES, NOT REALLY AN ERROR\n         CLC   =XL2'1471',RPLRTNCD IS THIS PSEUDO ERROR ?\n         BE    POFNOERR            ...YES, NOT REALLY AN ERROR\n         CLC   =XL2'1470',RPLRTNCD IS THIS PSEUDO ERROR ?\n         BNE   POFERR              ...NO, GO TO ERROR DIAGNOSE\n         TM    POFSW,FSEOJ         ...YES, THE END ?\n         BZ    POFERR              ...NO, ERROR\nPOFNOERR SLR   R15,R15             SET GOOD RETURN CODE\n         L     R14,POFLSSV         RELOAD RETURN REG\n         BR    R14                 RETURN\nPOFERR   MVC   POFOUT(14),=C'UNKNOWN FAILED'\n         TM    RPLREQ,RPLRVCMD     RCVCMD FAILED ?\n         BNO   POFREQ              ...NO, TRY SENDCMD\n         MVC   POFOUT(7),=C'RCVCMD '    SHOW RCVCMD\n         B     POFRQST\nPOFREQ   TM    RPLREQ,RPLSDCMD     SENDCMD FAILED ?\n         BNO   POFRQST             ...NO, THATS IT\n         MVC   POFOUT(7),=C'SENDCMD'    SHOW SENDCMD\nPOFRQST TPUT   POFOUT,14\n         MVC   POFDBLWK+1(1),RPLRTNCD   GET RETURN CODE\n         UNPK  POFDBLWK(1),POFDBLWK+1(1)     PREPARE FOR CONVERSION\n         MVC   POFDBLWK+3(1),RPLFDB2    GET FEEDBACK FIELD\n         UNPK  POFDBLWK+2(1),POFDBLWK+3(1)   PREPARE FOR CONVERSION\n         NC    POFDBLWK(4),=X'0F0F0F0F' PREPARE FOR TRANSLATE\n         TR    POFDBLWK(4),POFTRTBL     TRANSLATE\n         MVC   POFMSG2(4),POFDBLWK PUT IN MESSAGE\n        TPUT   POFMSG2,L'POFMSG2\n         NI    POFSW,255-FREND     RESET WAIT FOR END\n         LA    R15,BIT0            INDICATE SENDCMD/RCVCMD FAILURE\n         L     R14,POFLSSV         RELOAD RETURN REG\n         BR    R14                 RETURN\n         SPACE 1\n         DROP  R2,R12\n         SPACE 1\n        LTORG\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        POF - COMMON DATA AREAS.                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nDATA     DS    0D\n         SPACE 1\nPOFDBLWK DC    D'0'                DOUBLE WORD WORK AREA\nPOFRCVSA DC    18F'0'              RSA FOR RCVCMD EXIT\nPOFRCSV  DC    F'0'\nPOFLSSV  DC    F'0'\nPOFPSCB  DC    A(*-*)\n         SPACE 1\nPOFCMDI  DS    0C                  COMMAND INPUT BUFFER (FROM VTAM)\n         DC    XL4'0'              COMMAND HEADER\nPOFIMSG  DC    CL126' '            MESSAGE\nPOFCMDIL EQU   *-POFCMDI\nLRM      DC    H'0'                LENGTH OF RECEIVED MESSAGE\nPOFCMDIE EQU   *-1                 END SNAP ID 2 ADDRESS\n         SPACE 1\nPOFCMDO  DS    0C                  COMMAND OUTPUT BUFFER (TO VTAM)\n         DC    XL1'0'              COMMAND HEADER\n         DC    AL1(POHRREQ+POHGEN)\n         DC    XL2'0'\nPOFIN    DC    CL80' '             TGET BUFFER\nPOFCMDOL EQU   *-POFCMDO\nSAVECMDL DC    F'0'                LENGTH OF SAVED COMMAND\nPOFCMDOE EQU   *-1                 END SNAP ID 1 ADDRESS\n         SPACE 1\nGTSIZE0  DC    XL1'0'              NUMBER OF LINES/SCREEN\nGTSIZE1  DC    XL1'0'              NUMBER OF CHARS/LINE\nPOFSW    DC    XL1'0'              PROCESSING FLAGS\nFSEOJ    EQU   X'01'                    END REQUESTED\nFSLOG    EQU   X'02'                    HARD COPY ACTIVE\nFREND    EQU   X'10'                    WAIT END OF RECEIVE\nFRMSG    EQU   X'20'                    END MESSAGE PENDING\nAUTH     DC    XL1'0'\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(AUTH)\nTIMESC   DC    A(1*100)            1.00 SEC WAIT INTERVAL\n         SPACE 1\nPOFTRTBL DC    CL16'0123456789ABCDEF'\nPOFOUT   DC    CL80' '             TPUT BUFFER\nSAVECMD  DC    CL80' '             SAVED COMMAND\nWORKCMD  DC    CL80' '             COMMAND WORK AREA\n         EJECT\n         PRINT NOGEN\nWTOSTRT WTO    ' ',MCSFLAG=HRDCPY,MF=L   WTO TO LOG CMDS & RESP.\n         PRINT GEN\nWTOSLT   EQU   WTOSTRT,2           LENGTH OF TEXT + 4\n         ORG   WTOSTRT+4           POINT TO MESSAGE\nWTOSTX   DC    CL126' '            MESSAGE TEXT (MAX OF 124)\n         SPACE 1\n         PRINT NOGEN\nWTOLIST WTO    ' ',MCSFLAG=HRDCPY,MF=L   WTO TO LOG CMDS & RESPONSES\n         PRINT GEN\nWTOLTH   EQU   WTOLIST,2           LENGTH OF TEXT + 4\n         ORG   WTOLIST+4           POINT TO MESSAGE\nWTOTXT   DC    CL126' '            MESSAGE TEXT (MAX OF 124)\n         SPACE 1\nPOFUSRID DC    CL7' '              TSO USER ID\nPOFMSG1  DC    C'XXXX = ACBOFLGS/ACBERFLG'\nPOFMSG2  DC    C'XXXX = RTNCD/FDBK2'\n         SPACE 1\n         PRINT NOGEN\nPOFACB   ACB   AM=VTAM,                                                X\n               APPLID=POFACBAI,                                        X\n               PASSWD=POFACBPW,                                        X\n               EXLST=POFACBEX,                                         X\n               MACRF=NLOGON\n         PRINT GEN\n         SPACE 1\nPOFACB#  DC    PL2'1'              ACB COUNTER FOR MULTIPLE POF'S\nPOFACBAI DC    X'08'\n         DC    CL8'POF001'         ACB NAME\nPOFACBPW DC    X'08'\n         DC    CL8'POFSPOPW'       ACB PASSWORD\n         SPACE 1\n         PRINT NOGEN\nPOFACBEX EXLST AM=VTAM,                                                X\n               LERAD=POFLSAD,                                          X\n               SYNAD=POFLSAD\n         SPACE 1\nPOFRPLSC RPL   AM=VTAM,                                                X\n               ACB=POFACB,                                             X\n               AREA=POFCMDO,                                           X\n               RECLEN=POFCMDOL,                                        X\n               OPTCD=(SYN)\n         SPACE 1\nPOFRPLRC RPL   AM=VTAM,                                                X\n               ACB=POFACB,                                             X\n               AREA=POFCMDI,                                           X\n               AREALEN=POFCMDIL,                                       X\n               EXIT=POFRCVEX,                                          X\n               OPTCD=(ASY,Q,TRUNC)\n         PRINT GEN\n         SPACE 1\n*------- END OF COMMON DATA AREAS ADDESSABILITY (R8) -----------------*\n         EJECT\nAIDTABLE DS    0F\n         DC    X'7D',AL3(ENTER)    ENTER KEY/SELECTOR LIGHT-PEN ATTN\n         DC    X'F1',AL3(PFK1)     PFK 1\n         DC    X'F2',AL3(PFK2)     PFK 2\n         DC    X'F3',AL3(PFK3)     PFK 3\n         DC    X'F4',AL3(PFK4)     PFK 4\n         DC    X'F5',AL3(PFK5)     PFK 5\n         DC    X'F6',AL3(PFK6)     PFK 6\n         DC    X'F7',AL3(PFK7)     PFK 7\n         DC    X'F8',AL3(PFK8)     PFK 8\n         DC    X'F9',AL3(PFK9)     PFK 9\n         DC    X'7A',AL3(PFK10)    PFK 10\n         DC    X'7B',AL3(PFK11)    PFK 11\n         DC    X'7C',AL3(PFK12)    PFK 12\n         DC    X'C1',AL3(PFK13)    PFK 13\n         DC    X'C2',AL3(PFK14)    PFK 14\n         DC    X'C3',AL3(PFK15)    PFK 15\n         DC    X'C4',AL3(PFK16)    PFK 16\n         DC    X'C5',AL3(PFK17)    PFK 17\n         DC    X'C6',AL3(PFK18)    PFK 18\n         DC    X'C7',AL3(PFK19)    PFK 19\n         DC    X'C8',AL3(PFK20)    PFK 20\n         DC    X'C9',AL3(PFK21)    PFK 21\n         DC    X'4A',AL3(PFK22)    PFK 22\n         DC    X'4B',AL3(PFK23)    PFK 23\n         DC    X'4C',AL3(PFK24)    PFK 24\n         DC    X'6E',AL3(PA2)      PA 2\n         DC    X'6B',AL3(PA3)      PA 3\nNUMAIDS  EQU   (*-AIDTABLE)/4      TOTAL NUMBER OF AIDS\nBADAID   DC    X'00',AL3(NOSUPT)   NOT SUPPORTED\n         SPACE 1\nENTER    DC    X'FF'               FLAGS\n         DC    AL1(ENTERL-3)       LENGTH FOR EXECUTED MOVE\n         DC    C' '                COMMAND\nENTERL   EQU   *-ENTER             LENGTH\nPFK1     DC    X'00'\n         DC    AL1(PFK1L-3)\n         DC    C'HELP'\nPFK1L    EQU   *-PFK1\nPFK2     DC    X'00'\n         DC    AL1(PFK2L-3)\n         DC    C'D NET,BFRUSE'\nPFK2L    EQU   *-PFK2\nPFK3     DC    X'00'\n         DC    AL1(PFK3L-3)\n         DC    C'END'\nPFK3L    EQU   *-PFK3\nPFK4     DC    X'00'\n         DC    AL1(PFK4L-3)\n         DC    C'D NET,PENDING'\nPFK4L    EQU   *-PFK4\nPFK5     DC    X'00'\n         DC    AL1(PFK5L-3)\n         DC    C'D NET,APPLS'\nPFK5L    EQU   *-PFK5\nPFK6     DC    X'00'\n         DC    AL1(PFK6L-3)\n         DC    C'D NET,MAJNODES'\nPFK6L    EQU   *-PFK6\nPFK7     DC    X'00'\n         DC    AL1(PFK7L-3)\n         DC    C'D NET,LINES,I'\nPFK7L    EQU   *-PFK7\nPFK8     DC    X'00'\n         DC    AL1(PFK8L-3)\n         DC    C'D NET,CLSTRS,I'\nPFK8L    EQU   *-PFK8\nPFK9     DC    X'00'\n         DC    AL1(PFK9L-3)\n         DC    C'D NET,TERMS,I'\nPFK9L    EQU   *-PFK9\nPFK10    DC    X'01'\n         DC    AL1(PFK10L-3)\n         DC    C'D NET,ID='\nPFK10L   EQU   *-PFK10\nPFK11    DC    X'01'\n         DC    AL1(PFK11L-3)\n         DC    C'V NET,ACT,ID='\nPFK11L   EQU   *-PFK11\nPFK12    DC    X'01'\n         DC    AL1(PFK12L-3)\n         DC    C'V NET,INACT,ID='\nPFK12L   EQU   *-PFK12\nPFK13    DC    X'00'\n         DC    AL1(PFK13L-3)\n         DC    C'HELP'\nPFK13L   EQU   *-PFK13\nPFK14    DC    X'00'\n         DC    AL1(PFK14L-3)\n         DC    C'D NET,BFRUSE'\nPFK14L   EQU   *-PFK14\nPFK15    DC    X'00'\n         DC    AL1(PFK15L-3)\n         DC    C'END'\nPFK15L   EQU   *-PFK15\nPFK16    DC    X'00'\n         DC    AL1(PFK16L-3)\n         DC    C'D NET,PENDING'\nPFK16L   EQU   *-PFK16\nPFK17    DC    X'00'\n         DC    AL1(PFK17L-3)\n         DC    C'D NET,APPLS'\nPFK17L   EQU   *-PFK17\nPFK18    DC    X'00'\n         DC    AL1(PFK18L-3)\n         DC    C'D NET,MAJNODES'\nPFK18L   EQU   *-PFK18\nPFK19    DC    X'00'\n         DC    AL1(PFK19L-3)\n         DC    C'D NET,LINES,I'\nPFK19L   EQU   *-PFK19\nPFK20    DC    X'00'\n         DC    AL1(PFK20L-3)\n         DC    C'D NET,CLSTRS,I'\nPFK20L   EQU   *-PFK20\nPFK21    DC    X'00'\n         DC    AL1(PFK21L-3)\n         DC    C'D NET,TERMS,I'\nPFK21L   EQU   *-PFK21\nPFK22    DC    X'01'\n         DC    AL1(PFK22L-3)\n         DC    C'D NET,ID='\nPFK22L   EQU   *-PFK22\nPFK23    DC    X'01'\n         DC    AL1(PFK23L-3)\n         DC    C'V NET,ACT,ID='\nPFK23L   EQU   *-PFK23\nPFK24    DC    X'01'\n         DC    AL1(PFK24L-3)\n         DC    C'V NET,INACT,ID='\nPFK24L   EQU   *-PFK24\nPA2      DC    X'00'\n         DC    AL1(PA2L-3)\n         DC    C'PA 2 KEY'\nPA2L     EQU   *-PA2\nPA3      DC    X'00'\n         DC    AL1(PA3L-3)\n         DC    C'PA 3 KEY'\nPA3L     EQU   *-PA3\nNOSUPT   DC    X'00'\n         DC    AL1(NOSUPTL-3)\n         DC    C'THIS AID NOT SUPPORTED.'\nNOSUPTL  EQU   *-NOSUPT\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        POF - SNAP DUMP PROCESS.                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* SNAP ENTRY : TO TAKE A SNAP DUMP.                                   *\n*              R0  = SNAP ID NUMBER (0-255).                          *\n*              R8  = ADDRESS OF DATA AREA (PASSED BY CALLER).         *\n*              R9  = LINK REGISTER.                                   *\n*              R10 = ADDRESS OF SNAP ROUTINE.                         *\n*              NOTE - THE FOLLOWING ALLOCATION IS NEEDED TO           *\n*                     OBTAIN THE SNAP DUMPS :                         *\n*                        ALLOC F(SYSSNAP) SYSOUT(A)                   *\n*                     OR :                                            *\n*                        ALLOC F(SYSSNAP) DA(...) OLD                 *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\n         CNOP  0,4\n         USING *,R10\nSNAP     TM    SNAPSW,SNAPFNA      FUNCTION INACTIVE ?\n         BOR   R9                  YES, BYPASS\n         STM   R14,R12,12(R13)     ENTRY\n         LR    R1,R13\n         LA    R13,SNAPSV\n         ST    R1,4(R13)\n         ST    R13,8(R1)\n         LR    R4,R0               SAVE SNAP ID NUMBER\n         LA    R2,SNAPDCB\n         USING IHADCB,R2\n         TM    SNAPSW,SNAPOPN      DATA-SET ALREADY OPENED ?\n         BO    SNO                 YES\n        EXTRACT ATIOT,'S',FIELDS=(TIOT)\n         L     R3,ATIOT\n         USING TIODSECT,R3\n         XR    R1,R1\nSNS      CLC   TIOELNGH(4),=F'0'\n         BE    SNN\n         CLC   TIOEDDNM(L'TIOEDDNM),DCBDDNAM\n         BE    SNF\n         IC    R1,TIOELNGH\n         ALR   R3,R1\n         B     SNS\n         DROP  R3\nSNF     OPEN   (SNAPDCB,OUTPUT)\n         TM    DCBOFLGS,DCBOFOPN   SUCCESSFULLY OPENED ?\n         BZ    SNN                 NO\n         DROP  R2\n         OI    SNAPSW,SNAPOPN      INDICATE DATA-SET OPENED\nSNO      CH    R4,SNAPMAX          KNOWN ID NUMBER ?\n         BNL   SNE                 NO, BYPASS\n         LR    R5,R4\n         MH    R5,SNAPTLE\n         LA    R5,SNAPTB(R5)\n         LA    R6,8(R5)\n         TM    0(R6),X'80'         UNUSED ELEMENT ?\n         BZ    SNE                 YES, BYPASS\n        SNAP   TCB='S',ID=(R4),LIST=(R5),STRHDR=(R6),MF=(E,SNAPLIST)\n         LTR   R15,R15             ALL OK ?\n         BZ    SNE                 YES\nSNN      OI    SNAPSW,SNAPFNA      INACTIVE FUNCTION\nSNE      L     R13,4(R13)          EXIT\n         LM    R14,R12,12(R13)\n         BR    R9\n         DROP  R10\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* SNAPCL ENTRY : TO CLOSE THE SNAP FILE IF OPENED.                    *\n*              R8  = ADDRESS OF DATA AREA (PASSED BY CALLER).         *\n*              R9  = LINK REGISTER.                                   *\n*              R10 = ADDRESS OF SNAPCL ROUTINE.                       *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\n         CNOP  0,4\n         USING *,R10\nSNAPCL   TM    SNAPSW,SNAPOPN      DATA-SET IS OPENED ?\n         BZR   R9                  NO\n         STM   R14,R12,12(R13)     ENTRY\n         LR    R1,R13\n         LA    R13,SNAPSV\n         ST    R1,4(R13)\n         ST    R13,8(R1)\n        CLOSE  (SNAPDCB)\n         L     R13,4(R13)          EXIT\n         LM    R14,R12,12(R13)\n         BR    R9\n         DROP  R10\n         SPACE 1\n         PRINT NOGEN\nSNAPDCB  DCB   DSORG=PS,RECFM=VBA,MACRF=(W),                           X\n               BLKSIZE=1632,LRECL=125,DDNAME=SYSSNAP\nSNAPLIST SNAP  DCB=SNAPDCB,MF=L\n         PRINT GEN\n         SPACE 1\nSNAPSV   DC    18F'0'\nATIOT    DC    F'0'\n         SPACE 1\nSNAPTB   DC    3F'0'               0 = NOT USED\nSNAPTBL  EQU   *-SNAPTB            ELEMENT LENGTH\n         DC    A(POFCMDO),XL1'80',AL3(POFCMDOE),XL1'80',AL3(SHDO)\n         DC    A(POFCMDI),XL1'80',AL3(POFCMDIE),XL1'80',AL3(SHDI)\nSNAPTBM  EQU   (*-SNAPTB)/SNAPTBL  NUMBER OF ELEMENTS\n         SPACE 1\nSNAPTLE  DC    Y(SNAPTBL)          ELEMENT LENGTH\nSNAPMAX  DC    Y(SNAPTBM)          NUMBER OF ELEMENTS (MAX ID)\nSNAPSW   DC    XL1'0'\nSNAPFNA  EQU   X'01'               SNAP FUNCTION NOT ACTIVE.\nSNAPOPN  EQU   X'02'               SNAP DATA-SET IS OPENED.\nSHDO     DC    AL1(L'SHDOT)\nSHDOT    DC    C'P O F - DUMP OF COMMAND OUTPUT BUFFER (SENDCMD).'\nSHDI     DC    AL1(L'SHDIT)\nSHDIT    DC    C'P O F - DUMP OF COMMAND INPUT BUFFER (RCVCMD).'\n         SPACE 1\n        LTORG\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        POF - ABEND PROCESS.                                         *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\n         CNOP  2,4\n         USING *,R10\nABEND    STCM  R1,B'1111',ABCODE   SET ABEND ERROR CODE\n         LA    R1,1                SET DUMP OPTION\n         SLL   R1,31\n         ALR   R1,R15              SET ABEND CODE\n        ABEND  (1)                 THIS ABEND WILL CAUSE A SVC DUMP\n         DROP  R10\n         SPACE 1\nABCODE   DC    CL4' '              ENTITLED 'VTAM IRB ABEND' ALSO\n         SPACE 2\n         PRINT NOGEN\n        ISTDPOHD\n        IFGACB AM=VTAM\n        IFGRPL AM=VTAM\n        IHAPSA\n        IHAASCB\n        IKJCPPL\n        IKJPSCB\n        IKJEBECA\nTIODSECT DSECT\n        IEFTIOT1\n        DCBD   DEVD=DA,DSORG=PS\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "POF$": {"ttr": 28163, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15H\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:48:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//POF      JOB (........),'INSTALL  - P O F -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ4AS3,MBR=POF\n//LNK     EXEC PAJILKC\n//SYSIN     DD *\n  ENTRY   POF\n  NAME    POF(R)\n/*\n//HLP     EXEC PAJHELP,MBR=POFH,DSS='->.SOURCE.FILE4'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "POF@": {"ttr": 28165, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x008\\x008\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 56, "newlines": 56, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      POF       1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *   VTAM SECONDARY PROGRAM OPERATOR   * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    This VTAM secondary program operator only runs under\n  ---------    TSO. The TSO user may be logged on either under TCAM\n               or VTAM. The TSO user is required to have the OPER\n               authorization. It is also necessary to add the following\n               to SYS1.VTAMLST(APPCONXX) :\n\n               POF001  APPL  PRTCT=POFSPOPW,  TSO COMMAND VTAM SPO\n                             AUTH=(SPO),\n                             EAS=1\n               POF002  APPL  PRTCT=POFSPOPW,  TSO COMMAND VTAM SPO\n                             AUTH=(SPO),\n                             EAS=1\n               POF003  APPL  PRTCT=POFSPOPW,  TSO COMMAND VTAM SPO\n                             AUTH=(SPO),\n                             EAS=1\n\n               All commands and responses are logged to SYSLOG.\n               Up to 3 TSO users at a time may be executing POF.\n               This may be modified by increasing or decreasing\n               the number of POF applications defined to VTAM and\n               changing the literal =CL8'POF003' in POF to match.\n\n               Help is available by entering HELP,\n               END terminates the command,\n               ? will display the previous entry and\n               * will reissue the previous entry.\n               PFKs 13-24 are treated like PFKs 1-12.\n\n               PFK definitions :\n\n                   +-----------+-----------+-----------+\n                   I         1 I         2 I         3 I\n                   I HELP      I D BFRUSE  I END       I\n                   +-----------+-----------+-----------+\n                   I         4 I         5 I         6 I\n                   I D PENDING I D APPLS   I D MAJNODE I\n                   +-----------+-----------+-----------+\n                   I         7 I         8 I         9 I\n                   I D LINES   I D CLSTRS  I D TERMS   I\n                   +-----------+-----------+-----------+\n                   I        10 I        11 I        12 I\n                   I D ID=     I V ACT     I V INACT   I\n                   +-----------+-----------+-----------+\n\n Author :      DOUG MOORE, SCHERING-PLOUGH, INC (31 MAR 82)\n --------      3030 JACKSON AVE, MEMPHIS, TN 38151\n               901/320-2883\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "POFH": {"ttr": 28167, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=POF\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  THIS VTAM SECONDARY PROGRAM OPERATOR ONLY RUNS UNDER\n               TSO. THE TSO USER MAY BE LOGGED ON EITHER UNDER TCAM\n               OR VTAM. THE TSO USER IS REQUIRED TO HAVE THE \"OPER\"\n               AUTHORIZATION. ALL COMMANDS AND RESPONSES ARE LOGGED\n               TO SYSLOG, AND UP TO 3 TSO USERS AT A TIME MAY BE\n               EXECUTING POF. HELP IS AVAILABLE BY ENTERING \"HELP\",\n               \"END\" TERMINATES THE COMMAND, \"?\" WILL DISPLAY THE\n               PREVIOUS ENTRY AND \"*\" WILL REISSUE THE PREVIOUS ENTRY.\n               PFK DEFINITIONS :\n                   +-----------+-----------+-----------+\n                   I         1 I         2 I         3 I\n                   I HELP      I D BFRUSE  I END       I\n                   +-----------+-----------+-----------+\n                   I         4 I         5 I         6 I\n                   I D PENDING I D APPLS   I D MAJNODE I\n                   +-----------+-----------+-----------+\n                   I         7 I         8 I         9 I\n                   I D LINES   I D CLSTRS  I D TERMS   I\n                   +-----------+-----------+-----------+\n                   I        10 I        11 I        12 I\n                   I D ID=     I V ACT     I V INACT   I\n                   +-----------+-----------+-----------+\n               PFKS 13-24 ARE TREATED LIKE PFKS 1-12.\n)X SYNTAX :    POF\n               ALIAS : NONE.\n)O OPERANDS :  NONE.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PSWSAMP": {"ttr": 28169, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882o\\x00\\x882o\\x158\\x05\\x05\\x05\\x05\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-21T00:00:00", "modifydate": "1988-11-21T15:38:00", "lines": 1285, "newlines": 1285, "modlines": 0, "user": "SYSPAJA"}, "text": "PSWS     TITLE 'PACKLIST - SAMPLE TAKER.'\nPSWSAMP START 0\n         SPACE 1\n*        DATA SET CBT932 - AT LEVEL 001 AS OF 02/25/79\n*                          PSWSAMP VERSION 1.0 (WDPSC)\n         SPACE 1\n* PURPOSE OF ORIGINAL VERSION :\n* -----------------------------\n*\n*              IS THE SAMPLE TAKER FOR PACKLIST. THE TECHNIQUE IS\n*              TO MOVE THE TRACE TABLE TO AN OUTPUT RECORD. IT DOES\n*              NOT MATTER THAT THE MOVE LONG OF THE TABLE CAN BE\n*              INTERUPTED. THE VALUES TAKEN AT ANY POINT ARE A SAMPLE,\n*              WHETHER INTERUPTED OR NOT.\n*              THE SAMPLE WILL NOT BEGIN UNLESS THE FIRST ENTRY OF THE\n*              TABLE IS NOW DIFFERENT THAN THE PREVIOUS SAMPLE. THE\n*              SAMPLE RATE IS APPROXIMATELY ONCE EVERY 2.5 SECONDS\n*              (THE FIELD HOW LONG CAN BE ADJUSTED).\n*              THE TECHNIQUE FOR OVERALL SAMPLING AND END USE IS\n*              COVERED IN THE PACKLIST PROGRAM.\n*\n*              PSWSAMP WILL RUN FOR THE TIME INTERVAL SET WITHIN THIS\n*              PROGRAM (UNLESS CHANGED BY THE USE OF PARM=... IN THE\n*              EXEC) AND THEN WILL AUTOMATICALLY TERMINATE. IT CAN\n*              ALSO BE STOPPED BY REPLYING TO THE WTOR ISSUED.\n         EJECT ,                                                   -EU-\n* STRATEGY CHANGES DESCRIPTION :                                   -EU-\n* ------------------------------                                   -EU-\n*                                                                  -EU-\n*              ORIGINALLY, THIS SAMPLER TAKER WAS COPYING THE      -EU-\n*              ENTIRE TRACE TABLE, BUT THE PACKLIST PROGRAM        -EU-\n*              REALLY USE ONLY 1/10 OF ALL ENTRIES, ONLY THOSE     -EU-\n*              WHICH FAULTS INTO THE LPA BOUNDARIES. SO, THE       -EU-\n*              NUMBER OF OUTPUT RECORDS WILL BE CONSIDERABLY       -EU-\n*              REDUCED BY SELECTING THE USEFULL TRACE TABLE        -EU-\n*              ENTRIES ONLY.                                       -EU-\n         SPACE 1                                                   -EU-\n*     N O T E  THAT THE SIZE (BLKSIZE) OF THE OUTPUT RECORD        -EU-\n*              DEPENDS UPON THE CHOICE OF THE VALUE SPECIFIED      -EU-\n*              TO THE PARAMETER HEREAFTER :                        -EU-\n         SPACE 1                                                   -EU-\nNTTE     EQU   355            NUMBER OF TRACE TABLE ENTRIES        -EU-\n         SPACE 1                                                   -EU-\n*              AN ENTRY OF THE TRACE TABLE IS 32 BYTES LONG.       -EU-\n*              HERE FOLLOWS, AS EXAMPLE, SOME VALUES TO SET AN     -EU-\n*              ADJUSTED DATA-SET BLOCK-SIZE CONSIDERING THE DISK   -EU-\n*              TYPE ON WHICH IT RESIDES :                          -EU-\n*                   400 - 3330 DISK (1 REC/TRK)                    -EU-\n*                   295 - 3350 DISK (2 REC/TRK)                    -EU-\n*                   355 - 3380 DISK (4 REC/TRK)                    -EU-\n         SPACE 1                                                   -EU-\n*              THE ORIGINAL PENDING WTOR USED TO STOP THE PROGRAM  -EU-\n*              HAS BEEN REPLACED BY THE MAIN CONSOLE OPERATOR STOP -EU-\n*              COMMAND, AND THE TIME INTERVAL LIMIT MAY BE CHANGED -EU-\n*              AT ANY MOMENT THROUGH THE MODIFY COMMAND.           -EU-\n*              NOW, THE PROGRAM TRIES TO DYNAMICALLY ADJUST THE    -EU-\n*              SAMPLE RATE STARTING WITH ONCE EVERY 2.4 SECONDS.   -EU-\n         SPACE 1                                                   -EU-\n*              THE AMBLIST SERVICE AIDS AND THE IEHLIST UTILITY    -EU-\n*              PROGRAMS ARE ALSO INTERNALLY INVOKED TO PRODUCE     -EU-\n*              THE LISTLPA AND LISTPDS OF THE CURRENTLY RUNNING    -EU-\n*              SYSTEM, AVOIDING POSSIBLE PROBLEMS WHEN EXECUTING   -EU-\n*              THE PACKLIST PROGRAM LATER.                         -EU-\n         SPACE 1                                                   -EU-\n*              NOW, AT THE START TIME, WHEN THE TRACE IS FOUND     -EU-\n*              INACTIVE, THE PROGRAM TRIES TO START IT FOR HIS     -EU-\n*              PURPOSES. IF SUCCESSFULLY STARTED, THEN IT STOPS    -EU-\n*              THE TRACE AUTOMATICALLY AT THE END.                 -EU-\n         EJECT ,                                                   -EU-\n* INVOKING JCL :\n* --------------\n*\n*   //SAMPLER  EXEC PGM=PSWSAMP,PARM=NNNN                          -EU-\n*   //SYSDIR     DD DSN=SYS1.LPALIB,DISP=SHR ---> MVS/370          -EU-\n*   OR :                                                           -EU-\n*   //SYSDIR0    DD DSN=SYS1.LPALIB,DISP=SHR ---> MVS/XA           -EU-\n*   //SYSDIR1    DD DSN=OTHER.LPALIB,DISP=SHR ---> MVS/XA          -EU-\n*   //SYSPSW     DD ... OUTPUT SAMPLER DATA-SET ...                -EU-\n*   OR OMIT IT IF PARM=NULL IS SPECIFIED.                          -EU-\n*   //SYSPRINT   DD ... OUTPUT LISTLPA DATA-SET / AMBLIST ...      -EU-\n*   //SYSIN      DD ... (LISTLPA STATEMENT / AMBLIST) ...          -EU-\n*   //SYSDOU     DD ... OUTPUT LISTPDS DATA-SET(S) / IEHLIST ...   -EU-\n*   //SYSDIN     DD ... (LISTPDS STATEMENT(S) / IEHLIST) ...       -EU-\n*                                                                  -EU-\n*        WHERE NNNN (1 TO 4 NUMERIC DIGITS) IS THE TIME INTERVAL   -EU-\n*                   LIMIT EXPRESSED IN MINUTES (MAXIMUM IS 1200).  -EU-\n*        IF PARM=NULL IS SPECIFIED, THEN ONLY LISTLPA (AMBLIST)    -EU-\n*                   AND LISTPDS (IEHLIST) ARE EXECUTED.            -EU-\n*        IF PARM=... IS OMITTED, THE DEFAULT IS 15 MINUTES.        -EU-\n*\n* CBT ORIGIN : EXTRACTED FROM CBT TAPE FEB 85, FILE 270.\n* ------------ ADAPTED BY : MOINIL P.A.\n*                           COMPUTING CENTRE\n*                           J.R.C. - ISPRA ESTABLISHMENT\n*                           21020 ISPRA (VA), ITALY\n         SPACE 2                                                   -EU-\nPSWSAMP AMODE  24                                                  -EU-\nPSWSAMP RMODE  24                                                  -EU-\n         SPACE 2                                                   -EU-\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *  -EU-\n*        AUTHORITY LEVELS DEFINITIONS.                          *  -EU-\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *  -EU-\n         SPACE 1                                                   -EU-\nLV15     EQU   15                  FULLY AUTHORIZED                -EU-\n         SPACE 1                                                   -EU-\n        $MDL@IX ,                                                  -EU-\n         SPACE 2                                                   -EU-\n*        MISCELLANEOUS DEFINITIONS                                 -EU-\n*        -------------------------                                 -EU-\n         SPACE 1                                                   -EU-\nTMVSXA   EQU   X'01'          MVS/XA SYSTEM TYPE                   -EU-\nEL       EQU   X'80'          END OF LIST INDICATOR                -EU-\nSETNOP   EQU   X'0F'          SET NO-OPERATION                     -EU-\nSETBR    EQU   X'F0'          SET BRANCH                           -EU-\n         EJECT ,                                                   -EU-\n        $DEFREG ,                                                  -EU-\n        $XENT  BASE=(R11,R12)                                      -EU-\n         XR    R10,R10             C.C. = 0                        -EU-\n         L     R8,0(R1)            GET PARM DATA AREA ADDRESS      -EU-\n         EJECT\n*        VERIFY CALLER AUTHORITY                                   -EU-\n*        -----------------------                                   -EU-\n         SPACE 1                                                   -EU-\n        EXTRACT ATIOT,'S',FIELDS=(TIOT,TSO)                        -EU-\n         L     R1,ATSO             TSO FLAG ADDRESS                -EU-\n         TM    0(R1),X'80'         ARE WE RUNNING IN TSO ?         -EU-\n         BZ    NOTTSO              BRANCH IF NOT                   -EU-\n        TPUT   NOTAUT,L'NOTAUT                                     -EU-\n         B     RETURN              REJECTED IF TSO ADDRESS SPACE   -EU-\nNOTTSO  $EACM  REQAUT                                              -EU-\n         CLI   AUTH,LV15           AUTHORIZED ?                    -EU-\n         BNL   CHPRM               YES                             -EU-\n        WTO    ' PSWSAMP - INSUFFICIENT AUTHORITY.',               -EU-X\n               ROUTCDE=(2,11),DESC=(6)                             -EU-\n         B     RETURN              REJECTED BECAUSE UNAUTHORIZED   -EU-\n         EJECT\n*        HANDLE PARM=... IF ANY VALID                              -EU-\n*        ----------------------------                              -EU-\n*        (TIME INTERVAL LIMIT EXPRESSED IN MINUTES OR 'NULL')      -EU-\n         SPACE 1                                                   -EU-\nCHPRM    LH    R1,0(R8)            PARM DATA COUNT                 -EU-\n         LTR   R1,R1                                               -EU-\n         BNP   SETUP               NO PARM SPECIFIED               -EU-\n         CH    R1,PRMLG                                            -EU-\n         BH    SETUP               INVALID, IGNORE IT              -EU-\n         LA    R2,VALUE+L'VALUE                                    -EU-\n         SLR   R2,R1                                               -EU-\n         BCT   R1,*+L'*+6                                          -EU-\n         MVC   0(*-*,R2),2(R8)     GET PARM DATA                   -EU-\n         EX    R1,*-6                                              -EU-\n         CLC   VALUE,=CL4'NULL'    NO SAMPLER REQUESTED ?          -EU-\n         BNE   *+L'*+8             NO, GO TEST FOR A TIME VALUE    -EU-\n         L     R4,CVTPTR           CVT POINTER                     -EU-\n         B     GETSID                                              -EU-\n         CLC   VALUE,LOWV                                          -EU-\n         BL    SETUP               INVALID, IGNORE IT              -EU-\n         CLC   VALUE,HIGHV                                         -EU-\n         BH    SETUP               INVALID, IGNORE IT              -EU-\n         PACK  WORKD,VALUE                                         -EU-\n         CVB   R3,WORKD                                            -EU-\n         M     R2,=F'6000'                                         -EU-\n         ST    R3,MAXTIME          SET TIME INTERVAL LIMIT         -EU-\n         B     EDTME                                               -EU-\nSETUP    L     R3,MAXTIME                                          -EU-\n         XR    R2,R2                                               -EU-\n         D     R2,=F'6000'                                         -EU-\n         CVD   R3,WORKD            EDIT VALUE IN MESSAGE           -EU-\nEDTME    MVC   STMEL+40(L'EDMSK),EDMSK                             -EU-\n         ED    STMEL+40(L'EDMSK),WORKD+L'WORKD-(L'EDMSK/2)         -EU-\n         EJECT\n*        TEST TRACE STATUS\n*        -----------------\n         SPACE 1                                                   -EU-\n         L     R15,=A(XTTR)        GO TEST STATUS                  -EU-\n         BASR  R9,R15                                              -EU-\n         B     TRCOK                                               -EU-\n         B     ERR9                                                -EU-\n        $SSCMD STRCMD              TRY TO START TRACE              -EU-\n         LTR   R15,R15                                             -EU-\n         BZ    TRSTD                                               -EU-\n         STC   R15,SRC+L'SRC+29                                    -EU-\n         SRL   R15,4                                               -EU-\n         STC   R15,SRC+L'SRC+28                                    -EU-\n         NC    SRC+L'SRC+28(3),MASK                                -EU-\n         TR    SRC+L'SRC+28(3),TRTAB                               -EU-\nSRC     WTO    ' PSWSAMP - SSCMD R.C. =     (TRACE ST).',          -EU-X\n               ROUTCDE=(2,11),DESC=(4)                             -EU-\n         LA    R10,103             C.C. = 103 ******************** -EU-\n         B     LEAVE                                               -EU-\n         SPACE 1                                                   -EU-\nTRSTD    OI    SWPROC,SWTST        SET COMMAND SENDED              -EU-\nTRCOK    L     R4,CVTPTR           CVT POINTER                     -EU-\n         USING CVT,R4                                              -EU-\n         EJECT ,                                                   -EU-\n*        GET SYSTEM ID                                             -EU-\n*        -------------                                             -EU-\n         SPACE 1                                                   -EU-\nGETSID   L     R1,CVTSMCA          SMF CONTROL AREA ADDRESS        -EU-\n         USING SMCABASE,R1                                         -EU-\n         MVC   SID,SMCASID         SYSTEM ID (SID)                 -EU-\n         DROP  R1,R4                                               -EU-\n         SPACE 1                                                   -EU-\n*        EXECUTE AMBLIST (LISTLPA)                                 -EU-\n*        -------------------------                                 -EU-\n         SPACE 1                                                   -EU-\n        LINK   EP=AMBLIST                                          -EU-\n         LTR   R15,R15                                             -EU-\n         BZ    XLPDS                                               -EU-\n         STC   R15,ARC+L'ARC+31                                    -EU-\n         SRL   R15,4                                               -EU-\n         STC   R15,ARC+L'ARC+30                                    -EU-\n         NC    ARC+L'ARC+30(2),MASK                                -EU-\n         TR    ARC+L'ARC+30(2),TRTAB                               -EU-\nARC     WTO    ' PSWSAMP - AMBLIST R.C. =   .',                    -EU-X\n               ROUTCDE=(2,11),DESC=(4)                             -EU-\n         LA    R10,100             C.C. = 100 ******************** -EU-\n         B     LEAVE                                               -EU-\n         EJECT ,                                                   -EU-\n*        EXECUTE IEHLIST (LISTPDS)                                 -EU-\n*        -------------------------                                 -EU-\n         SPACE 1                                                   -EU-\nXLPDS   LINK   EP=IEHLIST,PARAM=(OPTLIST,DDNMELST),VL=1            -EU-\n         LTR   R15,R15                                             -EU-\n         BZ    RLOPEN                                              -EU-\n         STC   R15,IRC+L'IRC+31                                    -EU-\n         SRL   R15,4                                               -EU-\n         STC   R15,IRC+L'IRC+30                                    -EU-\n         NC    IRC+L'IRC+30(2),MASK                                -EU-\n         TR    IRC+L'IRC+30(2),TRTAB                               -EU-\nIRC     WTO    ' PSWSAMP - IEHLIST R.C. =   .',                    -EU-X\n               ROUTCDE=(2,11),DESC=(4)                             -EU-\n         LA    R10,101             C.C. = 101 ******************** -EU-\n         B     LEAVE                                               -EU-\n         EJECT ,                                                   -EU-\n*        GET LPA BOUNDARIES                                        -EU-\n*        ------------------                                        -EU-\n         SPACE 1                                                   -EU-\nRLOPEN  OPEN   (SYSLPA,(INPUT))    INPUT IS AMBLIST OUTPUT         -EU-\n         TM    SYSLPA+(DCBOFLGS-IHADCB),DCBOFOPN  OK OPEN ?        -EU-\n         BO    RLSRCH              YES                             -EU-\n        WTO    ' PSWSAMP - AMBLIST OUTPUT OPEN ERROR.',            -EU-X\n               ROUTCDE=(2,11),DESC=(4)                             -EU-\n         LA    R10,102             C.C. = 102 ******************** -EU-\n         B     LEAVE                                               -EU-\n         SPACE 1                                                   -EU-\nRLSRCH  GET    SYSLPA,PI           SEARCH FOR NUMERIC SESSION...   -EU-\n         CLI   CC,C'1'             TITLE PAGE ?                    -EU-\n         BNE   RLSRCH              NO... GET NEXT PRINT IMAGE      -EU-\n         CLC   CC+15(L'LPMNUM),LPMNUM   START OF NUMERICAL LIST ?  -EU-\n         BE    RLFNUM              YES                             -EU-\n         CLC   CC+1(L'LPMNEW),LPMNEW    NEW NUMERICAL LIST ?       -EU-\n         BNE   RLSRCH              NO... MUST STILL BE IN ALPHA    -EU-\n         OI    SWPROC,SWNEW        YES... NEW AMBLIST FORMAT       -EU-\n         SPACE 1                                                   -EU-\nRLFNUM  GET    SYSLPA,PI           READ PRINT IMAGE                -EU-\n         CLI   CC,C' '             DETAIL LINE ?                   -EU-\n         BNE   RLFNUM              NO... IGNORE                    -EU-\n         LA    R1,S1               POINT TO FIRST SEGMENT          -EU-\n         BAS   R14,RLANAL          ANALYZE IT                      -EU-\n         LA    R1,S2               POINT TO SECOND SEGMENT         -EU-\n         BAS   R14,RLANAL          ANALYZE IT                      -EU-\n         B     RLFNUM              GET NEXT RECORD                 -EU-\n         SPACE 1                                                   -EU-\n         USING LPAE,R1             SEGMENT DSECT                   -EU-\nRLANAL   CLC   LL+1(4),=CL4' '     BLANK LENGTH (NOT MODULE) ?     -EU-\n         BER   R14                 YES... IGNORE                   -EU-\n         CLI   LN,C'A'             AMBLIST INVALID NAME ?    -ERROR-EU-\n         BLR   R14                 YES... IGNORE             -ERROR-EU-\n         TM    SWPROC,SWNEW        NEW AMBLIST FORMAT ?            -EU-\n         BO    RLANAL1             YES                             -EU-\n         TR    LX,TOBIN            CONVERT START AND LENGTH TO BIN -EU-\n         PACK  TS(L'TS+1),LS(L'LS+1)    SAVE START ADDRESS         -EU-\n         PACK  TL(L'TL+1),LL(L'LL+1)    LENGTH                     -EU-\n         B     RLANAL2                                             -EU-\nRLANAL1  CLI   LXN,C' '            TWO BLANKS AFTER NAME ?         -EU-\n         BNE   *+L'*+4             NO, OK                          -EU-\n         LA    R1,1(R1)            YES, ADJUST LINE POINTER        -EU-\n         TR    LXN,TOBIN           CONVERT START AND LENGTH TO BIN -EU-\n         PACK  TS(L'TS+1),LSN(L'LSN+1)  SAVE START ADDRESS         -EU-\n         PACK  TL(L'TL+1),LLN(L'LLN+1)  LENGTH                     -EU-\n         DROP  R1                                                  -EU-\nRLANAL2  NOP   RLANAL3             ONE TIME SWITCH                 -EU-\n         OI    RLANAL2+1,SETBR     CHANGE TO BRANCH                -EU-\n         MVC   LPALOW,TS           SAVE LPA LOW ADDR               -EU-\n         CLC   LPALOW,LPAUP        DOWN 16M LINE ?                 -EU-\n         BL    RLANAL4             YES                             -EU-\n         OI    RLANAL3+1,SETBR     NO... ONLY UP 16M LINE          -EU-\nRLANAL3  NOP   RLANAL4             16M LINE SWITCH                 -EU-\n         CLC   TS,LPAUP            DOWN 16M LINE ?                 -EU-\n         BL    RLANAL4             YES                             -EU-\n         OI    RLANAL3+1,SETBR     CHANGE TO BRANCH                -EU-\n         MVC   LPALOWX,TS          SAVE X-LPA LOW ADDR             -EU-\n         MVC   LPAHI,TE            SAVE LPA HIGH ADDR              -EU-\nRLANAL4  L     R0,TS               COMPUTE MODULE END ADDRESS      -EU-\n         AL    R0,TL                                               -EU-\n         ST    R0,TE                                               -EU-\n         BR    R14                 RETURN                          -EU-\n         SPACE 1                                                   -EU-\nRLEND    OC    LPAHI,LPAHI         ALREADY STORED ?                -EU-\n         BZ    RLONLY              NO... ONLY ONE LPA AREA         -EU-\n         MVC   LPAHIX,TE           SAVE X-LPA HIGH ADDR            -EU-\n         OI    SWPROC,SW16M        INDICATE UP 16M ALSO            -EU-\n         B     RLCLOSE                                             -EU-\nRLONLY   MVC   LPAHI,TE            SAVE LPA HIGH ADDR              -EU-\nRLCLOSE CLOSE  SYSLPA              DON'T NEED THIS ANYMORE         -EU-\n         CLC   VALUE,=CL4'NULL'    NO SAMPLER REQUESTED ?          -EU-\n         BE    RETURN              YES, END                        -EU-\n         EJECT ,                                                   -EU-\n*        TEST TRACE STATUS AGAIN IF NEEDED                         -EU-\n*        ---------------------------------                         -EU-\n         SPACE 1                                                   -EU-\n         TM    SWPROC,SWTST        COMMAND HAS BEEN SENDED?        -EU-\n         BZ    OKTRC               NO                              -EU-\n         L     R15,=A(XTTR)        GO TEST STATUS                  -EU-\n         BASR  R9,R15                                              -EU-\n         B     OKTRC                                               -EU-\n         NOP   0                                                   -EU-\n         NI    SWPROC,255-SWTST    COMMAND HAS NOT RUN             -EU-\n         B     ERR9                                                -EU-\n         SPACE 1\n*        PREPARE TRACE TABLE COPY                                  -EU-\n*        ------------------------                                  -EU-\n         SPACE 1\nOKTRC   ZEROKEY ,                                                  -EU-\n        ESAR   R2                  GET SECONDARY ASID              -EU-\n         ST    R2,SASID            KEEP IT                         -EU-\n        AXRES  AXLIST=AXPL         RESERVE AX                      -EU-\n         L     R2,TRASID           GET TRACE ASID                  -EU-\n        AXEXT  ASID=(2)            EXTRACT AX OF TRACE IN R0       -EU-\n        AXSET  AX=(0)              SET AX TO ALLOW TRACE AS 2ND    -EU-\n        RESETKEY ,                                                 -EU-\n         L     R5,TRSIZE           TRACE BUFFER LENGTH             -EU-\n         ST    R5,MOVLONG+4        LENGTH                          -EU-\n        GETMAIN R,LV=(5)           WORK AREA                       -EU-\n         ST    R1,MOVLONG+8        WORK AREA ADDRESS               -EU-\n         ST    R1,SCAN             SET SCAN REGISTERS VALUES       -EU-\n         L     R14,=A(SNAP1)                                       -EU-\n         ST    R1,0(R14)                                           -EU-\n         AR    R1,R5                                               -EU-\n         LR    R2,R1                                               -EU-\n         SH    R1,=H'4'            (LESS EBCDIC 'TBUF')            -EU-\n         ST    R1,SCAN+8                                           -EU-\n         BCTR  R2,0                                                -EU-\n         O     R2,=A(X'80000000')                                  -EU-\n         ST    R2,4(R14)                                           -EU-\n         EJECT ,                                                   -EU-\n*        OPEN OUTPUT DATA-SET\n*        --------------------\n         SPACE 1                                                   -EU-\n         LA    R2,OUTS                                             -EU-\n         USING IHADCB,R2                                           -EU-\n         LH    R0,BLKSZ                                            -EU-\n         STH   R0,DCBLRECL         LRECL\n         STH   R0,DCBBLKSI         BLKSIZE\n         SLL   R0,1                                                -EU-\n        GETMAIN R,LV=(0)           BUFFER AREA                     -EU-\n         ST    R1,BUFSTR           MAIN BUFFER AREA                -EU-\n         LR    R3,R1               SET STARTING BUFFER AREA        -EU-\n         LH    R5,BLKSZ                                            -EU-\n         AR    R1,R5                                               -EU-\n         ST    R1,BUFSTRA          ALTERNATE BUFFER AREA           -EU-\n         LR    R4,R3               CLEAR BUFFER                    -EU-\n         LA    R6,*                                                -EU-\n         XR    R7,R7                                               -EU-\n         MVCL  R4,R6                                               -EU-\n         LR    R8,R3               SET CURRENT BUFFER POINTER      -EU-\n        OPEN   (OUTS,(OUTPUT))     OUTPUT FILE                     -EU-\n         TM    DCBOFLGS,DCBOFOPN   OPEN SUCCESSFULL ?              -EU-\n         BZ    ERR2                NO                              -EU-\n         DROP  R2                                                  -EU-\n         L     R2,BUFSTRA          BUFFER AREA END +1              -EU-\n         EJECT\n*        MESSAGE TO OPERATOR SO PROGRAM CAN BE ENDED\n*        -------------------------------------------\n         SPACE 1\n         L     R1,ATIOT                                            -EU-\n         USING TIODSECT,R1                                         -EU-\n         MVC   EUMSP(L'EUMSP),TIOCNJOB  SET JOB-NAME               -EU-\n         DROP  R1                                                  -EU-\n        $SETOPC EUMS               ESTABLISH OPERATOR COMM.        -EU-\n         LTR   R15,R15             SUCCESSFULL ?                   -EU-\n         BNZ   ERR3                NO                              -EU-\n         STM   R0,R1,MSGLL         SAVE LENGTH AND MSG-ID'S LIST   -EU-\n         SPACE 1\n*        DISPLAY TIME INTERVAL LIMIT TO RUN                        -EU-\n*        ----------------------------------                        -EU-\n         SPACE 1\nSTMEL   WTO    ' PSWSAMP - TIME INTERVAL LIMIT :       MIN.',      -EU-X\n               ROUTCDE=(2),DESC=(2)                                -EU-\n         ST    R1,MSGDEL                                           -EU-\n         OI    MSGDEL,EL                                           -EU-\n         SPACE 1\n*        CONTROL CONSTANTS\n*        -----------------\n         SPACE 1\n        TIME   BIN                 TIME CHECK\n         ST    R0,STRTME           STARTING TIME OF DAY            -EU-\n         STCM  R1,B'0111',DAY      DAY (00YYDDDF)                  -EU-\n         AL    R0,MAXTIME          MAX IS TIME TO RUN\n         ST    R0,TIME             SAVE FOR REFERENCE\n         EJECT ,                                                   -EU-\n*        MAIN PROCESSING - COPY SAMPLES                            -EU-\n*        ------------------------------                            -EU-\n         SPACE 1                                                   -EU-\nANAL    $TSWXA 31,EXPAND=ONLY      ENTER 31-BIT MODE               -EU-\n         LA    R5,4                                                -EU-\n         XR    R7,R7                                               -EU-\n         USING PSA,R0                                              -EU-\n         L     R4,PSATBVTV         GET CURRENT TBVT                -EU-\n         ST    R4,CURTBVT          SAVE IT FOR CONTROL             -EU-\n         DROP  R0                                                  -EU-\n        ZEROKEY ,                                                  -EU-\n         L     R1,TRASID           GET TRACE ASID                  -EU-\n        SSAR   R1                  SET TRACE AS SECONDARY          -EU-\n         USING TBVT,R4                                             -EU-\n         MVCP  GADDR(R5),TBVTBWRD,R7    GET PREVIOUS TBVT          -EU-\n         L     R4,GADDR                                            -EU-\n         MVCP  GADDR(R5),TBVTBUFV,R7    GET PREVIOUS TBVT BUFFER   -EU-\n         DROP  R4                                                  -EU-\n         L     R4,GADDR                                            -EU-\n         LM    R5,R6,MOVLONG+4     LENGTH + WORK AREA              -EU-\nMOVEBUF  MVCP  0(R5,R6),0(R4),R7   MOVE DATA FROM TRACE BUFFER     -EU-\n         BZ    ENDMOVE                                             -EU-\n         AL    R4,=F'256'          BUMP 'FROM' ADDRESS             -EU-\n         AL    R6,=F'256'          BUMP 'TO' ADDRESS               -EU-\n         SL    R5,=F'256'          DECREMENT THE LENGTH            -EU-\n         B     MOVEBUF             GO BACK AND GET MORE            -EU-\nENDMOVE  L     R1,SASID            RESTORE PREVIOUS SECONDARY      -EU-\n        SSAR   R1                  SHOULD BE AS PRIMARY            -EU-\n        RESETKEY ,                                                 -EU-\n        $TSWXA 24,EXPAND=ONLY      BACK 24-BIT MODE                -EU-\n         L     R15,=A(SNAP)        TRACE IF NEEDED                 -EU-\n         LA    R0,1                SNAP ID NUMBER - - - - - ID = 1 -EU-\n         BASR  R9,R15                                              -EU-\n         LM    R5,R7,SCAN          SCAN TRACE TABLE ENTRIES        -EU-\nLOOP     L     R15,=A(XATT)        TTE'S ANALYSIS                  -EU-\n         BASR  R9,R15                                              -EU-\n         LTR   R1,R1               TTE OK ?                        -EU-\n         BZ    NXTE                BRANCH IF NO                    -EU-\n         CL    R1,LPALOW           IN LPA ?                        -EU-\n         BL    TSUP                BRANCH IF NOT                   -EU-\n         CL    R1,LPAHI            IN LPA ?                        -EU-\n         BNH   PICK                BRANCH IF YES                   -EU-\nTSUP     TM    SWPROC,SW16M        16M LINE ACTIVE ?               -EU-\n         BZ    NXTE                BRANCH IF NOT                   -EU-\n         CL    R1,LPALOWX          IN X-LPA ?                      -EU-\n         BL    NXTE                BRANCH IF NOT                   -EU-\n         CL    R1,LPAHIX           IN X-LPA ?                      -EU-\n         BH    NXTE                BRANCH IF NOT                   -EU-\nPICK     MVC   0(32,R8),NEWTTE     SET NEW XA-TTE FORMAT           -EU-\n         LA    R8,32(,R8)          BUMP OUTPUT POINTER             -EU-\n         CLR   R8,R2               BUFFER FILLED ?                 -EU-\n         BL    NXTE                BRANCH IF NOT                   -EU-\n         BAS   R14,CHCK            VERIFY PREVIOUS RECORD OUTPUTED -EU-\n         BAS   R14,WRTE            EACH COPY IS SEPARATE RECORD    -EU-\n         TM    SWITCH,ALTBUF       SELECT BUFFER                   -EU-\n         BO    FLIP                                                -EU-\n         L     R3,BUFSTRA          ALTERNATE BUFFER                -EU-\n         B     FLOP                                                -EU-\nFLIP     L     R3,BUFSTR           MAIN BUFFER                     -EU-\nFLOP     XI    SWITCH,ALTBUF                                       -EU-\n         LR    R8,R3               CLEAR BUFFER                    -EU-\n         LH    R9,BLKSZ                                            -EU-\n         LR    R2,R3                                               -EU-\n         ALR   R2,R9                                               -EU-\n         LA    R14,*                                               -EU-\n         XR    R15,R15                                             -EU-\n         MVCL  R8,R14                                              -EU-\n         LR    R8,R3               RESET CURRENT BUFFER POINTER    -EU-\nNXTE     BXLE  R5,R6,LOOP          NEXT ENTRY                      -EU-\n         EJECT ,                                                   -EU-\n*        MAIN PROCESSING - CONTROL                                 -EU-\n*        -------------------------                                 -EU-\n         SPACE 1                                                   -EU-\n         LA    R1,L'MTXT                                           -EU-\n         STH   R1,MTXTL                                            -EU-\n        $OPCOM ,MTXTL              LOOK TO OPERATOR                -EU-\n         BCT   R15,GOBACK          BR IF OPERATOR SAY SOMETHING    -EU-\nCTRLT   TIME   BIN                 TIME CHECK\n         ST    R0,ENDTME           ENDING TIME OF DAY IF STOP      -EU-\n         CL    R0,TIME             HAS MAX TIME BEEN REACHED ?\n         BH    GOHOME              YES, THEN STOP\nCTNUE    XR    R14,R14                                             -EU-\n         L     R15,WTIME                                           -EU-\n         SLDL  R14,12                                              -EU-\n         STM   R14,R15,HOWLONG                                     -EU-\nWHEN    STIMER WAIT,MICVL=HOWLONG  WAIT A FEW SECONDS\n         USING PSA,R0                                              -EU-\n         CLC   PSATBVTV,CURTBVT    HAS CURRENT TBVT CHANGED ?      -EU-\n         DROP  R0                                                  -EU-\n         BNE   DYNAD               YES (1ST ENTRY TOD VALUE CHANGED)\n         OI    SWITCH,SWWAIT       NO, WAIT SOME MORE\n         XR    R14,R14                                             -EU-\n         L     R15,WTLOW                                           -EU-\n         SLDL  R14,12                                              -EU-\n         STM   R14,R15,HOWLONG                                     -EU-\n         B     WHEN                                                -EU-\n         EJECT ,                                                   -EU-\n*        MAIN PROCESSING - WAIT ADJUSTMENT                         -EU-\n*        ---------------------------------                         -EU-\n         SPACE 1                                                   -EU-\nDYNAD    TM    SWITCH,SWWAIT       HAVE WE WAIT SOME MORE ?        -EU-\n         BO    DYNAD3              YES                             -EU-\n         CLC   WTIME,WTLOW         HAVE WE REACH THE LOWER LIMIT ? -EU-\n         BNH   ANAL                YES, DON'T ADJUST ANY MORE      -EU-\n         TM    SWITCH,WTON+WTOFF   ADJUSTMENT SHOULD BE DONE ?     -EU-\n         BO    DYNAD1              NO                              -EU-\n         L     R15,WTIME           TRY TO DECREMENT WAIT TIME      -EU-\n         S     R15,WTADJ                                           -EU-\n         ST    R15,WTIME                                           -EU-\n         OI    SWITCH,WTOFF                                        -EU-\n         NI    SWITCH,255-WTON                                     -EU-\n         B     ANAL                                                -EU-\nDYNAD1   CP    WTCTR,WTMAX                                         -EU-\n         BNL   DYNAD2                                              -EU-\n         AP    WTCTR,=P'1'         STILL INTERVAL                  -EU-\n         B     ANAL                                                -EU-\nDYNAD2   ZAP   WTCTR,=P'0'         STILL INTERVAL ENDED            -EU-\n         NI    SWITCH,255-WTON-WTOFF                               -EU-\n         L     R15,WTIME           COMPUTE MEDIUM WAIT TIME        -EU-\nSWMF     NOP   *+L'*+8                                             -EU-\n         OI    SWMF+1,X'F0'        CLOSE THIS WAY                  -EU-\n         B     *+L'*+8                                             -EU-\n         A     R15,MDMTME                                          -EU-\n         SRL   R15,1                                               -EU-\n         ST    R15,MDMTME                                          -EU-\n         B     ANAL                                                -EU-\nDYNAD3   CLC   WTIME,WTHIGH        HAVE WE REACH THE HIGH LIMIT ?  -EU-\n         BNL   DYNAD6              YES, DON'T ADJUST ANY MORE      -EU-\n         TM    SWITCH,WTOFF                                        -EU-\n         BZ    DYNAD4                                              -EU-\n         TM    SWITCH,WTON                                         -EU-\n         BO    DYNAD4                                              -EU-\n         ZAP   WTCTR,=P'0'         RESET STILL INTERVAL            -EU-\n         B     DYNAD5                                              -EU-\nDYNAD4   NI    SWITCH,255-WTOFF                                    -EU-\nDYNAD5   OI    SWITCH,WTON                                         -EU-\n         L     R15,WTIME           TRY TO INCREMENT WAIT TIME      -EU-\n         A     R15,WTADJ                                           -EU-\n         ST    R15,WTIME                                           -EU-\nDYNAD6   NI    SWITCH,255-SWWAIT                                   -EU-\n         B     ANAL                                                -EU-\n         EJECT ,                                                   -EU-\n*        CHANGE TIME LIMIT - MODIFY COMMAND                        -EU-\n*        ----------------------------------                        -EU-\n*        (NEW TIME INTERVAL LIMIT EXPRESSED IN MINUTES)            -EU-\n         SPACE 1                                                   -EU-\nMODIFY   BCT   R15,ERR5            BR IF NOT OPERATOR MODIFY       -EU-\n         LH    R1,MTXTL            NEW TIME LIMIT SPECIFICATION    -EU-\n         LTR   R1,R1                                               -EU-\n         BNP   CTRLT               NO VALUE SPECIFIED              -EU-\n         CH    R1,PRMLG                                            -EU-\n         BH    CTRLT               INVALID, IGNORE IT              -EU-\n         MVC   VALUE,LOWV                                          -EU-\n         LA    R14,VALUE+L'VALUE                                   -EU-\n         SLR   R14,R1                                              -EU-\n         BCT   R1,*+L'*+6                                          -EU-\n         MVC   0(*-*,R14),MTXT     GET NEW VALUE                   -EU-\n         EX    R1,*-6                                              -EU-\n         CLC   VALUE,LOWV                                          -EU-\n         BL    CTRLT               INVALID, IGNORE IT              -EU-\n         CLC   VALUE,HIGHV                                         -EU-\n         BH    CTRLT               INVALID, IGNORE IT              -EU-\n         PACK  WORKD,VALUE                                         -EU-\n         CVB   R15,WORKD                                           -EU-\n         M     R14,=F'6000'                                        -EU-\n         ST    R15,MAXTIME         NEW TIME INTERVAL LIMIT         -EU-\n        TIME   BIN                                                 -EU-\n         AL    R0,MAXTIME                                          -EU-\n         ST    R0,TIME             NEW MAX IS TIME TO RUN          -EU-\n         MVC   EXPMS+18(L'EDMSK),EDMSK                             -EU-\n         ED    EXPMS+18(L'EDMSK),WORKD+L'WORKD-(L'EDMSK/2)         -EU-\n         LA    R1,MSGDEL                                           -EU-\n        DOM    MSGLIST=(1)         DELETE PREVIOUS MSG LIMIT       -EU-\nEXPMS   WTO    ' PSWSAMP -       MIN. NEW TIME INT. LIMIT SET.',   -EU-X\n               ROUTCDE=(2),DESC=(2)                                -EU-\n         ST    R1,MSGDEL                                           -EU-\n         OI    MSGDEL,EL                                           -EU-\n         B     CTNUE                                               -EU-\n         EJECT ,                                                   -EU-\n*        PROGRAM TERMINATION                                       -EU-\n*        -------------------                                       -EU-\n         SPACE 1                                                   -EU-\nGOBACK   BCT   R15,MODIFY          BR IF NOT OPERATOR STOP         -EU-\n         XC    MSGLA,MSGLA         MSG-ID'S LIST IS DELETED        -EU-\nGOHOME   BAS   R14,CHCK                                            -EU-\n         MVC   0(4,R8),=F'-1'      PSW SAMPLER INFO                -EU-\n         MVC   4(PSIL,R8),PSI                                      -EU-\n         MVC   4+PSIL(4,R8),WTIME                                  -EU-\n         MVC   8+PSIL(4,R8),COUNTER                                -EU-\n         BAS   R14,WRTE            LAST RECORD TO OUTPUT FILE      -EU-\n         BAS   R14,CHCK                                            -EU-\nCLOUTS  CLOSE  (OUTS)              CLOSE THE OUTPUT FILE           -EU-\nFREE     LM    R5,R6,MOVLONG+4                                     -EU-\n        FREEMAIN R,A=(R6),LV=(R5)  FREE WORK AREA                  -EU-\n        ZEROKEY ,                                                  -EU-\n        AXFRE  AXLIST=AXPL         FREE AX                         -EU-\n        RESETKEY ,                                                 -EU-\n         LH    R0,BLKSZ                                            -EU-\n         SLL   R0,1                                                -EU-\n         L     R1,BUFSTR                                           -EU-\n        FREEMAIN R,A=(1),LV=(0)    FREE BUFFER AREA                -EU-\nEXIT     OC    MSGDEL,MSGDEL                                       -EU-\n         BZ    NODEL                                               -EU-\n         LA    R1,MSGDEL                                           -EU-\n        DOM    MSGLIST=(1)         DELETE MSG LIMIT                -EU-\nNODEL    L     R1,MSGLA                                            -EU-\n         LTR   R1,R1                                               -EU-\n         BZ    LEAVE                                               -EU-\n        DOM    MSGLIST=(1)         DELETE INITIAL MSG-ID'S LIST    -EU-\n         LM    R0,R1,MSGLL                                         -EU-\n        FREEMAIN R,LV=(0),A=(1)    FREE AREA                       -EU-\n         EJECT ,                                                   -EU-\n*        EVERY THING DONE (QUIT)                                   -EU-\n*        -----------------------                                   -EU-\n         SPACE 1                                                   -EU-\nLEAVE   WTO    ' --- PSW SAMPLER ACTIVITY STOPPED ---',            -EU-X\n               ROUTCDE=(2,11),DESC=(4)                             -EU-\nRETURN   L     R15,=A(SNAPCL)                                      -EU-\n         BASR  R9,R15                                              -EU-\n         TM    SWPROC,SWTST        COMMAND HAS BEEN SENDED?        -EU-\n         BZ    QUIT                NO                              -EU-\n        $SSCMD STPCMD              STOP TRACE                      -EU-\n         LTR   R15,R15                                             -EU-\n         BZ    QUIT                                                -EU-\n         STC   R15,PRC+L'PRC+29                                    -EU-\n         SRL   R15,4                                               -EU-\n         STC   R15,PRC+L'PRC+28                                    -EU-\n         NC    PRC+L'PRC+28(3),MASK                                -EU-\n         TR    PRC+L'PRC+28(3),TRTAB                               -EU-\nPRC     WTO    ' PSWSAMP - SSCMD R.C. =     (TRACE ST,OFF).',      -EU-X\n               ROUTCDE=(2,11),DESC=(4)                             -EU-\nQUIT    $XRET  CC=(R10)                                            -EU-\n         EJECT ,                                                   -EU-\n*        ABNORMAL TERMINATION                                      -EU-\n*        --------------------                                      -EU-\n         SPACE 1                                                   -EU-\n        PRINT  NOGEN                                               -EU-\nERR0    $TSWXA 24,EXPAND=ONLY      BACK 24-BIT MODE                -EU-\n        WTO    ' PSWSAMP - TRACE SERVICES UNAVAILABLE.',           -EU-X\n               ROUTCDE=(2,11),DESC=(4)                             -EU-\nERR0X    LA    R10,4               C.C. = 4 ********************** -EU-\n         B     EXIT                                                -EU-\nERR1    $TSWXA 24,EXPAND=ONLY      BACK 24-BIT MODE                -EU-\n        WTO    ' PSWSAMP - NO TRACE TABLE.',                       -EU-X\n               ROUTCDE=(2,11),DESC=(4)                             -EU-\nERR1X    LA    R10,8               C.C. = 8 ********************** -EU-\n         B     EXIT                                                -EU-\nERR2    WTO    ' PSWSAMP - OPEN OUTPUT FAILED.',                   -EU-X\n               ROUTCDE=(2,11),DESC=(4)                             -EU-\n         LA    R10,12              C.C. = 12 ********************* -EU-\n         B     FREE                                                -EU-\nERR3    WTO    ' PSWSAMP - OP.COM. NOT ESTABLISHED.',              -EU-X\n               ROUTCDE=(2,11),DESC=(4)                             -EU-\n         LA    R10,16              C.C. = 16 ********************* -EU-\n         B     CLOUTS                                              -EU-\nERR4    WTO    ' PSWSAMP - OUTPUT I/O ERROR.',                     -EU-X\n               ROUTCDE=(2,11),DESC=(4)                             -EU-\n         LA    R10,20              C.C. = 20 ********************* -EU-\n         B     CLOUTS                                              -EU-\nERR5    WTO    ' PSWSAMP - OP.COM. FAILED.',                       -EU-X\n               ROUTCDE=(2,11),DESC=(4)                             -EU-\n         LA    R10,24              C.C. = 24 ********************* -EU-\n         B     GOHOME                                              -EU-\nERR6    $TSWXA 24,EXPAND=ONLY      BACK 24-BIT MODE                -EU-\n        WTO    ' PSWSAMP - NO TRACE OPTION BLOCK.',                -EU-X\n               ROUTCDE=(2,11),DESC=(4)                             -EU-\n         B     ERR1X                                               -EU-\nERR7    $TSWXA 24,EXPAND=ONLY      BACK 24-BIT MODE                -EU-\n        WTO    ' PSWSAMP - TRACE PENDING ACTION.',                 -EU-X\n               ROUTCDE=(2,11),DESC=(4)                             -EU-\n         B     ERR0X                                               -EU-\nERR8    $TSWXA 24,EXPAND=ONLY      BACK 24-BIT MODE                -EU-\n        WTO    ' PSWSAMP - TRACE MUST BE : AS=ON BR=OFF EX=ON.',   -EU-X\n               ROUTCDE=(2,11),DESC=(4)                             -EU-\n         B     ERR0X                                               -EU-\nERR9    WTO    ' PSWSAMP - UNABLE TO ACTIVATE THE TRACE.',         -EU-X\n               ROUTCDE=(2,11),DESC=(4)                             -EU-\n         B     ERR0X                                               -EU-\n        PRINT  GEN                                                 -EU-\n         EJECT\n*        I/O ROUTINES (R14 - LINK REGISTER)                        -EU-\n*        ------------                                              -EU-\n         SPACE 1                                                   -EU-\nWRTE     ST    R14,SVRET                                           -EU-\n        WRITE  OUTSD,SF,,(R3),,MF=E                                -EU-\n         OI    SWITCH,WAITIO       SET I/O STARTED                 -EU-\n         L     R14,SVRET                                           -EU-\n         BR    R14                 RETURN                          -EU-\n         SPACE 1                                                   -EU-\nCHCK     TM    SWITCH,WAITIO       PREVIOUS I/O ACTIVE ?           -EU-\n         BZR   R14                 NO, RETURN                      -EU-\n         ST    R14,SVRET                                           -EU-\n         NI    SWITCH,255-WAITIO                                   -EU-\n        CHECK  OUTSD                                               -EU-\n         TM    SWITCH,ERRIO        HOW COMPLETED ?                 -EU-\n         BO    ERR4                WITH ERROR                      -EU-\n         L     R14,SVRET                                           -EU-\n         BR    R14                 RETURN                          -EU-\n         EJECT ,                                                   -EU-\n*        SYNAD ROUTINE                                             -EU-\n*        -------------                                             -EU-\n         SPACE 1                                                   -EU-\n         USING *,R15                                               -EU-\nOUTERR   ST    R10,SVREG                                           -EU-\n         LR    R10,R15                                             -EU-\n         DROP  R15                                                 -EU-\n         USING OUTERR,R10                                          -EU-\n        SYNADAF ACSMETH=BSAM                                       -EU-\n         CLI   69(R1),C'*'         UNSIGNIFICANT MESSAGE ?         -EU-\n         BE    SYNAD4              YES                             -EU-\n         CLI   8(R1),C' '          BINARY INFORMATIONS ?           -EU-\n         BE    SYNAD2              NO                              -EU-\n         UNPK  56(7,R1),9(4,R1)                                    -EU-\n         NC    56(6,R1),MASK                                       -EU-\n         TR    56(6,R1),TRTAB                                      -EU-\n         MVI   62(R1),C','                                         -EU-\n         UNPK  63(5,R1),12(3,R1)                                   -EU-\n         NC    63(4,R1),MASK                                       -EU-\n         TR    63(4,R1),TRTAB                                      -EU-\n         MVI   67(R1),C','                                         -EU-\n         B     SYNAD3                                              -EU-\nSYNAD2   MVC   56(12,R1),8(R1)     MOVE BLANKS                     -EU-\nSYNAD3   LA    R1,52(R1)           SET PARM ADDRESS FOR WTO        -EU-\n         MVC   0(4,R1),LWTO                                        -EU-\n         MVC   76(4,R1),RWTO                                       -EU-\n        WTO    MF=(E,(1))                                          -EU-\nSYNAD4  SYNADRLS ,                                                 -EU-\n         OI    SWITCH,ERRIO        SET ERROR OCCURED               -EU-\n         L     R10,SVREG                                           -EU-\n         BR    R14                 RETURN                          -EU-\n         DROP  R10                                                 -EU-\n         EJECT\n*        CONSTANTS AND WORK-AREAS\n*        ------------------------\n         SPACE 1\nWORKD    DC    D'0'                                                -EU-\nMOVLONG  DC    4F'0'                                               -EU-\nTE       DC    F'0'                                                -EU-\nTS       DC    F'0'                                                -EU-\nTL       DC    F'0'                                                -EU-\nSVRET    DC    F'0'                                                -EU-\nSVREG    DC    F'0'                                                -EU-\nMSGDEL   DC    F'0'                                                -EU-\nMSGLL    DC    F'0'                LENGTH OF AREA AND              -EU-\nMSGLA    DC    F'0'                  MSG-ID'S LIST                 -EU-\nTIME     DC    F'0'\nPSI      DS    0F  - - - - - - - - PSW SAMPLER INFO                -EU-\n         DC    AL1(TMVSXA)           ...                           -EU-\nDAY      DC    XL3'0'                ...                           -EU-\nSID      DC    CL4' '                ...                           -EU-\nSTRTME   DC    F'0'                  ...                           -EU-\nENDTME   DC    F'0'                  ...                           -EU-\nMDMTME   DC    F'0'                  ...                           -EU-\nPSIL     EQU   *-PSI   - - - - - - - ---                           -EU-\nSCAN     DC    A(*-*,32,*-*)                                       -EU-\nLPALOW   DC    A(*-*)                                              -EU-\nLPAHI    DC    A(*-*)                                              -EU-\nLPALOWX  DC    A(*-*)                                              -EU-\nLPAHIX   DC    A(*-*)                                              -EU-\nLPAUP    DC    A(16*1024*1024)     16M LINE                        -EU-\nATIOT    DC    A(*-*)                                              -EU-\nATSO     DC    A(*-*)                                              -EU-\nBUFSTR   DC    A(*-*)                                              -EU-\nBUFSTRA  DC    A(*-*)                                              -EU-\nMAXTIME  DC    A(15*60*100)        IN 0.01 SEC.                    -EU-\nTOBIN    DC    256X'0'                                             -EU-\n         ORG   TOBIN+C'A'               POSITION TO 'A'            -EU-\n         DC    X'0A0B0C0D0E0F'          TRANSLATE A-F              -EU-\n         ORG   TOBIN+C'0'               POSITION TO '0'            -EU-\n         DC    X'00010203040506070809'  TRANSLATE TO 0-9           -EU-\n         ORG   ,                                                   -EU-\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(AUTH)           -EU-\nBLKSZ    DC    0H'0',AL2(NTTE*32)                                  -EU-\nPRMLG    DC    0H'0',AL2(L'VALUE)                                  -EU-\nLWTO     DC    AL2(76),XL2'8000'   WTO - TEXT LENGTH, MCS FLAGS    -EU-\nRWTO     DC    XL2'1000',XL2'4020' WTO - DESC=4, ROUTCDE=(2,11)    -EU-\nMTXTL    DC    0H'0',AL2(L'MTXT)   OPERATOR                        -EU-\nMTXT     DC    CL40' '               COMMUNICATION                 -EU-\nNTTESTT  DC    H'0'                                                -EU-\nAUTH     DC    XL1'0'                                              -EU-\nSWITCH   DC    XL1'0'                                              -EU-\nALTBUF   EQU   X'01'          SWITCH - I/O ALTERNATE BUFFER USE    -EU-\nWAITIO   EQU   X'02'          SWITCH - CHECK I/O MUST BE ISSUED    -EU-\nERRIO    EQU   X'04'          SWITCH - OUTPUT I/O ERROR OCCURED    -EU-\nSWWAIT   EQU   X'10'          SWITCH - WAITING SOME MORE           -EU-\nWTOFF    EQU   X'20'          SWITCH - NO WAIT OCCURS              -EU-\nWTON     EQU   X'40'          SWITCH - WAIT OCCURS                 -EU-\nOFFBYTES DC    X'02FB'             TRACE OFF                       -EU-\nVALUE    DC    C'0000'                                             -EU-\nLOWV     DC    C'0001'             1 MINUTE                        -EU-\nHIGHV    DC    C'1200'             20 HOURS                        -EU-\nTRTAB    DC    C'0123456789ABCDEF'                                 -EU-\nEDMSK    DC    X'402020202120'                                     -EU-\nMASK     DC    X'0F0F0F0F0F0F'                                     -EU-\nSWPROC   DC    XL1'0'                                              -EU-\nSWNEW    EQU   X'01'          SWPROC - NEW FORMAT AMBLIST (LISTLPA)-EU-\nSW16M    EQU   X'02'          SWPROC - PROCESS UP 16M LINE ALSO    -EU-\nSWTST    EQU   X'10'          SWPROC - TRACE ST COMMAND SENDED     -EU-\nNOTAUT   DC    C' PSWSAMP - NOT AUTHORIZED IN TSO.'                -EU-\nLPMNUM   DC    C'LINK PACK MAP - NUMERICALLY BY'                   -EU-\nLPMNEW   DC    C'PAGEABLE LINK PACK AREA MAP -  NUMERICALLY BY'    -EU-\n         SPACE 1                                                   -EU-\n         DC    AL1(L'STRCMD)                                       -EU-\nSTRCMD   DC    C'TRACE ST'                                         -EU-\n         DC    AL1(L'STPCMD)                                       -EU-\nSTPCMD   DC    C'TRACE ST,OFF'                                     -EU-\n         SPACE 1                                                   -EU-\nEUMS     DC    AL1(L'EUMSM)        OP.COMM. PARM. LIST - - - -> S  -EU-\nEUMSM    DC    C' --- PSW SAMPLER ACTIVITY STARTED ---'         E  -EU-\n         DC    AL1(L'EUMSS+L'EUMSP)                             T  -EU-\nEUMSS    DC    C' PSWSAMP - TO INTERRUPT USE COMMAND : P '      O  -EU-\nEUMSP    DC    CL8' '                                           P  -EU-\n         DC    AL1(0)              END OF PARM. LIST            C  -EU-\n         SPACE 1                                                   -EU-\n        CNOP   2,4                                                 -EU-\nOPTLIST  DC    H'0',H'0'                                           -EU-\nDDNMELST DC    AL2(DDNMELSL)                                       -EU-\n         DC    4XL8'0'                                             -EU-\n         DC    CL8'SYSDIN'                                         -EU-\n         DC    CL8'SYSDOU'                                         -EU-\n         DC    XL8'0'                                              -EU-\nDDNMELSL EQU   (*-DDNMELST)-L'DDNMELST                             -EU-\n         SPACE 1                                                   -EU-\nTRSIZE   DC    A(4*1024)                                           -EU-\nTRASID   DC    F'0'                                                -EU-\nSASID    DC    F'0'                                                -EU-\nCURTBVT  DC    F'0'                                                -EU-\nGADDR    DC    F'0'                                                -EU-\nAXPL     DC    H'1',H'0'           AX PARM LIST                    -EU-\nNEWTTE   DS    0XL32               NEW XA-TTE FORMAT               -EU-\n         DC    H'0',X'70',X'0'       ...                           -EU-\nNEWPSWA  DC    A(*-*)                ...                           -EU-\nNEWDATA  DC    6F'0' - - - - - - - - ---                           -EU-\nCOUNTER  DC    PL4'+0'             UNKNOWN EX TTE'S                -EU-\n         EJECT\n*        WAIT TIME MECCHANISM VALUES (MICSEC)                      -EU-\n*        ------------------------------------                      -EU-\n         SPACE 1                                                   -EU-\nHOWLONG  DC    D'0'                BIT 51 = 1 MICSEC.              -EU-\nWTIME    DC    A(24*100000)         2.4 SEC                        -EU-\nWTLOW    DC    A(10*100000)         1.0 SEC                        -EU-\nWTHIGH   DC    A(100*100000)       10.0 SEC                        -EU-\nWTADJ    DC    A(2*100000)          0.2 SEC                        -EU-\nWTCTR    DC    PL2'0'                                              -EU-\nWTMAX    DC    PL2'20'             STILL INTERVAL                  -EU-\n         SPACE 1                                                   -EU-\nPI       DS    0CL121              PRINT IMAGE FOR SYSLPA HERE     -EU-\nCC       DC    CL1' '              PRINTER CARRIAGE CONTROL CHAR.  -EU-\nS1       DC    CL60' '             SEGMENT ONE                     -EU-\nS2       DC    CL60' '             SEGMENT TWO                     -EU-\n         SPACE 2                                                   -EU-\n        LTORG  ,                                                   -EU-\n         SPACE 2\n         PRINT NOGEN                                               -EU-\nSYSLPA  DCB    DSORG=PS,MACRF=GM,EODAD=RLEND,DDNAME=SYSPRINT       -EU-\nOUTS    DCB    DSORG=PS,DEVD=DA,MACRF=W,RECFM=F,                   -EU-X\n               SYNAD=OUTERR,DDNAME=SYSPSW                          -EU-\n         SPACE 1                                                   -EU-\n         PRINT GEN                                                 -EU-\n        WRITE  OUTSD,SF,OUTS,,'S',MF=L                             -EU-\n         EJECT ,                                                   -EU\n*        TEST TRACE ON AND GET TABLE POINTER\n*        -----------------------------------\n         SPACE 1                                                   -EU-\n* XTTR ENTRY : TEST TRACE STATUS.                                  -EU-\n*              R9  = LINK REGISTER.                                -EU-\n*              R10 = LOCAL BASE REGISTER.                          -EU-\n*              R11 = PSWSAMP FIRST BASE REGISTER.                  -EU-\n*              R12 = PSWSAMP SECOND BASE REGISTER.                 -EU-\n*              R15 = ADDRESS OF XTTR ROUTINE AT ENTRY.             -EU-\n* XTTR EXIT  : R15 = RETURN CODE :                                 -EU-\n*                    0 = TRACE STATUS OK.                          -EU-\n*                    4 = TRACE INACTIVE BUT SOMETHING PENDING.     -EU-\n*                    8 = TRACE INACTIVE AND NOTHING PENDING.       -EU-\n         SPACE 1                                                   -EU-\n         CNOP  0,4                                                 -EU-\n         USING *,R10                                               -EU-\nXTTR     STM   R14,R12,12(R13)     ENTRY                           -EU-\n         LR    R10,R15             SET LOCAL BASE                  -EU-\n        $TSWXA 31,EXPAND=ONLY      ENTER 31-BIT MODE               -EU-\n         USING PSA,R0                                              -EU-\n         L     R2,PSATRVT          TRACE VECTOR TABLE POINTER      -EU-\n         DROP  R0                                                  -EU-\n         USING TRVT,R2                                             -EU-\n         CLC   TRVTID,=CL4'TRVT'   IDENTIFIER ?                    -EU-\n         BNE   ERR1                NO                              -EU-\n         L     R1,TRVTTOB          TRACE OPTION BLOCK ADDRESS      -EU-\n         DROP  R2                                                  -EU-\n         USING TOB,R1                                              -EU-\n         CLC   TOBID,=CL4'TOB '    IDENTIFIER ?                    -EU-\n         BNE   ERR6                NO                              -EU-\n         TM    TOBTRFG1,TOBSVACT   TRACE SERVICES AVAILABLE ?      -EU-\n         BZ    ERR0                NO                              -EU-\n         TM    TOBTRFG1,TOBSTACT   TRACE ACTIVE ?                  -EU-\n         BO    XTTR2               YES                             -EU-\n         CLC   TOBTRFG1(3),=AL1(TOBSVACT,0,0) SOMETHING PENDING ?  -EU-\n         BE    XTTR1               NO                              -EU-\n         LA    R15,4               YES, RC = 4                     -EU-\n         B     XTTR3               RETURN                          -EU-\nXTTR1    LA    R15,8               RC = 8                          -EU-\n         B     XTTR3               RETURN                          -EU-\nXTTR2    TM    TOBTRFG2,TOBPNDEA+TOBPNDOF    PENDING ACTION ?      -EU-\n         BNZ   ERR7                YES                             -EU-\n         TM    TOBTRFG3,TOBTAST    PENDING ACTION ?                -EU-\n         BNZ   ERR7                YES                             -EU-\n         TM    TOBTROPT,TOBTRBR    BR TRACE OPTION ?               -EU-\n         BO    ERR8                YES                             -EU-\n         TM    TOBTROB4,TOBTRASD+TOBTREXP    AS+EX TRACE OPTIONS ? -EU-\n         BNO   ERR8                NO                              -EU-\n         MVC   TRASID+2(2),TOBASID GET TRACE A.S. ID               -EU-\n         DROP  R1                                                  -EU-\n         XR    R15,R15             RC = 0                          -EU-\nXTTR3   $TSWXA 24,EXPAND=ONLY      BACK 24-BIT MODE                -EU-\n         L     R14,12(R13)         EXIT                            -EU-\n         LM    R0,R12,20(R13)                                      -EU-\n         B     0(R9,R15)           RETURN                          -EU-\n         DROP  R10                                                 -EU-\n         SPACE 2                                                   -EU-\n        LTORG  ,                                                   -EU-\n         EJECT ,                                                   -EU-\n*        MVS/XA TTE'S ANALYSIS                                     -EU-\n*        ---------------------                                     -EU-\n         SPACE 1                                                   -EU-\n* XATT ENTRY : TRACE BUFFER SCANNING.                              -EU-\n*              R5  = CURRENT TTE POINTER.                          -EU-\n*              R7  = END OF TRACE BUFFER POINTER.                  -EU-\n*              R9  = LINK REGISTER.                                -EU-\n*              R10 = LOCAL BASE REGISTER.                          -EU-\n*              R11 = PSWSAMP FIRST BASE REGISTER.                  -EU-\n*              R12 = PSWSAMP SECOND BASE REGISTER.                 -EU-\n*              R15 = ADDRESS OF XATT ROUTINE AT ENTRY.             -EU-\n* AT EXIT :    R1  = FAULT ADDRESS FOR CONTROL OR ZERO (END).      -EU-\n*              R6  = TTE LENGTH.                                   -EU-\n*       NOTE - THE CURRENT TTE ENTRY, IF ACCEPTED, HAS BEEN        -EU-\n*              BUILDED TO LOOK LIKE AN MVS/370 TTE (LENGTH=32)     -EU-\n*              AND PLACED IN FIELD NAMED 'NEWTTE'.                 -EU-\n         SPACE 1                                                   -EU-\n         CNOP  0,4                                                 -EU-\n         USING *,R10                                               -EU-\nXATT     STM   R14,R12,12(R13)     ENTRY                           -EU-\n         LR    R10,R15             SET LOCAL BASE                  -EU-\n         XC    NEWDATA(6*4),NEWDATA                                -EU-\n         USING TTE,R5                                              -EU-\n         CLI   TTEPCTYP,TTETPC     PC TTE ?                        -EU-\n         BE    XAPCPT              YES                             -EU-\n         CLI   TTEPTTYP,TTETPT     PT TTE ?                        -EU-\n         BE    XAPCPT              YES                             -EU-\n         CLI   TTESSTYP,TTETSSAR   SSAR TTE ?                      -EU-\n         BE    XASSAR              YES                             -EU-\n         XR    R6,R6                                               -EU-\n         IC    R6,TTETYPE          GET TTE TYPE                    -EU-\n         LR    R2,R6                                               -EU-\n         N     R6,=A(TTEMEX)                                       -EU-\n         CL    R6,=A(TTETEX)       EXPLICIT TTE ?                  -EU-\n         BE    XAEX                YES                             -EU-\n         L     R6,=F'4096'         SET R6 TO FORCE END             -EU-\n         B     XARESET                                             -EU-\nXAPCPT   MVC   NEWDATA(8),TTEPC OR TTEPT                           -EU-\n         LA    R6,L'TTEPC OR L' TTEPT                              -EU-\n         MVC   NEWPSWA,TTEPCADR OR TTEPTADR                        -EU-\n         TM    NEWPSWA,TTEPCAMD OR TTEPTAMD                        -EU-\n         BO    *+L'*+8                                             -EU-\n         MVI   NEWPSWA,0                                           -EU-\n         B     *+L'*+4                                             -EU-\n         NI    NEWPSWA,255-TTEPCAMD OR TTEPTAMD                    -EU-\n         B     XALOAD                                              -EU-\nXASSAR   LA    R6,L'TTESSAR        BYPASS IT                       -EU-\n         B     XARESET                                             -EU-\nXAEX     N     R2,=A(TTEREGS)                                      -EU-\n         LA    R2,1(,R2)                                           -EU-\n         SLL   R2,2                                                -EU-\n         LA    R6,L'TTEXP(R2)                                      -EU-\n         MVC   NEWDATA(L'TTEXP),TTEXP                              -EU-\n         LM    R1,R3,XAEXSCN                                       -EU-\n         CLC   0(L'TTEXPTYP,R1),TTEXPTYP                           -EU-\n         BE    2(R1)                                               -EU-\n         BXLE  R1,R2,*-10                                          -EU-\n         AP    COUNTER,=PL1'+1'    UNKNOWN EX TTE                  -EU-\nXARESET  XR    R1,R1                                               -EU-\n         B     XAEXIT                                              -EU-\nXAXEXT   MVC   NEWDATA+L'TTEXP(L'TTE003PW),TTE003PW                -EU-\n         MVC   NEWPSWA,TTE003P2                                    -EU-\n         B     XAXX                                                -EU-\nXAXSVC   MVC   NEWDATA+L'TTEXP(L'TTE005PW),TTE005PW                -EU-\n         MVC   NEWPSWA,TTE005P2                                    -EU-\n         B     XAXX                                                -EU-\nXAXPGM   MVC   NEWDATA+L'TTEXP(L'TTE007PW),TTE007PW                -EU-\n         MVC   NEWPSWA,TTE007P2                                    -EU-\n         B     XAXX                                                -EU-\nXAXSPER  MVC   NEWDATA+L'TTEXP(L'TTE009PW),TTE009PW                -EU-\n         MVC   NEWPSWA,TTE009P2                                    -EU-\n         B     XAXX                                                -EU-\nXAXIO    MVC   NEWDATA+L'TTEXP(L'TTE00BPW),TTE00BPW                -EU-\n         MVC   NEWPSWA,TTE00BP2                                    -EU-\n         B     XAXX                                                -EU-\nXAXDSP   MVC   NEWDATA+L'TTEXP(L'TTE00FPW),TTE00FPW                -EU-\n         MVC   NEWPSWA,TTE00FP2                                    -EU-\n         B     XAXX                                                -EU-\nXAXMCH   MVC   NEWDATA+L'TTEXP(L'TTE013PW),TTE013PW                -EU-\n         MVC   NEWPSWA,TTE013P2                                    -EU-\n         B     XAXX                                                -EU-\nXAXRST   MVC   NEWDATA+L'TTEXP(L'TTE015PW),TTE015PW                -EU-\n         MVC   NEWPSWA,TTE015P2                                    -EU-\n         B     XAXX                                                -EU-\nXAXSUSP  MVC   NEWDATA+L'TTEXP(L'TTE019RT),TTE019RT                -EU-\n         MVC   NEWDATA+L'TTEXP+L'TTE019RT(L'TTE019SI),TTE019SI     -EU-\n         MVC   NEWPSWA,TTE019RT                                    -EU-\n         B     XAXX                                                -EU-\nXAXUSR0  MVC   NEWDATA+L'TTEXP(L'TTE07FAD),TTE07FAD                -EU-\n         MVC   NEWDATA+L'TTEXP+L'TTE07FAD(L'TTE07FCI),TTE07FCI     -EU-\n         MVC   NEWPSWA,TTE07FAD                                    -EU-\n         B     XAXX                                                -EU-\nXAXEMS   MVC   NEWDATA+L'TTEXP(L'TTE103PW),TTE103PW                -EU-\n         MVC   NEWPSWA,TTE103P2                                    -EU-\n         B     XAXX                                                -EU-\nXAXSVCR  MVC   NEWDATA+L'TTEXP(L'TTE105PW),TTE105PW                -EU-\n         MVC   NEWPSWA,TTE105P2                                    -EU-\n         B     XAXX                                                -EU-\nXAXSRB   MVC   NEWDATA+L'TTEXP(L'TTE10FPW),TTE10FPW                -EU-\n         MVC   NEWPSWA,TTE10FP2                                    -EU-\n         B     XAXX                                                -EU-\nXAXSS    MVC   NEWDATA+L'TTEXP(L'TTE203PW),TTE203PW                -EU-\n         MVC   NEWPSWA,TTE203P2                                    -EU-\n         B     XAXX                                                -EU-\nXAXSSRB  MVC   NEWDATA+L'TTEXP(L'TTE20FPW),TTE20FPW                -EU-\n         MVC   NEWPSWA,TTE20FP2                                    -EU-\n         B     XAXX                                                -EU-\nXAXCALL  MVC   NEWDATA+L'TTEXP(L'TTE303PW),TTE303PW                -EU-\n         MVC   NEWPSWA,TTE303P2                                    -EU-\n         B     XAXX                                                -EU-\nXAXCLKC  MVC   NEWDATA+L'TTEXP(L'TTE403PW),TTE403PW                -EU-\n         MVC   NEWPSWA,TTE403P2                                    -EU-\n         B     XAXX                                                -EU-\nXAXSVCE  MVC   NEWDATA+L'TTEXP(L'TTEF05PW),TTEF05PW                -EU-\n         MVC   NEWPSWA,TTEF05P2                                    -EU-\nXAXX     TM    NEWPSWA,X'80'                                       -EU-\n         BO    *+L'*+8                                             -EU-\n         MVI   NEWPSWA,0                                           -EU-\n         B     *+L'*+4                                             -EU-\n         NI    NEWPSWA,X'7F'                                       -EU-\nXALOAD   L     R1,NEWPSWA                                          -EU-\nXAEXIT   ST    R1,20+R1*4(R13)     SET R1                          -EU-\n         ST    R6,20+R6*4(R13)     SET R6                          -EU-\n         LM    R14,R12,12(R13)     EXIT                            -EU-\n         BR    R9                  RETURN                          -EU-\n         DROP  R5,R10                                              -EU-\n         SPACE 1                                                   -EU-\nXAEXSCN  DC    A(XAEXTAB,L'XAEXTAB,XAEXEND)                        -EU-\n         SPACE 1                                                   -EU-\nXAEXTAB  DS    0XL6                EX TTE ID TABLE                 -EU-\n         DC    AL2(TTETSSCH)       001 - SKIP                      -EU-\n         B     XARESET                                             -EU-\n         DC    AL2(TTETEXT)        003                             -EU-\n         B     XAXEXT                                              -EU-\n         DC    AL2(TTETSVC)        005                             -EU-\n         B     XAXSVC                                              -EU-\n         DC    AL2(TTETPGM)        007                             -EU-\n         B     XAXPGM                                              -EU-\n         DC    AL2(TTETSPER)       009                             -EU-\n         B     XAXSPER                                             -EU-\n         DC    AL2(TTETIO)         00B                             -EU-\n         B     XAXIO                                               -EU-\n         DC    AL2(TTETDSP)        00F                             -EU-\n         B     XAXDSP                                              -EU-\n         DC    AL2(TTETMCH)        013                             -EU-\n         B     XAXMCH                                              -EU-\n         DC    AL2(TTETRST)        015                             -EU-\n         B     XAXRST                                              -EU-\n         DC    AL2(TTETACR)        017 - SKIP                      -EU-\n         B     XARESET                                             -EU-\n         DC    AL2(TTETSUSP)       019                             -EU-\n         B     XAXSUSP                                             -EU-\n         DC    AL2(TTETALTR)       01B - SKIP                      -EU-\n         B     XARESET                                             -EU-\n         DC    AL2(TTETUSR0)       07F                             -EU-\n         B     XAXUSR0                                             -EU-\n         DC    AL2(TTETMSCH)       101 - SKIP                      -EU-\n         B     XARESET                                             -EU-\n         DC    AL2(TTETEMS)        103                             -EU-\n         B     XAXEMS                                              -EU-\n         DC    AL2(TTETSVCR)       105                             -EU-\n         B     XAXSVCR                                             -EU-\n         DC    AL2(TTETSRB)        10F                             -EU-\n         B     XAXSRB                                              -EU-\n         DC    AL2(TTETHSCH)       201 - SKIP                      -EU-\n         B     XARESET                                             -EU-\n         DC    AL2(TTETSS)         203                             -EU-\n         B     XAXSS                                               -EU-\n         DC    AL2(TTETSSRB)       20F                             -EU-\n         B     XAXSSRB                                             -EU-\n         DC    AL2(TTETCSCH)       301 - SKIP                      -EU-\n         B     XARESET                                             -EU-\n         DC    AL2(TTETCALL)       303                             -EU-\n         B     XAXCALL                                             -EU-\n         DC    AL2(TTETRSCH)       401 - SKIP                      -EU-\n         B     XARESET                                             -EU-\n         DC    AL2(TTETCLKC)       403                             -EU-\n         B     XAXCLKC                                             -EU-\n         DC    AL2(TTETSVCE)       F05                             -EU-\n         B     XAXSVCE                                             -EU-\n         DC    AL2(TTETWAIT)       F0F - SKIP                      -EU-\n         B     XARESET                                             -EU-\nXAEXEND  EQU   *-L'XAEXTAB         END OF TABLE                    -EU-\n         SPACE 1                                                   -EU-\n         SPACE 1                                                   -EU-\n        LTORG  ,                                                   -EU-\n         EJECT ,                                                   -EU-\n*        SNAP DUMP PROCESS                                         -EU-\n*        -----------------                                         -EU-\n         SPACE 1                                                   -EU-\n* SNAP ENTRY : TO TAKE A SNAP DUMP.                                -EU-\n*              R0  = SNAP ID NUMBER (0-255).                       -EU-\n*              R9  = LINK REGISTER.                                -EU-\n*              R10 = LOCAL BASE REGISTER.                          -EU-\n*              R11 = PSWSAMP FIRST BASE REGISTER.                  -EU-\n*              R12 = PSWSAMP SECOND BASE REGISTER.                 -EU-\n*              R15 = ADDRESS OF SNAP ROUTINE AT ENTRY.             -EU-\n*              NOTE - THE FOLLOWING ALLOCATION IS NEEDED TO        -EU-\n*                     OBTAIN THE SNAP DUMPS :                      -EU-\n*                        ALLOC F(SYSSNAP) SYSOUT(A)                -EU-\n*                     OR :                                         -EU-\n*                        ALLOC F(SYSSNAP) DA(...) OLD              -EU-\n         SPACE 1                                                   -EU-\n         CNOP  0,4                                                 -EU-\n         USING *,R15                                               -EU-\nSNAP     TM    SNAPSW,SNAPFNA      FUNCTION INACTIVE ?             -EU-\n         BOR   R9                  YES, BYPASS                     -EU-\n         STM   R14,R12,12(R13)     ENTRY                           -EU-\n         LR    R10,R15             SET LOCAL BASE                  -EU-\n         DROP  R15                                                 -EU-\n         USING SNAP,R10                                            -EU-\n         LR    R1,R13                                              -EU-\n         LA    R13,SNAPSV                                          -EU-\n         ST    R1,4(R13)                                           -EU-\n         ST    R13,8(R1)                                           -EU-\n         LR    R4,R0               SAVE SNAP ID NUMBER             -EU-\n         LA    R2,SNAPDCB                                          -EU-\n         USING IHADCB,R2                                           -EU-\n         TM    SNAPSW,SNAPOPN      DATA-SET ALREADY OPENED ?       -EU-\n         BO    SNO                 YES                             -EU-\n         L     R3,ATIOT                                            -EU-\n         USING TIODSECT,R3                                         -EU-\n         XR    R1,R1                                               -EU-\nSNS      CLC   TIOELNGH(4),=F'0'                                   -EU-\n         BE    SNN                                                 -EU-\n         CLC   TIOEDDNM(L'TIOEDDNM),DCBDDNAM                       -EU-\n         BE    SNF                                                 -EU-\n         IC    R1,TIOELNGH                                         -EU-\n         ALR   R3,R1                                               -EU-\n         B     SNS                                                 -EU-\n         DROP  R3                                                  -EU-\nSNF     OPEN   (SNAPDCB,OUTPUT)                                    -EU-\n         TM    DCBOFLGS,DCBOFOPN   SUCCESSFULLY OPENED ?           -EU-\n         BZ    SNN                 NO                              -EU-\n         DROP  R2                                                  -EU-\n         OI    SNAPSW,SNAPOPN      INDICATE DATA-SET OPENED        -EU-\nSNO      CH    R4,SNAPMAX          KNOWN ID NUMBER ?               -EU-\n         BNL   SNE                 NO, BYPASS                      -EU-\n         LR    R5,R4                                               -EU-\n         MH    R5,SNAPTLE                                          -EU-\n         LA    R5,SNAPTB(R5)                                       -EU-\n         LA    R6,8(R5)                                            -EU-\n         TM    0(R6),X'80'         UNUSED ELEMENT ?                -EU-\n         BZ    SNE                 YES, BYPASS                     -EU-\n        SNAP   TCB='S',ID=(R4),LIST=(R5),STRHDR=(R6),              -EU-1\n               MF=(E,SNAPLIST)                                     -EU-\n         LTR   R15,R15             ALL OK ?                        -EU-\n         BZ    SNE                 YES                             -EU-\nSNN      OI    SNAPSW,SNAPFNA      INACTIVE FUNCTION               -EU-\nSNE      L     R13,4(R13)          EXIT                            -EU-\n         LM    R14,R12,12(R13)                                     -EU-\n         BR    R9                                                  -EU-\n         DROP  R10                                                 -EU-\n         SPACE 1                                                   -EU-\n* SNAPCL ENTRY : TO CLOSE THE SNAP FILE IF OPENED.                 -EU-\n*              R9  = LINK REGISTER.                                -EU-\n*              R10 = LOCAL BASE REGISTER.                          -EU-\n*              R11 = PSWSAMP FIRST BASE REGISTER.                  -EU-\n*              R12 = PSWSAMP SECOND BASE REGISTER.                 -EU-\n*              R10 = ADDRESS OF SNAPCL ROUTINE AT ENTRY.           -EU-\n         SPACE 1                                                   -EU-\n         CNOP  0,4                                                 -EU-\n         USING *,R15                                               -EU-\nSNAPCL   TM    SNAPSW,SNAPOPN      DATA-SET IS OPENED ?            -EU-\n         BZR   R9                  NO                              -EU-\n         STM   R14,R12,12(R13)     ENTRY                           -EU-\n         LR    R10,R15             SET LOCAL BASE                  -EU-\n         DROP  R15                                                 -EU-\n         USING SNAPCL,R10                                          -EU-\n         LR    R1,R13                                              -EU-\n         LA    R13,SNAPSV                                          -EU-\n         ST    R1,4(R13)                                           -EU-\n         ST    R13,8(R1)                                           -EU-\n        CLOSE  (SNAPDCB)                                           -EU-\n         L     R13,4(R13)          EXIT                            -EU-\n         LM    R14,R12,12(R13)                                     -EU-\n         BR    R9                                                  -EU-\n         DROP  R10                                                 -EU-\n         SPACE 1                                                   -EU-\n         PRINT NOGEN                                               -EU-\nSNAPDCB  DCB   DSORG=PS,RECFM=VBA,MACRF=(W),                       -EU-1\n               BLKSIZE=1632,LRECL=125,DDNAME=SYSSNAP               -EU-\nSNAPLIST SNAP  DCB=SNAPDCB,MF=L                                    -EU-\n         PRINT GEN                                                 -EU-\n         SPACE 1                                                   -EU-\nSNAPSV   DC    18F'0'                                              -EU-\n         SPACE 1                                                   -EU-\nSNAPTB   DC    3F'0'               0 = NOT USED                    -EU-\nSNAPTBL  EQU   *-SNAPTB            ELEMENT LENGTH                  -EU-\nSNAP1    DC    A(*-*),XL1'80',AL3(*-*),XL1'80',AL3(SHD1)           -EU-\nSNAPTBM  EQU   (*-SNAPTB)/SNAPTBL  NUMBER OF ELEMENTS              -EU-\n         SPACE 1                                                   -EU-\nSNAPTLE  DC    Y(SNAPTBL)          ELEMENT LENGTH                  -EU-\nSNAPMAX  DC    Y(SNAPTBM)          NUMBER OF ELEMENTS (MAX ID)     -EU-\nSNAPSW   DC    XL1'0'                                              -EU-\nSNAPFNA  EQU   X'01'               SNAP FUNCTION NOT ACTIVE.       -EU-\nSNAPOPN  EQU   X'02'               SNAP DATA-SET IS OPENED.        -EU-\nSHD1     DC    AL1(L'SHD1T)                                        -EU-\nSHD1T    DC    C'P S W S A M P - DUMP OF TRACE BUFFER.'            -EU-\n         SPACE 1                                                   -EU-\n        LTORG  ,                                                   -EU-\n         EJECT ,                                                   -EU-\nLPAE     DSECT             -- LPA LIST PRINT SEGMENT               -EU-\nLN       DS    CL8            MODULE NAME                          -EU-\n         DS    C                                                   -EU-\nLX       DS    0CL17          TRANSLATE NEXT 17 BYTES              -EU-\nLS       DS    CL6                 START ADDRESS                   -EU-\n         DS    CL4                                                 -EU-\nLL       DS    CL6                 LENGTH                          -EU-\n         DS    CL2                 ... ETC ...                     -EU-\n         ORG   LX                                                  -EU-\nLXN      DS    0CL19          TRANSLATE NEXT 19 BYTES              -EU-\nLSN      DS    CL8                 START ADDRESS                   -EU-\n         DS    CL2                                                 -EU-\nLLN      DS    CL8                 LENGTH                          -EU-\n         DS    CL2                 ... ETC ...                     -EU-\n         SPACE 2                                                   -EU-\nTRACEHDR DSECT             -- TRACE TABLE HEADER\nNEXT     DS    F              NEXT ENTRY ADDRESS\nFIRST    DS    F              FIRST ENTRY ADDRESS\nLAST     DS    F              LAST ENTRY ADDRESS\nSPLENGTH DS    F              SUBPOOL & LENGTH OF TABLE\n         EJECT ,                                                   -EU-\n*       IHATOB - A DSECT SHOULD BE SUBSTITUTED WHEN AVAILABLE.     -EU-\n         SPACE 1                                                   -EU-\nTOB      DSECT                SYSTEM TRACE OPTION BLOCK            -EU-\nTOBID    DS    CL4,CL17       TOB EBCDIC IDENTIFIER                -EU-\nTOBTRFG1 DS    XL1            TRACE STATUS FLAGS                   -EU-\nTOBSVACT EQU   X'80'          TRACE SERVICES AVAILABLE             -EU-\nTOBSTACT EQU   X'40'          TRACE ACTIVE                         -EU-\nTOBTRFG2 DS    XL1            TRACE PENDING FLAGS                  -EU-\nTOBPNDEA EQU   X'80'          TRACE ENV. ALTERATION PENDING        -EU-\nTOBPNDOF EQU   X'40'          TRACE OFF PENDING                    -EU-\nTOBTRFG3 DS    XL1            MISCELLANEOUS TRACE FLAGS            -EU-\nTOBTAST  EQU   X'80'          TRACE A.S. TERMINATION IN PROGRESS   -EU-\nTOBTROPT DS    0XL4,XL3       TRACE OPTIONS REQ. IN CR12 FORMAT    -EU-\nTOBTRBR  EQU   X'80'          BRANCH TRACE OPTION                  -EU-\nTOBTROB4 DS    XL1,XL4        LAST BYTE OF TRACE OPTIONS REQ.      -EU-\nTOBTRASD EQU   X'02'          ASID TRACE OPTION                    -EU-\nTOBTREXP EQU   X'01'          EXPLICIT TRACE OPTION                -EU-\nTOBASCB  DS    A,XL2          TRACE A.S. ASCB ADDRESS              -EU-\nTOBASID  DS    H              TRACE A.S. ASID                      -EU-\n         SPACE 2                                                   -EU-\n*       IHATBVT - A DSECT SHOULD BE SUBSTITUTED WHEN AVAILABLE.    -EU-\n         SPACE 1                                                   -EU-\nTBVT     DSECT                SYSTEM TRACE BUFFER VECTOR TABLE     -EU-\nTBVTID   DS    CL4,XL12       TBVT EBCDIC IDENTIFIER               -EU-\nTBVTFWRD DS    0D             TBVT FORWARD QUEUE POINTERS          -EU-\nTBVTNXTR DS    A              REAL ADDRESS OF NEXT TBVT            -EU-\nTBVTNXTV DS    A              VIRTUAL ADDRESS OF NEXT TBVT         -EU-\nTBVTBWRD DS    A              VIRTUAL ADDRESS OF PREVIOUS TBVT     -EU-\nTBVTBUFV DS    A              VIRTUAL ADDRESS OF 4K BUFFER         -EU-\n         SPACE 2                                                   -EU-\n         PRINT NOGEN                                               -EU-\n        CVT    DSECT=YES,LIST=YES                                  -EU-\n        IHAPSA ,                                                   -EU-\n        IHATRVT ,                                                  -EU-\n        IHATTE AS=YES,EX=YES                                       -EU-\n        IEESMCA ,                                                  -EU-\nTIODSECT DSECT ,                                                   -EU-\n        IEFTIOT1 ,                                                 -EU-\n        DCBD   DSORG=PS,DEVD=DA                                    -EU-\n         SPACE 2                                                   -EU-\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PSWSAMP$": {"ttr": 28678, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x8f\\x00\\x942\\x8f\\x10D\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-24T00:00:00", "modifydate": "1994-11-24T10:44:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": "//PSWSAMP  JOB (........),'INSTALL - PSWSAMP -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=2\n/*JOBPARM L=6\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL   OPCOM     SSCMD                          *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ4AS3,MBR=PSWSAMP\n//LNK     EXEC PAJILKL\n//SYSIN     DD *\n  INCLUDE SYSADD(SETOPC,SSCMD)\n  ENTRY   PSWSAMP\n  SETCODE AC(1)\n  NAME    PSWSAMP(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PUSE": {"ttr": 28680, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x01\\x7f\\x00\\x90\\x01\\x7f\\x16(\\x02\\x1d\\x02\\x1d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-17T00:00:00", "modifydate": "1990-01-17T16:28:00", "lines": 541, "newlines": 541, "modlines": 0, "user": "SYSPAJA"}, "text": "PUSE     TITLE '* * * PAGEING UTILIZATION PROGRAM * * *'\nPUSE     START 0\n         SPACE 1\n*        DATA-SET CBT767 AT LEVEL 001 AS OF 07/09/81\n*\n* PURPOSE :    THIS PROGRAM IS FOR USE ON TSO AND USES FULLSCREEN\n*              SUPPORT. IT HAS BEEN TESTED OK UNDER TCAM AND VTAM.\n*              IT IS DEPENDENT ON RUNNING ON 3270'S ONLY.\n*              THE PROGRAM PRODUCES A PICTURE OF THE SLOTS USED ON\n*              EACH PAGE DATA-SET, ITS NAME, DEVICE AND VOLUME,\n*              ALSO PRODUCED ARE THE SWAP DATA-SETS AND NUMBER OF\n*              SWAP SETS ALLOCATED. A NEW PICTURE IS PRODUCED EACH\n*              TIME THE ENTER KEY IS USED. THE PROGRAM CAN BE ENDED\n*              BY ENTERING 'Z'.\n         SPACE 1\n* REMARK : COMMAND IS NOW RE-ENTERABLE.                            -EU-\n         SPACE 2\nPUSE    AMODE  24\nPUSE    RMODE  24\n         SPACE 2\nNTK      EQU   100                 NUMBER OF PAGE DATA-SETS\n*                                       LINES IN TANK\nTNKMX    EQU   (PSLINL*(NTK-1))    TANK LINES SPACE\nTNKL     EQU   (((PSLINL*NTK)+7)/8)*8   TANK SPACE\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        AUTHORITY LEVELS DEFINITIONS.                          *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nLV0      EQU   0         REJECT LEVEL.\n         SPACE 1\n        $MDL@IX\n         SPACE 2\n        $DEFREG\n         EJECT\n        $XENT  BASE=(R11,R12),LV=WRKL,TYPE=RENT\n         LA    R6,LSVA(R13)\n         LA    R7,WRKML\n         LA    R8,WRKAR+LSVA\n         LR    R9,R7\n         MVCL  R6,R8\n         LR    R10,R13\n         USING WRKAR,R10\n         LA    R1,AUTH\n         ST    R1,REQAUT+4\n         SPACE 1\n*        CONTROL WHO CALL ME.\n         SPACE 1\n        EXTRACT ANSWER,'S',FIELDS=(TSO),MF=(E,EXTR)\n         L     R4,ANSWER           GET ADDRESSES\n         TM    0(R4),X'80'         ARE WE IN TSO?\n         BO    TPTSO               YES\n        WTO    'ONLY \"TSO\" ALLOWED.',ROUTCDE=11,DESC=7\n         LA    R15,16              SET R.C.\n         B     PEXIT\nTPTSO   $EACM  REQAUT\n         CLI   AUTH,LV0            AUTHORIZED?\n         BNE   CHECK               YES\n        TPUT   MUAUT,L'MUAUT       NO, NOT AUTHORIZED\n         LA    R15,12              SET R.C.\n         B     PEXIT\nNOTSCR  TPUT   MNSCR,L'MNSCR       NOT A SCREEN TERMINAL\n         B     SETRC\nNOTSTD  TPUT   MNSTD,L'MNSTD       NOT STANDARD 24 * 80\nSETRC    LA    R15,8               SET R.C.\n         B     PEXIT\nCHECK   GTSIZE ,                   CHECK CALLER TERMINAL\n         LTR   R0,R0               IS IT A SCREEN?\n         BZ    NOTSCR              NO\n         CH    R0,=H'24'           STANDARD NUMBER OF LINES?\n         BNE   NOTSTD              NO\n         CH    R1,=H'80'           STANDARD LINE LENGTH?\n         BNE   NOTSTD              NO\n        STFSMODE INITIAL=YES\n        GETMAIN R,LV=TNKL,SP=1\n         ST    R1,ATNK\n         LR    R0,R1\n         SL    R0,STNK+4\n         ST    R0,STNK\n         AL    R1,STNK+8\n         ST    R1,STNK+8\n         SPACE 2\nBEGIN   TIME   DEC\n         IC    R0,=X'C0'           PACK SIGN\n         SRL   R0,4                DROP LEADING ZERO\n         ST    R0,SYSTIM           GET SYSTEM TIME\n         MVC   PRTIME,=X'402120204B20204B2020'    MOVE TIME MASK IN\n         ED    PRTIME,SYSTIM       TIME TO PRINT\n         MVI   PRTIME,C':'\n        $TSWXA 31,EXPAND=ONLY\n         USING PSA,R0\n         L     R2,PSAPCCAV         ADDRESS OF CPU-ID\n         DROP  R0\n         USING PCCA,R2\n         MVC   CPUID1(2),PCCACPID\n         MVC   CPUID2(6),PCCACPID+2\n         MVC   CPUID3(4),PCCACPID+8\n         DROP  R2\n         L     R2,CVTPTR           POINT TO CVT\n         USING CVT,R2\n         L     R3,CVTSMCA          GET SMF CONTROL AREA ADDRESS\n         USING SMCABASE,R3\n         MVC   SYS,SMCASID         SYSTEM ID (SID)\n         DROP  R3\n         L     R3,CVTASVT          GET ASVT POINTER\n         ST    R3,ASVTAD           AND SAVE IT\n         L     R2,CVTASMVT         POINT TO ASMVT FROM CVT-OFFSET\n         DROP  R2\n         USING ASMVT,R2\n         L     R5,ASMPART          GET PART ADDR\n         L     R4,ASMSART          GET SART ADDR\n         LA    R3,ASMSLOTS         GET TOTAL ADDR\n         L     R14,0(R3)           SAVE OVERALL TOTAL\n         SPACE 1\n*        GET TOTALS OF SLOT COUNTS FOR HEADING.\n         SPACE 1\n         LA    R15,3               BCT COUNT REG\n         LA    R1,T1               POINT TO TOTALS IN HEADING\n         B     CNVTOT1\nCNVTOT   S     R14,0(R3)\nCNVTOT1  L     R0,0(R3)            TOTAL TO REG\n         CVD   R0,DWD              TOT TO DECIMAL\n         MVC   0(6,R1),MASK        MASK TO PRINT\n         ED    0(6,R1),DWD+5       TOTAL TO PRINT\n         LA    R3,4(R3)            NEXT TOTAL ADDR\n         LA    R1,TTL(R1)          NEXT HEADING POSITION\n         BCT   R15,CNVTOT          AND PROCESS\n         LR    R0,R14              GET UNUSED RESERVED SLOTS\n         LA    R1,UNUSED\n         BAS   R8,CNVT\n         SPACE 1\n*        PART INFO PROCESS.\n         SPACE 1\n         L     R9,STNK             GET POINTER TO LINES TANK\n         USING PART,R5\n         L     R3,PARTDSNL         ADDR OF DSN LIST\n         L     R7,PARTSIZE         TOTAL NBR PARTES\n         LA    R6,PARTENTS         ADDR OF PARTES\n         B     TSTPRT\nNXTLOT   LA    R6,L'PARTENT(R6)    NEXT PARTE\nNXTDSN   LA    R3,44(R3)           NEXT DSN\n         USING PARTENT,R6\nTSTPRT   TM    PARETYPE,PAREDPLX   DUPLEX PARTE?\n         BO    UPNXT               YES, GET NEXT PARTE & DSN\n         CLI   0(R3),C' '          BLANK DSN\n         BE    UPNXT               YES GET NEXT DSN\n         MVC   DSN(L'DSN),0(R3)    DSN TO PRINT\n         TM    PARETYPE,PAREPLPA   GET PAGE TYPE. PLPA DS?\n         BZ    COMDS               NO\n         MVI   TYP,C'P'            MOVE IN DS TYPE\n         B     GSA\nCOMDS    TM    PARETYPE,PARECOMM   COMMON DS?\n         BZ    LOCLDS              NO\n         MVI   TYP,C'C'            MOVE IN DS TYPE\n         B     GSA\nLOCLDS   TM    PARETYPE,PARELOCL   LOCAL DS?\n         BZ    NXTDSN              NO, GET NEXT DSN\n         MVI   TYP,C'L'            MOVE IN DS TYPE\nGSA      L     R0,PARESLTA         GET SLOTS ALLOCATED\n         ST    R0,NAV\n         LA    R1,ALC\n         BAS   R8,CNVT\n         L     R0,PARESZSL         GET DS SIZE IN SLOTS\n         ST    R0,NSZ\n         LA    R1,SIZ\n         BAS   R8,CNVT\n         BAS   R8,CUSEP            GET USE PERCENTAGE\n         LA    R1,WGHT             GET WEIGHTING. PRINT ADDRESS\n         L     R0,PARERQTM         CORRECTION VALUE\n         BAS   R8,CNVT\n         L     R0,PARERRCT         GET IO ERROR COUNT\n         LA    R1,ERS\n         BAS   R8,CNVT\n         TM    PAREFLG1,PAREDSBD   BAD DS?\n         BZ    *+L'*+4             NO, CARRY ON\n         MVI   0(R1),C'*'          YES, MARK DS WITH *\n         L     R1,PAREUCBP         GET UCB INFO\n         USING UCBDSECT,R1\n         MVC   VOL,UCBVOLI         MOVE IN VOLSER\n         MVC   DVADR,UCBNAME       MOVE IN DEV ADDRESS\n         DROP  R1\n         BAS   R8,TOTANK           MOVE LINE IN TANK\nUPNXT    BCT   R7,NXTLOT           AND PROCESS\n         DROP  R5,R6\n         SPACE 1\n*        SART INFO PROCESS.\n         SPACE 1\n         USING SART,R4\n         L     R3,SARDSNL          POINT TO DSN LIST\n         L     R7,SARSIZE          NBR OF SARTES\n         LA    R6,SARENTS          POINT TO SARTES\n         B     TSTSRT\nSRTNXT   LA    R3,44(R3)           NEXT DSN\n         LA    R6,L'SARTE(R6)      NEXT SARTE\n         USING SARTE,R6\nTSTSRT   CLI   0(R3),C' '          IS DSN BLANK?\n         BE    UPSRT               NO\n         MVC   DSN(L'DSN),0(R3)    MOVE IN DSN\n         MVI   TYP,C'S'            MOVE IN TYPE\n         L     R0,SREAVLSL         GET SWAP SETS ALLOCATED\n         ST    R0,NAV\n         LA    R1,ALC\n         BAS   R8,CNVT\n         L     R0,SRETOTSL         GET DS SIZE\n         ST    R0,NSZ\n         LA    R1,SIZ\n         BAS   R8,CNVT\n         BAS   R8,CUSEP            GET USE PERCENTAGE\n         L     R0,SRERRCNT         GET ERRORS COUNT\n         LA    R1,ERS\n         BAS   R8,CNVT\n         TM    SREFLG,SREDSBD      BAD DS?\n         BZ    *+L'*+4             NO, CARRY ON\n         MVI   0(R1),C'*'          YES, MARK DS WITH *\n         L     R1,SREUCB           GET UCB INFO\n         USING UCBDSECT,R1\n         MVC   VOL,UCBVOLI         MOVE IN VOLSER\n         MVC   DVADR,UCBNAME       MOVE IN DEV ADDRESS\n         DROP  R1\n         BAS   R8,TOTANK           MOVE  LINE IN TANK\nUPSRT    BCT   R7,SRTNXT\n         DROP  R2,R4,R6\n         SPACE 1\n         XR    R6,R6               CLEAR NON 8 CHAR BATCH COUNT\n         XR    R0,R0               CLEAR BATCH COUNT\n         XR    R7,R7               CLEAR TSO COUNT\n         L     R1,ASVTAD           RESTORE ASVT ADDRESS\n         USING ASVT,R1\n         L     R2,ASVTMAXU         MAX NUMBER OF ADDRESS SPACES\n         LA    R3,ASVTFRST         FIRST ASVT ENTRY MINUS 4\n         DROP  R1\nASVTLOOP LA    R3,L'ASVTENTY(R3)   GET ASVT ENTRY\n         ICM   R4,B'1111',0(R3)    IS HIGH ORDER BIT ON?\n         BM    GETNXT              ASID NOT ASSIGNED-GETNXT\n         USING ASCB,R4\n         ICM   R5,B'1111',ASCBTSB  IS THERE A TSB ADDRESS?\n         BNZ   TSOJOB              YES, MUST BE TSO JOB\n         L     R1,ASCBJBNS         2ND JOB POINTER\n         CLC   =C'INIT',0(R1)      IS NAME INIT?\n         BE    BATCH               YES, THERFORE BATCH JOB\n         AH    R0,=H'1'            UP STASK COUNT BY 1\n         B     GETNXT              AND GET NEXT ASCB\nBATCH    ICM   R14,B'1111',ASCBJBNI\n         BZ    GETNXT\n         LA    R6,1(R6)            UP BATCH COUNT BY 1\n         B     GETNXT              AND GET NEXT ASCB\nTSOJOB   LA    R7,1(R7)            UP TSO COUNT\nGETNXT   BCT   R2,ASVTLOOP         AND ROUND AGAIN\n         DROP  R4\n         SPACE 1\n         BCTR  R0,0                LOSE *MASTER*\n         LA    R1,TSTKS            PRINT POINTER\n         BAS   R8,CNVT             DEAL WITH STASK COUNT\n         LR    R0,R6               GET BATCH TOTAL\n         LA    R1,TBTCH            PRINT POINTER\n         BAS   R8,CNVT             DEAL WITH BATCH COUNT\n         LR    R0,R7               GET TSO TOTAL\n         LA    R1,TTSOT            PRINT POINTER\n         BAS   R8,CNVT             DEAL WITH TSO COUNT\n        $TSWXA 24,EXPAND=ONLY\n         L     R7,ATNK\n         L     R8,STNK+4\n         TM    SWITCH,OVRFL\n         BZ    *+L'*+4\n         L     R9,STNK+8\nLLOOP    LA    R1,LPS              GET POINTER TO LINES\n         LA    R0,DATAL            NUMBER OF DATA LINES\nMVLTS    MVC   2(PSLINL,R1),0(R7)  MOVE LINE TO SCREEN\n         BXLE  R7,R8,*+L'*+4\n         B     CHKEND\n         LA    R1,81(R1)           NEXT LINE\n         BCT   R0,MVLTS\n         MVC   LOV(21),=CL21'         *** MORE ***'\n         B     OUTSCR\nCHKEND   TM    SWITCH,OVRFL\n         BZ    OUTSCR\n         MVC   LOV(21),=CL21'*** TANK OVERFLOW ***'\nOUTSCR  TPUT   LINE,LINEL,FULLSCR\n         XC    GETAREA,GETAREA\n        TGET   GETAREA,L'GETAREA,ASIS\n         CLI   PFCODE,X'F3'        PFK-3 ?\n         BE    EXIT                YES, END\n         MVC   LI,RSPONSE          NO, GET RESPONSE\n         OI    LI,C' '             UPPER CASE\n         CLI   LI,C'Z'             END?\n         BE    EXIT                YES, END\n         MVI   LOV,C' '            NO, REFRESH SCREEN\n         MVC   LOV+1(L'LOV-1),LOV\n         LA    R1,LPS              GET POINTER TO LINES\n         LA    R0,DATAL            NUMBER OF DATA LINES\n         MVC   2(PSLINL,R1),PSLIN  CLEAR LINE\n         LA    R1,81(R1)           NEXT LINE\n         BCT   R0,*-10\n         NI    SWITCH,255-OVRFL\n         CLR   R7,R9\n         BH    BEGIN\n         B     LLOOP\nEXIT     L     R1,ATNK\n        FREEMAIN R,A=(1),LV=TNKL,SP=1\n        TPUT   CLR,CLRL,FULLSCR,,HOLD   YES, CLEAR AND EXIT\n        STFSMODE OFF\n        TCLEARQ INPUT\n         XR    R15,R15             SET R.C.\nPEXIT   $XRET  CC=(R15),LV=WRKL,TYPE=RENT\n         EJECT\n*        UTILITY ROUTINES.\n         SPACE 1\nCUSEP    XR    R14,R14             - - - - - - - - - - - - - - - - - -*\n         L     R15,NSZ             COMPUTE ((NSZ-NAV)*100)/NSZ\n         S     R15,NAV\n         M     R14,=F'100'\n         D     R14,NSZ\n         CVD   R15,DWD\n         MVC   USEP(4),=X'40202120'\n         ED    USEP,DWD+6          EDIT USE PERCENTAGE\n         BR    R8\n         SPACE 1\nTOTANK   TM    SWITCH,OVRFL        LINE TO TANK  - - - - - - - - - - -*\n         BO    CLBAR\n         LM    R14,R15,STNK+4\n         BXLE  R9,R14,MVTNK\n         OI    SWITCH,OVRFL        TANK OVERFLOW\n         B     CLBAR\nMVTNK    MVC   0(PSLINL,R9),PSLIN  MOVE LINE\nCLBAR    MVI   PSLIN,C' '          CLEAR LINE BUILDING AREA\n         MVC   PSLIN+1(PSLINL-1),PSLIN\n         BR    R8\n         SPACE 1\nCNVT     CVD   R0,DWD              TO DECIMAL  - - - - - - - - - - - -*\n         MVC   0(6,R1),MASK        MOVE IN MASK\n         ED    0(6,R1),DWD+5       EDIT IN TOTAL\n         BR    R8\n         EJECT\n*        CONSTANTS.\n         SPACE 1\nMUAUT    DC    C'UNAUTHORIZED COMMAND.'\nMNSCR    DC    C'YOUR TERMINAL IS NOT A SCREEN.'\nMNSTD    DC    C'YOUR SCREEN SIZE IS NOT 24 * 80 DIMENSIONED.'\nMASK     DC    X'402020202021'\n         SPACE 2\n        LTORG\n         EJECT\n*        DATA - WORK AREAS DESCRIPTIONS.\n         SPACE 1\nWRKAR    DS    0D                  DOUBLE-WORD BOUNDARY  - - - - - - -*\nSVA      DC    18F'0'              SAVE AREA\nLSVA     EQU   *-SVA\nDWD      DC    D'0'\nEXTR    EXTRACT *-*,'S',MF=L\nSYSTIM   DC    F'0'\nASVTAD   DC    F'0'\nNAV      DC    F'0'\nNSZ      DC    F'0'\nANSWER   DC    A(*-*)\nATNK     DC    A(*-*)\nSTNK     DC    A(*-*,PSLINL,TNKMX)\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(*-*)\nAUTH     DC    XL1'0'\nSWITCH   DC    XL1'0'\nOVRFL    EQU   X'01'               TANK OVERFLOW\n         SPACE 1\nGETAREA  DS    0CL8\nPFCODE   DC    XL1'0',XL5'0'\nRSPONSE  DC    XL2'0'\n         SPACE 1\nCLR     $FS    WCC=(AL,KBR,RMDT),MF=L\n        $FS    SBA=(1,1),RA=(1,1,00),MF=L\n        $FS    SBA=(1,1),SF=(IC),MF=L\nCLRL     EQU   *-CLR\n         SPACE 1\nLINE    $FS    WCC=(KBR,RMDT),MF=L\n        $FS    SBA=(1,1),RA=(1,1,00),MF=L\n        $FS    SBA=(1,1),SF=NORMAL,TEXT=' ',MF=L           L1\n        $FS    SF=(PROT,INT),MF=L\nLI      $FS    TEXT=' ',MF=L\n        $FS    SF=(PROT),TEXT=' ---> USE',MF=L\n        $FS    SF=(PROT,INT),TEXT='PFK-3',MF=L\n        $FS    SF=(PROT),TEXT='OR ENTER',MF=L\n        $FS    SF=(PROT,INT),TEXT='Z',MF=L\n        $FS    SF=(PROT),TEXT='TO EXIT PUSE.',MF=L\n        $FS    TEXT=(' ',10),MF=L\n        $FS    SF=(PROT,INT),MF=L\nLOV     $FS    TEXT=(' ',21),MF=L\n        $FS    SF=(PROT),MF=L\n        $FS    SBA=(2,1),MF=L\n        $FS    TEXT='TIME ',MF=L                           L2\nPRTIME  $FS    TEXT=(' ',10),MF=L\n        $FS    TEXT=' -  SLOTS :',MF=L\nT1      $FS    TEXT=(' ',6),MF=L\n        $FS    TEXT='     VIO :',MF=L\nTTL      EQU   *-T1\nT2      $FS    TEXT=(' ',6),MF=L\n        $FS    TEXT='  NONVIO :',MF=L\nT3      $FS    TEXT=(' ',6),MF=L\n        $FS    SBA=(3,1),MF=L\n        $FS    TEXT=(' ',18),MF=L                          L3\n        $FS    TEXT='UNUSED :',MF=L\nUNUSED  $FS    TEXT=(' ',6),MF=L\n        $FS    SBA=(4,1),MF=L\n        $FS    TEXT='CPU-ID : ',MF=L                       L4\nCPUID1  $FS    TEXT=(' ',2),MF=L\n        $FS    TEXT='/',MF=L\nCPUID2  $FS    TEXT=(' ',6),MF=L\n        $FS    TEXT='/',MF=L\nCPUID3  $FS    TEXT=(' ',4),MF=L\n        $FS    TEXT=' - SYSTEM : ',MF=L\nSYS     $FS    TEXT=(' ',4),MF=L\n        $FS    SBA=(5,1),MF=L\n        $FS    SF=(PROT,INT),MF=L                          L5\n        $FS    TEXT='TY DATA-SET NAME            ',MF=L\n        $FS    TEXT='VOLUME UNIT  AVAIL   ',MF=L\n        $FS    TEXT='SIZE  %-USE WEIGHT ERRORS',MF=L\n        $FS    SBA=(6,1),MF=L\nLPS     $FS    SF=(PROT),TEXT=(' ',79),MF=L                L6\n        $FS    SF=(PROT),TEXT=(' ',79),MF=L                L7\n        $FS    SF=(PROT),TEXT=(' ',79),MF=L                L8\n        $FS    SF=(PROT),TEXT=(' ',79),MF=L                L9\n        $FS    SF=(PROT),TEXT=(' ',79),MF=L                L10\n        $FS    SF=(PROT),TEXT=(' ',79),MF=L                L11\n        $FS    SF=(PROT),TEXT=(' ',79),MF=L                L12\n        $FS    SF=(PROT),TEXT=(' ',79),MF=L                L13\n        $FS    SF=(PROT),TEXT=(' ',79),MF=L                L14\n        $FS    SF=(PROT),TEXT=(' ',79),MF=L                L15\n        $FS    SF=(PROT),TEXT=(' ',79),MF=L                L16\n        $FS    SF=(PROT),TEXT=(' ',79),MF=L                L17\n        $FS    SF=(PROT),TEXT=(' ',79),MF=L                L18\n        $FS    SF=(PROT),TEXT=(' ',79),MF=L                L19\n        $FS    SF=(PROT),TEXT=(' ',79),MF=L                L20\n        $FS    SF=(PROT),TEXT=(' ',79),MF=L                L21\nDATAL    EQU   (*-LPS)/81\n        $FS    SBA=(22,1),MF=L\n        $FS    SF=(PROT,INT),MF=L                          L22\n        $FS    TEXT='S.TASK TOTAL :',MF=L\nTSTKS   $FS    TEXT=(' ',6),MF=L\n        $FS    TEXT=' - BATCH TOTAL :',MF=L\nTBTCH   $FS    TEXT=(' ',6),MF=L\n        $FS    TEXT=' - TSO TOTAL :',MF=L\nTTSOT   $FS    TEXT=(' ',6),MF=L\n        $FS    SBA=(23,1),MF=L\n        $FS    SF=(PROT,INT),TEXT='WEIGHT :',MF=L          L23-24\n        $FS    SF=(PROT),TEXT='LATEST CALCULATION OF ',MF=L\n        $FS    TEXT='SINGLE-REQUEST SERVICE TIME FOR ',MF=L\n        $FS    TEXT='THIS DATA-SET,',MF=L\n        $FS    SBA=(24,11),TEXT='USED FOR LOCALS ONLY.',MF=L\n        $FS    SBA=(1,2),SF=(IC),MF=L\nLINEL    EQU   *-LINE\n         SPACE 1\nPSLIN    DC    CL1' '\nTYP      DC    CL1' '\n         DC    CL1' '\nDSN      DC    CL24' '\n         DC    CL1' '\nVOL      DC    CL6' '\n         DC    CL2' '\nDVADR    DC    CL3' '\n         DC    CL1' '\nALC      DC    CL6' '\n         DC    CL1' '\nSIZ      DC    CL6' '\n         DC    CL3' '\nUSEP     DC    CL4' '\n         DC    CL1' '\nWGHT     DC    CL6' '\n         DC    CL1' '\nERS      DC    CL6' '\nPSLINL   EQU   *-PSLIN\n         SPACE 1\nWRKML    EQU   (((*-DWD)+7)/8)*8   WORK AREAS LENGTH\nWRKL     EQU   (((*-WRKAR)+7)/8)*8 TOTAL WORK AREAS LENGTH\n         EJECT\n        PRINT  NOGEN\n         SPACE 1\nPCCA     DSECT ,                   (IHAPCCA)\n         DS    CL4\nPCCACPID DS    CL12\n         SPACE 1\nASMVT    DSECT ,                   (ILRASMVT)\n         DS    XL4\nASMSART  DS    A\nASMPART  DS    A\n         DS    24F\n         DS    F\nASMSLOTS DS    F\n         SPACE 1\nPART     DSECT ,                   (ILRPART)\n         DS    CL4\nPARTSIZE DS    F\n         DS    4F\nPARTDSNL DS    A\n         DS    13F\nPARTENTS DS    X\n         ORG   PART\nPARTENT  DS    0XL96\n         DS    2F\nPARETYPE DS    X\nPAREPLPA EQU   X'80'\nPARECOMM EQU   X'40'\nPAREDPLX EQU   X'20'\nPARELOCL EQU   X'10'\nPAREFLG1 DS    X\nPAREDSBD EQU   X'40'\n         DS    H\n         DS    F\nPARESZSL DS    F\nPARESLTA DS    F\nPARERRCT DS    F\n         DS    4F\nPAREUCBP DS    F\n         DS    2F\nPARERQTM DS    F\n         EJECT\nSART     DSECT ,                   (ILRSART)\n         DS    CL4\nSARSIZE  DS    F\n         DS    4F\nSARDSNL  DS    A\n         DS    13F\nSARENTS  DS    X\n         ORG   SART\nSARTE    DS    0XL80\n         DS    2F\n         DS    X\nSREFLG   DS    X\nSREDSBD  EQU   X'40'\n         DS    H\n         DS    F\nSRETOTSL DS    F\nSREAVLSL DS    F\nSRERRCNT DS    F\n         DS    4F\nSREUCB   DS    F\n         SPACE 1\n        CVT    DSECT=YES,LIST=YES\n        IHAPSA\n        IHAASVT\n        IHAASCB\n        IEESMCA\nUCBDSECT DSECT\n        IEFUCBOB\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PUSE$": {"ttr": 28933, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15H\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:48:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//PUSE     JOB (........),'INSTALL  - P U S E -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ4AS3,MBR=PUSE\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   PUSE\n  NAME    PUSE(R)\n/*\n//HLP     EXEC PAJHELP,MBR=PUSEH,DSS='->.SOURCE.FILE4'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PUSE@": {"ttr": 28935, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      PUSE      1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     PAGEING UTILIZATION PROGRAM     * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    This program is for use on TSO and uses fullscreen\n  ---------    support (it is dependent on running on 3270's only).\n               The program produces a picture of the slots used on\n               each PAGE data-set, its name, device and volume,\n               also produced are the SWAP data-sets and number of\n               swap sets allocated. A new picture is produced each\n               time the enter key is used. The program can be ended\n               by entering Z or PFK-3.\n\n  Authority :  only system group USER-id's are authorized to issue\n  -----------  this command.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PUSEH": {"ttr": 28937, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=PUSE\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  THIS COMMAND USES THE FULLSCREEN SUPPORT (IT DEPENDS\n               ON RUNNING ON 3270'S ONLY). THE COMMAND PRODUCES A\n               PICTURE OF THE SLOTS USED ON EACH PAGE DATA-SET, ITS\n               NAME, DEVICE AND VOLUME, ALSO PRODUCED ARE THE SWAP\n               DATA-SETS AND NUMBER OF SWAP SETS ALLOCATED.\n               A NEW PICTURE IS PRODUCED EACH TIME THE ENTER KEY IS\n               USED. THE COMMAND CAN BE ENDED BY ENTERING 'Z'.\n               THIS COMMAND IS RESTRICTED TO SYSTEMS SUPPORT PEOPLE\n               ONLY.\n)X SYNTAX :    PUSE\n               ALIAS : NONE.\n)O OPERANDS :  NONE.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QSP": {"ttr": 28939, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12O\\x00\\x94\\x12O\\x114\\x1d,\\x1d,\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-04T00:00:00", "modifydate": "1994-05-04T11:34:00", "lines": 7468, "newlines": 7468, "modlines": 0, "user": "SYSPAJA"}, "text": "QSP      TITLE '--- QUEUE/SP - JES2 V2.R2.L0 ---'\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS IS THE FAMOUS AND WELL KNOWN TSO COMMAND                       *\n*                                                                     *\n*        QQQQ       U    U      EEEEE       U    U      EEEEE         *\n*       Q    Q      U    U      E           U    U      E             *\n*       Q    Q      U    U      E           U    U      E             *\n*       Q    Q      U    U      EEEE        U    U      EEEE          *\n*       Q    Q      U    U      E           U    U      E             *\n*       Q  Q Q      U    U      E           U    U      E             *\n*        QQQQ        UUUU       EEEEEE       UUUU       EEEEEE        *\n*            Q                                                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* CBT ORIGIN : EXTRACTED FROM CBT TAPE 84 JUN, FILE 149, ADDS BASED   *\n*              ON CBT TAPE 85 FEB, FILE 153, AND CBT TAPE 87 FEB,     *\n*              FILE 394. VERSION ADAPTED TO JES2 V2R2L0 MVS/XA 2.2.0  *\n*              BY : MOINIL P.A. - J.R.C. - ISPRA ESTABLISHMENT        *\n*                                 21020 ISPRA (VA), ITALY.            *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* COMMAND SYNTAX : QSP ...SUB-COMMAND...                              *\n*                  THE SUB-COMMAND WILL BE EXECUTED WHEN ENTERING.    *\n*                  IF OMITED, THE STATUS OF ALL THE JOBS FOR THE      *\n*                  CURRENT SESSION USER-ID (LOGON ID) IS DISPLAYED.   *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* DEFAULT DATA-SETS NAMES ALLOCATIONS FOR :                           *\n*        CHECKPOINT ---> DSNAME=SYS1.HASPCKPT                         *\n*        SPOOL SPACE ---> DSNAME=SYS1.HASPACE                         *\n* THIS MAY BE ALTERED AS FOLLOWS :                                    *\n*        1. ALLOC F(JES2CKPT) DA(...) VOL(...) SHR                    *\n*           QSP ...                                                   *\n*           THIS ALLOWS :                                             *\n*           THE USE OF A SPECIFIC CHECKPOINT DATA-SET,                *\n*           THE ASSIGNMENT TO THE SPOOL SPACE DATA-SETS NAMES THE     *\n*              SAME PREFIX AS THAT GIVEN FOR THE CHECKPOINT DATA-SET, *\n*           AND THE CHECKPOINT DATA-SET IS NOT DE-ALLOCATED AT END.   *\n*           I.E. : ALLOC F(JES2CKPT) DA('ALPHA.TESTJES') SHR          *\n*                  SPOOL SPACE ---> DSNAME=ALPHA.HASPACE              *\n*        2. ALLOC F(...) DA('SYS1.HASPCKPT') VOL(...) SHR             *\n*           QSP ...                                                   *\n*           THIS ALLOWS :                                             *\n*           THE USE OF A SPECIFIC CHECKPOINT DATA-SET,                *\n*           THE RETRIEVE FROM IT OF THE SPOOL DATA-SETS SPACES,       *\n*           AND ALL DATA-SETS ARE DE-ALLOCATED AT END.                *\n*           I.E. : ALLOC F(TESTCKPT) DA('BRAVO.TESTJES') SHR          *\n*                  SPOOL SPACE ---> DSNAME=SYS1.HASPACE               *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\n         PRINT OFF\n         MACRO\n&NAME    QCALL     &RTN,&R1,&R0,&ERRAD=\n         LCLC  &L\n&L       SETC  '&NAME'\n         AIF   ('&R1' EQ '' OR '&R1' EQ '(R1)').R1OK2\n         AIF   ('&R1'(1,1) EQ '(').R1REG\n         AIF   ('&R1' EQ '0').R1Z\n&L       LA    R1,&R1\n         AGO   .R1OK1\n.R1Z     ANOP\n&L       XR    R1,R1\n         AGO   .R1OK1\n.R1REG   ANOP\n&L       LR    R1,&R1(1)\n.R1OK1   ANOP\n&L       SETC  ''\n.R1OK2   ANOP\n         AIF   ('&R0' EQ '' OR '&R0' EQ '(R0)').R0OK2\n         AIF   ('&R0'(1,1) EQ '(').R0REG\n         AIF   ('&R0' EQ '0').R0Z\n&L       LA    R0,&R0\n         AGO   .R0OK1\n.R0Z     ANOP\n&L       XR    R0,R0\n         AGO   .R0OK1\n.R0REG   ANOP\n&L       LR    R0,&R0(1)\n.R0OK1   ANOP\n&L       SETC  ''\n.R0OK2   ANOP\n         AIF   ('&RTN' EQ '' OR '&RTN' EQ '(R15)').R15OK2\n         AIF   ('&RTN'(1,1) EQ '(').R15REG\n&L       L     R15,=A(&RTN)        @ OF ROUTINE\n         AGO   .R15OK1\n.R15REG  ANOP\n&L       LR    R15,&RTN(1)\n.R15OK1  ANOP\n&L       SETC  ''\n.R15OK2  ANOP\n&L       BASR  R14,R15\n         AIF   ('&ERRAD' EQ '').EXIT\n         BNZ   &ERRAD\n.EXIT    MEND\n         MACRO\n&NAME    QSTART    &DUMMY\n&NAME    STM   R14,R12,12(R13)     SAVE CALLERS REGS\n         USING QCOMMON,R11         COMMON AREA BASE\n         LR    R12,R13\n         LA    R13,18*4(R13)       PUSH SAVE AREA STACK\n         XC    0(18*4,R13),0(R13)  CLEAN NEW SAVE AREA\n         ST    R13,8(R12)          CHAIN SAVE AREAS\n         ST    R12,4(R13)\n         LR    R12,R15             LOCAL BASE REGISTER\n         USING &NAME,R12\n         MEND\n         MACRO\n&NAME    QSTOP     &DUMMY\n&NAME    L     R13,4(R13)          BACK TO PREVIOUS SAVE AREA\n         LM    R2,R12,28(R13)      RESTORE REGISTERS 2-12\n         L     R14,12(R13)         RESTORE REGISTER 14\n         MVI   12(R13),X'FF'       SET RETURN INDICATOR\n         LTR   R15,R15             SET CC ON RETURN CODE\n         BR    R14                 RETURN TO CALLER\n         MEND\n         MACRO\n&NAME    QBACK     &DUMMY\n&NAME    L     R13,QFRSTSA         GO BACK TO MAIN MODULE\n         LM    R14,R12,12(R13)     RESTORE REGS FROM 1ST SAVE AREA\n         MVI   12(R13),X'FF'       SET RETURN INDICATOR\n         BR    R10                 -> INTERRUPT HANDLER IN QUEUE\n         MEND\n         MACRO\n&NAME    QTILT &MESSAGE,&LENGTH\n         LCLA  &L\n         LCLC  &N\n&N       SETC  '&NAME'\n         AIF   ('&MESSAGE' EQ '').SM\n&N       LA    R1,=C&MESSAGE       @ OF MESSAGE\n&N       SETC  ''\n&L       SETA  K'&MESSAGE-2\n         AIF   ('&LENGTH' EQ '').SL\n         AGO   .TL\n.SM      AIF   ('&LENGTH' EQ '').OK\n.TL      ANOP\n&L       SETA  &LENGTH\n.SL      ANOP\n&N       LA    R0,&L               LENGTH OF MESSAGE\n&N       SETC  ''\n.OK      ANOP\n&N       L     R15,=A(TILT)        @ TILT ROUTINE\n         BR    R15                 TILT, NEVER RETURN\n         MEND\n         MACRO\n&NAME    ZIC   &REG,&ADDR\n&NAME    XR    &REG,&REG\n         IC    &REG,&ADDR\n         MEND\n         MACRO\n&NAME    QSCT  &SCN,&IND,&CDE,&ADDR\n         LCLA  &L\n         LCLC  &I,&C\n         AIF   ('&ADDR' EQ '').ERRA\n         AIF   ('&SCN' EQ '').NULL\n&L       SETA  K'&SCN\n         AIF   (&L GT 2).ERRS\n         AIF   ('&IND' EQ '').A\n&I       SETC  '&IND'\n         AGO   .B\n.A       ANOP\n&I       SETC  '0'\n.B       AIF   ('&CDE' EQ '').C\n&C       SETC  '&CDE'\n         AGO   .D\n.C       ANOP\n&C       SETC  '0'\n.D       ANOP\n&NAME    DC    CL2'&SCN',AL1(&I,&C),A(&ADDR)\n         MEXIT\n.NULL    AIF   ('&IND' NE '').ERRI\n         AIF   ('&CDE' NE '').ERRC\n&NAME    DC    XL2'FF00',AL1(0,0),A(&ADDR)\n         MEXIT\n.ERRA    MNOTE 8,' SUB-COMMAND ADDRESS MISSING ***********************'\n         MEXIT\n.ERRS    MNOTE 8,' SUB-COMMAND NAME TOO LONG *************************'\n         MEXIT\n.ERRI    MNOTE 8,' INDICATOR(S) NOT ALLOWED **************************'\n         MEXIT\n.ERRC    MNOTE 8,' SUB-COMMAND CODE NOT ALLOWED **********************'\n         MEND\n         PRINT ON\n         SPACE 1\nQUEUE    START 0\n         EJECT\n         PRINT NOGEN\n         COPY  $HASPGBL\n         $HASPEQU\n         SPACE 1\n&MACSPLV SETC  '2'                 MACROS LIBRARY LEVEL\n&VERSION SETC  'SP 2.2.0'          HASP VERSION\n         SPACE 1\n************************************************************* *\n*                                                             *\n*        THE VALUE OF THE VARIABLE BELOW CANNOT BE            *\n*        DYNAMICALLY RETRIEVED, SO YOU MUST ADJUST            *\n*        IT LOOKING IN THE HASPIRDA ASSEMBLY LIST.            *\n*                                                             *\nNCTETENT EQU   8                   NUMBER OF CKPT ENTRIES     * <======\n*                                                             *\n************************************************************* *\n         SPACE 1\n         $DAS\n         $MIT\n         $TAB\n         $PCE\n         IFGRPL ,        MVS ACB REQUEST PARAMETER LIST / $BUFFER\n         $BUFFER\n         $JQE\n         $JOE\n         $JOT\n         $KIT\n         $QSE\n         $JCT\n         $PDDB\n         $IOT\n         $CAT\n         $HCT\n         $LRC\n         SPACE 1\n         DROP ,                    DROP ALL JES REGS\n         SPACE 1\n         PRINT GEN\n         TITLE '--- QUEUE/SP MISCELLANEOUS DEFINITIONS ---'\nQUEUE    CSECT ,                   RESTORE MAIN CSECT\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* CURRENT REGISTER USAGE :                                            *\n*                                                                     *\n*  R0  - PARM                                                         *\n*  R1  - PARM                                                         *\n*  R11 - @ QUEUE COMMON AREA (QCOMMON)                                *\n*  R12 - LOCAL PROGRAM BASE                                           *\n*  R13 - STACK PTR (@ 72 BYTE SAVE AREA IN STACK)                     *\n*  R14 - RETURN ADDRESS                                               *\n*  R15 - LINKAGE                                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\n*---------------------------------------------------------------------*\n*        AUTHORITY LEVELS DEFINITIONS.                                *\n*---------------------------------------------------------------------*\n         SPACE 1\nLV15     EQU   15        PRIVILEGED LEVEL\nLV12     EQU   12        AUTOMATIC MODE CONTROL LEVEL\nLV10     EQU   10        WHEN LESS : REDUCED SERVICES LEVEL\nLV0      EQU   0         REJECT LEVEL\n         SPACE 1\nQSP     $MDL@IX\n         SPACE 1\n*---------------------------------------------------------------------*\n*        MISCELLANEOUS VALUES DEFINITION.                             *\n*---------------------------------------------------------------------*\n         SPACE 1\nWASSZ    EQU   16*1024   WORK AREA SPACE SIZE\nLDSSZ    EQU   256*1024  BLOCK ADDR TABLE SIZE FOR LISTDS\nTDFLT    EQU   60*100    AUTOMATIC MODE DEFAULT TIME VALUE\n         TITLE '--- QUEUE/SP -- MAINLINE MODULE ---'\n         $XENT BASE=R12,LV=QWAREAL,SP=1,TYPE=RENT\n         SPACE 1\n*---     SET COMMON AREA                                           ---*\n         SPACE 1\n         LR    R2,R1               SAVE ENTRY ADDRESS\n         LA    R11,0(,R13)\n         LA    R5,18*4\n         LR    R0,R11\n         AR    R0,R5\n         L     R1,=A(QCOMMONL)\n         SR    R1,R5\n         L     R14,=A(QCOMMON)\n         AR    R14,R5\n         LR    R15,R1\n         MVCL  R0,R14              INITIALIZE COMMON\n         USING QCOMMON,R11         ACCESS TO COMMON VECTOR TABLE\n         SPACE 1\n*---     CHECK USER AUTHORITY : SYSTEM, OPERATOR, ...              ---*\n*---           THESE TESTS DON'T INCLUDE RACF PROTECTION ON        ---*\n*---           DATA-SETS, WHICH IS CONTROLED AT OPEN TIME IF       ---*\n*---           INSTALLED IN THE SYSTEM.                            ---*\n         SPACE 1\n         $TEW$EC REG=R2,TIOT=YES,NOTTSO=(,ONLY),MSG=PUTMSG,ERR=XBACK\n         LA    R1,QXAUTH\n         ST    R1,REQAUT+4\n         $EACM REQAUT\n         CLI   QXAUTH,LV0\n         BE    NOTAUT\n         MVC   SAVAUTH,QXAUTH      RETAIN ORIGINAL AUTHORITY\n         SPACE 1\n*---     CHECK CALLER TERMINAL                                     ---*\n         SPACE 1\n         GTSIZE ,                  GET SCREEN SIZE\n         LTR   R0,R0               IS IT A SCREEN?\n         BZ    NOTSCR              IF ZERO, NOT A SCREEN\n         CH    R0,=H'24'           STANDARD NUMBER OF LINES?\n         BL    NOTSTD              BRANCH IF LESS\n         BE    TSTLNL              BRANCH IF YES\n         CH    R1,=H'80'           STANDARD LINE LENGTH?\n         BL    NOTSTD              BRANCH IF LESS\nSETSSZ   ST    R0,SZSCRN           SAVE SCREEN SIZE\n         ST    R1,SZLINE           SAVE LINE SIZE\n         OI    SZSWTCH,SCRST       INDICATE SCREEN SIZE TO BE SET\n         B     GASID\nTSTLNL   CH    R1,=H'80'           STANDARD LINE LENGTH?\n         BL    NOTSTD              BRANCH IF LESS\n         BH    SETSSZ              BRANCH IF MORE\n         SPACE 1\n*---     OK, GET MY \"ASID\"                                         ---*\n         SPACE 1\n         USING PSA,R0              PSA ADDRESSABILITY\nGASID    L     R3,PSAAOLD          CURRENT ASCB ADDRESS\n         USING ASCB,R3             ASCB ADDRESSABILITY\n         MVC   QASID,ASCBASID      GET MY ADDRESS SPACE IDENTIFIER\n         DROP  R0,R3\n         SPACE 1\n*---     COMPLETE COMMON AREA INITIALIZATION                       ---*\n         SPACE 1\n         LR    R5,R11\n         AL    R5,=A(QCOMMONL)\n         ST    R5,QCWA             SET PTR TO SPACE WORK AREA\n         LA    R5,2048(R11)\n         LA    R5,2048(R5)\n         USING QCOMMON+4096,R5\n         LA    R1,QDISPLAY\n         ST    R1,QVDSPL           SET PTR TO DISPLAY WORK AREA\n         LA    R1,QCKPT\n         ST    R1,QVCKPT           SET PTR TO CKPT WORK AREA\n         LA    R1,QSNAP\n         ST    R1,QVSNAP           SET PTR TO SNAP WORK AREA\n         LA    R1,QPRINT\n         ST    R1,QVPRINT          SET PTR TO HARDCOPY WORK AREA\n         LA    R1,DAIRECB\n         ST    R1,DAPLECB          SET PTR TO CP'S ECB\n         LA    R1,HASPCKPT\n         ST    R1,HDECB1+(DECDCBAD-DECB)     SET PTR TO DCB\n         LA    R1,HASPACE\n         ST    R1,HDECB2+(DECDCBAD-DECB)     SET PTR TO DCB\n         LA    R1,QCDAD\n         ST    R1,HDECB2+(DECRECPT-DECB)     SET PTR TO BLKREF\n         LA    R1,QCOUT\n         O     R1,QCOPEN\n         ST    R1,QCOPEN           SET PTR TO DCB\n         LA    R1,HASPCKPT\n         O     R1,HOCKPT\n         ST    R1,HOCKPT           SET PTR TO DCB\n         LA    R1,INT#DCB\n         O     R1,INT#RDJF\n         ST    R1,INT#RDJF         SET PTR TO DCB\n         LA    R1,INT#ELST\n         O     R1,INT#DCB+(DCBEXLST-IHADCB)\n         ST    R1,INT#DCB+(DCBEXLST-IHADCB)  SET PTR TO EXIT LIST\n         LA    R1,INT#JFCB\n         O     R1,INT#ELST\n         ST    R1,INT#ELST         SET PTR TO JFCB READ AREA\n         DROP  R5\n         SPACE 1\n*---     GET SAVE AREA STACK                                       ---*\n         SPACE 1\nGTSAS    L     R5,QGSASSZ          GET SAVE AREA STACK SIZE\n         GETMAIN R,LV=(R5),SP=1    GET SAVE AREA STACK\n         LA    R4,0(,R1)\n         LR    R0,R4\n         LR    R1,R5\n         XR    R15,R15\n         MVCL  R0,R14              ZERO STACK\n         ST    R13,4(R4)           CHAIN WITH ENTRY SAVE AREA\n         ST    R4,8(R13)\n         LR    R13,R4              SET @ OF STACK\n         ST    R13,QFRSTSA         INIT KLUDGE *******\n         SPACE 1\n*---     VTAM INITIALIZATION                                       ---*\n         SPACE 1\n         STFSMODE  ON,INITIAL=YES\n         TM    SZSWTCH,SCRST       SCREEN SIZE TO BE SET?\n         BZ    NOSCRS              BRANCH IF NOT\n         STSIZE SIZE=80,LINE=24    SET STANDARD SCREEN SIZE\n         OI    SZSWTCH,SCRRS       INDICATE SCREEN SIZE TO BE RESET\n         SPACE 1\n*---     JES2 DEPENDENT INITIALIZATION - INIT                      ---*\n         SPACE 1\nNOSCRS   QCALL INIT                INITIALIZE\n         LA    R10,LOOP            INTERRUPTED RETURN ADDRESS\n         L     R9,QVDSPL           @ DISPLAY WORK AREA\n         USING QDISPLAY,R9\n         SPACE 1\n*---     READ JES2 CHECKPOINT FILE - CKPT                          ---*\n         SPACE 1\nLOOP     QCALL CKPT\n         SPACE 1\n*---     COMMAND LINE PARSE                                        ---*\n         SPACE 1\n         QCALL PARSE\n         CLC   =C'E ',QSUBNAME     STOP?\n         BE    EXIT                YES\n         CLC   =C'EXIT ',QSUBNAME  STOP?\n         BE    EXIT                YES\n         CLC   =C'END ',QSUBNAME   STOP?\n         BE    EXIT                YES\n         CLC   =C'STOP ',QSUBNAME  STOP?\n         BE    EXIT                YES\n         SPACE 1\n*---     CALL SUB-COMMAND MODULE SELECTED BY PARSE                 ---*\n         SPACE 1\n         MVC   QDHLINE,DUMMY       NO OUTPUT MESSAGE\n         L     R15,QSUBCMD         ADDR OF SUBCMD FROM QCOMMON\n         QCALL ,                   GO TO IT\n         CLC   QDHLINE,DUMMY       WAS ANYTHING WRITTEN?\n         BE    NO$DATA             NO - SKIP\n         L     R1,=A(EMPTYDS)      POINT TO EMPTY DS MESSAGE\n         CLC   QDHLINE,0(R1)       IS DATA-SET EMPTY?\n         BE    NO$DATA             YES, SKIP\n         TM    QDOVER,QESKIP       END OF DATA SKIP REQUESTED?\n         BZ    SND$DATA            NO, SEND IT\n         NI    QDOVER,255-QESKIP   OFF INDICATOR\n         B     NO$DATA\nSND$DATA QCALL DISPLAY,ENDDATA,80  MOVE TO SCREEN\nNO$DATA  QCALL DISPLAY,,0          WRITE LAST SCRN, GET NEXT INPUT\n         B     LOOP                DO IT AGAIN\nCMDINV   MVC   QDHLINE,CINVMSG     SEND INVALID MSG\n         B     NO$DATA\nCMDUNK   MVC   QDHLINE,CUNKMSG     SEND UNKNOWN MSG\n         B     NO$DATA\n         SPACE 1\n*---     CLEAN UP AND GO HOME                                      ---*\n         SPACE 1\nEXIT     MVC   QDSCREEN(CLEARL),CLEAR   SET CLEAR SEQUENCE\n         TM    SZSWTCH,SCRRS       WAS SCREEN SIZE CHANGED?\n         BZ    ENDCL               BRANCH IF NOT\n         STSIZE SIZELOC=SZLINE,LINELOC=SZSCRN     RESTORE\n         $FS   CC=EWA,MF=(I,QDSCREEN)\nENDCL    TPUT  QDSCREEN,CLEARL,FULLSCR,,HOLD CLEAR THE SCREEN\n         STFSMODE  OFF             TELL VTAM WE'RE DONE\n         SPACE 1\n*---     CLOSE AND EVENTUALLY FREE HASPCKPT                        ---*\n         SPACE 1\n         L     R8,QVCKPT           LOAD BASE REG\n         USING QCKPT,R8            BASE REG FOR CKPT WORK AREA\n         CLOSE MF=(E,HOCKPT)       CLOSE\n         MVI   DAIRFLAG,DFFREE+DFABORT  REQUEST FREE FUNCTION\n         MVC   DAFRDDN(L'DAFRDDN),HASPCKPT+(DCBDDNAM-IHADCB)\n*                                  DDNAME TO DAIR PARM AREA\n         CLC   DAFRDDN,INT#DCB+(DCBDDNAM-IHADCB)\n         BE    FR$SP\n         QCALL ALLOCATE            FREE IT BY DDNAME\n         SPACE 1\n*---     CLOSE AND FREE HASPACE(S)                                 ---*\n         SPACE 1\nFR$SP    L     R1,QCSPOPNL\n         CLOSE MF=(E,(1))          CLOSE\n         L     R2,QCSPOPNL         -> TO FIRST DCB ADDRESS\nLOOP$FR  L     R1,0(,R2)           GET A DCB ADDRESS\n         MVC   DAFRDDN,DCBDDNAM-IHADCB(R1)\n*                                  COPY DDNAME TO DAIR PARM AREA\n         QCALL ALLOCATE            FREE IT BY DDNAME\n         TM    0(R2),X'80'         WAS THIS THE LAST HASPACE DCB?\n         LA    R2,4(,R2)           -> NEXT DCB ADDRESS IN CASE NOT\n         BNO   LOOP$FR             NO - DO NEXT\n         SPACE 1\n*---     CLOSE HARDCOPY FILE IF ANY                                ---*\n         SPACE 1\n         TM    QHFREQ,QHCOPY       IS HARDCOPY ACTIVE?\n         BZ    FREETRC             NO\n         OI    QHFREQ,QHCLOSE      SAY CLOSE IT\n         QCALL PRINT\n         SPACE 1\n*---     CLOSE TRACE FILE IF ANY                                   ---*\n         SPACE 1\nFREETRC  TM    QXSWXQ,OPTR         TRACE FILE IS OPENED?\n         BZ    FREETSO             NO\n         L     R1,QVSNAP           @ SNAP WORK AREA\n         USING QSNAP,R1\n         LA    R2,SNAPDCB\n         DROP  R1\n         CLOSE ((R2)),MF=(E,SNAPCL)\n         SPACE 1\n*---     FREE EVENTUALLY THE TSO WORK AREA                         ---*\n         SPACE 1\nFREETSO  L     R1,ATSOX            GET TSO WORK AREA ADDRESS\n         LTR   R1,R1               WAS ACQUIRED?\n         BZ    NOTSOC              NO, SKIP FREE\n         LA    R0,TSOXEQL          LENGTH FOR FREEMAIN\n         FREEMAIN R,LV=(0),A=(1)   FREE WORKING STORAGE\n         SPACE 1\n*---     FREE ALL OTHER WORK AREAS                                 ---*\n         SPACE 1\nNOTSOC   L     R4,QFRAR1           BLOCK ADDR TABLE FOR LISTDS\n         L     R5,QFRSZ1           HIS LENGTH\n         FREEMAIN R,A=(R4),LV=(R5),SP=1\n         L     R4,QFRAR2           DECB WORK AREA FOR CKPT ROUTINE\n         L     R5,QFRSZ2           HIS LENGTH\n         FREEMAIN R,A=(R4),LV=(R5),SP=1\n         L     R4,QFRAR3           BUFFERS FOR HASPCKPT & HASPACE(S)\n         L     R5,QFRSZ3           HIS LENGTH\n         FREEMAIN R,A=(R4),LV=(R5),SP=1\n         L     R4,QFRAR4           DCB POOL FOR HASPACE(S)\n         L     R5,QFRSZ4           HIS LENGTH\n         FREEMAIN R,A=(R4),LV=(R5),SP=1\n         SPACE 1\n*---     FREE STACK AREA + COMMON AREA                             ---*\n         SPACE 1\n         L     R4,QFRSTSA          GET SAVE AREA STACK ADDRESS\n         L     R5,QGSASSZ          GET SAVE AREA STACK SIZE\n         FREEMAIN R,A=(R4),LV=(R5),SP=1\nXBACK    LR    R13,R11\n         $XRET CC=0,LV=QWAREAL,SP=1,TYPE=RENT\n         SPACE 1\n*---     SEND DIAGNOSTIC MESSAGES                                  ---*\n         SPACE 1\nNOTAUT   LA    R1,NAUTM\n         B     SDMSG\nNOTSCR   LA    R1,NSCRM\n         B     SDMSG\nNOTSTD   LA    R1,NSTDM\nSDMSG    BAS   R14,PUTMSG\n         B     XBACK\n         EJECT\n*---     CONSTANTS AND OTHER ODDITIES                              ---*\n         SPACE 1\nCLEAR    $FS   CC=EW,WCC=(AL,KBR,RMDT),SBA=(24,79),MF=L\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SF=(INT,IC),MF=L\nCLEARL   EQU   *-CLEAR\nDUMMY    DC    CL79'    NO DATA IS AVAILABLE FOR YOUR REQUEST'\nCINVMSG  DC    CL79'=== INVALID SUB-COMMAND ==='\nCUNKMSG  DC    CL79'=== WHAT ?'\nENDDATA  $FS   SF=(PROT,INT),MF=L  HIGH INTENSITY, PROTECTED\n         DC    CL76'                            *** END OF DATA ***'\n         $FS   SF=(PROT),MF=L      NORMAL INTENSITY, PROTECTED\n         SPACE 1\nNAUTM    WTO   ' -> UNAUTHORIZED COMMAND.',                            X\n               ROUTCDE=11,DESC=7,MF=L\nNSCRM    WTO   ' -> QUEUE/SP RUN ONLY ON A SCREEN TERMINAL.',          X\n               ROUTCDE=11,DESC=7,MF=L\nNSTDM    WTO   ' -> QUEUE/SP WANT TO BE SCREEN SIZED 24 * 80.',        X\n               ROUTCDE=11,DESC=7,MF=L\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R8,R9,R11,R12\n         TITLE '--- QUEUE/SP -- INIT -- INITIALIZATION ROUTINES ---'\nINIT     QSTART\n         L     R9,QVCKPT           LOAD BASE REG\n         USING QCKPT,R9            BASE REG FOR CKPT WORK\n         L     R8,QVDSPL           LOAD BASE REG\n         USING QDISPLAY,R8         BASE REG FOR DISPLAY WORK\n         SPACE 1\n*---     MOVE PARMS FROM CPPL TO DAPL                              ---*\n         SPACE 1\n         L     R2,#TSCPPL          ADDRESS OF CPPL\n         USING CPPL,R2             ADDR OF CPPL IS IN R2\n         MVC   DAPLUPT,CPPLUPT     USER PROFILE TABLE\n         MVC   DAPLPSCB,CPPLPSCB   PROTECTED STORAGE CNTL BLK\n         MVC   DAPLECT,CPPLECT     ENVIRONMENT CNTL TABLE\n         SPACE 1\n*---     LOCATE LOGON ID, SAVE FOR FUTURE REFERENCE                ---*\n         SPACE 1\n         L     R1,CPPLPSCB         -> PSCB\n         USING PSCB,R1\n         MVC   QLOGON(7+1),PSCBUSER     SAVE TSO USERID AND LENGTH\n         MVC   QSTKEY(7),QLOGON    SET SEARCH KEY FOR 'ST'\n         MVI   QSTKEY+7,C' '       FIX LAST BYTE\n         DROP  R1\n         SPACE 1\n*---     MOVE COMMAND BUFFER TO REPLY BUFFER                       ---*\n         SPACE 1\n         L     R1,CPPLCBUF         ADDR OF COMMAND BUFFER\n         DROP  R2                  DONE WITH THIS REGISTER\n         LH    R3,0(,R1)           LENGTH OF COMMAND BUFFER\n         LH    R4,2(,R1)           OFFSET TO FIRST DATA BYTE\n         LA    R1,4(R1,R4)         FIRST DATA BYTE\n         SR    R3,R4               SUBTRACT OFFSET FROM LENGTH\n         SH    R3,=H'4'            SUBTRACT OVERHEAD\n         SH    R3,=H'1'            IS LENGTH ZERO?\n         BM    INT$SKIP            YES, SKIP IT\n         EX    R3,OCBUF            TRANSLATE TO UPPER CASE\n         XC    QDREPLY,QDREPLY     RESET THE REPLY LINE\n         CH    R3,=Y(QDREPLYL-1)   IS LENGTH OVER MAX?\n         BNH   *+L'*+4             NO, USE IT\n         LA    R3,QDREPLYL-1       USE MAXIMUM LENGTH\n         EX    R3,MVCBUF           MOVE THE DATA\n         LA    R3,1(,R3)           INCREMENT TO TRUE LENGTH\n         STH   R3,QDRLNG           STORE REPLY LENGTH\n         OC    QDREPLY(2),QBLANK   UPPER CASE SUB-COMMAND\n         L     R15,=A(P$TABLE)     START OF SUB-COMMANDS TABLE\nINT$SCTB CLC   QDREPLY(2),0(R15)   THIS ONE?\n         BE    INT$TSNR            YES\n         LA    R15,L'P$TABLE(R15)  NO, NEXT ENTRY\n         CLI   0(R15),X'FF'        IS THIS THE END OF TABLE?\n         BNE   INT$SCTB            NO, TRY NEXT ENTRY\nINT$SREQ OI    QDPRSW,QRPVCMD      YES, SET RESTORE SUB-COMMAND REQ\n         B     INT$SKIP            DON'T SET TO REPROMPT\nINT$TSNR TM    2(R15),FLNPR        NO REPROMPT?\n         BO    INT$SREQ            YES, DON'T SET TO REPROMPT\n         MVC   QDPROMPT,QDREPLY    NO, SAVE FOR REPROMPT\n         MVC   QDRLNGP,QDRLNG      LENGTH FOR REPROMPT\n         SPACE 1\n*---     GETMAIN BLOCK ADDR TABLE FOR LISTDS                       ---*\n         SPACE 1\nINT$SKIP L     R3,QFRSZ1           LENGTH\n         GETMAIN R,LV=(R3),SP=1\n         ST    R1,QCSTART          STORE STARTING ADDR OF TABLE\n         ST    R1,QFRAR1           STORE ADDRESS FOR FREE\n         A     R1,QFRSZ1           END OF TABLE\n         ST    R1,QCEND\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        IF HASPCKPT ALREADY ALLOCATED USE IT                         *\n*        AND USE HIS DATA-SET NAME PREFIX FOR HASPACE(S)              *\n*        (THIS ALLOWS ALTERNATE CKPT OR TEST JES)                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\n         RDJFCB MF=(E,INT#RDJF)    GET JFCB IF ANY\n         LTR   R15,R15             ANY JFCB?\n         BNZ   INT$CKTP            BRANCH IF NO JFCB, ALLOC CKPT\n         LA    R15,INT#JFCB\n         LA    R0,44\nINT$CLP  CLI   0(R15),C'.'\n         BE    INT$CLL\n         LA    R15,1(,R15)\n         BCT   R0,INT$CLP\n         B     INT$CKTP\nINT$CLL  LA    R1,INT#JFCB\n         SR    R15,R1              LENGTH OF PREFIX\n         BCTR  R15,0               GET EX LENGTH\n         MVC   DSNSPACE+2(44),=CL44' '  BLANK OUT DSN\n         EX    R15,INT$CMVC\n         LA    R1,DSNSPACE+2+1(R15)\n         MVC   0(8,R1),=C'.HASPACE'     FINISH SPACE NAME\n         LA    R15,8+1(,R15)       HASPACE NAME LENGTH\n         STH   R15,DSNSPACE        SAVE NAME LENGTH\n         B     INT$CHAV            AND GO USE CKPT\nINT$CMVC MVC   DSNSPACE+2(0),INT#JFCB   <<EXECUTED>>\n         SPACE 1\n*---     ALLOCATE HASPCKPT                                         ---*\n         SPACE 1\nINT$CKTP LA    R15,DSNCKPT         DSNAME FOR ALLOCATE\n         ST    R15,DAALPDSN\n         MVI   DAIRFLAG,DFALLOC+DFABORT REQUEST ALLOCATE FUNCTION\n         QCALL ALLOCATE            ALLOCATE IT\n         MVC   HASPCKPT+(DCBDDNAM-IHADCB)(L'DAALDDN),DAALDDN\n*                                  GET DDNAME DAIR RETURNED\n         SPACE 1\n*---     OPEN HASPCKPT                                             ---*\n         SPACE 1\nINT$CHAV DEVTYPE HASPCKPT+(DCBDDNAM-IHADCB),IT#DEVTB,DEVTAB,RPS\n*                                  GET CKPT DEV INFO\n         L     R3,IT#DEVTB+4       MAX BLKSIZE FOR DEVICE\n         STH   R3,HASPCKPT+(DCBBLKSI-IHADCB) SET IN CKPT DCB\n         XR    R3,R3\n         IC    R3,IT#DEVTB+3       UNIT TYPE INFO FOR TRKCALC\n         L     R4,=A(X'01001000')  # OF 4K BLOCKS / TRK\n         TRKCALC FUNCTN=TRKCAP,TYPE=(R3),RKDD=(R4),REGSAVE=YES,        1\n               MF=(E,TRKLIST)\n         ST    R0,IT#CKRT          SAVE # 4K BLK/TRK ON CKPT\n         OPEN  MF=(E,HOCKPT)       OPEN HASPCKPT\n         TM    HASPCKPT+(DCBOFLGS-IHADCB),DCBOFOPN     OPEN OK?\n         BZ    IT$DIE1             NO, OPEN ERROR\n         SPACE 1\n*---     GETMAIN DECB WORK AREA FOR CKPT ROUTINE                   ---*\n         SPACE 1\n         XR    R2,R2\n         IC    R2,HASPCKPT+(DCBNCP-IHADCB)   NCP VALUE FROM DCB\n         MH    R2,=Y(HDECB1L)      * LENGTH OF EACH DECB\n         LA    R2,7(R2)            ROUND TO 8 BYTE BOUNDARY\n         SRL   R2,3\n         SLL   R2,3\n         ST    R2,QFRSZ2           STORE LENGTH FOR FREE\n         GETMAIN R,LV=(R2),SP=1\n         ST    R1,QCDECBPT         SAVE @ DECB WORK AREA FOR CKPT\n         ST    R1,QFRAR2           STORE ADDRESS FOR FREE\n         SPACE 1\n*---     READ MASTER RECORD (RECORD 3)                             ---*\n         SPACE 1\n         L     R2,QCSTART          USE TABLE AREA FOR IOAREA\n         ST    R2,QCMSA\n         OI    SWCKPT,SWCKPTMR     ASK FOR MASTER RECORD ONLY\n         QCALL CKPT                READ MASTER RECORD\n         USING $SAVEBEG,R2         BASE REG FOR CHECKPOINT\n         CLC   $HASPID,=CL4'JES2'  IS IT VALID HCT?\n         BNE   IT$DIE2             NO, STOP HERE\n         SPACE 1\n*---     FIND KIT AREA IN MASTER RECORD                            ---*\n         SPACE 1\n         LH    R1,$QSEMAX          # OF QSE'S\n         MH    R1,=Y(QSELEN)       * LENGTH OF EACH QSE\n         LA    R3,$SAVEEND(R1)     @ OF CKPT EXT. INFO IN M.R.\n         ST    R3,QCJQEXA          @ OF JQE EXTENSIONS\n         AH    R3,$MAXEXSZ         MAX. SIZE OF EXTENSION\n         LA    R0,DASEXLEN         COMPUTE\n         MH    R0,$SPOLNUM           THE DAS EXTENSION\n         ALR   R3,R0                   AREAS LENGTH\n         ST    R3,IT#KITF          SAVE @ FIRST KIT\n         LH    R0,=Y(KITLNGTH)     COMPUTE\n         MH    R0,=Y(NCTETENT-1)     THE\n         ALR   R3,R0                   @ OF LAST KIT\n         ST    R3,IT#KITL          SAVE @ OF LAST KIT\n         SPACE 1\n*---     FIND DAS TABLE BLOCK #; # OF BLOCKS                       ---*\n         SPACE 1\n         L     R0,=CL4'DAS '       ID FOR DAS'S\n         BAS   R14,IT$KITFD        SEARCH KIT FOR DAS SLOT\n         B     IT$DIE3             BRANCH IF SYSTEM HAS NO DAS'S\n         USING KIT,R1\n         LH    R14,KITRECN         # OF BLOCKS OF DAS'S\n         ST    R14,QCDASNUM        SAVE # BLOCKS OF DAS'S\n         BAS   R14,IT$CKTTR        COMPUTE TTR OF DAS'S\n         DROP  R1\n         ST    R1,QCDASTTR         SAVE TTR OF DAS'S\n         SPACE 1\n*---     FIND JQE TABLE BLOCK #; # OF BLOCKS                       ---*\n         SPACE 1\n         L     R0,=CL4'JQE '       ID FOR JQE'S\n         BAS   R14,IT$KITFD        SEARCH KIT FOR JQE SLOT\n         B     IT$DIE4             BRANCH IF SYSTEM HAS NO JQE'S\n         USING KIT,R1\n         LH    R6,KITRECN          # OF BLOCKS OF JQE'S\n         ST    R6,QCJQENUM         SAVE # BLOCKS OF JQE'S\n         BAS   R14,IT$CKTTR        COMPUTE TTR OF JQE'S\n         DROP  R1\n         ST    R1,QCJQETTR         SAVE TTR OF JQE'S\n         SPACE 1\n*---     FIND JOE TABLE BLOCK #; # OF BLOCKS                       ---*\n         SPACE 1\n         L     R0,=CL4'JOE '       ID FOR JOE'S\n         BAS   R14,IT$KITFD        SEARCH KIT FOR JOE SLOT\n         B     IT$DIE5             BRANCH IF SYSTEM HAS NO JOE'S\n         USING KIT,R1\n         LH    R3,KITRECN          # OF BLOCKS OF JOE'S\n         ST    R3,QCJOENUM         SAVE # OF BLOCKS OF JOE'S\n         BAS   R14,IT$CKTTR        COMPUTE TTR OF JOE'S\n         DROP  R1\n         ST    R1,QCJOETTR         SAVE TTR OF JOE'S\n         SPACE 1\n*---     SAVE ALL SYSTEM ID'S IN COMPLEX                           ---*\n         SPACE 1\n         LH    R0,$QSEMAX          NUMBER OF QSE'S\n         LA    R1,QSYSID           OUTPUT @ FOR SYSTEM ID'S\n         LA    R15,$SAVEEND        @ 1ST QSE\n         USING QSE,R15\nIT$QSELP MVC   0(L'QSESID,R1),QSESID    SAVE SYSTEM ID\n         TM    QSESTAT,QSELAST     LAST QSE?\n         BO    *+L'*+12            YES\n         LA    R1,L'QSYSID(,R1)\n         LA    R15,QSELEN(,R15)\n         BCT   R0,IT$QSELP\n         DROP  R15\n         SPACE 1\n*---     COMPUTE HASPACE(S) BUFFER SIZE                            ---*\n         SPACE 1\n         LH    R5,$BUFSIZE         BLKSIZE FOR HASPACE(S)\n         STH   R5,HASPACE+(DCBBLKSI-IHADCB)  STORE IN DCB\n         STH   R5,HDECB2+(DECLNGTH-DECB)     STORE IN DECB\n         LA    R5,63(R5)           PREPARE TO ROUND\n         N     R5,=F'-64'          ROUND TO 64 BYTE BOUNDARY\n         SPACE 1\n*---     GETMAIN BUFFERS FOR HASPCKPT AND HASPACE(S)               ---*\n         SPACE 1\n         L     R6,$MASTERL         LENGTH OF MASTER RECORD\n         LA    R6,4095(,R6)        ROUND UP TO 4K BOUNDARY\n         N     R6,=F'-4096'\n         L     R7,QCJQENUM         # OF JQE CKPT BLOCKS\n         SLL   R7,12               LENGTH OF JQE CKPT AREA\n         L     R8,QCJOENUM         # OF JOE CKPT BLOCKS\n         SLL   R8,12               LENGTH OF JOE CKPT AREA\n         LR    R14,R5              HASPACE(S) BUFFER SIZE\n         MH    R14,=H'3'           3 BUFFERS\n         AR    R14,R6              + ROUNDED MASTER RECORD\n         AR    R14,R7              + JQE CKPT AREA\n         AR    R14,R8              + JOE CKPT AREA\n         LA    R4,256(,R14)        + SLOP\n         LA    R4,7(R4)            ROUND TO 8 BYTE BOUNDARY\n         SRL   R4,3\n         SLL   R4,3\n         ST    R4,QFRSZ3           STORE LENGTH FOR FREE\n         GETMAIN R,LV=(R4),SP=1    GET STORAGE FOR BUFFERS\n         ST    R1,QCMSA            @ MASTER CKPT RECORD\n         ST    R1,QFRAR3           STORE ADDRESS FOR FREE\n         AR    R1,R6               + ROUNDED LENGTH MASTER CKPT RECORD\n         ST    R1,QCJQEA           @ JQE CKPT INFO\n         LA    R15,BFPLEN(,R1)     BUMP PAST BUFFER ID\n         ST    R15,QCJQEWA         @ JQE CKPT INFO (BASE TO OFFSET)\n         AR    R1,R7               + LENGTH OF JQE CKPT INFO\n         ST    R1,QCJOTA           @ JOE CKPT INFO\n         LA    R15,BFPLEN(,R1)     BUMP PAST BUFFER ID\n         ST    R15,QCJOTWA         @ JOE CKPT INFO (BASE TO OFFSET)\n         AR    R1,R8               + LENGTH OF JOE CKPT INFO\n         ST    R1,QCJCTA           @ JCT BUFFER\n         AR    R1,R5               + SPOOL BUFFER SIZE\n         ST    R1,QCIOTA           @ IOT BUFFER\n         AR    R1,R5               + SPOOL BUFFER SIZE\n         ST    R1,QCBLKA           @ DATA BUFFER BLOCK\n         LA    R1,$JQHEADS-$SAVEBEG OFFSET TO JQE QUEUES IN MASTER REC\n         A     R1,QCMSA            + @ MASTER RECORD\n         ST    R1,QCJQHEAD         @ JQE'S QUEUES HEADS\n         SPACE 1\n*---     ALLOCATE AND OPEN HASPACE(S)                              ---*\n         SPACE 1\n         AR    R6,R2               USE TABLE AREA AFTER CHECKPOINT\n         ST    R6,QCDASA           AS IOAREA TO READ IN DAS BLOCKS\n         OI    SWCKPT,SWCKPTDA     SET DAS REQUEST ONLY\n         QCALL CKPT                READ DAS BLOCKS\n         LA    R3,BFPLEN(,R6)      BUMP PAST BUFFER ID\n         USING DAS,R3              SET ADDRESSING\n         LA    R4,DSNSPACE         DSNAME FOR ALLOCATE\n         ST    R4,DAALPDSN\n         LH    R4,$SPOLNUM         NUMBER OF SPOOL VOLUMES\n         STH   R4,QSPOLNUM\n         LA    R7,QCDCBL           LENGTH OF HASPACE DCB\n         MR    R6,R4               COMPUTE LENGTH OF DCB POOL\n         LR    R6,R4\n         SLL   R6,2                COMPUTE LENGTH OF A LIST\n         AR    R7,R6               + OPEN LIST SPACE\n         AR    R7,R6               + DCB ADDR LIST SPACE\n         AR    R7,R6               + # TRKS/CYL LIST SPACE\n         LA    R7,7(R7)            ROUND TO 8 BYTE BOUNDARY\n         SRL   R7,3\n         SLL   R7,3\n         ST    R7,QFRSZ4           STORE LENGTH FOR FREE\n         GETMAIN R,LV=(R7),SP=1    GET SPACE FOR DCB POOL\n         ST    R1,QFRAR4           STORE ADDRESS FOR FREE\n         LR    R8,R1               @ OF OPEN LIST\n         ST    R8,QCSPOPNL         SAVE ADDR OF OPEN LIST\n         LA    R7,0(R8,R6)         @ OF DCB ADDR LIST\n         ST    R7,QCSPDCBP         SAVE ADDR OF DCB ADDR LIST\n         AR    R7,R6               @ OF # TRKS/CYL LIST\n         ST    R7,QCSPNMTC         SAVE ADDR OF # TRKS/CYL LIST\n         AR    R7,R6               @ OF DCB POOL\n         XR    R6,R6               ACTUAL NUMBER OF SPOOL VOLUMES\n         MVI   DAIRFLAG,DFALLOC+DFABORT REQUEST ALLOCATE FUNCTION\nIT$SP1   TM    DASFLAG,DASEXSTS    DOES VOLUME EXIST?\n         BZ    IT$SP2              NO, TRY NEXT\n         TM    DASFLAG2,DASINACT   IS IT INACTIVE?\n         BO    IT$SP2              YES, TRY NEXT\n         LH    R15,DASNOTGE        # OF TRACKS IN EXTENT\n         A     R15,QCTNUMTG        COMPUTE ACTIVE VOLUMES\n         ST    R15,QCTNUMTG          TRACK GROUPS COUNT\n         MVC   DAALUNIT,=CL8'SYSALLDA'  UNIT NAME FOR ALLOC\n         MVC   DAALSER(L'DASVOLID),DASVOLID  VOLSER FOR ALLOC\n         QCALL ALLOCATE            ALLOCATE IT\n         MVC   0(QCDCBL,R7),HASPACE     MOVE PATTERN DCB TO POOL\n         MVC   DCBDDNAM-IHADCB(L'DAALDDN,R7),DAALDDN\n*                                  UPDATE THE DDNAME\n         ST    R7,0(R8)            STORE DCB ADDR IN OPEN LIST\n         DEVTYPE DCBDDNAM-IHADCB(,R7),IT#DEVTB,DEVTAB,RPS\n*                                  GET HASPACE DEV INFO\n         LR    R15,R6              DCB # TO R15 (ORIGIN 0)\n         SLL   R15,2               * 4 FOR OFFSET INTO QCSPDCBP\n         L     R14,QCSPDCBP\n         ST    R7,0(R14,R15)       SAVE DCB ADDR FOR MTTR CONVERT\n         LH    R0,IT#DEVTB+10      # OF TRACKS / CYLINDER\n         L     R14,QCSPNMTC\n         ST    R0,0(R14,R15)       SAVE # TRKS/CYL FOR THIS HASPACE\n         LA    R7,QCDCBL(R7)       INCREMENT TO NEXT DCB\n         LA    R8,4(R8)            NEXT ENTRY IN OPEN LIST\nIT$SP2   LA    R3,DASSIZ(R3)       NEXT VOLUME\n         DROP  R3                  KILL ADDRESSABILITY\n         LA    R6,1(R6)            INCREASE COUNT BY ONE\n         BCT   R4,IT$SP1           BRANCH IF MORE VOLUMES\n         SH    R8,=H'4'            WE ARE ONE TOO FAR\n         OI    0(R8),X'80'         MARK END OF OPEN LIST\n         L     R1,QCSPOPNL\n         OPEN  MF=(E,(1))          OPEN HASPACE(S)\n         L     R2,QCSPOPNL\nIT$SP3   L     R3,0(R2)            DCB ADDRESS\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN  OPEN OK?\n         BZ    IT$DIE6             NO, OPEN ERROR\n         TM    0(R2),X'80'         END OF OPEN LIST?\n         BO    *+L'*+8             YES\n         LA    R2,4(R2)            NEXT ENTRY IN OPEN LIST\n         B     IT$SP3\n         QSTOP\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        IT$KITFD - FIND SELECTED KIT                                 *\n*                                                                     *\n*        ENTRY : R0  - CHAR ID STRING (CL4 IN REG)                    *\n*                R14 - RETURN ADDRESS                                 *\n*                                                                     *\n*        EXIT :  R1 - @ OF KIT (IF RETURN 4(,R14); ELSE NOT FOUND)    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nIT$KITFD L     R1,IT#KITF          @ FIRST KIT\n         USING KIT,R1\nIT$KITFL CL    R0,KITID\n         BE    4(,R14)             BRANCH IF SELECTED KIT FOUND\n         LA    R1,KITLNGTH(,R1)    @ NEXT KIT IF ANY\n         C     R1,IT#KITL          @ LAST KIT\n         BNH   IT$KITFL            BRANCH IF WAS NOT LAST KIT\n         BR    R14                 BRANCH IF KIT NOT FOUND\n         DROP  R1                  (KIT DSECT)\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        IT$CKTTR - COMPUTE CKPT TTR OF GROUP OF BLOCKS FROM KITORG   *\n*                                                                     *\n*        ENTRY : R1  - @ KIT DSECT                                    *\n*                R14 - RETURN ADDRESS                                 *\n*                                                                     *\n*        EXIT :  R1  - TTR0 OF THIS GROUP ON CKPT                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\n         USING KIT,R1\nIT$CKTTR L     R1,KITORG           GET ORIGIN IN BYTES OF THIS GROUP\n         DROP  R1\n         SRL   R1,12               ORG TO # OF BLOCKS\n         XR    R0,R0\n         LTR   R1,R1\n         BZ    *+L'*+10\n         D     R0,IT#CKRT          / # 4K BLOCKS/TRK ON CKPT DEVICE\n         SLL   R1,8                POSITION TT IN R1\n         OR    R1,R0               BUILD TTR IN R1\n         AL    R1,=A(X'00000101')  SKIP 1ST TRK/RECORD ORIGIN 1\n         SLL   R1,8                NOW TTR0\n         BR    R14\n         EJECT\n*---------------------------------------------------------------------*\n*        FORCE AN ABEND U.... FOR ANALYSIS                            *\n*---------------------------------------------------------------------*\n         SPACE 1\nIT$DIE1  LA    R1,1                HASPCKPT OPEN ERROR ---------- U-001\n         B     CRASHIN\nIT$DIE2  LA    R1,2                NOT JES2 HCT ----------------- U-002\n         B     CRASHIN\nIT$DIE3  LA    R1,3                NO DAS'S QUEUE --------------- U-003\n         B     CRASHIN\nIT$DIE4  LA    R1,4                NO JQE'S QUEUE --------------- U-004\n         B     CRASHIN\nIT$DIE5  LA    R1,5                NO JOE'S QUEUE --------------- U-005\n         B     CRASHIN\nIT$DIE6  LA    R1,6                HASPACE(S) OPEN ERROR -------- U-006\nCRASHIN  ABEND (1),DUMP\n         SPACE 1\nOCBUF    OC    0(*-*,R1),QBLANK    * EXECUTED * CMD TO UPPER CASE\nMVCBUF   MVC   QDREPLY(*-*),0(R1)  * EXECUTED * CMD TO REPLY BUFFER\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R2,R8,R9,R11,R12\n TITLE '--- QUEUE/SP -- ALLOCATE -- DATA-SET ALLOCATION ROUTINE ---'\nALLOCATE QSTART\n         L     R10,QVCKPT          @ OF DAIR WORK AREAS\n         USING QCKPT,R10\n         SPACE 1\n*---     DETERMINE REQUESTED FUNCTION                              ---*\n         SPACE 1\n         TM    DAIRFLAG,DFALLOC    IS THE FUNCTION ALLOCATE?\n         BO    ALLOC               YES, DO IT\n         TM    DAIRFLAG,DFFREE     IS THE FUNCTION FREE?\n         BZ    ALC$STOP            NO, PRETEND LIKE WE DID IT\n         SPACE 1\n*---     FREE DDNAME(W)                                            ---*\n         SPACE 1\n         XC    DAFRDARC(L'DAFRDARC+L'DAFRCTRC),DAFRDARC\n         LA    R1,DAFRCD           LOAD ADDR OF FREE PARM LIST\n         BAS   R2,CALLDAIR         CALL DAIR\n         B     ALC$STOP            RETURN TO CALLER\n         SPACE 1\n*---     ALLOCATE DDNAME(W) DSNAME(X) SHR UNIT(Y) VOLUME(Z)        ---*\n         SPACE 1\nALLOC    MVC   DAALDDN,QBLANK      BLANK THE DDNAME AREA\n         XC    DAALDARC(L'DAALDARC+L'DAALCTRC),DAALDARC\n         LA    R1,DAALCD           LOAD ADDR OF ALLOC PARM LIST\n         BAS   R2,CALLDAIR         CALL DAIR - ALLOC THE DATA-SET\n         SPACE 1\n*---     RETURN TO CALLER                                          ---*\n         SPACE 1\nALC$STOP QSTOP\n         SPACE 1\n*---     CALL DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR)          ---*\n         SPACE 1\nCALLDAIR ST    R1,DAPLDAPB         SET PARM LIST ADDR IN CALL LIST\n         XC    DAIRECB,DAIRECB     CLEAR ECB\n         CALLTSSR EP=IKJDAIR,MF=(E,DAPLUPT)\n         LTR   R15,R15             IS RETURN CODE ZERO?\n         BZR   R2                  YES, RETURN\n         CH    R15,=H'28'          IS DATA-SET ALREADY FREE?\n         BER   R2                  YES, RETURN\n         TM    DAIRFLAG,DFABORT    ABORT REQUESTED?\n         BO    DAIRFAIL            YES, DIAGNOSE FAILURE\n         MVC   QDMSG(31),=CL31'---> UNABLE TO XXXX DATA-SET : '\n         TM    DAIRFLAG,DFALLOC    IS THE FUNCTION ALLOCATE?\n         BZ    *+L'*+10            NO\n         MVC   QDMSG+15(4),=CL4'ALL.'   YES, SAY ALLOCATE\n         B     *+L'*+6\n         MVC   QDMSG+15(4),=CL4'FREE'   SAY FREE\n         MVC   QDMSG+31(9),=CL9'RC=0000, '\n         MVC   QDMSG+40(14),=CL14'DARC=X''0000'', '\n         MVC   QDMSG+54(13),=CL13'CTRC=X''0000''.'\n         CVD   R15,DAIRDWD         DISPLAY RC\n         UNPK  DAIRDWD(5),DAIRDWD+5(3)\n         OI    DAIRDWD+4,C'0'\n         MVC   QDMSG+34(4),DAIRDWD+1\n         L     R1,DAPLDAPB\n         MVC   DAIRDWD+6(2),4(R1)  DISPLAY DARC\n         UNPK  DAIRDWD(5),DAIRDWD+6(3)\n         TR    DAIRDWD(4),HEXTAB-X'F0'\n         MVC   QDMSG+47(4),DAIRDWD\n         MVC   DAIRDWD+6(2),6(R1)  DISPLAY CTRC\n         UNPK  DAIRDWD(5),DAIRDWD+6(3)\n         TR    DAIRDWD(4),HEXTAB-X'F0'\n         MVC   QDMSG+61(4),DAIRDWD\n         LA    R1,QDMSG            ERROR MESSAGE\n         LA    R0,67               ERROR MESSAGE LENGTH\n         QTILT ,                   BACK WITH ERROR MESSAGE\n         SPACE 1\n*---     DAIR FAILURE PROCESSING                                   ---*\n         SPACE 1\nDAIRFAIL ST    R15,DFRETC          STORE RETURN CODE\n         MVC   QDSCREEN(RESETL),RESET   SET CLEAR SEQUENCE\n         TM    SZSWTCH,SCRRS       WAS SCREEN SIZE CHANGED?\n         BZ    ENDFAIL             BRANCH IF NOT\n         STSIZE SIZELOC=SZLINE,LINELOC=SZSCRN    RESTORE\n         $FS   CC=EWA,MF=(I,QDSCREEN)\nENDFAIL  TPUT  QDSCREEN,RESETL,FULLSCR,,HOLD CLEAR THE SCREEN\n         STFSMODE  OFF             TELL VTAM WE'RE DONE\n         LA    R15,DFDASW          PREPARE DAIR FAILURE LIST\n         ST    R15,DFIDP\n         LA    R15,DFZERO\n         ST    R15,DFJEFF02\n         LA    R15,DFRETC\n         ST    R15,DFRCP\n         LA    R15,DAPLUPT\n         ST    R15,DFDAPLP\n         LA    R1,DFDAPLP\n         LINK  EP=IKJEFF18         ERROR MESSAGE ROUTINE\n         ST    R15,DFZERO          KEEP CC IN SAD\n         TPUT  MESSAGE0,L'MESSAGE0 TELL THEM A SAD STORY\n         L     R1,ATSOX            GET TSO WORK AREA ADDRESS\n         LTR   R1,R1               WAS ACQUIRED?\n         BZ    CRASHAL             NO, SKIP FREE\n         LA    R0,TSOXEQL          LENGTH FOR FREEMAIN\n         FREEMAIN R,LV=(0),A=(1)   FREE WORKING STORAGE\nCRASHAL  ABEND 10,DUMP             DAIR FAILURE ----------------- U-010\n         SPACE 1\nMESSAGE0 DC    C'A MAJOR DISASTER HAS OCCURRED IN DAIR PROCESSING.'\nRESET    $FS   CC=EW,WCC=(AL,KBR,RMDT),SBA=(24,79),MF=L\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SF=(INT,IC),MF=L\nRESETL   EQU   *-RESET\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R10,R11,R12\n         TITLE '--- QUEUE/SP -- TILT -- ERROR MESSAGE ROUTINE ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n* TILT - ERROR MESSAGE ROUTINE                                        *\n*                                                                     *\n*        ENTRY : R0  - LENGTH OF ERROR MESSAGE                        *\n*                R1  - ADDRESS OF ERROR MESSAGE                       *\n*                R15 - @ TILT                                         *\n*                                                                     *\n*        EXIT : GO BACK TO MAIN MODULE.                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nTILT     QSTART\n         L     R7,QVDSPL           @ DISPLAY WORK AREA\n         USING QDISPLAY,R7\n         NI    QDOVER,255-QAUTCMD  KILL ELIGIBLE AUTOMATIC MODE\n         LR    R2,R1               @ ERROR MSG TEXT\n         LR    R3,R0               LENGTH OF ERROR TEXT\n         LA    R4,QDHLINE          ERROR MSG LINE\n         LA    R5,L'QDHLINE        LENGTH OF ERROR MSG LINE\n         DROP  R7\n         CR    R3,R5               ERROR MSG TOO LONG?\n         BNH   *+L'*+2             BRANCH IF ERROR MSG NOT TOO LONG\n         LR    R3,R5               TRUNCATE ERROR MSG IF TOO LONG\n         ICM   R3,B'1000',=C' '    PAD ERR MSG WITH BLANKS\n         MVCL  R4,R2               MOVE ERROR MSG TO QDHLINE\nTILT$L   QCALL DISPLAY,,0          DISPLAY ERROR MSG\n         QBACK\n         SPACE 1\n         DROP  R11,R12\n TITLE '--- QUEUE/SP -- CKPT -- READ JES2 CHECKPOINT RECORDS ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n* CKPT - READ JES2 CHECKPOINT RECORDS ROUTINE                         *\n*                                                                     *\n*        PROCESSING SELECTED BY SWITCHES (SEE \"SWCKPT\").              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nCKPT     QSTART\n         L     R10,QVCKPT          @ CKPT WORK AREA\n         USING QCKPT,R10\n         TM    SWCKPT,SWCKPTDA     ONLY DAS RECORDS REQUESTED?\n         BO    CKPTDAS             YES, GO DO IT\n         SPACE 1\n*---     REPOSITION AND READ MASTER RECORD                         ---*\n         SPACE 1\n         L     R2,QCMSA            ADDR OF IOAREA CKPT RECS\n         POINT HASPCKPT,QCMSTTR    POINT TO MASTER RECORD\n         READ  HDECB1,SF,,(R2),'S',MF=E READ MASTER RECORD\n         CHECK HDECB1\n         TM    SWCKPT,SWCKPTMR     ONLY M.R. REQUESTED?\n         BZ    CKPTCNT             NO, CONTINUE\n         NI    SWCKPT,255-SWCKPTMR YES, RESET REQUEST\n         B     CKPTEX              EXIT\n         SPACE 1\n*---     REPOSITION AND READ DAS RECORDS                           ---*\n         SPACE 1\nCKPTDAS  NI    SWCKPT,255-SWCKPTDA RESET REQUEST\n         LA    R2,QCDASA           @ PARM FOR CKPTRD\n         BAS   R8,CKPTRD           READ DAS CKPT RECORDS\n         B     CKPTEX              EXIT\n         SPACE 1\n*---     REPOSITION AND READ JQE RECORDS                           ---*\n         SPACE 1\nCKPTCNT  LA    R2,QCJQEA           @ PARM FOR CKPTRD\n         BAS   R8,CKPTRD           READ JQE CKPT RECORDS\n         SPACE 1\n*---     REPOSITION AND READ JOE RECORDS                           ---*\n         SPACE 1\n         LA    R2,QCJOTA           @ PARM FOR CKPTRD\n         BAS   R8,CKPTRD           READ JQE CKPT RECORDS\nCKPTEX   QSTOP\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* CKPTRD - READ CKPT BLOCKS SUBROUTINE                                *\n*                                                                     *\n* ENTRY : R2 = @ +0 - @ BUFFER AREA                                   *\n*                +4 - TTR OF 1ST BLOCK TO READ IN HASPCKPT            *\n*                +8 - NUMBER OF BLOCKS TO READ (EACH 4K)              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nCKPTRD   POINT HASPCKPT,4(,R2)     POINT TO 1ST BLOCK TO READ\n         L     R3,0(,R2)           @ 1ST BUFFER\n         L     R4,8(,R2)           # OF BLOCKS TO READ\n         L     R5,=F'4096'         BLOCK LENGTH\nCKPTRD1  LR    R6,R4               ASSUME CAN READ ALL BLOCKS AT ONCE\n         XR    R0,R0\n         IC    R0,HASPCKPT+(DCBNCP-IHADCB)   GET NCP ALLOWED\n         CR    R6,R0\n         BNH   *+L'*+2\n         LR    R6,R0               LIMIT READ'S TO NCP MAX\n         LR    R2,R6               COPY # OF READ/CHECKS TO DO\n         L     R7,QCDECBPT         @ DECB WORK AREA\nCKPTRD2  MVC   0(HDECB1L,R7),HDECB1     INIT DECB\n         READ  (R7),SF,,(R3),(R5),MF=E  START A READ\n         AR    R3,R5               BUMP READ BUFFER PTR\n         LA    R7,HDECB1L(,R7)     BUMP DECB PTR\n         BCT   R2,CKPTRD2\n         LR    R2,R6               # OF READS JUST ISSUED\n         L     R7,QCDECBPT         @ DECB WORK AREA\nCKPTRD3  CHECK (R7)\n         LA    R7,HDECB1L(,R7)     BUMP DECB PTR\n         BCT   R2,CKPTRD3\n         SR    R4,R6               DCR # BLOCKS JUST READ/CHECKED\n         BNZ   CKPTRD1\n         BR    R8                  RETURN IF ALL DONE\n         DROP  R10\n         SPACE 1\n         LTORG\n TITLE '--- QUEUE/SP -- READSPC -- READ A BLOCK FROM HASPACE(S) ---'\nREADSPC  QSTART\n         L     R10,QVCKPT          @ CKPT WORK AREA\n         USING QCKPT,R10\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CONVERT MTTR TO MBBCCHHR                                     *\n*                                                                     *\n*        NOTE - THE INPUT TO THIS ROUTINE IS AS FOLLOWS :             *\n*               QCTRAK CONTAINS THE MTTR                              *\n*               R1 CONTAINS THE IOAREA ADDRESS                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\n         LR    R2,R1               MOVE IOAREA ADDR TO R2\n         ZIC   R3,QCTRAKM          RELATIVE DCB NUMBER\n         CH    R3,QSPOLNUM         HIGHER THAN MAX POSSIBLE SPOOLS?\n         BNL   RS$TILT             YES, ERROR, IT IS TOO LARGE\n         SLL   R3,2                MULTIPLY BY 4\n         MVC   QCDADR,QCTRAKR      MOVE RECORD NUMBER\n         MVC   QCDADHH,QCTRAKTT    MOVE TRACK TO A HALFWORD BOUND\n         LH    R5,QCDADHH          LOAD RELATIVE TRACK NUMBER\n         L     R14,QCSPNMTC\n         L     R15,0(R14,R3)       # TRKS/CYL FOR THIS HASPACE\n         LTR   R15,R15             NONE?\n         BZ    RS$DIV              YES, ERROR, BAD MTTR\n         XR    R4,R4               CLEAR FOR DIVIDE\n         DR    R5-1,R15            TT/(TRKS/CYL)-> TO TRK AND CYL\n         STH   R4,QCDADHH          STORE HEAD NUMBER\n         STH   R5,QCDADCC          STORE CYLINDER NUMBER\n         L     R14,QCSPDCBP\n         L     R3,0(R14,R3)        DCB ADDRESS\n         LTR   R3,R3               NONE?\n         BZ    RS$TILT             YES, ERROR, BAD MTTR (NO DCB)\n         USING IHADCB,R3\n         CLC   =C'XB',QSUBNAME     IS THIS HEXBLK?\n         BNE   *+L'*+6             NO, SKIP\n         MVC   DCBSYNAD,=A(HEXBLKER)    YES, SET SYNAD ADDRESS\n         READ  HDECB2,DI,(R3),(R2),MF=E\n         CHECK HDECB2\n         MVC   DCBSYNAD,=A(1)      RESTORE NO SYNAD ADDRESS\n         DROP  R3\nRS$EXIT  QSTOP\nRS$DIV   CLC   =C'XB',QSUBNAME     IS THIS HEXBLK?\n         BNE   RS$TILT             NO, GO BLOW UP NORMALLY\n         MVI   QSYNADFL,15         INDICATE ZERO DIVIDE\n         B     RS$EXIT\nRS$TILT  MVC   QDMSG(19),=CL19'*** INVALID MTTR : '\n         UNPK  QDMSG+19(9),QCTRAK(5)\n         TR    QDMSG+19(8),HEXTAB-X'F0'\n         MVC   QDMSG+27(4),=CL4' ***'\n         LA    R1,QDMSG\n         LA    R0,31\n         QTILT\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R10,R11,R12\n TITLE '--- QUEUE/SP -- PARSE -- COMMAND LINE PARSE ROUTINE ---'\nPARSE    QSTART\n         L     R10,QVDSPL          LOAD BASE REG\n         USING QDISPLAY,R10        BASE REG FOR DISPLAY WORK AREA\n         NI    QDFREQ,255-QDFSC-QDFSV-QDFRS\n         SPACE 1\n*---     PARSE SUB-COMMAND NAME                                    ---*\n         SPACE 1\n         LH    R2,QDRLNG           LENGTH OF REPLY LINE\n         OC    QDREPLY,QBLANK      TRANSLATE TO UPPER CASE\n         CLC   QDREPLY,QBLANK      IS THE ENTIRE REPLY BLANK?\n         BE    LOOKUP              YES, DO LOOKUP\n         MVC   P#OFFSET(4),=F'0'   ZERO THE OFFSET AND LENGTH\n         MVC   FIELD,QBLANK        BLANK THE WORK FIELD\n         MVC   QOFF0(12),P#OFFSET  INITIALIZE FIRST FIELD\n         MVC   QOFF1(QOFFLR),QOFF0 INITIALIZE NEXT FIELDS\n         LA    R6,QOFF4+12         ADDR PAST LAST FIELD\n         LA    R5,QOFF0            ADDR OF FIRST SET OF FIELDS\n         LA    R3,QDREPLY          FIRST BYTE OF REPLY LINE\nNEXTFD   LA    R4,FIELD            FIRST BYTE OF WORK FIELD\nBLANK    CLI   0(R3),C' '          IS THIS BYTE BLANK?\n         BNE   P$FIRST             NO, START OF FIELD\n         LA    R3,1(R3)            YES, SKIP IT\n         BCT   R2,BLANK            TRY NEXT BYTE\n         B     EMPTY               END OF REPLY LINE\nP$FIRST  LH    R1,QDRLNG           REPLY LENGTH\n         SR    R1,R2               COMPUTE OFFSET TO FIELD START\n         STH   R1,P#OFFSET         STORE OFFSET\n         LR    R1,R2               SAVE COUNT OF REMAINING BYTES\n         LA    R0,L'FIELD          PREVENT TOO LONG TEXT MOVE\n         B     CHAREX              CONTINUE\nPARSE$LP CLI   0(R3),C' '          IS THIS BYTE BLANK?\n         BE    LASTCH              YES, END OF FIELD\n         LTR   R0,R0               NO, CAN BE MOVED?\n         BZ    P$SKIP              NO\nCHAREX   MVC   0(1,R4),0(R3)       MOVE BYTE TO SUB-NAME\n         LA    R4,1(,R4)           INCREMENT\n         BCTR  R0,0                DECREMENT\nP$SKIP   LA    R3,1(,R3)           INCREMENT\n         BCT   R2,PARSE$LP         TRY NEXT BYTE\nLASTCH   SR    R1,R2               COMPUTE FIELD LENGTH\n         CH    R1,=H'8'            IS LENGTH GREATER THAN 8?\n         BNH   *+L'*+4             NO, USE IT\n         LA    R1,8                YES, USE LENGTH OF EIGHT\n         STH   R1,LENGTH           STORE FIELD LENGTH\nEMPTY    MVC   0(12,R5),P#OFFSET   MOVE FIELD TO QCOMMON\n         LTR   R2,R2               IS THE REMAINING LENGTH ZERO?\n         BZ    LOOKUP              YES, DO THE TABLE LOOKUP\n         MVC   P#OFFSET(4),=F'0'   ZERO OUT OFFSET AND LENGTH\n         MVC   FIELD,QBLANK        BLANK THE WORK FIELD\n         LA    R5,12(R5)           INCREMENT TO NEXT FIELD\n         CR    R5,R6               WAS THAT THE LAST FIELD?\n         BL    NEXTFD              NO, PROCESS NEXT FIELD\n         SPACE 1\n*---     LOOK UP THE MODULE ADDRESS FOR THE SUB-COMMAND            ---*\n         SPACE 1\nLOOKUP   CLI   QSUBNAME,C'X'       IS THIS A PRIVILEGED OPERATION?\n         BE    SECRET              YES, CHECK FOR PASSWORD\nLOOKUP2  LA    R2,P$TABLE          START OF SUB-COMMANDS TABLE\nNEXT     CLC   0(2,R2),QSUBNAME    COMPARE FIRST TWO CHARACTERS\n         BE    P$FOUND             THIS IS THE ONE\n         LA    R2,L'P$TABLE(R2)    NEXT ENTRY\n         CLI   0(R2),X'FF'         IS THIS THE END OF TABLE?\n         BNE   NEXT                NO, TRY NEXT ENTRY\n         LA    R2,P$TBUNK          UNKNOWN SUB-COMMAND\nP$FOUND  MVC   QCODE(5),3(R2)      SUBCMD CODE AND COMMAND ADDRESS\n         TM    2(R2),FLJID         IS PARM1 A <JOBID> ?\n         BZ    P$STOP              NO, SKIP\n         CLC   QPARM1,=CL8'*'      REQUEST PREVIOUS?\n         BE    USE$PREV            YES, DON'T OVERLAY IT\n         CLC   QPARM1,QBLANK       ANOTHER WAY TO DO THAT?\n         BE    USE$PREV            YES, DON'T OVERLAY IT\n         MVC   QJOBID(2+8),QLNG1   SAVE JOBID + LENGTH\nUSE$PREV MVC   QLNG1(2+8),QJOBID   RESTORE PREVIOUS\nP$STOP   QSTOP\n         SPACE 1\n*---     CHECK AUTHORITY FOR X SUB-COMMANDS                        ---*\n         SPACE 1\nSECRET   CLI   QSUBNAME+1,C'P'     IS THIS THE PASSWORD?\n         BE    PASSWD              YES, CHECK IT\n         CLI   QXAUTH,LV15         IS THIS USER AUTHORIZED?\n         BE    LOOKUP2             YES, PROCESS COMMAND\nBOUNCE   LA    R2,P$TBEND          NO, INVALID\n         B     P$FOUND             CONTINUE\nPASSWD   CLC   QPARM1,=CL8'RESET'  DID THE USER SAY RESET?\n         BNE   PASSWG              NO, LOOK FURTHER\n         CLI   QXAUTH,LV15         IS THIS USER AUTHORIZED?\n         BNE   BOUNCE              NO, REJECT\n         MVC   QXAUTH,SAVAUTH      RESTORE ORIGINAL AUTHORITY\n         QTILT '=== RESET DONE ==='\nPASSWG   CLC   QPARM1,=CL8'PASSWORD'    DID THE USER SAY PASSWORD?\n         BNE   BOUNCE              NO, REJECT\n        PRINT  OFF\n*       THE PURPOSE OF PASSWORDS IS TO ENTER SYSTEM AUTHORITY\n*       UNDER ANY LOGON'ED USER-ID, ALLOWING ME TO ANALYZE\n*       USER'S COMPLAINTS DIRECTLY FROM HIS SESSION (USER CAN'T\n*       SEE IT BECAUSE IT IS UNVIEWABLE).\n*       PASSWORDS ARE : \"ARCHELAS\" AND/OR \"METAXAS\" (MOINIL P.A.).\n        PRINT  ON\n         TPUT  WPASS,WPASSL,FULLSCR\n         XC    RPASS,RPASS\n         LA    R1,RPASS            REPLY ADDRESS\n         TGET  (1),8\n         OC    RPASS(L'RPASS),QBLANK\n         XC    RPASS(4),RPASS+4\n         CLC   RPASS(4),=XL4'040A022A'  IS THE PASSWORD CORRECT?\n         BE    SETALTS             YES\n         CLC   RPASS(4),=XL4'33040181'  IS THE PASSWORD CORRECT?\n         BNE   BOUNCE              NO, REJECT\nSETALTS  MVI   QXAUTH,LV15         AUTHORIZE USER\n         QTILT '=== PASSWORD ACCEPTED ==='\n         SPACE 1\nWPASS    $FS   WCC=(RMDT),SBA=(24,80),MF=L\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SF=(PROT,INT),MF=L\n         $FS   TEXT='ENTER PASSWORD :',MF=L\n         $FS   SF=(DARK,IC),MF=L\n         $FS   SBA=(1,27),SF=(PROT),MF=L\nWPASSL   EQU   *-WPASS\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R10,R11,R12\n         SPACE 1\nFLJID    EQU   X'01'               JOB-ID ARGUMENT\nFLNPR    EQU   X'02'               NO REPROMPT\n         SPACE 1\n         DS    0D                  SUB-COMMANDS TABLE\nP$TABLE  DS    0XL8                ------------------\n         QSCT  +,,20,REPOS                   DOWN\n         QSCT  -,,24,REPOS                   UP\n         QSCT  :,,0,TSOCMD                   TSO COMMAND OR CLIST\n         QSCT  @,,16,REPOS                   POSITION\n         QSCT  AI,,16,SEARCH                 AVAIL INPUT\n         QSCT  AO,,20,SEARCH                 AVAIL OUTPUT\n         QSCT  B,,32,REPOS                   BOTTOM\n         QSCT  BO,,32,REPOS                  BOTTOM\n         QSCT  C,,12,REPOS                   COLUMN\n         QSCT  CO,,12,REPOS                  COLUMN\n         QSCT  D,,20,REPOS                   DOWN\n         QSCT  DA,,4,SEARCH                  DISP ACTIVE\n         QSCT  DD,FLJID,,DDNAME              LIST DDNAMES\n         QSCT  DI,,8,SEARCH                  DISP INPUT\n         QSCT  DJ,FLJID,36,SEARCH            DISP JOB\n         QSCT  DL,,52,SEARCH                 DISP LOCAL OUTPUT\n         QSCT  DO,,12,SEARCH                 DISP OUTPUT\n         QSCT  DR,,56,SEARCH                 DISP REMOTE OUTPUT\n         QSCT  DS,,40,SEARCH                 DISP SYS TASKS\n         QSCT  DT,,32,SEARCH                 DISP TSO USERS\n         QSCT  F,,4,REPOS                    FIND\n         QSCT  FA,,4,REPOS                   FIND ALL\n         QSCT  FI,,4,REPOS                   FIND\n         QSCT  FT,,8,REPOS                   FIND TIME\n         QSCT  H,FLNPR,0,HELP                HELP\n         QSCT  HE,FLNPR,0,HELP               HELP\n         QSCT  HI,,24,SEARCH                 HELD INPUT\n         QSCT  HO,,28,SEARCH                 HELD OUTPUT\n         QSCT  ID,,,IDCMD                    JES2 INITIATORS DISPLAY\n         QSCT  JC,FLJID,,JCL                 LIST JCL\n         QSCT  JL,FLJID,,JLOG                LIST JOBLOG\n         QSCT  JM,FLJID,,JMSG                LIST JOBMSG\n         QSCT  L,FLJID,,LIST                 LIST DATA-SET\n         QSCT  LI,FLJID,,LIST                LIST DATA-SET\n         QSCT  LP,FLJID,,LPDDB               LIST JOB PDDB'S\n         QSCT  P,,,PRINT                     START/STOP HARDCOPY\n         QSCT  PF,FLNPR,4,HELP               SET PF-KEYS\n         QSCT  PL,FLNPR,16,HELP              LOAD PF-KEYS\n         QSCT  PZ,FLNPR,8,HELP               RESET PF-KEYS\n         QSCT  PR,,,PRINT                    START/STOP HARDCOPY\n         QSCT  PS,FLNPR,12,HELP              SAVE PF-KEYS\n         QSCT  QI,,44,SEARCH                 SUMMARY INPUT QUEUES\n         QSCT  QO,,48,SEARCH                 SUMMARY OUTPUT QUEUES\n         QSCT  SA,FLNPR,4,SAVEX              SAVE (IT USE LIST)\n         QSCT  SL,FLJID,,SYSLOG              LIST SYSLOG\n         QSCT  ST,,0,SEARCH                  STATUS\n         QSCT  T,,28,REPOS                   TOP\n         QSCT  TD,,4,TSOCMD                  DISPLAY TSO CMDS RC\n         QSCT  TG,,,TGJU                     TRACK GROUPS JOBS USAGE\n         QSCT  TO,,28,REPOS                  TOP\n         QSCT  TS,,0,TSOCMD                  TSO COMMAND OR CLIST\n         QSCT  U,,24,REPOS                   UP\n         QSCT  UP,,24,REPOS                  UP\n         QSCT  XB,,0,HEXBLK                  DISPLAY HASPACE BLOCK\n         QSCT  XE,FLNPR,4,HEXBLK             SET DUMP EXT. FORMAT\n         QSCT  XJ,FLJID,36,SEARCH            HEX JOE/JQE DISP\n         QSCT  XL,FLJID,,LIST                LIST DATA-SET\n         QSCT  XO,,,XOCMD                    DISPLAY JOES\n         QSCT  XQ,,,XQCMD                    DISPLAY ALL JQES Q\n         QSCT  XT,,,XTCMD                    SOME BLOCKS ...\n         QSCT  YA,FLNPR,0,AUTOM              AUTOMATIC MODE ON\n         QSCT  YT,,,SETTR                    TRACE FACILITIES\n         QSCT  ZA,FLNPR,4,AUTOM              AUTOMATIC MODE OFF\nP$TBEND  QSCT  ,,,CMDINV\nP$TBUNK  QSCT  ,,,CMDUNK\n         TITLE '--- QUEUE/SP -- DISPLAY -- 3270 DISPLAY ROUTINE ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n* DISPLAY - 3270 DISPLAY SUBROUTINE                                   *\n*                                                                     *\n*        ENTRY : R1 - @ OF TEXT                                       *\n*                R0 - LENGTH OF TEXT                                  *\n*                                                                     *\n*        EXIT : QDOVER - FLAG SET IF SCREEN OVERFLOW                  *\n*               QDMORE - *MORE*                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nDISPLAY  QSTART\n         USING QDISPLAY,R10\n         L     R10,QVDSPL          @ OF DISPLAY WORK AREA\n         STH   R0,QDMLNG           SET CALLERS LENGTH\n         ST    R1,QDMSGA           AND TEXT ADDRESS\n         SPACE 1\n*---     CHECK FOR ROOM ON SCREEN                                  ---*\n         SPACE 1\n         NI    QDOVER,255-QOVPAGE  RESET INDICATOR\n         MVC   QDMORE,QBLANK       BLANK THE OVERFLOW INDICATOR\n         LH    R4,QDMLNG           LOAD MSG LENGTH\n         CH    R4,=H'1680'         IS MSG LENGTH MORE THAN 1680?\n         BH    RETURN              YES, GO AWAY\n         LTR   R4,R4               IS MSG LENGTH ZERO?\n         BZ    WRTSCR              YES, WRITE SCREEN\n         MVC   QDMORE,=C'*MORE*'   INDICATE SCREEN OVERFLOW\n         AH    R4,QDNEXT           ADD CURRENT LOCATION ON SCREEN\n         CH    R4,=H'1680'         IS THERE ROOM ON THE SCREEN?\n         BH    WRTSCR              NO, WRITE SCREEN\n         SPACE 1\n*---     MOVE THE MESSAGE TO THE SCREEN                            ---*\n         SPACE 1\nDSP2     LH    R7,QDMLNG           LOAD MESSAGE LENGTH\n         LTR   R7,R7               IS MESSAGE LENGTH ZERO?\n         BZ    RETURN              YES, RETURN\n         LH    R4,QDNEXT           GET CURRENT SCREEN LINE NUMBER\n         LR    R1,R4               SAVE LINE NUMBER\n         LA    R4,QDLINE1(R4)      LOAD ADDRESS OF NEXT LINE\n         L     R6,QDMSGA           LOAD ADDR OF MESSAGE\n         LA    R5,80               LENGTH MUST BE MULTIPLE OF 80\nDSP3     CR    R5,R7               IS 5 NOT LESS THAN 7?\n         BNL   DSP4                YES, GO DO IT\n         LA    R5,80(,R5)          INCR BY 80\n         B     DSP3                TRY AGAIN\nDSP4     AR    R1,R5               UPDATE LINE NUMBER\n         STH   R1,QDNEXT           STORE LINE NUMBER\n         ICM   R7,B'1000',=C' '    GET PAD CHAR\n         LR    R1,R4               SAVE DESTINATION ADDRESS\n         LR    R0,R5               SAVE DESTINATION LENGTH\n         MVCL  R4,R6               MOVE THE MESSAGE TO THE SCREEN\n         CLC   =A(ENDDATA),QDMSGA  IS THIS THE SPECIAL MESSAGE?\n         BE    RETURN              YES, DON'T TRANSLATE\n         TM    QDOVER,QTSKIP       SKIP TRANSLATE REQUESTED?\n         BZ    DSP5                NO\n         NI    QDOVER,255-QTSKIP   OFF INDICATOR\n         B     DSP6\nDSP5     TR    0(80,R1),D$TABLE    TRANSLATE OUT STRANGE CHARS\n         LA    R1,80(,R1)          -> NEXT SCREEN LINE\n         SH    R0,=H'80'           DECREMENT REMAINING LENGTH\n         BP    DSP5                KEEP TRANSLATING\nDSP6     TM    QDOVER,QPFORCE      FORCE PAGE REQUESTED?\n         BO    WRTSCR              YES, WRITE SCREEN\nRETURN   QSTOP\n         SPACE 1\n*---     WRITE A FULL SCREEN                                       ---*\n         SPACE 1\nWRTSCR   CLC   QDFINAL-L'QBLANK(L'QBLANK),QBLANK\n*                                  LAST PART OF SCREEN BLANK?\n         BNE   NORA                NO, DON'T BOTHER WITH RA\n         LA    R1,QDFINAL-L'QBLANK -> FIRST CHAR TO CHECK\n         BASR  R14,0               SET LOOP ADDR\n         CLI   0(R1),C' '          FIND NON-BLANK?\n         BNE   *+L'*+2             YES, EXIT LOOP\n         BCTR  R1,R14              NO, KEEP LOOKING\n         LA    R2,1(,R1)           POINT PAST LAST CHAR\n         $FS   RA=(1,1,00),MF=(E,(R2))  SET RA TO TOP\n         TM    QDOVER,QAUTOM+QAUTCMD    ELIGIBLE AUTOMATIC MODE?\n         BNO   *+L'*+8             NO\n         TM    QDPRSW,QAUTPIA      PRESERVE INPUT AREA?\n         BO    TPUTK               YES\n         MVC   0(QDSLNG,R2),QDFINAL     SET INPUT MANAGEMENT\n         LA    R2,QDSLNG(R2)       POINT PAST LAST CHAR\nTPUTR    $FS   WCC=(KBR,RMDT),MF=(I,QDSCRWCC)\n         B     TPUT\nNORA     LA    R2,QDPAST           POINT PAST LAST CHAR\n         TM    QDOVER,QAUTOM+QAUTCMD    ELIGIBLE AUTOMATIC MODE?\n         BNO   TPUTR               NO\n         TM    QDPRSW,QAUTPIA      PRESERVE INPUT AREA?\n         BZ    TPUTR               NO\n         LA    R2,QDFINAL          POINT PAST LAST CHAR\n*                                  ADD INPUT MANAGEMENT\nTPUTK    $FS   WCC=(KBR),MF=(I,QDSCRWCC)\nTPUT     LA    R3,QDSCREEN         LOAD ADDRESS OF SCREEN BUFFER\n         TM    SZSWTCH,SCRST+SCRRS FIRST TPUT DONE?\n         BNO   SNDWR               BRANCH IF YES\n         $FS   CC=EW,MF=(I,(R3))   SET ERASE/WRITE\nSNDWR    SR    R2,R3               COMPUTE TPUT LENGTH\n         ICM   R3,B'1000',=X'03'   GET FULLSCREEN FLAG\n         NI    QDPRSW,255-QAUTPIA  RESET\n         TM    QHFREQ,QHCOPY       IS HARDCOPY ACTIVE?\n         BZ    RESHOW              NO\n         TM    QDOVER,QAUTOM+QAUTCMD    ELIGIBLE AUTOMATIC MODE?\n         BO    RESHOW              YES\n         QCALL HCOPY               HARDCOPY SCREEN\nRESHOW   LR    R1,R3               GET THE ADDRESS\n         LR    R0,R2               GET THE LENGTH\n         TPUT  (1),(0),R           WRITE SCREEN\n         TM    SZSWTCH,SCRST+SCRRS FIRST TPUT DONE?\n         BNO   SNDGT               BRANCH IF YES\n         $FS   CC=W,MF=(I,(R3))    RESTORE WRITE\n         NI    SZSWTCH,255-SCRST   SET FIRST TPUT DONE\nSNDGT    XC    PFREPLY,PFREPLY\n         MVC   QDREPLY,QBLANK\n         XC    TIMEVL,TIMEVL       RESET TIME COUNTER\n         TM    QDOVER,QAUTOM+QAUTCMD    ELIGIBLE AUTOMATIC MODE?\n         BO    SAUTOM              YES\n         SPACE 1\n*---     WAIT FOR REPLY                                            ---*\n         SPACE 1\n         TGET  PFREPLY,L'PFREPLY-3,ASIS NORMAL, WAIT FOR REPLY\n         B     ANALRP\n         SPACE 1\n*---     START WAIT TIME AND THEN SEE IF ANY REPLY                 ---*\n         SPACE 1\nSAUTOM   ZEROKEY\n         $NOSWAP QASID\n         ST    R1,SRMCC\n         CLI   SRMCC+3,0\n         BNE   DIAG1\n         STIMER  WAIT,,BINTVL=TIMESC,ERRET=TINTERR\n         $OKSWAP QASID\n         ST    R1,SRMCC\n         RESETKEY\n         CLI   SRMCC+3,0\n         BNE   DIAG2\n         TGET  PFREPLY,L'PFREPLY-3,ASIS,NOWAIT    NO WAIT REPLY\n         LTR   R15,R15             ANY INPUT AVAILABLE?\n         BZ    GETTEXT             YES\n         CH    R15,=H'4'           NORMAL NOWAIT?\n         BNE   GETTEXT             NO\n         L     R1,TIMEVL           UPDATE TIME COUNTER\n         A     R1,TIMESC\n         CL    R1,TIMECT           NEXT PANEL TO SHOW?\n         BNL   NXPANEL             YES\n         ST    R1,TIMEVL\n         B     SAUTOM\nTINTERR  $OKSWAP QASID\n         ST    R1,SRMCC\n         RESETKEY\n         CLI   SRMCC+3,0\n         BNE   DIAG3\n         NI    QDOVER,255-QAUTOM-QAUTCMD     OFF AUTOMATIC MODE\n         OI    QDOVER,QDAMAGE      INDICATE DAMAGED CLOCKS\n         MVC   PFTXT(3),=CL3'ZA'   AUTO OFF\n         LA    R1,L'PFCODE+3\n         B     STENTK\nDIAG1    RESETKEY\n         MVI   PFTXT+9,C'1'\n         B     DIAGZA\nDIAG2    MVI   PFTXT+9,C'2'\n         B     DIAGZA\nDIAG3    MVI   PFTXT+9,C'3'\nDIAGZA   NI    QDOVER,255-QAUTOM-QAUTCMD     OFF AUTOMATIC MODE\n         OI    QDOVER,QDAMAGE      FORCE DAMAGED CLOCKS\n         MVC   PFTXT(9),=CL9'ZA SRMCC'  AUTO OFF + SWAP\n         LA    R1,L'PFCODE+9\n         B     STENTK\nNXPANEL  TM    QXSWXQ,RQTR         TRACE REQUESTED?\n         BZ    GOPANEL             NO\n         L     R1,TIMEVLM\n         A     R1,TIMECT\n         CL    R1,TIMECTM          MAX. TIME REACHED?\n         BL    GOPANEL             NO, CONTINUE\n         QCALL TRACE,1             SNAP. USER CODE 001. -------- ID-001\nGOPANEL  ST    R1,TIMEVLM\n         LA    R1,3\n         OI    QDPRSW,QAUTPIA      PRESERVE INPUT AREA\nSTENTK   MVI   PFCODE,X'7D'        SIMULATE ENTER KEY\n         XR    R15,R15\n         B     ANALRP\nGETTEXT  NI    QDOVER,255-QAUTCMD  KILL ELIGIBILITY\n         XC    TIMEVLM,TIMEVLM\n         SPACE 1\n*---     HANDLE THE REPLY                                          ---*\n         SPACE 1\nANALRP   CLI   PFCODE,X'6E'        PA2? (RESHOW)\n         BE    TCLEARQ             YES, GO FLUSH REST OF INPUT\n         CH    R15,=H'12'          INPUT LONGER THAN BUFFER?\n         BNE   NOCLEAR             NO, CONTINUE\nTCLEARQ  LR    R4,R1               SAVE THE INPUT LENGTH\n         TCLEARQ INPUT             CLEAR THE QUEUE\n         LR    R1,R4               RESTORE THE INPUT LENGTH\n         CLI   PFCODE,X'6E'        PA2? (RESHOW)\n         BE    RESHOW              YES, RE-DISPLAY LAST SCREEN\nNOCLEAR  LA    R4,QDLINE1          LOAD ADDRESS OF FIRST LINE\n         LA    R5,1680             LOAD LENGTH OF SCREEN\n         XR    R6,R6               NO SENDING FIELD NEEDED\n         STH   R6,QDNEXT           STORE ZERO IN LINE NUMBER\n         L     R7,=A(X'40000000')  FILL SCREEN WITH BLANKS\n         MVCL  R4,R6               CLEAR THE SCREEN\n         XC    QDTLINE,QDTLINE     CLEAR INPUT AREA ON SCREEN\n         LA    R6,QDREPLY\n         LA    R7,QDREPLYL         MAX. MOVE INSTR. LENGTH\n         LH    R4,=Y(PFKNO)\n         LA    R5,PFKTAB\nSCANPFK  CLC   PFCODE(1),0(R5)     IS A PF-KEY ENTERED?\n         BE    ENTPFK              YES\n         LA    R5,L'PFKTAB(R5)     NO, LOOK TO NEXT\n         BCT   R4,SCANPFK          LOOP UNTIL NO MORE\n         XR    R5,R5               GO AS 'ENTER' KEY\n         B     ENTKEY\nENTPFK   MVC   QDREPLY(L'PFKTAB-1),1(R5)     MOVE PF-KEY VALUE\n         LA    R5,L'PFKTAB\n         LA    R6,L'PFKTAB(,R6)\n         LR    R7,R6\n         BCTR  R7,0\nCMPPFK   BCTR  R7,0\n         CLI   0(R7),C' '\n         BNE   *+L'*+6\n         BCTR  R6,0\n         BCT   R5,CMPPFK\n         LA    R7,QDREPLYL         MAX. MOVE INSTR. LENGTH\n         SR    R7,R5\nENTKEY   SH    R1,=H'3'\n         BNP   NOTXT\n         SH    R1,=H'3'\n         BNP   NOTXT\n         CLR   R1,R7               CONTROL MOVE LENGTH\n         BNH   *+L'*+2\n         LR    R1,R7               TRUNCATE IF TOO LONG\n         BCT   R1,*+L'*+6\n         MVC   0(*-*,R6),PFTXT     <<EXECUTED>>\n         EX    R1,*-6\n         LA    R5,1(R5,R1)\nNOTXT    STH   R5,QDRLNG           STORE LENGTH OF REPLY\n         TM    QDOVER,QPROMPT      WAS IT A REPROMPT?\n         BZ    NPROMPT             NO\n         NI    QDOVER,255-QPROMPT  RESET IT\n         MVC   QDHLINE,QDHSAVE     RESTORE HEADING\n         LTR   R5,R5               RESPONSE FROM USER?\n         BNZ   INTER               YES, INTERRUPT PROCESSING\n         MVC   QDREPLY,QDPROMPT    NO, SET LAST COMMAND IN REPLY AREA\n         MVC   QDRLNG,QDRLNGP      SET LENGTH\n         B     INTER               SIMULATE RESPONSE FROM USER\nNPROMPT  LTR   R5,R5               RESPONSE FROM USER?\n         BNZ   INTER               YES, INTERRUPT PROCESSING\n         TM    QDPRSW,QRPVCMD      RESTORE SUB-COMMAND REQ?\n         BZ    PROCEED             NO\n         MVC   QDREPLY,QDPROMPT    YES, SET LAST COMMAND IN REPLY AREA\n         MVC   QDRLNG,QDRLNGP      SET LENGTH\nPROCEED  OI    QDOVER,QOVPAGE      INDICATE PAGE OVERFLOW\n         NI    QDPRSW,255-QRPVCMD  RESET EVENTUAL RESTORE REQ\n         TM    QDOVER,QPFORCE      FORCE PAGE REQUESTED?\n         BZ    DSP2                NO, CONTINUE PROCESSING\n         NI    QDOVER,255-QPFORCE  RESET FORCE PAGE INDICATOR\n         B     RETURN\nINTER    NI    QDOVER,255-QPFORCE  RESET FORCE PAGE INDICATOR\n         NI    QDPRSW,255-QRPVCMD  RESET EVENTUAL RESTORE REQ\n         CLI   QDREPLY,C'*'        REPROMPT REQUEST?\n         BE    REPROMPT            YES, DO IT\n         OC    QDREPLY(2),QBLANK   UPPER CASE SUB-COMMAND\n         L     R15,=A(P$TABLE)     START OF SUB-COMMANDS TABLE\nSCTAB    CLC   QDREPLY(2),0(R15)   THIS ONE?\n         BE    TSNPR               YES\n         LA    R15,L'P$TABLE(R15)  NO, NEXT ENTRY\n         CLI   0(R15),X'FF'        IS THIS THE END OF TABLE?\n         BNE   SCTAB               NO, TRY NEXT ENTRY\n         B     SETRP               YES, GO SET TO REPROMPT\nTSNPR    TM    2(R15),FLNPR        NO REPROMPT?\n         BZ    SETRP               NO, GO SET TO REPROMPT\n         OI    QDPRSW,QRPVCMD      YES, SET RESTORE SUB-COMMAND REQ\n         B     RBACK               DON'T SET TO REPROMPT\nSETRP    MVC   QDPROMPT,QDREPLY    SAVE REPLY IN CASE REPROMPT\n         STH   R5,QDRLNGP          SAVE LENGTH FOR REPROMPT\nRBACK    QBACK\nREPROMPT MVC   QDTLINE,QDPROMPT    COPY LAST COMMAND\n         OI    QDOVER,QPROMPT      SIGNAL IT\n         MVC   QDHSAVE,QDHLINE     SAVE HEADING\n         MVC   QDHLINE(L'QDHLINE),QBLANK     CLEAR HEADING\n         B     WRTSCR              RE-DISPLAY THE LAST COMMAND\n         EJECT\n*        TABLE OF PRINTABLE CHARACTERS\n         SPACE 1\nD$TABLE  DC    256C'?'             TRANSLATE ALL GARBAGE TO '?'\n         ORG   D$TABLE+C' '        BLANK\n         DC    C' '\n         ORG   D$TABLE+C'\u00a2'        CENT\n         DC    C'\u00a2.<(+|&&'\n         ORG   D$TABLE+C'!'        EXCLAMATION\n         DC    C'!$*);\u00ac-/'\n         ORG   D$TABLE+C'\u00a6'        BROKEN BAR\n         DC    C'\u00a6,%_>?'\n         ORG   D$TABLE+C'`'        ACCENT GRAVE\n         DC    C'`:#@''=\"'\n         ORG   D$TABLE+C'A'-X'40'\n         DC    X'818283848586878889'\n         ORG   D$TABLE+C'J'-X'40'\n         DC    X'919293949596979899'\n         ORG   D$TABLE+C'S'-X'40'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG   D$TABLE+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   D$TABLE+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   D$TABLE+C'S'\n         DC    C'STUVWXYZ'\n         ORG   D$TABLE+C'0'\n         DC    C'0123456789'\n         ORG   D$TABLE+C'{'        LEFT BRACE\n         DC    C'{'\n         ORG   D$TABLE+C'}'        RIGHT BRACE\n         DC    C'}'\n         ORG   D$TABLE+C'~'        TILDE\n         DC    C'~'\n         ORG   D$TABLE+C'\\'        BACKSLASH\n         DC    C'\\'\n         ORG\n         EJECT\n         LTORG\n         SPACE 1\n         DROP  R10,R11,R12\n         TITLE '--- QUEUE/SP -- TRACE -- SNAP ROUTINE ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n* TRACE - SNAP ROUTINE                                                *\n*                                                                     *\n*        ENTRY : R1  - USER CODE (SNAP ID NUMBER),                    *\n*                      VALID CODE : 1 TO 255 (1 TO 127 = JUST ONCE).  *\n*                R15 - @ SNAP                                         *\n*                                                                     *\n*        NOTE - THE FOLLOWING ALLOCATION IS NEEDED TO OBTAIN          *\n*               THE SNAP DUMP :                                       *\n*                                                                     *\n*                    ALLOC F(SYSSNAP) SYSOUT(A)                       *\n*                                                                     *\n*               OR A PRE-ALLOCATED DATA-SET (THE CHARACTERISTICS      *\n*               WILL BE FORCED RECFM=VBA,BLKSIZE=1632,LRECL=125)      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nTRACE    QSTART\n         L     R10,QVDSPL          @ DISPLAY WORK AREA\n         USING QDISPLAY,R10\n         L     R9,QVSNAP           @ SNAP WORK AREA\n         USING QSNAP,R9\n         TM    QXSWXQ,SKTR         TRACE FILE IN ERROR?\n         BO    TRACE23             YES\n         LTR   R7,R1               TEST AND SAVE ID NUMBER\n         BNP   TRACE24             IGNORE IF ERRONEOUS\n         CH    R1,=H'255'          ID IS VALID RANGE?\n         BNL   TRACE24             IGNORE IF ERRONEOUS\n         XR    R0,R0\n         SLDL  R0,24\n         SRL   R1,24\n         LA    R4,SNAPIDT\n         ALR   R4,R0\n         LA    R3,X'80'\n         SRL   R3,0(R1)\n         EX    R3,TRACET           ID IS ACTIVE?\n         BZ    TRACE10             NO, SKIP\n         LA    R6,SNAPDCB\n         USING IHADCB,R6\n         TM    QXSWXQ,OPTR         TRACE FILE ALREADY OPENED?\n         BO    TRACE3              YES\n         L     R2,#TSTIOT            TIOT POINTER\n         USING TIODSECT,R2\n         XR    R1,R1\nTRACE1   CLC   TIOELNGH(4),=F'0'\n         BE    TRACE21\n         CLC   TIOEDDNM(L'TIOEDDNM),DCBDDNAM\n         BE    TRACE2\n         IC    R1,TIOELNGH\n         ALR   R2,R1\n         B     TRACE1\n         DROP  R2\nTRACE2   OPEN  ((R6),OUTPUT),MF=(E,SNAPOP)\n         TM    DCBOFLGS,DCBOFOPN   OPEN SUCCESSFULL?\n         BZ    TRACE21             NO, OPEN ERROR\n         OI    QXSWXQ,OPTR         SET TRACE FILE OPENED?\n         L     R1,4(R11)           SET LIST\n         L     R1,16(R1)\n         ST    R1,SNAPLST          DISPLAY MODULE START + VERSION\n         LA    R1,32(R1)\n         ST    R1,SNAPLST+4\n         OI    SNAPLST+4,X'80'\n         LA    R1,HDQSP            SET HEADER\n         ST    R1,SNAPHD\n         OI    SNAPHD,X'80'\nTRACE3   SNAP  DCB=(R6),TCB='S',ID=(R7),PDATA=(REGS,SPLS),             1\n               LIST=SNAPLST,STRHDR=SNAPHD,MF=(E,SNAPCTL)\n         LTR   R5,R15              TEST AND SAVE COMPLETION CODE\n         BNZ   TRACE20             BRANCH IF SNAP ERROR\n         CH    R7,=H'128'          IS IT A JUST ONCE ID?\n         BNL   TRACE10             NO\n         XR    R1,R1\n         BCTR  R1,0\n         XR    R1,R3\n         EX    R1,TRACER           OFF TRACE ID\n         OC    SNAPIDT,SNAPIDT     ANY OTHER ONE ACTIVE?\n         BNZ   TRACE10             YES\n         NI    QXSWXQ,255-RQTR     OFF TRACE REQUEST\nTRACE10  XR    R15,R15             SET RC\nTRACEX   QSTOP\nTRACE20  CLOSE ((R6)),MF=(E,SNAPCL)\n         B     TRACE22\n         DROP  R6\nTRACE21  LA    R5,2*16             SET OPEN ERROR (RC = X'20')\nTRACE22  NI    QXSWXQ,255-RQTR-OPTR     OFF TRACE\n         OI    QXSWXQ,SKTR         SET TRACE FILE IN ERROR\n         XC    SNAPIDT,SNAPIDT     OFF ALL TRACE ID'S\n         MVC   QDMSG(L'TRACEM),TRACEM\n         STC   R5,QDMSG+L'TRACEM-5 SET RC IN MSG\n         SRL   R5,4\n         STC   R5,QDMSG+L'TRACEM-6\n         NC    QDMSG+L'TRACEM-6(2),=XL2'0F0F'\n         TR    QDMSG+L'TRACEM-6(2),HEXTAB\n         CVD   R7,FMT@CONV         SET ID NUMBER IN MSG\n         UNPK  QDMSG+13(3),FMT@CONV+6(2)\n         OI    QDMSG+15,C'0'\n         LA    R1,QDMSG\n         LA    R0,L'TRACEM\n         B     TRACE30\nTRACE23  LA    R1,TRACED\n         LA    R0,L'TRACED\n         B     TRACE30\nTRACE24  LA    R1,TRACEI\n         LA    R0,L'TRACEI\nTRACE30  LA    R4,QDLINE1          LOAD ADDRESS OF FIRST LINE\n         LA    R5,1680             LOAD LENGTH OF SCREEN\n         XR    R6,R6               NO SENDING FIELD NEEDED\n         STH   R6,QDNEXT           STORE ZERO IN LINE NUMBER\n         L     R7,=A(X'40000000')  FILL SCREEN WITH BLANKS\n         MVCL  R4,R6               CLEAR THE SCREEN\n         XC    QDTLINE,QDTLINE     CLEAR INPUT AREA ON SCREEN\n         TM    QXSWXQ,NFTR         FULL SCREEN INHIBIT?\n         BO    TRACE31             NO\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         B     TRACE10\nTRACE31  TM    QXSWXQ,MSTR         BACK MESSAGE?\n         BO    TRACE32             YES\n         QTILT\nTRACE32  LA    R15,4               SET RC (R0-R1 MESSAGE PENDING)\n         B     TRACEX\nTRACET   TM    0(R4),*-*           <<EXECUTED>>\nTRACER   NI    0(R4),*-*           <<EXECUTED>>\n         SPACE 1\nTRACEM   DC    C'--- TRACE ID-    REQUESTED, RC =    ---'\nTRACED   DC    C'--- TRACE HAS BEEN DISABLED ---'\nTRACEI   DC    C'--- INVALID TRACE ID REQUESTED ---'\nHDQSP    DC    AL1(L'HDQSPT)\nHDQSPT   DC    C'Q S P - DUMP OF WORK-AREAS (R11 = A.QCOMMON).'\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9,R10,R11,R12\n TITLE '--- QUEUE/SP -- FINDJOB -- LOC. JQE, JCT, IOT BY JOB-ID ---'\nFINDJOB  QSTART\n         USING QCKPT,R10           BASE REG FOR CHECKPT WORK AREA\n         L     R10,QVCKPT          LOAD BASE REG\n         SPACE 1\n*---     DETERMINE IF SEARCH IS BY JOB NUMBER OR JOB NAME          ---*\n         SPACE 1\n         LH    R1,QLNG1            LENGTH OF PARAMETER FIELD\n         SH    R1,=H'1'            IS THE LENGTH ZERO?\n         BM    FJ$TILT             YES, TILT\n         CLI   QPARM1,C'0'         IS THE FIRST CHARACTER NUMERIC?\n         BL    JOBNAME             NO, SEARCH BY JOB NAME\n         LA    R15,QPARM1          POINT TO PARM\n         BAS   R14,QNUMCONV        CONVERT IT\n         BNE   FJ$TILT             TILT IF NOT NUMERIC\n         LR    R5,R15              SAVE THE VALUE\n         SPACE 1\n*---     LOCATE JQE BY JOB NAME                                    ---*\n         SPACE 1\nJOBNAME  L     R2,QCJQHEAD         @ JQE'S QUEUES HEADS\n         LA    R1,$JQTYPES         # OF QUEUES\nNEXTJQT1 L     R3,0(,R2)\nNEXTJQE1 N     R3,=A(X'00FFFFFF')  OFFSET TO JQE\n         BZ    ENDJQE              BRANCH IF END OF QUEUE\n         AL    R3,QCJQEWA          ADD BASE TO OFFSET\n         USING JQE,R3              BASE REG FOR JQE\n         CLI   QPARM1,C'0'         IS SEARCH BY JOB NUMBER?\n         BL    CLCNAME             NO, SEARCH BY JOB NAME\n         CH    R5,JQEJOBNO         IS THIS THE RIGHT JOB NUMBER?\n         BNE   NOMATCH             NO, TRY NEXT JQE\n         B     FJ$FOUND            YES, PROCESS IT\nCLCNAME  CLC   QPARM1,JQEJNAME     IS THIS THE RIGHT JOB NAME?\n         BE    FJ$FOUND            YES, PROCESS IT\nNOMATCH  L     R3,JQENEXT          OFFSET OF NEXT JQE OR 0 MAS/SP3\n         B     NEXTJQE1            LOOP\nENDJQE   LA    R2,$JQHEADL(,R2)    TRY NEXT QUEUE\n         BCT   R1,NEXTJQT1         LOOP IF NOT LAST QUEUE\nFJ$TILT  QTILT '*** JOB NAME OR NUMBER NOT FOUND OR INVALID ***'\n         SPACE 1\n*---     READ JCT AND IOT                                          ---*\n         SPACE 1\nFJ$FOUND ST    R3,QCJQECA          SAVE THE ADDRESS\n         ICM   R1,B'1111',JQETRAK  DISK ADDR OF JCT\n         BZ    FJ$NOJCT            BRANCH IF NO JCT\n         STCM  R1,B'1111',QCTRAK   SET IT FOR READ\n         TM    JQEFLAG3,JQE3SYSD   JQETRAK POINT TO IOT?\n         BO    FJ$SYSDS            YES\n         DROP  R3\n         L     R3,QCJCTA           ADDR OF IOAREA FOR JCT\n         LR    R1,R3               PARM FOR READSPC\n         QCALL READSPC             READ HASPACE\n         USING JCTSTART,R3         BASE REG FOR JCT\n         CLC   JCTID,=CL4'JCT '    IS THIS A JCT?\n         BNE   FJ$JCTER            BRANCH IF NOT VALID JCT\n         MVC   QPJOBID,JCTJBKEY    JOB IDENTIFICATION\n         MVC   QCTRAK,JCTIOT       DISK ADDR OF IOT\n         DROP  R3\n         L     R3,QCIOTA           @ IOT BUFFER AREA\n         LR    R1,R3               PARM FOR READSPC\n         QCALL READSPC             READ IOT\n         USING IOTSTART,R3\n         CLC   IOTID,=CL4'IOT '   IS THIS IOT?\n         BNE   FJ$IOTER           BRANCH IF NOT IOT\n         DROP  R3\nSTOP     QSTOP\nFJ$NOJCT QTILT 'THIS JOB HAS NO JCT OR IOT'\nFJ$SYSDS QTILT 'THIS IS A SYSTEM DS JOB'\nFJ$JCTER QTILT 'INVALID JCT (BAD JCTID)'\nFJ$IOTER QTILT 'INVALID IOT (BAD IOTID)'\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R10,R11,R12\n TITLE '--- QUEUE/SP -- FORMAT -- JQE AND JOE FORMAT ROUTINE ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n* FORMAT : FORMAT JOES OR JQES                                        *\n*          OR DUMP HEX JOES OR JQES                                   *\n*                                                                     *\n*        ENTRY : R1 = 0 FORMAT JQE                                    *\n*                R1 = 4 FORMAT JOE                                    *\n*                R8 = @ JOE (IF JOE FORMAT REQUESTED)                 *\n*                R9 = @ JQE                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nFORMAT   QSTART\n         L     R10,QVDSPL          LOAD BASE REG\n         USING QDISPLAY,R10        BASE REG FOR DISPLAY WORK AREA\n         USING JQE,R9              BASE REG FOR JQE DSECT\n         USING JOE,R8              BASE REG FOR JOE DSECT\n         CLI   QSUBNAME,C'X'       IS THE REQUEST FOR A HEX DUMP?\n         BE    HEXDM               YES\n         MVC   FCLEAR,QBLANK       CLEAR THE PRINT AREA\n         MVC   FQUEUE(1),QCLASS    CLASS NAME\n         CLI   QCLASS,(2+(2*36))\n         BNL   *+L'*+6\n         MVC   FQUEUE,QCLASSE\n         MVC   QDHLINE,FMT#HEAD    REPORT HEADING\n         LA    R15,JOEROUT         POINT TO REMOTE ID\n         LTR   R1,R1               JQE OR JOE?\n         BNZ   FMT$ROUT            JOE\n         LA    R15,JQEPUNRT        POINT TO PUNCH ROUTE FIELD\n         L     R14,QCMSA           @ MASTER CKPT RECORD\n         LH    R14,$NODEID-$SAVEBEG(,R14)    THIS NODE ID\n         SLL   R14,16              MAKE LOCAL ID\n         CL    R14,0(,R15)         IS THIS LOCAL?\n         BNE   FMT$ROUT            NO, GO FORMAT IT\n         LA    R15,JQEPRTRT        POINT TO PRINT ROUTE FIELD\nFMT$ROUT BAS   R14,FMT$RJE         GO DECODE DEST (ROUTE)\n         TM    JQEFLAG1,JQE1BUSY   IS THE JOB EXECUTING?\n         BZ    NOTBUSY             NO, SKIP THIS ROUTINE\n         IC    R15,JQEFLAG1        GET SYSTEM NUMBER\n         N     R15,=A(JQE1BUSY)    ZERO OUT UNWANTED BITS\n         SLL   R15,3               MULTIPLY BY 8\n         LA    R15,QSYSIDU(R15)    OBTAIN SYSTEM ID\n         MVC   FSYSID,0(R15)       MOVE SYSTEM ID TO DISPLAY\nNOTBUSY  LTR   R1,R1               IS REQUEST FOR JQE OR JOE?\n         BZ    LISTJQE             JQE\n         SPACE 1\n*---     FORMAT JOE                                                ---*\n         SPACE 1\n         MVI   FQNAME,C'O'         MOVE IN NAME OF QUEUE\n         CLI   JOEDEVID,X'0F'      EXTERNAL WRITER?\n         BNE   *+L'*+6             NO, SKIP\n         MVC   FDEV,=C'XWTR'       YES\n         TM    JOEFLAG2,JOE2SLEC   IS THIS JOE SELECTABLE?\n         BZ    *+L'*+4             YES, DON'T FLAG IT\n         MVI   FHOLD,C'N'          NO, SAY SO\n         SPACE 1\n*---     NOTE THAT IF THE JOB IS TRULY ON THE EXTERNAL             ---*\n*---     WRITER (AND NOT ALSO ON A REAL PRINTER),                  ---*\n*---     THE ON-PRINTER & ON-PUNCH FLAGS WILL BE OFF.              ---*\n         SPACE 1\n         L     R0,JOERECCT         NUMBER OF PRINT LINES\n         TM    JOEFLAG1,JOE1PRT+JOE1PUN PRINTING OR PUNCHING?\n         BZ    FMT$LNCT            NO, SKIP\n         MVC   FDEV,=C'INT.'       ASSUME IT WAS $I'D\n         TM    JOEFLAG1,JOE1BUSY   BUT WAS IT INTERRUPTED?\n         BZ    NOT$PRT             YES, OK\n         TM    JOEFLAG1,JOE1PRT    IS IT PRINTING?\n         BNO   *+L'*+4             NO, SKIP\n         MVI   FDEV,C'#'           SHOW IT'S PRINTING\n         TM    JOEFLAG1,JOE1PUN    IS IT PUNCHING?\n         BNO   *+L'*+4             NO, SKIP\n         MVI   FDEV,C'@'           SHOW IT'S PUNCHING\n         XR    R15,R15\n         ICM   R15,B'0011',JOEDEVID+1   GET PRINTER/PUNCH NUMBER\n         CVD   R15,FMT@CONV        MAKE IT EBCDIC\n         MVC   FMT@CONV(4),=XL4'40202120'\n         ED    FMT@CONV(4),FMT@CONV+6\n         MVC   FDEV+1(L'FDEV-1),FMT@CONV+1   SET DEVICE NUMBER\nNOT$PRT  TM    JOEFLAG1,JOE1CKV    IS THE CKPT VALID\n         BZ    FMT$LNCT            NO, SKIP IT\n         S     R0,JOEWRECN         SUB RECS PRINTED FROM TOTAL\nFMT$LNCT CVD   R0,FMT@CONV         CONVERT TO DECIMAL\n         MVC   FLINES,ED5          PREPARE FOR EDIT\n         C     R0,=F'99999'        TOO BIG?\n         BH    FMT$LNC2            YES, DO IT THE OTHER WAY\n         ED    FLINES,FMT@CONV+5   PRINT UPDATED LINE COUNT\n         B     FMT$CHAR            FORMAT CHARACTERISTICS\nFMT$LNC2 MVI   FLINES+5,C'K'       MAKE IT *1000\n         ED    FLINES,FMT@CONV+4   GET JUST THE RIGHT AMOUNT\nFMT$CHAR ZIC   R0,JOEPRIO          LOAD JOE PRIORITY\n         CVD   R0,FMT@CONV         CONVERT TO DECIMAL\n         MVC   FIELD(4),=XL4'40202120'  PREPARE FOR EDIT\n         ED    FIELD(4),FMT@CONV+6 EDIT JQE PRIORITY\n         MVC   FPRIO(L'FPRIO),FIELD+4-L'FPRIO\n         L     R8,JOECHAR          OFFSET TO CHARACTERISTICS JOE\n         N     R8,=A(X'00FFFFFF')  ANY CHAR-JOE?\n         BZ    FMT$LIST            BRANCH IF NO CHAR-JOE\n         AL    R8,QCJOTWA          ADD BASE TO OFFSET\n         CLC   =CL8'STD ',JOEFORM  IS IT STANDARD?\n         BE    *+L'*+6             YES, DON'T DISPLAY IT\n         MVC   FFORM,JOEFORM       MOVE FORM NAME\n         CLC   =C'****',JOEUCS     IS IT STANDARD?\n         BE    *+L'*+6             YES, DON'T DISPLAY IT\n         MVC   FUCS,JOEUCS         MOVE UCS NAME\n         CLC   =C'****',JOEFCB     IS IT STANDARD?\n         BE    *+L'*+6             YES, DON'T DISPLAY IT\n         MVC   FFCB,JOEFCB         MOVE FCB NAME\n         B     FMT$LIST            FORMAT REST OF LINE\n         SPACE 1\n*---     FORMAT JQE                                                ---*\n         SPACE 1\nLISTJQE  CLI   QCLASS,0            IS THIS THE TSO QUEUE?\n         BE    LISTTSO             YES, DO IT\n         CLI   QCLASS,4            IS THIS THE STC QUEUE?\n         BE    LISTSTC             YES, DO IT\n         CLI   QCLASS,8            IS THIS THE HELD OUTPUT QUEUE?\n         BE    LISTHO              YES, DO IT\n         MVI   FQNAME,C'I'         NAME OF QUEUE\n         TM    JQEFLAG1,JQE1BUSY   IS THE JOB EXECUTING?\n         BZ    *+L'*+4             NO, SKIP\n         MVI   FQNAME,C'X'         NAME OF QUEUE\n         MVC   QDHLINE+28(L'FMT#RLN),FMT#RLN MODIFY HEADING\n         MVC   QDHLINE+42(L'FMT#RTI),FMT#RTI MODIFY HEADING\n         DROP  R10\n         L     R10,QVCKPT          LOAD BASE REG\n         USING QCKPT,R10           BASE REG FOR CHECKPT WORK AREA\n         MVC   QCTRAK,JQETRAK      DISK ADDR OF JCT\n         L     R3,QCJCTA           ADDR OF IOAREA FOR JCT\n         LR    R1,R3               PARM FOR READSPC\n         QCALL READSPC             READ HASPACE\n         DROP  R10\n         L     R10,QVDSPL          RESTORE BASE REG\n         USING QDISPLAY,R10        BASE REG FOR DISPLAY WORK AREA\n         USING JCTSTART,R3         BASE REG FOR JCT\n         CLC   JCTID,=CL4'JCT '    IS THIS A JCT?\n         BNE   FM$JCTER            BRANCH IF NOT VALID JCT\n         CLC   JCTJNAME,JQEJNAME   IS THIS JOB?\n         BNE   FM$JOBER            BRANCH IF NOT MATCH\n         L     R1,JCTESTLN         ESTIMATED LINES\n         XR    R0,R0\n         D     R0,=F'1000'         MAKE IT IN KILO\n         CLI   QCODE,8             IS THIS A DI REQUEST?\n         BNE   *+L'*+10            NO, SKIP\n         LR    R2,R1               UPDATE TOTAL I/O\n         A     R2,TOTLNES\n         ST    R2,TOTLNES\n         LA    R2,FLINES\n         BAS   R14,FMT$EDIT\n         L     R1,JCTETIME         ESTIMATED CPU TIME\n         CLI   QCODE,8             IS THIS A DI REQUEST?\n         BNE   *+L'*+10            NO, SKIP\n         LR    R15,R1              UPDATE TOTAL CPU\n         A     R15,TOTCPU\n         ST    R15,TOTCPU\n         LA    R15,FMT$FIO\n         BAS   R14,FMT$CVD\n         MVC   FCPU,=CL9'  0: 0: 0'\n         MVC   FCPU+7(2),FIELD+2\n         BAS   R14,FMT$CVD\n         MVC   FCPU+4(2),FIELD+2\n         LTR   R0,R1\n         BNPR  R15\n         BAS   R14,FMT$CVDE\n         MVC   FCPU(3),FIELD+1\nFMT$FIO  L     R1,JCTUSER0         ESTIMATED I/O\n         LA    R1,0(R1)\n         CLI   QCODE,8             IS THIS A DI REQUEST?\n         BNE   *+L'*+10            NO, SKIP\n         LR    R2,R1               UPDATE TOTAL I/O\n         A     R2,TOTIO\n         ST    R2,TOTIO\n         LA    R2,FIO\n         BAS   R14,FMT$EDIT\n         AIF   ('&SYSPARM' NE 'CJS').CJS1\n         CLI   JCTUSER1,0          ANY CJS NET-ID?                -CJS-\n         BE    FMT$PRIO            NO, CONTINUE                   -CJS-\n         MVC   FCJSID(L'FCJSID),JCTUSER1     TELL IT TO OPER      -CJS-\n.CJS1    B     FMT$PRIO            CONTINUE\n         DROP  R3\nFMT$EDIT CVD   R1,FMT@CONV         CONVERT TO DECIMAL\n         MVC   0(L'ED5,R2),ED5     PREPARE FOR EDIT\n         C     R1,=F'99999'        TOO BIG?\n         BH    FMT$EDK             YES, DO IT THE OTHER WAY\n         ED    0(L'ED5,R2),FMT@CONV+5   EDIT EST. LINES\n         BR    R14\nFMT$EDK  MVI   5(R2),C'M'          MAKE IT MEGA\n         ED    0(L'ED5,R2),FMT@CONV+4   GET JUST THE RIGHT AMOUNT\n         BR    R14\nFMT$CVD  LTR   R1,R1\n         BNPR  R15\n         C     R1,=F'60'\n         BNL   FMT$RED\n         LR    R0,R1\n         XR    R1,R1\n         B     FMT$CVDE\nFMT$RED  XR    R0,R0\n         D     R0,=F'60'\nFMT$CVDE CVD   R0,FMT@CONV\n         MVC   FIELD(4),=XL4'40202120'\n         ED    FIELD(4),FMT@CONV+6\n         BR    R14\nFM$JCTER QTILT 'INVALID JCT (BAD JCTID)'\nFM$JOBER QTILT 'WRONG JCT (BAD JOB NAME)'\nLISTTSO  MVC   FQNAME,=CL4'TSU '   NAME OF QUEUE\n         B     *+L'*+16            CONTINUE\nLISTSTC  MVC   FQNAME,=CL4'SYS '   NAME OF QUEUE\n         B     *+L'*+6             CONTINUE\nLISTHO   MVC   FQNAME,=CL4'H/O '   NAME OF QUEUE\nFMT$PRIO ZIC   R0,JQEPRIO          LOAD JQE PRIORITY\n         SRL   R0,4                DIVIDE BY 16\n         CVD   R0,FMT@CONV         CONVERT TO DECIMAL\n         MVC   FIELD(4),=XL4'40202120'  PREPARE FOR EDIT\n         ED    FIELD(4),FMT@CONV+6 EDIT JQE PRIORITY\n         MVC   FPRIO(L'FPRIO),FIELD+4-L'FPRIO\nFMT$LIST MVC   FMT@CONV(6),ED5\n         ED    FMT@CONV(6),QCOUNT\n         MVC   FCOUNT,FMT@CONV+6-L'FCOUNT\n         MVC   FNAME,JQEJNAME      MOVE IN JOB NAME\n         MVC   FJOBNO-1(6),ED5     PREPARE FOR EDIT\n         LH    R0,JQEJOBNO         LOAD HASP JOB NUMBER\n         CVD   R0,FMT@CONV         CONVERT TO DECIMAL\n         ED    FJOBNO-1(6),FMT@CONV+5   EDIT HASP JOB NUMBER\n         TM    JQEFLAG1,JQE1HLD2   HELD BECAUSE DUP JOB NAME?\n         BNO   *+L'*+4             NO, SKIP\n         MVI   FHOLD,C'D'          YES, FLAG IT\n         TM    JQEFLAG1,JQE1HLDA   HOLD ALL?\n         BNO   *+L'*+4             NO\n         MVI   FHOLD,C'A'          INDICATE JOB HELD FOR HOLD ALL\n         TM    JQEFLAG1,JQE1HLD1   THIS JOB HELD?\n         BNO   *+L'*+4             NO, SKIP\n         MVI   FHOLD,C'H'          YES, INDICATE IT\n         QCALL DISPLAY,QDMSG,80    DISPLAY THE LINE\nFMT$END  QSTOP\n         SPACE 1\n*---------------------------------------------------------------------*\n*        TAKE HEX DUMPS                                               *\n*---------------------------------------------------------------------*\n         SPACE 1\nHEXDM    TM    QDFREQ,QDFSC        POINTERS SET?\n         BO    HEXSH               YES\n         L     R2,QCWA             NO, BUILD AND SET BXLE POINTERS\n         LA    R3,4\n         ST    R3,QPTRSV\n         AL    R2,=A(WASSZ)\n         SLR   R2,R3\n         ST    R2,QPTRSV+4\n         SL    R2,=A(1020)\n         ST    R2,QPTRSV+8\n         MVI   0(R2),0\n         OI    QDFREQ,QDFSC\nHEXSH    MVC   QDHLINE,FMT#JN      REPORT HEADING\n         MVC   QDHLINE+10(8),JQEJNAME   MOVE IN JOB NAME\n         MVC   QDHLINE+32(6),=XL6'402020202120' PREPARE FOR EDIT\n         LH    R0,JQEJOBNO         LOAD HASP JOB NUMBER\n         CVD   R0,FMT@CONV         CONVERT TO DECIMAL\n         ED    QDHLINE+32(6),FMT@CONV+5 EDIT HASP JOB NUMBER\n         NI    QDFREQ,255-QDFRL    SET NORMAL\n         LTR   R1,R1               REQUEST FOR JQE OR JOE?\n         BZ    HEX                 JQE\n         SPACE 1\n*---     TAKE HEX DUMP OF JOE                                      ---*\n         SPACE 1\n         LA    R3,0(R8)            SET START ADDRESS TO DUMP\n         LR    R15,R3\n         SL    R15,QCJOTWA         SUBSTRACT BASE TO OFFSET\n         ST    R15,XQDWD\n         MVI   XQDWD,C'O'\n         BAS   R14,HEXSCAN\n         B     HEXPC\n         MVC   QDMSG,QBLANK\n         MVI   FHEXSP1,C':'\n         UNPK  FMT@CONV(7),XQDWD+1(4)\n         TR    FMT@CONV(6),HEXTAB-X'F0'\n         MVC   FHEXRP1(L'FHEXRP1),FMT@CONV\n         TM    JOETYPE,JOEFREE     FREE-JOE?\n         BO    HEXOF               YES\n         TM    JOETYPE,JOEWORK     WORK-JOE?\n         BZ    HEXTS               NO\n         MVC   FHEXNM1,=CL5'@-JOE' YES, SAY WORK-JOE\n         MVC   FHEXNM2,=CL8'---> JQE'\n         MVI   FHEXSP2,C':'\n         TM    QDFREQ,QDFSV        INFO SAVED?\n         BZ    *+L'*+10            NO\n         MVC   JOEJQEB(3),QPTRSV+13     RESTORE INFO FOR DUMP\n         OI    QDFREQ,QDFRS        SET RESET\n         UNPK  FMT@CONV(7),JOEJQEB(4)\n         TR    FMT@CONV(6),HEXTAB-X'F0'\n         MVC   FHEXRP2(L'FHEXRP2),FMT@CONV\n         LA    R2,0+((JOE1END-JOE)/4)*4 SET WORK-JOE LENGTH\n         OC    JOECHARB,JOECHARB\n         BZ    HEXOS\n         MVC   FHEXNM3,=CL8'---> CHA'\n         MVI   FHEXSP3,C':'\n         UNPK  FMT@CONV(7),JOECHARB(4)\n         TR    FMT@CONV(6),HEXTAB-X'F0'\n         MVC   FHEXRP3(L'FHEXRP3),FMT@CONV\n         B     HEXOS\nHEXTS    TM    JOETYPE,JOECHARJ    CHARACTERISTICS JOE?\n         BZ    HEXOF               NO\n         MVC   FHEXNM1,=CL5'@-CHA' YES, SAY CHAR-JOE\n         LA    R2,0+((JOE2END-JOE)/4)*4 SET CHAR-JOE LENGTH\n         B     HEXOS\nHEXOF    MVC   FHEXNM1,=CL5'@FREE' SAY FREE-JOE\n         LA    R2,0+(JOESIZE/4)*4  SET JOE LENGTH\nHEXOS    QCALL DISPLAY,QDMSG,80    DISPLAY LINE\n         MVC   QDMSG,QBLANK\n         QCALL HEXDUMP             PRINT JOE IN HEX\n         TM    QDFREQ,QDFRS        RESET REQUESTED?\n         BZ    HEXPC               NO\n         MVC   JOEJQEB,=XL3'00'    RESTORE THIS JOE USED\nHEXPC    TM    JOETYPE,JOEFREE     FREE-JOE?\n         BO    HEX                 YES\n         TM    JOETYPE,JOEWORK     WORK-JOE?\n         BZ    HEX                 NO\n         L     R8,JOECHAR          OFFSET TO CHARACTERISTICS JOE\n         N     R8,=A(X'00FFFFFF')  ANY CHAR-JOE?\n         BZ    HEX                 BRANCH IF NO CHAR-JOE\n         LR    R15,R8\n         AL    R8,QCJOTWA          ADD BASE TO OFFSET\n         ST    R15,XQDWD\n         MVI   XQDWD,C'O'\n         BAS   R14,HEXSCAN\n         B     HEX\n         MVC   QDMSG,QBLANK\n         TM    JOETYPE,JOEFREE     FREE-JOE?\n         BO    *+L'*+8             YES\n         TM    JOETYPE,JOECHARJ    NO, CHARACTERISTICS JOE?\n         BO    *+L'*+10            YES\n         MVC   FHEXNM1,=CL5'@-???' NO, WHAT'S THAT\n         B     *+L'*+6\n         MVC   FHEXNM1,=CL5'@-CHA' SAY CHAR-JOE\n         MVI   FHEXSP1,C':'\n         UNPK  FMT@CONV(7),XQDWD+1(4)\n         TR    FMT@CONV(6),HEXTAB-X'F0'\n         MVC   FHEXRP1(L'FHEXRP1),FMT@CONV\n         QCALL DISPLAY,QDMSG,80    DISPLAY LINE\n         MVC   QDMSG,QBLANK\n         LA    R3,0(R8)            SET START ADDRESS TO DUMP\n         LA    R2,0+((JOE2END-JOE)/4)*4 SET CHAR-JOE LENGTH\n         QCALL HEXDUMP             PRINT CHAR-JOE IN HEX\n         SPACE 1\n*---     TAKE HEX DUMP OF JQE                                      ---*\n         SPACE 1\nHEX      NI    QDFREQ,255-QDFSV-QDFRS\n         LA    R3,0(R9)            SET START ADDRESS TO DUMP\n         LR    R15,R3\n         SL    R15,QCJQEWA         SUBSTRACT BASE TO OFFSET\n         ST    R15,XQDWD\n         MVI   XQDWD,C'Q'\n         BAS   R14,HEXSCAN\n         B     FMT$END\n         MVC   QDMSG,QBLANK\n         MVC   FHEXNM1,=CL5'@-JQE'   SAY JQE\n         MVI   FHEXSP1,C':'\n         UNPK  FMT@CONV(7),XQDWD+1(4)\n         TR    FMT@CONV(6),HEXTAB-X'F0'\n         MVC   FHEXRP1(L'FHEXRP1),FMT@CONV\n         OC    JQEJOEB,JQEJOEB\n         BZ    HEXJQ\n         MVC   FHEXNM2,=CL8'---> JOE'\n         MVI   FHEXSP2,C':'\n         UNPK  FMT@CONV(7),JQEJOEB(4)\n         TR    FMT@CONV(6),HEXTAB-X'F0'\n         MVC   FHEXRP2(L'FHEXRP2),FMT@CONV\nHEXJQ    QCALL DISPLAY,QDMSG,80    DISPLAY LINE\n         MVC   QDMSG,QBLANK\nXLJQE    EQU   (JQEBLEN/4)*4\n         LA    R2,XLJQE            SET LENGTH\n         QCALL HEXDUMP             PRINT JQE IN HEX\n         B     FMT$END             ALL DUMPED\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        HEXSCAN - REMEMBER JQE/JOE ALREADY DUMPED                    *\n*                                                                     *\n*        ENTRY : XQDWD +0   = TYPE                                    *\n*                XQDWD +1-3 = JQE/JOE RELATIVE ADDRESS                *\n*                R4-R5-R6 = WORK REGISTERS                            *\n*                R14 +0 = FOUND RETURN ADDRESS                        *\n*                    +4 = NOT FOUND RETURN ADDRESS                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nHEXSCAN  LM    R4,R6,QPTRSV        GET POINTERS\nHEXSCAN0 CLI   0(R6),0             ANY MORE?\n         BE    HEXSCAN1            NO\n         CLC   0(4,R6),XQDWD       YES, THIS ONE?\n         BER   R14                 YES, ALREADY DUMPED\n         BXLE  R6,R4,HEXSCAN0      NO, LOOP TO NEXT\n         B     4(R14)              NOT FOUND\nHEXSCAN1 MVC   0(4,R6),XQDWD       INSERT THIS ONE\n         BXLE  R6,R4,*+L'*+4\n         B     4(R14)\n         MVI   0(R6),0\n         B     4(R14)\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        FMT$RJE - FORMAT REMOTE ID                                   *\n*                                                                     *\n*        ENTRY : R14 - RETURN ADDRESS                                 *\n*                R15 - @ ROUTE FIELD (4 BYTES)                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nFMT$RJE  STM   R14,R12,12(R13)\n         L     R14,QCMSA           @ MASTER CKPT RECORD\n         LH    R14,$NODEID-$SAVEBEG(,R14)    THIS NODE ID\n         SLL   R14,16              MAKE LOCAL ID\n         CL    R14,0(,R15)         IS THIS LOCAL?\n         BE    FMT$RJE9            BRANCH IF LOCAL ROUTING\n         LA    R3,FREMOTE          @ OUTPUT FIELD FOR REMOTE ID\n         LA    R0,C'R'             ASSUME IS REMOTE\n         CLM   R14,B'1100',0(R15)  IS THIS MY NODE?\n         BE    FMT$RJE3            BRANCH IF IS RNNN\n         LA    R0,C'U'             ASSUME IS U TYPE\n         XR    R14,R14\n         CLM   R14,B'1100',0(R15)  IS THIS NODE 0?\n         BE    FMT$RJE3            BRANCH IF IS UNNN\n         SPACE 1\n*---     NODE IS N###R### FORMAT                                   ---*\n         SPACE 1\n         LA    R0,C'N'             1ST ID IS N###\n         LH    R1,0(,R15)          GET NODE ID\n         BAS   R14,FMT$RJEC        CONVERT NODE ID\n         SPACE 1\n*--- NOTE : NODE IS N### FORMAT ONLY BECAUSE THERE IS\n*---        NO ROOM IN THE NEW DEFINED OUTPUT LINE.\n         SPACE 1\n         B     FMT$RJE9            ONLY THE NODE ID\n*        LA    R0,C'R'             RESET IS R###\nFMT$RJE3 LH    R1,2(,R15)\n         BAS   R14,FMT$RJEC        CONVERT OTHER ID\nFMT$RJE9 LM    R14,R12,12(R13)\n         BR    R14\nFMT$RJEC CVD   R1,120(,R13)        CONVERT TO DEC\n         MVC   128(6,R13),=XL6'402020202120' EDIT MASK\n         LA    R1,128+5(,R13)\n         LR    R2,R1\n         EDMK  128(6,R13),120+5(R13)\n         SR    R2,R1               LENGTH -1 OF NUMBER\n         STC   R0,0(,R3)           SET TYPE ID\n         EX    R2,FMT$RJEM\n         LA    R3,1+1(R2,R3)       BUMP OUTPUT PTR\n         BR    R14\nFMT$RJEM MVC   1(0,R3),0(R1)       * EXECUTED *\n         SPACE 1\nED5      DC    X'402020202021'\n         AIF   ('&SYSPARM' NE 'CJS').CJS2\nFMT#HEAD DC    CL79'QUEUE POS JOBNAME   JOB# PR  LINES EXEC H DEV  FORM1\n                    FCB  UCS  RJE  CJS-NET'                       -CJS-\n         AGO   .CJS3                                              -CJS-\n.CJS2    ANOP\nFMT#HEAD DC    CL79'QUEUE POS JOBNAME   JOB# PR  LINES EXEC H DEV  FORM1\n                    FCB  UCS  RJE'\n.CJS3    ANOP\nFMT#JN   DC    CL79'JOBNAME : XXXXXXXX / JOBNUMBER : '\nFMT#RLN  DC    C' REQ.L'\nFMT#RTI  DC    C'   REQ.CPU     REQ.I    '\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R8,R9,R10,R11,R12\n         TITLE '--- QUEUE/SP -- HEXDUMP -- DUMP HEX ROUTINE ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n* HEXDUMP : DISPLAY IN HEX A CONTROL BLOCK                            *\n*                                                                     *\n*        ENTRY : R2 = LENGTH OF BLOCK TO BE DUMPED                    *\n*                R3 = ADDRESS OF BLOCK TO BE DUMPED                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nHEXDUMP  QSTART\n         L     R10,QVDSPL          LOAD BASE REG\n         USING QDISPLAY,R10        BASE REG FOR DISPLAY WORK AREA\n         TM    QDFREQ,QDFRL        WHICH FORMAT?\n         BO    HEXF1D              RELATIVE\n         LA    R4,L'FHEXDATA-1     NORMAL\n         LA    R5,4*8\nHEXF0D   CLR   R2,R5\n         BNL   HEXF0D1\n         LR    R4,R2\n         AR    R4,R2\n         SRL   R2,2\n         AR    R4,R2\n         BCTR  R4,0\nHEXF0D1  LR    R1,R3               GET ADDRESS TO DUMP\n         UNPK  FMT@HEXW+00(14+1),00(7+1,R1)  BYTES 01-07\n         UNPK  FMT@HEXW+14(14+1),07(7+1,R1)  BYTES 08-14\n         UNPK  FMT@HEXW+28(14+1),14(7+1,R1)  BYTES 15-21\n         UNPK  FMT@HEXW+42(14+1),21(7+1,R1)  BYTES 22-28\n         UNPK  FMT@HEXW+56(14+1),28(7+1,R1)  BYTES 29-35\n         TR    FMT@HEXW(70),TABLEP      MAKE IT PRINTABLE HEX\n         MVC   FMT@LINE,QBLANK     CLEAR OUTPUT LINE\n         MVC   FMT@LINE+00(08),FMT@HEXW+00   MOVE FIRST WORD\n         MVC   FMT@LINE+09(08),FMT@HEXW+08   MOVE SECOND WORD\n         MVC   FMT@LINE+18(08),FMT@HEXW+16   MOVE THIRD WORD\n         MVC   FMT@LINE+27(08),FMT@HEXW+24   MOVE FOURTH WORD\n         MVC   FMT@LINE+36(08),FMT@HEXW+32   MOVE FIFTH WORD\n         MVC   FMT@LINE+45(08),FMT@HEXW+40   MOVE SIXTH WORD\n         MVC   FMT@LINE+54(08),FMT@HEXW+48   MOVE SEVENTH WORD\n         MVC   FMT@LINE+63(08),FMT@HEXW+56   MOVE EIGHTH WORD\n         MVC   FHEXDATA(L'FHEXDATA),QBLANK   CLEAR OUTPUT LINE\n         EX    R4,HEXF0DMV         COPY IT\n         QCALL DISPLAY,QDMSG,80    DISPLAY THE LINE\n         MVC   FHEXID(L'FHEXID),QBLANK\n         TM    QDFREQ,QDFEX        WHICH FORMAT?\n         BZ    HEXF0D3             NORMAL\n         MVC   FMT@LINE,QBLANK     CLEAR OUTPUT LINE\n         LA    R0,8\n         LR    R14,R3\n         LA    R15,FMT@LINE\nHEXF0D2  MVC   0(1,R15),0(R14)\n         MVC   2(1,R15),1(R14)\n         MVC   4(1,R15),2(R14)\n         MVC   6(1,R15),3(R14)\n         LA    R14,4(R14)\n         LA    R15,9(R15)\n         BCT   R0,HEXF0D2\n         TR    FMT@LINE,TABLECH\n         MVC   FHEXDATA(L'FHEXDATA),QBLANK   CLEAR OUTPUT LINE\n         EX    R4,HEXF0DMV         COPY IT\n         QCALL DISPLAY,QDMSG,80    DISPLAY THE LINE\nHEXF0D3  SR    R2,R5\n         BNP   HEXDUMPE            ALL DUMPED\n         AR    R3,R5               NEXT ADDRESS\n         B     HEXF0D\nHEXF0DMV MVC   FHEXDATA(*-*),FMT@LINE   <<EXECUTED>>\nHEXF1D   L     R4,QCWA             USE THE WORK AREA\n         USING IN,R3               BASE REG FOR RAW BLOCK\n         USING OUT,R4              BASE REG FOR PRINTABLE LINES\n         XR    R5,R5               START OFFSET AT ZERO\n         TM    QDFREQ,QDFEX        WHICH FORMAT?\n         BO    HEXF2D1             EXTENDED\nHEXF1D1  MVC   OLINE1,QBLANK       BLANK THE WORK AREA\n         LA    R1,8*8(R5)\n         CLR   R1,R2\n         BNH   HEXF1D2\n         SR    R1,R2\n         LA    R15,I8+L'I8\n         SR    R15,R1\n         BCTR  R1,0\n         EX    R1,HEXF1DMV\nHEXF1D2  MVC   O11,I1              MOVE RECORD TO PRINT LINE 1\n         MVC   O12,I2\n         MVC   O13,I3\n         MVC   O14,I4\n         MVC   O15,I5\n         MVC   O16,I6\n         MVC   O17,I7\n         MVC   O18,I8\n         MVC   OLINE2,OLINE1       COPY INTO LINE 2\n         STH   R5,QNUMWORK         STORE OFFSET\n         UNPK  HBOFFSET(5),QNUMWORK(3)  CONVERT TO HEX\n         TR    HBOFFSET,TABLEP     TRANSLATE TO PRINTABLE\n         MVI   HBOFFSET+4,C' '     CLEAR GARBAGE BYTE\n         TR    ODATA1,TABLEU       TRANSLATE TO UPPER HEX\n         TR    ODATA2,TABLEL       TRANSLATE TO LOWER HEX\n         QCALL DISPLAY,OLINE1,160  DISPLAY THE LINES 1 AND 2\n         LR    R1,R3               SAVE ADDR OF RECORD\nHEXF1D3  LA    R3,8*8(R3)          NEXT RECORD\n         LA    R5,8*8(R5)          INCREMENT TO NEXT OFFSET\n         CLR   R5,R2               IS THIS THE END?\n         BNL   HEXDUMPE            YES, GO HOME\n         CLC   0(8*8,R1),0(R3)     THIS RECORD THE SAME AS PREV?\n         BE    HEXF1D3             YES, SKIP IT\n         B     HEXF1D1             PRINT NEXT RECORD\nHEXF1DMV MVC   0(*-*,R15),QBLANK   <<EXECUTED>>\nHEXF2D1  MVC   OLINE1,QBLANK       BLANK THE WORK AREA\n         MVC   OLINE2,QBLANK\n         MVC   OLINE3,QBLANK\n         STH   R5,QNUMWORK         STORE OFFSET\n         UNPK  HBOFFSET(5),QNUMWORK(3)  CONVERT TO HEX\n         TR    HBOFFSET,TABLEP     TRANSLATE TO PRINTABLE\n         MVI   HBOFFSET+4,C' '     CLEAR GARBAGE BYTE\n         LA    R0,8*8\n         LA    R1,8*8(R5)\n         CLR   R1,R2\n         BNH   HEXF2D2\n         SR    R1,R2\n         LA    R15,I8+L'I8\n         SR    R15,R1\n         BCTR  R1,0\n         EX    R1,HEXF2DMV\n         LR    R0,R2\n         SR    R0,R5\nHEXF2D2  MVC   O31,I1              MOVE RECORD TO PRINT LINE 3\n         MVC   O32,I2\n         MVC   O33,I3\n         MVC   O34,I4\n         MVC   O35,I5\n         MVC   O36,I6\n         MVC   O37,I7\n         MVC   O38,I8\n         TR    ODATA3,TABLECH      TRANSLATE TO CHARACTERS\n         LA    R15,I1\n         BAS   R14,HEXF2DR\n         MVC   O11(*-*),FMT@HEXW+8 +0   <<EXECUTED>>\n         MVC   O21(*-*),FMT@HEXW   +6   <<EXECUTED>>\n         LA    R15,I2              +12\n         BAS   R14,HEXF2DR\n         MVC   O12(*-*),FMT@HEXW+8 +0   <<EXECUTED>>\n         MVC   O22(*-*),FMT@HEXW   +6   <<EXECUTED>>\n         LA    R15,I3              +12\n         BAS   R14,HEXF2DR\n         MVC   O13(*-*),FMT@HEXW+8 +0   <<EXECUTED>>\n         MVC   O23(*-*),FMT@HEXW   +6   <<EXECUTED>>\n         LA    R15,I4              +12\n         BAS   R14,HEXF2DR\n         MVC   O14(*-*),FMT@HEXW+8 +0   <<EXECUTED>>\n         MVC   O24(*-*),FMT@HEXW   +6   <<EXECUTED>>\n         LA    R15,I5              +12\n         BAS   R14,HEXF2DR\n         MVC   O15(*-*),FMT@HEXW+8 +0   <<EXECUTED>>\n         MVC   O25(*-*),FMT@HEXW   +6   <<EXECUTED>>\n         LA    R15,I6              +12\n         BAS   R14,HEXF2DR\n         MVC   O16(*-*),FMT@HEXW+8 +0   <<EXECUTED>>\n         MVC   O26(*-*),FMT@HEXW   +6   <<EXECUTED>>\n         LA    R15,I7              +12\n         BAS   R14,HEXF2DR\n         MVC   O17(*-*),FMT@HEXW+8 +0   <<EXECUTED>>\n         MVC   O27(*-*),FMT@HEXW   +6   <<EXECUTED>>\n         LA    R15,I8              +12\n         BAS   R14,HEXF2DR\n         MVC   O18(*-*),FMT@HEXW+8 +0   <<EXECUTED>>\n         MVC   O28(*-*),FMT@HEXW   +6   <<EXECUTED>>\nHEXF2D3  QCALL DISPLAY,OLINE1,240  DISPLAY THE LINE\n         LR    R1,R3               SAVE ADDR OF RECORD\nHEXF2D4  LA    R3,8*8(R3)          NEXT RECORD\n         LA    R5,8*8(R5)          INCREMENT TO NEXT OFFSET\n         CLR   R5,R2               IS THIS THE END?\n         BNL   HEXDUMPE            YES, GO HOME\n         CLC   0(8*8,R1),0(R3)     THIS RECORD THE SAME AS PREV?\n         BE    HEXF2D4             YES, SKIP IT\n         B     HEXF2D1             PRINT NEXT RECORD\nHEXF2DMV MVC   0(*-*,R15),QBLANK   <<EXECUTED>>\n         DROP  R3,R4\nHEXF2DR  LTR   R0,R0\n         BNP   HEXF2D3\n         MVC   FMT@HEXW(8),0(R15)\n         MVO   FMT@HEXW+8(9),FMT@HEXW(8)\n         OC    FMT@HEXW(16),UPPERZ\n         TR    FMT@HEXW(16),TABLEP\n         LA    R15,8\n         CLR   R0,R15\n         BNL   *+L'*+2\n         LR    R15,R0\n         SR    R0,R15\n         BCTR  R15,0\n         EX    R15,0(R14)\n         EX    R15,6(R14)\n         B     12(R14)\nHEXDUMPE QSTOP ,                   RETURN\n         SPACE 1\n*---     TABLE USED TO CONVERT TO UPPER HALF OF PRINTABLE HEX      ---*\n         SPACE 1\nTABLEU   DS    0CL256\nUPPERZ   EQU   *                   TABLE FOR HEX CONVERT\n* - - - - - - -> 0123456789ABCDEF <- *\n         DC    C'0000000000000000'   0\n         DC    C'1111111111111111'   1\n         DC    C'2222222222222222'   2\n         DC    C'3333333333333333'   3\n         DC    C' 4444444444.<(+|'   4\n         DC    C'&&5555555555$*);\u00ac'  5\n         DC    C'-/666666666,%_>?'   6\n         DC    C'7777777777:#@''=\"'  7\n         DC    C'8888888888888888'   8\n         DC    C'9999999999999999'   9\n         DC    C'AAAAAAAAAAAAAAAA'   A\n         DC    C'BBBBBBBBBBBBBBBB'   B\n         DC    C'CABCDEFGHICCCCCC'   C\n         DC    C'DJKLMNOPQRDDDDDD'   D\n         DC    C'EESTUVWXYZEEEEEE'   E\n         DC    C'0123456789FFFFFF'   F\n         SPACE 1\n*---     TABLE USED TO CONVERT TO LOWER HALF OF PRINTABLE HEX      ---*\n         SPACE 1\nTABLEL   DS    0CL256\nTABLEP   EQU   *-C'0'              TABLE FOR HEX UNCONVERT\n* - - - - - - -> 0123456789ABCDEF <- *\n         DC    C'0123456789ABCDEF'   0\n         DC    C'0123456789ABCDEF'   1\n         DC    C'0123456789ABCDEF'   2\n         DC    C'0123456789ABCDEF'   3\n         DC    C' 123456789A     '   4\n         DC    C' 123456789A     '   5\n         DC    C'  23456789A     '   6\n         DC    C'0123456789      '   7\n         DC    C'0123456789ABCDEF'   8\n         DC    C'0123456789ABCDEF'   9\n         DC    C'0132456789ABCDEF'   A\n         DC    C'0123456789ABCDEF'   B\n         DC    C'0         ABCDEF'   C\n         DC    C'0         ABCDEF'   D\n         DC    C'01        ABCDEF'   E\n         DC    C'          ABCDEF'   F\n         SPACE 1\n*---     TABLE USED TO CONVERT TO PRINTABLE CHARACTERS             ---*\n         SPACE 1\nTABLECH  DS    0CL256\n* - - - - - - -> 0123456789ABCDEF <- *\n         DC    C'                '   0\n         DC    C'                '   1\n         DC    C'                '   2\n         DC    C'                '   3\n         DC    C'           .<(+|'   4\n         DC    C'&&          $*);\u00ac'  5\n         DC    C'-/         ,%_>?'   6\n         DC    C'          :#@''=\"'  7\n         DC    C' ABCDEFGHI      '   8  LIST LOWER\n         DC    C' JKLMNOPQR      '   9    ALPHA TO\n         DC    C'  STUVWXYZ      '   A      UPPER ALPHA\n         DC    C'                '   B\n         DC    C' ABCDEFGHI      '   C\n         DC    C' JKLMNOPQR      '   D\n         DC    C'  STUVWXYZ      '   E\n         DC    C'0123456789      '   F\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R10,R11,R12\n         TITLE '--- QUEUE/SP -- HELP -- DISPLAY HELP ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n* HELP : HELP COMMAND ROUTINE (DISPLAY HELP INFORMATION)              *\n* PFKS : CHANGE, RESET, SAVE OR LOAD PF-KEYS DEFINITIONS              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nHELP     QSTART\n         L     R9,QVCKPT           ADDR OF DAIR WORK AREAS\n         USING QCKPT,R9            BASE REG FOR DAIR WORK AREAS\n         L     R10,QVDSPL          ADDR OF DISPLAY WORK AREA\n         USING QDISPLAY,R10        BASE REG FOR DISPLAY WORK AREA\n         LH    R1,QCODEH           LOAD FUNCTION CODE INTO R1\n         CH    R1,MAXHELP          IS THE FUNCTION SUPPORTED?\n         BH    HELPBACK            NO, RETURN\n         B     GETHELP(R1)         BRANCH TO ROUTINE\nGETHELP  DS    0H\n         B     HELPREQ                  0 OFFSET\n         B     SETPF                    4\n         B     RSPFK                    8\n         B     LSPF                     12\n         B     LSPF                     16\nMAXHELP  DC    0H'0',AL2(*-GETHELP-4)\n         SPACE 1\n*---     SAVE OR LOAD THE PF-KEYS TO/FROM DATA-SET                 ---*\n*---     NAME IS : USERID.QPARM1.QPARM2(QPARM3)                    ---*\n*---     BY DEFAULT IS : USERID.SPF.PROF(QSPPROF)                  ---*\n         SPACE 1\nLSPF     CLI   QPARM1,C'0'         IS FIRST CHARACTER VALID?\n         BL    LSPF1               YES\n         QTILT '*** FIRST PART OF DSNAME INVALID ***'\nLSPF1    CLI   QPARM2,C'0'         IS FIRST CHARACTER VALID?\n         BL    LSPF2               YES\n         QTILT '*** LAST PART OF DSNAME INVALID ***'\nLSPF2    CLI   QPARM3,C'0'         IS FIRST CHARACTER VALID?\n         BL    LSPF3               YES\n         QTILT '*** MEMBER NAME INVALID ***'\nLSPF3    MVC   DSNAME+2(44),QBLANK NO, BLANK THE DSNAME\n         LA    R1,DSNAME           ADDRESS OF DSNAME\n         CLI   QPARM1,C' '         DEFAULT TO BE USED?\n         BE    *+L'*+8             YES\n         CLI   QPARM1,C'-'         DEFAULT TO BE USED?\n         BNE   LSPF10              NO\n         MVC   DSNAME+2(3),=CL3'SPF'    YES, SET IT\n         LH    R2,=H'3'            LENGTH OF FIRST PART\n         B     LSPF11\nLSPF10   MVC   DSNAME+2(8),QPARM1  FIRST PART OF DSNAME\n         LH    R2,QLNG1            LENGTH OF QPARM1\nLSPF11   LA    R1,2(R2,R1)         OFFSET INTO DSNAME\n         MVI   0(R1),C'.'          SET SEPARATOR\n         CLI   QPARM2,C' '         DEFAULT TO BE USED?\n         BE    *+L'*+8             YES\n         CLI   QPARM2,C'-'         DEFAULT TO BE USED?\n         BNE   LSPF12              NO\n         MVC   1(4,R1),=CL4'PROF'  YES, SET IT\n         LA    R1,5(,R2)           LENGTH OF DSNAME\n         B     LSPF13\nLSPF12   MVC   1(8,R1),QPARM2      LAST PART OF DSNAME\n         LA    R1,1(,R2)\n         AH    R1,QLNG2            LENGTH OF DSNAME\nLSPF13   STH   R1,DSNAME           STORE LENGTH OF DSNAME\n         CLI   QPARM3,C' '         DEFAULT TO BE USED?\n         BE    *+L'*+8             YES\n         CLI   QPARM3,C'-'         DEFAULT TO BE USED?\n         BNE   *+L'*+10            NO\n         MVC   QCPFMEM,=CL8'QSPPROF'    YES, SET IT\n         B     *+L'*+6\n         MVC   QCPFMEM,QPARM3      MEMBER NAME\n         MVC   DAALUNIT(DAAL$L),ALLOCPFK     SET ALLOCATE PARM LIST\n         LA    R1,DSNAME           ADDRESS OF DSNAME\n         ST    R1,DAALPDSN         STORE IN PARM LIST\n         MVI   QCPFKSW,0           INITIAL RESET\n         MVI   DAIRFLAG,DFALLOC    REQUEST ALLOCATE FUNCTION\n         QCALL ALLOCATE            ALLOCATE IT\n         OI    QCPFKSW,PFDAAL      SAY ALLOCATED\n         TM    DAALDSO,DCBDSGPO    DSORG=PO?\n         BO    LSPF20              YES, OK\n         MVC   QDMSG(35),=CL35'*** DATA-SET IS NOT PARTITIONED ***'\n         LA    R2,35\n         B     LSPF46\nLSPF20   MVC   QCPFKOP(1),HOCKPT   SET INPUT\n         L     R1,=A(QCPFKPO)\n         MVC   QCPFKPO(QCPFKPOL),0(R1)  INITIALIZE DCB\n         MVC   QCPFKPO+(DCBDDNAM-IHADCB)(L'DAALDDN),DAALDDN\n*                                  GET THE DDNAME RETURNED BY DAIR\n         LA    R1,QCPFKPO\n         ICM   R1,B'1000',QCPFKOP\n         ST    R1,QCPFKOP          SET PTR TO DCB IN OPEN LIST\n         ICM   R1,B'1000',QCPFKCL\n         ST    R1,QCPFKCL          SET PTR TO DCB IN CLOSE LIST\n         OPEN  MF=(E,QCPFKOP)      OPEN DATA-SET\n         TM    QCPFKPO+(DCBOFLGS-IHADCB),DCBOFOPN OPEN OK?\n         BZ    LSPF41              NO\n         TM    QCPFKSW,PFRFERR     RECFM ERROR?\n         BO    LSPF43              YES\n         TM    QCPFKSW,PFLRERR     LRECL ERROR?\n         BO    LSPF44              YES\n         OI    QCPFKSW,PFDAOP      SAY OPENED\n         L     R2,QCWA             USE WORK SPACE\n         MVC   0(4,R2),=AL2(1,58)  AS BLDL PARM LIST\n         MVC   4(8,R2),QCPFMEM\n         XC    12(50,R2),12(R2)\n         BLDL  QCPFKPO,(R2)\n         LTR   R15,R15             COMPLETION CODE?\n         BZ    LSPF22              OK\n         CH    R15,=H'4'           IS IT MEMBER NOT FOUND?\n         BE    LSPF21              YES\n         MVC   QDMSG(37),=CL37'*** DATA-SET SEARCH ERROR :   /   ***'\n         STC   R15,QDMSG+29\n         SRL   R15,4\n         STC   R15,QDMSG+28\n         NC    QDMSG+28(2),=XL2'0F0F'\n         TR    QDMSG+28(2),HEXTAB\n         STC   R0,QDMSG+32\n         SRL   R0,4\n         STC   R0,QDMSG+31\n         NC    QDMSG+31(2),=XL2'0F0F'\n         TR    QDMSG+31(2),HEXTAB\n         LA    R2,37\n         B     LSPF45\nLSPF21   CLI   QCODE,12            SAVE REQUESTED?\n         BE    LSPF30              YES\n         MVC   QDMSG(35),=CL35'*** MEMBER NOT FOUND :          ***'\n         MVC   QDMSG+23(8),QCPFMEM\n         LA    R2,35\n         B     LSPF45\nLSPF22   CLI   QCODE,12            SAVE REQUESTED?\n         BNE   LSPF30              NO\n         OI    QCPFKSW,PFDAIN      YES, DO IT IN PLACE\nLSPF30   CLOSE MF=(E,QCPFKCL)      CLOSE DATA-SET\n         MVI   DAIRFLAG,DFFREE     REQUEST FREE FUNCTION\n         MVC   DAFRDDN,QCPFKPO+(DCBDDNAM-IHADCB)  GET THE DDNAME\n         QCALL ALLOCATE            FREE IT BY DDNAME\n         MVC   DAALUNIT(DAAL$L),ALLOCPFK     SET ALLOCATE PARM LIST\n         MVC   DAALMNM,QCPFMEM     MEMBER NAME\n         CLI   QCODE,12            SAVE REQUESTED?\n         BNE   LSPF40              NO\n         MVI   DAALDSP1,DA08OLD    YES, CHANGE TO OLD\n         TM    QCPFKSW,PFDAIN      IN PLACE?\n         BO    UPPF1               YES\n         MVC   QCPFKOP(1),QCOPEN   NO, SET OUTPUT\n         B     LSPF40+L'LSPF40\nUPPF1    L     R1,=A(QCPFKOP)      SET UPDAT\n         IC    R0,0(R1)\n         STC   R0,QCPFKOP\n         B     LSPF40+L'LSPF40\nLSPF40   MVC   QCPFKOP(1),HOCKPT   SET INPUT\n         NI    QCPFKSW,PFDAIN      RESET ALL UNLESS ...\n         MVI   DAIRFLAG,DFALLOC    REQUEST ALLOCATE FUNCTION\n         QCALL ALLOCATE            ALLOCATE IT\n         OI    QCPFKSW,PFDAAL      SAY ALLOCATED\n         L     R1,=A(QCPFKPS)\n         MVC   QCPFKPS(QCPFKPSL),0(R1)  INITIALIZE DCB & DECB\n         MVC   QCPFKPS+(DCBDDNAM-IHADCB)(L'DAALDDN),DAALDDN\n*                                  GET THE DDNAME RETURNED BY DAIR\n         LA    R1,QCPFKPS\n         ST    R1,QCPDECB+8        SET PTR TO DCB IN DECB\n         ICM   R1,B'1000',QCPFKOP\n         ST    R1,QCPFKOP          SET PTR TO DCB IN OPEN LIST\n         ICM   R1,B'1000',QCPFKCL\n         ST    R1,QCPFKCL          SET PTR TO DCB IN CLOSE LIST\n         OPEN  MF=(E,QCPFKOP)      OPEN DATA-SET\n         TM    QCPFKPS+(DCBOFLGS-IHADCB),DCBOFOPN OPEN OK?\n         BO    LSPF50              YES\nLSPF41   TM    QCPFKSW,PFDAABN     ABEND HAS OCCURED?\n         BO    LSPF42              YES\n         MVC   QDMSG(27),=CL27'*** DATA-SET OPEN ERROR ***'\n         LA    R2,27\n         B     LSPF46\nLSPF42   ICM   R2,B'1111',=CL4'OPEN'\n         BAS   R14,LSPFSCC\n         B     LSPF46\nLSPF43   MVC   QDMSG(35),=CL35'*** DATA-SET : DCBRECFM INVALID ***'\n         LA    R2,35\n         B     LSPF45\nLSPF44   MVC   QDMSG(34),=CL34'*** DATA-SET : DCBLRECL NOT 80 ***'\n         LA    R2,34\nLSPF45   CLOSE MF=(E,QCPFKCL)      CLOSE DATA-SET\nLSPF46   MVI   QCPFKSW,0           RESET ALL\n         MVC   DAFRDDN,DAALDDN     COPY DDNAME RETURNED BY DAIR\n         MVI   DAIRFLAG,DFFREE     REQUEST FREE FUNCTION\n         QCALL ALLOCATE            FREE IT BY DDNAME\n         LR    R0,R2               ERROR MESSAGE LENGTH\n         B     LSPFTILT\nLSPF50   TM    QCPFKSW,PFRFERR     RECFM ERROR?\n         BO    LSPF43              YES\n         TM    QCPFKSW,PFLRERR     LRECL ERROR?\n         BO    LSPF44              YES\n         OI    QCPFKSW,PFDAOP      SAY OPENED\n         LH    R0,QCPFKPS+(DCBBLKSI-IHADCB)\n         LTR   R0,R0\n         BP    *+L'*+4\n         LH    R0,QCPFKPS+(DCBLRECL-IHADCB)\n         L     R4,=A(PFKSVL)\n         XR    R3,R3\n         XR    R1,R1\nLSPF51   CR    R4,R3\n         BNH   LSPF52\n         AR    R3,R0\n         LA    R1,1(,R1)\n         B     LSPF51\nLSPF52   AR    R3,R0               ONE MORE FOR SECURITY\n         CL    R3,=A(WASSZ)        WORK SPACE LARGE ENOUGH?\n         BNH   LSPF53              YES\n         MVC   QDMSG(35),=CL35'*** WORK SIZE (WASSZ) TOO SMALL ***'\n         LA    R2,35\n         B     LSPF45\nLSPF53   L     R2,QCWA             USE WORK SPACE AS I/O AREA\n         LR    R4,R2\n         XR    R5,R5\n         MVCL  R2,R4               ZEROES NEEDED AREA\n         L     R2,QCWA\n         TM    QCPFKSW,PFDAIN      IN PLACE?\n         BO    UPPF2               YES\n         CLI   QCODE,16            NO, LOAD REQUESTED?\n         BNE   SVPF1               NO\n         LA    R6,1(R1)            YES, CONTROL NUMBER OF RECORDS\nUPPF2    LR    R4,R0\nLDPF1    READ  QCPDECB,SF,,(R2),'S',MF=E     READ RECORDS\n         CHECK QCPDECB\n         TM    QCPFKSW,PFDAERR+PFDAABN  ERROR OR ABEND HAS OCCURED?\n         BNZ   LSPFEND             YES\n         TM    QCPFKSW,PFDAIN      IN PLACE?\n         BO    UPPF3               YES\n         AR    R2,R4               NO, BUMP POINTER\n         BCT   R6,LDPF1            LOOP CONTROL\n         B     LSPFEND             TRUNCATE HERE, WE ARE STILL ONE MORE\nUPPF3    LR    R0,R4\n         LR    R6,R2\n         L     R2,QCWA\nSVPF1    L     R3,=A(PFKTABL)\n         LA    R4,PFKTAB\n         LR    R5,R3\n         MVCL  R2,R4               COPY PFK-TABLE TO AREA\n         TM    QCPFKSW,PFDAIN      IN PLACE?\n         BZ    SVPF2               NO\n         LR    R2,R6               YES\n         B     UPPF4\nSVPF2    L     R2,QCWA\n         LR    R3,R1\nUPPF4    LR    R4,R0\nSVPF3    WRITE QCPDECB,SF,,(R2),'S',MF=E     WRITE RECORDS\n         CHECK QCPDECB\n         TM    QCPFKSW,PFDAERR+PFDAABN  ERROR OR ABEND HAS OCCURED?\n         BNZ   LSPFEND             YES\n         AR    R2,R4               NO, BUMP POINTER\n         TM    QCPFKSW,PFDAIN      IN PLACE?\n         BO    LDPF1               YES\n         BCT   R3,SVPF3\n         B     LSPFEND\n         CNOP  0,4\n*        DCB EXIT ROUTINE          R2 -> R13 = AS OPEN ISSUED\n         USING IHADCB,R1\nLSPFEXT  TM    DCBRECFM,DCBRECF    TEST FIXED RECORDS\n         BZ    *+L'*+8\n         TM    DCBRECFM,DCBRECV\n         BZ    *+L'*+6\n         OI    QCPFKSW,PFRFERR     SAY RECFM ERROR\n         BR    R14                 RETURN\n         CLC   DCBLRECL,LSPFLR     TEST RECORD LENGTH\n         BER   R14                 RETURN\n         OI    QCPFKSW,PFLRERR     SAY LRECL ERROR\n         BR    R14                 RETURN\n         DROP  R1\nLSPFLR   DC    H'80'               REQUESTED LRECL\nLSPFXLS  DC    0F'0',XL1'05',AL3(LSPFEXT)\n*        DC    XL1'91',AL3(LSPFABX)\n         CNOP  0,4\n*        SYNAD EXIT ROUTINE        R2 -> R13 = AS GET/PUT ISSUED\nLSPFERR  STM   R13,R1,QCPFSV\n         SYNADAF ACSMETH=BSAM\n         MVC   QDMSG(78),50(R1)    GET MESSAGE TEXT\n         SYNADRLS\n         OI    QCPFKSW,PFDAERR     SAY ERROR OCCURED\n         LM    R13,R1,QCPFSV\n         BR    R14                 RETURN\n         CNOP  0,4\n*        DCB ABEND ROUTINE         R2 -> R13 = AS OPEN ... ISSUED\nLSPFABX  TM    3(R1),B'00000100'   OPTION MASK = OK TO IGNORE?\n         BO    *+L'*+6             YES\n         NI    3(R1),B'11110001'   NO, IMMEDIATE ABEND\n         BR    R14\n         MVC   QCSCCRC(3),0(R1)    SAVE ABEND CODES\n         OI    QCPFKSW,PFDAABN     SAY ABEND\n         NI    3(R1),B'11110101'   OK TO IGNORE ONLY\n         BR    R14                 RETURN\nLSPFSCC  MVC   QDMSG(36),=CL36'*** DATA-SET      ABEND :    /   ***'\n         STCM  R2,B'1111',QDMSG+13\n         UNPK  QDMSG+26(3),QCSCCRC(2)\n         TR    QDMSG+26(3),HEXTAB-X'F0'\n         UNPK  QDMSG+30(3),QCSCCRC+2(2)\n         TR    QDMSG+30(2),HEXTAB-X'F0'\n         MVI   QDMSG+32,C' '\n         LA    R2,36\n         BR    R14\n         CNOP  0,4\n*        EODAD EXIT\nLSPFEND  NI    QCPFKSW,255-PFDAOP  SAY CLOSED\n         CLOSE MF=(E,QCPFKCL)      CLOSE DATA-SET\n         NI    QCPFKSW,255-PFDAAL  SAY DE-ALLOCATED\n         MVI   DAIRFLAG,DFFREE     REQUEST FREE FUNCTION\n         MVC   DAFRDDN,QCPFKPS+(DCBDDNAM-IHADCB)  GET THE DDNAME\n         QCALL ALLOCATE            FREE IT BY DDNAME\n         TM    QCPFKSW,PFDAERR+PFDAABN  ERROR OR ABEND HAS OCCURED?\n         BZ    LSPFOK              NO\n         TM    QCPFKSW,PFDAABN     ABEND HAS OCCURED?\n         BZ    LSPFERM             NO\n         NI    QCPFKSW,255-PFDAABN RESET ABEND INDICATOR\n         CLI   QCODE,12            SAVE WAS REQUESTED?\n         BE    *+L'*+8             YES\n         ICM   R2,B'1111',=CL4'LOAD'\n         B     *+L'*+4\n         ICM   R2,B'1111',=CL4'SAVE'\n         BAS   R14,LSPFSCC\n         LR    R0,R2               ERROR MESSAGE LENGTH\n         B     LSPFTILT\nLSPFERM  NI    QCPFKSW,255-PFDAERR RESET ERROR INDICATOR\n         LA    R0,78               ERROR MESSAGE LENGTH\nLSPFTILT LA    R1,QDMSG            ERROR MESSAGE\n         QTILT ,                   BACK WITH ERROR MESSAGE\nLSPFOK   CLI   QCODE,12            SAVE WAS REQUESTED?\n         BE    SETPFDP             YES, GO DISPLAY PF-KEYS\n         L     R14,QCWA            POINT TO KEYS DEFINITIONS\n         B     RSPFK+L'RSPFK       GO STORE PF-KEYS\n         SPACE 1\n*---     RESET ALL PF-KEYS TO ORIGINAL VALUES                      ---*\n         SPACE 1\nRSPFK    L     R14,=A(PFKTAB)      POINT TO ORIGINAL DEFINITIONS\n         LA    R15,PFKTAB          POINT TO TABLE ENTRY\n         LH    R0,=Y(PFKNO)        NUMBER OF PFK'S\nRSPFKL   CLC   0(1,R15),0(R14)     KEY MATCHES?\n         BNE   *+L'*+6             NO\n         MVC   1(L'PFKTAB-1,R15),1(R14) SET DEFINITION\n         LA    R14,L'PFKTAB(R14)   POINT TO NEXT\n         LA    R15,L'PFKTAB(R15)\n         BCT   R0,RSPFKL           FILL ALL PFK'S\n         B     SETPFDP             GO DISPLAY PF-KEYS\n         SPACE 1\n*---     SET A PF-KEY TO VALUE                                     ---*\n         SPACE 1\nSETPF    LH    R1,QLNG1            YES, LENGTH OF PFK-ID\n         SH    R1,=H'1'            NOT SPECIFIED?\n         BM    SETPFDP             NO, GO JUST DISPLAY PF-KEYS\n         CLI   QPARM1,C'0'         YES, IS FIRST CHARACTER NUMERIC?\n         BL    SETTILT             NO, TILT IF NOT NUMERIC\n         LA    R15,QPARM1          POINT TO PFK NUMBER\n         BAS   R14,QNUMCONV        CONVERT IT\n         BNE   SETTILT             TILT IF NOT NUMERIC\n         CH    R15,=Y(PFKNO)       VALID PFK NUMBER?\n         BNH   SETPFOK             YES\nSETTILT  QTILT '*** PFK NUMBER IS INVALID ***'\nSETTILTX QTILT '*** PFK COMMAND TEXT MISSING ***'\nSETPFOK  OC    QOFF2,QOFF2         COMMAND TEXT SUPPLIED?\n         BZ    SETTILTX            NONE\n         BCTR  R15,0               RELATIVE PFK NUMBER\n         MH    R15,=Y(L'PFKTAB)    DISPLACEMENT IN PF-TABLE\n         LA    R15,PFKTAB(R15)     POINT TO TABLE ENTRY\n         LA    R14,QDREPLY         POINT TO REPLY AREA\n         AH    R14,QOFF2           ADD OFFSET PAST PFK NUMBER\n         MVC   1(L'PFKTAB-1,R15),0(R14) SET NEW DEFINITION\nSETPFDP  MVC   QPARM1(3),=CL3'PFK' SPECIFY PF-KEYS DISPLAY\n         SPACE 1\n*---     DISPLAY HELP INFORMATION                                  ---*\n         SPACE 1\nHELPREQ  CLI   QPARM1,C' '         DID USER SPECIFY PANEL?\n         BE    HELPALL             NO, ALL\n         CLC   QPARM1(3),=CL3'PFK' DID USER SPECIFY PF-KEYS?\n         BNE   *+L'*+4             NO\n         MVI   QPARM1+1,C' '       YES, SET PF-KEYS PANEL\n         LA    R5,QPARM1\n         BAS   R6,HELPDSPP\n         B     HELPEXIT\nHELPALL  BAS   R5,HELPDSPL\n         DC    CL2'Q '             QUEUE/SPOOL\n         BAS   R5,HELPDSPL\n         DC    CL2'QN'             QUEUE/SPOOL NOTES\n         BAS   R5,HELPDSPL\n         DC    CL2'J '             JOBS DATA-SETS\n         BAS   R5,HELPDSPL\n         DC    CL2'JN'             JOBS DATA-SETS NOTES\n         BAS   R5,HELPDSPL\n         DC    CL2'E '             EXTENDED SERVICES\n         CLI   QXAUTH,LV12         IS THE USER AUTHORIZED?\n         BL    HELPPFK             NO, SKIP\n         BAS   R5,HELPDSPL\n         DC    CL2'O '             OPERATOR SERVICES\n         CLI   QXAUTH,LV15         IS THE USER PRIVILEGED?\n         BL    HELPPFK             NO, SKIP\n         BAS   R5,HELPDSPL\n         DC    CL2'D '             PRIVILEGED\nHELPPFK  BAS   R5,HELPDSPL\n         DC    CL2'PN'             SET PF-KEYS SERVICES\n         BAS   R5,HELPLAST\n         DC    CL2'P '             PF-KEYS DISPLAY\nHELPEXIT OI    QDOVER,QESKIP       REQ TO SKIP END OF DATA\nHELPBACK QSTOP\n         SPACE 1\nHELPDSPL OI    QDOVER,QPFORCE      FORCE PAGE DISPLAY\nHELPLAST LA    R6,2(R5)            SET RETURN\nHELPDSPP L     R4,=V(QSPHELP)      HELP PANELS DATA\nHELPSRCH CLC   0(2,R4),=XL2'0'     END OF VECTOR?\n         BE    HELPERR             YES, UNEXISTANT\n         CLC   0(2,R4),0(R5)       THIS PANEL?\n         BE    HELPDFND            YES\n         LA    R4,6(R4)            NO, BUMP TO NEXT IN VECTOR\n         B     HELPSRCH            CONTINUE SEARCH\nHELPDFND ICM   R1,B'1111',2(R4)    GET PANEL DATA ADDRESS\n         MVC   QDHLINE,0(R1)       MOVE HEADING\n         CLC   0(2,R4),=CL2'P '    PF-KEYS DISPLAY PANEL?\n         BE    HELPIPFK            YES\n         LH    R0,80(R1)           NO, GET LENGTH\n         LA    R1,82(,R1)          SET PANEL ADDRESS\nHELPSND  QCALL DISPLAY,(R1),(R0)   DISPLAY HELP PANEL\n         BR    R6                  RETURN\nHELPIPFK L     R2,QCWA             BUILD PF-KEYS PANEL\n         LH    R3,80(R1)\n         LA    R14,82(,R1)\n         LR    R15,R3\n         MVCL  R2,R14\n         LH    R0,=Y(PFKNO)\n         LA    R2,8(,R4)\n         LA    R15,PFKTAB\nHELPSPFK LH    R14,0(R2)\n         AL    R14,QCWA\n         MVC   0(L'PFKTAB-1,R14),1(R15)\n         LA    R2,2(,R2)\n         LA    R15,L'PFKTAB(R15)\n         BCT   R0,HELPSPFK\n         LH    R0,80(R1)           GET LENGTH\n         L     R1,QCWA             SET PANEL ADDRESS\n         B     HELPSND             GO DISPLAY PF-KEYS PANEL\nHELPERR  NI    QDOVER,255-QPFORCE\n         MVC   QDMSG(L'HELPMSG),HELPMSG\n         MVC   QDMSG+L'HELPMSG-7(2),0(R5)\n         LA    R1,QDMSG\n         LA    R0,L'HELPMSG\n         QTILT\nHELPMSG  DC    C'=== UNEXISTANT HELP PANEL (  ) ==='\n         SPACE 1\n         DS    0F\nALLOCPFK DC    2CL8' '             UNIT & VOLSER\n         DC    4F'0'               BLKSIZE / PRI / SEC / DIR\n         DC    2CL8' '             MEMBER & PASSWORD\n         DC    AL1(DA08SHR)        STAT=SHR\n         DC    AL1(DA08KEEP)       DISP=KEEP\n         DC    AL1(DA08KEP)        DISP=KEEP\n         DC    AL1(DA08UID)        PREFIX_USERID TO DSNAME\n         DC    F'0',CL8' '\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9,R10,R11,R12\n TITLE '--- QUEUE/SP -- DDNAME -- LIST DDNMS && DSIDS FOR A JOB ---'\nDDNAME   QSTART\n         USING QCKPT,R10           BASE FOR CHECKPOINT WORK AREA\n         L     R10,QVCKPT          LOAD BASE REG\n         USING QDISPLAY,R9         BASE REG FOR DISPLAY WORK AREA\n         L     R9,QVDSPL           LOAD BASE REG\n         SPACE 1\n*---     CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT              ---*\n         SPACE 1\n         QCALL FINDJOB             FIND THE JOB\n         SPACE 1\n*---     BUILD TABLE OF DSID'S AND RECORDS COUNTS                  ---*\n         SPACE 1\n         L     R6,QCSTART          -> TABLE AREA\n         MVI   DDN@SW,0            HAVEN'T READ SPIN IOT YET\n         L     R5,QCIOTA           -> IOT\n         USING IOTSTART,R5\n         MVC   PGMNAME(80),QBLANK  BLANK THE DISPLAY LINE\nDD$IOTLP CLC   IOTID,=CL4'IOT'     WAS AN IOT READ FROM SPOOL?\n         BNE   DD$TILTB            NO, ERROR\n         CLC   QPJOBID,IOTJBKEY    IS THE IOT'S JOB KEY VALID?\n         BNE   DD$TILTB            NO, ERROR\n         LR    R4,R5               BASE OF IOT\n         SL    R4,=A(IOTSTART-IOT) ADJUST FOR HEADER\n         LR    R2,R4               COPY IT\n         A     R4,IOTPDDBP         OFFSET BEYOND LAST PDDB\n         A     R2,IOTPDDB          OFFSET TO FIRST PDDB IN IOT\n         USING PDB,R2\nDD$PDBLP LH    R1,PDBDSKEY         GET DSID\n         LTR   R1,R1               IS IT 0?\n         BZ    NXT$DSID            YES - IGNORE IT\n         TM    PDBFLAG1,PDB1NSOT   NOT FOR SYSOUT?\n         BZ    DD$SYOUT            NO - IT'S FOR SYSOUT\n         CH    R1,=H'2'            IT IS 2 THRU 4?\n         BL    DD$SYOUT            NO - OK\n         CH    R1,=H'4'            IT IS 2 THRU 4?\n         BNH   NXT$DSID            YES - IGNORE IT BECAUSE IT IS\n*                                  MARKED 'NOT FOR SYSOUT' AND IS\n*                                  THE JOBLOG, JOBMSG, OR JCL DS,\n*                                  WHICH ARE DUPLICATED ON THE\n*                                  SPIN IOT WITHOUT THE 'NOT FOR\n*                                  SYSOUT' FLAG SET\nDD$SYOUT MVI   0(R6),SW@FOUND      INDICATE FOUND\n         CVD   R1,DDN@DWD          CONVERT TO PACKED\n         OI    DDN@DWD+7,X'0F'     REMOVE SIGN\n         UNPK  1(4,R6),DDN@DWD     MAKE IT PRINTABLE\n         MVC   DSID,QBLANK         CLEAR DISPLAY FIELD\n         CLC   =H'100',PDBDSKEY    A PROBLEM PROGRAM DATA-SET?\n         BL    DD$PDBSV            YES - GO SAVE IT\n         CLI   QXAUTH,LV10         AUTHORIZED USER?\n         BL    *+L'*+6 >======+    NO - DON'T DISPLAY DSID\n         MVC   DSID,1(R6)     I    YES - MOVE DSID TO PRINT LINE\n         MH    R1,=H'6'  <====+    ENTRIES ARE 6 BYTES EACH\n         LA    R1,DSIDTYPE-6(R1)   -> TYPE\n         CLI   QXAUTH,LV10         AUTHORIZED USER?\n         BNL   DD$AUTH1            YES - SHOW HIM EVERYTHING\n         CLI   PDBDSKEY+1,1        INPUT JCL?\n         BE    NXT$DSID            YES - DON'T SHOW IT\n         CLI   PDBDSKEY+1,4        JOBLOG/JCL/JOBMSG?\n         BH    NXT$DSID            NO - DON'T SHOW IT\nDD$AUTH1 MVC   DSTYPE,0(R1)        MOVE IN SYSTEM DSTYPE\n         TM    PDBFLAG1,PDB1HOLD   HELD DATA-SET?\n         BNO   *+L'*+6 >======+    NO - SKIP\n         MVC   HELD,=C'H-'    I    YES - INDICATE\n         L     R0,PDBRECCT  <=+    GET RECORD COUNT\n         CVD   R0,DDN@DWD          CONVERT TO PACKED\n         MVC   RECORDS,=XL8'4020202020202120'     MOVE IN EDIT MASK\n         ED    RECORDS,DDN@DWD+4\n         BAS   R8,DDN$DISP         ADD THIS LINE TO SCREEN\n         B     NXT$DSID            DON'T SAVE THIS ONE\nDD$PDBSV MVC   0(1,R6),DDN@SW      SAVE SPIN INDICATOR\n         TM    PDBFLAG1,PDB1HOLD   HELD DATA-SET?\n         BNO   *+L'*+4             NO - SKIP\n         OI    0(R6),SW@HELD       YES - REMEMBER THIS TIDBIT\n         MVC   5(4,R6),PDBRECCT    SAVE RECORD COUNT\n         LA    R6,9(,R6)           -> NEXT SLOT\n         LA    R0,9(,R6)           -> THE ONE AFTER THE NEXT\n         C     R0,QCEND            DOES THE NEXT ONE FIT?\n         BL    NXT$DSID            YES - OK\n         QTILT '*** TOO MANY DSIDS ***'\nDD$TILTB QTILT '*** JOB HAS PURGED (OR IOT IS INVALID) ***'\nNXT$DSID LA    R2,PDBLENG(,R2)     -> NEXT PDDB\n         CR    R2,R4               PAST LAST PDDB?\n         BL    DD$PDBLP            NO - DO NEXT\n         L     R4,IOTIOTTR         DISK ADDR OF NEXT IOT\nDD$RDIOT LTR   R4,R4               ANY MORE?\n         BZ    DD$SPIOT            NO - TRY SPIN IOT\n         BAS   R8,DDN$READ         READ THE IOT\n         B     DD$IOTLP            PROCESS IT\nDD$SPIOT L     R1,QCJCTA           -> JCT\n         TM    DDN@SW,SW@SPIN      SPIN IOT SEARCHED ALREADY?\n         BO    DD$OKIOT            YES - DONE READING IOT'S\n         L     R4,JCTSPIOT-JCTSTART(,R1)     DISK ADDR OF SPIN IOT\n         OI    DDN@SW,SW@SPIN      INDICATE SPIN IOT'S\n         B     DD$RDIOT            GO READ THE SPIN IOT\nDD$OKIOT MVI   0(R6),SW@END        SET END FLAG\n         L     R4,JCTIOT-JCTSTART(,R1)  DISK ADDR OF IOT\n         BAS   R8,DDN$READ         READ IOT\n         DROP  R2,R5\n         SPACE 1\n*---     LOCATE PDDB NUMBER 5                                      ---*\n         SPACE 1\n         USING PDB,R2              BASE REG FOR PDDB\n         L     R3,QCIOTA           LOAD BASE REG\n         USING IOTSTART,R3         BASE REG FOR IOT\n         CLC   IOTID,=CL4'IOT'     WAS AN IOT READ FROM SPOOL?\n         BNE   DD$NONE             NO\n         CLC   QPJOBID,IOTJBKEY    IS THE IOT'S JOB KEY VALID?\n         BNE   DD$NONE             NO\n         LR    R4,R3               BASE OF IOT\n         SL    R4,=A(IOTSTART-IOT) ADJUST FOR HEADER\n         LR    R2,R4               COPY IT\n         A     R4,IOTPDDBP         OFFSET BEYOND LAST PDDB\n         A     R2,IOTPDDB          OFFSET TO  FIRST PDDB IN IOT\n         MVC   QPDSID,=H'0'        NULLIFY VALIDITY FOR LISTDS\nFINDDS1  CLC   =H'5',PDBDSKEY      IS THIS THE DATA-SET?\n         BE    FOUNDDS1            YES, CONTINUE\n         LA    R2,PDBLENG(,R2)     NO, LOOK AT NEXT PDDB\n         CR    R2,R4               PAST THE LAST PDDB?\n         BL    FINDDS1             NO, TRY AGAIN\nDD$NONE  QTILT '*** JOB DOES NOT HAVE DD TABLE ***'\nFOUNDDS1 L     R4,PDBMTTR          DISK ADDR OF FIRST BLOCK\n         L     R5,QCBLKA           ADDR OF DATA-SET BLOCK IOAREA\n         MVC   QDMSG,QBLANK        BLANK OUT THE MESSAGE AREA\n         B     DDNFIRST            PROCESS DATA-SET\n         SPACE 1\n*---     PROCESS DATA-SET                                          ---*\n         SPACE 1\n         USING BUFSTART,R5\nDDNXTBLK L     R4,HDBNXTRK         DISK ADDR OF NEXT BLOCK\nDDNFIRST LTR   R4,R4               IS THE DISK ADDR ZERO?\n         BZ    DDN$END             YES, END OF DATA-SET\n         BAS   R8,DDN$READ         READ A BLOCK\n         CLC   QPJOBID,HDBJBKEY    DOES THE JOBID MATCH?\n         BNE   DDN$END             NO, END OF DATA-SET\n         CLC   HDBPDDBK,=H'5'      IS THE DSID 5?\n         BNE   DDN$END             NO, END OF DATA-SET\n         LA    R4,HDBSTART         ADDR OF FIRST RECORD IN BLOCK\n         SPACE 1\n*---     PROCESS RECORDS (SKIP SPANNED)                            ---*\n         SPACE 1\n         USING LRC,R4\nNEXTREC1 CLI   LRCTLENG,ENDIND     IS LENGTH BYTE FF?\n         BE    DDNXTBLK            YES, END OF BLOCK\n         TM    LRCFLAG1,LRC1SPAN   IS THIS A SPANNED RECORD?\n         BO    DDN$SPAN            YES, SKIP IT\n         ZIC   R6,LRCTLENG         INSERT LENGTH\n         TM    LRCTEXT+2,2         IS THIS AN EXEC RECORD?\n         BO    EXEC                YES, PROCESS IT\n         TM    LRCTEXT+2,4         IS THIS A DD RECORD?\n         BO    DD                  YES, PROCESS IT\nSKIPREC  LA    R4,LRCTEXT(R6)      INCREMENT TO NEXT RECORD\n         B     NEXTREC1            PROCESS NEXT RECORD\nDDN$SPAN LH    R6,LRCSEGL          LENGTH OF SEGMENT\n         TM    LRCFLAG1,LRC1SBGN   IS THIS THE FIRST SEGMENT?\n         BO    SPAN1ST1            YES, USE HEADER LENGTH OF 6\n         LA    R4,LRCSTEXT(R6)     INCREMENT TO NEXT RECORD\n         B     NEXTREC1            PROCESS NEXT RECORD\nSPAN1ST1 LA    R4,LRCSFTXT(R6)     INCREMENT TO NEXT RECORD\n         B     NEXTREC1            PROCESS NEXT RECORD\n         SPACE 1\n*---     PROCESS AN EXEC RECORD                                    ---*\n         SPACE 1\nEXEC     CLI   LRCTEXT+4,EXECK     IS THERE A STEPNAME?\n         BNE   SKIPREC             NO, SKIP THIS RECORD\n         ZIC   R1,LRCTEXT+6        LENGTH OF PROCSTEP/STEPNAME\n         TM    LRCTEXT+3,X'20'     EXEC PROC=XXXX?\n         BO    EXECPROC            YES, HANDLE IT\n         SPACE 1\n*---     ASSUME (FOR LACK OF KNOWLEDGE TO                          ---*\n*---     THE CONTRARY) THAT IT'S PGM=                              ---*\n         SPACE 1\n         LA    R15,PROCSTEP        ASSUME IN PROC\n         TM    LRCTEXT+3,X'08'     IN A PROC?\n         BO    EXECINPR            YES, OK\n         LA    R15,STEPNAME        POINT TO WHERE STEPNAME GOES\n         MVC   PROCSTEP,=C'  N/A   '    INDICATE NO PROCSTEP NAME\n         MVC   PROCNAME,=C' (NONE) '    THERE IS NO PROCEDURE IN EFFECT\nEXECINPR MVC   0(8,R15),=C' (NONE) '    CLEAR IT\n         MVC   PGMNAME,=C' (NONE) '     AND THIS TOO\n         SH    R1,=H'1'            -1 FOR EX\n         BM    *+L'*+10    >=======+    SKIP IF NO STEPNAME\n         MVC   0(8,R15),QBLANK     I    CLEAR THE FIELD FIRST\n         EX    R1,MVCSTEP          I    MOVE THE STEPNAME\n         LA    R15,LRCTEXT+8(R1) <=+    POINT TO PGMNAME KEY\n         CLI   0(R15),PGMEK        IS THIS THE PROGRAM NAME?\n         BNE   SKIPREC             NO, DONE WITH THIS RECORD\n         CLI   2(R15),X'83'        IS THIS PGM=*.STEP.DDNAME?\n         BE    EXECSTAR            YES, HANDLE IT\n         ZIC   R1,2(,R15)          GET PGMNAME LENGTH\n         SH    R1,=H'1'            -1 FOR EX\n         BM    SKIPREC             SKIP IF NONE\n         MVC   PGMNAME,QBLANK      CLEAR THE FIELD\n         EX    R1,MVCPGM           MOVE PGM NAME\n         B     SKIPREC             CONTINUE PROCESSING\nEXECSTAR MVC   PGMNAME,=C'*.DDNAME'     THE REAL WHOLE THING WON'T FIT\n         B     SKIPREC             IGNORE THE REST OF THE RECORD\nEXECPROC MVC   PROCSTEP,=C' (NONE) '    INIT FIELD\n         MVC   STEPNAME,=C' (NONE) '    THIS ONE TOO\n         MVC   PROCNAME,=C' (NONE) '    AND YET ANOTHER ONE\n         MVC   PGMNAME,=C' (NONE) '     AND THIS TOO\n         SH    R1,=H'1'            -1 FOR EX\n         BM    *+L'*+10    >=======+    SKIP IF NONE\n         MVC   STEPNAME,QBLANK     I    BLANK THE FIELD\n         EX    R1,MVCPSTEP         I    MOVE STEPNAME\n         LA    R15,LRCTEXT+8(R1) <=+    POINT TO PROCNAME OR NEXT UNIT\n         CLI   LRCTEXT+5,2         ARE THERE 2 POSITIONAL UNITS?\n         BE    EXECPR03            YES, GO PROCESS IT\n         CLI   0(R15),PROCEK       EXPLICIT EXEC PROC= ?\n         BNE   SKIPREC             NO, GET OUT\n         LA    R15,2(,R15)         POINT TO PROCNAME LENGTH\nEXECPR03 ZIC   R1,0(,R15)          GET PROCNAME LENGTH\n         SH    R1,=H'1'            -1 FOR EX\n         BM    SKIPREC             IGNORE IF NONE\n         MVC   PROCNAME,QBLANK     BLANK THE FIELD\n         EX    R1,MVCPROC          MOVE PROCNAME\n         B     SKIPREC             DONE WITH THIS RECORD\n         SPACE 1\n*---     PROCESS DD RECORDS                                        ---*\n         SPACE 1\nDD       TM    LRCTEXT+3,X'30'     IS THIS A SYSIN OR SYSOUT DD?\n         BZ    SKIPREC             NO, SKIP THE RECORD\n         MVC   DDN,QBLANK          BLANK OUT THE DDNAME\n         MVC   DSID,QBLANK         BLANK OUT THE DSID\n         LA    R7,LRCTEXT+4        ADDR OF FIRST KEY\n         LR    R8,R6               REMAINING LENGTH OF RECORD\n         XR    R15,R15             CLEAR FOR IC\n         XR    R14,R14             CLEAR FOR IC\n         XR    R1,R1               CLEAR FOR IC\nTRYFLD   CLI   0(R7),DDK           IS THIS THE DDNAME?\n         BE    DDKEY               YES, PROCESS IT\n         CLI   0(R7),DSNAMEK       IS THIS THE DSNAME?\n         BE    DSKEY               YES, PROCESS IT\nNEXTFLD  IC    R1,1(,R7)           NUMBER OF SUBFIELDS\n         LA    R7,2(,R7)           UPDATE LOCATION\n         SH    R8,=H'2'            REMAINING COUNT\n         SR    R8,R1               REMAINING COUNT\n         BNP   SKIPREC             RECORD IS EXHAUSTED\n         LTR   R1,R1               ARE THERE ANY SUBFIELDS?\n         BZ    TRYFLD              NO, TRY NEXT FIELD\nLOOPFLD  TM    0(R7),X'80'         IS THIS A SUB-SUB-FIELD\n         BZ    NOSUB               NO, CONTINUE\n         NI    0(R7),X'7F'         CLEAR THE HEX 80 BIT\n         IC    R14,0(,R7)          NUMBER OF SUB-SUB-FIELDS\n         LA    R7,1(,R7)           UPDATE LOCATION\n         SH    R8,=H'1'            REMAINING COUNT\n         SR    R8,R14              REMAINING COUNT\n         BNP   SKIPREC             RECORD IS EXHAUSTED\n         AR    R1,R14              INCREASE NUMBER OF SUBFIELDS\n         B     YESSUB              DECREMENT AND TRY AGAIN\nNOSUB    IC    R15,0(,R7)          SUBFIELD LENGTH\n         LA    R7,1(R15,R7)        ADD TO LOCATION\n         SR    R8,R15              REMAINING COUNT\n         BNP   SKIPREC             RECORD IS EXHAUSTED\nYESSUB   BCT   R1,LOOPFLD          DO NEXT SUBFIELD\n         B     TRYFLD              TRY NEXT FIELD\nDDKEY    IC    R1,2(,R7)           LENGTH OF DDNAME\n         LTR   R1,R1               IS THE LENGTH ZERO?\n         BZ    NEXTFLD             YES, SKIP THE FIELD\n         BCTR  R1,0                DECREMENT BY 1\n         EX    R1,MVCDDN           MOVE THE DDNAME\n         B     NEXTFLD             PROCESS NEXT FIELD\nDSKEY    MVC   DSID,19(R7)         MOVE THE DSID\n         MVC   DSTYPE,=C'*ERROR'   INIT FIELD\n         TM    LRCTEXT+3,X'20'     SYSOUT?\n         BNO   *+L'*+6             NO, SKIP\n         MVC   DSTYPE,=C'SYSOUT'\n         TM    LRCTEXT+3,X'10'     SYSIN?\n         BNO   *+L'*+6             NO, SKIP\n         MVC   DSTYPE,=C'SYSIN '\n         TM    LRCTEXT+3,X'30'     BOTH?\n         BNO   *+L'*+6             NO, SKIP\n         MVC   DSTYPE,=C'ERROR*'\n         DROP  R4,R5\n         L     R1,QCSTART          -> DSID TABLE\n         MVC   RECORDS,QBLANK      ASSUME WE WON'T FIND ANYTHING\n         MVC   HELD,QBLANK         ...\nDSID$LP  TM    0(R1),SW@END        HIT END OF TABLE?\n         BO    NO$COUNT            YES, IT'S NOT HERE\n         CLC   DSID,1(R1)          THIS IT?\n         BE    DSID$GOT            YES\n         LA    R1,9(,R1)           -> NEXT ENTRY\n         B     DSID$LP\nDSID$GOT L     R0,5(,R1)           GET RECORD COUNT\n         CVD   R0,DDN@DWD          CONVERT TO PACKED\n         TM    0(R1),SW@HELD       HELD DATA-SET?\n         BNO   *+L'*+6             NO, SKIP\n         MVC   HELD,=C'H-'         YES, INDICATE\n         OI    0(R1),SW@FOUND      INDICATE THIS ONE'S BEEN USED\n         MVC   RECORDS,=XL8'4020202020202120'     MOVE IN EDIT MASK\n         ED    RECORDS,DDN@DWD+4\nNO$COUNT BAS   R8,DDN$DISP         CALL DISPLAY FOR THIS LINE\n         MVC   PROCSTEP,QBLANK     RESET\n         MVC   STEPNAME,QBLANK           THESE\n         MVC   PROCNAME,QBLANK                 FIELDS\n         MVC   PGMNAME,QBLANK                         ...\n         B     SKIPREC             PROCESS NEXT RECORD\n         SPACE 1\n*---     DISPLAY SPIN-IOT DSID'S AND NON-SPIN DSID'S THAT WEREN'T  ---*\n*---     CLAIMED BY PREVIOUS CODE                                  ---*\n         SPACE 1\nDDN$END  MVC   PGMNAME(80),QBLANK  DON'T KNOW PGM NAMES ANYMORE\n         L     R6,QCSTART          -> DSID TABLE\nDD$SPLP  TM    0(R6),SW@END        END OF TABLE?\n         BO    DDN$STOP            YES, FINALLY DONE\n         TM    0(R6),SW@FOUND      ALREADY DISPLAYED?\n         BO    DD$NXTDS            YES, SKIP IT NOW\n         MVC   DSID,1(R6)          MOVE IN DSID\n         MVC   DSTYPE,=C'*LOST*'   UNCLAIMED DATA-SET\n         TM    0(R6),SW@SPIN       SPIN?\n         BNO   *+L'*+6             NO, SKIP\n         MVC   DSTYPE,=C'<SPIN>'   YES, SAY SO\n         L     R0,5(,R6)           GET RECORD COUNT\n         CVD   R0,DDN@DWD          CONVERT TO PACKED\n         MVC   RECORDS,=XL8'4020202020202120'     MOVE IN EDIT MASK\n         ED    RECORDS,DDN@DWD+4   PUT IN RECORD COUNT\n         BAS   R8,DDN$DISP         MOVE LINE TO SCREEN\nDD$NXTDS LA    R6,9(,R6)           -> NEXT DSID ENTRY\n         B     DD$SPLP             FORMAT IT\n         SPACE 1\n*---     LEAVE THIS ROUTINE                                        ---*\n         SPACE 1\nDDN$STOP QSTOP\n         SPACE 1\n*---     READ A BLOCK FROM HASPACE                                 ---*\n         SPACE 1\nDDN$READ ST    R4,QCTRAK           STORE DISK ADDR\n         LR    R1,R5               IOAREA ADDRESS\n         QCALL READSPC             READ HASPACE\n         BR    R8                  RETURN TO CALLER\n         SPACE 1\n*---     CALL DISPLAY TO ADD A LINE TO SCREEN                      ---*\n         SPACE 1\nDDN$DISP MVC   QDHLINE,DDN#HEAD    MOVE IN HEADING\n         QCALL DISPLAY,QDMSG,80\n         BR    R8                  RETURN TO MAINLINE\n         SPACE 1\nMVCPSTEP MVC   STEPNAME(*-*),10(R4)     << EXECUTED >>\nMVCPROC  MVC   PROCNAME(*-*),1(R15)     << EXECUTED >>\nMVCSTEP  MVC   0(*-*,R15),10(R4)        << EXECUTED >>\nMVCPGM   MVC   PGMNAME(*-*),3(R15)      << EXECUTED >>\nMVCDDN   MVC   DDN(*-*),3(R7)           << EXECUTED >>\nDSIDTYPE DC    C'JCLIN JOBLOGJCL   JOBMSGJCLTXTSWA   '\nDDN#HEAD DC    CL79'PROGRAM   PROCEDURE     STEPNAME  PROCSTEP   DDNAME1\n                    DSID    DSTYPE  RECORDS'\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R2,R3,R9,R10,R11,R12\n         TITLE '--- QUEUE/SP -- LPDDB -- LIST PDDB''S FOR A JOB ---'\nLPDDB    QSTART\n         CLI   QXAUTH,LV15         AUTHORIZED USER?\n         BL    LP$TILTI            NO\n         USING QCKPT,R10           BASE FOR CHECKPOINT WORK AREA\n         L     R10,QVCKPT          LOAD BASE REG\n         USING QDISPLAY,R9         BASE FOR DISPLAY WORK AREA\n         L     R9,QVDSPL           LOAD BASE REG\n         SPACE 1\n*---     CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT              ---*\n         SPACE 1\n         QCALL FINDJOB             FIND THE JOB\n         SPACE 1\n*---     CHECK AND CONVERT THE PDDB ID NUMBER IF ANY               ---*\n         SPACE 1\n         LH    R1,QLNG2            LENGTH OF PDDB ID FIELD\n         SH    R1,=H'1'            PDDB ID FIELD ZERO LENGTH?\n         BM    LPSRCH              YES, PROCEED NORMALLY\n         LA    R15,QPARM2          POINT TO PARM\n         BAS   R14,QNUMCONV        CONVERT IT\n         BNE   LP$TILTN            QUIT IF NOT NUMERIC\n         LR    R6,R15              GET PDDB NUMBER\n         SPACE 1\n*---     FIND ALL OR SPECIFIED PDDB(S) FOR THIS JOB                ---*\n         SPACE 1\nLPSRCH   MVI   DDN@SW,0            HAVEN'T READ SPIN IOT YET\n         L     R5,QCIOTA           -> IOT\n         USING IOTSTART,R5\nLPNXIOT  CLC   IOTID,=CL4'IOT'     WAS AN IOT READ FROM SPOOL?\n         BNE   LP$TILTB            NO, ERROR\n         CLC   QPJOBID,IOTJBKEY    IS THE IOT'S JOB KEY VALID?\n         BNE   LP$TILTB            NO, ERROR\n         LR    R4,R5               BASE OF IOT\n         SL    R4,=A(IOTSTART-IOT) ADJUST FOR HEADER\n         LR    R3,R4               COPY IT\n         A     R4,IOTPDDBP         OFFSET BEYOND LAST PDDB\n         A     R3,IOTPDDB          OFFSET TO FIRST PDDB IN IOT\n         USING PDB,R3\nLPLOOP   LH    R0,PDBDSKEY         GET DSID\n         TM    PDBFLAG3,PDB3PLHD   IS IT A PLACE HOLDER PDDB?\n         BO    LPNXPDB             YES, IGNORE IT\n         CLI   QPARM2,C' '         WANT A SPECIFIED PDDB?\n         BE    LPPALL              NO, ALL\n         CR    R0,R6               FOUND RIGHT PDDB?\n         BNE   LPNXPDB             NO, TRY NEXT ONE\n         LA    R2,PDBLENG          LENGTH OF PDDB\n         NI    QDFREQ,255-QDFRL    SET NORMAL\n         MVC   FHEXID-1(L'FHEXID+2),=C' PDB : '   SAY WHAT IT IS\n         MVC   QDHLINE,QBLANK      BLANK THE TITLE LINE\n         QCALL HEXDUMP             PRINT PDDB IN HEX\n         B     LPNXPDB             JUST IN CASE MULTIPLE PDDBS (SYSLOG)\n         SPACE 1\nLPPALL   MVC   QDMSG,QBLANK        BLANK OUT WORK LINE AREA\n         CVD   R0,DDN@DWD          CONVERT TO DECIMAL\n         MVC   LPDSID,=XL8'4020202020202120'\n         ED    LPDSID,DDN@DWD+4    EDIT THE DSID\n         MVC   LPFLAG1+1(2),=CL2'X'''\n         UNPK  LPFLAG1+3(3),PDBFLAG1(2) HEX OF FLAG-1 BYTE\n         TR    LPFLAG1+3(2),HEXTAB-X'F0'     MAKE PRINTABLE\n         MVI   LPFLAG1+5,C''''\n         L     R0,PDBRECCT         GET RECORDS COUNT\n         CVD   R0,DDN@DWD          CONVERT TO DECIMAL\n         MVC   LPRECCT,=XL8'4020202020202120'\n         ED    LPRECCT,DDN@DWD+4   EDIT RECORDS COUNT\n         MVC   LPCLASS,PDBCLASS    MOVE PDBCLASS\n         UNPK  LPMTTR(L'LPMTTR+1),PDBMTTR(5) START MTTR\n         TR    LPMTTR,HEXTAB-X'F0'      MAKE PRINTABLE\n         MVI   LPMTTR+L'LPMTTR,C' '     CLEAR JUNK BYTE\n         UNPK  LPMTTRL(L'LPMTTRL+1),PDBMTTRL(5)   LAST MTTR\n         TR    LPMTTRL,HEXTAB-X'F0'     MAKE PRINTABLE\n         MVI   LPMTTRL+L'LPMTTRL,C' '   CLEAR JUNK BYTE\n         MVC   LPNPROC,PDBPNAME    SET PDDB PROC NAME\n         MVC   LPNSTEP,PDBSNAME    SET PDDB STEP NAME\n         MVC   LPNDDNM,PDBDDNAM    SET PDDB DD NAME\n         MVC   QDHLINE,LPHEAD      SET HEADING LINE\n         QCALL DISPLAY,QDMSG,80    ADD LINE TO SCREEN\nLPNXPDB  LA    R3,PDBLENG(R3)      -> NEXT PDDB\n         CR    R3,R4               PAST LAST PDDB?\n         BL    LPLOOP              NO, DO NEXT\n         L     R4,IOTIOTTR         DISK ADDR OF NEXT IOT\nLPSPIN   LTR   R4,R4               IS THERE ANOTHER IOT?\n         BZ    LPTRYS              NO, TRY SPIN IOT\n         ST    R4,QCTRAK           STORE DISK ADDR\n         LR    R1,R5               IOAREA ADDRESS\n         QCALL READSPC             READ IOT FROM HASPACE\n         B     LPNXIOT             PROCESS IT\nLPTRYS   TM    DDN@SW,SW@SPIN      SPIN IOT SEARCHED ALREADY?\n         BO    LPSTOP              YES, DONE\n         OI    DDN@SW,SW@SPIN      INDICATE SPIN IOT\n         L     R1,QCJCTA           -> JCT\n         L     R4,JCTSPIOT-JCTSTART(,R1)     DISK ADDR OF SPIN IOT\n         B     LPSPIN              SEARCH THE SPIN IOT CHAIN\nLPSTOP   QSTOP ,                   GO BACK TO CALLER\n         SPACE 1\nLP$TILTI QTILT '=== NOT AVAILABLE TO YOU, SORRY ==='\nLP$TILTN QTILT 'INVALID PDDB ID NUMBER SPECIFIED'\nLP$TILTB QTILT '*** JOB HAS PURGED (OR IOT IS INVALID) ***'\n         SPACE 1\nLPHEAD   DC    CL79'   DS-ID FLAG-1   #-RECS CL  START<-MTTR->LAST  PRO1\n               CNAME STEPNAME DD-NAME'\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R3,R5,R9,R10,R11,R12\n         TITLE '--- QUEUE/SP -- JCL -- LIST THE JCL FOR A JOB ---'\nJCL      QSTART\n         SPACE 1\n*---     CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT              ---*\n         SPACE 1\n         QCALL FINDJOB             FIND THE JOB\n         SPACE 1\n*---     ENSURE JOB NAME BEGINS WITH USER ID                       ---*\n         SPACE 1\n         L     R9,QCJCTA           ADDR OF JCT\n         USING JCTSTART,R9         BASE REG FOR JCT\n         IC    R2,QLOGONL          GET LENGTH OF USERID\n         BCTR  R2,0                -1 FOR EX\n         CLI   QXAUTH,LV10         IS THIS AN AUTHORIZED USER?\n         BNL   *+L'*+8             YES, THE JOB NAME IS VALID\n         EX    R2,JCL$CLC          IS THE JOB NAME VALID?\n         BNE   J$TILT              NO, TILT\n         SPACE 1\n*---     CALL LISTDS TO LIST THE DATA-SET                          ---*\n         SPACE 1\n         MVC   QPOFFSET,=H'10'     PRINT OFFSET FOR EACH RECORD\n         MVC   QPDSID,=H'3'        DSID OF DATA-SET TO BE PRINTED\n         QCALL LISTDS\n         QSTOP\nJ$TILT   QTILT '*** JOB NAME MUST BEGIN WITH USERID ***'\n         SPACE 1\nJCL$CLC  CLC   QLOGON(*-*),JCTJNAME     << EXECUTED >>\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9,R11,R12\n TITLE '--- QUEUE/SP -- JLOG -- LIST THE JOBLOG MSGS FOR A JOB ---'\nJLOG     QSTART\n         USING QCKPT,R10           BASE REG FOR CKPT WORK AREA\n         L     R10,QVCKPT          LOAD BASE REG\n         SPACE 1\n*---     CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT              ---*\n         SPACE 1\n         QCALL FINDJOB             FIND THE JOB\n         SPACE 1\n*---     ENSURE JOB NAME BEGINS WITH USER ID                       ---*\n         SPACE 1\n         L     R9,QCJCTA           ADDR OF JCT\n         USING JCTSTART,R9         BASE REG FOR JCT\n         IC    R2,QLOGONL          GET LENGTH OF USERID\n         BCTR  R2,0                -1 FOR EX\n         CLI   QXAUTH,LV10         IS THIS AN AUTHORIZED USER?\n         BNL   *+L'*+8             YES, THE JOB NAME IS VALID\n         EX    R2,JLOG$CLC         IS THE JOB NAME VALID?\n         BNE   G$TILT              NO, TILT\n         SPACE 1\n*---     ONLY PROCESS JOB IF IT IS ON THE OUTPUT QUEUE             ---*\n         SPACE 1\n         L     R2,QCJQECA          ADDR OF JQE FOR THIS JOB\n         USING JQE,R2              BASE REG FOR JQE\n         CLI   JQETYPE,$HARDCPY    IS THE JOB ON THE OUTPUT QUEUE?\n         BNE   JL$TILT             NO, INFORM THE USER\n         SPACE 1\n*---     CALL LISTDS TO LIST THE DATA-SET                          ---*\n         SPACE 1\n         MVC   QPOFFSET,=H'0'      PRINT OFFSET FOR EACH RECORD\n         MVC   QPDSID,=H'2'        DSID OF DATA-SET TO BE PRINTED\n         QCALL LISTDS\n         QSTOP\nG$TILT   QTILT '*** JOB NAME MUST BEGIN WITH USERID ***'\nJL$TILT  QTILT '*** JOBLOG IS NOT AVAILABLE ***'\n         SPACE 1\nJLOG$CLC CLC   QLOGON(*-*),JCTJNAME     << EXECUTED >>\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R2,R9,R10,R11,R12\n TITLE '--- QUEUE/SP -- JMSG -- LIST THE SYSTEM MSGS FOR A JOB ---'\nJMSG     QSTART\n         SPACE 1\n*---     CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT              ---*\n         SPACE 1\n         QCALL FINDJOB             FIND THE JOB\n         SPACE 1\n*---     ENSURE JOB NAME BEGINS WITH USER ID                       ---*\n         SPACE 1\n         L     R9,QCJCTA           ADDR OF JCT\n         USING JCTSTART,R9         BASE REG FOR JCT\n         IC    R2,QLOGONL          GET LENGTH OF USERID\n         BCTR  R2,0                -1 FOR EX\n         CLI   QXAUTH,LV10         IS THIS AN AUTHORIZED USER?\n         BNL   *+L'*+8             YES, THE JOB NAME IS VALID\n         EX    R2,JMSG$CLC         IS THE JOB NAME VALID?\n         BNE   M$TILT              NO, TILT\n         SPACE 1\n*---     CALL LISTDS TO LIST THE DATA-SET                          ---*\n         SPACE 1\n         MVC   QPOFFSET,=H'0'      PRINT OFFSET FOR EACH RECORD\n         MVC   QPDSID,=H'4'        DSID OF DATA-SET TO BE PRINTED\n         QCALL LISTDS\n         QSTOP\nM$TILT   QTILT '*** JOB NAME MUST BEGIN WITH USERID ***'\n         SPACE 1\nJMSG$CLC CLC   QLOGON(*-*),JCTJNAME     << EXECUTED >>\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9,R11,R12\n TITLE '--- QUEUE/SP -- LIST -- LIST A DS FROM SPOOL BY ID ---'\nLIST     QSTART\n         USING QCKPT,R10           BASE REG FOR CKPT WORK AREA\n         L     R10,QVCKPT          LOAD BASE REG\n         SPACE 1\n*---     CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT              ---*\n         SPACE 1\n         QCALL FINDJOB             FIND THE JOB\n         SPACE 1\n*---     ENSURE JOB NAME BEGINS WITH USER ID                       ---*\n         SPACE 1\n         L     R9,QCJCTA           ADDR OF JCT\n         USING JCTSTART,R9         BASE REG FOR JCT\n         IC    R2,QLOGONL          GET LENGTH OF USERID\n         BCTR  R2,0                -1 FOR EX\n         CLI   QXAUTH,LV10         IS THIS AN AUTHORIZED USER?\n         BNL   *+L'*+8             YES, THE JOB NAME IS VALID\n         EX    R2,LIST$CLC         IS THE JOB NAME VALID?\n         BNE   L$TILT1             NO, TILT\n         SPACE 1\n*---     CHECK AND CONVERT THE DATA-SET ID NUMBER                  ---*\n         SPACE 1\n         LH    R1,QLNG2            LENGTH OF DATA-SET ID FIELD\n         SH    R1,=H'1'            DATA-SET ID FIELD ZERO LENGTH?\n         BM    L$TILT              YES, QUIT\n         LA    R15,QPARM2          POINT TO PARM\n         BAS   R14,QNUMCONV        CONVERT IT\n         BNE   L$TILT              QUIT IF NOT NUMERIC\n         CLI   QSUBNAME,C'X'       'XL' COMMAND?\n         BE    *+L'*+8             YES, SKIP NEXT VALIDITY CHECK\n         CH    R15,=H'101'         DATA-SET ID LESS THAN 101?\n         BL    L$TILT              YES, TILT\n         STH   R15,QPDSID          STORE DATA-SET ID\n         SPACE 1\n*---     CHECK AND CONVERT THE PRINT OFFSET                        ---*\n         SPACE 1\n         MVC   QPOFFSET,=H'0'      DEFAULT TO ZERO\n         LH    R2,QLNG3            LENGTH OF OFFSET FIELD\n         SH    R2,=H'1'            OFFSET FIELD ZERO LENGTH?\n         BM    L$CALIST            YES, USE ZERO OFFSET\n         LA    R15,QPARM3          POINT TO PARM\n         BAS   R14,QNUMCONV        CONVERT IT\n         BNE   L$TILT              QUIT IF NOT NUMERIC\n         STH   R15,QPOFFSET        STORE OFFSET\n         SPACE 1\n*---     CALL LISTDS TO LIST THE DATA-SET                          ---*\n         SPACE 1\nL$CALIST QCALL LISTDS\n         QSTOP\nL$TILT   QTILT '*** DATA-SET ID INVALID ***'\nL$TILT1  QTILT '*** JOB NAME MUST BEGIN WITH USERID ***'\n         SPACE 1\nLIST$CLC CLC   QLOGON(*-*),JCTJNAME     << EXECUTED >>\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9,R10,R11,R12\n TITLE '--- QUEUE/SP -- LISTDS -- LIST A DS FROM THE SPOOL PACK ---'\nLISTDS   QSTART\n         USING QCKPT,R10           BASE REG FOR CHECKPT WORK AREA\n         L     R10,QVCKPT          LOAD BASE REG\n         USING QDISPLAY,R9         BASE REG FOR DISPLAY WORK AREA\n         L     R9,QVDSPL           LOAD BASE REG\n         SPACE 1\n*---     DETERMINE FUNCTION REQUESTED                              ---*\n         SPACE 1\n         CLI   QCODE,0             IS REQUEST FOR REPOSITIONING?\n         BNE   LD$REPOS            YES, DO IT\n         SPACE 1\n*---     LOCATE PDDB FOR DATA-SET SPECIFIED IN QPDSID              ---*\n         SPACE 1\n         MVI   SWITCH,0            INITIALIZE SWITCH\n         USING PDB,R2              BASE REG FOR PDDB\n         L     R3,QCIOTA           LOAD BASE REG\n         USING IOTSTART,R3         BASE REG FOR IOT\n         LR    R5,R3               IOAREA FOR READ IOT BLOCK\nNEXTIOT  CLC   IOTID,=CL4'IOT'     WAS AN IOT READ FROM SPOOL?\n         BNE   LD$TILTB            NO, ERROR\n         CLC   QPJOBID,IOTJBKEY    IS THE IOT'S JOB KEY VALID?\n         BNE   LD$TILTB            NO, ERROR\n         LR    R4,R3               BASE OF IOT\n         SL    R4,=A(IOTSTART-IOT) ADJUST FOR HEADER\n         LR    R2,R4               COPY IT\n         A     R4,IOTPDDBP         OFFSET BEYOND LAST PDDB\n         A     R2,IOTPDDB          OFFSET TO FIRST PDDB IN IOT\nLD$DS$LP CLC   QPDSID,PDBDSKEY     IS THIS THE DATA-SET?\n         BE    FOUNDDS2            YES, CONTINUE\nLD$NXT   LA    R2,PDBLENG(R2)      NO, LOOK AT NEXT PDDB\n         CR    R2,R4               HAVE WE PAST THE LAST PDDB?\n         BL    LD$DS$LP            NO, TRY AGAIN\n         L     R4,IOTIOTTR         DISK ADDR OF NEXT IOT\nSPIN     LTR   R4,R4               IS THERE ANOTHER IOT?\n         BZ    SPINIOT             NO, TRY THE SPIN IOT\n         BAS   R8,LDS$READ         READ THE IOT\n         B     NEXTIOT             SEARCH THE NEXT IOT\n         USING JCTSTART,R1         BASE REG FOR JCT\nSPINIOT  TM    SWITCH,SPINDONE     SPIN IOT SEARCHED YET?\n         BO    LDS$TILT            YES, TILT\n         OI    SWITCH,SPINDONE     SET SWITCH\n         L     R1,QCJCTA           LOAD BASE REG\n         L     R4,JCTSPIOT         DISK ADDR OF SPIN IOT\n         DROP  R1\n         B     SPIN                SEARCH THE SPIN IOT CHAIN\nLDS$TILT MVC   QPDSID,=H'0'        INVALIDATE DSID\n         TM    SWITCH,DSFOUND      IS DATA-SET FOUND?\n         BO    LSTDSTOP            YES, DATA-SET WAS EMPTY\n         QTILT '*** DATA-SET ID NOT FOUND ***'\nLD$TILT2 QTILT '*** DATA-SET TABLE LIMITS EXCEEDED ***'\nLD$TILTB QTILT '*** JOB HAS PURGED (OR IOT IS INVALID) ***'\nFOUNDDS2 STM   R2,R5,QPTRSV        SAVE PTRS (EVENTUAL FURTHER USE)\n         OI    SWITCH,DSFOUND      SET DATA-SET FOUND\n         MVC   QCJNAME,QPARM1      SAVE THE JOB NAME\n         MVC   QCDSNO,QPARM2       SAVE THE DATA-SET ID NUMBER\n         MVC   QDHLINE,QCHLINE     MOVE IN HEADING LINE\n         MVC   QCRECFM,PDBRECFM    RECORD FORMAT FOR SAVE\n         MVC   QCLRECL,PDBLRECL    RECORD LENGTH FOR SAVE\n         L     R4,PDBMTTR          DISK ADDR OF FIRST BLOCK\n         L     R5,QCBLKA           ADDR OF DATA-SET BLOCK IOAREA\n         L     R2,QCSTART          BEGINNING OF DISK ADDR TABLE\n         ZAP   QCCREC,=P'0'        ZERO CURRENT RECORD NO\n         MVC   QCCPTR,QCSTART      BEGIN OF TBL\n         ZAP   QCHREC,=P'0'        ZERO HIGH REC NO\n         MVC   QCHPTR,QCSTART      BEGIN OF TBL\n         ZAP   QPREC,=P'1'         REPOSITION TO TOP OF DATA-SET\n         LTR   R4,R4               IS THE DISK ADDR ZERO?\n         BNZ   LDPRCSS             NO, PROCESS THE DATA-SET\n         TM    SWITCH,SPINDONE     SPIN IOT SEARCHED YET?\n         BO    LDS$END             YES, END OF DATA-SET SEARCH\n         LM    R2,R5,QPTRSV        RESTORE SEARCH PTRS\n         B     LD$NXT              SEARCH NEXT PDDB/IOT\n         DROP  R2,R3\n         SPACE 1\n*---     PROCESS DATA-SET                                          ---*\n         SPACE 1\n         USING BUFSTART,R5\nLDSNXTBL L     R4,HDBNXTRK         DISK ADDR OF NEXT BLOCK\nLDSFIRST LTR   R4,R4               IS THE DISK ADDR ZERO?\n         BZ    LDS$END             YES, END OF DATA-SET\nLDPRCSS  ST    R4,0(R2)            STORE DISK ADDR IN TABLE\n         BAS   R8,LDS$READ         READ A BLOCK\n         CLC   HDBKEY,QPJOBID      DOES THE JOBID MATCH?\n         BNE   LDS$END             NO, END OF DATA-SET\n         MVC   4(4,R2),QCCREC      STORE CURRENT REC NUM IN TABLE\n         ST    R2,QCCPTR           STORE CURRENT TABLE ADDR\n         CP    QCCREC,QCHREC       IS CURRENT REC NO > HIGHEST?\n         BNH   *+L'*+6             NO, SKIP\n         MVC   QCHREC(8),QCCREC    REPLACE HI REC CNT AND PTR\n         LA    R2,8(,R2)           INCREMENT TO NEXT TBL ENTRY\n         C     R2,QCEND            IS THIS THE END OF TABLE?\n         BNL   LD$TILT2            YES, TILT\n         LA    R4,HDBSTART         ADDR OF FIRST RECORD IN BLOCK\n         SPACE 1\n*---     PROCESS RECORDS                                           ---*\n         SPACE 1\n         USING LRC,R4\nNEXTREC2 CLI   LRCTLENG,ENDIND     IS LENGTH BYTE FF?\n         BE    LDSNXTBL            YES, END OF BLOCK\n         TM    LRCFLAG1,LRC1SPAN   IS THIS A SPANNED RECORD?\n         BO    LDS$SPAN            YES, SKIP IT\n         ZIC   R6,LRCTLENG         INSERT LENGTH\n         LR    R7,R6               SAVE RECORD LENGTH\n         LR    R1,R4               SAVE RECORD LOCATION\n         TM    LRCFLAG1,LRC1CCTL   IS CARRIAGE CONTROL SPECIFIED?\n         BZ    *+L'*+4             NO, CONTINUE\n         LA    R1,1(,R1)           SKIP OVER CARRIAGE CONTROL\n         TM    LRCFLAG1,LRC1INUL+LRC1ONUL    IS RECORD TO BE IGNORED?\n         LR    R4,R1               UPDATE RECORD POINTER\n         BNZ   SKIPREC2            YES, SKIP IT\n         AP    QCCREC,=P'1'        ADD ONE TO CUR REC NO\n         CP    QCCREC,QPREC        REACHED THE RECORD WE WANT?\n         BL    SKIPREC2            NO, TRY NEXT RECORD\n         CLI   QCODE,4             IS THE REQUEST FOR A FIND?\n         BE    LDS$FIND            YES, DO IT\n         CLI   QCODE,8             IS IT A FINDTIME REQUEST?\n         BE    LD$FTIME            YES, DO IT\nFINDOFF  AH    R1,QPOFFSET         ADD OFFSET TO START OF RECORD\n         SH    R7,QPOFFSET         SUBTRACT OFFSET FROM LENGTH\n         BNP   ZEROPRT             NO DATA LEFT IN RECORD\n         CH    R7,=H'80'           IS RECORD BIGGER THAN 80 CHARS?\n         BNH   LT80                NO, USE RECORD LENGTH\n         LA    R7,80               YES, USE A LENGTH OF 80\nLT80     QCALL DISPLAY,3(,R1),(R7)\n         TM    QDOVER,QOVPAGE      WAS THERE A PAGE OVERFLOW?\n         BNO   SKIPREC2            NO, SKIP\n         ZAP   QPREC,QCCREC        UPDATE THE REPOSITION NUMBER\n         MVC   HREC,EDIT           PATTERN FOR EDIT\n         ED    HREC,QCCREC         EDIT RECORD NUMBER\nSKIPREC2 LA    R4,LRCTEXT(R6)      INCREMENT TO NEXT RECORD\n         B     NEXTREC2            PROCESS NEXT RECORD\nLDS$SPAN LH    R6,LRCSEGL          LENGTH OF SEGMENT\n         TM    LRCFLAG1,LRC1SBGN   IS THIS THE FIRST SEGMENT?\n         BO    SPAN1ST2            YES, USE HEADER LENGTH OF 6\n         LA    R4,LRCSTEXT(R6)     UPDATE RECORD POSITION\n         B     NEXTREC2            PROCESS NEXT RECORD\nSPAN1ST2 LA    R4,LRCSFTXT(R6)     UPDATE RECORD POSITION\n         B     NEXTREC2            PROCESS NEXT RECORD\nZEROPRT  LA    R1,QBLANK           PRINT A BLANK\n         LA    R7,1                LENGTH OF ONE\n         B     LT80                PRINT THE RECORD\n         DROP  R4,R5\nLDS$END  CP    QCCREC,=P'0'        IS THE DATA-SET EMPTY\n         BE    LSTDSTOP            YES, QUIT\n         MVC   HEND,ENDLINE        TELL THEM THIS IS THE END\n         MVC   HREND,EDIT          PATTERN FOR EDIT\n         ED    HREND,QCCREC        LAST REC NO\n         CLI   QCODE,32            WAS REQUEST FOR BOTTOM?\n         BE    BOTTOM1             YES, BACK UP 20 LINES\n         L     R1,=A(ENDDATA)\n         QCALL DISPLAY,(R1),80     MOVE 'END OF DATA' TO SCREEN\n         QCALL DISPLAY,,0          FLUSH THE SCREEN\n         ZAP   QPREC,=P'1'         RECORD NUMBER 1\n         MVC   QDHLINE,QCHLINE     BLANK THE TITLE LINE\n         B     LD$TOP              START AT TOP OF DATA-SET\nLSTDSTOP MVC   QDHLINE,EMPTYDS\n         QSTOP\n         SPACE 1\n*---     BOTTOM OF DATA-SET                                        ---*\n         SPACE 1\nBOTTOM1  ZAP   QPREC,QCCREC        LAST RECORD NUMBER\n         MVI   QCODE,0             AVOID A LOOP\n         SP    QPREC,=P'19'        TOP OF PAGE\n         BP    LD$REPOS            CONTINUE IF POSITIVE\n         ZAP   QPREC,=P'1'         TOP OF DATA-SET\n         SPACE 1\n*---     REPOSITION TO REQUESTED RECORD NUMBER                     ---*\n         SPACE 1\nLD$REPOS MVC   QDHLINE,QCHLINE     MOVE IN HEADING LINE\n         MVC   HREC,EDIT           PREPARE FOR EDIT\n         ED    HREC,QPREC          EDIT RECORD NUMBER\n         CP    QPREC,QCHREC        IS THE REQ NO > HIGHEST READ?\n         BNL   LD$HI               YES, GO FROM HI\n         CP    QPREC,QCCREC        IS THE REQ NO > CURRENT REC?\n         BH    UP                  YES, GO FROM CURRENT\n         CP    QPREC,=P'1'         IS REQ FOR TOP OF DATA-SET?\n         BH    DOWN                NO, GO DOWN FROM CURRENT\nLD$TOP   L     R2,QCSTART          START AT TOP\nLDRESUME L     R4,0(R2)            LOAD DISK ADDR\n         L     R5,QCBLKA           ADDR OF BLOCK IOAREA\n         MVC   QCCREC,4(R2)        RESET CURRENT REC NO\n         B     LDSFIRST            RESUME PROCESSING\nLD$HI    L     R2,QCHPTR           START AT HIGHEST SO FAR\n         B     DOWNLOOP            FIND CORRECT BLOCK\nUP       L     R2,QCCPTR           CURRENT TABLE PTR\nUPLOOP   CP    QPREC,12(4,R2)      IS THE NEXT ENTRY > REQ NO?\n         BNH   LDRESUME            YES, PROCESS IT\n         LA    R2,8(R2)            TRY NEXT ENTRY\n         B     UPLOOP              AGAIN\nDOWN     L     R2,QCCPTR           CURRENT TABLE PTR\nDOWNLOOP CP    QPREC,4(4,R2)       IS THE ENTRY < REQ NO?\n         BH    LDRESUME            YES, PROCESS IT\n         SH    R2,=H'8'            TRY PREVIOUS ENTRY\n         B     DOWNLOOP            AGAIN\n         SPACE 1\n*---     FIND MATCHING RECORD ROUTINE                              ---*\n         SPACE 1\nLDS$FIND LH    R3,QPLNG            LENGTH-1 OF COMPARE\n         LR    R14,R6              LENGTH OF RECORD\n         SR    R14,R3              NUMBER OF COMPARES\n         BNP   SKIPREC2            RECORD IS TOO SMALL, SKIP IT\n         LR    R15,R4              FIRST BYTE OF RECORD\nFLOOP    EX    R3,LDS$CLC          DOES THE FIND DATA MATCH THE REC?\n         BE    MATCH               YES, DISCONTINUE SEARCH\n         LA    R15,1(R15)          INCREMENT TO NEXT BYTE\n         BCT   R14,FLOOP           TRY NEXT BYTE\n         B     SKIPREC2            SKIP THE RECORD, NO MATCH\nMATCH    CLI   QSUBNAME+1,C'A'     IS THE REQUEST FOR A FINDALL?\n         BE    FALL                YES, DO NOT DISABLE SEARCH\n         MVI   QCODE,0             END THE SEARCH\n         ZAP   QPREC,QCCREC        UPDATE THE REPOSITION NUMBER\nFALL     MVC   HREC,EDIT           PREPARE FOR EDIT\n         ED    HREC,QCCREC         EDIT RECORD NUMBER\n         B     FINDOFF             CONTINUE\nLDS$CLC  CLC   QPFIND(1),3(R15)    COMPARE PARM TO RECORD\n         SPACE 1\n*---     FIND THE RECORD WHICH IS GREATER THAN OR EQUAL TO TIME    ---*\n         SPACE 1\nLD$FTIME CLI   10(R4),C'.'         MVS/370 LOG TIME?\n         BNE   *+L'*+10            NO\n         CLC   QPARM1,8(R4)        YES, IS THIS THE TIME WE WANT?\n         B     LD$FTBW\n         CLI   27(R4),C':'         MVS/XA LOG TIME?\n         BNE   *+L'*+10            NO\n         CLC   QPARM4,25(R4)       YES, IS THIS THE TIME WE WANT?\n         B     LD$FTBW\n         CLI   30(R4),C':'         MVS/XA 2.2.0 LOG TIME?\n         BNE   SKIPREC2            NO, SKIP IT\n         CLC   QPARM4,28(R4)       YES, IS THIS THE TIME WE WANT?\nLD$FTBW  BH    SKIPREC2            NO, SKIP IT\n         B     MATCH               END THE SEARCH\n         SPACE 1\n*---     READ A BLOCK FROM HASPACE                                 ---*\n         SPACE 1\nLDS$READ ST    R4,QCTRAK           STORE DISK ADDR\n         LR    R1,R5               IOAREA ADDRESS\n         QCALL READSPC             READ HASPACE\n         BR    R8                  RETURN TO CALLER\n         SPACE 1\n         LTORG\n         SPACE 1\nEMPTYDS  DC    CL79'*** DATA SET IS EMPTY ***'\nENDLINE  DC    C', END OF DATA. LAST REC #'\nEDIT     DC    X'4020202020202021'\n         DC    CL45' '\n         SPACE 1\n         DROP  R9,R10,R11,R12\n TITLE '--- QUEUE/SP -- REPOS -- DATA-SET REPOSITIONING ROUTINES ---'\nREPOS    QSTART\n         USING QCKPT,R10           BASE REG FOR CKPT WORK AREA\n         L     R10,QVCKPT          LOAD BASE REG\n         USING QDISPLAY,R9         BASE REG FOR DISPLAY WORK AREA\n         L     R9,QVDSPL           LOAD BASE REG\n         SPACE 1\n*---     BRANCH TO PROPER ROUTINE                                  ---*\n         SPACE 1\n         CLC   QPDSID,=H'0'        IS THERE A VALID DATA-SET?\n         BNE   GO                  YES, GO AHEAD\n         QTILT '=== YOU ARE NOT PROCESSING A VALID DATA-SET ==='\nGO       LH    R1,QCODEH           LOAD FUNCTION CODE\n         CH    R1,=H'32'           IS THE FUNCTION SUPPORTED?\n         BH    RP$STOP             NO, RETURN\n         B     *+L'*(R1)           BRANCH TO ROUTINE\n         B     RP$TILT                  0 OFFSET\n         B     RP$FIND                  4\n         B     RP$FTIME                 8\n         B     COLUMN                   12\n         B     AT                       16\n         B     RP$PLUS                  20\n         B     MINUS                    24\n         B     RP$TOP                   28\n         B     RP$BOTTM                 32\nRP$TILT  QTILT '*** PARAMETER IS INVALID OR OMITTED ***'\n         SPACE 1\n*---     REPOSITION VERTICALLY                                     ---*\n         SPACE 1\n*---     SKIP FORWARD                                              ---*\n         SPACE 1\nRP$PLUS  BAS   R4,NUMERIC          VALIDATE PARAMETER\n         AP    QPREC,QNUMWORK      ADD COUNT TO CURRENT RECORD\n         B     RPRESUME            CALL LISTDS\n         SPACE 1\n*---     SKIP BACKWARD                                             ---*\n         SPACE 1\nMINUS    BAS   R4,NUMERIC          VALIDATE PARAMETER\n         SP    QPREC,QNUMWORK      SUBTRACT COUNT FROM CURR REC\n         BP    RPRESUME            CALL LISTDS IF RESULT POSITIVE\n         SPACE 1\n*---     TOP OF DATA-SET                                           ---*\n         SPACE 1\nRP$TOP   ZAP   QPREC,=P'1'         SET CURRENT RECORD TO TOP OF DS\n         SPACE 1\n*---     RESUME AT CURRENT RECORD                                  ---*\n         SPACE 1\nRPRESUME QCALL LISTDS\nRP$STOP  QSTOP\n         SPACE 1\n*---     BOTTOM OF DATA-SET                                        ---*\n         SPACE 1\nRP$BOTTM ZAP   QPREC,=P'9999999'   SET CURRENT RECORD TO LARGEST\n         B     RPRESUME            CALL LISTDS\n         SPACE 1\n*---     POSITION TO THIS RECORD                                   ---*\n         SPACE 1\nAT       BAS   R4,NUMERIC          VALIDATE PARAMETER\n         ZAP   QPREC,QNUMWORK      INDICATE REPOSITION NO\n         B     RPRESUME            CALL LISTDS\n         SPACE 1\n*---     CHECK THE PARMETER FOR VALID NUMERIC AND PACK IT          ---*\n         SPACE 1\nNUMERIC  LH    R1,QLNG1            LENGTH OF PARM\n         SH    R1,=H'1'            IS THE COUNT FIELD ZERO?\n         BM    RPRESUME            YES, RESUME FROM CURRENT POSIT\n         LA    R15,QPARM1          POINT TO PARM\n         BAS   R14,QNUMCONV        CONVERT IT\n         BNE   RP$TILT             TILT IF NOT NUMERIC\n         BR    R4                  RETURN\n         SPACE 1\n*---     REPOSITION HORIZONTALLY                                   ---*\n         SPACE 1\nCOLUMN   BAS   R4,NUMERIC          VALIDATE PARAMETER\n         CP    QNUMWORK,=P'255'    IS THE COUNT FIELD TOO BIG?\n         BH    RP$TILT             YES, TILT\n         SP    QNUMWORK,=P'1'      COLUMN RELATIVE TO ZERO\n         BM    RP$TILT             INVALID, TILT\n         CVB   R5,QNUMWORK         CONVERT TO BINARY\n         STH   R5,QPOFFSET         STORE IN QPOFFSET\n         B     RPRESUME            CALL LISTDS\n         SPACE 1\n*---     LOCATE SPECIFIC RECORD                                    ---*\n         SPACE 1\nRP$FIND  CLI   QSUBNAME+1,C'A'     IS THE REQUEST FOR FIND ALL?\n         BE    *+L'*+6             YES, DO NOT UPDATE REC POINTER\n         AP    QPREC,=P'1'         START SEARCH AT NEXT RECORD\n         CLI   QPARM1,C' '         IS THERE A PARAMETER?\n         BE    RPRESUME            NO, CONTINUE WITH PREV. FIND\n         LA    R2,QDREPLY+QDREPLYL-1    END OF USER REPLY\n         LA    R3,QDREPLYL-2       MAXIMUM LENGTH OF PARM\n         SH    R3,QOFF1            OFFSET TO FIRST PARM\nREPOS$LP CLC   0(1,R2),QPARM1      IS THIS THE DELIMITER?\n         BE    RP$FOUND            YES, CONTINUE\n         BCTR  R2,0                TRY THE PREVIOUS BYTE\n         BCT   R3,REPOS$LP         IS THE LENGTH FIELD EXHAUSTED?\n         B     RP$TILT             YES, TILT\nRP$FOUND BCTR  R3,0                DECREMENT LENGTH BY 1\n         LA    R2,QDREPLY+1        ADDR OF REPLY + 1\n         AH    R2,QOFF1            ADDR OF FIRST BYTE OF PARM\n         EX    R3,MVC              MOVE PARM TO QPFIND\n         STH   R3,QPLNG            SAVE LENGTH-1 OF PARM\n         B     RPRESUME            CALL LISTDS\nMVC      MVC   QPFIND(1),0(R2)     MOVE PARM TO QPFIND\n         SPACE 1\n*---     REPOSITION IN SYSLOG DATA-SET BY TIME OF DAY              ---*\n         SPACE 1\nRP$FTIME CLI   QPARM1,C' '         IS THE PARM OMITTED?\n         BE    RP$TILT             YES, TILT\n         MVC   QPARM4,QPARM1       BUILD MVS/XA LOG TIME FORMAT\n         MVI   QPARM4+2,C':'\n         MVI   QPARM4+5,C':'\n         B     RPRESUME            CALL LISTDS\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9,R10,R11,R12\n TITLE '--- QUEUE/SP -- SAVE -- CREATE A COPY OF CURRENT DS ---'\nSAVEX    QSTART\n         USING QCKPT,R10           BASE REG FOR CHECKPT WORK AREA\n         L     R10,QVCKPT          LOAD BASE REG\n         USING QDISPLAY,R9         BASE REG FOR DISPLAY WORK AREA\n         L     R9,QVDSPL           LOAD BASE REG\n         SPACE 1\n*---     ALLOCATE OUTPUT DATA-SET                                  ---*\n         SPACE 1\n         CLC   QPDSID,=H'0'        IS THERE A VALID DATA-SET?\n         BE    SV$TILT1            NO, TELL THE USER\n         MVC   DSNAME+2(44),QBLANK BLANK THE DSNAME\n         MVC   DSNAME+2(8),QPARM1  FIRST PART OF DSNAME\n         LA    R1,DSNAME           ADDR OF DSNAME\n         ST    R1,DAALPDSN         STORE IN PARM LIST\n         LH    R2,QLNG1            LENGTH OF QPARM1\n         LA    R1,2(R2,R1)         OFFSET INTO DSNAME\n         MVC   0(8,R1),=C'.OUTLIST'     LAST PART OF DSNAME\n         LA    R1,8(,R2)           LENGTH OF DSNAME\n         STH   R1,DSNAME           STORE LENGTH OF DSNAME\n         CLI   QPARM2,C' '         ANY DISP?\n         BNE   *+L'*+6             YES, USE IT\n         MVC   QPARM2,=CL8'NEW'    NO, USE NEW\n         MVC   DAALUNIT(DAAL$L),ALLOCNEW  REST OF DISP=NEW PARM LIST\n         CLC   QPARM2,=CL8'NORLSE' NEW BUT NO RELEASE?\n         BNE   *+L'*+10            NO, SKIP\n         MVC   QPARM2,=CL8'NEW'    YES, CHANGE TO DISP=NEW\n         MVI   DAALCTL,DA08TRKS+DA08UID TURN OFF RLSE BIT\n         CLC   QPARM2,=CL8'NEW'    IS THIS DISP=NEW?\n         BE    SAVE$ALC            YES, GO ALLOC\n         MVC   DAALUNIT(DAAL$L),ALLOCOLD     NO, ASSUME OLD\n         CLC   QPARM2,=CL8'OLD'    IS IT?\n         BE    SAVE$ALC            YES\n         MVI   DAALDSP1,DA08MOD    NO, CHANGE TO MOD\n         CLC   QPARM2,=CL8'MOD'    IS IT?\n         BNE   SV$TILT2            NO, COMPLAIN\nSAVE$ALC MVI   DAIRFLAG,DFALLOC    REQUEST ALLOCATE FUNCTION\n         QCALL ALLOCATE            ALLOCATE IT\n         MVC   QCOUT+(DCBDDNAM-IHADCB)(L'DAALDDN),DAALDDN\n*                                  GET THE DDNAME RETURNED BY DAIR\n         CLC   QPARM2,=CL8'NEW'    WAS IT DISP=NEW?\n         BNE   SV$OPEN             NO, GO OPEN\n         MVC   QCOUT+(DCBRECFM-IHADCB)(1),QCRECFM\n*                                  MOVE IN RECORD FORMAT\n         NI    QCOUT+(DCBRECFM-IHADCB),DCBRECCC\n*                                  TURN OFF EVERTHING BUT CCTL\n         OI    QCOUT+(DCBRECFM-IHADCB),DCBRECF+DCBRECBR\n*                                  SPECIFY FIXED BLOCKED RECORDS\n         LH    R1,QCLRECL          RECORD LENGTH\n         LTR   R1,R1               IS THE LRECL ZERO?\n         BNZ   *+L'*+4             NO, SKIP\n         LA    R1,133              YES, USE LRECL 133\n         STH   R1,QCOUT+(DCBLRECL-IHADCB)    STORE LRECL\nBIGGER   LR    R2,R1               UPDATE BLKSIZE\n         AH    R1,QCOUT+(DCBLRECL-IHADCB)    ADD LRECL TO BLKSIZE\n         CH    R1,=H'4096'         BLKSIZE GREATER THAN 4096?\n         BL    BIGGER              NO, MAKE IT BIGGER\n         STH   R2,QCOUT+(DCBBLKSI-IHADCB)    STORE BLKSIZE\nSV$OPEN  XC    QCERR,QCERR         RESET ERROR INDICATOR\n         OPEN  MF=(E,QCOPEN)\n         OC    QCERR(2),QCERR      ABEND HAS BEEN ENTERED?\n         BNZ   SV$TILT5            YES\n         TM    QCOUT+(DCBOFLGS-IHADCB),DCBOFOPN   OPEN OK?\n         BZ    SV$TILT3            NO, OPEN ERROR\n         MVI   QCERR+3,ENDIND      SAY DATA-SET OPENED\n         CLC   QPARM2,=CL8'NEW'    WAS IT DISP=NEW?\n         BE    SV$START            YES, OK, START TO PROCESS\n         MVC   BUFFER(1),QCRECFM   NO, CHECK RECORD FORMAT AND CC\n         MVC   BUFFER+1(1),QCOUT+(DCBRECFM-IHADCB)\n         NI    BUFFER,DCBRECF+DCBRECCC\n         NI    BUFFER+1,DCBRECF+DCBRECCC\n         CLC   BUFFER(1),BUFFER+1  RECORD FORMAT AND CC MATCH?\n         BNE   SV$TILT4            NO, REJECT REQUEST\n         SPACE 1\n*---     REPOSITION DATA-SET TO TOP                                ---*\n         SPACE 1\nSV$START L     R4,QCSTART          TOP OF DATA-SET POINTER\n         L     R4,0(R4)            DISK ADDR TOP OF DATA-SET\n         L     R5,QCBLKA           IOAREA ADDRESS\n         B     SV$FIRST            GO DO IT\n         SPACE 1\n*---     PROCESS DATA-SET                                          ---*\n         SPACE 1\n         USING BUFSTART,R5\nSV$NXTBL L     R4,HDBNXTRK         DISK ADDR OF NEXT BLOCK\nSV$FIRST LTR   R4,R4               IS THE DISK ADDR ZERO?\n         BZ    SAVE$END            YES, END OF DATA-SET\n         BAS   R8,SV$READ          READ A BLOCK\n         CLC   HDBKEY,QPJOBID      DOES THE JOBID MATCH?\n         BNE   SAVE$END            NO, END OF DATA-SET\n         LA    R4,HDBSTART         ADDR OF FIRST RECORD IN BLOCK\n         SPACE 1\n*---     PROCESS RECORDS (SKIP SPANNED)                            ---*\n         SPACE 1\n         USING LRC,R4\nNEXTREC3 CLI   LRCTLENG,ENDIND     IS LENGTH BYTE FF?\n         BE    SV$NXTBL            YES, END OF BLOCK\n         TM    LRCFLAG1,LRC1SPAN   SPANNED RECORD?\n         BO    SV$SPAN             YES, SKIP IT\n         ZIC   R6,LRCTLENG         INSERT LENGTH\n         TM    LRCFLAG1,LRC1CCTL   IS CCTL SPECIFIED?\n         BZ    *+L'*+4             NO, SKIP\n         LA    R6,1(,R6)           INCREMENT LENGTH FOR CCTL\n         TM    LRCFLAG1,LRC1INUL+LRC1ONUL    IS RECORD TO BE IGNORED?\n         BNZ   SKIPREC3            YES, SKIP IT\n         MVI   BUFFER,C' '         BLANK FIRST BYTE OF BUFFER\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER   BLANK THE BUFFER\n         LR    R7,R6               DO NOT DESTROY R6\n         SH    R7,=H'1'            IS LENGTH ZERO?\n         BM    SKIPREC3            YES, SKIP RECORD\n         EX    R7,MVCREC           MOVE RECORD TO BUFFER\n         PUT   QCOUT,BUFFER\n         OC    QCERR(2),QCERR      ABEND OR SYNAD HAS BEEN ENTERED?\n         BNZ   SV$TILT5            YES\nSKIPREC3 LA    R4,LRCTEXT(R6)      INCREMENT TO NEXT RECORD\n         B     NEXTREC3            PROCESS NEXT RECORD\nSV$SPAN  LH    R6,LRCSEGL          SEGMENT LENGTH\n         TM    LRCFLAG1,LRC1SBGN   IS THIS THE FIRST SEGMENT?\n         BO    SPAN1ST3            YES, USE LARGER HEADER SIZE\n         LA    R4,LRCSTEXT(R6)     INCREMENT TO NEXT RECORD\n         B     NEXTREC3            PROCESS NEXT RECORD\nSPAN1ST3 LA    R4,LRCSFTXT(R6)     INCREMENT TO NEXT RECORD\n         B     NEXTREC3            PROCESS NEXT RECORD\nMVCREC   MVC   BUFFER(*-*),LRCTEXT <<EXECUTED>>\n         DROP  R4,R5\n         SPACE 1\n*---     READ A BLOCK FROM HASPACE                                 ---*\n         SPACE 1\nSV$READ  ST    R4,QCTRAK           STORE DISK ADDR\n         LR    R1,R5               IOAREA ADDRESS\n         QCALL READSPC             READ HASPACE\n         BR    R8                  RETURN TO CALLER\n         SPACE 1\n*---     CLOSE UP SHOP AND GO HOME                                 ---*\n         SPACE 1\nSAVE$END CLI   QCERR+2,ENDIND      MOD=NEW STATUS?\n         BNE   SV$LEAVE            NO\n         XR    R3,R3               YES, GET TIOT OFFSET\n         LR    R2,R3\n         ICM   R3,B'0011',QCOUT+(DCBTIOT-IHADCB)\n         AL    R3,#TSTIOT\n         USING TIOENTRY,R3\n         ICM   R2,B'0111',TIOEFSRT GET UCB POINTER\n         DROP  R3\n         MVI   QCERR+1,72\n         MVC   BUFFER(72),=CL72'*** DATA-SET HAS BEEN CREATED ON VOLUME1\n                ??????, BUT IS NOT CATALOG''D ***'\n         ZEROKEY\n         USING UCBDSECT,R2\n         CLI   UCBID,UCBSTND       TRUE UCB?\n         BNE   *+L'*+6             NO\n         MVC   BUFFER+40(6),UCBVOLI     YES, GET VOLUME\n         DROP  R2\n         RESETKEY\n         MVI   QCERR+2,0           RESET MOD=NEW STATUS\n         B     SV$TILT5\nSV$LEAVE MVI   QCERR+3,0           RESET DATA-SET OPENED\n         CLOSE MF=(E,QCOPEN)\n         OC    QCERR(2),QCERR      ABEND HAS BEEN ENTERED?\n         BNZ   SV$TILT5            YES\n         MVI   DAIRFLAG,DFFREE     REQUEST FREE FUNCTION\n         MVC   DAFRDDN,QCOUT+(DCBDDNAM-IHADCB)    GET THE DDNAME\n         QCALL ALLOCATE            FREE IT BY DDNAME\n         QCALL LISTDS              GO BACK TO LISTDS\n         QSTOP\n         SPACE 1\nSV$TILT1 QTILT '=== YOU ARE NOT PROCESSING A VALID DATA-SET ==='\nSV$TILT2 QTILT '*** INVALID DISP ***'\nSV$TILT3 MVI   QCERR+1,27\n         MVC   BUFFER(27),=CL27'*** DATA-SET OPEN ERROR ***'\n         B     SV$TILTX\nSV$TILT4 MVI   QCERR+1,43\n         MVC   BUFFER(43),=CL43'*** RECORD FORMAT AND/OR CC DISCREPANCY1\n                ***'\n         B     SV$TILTX\nSV$TILT5 CLI   QCERR+3,ENDIND\n         BNE   SV$EXIT\nSV$TILTX MVI   QCERR+3,0           RESET DATA-SET OPENED\n         CLOSE MF=(E,QCOPEN)\nSV$EXIT  MVI   DAIRFLAG,DFFREE     REQUEST FREE FUNCTION\n         MVC   DAFRDDN,QCOUT+(DCBDDNAM-IHADCB)    GET THE DDNAME\n         QCALL ALLOCATE            FREE IT BY DDNAME\n         LH    R0,QCERR\n         LA    R1,BUFFER\n         QTILT ,\n         SPACE 1\n         CNOP  0,4\n         USING IHADCB,R1\nSV$DCBEX CLC   QPARM2,=CL8'MOD'    WAS IT DISP=MOD?\n         BNER  R14                 NO, OK, LET'S GO\n         OC    DCBBLKSI,DCBBLKSI   YES, IS MOD BEEING USED LIKE NEW?\n         BNZ   R14                 NO, OK, TRUE MOD, LET'S GO\n         LH    R2,QCLRECL          YES, COMPLETE DCB INFO\n         LTR   R2,R2               IS THE LRECL ZERO?\n         BNZ   *+L'*+4             NO, SKIP\n         LA    R2,133              YES, USE LRECL 133\n         STH   R2,DCBLRECL         STORE LRECL\n         LR    R3,R2               UPDATE BLKSIZE\n         AH    R2,DCBLRECL         ADD LRECL TO BLKSIZE\n         CH    R2,=H'4096'         BLKSIZE GREATER THAN 4096?\n         BL    *-10                NO, MAKE IT BIGGER\n         STH   R3,DCBBLKSI         STORE BLKSIZE\n         MVC   DCBRECFM,QCRECFM    MOVE IN RECORD FORMAT\n         NI    DCBRECFM,DCBRECCC   TURN OFF EVERTHING BUT CCTL\n         OI    DCBRECFM,DCBRECF+DCBRECBR     SPECIFY FIXED BLOCKED\n         MVI   DCBDSORG,DCBDSGPS   SET DSORG=PS\n         MVI   QCERR+2,ENDIND      SIGNAL MOD=NEW STATUS\n         BR    R14                 AND GO BACK\n         DROP  R1\n         SPACE 1\n         CNOP  0,4\nSV$DCBSA SYNADAF ACSMETH=QSAM\n         CLI   69(R1),C'*'         UNSIGNIFICANT MESSAGE?\n         BE    SV$SYN3             YES\n         CLI   8(R1),C' '          YES, BINARY INFORMATIONS?\n         BE    SV$SYN1             NO\n         UNPK  56(7,R1),9(4,R1)    YES\n         TR    56(6,R1),HEXTAB-X'F0'\n         MVI   62(R1),C','\n         UNPK  63(5,R1),12(3,R1)\n         TR    63(4,R1),HEXTAB-X'F0'\n         MVI   67(R1),C','\n         B     SV$SYN2\nSV$SYN1  MVC   56(12,R1),8(R1)     MOVE BLANKS\nSV$SYN2  MVC   BUFFER(72),56(R1)\n         MVI   QCERR+1,72\n         B     SV$SYN4\nSV$SYN3  MVC   BUFFER(38),=CL38'*** SYNAD ERROR, BUT UNSIGNIFICANT ***'\n         MVI   QCERR+1,38\nSV$SYN4  SYNADRLS\n         BR    R14                 GO BACK\n         SPACE 1\n         CNOP  0,4\nSV$DCBAB TM    3(R1),X'04'         OK TO IGNORE AVAILABLE?\n         BO    *+L'*+6             YES\n         MVI   3(R1),0             NO, LET'S GO THE ABEND\n         BR    R14\n         MVC   BUFFER(26),=CL26'*** ABEND S     RC=    ***'\n         UNPK  BUFFER+11(5),0(3,R1)\n         MVC   BUFFER+14(2),=CL2' ('\n         UNPK  BUFFER+19(3),2(2,R1)\n         MVI   BUFFER+21,C')'\n         MVI   QCERR+1,26\n         MVI   3(R1),4             SET IGNORE ABEND CONDITION\n         BR    R14\n         SPACE 1\nQCOLST   DC    0F'0',XL1'05',AL3(SV$DCBEX),XL1'91',AL3(SV$DCBAB)\n         SPACE 1\n         DS    0F\nALLOCNEW DC    2CL8' '             UNIT & VOLSER\n         DC    F'0,10,50,0'        BLKSIZE / PRI / SEC / DIR\n         DC    2CL8' '             MEMBER & PASSWORD\n         DC    AL1(DA08NEW)        STAT=NEW\n         DC    AL1(DA08CAT)        DISP=CATLG\n         DC    AL1(DA08CATL)       DISP=CATLG\n         DC    AL1(DA08TRKS+DA08UID+DA08RLSE)\n*                                  TRKS + PREFIX_USERID + RLSE\n         DC    F'0',CL8' '\n         SPACE 1\nALLOCOLD DC    2CL8' '             UNIT & VOLSER\n         DC    4F'0'               BLKSIZE / PRI / SEC / DIR\n         DC    2CL8' '             MEMBER & PASSWORD\n         DC    AL1(DA08OLD)        STAT=OLD\n         DC    AL1(DA08KEEP)       DISP=KEEP\n         DC    AL1(DA08KEP)        DISP=KEEP\n         DC    AL1(DA08UID)        PREFIX_USERID TO DSNAME\n         DC    F'0',CL8' '\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9,R10,R11,R12\n TITLE '--- QUEUE/SP -- SEARCH -- JQE AND JOE SEARCH AND FORMAT ---'\nSEARCH   QSTART\n         L     R10,QVCKPT          @ CKPT WORK AREA\n         USING QCKPT,R10\n         USING JQE,R9              BASE REG FOR JQE DSECT\n         USING JOE,R8              BASE REG FOR JOE DSECT\n         SPACE 1\n*---     BRANCH TO PROPER ROUTINE                                  ---*\n         SPACE 1\n         LH    R1,QCODEH           LOAD FUNCTION CODE INTO R1\n         CH    R1,MAXSRCH          IS THE FUNCTION SUPPORTED?\n         BH    SRCHEXIT            NO, RETURN\n         OI    QDOVER,QAUTCMD      SET ELIGIBLE AUTOMATIC MODE\n         B     GETSRCH(R1)         BRANCH TO ROUTINE\nGETSRCH  DS    0H\n         B     ST                       0 OFFSET\n         B     DA                       4\n         B     DI                       8\n         B     AO                       12  REALLY 'DO' COMMAND\n         B     AI                       16\n         B     AO                       20\n         B     HI                       24\n         B     HO                       28\n         B     DT                       32\n         B     DJ                       36  ALSO 'XJ' COMMAND\n         B     DS                       40\n         B     QI                       44\n         B     QO                       48\n         B     DL                       52\n         B     DL                       56  REALLY 'DR' COMMAND\nMAXSRCH  DC    0H'0',AL2(*-GETSRCH-4)\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* STATUS : FIND ALL JOBS THAT MATCH LEVEL                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nST       CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?\n         BL    ST0                 NO\n         QTILT '*** YOU MUST SPECIFY JOB NAME OR PREFIX ***'\nST0      CLI   QPARM1,C'*'         DID USER SPECIFY LOGON LEVEL?\n         BNE   ST1                 NO, SKIP\n         MVC   QSTKEY(7),QLOGON    SET SEARCH KEY\n         MVI   QSTKEY+7,C' '       FIX LAST BYTE\n         B     ST2\nST1      CLI   QPARM1,C' '         DID USER SPECIFY LEVEL?\n         BNE   *+L'*+6             YES, SKIP\nST2      MVC   QPARM1,QSTKEY       NO, USE LAST SEARCH KEY\n         MVC   QSTKEY,QPARM1       SAVE SEARCH KEY\n         BAS   R2,PARMLEN          DETERMINE PARM LENGTH\n         SPACE 1\n*---     SEARCH THE TSO QUEUE                                      ---*\n         SPACE 1\n         USING JQTDSECT,R1         BASE REG FOR JQT\nDJ2      LH    R6,QLNG1            LENGTH OF COMPARE FOR LEVEL\n         L     R1,QCJQHEAD         @ JQE'S QUEUES HEADS\n         LA    R4,JQTTSU           ADDR OF TSO QUEUE\n         MVI   QCLASS,0            INDICATE THIS IS THE TSO QUEUE\n         BAS   R2,SRCHJQE          SEARCH THE QUEUE\n         B     DJ3                 END OF QUEUE\n         CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?\n         BL    *+L'*+8             NO\n         CH    R5,JQEJOBNO         IS THIS THE RIGHT JOB NUMBER?\n         B     *+L'*+4\n         EX    R6,STCLC            IS THE JOB NAME EQUAL TO LEVEL?\n         BNE   SKIPJQE             NO, SKIP THIS RECORD\n         B     PRTJQE              PRINT THE RECORD\n         SPACE 1\n*---     SEARCH THE SYSTEM QUEUE                                   ---*\n         SPACE 1\nDJ3      L     R1,QCJQHEAD         @ JQE'S QUEUES HEADS\n         LA    R4,JQTSTC           ADDR OF STC QUEUE\n         MVI   QCLASS,4            INDICATE THIS IS THE STC QUEUE\n         BAS   R2,SRCHJQE          SEARCH THE QUEUE\n         B     DJ4                 END OF QUEUE\n         CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?\n         BL    *+L'*+8             NO\n         CH    R5,JQEJOBNO         IS THIS THE RIGHT JOB NUMBER?\n         B     *+L'*+4\n         EX    R6,STCLC            IS THE JOB NAME EQUAL TO LEVEL?\n         BNE   SKIPJQE             NO, SKIP THIS RECORD\n         B     PRTJQE              PRINT THE RECORD\n         SPACE 1\n*---     SEARCH FOR HELD OUTPUT                                    ---*\n         SPACE 1\nDJ4      L     R1,QCJQHEAD         @ JQE'S QUEUES HEADS\n         LA    R4,JQTOUT           ADDR OF $OUTPUT QUEUE\n         DROP  R1\n         MVI   QCLASS,8            INDICATE THIS IS THE HELD OUT Q\n         BAS   R2,SRCHJQE          SEARCH THE QUEUE\n         B     ST3                 END OF QUEUE\n         CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?\n         BL    *+L'*+8             NO\n         CH    R5,JQEJOBNO         IS THIS THE RIGHT JOB NUMBER?\n         B     *+L'*+4\n         EX    R6,STCLC            IS THE JOB NAME EQUAL TO LEVEL?\n         BNE   SKIPJQE             NO, SKIP THIS RECORD\n         CLI   JQEHLDCT,0          ANY HELD DATA-SETS? (PART 1)\n         BNE   PRTJQE              YES, PRINT THE RECORD\n         TM    JQEHLDCT,X'F0'      ANY HELD DATA-SETS? (PART 2)\n         BNZ   PRTJQE              YES, PRINT THE RECORD\n         B     REJJQE              REJECT THE RECORD\n         SPACE 1\n*---     SEARCH INPUT QUEUES                                       ---*\n         SPACE 1\nST3      MVI   QCLASS,192          START WITH CLASS A\nST4      BAS   R2,NEXTJQT          FIND NEXT QUEUE\n         BAS   R2,SRCHJQE          SEARCH THE QUEUE\n         B     ST4                 END OF QUEUE\n         CLI   JQEFLAG1,0          IS THE JOB EXECUTING OR HELD?\n         BNE   ST7                 YES, SPECIAL HANDLING\n         CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?\n         BL    *+L'*+8             NO\n         CH    R5,JQEJOBNO         IS THIS THE RIGHT JOB NUMBER?\n         B     *+L'*+4\n         EX    R6,STCLC            IS THE JOB NAME EQUAL TO LEVEL?\n         BNE   SKIPJQE             NO, SKIP THIS RECORD\n         B     PRTJQE              PRINT THE JQE\nST7      CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?\n         BL    *+L'*+8             NO\n         CH    R5,JQEJOBNO         IS THIS THE RIGHT JOB NUMBER?\n         B     *+L'*+4\n         EX    R6,STCLC            IS THE JOB NAME EQUAL TO LEVEL?\n         BNE   REJJQE              NO, SKIP THIS RECORD\n         B     PRT2JQE             PRINT REC WITHOUT INCR COUNT\n         SPACE 1\n*---     SEARCH OUTPUT QUEUES                                      ---*\n         SPACE 1\nST5      XR    R4,R4               SEARCH ALL OUTPUT CLASSES\n         BAS   R2,THISJOT\n         B     ST6S\nST6      BAS   R2,NEXTJOT          DETERMINE NEXT QUEUE\nST6S     BAS   R2,SRCHJOE          SEARCH A JOE QUEUE\n         B     ST6                 END OF QUEUE\n         CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?\n         BL    *+L'*+8             NO\n         CH    R5,JQEJOBNO         IS THIS THE RIGHT JOB NUMBER?\n         B     *+L'*+4\n         EX    R6,STCLC            IS THE JOB NAME EQUAL TO LEVEL?\n         BE    PRTJOE              YES, PRINT THE RECORD\n         NI    QDFREQ,255-QDFSV-QDFRS\n         B     SKIPJOE             SKIP THIS RECORD\n         SPACE 1\n*---     COMPARE USED TO CHECK LEVEL                               ---*\n         SPACE 1\nSTCLC    CLC   QPARM1(*-*),JQEJNAME  IS THE JOB NAME EQUAL TO LEVEL?\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* DJ : FIND A SPECIFIC JOB                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nDJ       CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?\n         BL    DJ0                 NO\n         LH    R1,QLNG1            LENGTH OF PARAMETER FIELD\n         SH    R1,=H'1'            IS THE LENGTH ZERO?\n         BM    DJ$TILT1            YES, TILT\n         LA    R15,QPARM1          POINT TO PARM\n         BAS   R14,QNUMCONV        CONVERT IT\n         BNE   DJ$TILT2            TILT IF NOT NUMERIC\n         LR    R5,R15              SAVE THE VALUE\n         B     DJ2                 USE THE STATUS ROUTINES\nDJ$TILT1 QTILT '*** MISSING JOB NUMBER ***'\nDJ$TILT2 QTILT '*** INVALID JOB NUMBER ***'\nDJ0      CLI   QPARM1,C' '         DID USER SPECIFY JOB NAME?\n         BE    DJ9                 NO, TILT\n         MVC   QLNG1,=H'7'         COMPARE FOR 8 CHARACTERS\n         B     DJ2                 USE THE STATUS ROUTINES\nDJ9      QTILT '*** YOU MUST SPECIFY JOB NAME ***'\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* DI : PRINT ALL JOBS IN INPUT QUEUES                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nDI       XC    TOTLNES,TOTLNES     RESET TOTAL COUNTERS\n         XC    TOTCPU,TOTCPU\n         XC    TOTIO,TOTIO\n         CLI   QPARM1,C' '         DID USER SPECIFY CLASS?\n         BNE   DI5                 YES, LIMIT TO ONE QUEUE\n         SPACE 1\n*---     SEARCH ALL QUEUES                                         ---*\n         SPACE 1\n         MVI   QCLASS,192          START WITH CLASS A\nDI2      BAS   R2,NEXTJQT          DETERMINE NEXT QUEUE\n         BAS   R2,SRCHJQE          SEARCH A JQE QUEUE\n         B     DI2                 END OF QUEUE\n         TM    JQEFLAG1,JQE1BUSY   IS THE JOB EXECUTING?\n         BNZ   REJJQE              YES, REJECT IT\n         B     PRTJQE              PRINT THE RECORD\n         SPACE 1\n*---     SEARCH ONLY ONE QUEUE                                     ---*\n         SPACE 1\nDI5      MVC   QCLASS,QPARM1       USER SPECIFIED CLASS\n         BAS   R2,FINDJQT          FIND QUEUE\n         BAS   R2,SRCHJQE          SEARCH THE QUEUE\n         B     SRCHSTOP            END OF QUEUE\n         TM    JQEFLAG1,JQE1BUSY   IS THE JOB EXECUTING?\n         BNZ   REJJQE              YES, REJECT IT\n         B     PRTJQE              PRINT THE RECORD\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* AI : PRINT JOBS IN INPUT QUEUES THAT ARE AVAILABLE FOR SELECTION    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nAI       CLI   QPARM1,C' '         DID USER SPECIFY CLASS?\n         BNE   AI5                 YES, LIMIT TO ONE QUEUE\n         SPACE 1\n*---     SEARCH ALL QUEUES                                         ---*\n         SPACE 1\n         MVI   QCLASS,192          START WITH CLASS A\nAI2      BAS   R2,NEXTJQT          DETERMINE NEXT QUEUE\n         BAS   R2,SRCHJQE          SEARCH A JQE QUEUE\n         B     AI2                 END OF QUEUE\n         CLI   JQEFLAG1,0          IS THE JOB BUSY OR HELD?\n         BNE   REJJQE              YES, SKIP IT\n         B     PRTJQE              PRINT THE RECORD\n         SPACE 1\n*---     SEARCH ONLY ONE QUEUE                                     ---*\n         SPACE 1\nAI5      MVC   QCLASS,QPARM1       USER SPECIFIED CLASS\n         BAS   R2,FINDJQT          FIND QUEUE\n         BAS   R2,SRCHJQE          SEARCH THE QUEUE\n         B     SRCHSTOP            END OF QUEUE\n         CLI   JQEFLAG1,0          IS THE JOB BUSY OR HELD?\n         BNE   REJJQE              YES, SKIP IT\n         B     PRTJQE              PRINT THE RECORD\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* AO : PRINT AVAILABLE JOBS IN THE OUTPUT QUEUE                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nAO       CLI   QPARM1,C' '         DID USER SPECIFY CLASS?\n         BNE   AO5                 YES, LIMIT TO ONE QUEUE\n         SPACE 1\n*---     SEARCH ALL QUEUES                                         ---*\n         SPACE 1\n         XR    R4,R4               START WITH FIRST CLASS\n         BAS   R2,THISJOT          START SEARCH\nAO2S     BAS   R2,SRCHJOE          SEARCH A JQE QUEUE\n         B     AO2                 END OF QUEUE\n         B     PRTJOE              PRINT THE RECORD\nAO2      BAS   R2,NEXTJOT          DETERMINE NEXT QUEUE\n         B     AO2S\n         SPACE 1\n*---     SEARCH ONLY ONE QUEUE                                     ---*\n         SPACE 1\nAO5      MVC   QCLASS,QPARM1       USER SPECIFIED CLASS\n         BAS   R2,FINDJOT          FIND QUEUE\n         BAS   R2,SRCHJOE          SEARCH THE QUEUE\n         B     AO5S                END OF QUEUE\n         B     PRTJOE              PRINT THE RECORD\nAO5S     BAS   R2,NEXTJOT          DETERMINE THE OTHER QUEUE\n         BAS   R2,SRCHJOE          SEARCH A JQE QUEUE\n         B     SRCHSTOP            END OF QUEUE\n         B     PRTJOE              PRINT THE RECORD\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* DL : PRINT AVAILABLE JOBS IN THE OUTPUT QUEUE (LOCAL OR REMOTE)     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nDL       CLI   QPARM1,C' '         DID USER SPECIFY CLASS?\n         BNE   DL5                 YES, LIMIT TO ONE QUEUE\n         SPACE 1\n*---     SEARCH ALL QUEUES (LOCAL OR REMOTE)                       ---*\n         SPACE 1\n         LA    R4,1                START WITH FIRST CLASS\n         CLI   QCODE,52            IS IT LOCAL REQUEST?\n         BE    *+L'*+4             YES\n         LA    R4,1(R4)            NO, REMOTE\n         BAS   R2,THISJOT          START SEARCH\nDL2S     BAS   R2,SRCHJOE          SEARCH A JQE QUEUE\n         B     DL2                 END OF QUEUE\n         B     PRTJOE              PRINT THE RECORD\nDL2      LA    R4,2\n         BAS   R2,NEXTJOT+L'NEXTJOT     DETERMINE NEXT QUEUE\n         B     DL2S\n         SPACE 1\n*---     SEARCH ONLY ONE QUEUE (LOCAL OR REMOTE)                   ---*\n         SPACE 1\nDL5      MVC   QCLASS,QPARM1       USER SPECIFIED CLASS\n         TR    QCLASS,CLASSTBL     DETERMINE OFFSET\n         LH    R4,QCLASSH          LOAD TABLE OFFSET\n         SLL   R4,1                TO A-Z,0-9 CLASSES\n         CLI   QCODE,56            IS IT REMOTE REQUEST?\n         BE    *+L'*+2             YES\n         BCTR  R4,0                SUBTRACT 1\n         BAS   R2,GETJOT           GET QUEUE\n         BAS   R2,SRCHJOE          SEARCH THE QUEUE\n         B     SRCHSTOP            END OF QUEUE\n         B     PRTJOE              PRINT THE RECORD\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* HI : PRINT JOBS IN INPUT QUEUES THAT ARE HELD                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nHI       CLI   QPARM1,C' '         DID USER SPECIFY CLASS?\n         BNE   HI5                 YES, LIMIT TO ONE QUEUE\n         SPACE 1\n*---     SEARCH ALL QUEUES                                         ---*\n         SPACE 1\n         MVI   QCLASS,192          START WITH CLASS A\nHI2      BAS   R2,NEXTJQT          DETERMINE NEXT QUEUE\n         BAS   R2,SRCHJQE          SEARCH A JQE QUEUE\n         B     HI2                 END OF QUEUE\nQUEHALL  EQU   JQE1HLDA+JQE1HLD1+JQE1HLD2\n         TM    JQEFLAG1,QUEHALL    IS THE JOB HELD?\n         BZ    REJJQE              NO, SKIP IT\n         B     PRTJQE              PRINT THE RECORD\n         SPACE 1\n*---     SEARCH ONLY ONE QUEUE                                     ---*\n         SPACE 1\nHI5      MVC   QCLASS,QPARM1       USER SPECIFIED CLASS\n         BAS   R2,FINDJQT          FIND QUEUE\n         BAS   R2,SRCHJQE          SEARCH THE QUEUE\n         B     SRCHSTOP            END OF QUEUE\n         TM    JQEFLAG1,QUEHALL    IS THE JOB HELD?\n         BZ    REJJQE              NO, SKIP IT\n         B     PRTJQE              PRINT THE RECORD\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* HO : LIST ALL JOBS WITH HELD OUTPUT                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\n         USING JQTDSECT,R1         BASE REG FOR JQT\nHO       L     R1,QCJQHEAD         @ JQE'S QUEUES HEADS\n         LA    R4,JQTOUT           ADDR OF $OUTPUT QUEUE\n         DROP  R1\n         MVI   QCLASS,8            INDICATE THIS IS THE HELD OUT Q\n         BAS   R2,SRCHJQE          SEARCH THE QUEUE\n         B     SRCHSTOP            END OF QUEUE\n         CLI   JQEHLDCT,0          ANY HELD DATA-SETS? (PART 1)\n         BNE   PRTJQE              YES, PRINT THE RECORD\n         TM    JQEHLDCT,X'F0'      ANY HELD DATA-SETS? (PART 2)\n         BNZ   PRTJQE              YES, PRINT THE RECORD\n         B     REJJQE              REJECT THE RECORD\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* DA : FIND ALL EXECUTING JOBS                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nDA       MVI   QCLASS,192          START WITH CLASS A\nDA2      BAS   R2,NEXTJQT          DETERMINE NEXT QUEUE\n         BAS   R2,SRCHJQE          SEARCH THE QUEUE\n         B     DA2                 END OF QUEUE\n         TM    JQEFLAG1,JQE1BUSY   IS THE JOB EXECUTING?\n         BZ    REJJQE              NO, REJECT IT\n         B     PRTJQE              PRINT THE RECORD\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* DT : LIST ALL TSO USERS                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\n         USING JQTDSECT,R1         BASE REG FOR JQT\nDT       L     R1,QCJQHEAD         @ JQE'S QUEUES HEADS\n         LA    R4,JQTTSU           ADDR OF TSO QUEUE\n         DROP  R1\n         MVI   QCLASS,0            INDICATE THIS IS THE TSO Q\n         BAS   R2,SRCHJQE          SEARCH THE QUEUE\n         B     SRCHSTOP            END OF QUEUE\n         B     PRTJQE              PRINT THE RECORD\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* DS : LIST ALL SYSTEM STARTED TASKS                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\n         USING JQTDSECT,R1         BASE REG FOR JQT\nDS       L     R1,QCJQHEAD         @ JQE'S QUEUES HEADS\n         LA    R4,JQTSTC           ADDR OF STC QUEUE\n         DROP  R1\n         MVI   QCLASS,4            INDICATE THIS IS THE STC QUEUE\n         BAS   R2,SRCHJQE          SEARCH THE QUEUE\n         B     SRCHSTOP            END OF QUEUE\n         B     PRTJQE              PRINT THE RECORD\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* QI : SUMMARY OF ALL JOBS IN THE INPUT QUEUES                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nQI       MVI   QCLASS,192          START WITH CLASS A\n         MVC   QDHLINE,QIHEADER    MOVE THE HEADING\nQI1      BAS   R2,NEXTJQT          FIND NEXT QUEUE\n         ZAP   QCOUNTE,=P'0'       ZERO COUNT FOR EXECUTING JOBS\n         ZAP   QCOUNTA,=P'0'       ZERO COUNT FOR AWAITING JOBS\n         ZAP   QCOUNTH,=P'0'       ZERO COUNT FOR HELD JOBS\n         BAS   R2,SRCHJQE          SEARCH THE QUEUE\n         B     QI4                 END OF QUEUE\n         TM    JQEFLAG1,JQE1BUSY   IS THIS JOB EXECUTING?\n         BZ    QI2                 NO, NEXT TEST\n         AP    QCOUNTE,=P'1'       YES, BUMP COUNTER\n         B     SKIPJQE             PROCESS NEXT JQE\nQI2      TM    JQEFLAG1,QUEHALL    HELD JOB?\n         BZ    QI3                 NO, NEXT TEST\n         AP    QCOUNTH,=P'1'       YES, BUMP COUNTER\n         B     SKIPJQE             PROCESS NEXT JQE\nQI3      CLI   JQEFLAG1,0          IS THIS JOB AWAITING EXECUTION?\n         BNE   SKIPJQE             NO, PROCESS NEXT JQE\n         AP    QCOUNTA,=P'1'       YES, BUMP COUNTER\n         B     SKIPJQE             PROCESS NEXT JQE\nQI4      CLC   QCOUNT,=PL3'0'      IS THIS QUEUE EMPTY?\n         BE    QI1                 YES, TRY NEXT QUEUE\n         MVC   QDMSG,QBLANK\n         MVC   QTCOUNT,=XL6'402020202120'\n         ED    QTCOUNT,QCOUNTE\n         MVC   QECOUNT,QTCOUNT+3   NO. OF EXECUTING JOBS\n         MVC   QTCOUNT,=XL6'402020202120'\n         ED    QTCOUNT,QCOUNTA\n         MVC   QACOUNT,QTCOUNT+3   NO. OF AWAITING JOBS\n         MVC   QTCOUNT,=XL6'402020202120'\n         ED    QTCOUNT,QCOUNTH\n         MVC   QHCOUNT,QTCOUNT+3   NO. OF HELD JOBS\n         MVC   QTCOUNT,=XL6'402020202120'\n         ED    QTCOUNT,QCOUNT      TOTAL NO. OF JOBS IN THIS QUEUE\n         MVC   CLASS,QCLASS        MOVE IN QUEUE CLASS\n         QCALL DISPLAY,QDMSG,80    DISPLAY THE LINE\n         B     QI1                 PROCESS THE NEXT QUEUE\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* QO : SUMMARY OF ALL JOBS IN THE OUTPUT QUEUES                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nQO       XR    R4,R4               START WITH FIRST CLASS\n         XC    TOTLNES,TOTLNES     RESET TOTAL COUNTER\n         MVC   QDHLINE,QOHEADER    MOVE THE HEADING\n         BAS   R2,THISJOT          START SEARCH\n         B     QOS\nQO1      BAS   R2,NEXTJOT          FIND NEXT QUEUE\nQOS      ZAP   QCOUNTE,=P'0'       ZERO COUNT FOR EXECUTING JOBS\n         ZAP   QCOUNTA,=P'0'       ZERO COUNT FOR AWAITING JOBS\n         ZAP   QCOUNTH,=P'0'       ZERO COUNT FOR HELD JOBS\n         XR    R5,R5               ACCUMULATOR FOR LINES COUNT\n         ZAP   QCOUNT,=P'0'        ZERO THE QUEUE COUNT\nQOC      BAS   R2,FIRSTJOE         SEARCH THE QUEUE\n         B     QO2                 END OF QUEUE\n         A     R5,JOERECCT         ADD UP COUNT OF RECS\n         L     R14,QCMSA           @ MASTER CKPT RECORD\n         LH    R14,$NODEID-$SAVEBEG(,R14)    THIS NODE ID\n         SLL   R14,16              MAKE LOCAL ID\n         CL    R14,JOEROUT         IS THIS LOCAL?\n         BNE   QOR                 NO, IT IS REMOTE\n         AP    QCOUNTA,=P'1'       YES, IT IS LOCAL\n         B     QOA\nQOR      AP    QCOUNTH,=P'1'       REMOTE\nQOA      TM    JOEFLAG1,JOE1PRT    IS JOB PRINTING?\n         BZ    SKIPJOE             NO, PROCESS NEXT JOE\n         AP    QCOUNTE,=P'1'       YES, BUMP COUNTER\n         B     SKIPJOE             PROCESS NEXT JOE\nQO2      CLI   QCLASSE+1,C'>'      LAST QUEUE ID OF THIS CLASS?\n         BE    QOP                 YES\n         BAS   R2,NEXTJOT          FIND NEXT QUEUE\n         B     QOC                 CONTINUE\nQOP      CLC   QCOUNT,=PL3'0'      IS THIS QUEUE EMPTY?\n         BE    QO1                 YES, TRY NEXT QUEUE\n         MVC   QDMSG,QBLANK\n         MVC   QTCOUNT,=XL6'402020202120'\n         ED    QTCOUNT,QCOUNTE\n         MVC   QECOUNT,QTCOUNT+3   NO. OF PRINTING JOBS\n         MVC   QTCOUNT,=XL6'402020202120'\n         ED    QTCOUNT,QCOUNTA\n         MVC   QACOUNT,QTCOUNT+3   NO. OF LOCAL JOBS\n         MVC   QTCOUNT,=XL6'402020202120'\n         ED    QTCOUNT,QCOUNTH\n         MVC   QHCOUNT,QTCOUNT+3   NO. OF REMOTE JOBS\n         MVC   QTCOUNT,=XL6'402020202120'\n         ED    QTCOUNT,QCOUNT      TOTAL NO. OF JOBS IN THIS QUEUE\n         MVC   CLASS(1),QCLASSE    MOVE IN QUEUE CLASS\n         CVD   R5,FMT@CONV         CONVERT RECORDS TO DECIMAL\n         A     R5,TOTLNES          ADD UP TOTAL RECORDS\n         ST    R5,TOTLNES          AND SAVE IT AWAY\n         CP    FMT@CONV+2(6),=PL6'+99999'\n         BH    QO3\n         MVC   QTRECS(6),=XL6'402020202120'\n         ED    QTRECS(L'QTRECS),FMT@CONV+5   TOTAL\n         B     QO5\nQO3      MVC   QTRECS-1(6),=XL6'402020202120'\n         MVO   FMT@CONV,FMT@CONV(6)\n         CP    FMT@CONV+2(6),=PL6'+99999'\n         BH    QO4\n         MVI   QTRECS+L'QTRECS-1,C'K'\n         ED    QTRECS-1(L'QTRECS),FMT@CONV+5 TOTAL IN K\n         B     QO5\nQO4      MVO   FMT@CONV,FMT@CONV(6)\n         MVI   QTRECS+L'QTRECS-1,C'M'\n         ED    QTRECS-1(L'QTRECS),FMT@CONV+5 TOTAL IN M\nQO5      QCALL DISPLAY,QDMSG,80    DISPLAY THE LINE\n         B     QO1                 PROCESS THE NEXT QUEUE\n         SPACE 1\n*---     DETERMINE LENGTH OF LEVEL                                 ---*\n         SPACE 1\nPARMLEN  LA    R3,7                MAXIMUM LENGTH OF 8\n         LA    R4,QPARM1+7         END OF FIELD\nPARMLEN2 CLI   0(R4),C' '          IS THIS BYTE BLANK?\n         BNE   PARMLEN3            NO, THIS IS THE LENGTH\n         BCTR  R4,0                TRY PREVIOUS BYTE\n         BCT   R3,PARMLEN2         LOOP\nPARMLEN3 STH   R3,QLNG1            STORE THE LENGTH OF LEVEL\n         BR    R2                  RETURN TO CALLER\n         SPACE 1\n*---     SEARCH A JQE QUEUE                                        ---*\n         SPACE 1\nSRCHJQE  ZAP   QCOUNT,=P'0'        ZERO THE QUEUE COUNT\n         L     R9,0(R4)            LOAD FIRST JQE OFFSET\nNEXTJQE2 N     R9,=A(X'00FFFFFF')  END OF QUEUE?\n         BZR   R2                  BRANCH IF END OF QUEUE\n         AL    R9,QCJQEWA          ADD BASE TO OFFSET\n         B     4(R2)               DETERMINE ELIGIBILITY\nPRTJQE   AP    QCOUNT,=P'1'        INCREMENT COUNT\nPRT2JQE  XR    R1,R1               INDICATE THIS IS A JQE\n         QCALL FORMAT              PRINT THE JQE IN R9\nREJJQE   L     R9,JQENEXT          LOAD OFFSET TO NEXT JQE\n         B     NEXTJQE2            GET THE NEXT JQE\nSKIPJQE  AP    QCOUNT,=P'1'        INCREMENT COUNT\n         B     REJJQE              CONTINUE\n         SPACE 1\n*---     SEARCH A JOE QUEUE                                        ---*\n         SPACE 1\nSRCHJOE  ZAP   QCOUNT,=P'0'        ZERO THE QUEUE COUNT\nFIRSTJOE L     R8,0(R4)            LOAD FIRST JOE OFFSET\n         N     R8,=A(X'00FFFFFF')  END OF QUEUE?\n         BZR   R2                  YES, RETURN TO CALLER\n         XC    PRIORITY(12),PRIORITY    ZERO OUT HIGHEST POINTERS\nNEXTJOE  N     R8,=A(X'00FFFFFF')  END OF QUEUE?\n         BZ    TESTJOE             BRANCH IF END, RET HIGHEST\n         AL    R8,QCJOTWA          ADD BASE TO OFFSET\n         L     R9,JOEJQE           OFFSET TO JQE\n         N     R9,=A(X'00FFFFFF')  ANY POINTER?\n         BZ    TRYJOE              BRANCH IF THIS JOE ALREADY USED\n         AL    R9,QCJQEWA          ADD BASE TO OFFSET\n         LA    R7,255              PRESET MAXIMUM PRIORITY\n         TM    JQEPRIO,240         IS THIS JOB PRIORITY 15?\n         BO    HIGHJOE             YES, PASS TO CALLER\n         LA    R1,16               PRESET PRIORITY ONE\n         CLI   JQETYPE,$HARDCPY    IS THE JOB EXECUTING?\n         BNE   *+L'*+4             YES, USE PRIORITY ONE\n         IC    R1,JQEPRIO          INSERT JQE PRIORITY\n         IC    R7,JOEPRIO          INSERT JOE PRIORITY\n         AR    R7,R1               ADD PRIORITIES\n         SRL   R7,1                'CUZ HASP DOES IT, THAT'S WHY\nHIGHJOE  C     R7,PRIORITY         THIS LESS THAN PREVIOUS HIGH?\n         BL    TRYJOE              YES, TRY NEXT ONE\n         STM   R7,R9,PRIORITY      NO, REPLACE PREVIOUS HIGH\nTRYJOE   L     R8,JOENEXT          ADDR OF NEXT JOE\n         B     NEXTJOE             TRY NEXT JOE\nTESTJOE  LM    R7,R9,PRIORITY      LOAD ADDR OF HIGHEST JOE\n         LTR   R8,R8               WAS THE QUEUE EMPTY?\n         BZR   R2                  YES, END OF QUEUE\n         CLI   QSUBNAME,C'X'       IS THE REQUEST FOR A HEX DUMP?\n         BNE   *+L'*+10            NO\n         MVC   QPTRSV+13(3),JOEJQEB     SAVE INFO FOR DUMP\n         OI    QDFREQ,QDFSV\n         MVC   JOEJQEB,=XL3'00'    INDICATE THIS JOE USED\n         B     4(R2)               DETERMINE ELIGIBILITY\nPRTJOE   LA    R1,4                INDICATE THIS IS A JOE\n         AP    QCOUNT,=P'1'        INCREMENT COUNT\n         QCALL FORMAT              PRINT THE JOE IN R8\n         B     FIRSTJOE            GET THE NEXT JOE\nSKIPJOE  AP    QCOUNT,=P'1'        INCREMENT COUNT\n         B     FIRSTJOE            CONTINUE\n         SPACE 1\n*---     DETERMINE INPUT QUEUE                                     ---*\n         SPACE 1\nFINDJQT  TR    QCLASS,CLASSTBL     DETERMINE OFFSET\n         LH    R4,QCLASSH          LOAD TABLE OFFSET\n         BCTR  R4,0                SUBTRACT 1\n         STH   R4,QCLASSH          RESTORE VALUE\n         B     NEXTJQT2            CONTINUE\nNEXTJQT  TR    QCLASS,CLASSTBL     DETERMINE OFFSET FROM 1ST CLASS\n         LH    R4,QCLASSH          LOAD TABLE OFFSET\n         CH    R4,=H'36'           IS THIS THE LAST QUEUE?\n         BNL   NEXTJQT9            YES, GO HOME\nNEXTJQT2 TR    QCLASS,NAMETBL      MOVE CLASS NAME TO QCLASS\n         SLL   R4,2                * 4\n         USING JQTDSECT,R1         BASE REG FOR JQT\n         L     R1,QCJQHEAD         @ JQE'S QUEUES HEADS\n         LA    R4,JQTCLSA(R4)      NEXT QUEUE\n         DROP  R1\n         BR    R2                  RETURN TO CALLER\nNEXTJQT9 CLI   QCODE,0             IS THIS A STATUS REQUEST?\n         BE    ST5                 YES, GO TO STATUS\n         CLI   QCODE,36            IS THIS A DJ REQUEST?\n         BNE   SRCHSTOP            NO, GO HOME\n         B     ST5                 YES, GO TO STATUS\n         SPACE 1\n*---     DETERMINE OUTPUT QUEUE                                    ---*\n         SPACE 1\nFINDJOT  TR    QCLASS,CLASSTBL     DETERMINE OFFSET\n         LH    R4,QCLASSH          LOAD TABLE OFFSET\n         SLL   R4,1                TO A-Z,0-9 CLASSES\n         BCTR  R4,0                SUBTRACT 1\nTHISJOT  STH   R4,QCLASSH\n         B     GETJOT\nNEXTJOT  LA    R4,1\n         AH    R4,QCLASSH\n         STH   R4,QCLASSH\nGETJOT   CH    R4,=Y(1+(2*36))     IS THIS THE LAST QUEUE?\n         BNL   SRCHSTOP            YES, GO HOME\n         LR    R1,R4               COPY QUEUE ID\n         SLL   R1,1                OFFSET OF QUEUE CHAR FORM\n         LA    R1,SR#TAB1(R1)      @ OF QUEUE ID\n         MVC   QCLASSE,0(R1)       RETURN QUEUE ID IN CHAR TOO\n         SLL   R4,2                * 4 FOR OFFSET\n         USING JOT,R1              BASE REG FOR JOT\n         L     R1,QCJOTWA          LOAD ADDR OF JOT\n         LA    R4,JOTRDYWQ(R4)     NEXT QUEUE\n         DROP  R1\n         BR    R2                  RETURN TO CALLER\n         SPACE 1\n*---     GO HOME                                                   ---*\n         SPACE 1\nSRCHSTOP CLI   QCODE,8             IS THIS A DI REQUEST?\n         BE    DITEU0              YES, GET TOTALS\n         CLI   QCODE,48            IS THIS A QO REQUEST?\n         BNE   SRCHEXIT            NO, GO HOME\n         L     R1,TOTLNES\n         LTR   R1,R1\n         BZ    SRCHEXIT\n         L     R7,QVDSPL           LOAD BASE REG\n         USING QDISPLAY,R7         BASE REG FOR DISPLAY WORK AREA\n         MVC   FCLEAR,QBLANK       CLEAR THE PRINT AREA\n         $FS   SF=(PROT,INT),MF=(I,FCLEAR)\n         MVC   FQUEUE(QOTEUL),QOTEUS    SET IN FINAL TOTAL MSG\n         CVD   R1,FMT@CONV         CONVERT TOTAL IN DECIMAL\n         ED    FQUEUE+L'QOTEUS(L'QOTEUN),FMT@CONV+3    EDIT IT\n         $FS   SF=(PROT),MF=(I,QDMSG+L'QDMSG-2)   NORMAL INT, PROT\n         OI    QDOVER,QTSKIP       NO TRANSLATE\n         QCALL DISPLAY,QDMSG,80    DISPLAY THE LINE\n         OI    QDOVER,QESKIP       NO END OF DATA LINE\n         DROP  R7\n         B     SRCHEXIT            GO HOME\nDITEU0   L     R7,QVDSPL           LOAD BASE REG\n         USING QDISPLAY,R7         BASE REG FOR DISPLAY WORK AREA\n         CLC   QDHLINE,DIDUMMY     WAS ANYTHING WRITTEN?\n         BE    SRCHEXIT            NO, SKIP\n         MVC   FCLEAR,QBLANK       CLEAR THE PRINT AREA\n         $FS   SF=(PROT,INT),MF=(I,FCLEAR)\n         L     R1,TOTLNES\n         CVD   R1,FMT@CONV\n         MVC   FLINES+1,=XL6'402020202120'\n         CP    FMT@CONV+5(3),=PL3'+99999'\n         BNH   DITEU1\n         MVI   FLINES+6,C'M'\n         ED    FLINES+1(L'FLINES),FMT@CONV+4 TOTAL LINES IN M\n         B     DITEU2\nDITEU1   ED    FLINES+1(L'FLINES),FMT@CONV+5 TOTAL LINES IN K\nDITEU2   LA    R15,DITEU4\n         L     R1,TOTCPU\n         CL    R1,=A(999*60*60)\n         BNH   DITEU3\n         MVC   FCPU+1(9),=CL9'> 999 HRS'\n         BR    R15\nDITEU3   BAS   R14,DITEUCVD        TOTAL CPU\n         MVC   FCPU+1(9),=CL9'  0: 0: 0'\n         MVC   FCPU+8(2),FIELD+2\n         BAS   R14,DITEUCVD\n         MVC   FCPU+5(2),FIELD+2\n         LTR   R0,R1\n         BNPR  R15\n         BAS   R14,DITEUCVE\n         MVC   FCPU+1(3),FIELD+1\n         BR    R15\nDITEUCVD LTR   R1,R1\n         BNPR  R15\n         C     R1,=F'60'\n         BNL   DITEUCVR\n         LR    R0,R1\n         XR    R1,R1\n         B     DITEUCVE\nDITEUCVR XR    R0,R0\n         D     R0,=F'60'\nDITEUCVE CVD   R0,FMT@CONV\n         MVC   FIELD(4),=XL4'40202120'\n         ED    FIELD(4),FMT@CONV+6\n         BR    R14\nDITEU4   L     R1,TOTIO\n         CVD   R1,FMT@CONV\n         MVC   FIO+1,=XL6'402020202120'\n         CP    FMT@CONV+5(3),=PL3'+99999'\n         BNH   DITEU5\n         MVI   FIO+6,C'M'\n         ED    FIO+1(L'FIO),FMT@CONV+4  TOTAL I/O IN M\n         B     DITEU6\nDITEU5   ED    FIO+1(L'FIO),FMT@CONV+5  TOTAL I/O IN K\nDITEU6   MVC   FCOUNT(8),=CL8'TOTALS :'\n         $FS   SF=(PROT),MF=(I,QDMSG+L'QDMSG-2)   NORMAL INT, PROT\n         OI    QDOVER,QTSKIP       NO TRANSLATE\n         QCALL DISPLAY,QDMSG,80    DISPLAY THE LINE\n         OI    QDOVER,QESKIP       NO END OF DATA LINE\n         DROP  R7\nSRCHEXIT QSTOP\n         SPACE 1\n*---     TABLES FOR CLASS DETERMINATION                            ---*\n         SPACE 1\nNAMETBL  DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\nCLASSTBL DC    192X'01'\n         DC    X'00010203040506070809',7X'00'\n         DC    X'0A0B0C0D0E0F101112',8X'00'\n         DC    X'131415161718191A',6X'00'\n         DC    X'1B1C1D1E1F2021222324',6X'00'\n         SPACE 1\n*---     OUTPUT QUEUE NAMES (SEE $JOT)                             ---*\n         SPACE 1\nSR#TAB1  DC    C'NT'               NETWORK QUEUE\n         DC    C'A A>B B>C C>D D>E E>F F>G G>H H>I I>J J>K K>L L>M M>'\n         DC    C'N N>O O>P P>Q Q>R R>S S>T T>U U>V V>W W>X X>Y Y>Z Z>'\n         DC    C'0 0>1 1>2 2>3 3>4 4>5 5>6 6>7 7>8 8>9 9>'\n         SPACE 1\nQIHEADER DC    CL79'QUEUE   #JOBS  EXECUTING  WAITING   HELD'\nQOHEADER DC    CL79'QUEUE   #JOBS   PRINTING    LOCAL  REMOTE   RECS.'\nQOTEUS   DC    C'TOTAL RECORDS IN QUEUES SELECTED :'\nQOTEUN   DC    X'402020204B2020204B202120'\nQOTEUL   EQU   *-QOTEUS\nDIDUMMY  DC    CL79'    NO DATA IS AVAILABLE FOR YOUR REQUEST'\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R8,R9,R10,R11,R12\n TITLE '--- QUEUE/SP -- SYSLOG -- LIST THE SYSTEM LOG DATA-SET ---'\nSYSLOG   QSTART\n         USING QCKPT,R10           BASE REG FOR CKPT WORK AREA\n         L     R10,QVCKPT          LOAD BASE REG\n         CLI   QXAUTH,LV10         AUTHORIZED?\n         BL    SL$TILTI            NO\n         SPACE 1\n*---     CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT              ---*\n         SPACE 1\n         QCALL FINDJOB             FIND THE JOB\n         SPACE 1\n*---     CHECK JOB NAME EQUAL SYSLOG                               ---*\n         SPACE 1\n         L     R9,QCJCTA           ADDR OF IOAREA FOR JCT\n         USING JCTSTART,R9         BASE REG FOR JCT\n         CLC   JCTJNAME,=CL8'SYSLOG'    IS THIS SYSLOG?\n         BNE   SL$TILT             NO, TILT\n         SPACE 1\n*---     DETERMINE NUMBER OF DATA-SETS FROM CURRENT DATA-SET       ---*\n         SPACE 1\n         LH    R3,JCTPDDBK         HIGHEST DATA-SET ID NUMBER\n         LH    R1,QLNG2            LENGTH OF BACKUP PARM\n         SH    R1,=H'1'            IS THE BACKUP PARM ZERO LENGTH?\n         BM    SL$CALST            YES, SKIP\n         CLI   QPARM2,C'-'         IS THERE A MINUS SIGN?\n         BNE   *+L'*+4             NO, SKIP\n         MVI   QPARM2,C'0'         CHANGE MINUS TO ZERO\n         LA    R15,QPARM2          POINT TO PARM\n         BAS   R14,QNUMCONV        CONVERT IT\n         BNE   SL$TILT             QUIT IF NOT NUMERIC\n         SR    R3,R15              BACK UP NUMBER OF DATA-SETS\n         CH    R3,=H'101'          IS THE NUMBER LESS THAN 101?\n         BL    SL$TILT             YES, TILT\n         SPACE 1\n*---     CALL LISTDS TO LIST THE DATA-SET                          ---*\n         SPACE 1\nSL$CALST STH   R3,QPDSID           STORE DATA-SET ID\n         MVC   QPOFFSET,=H'0'      PRINT OFFSET ZERO\n         QCALL LISTDS\n         QSTOP\nSL$TILT  QTILT '*** INVALID PARAMETER ***'\nSL$TILTI QTILT '=== NOT AVAILABLE TO YOU, SORRY ==='\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9,R10,R11,R12\n         TITLE '--- QUEUE/SP -- TSOCMD -- TSO COMMAND OR CLIST ---'\nTSOCMD   QSTART\n         L     R10,QVDSPL          @ DISPLAY WORK AREA\n         USING QDISPLAY,R10\n         NI    QTSSW,255-CLTSO-CLSTX-CLSTP\n         CLI   QCODE,0             TSO COMMAND/CLIST EXECUTION?\n         BE    TC$CMD              YES\n         CLC   QPARM1(5),=CL5'FULL '    FULL DISPLAY REQUESTED?\n         BE    TSOCMD3             YES\n         CLC   QPARM1(3),=CL3'ON ' SET ACTIVE?\n         BE    TSOCMD2             YES\n         CLC   QPARM1(4),=CL4'OFF '     SET INACTIVE?\n         BE    TSOCMD1             YES\n         CLI   QPARM1,C' '         DEFAULT OFF?\n         BE    TSOCMD1             YES\n         QTILT '=== INVALID DISPLAY REQUEST (ON/OFF) ==='\nTSOCMD1  NI    QTSSW,255-RCTSO-FLTSO    OFF TSO RC DISPLAY\n         QTILT '=== TSO COMMANDS R.C. DISPLAY OFF ==='\nTSOCMD2  OI    QTSSW,RCTSO         ON TSO RC DISPLAY\n         NI    QTSSW,255-FLTSO     OFF FULL TSO RC DISPLAY\n         QTILT '=== TSO COMMANDS R.C. DISPLAY ON ==='\nTSOCMD3  OI    QTSSW,RCTSO+FLTSO   ON FULL TSO RC DISPLAY\n         QTILT '=== FULL TSO COMMANDS R.C. DISPLAY ON ==='\nTC$CMD   CLC   QPARM1,QBLANK       ANYTHING TO DO?\n         BNE   TC$CTL              YES, GO CONTROL\n         QTILT '*** MISSING TSO COMMAND ***'\nTC$CTL   CLI   QPARM1,C'%'         CLIST EXECUTION?\n         BNE   TC$CTLS             NO, GO SCAN\n         MVC   QPARM1(L'QPARM1-1),QPARM1+1   SHIFT NAME\n         MVI   QPARM1+L'QPARM1-1,C' '\n         LH    R1,QOFF1            ADJUST OFFSET\n         LA    R1,1(R1)\n         STH   R1,QOFF1\n         LH    R1,QLNG1            ADJUST LENGTH\n         BCTR  R1,0\n         STH   R1,QLNG1\n         OI    QTSSW,CLTSO         INDICATE CLIST\n         B     TC$CMD\nTC$CTLS  TM    QTSSW,CLTSO         IS IT A CLIST?\n         BO    TC$XEQ              YES\n         LA    R1,TC#TCMD          SCAN RESERVED COMMAND\nTC$LOOP  CLC   0(L'TC#TCMD,R1),QPARM1   MATCH?\n         BE    TC$KILL             YES, REJECT IT\n         BL    TC$XEQ              NO MORE FURTHER, PROCESS IT\n         LA    R1,L'TC#TCMD(R1)    BUMP TO NEXT\n         CLI   0(R1),X'FF'         END OF TABLE?\n         BNE   TC$LOOP             NO, CONTINUE\n         B     TC$XEQ              YES, PROCESS IT\nTC$KILL  MVC   QDMSG(L'TC#KILLS),TC#KILLS\n         LA    R2,QDMSG+L'TC#KILLS\n         MVC   0(L'TC#TCMD,R2),0(R1)\n         LA    R2,L'TC#TCMD-1(R2)\n         CLI   0(R2),C' '\n         BNE   *+L'*+4\n         BCT   R2,*-8\n         MVC   1(L'TC#KILLE,R2),TC#KILLE\n         LA    R1,QDMSG\n         LA    R0,L'TC#KILLS+L'TC#KILLE+8\n         QTILT\nTC$XEQ   L     R9,ATSOX            TSO WORK AREA ADDRESS\n         LTR   R9,R9               ALREADY ACQUIRED?\n         BNZ   TSOCMX              YES\n         LA    R0,TSOXEQL          SIZE FOR GETMAIN REQUEST\n         GETMAIN R,LV=(0)\n         LR    R9,R1\n         ST    R9,ATSOX            SAVE ADDRESS\n         USING TSOXEQ,R9\n         SPACE 1\n*---     TELL VTAM WE'RE DONE                                      ---*\n         SPACE 1\nTSOCMX   TPUT  TC#CLEAR,TC#CLL,FULLSCR,,HOLD      CLEAR THE SCREEN\n         STFSMODE  OFF\n         SPACE 1\n         MVC   GTPBK(GTPBLN),GTPBL CLEAR GETLINE LIST\n         MVC   ATTCH(ATTLN),ATTCHL CLEAR ATTACH LIST\n         LA    R6,GTPBK            GETLINE PARM BLOCK\n         USING GTPB,R6\n         L     R5,DAPLECT          POINT TO ECT\n         USING ECT,R5\n         MVC   TSOPCMD,ECTPCMD     SAVE PRIMARY COMMAND NAME\n         MVC   TSOSCMD,ECTSCMD     AND SECONDARY COMMAND NAME\n         LA    R4,TSOCPPL          ADDRESS OF CPPL FOR COMMAND\n         USING CPPL,R4\n         MVC   CPPLUPT,DAPLUPT     COPY UPT POINTER\n         MVC   CPPLPSCB,DAPLPSCB   COPY PSCB POINTER\n         MVC   CPPLECT,DAPLECT     COPY ECT POINTER\n         LA    R1,TSOXCMD          ADDRESS OF COMMAND BUFFER\n         USING CMDBUF,R1\n         LH    R14,QDRLNG          COMPUTE TSO COMMAND LENGTH\n         SH    R14,QOFF1\n         AH    R14,=H'4'\n         STH   R14,CMDLEN          STORE COMMAND BUFFER LENGTH\n         LA    R15,QDREPLY         COMPUTE TSO COMMAND ADDRESS\n         AH    R15,QOFF1\n         LA    R14,QDREPLYL        COMPUTE MOVE LENGTH\n         SH    R14,QOFF1\n         B     *+L'*+6\n         MVC   CMDTEXT(*-*),0(R15) <<EXECUTED>>\n         EX    R14,*-6             MOVE TSO COMMAND IN BUFFER\nTSOSCAN  XC    CMDOFF,CMDOFF       CLEAR OFFSET TO SECOND OPERAND\n         DROP  R1\n         ST    R1,CPPLCBUF         SET BUFFER CB POINTER\n         LA    R1,TSOCSPL          ADDRESS OF IKJSCAN PARM LIST\n         USING CSPL,R1\n         MVC   CSPLUPT,DAPLUPT     COPY UPT POINTER\n         MVC   CSPLECT,DAPLECT     COPY ECT POINTER\n         LA    R15,TSOXECB         ADDRESSS OF ECB\n         ST    R15,CSPLECB\n         XC    TSOXECB,TSOXECB     CLEAR ECB\n         LA    R15,TSOXTCB         ADDRESSS OF FLAGS\n         ST    R15,CSPLFLG\n         XC    TSOXTCB,TSOXTCB     CLEAR FLAGS\n         LA    R15,TSOCSOA         ADDRESSS OF OUTPUT AREA\n         ST    R15,CSPLOA\n         XC    TSOCSOA(8),TSOCSOA  CLEAR OUTPUT AREA\n         MVC   CSPLCBUF,CPPLCBUF   COPY COMMAND BUFFER POINTER\n         DROP  R1\n         CALLTSSR EP=IKJSCAN       SCAN INPUT BUFFER\n         XC    TSOXECB,TSOXECB     CLEAR ECB\n         LA    R1,TSOCSOA          POINT TO OUTPUT AREA\n         USING CSOA,R1\n         L     R14,CSOACNM         POINTER TO COMMAND NAME\n         ICM   R15,B'0011',CSOALNM LENGTH OF NAME\n         BZ    TSONCMD             NONE, SKIP REST\n         TM    CSOAFLG,CSOAQM+CSOANOC   Q.M. OR NO CMD?\n         BNZ   TSONCMD             YES, SKIP REST\n         BCTR  R15,0\n         MVC   TSOBLNM,QBLANK      FILL WITH BLANKS\n         B     *+L'*+6\n         MVC   TSOBLNM(*-*),0(R14) <<EXECUTED>>\n         EX    R15,*-6             MOVE COMMAND TO BLDL NAME\n         TM    CSOAFLG,CSOABAD     BAD CMD NAME?\n         BZ    TSOTX               NO\n         ICM   R0,B'0111',=CL3'BAD'\n         B     TSODIAG\nTSOTX    CLC   TSOBLNM(2),=CL2'EX' EXEC COMMAND?\n         BNE   TSOTVLD             NO\n         TM    CSOAFLG,CSOAEXEC    IMPLICIT EXEC CMD NAME?\n         BZ    TSOINVC             NO, INVALID\nTSOTVLD  TM    CSOAFLG,CSOAVWP+CSOAVNP  VALID COMMAND?\n         BNZ   TSOGCMD             YES\n         DROP  R1\nTSOINVC  ICM   R0,B'0111',=CL3'INV'\nTSODIAG  MVC   TSOMSG(L'TC#DG),TC#DG    SEND DIAGNOSE\n         STCM  R0,B'0111',TSOMSG+TC#DGER\n         MVC   TSOMSG+L'TC#DG(L'TSOMSG-L'TC#DG),QBLANK\n         L     R1,CPPLCBUF         POINT TO BUFFER\n         USING CMDBUF,R1\n         LH    R15,CMDLEN          LENGTH\n         SH    R15,=H'4'\n         CH    R15,=Y(L'TSOMSG-L'TC#DG)\n         BNH   *+L'*+4\n         LH    R15,=Y(L'TSOMSG-L'TC#DG)\n         BCT   R15,*+L'*+6\n         MVC   TSOMSG+L'TC#DG(*-*),CMDTEXT   <<EXECUTED>>\n         EX    R15,*-6\n         DROP  R1\n         CLC   TSOMSG+L'TSOMSG-5(5),=CL5' '\n         BE    *+L'*+6\n         MVC   TSOMSG+L'TSOMSG-5(5),=CL5' ... '\n         LA    R1,TSOMSG\n         LA    R0,L'TSOMSG\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         B     TSONCMD             SKIP REST\nTSOGCMD  TM    QTSSW,FLTSO         FULL DISPLAY REQUESTED?\n         BZ    TSOISPF             NO\n         MVC   TSOMSG(L'TC#MSGH),TC#MSGH     SEND COMMAND IMAGE\n         MVC   TSOMSG+16(6),=CL6'BUFFER'\n         MVC   TSOMSG+L'TC#MSGH(L'TSOMSG-L'TC#MSGH),QBLANK\n         L     R1,CPPLCBUF         POINT TO BUFFER\n         USING CMDBUF,R1\n         LH    R15,CMDLEN          LENGTH\n         SH    R15,=H'4'\n         CH    R15,=Y(L'TSOMSG-L'TC#MSGH)\n         BNH   *+L'*+4\n         LH    R15,=Y(L'TSOMSG-L'TC#MSGH)\n         BCT   R15,*+L'*+6\n         MVC   TSOMSG+L'TC#MSGH(*-*),CMDTEXT <<EXECUTED>>\n         EX    R15,*-6\n         DROP  R1\n         CLC   TSOMSG+L'TSOMSG-5(5),=CL5' '\n         BE    *+L'*+6\n         MVC   TSOMSG+L'TSOMSG-5(5),=CL5' ... '\n         LA    R1,TSOMSG\n         LA    R0,L'TSOMSG\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         SPACE 1\n*---     WHEN RUNNING UNDER ISPF, THE FIRST TIME AN 'END' OR\n*---     'TSO END' (QED) CLIST'S FINAL COMMAND IS ENCOUNTERED,\n*---     IT WILL BE INTERCEPTED, AND TWO ADDITIONAL COMMANDS\n*---     ('TERMINAL ...' AND 'ISPEXEC ...') ARE PLACED IN THE\n*---     INTERNAL STACK. HERE WE SUPPRESS ALL 'END' OR 'TSO END'\n*---     COMMANDS WITHOUT ANY TROUBLES FOR THE CLIST EXECUTION,\n*---     BUT SO ELIMINATE UNDESIRABLE FAILURE MESSAGES.\n*---     NOTE - THIS DOES'NT ALLOW ISPF COMMANDS RUN, IN FACT,\n*---            AS SOON AS ONE IS DETECTED THE COMMAND (AND\n*---            CLIST) IS ABORTED, UNLESS IT IS A VGET/VPUT, IN\n*---            WHICH CASE THE COMMAND IS SKIPPED (GET A CHANCE\n*---            TO TRY ISPF PROCEDURE CONTINUE, BECAUSE IT MAY\n*---            BE JUST TO OBTAIN PANELS VALUES AND THUS WILL\n*---            NOT DISTURB THE TSO PROCEDURE NORMAL EXECUTION).\n         SPACE 1\nTSOISPF  L     R1,CPPLCBUF         POINT TO BUFFER\n         USING CMDBUF,R1\n         LA    R15,CMDTEXT         POINT TO COMMAND TEXT\n         LH    R14,CMDLEN          LENGTH\n         SH    R14,=H'4'\n         LA    R14,CMDTEXT-1(R14)  POINT TO COMMAND TEXT END\n         DROP  R1\nTSOISPF1 CLI   0(R15),C' '         ANALYZE\n         BNE   TSOISPF2\n         LA    R15,1(R15)\n         B     TSOISPF1\nTSOISPF2 CLC   0(4,R15),=CL4'END ' END COMMAND?\n         BE    TSONCMD             YES, SKIP IT\n         CLC   0(4,R15),=CL4'TSO ' TSO COMMAND (QED FORM)?\n         BNE   TSOISPF3            NO\n         LA    R15,4(R15)\n         B     TSOISPF1\nTSOISPF3 CLC   0(3,R15),=CL3'ISP'  ISPF FUNCTION?\n         BNE   TSOANAL             NO\n         CLC   0(8,R15),=CL8'ISPEXEC '  IS IT ISPEXEC?\n         BNE   TSOISPF6            NO\n         LA    R15,8(R15)\nTSOISPF4 CLI   0(R15),C' '         LOOK FURTHER\n         BNE   TSOISPF5\n         CLR   R15,R14\n         BNL   TSOISPF6\n         LA    R15,1(R15)\n         B     TSOISPF4\nTSOISPF5 CLC   0(5,R15),=CL5'VGET '     IS IT VGET?\n         BE    TSONCMD             YES, TRY TO CONTINUE (SKIP IT)\n         CLC   0(5,R15),=CL5'VPUT '     IS IT VPUT?\n         BE    TSONCMD             YES, TRY TO CONTINUE (SKIP IT)\nTSOISPF6 LA    R1,TC#ISPF\n         LA    R0,L'TC#ISPF\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         OI    QTSSW,CLSTP         STOP PROCESSING\n         B     TSONCMD             SKIP REST\n         SPACE 1\nTSOANAL  TM    QTSSW,CLTSO         IS IT A CLIST?\n         BO    TSOCLST             YES\n         CLC   TSOBLNM(2),=CL2'EX' IMPLICIT EXEC OF CLIST?\n         BNE   TSONEX              NO\nTSOCLST  NI    QTSSW,255-CLTSO\nTSOSEX   OI    QTSSW,CLSTX         CLIST IN EXECUTION\n         MVC   TSOBLNM,=CL8'EXEC'  SET MODULE NAME TO ATTACH\n         L     R1,CPPLCBUF         POINT TO BUFFER\n         USING CMDBUF,R1\n         XC    CMDOFF,CMDOFF       CLEAR OFFSET FOR EXEC\n         B     TSOATTCH            GO DO IT\n         DROP  R1\nTSONEX   MVC   TSOBLFF,=H'1'       ONE ENTRY IN LIST\n         MVC   TSOBLLL,=H'12'      12 BYTES TO BE RETURNED\n         XC    TSOBLTTR(L'TSOBLTTR+L'TSOBLLK),TSOBLTTR CLEAR REST\n         BLDL  0,TSOBLDL           CHECK FOR MODULE PRESENT\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   TSOSEX              NONE, MUST BE CLIST\nTSOATTCH XC    TSOXECB,TSOXECB     CLEAR ECB\n         MVC   ECTPCMD,TSOBLNM     FAKE PRIMARY COMMAND NAME\n         MVC   ECTSCMD,QBLANK      AND SECONDARY COMMAND NAME\n         LA    R1,TSOCPPL          ADDRESS OF CPPL\n         LA    R2,TSOXECB          ADDRESSS OF ECB\n         LA    R3,TSOBLNM          ADDRESSS OF COMMAND NAME\n         LA    R15,ATTCH           ADDRESSS OF ATTACH BLOCK\n         ATTACH EPLOC=(R3),ECB=(R2),SF=(E,(15)),MF=(E,(1))\n         ST    R1,TSOXTCB          SAVE TCB ADDRESS\n         WAIT  ECB=(R2)            WAIT FOR SUBTASK COMPLETION\n         LA    R1,TSOXTCB          GET TCB ADDRESS\n         DETACH (1)\n         OC    TSOXECB+1(3),TSOXECB+1   ANY COMPLETION CODE?\n         BZ    TSONCMD             NO\n         TM    QTSSW,RCTSO         DISPLAY RC REQUESTED?\n         BZ    TSONCMD             NO\n         MVC   TSOMSG(L'TC#MSG),TC#MSG  SEND COMPLETION MESSAGE\n         MVC   TSOMSG+25(8),TSOBLNM     GET COMMAND NAME\n         UNPK  QNUMWORK(5),TSOXECB+1(3) GET SYSTEM CODE\n         TR    QNUMWORK(3),HEXTAB-C'0'\n         MVC   TSOMSG+36(3),QNUMWORK\n         NI    TSOXECB+2,X'0F'     GET USER CODE\n         LH    R1,TSOXECB+2\n         CVD   R1,QNUMWORK\n         UNPK  TSOMSG+41(4),QNUMWORK+5(3)\n         OI    TSOMSG+44,C'0'\n         LA    R1,TSOMSG\n         LA    R0,L'TC#MSG\n         TPUT  (1),(0),R           ISSUE MESSAGE\nTSONCMD  TM    QTSSW,CLSTX         CLIST IN EXECUTION?\n         BZ    TSODONE             NO, DONE\n         ICM   R1,B'1111',GTPBIBUF GETLINE BUFFER?\n         BZ    TSOGSTK             NO, SKIP\n         USING CMDBUF,R1\n         LH    R0,CMDLEN           LENGTH OF BUFFER\n         DROP  R1\n         ICM   R0,B'1000',=AL1(1)  SUBPOOL 1\n         FREEMAIN R,LV=(0),A=(1)   FREE THE BUFFER\nTSOGSTK  XC    TSOXECB,TSOXECB     CLEAR ECB\n         LA    R1,TSOIOPL          GETLINE I/O PARM LIST\n         L     R2,CPPLUPT          ADDRESS OF UPT\n         LA    R3,TSOXECB          ADDRESSS OF ECB\n         GETLINE PARM=(R6),UPT=(R2),ECT=(R5),ECB=(R3),MF=(E,(1))\n         CH    R15,=H'16'          END OF INPUT (STACK-CLIST)?\n         BE    TSODONE             YES, DONE\n         TM    QXSWXQ,RQTR         TRACE REQUESTED?\n         BZ    TSOSKIP             NO\n         OI    QXSWXQ,NFTR+MSTR\n         XC    TSORSV(2*4),TSORSV\n         QCALL TRACE,2             SNAP. USER CODE 002. -------- ID-002\n         BZ    *+L'*+4\n         STM   R0,R1,TSORSV\n         NI    QXSWXQ,255-NFTR-MSTR\nTSOSKIP  TM    QTSSW,CLSTP         PROCESS STOP?\n         BO    TSONCMD             YES, GO SKIP\n         L     R1,GTPBIBUF         POINT TO INPUT BUFFER\n         B     TSOSCAN             GO PROCESS NEXT\nTSODONE  MVC   ECTPCMD,TSOPCMD     RESTORE PRIMARY COMMAND NAME\n         MVC   ECTSCMD,TSOSCMD     AND SECONDARY COMMAND NAME\n         DROP  R4,R5,R6\n         SPACE 1\n*---     TELL VTAM WE'RE BACK                                      ---*\n         SPACE 1\n         STFSMODE  ON\n         OC    TSORSV(2*4),TSORSV  ANY MESSAGE PENDING?\n         BNZ   TSOSMSG             YES\n         QTILT '=== DONE ==='\nTSOSMSG  LM    R0,R1,TSORSV\n         XC    TSORSV(2*4),TSORSV\n         QTILT\n         SPACE 1\nGTPBL    GETLINE MF=L\nATTCHL   ATTACH  SHSPV=78,SF=L     NEEDED TO PREVENT S305 ABENDS\n         SPACE 1\nTC#CLEAR $FS   WCC=(RMDT),SBA=(24,79),MF=L\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SF=IC,MF=L\nTC#CLL   EQU   *-TC#CLEAR\nTC#MSG   DC    C'   ---> COMMAND FAILED :          (S   /U    ).'\nTC#MSGH  EQU   TC#MSG,25\nTC#DG    DC    C'   ===>     COMMAND : '\nTC#DGER  EQU   8\nTC#KILLS DC    C'COMMAND REJECTED - \"'\nTC#KILLE DC    C'\" COMMAND NOT ACCEPTED UNDER QSP.        '\nTC#ISPF  DC    C'SORRY, ISPF NOT SUPPORTED - IMMEDIATE STOP.'\nTC#TCMD  DS    0CL8                MUST BE IN ALPHABETICAL ORDER\n         DC    CL8'ACCOUNT'\n         DC    CL8'AUTHC'\n         DC    CL8'CALL'\n         DC    CL8'E'\n         DC    CL8'EDIT'\n         DC    CL8'ISPF'\n         DC    CL8'OPER'\n         DC    CL8'PDF'\n         DC    CL8'POF'\n         DC    CL8'PUSE'\n         DC    CL8'QED'\n         DC    CL8'QSP'\n         DC    CL8'SCHED'\n         DC    CL8'SCHEDULE'\n         DC    CL8'TEST'\n         DC    CL8'TIME'\n         DC    CL8'VCOREZAP'\n         DC    CL8'VSM'\n         DC    CL8'ZAP'\n         DC    XL1'FF'             END OF TABLE INDICATOR\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9,R10,R11,R12\n         TITLE '--- QUEUE/SP -- XQ -- DISPLAY ALL JQES QUEUES ---'\nXQCMD    QSTART\n         CLI   QPARM1,C' '         SPECIFIC REQUEST?\n         BE    XQ$QL0              NO\n         CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?\n         BL    XQ$QF0              NO, ASSUME JOB NAME\n         LH    R1,QLNG1            LENGTH OF PARAMETER FIELD\n         SH    R1,=H'1'            IS THE LENGTH ZERO?\n         BM    XQ$TILT1            YES, TILT\n         LA    R15,QPARM1          POINT TO PARM\n         BAS   R14,QNUMCONV        CONVERT IT\n         BNE   XQ$TILT2            TILT IF NOT NUMERIC\n         LR    R6,R15              SAVE THE VALUE\n         B     XQ$QF0\nXQ$TILT1 QTILT '*** MISSING JOB NUMBER ***'\nXQ$TILT2 QTILT '*** INVALID JOB NUMBER ***'\nXQ$QL0   L     R1,QVDSPL           @ DISPLAY WORK AREA\n         USING QDISPLAY,R1\n         MVC   QDHLINE,XQHEAD\n         DROP  R1\nXQ$QF0   L     R3,QCJQHEAD         @ JQE'S QUEUES HEADS\n         LA    R2,$JQTYPES         # OF JQE QUEUE HEADS\nXQ$QL1   LR    R4,R3               COPY @ CURRENT QUEUE HEAD\n         SH    R4,=Y(JQENEXT-JQE)  MAKE LOOK LIKE JQE\n         XR    R5,R5               INIT QUEUE POSITION ZERO\nXQ$QL2   BAS   R14,NXT$JQE         TO NEXT JQE\n         BZ    XQ$NQ               BRANCH IF NO NEXT JQE\n         USING JQE,R4\n         CLI   QPARM1,C' '         SPECIFIC REQUEST?\n         BE    XQ$QL3              NO\n         CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?\n         BL    XQ$QF1              NO, ASSUME JOB NAME\n         CH    R6,JQEJOBNO         IS THIS THE RIGHT JOB NUMBER?\n         B     XQ$QF1+L'XQ$QF1\nXQ$QF1   CLC   QPARM1(8),JQEJNAME  IS THE JOB NAME EQUAL?\n         BNE   XQ$QL2              NO, SKIP THIS\n         XR    R1,R1               INDICATE THIS IS A JQE\n         LR    R9,R4               SET R9\n         QCALL FORMAT              PRINT THE JQE IN R9\n         B     XQ$QL2\nXQ$QL3   MVC   XQLINE,QBLANK\n         CVD   R5,XQDWD\n         MVC   XQLINE(4),=XL4'40202120'\n         ED    XQLINE(4),XQDWD+6\n         BAS   R14,CVQP$\n         STCM  R1,15,XQLINE+6\n         ST    R0,XQDWD\n         MVI   XQDWD+4,X'04'\n         UNPK  XQLINE+30(9),XQDWD(5)\n         TR    XQLINE+30(8),HEXTAB-X'F0'\n         MVC   XQLINE+13(8),JQEJNAME\n         LH    R0,JQEJOBNO\n         CVD   R0,XQDWD\n         MVC   XQLINE+22(6),=XL6'402020202120'\n         ED    XQLINE+22(6),XQDWD+5\n         DROP  R4                  (JQE DSECT)\n         QCALL DISPLAY,XQLINE,L'XQLINE\n         B     XQ$QL2\nXQ$NQ    LA    R3,4(,R3)           @ NEXT JQE QUEUE HEAD\n         BCT   R2,XQ$QL1           BRANCH IF MORE QUEUES TO DO\n         QSTOP\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        NXT$JQE - CONTINUE 'JQENEXT' SEARCH                          *\n*                                                                     *\n*        ENTRY : R4  - @ PREVIOUS JQE (ONLY JQENEXT FIELD IS VALID)   *\n*                R5  - JQE CHAIN POSITION                             *\n*                R14 - RETURN ADDRESS                                 *\n*                                                                     *\n*        EXIT : CONDITION CODE SET -  0 - NO MORE JQE'S EXIST         *\n*                                         (R4 = 0)                    *\n*                                    \u00ac0 - R4 = @ JQE                  *\n*                                         (R5 INCREMENTED)            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\n         USING JQE,R4\nNXT$JQE  L     R4,JQENEXT          VALUE FROM JQENEXT\n         N     R4,=A(X'00FFFFFF')  IS ZERO IF NO NEXT JQE\n         BZR   R14                 BRANCH IF NO NEXT JQE, CC 0, R4 = 0\n         AL    R4,QCJQEWA          ADD BASE TO OFFSET\n         LA    R5,1(,R5)           INCREMENT QUEUE POSITION\n         BR    R14                 BRANCH IF JQE, CC \u00ac0, R4 = @ JQE\n         DROP  R4\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CVQP$ - CONVERT JQEHEAD ADDRESS TO CHARACTER QUEUE ID        *\n*                                                                     *\n*        ENTRY : R3  - @ JQE QUEUE HEAD (IN MASTER RECORD)            *\n*                R14 - RETURN ADDRESS                                 *\n*                                                                     *\n*        EXIT :  R0  - $QINDEX                                        *\n*                R1  - 4 CHARACTER QUEUE ID                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nCVQP$    LA    R1,$JQHEADL(,R3)    OFFSET FOR $QINDEX\n         S     R1,QCJQHEAD         SIMILAR LOOK UP\n         LR    R0,R1               SET $QINDEX VALUE TO RETURN IT\n         CH    R1,=Y(44)           SPECIAL QUEUE? (< QUEUE 'A')\n         BL    CVQP$2              BRANCH IF SPECIAL ID\n         SRL   R1,2                QUEUE HEAD NUMBER\n         IC    R1,CVQP#TB1-(44/4)(R1)   GET QUEUE ID\n         SLL   R1,24               ALIGN QUEUE ID\n         ICM   R1,B'0111',QBLANK   AND BLANK REST\n         BR    R14\nCVQP$2   L     R1,CVQP#TB2(R1)     GET SPECIAL ID\n         BR    R14                 BRANCH IF WITH ID\n         SPACE 1\n*        NOTE - SEE $QINDEX IN HASPTABS FOR MORE DETAILS.\n         SPACE 1\nXQHEAD   DC    CL79' POS  QUEUE  JNAME     JOBNO  $QINDEX  '\n         SPACE 1\nCVQP#TB1 DC    0F'0',64AL1(0)      DEFAULT ALL UNKNOWN\n         ORG   CVQP#TB1\n         DC    C'ABCDEFGHI'             A - I\n         DC    C'JKLMNOPQR'             J - R\n         DC    C'STUVWXYZ'              S - Z\n         DC    C'0123456789'            0 - 9\n         ORG\n         SPACE 1\nCVQP#TB2 DC    0F'0'\n         DC    CL4'FREE'            0 - FREE\n         DC    CL4'PURG'            1 - PURGE\n         DC    CL4'HCPY'            2 - HARDCPY\n         DC    CL4'OUT '            3 - OUTPUT\n         DC    CL4'REC '            4 - RECEIVE\n         DC    CL4'SETU'            5 - SETUP\n         DC    CL4'XMIT'            6 - XMIT\n         DC    CL4'IN  '            7 - INPUT\n         DC    CL4'XEQ '            8 - XEQ\n         DC    CL4'STC '            9 - STC\n         DC    CL4'TSU '           10 - TSU\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R11,R12\n         TITLE '--- QUEUE/SP -- XO -- DISPLAY/DUMP JOES ---'\nXOCMD    QSTART\n         USING JOE,R8\n         USING JQE,R9\n         CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?\n         BL    XO$QL0              NO, ASSUME JOB NAME\n         LH    R1,QLNG1            LENGTH OF PARAMETER FIELD\n         SH    R1,=H'1'            IS THE LENGTH ZERO?\n         BM    XO$TILT1            YES, TILT\n         LA    R15,QPARM1          POINT TO PARM\n         BAS   R14,QNUMCONV        CONVERT IT\n         BNE   XO$TILT2            TILT IF NOT NUMERIC\n         LR    R5,R15              SAVE THE VALUE\n         B     XO$QL1\nXO$QL0   CLI   QPARM1,C' '         DID USER SPECIFY JOB NAME?\n         BNE   XO$QL1              YES\n         QTILT '*** YOU MUST SPECIFY JOB NAME ***'\nXO$TILT1 QTILT '*** MISSING JOB NUMBER ***'\nXO$TILT2 QTILT '*** INVALID JOB NUMBER ***'\nXO$QL1   BAS   R2,XO$TJOT          SEARCH ALL OUTPUT CLASSES\n         B     XO$QL3\nXO$QL2   BAS   R2,XO$NJOT          DETERMINE NEXT QUEUE\nXO$QL3   BAS   R2,XO$SJOE          SEARCH A JOE QUEUE\n         B     XO$QL2              END OF QUEUE\n         CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?\n         BL    *+L'*+8             NO\n         CH    R5,JQEJOBNO         IS THIS THE RIGHT JOB NUMBER?\n         B     *+L'*+6\n         CLC   QPARM1(8),JQEJNAME  IS THE JOB NAME EQUAL?\n         BNE   XO$KJOE             NO, SKIP THIS RECORD\n         B     XO$PJOE             PRINT THE RECORD\nXO$STOP  QSTOP\n         SPACE 1\n*---     DETERMINE OUTPUT QUEUE                                    ---*\n         SPACE 1\nXO$TJOT  XR    R4,R4               SEARCH ALL OUTPUT CLASSES\n         STH   R4,QCLASSH\n         B     XO$CJOT\nXO$NJOT  LA    R4,1\n         AH    R4,QCLASSH\n         STH   R4,QCLASSH\nXO$CJOT  CH    R4,=Y(1+(2*36))     IS THIS THE LAST QUEUE?\n         BNL   XO$STOP             YES, GO HOME\n         SLL   R4,2                * 4 FOR OFFSET\n         USING JOT,R1              BASE REG FOR JOT\n         L     R1,QCJOTWA          LOAD ADDR OF JOT\n         LA    R4,JOTRDYWQ(R4)     NEXT QUEUE\n         DROP  R1\n         BR    R2                  RETURN TO CALLER\n         SPACE 1\n*---     SEARCH A JOE QUEUE                                        ---*\n         SPACE 1\nXO$SJOE  L     R8,0(R4)            LOAD FIRST JOE OFFSET\nXO$NJOE  N     R8,=A(X'00FFFFFF')  END OF QUEUE?\n         BZR   R2                  YES, RETURN TO CALLER\n         AL    R8,QCJOTWA          ADD BASE TO OFFSET\n         L     R9,JOEJQE           OFFSET TO JQE\n         N     R9,=A(X'00FFFFFF')  ANY POINTER?\n         BZ    XO$KJOE             BRANCH IF NO JQE\n         AL    R9,QCJQEWA          ADD BASE TO OFFSET\n         B     4(R2)               DETERMINE ELIGIBILITY\nXO$PJOE  LA    R1,4                INDICATE THIS IS A JOE\n         QCALL FORMAT              PRINT THE JOE IN R8\nXO$KJOE  L     R8,JOENEXT          ADDR OF NEXT JOE\n         B     XO$NJOE             TRY NEXT JOE\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R8,R9,R11,R12\n         TITLE '--- QUEUE/SP -- AUTOM -- AUTOMATIC MODE CONTROL ---'\nAUTOM    QSTART\n         L     R10,QVDSPL          @ DISPLAY WORK AREA\n         USING QDISPLAY,R10\n         L     R9,QVSNAP           @ SNAP WORK AREA\n         USING QSNAP,R9\n         CLI   QXAUTH,LV12         IS THIS AN AUTHORIZED USER?\n         BNL   AUTEST              YES, PROCESS IT\n         QTILT '=== NOT AVAILABLE TO YOU, SORRY ==='\nAUTEST   TM    QDOVER,QDAMAGE      DAMAGED CLOCKS?\n         BZ    AUTRT               NO\n         NI    SNAPIDT,B'10111111' OFF TRACE ID 1\n         OC    SNAPIDT,SNAPIDT     ANY OTHER ONE ACTIVE?\n         BNZ   *+L'*+4             YES\n         NI    QXSWXQ,255-RQTR     OFF TRACE REQUEST\n         CLC   QPARM1(6),=CL6'SRMCC'    SRM CC ERROR?\n         BE    AUTSRM              YES\n         QTILT '=== DISABLED FOR DAMAGED CLOCKS ==='\nAUTSRM   MVC   QDMSG(L'AUT$SRM),AUT$SRM\n         MVC   QDMSG+L'AUT$SRM-6(1),QPARM1+6\n         LA    R1,QDMSG\n         LA    R0,L'AUT$SRM\n         QTILT\nAUTRT    CLI   QCODE,0             SET MODE ON REQUEST?\n         BE    AUTON               YES\n         NI    QDOVER,255-QAUTOM   OFF AUTOMATIC MODE\n         NI    SNAPIDT,B'10111111' OFF TRACE ID 1\n         OC    SNAPIDT,SNAPIDT     ANY OTHER ONE ACTIVE?\n         BNZ   *+L'*+4             YES\n         NI    QXSWXQ,255-RQTR     OFF TRACE REQUEST\n         QTILT '=== AUTOMATIC MODE OFF ==='\nAUTON    LH    R1,QLNG1            LENGTH OF PARAMETER FIELD\n         SH    R1,=H'1'            IS THE LENGTH ZERO?\n         BM    AUTDEF              YES, SET DEFAULT\n         LA    R15,QPARM1          POINT TO PARM\n         BAS   R14,QNUMCONV        CONVERT IT\n         BNE   AUDBGT              MAY BE BEBUG IF NOT NUMERIC\n         C     R15,=A(5*60)        MORE THAN 5 MINUTES?\n         BH    AUTILT              YES, TOO MUCH\n         MH    R15,=H'100'\n         B     AUTSET\nAUDBGT   CLI   QPARM1,C'T'         IS TEST MODE REQUEST?\n         BNE   AUTILT              TILT IF NOT\n         CLI   QXAUTH,LV15         IS THIS AN AUTHORIZED USER?\n         BL    AUTDEF              NO, BYPASS TRACE\n         TM    QXSWXQ,SKTR         TRACE FILE IN ERROR?\n         BO    AUTDEF              IGNORE\n         OI    SNAPIDT,B'01000000' ON TRACE ID 1\n         OI    QXSWXQ,RQTR         ON TRACE\n         B     AUTDEF              AND SET DEFAULT\nAUTILT   QTILT '*** INVALID INTERVAL TIME ***'\nAUTDEF   L     R15,=A(TDFLT)       SET DEFAULT\nAUTSET   ST    R15,TIMECT\n         LH    R1,QLNG2            LENGTH OF PARAMETER FIELD\n         SH    R1,=H'1'            IS THE LENGTH ZERO?\n         BM    AUTOK               YES, SKIP\n         CLI   QPARM2,C'T'         IS TEST MODE REQUEST?\n         BNE   AUTOK               IGNORE IF NOT\n         CLI   QXAUTH,LV15         IS THIS AN AUTHORIZED USER?\n         BL    AUTOK               NO, BYPASS TRACE\n         TM    QXSWXQ,SKTR         TRACE FILE IN ERROR?\n         BO    AUTOK               IGNORE\n         OI    SNAPIDT,B'01000000' ON TRACE ID 1\n         OI    QXSWXQ,RQTR         ON TRACE\nAUTOK    OI    QDOVER,QAUTOM       ON AUTOMATIC MODE\n         QTILT '=== AUTOMATIC MODE ON ==='\nAUT$SRM  DC    C'=== DISABLED FOR SRM CC (ERROR  ) ==='\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9,R10,R11,R12\n         TITLE '--- QUEUE/SP -- SETTR -- TRACE FACILITIES ---'\nSETTR    QSTART\n         L     R10,QVDSPL          @ DISPLAY WORK AREA\n         USING QDISPLAY,R10\n         L     R9,QVSNAP           @ SNAP WORK AREA\n         USING QSNAP,R9\n         CLI   QXAUTH,LV12         IS THIS AN AUTHORIZED USER?\n         BNL   SETTR1              YES, PROCESS IT\nSETTR0   QTILT '=== NOT AVAILABLE TO YOU, SORRY ==='\nSETTR1   CLI   QPARM1,C'I'         INITIALIZE TRACE STATUS?\n         BE    SETTR20             YES\n         TM    QXSWXQ,SKTR         TRACE FILE IN ERROR?\n         BO    SETTR10             YES\n         CLI   QPARM1,C'S'         STOP ALL ID'S REQUEST?\n         BNE   SETTR2              NO\n         XC    SNAPIDT,SNAPIDT     RESET ALL\n         NI    QXSWXQ,255-RQTR     OFF TRACE REQUEST\n         QTILT '=== ALL TRACE ID''S OFF ==='\nSETTR2   LH    R1,QLNG1            LENGTH OF PARAMETER FIELD\n         SH    R1,=H'1'            IS THE LENGTH ZERO?\n         BM    SETTR4              YES, SET DEFAULT\n         LA    R15,QPARM1          POINT TO PARM\n         BAS   R14,QNUMCONV        CONVERT IT\n         BNE   SETTR3              NOT NUMERIC\n         CH    R15,=H'1'           VALID ID-NUMBER?\n         BL    SETTR3              NO\n         CH    R15,=H'255'\n         BNH   SETTR5              NO\nSETTR3   QTILT '=== INVALID TRACE ID-NUMBER ==='\nSETTR4   LH    R15,=H'1'           SET DEFAULT ID=1\nSETTR5   XR    R14,R14\n         SLDL  R14,24\n         SRL   R15,24\n         LA    R2,SNAPIDT\n         ALR   R2,R14\n         LA    R3,X'80'\n         SRL   R3,0(R15)\n         XR    R4,R4\n         BCTR  R4,0\n         XR    R4,R3\n         CLC   QPARM2(3),=CL3'ON ' SET ACTIVE?\n         BNE   SETTR6              NO\n         EX    R3,SETTRS           YES, SET IT\n         OI    QXSWXQ,RQTR         ON TRACE\n         QTILT '=== REQUESTED TRACE ID ON ==='\nSETTRS   OI    0(R2),*-*           <<EXECUTED>>\nSETTR6   CLI   QPARM2,C' '         DEFAULT OFF?\n         BE    SETTR7              YES\n         CLC   QPARM2(4),=CL4'OFF '     SET INACTIVE?\n         BNE   SETTR8              NO\nSETTR7   EX    R4,SETTRC           YES, RESET IT\n         OC    SNAPIDT,SNAPIDT     ANY OTHER ONE ACTIVE?\n         BNZ   *+L'*+4             YES\n         NI    QXSWXQ,255-RQTR     OFF TRACE REQUEST\n         QTILT '=== REQUESTED TRACE ID OFF ==='\nSETTRC   NI    0(R2),*-*           <<EXECUTED>>\nSETTR8   QTILT '=== INVALID TRACE REQUEST (ON/OFF) ==='\nSETTR10  QTILT '=== TRACE DISABLED DUE TO ERROR ==='\nSETTR20  CLI   QXAUTH,LV15         IS THIS AN AUTHORIZED USER?\n         BL    SETTR0              NO, REJECT IT\n         TM    QXSWXQ,SKTR         TRACE FILE IN ERROR?\n         BZ    SETTR21             NO\n         MVI   QXSWXQ,0            RESET TRACE STATUS\n         LR    R0,R9\n         L     R1,=A(QSNAPL)\n         L     R14,=A(QSNAP)\n         LR    R15,R1\n         MVCL  R0,R14\n         QTILT '=== TRACE STATUS RE-INITIALIZED ==='\nSETTR21  QTILT '=== TRACE IS STILL ENABLE ==='\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9,R10,R11,R12\n TITLE '--- QUEUE/SP -- HEXBLK -- HEXADECIMAL DUMP OF A BLOCK ---'\nHEXBLK   QSTART\n         USING QCKPT,R10           BASE REG FOR CKPT WORK AREA\n         L     R10,QVCKPT          LOAD BASE REG\n         USING QDISPLAY,R9         BASE REG FOR DISPLAY WORK AREA\n         L     R9,QVDSPL           LOAD BASE REG\n         CLI   QCODE,0             IS IT THE 'XB' COMMAND?\n         BE    HEXBLKD             YES\n         CLC   QPARM1(3),=CL3'ON ' SET ACTIVE?\n         BE    HEXBLK2             YES\n         CLC   QPARM1(4),=CL4'OFF '     SET INACTIVE?\n         BE    HEXBLK1             YES\n         CLI   QPARM1,C' '         DEFAULT OFF?\n         BE    HEXBLK1             YES\n         QTILT '=== INVALID SET DUMP FORMAT (ON/OFF) ==='\nHEXBLK1  NI    QDFREQ,255-QDFEX    RESET TO NORMAL\n         QTILT '=== DUMP FORMAT RESET TO NORMAL ==='\nHEXBLK2  OI    QDFREQ,QDFEX        SET EXTENDED\n         QTILT '=== DUMP FORMAT SET TO EXTENDED ==='\n         SPACE 1\n*---     VALIDATE AND CONVERT BLOCK ADDRESS                        ---*\n         SPACE 1\nHEXBLKD  OI    QDFREQ,QDFRL        SET RELATIVE\n         LH    R15,QLNG1           LENGTH OF USER PARM\n         LTR   R15,R15             IS THE LENGTH ZERO?\n         BNP   HB$TILT             YES, TILT\n         CH    R15,=H'8'           IS THE LENGTH TOO BIG?\n         BH    HB$TILT             YES, TILT\n         LR    R14,R15             COPY THE LENGTH\n         BCTR  R14,0               -1 FOR EX\n         EX    R14,HB$TRT          ALL VALID CHARACTERS?\n         BNZ   HB$TILT             NO, ABORT\n         MVC   QNUMWORK,QPARM1     LEAVE THE ORIGINAL ALONE\n         TR    QNUMWORK,TABLEH     CONVERT TO HEX\n         EX    R15,HB$PACK         PACK INTO QCTRAK\n         SPACE 1\n*---     READ THE BLOCK FROM HASPACE                               ---*\n         SPACE 1\n         L     R3,QCBLKA           BLOCK IOAREA ADDR\n         LH    R1,HASPACE+(DCBBLKSI-IHADCB)  BLKSIZE FROM DCB\n         LR    R2,R1\n         BCTR  R1,0                SUBTRACT 1\n         N     R1,ROUND            ROUND TO PREV. 64 BYTE BOUNDARY\n         AR    R1,R3               ADD BASE OF BUFFER\n         MVC   0(64,R1),QBLANK     BLANK LAST 64 BYTES OF BUFFER\n         LR    R1,R3               PARM FOR READSPC\n         MVI   QSYNADFL,0          INIT FLAG\n         QCALL READSPC             READ HASPACE\n         CLI   QSYNADFL,0          WAS THERE AN ERROR?\n         BNE   HB$IOERR            YES, SAY SO\n         SPACE 1\n*---     LIST THE BLOCK                                            ---*\n         SPACE 1\n         MVC   QDHLINE,QBLANK      BLANK THE TITLE LINE\n         QCALL HEXDUMP             DUMP THE BLOCK\n         QSTOP\n         SPACE 1\n*---     SYNAD EXIT                                                ---*\n         SPACE 1\nHEXBLKER MVI   QSYNADFL,255        SET SYNAD FLAG\n         BR    R14                 RETURN TO READSPC VIA SYSTEM\n         SPACE 1\n*---     EXCEPTIONS AND RETURN                                     ---*\n         SPACE 1\nHB$TILT  QTILT '*** BLOCK ADDRESS WAS OMITTED OR INVALID ***'\nHB$IOERR CLI   QSYNADFL,255        REAL SYNAD ERROR?\n         BE    HB$SYNAD\n         QTILT '*** NOT IN HASPACE(S) EXTENT ***'\nHB$SYNAD QTILT '*** SYNAD ERROR ROUTINE ENTERED ***'\n         SPACE 1\nHB$PACK  PACK  QCTRAK(5),QNUMWORK(1)    BLOCK ADDRESS\nHB$TRT   TRT   QPARM1(*-*),TABLEV  << EXECUTED >>\nROUND    DC    0F'0',X'0000FFC0'\n         SPACE 1\n*---     TABLE FOR HEX CONVERT                                     ---*\n         SPACE 1\nTABLEH   DC    CL193' '\n         DC    X'0A0B0C0D0E0F',CL41' ',C'01234567890',CL6' '\n         SPACE 1\n*---     TABLE USED TO VERIFY HEX OPERAND                          ---*\n         SPACE 1\nTABLEV   DC    256X'FF'\n         ORG   TABLEV+C'A'\n         DC    6X'00'\n         ORG   TABLEV+C'0'\n         DC    10X'00'\n         ORG\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9,R10,R11,R12\n         TITLE '--- QUEUE/SP -- XT -- DISPLAY SOME BLOCKS ... ---'\nXTCMD    QSTART\n         L     R10,QVDSPL          @ DISPLAY WORK AREA\n         USING QDISPLAY,R10\n         CLI   QXAUTH,LV10         IS THIS AN AUTHORIZED USER?\n         BNL   XTCMD1              YES, PROCESS IT\n         QTILT '=== NOT AVAILABLE TO YOU, SORRY ==='\nXTCMD1   MVC   QDHLINE,QBLANK      BLANK THE TITLE LINE\n         MVC   FCLEAR,QBLANK       CLEAR THE PRINT AREA\n         NI    QDFREQ,255-QDFRL    SET NORMAL\n         L     R8,#TSCPPL          GET CPPL ADDRESS\n         LR    R3,R8\n         LA    R2,4*4\n         MVC   FHEXID(L'FHEXID),=CL5'CPPL'\n         QCALL HEXDUMP             DUMP CPPL\n         USING CPPL,R8\n         L     R3,CPPLCBUF         GET COMMAND BUFFER ADDRESS\n         LA    R2,84\n         MVC   FHEXID(L'FHEXID),=CL5'CBUF'\n         QCALL HEXDUMP             DUMP COMMAND BUFFER\n         L     R3,CPPLECT          GET ECT ADDRESS\n         LA    R2,12*4\n         MVC   FHEXID(L'FHEXID),=CL5'ECT'\n         QCALL HEXDUMP             DUMP ECT\n         LA    R3,QCODEH-2         GET PARSE ADDRESSES\n         LA    R2,68\n         MVC   FHEXID(L'FHEXID),=CL5'QOFF'\n         QCALL HEXDUMP             DUMP PARSE\n         LA    R3,QDRLNG           GET REPLY ADDRES\n         LA    R2,L'QDRLNG+QDREPLYL\n         MVC   FHEXID(L'FHEXID),=CL5'RPLY'\n         QCALL HEXDUMP             DUMP REPLY\n         LA    R3,SRMCC            GET SRMCC ADDRES\n         LA    R2,L'SRMCC\n         MVC   FHEXID(L'FHEXID),=CL5'SRMCC'\n         QCALL HEXDUMP             DUMP REPLY\n         QSTOP                     RETURN\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R10,R11,R12\n         TITLE '--- QUEUE/SP -- ID -- JES2 INITIATORS DISPLAY ---'\nIDCMD    QSTART\n         CLI   QXAUTH,LV12         AUTHORIZED USER?\n         BL    ID$TILTI            NO\n         SPACE 1\n*---     FIND THE ACTIVE MAIN SUBSYSTEM AND JES2 PITS              ---*\n         SPACE 1\n         L     R2,CVTPTR           POINT TO CVT\n         USING CVTMAP,R2\n         L     R1,CVTJESCT         POINT TO JESCT\n         DROP  R2\n         USING JESCT,R1\n         CLC   JESCTID,=CL4'JEST'\n         BNE   ID$TILTN\n         CLC   JESPJESN,=CL4'JES2'\n         BNE   ID$TILTN\n         L     R2,JESSSCT          POINT TO SSCT\n         DROP  R1\n         USING SSCT,R2\n         CLC   SSCTID,=CL4'SSCT'\n         BNE   ID$TILTN\n         CLC   SSCTSNAM,=CL4'JES2'\n         BNE   ID$TILTN\n         L     R1,SSCTSSVT         POINT TO SSVT\n         DROP  R2\n         USING SSVT,R1\n         ICM   R2,B'1111',SVTPIT   STARTING POINT OF PITS\n         BZ    ID$TILTN            IGNORE IF NO PITS\n         DROP  R1\n         SPACE 1\n*---     COLLECT ALL INFORMATION ABOUT PITS                        ---*\n         SPACE 1\n         L     R5,QCWA             USE WORK SPACE TO COLLECT\nIDI#     EQU   0,2                      PIT ID\nIDJ#     EQU   2,2                      JOB NUMBER\nIDJN     EQU   4,8                      JOB NAME\nIDST     EQU   12,1                     PIT STATUS\nIDCL     EQU   13,36                    PIT CLASSES\nIDLL     EQU   49                  LENGTH\n        $TSWXA 31,EXPAND=ONLY\n         USING PIT,R2\nIDLOOP   MVC   IDI#(,R5),PITPATID  GET PIT ID\n         MVC   IDST(,R5),PITSTAT   GET PIT STATUS\n         MVC   IDCL(,R5),PITCLASS  GET PIT CLASSES\n         XC    IDJ#(,R5),IDJ#(R5)\n         MVC   IDJN(L'IDJN,R5),QBLANK\n         ICM   R3,B'1111',PITSJB   POINT TO THE SJB\n         BZ    IDNXPIT             NONE\n         USING SJB,R3\n         CLC   SJBID,=CL4'SJB'\n         BNE   IDNXPIT\n         L     R4,SJBJQOFF\n         N     R4,=A(X'00FFFFFF')  OFFSET TO JQE\n         BZ    IDNXPIT\n         AL    R4,QCJQEWA          ADD BASE TO OFFSET\n         USING JQE,R4\n         CLC   JQEJNAME,SJBJOBNM   THIS JOB?\n         BNE   IDNXPIT             NO\n         MVC   IDJ#(,R5),JQEJOBNO  GET JOB NUMBER\n         MVC   IDJN(,R5),JQEJNAME  GET JOB NAME\n         DROP  R3,R4\nIDNXPIT  LA    R5,IDLL(R5)         BUMP TO COLLECT NEXT IF ANY\n         ICM   R2,B'1111',PITNEXT  POINT TO NEXT PIT\n         BNZ   IDLOOP              ANOTHER ONE\n         DROP  R2\n        $TSWXA 24,EXPAND=ONLY\n         LR    R4,R5               RETAIN END\n         SPACE 1\n*---     BUILD AND SEND THE MESSAGE(S) DESCRIBING THE PITS         ---*\n         SPACE 1\n         L     R5,QCWA             STARTING POINTER\n         L     R10,QVDSPL          @ DISPLAY WORK AREA\n         USING QDISPLAY,R10\n         MVC   QDHLINE,IDINHD      MOVE IN THE HEADING\nIDBMSG   MVC   QDMSG,QBLANK        BLANK THE LINE\n         MVC   IDIN#,IDI#(R5)      MOVE IN PIT ID\n         MVC   IDCLS,IDCL(R5)      SET CLASSES\n         TM    IDST(R5),PITHOLDA+PITHOLD1   TEST FOR DRAINED\n         BNZ   IDHPIT              YES\n         TM    IDST(R5),PITHALTA+PITHALT1   TEST FOR HALTED\n         BNZ   IDSPIT              YES\n         MVC   IDSTAT,=CL8'ACTIVE' SET STATUS\n         TM    IDST(R5),PITBUSY    TEST FOR BUSY\n         BO    IDAPIT              YES\n         MVC   IDSTAT,=CL8'INACTIVE'    SET STATUS\n         B     IDSEND\nIDHPIT   MVC   IDSTAT,=CL8'DRAINED'     SET STATUS\n         TM    IDST(R5),PITBUSY    TEST FOR BUSY\n         BZ    IDSEND              NO\n         MVC   IDSTAT+5(3),=C'ING' SET STATUS\n         B     IDAPIT\nIDSPIT   MVC   IDSTAT,=CL8'HALTED' SET STATUS\n         TM    IDST(R5),PITBUSY    TEST FOR BUSY\n         BZ    IDSEND              NO\n         MVC   IDSTAT+4(3),=C'ING' SET STATUS\nIDAPIT   CLI   IDJN(R5),C' '       JOBNAME?\n         BE    IDSEND              NONE\n         MVC   IDJOBNM,IDJN(R5)    MOVE IN JOBNAME\n         LA    R1,IDCLS+L'IDCLS-2\nIDFILL   CLC   0(2,R1),=CL2' '\n         BNE   IDSJNUM\n         MVI   1(R1),C'-'\n         BCTR  R1,0\n         BCT   R1,IDFILL\nIDSJNUM  XR    R0,R0\n         ICM   R0,B'0011',IDJ#(R5) SET JOB NUMBER\n         BZ    IDSEND              NONE\n         CVD   R0,FMT@CONV\n         MVC   IDJOB#,=XL6'402020202120'\n         ED    IDJOB#,FMT@CONV+5\nIDSEND   QCALL DISPLAY,QDMSG,80    ADD LINE TO SCREEN\n         LA    R5,IDLL(R5)         BUMP TO NEXT IF ANY\n         CLR   R5,R4               IS IT THE END?\n         BL    IDBMSG              NO, CONTINUE\n         QSTOP\nID$TILTI QTILT '=== NOT AVAILABLE TO YOU, SORRY ==='\nID$TILTN QTILT '*** NO INITIATORS TO DISPLAY ***'\n         SPACE 1\nIDINHD   DC    CL79'INIT   STATUS   CLASSES                            1\n                  JOB-NAME   JOB#'\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R10,R11,R12\n         TITLE '--- QUEUE/SP -- TGJU -- TRACK GROUPS JOBS USAGE ---'\nTGJU     QSTART\n         CLI   QXAUTH,LV12         AUTHORIZED USER?\n         BL    TG$TILTI            NO\n         L     R10,QVCKPT          @ CHECKPOINT WORK AREA\n         USING QCKPT,R10\n         L     R9,QVDSPL           @ DISPLAY WORK AREA\n         USING QDISPLAY,R9\n         XC    TGJQAR(L'TGJQAR),TGJQAR  CLEAR JQE AREA\n         L     R1,=A(TGPSAR)       INITIALIZE\n         MVC   TGPSAR,0(R1)        PRIME TRACK GROUPS ACCUMULATORS\n         XC    TGTTGPS,TGTTGPS     CLEAR ACCUMULATORS\n         XC    TGTJOBS,TGTJOBS\n         L     R3,QCJQHEAD         @ JQE'S QUEUES HEADS\n         SL    R3,=A(JQENEXT-JQE)\n         LA    R4,$JQHEADL         SIZE OF EACH QUEUE HEAD\n         LA    R5,($JQTYPES*$JQHEADL)-1(,R3)\nTGNXQH   LR    R6,R3               POINT TO NEXT QHEAD\n         USING JQE,R6\nTGJQEL   L     R6,JQENEXT          GET CHAIN FIELD\n         N     R6,=A(X'00FFFFFF')  OFFSET TO JQE\n         BZ    TGSTQH              BRANCH IF END OF QUEUE\n         AL    R6,QCJQEWA          ADD BASE TO OFFSET\n         LH    R2,JQETGNUM         NUMBER OF TRACK GROUPS\n         TM    JQEFLAG5,JQE5XUSD   USING JQE EXTENSION?\n         BZ    TGJU1               NO\n         AL    R2,QCJQEXA          COMPUTE ADDR OF EXTENSION\n         LH    R2,$JEXTTGN(,R2)    TRACK GROUPS IN EXTENSION\nTGJU1    LTR   R2,R2               ANY TGPS?\n         BNP   TGJQEL              NONE, SKIP THIS JQE\n         LR    R14,R2              NUMBER OF TRACK GROUPS\n         A     R14,TGTTGPS         ADD TO ACCUMULATOR\n         ST    R14,TGTTGPS\n         LA    R14,1\n         A     R14,TGTJOBS         BUMP TOTAL NUMBER OF JOBS\n         ST    R14,TGTJOBS\n         LA    R14,TGPSAR+L'TGPSAR-8    POINT TO LAST ENTRY\n         LA    R15,(L'TGPSAR/8)    NUMBER OF ENTRIES\n         LA    R1,8                SIZE OF AN ENTRY\nTGJU2    CL    R2,0(R14)           COMPARE TRACK GROUPS WITH SLOT SIZE\n         BNH   TGJU3               YES, INSERT IT HERE\n         SLR   R14,R1              BACK UP TO PREVIOUS ENTRY\n         BCT   R15,TGJU2           LOOP THROUGH ELEMENTS\n         B     TGJU4               NONE, SKIP INCREMENT\nTGJU3    LA    R15,1\n         A     R15,4(,R14)         INCREMENT COUNT\n         ST    R15,4(,R14)\nTGJU4    LA    R14,TGJQAR+L'TGJQAR-8    POINT TO LAST ENTRY\n         LA    R15,(L'TGJQAR/8)    NUMBER OF ENTRIES\n         LA    R1,8                SIZE OF AN ENTRY\nTGJU5    CL    R2,4(R14)           SEE IF NEW IS BIGGER\n         BNL   TGJU6               YES, INSERT IT HERE\n         SLR   R14,R1              BACK UP TO PREVIOUS ENTRY\n         BCT   R15,TGJU5           LOOP THROUGH ELEMENTS\n         B     TGJQEL              GO TRY NEXT JQE\nTGJU6    BCTR  R15,0               DROP BY ONE\n         SLL   R15,3               TIMES 8 (LENGTH OF ENTRY)\n         BCTR  R15,0               DROP FOR EXECUTE\n         LTR   R15,R15             TEST FOR VALID\n         BNP   *+L'*+4             NO, JUST DO THE INSERT\n         EX    R15,TGTMVC          MOVE ENTRIES DOWN\n         ST    R6,0(,R14)          SAVE JQE ADDRESS\n         ST    R2,4(,R14)          SAVE # OF TRACK GROUPS\n         B     TGJQEL              TRY NEXT JQE\nTGTMVC   MVC   TGJQAR(*-*),TGJQAR+8     SLIDE ENTRIES DOWN\nTGSTQH   BXLE  R3,R4,TGNXQH        STEP TO NEXT QHEAD\n         DROP  R6                  DROP OLD JQE REG\n         LA    R2,TGJQAR+L'TGJQAR-8     POINT TO LAST ENTRY\n         LA    R3,(L'TGJQAR/8)     NUMBER OF ENTRIES\n         LA    R4,8                SIZE OF EACH ENTRY\n         MVC   QDHLINE,TGJUHD      SET HEADER LINE\nTGPJQE   L     R5,0(,R2)           JQE ADDRESS\n         USING JQE,R5\n         MVC   QDMSG,QBLANK        BLANK THE TEXT AREA\n         LTR   R5,R5               ANY ADDRESS?\n         BZ    TGPNJQE             NO, SKIP TRASH\n         LH    R0,JQEJOBNO         GET JOB NUMBER\n         CVD   R0,FMT@CONV         TO DECIMAL\n         MVC   TGUJOBID,=XL6'402020202120'\n         ED    TGUJOBID,FMT@CONV+5 EDIT JOB ID IN MESSAGE TEXT\n         MVC   TGUJNAME,JQEJNAME   MOVE JOB NAME TO MESSAGE\n         TM    JQEFLAG1,JQE1BUSY   IS JOB BUSY?\n         BZ    TGPJQEN             NO\n         IC    R1,JQEFLAG1         SYSTEM BUSY INDICATOR\n         N     R1,=A(JQE1BUSY)\n         SLL   R1,3                COMPUTE OFFSET INTO QSE TABLE\n         LA    R1,QSYSIDU(R1)      ADDR OF SYSTEM BUSY\n         MVC   TGUACT,0(R1)        INSERT INTO MESSAGE\n         DROP  R5\nTGPJQEN  L     R0,4(,R2)           NUMBER OF TRACK GROUPS\n         CVD   R0,FMT@CONV         TO DECIMAL\n         MVC   TGU#TGPS,=XL8'4020202020202120'\n         ED    TGU#TGPS,FMT@CONV+4 EDIT IN MESSAGE\n         LTR   R1,R0               TEST AND SAVE FOR DIVIDE\n         BNP   TGJU10              SKIP IF NONE\n         XR    R0,R0               CLEAR FOR DIVIDE\n         MH    R1,=H'1000'\n         L     R15,QCTNUMTG        NUMBER OF ACTIVE TRACK GROUPS\n         DR    R0,R15              DIVIDE TO GET PERCENT OF TOTAL\nTGJU10   CVD   R1,FMT@CONV         TO DECIMAL\n         MVC   TGUTGPCT,=XL7'40202020214B20' EDIT MASK FOR % SPOOL\n         ED    TGUTGPCT,FMT@CONV+5 SET % TO MESSAGE\nTGPNJQE  L     R0,TGPSAR-TGJQAR(,R2)    TRACK GROUP ACCUMULATOR\n         CL    R0,TGPSAR           IS THIS THE MAX VALUE?\n         BNE   TGJU11              NO\n         MVC   TGU$TGPS,=CL8'     MAX'  SET MORE REASONABLE VALUE\n         B     TGJU12\nTGJU11   CVD   R0,FMT@CONV         TO DECIMAL\n         MVC   TGU$TGPS,=XL8'4020202020202120'\n         ED    TGU$TGPS,FMT@CONV+4 EDIT IN MESSAGE TEXT\nTGJU12   L     R0,TGPSAR-TGJQAR+4(,R2) NUMBER OF JOBS\n         LTR   R1,R0               TEST AND SAVE FOR DIVIDE\n         BNP   TGJU13              SKIP IF NONE\n         CVD   R0,FMT@CONV         TO DECIMAL\n         MVC   TGU$JOBS,=XL8'4020202020202120'\n         ED    TGU$JOBS,FMT@CONV+4 EDIT IN MESSAGE TEXT\n         XR    R0,R0               CLEAR FOR DIVIDE\n         MH    R1,=H'1000'\n         L     R15,TGTJOBS         GET TOTAL NUMBER OF JOBS\n         DR    R0,R15              DIVIDE TO GET PERCENT OF TOTAL\n         CVD   R1,FMT@CONV         TO DECIMAL\n         MVC   TGU$PCT,=XL7'40202020214B20'  EDIT MASK FOR % SPOOL\n         ED    TGU$PCT,FMT@CONV+5  SET % TO MESSAGE\nTGJU13   QCALL DISPLAY,QDMSG,80    ADD LINE TO SCREEN\n         SR    R2,R4               MOVE TO NEXT ENTRY\n         BCT   R3,TGPJQE           PRINT ALL ENTRIES\n         MVC   QDMSG,QBLANK        BLANK THE TEXT AREA\n         $FS   SF=(PROT,INT),MF=(I,QDMSG)    HIGH INTENSITY, PROTECTED\n         MVC   TGPTOTAL,=CL8'TOTAL :'\n         L     R0,TGTTGPS          TOTAL NUMBER OF TRACK GROUPS\n         CVD   R0,FMT@CONV         TO DECIMAL\n         MVC   TGT#TGPS,=XL8'4020202020202120'\n         ED    TGT#TGPS,FMT@CONV+4 EDIT IN MESSAGE\n         LTR   R1,R0               TEST AND SAVE FOR DIVIDE\n         BNP   TGJU20              SKIP IF NONE\n         XR    R0,R0               CLEAR FOR DIVIDE\n         MH    R1,=H'1000'\n         L     R15,QCTNUMTG        NUMBER OF ACTIVE TRACK GROUPS\n         DR    R0,R15              DIVIDE TO GET PERCENT OF TOTAL\nTGJU20   CVD   R1,FMT@CONV         TO DECIMAL\n         MVC   TGTTGPCT,=XL7'40202020214B20' EDIT MASK FOR % SPOOL\n         ED    TGTTGPCT,FMT@CONV+5 SET % TO MESSAGE\n         MVC   TGJTOTAL,=CL8'TOTAL :'\n         L     R0,TGTJOBS          TOTAL NUMBER OF JOBS\n         CVD   R0,FMT@CONV         TO DECIMAL\n         MVC   TGT$JOBS,=XL8'4020202020202120'\n         ED    TGT$JOBS,FMT@CONV+4 EDIT IN MESSAGE\n         $FS   SF=(PROT),MF=(I,QDMSG+L'QDMSG-2)   NORMAL INT, PROT\n         OI    QDOVER,QESKIP+QTSKIP     NO END OF DATA & NO TRANSLATE\n         QCALL DISPLAY,QDMSG,80    ADD LINE TO SCREEN\n         QSTOP\nTG$TILTI QTILT '=== NOT AVAILABLE TO YOU, SORRY ==='\n         SPACE 1\nTGJUHD   DC    CL79'  JOB#  JOBNAME  #-TGPS      % EXEC            #-TG1\n               PS  #-JOBS      %'\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9,R10,R11,R12\n         TITLE '--- QUEUE/SP -- PRINT -- START/STOP HARDCOPY ---'\nPRINT    QSTART\n         L     R10,QVDSPL          @ DISPLAY WORK AREA\n         USING QDISPLAY,R10\n         L     R9,QVPRINT          @ PRINT WORK AREA\n         USING QPRINT,R9\n         TM    QHFREQ,QHFAIL       IS HARDCOPY OPEN FAILED?\n         BO    PRNFAIL             YES, BYPASS ALL\n         TM    QHFREQ,QHCLOSE      IS HARDCOPY TO BE CLOSED?\n         BO    PRNSTOP             YES, GO DO IT\n         CLC   QPARM1(3),=CL3'OFF' IS PRINT OFF?\n         BE    PRNSTP              YES, GO STOP IT\n         CLC   QPARM1(2),=CL2'ON'  IS IT ON?\n         BE    PRNSTR              YES, GO START IT\n         CLI   QPARM1,C' '         NO PARM?\n         BE    PRNSTP              YES, ASSUME STOP\n         QTILT '=== INVALID PRINT COMMAND (ON/OFF) ==='\n         SPACE 1\n*---     ALLOCATE/OPEN AND START HARDCOPY PROCESS                  ---*\n         SPACE 1\nPRNSTR   TM    QHFREQ,QHCOPY       IS HARDCOPY ACTIVE?\n         BZ    PRNALLOC            NO, START IT\n         QTILT '=== HARDCOPY IS ALREADY ACTIVE ==='\n         SPACE 1\n*---     ALLOCATE / OPEN HARDCOPY                                  ---*\n         SPACE 1\nPRNALLOC LA    R1,P99RB            RELOCATE THE LIST ADDRESSES\n         ST    R1,P99RBPTR              *\n         OI    P99RBPTR,X'80'           *\n         LA    R1,P99TUPL               *\n         ST    R1,P99TXTPP              *\n         LA    R1,P99TUKY1              *\n         ST    R1,P99TUPL               *\n         LA    R1,P99TUKY2              *\n         ST    R1,P99TUPL+4             *\n         LA    R1,P99TUKY3              *\n         ST    R1,P99TUPL+8             *\n         LA    R1,P99TUKY4              *\n         ST    R1,P99TUPL+12            *\n         OI    P99TUPL+12,X'80'         *\n         SPACE 1\n*---     PROCESS PARMS ...                                         ---*\n         SPACE 1\n         LH    R1,QLNG2            GET LENGTH OF SECOND PARM\n         CH    R1,=H'1'            LENGTH OF ONE?\n         BNE   PRNNSCHG            NO, NO CHANGE OF SYSOUT CLASS\n         CLI   QPARM2,C'A'         IS IT ALPHA?\n         BL    PRNNSCHG            NO, NO CHANGE OF SYSOUT CLASS\n         MVC   P99SYSOC,QPARM2     MOVE IN PARM FOR SYSOUT CLASS\nPRNNSCHG CLI   QPARM3,C' '         ANY DEST SPECIFIED\n         BE    PRNNDEST\n         MVC   P99DEST,QPARM3      MOVE IN DEST\n         MVC   P99DESTL,QLNG3      MOVE IN LENGTH\n         B     PRNDYALL\nPRNNDEST MVC   P99TUPL+8(4),P99TUPL+12  OVERRIDE DEST= PARM\n         SPACE 1\n*---     DO THE ALLOCATION                                         ---*\n         SPACE 1\nPRNDYALL LA    1,P99RBPTR          ADDR OF PARM LIST FOR DYNALLOC\n         DYNALLOC\n         LTR   R15,R15             CHECK RETURN CODE?\n         BNZ   PRNCANT             ERROR, CAN DO POST MESSAGE\n         LA    R6,HCPYDCB          ADDRESS OF OUTPUT DCB\n         USING IHADCB,R6           ADDRESSABILITY TO OUTPUT DCB\n         MVC   DCBDDNAM,QBLANK\n         ICM   R15,B'0011',P99DDNL\n         BCT   R15,*+L'*+6\n         MVC   DCBDDNAM(*-*),P99DDN     <<EXECUTED>>\n         EX    R15,*-6             SET DDNAME\n         OPEN  ((R6),OUTPUT),MF=(E,HCPYOP)   OPEN THE FILE\n         TM    DCBOFLGS,DCBOFOPN   CHECK FOR SUCCESSFUL OPEN\n         DROP  R6                  KILL DCB ADDRESSABILITY\n         BZ    PRNBAD              BYPASS IF BAD OPEN\n         OI    QHFREQ,QHCOPY       SET HARDCPY FILE AVAILABLE\n         ZAP   QHPAGE#,=PL1'+0'    RESET PAGE NUMBER\n         ZAP   QHLINE#,=PL2'+999'  RESET LINES COUNT\n         MVC   QDMSG(L'PMSSTART),PMSSTART    MOVE START MSG\n         MVC   QDMSG+PMSCLASS(L'PMSCLASS),P99SYSOC     SYSOUT CLASS\n         MVC   QDMSG+PMSDEST(L'PMSDEST),P99DEST\n         CLI   QDMSG+PMSDEST,C' '  ANY DEST?\n         BNE   *+L'*+6\n         MVC   QDMSG+PMSDEST(L'PMSDEST),=CL8'LOCAL'    SAY LOCAL\n         LA    R0,L'PMSSTART\nPRNMSG   LA    R1,QDMSG\n         QTILT ,                   SEND MESSAGE\nPRNBAD   NI    QHFREQ,255-QHCOPY   TURN OFF HARDCOPY FLAG\n         OI    QHFREQ,QHFAIL       SET HARDCOPY OPEN FAILED FLAG\nPRNFAIL  QTILT 'SORRY, ... HARDCOPY OPEN FAILED'\n         SPACE 1\n*---     FORMULATE TEXT FOR SVC99 ALLOCATE FAILURE                 ---*\n         SPACE 1\nPRNCANT  CLC   P99ERROR,=XL2'046C' WAS IT 'RMT NOT DEF TO JES2'?\n         BE    PBADRMT             YES, POST MSG AND EXIT\n         MVC   QDMSG,QBLANK        CLEAR OUT LINE\n         MVC   QDMSG(L'PMSERR),PMSERR\n         CVD   R15,QNUMWORK        CONVERT SVC 99 RETURN CODE\n         MVC   QDMSG+PMSRC(L'PMSRC),=XL4'40202020'     TO DEC\n         ED    QDMSG+PMSRC(L'PMSRC),QNUMWORK+6\n         UNPK  QDMSG+PMSERC(L'PMSERC+1),P99ERROR(3)    ERR CODE\n         TR    QDMSG+PMSERC(L'PMSERC),HEXTAB-X'F0'\n         MVI   QDMSG+PMSERC+L'PMSERC,C' '\n         UNPK  QDMSG+PMSINFO(L'PMSINFO+1),P99INFO(3)   INFO CODE\n         TR    QDMSG+PMSINFO(L'PMSINFO),HEXTAB-X'F0'\n         MVI   QDMSG+PMSINFO+L'PMSINFO,C' '\n         LA    R0,L'PMSERR\n         B     PRNMSG              GO SEND THE MESSAGE\nPBADRMT  MVC   QDMSG(L'PMSNRMT),PMSNRMT MOVE IN NO SUCH REMOTE MSG\n         MVC   QDMSG+PMSRMTN(L'PMSRMTN),QPARM3    RMT ASKED FOR\n         LA    R0,L'PMSNRMT\n         B     PRNMSG              GO SEND THE MESSAGE\n         SPACE 1\n*---     STOP HARDCOPY PROCESS AND FREE SYSOUT FILE                ---*\n         SPACE 1\nPRNSTP   TM    QHFREQ,QHCOPY       IS HARDCOPY ACTIVE?\n         BO    PRNSTOP             YES\n         QTILT '=== HARDCOPY IS ALREADY INACTIVE ==='\nPRNSTOP  LA    R2,HCPYDCB          ADDRESS OF OUTPUT DCB\n         CLOSE ((R2)),MF=(E,HCPYCL)     CLOSE OFF THE FILE\n         FREEPOOL (R2)             FREE THE BUFFERS TOO\n         TM    QHFREQ,QHCLOSE      WAS HARDCOPY TO BE CLOSED?\n         BZ    PRNRST              NO\n         QSTOP ,                   YES, EXIT\nPRNRST   LR    R0,R9               RE-INITIALIZE\n         L     R1,=A(QPRINTL)\n         L     R2,=A(QPRINT)\n         LR    R3,R1\n         MVCL  R0,R2\n         NI    QHFREQ,255-QHCOPY   TURN OFF HARDCOPY FLAG\n         QTILT 'HARDCOPY STOPPED : SYSOUT FREED FOR PRINT.'\n         SPACE 1\nPMSSTART DC    C'HARDCOPY STARTED : SYSOUT= ,DEST=        '\nPMSCLASS EQU   26,1\nPMSDEST  EQU   33,8\nPMSERR   DC    C'HARDCOPY ALL. ERR. : DARC=     INFO=     R15=    .'\nPMSERC   EQU   26,4\nPMSINFO  EQU   36,4\nPMSRC    EQU   45,4\nPMSNRMT  DC    C'HARDCOPY ERR. : REMOTE          UNDEFINED TO JES2.'\nPMSRMTN  EQU   23,8\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9,R10,R11,R12\n         TITLE '--- QUEUE/SP -- HCOPY -- HARDCOPY ROUTINE ---'\nHCOPY    QSTART\n         L     R10,QVDSPL          @ DISPLAY WORK AREA\n         USING QDISPLAY,R10\n         L     R9,QVPRINT          @ PRINT WORK AREA\n         USING QPRINT,R9\n         SPACE 1\n*---     GET DATE/TIME FOR HEADING                                 ---*\n*---     SET HJDATE ... (YY.DDD  HH:MM:SS DAY MTH DD,19YY)         ---*\n         SPACE 1\n         TIME  DEC\n         ST    R1,BINDATE          SAVE DATE FOR LATER\n         SPACE 1\n*---     FORMAT THE PRESENT TIME (AS SET BY THE OPERATOR)          ---*\n         SPACE 1\n         ST    R0,QNUMWORK         CONVERT PACKED TO DEC\n         MVI   QNUMWORK+4,X'0F'\n         UNPK  XQDWD(9),QNUMWORK(5)\n         MVC   HTMEHRS,XQDWD       MOVE TIME TO MSG\n         MVC   HTMMINS,XQDWD+2\n         MVC   HTMSECS,XQDWD+4\n         SPACE 1\n*---     FORMAT TODAY'S DATE INTO THE OUTPUT MSG                   ---*\n         SPACE 1\n         MVC   XQDWD(4),BINDATE    MOVE DATE TO WORK AREA\n         MVO   XQDWD+1(3),XQDWD(2) MAKE 00YYDDDS INTO 00000YYS\n         UNPK  HCYR(2),XQDWD+2(2)  FORMAT YEAR\n         XC    QNUMWORK,QNUMWORK\n         MVC   QNUMWORK+4(4),XQDWD CONVERT YEAR TO BIN\n         CVB   R0,QNUMWORK\n         ST    R0,BINYEAR          AND SAVE\n         TM    BINYEAR+3,X'03'     LEAP YEAR?\n         BNZ   HMON1               NO\n         MVI   HMONMSK+10,29       YES, CORRECT\nHMON1    XC    QNUMWORK,QNUMWORK   CONVERT DAYS TO BIN\n         MVC   QNUMWORK+6(2),BINDATE+2\n         CVB   R2,QNUMWORK\n         ST    R2,BINDAYS          SAVE FOR LATER\n         XR    R1,R1\n         LA    R15,11\nHMON2    IC    R1,HMONMSK(R15)     COMPUTE MON AND DAY\n         SR    R2,R1\n         BNP   HMONOVR\n         BCT   R15,HMON2\n         B     *+L'*+2\nHMONOVR  AR    R2,R1               CORRECT OVERDRAW\n         CVD   R2,QNUMWORK         FORMAT DAY\n         UNPK  HCDAYN(2),QNUMWORK+6(2)\n         OI    HCDAYN+1,C'0'       FIX UP SIGN\n         MH    R15,=Y(L'HMONTAB)   GET TABLE OFFSET\n         LA    R15,HMONTAB(R15)    AND POINT AT MONTH\n         MVC   HCMON(L'HCMON),0(R15)    MOVE IT TO THE MSG\n         SPACE 1\n*---     DAY OF WEEK                                               ---*\n         SPACE 1\n         L     R15,BINYEAR\n         SH    R15,=H'69'\n         BNP   HOUTT               MUST BE GREATER OR BAD\n         XR    R14,R14             CLEAR DAY REG\n         D     R14,=F'4'\n         MH    R15,=H'5'\n         AR    R14,R15\n         A     R14,BINDAYS\n         SRDA  R14,32\n         D     R14,=F'7'           MODULO 7 FOR WEEK\n         MH    R14,=Y(L'HDAYTAB)\n         LA    R14,HDAYTAB(R14)    POINT AT TODAY\n         MVC   HCDAY(L'HCDAY),0(R14)    INSERT IN MSG\n         B     HMOVEJD\nHOUTT    MVC   HCDAY(L'HCDAY),=CL3'???'\nHMOVEJD  MVC   HJDATE,=XL7'4020204B202020'\n         ED    HJDATE,BINDATE+1\n         MVI   HJDATE,C'='\n         MVC   QHUSER,QLOGON       MOVE IN USERID\n         MVI   QHPAGS,C' '\n         MVC   QHPAGE,QBLANK       CLEAR OUT PAGE FIELD\n         MVI   QHHEAD1,C'0'        SET DOUBLE SPACE\n         CP    QHLINE#,=PL2'+35'   EJECT TO BE SCHEDULED?\n         BNH   HNOPAGE             NO, ... SKIP PAGE SETTING\n         AP    QHPAGE#,=PL1'+1'    BUMP PAGE COUNT\n         MVI   QHPAGS,C'/'\n         MVC   QHPAGE,=XL6'402020202021'     MOVE IN MASK\n         ZAP   QNUMWORK,QHPAGE#    MOVE INTO AREA\n         ED    QHPAGE,QNUMWORK+5   EDIT IN PAGE NUMBER\n         MVI   QHHEAD1,C'1'        SET EJECT\n         ZAP   QHLINE#,=PL1'+0'    RESET LINES COUNT\nHNOPAGE  PUT   HCPYDCB,QHHEAD1     PUT OUT TITLE LINE\n         PUT   HCPYDCB,QHHEAD2     PUT OUT UNDERLINE\n         AP    QHLINE#,=PL1'+3'    BUMP LINES COUNT\n         MVC   QHLINE,QBLANK       RECONSTRUCT IMAGE OF\n         MVC   QHLINE(12),=CL12'COMMAND ===>'     COMMAND LINE\n         MVC   QHLINE+13(L'QDPROMPT),QDPROMPT     WITHOUT 3270\n         OC    QHLINE+13(L'QDPROMPT),QBLANK       CONTROL CHARS\n         PUT   HCPYDCB,QHDETAIL\n         AP    QHLINE#,=PL1'+1'    BUMP LINES COUNT\n         SPACE 1\n*---     PUT OUT ENTIRE SCREEN OF DETAIL LINES                     ---*\n         SPACE 1\n         CLC   QDHLINE(L'QDHLINE),QBLANK\n         BE    HNOHD\n         MVC   QHLINE(L'QDHLINE),QDHLINE     MOVE HEADING LINE\n         PUT   HCPYDCB,QHDETAIL    PRINT THE LINE\n         AP    QHLINE#,=PL1'+1'    BUMP LINES COUNT\nHNOHD    LA    R2,QDLINE1          SET SCAN REGISTERS\n         LA    R5,QHLINE\nHSCNEXT  LR    R3,R2\n         LA    R4,L'QDLINE1\nHSCLOOP  CLI   0(R2),X'1D'         IS IT A SF ORDER?\n         BE    HTLNE               YES\n         CLI   0(R2),X'11'         IS IT A SBA ORDER?\n         BE    HTLNE               YES\n         CLI   0(R2),X'3C'         IS IT A RA ORDER?\n         BE    HTLNE               YES\n         LA    R2,1(R2)            POINT TO NEXT CHAR IN LINE\n         BCT   R4,HSCLOOP          CONTINUE THROUGH SCREEN\nHTLNE    LR    R1,R2               COMPUTE LINE LENGTH\n         SR    R1,R3\n         BNP   HSCNONE\n         MVC   QHLINE,QBLANK\n         BCTR  R1,0\n         EX    R1,HPLNE            MOVE LINE TO BUFFER\n         PUT   HCPYDCB,QHDETAIL    PUT DETAIL LINE OUT\n         AP    QHLINE#,=PL1'+1'    BUMP LINES COUNT\nHSCNONE  LA    R5,QHLINE\n         CLI   0(R2),X'1D'         WAS IT A SF ORDER?\n         BNE   HTNULL              NO\n         LA    R2,2(R2)            SKIP SF ORDER\n         LA    R5,1(R5)            ADJUST NEXT MOVE DATA\n         B     HSCNEXT             CONTINUE THROUGH SCREEN\nHTNULL   CLI   0(R2),X'11'         WAS IT A SBA ORDER?\n         BE    HTLEND              YES\n         CLI   0(R2),X'3C'         WAS IT A RA ORDER?\n         BNE   HSCNEXT             NO, CONTINUE THROUGH SCREEN\nHTLEND   MVI   QHDETAIL,C'0'       DOUBLE SPACE\n         MVC   QHLINE,QBLANK       BLANK LINE\n         PUT   HCPYDCB,QHDETAIL    AND PRINT IT\n         MVI   QHDETAIL,C' '       RESTORE TO SINGLE SPACE\n         AP    QHLINE#,=PL1'+1'    BUMP LINES COUNT\n         QSTOP ,                   RETURN\nHPLNE    MVC   0(*-*,R5),0(R3)     <<EXECUTED>>\n         SPACE 1\nHDAYTAB  DS    0CL3\n         DC    C'TUEWEDTHUFRISATSUNMON'\nHMONTAB  DS    0CL3\n         DC    C'DECNOVOCTSEPAUGJULJUNMAYAPRMARFEBJAN'\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9,R10,R11,R12\n         TITLE '--- QUEUE/SP COMMON AREA ---'\n***********************************************************************\n***********************************************************************\n***                                                                 ***\n***      QUEUE COMMAND - COMMON AREA DESCRIPTION                    ***\n***                                                                 ***\n***********************************************************************\n***********************************************************************\n         SPACE 1\nQCOMMON  DS    0D                  START ON A DOUBLE-WORD BOUNDARY\n         DC    18F'0'              COLD SAVE AREA\n         SPACE 1\n*---     NUMERIC CONVERT ROUTINE                                   ---*\n         SPACE 1\n         USING QCOMMON,R11\nQNUMCONV MVC   QFZONES,QFZONE      INITIALIZE FIELD\n         EX    R1,QMVZ             COPY THE ZONES\n         CLC   QFZONES,QFZONE      ALL NUMERICS?\n         BNER  R14                 NO, RETURN WITH CC SET TO 'NE'\n         EX    R1,QPACK            PACK IT\n         CVB   R15,QNUMWORK        GET IT IN BINARY\n         BR    R14                 RETURN WITH CC SET TO 'EQ'\nQMVZ     MVZ   QFZONES(*-*),0(R15) << EXECUTED >>\nQPACK    PACK  QNUMWORK,0(*-*,R15) << EXECUTED >>\n         DROP  R11\n         EJECT\n*---     VECTOR TABLE - ADDRESSES OF AREAS IN QCOMMON              ---*\n         SPACE 1\nQCWA     DC    A(0)                PTR TO SPACE WORK AREA\nQVDSPL   DC    A(0)                PTR TO DISPLAY WORK AREA\nQVCKPT   DC    A(0)                PTR TO CKPT WORK AREA\nQVSNAP   DC    A(0)                PTR TO SNAP WORK AREA\nQVPRINT  DC    A(0)                PTR TO HARDCOPY WORK AREA\nQGSASSZ  DC    A(4096)             SAVE AREA STACK SIZE\nQPTRSV   DC    4F'0'               SPARE POINTERS SAVE AREA\nQFRSTSA  DC    A(0)                @ OF FIRST SAVE AREA\nQCJQHEAD DC    A(0)                @ OF $JQHEADS IN MASTER RECORD\nQCJQEXA  DC    A(0)                @ OF JQE EXTENSIONS\nQCTNUMTG DC    F'0'                # OF TRACK GROUPS ON ACTIVE VOLUMES\nQCMSA    DC    A(0)                @ OF MASTER RECORD\nQCMSTTR  DC    0F'0',X'00000300'   TTR OF MASTRER CKPT RECORD\nQCDASA   DC    A(0)    *ORDER*     @ DAS CKPT AREA\nQCDASTTR DC    F'0'    *ORDER*     TTR OF 1ST DAS CKPT BLOCK\nQCDASNUM DC    F'0'    *ORDER*     # OF DAS CKPT BLOCKS\nQCJQEWA  DC    A(0)                @ JQE CKPT AREA (BASE TO OFFSET)\nQCJQEA   DC    A(0)    *ORDER*     @ JQE CKPT AREA\nQCJQETTR DC    F'0'    *ORDER*     TTR OF 1ST JQE CKPT BLOCK\nQCJQENUM DC    F'0'    *ORDER*     # OF JQE CKPT BLOCKS\nQCJOTWA  DC    A(0)                @ JOE CKPT AREA (BASE TO OFFSET)\nQCJOTA   DC    A(0)    *ORDER*     @ JOE CKPT AREA\nQCJOETTR DC    F'0'    *ORDER*     TTR OF 1ST JQE CKPT BLOCK\nQCJOENUM DC    F'0'    *ORDER*     # OF JOE CKPT BLOCKS\nQCJCTA   DC    A(0)                @ OF JCT BUFFER\nQCIOTA   DC    A(0)                @ OF IOT BUFFER\nQCBLKA   DC    A(0)                @ OF DATA-SET BLOCK BUFFER\n         EJECT\n*---     MISCELLANEOUS NUTS AND BOLTS                              ---*\n         SPACE 1\nQLOGON   DC    CL7' '              LOGON ID (PSCBUSER)\nQLOGONL  DC    AL1(0)              LENGTH OF LOGON ID\nQCLASSH  DC    0H'0',X'00'         HALFWORD BOUNDARY\nQCLASS   DC    C' '                SEARCH CLASS\nQCLASSE  DC    CL2' '              EXTERNAL CLASS\n         CNOP  2,4\nQCODEH   DC    0H'0',X'00'         HALFWORD BOUNDARY\nQCODE    DC    X'00'               SEARCH FUNCTION CODE\nQSUBCMD  DC    A(0)                ADDR OF CURRENT SUB-COMMAND\nQOFF0    DC    H'0'                OFFSET TO SUB-COMMAND\nQLNG0    DC    H'0'                LENGTH OF SUB-COMMAND\nQSUBNAME DC    CL8' '              NAME OF SUB-COMMAND\nQOFF1    DC    H'0'                OFFSET TO QPARM1\nQLNG1    DC    H'0'                LENGTH OF QPARM1\nQPARM1   DC    CL8' '              USER SUPPLIED PARAMETER #1\nQOFF2    DC    H'0'\nQLNG2    DC    H'0'\nQPARM2   DC    CL8' '                                      #2\nQOFF3    DC    H'0'\nQLNG3    DC    H'0'\nQPARM3   DC    CL8' '                                      #3\nQOFF4    DC    H'0'\nQLNG4    DC    H'0'\nQPARM4   DC    CL8' '                                      #4\nQOFFLR   EQU   *-QOFF1\nQJOBID   DC    H'0',CL8' '         LAST JOBID (AND LENGTH)\nQSTKEY   DC    CL8' '              SEARCH KEY FOR 'ST' SUBCMD\nQXAUTH   DC    X'00'\nQSYNADFL DC    X'00'               SYNAD ERROR ROUTINE FLAG BYTE\nQBLANK   DC    CL80' '             80 BLANKS\nSZLINE   DC    F'0'                LINE SIZE (LINE LENGTH)\nSZSCRN   DC    F'0'                SCREEN SIZE (NUMBER OF LINES)\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(*-*)\nSAVAUTH  DC    X'00'\nQXSWXQ   DC    X'00'          TRACE INDICATORS\nOPTR     EQU   X'01'               TRACE FILE OPENED FLAG\nRQTR     EQU   X'02'               TRACE REQUESTED FLAG\nNFTR     EQU   X'04'               NOT FULL SCREEN FLAG\nMSTR     EQU   X'08'               BACK ERROR MESSAGE FLAG\nSKTR     EQU   X'10'               TRACE FILE IN ERROR FLAG\nSZSWTCH  DC    X'00'          SCREEN SIZE INDICATORS\nSCRST    EQU   X'01'               SCREEN SIZE TO BE SET\nSCRRS    EQU   X'02'               SCREEN SIZE TO BE RESET\nQTSSW    DC    X'00'          TSO CMDS INDICATORS\nRCTSO    EQU   X'01'               DISPLAY TSO CMDS RC FLAG\nFLTSO    EQU   X'02'               FULL DISPLAY TSO CMDS RC FLAG\nCLTSO    EQU   X'10'               CLIST EXECUTION REQUEST FLAG\nCLSTX    EQU   X'20'               CLIST IN EXECUTION FLAG\nCLSTP    EQU   X'40'               STOP PROCESS FLAG\n         EJECT\nQNUMWORK DC    D'0'                CONVERT WORK AREA\nQFZONE   DC    C'0'                USED TO CLEAR QFZONES\nQFZONES  DC    C'00000000'         USED FOR NUMERIC CHECK\nQCOUNT   DC    PL3'0'              NUMBER OF ELEMENTS IN QUEUE\nQPJOBID  DC    XL4'0'              JOB ID FOR LISTDS\nQPDSID   DC    H'0'                DATA-SET ID FOR LISTDS\nQPOFFSET DC    H'0'                PRINT OFFSET FROM BEG. OF REC\nQPREC    DC    PL4'0'              CURRENT RECORD COUNT\nQPLNG    DC    H'0'                LEN OF COMPARE FIELD FOR FIND\nQPFIND   DC    CL64' '             COMPARE FIELD FOR FIND\nQSPOLNUM DC    H'0'                NUMBER OF SPOOL VOLUMES\nQSYSIDU  DC    CL8'UNKNOWN '       SYSTEM ID TABLE START\nQSYSID   DC    8CL8' '             SYSTEM ID TABLE\n         SPACE 1\nQASID    DC    H'0'                ADDRESS SPACE IDENTIFIER\nSRMCC    DC    F'0'                SRM RETURNS INFORMATION\nATSOX    DC    A(0)                TSO COMMANDS WORK AREA\nQFRAR1   DC    A(0)                BLOCK ADDR TABLE FOR LISTDS\nQFRSZ1   DC    A(LDSSZ)            HIS LENGTH\nQFRAR2   DC    A(0)                DECB WORK AREA FOR CKPT ROUTINE\nQFRSZ2   DC    A(0)                HIS LENGTH\nQFRAR3   DC    A(0)                BUFFERS FOR HASPCKPT & HASPACE(S)\nQFRSZ3   DC    A(0)                HIS LENGTH\nQFRAR4   DC    A(0)                DCB'S POOL FOR HASPACE(S)\nQFRSZ4   DC    A(0)                HIS LENGTH\n         SPACE 1\nQCOUNTE  DC    PL3'0'\nQCOUNTA  DC    PL3'0'\nQCOUNTH  DC    PL3'0'\n         SPACE 1\nQDFREQ   DC    XL1'0'         DUMP FORMAT REQUESTS\nQDFSC    EQU   X'80'               SCAN POINTERS SET\nQDFSV    EQU   X'40'               SAVED INFO FOR DUMP\nQDFRS    EQU   X'20'               RESET REQUEST\nQDFEX    EQU   X'01'               EXTENDED\nQDFRL    EQU   X'02'               RELATIVE\n         SPACE 1\nQHFREQ   DC    XL1'0'         HARDCOPY REQUESTS - STATUS\nQHCOPY   EQU   X'80'               HARDCOPY ACTIVE\nQHCLOSE  EQU   X'40'               CLOSE HARDCOPY\nQHFAIL   EQU   X'20'               HARDCOPY OPEN FAILED\n         EJECT\n*---     DATA-SETS CONTROL BLOCKS                                  ---*\n         SPACE 1\nHASPCKPT DCB   DDNAME=JES2CKPT,DSORG=PS,MACRF=(RCP),RECFM=U,NCP=3\n         SPACE 1\nHASPACE  DCB   DDNAME=JES2ACE1,DSORG=DA,MACRF=(RIC),OPTCD=A,RECFM=F\nQCDCBL   EQU   *-HASPACE           LENGTH OF HASPACE DCB\n         SPACE 1\nQCOUT    DCB   DDNAME=JES2SAVE,DSORG=PS,MACRF=(PM),                    1\n               EXLST=QCOLST,SYNAD=SV$DCBSA\n         SPACE 1\n         READ  HDECB1,SF,*-*,,'S',MF=L\nHDECB1L  EQU   *-HDECB1            LENGTH OF DECB FOR HASPCKPT\n         SPACE 1\n         READ  HDECB2,DI,*-*,,0,0,*-*,MF=L\n         SPACE 1\nQCOPEN   OPEN  (*-*,OUTPUT),MF=L\nQCERR    DC    F'0'\n         SPACE 1\nHOCKPT   OPEN  (*-*),MF=L\n         EJECT\nINT#DCB  DCB    MACRF=E,DSORG=PS,DDNAME=JES2CKPT\n         SPACE 1\nINT#RDJF RDJFCB (*-*),MF=L\nINT#ELST DC     0F'0',X'87',AL3(*-*)\nINT#JFCB DC     0D'0',XL176'00'\n         EJECT\n*---     MISCELLANEOUS WORK AREAS\n         SPACE 1\n         $TEW$WA\nTOTLNES  DC    F'0'                TOTAL LINES\nTOTCPU   DC    F'0'                TOTAL CPU\nTOTIO    DC    F'0'                TOTAL I/O\nTIMESC   DC    A(2*100)            2.00 SEC SCAN INTERVAL\nTIMEVL   DC    F'0'                TIME COUNTER\nTIMECT   DC    A(TDFLT)            TIME COUNTER VALUE\nTIMEVLM  DC    F'0'                MAX. TIME COUNTER\nTIMECTM  DC    A(30*60*100)        MAX. TIME VALUE (30 MIN)\n         SPACE 1\nTRKLIST  TRKCALC MF=L\n         EJECT\nXQDWD    DS    0D\nDDN@DWD  DC    D'0'\nFMT@CONV DC    D'0'                CONVERT WORK DOUBLEWORD\nIT#KITF  DC    A(0)                @ FIRST KIT AT INIT TIME\nIT#KITL  DC    A(0)                @ LAST KIT AT INIT TIME\nIT#DEVTB DC    6F'0'               CKPT DEVICE DEVTYPE INFO\nIT#CKRT  DC    F'0'                4K BLOCKS/TRK ON CKPT DEVICE\nPRIORITY DC    3F'0'\nP#OFFSET DC    H'0'\nLENGTH   DC    H'0'\nFIELD    DC    CL8' '\nRPASS    DC    CL8' '\n         DS    0F\nDSNCKPT  DC    H'13',CL44'SYS1.HASPCKPT'\nDSNSPACE DC    H'12',CL44'SYS1.HASPACE'\nDSNAME   DC    H'0',CL44' '\nSWITCH   DC    X'0'\nSPINDONE EQU   X'01'               SPIN IOT SEARCHED\nDSFOUND  EQU   X'02'               DATA-SET FOUND\nDDN@SW   DC    X'0'\nSW@SPIN  EQU   X'01'               THIS IS A SPIN DSID\nSW@FOUND EQU   X'02'               DSID FOUND IN PDDB 5\nSW@HELD  EQU   X'04'               THIS IS A HELD DATA-SET\nSW@END   EQU   X'80'               END OF TABLE INDICATOR\nBUFFER   DC    CL256' '\nXQLINE   DS    0CL80\nFMT@LINE DC    CL80' '             HEX OUTPUT AREA\nFMT@HEXW DC    CL71' '             HEX WORK AREA\nHEXTAB   DC    CL16'0123456789ABCDEF'   HEX TABLE TRANSLATION\n         SPACE 1\nQLCOM    EQU   *-QCOMMON --------- USING LIMIT FOR QCOMMON -----------*\n         EJECT\n*---     DISPLAY WORK FIELDS                                       ---*\n         SPACE 1\nQDISPLAY DS    0D                  START OS DISPLAY WORK AREA\nQDREPLYL EQU   66                  LENGTH OF REPLY AREA\nPFREPLY  DS    0XL(6+QDREPLYL)\nPFCODE   DC    XL6'0'\nPFTXT    DC    XL(QDREPLYL)'0'\nQDMSGA   DC    A(0)                ADDRESS OF MSG TO BE DISPLAYED\nQDMLNG   DC    H'0'                MESSAGE LENGTH\n         SPACE 1\nQDMSG    DS    0CL80               AREA FOR BUILDING OUTPUT LINE\nPGMNAME  DS    CL8\n         DS    CL2\nPROCNAME DS    CL8\n         DS    CL6\nSTEPNAME DS    CL8\n         DS    CL2\nPROCSTEP DS    CL8\n         DS    CL3\nDDN      DS    CL8\n         DS    CL3\nDSID     DS    CL4\n         DS    CL2\nHELD     DS    CL2                 'H-' OR BLANK\nDSTYPE   DS    CL6                 'SYSOUT' OR 'SYSIN'\nRECORDS  DS    CL8\n         ORG   QDMSG\n         DS    CL1\nQTYPE    DS    CL1\n         DS    CL1\nCLASS    DS    CL1\n         DS    CL3\nQTCOUNT  DS    CL6\n         DS    CL7\nQECOUNT  DS    CL3\n         DS    CL6\nQACOUNT  DS    CL3\n         DS    CL5\nQHCOUNT  DS    CL3\n         DS    CL3\nQTRECS   DS    CL6\n         ORG   QDMSG\nFCLEAR   DS    0CL80               FORMAT FOR QUEUE RECORDS\nFQNAME   DS    0CL4,C              NAME OF QUEUE (I,X,O,TSU,SYS,H/O)\n         DS    C\nFQUEUE   DS    CL2                 CLASS NAME (IF FQNAME=I, X OR O)\n         DS    C\nFCOUNT   DS    CL4                 POSITION IN QUEUE\n         DS    C\nFNAME    DS    CL8                 JOB NAME\n         DS    C\nFJOBNO   DS    CL5                 JES2 JOB NUMBER\n         DS    C\nFPRIO    DS    CL2                 JOB PRIORITY\n         DS    C\nFLINES   DS    CL6                 NUMBER OF OUTPUT LINES\n         DS    C\nFSYSID   DS    CL4                 SYSTEM ID\n         DS    C\nFHOLD    DS    CL1                 JOB HOLD STATUS\n         DS    C\nFDEV     DS    CL4                 PRINTING\nFCPU     EQU   FDEV+1,9            REQUESTED CPU TIME\n         DS    C\nFFORM    DS    CL8                 FORM NAME\n         DS    C\nFFCB     DS    CL4                 FCB NAME\nFIO      EQU   FFCB,6              REQUESTED I/O\n         DS    C\nFUCS     DS    CL4                 UCS NAME\n         DS    C\nFREMOTE  DS    CL4                 REMOTE JOB (RJE)\n         AIF   ('&SYSPARM' NE 'CJS').CJS4\n         DS    C                                                  -CJS-\nFCJSID   DS    CL8                 NET ID (CJS)                   -CJS-\n.CJS4    ORG   QDMSG\n         DS    C\nFHEXNM1  DS    CL5\n         DS    C\nFHEXSP1  DS    CL1\n         DS    C\nFHEXRP1  DS    CL6\n         DS    C\nFHEXNM2  DS    CL8\n         DS    C\nFHEXSP2  DS    CL1\n         DS    C\nFHEXRP2  DS    CL6\n         DS    C\nFHEXNM3  DS    CL8\n         DS    C\nFHEXSP3  DS    CL1\n         DS    C\nFHEXRP3  DS    CL6\n         ORG   QDMSG\n         DS    C\nFHEXID   DS    CL5\n         DS    C\nFHEXDATA DS    CL72\n         ORG   QDMSG\nLPDSID   DS    CL8\n         DS    CL1\nLPFLAG1  DS    CL6\n         DS    CL1\nLPRECCT  DS    CL8\n         DS    CL2\nLPCLASS  DS    CL1\n         DS    CL2\nLPMTTR   DS    CL8\n         DS    CL1\nLPMTTRL  DS    CL8\n         DS    CL2\nLPNPROC  DS    CL8\n         DS    CL1\nLPNSTEP  DS    CL8\n         DS    CL1\nLPNDDNM  DS    CL8\n         ORG   QDMSG\n         DS    C\nIDIN#    DS    CL2                 PIT ID\n         DS    CL3\nIDSTAT   DS    CL8                 PIT STATUS\n         DS    CL2\nIDCLS    DS    CL36                PIT CLASSES\n         DS    CL2\nIDJOBNM  DS    CL8                 JOB NAME\n         DS    C\nIDJOB#   DS    CL6                 JOB NUMBER\n         ORG   QDMSG\nTGUJOBID DS    CL6                 JOB NUMBER\n         DS    CL1\nTGUJNAME DS    CL8                 JOB NAME\nTGU#TGPS DS    CL8                 NUMBER OF TRACK GROUPS\nTGUTGPCT DS    CL7                 % OF TOTAL TRACK GROUPS\n         DS    CL1\nTGUACT   DS    CL4                 ACTIVE SYSTEM NAME\n         DS    CL10\nTGU$TGPS DS    CL8                 NUMBER OF TRACK GROUPS\nTGU$JOBS DS    CL8                 NUMBER OF JOBS W/TGPS\nTGU$PCT  DS    CL7                 % OF JOBS\n         ORG   QDMSG\n         DS    XL2                 TO SET SF=(PROT,PROT)\n         DS    CL6\nTGPTOTAL DS    CL8                 'TOTAL : '\nTGT#TGPS DS    CL8                 NUMBER OF TRACK GROUPS\nTGTTGPCT DS    CL7                 % OF TOTAL TRACK GROUPS\n         DS    CL15\nTGJTOTAL DS    CL8                 'TOTAL : '\nTGT$JOBS DS    CL8                 NUMBER OF JOBS W/TGPS\n         ORG   QDMSG\n         DC    CL80' '             SET OUTPUT LINE BUILD TO BLANKS\n         SPACE 1\nQDRLNG   DC    H'6'                REPLY LENGTH\nQDREPLY  DC    CL(QDREPLYL)'STATUS'     TERMINAL USER REPLY\nQDRLNGP  DC    H'6'                SAVE REPLY LENGTH\nQDPROMPT DC    CL(QDREPLYL)'STATUS'     HIS PREVIOUS COMMAND\nQDOVER   DC    X'00'               INDICATORS\nQOVPAGE  EQU   X'01'               PAGE OVERFLOW INDICATOR\nQPFORCE  EQU   X'02'               PAGE FORCE INDICATOR\nQESKIP   EQU   X'04'               END OF DATA SKIP INDICATOR\nQTSKIP   EQU   X'08'               TRANSLATE SKIP INDICATOR\nQAUTOM   EQU   X'10'               AUTOMATIC DISPLAY\nQAUTCMD  EQU   X'20'               AUTOMATIC DISPLAY ELIGIBILITY\nQDAMAGE  EQU   X'40'               DAMAGED CLOCKS\nQPROMPT  EQU   X'80'               REPROMPT HEADING LINE RESTORE\nQDPRSW   DC    X'00'               INDICATORS\nQAUTPIA  EQU   X'01'               PRESERVE INPUT AREA (AUTOMATIC)\nQRPVCMD  EQU   X'02'               RESTORE PREVIOUS SUB-COMMAND\nQDNEXT   DC    H'0'                CURRENT LINE NUMBER ON SCREEN\nQDSCREEN $FS   CC=W,MF=L           DISPLAY SCREEN\nQDSCRWCC $FS   WCC=(RMDT),SBA=(24,80),MF=L\n         $FS   SBA=(1,1),MF=L\n         SPACE 1\n*---     NOTE : THE FIRST DISPLAY FIELD IS PROT                    ---*\n*---            NORM FROM ATTR BYTE AT (2,80)                      ---*\n         SPACE 1\n         $FS   RA=(1,31,'-'),MF=L  RA TO (1,31) C'-'\n         $FS   SF=(PROT,INT),MF=L  ATTR - PROT BRIGHT\n         DC    C'QUEUE/SPOOL'      TITLE IN CENTER OF TOP LINE\n         $FS   SF=(PROT),MF=L      ATTR - PROT NORM\n         $FS   RA=(1,74,'-'),MF=L  RA TO (1,74) C'-'\n         $FS   SF=(PROT,INT),MF=L  ATTR - PROT BRIGHT\nQDMORE   DC    CL6' '              INDICATES MORE TO BE DISPLAYED\n         DC    C'COMMAND ===>'     SHOW HIM WHERE TO TYPE\n         $FS   SBA=(2,80),MF=L     SBA TO (2,80) - SKIP OVER INPUT\n         $FS   SF=(PROT,INT),MF=L  ATTR - PROT BRIGHT\n         SPACE 1\nQDHLINE  DS    0CL79               HEADING LINE\n         DS    CL34'JOB XXXXXXXX, DSID XXXXXXXX, REC #'\nHREC     DS    CL8\nHEND     DS    CL25', END OF DATA. LAST REC #'\nHREND    DS    CL8\n         ORG   QDHLINE\n         DC    CL79' '             SET HEADING LINE TO BLANKS\n         SPACE 1\n         $FS   SF=(PROT),MF=L      ATTR - PROT NORM\nQDLINE1  DC    CL80' '             FIRST MESSAGE LINE ON SCREEN\n         DC    20CL80' '           NEXT 20 LINES\nQDFINAL  $FS   SBA=(2,13),MF=L     SBA TO (2,13) - START OF INPUT\n         $FS   SF=NORMAL,MF=L      ATTR - INPUT NORM\nQDTLINE  DC    XL(QDREPLYL)'0'     INPUT AREA / LAST COMMAND\n         $FS   SBA=(1,1),SF=(PT,IC),MF=L\n*                                  PT TO FIRST INPUT FIELD; IC\n*                                  (TCAM REQUIRES CURSOR AT END)\nQDPAST   EQU   *                   POINTER TO PAST LAST CHAR\nQDSLNG   EQU   *-QDFINAL           LENGTH OF INPUT MANAGEMENT\n         SPACE 1\nQDHSAVE  DC    CL79' '             SAVE HEADING LINE ON REPROMPT\n         EJECT\nQCPFKSW  DC    X'00'               PF-KEYS SWITCHES\nPFDAAL   EQU   X'01'                    DATA-SET ALLOCATED\nPFDAOP   EQU   X'02'                    DATA-SET OPENED\nPFDAIN   EQU   X'04'                    DATA-SET UPDATE IN PLACE\nPFDAERR  EQU   X'10'                    I/O ERROR (SYNAD ENTERED)\nPFDAABN  EQU   X'20'                    DCB ABEND ENTERED\nPFLRERR  EQU   X'40'                    LRECL ERROR (OPEN EXIT)\nPFRFERR  EQU   X'80'                    RECFM ERROR (OPEN EXIT)\nQCPFMEM  DC    CL8' '              PF-KEYS MEMBER NAME\n         SPACE 1\n*---     DEFAULT PF-KEYS DEFINITIONS                               ---*\n         SPACE 1\nPFKTAB   DS    0XL26\n         DC    XL1'F1',CL25'H     '               PF1\n         DC    XL1'F2',CL25'*     '               PF2\n         DC    XL1'F3',CL25'E     '               PF3\n         DC    XL1'F4',CL25'DA    '               PF4\n         DC    XL1'F5',CL25'F     '               PF5\n         DC    XL1'F6',CL25'DI    '               PF6\n         DC    XL1'F7',CL25'-   21'               PF7\n         DC    XL1'F8',CL25'+   21'               PF8\n         DC    XL1'F9',CL25'DO    '               PF9\n         DC    XL1'7A',CL25'CO   1'               PF10\n         DC    XL1'7B',CL25'CO  41'               PF11\n         DC    XL1'7C',CL25'ST    '               PF12\n         DC    XL1'C1',CL25'H     '               PF13\n         DC    XL1'C2',CL25'*     '               PF14\n         DC    XL1'C3',CL25'E     '               PF15\n         DC    XL1'C4',CL25'DA    '               PF16\n         DC    XL1'C5',CL25'F     '               PF17\n         DC    XL1'C6',CL25'DI    '               PF18\n         DC    XL1'C7',CL25'-   21'               PF19\n         DC    XL1'C8',CL25'+   21'               PF20\n         DC    XL1'C9',CL25'DO    '               PF21\n         DC    XL1'4A',CL25'CO   1'               PF22\n         DC    XL1'4B',CL25'CO  41'               PF23\n         DC    XL1'4C',CL25'ST    '               PF24\nPFKTABL  EQU   *-PFKTAB\nPFKNO    EQU   (PFKTABL/L'PFKTAB)\nPFKSVL   EQU   ((PFKTABL+79)/80)*80\n         SPACE 1\nQCPFKOP  OPEN  (*-*,UPDAT),MF=L\nQCPFKCL  CLOSE (*-*),MF=L\nQCPFSV   DC    5F'0'               SYNAD SAVE AREA (R13-R1)\nQCSCCRC  DC    F'0'                SAVE ABEND CODES\n         SPACE 1\nQCPFKPO  DCB   DDNAME=QSP$PFK,DSORG=PO,MACRF=(R),EXLST=LSPFXLS\nQCPFKPOL EQU   *-QCPFKPO\nQCPFKPS  DCB   DDNAME=QSP$PFK,DSORG=PS,MACRF=(R,W),                    1\n               EXLST=LSPFXLS,SYNAD=LSPFERR,EODAD=LSPFEND\n         READ  QCPDECB,SF,,,'S',MF=L\nQCPFKPSL EQU   *-QCPFKPS\n         SPACE 1\nQLDIS    EQU   *-QDISPLAY -------- USING LIMIT FOR QDISPLAY ----------*\n         EJECT\n*---     CHECKPOINT WORK AREAS                                     ---*\n         SPACE 1\nQCKPT    DS    0D\nQCDECBPT DC    A(0)                @ DECB WORK AREA FOR CKPT ROUTINE\n         SPACE 1\nQCJQECA  DC    A(0)                ADDR CURRENT JQE (SELECTED JOB)\nQCTRAK   DS    0F                  DISK ADDR IN THE FORM MTTR\nQCTRAKM  DC    XL1'0'              EXTENT NUMBER\nQCTRAKTT DC    XL2'0'              ABSOLUTE TRACK NUMBER\nQCTRAKR  DC    XL1'0'              RECORD NUMBER\n         DC    X'0'                EXTRA SPACE NEEDED FOR HEX CONV\nQCDAD    DS    0XL8                DISK ADDR IN THE FORM MBBCCHHR\nQCDADM   DC    XL1'0'              EXTENT NUMBER\nQCDADBB  DC    XL2'0'              BIN NUMBER\nQCDADCC  DC    XL2'0'              CYLINDER NUMBER\nQCDADHH  DC    XL2'0'              HEAD NUMBER\nQCDADR   DC    XL1'0'              RECORD NUMBER\n         DC    XL3'0'              DEAD SPACE TO GET BACK TO FW\n         DS    0F\nQCCREC   DC    PL4'0'              CURRENT RECORD NUMBER\nQCCPTR   DC    A(0)                CURRENT TABLE ADDRESS\nQCHREC   DC    PL4'0'              HIGHEST RECORD NUMBER\nQCHPTR   DC    A(0)                HIGHEST TABLE ADDRESS\nQCSTART  DC    A(0)                ADDRESS OF TABLE START\nQCEND    DC    A(0)                ADDRESS OF TABLE END\nQCHLINE  DS    0CL80               HEADING LINE FOR LISTDS\n         DC    C'JOB '\nQCJNAME  DC    CL8' '              JOB NAME\n         DC    C'  DSID '\nQCDSNO   DC    CL8' '              DATA-SET ID NUMBER\n         DC    C'  REC #       1'\n         DC    CL40' '\nQCLRECL  DC    H'0'                LRECL FOR SAVE\nQCRECFM  DC    XL1'0'              RECFM FOR SAVE\n         SPACE 1\nSWCKPT   DC    XL1'0'              CHECKPOINT SWITCHES PROCESSING\nSWCKPTMR EQU   X'01'               READ MASTER RECORD ONLY\nSWCKPTDA EQU   X'02'               READ DAS RECORDS ONLY\nQCSPOPNL DC    F'0'                @ OF DCB OPEN LIST FOR HASPACE(S)\nQCSPDCBP DC    F'0'                @ OF DCB PTRS INDEX BY M*4 (MTTR)\nQCSPNMTC DC    F'0'                @ OF # TRK/CYL FOR HASPACE(S)\n         EJECT\n*---     DAIR WORK AREAS                                           ---*\n*---     DATA-SET ALLOCATION FIELDS                                ---*\n*---     (ADAPTED FROM SYS1.MACLIB (IKJDAPL,IKJDAP08,18))          ---*\n         SPACE 1\nDAIRDWD  DC    D'0'\nDAIRECB  DC    F'0'                ECB USED BY DAIR\nDAIRFLAG DC    XL1'0'              FLAGS FOR ALLOCATE SUBROUTINE\nDFALLOC  EQU   X'80'                    ALLOCATE FUNCTION\nDFFREE   EQU   X'40'                    FREE FUNCTION\nDFABORT  EQU   X'01'                    FREE FUNCTION\n         DC    XL3'0'              DEAD SPACE FOR ALLIGNMENT\n         SPACE 1\n*---     THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR)           ---*\n*---     PARAMETER LIST (DAPL) IS A LIST OF ADDRESSES PASSED       ---*\n*---     FROM THE INVOKER TO DAIR VIA REGISTER 1                   ---*\n         SPACE 1\nDAPLUPT  DC    A(0)                PTR TO UPT\nDAPLECT  DC    A(0)                PTR TO ECT\nDAPLECB  DC    A(0)                PTR TO CP'S ECB\nDAPLPSCB DC    A(0)                PTR TO PSCB\nDAPLDAPB DC    A(0)                PTR TO DAIR PARAMETER BLOCK\n         SPACE 1\n*---     DAIR FAILURE PARAMETER LIST                               ---*\n         SPACE 1\nDFDAPLP  DC    A(0)\nDFRCP    DC    A(0)\nDFJEFF02 DC    A(0)\nDFIDP    DC    A(0)\n         SPACE 1\nDFRETC   DC    F'0'\nDFZERO   DC    F'0'\nDFDASW   DC    0H'0',X'0001'\n         EJECT\n*---     ALLOCATE DDNAME(W) DSNAME(X) SHR UNIT(Y) VOLUME(Z)        ---*\n         SPACE 1\nDAALCD   DS    0F                  ALLOCATE PARM. LIST\n         DC    X'0008'             DAIR ENTRY CODE\nDAALFLG  DC    XL1'0'              FLAGS SET BY DAIR\n         DC    X'0'\nDAALDARC DC    H'0'                DYN ALLOC RETURN CODE\nDAALCTRC DC    H'0'                CATALOG RETURN CODE\nDAALPDSN DC    A(0)                PTR TO DSN TO BE SRCHED IN DSE\nDAALDDN  DC    CL8' '              DDNAME TO BE SEARCHED IN DSE\nDAALUNIT DC    CL8' '              UNIT FOR SYS1.HASPCKPT\nDAALSER  DC    CL8' '              VOLSER FOR SYS1.HASPCKPT\nDAALBLK  DC    F'0'                DATA-SET AVERAGE REC LENGTH\nDAALPQTY DC    F'0'                PRIMARY SPACE QUANTITY\nDAALSQTY DC    F'0'                SECONDARY SPACE QUANTITY\nDAALDQTY DC    F'0'                DIRECTORY BLOCK QUANTITY\nDAALMNM  DC    CL8' '              MEMBER NAME\nDAALPSWD DC    CL8' '              PASSWORD\nDAALDSP1 DC    AL1(DA08SHR)        STATUS FLAGS - SHR\nDAALDPS2 DC    AL1(DA08KEEP)       DATA-SET DISPOSITION - KEEP\nDAALDPS3 DC    AL1(DA08KEP)        DATA-SET COND. DISP. - KEEP\nDAALCTL  DC    X'00'               DAIR ACTION FLAGS\n         DC    XL3'0'              RESERVED\nDAALDSO  DC    XL1'0'              DSORG\nDAALALN  DC    CL8' '              ATTR-LIST-NAME\nDAAL$L   EQU   *-DAALUNIT\n         SPACE 1\n*---     FREE DDNAME(W)                                            ---*\n         SPACE 1\nDAFRCD   DS    0F                  FREE PARM. LIST\n         DC    X'0018'             DAIR ENTRY CODE\nDAFRFLG  DC    XL1'0'              FLAGS SET BY DAIR\n         DC    X'0'\nDAFRDARC DC    H'0'                DYNAMIC ALLOCATION RETURN CODE\nDAFRCTRC DC    H'0'                CATALOG RETURN CODE AREA\nDAFRPDSN DC    A(0)                PTR TO DSN TO BE SRCHED IN DSE\nDAFRDDN  DC    CL8' '              DDNAME TO BE SEARCHED IN DSE\nDAFRMNM  DC    CL8' '              MEMBER NAME\nDAFRSCLS DC    CL2' '              SYSOUT CLASS DESIRED WHEN\n*                                  UNALLOC'ING A SYSOUT DATA-SET\nDAFRDPS2 DC    AL1(DA18KEEP)       DATA-SET DISPOSITION - KEEP\nDAFRCTL  DC    AL1(DA18PERM)       FLAGS FOR SPECIAL DAIR PROC'ING\nDAFRJBNM DC    CL8' '              IGNORED AS OF OS VS/2 RELEASE 2\n         EJECT\n*---     TRACK GROUPS JOBS USAGE WORK AREAS                        ---*\n         SPACE 1\nTGTTGPS  DC    F'0'                TOTAL TRACK GROUPS ALLOCATED\nTGTJOBS  DC    F'0'                TOTAL NUMBER OF JOBS PROCESSED\nTGJQAR   DC    XL(20*8)'0'         20 ENTRIES (JQEADDR, #TGPS)\nTGPSAR   DS    0XL(20*8)           20 ENTRIES (# TGPS, # JOBS)\n         DC    0F'0',XL4'7FFFFFFF',F'0'\n         DC    F'150',F'0'\n         DC    F'100',F'0'\n         DC    F'80',F'0'\n         DC    F'60',F'0'\n         DC    F'50',F'0'\n         DC    F'40',F'0'\n         DC    F'30',F'0'\n         DC    F'20',F'0'\n         DC    F'15',F'0'\n         DC    F'10',F'0'\n         DC    F'9',F'0'\n         DC    F'8',F'0'\n         DC    F'7',F'0'\n         DC    F'6',F'0'\n         DC    F'5',F'0'\n         DC    F'4',F'0'\n         DC    F'3',F'0'\n         DC    F'2',F'0'\n         DC    F'1',F'0'\n         SPACE 1\nQLCKT    EQU   *-QCKPT ----------- USING LIMIT FOR QCKPT -------------*\n         EJECT\n*---     SNAP WORK AREAS                                           ---*\n         SPACE 1\nQSNAP    DS    0F\n         SPACE 1\nSNAPDCB  DCB   DSORG=PS,RECFM=VBA,MACRF=(W),                           1\n               BLKSIZE=1632,LRECL=125,DDNAME=SYSSNAP\nSNAPOP   OPEN  (*-*),MF=L\nSNAPCL   CLOSE (*-*),MF=L\n         SPACE 1\nSNAPCTL  SNAP  MF=L\nSNAPLST  DC    2F'0'\nSNAPHD   DC    F'0'\n         SPACE 1\nSNAPIDT  DC    XL32'0'             SNAP ID ACTIVE TABLE\n         SPACE 1\nQSNAPL   EQU   *-QSNAP             SNAP WORK AREAS LENGTH\n         SPACE 1\nQLSNP    EQU   *-QSNAP ----------- USING LIMIT FOR QSNAP -------------*\n         EJECT\n*---     HARDCOPY WORK AREAS                                       ---*\n         SPACE 1\nQPRINT   DS    0F\n         SPACE 1\nP99RBPTR DC    A(*-*)              SVC 99 REQUEST BLOCK PTR\nP99RB    DS    0F                  SVC 99 REQUEST BLOCK\n         DC    AL1(P99RBLN)             RB LENGTH IN BYTES\nP99VERB  DC    AL1(S99VRBAL)            VERB CODE (DSNAME ALL.)\nP99FLAG1 DC    AL1(S99NOCNV+S99NOMNT,0) FLAGS 1\nP99ERROR DC    XL2'0'                   ERROR CODE\nP99INFO  DC    XL2'0'                   INFO CODE\nP99TXTPP DC    A(*-*)                   POINTER TO TEXT UNIT PTRS\nP99RSVD1 DC    XL4'0'                   RESERVED\nP99FLAG2 DC    XL4'0'                   FLAGS 2\nP99RBLN  EQU   *-P99RB                  RB LENGTH\nP99TUPL  DS    0F                  TEXT UNIT POINTERS\n         DC    A(*-*)                   SYSOUT\n         DC    A(*-*)                   FREE AT CLOSE\n         DC    A(*-*)                   LAST PARM IF NO DEST=\n         DC    A(*-*)                   LAST PARM IF DEST= GIVEN\nP99TUKY1 DC    AL2(DALSYSOU),AL2(1),AL2(1)\nP99SYSOC DC    C'A'                     SYSOUT=A\nP99TUKY2 DC    AL2(DALCLOSE),AL2(0)     UNALLOC AT CLOSE\nP99TUKY3 DC    AL2(DALSUSER),AL2(1)     OPTIONAL : DEST=RMTXXX\nP99DESTL DC    AL2(*-*)                 LENGTH OF DEST\nP99DEST  DC    CL8' '                   DEST PARAMETER\nP99TUKY4 DC    AL2(DALRTDDN),AL2(1)     DDNAME RETURN\nP99DDNL  DC    AL2(8)                   LENGTH OF DDNAME\nP99DDN   DC    CL8' '                   DDNAME\n         SPACE 1\nHCPYDCB  DCB   DDNAME=QSPHCOPY,DSORG=PS,MACRF=(PM),                    1\n               RECFM=FA,LRECL=91,BLKSIZE=91\nHCPYOP   OPEN  (*-*),MF=L\nHCPYCL   CLOSE (*-*),MF=L\n         SPACE 1\nBINYEAR  DC    F'0'\nBINDAYS  DC    F'0'\nBINDATE  DC    F'0'\nQHPAGE#  DC    PL3'+1'             PAGE NUMBER\nQHLINE#  DC    PL3'+0'             LINES COUNT\nHMONMSK  DC    AL1(31,30,31,30,31,31,30,31,30,31,28,31)\n         SPACE 1\nQHHEAD1  DC    CL1'1',CL10' '      ASA ON HEADING\n         DC    CL23'QSP-HARDCOPY LOG  USER='\nQHUSER   DC    CL7' ',CL2' '       FOR USERID\n         DC    CL4'DATE'\nHJDATE   DC    CL7' ',CL3' - '\nHTMEHRS  DC    CL2' ',CL1':'\nHTMMINS  DC    CL2' ',CL1':'\nHTMSECS  DC    CL2' ',CL1' '\nHCDAY    DC    CL3' ',CL1' '\nHCMON    DC    CL3' ',CL1' '\nHCDAYN   DC    CL2' ',CL3',19'\nHCYR     DC    CL2' ',CL1' '\nQHPAGS   DC    CL1' ',CL2'  '\nQHPAGE   DC    CL6' '\n         SPACE 1\nQHHEAD2  DC    CL1' ',CL10' ',80C'-'\n         SPACE 1\nQHDETAIL DC    CL1' ',CL10' '      ASA CONTROL CHARACTER\nQHLINE   DC    CL80' '             TO HOLD PRINT LINE\n         SPACE 1\nQPRINTL  EQU   *-QPRINT            HARDCOPY WORK AREAS LENGTH\n         SPACE 1\nQLPRT    EQU   *-QPRINT ---------- USING LIMIT FOR QPRINT ------------*\n         SPACE 1\n         CNOP  0,8\n         SPACE 1\nQCOMMONL EQU   *-QCOMMON --------- LENGTH OF COMMON AREA --------------\n         SPACE 1\nQWAREAL  EQU   QCOMMONL+WASSZ      ADD SPACE WORK AREA\n         TITLE '--- QUEUE/SP -- MISCELLANEOUS DSECTS ---'\n*---     TSO COMMANDS/CLIST WORK AREA                              ---*\n         SPACE 1\nTSOXEQ   DSECT\n         SPACE 1\nGTPBK    GETLINE MF=L\nGTPBLN   EQU   *-GTPBK             LENGTH\n         SPACE 1\nATTCH    ATTACH  SHSPV=78,SF=L     NEEDED TO PREVENT S305 ABENDS\nATTLN    EQU   *-ATTCH             LENGTH\n         SPACE 1\nTSOXTCB  DS    F                   TCB\nTSOXECB  DS    F                   ECB\nTSOCPPL  DS    4F                  CPPL\nTSOIOPL  DS    4F                  GETLINE I/O PARM LIST\nTSOCSPL  DS    6F                  IKJSCAN PARM LIST\nTSOCSOA  DS    2F                  OUTPUT AREA FROM IKJSCAN\n         SPACE 1\nTSOBLDL  DS    0XL16               BLDL LIST\nTSOBLFF  DS    H                   NUMBER OF ENTRIES IN LIST\nTSOBLLL  DS    H                   LENGTH OF EACH ENTRY\nTSOBLNM  DS    CL8                 MEMBER NAME\nTSOBLTTR DS    XL3                 TTR OF MEMBER START\nTSOBLLK  DS    XL1                 CONCATENATION NUMBER\n         SPACE 1\nTSORSV   DS    2F                  R0-R1 MESSAGE PENDING\nTSOPCMD  DS    CL8                 PRIMARY COMMAND NAME\nTSOSCMD  DS    CL8                 SECONDARY COMMAND NAME\nTSOXCMD  DS    CL84                COMMAND BUFFER\nTSOMSG   DS    CL78                MESSAGE BUFFER\n         SPACE 1\n         CNOP  0,8\nTSOXEQL  EQU   *-TSOXEQ            LENGTH\n         SPACE 1\nCMDBUF   DSECT\nCMDLEN   DS    H                   LENGTH, INCLUDES HEADER (+4)\nCMDOFF   DS    H                   OFFSET TO NON-BLANK PAST CMD\nCMDTEXT  DS    C                   FIRST TEXT BYTE\n         SPACE 1\n         EJECT\n*---     INPUT WORK AREA                                           ---*\n         SPACE 1\nIN       DSECT\nI1       DS    CL8\nI2       DS    CL8\nI3       DS    CL8\nI4       DS    CL8\nI5       DS    CL8\nI6       DS    CL8\nI7       DS    CL8\nI8       DS    CL8\n         SPACE 1\n*---     OUTPUT WORK AREA                                          ---*\n         SPACE 1\nOUT      DSECT\nOLINE1   DS    0CL80\nHBOFFSET DS    CL4\n         DS    CL2\nODATA1   DS    0CL74\nO11      DS    CL8\n         DS    C\nO12      DS    CL8\n         DS    CL2\nO13      DS    CL8\n         DS    C\nO14      DS    CL8\n         DS    CL2\nO15      DS    CL8\n         DS    C\nO16      DS    CL8\n         DS    CL2\nO17      DS    CL8\n         DS    C\nO18      DS    CL8\nOLINE2   DS    0CL80\n         DS    CL6\nODATA2   DS    0CL74\nO21      DS    CL8\n         DS    C\nO22      DS    CL8\n         DS    CL2\nO23      DS    CL8\n         DS    C\nO24      DS    CL8\n         DS    CL2\nO25      DS    CL8\n         DS    C\nO26      DS    CL8\n         DS    CL2\nO27      DS    CL8\n         DS    C\nO28      DS    CL8\nOLINE3   DS    0CL80\n         DS    CL6\nODATA3   DS    0CL74\nO31      DS    CL8\n         DS    C\nO32      DS    CL8\n         DS    CL2\nO33      DS    CL8\n         DS    C\nO34      DS    CL8\n         DS    CL2\nO35      DS    CL8\n         DS    C\nO36      DS    CL8\n         DS    CL2\nO37      DS    CL8\n         DS    C\nO38      DS    CL8\n         EJECT\nJQTDSECT DSECT ,  - - - - - - SEE $QINDEX IN HASPTABS FOR MORE DETAILS\n         SPACE 1\n         ORG   JQTDSECT+8\nJQTOUT   DC    A(0)\n         SPACE 1\n         ORG   JQTDSECT+32\nJQTSTC   DC    A(0)\n         SPACE 1\n         ORG   JQTDSECT+36\nJQTTSU   DC    A(0)\n         SPACE 1\n         ORG   JQTDSECT+40\nJQTCLSA  DC    A(0)\n         SPACE 1\n         PRINT NOGEN\n         SPACE 1\n         $TEW$DS CVT=YES\n         IHAPSA\n         IHAASCB\nUCBDSECT DSECT\n         IEFUCBOB\n         IKJECT\n         IKJCSPL\n         IKJCSOA\n         IKJGTPB\n         IKJDAP08\n         IKJDAP18\n         IEFVKEYS\n         IEFZB4D0\n         IEFZB4D2\n         DCBD  DSORG=(PS,DA)\n         IHADECB\n         IEFJESCT TYPE=DSECT\n         IEFJSCVT\n         $PIT\n         IEZDEB\n         $SJB\n         $TQE\n         $XECB\n         $SCAT\n         $SVT\n         $HFAME\n         SPACE 1\n         PRINT GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QSP$": {"ttr": 32005, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15H\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:48:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SYSPAJA"}, "text": "//QSP      JOB (........),'INSTALL  - QUEUE -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=14\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* NOTES : 1. YOU MUST FIX THE VALUE OF THE VARIABLE \"NCTETENT\" (SEE *\n//*            MODULE HASPIRDA) IN THE SOURCE OF QSP MODULE BEFORE    *\n//*            ASSEMBLY (YOU MAY ALSO QUICKLY ZAP IT AFTER).          *\n//*         2. A LOCAL JES2 MODIFICATION FORCES OUR USERS TO DECLARE  *\n//*            AN ESTIMATED NUMBER OF I/O IN THOUSANDS OF THEIR JOBS. *\n//*            THIS INFORMATION IS PLACED IN THE JCTUSER0 FIELD AND   *\n//*            BY QSP. AN EASY WAY TO SUPPRESS IT IS TO REPLACE IN    *\n//*            THE SOURCE OF QSP MODULE THE \" L     R1,JCTUSER0 \"     *\n//*            INSTRUCTION BY A \" XR    R1,R1 \" INSTRUCTION.          *\n//*         3. WE HAVE INSTALL THE CJS (CHAINED JOBS SCHEDULING, PP   *\n//*            5785-GAK) AND OUR SMF \"IEFUJV\" EXIT ROUTINE PLACE THE  *\n//*            NET-ID NAME IN THE JCTUSER1 AND JCTUSER2 FIELDS, WHICH *\n//*            ARE DISPLAYED BY QSP. THIS CODING IS INSERTED WHEN     *\n//*            SPECIFYING OPT=',SYSPARM(CJS)' AT ASSEMBLY STEP 'ASSQ'.*\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASSQ    EXEC PAJ4AS4,MBR=QSP\n//ASSQH   EXEC PAJ4AS1,MBR=QSPHELP\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   QUEUE\n  SETCODE AC(1)\n  NAME    QSP(R)\n/*\n//HLP     EXEC PAJHELP,MBR=QSPH,DSS='->.SOURCE.FILE4'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QSP@": {"ttr": 32007, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x14R\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T14:52:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "SYSPAJA"}, "text": "1   17/11/87\n                                                      QSP       1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     TSO : QUEUE/SPOOL ANALYZER      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   The QSP command is used to interrogete the system queues\n  ----------   in order to determine the status of a job or group of\n               jobs. It also provides access to all parts of a job\n               while it is on the SPOOL queue.\n\n  Command :    Syntax : QSP <SUBCMD>\n  ---------             where <SUBCMD> is a subcommand to be executed\n                        when entering. If omitted, the status of all\n                        the jobs for current session USER-id (LOGON\n                        id) is displayed.\n                        For more information about the available\n                        sub-commands, type in \"QSP HELP\".\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QSPH": {"ttr": 32009, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x875/\\x00\\x875/\\x10I\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-12-18T00:00:00", "modifydate": "1987-12-18T10:49:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=QSP\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  THE QSP COMMAND IS USED TO INTERROGATE THE SYSTEM QUEUES\n               IN ORDER TO DETERMINE THE STATUS OF A JOB OR GROUP OF\n               JOBS. IT ALSO PROVIDES ACCESS TO ALL PARTS OF A JOB\n               WHILE IT IS ON THE SPOOL QUEUE.\n)X SYNTAX :    QSP S-CMD\n               DEFAULT : \"STATUS\" SUB-COMMAND.\n)O OPERANDS :\n))S-CMD :      A SUB-COMMAND TO BE EXECUTED AS ENTERING.\n               IF OMITED, THE STATUS OF ALL THE JOBS FOR THE CURRENT\n               SESSION USER-ID (LOGON-ID) IS DISPLAYED.\n               FOR MORE INFORMATION ABOUT THE AVAILABLE SUB-COMMANDS,\n               TYPE IN \"QSP HELP\".\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QSPHELP": {"ttr": 32011, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89$?\\x00\\x89$?\\x17\\x12\\x01#\\x01#\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-08-31T00:00:00", "modifydate": "1989-08-31T17:12:00", "lines": 291, "newlines": 291, "modlines": 0, "user": "SYSPAJA"}, "text": "QSPH     TITLE '--- QUEUE/SP -- HELP -- HELP PANELS DATA ---'\n         PRINT OFF\n         MACRO\n&NAME    $     &TEXT,&LEN\n         AIF   ('&LEN' EQ '').L80\n&NAME    DC    CL&LEN&TEXT\n         MEXIT\n.L80     ANOP\n&NAME    DC    CL80&TEXT\n         MEND\n         MACRO\n&NAME    $PFLOC &LOC,&SHIFT\n         LCLA  &L,&N\n&L       SETA  &LOC\n&N       SETA  1\n         AIF   ('&NAME' EQ '').A\n&NAME    DS    0H\n.A       DC    AL2(&L)\n         AIF   (&N EQ 12).B\n&N       SETA  &N+1\n&L       SETA  &L+80\n         AGO   .A\n.B       ANOP\n&L       SETA  &LOC+&SHIFT\n&N       SETA  1\n.C       DC    AL2(&L)\n         AIF   (&N EQ 12).D\n&N       SETA  &N+1\n&L       SETA  &L+80\n         AGO   .C\n.D       MEND\n         PRINT ON\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* HELP : HELP COMMAND DATA (DISPLAY HELP PANELS INFORMATION)          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nQSPHELP  START 0\n         SPACE 1\n*        VECTOR OF POINTERS TO HELP PANELS DATA.\n*        ---------------------------------------\n         SPACE 1\n         DC    CL2'Q ',AL4(HELPQ)       QUEUE/SPOOL\n         DC    CL2'QN',AL4(HELPQN)      QUEUE/SPOOL NOTES\n         DC    CL2'J ',AL4(HELPJ)       JOBS DATA-SETS\n         DC    CL2'JN',AL4(HELPJN)      JOBS DATA-SETS NOTES\n         DC    CL2'E ',AL4(HELPE)       EXTENDED SERVICES\n         DC    CL2'O ',AL4(HELPO)       OPERATOR SERVICES\n         DC    CL2'D ',AL4(HELPD)       PRIVILEGED\n         DC    CL2'PN',AL4(HELPPN)      SET PF-KEYS SERVICES\n         DC    CL2'P ',AL4(HELPP)       PF-KEYS DISPLAY\n         DC    H'0'                     END OF VECTOR\n         SPACE 1\n*        PF-KEYS PANEL DISPLACEMENTS TO STORE VALUES.\n         SPACE 1\n         $PFLOC 94,36         DISPLACEMENTS FROM 'HELPSP'\n         SPACE 1\n         PRINT NOGEN\n         EJECT\nHELPQ    $     'QUEUE/SPOOL Subcommands (HELP Q) :',79\n         DC    0H'0',AL2(HELPLQ)\nHELPSQ   DC    CL4' '              INDENT THE FOLLOWING 4 SPACES\n $ 'STATUS <level> - Display all jobs beginning with <level>.'\n $ 'DA             - Display all jobs in execution.'\n $ 'DI     <class> - Display all jobs in input <class>.'\n $ 'DO     <class> - Display all jobs in output <class>.'\n $ 'DL     <class> - Display all jobs in local output <class>.'\n $ 'DR     <class> - Display all jobs in remote output <class>.'\n $ 'AI     <class> - Display jobs available for processing in <class>.'\n $ 'AO     <class> - Display jobs available for printing/punching in <c1\n               lass>.'\n $ 'HI     <class> - Display held jobs in input <class>.'\n $ 'HO             - Display held output jobs.'\n $ 'DJ     <jobid> - Display job by job-name or job-number.'\n $ 'DT             - Display TSO users.'\n $ 'DS             - Display SYSTEM tasks.'\n $ 'QI             - Display summary of input queues.'\n $ 'QO             - Display summary of output queues.'\n $ ' ',76\n $ 'E, END, EXIT or STOP : Terminate processing.'\nHELPLQ   EQU   *-HELPSQ\n         EJECT\nHELPQN   $     'QUEUE/SPOOL subcommands notes (HELP QN) :',79\n         DC    0H'0',AL2(HELPLQN)\nHELPSQN  DC    CL4' '              INDENT THE FOLLOWING 4 SPACES\n $ '<level>  is job-name prefix, default is LOGON ID.'\n $ '         A <level> of * indicates use the LOGON ID.'\n $ '<class>  is a valib job class, default is all classes.'\n $ '<jobid>  is job-name or job-number, no default is supplied.'\n $ '         A <jobid> of * indicates use previously entered <jobid>.'\n $ ' ',76\n $ 'NOTES : - When you see *MORE* in the upper right-hand corner of the1\n                screen, it'\n $ '          means that more information is waiting. You may either hi1\n               t ENTER to'\n $ '          view it, or enter a new subcommand to skip it.'\n $ '        - A help panel can be directly viewed using his specific HE1\n               LP (or H)'\n $ '          subcommand.'\nHELPLQN  EQU   *-HELPSQN\n         EJECT\nHELPJ    $     'Jobs DATA-SETS subcommands (HELP J) :',79\n         DC    0H'0',AL2(HELPLJ)\nHELPSJ   DC    CL4' '              INDENT THE FOLLOWING 4 SPACES\n $ 'JCL    <jobid>        - List JCL for a job.'\n $ 'JLOG   <jobid>        - List JOBLOG for a job (only on output queue1\n               ).'\n $ 'JMSG   <jobid>        - List SYSTEM messages for a job.'\n $ 'DD     <jobid>        - List SYSIN and SYSOUT data-sets for a job.'\n $ 'LIST   <jobid> <dsid> - List a SYSIN or SYSOUT data-set.'\n $ 'FIND   <string>       - Find a character string in a data-set.'\n $ 'FALL   <string>       - Find all occurrences of <string>.'\n $ 'COLUMN <col>          - Reposition horizontally to column <col>.'\n $ '@      <#>            - Reposition to specific record number.'\n $ '+      <#>            - Reposition forward in data-set <#> records.1\n                '\n $ '-      <#>            - Reposition backward in data-set <#> records1\n               .'\n $ 'TOP                   - Reposition to top of data-set.'\n $ 'BOTTOM                - Reposition to bottom of data-set.'\n $ '*                     - Re-prompt with previous command.'\n $ ' ',76\nHELPLJ   EQU   *-HELPSJ\n         EJECT\nHELPJN   $     'Jobs DATA-SETS subcommands notes (HELP JN) :',79\n         DC    0H'0',AL2(HELPLJN)\nHELPSJN  DC    CL4' '              INDENT THE FOLLOWING 4 SPACES\n $ '<jobid>  is job-name or job-number, no default is supplied.'\n $ '         A <jobid> of * indicates use previously entered <jobid>.'\n $ '<dsid>   is data-set ID number (it can be determined by using the D1\n               D'\n $ '         subcommand).'\n $ '<string> is search string, delimited by any same CHAR at each end.'\n $ '<col>    default is column 1.'\n $ '<#>      default is 0.'\n $ ' ',76\n $ 'Following is a list of synonyms :'\n $ '    LIST or L      FIND or F      COLUMN or C    + or D'\n $ '    - or UP        TOP or T       BOTTOM or B'\nHELPLJN  EQU   *-HELPSJN\n         EJECT\nHELPE    $     'EXTENDED SERVICES subcommands (HELP E) :',79\n         DC    0H'0',AL2(HELPLE)\nHELPSE   DC    CL4' '              INDENT THE FOLLOWING 4 SPACES\n $ 'SLOG  <job#> <seq>    - List the SYSTEM LOG data-set.'\n $ 'FTIME <time>          - Reposition SYSTEM LOG to given time.'\n $ 'SAVE  <dsname> <disp> - Create a copy of the current data-set.'\n $ 'TSO   <TSOcmd>        - Issue a TSO command or CLIST (alias : TSO, 1\n               :).'\n $ 'TD    <opt>           - Display TSO commands non-zero R.C.'\n $ 'PRINT ON <cl> <dest>  - Start the HARDCOPY function (alias : PRINT,1\n                P).'\n $ 'PRINT OFF             - Stop the HARDCOPY function (default).'\n $ ' ',76\n $ '<job#>   may be determined by STATUS SYSLOG.'\n $ '<seq>    defaults to 0 (the current SYSLOG data-set), use a value o1\n               f 1, 2,'\n $ '         3, ... to obtain previous data-sets.'\n $ '<time>   is in the form HH.MM.SS.'\n $ '<dsname> will be expanded to USERID.<dsname>.OUTLIST.'\n $ '<disp>   is OLD/MOD/NEW/NORLSE (default is NEW and assume RLSE, NOR1\n               LSE is new'\n $ '         with unused space not released).'\n $ '<TSOcmd> may be a command or a CLIST (implicit form only, and the w1\n               ord EXEC or'\n $ '         EX may preceed it).'\n $ '<opt>    may be OFF, ON or FULL.'\n $ '<cl>     is the SYSOUT class for HARDCOPY (default is A).'\n $ '<dest>   is a JES2 destination for HARDCOPY (default is LOCAL).'\nHELPLE   EQU   *-HELPSE\n         EJECT\nHELPO    $     'OPERATOR SERVICES subcommands (HELP O) :',79\n         DC    0H'0',AL2(HELPLO)\nHELPSO   DC    CL4' '              INDENT THE FOLLOWING 4 SPACES\n $ 'ID                - JES2 running initiators status display.'\n $ 'TG                - Track groups jobs usage. The panel left side is1\n                a list'\n $ '                    of the top 20 jobs with most track groups (spoo1\n               l space),'\n $ '                    and the right side shows all jobs distribution 1\n               into 20'\n $ '                    categories of track groups allocation.'\n $ 'YA <sec> T        - Enable AUTOMATIC MODE (sec : continuous display1\n                time'\n $ '                    interval expressed in seconds). Default for <se1\n               c> is'\n $ '                    60 seconds. The acceptable lower and upper limi1\n               ts values'\n $ '                    for <sec> are 2 sec and 300 sec (5 min) respect1\n               ively.'\n $ '                    T is for TRACE use (id=1, just once).'\n $ 'ZA                - Disable AUTOMATIC MODE.'\n $ ' ',76\n $ 'NOTES : - The AUTOMATIC MODE CONTROL (continuous display) is active1\n                only with'\n $ '          a QUEUE/SPOOL subcommand (it is suspended during executio1\n               n of any'\n $ '          other subcommand type).'\n $ '        - The HARDCOPY function is inactive during AUTOMATIC MODE C1\n               ONTROL,'\n $ '          unless this is suspended.'\nHELPLO   EQU   *-HELPSO\n         EJECT\nHELPD    $     'PRIVILEGED subcommands - DEBUG use (HELP D) :',79\n         DC    0H'0',AL2(HELPLD)\nHELPSD   DC    CL4' '              INDENT THE FOLLOWING 4 SPACES\n $ 'XE <opt>          - Set dump extended format (opt=ON/OFF).'\n $ 'XB <MTTR>         - Display block from SYS1.HASPACE.'\n $ 'XP PASSWORD       - Allow PRIVILEGED authority.'\n $ '                    (You are prompted to supply the password)'\n $ 'XP RESET          - Reset PRIVILEGED authority.'\n $ 'XQ                - Display all JQEs queues.'\n $ 'XQ <jobid>        - Unrestricted display of JQEs for a job.'\n $ 'XO <jobid>        - Unrestricted display of JOEs for a job.'\n $ 'XJ <jobid>        - Display uninterpreted JQEs and JOEs for a job.'\n $ 'LP <jobid> <dsid> - List all PDDBs or dump specific <dsid> PDDBs fo1\n               r a job.'\n $ 'XL <jobid> <dsid> - Unrestricted display of a data-set for a job.'\n $ 'XT                - Display some control blocks.'\n $ 'YT <id> <opt>     - Set TRACE id (default id=1, max=255) : active (1\n               opt=ON)'\n $ '                    or inactive (opt=OFF, default). 1-127 : execute1\n               d once.'\n $ 'YT S              - Stop (reset) all TRACE activities.'\n $ 'YT I              - TRACE status re-initialization.'\n $ ' ',76\n $ 'NOTE : The TRACE feature needs SYSSNAP pre-allocated.'\nHELPLD   EQU   *-HELPSD\n         EJECT\nHELPPN   $     'QUEUE/SPOOL set PF-keys services (HELP PN) :',79\n         DC    0H'0',AL2(HELPLPN)\nHELPSPN  DC    CL4' '              INDENT THE FOLLOWING 4 SPACES\n $ 'PF or PFK : display all PF-keys current definitions.'\n $ 'PF or PFK nn ...sub-command... : redefine value of PF-key nn (1-24)1\n               .'\n $ 'PZ : restore all original PF-keys definitions.'\n $ 'PS <A> <B> <M> : save in member M of the data-set named USERID.A.B 1\n               all'\n $ '                 the current PF-keys definitions.'\n $ 'PL <A> <B> <M> : restore from member M of the data-set named USERID1\n               .A.B'\n $ '                 all PF-keys definitions.'\n $ ' '\n $ 'where <A> is the first part of the data-set name (default is SPF),'\n $ '      <B> is the last part of the data-set name (default is PROF),'\n $ '      <M> is the member name (default is QSPPROF).'\n $ ' ',76\n $ 'NOTES : - <A>, <B> and <M> defaults must be indicated by a minus si1\n               gn (-)'\n $ '          if followed by a parameter, otherwise you may omit it, as1\n                i.e. :'\n $ '                 PS  -  -  ZULU : means to USERID.SPF.PROF(ZULU)'\n $ '                 PL  TEST  DATA : means from USERID.TEST.DATA(QSPPR1\n               OF)'\n $ '        - The data-set USERID.A.B must be an existing PO data-set w1\n               ith the'\n $ '          characteristics : LRECL=80 and RECFM=F (or FB).'\nHELPLPN  EQU   *-HELPSPN\n         EJECT\nHELPP    $     'The PF-KEYs are defined as follows (HELP P, HELP PFK or1\n                PFK) :',79\n         DC    0H'0',AL2(HELPLP)\nHELPSP   DC    CL4' '              INDENT THE FOLLOWING 4 SPACES\n $ '          <------ 25c. max. ------>           <------ 25c. max. ---1\n               --->'\n $ ' PFK-1  :                            PFK-13 :'\n $ ' PFK-2  :                            PFK-14 :'\n $ ' PFK-3  :                            PFK-15 :'\n $ ' PFK-4  :                            PFK-16 :'\n $ ' PFK-5  :                            PFK-17 :'\n $ ' PFK-6  :                            PFK-18 :'\n $ ' PFK-7  :                            PFK-19 :'\n $ ' PFK-8  :                            PFK-20 :'\n $ ' PFK-9  :                            PFK-21 :'\n $ ' PFK-10 :                            PFK-22 :'\n $ ' PFK-11 :                            PFK-23 :'\n $ ' PFK-12 :                            PFK-24 :'\n $ ' PA1    : interrupt running QSP command (EMERGENCY EXIT).'\n $ ' PA2    : redisplay the current screen image (RESHOW).'\n $ ' ',76\n $ ' Enter PF nn ...sub-command... to redefine PFK-nn.'\n $ ' Enter PZ to restore all original PF-keys definitions.'\n $ ' Enter PS or PL <A> <B> <M> to save or restore your PF-keys definit1\n               ions.'\nHELPLP   EQU   *-HELPSP\n         SPACE 2\n         PRINT GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ROTATER": {"ttr": 32257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882o\\x00\\x882o\\x175\\x02\\xd3\\x02\\xd3\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-21T00:00:00", "modifydate": "1988-11-21T17:35:00", "lines": 723, "newlines": 723, "modlines": 0, "user": "SYSPAJA"}, "text": "RTTR     TITLE 'R O T A T E R'\n         PRINT OFF\n         MACRO           MESSAGE.\n&NAME    MSG   &TEXT\n&NAME   WTO    &TEXT,                                                  C\n               ROUTCDE=11,DESC=7\n         MEND\n         PRINT ON\n         SPACE 1\nROTATER  START 0\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*                        R  O  T  A  T  E  R                          *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  WRITTEN BY BILL GODFREY, PRC (PLANNING RESEARCH CORPORATION).      *\n*  A MODIFIED VERSION OF A PROGRAM BY BRUCE E. HOGMAN,                *\n*        WHICH HAD ASSEMBLER-H DEPENDENT CODE AND USER MACROS.        *\n*  INSTALLATION. AIR FORCE DATA SERVICES CENTER, THE PENTAGON.        *\n*  DATE WRITTEN. MARCH 12 1982.                                       *\n*  DATE UPDATED. MARCH 15 1982.                                       *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  THIS PROGRAM MANIPULATES THE DATA OF A PRINTED PAGE SO THAT IT     *\n*        CAN BE PRINTED ON THE 3800 PRINTER USING A CHARACTER SET     *\n*        THAT CONTAINS CHARACTERS ROTATED 90 DEGREES CLOCKWISE.       *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  PROGRAM MODIFIED BY CRESPI R. - MOINIL P.A.                        *\n*                      COMPUTING CENTRE                               *\n*                      J.R.C. - ISPRA ESTABLISHMENT                   *\n*                      21020 ISPRA (VA), ITALY.                       *\n*              CHANGE DINAMICALLY THE PAGE SIZE AND CHOICE 'FCB'      *\n*              AND 'CHARS' SYSOUT CHARACTERISTICS ACCORDING TO SIZE.  *\n*           DATE UPDATED. MAY 1985.                                   *\n*                                                                     *\n*  I.E., EXECUTION JCL                                                *\n*                                                                     *\n*        //LIST  EXEC PGM=ROTATER                                     *\n*        //SUSUT1  DD DSN=...INPUT DATA-SET...,DISP=SHR               *\n*        //SUSUT2  DD SYSOUT=A,CHARS=T11,COPIES=2                     *\n*                                                                     *\n*        NOTE - CHARS=T11 IS JUST A REFERENCE TO FORCE THE JFCB       *\n*               EXTENSION BLOCK TO BE GENERATED.                      *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\nROTATER AMODE  24\nROTATER RMODE  24\n         SPACE 2\n        $DEFREG\n         EJECT\n        $XENT  BASE=R11,LV=@DATAL,TYPE=RENT\n         LR    R9,R13\n         USING @DATA,R9\n         XC    @ZERO(@ZEROL),@ZERO CLEAR SOME FIELDS TO ZEROS\n         EJECT\n*********************************************************************\n*                                                                   *\n*        GET PARAMETERS (REQUESTS) : PARM=XYZ                       *\n*                                                                   *\n*********************************************************************\n*                                                                   *\n* A4 SHEET FORMAT :  HORIZONTAL   PARM=X..   X=1-5                  *\n*                                                                   *\n* 1- 6 CHAR/INCH ->  43 CHAR/ROW -> FCB=LM6  (CHANNEL1 TO LINE 8)   *\n* 2- 8 CHAR/INCH ->  57 CHAR/ROW -> FCB=LM8  (CHANNEL1 TO LINE 11)  *\n* 3-10 CHAR/INCH ->  25 CHAR/ROW -> FCB=LM10 (CHANNEL1 TO LINE 14)  *\n* 4-12 CHAR/INCH ->  86 CHAR/ROW -> FCB=LM12 (CHANNEL1 TO LINE 16)  *\n* 5-24 CHAR/INCH -> 172 CHAR/ROW -> FCB=LM24 (CHANNEL1 TO LINE 32)  *\n*                                                                   *\n*-------------------------------------------------------------------*\n* A4 SHEET FORMAT :  VERTICAL     PARM=.Y.   Y=1-5                  *\n*                                                                   *\n* 1- 6 LINE/INCH -->  66 LINES/PAGE --> CHARS=..06                  *\n* 2-10 LINE/INCH --> 110 LINES/PAGE --> CHARS=..10                  *\n* 3-12 LINE/INCH --> 132 LINES/PAGE --> CHARS=..12                  *\n* 4-15 LINE/INCH --> 165 LINES/PAGE --> CHARS=..15                  *\n* 5-20 LINE/INCH --> 220 LINES/PAGE --> CHARS=..20                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n*                                                                   *\n* CHARACTER TYPE SELECTION        PARM=..Z   Z=1-8                  *\n*                                                                   *\n*          CHARS=GO.. FOR GOTHIC             1                      *\n*                GB.. FOR GOTHIC BOLD        2                      *\n*                SE.. FOR SERIF              3                      *\n*                RB.. FOR ROMAN BOLD         4                      *\n*                CO.. FOR COURIER            5                      *\n*                SI.. FOR SERIF ITALIC       6                      *\n*                OR.. FOR ORATOR             7                      *\n*                SC.. FOR SCRIPT             8                      *\n*                                                                   *\n*********************************************************************\n         SPACE 1\n         L     R2,0(R1)            PARM ADDRESS\n         LH    R3,0(R2)            PARAMETERS LENGTH\n         LTR   R3,R3\n         BNP   SETPARM             NO PARM, BRANCH\n         LA    R2,2(R2)            BYPASS LENGTH\n         NI    0(R2),X'0F'         FORCE ZONE TO ZERO\n         XR    R4,R4\n         IC    R4,0(R2)            1ST PARAMETER\n         LTR   R4,R4\n         BZ    ERROR1              0 IS INVALID\n         CLI   0(R2),5\n         BH    ERROR1              >5 IS INVALID\n         BCTR  R4,0\n         SLL   R4,2\n         LA    R5,FCBNAME(R4)      POINT FCB\n         MVC   F4,0(R5)\n         LA    R5,FMARG(R4)        POINT PAGE WIDTH\n         MVC   F1,0(R5)\n         SPACE 1\n         BCT   R3,*+L'*+4          OTHER PARAMETERS ?\n         B     SETPARM             NO MORE, BRANCH\n         LA    R2,1(R2)            2ND PARAMETER\n         NI    0(R2),X'0F'         FORCE ZONE TO ZERO\n         XR    R4,R4\n         IC    R4,0(R2)            2ND PARAMETER\n         LTR   R4,R4\n         BZ    ERROR2              0 IS INVALID\n         CLI   0(R2),5\n         BH    ERROR2              >5 IS INVALID\n         BCTR  R4,0\n         SLL   R4,2\n         LA    R5,CHARNAME(R4)     POINT CHARS\n         MVC   F5,0(R5)\n         LA    R5,CLEN(R4)         POINT PAGE LENGTH\n         MVC   F2,0(R5)\n         LA    R5,CDISP(R4)        POINT DISPLACEMENT IN SHEET\n         MVC   F3,0(R5)\n         SPACE 1\n         BCT   R3,*+L'*+4          OTHER PARAMETERS ?\n         B     SETPARM             NO MORE, BRANCH\n         LA    R2,1(R2)            3RD  PARAMETER\n         NI    0(R2),X'0F'         FORCE ZONE TO ZERO\n         XR    R4,R4\n         IC    R4,0(R2)            3RD PARAMETER\n         LTR   R4,R4\n         BZ    ERROR3              0 IS INVALID\n         CLI   0(R2),8\n         BH    ERROR3              >8 IS INVALID\n         BCTR  R4,0\n         SLL   R4,1\n         LA    R5,CHARPRE(R4)      POINT CHARS PREFIX\n         MVC   F5(2),0(R5)\n         SPACE 1\nSETPARM  L     R1,F1\n         ST    R1,PMARG            SET LINE LENGTH\n         LA    R1,1(R1)\n         ST    R1,PMARG1           SET LINE LENGTH+1\n         L     R1,F2\n         ST    R1,PLENX            SET PAGE TEXT LENGTH\n         A     R1,F3\n         ST    R1,PLEN             SET PAGE LENGTH\n         LA    R1,1(R1)\n         ST    R1,PLEN1            SET PAGE LENGTH+1\n         SPACE 1\n         LA    R7,OUTDCB\n         USING IHADCB,R7\n         STH   R1,DCBLRECL         SYSOUT LRECL\n         SLL   R1,5\n         STH   R1,DCBBLKSI         SYSOUT BLKSIZE=LRECL*32\n         EJECT\n*********************************************************************\n*                                                                   *\n*        LOOK IF SYSUT1-SYSUT2 ARE PRESENT                          *\n*                                                                   *\n*********************************************************************\n         SPACE 1\n        EXTRACT ATIOT,'S',FIELDS=(TIOT)\n         L     R3,ATIOT\n         USING TIODSECT,R3\n         XR    R1,R1\n         MVI   SWITCH,0\nSEARCH   CLC   TIOELNGH(4),=F'0'\n         BE    ERRUTS\n         CLC   TIOEDDNM(L'DCBDDNAM),INDCB+(DCBDDNAM-IHADCB)\n         BNE   SEARCH1\n         OI    SWITCH,UT1\n         B     SEARCH2\nSEARCH1  CLC   TIOEDDNM(L'DCBDDNAM),DCBDDNAM\n         BNE   SEARCH3\n         OI    SWITCH,UT2\nSEARCH2  TM    SWITCH,UT1+UT2\n         BO    ADJUST\nSEARCH3  IC    R1,TIOELNGH\n         ALR   R3,R1\n         B     SEARCH\n         DROP  R3\n         EJECT\n*********************************************************************\n*                                                                   *\n*        ADJUST SYSOUT CHARACTERISTICS                              *\n*                                                                   *\n*********************************************************************\n         SPACE 1\nADJUST  RDJFCB OUTDCB              GET JFCB BLOCK\n         LTR   R15,R15\n         BNZ   ERRJF\n         LA    R3,JFAREA\n         USING JFDSECT,R3\n         XR    R4,R4\n         ICM   R4,B'0111',JFCBEXAD GET EXTENSION ADDRESS\n         LTR   R4,R4\n         BZ    ERRJFE\n         CLC   12(4,R4),=CL4'JFCE'\n         BNE   ERRJFEN\n         LA    R4,16(R4)           SKIP PREFIX, POINT TO JFCB EXT.\n         USING JFCBE,R4\n         MVC   JFCFCBID,F4\n        ZEROKEY\n         MVC   JFCBTRS1,F5\n        RESETKEY\n         DROP  R3,R4\n         EJECT\n*********************************************************************\n*                                                                   *\n*        OPEN THE OUTPUT AND INPUT FILES                            *\n*                                                                   *\n*********************************************************************\n         SPACE 1\n        OPEN   (OUTDCB,OUTPUT),TYPE=J\n         TM    DCBOFLGS,DCBOFOPN   OUTPUT OPENED ?\n         BZ    ERROUT              NO\n         SPACE 1\n        OPEN   (INDCB,INPUT)\n         LA    R7,INDCB\n         TM    DCBOFLGS,DCBOFOPN   INPUT OPENED ?\n         BZ    ERRIN               NO\n         EJECT\n*********************************************************************\n*                                                                   *\n*        DETERMINE TYPE OF INPUT FILE                               *\n*                                                                   *\n*********************************************************************\n         SPACE 1\n         MVC   UT1LRECL,DCBLRECL\n         CLC   UT1LRECL,=H'0'      IS LRECL 0 ?\n         BNE   *+L'*+6             NO\n         MVC   UT1LRECL,DCBBLKSI   YES, USE BLKSIZE\n         MVC   UT1RECFM,DCBRECFM\n         TM    UT1RECFM,DCBRECU    IS RECFM U ?\n         BNO   *+L'*+4             NO\n         NI    UT1RECFM,255-DCBRECU     YES, TURN OFF F AND V BITS\n         MVC   MAXLINE1,PMARG+2    CC PRESENT\n         TM    UT1RECFM,DCBRECCC   IS RECFM A OR M ?\n         BZ    *+L'*+6             NO\n         MVC   MAXLINE1,PMARG1+2   CC PRESENT\n         DROP  R7\n         SPACE 1\n         LH    R1,UT1LRECL         LRECL\n         M     R0,PLEN1\n         ST    R1,BUFFLEN\n         LR    R0,R1\n        GETMAIN R,LV=(0)\n         ST    R1,@BUFFER\n         BAS   R8,CLEARBUF\n         MVI   PREV,0\n         MVI   BLINE,C' '\n         MVC   BLINE+1(L'BLINE-1),BLINE\n         EJECT\n*********************************************************************\n*                                                                   *\n*        READ A RECORD                                              *\n*                                                                   *\n*********************************************************************\n         SPACE 1\nREADLOOP GET   INDCB\n         ST    R1,@RECORD\n         TM    UT1RECFM,X'40'      IS RECFM V\n         BZ    READNOTV            NO, BRANCH\n         LH    R0,0(R1) GET RDW\n         L     R1,@RECORD\n         LA    R1,4(R1)         POINT TO DATA PORTION\n         ST    R1,@RECORD\n         SH    R0,=H'4'         LESS RDW\n         B     READX\n         USING IHADCB,R7\nREADNOTV LH    R0,DCBLRECL         NO, GET LRECL FOR FB OR U\n         LTR   R0,R0               IS RECFM F UNBLOCKED\n         BP    READX               NO, BRANCH\n         LH    R0,DCBBLKSI         YES, GET BLKSIZE\n         DROP  R7\nREADX    CH    R0,MAXLINE1         IS RECORD TOO LONG\n         BNH   *+L'*+4             NO\n         LH    R0,MAXLINE1         YES, TRUNCATE IT\n         ST    R0,RECSIZE          SAVE USABLE RECORD LENGTH\n         TM    UT1RECFM,X'02'      MACHINE CC\n         BZ    READNOTM            NO\n         EJECT\n*********************************************************************\n*                                                                   *\n*        CONVERT CARRIAGE CONTROLS TO ASA                           *\n*                                                                   *\n*********************************************************************\n         SPACE 1\n*        ANY RECORD NOT CONTAINING A MACHINE CC WILL BE\n*        COPIED WITH ITS OWN CC, EXCEPT :\n*              IF IT IS THE FIRST RECORD OF ITS TYPE\n*              AND IS A SINGLE-SPACE IT WILL BE CHANGED TO\n*              SKIP-TO-CHANNEL 1.\n*\n*        A RECORD CONTAINING A MACHINE CC (WRITE) WILL BE\n*        COPIED WITH AN ASA BASED ON THE PREVIOUS MACHINE CC.\n*        IF THE RECORD WAS NOT PRECEDED WITH A MACHINE CC\n*        RECORD, IT IS WRITTEN WITH SKIP-TO-CHANNEL 1.\n*\n*        A RECORD CONTAINING A MACHINE CC (IMMEDIATE) WILL\n*        NOT BE COPIED, BUT ITS CC WILL DETERMINE THE CC\n*        OF THE NEXT RECORD (UNLESS NEXT IS ASA OR IMM).\n*\n*        IF A MACHINE WRTSP1 OR IMMSP1 IS FOLLOWED BY\n*        A MACHINE IMMEDIATE SKIP, THE SPACE 1 WILL BE\n*        DROPPED. THIS IS BECAUSE A BLANK LINE WOULD\n*        HAVE TO BE WRITTEN, AND IT IS PROBABLY UNNECESSARY.\n*        IF THIS EVER CAUSES A PROBLEM, IT IS EASY TO REMOVE\n*        THIS LOGIC AND WRITE THE BLANK LINE. JUST REMOVE\n*        THE GROUP OF INSTRUCTIONS MARKED '-OPT-'\n*\n*        CONDITIONS NOT PROPERLY HANDLED (BUT INSIGNIFICANT).\n*              IMMEDIATE FOLLOWED BY ASA OR EOF.\n*                   (IGNORED)\n*              WRITE FOLLOWED BY ASA OR EOF.\n*                   (SP/SK IGNORED)\n         SPACE 1\n         MVC   HPREV,PREV\n         L     R1,@RECORD\n         TRT   0(1,R1),TABMACH     MACHINE CC\n         BZ    ASA                 NO, BRANCH\n*- - - - MACHINE CC.\n         STC   R2,PREV             STORE ASA FOR NEXT RECORD\n         TM    0(R1),X'02'         IS IT IMMEDIATE\n         BZ    PUTP                NO, ITS A WRITE\n         CLI   HPREV,0             IS THERE AN OUTSTANDING ACTION\n         BE    READLOOP            NO, DO NOT WRITE A LINE\n         CLI   HPREV,C'+'          WAS PREV WRTSP0 OR IMMSP0\n         BE    READLOOP            YES, DO NOT WRITE A LINE\n         CLI   HPREV,C' '   -OPT-  WAS PREV WRTSP1 OR IMMSP1\n         BNE   PREVSIG      -OPT-  NO, ITS PROBABLY SIGNIFICANT\n         TM    0(R1),X'80'  -OPT-  IS THIS A SKIP, NOT A SPACE\n         BO    READLOOP     -OPT-  ITS A SKIP, SO PREV CAN BE IGNORED\nPREVSIG  MVC   BLINE(1),HPREV      WRITE A BLANK LINE WITH HPREV\n         LA    R1,BLINE\n         ST    R1,@RECORD\n         MVC   RECSIZE,=F'2'       IN CASE RECFM V\n         B     READNOTM            WRITE THE LINE POINTED TO BY @RECORD\nPUTP     MVC   0(1,R1),HPREV\n         CLI   0(R1),0             IS THERE A CC BASED ON PREV RECORD\n         BNE   READNOTM            YES, GO USE IT\n*- - - - WE'VE HIT A MACHINE WRT CC NOT PRECEDED BY A MACHINE CC.\n*- - - - MAKE IT SKIP TO CHANNEL 1.\n         MVI   0(R1),C'1'\n         B     READNOTM\n*- - - - ASA CC.\nASA      CLI   PREV,0              WAS PREVIOUS RECORD MACHINE\n         BE    READNOTM            NO, BRANCH\n         MVI   PREV,0\n*- - - - WE'VE HIT AN ASA RECORD NOT PRECEDED BY AN ASA RECORD.\n*- - - - IF IT'S A SINGLE SPACE, CHANGE IT TO SKIP TO CH 1.\n         CLI   0(R1),C' '\n         BNE   READNOTM\n         MVI   0(R1),C'1'\n         SPACE 1\n*********************************************************************\n*                                                                   *\n*        ROTATE AND PRINT THE DATA                                  *\n*                                                                   *\n*********************************************************************\n         SPACE 1\nREADNOTM L     R1,@RECORD\n         L     R2,LINENO\n         LA    R0,1(R2)            ADD 1 TO LINENO\n         TM    UT1RECFM,X'06'      CC PRESENT\n         BZ    ADJX                NO, EXIT\n         CLI   0(R1),C' '          SINGLE SPACE\n         BE    ADJX                YES, EXIT\n         LA    R0,2(R2)            ADD 2 TO LINENO\n         CLI   0(R1),C'0'          DOUBLE SPACE\n         BE    ADJX                YES, EXIT\n         LA    R0,3(R2)            ADD 3 TO LINENO\n         CLI   0(R1),C'-'          TRIPLE SPACE\n         BE    ADJX                YES, EXIT\n         LA    R0,1(R2)            ADD 1 TO LINENO\n         CLI   0(R1),C'1'          NEW PAGE\n         BNE   ADJX                NO, BRANCH\n         L     R14,RCNTI           ADD TO COUNT OF INPUT PAGES\n         AL    R14,=F'1'\n         ST    R14,RCNTI\n         LA    R0,999              CAUSE PAGE OVERFLOW\n         LTR   R2,R2                IF\n         BNZ   ADJX                  NOT FIRST TIME\n         LA    R0,1                FIRST TIME MAKE IT 1\nADJX     ST    R0,LINENO\n         TM    UT1RECFM,X'06'      IS THERE CARRIAGE CONTROL\n         BZ    CCABS               NO, BRANCH\n         L     R1,@RECORD          YES,\n         LA    R1,1(R1)             POINT\n         ST    R1,@RECORD            PAST IT\n         L     R1,RECSIZE             AND\n         BCTR  R1,0                    REDUCE\n         ST    R1,RECSIZE               LENGTH\nCCABS    CLC   LINENO,PLENX\n         BNH   SAMEBUFR\n         BAS   R8,PRINTBUF\n         BAS   R8,CLEARBUF\n         MVC   LINENO,=F'1'\nSAMEBUFR L     R1,@RECORD\n         L     R5,RECSIZE\n         LTR   R5,R5\n         BZ    READLOOP\n         C     R5,MAXLRECL         SAVE\n         BNH   *+L'*+4              MAX\n         ST    R5,MAXLRECL           LRECL\n         BCTR  R5,0\n         AR    R5,R1               POINT TO LAST BYTE FOR BXLE\n         LA    R4,1                INCREMENT FOR BXLE\n         LA    R3,0(,R1)           FIRST BYTE FOR BXLE\n         L     R2,PLEN1\n         S     R2,LINENO           LINENO 1 TO PLEN MAKES R2 PLEN TO 1\n         L     R1,@BUFFER          DEST\n         AR    R1,R2\nMLOOP    MVC   0(1,R1),0(R3)\n         A     R1,PLEN1\n         BXLE  R3,R4,MLOOP\n         B     READLOOP\n         EJECT\n*********************************************************************\n*                                                                   *\n*        SUBROUTINES (LINK REGISTER IS R8)                          *\n*                                                                   *\n*********************************************************************\n         SPACE 1\n         USING IHADCB,R7\nPRINTBUF LH    R3,DCBLRECL\n         LTR   R3,R3\n         BNZ   *+L'*+4\n         LH    R3,DCBBLKSI\n         DROP  R7\n         TM    UT1RECFM,X'40'      RECFM V\n         BZ    *+L'*+4\n         L     R3,MAXLRECL         OBTAIN MAX REC LEN FOR PAGE\n         C     R3,PMARG\n         BNH   *+L'*+4\n         L     R3,PMARG\n         BCTR  R3,0\n         M     R2,PLEN1\n         L     R2,PLEN1\n         L     R4,@BUFFER\n         MVI   0(R4),C'1'          FORCE NEW PAGE\n         AR    R3,R4\nPLOOP    TM    0(R4),X'F0'\n         BO    TLOOP\n         TM    0(R4),X'0F'\n         BZ    TLOOP\n         MVI   0(R4),C' '          FORCE SPACE 1 IF NOT 1,BLANK,0 OR -\nTLOOP    PUT   OUTDCB,(R4)\n         BXLE  R4,R2,PLOOP\n         XC    MAXLRECL,MAXLRECL   ZERO MAXLRECL FOR VB FORMAT\n         L     R14,RCNTO           ADD TO COUNT OF PAGES OUTPUT\n         AL    R14,=F'1'\n         ST    R14,RCNTO\n         BR    R8\n         SPACE 1\n*********************************************************************\n         SPACE 1\nCLEARBUF L     R14,@BUFFER\n         L     R15,BUFFLEN\n         XR    R0,R0\n         L     R1,=A(X'40000000')\n         MVCL  R14,R0\n         L     R1,@BUFFER\n         MVI   0(R1),C'1'\n         BR    R8\n         EJECT\n***********************************************************************\n*                                                                     *\n*        TERMINATE PROCESSING                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nEOF      CLC   LINENO,=F'1'        ANYTHING TO PRINT\n         BNH   *+L'*+4             NO, SKIP PRINTBUF\n         BAS   R8,PRINTBUF         PURGE PRINT BUFFER\n        CLOSE  (INDCB,,OUTDCB)     CLOSE BOTH DCB'S\n         L     R0,RCNTI            COUNT OF INPUT LINES CC1=C'1'\n         CVD   R0,DOUBLE           CONVERT TO DECIMAL\n         OI    DOUBLE+7,X'0F'      MAKE PRINTABLE\n         UNPK  PRCNTI,DOUBLE       UNPACK TO WTO MESSAGE\n         L     R0,RCNTO            DO SAME FOR OUTPUT PAGE COUNT\n         CVD   R0,DOUBLE           CONVERT TO DECIMAL\n         OI    DOUBLE+7,X'0F'      MAKE PRINTABLE\n         UNPK  PRCNTO,DOUBLE       UNPACK TO WTO MESSAGE\nCNTWTO  WTO    '-- TOTAL ROTATED PAGES IN=00000, OUT=00000.',          C\n               ROUTCDE=11,DESC=7\nPRCNTI   EQU   CNTWTO+34,5,C'C'\nPRCNTO   EQU   CNTWTO+45,5,C'C'\n         LH    R1,UT1LRECL         PICK UP LRECL\n         M     R0,PLEN1\n         LR    R0,R1               LENGTH FOR FREEMAIN\n         L     R1,@BUFFER          ADDRESS FOR FREEMAIN\n        FREEMAIN R,LV=(0),A=(1)\n         XR    R10,R10             R.C. = 0\nEXIT    $XRET  CC=(R10),LV=@DATAL,TYPE=RENT\n         EJECT\n***********************************************************************\n*                                                                     *\n*        DIAGNOSE ERRORS                                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n        PRINT  NOGEN\nERRUTS   TM    SWITCH,UT1\n         BO    ERROM\n         MSG   'SYSUT1 - INPUT DATA-SET DD-CARD MISSING.'\n         TM    SWITCH,UT2\n         BO    ERRIM\nERROM    MSG   'SYSUT2 - OUTPUT DATA-SET DD-CARD MISSING.'\nERRIM    LA    R10,101             R.C. = 101 <-----------------------*\n         B     EXIT\nERRJF    MVC   JFDG(19),=CL19'READ ERROR (RC=00).'\n         STC   R15,JFRC+1\n         SRL   R15,4\n         STC   R15,JFRC\n         NC    JFRC(L'JFRC),=XL8'0F0F0F0F0F0F0F0F'\n         TR    JFRC(L'JFRC),=CL16'0123456789ABCDEF'\n         B     JFWTO\nERRJFE   MVC   JFDG(18),=CL18'EXTENSION MISSING.'\n         B     JFWTO\nERRJFEN  MVC   JFDG(24),=CL24'EXTENSION ACRONYM ERROR.'\nJFWTO   WTO    'SYSUT2 - JFCB                         ',               C\n               ROUTCDE=11,DESC=7\nJFDG     EQU   JFWTO+22,1,C'C'\nJFRC     EQU   JFWTO+37,2,C'C'\n         LA    R10,102             R.C. = 102 <-----------------------*\n         B     EXIT\nERROUT   MSG   'SYSUT2 - OUTPUT DATA-SET OPEN FAILED.'\n         LA    R10,103             R.C. = 103 <-----------------------*\n         B     EXIT\nERRIN    MSG   'SYSUT1 - INPUT DATA-SET OPEN FAILED.'\n        CLOSE  (OUTDCB)            CLOSE OUTPUT DCB (EMPTY)\n         LA    R10,104             R.C. = 104 <-----------------------*\n         B     EXIT\nERROR1   MSG   '1ST PARAMETER MUST BE BETWEEN 1 AND 5'\n         MSG   '    1 IS FOR  43 LINES PER ROW,'\n         MSG   '    2 IS FOR  57 LINES PER ROW,'\n         MSG   '    3 IS FOR  72 LINES PER ROW,'\n         MSG   '    4 IS FOR  86 LINES PER ROW,'\n         MSG   '    5 IS FOR 172 LINES PER ROW.'\n         LA    R10,201             R.C. = 201 <-----------------------*\n         B     EXIT\nERROR2   MSG   '2ND PARAMETER MUST BE BETWEEN 1 AND 5'\n         MSG   '    1 IS FOR  66 LINES PER PAGE,'\n         MSG   '    2 IS FOR 110 LINES PER PAGE,'\n         MSG   '    3 IS FOR 132 LINES PER PAGE,'\n         MSG   '    4 IS FOR 165 LINES PER PAGE,'\n         MSG   '    5 IS FOR 220 LINES PER PAGE.'\n         LA    R10,202             R.C. = 202 <-----------------------*\n         B     EXIT\nERROR3   MSG   '3RD PARAMETER MUST BE BETWEEN 1 AND 8'\n         MSG   '    1 IS FOR GOTHIC       CHARACTER TYPE,'\n         MSG   '    2 IS FOR GOTHIC BOLD  CHARACTER TYPE,'\n         MSG   '    3 IS FOR SERIF        CHARACTER TYPE,'\n         MSG   '    4 IS FOR ROMAN BOLD   CHARACTER TYPE,'\n         MSG   '    5 IS FOR COURIER      CHARACTER TYPE,'\n         MSG   '    6 IS FOR SERIF ITALIC CHARACTER TYPE,'\n         MSG   '    7 IS FOR ORATOR       CHARACTER TYPE,'\n         MSG   '    8 IS FOR SCRIPT       CHARACTER TYPE.'\n         LA    R10,203             R.C. = 203 <-----------------------*\n         B     EXIT\n        PRINT  GEN\n         EJECT\n***********************************************************************\n*                                                                     *\n*       CONSTANTS AND WORK AREAS                                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nATIOT    DC    A(*-*)              TIOT ADDRESS\nFMARG    DC    F'43,57,72,86,172'\nCLEN     DC    F'66,110,132,165,220'\nCDISP    DC    F'6,10,12,15,20'\nFCBNAME  DC    C'LM6 LM8 LM12LM12LM24'\nCHARNAME DC    C'GO06GO10GO12GO15GO20'\nCHARPRE  DC    C'GOGBSERBCOSIORSC'\n         SPACE 1\nF1       DC    F'86'               DEFAULT X=4\nF2       DC    F'66'               DEFAULT Y=1\nF3       DC    F'0'                DISPLACEMENT IN SHEET\nF4       DC    C'LM12'             DEFAULT X=4\nF5       DC    C'ROTA'             DEFAULT Y=1,Z=1\n         EJECT\n         PRINT NOGEN\n         SPACE 1\nINDCB   DCB    DDNAME=SYSUT1,DSORG=PS,MACRF=GL,EODAD=EOF,EROPT=ACC\n         SPACE 1\nOUTDCB  DCB    DDNAME=SYSUT2,DSORG=PS,MACRF=PM,RECFM=FBA,EXLST=JFLIST, C\n               LRECL=1,BLKSIZE=10   <------------ DYNAMICALLY CHANGED\nJFLIST   DC    0F'0',XL1'87',AL3(JFAREA)\nJFAREA   DC    0F'0',XL176'0'\n         SPACE 1\n         PRINT GEN\n         SPACE 2\n        LTORG\n         SPACE 2\nTABMACH  DC    0D'0',256X'00'\n         ORG   TABMACH+X'01'       WRT SP0\n         DC    C'+'\n         ORG   TABMACH+X'09'       WRT SP1\n         DC    C' '\n         ORG   TABMACH+X'11'       WRT SP2\n         DC    C'0'\n         ORG   TABMACH+X'19'       WRT SP3\n         DC    C'-'\n         ORG   TABMACH+X'89'       WRT SK1\n         DC    C'1'\n         ORG   TABMACH+X'91'       WRT SK2\n         DC    C'2'\n         ORG   TABMACH+X'99'       WRT SK3\n         DC    C'3'\n         ORG   TABMACH+X'A1'       WRT SK4\n         DC    C'4'\n         ORG   TABMACH+X'A9'       WRT SK5\n         DC    C'5'\n         ORG   TABMACH+X'B1'       WRT SK6\n         DC    C'6'\n         ORG   TABMACH+X'B9'       WRT SK7\n         DC    C'7'\n         ORG   TABMACH+X'C1'       WRT SK8\n         DC    C'8'\n         ORG   TABMACH+X'C9'       WRT SK9\n         DC    C'9'\n         ORG   TABMACH+X'D1'       WRT SK10\n         DC    C'A'\n         ORG   TABMACH+X'D9'       WRT SK11\n         DC    C'B'\n         ORG   TABMACH+X'E1'       WRT SK12\n         DC    C'C'\n         ORG   TABMACH+X'03'       IMM SP0 (NO-OP)\n         DC    C'+'\n         ORG   TABMACH+X'0B'       IMM SP1\n         DC    C' '\n         ORG   TABMACH+X'13'       IMM SP2\n         DC    C'0'\n         ORG   TABMACH+X'1B'       IMM SP3\n         DC    C'-'\n         ORG   TABMACH+X'8B'       IMM SK1\n         DC    C'1'\n         ORG   TABMACH+X'93'       IMM SK2\n         DC    C'2'\n         ORG   TABMACH+X'9B'       IMM SK3\n         DC    C'3'\n         ORG   TABMACH+X'A3'       IMM SK4\n         DC    C'4'\n         ORG   TABMACH+X'AB'       IMM SK5\n         DC    C'5'\n         ORG   TABMACH+X'B3'       IMM SK6\n         DC    C'6'\n         ORG   TABMACH+X'BB'       IMM SK7\n         DC    C'7'\n         ORG   TABMACH+X'C3'       IMM SK8\n         DC    C'8'\n         ORG   TABMACH+X'CB'       IMM SK9\n         DC    C'9'\n         ORG   TABMACH+X'D3'       IMM SK10\n         DC    C'A'\n         ORG   TABMACH+X'DB'       IMM SK11\n         DC    C'B'\n         ORG   TABMACH+X'E3'       IMM SK12\n         DC    C'C'\n         ORG\n         EJECT\n@DATA    DSECT\n         SPACE 1\n         DS    18F                 SAVE AREA\n         SPACE 1\n@ZERO    DS    0D\nDOUBLE   DS    D                   DOUBLE WORD WORK AREA\nRCNTI    DS    F                   COUNT OF PAGES INPUT\nRCNTO    DS    F                   COUNT OF PAGES ACTUALLY PRINTED\n@BUFFER  DS    A                   ADDRESS OF ROTATED BUFFER\n@RECORD  DS    A                   ADDRESS OF INPUT RECORD\nBUFFLEN  DS    A                   LENGTH OF GOTTEN AREA\nLINENO   DS    A                   NUMBER OF LINE OF OUTPUT\nRECSIZE  DS    A                   RECORD LENGTH (UP TO 180)\n*                                  (BECOMES NUMBER OF LINES)\nMAXLRECL DS    A                   MAXLRECL FOR VB INPUT/PAGE\nPREV     DS    C\nHPREV    DS    C\nSWITCH   DS    X\nUT1      EQU   X'01'               SYSUT1 PRESENT\nUT2      EQU   X'02'               SYSUT2 PRESENT\nUT1RECFM DS    X\nUT1LRECL DS    H\nMAXLINE1 DS    H\n@ZEROL   EQU   *-@ZERO             LENGTH OF AREA TO BE ZERO'D\n         SPACE 1\nPMARG    DS    F                   LINE LENGTH\nPMARG1   DS    F                   LINE LENGTH+1\nPLEN     DS    F                   PAGE LENGTH\nPLEN1    DS    F                   PAGE LENGTH+1\nPLENX    DS    F                   PAGE TEXT LENGTH\n         SPACE 1\nBLINE    DS    CL180\n         SPACE 1\n@DATAL   EQU   (((*-@DATA)+7)/8)*8\n         SPACE 2\n        PRINT  NOGEN\n         SPACE 1\n        DCBD   DSORG=PS\nTIODSECT DSECT\n        IEFTIOT1\nJFDSECT  DSECT\n        IEFJFCBN LIST=YES\n        IEFJFCBE\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ROTATER$": {"ttr": 32516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942o\\x00\\x942o\\x16(\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-22T00:00:00", "modifydate": "1994-11-22T16:28:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "SYSPAJA"}, "text": "//ROTATER  JOB (........),'INSTALL  ROTATER',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHSVC                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ4AS3,MBR=ROTATER\n//LNK     EXEC PAJILKL\n//SYSIN     DD *\n  ENTRY   ROTATER\n  NAME    ROTATER(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ROTATER@": {"ttr": 32518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x00/\\x00/\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "SYSPAJA"}, "text": "1   19/12/85\n                                                      ROTATER   1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       R O T A T E R  program        * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    This program manipulates the data of a printed page\n  ---------    so that it can be printed on a 3800 printer using a\n               character set that contains characters rotated 90\n               degrees clockwise.\n\n  CBT origin : Extracted from CBT tape JUN 84, file 316.\n  ------------\n\n  Operational considerations :\n  ----------------------------\n\n         The input data may be fixed or variable, from PS or PO\n  data-sets, and may include the carriage control character (except\n  that the space suppress cc (+) is not supported, it is just handle\n  as a blank, single line space cc).\n         When the carriage control character is omitted, a new page is\n  provided following the FCB definition value.\n         Also the printed line length will be equal to the input file\n  record length, unless it is larger than the FCB definition value\n  (control carriage not included). In this case the line will be\n  truncated (the remaining text is lost).\n         The FCB and CHARS characters sets are normally defined and\n  stored in the SYS1.IMAGELIB using the IEBIMAGE program (IBM utility),\n  then, these may be selected through the PARM field (EXEC statement),\n  in accord with the ROTATER internal tables conventions (PARM=XYZ).\n\n  JCL example :\n  -------------\n\n         //...  JOB  ...\n         /*JOBPARM K=0,... <--- LINECT=0 or K=0 is mandatory\n         //LIST   EXEC  PGM=ROTATER\n         //SYSUT1   DD  DSN=...input data-set...,DISP=OLD OR SHR\n         //SYSUT2   DD  SYSOUT=A,CHARS=T11,COPIES=1\n\n         Notes - CHARS=T11 is just a reference to force the JFCB\n                 Extension block to be generated.\n               - When PARM is omitted, a default is used.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SCHEDALP": {"ttr": 32520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15H\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:48:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=SCHEDALC\n./     NUMBER  NEW1=100,INCR=100\nPROC 2 VOLUME OWNID\nDEF CL(NAME('->.OPER.SCHEDULE') VOL(&VOLUME) ATT(3) CODE(SCHEDULE) -\nERAS KEYS(12 0) OWNER(&OWNID) TO(99365) UNQ -\nMRPW(PASSWORD) CTLPW(PASSWORD) UPDPW(PASSWORD) RDPW(PASSWORD)) -\nDATA(NAME('->.OPER.SCHEDULE.DATA') RECORDS(1000 100) -\nRECSZ(X'48' X'12D')) -\nINDEX(NAME('->.OPER.SCHEDULE.INDEX'))\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCHEDMAC": {"ttr": 32522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882/\\x00\\x882/\\x168\\rI\\rI\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-17T00:00:00", "modifydate": "1988-11-17T16:38:00", "lines": 3401, "newlines": 3401, "modlines": 0, "user": "SYSPAJA"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "SCHEDRUN": {"ttr": 33801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x14?\\x00\\x89\\x14?\\x10\\x05\\x07\\xfb\\x07\\xfb\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-05-23T00:00:00", "modifydate": "1989-05-23T10:05:00", "lines": 2043, "newlines": 2043, "modlines": 0, "user": "SYSPAJA"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "SCHEDRUP": {"ttr": 34819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15H\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:48:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=SCHEDRUN\n./     NUMBER  NEW1=100,INCR=100\n//IEFPROC EXEC PGM=SCHEDRUN PARM=TT -- ONLY TO DEBUG (SCHEDLOG NEEDED)\n//*----------------------------------------------------------------*\n//*           A U T O M A T I C        O P E R A T O R S           *\n//*                                                                *\n//*            C O M M A N D S        S C H E D U L E R            *\n//*----------------------------------------------------------------*\n//STEPLIB   DD DSN=... LINK LIBRARY ...,DISP=SHR  (IF NEEDED)\n//***********************************************************\n//*      IF YALE'S GSAM IUP (AVAILABLE THROUGH IBM) IS      *\n//*      INSTALLED, THEN REMOVE THE FOLLOWING CARD.         *\n//SCHEDULE DD  DSN=->.OPER.SCHEDULE,DISP=SHR                *\n//***********************************************************\n//*      IF YOU WANT USE THE LOG FILE, LOOK AT 'SCHEDLO$'   *\n//*      MEMBER TO PREPARE AND PROCESS IT (MEMBER SHOULD    *\n//*      BE TAILORED FOR YOUR NEEDS).                       *\n//SCHEDLOG DD  DSN=->.OPER.SCHEDLOG,DISP=MOD  (OR DUMMY)    *\n//***********************************************************\n//SYSUDUMP DD  SYSOUT=A                           (IF DESIRED)\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCHEDUL$": {"ttr": 34821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x8f\\x00\\x942\\x8f\\x10D\\x00D\\x00D\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-24T00:00:00", "modifydate": "1994-11-24T10:44:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "SYSPAJA"}, "text": "//SCHEDULE JOB (........),'INSTALL  -SCHEDULE-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=2\n/*JOBPARM L=20\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//*  SCHEDULE FACILITY INSTALLATION :                                 *\n//*  NOTE - THE VSAM DATA-SET NAME IS ASSUMED '->.OPER.SCHEDULE'.     *\n//*         TO ASSIGN ANOTHER ONE, APPLY CHANGES IN SOURCE MODULE     *\n//*         \"SCHEDULE\", PROCEDURE \"SCHEDRUN\", TSO-CLIST \"SCHEDALC\"    *\n//*         AND DOCUMENTATION \"SCHEDUL@\".                             *\n//*  1. ASSEMBLE AND LINK-EDIT MODULES \"SCHEDULE\" AND \"SCHEDRUN\".     *\n//*  2. SET TSO HELP-MEMBER \"SCHEDULE\" IN HELP LIBRARY.               *\n//*  3. SET PROCEDURE MEMBER \"SCHEDRUN\" IN PROCEDURES LIBRARY.        *\n//*  4. SET TSO-CLIST MEMBER \"SCHEDALC\" IN TSO-CLIST'S LIBRARY.       *\n//*     REMARK - IF YOU DON'T WANT PASSWORDS USE, DELETE THE FOURTH   *\n//*              CARD IN THE CLIST AND ADD A RIGHT PARENTHESIS AFTER  *\n//*              THE \"UNQ\" KEYWORD IN THE THIRD CARD.                 *\n//*  5. ALLOCATE THE VSAM DATA-SET USING THE CLIST IN MEMBER          *\n//*     \"SCHEDALC\", THEN TYPE THE COMMAND 'SCHEDULE' (THIS WILL       *\n//*     INITIALIZE THE VSAM DATA-SET.                                 *\n//*  6. PROVIDE A \"S SCHEDRUN\" COMMAND IN SYS1.PARMLIB(COMMND00),     *\n//*     OR A \".VS,'S SCHEDRUN'\" COMMAND INTO JES2 INITIALIZATION      *\n//*     PARAMETERS TO AUTOMATICALLY ISSUE IT AT EVERY IPL.            *\n//*  7. USE THE \"SCHEDULE\" TSO-COMMAND AND ITS SUBCOMMANDS FOR        *\n//*     AUTOMATIC PURPOSES.                                           *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASF     EXEC PAJ4AS3,OPT=',RENT',MBR=FAKEGSAM\n//LKF     EXEC PAJILKR,OPT=',LET,RENT'\n//SYSIN     DD *\n  ENTRY   FAKEGSAM\n  NAME    FAKEGSAM(R)\n/*\n//ASS     EXEC PAJ4AS3,OPT=',RENT',MBR=SCHEDULE\n//LKS     EXEC PAJILKL,OPT=',LET,RENT'\n//SYSIN     DD *\n  INCLUDE      SYSADD(FAKEGSAM)\n  SETCODE      AC(1)\n  ENTRY   SCHEDULE\n  NAME    SCHEDULE(R)\n/*\n//ASR     EXEC PAJ4AS3,OPT=',RENT',MBR=SCHEDRUN\n//LKR     EXEC PAJILKL,OPT=',LET,RENT'\n//SYSIN     DD *\n  INCLUDE      SYSADD(FAKEGSAM)\n  SETCODE      AC(1)\n  ENTRY   SCHEDRUN\n  NAME    SCHEDRUN(R)\n/*\n//HLP     EXEC PAJHELP,MBR=SCHEDULH,DSS='->.SOURCE.FILE4'\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* EXECUTE THE STEP BELOW WITH PROCEDURE :                           *\n//*       \"PAJPROC\" IF YOUR ->.TARGET.PROCLIB DATA-SET                *\n//*                         IS RECFM=FB AND LRECL=80, ELSE            *\n//*       \"PAJPROV\" IF YOUR ->.TARGET.PROCLIB DATA-SET                *\n//*                         IS RECFM=VB AND LRECL=255.                *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//PRC     EXEC PAJPROC,MBR=SCHEDRUP,DSS='->.SOURCE.FILE4'\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* EXECUTE THE STEP BELOW WITH PROCEDURE :                           *\n//*       \"PAJPROC\" IF YOUR ->.TARGET.TSO.CLISTS DATA-SET             *\n//*                         IS RECFM=FB AND LRECL=80, ELSE            *\n//*       \"PAJPROV\" IF YOUR ->.TARGET.TSO.CLISTS DATA-SET             *\n//*                         IS RECFM=VB AND LRECL=255.                *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//TCL     EXEC PAJPROC,MBR=SCHEDALP,DSS='->.SOURCE.FILE4',\n//             DSP='->.TARGET.TSO.CLISTS'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCHEDUL@": {"ttr": 34823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15H\\x03\\x03\\x03\\x03\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:48:00", "lines": 771, "newlines": 771, "modlines": 0, "user": "SYSPAJA"}, "text": "1   04/05/87\n                                                      SCHEDULE   1/17.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *        THE SCHEDULE FACILITY        * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  From :  Dave Cole\n          RR#2 Box 712\n          Afton, Va. 22920         (202)537-7201 (work)\n          October 1983             (703)456-6764 (home)\n\n  CBT origin : Extracted from CBT tape JUN 84, file 388.\n               Updated from CBT tape FEB 87, file 388.\n\n  FUNCTIONAL SUMMARY.\n  -------------------\n\n  The SCHEDULE facility makes it possible to schedule the automatic\n  execution of any operator command at any time of day on any date.\n  The execution of the command can be repeated according to any of\n  a large variety of daily, weekly, monthly, and/or yearly repeat\n  cycles (See the accompanying TSO HELP file for details).\n\n  The SCHEDULE facility supports an override capability whereby\n  particular sets of periodically scheduled commands can be overridden\n  on selected dates (such as holidays) with another set of commands\n  to be executed instead. Such overrides can be defined even years in\n  advance, if desired.\n\n  The SCHEDULE facility permits the definition of a \"window\" period\n  (defined separately for each scheduled automatic command) whereby :\n\n   - If the system is down at the time that a command is scheduled to\n     be executed,\n   - But if the system comes up any time during the specified \"window\n     period\" following the command's scheduled time,\n   - Then that command will be executed anyway.\n\n  Thus the execution of important commands won't be missed just\n  because the system wasn't up in time.\n\n  In JES2 \"Multi-Access Spool\" configurations, the SCHEDULE facility's\n  VSAM data base can be shared between multiple systems, and operator\n  commands can be scheduled to execute on either one or the other (or\n  \"any\") of the attached CPUs.\n\n  The SCHEDULE facility can maintain a log file where it records a\n  timestamped copy of all operator commands that it issues.\n\n  The SCHEDULE facility is designed to execute in a JES2 environment.\n  If you wish to use it in a JES3 system, then you must make suitable\n  modifications to the facility's source code.\n1   04/05/87\n                                                      SCHEDULE   2/17.\n\n  OPERATIONAL OVERVIEW.\n  ---------------------\n\n  This SCHEDULE facility consists of two programs : an authorized TSO\n  command processor named SCHEDULE, and an authorized started task\n  named SCHEDRUN. The TSO command (\"SCHEDULE\") is used to create,\n  display, and manipulate the schedule of automatic operator commands\n  (This schedule is kept in a VSAM key-sequenced dataset. It is NOT the\n  same schedule implemented by the JES2 \"automatic commands facility\").\n  The started-task (\"SCHEDRUN\") reads the schedule of automatic\n  commands, and executes them at the appointed time.\n\n  Both the SCHEDULE TSO command and the SCHEDRUN started-task will\n  attempt to use Yale's GSAM IUP (available through IBM) to access the\n  \"schedule\" VSAM dataset. If the GSAM IUP is not available, the\n  SCHEDULE facility will use normal dataset allocation and VSAM I/O to\n  access the VSAM file.\n\n  The SCHEDULE TSO command operates as follows :\n\n   - If a suitably authorized TSO user wishes to examine or modify the\n     automatic commands schedule, he types SCHEDULE. He is then placed\n     in subcommand mode. The user can then use the following\n     subcommands :\n\n     - HELP to learn how to use the SCHEDULE facility.\n     - DISPLAY to examine the commands schedule.\n     - SCHEDULE to add new entries to the commands schedule.\n     - CHANGE either to change existing command schedule entries or to\n       create new entries that are modelled on existing entries.\n     - DELETE to delete entries from the commands schedule.\n     - END to leave the SCHEDULE command processor and return to READY.\n\n   - Upon leaving the SCHEDULE command processor, if the user has done\n     anything to change the commands schedule, then a \"S SCHEDRUN\"\n     operator command is automatically issued (via SVC 34) so that the\n     next execution time of the next automatic operator command can be\n     re-evaluated.\n\n   - If Yale's GSAM IUP is not installed, then whenever the SCHEDULE\n     command processor is invoked, it searches for its VSAM schedule\n     dataset as follows :\n\n     - If a ddname of SCHEDULE has been pre-allocated, then the command\n       processor assumes that it points to the desired VSAM dataset, so\n       it opens it and uses it.\n     - If the SCHEDULE ddname cannot be found, then the command\n       processor attempts to dynamically allocate (SHR) a dataset named\n       ->.OPER.SCHEDULE. If this succeeds, then it is opened and used.\n     - If the dynamic allocation fails, then the SCHEDULE command\n       processor also fails.\n1   04/05/87\n                                                      SCHEDULE   3/17.\n\n  The SCHEDRUN started-task operates as follows :\n\n   - Whenever it executes, it examines the automatic schedule to\n     determine if any automatic commands are schedule to be issued\n     right now. If so, then it issues SVC 34 to execute them.\n\n   - It then examines the schedule to see when the next automatic\n     command needs to be executed. It then issues a JES2 \"$TA ...\"\n     command that will cause SCHEDRUN to be re-executed either at that\n     time or at the next midnight, which ever is sooner. Thus unless\n     the \"$TA\" commands are interfered with, SCHEDRUN will execute\n     automatically whenever necessary.\n\n  Note, \"extra\" executions of SCHEDRUN do no damage. If SCHEDRUN is\n  executed at any time when no automatic commands are scheduled,\n  it does nothing more than determine when it next needs to be executed\n  and schedules a JES2 automatic command \"$TA ...\" to cause itself to\n  be re-executed at the correct time.\n\n  After each IPL a \"S SCHEDRUN\" operator command needs to be issued in\n  order to get the schedule process going. This can be done in any of\n  the following ways :\n\n   - The operator can be instructed to manually issue the \"S SCHEDRUN\"\n     command during each IPL (not recommended since he might forget).\n   - A \"S SCHEDRUN\" command may be placed in SYS1.PARMLIB(COMMND00).\n   - A \"$VS,'S SCHEDRUN'\" command may be placed among the JES2\n     initialization parameters.\n1   04/05/87\n                                                      SCHEDULE   4/17.\n\n  SCHEDULE TSO HELP file details.\n  -------------------------------\n\n  FUNCTION :  The SCHEDULE command displays and alters the automatic\n              operator commands schedule (These are the operator\n              commands that are issued automatically by the system\n              at particular dates and times).\n\n  SYNTAX :    SCHEDULE \"a subcommand and its operands\"\n        Alias : SCHED\n        Required : none.\n        Default : If no operands are given, then subcommands are\n              prompted for.\n        Notes : If operands are given, then they are processed as a\n              subcommand. In this case when the subcommand is\n              finished, the SCHEDULE command processor ends without\n              prompting for more subcommands.\n\n  OPERANDS :  Operands are optional. If given, then they are\n              processed as a subcommand. The following are\n              subcommands of the SCHEDULE command processor.\n    SCHEDULE : Adds entries to the automatic operator commands\n               schedule.\n    DISPLAY :  Displays entries in the automatic operator\n               commands schedule.\n    CHANGE :   Changes existing entries in the automatic operator\n               commands schedule. Also can be used to create new\n               entries that are similar to existing entries.\n    DELETE :   Removes entries from the automatic operator commands\n               schedule.\n    END :      Terminates the SCHEDULE command processor.\n    HELP :     Displays complete subcommand usage information.\n\n  SUBCOMMANDS : SCHEDULE, DISPLAY, CHANGE, DELETE, END, and HELP.\n1   04/05/87\n                                                      SCHEDULE   5/17.\n\n Sub-command : SCHEDULE or S\n -------------\n\n   FUNCTION :  The SCHEDULE subcommand adds an entry to the automatic\n               operator commands schedule.\n\n   SYNTAX :    SCHEDULE 'operator command' SYSID(sytem id)\n                    DATE(dd/mm/yy) TIME(hh:mm) Name(application name)\n                    WEEKDAY(day name) WINDOW(hh:mm)\n                    NOTIPLFORCED/IPLFORCED\n                    NOOVERRIDE/OVERRIDE\n         Alias : The minimum abreviation is S.\n         Required :- 'operator command', DATE, TIME, and NAME.\n         Defaults : SYSID(CRNT) WEEKDAY(ANY) WINDOW(\"until midnight\")\n               NOTIPLFORCED NOOVERRIDE.\n\n   OPERANDS :\n  'OPERATOR COMMAND' : This is required. It gives the operator command\n               that is to be automatically scheduled. The command may\n               be any command that can be issued from an operator's\n               console. The command must be enclosed within single\n               quotes ('). Imbedded quotes must be represented by\n               pairs of quotes; i.e., a ' appearing within the command\n               must be represented by '' (not \").\n  SYSID(system id) : For multi-system configurations, this operand\n               specifies on which computer this scheduled command is\n               permitted to be executed. \"System id\" must be the\n               \"SMF-id\" of the desired computer. System ids consist\n               of from one to four alphameric characters.\n               \"SYSID(CRNT)\" means the \"current computer\" - i.e., the\n               computer which you are currently logged on to.\n               This is the default.\n               \"SYSID(ANY)\" means \"any computer\". The scheduled command\n               may be executed by any computer in the configuration -\n               which ever one gets around to it first.\n  SYSTEM(system id) : This is an alias for SYSID.\n  DATE(dd/mm/yy) : This is required. It gives the date or dates on\n               which the operator command is to be executed.\n               dd, mm, and/or yy may each be given as a dash (-).\n               This is a \"wild card\" character that causes that field\n               to match any value. For example, a dash given for mm\n               means \"any month\". If yy is equal to or less than 50,\n               then the 21st century is assumed. When - is given for\n               mm, then a value of 31 given for dd means \"the last\n               day of the month\" - even those months that are shorter\n               than 31 days.\n         Examples : DATE(9/2/80)        means 9 February 1980.\n                    DATE(8/2/40)        means 8 February 2040.\n                    DATE(31/-/81)       means The last day of every\n                                        month in 1981.\n                    DATE(1/-/-)         means The first day of every\n                                        month in every year.\n                    DATE(-/-/-)         means every day.\n1   04/05/87\n                                                      SCHEDULE   6/17.\n\n  TIME(hh:mm) : This is required. It gives the time of day at which the\n               operator command is to be executed. hh:mm is a 24-hour\n               clock; i.e., afternoon hours are represented by values\n               of 13 through 23 for hh.\n  NAME(application name) : This is required. It gives a name by which\n               this and other automatic commands can be referenced.\n               \"Application name\" is a single name consisting of from\n               one to eight alphameric or national characters. The\n               first character cannot be numeric.\n               All scheduled commands having the same application name\n               can be referenced as a group by the DISPLAY and DELETE\n               commands. In addition, the \"scope\" of overriding\n               commands is defined in terms of application names.\n               Type HELP SCHEDULE O(OVERRIDE) for more information.\n  WEEKDAY(day name) : This modifies the date on which the automatic\n               command is to be executed. If a date selected by the\n               DATE operand does not fall on the weekday named by this\n               operand, then the command is not issued.\n               \"Day name\" must be either the name of a weekday or a\n               unique abreviation of the name of a weekday.\n               \"Day name\" may be preceeded by a not sign (\u00ac) : e.g.,\n               WEEKDAY(\u00acTHU). In this case, if a date selected by the\n               DATE operand falls on the weekday named by this operand,\n               then the command is not issued.\n               \"Day name\" may be preceeded by a plus sign (+) : e.g.,\n               WEEKDAY(+THU). In this case, if a date selected by the\n               DATE operand does not fall on the weekday named by this\n               operand, then the execution of the automatic command is\n               delayed until the named weekday arrives.\n               \"Day name\" may be preceeded by a minus sign (-) : e.g.,\n               WEEKDAY(-THU). In this case if the selected date does\n               not fall on the named weekday, then the execution of the\n               automatic command, instead of being delayed, is moved\n               forward to the desired weekday.\n               The default value for WEEKDAY is ANY.\n         Examples : DATE(1/2/80) WEEKDAY(THU) means the Thursday that\n                                        is on or following 1 FEB 1980.\n                                        In this case that would be\n                                        February 7th.\n                    DATE(1/2/80) WEEKDAY(+THU) idem to previously.\n                    DATE(1/-/-) WEEKDAY(MON) means the first Monday of\n                                        every month.\n                    DATE(1/-/-) WEEKDAY(+MON) idem to previously.\n                    DATE(31/-/-) WEEKDAY(-FRI) means the last Friday of\n                                        every month.\n                    DATE(-/6/83) WEEKDAY(TUE) means every Tuesday in\n                                        June, 1983.\n                    DATE(-/-/-) WEEKDAY(WED) means every Wednesday.\n                    DATE(-/-/-) WEEKDAY(\u00acWED) means every day of the\n                                        year that is not Wednesday.\n1   04/05/87\n                                                      SCHEDULE   7/17.\n\n  WINDOW(hh:mm) : This gives the length of time following the scheduled\n               execution of an automatic command that the command can\n               still be executed if, for some reason such as a system\n               crash, the command was not executed when it was\n               supposed to be.\n               The default value is \"0:00\" which has the special\n               meaning \"until midnight\".\n               The window cannot extend past midnight.\n  IPLFORCED :  This indicates that if the system crashes and is\n               re-IPLed within the \"window\" period for this automatic\n               command, then this command is to be executed after the\n               IPL even if it has already been executed before the IPL.\n               The default is NOTIPLFORCED.\n               When a scheduled command defined with the IPLFORCED\n               attribute is displayed, the letter I appears in the\n               FLAGS column.\n  NOTIPLFORCED : nullifies IPLFORCED. Type HELP SCHEDULE O(IPLFORCED)\n               for more information. This is the default.\n  OVERRIDE :   This causes the scheduling of certain automatic\n               commands to be overridden by this command for a\n               particular date. The circumstances are these.\n               - The commands to be overridden must have the same\n                 application name as this command.\n               - The commands to be overridden must not themselves\n                 be designated as \"override\" commands.\n               - The commands to be overridden will be overridden\n                 only on those dates that this command will execute.\n                 The time of day is not relevent.\n               The default is NOOVERRIDE.\n         Use the \"DISPLAY DATE(dd/mm/yy) NAME(application name) BOTH\"\n         command to find which automatic commands are overridden.\n         Those commands showing the letter O in the FLAGS column\n         override all commands without the O flag.\n  NOOVERRIDE : nullifies OVERRIDE. Type HELP SCHEDULE O(OVERRIDE) for\n               more information. This is the default.\n1   04/05/87\n                                                      SCHEDULE   8/17.\n\n Sub-command : DISPLAY or DI\n -------------\n\n   FUNCTION :  The DISPLAY subcommand displays one or more entries in\n               the automatic operator commands schedule.\n\n   SYNTAX :    DISPLAY YESTERDAY/TODAY/TOMORROW/DATE(dd/mm/yy)\n                    /ANYTIME/OBSOLETE ID(identification numbers)\n                    NAME(application names) SYSID(system ids)\n                    OVERRIDE/NOOVERRIDE/BOTH/EITHER\n                    SHORT/LONG\n         Alias : The minimum abreviation is DI.\n         Required : none.\n         Default : ANYTIME SYSID(ALL) EITHER LONG and all names.\n         Notes : YESTERDAY, TODAY, TOMORROW, DATE, ANYTIME, OBSOLETE,\n               and ID are mutually exclusive.\n               OVERRIDE, NOOVERRIDE, BOTH, and EITHER are mutually\n               exclusive.\n               SHORT and LONG are mutually exclusive.\n               Type HELP DISPLAY O(FLAGS) for a description of the\n               displayed flag characters.\n\n   OPERANDS :\n  YESTERDAY :  limits the display of scheduled commands to those that\n               executed yesterday. The default is ANYTIME.\n  TODAY :      limits the display of scheduled commands to those that\n               execute today. The default is ANYTIME.\n  TOMORROW :   limits the display of scheduled commands to those that\n               will execute tomorrow. The default is ANYTIME.\n  DATE(dd/mm/yy) : limits the display of scheduled commands to those\n               that will execute on the given date. If yy is 50 or\n               less, then the 21st century is assumed. When this\n               operand is omitted, the default is ANYTIME.\n  ANYTIME :    does not limit the display of scheduled commands with\n               respect to either execution date or ID number or\n               obsolescense. This is the default.\n               An alias for ANYTIME is ALL.\n  ALL :        This is an alias for ANYTIME.\n  OBSOLETE :   limits the display to those scheduled commands that are\n               obsolete - i.e., those commands that can never execute\n               again. the default is ANYTIME.\n               When an obsolete scheduled command is displayed, the\n               letter N appears in the FLAGS column.\n  ID(identification numbers) : limits the display of scheduled commands\n               to those having the given identification numbers.\n               \"Identification numbers\" is a list of one or more\n               decimal numbers or pairs of decimal numbers joined by\n               a colin (:). Each number must be in the range of 0 to\n               65535. When joined pair of numbers are given, the second\n               number must be equal to or larger than the first. Such\n               pairs indicate a range of scheduled commands to be\n               displayed.\n               When this operand is omitted, the default is ANYTIME.\n1   04/05/87\n                                                      SCHEDULE   9/17.\n\n  NAME(application names) : limits the display to only those scheduled\n               commands associated with the given applications.\n               \"Application names\" is a list of one or more names each\n               of which consists of from one to eight alphameric or\n               national characters. The first character of each name\n               cannot be numeric.\n               Type HELP SCHEDULE O(NAME) for more information.\n  SYSID(system ids) : For multi-system configurations. This operand\n               limits the selection of scheduled commands to those\n               that are permitted to be executed on the computers\n               having the listed system ids.\n               A \"system id\" is a four-character identifier assigned\n               by SMF to a computer (for accounting purposes).\n               Each character is alphameric.\n               The \"SYSID\" operand may specify any number of system\n               identifiers. If a scheduled command matches any listed\n               identifier, then it is selected.\n               \"SYSID(CRNT)\" means the \"current computer\" - i.e., the\n               computer which you are currently logged on to.\n               \"SYSID(ANY)\" limits the selection to those scheduled\n               commands that are permitted to execute on any computer\n               in the configuration.\n               \"SYSID(ALL)\" does not limit the selection (This is the\n               default.\n         Example :  SYSID(SYSA ANY)\n               This selects those scheduled commands that must be\n               executed specifically by the computer named \"SYSA\" as\n               well as those commands that may be executed by any\n               computer in the configuration. (Scheduled commands\n               that must be executed specifically by the \"SYSB\"\n               computer are not selected).\n  SYSTEM(system ids) : This is an alias for SYSID.\n  OVERRIDE :   limits the display to only those scheduled commands that\n               are overrides. The default is EITHER.\n               Type HELP SCHEDULE O(OVERRIDE) for more information.\n               When an overriding scheduled command is displayed,\n               the letter O appears in the FLAGS column.\n  NOOVERRIDE : limits the display to only those scheduled commands that\n               are not overrides. The default is EITHER.\n               Type HELP SCHEDULE O(OVERRIDE) for more information.\n  BOTH :       displays scheduled commands without reguard to whether\n               or not they are overrides. The default is EITHER.\n               Type HELP SCHEDULE O(OVERRIDE) for more information.\n               When an overriding scheduled command is displayed, the\n               letter O appears in the FLAGS column.\n1   04/05/87\n                                                      SCHEDULE  10/17.\n\n  EITHER :     If the display of scheduled commands is limited to a\n               particular date (via the DATE, YESTERDAY, TODAY, or\n               TOMORROW operands), then for particular application\n               names if overriding scheduled commands exist for that\n               date, then they are displayed and the overridden\n               commands are not displayed. If no overriding commands\n               exist for that date for the application, then the\n               non-overriding commands are displayed.\n               When an overriding scheduled command is displayed, the\n               letter O appears in the FLAGS column.\n               If a specific date is not given, then EITHER functions\n               exactly like BOTH.\n               EITHER is the default.\n  LONG :       displays a discriptive message for each scheduled\n               command selected for display. This is the default.\n               Aliases for LONG are PROMPT and NOPROMPT (Don't ask why,\n               that's just the way it is).\n  PROMPT :     This is an alias for LONG.\n  NOPROMPT :   This is an alias for LONG.\n  SHORT :      displays only a count of the number of scheduled\n               commands selected by the DISPLAY command. Individual\n               descriptive messages are not generated.\n               The default is LONG.\n  FLAGS :      Characters appearing in the FLAGS column of the displays\n               have the following meanings :\n               I - This scheduled command has been defined with the\n                   IPLFORCED attribute. Type HELP SCHEDULE O(IPLFORCED)\n                   for more information.\n               O - This scheduled command is an OVERRIDE. Type\n                   HELP SCHEDULE O(OVERRIDE) for more information.\n               N - This scheduled command is OBSOLETE. It will never be\n                   executed again. Type HELP DISPLAY O(OBSOLETE) for\n                   more information.\n1   04/05/87\n                                                      SCHEDULE  11/17.\n\n Sub-command : CHANGE or C\n -------------\n\n   FUNCTION :  The CHANGE subcommand changes one or more\n               characteristics of one or more entries in the automatic\n               operator commands schedule.\n\n   SYNTAX :    CHANGE ID(identification numbers) COPY/NOCOPY\n                    COMMAND('operator command') DATE(dd/mm/yy)\n                    TIME(hh:mm) NAME(application name)\n                    SYSID(system id) WEEKDAY(day name)\n                    WINDOW(hh:mm) NOTIPLFORCED/IPLFORCED\n                    NOOVERRIDE/OVERRIDE\n         Alias : The minimum abreviation is C.\n         Required : ID.\n         Defaults : NOCOPY (Leave unchanged those items not specified).\n\n   OPERANDS :\n  ID(identification numbers) : identifies which scheduled commands are\n               to be changed. \"Identification numbers\" is a list of\n               one or more decimal numbers or pairs of decimal numbers\n               joined by a colin (:). Each number must be in the range\n               of 0 to 65535. When joined pair of numbers are given,\n               the second number must be equal to or larger than the\n               first. Such pairs indicate a range of scheduled commands\n               to be changed.\n               When multiple scheduled commands are being changed, they\n               are all changed identically.\n               The ID operand is required. There is no default.\n  COPY :       causes a copy of the original record(s) to be made\n               before any changes are made to that record. Thus when\n               the COPY operand is used, the original record(s) remains\n               unchanged, and the changed record becomes a new record\n               in the SCHEDULE file.\n               The default is NOCOPY.\n  NOCOPY :     causes all changes to be made directly to the selected\n               record(s). A copy of the original record(s) is not kept.\n               This is the default.\n  COMMAND('operator command') : gives the new operator command that is\n               to be automatically scheduled. The command may be any\n               command that can be issued from an operator's console.\n               The command must be enclosed within single quotes (').\n               Imbedded quotes must be represented by pairs of quotes;\n               i.e., a ' appearing within the command must be\n               represented by '' (not \").\n               This operand is optional. If omitted, then the operator\n               command to be issued remains unchanged.\n1   04/05/87\n                                                      SCHEDULE  12/17.\n\n  DATE(dd/mm/yy) : gives the new date or dates on which the operator\n               command is to be executed.\n               dd, mm, and/or yy may each be given as a dash (-).\n               This is a \"wild card\" character that causes that field\n               to match any value. For example, a dash given for mm\n               means \"any month\". If yy is equal to or less than 50,\n               then the 21st century is assumed. When - is given for\n               mm, then a value of 31 given for dd means \"the last\n               day of the month\" - even those months that are shorter\n               than 31 days.\n         Examples : DATE(9/2/80)        means 9 February 1980.\n                    DATE(8/2/40)        means 8 February 2040.\n                    DATE(31/-/81)       means The last day of every\n                                        month in 1981.\n                    DATE(1/-/-)         means The first day of every\n                                        month in every year.\n                    DATE(-/-/-)         means every day.\n  TIME(hh:mm) : gives the new time of day at which the operator\n               command is to be executed. hh:mm is a 24-hour clock;\n               i.e., afternoon hours are represented by values of\n               13 through 23 for hh.\n  NAME(application name) : gives a new name by which this automatic\n               command can be referenced. \"Application name\" is a\n               single name consisting of from one to eight alphameric\n               or national characters. The first character cannot be\n               numeric. All scheduled commands having the same\n               application name can be referenced as a group by the\n               DISPLAY and DELETE commands. In addition, the \"scope\"\n               of overriding scheduled commands is defined in terms\n               of application names. Type HELP CHANGE O(OVERRIDE)\n               for more information.\n  SYSID(system id) : For multi-system configurations, this operand\n               specifies on which computer this scheduled command is\n               permitted to be executed. \"System id\" must be the\n               \"SMF-id\" of the desired computer. System ids consist\n               of from one to four alphameric characters.\n               \"SYSID(CRNT)\" means the \"current computer\" - i.e., the\n               computer which you are currently logged on to.\n               \"SYSID(ANY)\" means \"any computer\". The scheduled\n               command may be executed by any computer in the\n               configuration - which ever one gets around to it first.\n  SYSTEM(system id) : This is an alias for SYSID.\n1   04/05/87\n                                                      SCHEDULE  13/17.\n\n  WEEKDAY(day name) : modifies the date on which the automatic command\n               is to be executed. If a date selected by the DATE\n               operand does not fall on the weekday named by this\n               operand, then the command is not issued.\n               \"Day name\" must be either the name of a weekday or a\n               unique abreviation of the name of a weekday.\n               \"Day name\" may be preceeded by a not sign (\u00ac) : e.g.,\n               WEEKDAY(\u00acTHU). In this case, if a date selected by the\n               DATE operand falls on the weekday named by this\n               operand, then the command is not issued.\n               \"Day name\" may be preceeded by a plus sign (+) : e.g.,\n               WEEKDAY(+THU). In this case, if a date selected by the\n               DATE operand does not fall on the weekday named by this\n               operand, then the execution of the automatic command is\n               delayed until the named weekday arrives.\n               \"Day name\" may be preceeded by a minus sign (-) :\n               e.g., WEEKDAY(-THU). In this case if the selected date\n               does not fall on the named weekday, then the execution\n               of the automatic command, instead of being delayed, is\n               moved forward to the desired weekday.\n         Examples : DATE(1/2/80) WEEKDAY(THU) means the Thursday that\n                                        is on or following 1 FEB 1980.\n                                        In this case that would be\n                                        February 7th.\n                    DATE(1/2/80) WEEKDAY(+THU) idem to previously.\n                    DATE(1/-/-) WEEKDAY(MON) means the first Monday of\n                                        every month.\n                    DATE(1/-/-) WEEKDAY(+MON) idem to previously.\n                    DATE(31/-/-) WEEKDAY(-FRI) means the last Friday of\n                                        every month.\n                    DATE(-/6/83) WEEKDAY(TUE) means every Tuesday in\n                                        June, 1983.\n                    DATE(-/-/-) WEEKDAY(WED) means every Wednesday.\n                    DATE(-/-/-) WEEKDAY(\u00acWED) means every day of the\n                                        year that is not Wednesday.\n               Specifying WEEKDAY(ANY) removes the weekday modifier\n               from the scheduled commands being changed.\n  WINDOW(hh:mm) : gives the length of time following the scheduled\n               execution of an automatic command that the command can\n               still be executed if, for some reason such as a system\n               crash, the command was not executed when it was supposed\n               to be. The window cannot extend past midnight. The\n               special value \"0:00\" has the meaning \"until midnight\".\n  IPLFORCED :  This indicates that if the system crashes and is\n               re-IPLed within the \"window\" period for this automatic\n               command, then this command is to be executed after the\n               IPL even if it has already been executed before the IPL.\n               When a scheduled command defined with the IPLFORCED\n               attribute is displayed, the letter I appears in the\n               FLAGS column.\n  NOTIPLFORCED : nullifies IPLFORCED. Type HELP CHANGE O(IPLFORCED) for\n               more information.\n1   04/05/87\n                                                      SCHEDULE  14/17.\n\n  OVERRIDE :   This causes the scheduling of certain automatic commands\n               to be overridden by this command for a particular date.\n               The circumstances are these.\n               - The commands to be overridden must have the same\n                 application name as this command.\n               - The commands to be overridden must not themselves be\n                 designated as \"override\" commands.\n               - The commands to be overridden will be overridden only\n                 on those dates that this command will execute.\n                 The time of day is not relevent.\n               Use the \"DISPLAY DATE(dd/mm/yy) NAME(application name)\n               BOTH\" command to find which automatic commands are\n               overridden. Those commands showing the letter O in the\n               FLAGS column override all commands without the O flag.\n  NOOVERRIDE : nullifies OVERRIDE. Type HELP CHANGE O(OVERRIDE) for\n               more information.\n1   04/05/87\n                                                      SCHEDULE  15/17.\n\n Sub-command : DELETE or DE\n -------------\n\n   FUNCTION :  The DELETE subcommand removes one or more entries from\n               the automatic operator commands schedule.\n\n   SYNTAX :    DELETE YESTERDAY/TODAY/TOMORROW/DATE(dd/mm/yy)\n                    /ANYTIME/OBSOLETE ID(identification numbers)\n                    NAME(application names) SYSID(sytem ids)\n                    OVERRIDE/NOOVERRIDE/BOTH/EITHER\n                    SHORT/LONG/PROMPT\n         Alias : The minimum abreviation is DE.\n         Required : at least one of either YESTERDAY, TODAY, DATE,\n               ANYTIME, ID, OBSOLETE, NAME, or SYSID.\n         Default : EITHER PROMPT\n         Notes : YESTERDAY, TODAY, TOMORROW, DATE, ANYTIME, OBSOLETE,\n               and ID are mutually exclusive. (Note that NAME and SYSID\n               are not mutually exclusive with these).\n               OVERRIDE, NOOVERRIDE, BOTH, and EITHER are mutually\n               exclusive.\n               SHORT, LONG, and PROMPT are mutually exclusive.\n\n   OPERANDS :\n  YESTERDAY :  limits the deletion of scheduled commands to those that\n               executed yesterday.\n  TODAY :      limits the deletion of scheduled commands to those that\n               execute today.\n  TOMORROW :   limits the deletion of scheduled commands to those that\n               will execute tomorrow.\n  DATE(dd/mm/yy) : limits the deletion of scheduled commands to those\n               that will execute on the given date. If yy is 50 or\n               less, then the 21st century is assumed.\n  ANYTIME :    does not limit the deletion of scheduled commands with\n               respect to either execution date or ID number or\n               obsolescense. This is the default.\n               An alias for ANYTIME is ALL.\n  ALL :        This is an alias for ANYTIME.\n  OBSOLETE :   limits the deletion to those scheduled commands that are\n               obsolete - i.e., those commands that can never execute\n               again. The default is ANYTIME.\n  ID(identification numbers) : limits the deletion of scheduled\n               commands to those having the given identification\n               numbers. \"Identification numbers\" is a list of one or\n               more decimal numbers or pairs of decimal numbers joined\n               by a colin (:). Each number must be in the range of 0\n               to 65535. When joined pairs of numbers are given, the\n               second number must be equal to or larger than the first.\n               Such pairs indicate a range of scheduled commands to be\n               deleted.\n1   04/05/87\n                                                      SCHEDULE  16/17.\n\n  NAME(application names) : limits the deletion to only those scheduled\n               commands associated with the given applications.\n               \"Application names\" is a list of one or more names each\n               of which consists of from one to eight alphameric or\n               national characters. The first character of each name\n               cannot be numeric.\n               Type HELP SCHEDULE O(NAME) for more information.\n  SYSID(system ids) : For multi-system configurations. This operand\n               limits the selection of scheduled commands to those\n               that are permitted to be executed on the computers\n               having the listed system ids.\n               A \"system id\" is a four-character identifier assigned\n               by SMF to a computer (for accounting purposes). Each\n               character is alphameric.\n               The \"SYSID\" operand may specify any number of system\n               identifiers. If a scheduled command matches any listed\n               identifier, then it is selected.\n               \"SYSID(CRNT)\" means the \"current computer\" - i.e., the\n               computer which you are currently logged on to.\n               \"SYSID(ANY)\" limits the selection to those scheduled\n               scheduled commands that are permitted to execute on\n               any computer in the configuration.\n               \"SYSID(ALL)\" does not limit the selection. This is\n               the default.\n         Example :  SYSID(SYSA ANY)\n               This selects those scheduled commands that must be\n               executed specifically by the computer named \"SYSA\" as\n               well as those commands that may be executed by any\n               computer in the configuration. (Scheduled commands\n               that must be executed specifically by the \"SYSB\"\n               computer are not selected).\n  SYSTEM(system ids) : This is an alias for SYSID.\n  OVERRIDE :   limits the deletion to only those scheduled commands\n               that are overrides. The default is EITHER.\n               Type HELP SCHEDULE O(OVERRIDE) for more information.\n  NOOVERRIDE : limits the deletion to only those scheduled commands\n               that are not overrides. The default is EITHER.\n               Type HELP SCHEDULE O(OVERRIDE) for more information.\n  BOTH :       deletes scheduled commands without reguard to whether\n               or not they are overrides. The default is EITHER.\n               Type HELP SCHEDULE O(OVERRIDE) for more information.\n  EITHER :     If the deletion of scheduled commands is limited to a\n               particular date (via the DATE, YESTERDAY, TODAY, or\n               TOMORROW operands), then for particular application\n               names if overriding scheduled commands exist for that\n               date, then they are deleted and the overridden commands\n               are not deleted. If no overriding commands exist for\n               that date for the application, then the non-overriding\n               commands are deleted.\n               If a specific date is not given, then EITHER functions\n               exactly like BOTH.\n               EITHER is the default.\n1   04/05/87\n                                                      SCHEDULE  17/17.\n\n  PROMPT :     displays a descriptive message for each scheduled\n               command to be deleted, and then prompts you to may a\n               final delete/no-delete decision for that scheduled\n               command. This is the default.\n  LONG :       displays a discriptive message for each scheduled\n               command to be deleted, and then deletes it (without\n               prompting you for a final decision).\n               The default is PROMPT.\n  SHORT :      displays only a count of the number of scheduled\n               commands deleted. Individual descriptive messages are\n               not displayed. Nor are you prompted for a final\n               delete/no-delete decision.\n               The default is PROMPT.\n\n Sub-command : END or E\n -------------\n\n   FUNCTION :  The END subcommand causes the SCHEDULE command processor\n               to end. If a SCHEDULE, CHANGE, or DELETE subcommand has\n               been issued, then the END subcommand automatically\n               causes a 'S SCHEDRUN' operator command to be issued.\n               By this means, the system is notified of possible\n               changes to the automatic operator commands schedule.\n\n   SYNTAX :    END\n         Alias : The minimum abreviation is E.\n\n   OPERANDS : none.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCHEDULE": {"ttr": 35079, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15H\\x115\\x115\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:48:00", "lines": 4405, "newlines": 4405, "modlines": 0, "user": "SYSPAJA"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "SCHEDULH": {"ttr": 36871, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x12_\\x00\\x87\\x12_\\x11R\\x026\\x026\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-05-05T00:00:00", "modifydate": "1987-05-05T11:52:00", "lines": 566, "newlines": 566, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=SCHEDULE\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  The SCHEDULE command displays and alters the automatic\n               operator commands schedule (These are the operator\n               commands that are issued automatically by the system\n               at particular dates and times).\n)X SYNTAX :    SCHEDULE \"a subcommand and its operands\"\n         Alias : SCHED\n         Required : none.\n         Default : If no operands are given, then subcommands are\n               prompted for.\n         Notes : If operands are given, then they are processed as a\n               subcommand. In this case when the subcommand is\n               finished, the SCHEDULE command processor ends without\n               prompting for more subcommands.\n)O OPERANDS :  Operands are optional. If given, then they are\n               processed as a subcommand. The following are\n               subcommands of the SCHEDULE command processor.\n))SCHEDULE :   Adds entries to the automatic operator commands\n               schedule.\n))DISPLAY :    Displays entries in the automatic operator\n               commands schedule.\n))CHANGE :     Changes existing entries in the automatic operator\n               commands schedule. Also can be used to create new\n               entries that are similar to existing entries.\n))DELETE :     Removes entries from the automatic operator commands\n               schedule.\n))END :        Terminates the SCHEDULE command processor.\n))HELP :       Displays complete subcommand usage information.\n)S SUBCOMMANDS : SCHEDULE, DISPLAY, CHANGE, DELETE, END, and HELP.\n=SCHEDULE=S\n)F FUNCTION :  The SCHEDULE subcommand adds an entry to the automatic\n               operator commands schedule.\n)X SYNTAX :    SCHEDULE 'operator command' SYSID(sytem id)\n                    DATE(dd/mm/yy) TIME(hh:mm) Name(application name)\n                    WEEKDAY(day name) WINDOW(hh:mm)\n                    NOTIPLFORCED/IPLFORCED\n                    NOOVERRIDE/OVERRIDE\n         Alias : The minimum abreviation is S.\n         Required :- 'operator command', DATE, TIME, and NAME.\n         Defaults : SYSID(CRNT) WEEKDAY(ANY) WINDOW(\"until midnight\")\n               NOTIPLFORCED NOOVERRIDE.\n)O OPERANDS :\n))'OPERATOR COMMAND' : This is required. It gives the operator command\n               that is to be automatically scheduled. The command may\n               be any command that can be issued from an operator's\n               console. The command must be enclosed within single\n               quotes ('). Imbedded quotes must be represented by\n               pairs of quotes; i.e., a ' appearing within the command\n               must be represented by '' (not \").\n))SYSID(system id) : For multi-system configurations, this operand\n               specifies on which computer this scheduled command is\n               permitted to be executed. \"System id\" must be the\n               \"SMF-id\" of the desired computer. System ids consist\n               of from one to four alphameric characters.\n               \"SYSID(CRNT)\" means the \"current computer\" - i.e., the\n               computer which you are currently logged on to.\n               This is the default.\n               \"SYSID(ANY)\" means \"any computer\". The scheduled command\n               may be executed by any computer in the configuration -\n               which ever one gets around to it first.\n))SYSTEM(system id) : This is an alias for SYSID.\n))DATE(dd/mm/yy) : This is required. It gives the date or dates on\n               which the operator command is to be executed.\n               dd, mm, and/or yy may each be given as a dash (-).\n               This is a \"wild card\" character that causes that field\n               to match any value. For example, a dash given for mm\n               means \"any month\". If yy is equal to or less than 50,\n               then the 21st century is assumed. When - is given for\n               mm, then a value of 31 given for dd means \"the last\n               day of the month\" - even those months that are shorter\n               than 31 days.\n         Examples : DATE(9/2/80)        means 9 February 1980.\n                    DATE(8/2/40)        means 8 February 2040.\n                    DATE(31/-/81)       means The last day of every\n                                        month in 1981.\n                    DATE(1/-/-)         means The first day of every\n                                        month in every year.\n                    DATE(-/-/-)         means every day.\n))TIME(hh:mm) : This is required. It gives the time of day at which the\n               operator command is to be executed. hh:mm is a 24-hour\n               clock; i.e., afternoon hours are represented by values\n               of 13 through 23 for hh.\n))NAME(application name) : This is required. It gives a name by which\n               this and other automatic commands can be referenced.\n               \"Application name\" is a single name consisting of from\n               one to eight alphameric or national characters. The\n               first character cannot be numeric.\n               All scheduled commands having the same application name\n               can be referenced as a group by the DISPLAY and DELETE\n               commands. In addition, the \"scope\" of overriding\n               commands is defined in terms of application names.\n               Type HELP SCHEDULE O(OVERRIDE) for more information.\n))WEEKDAY(day name) : This modifies the date on which the automatic\n               command is to be executed. If a date selected by the\n               DATE operand does not fall on the weekday named by this\n               operand, then the command is not issued.\n               \"Day name\" must be either the name of a weekday or a\n               unique abreviation of the name of a weekday.\n               \"Day name\" may be preceeded by a not sign (\u00ac) : e.g.,\n               WEEKDAY(\u00acTHU). In this case, if a date selected by the\n               DATE operand falls on the weekday named by this operand,\n               then the command is not issued.\n               \"Day name\" may be preceeded by a plus sign (+) : e.g.,\n               WEEKDAY(+THU). In this case, if a date selected by the\n               DATE operand does not fall on the weekday named by this\n               operand, then the execution of the automatic command is\n               delayed until the named weekday arrives.\n               \"Day name\" may be preceeded by a minus sign (-) : e.g.,\n               WEEKDAY(-THU). In this case if the selected date does\n               not fall on the named weekday, then the execution of the\n               automatic command, instead of being delayed, is moved\n               forward to the desired weekday.\n               The default value for WEEKDAY is ANY.\n         Examples : DATE(1/2/80) WEEKDAY(THU) means the Thursday that\n                                        is on or following 1 FEB 1980.\n                                        In this case that would be\n                                        February 7th.\n                    DATE(1/2/80) WEEKDAY(+THU) idem to previously.\n                    DATE(1/-/-) WEEKDAY(MON) means the first Monday of\n                                        every month.\n                    DATE(1/-/-) WEEKDAY(+MON) idem to previously.\n                    DATE(31/-/-) WEEKDAY(-FRI) means the last Friday of\n                                        every month.\n                    DATE(-/6/83) WEEKDAY(TUE) means every Tuesday in\n                                        June, 1983.\n                    DATE(-/-/-) WEEKDAY(WED) means every Wednesday.\n                    DATE(-/-/-) WEEKDAY(\u00acWED) means every day of the\n                                        year that is not Wednesday.\n))WINDOW(hh:mm) : This gives the length of time following the scheduled\n               execution of an automatic command that the command can\n               still be executed if, for some reason such as a system\n               crash, the command was not executed when it was\n               supposed to be.\n               The default value is \"0:00\" which has the special\n               meaning \"until midnight\".\n               The window cannot extend past midnight.\n))IPLFORCED :  This indicates that if the system crashes and is\n               re-IPLed within the \"window\" period for this automatic\n               command, then this command is to be executed after the\n               IPL even if it has already been executed before the IPL.\n               The default is NOTIPLFORCED.\n               When a scheduled command defined with the IPLFORCED\n               attribute is displayed, the letter I appears in the\n               FLAGS column.\n))NOTIPLFORCED : nullifies IPLFORCED. Type HELP SCHEDULE O(IPLFORCED)\n               for more information. This is the default.\n))OVERRIDE :   This causes the scheduling of certain automatic\n               commands to be overridden by this command for a\n               particular date. The circumstances are these.\n               - The commands to be overridden must have the same\n                 application name as this command.\n               - The commands to be overridden must not themselves\n                 be designated as \"override\" commands.\n               - The commands to be overridden will be overridden\n                 only on those dates that this command will execute.\n                 The time of day is not relevent.\n               The default is NOOVERRIDE.\n         Use the \"DISPLAY DATE(dd/mm/yy) NAME(application name) BOTH\"\n         command to find which automatic commands are overridden.\n         Those commands showing the letter O in the FLAGS column\n         override all commands without the O flag.\n))NOOVERRIDE : nullifies OVERRIDE. Type HELP SCHEDULE O(OVERRIDE) for\n               more information. This is the default.\n=DISPLAY=DI\n)F FUNCTION :  The DISPLAY subcommand displays one or more entries in\n               the automatic operator commands schedule.\n)X SYNTAX :    DISPLAY YESTERDAY/TODAY/TOMORROW/DATE(dd/mm/yy)\n                    /ANYTIME/OBSOLETE ID(identification numbers)\n                    NAME(application names) SYSID(system ids)\n                    OVERRIDE/NOOVERRIDE/BOTH/EITHER\n                    SHORT/LONG\n         Alias : The minimum abreviation is DI.\n         Required : none.\n         Default : ANYTIME SYSID(ALL) EITHER LONG and all names.\n         Notes : YESTERDAY, TODAY, TOMORROW, DATE, ANYTIME, OBSOLETE,\n               and ID are mutually exclusive.\n               OVERRIDE, NOOVERRIDE, BOTH, and EITHER are mutually\n               exclusive.\n               SHORT and LONG are mutually exclusive.\n               Type HELP DISPLAY O(FLAGS) for a description of the\n               displayed flag characters.\n)O OPERANDS :\n))YESTERDAY :  limits the display of scheduled commands to those that\n               executed yesterday. The default is ANYTIME.\n))TODAY :      limits the display of scheduled commands to those that\n               execute today. The default is ANYTIME.\n))TOMORROW :   limits the display of scheduled commands to those that\n               will execute tomorrow. The default is ANYTIME.\n))DATE(dd/mm/yy) : limits the display of scheduled commands to those\n               that will execute on the given date. If yy is 50 or\n               less, then the 21st century is assumed. When this\n               operand is omitted, the default is ANYTIME.\n))ANYTIME :    does not limit the display of scheduled commands with\n               respect to either execution date or ID number or\n               obsolescense. This is the default.\n               An alias for ANYTIME is ALL.\n))ALL :        This is an alias for ANYTIME.\n))OBSOLETE :   limits the display to those scheduled commands that are\n               obsolete - i.e., those commands that can never execute\n               again. the default is ANYTIME.\n               When an obsolete scheduled command is displayed, the\n               letter N appears in the FLAGS column.\n))ID(identification numbers) : limits the display of scheduled commands\n               to those having the given identification numbers.\n               \"Identification numbers\" is a list of one or more\n               decimal numbers or pairs of decimal numbers joined by\n               a colin (:). Each number must be in the range of 0 to\n               65535. When joined pair of numbers are given, the second\n               number must be equal to or larger than the first. Such\n               pairs indicate a range of scheduled commands to be\n               displayed.\n               When this operand is omitted, the default is ANYTIME.\n))NAME(application names) : limits the display to only those scheduled\n               commands associated with the given applications.\n               \"Application names\" is a list of one or more names each\n               of which consists of from one to eight alphameric or\n               national characters. The first character of each name\n               cannot be numeric.\n               Type HELP SCHEDULE O(NAME) for more information.\n))SYSID(system ids) : For multi-system configurations. This operand\n               limits the selection of scheduled commands to those\n               that are permitted to be executed on the computers\n               having the listed system ids.\n               A \"system id\" is a four-character identifier assigned\n               by SMF to a computer (for accounting purposes).\n               Each character is alphameric.\n               The \"SYSID\" operand may specify any number of system\n               identifiers. If a scheduled command matches any listed\n               identifier, then it is selected.\n               \"SYSID(CRNT)\" means the \"current computer\" - i.e., the\n               computer which you are currently logged on to.\n               \"SYSID(ANY)\" limits the selection to those scheduled\n               commands that are permitted to execute on any computer\n               in the configuration.\n               \"SYSID(ALL)\" does not limit the selection (This is the\n               default.\n         Example :  SYSID(SYSA ANY)\n               This selects those scheduled commands that must be\n               executed specifically by the computer named \"SYSA\" as\n               well as those commands that may be executed by any\n               computer in the configuration. (Scheduled commands\n               that must be executed specifically by the \"SYSB\"\n               computer are not selected).\n))SYSTEM(system ids) : This is an alias for SYSID.\n))OVERRIDE :   limits the display to only those scheduled commands that\n               are overrides. The default is EITHER.\n               Type HELP SCHEDULE O(OVERRIDE) for more information.\n               When an overriding scheduled command is displayed,\n               the letter O appears in the FLAGS column.\n))NOOVERRIDE : limits the display to only those scheduled commands that\n               are not overrides. The default is EITHER.\n               Type HELP SCHEDULE O(OVERRIDE) for more information.\n))BOTH :       displays scheduled commands without reguard to whether\n               or not they are overrides. The default is EITHER.\n               Type HELP SCHEDULE O(OVERRIDE) for more information.\n               When an overriding scheduled command is displayed, the\n               letter O appears in the FLAGS column.\n))EITHER :     If the display of scheduled commands is limited to a\n               particular date (via the DATE, YESTERDAY, TODAY, or\n               TOMORROW operands), then for particular application\n               names if overriding scheduled commands exist for that\n               date, then they are displayed and the overridden\n               commands are not displayed. If no overriding commands\n               exist for that date for the application, then the\n               non-overriding commands are displayed.\n               When an overriding scheduled command is displayed, the\n               letter O appears in the FLAGS column.\n               If a specific date is not given, then EITHER functions\n               exactly like BOTH.\n               EITHER is the default.\n))LONG :       displays a discriptive message for each scheduled\n               command selected for display. This is the default.\n               Aliases for LONG are PROMPT and NOPROMPT (Don't ask why,\n               that's just the way it is).\n))PROMPT :     This is an alias for LONG.\n))NOPROMPT :   This is an alias for LONG.\n))SHORT :      displays only a count of the number of scheduled\n               commands selected by the DISPLAY command. Individual\n               descriptive messages are not generated.\n               The default is LONG.\n))FLAGS :      Characters appearing in the FLAGS column of the displays\n               have the following meanings :\n               I - This scheduled command has been defined with the\n                   IPLFORCED attribute. Type HELP SCHEDULE O(IPLFORCED)\n                   for more information.\n               O - This scheduled command is an OVERRIDE. Type\n                   HELP SCHEDULE O(OVERRIDE) for more information.\n               N - This scheduled command is OBSOLETE. It will never be\n                   executed again. Type HELP DISPLAY O(OBSOLETE) for\n                   more information.\n=CHANGE=C\n)F FUNCTION :  The CHANGE subcommand changes one or more\n               characteristics of one or more entries in the automatic\n               operator commands schedule.\n)X SYNTAX :    CHANGE ID(identification numbers) COPY/NOCOPY\n                    COMMAND('operator command') DATE(dd/mm/yy)\n                    TIME(hh:mm) NAME(application name)\n                    SYSID(system id) WEEKDAY(day name)\n                    WINDOW(hh:mm) NOTIPLFORCED/IPLFORCED\n                    NOOVERRIDE/OVERRIDE\n         Alias : The minimum abreviation is C.\n         Required : ID.\n         Defaults : NOCOPY (Leave unchanged those items not specified).\n)O OPERANDS :\n))ID(identification numbers) : identifies which scheduled commands are\n               to be changed. \"Identification numbers\" is a list of\n               one or more decimal numbers or pairs of decimal numbers\n               joined by a colin (:). Each number must be in the range\n               of 0 to 65535. When joined pair of numbers are given,\n               the second number must be equal to or larger than the\n               first. Such pairs indicate a range of scheduled commands\n               to be changed.\n               When multiple scheduled commands are being changed, they\n               are all changed identically.\n               The ID operand is required. There is no default.\n))COPY :       causes a copy of the original record(s) to be made\n               before any changes are made to that record. Thus when\n               the COPY operand is used, the original record(s) remains\n               unchanged, and the changed record becomes a new record\n               in the SCHEDULE file.\n               The default is NOCOPY.\n))NOCOPY :     causes all changes to be made directly to the selected\n               record(s). A copy of the original record(s) is not kept.\n               This is the default.\n))COMMAND('operator command') : gives the new operator command that is\n               to be automatically scheduled. The command may be any\n               command that can be issued from an operator's console.\n               The command must be enclosed within single quotes (').\n               Imbedded quotes must be represented by pairs of quotes;\n               i.e., a ' appearing within the command must be\n               represented by '' (not \").\n               This operand is optional. If omitted, then the operator\n               command to be issued remains unchanged.\n))DATE(dd/mm/yy) : gives the new date or dates on which the operator\n               command is to be executed.\n               dd, mm, and/or yy may each be given as a dash (-).\n               This is a \"wild card\" character that causes that field\n               to match any value. For example, a dash given for mm\n               means \"any month\". If yy is equal to or less than 50,\n               then the 21st century is assumed. When - is given for\n               mm, then a value of 31 given for dd means \"the last\n               day of the month\" - even those months that are shorter\n               than 31 days.\n         Examples : DATE(9/2/80)        means 9 February 1980.\n                    DATE(8/2/40)        means 8 February 2040.\n                    DATE(31/-/81)       means The last day of every\n                                        month in 1981.\n                    DATE(1/-/-)         means The first day of every\n                                        month in every year.\n                    DATE(-/-/-)         means every day.\n))TIME(hh:mm) : gives the new time of day at which the operator\n               command is to be executed. hh:mm is a 24-hour clock;\n               i.e., afternoon hours are represented by values of\n               13 through 23 for hh.\n))NAME(application name) : gives a new name by which this automatic\n               command can be referenced. \"Application name\" is a\n               single name consisting of from one to eight alphameric\n               or national characters. The first character cannot be\n               numeric. All scheduled commands having the same\n               application name can be referenced as a group by the\n               DISPLAY and DELETE commands. In addition, the \"scope\"\n               of overriding scheduled commands is defined in terms\n               of application names. Type HELP CHANGE O(OVERRIDE)\n               for more information.\n))SYSID(system id) : For multi-system configurations, this operand\n               specifies on which computer this scheduled command is\n               permitted to be executed. \"System id\" must be the\n               \"SMF-id\" of the desired computer. System ids consist\n               of from one to four alphameric characters.\n               \"SYSID(CRNT)\" means the \"current computer\" - i.e., the\n               computer which you are currently logged on to.\n               \"SYSID(ANY)\" means \"any computer\". The scheduled\n               command may be executed by any computer in the\n               configuration - which ever one gets around to it first.\n))SYSTEM(system id) : This is an alias for SYSID.\n))WEEKDAY(day name) : modifies the date on which the automatic command\n               is to be executed. If a date selected by the DATE\n               operand does not fall on the weekday named by this\n               operand, then the command is not issued.\n               \"Day name\" must be either the name of a weekday or a\n               unique abreviation of the name of a weekday.\n               \"Day name\" may be preceeded by a not sign (\u00ac) : e.g.,\n               WEEKDAY(\u00acTHU). In this case, if a date selected by the\n               DATE operand falls on the weekday named by this\n               operand, then the command is not issued.\n               \"Day name\" may be preceeded by a plus sign (+) : e.g.,\n               WEEKDAY(+THU). In this case, if a date selected by the\n               DATE operand does not fall on the weekday named by this\n               operand, then the execution of the automatic command is\n               delayed until the named weekday arrives.\n               \"Day name\" may be preceeded by a minus sign (-) :\n               e.g., WEEKDAY(-THU). In this case if the selected date\n               does not fall on the named weekday, then the execution\n               of the automatic command, instead of being delayed, is\n               moved forward to the desired weekday.\n         Examples : DATE(1/2/80) WEEKDAY(THU) means the Thursday that\n                                        is on or following 1 FEB 1980.\n                                        In this case that would be\n                                        February 7th.\n                    DATE(1/2/80) WEEKDAY(+THU) idem to previously.\n                    DATE(1/-/-) WEEKDAY(MON) means the first Monday of\n                                        every month.\n                    DATE(1/-/-) WEEKDAY(+MON) idem to previously.\n                    DATE(31/-/-) WEEKDAY(-FRI) means the last Friday of\n                                        every month.\n                    DATE(-/6/83) WEEKDAY(TUE) means every Tuesday in\n                                        June, 1983.\n                    DATE(-/-/-) WEEKDAY(WED) means every Wednesday.\n                    DATE(-/-/-) WEEKDAY(\u00acWED) means every day of the\n                                        year that is not Wednesday.\n               Specifying WEEKDAY(ANY) removes the weekday modifier\n               from the scheduled commands being changed.\n))WINDOW(hh:mm) : gives the length of time following the scheduled\n               execution of an automatic command that the command can\n               still be executed if, for some reason such as a system\n               crash, the command was not executed when it was supposed\n               to be. The window cannot extend past midnight. The\n               special value \"0:00\" has the meaning \"until midnight\".\n))IPLFORCED :  This indicates that if the system crashes and is\n               re-IPLed within the \"window\" period for this automatic\n               command, then this command is to be executed after the\n               IPL even if it has already been executed before the IPL.\n               When a scheduled command defined with the IPLFORCED\n               attribute is displayed, the letter I appears in the\n               FLAGS column.\n))NOTIPLFORCED : nullifies IPLFORCED. Type HELP CHANGE O(IPLFORCED) for\n               more information.\n))OVERRIDE :   This causes the scheduling of certain automatic commands\n               to be overridden by this command for a particular date.\n               The circumstances are these.\n               - The commands to be overridden must have the same\n                 application name as this command.\n               - The commands to be overridden must not themselves be\n                 designated as \"override\" commands.\n               - The commands to be overridden will be overridden only\n                 on those dates that this command will execute.\n                 The time of day is not relevent.\n               Use the \"DISPLAY DATE(dd/mm/yy) NAME(application name)\n               BOTH\" command to find which automatic commands are\n               overridden. Those commands showing the letter O in the\n               FLAGS column override all commands without the O flag.\n))NOOVERRIDE : nullifies OVERRIDE. Type HELP CHANGE O(OVERRIDE) for\n               more information.\n=DELETE=DE\n)F FUNCTION :  The DELETE subcommand removes one or more entries from\n               the automatic operator commands schedule.\n)X SYNTAX :    DELETE YESTERDAY/TODAY/TOMORROW/DATE(dd/mm/yy)\n                    /ANYTIME/OBSOLETE ID(identification numbers)\n                    NAME(application names) SYSID(sytem ids)\n                    OVERRIDE/NOOVERRIDE/BOTH/EITHER\n                    SHORT/LONG/PROMPT\n         Alias : The minimum abreviation is DE.\n         Required : at least one of either YESTERDAY, TODAY, DATE,\n               ANYTIME, ID, OBSOLETE, NAME, or SYSID.\n         Default : EITHER PROMPT\n         Notes : YESTERDAY, TODAY, TOMORROW, DATE, ANYTIME, OBSOLETE,\n               and ID are mutually exclusive. (Note that NAME and SYSID\n               are not mutually exclusive with these).\n               OVERRIDE, NOOVERRIDE, BOTH, and EITHER are mutually\n               exclusive.\n               SHORT, LONG, and PROMPT are mutually exclusive.\n)O OPERANDS :\n))YESTERDAY :  limits the deletion of scheduled commands to those that\n               executed yesterday.\n))TODAY :      limits the deletion of scheduled commands to those that\n               execute today.\n))TOMORROW :   limits the deletion of scheduled commands to those that\n               will execute tomorrow.\n))DATE(dd/mm/yy) : limits the deletion of scheduled commands to those\n               that will execute on the given date. If yy is 50 or\n               less, then the 21st century is assumed.\n))ANYTIME :    does not limit the deletion of scheduled commands with\n               respect to either execution date or ID number or\n               obsolescense. This is the default.\n               An alias for ANYTIME is ALL.\n))ALL :        This is an alias for ANYTIME.\n))OBSOLETE :   limits the deletion to those scheduled commands that are\n               obsolete - i.e., those commands that can never execute\n               again. The default is ANYTIME.\n))ID(identification numbers) : limits the deletion of scheduled\n               commands to those having the given identification\n               numbers. \"Identification numbers\" is a list of one or\n               more decimal numbers or pairs of decimal numbers joined\n               by a colin (:). Each number must be in the range of 0\n               to 65535. When joined pairs of numbers are given, the\n               second number must be equal to or larger than the first.\n               Such pairs indicate a range of scheduled commands to be\n               deleted.\n))NAME(application names) : limits the deletion to only those scheduled\n               commands associated with the given applications.\n               \"Application names\" is a list of one or more names each\n               of which consists of from one to eight alphameric or\n               national characters. The first character of each name\n               cannot be numeric.\n               Type HELP SCHEDULE O(NAME) for more information.\n))SYSID(system ids) : For multi-system configurations. This operand\n               limits the selection of scheduled commands to those\n               that are permitted to be executed on the computers\n               having the listed system ids.\n               A \"system id\" is a four-character identifier assigned\n               by SMF to a computer (for accounting purposes). Each\n               character is alphameric.\n               The \"SYSID\" operand may specify any number of system\n               identifiers. If a scheduled command matches any listed\n               identifier, then it is selected.\n               \"SYSID(CRNT)\" means the \"current computer\" - i.e., the\n               computer which you are currently logged on to.\n               \"SYSID(ANY)\" limits the selection to those scheduled\n               scheduled commands that are permitted to execute on\n               any computer in the configuration.\n               \"SYSID(ALL)\" does not limit the selection. This is\n               the default.\n         Example :  SYSID(SYSA ANY)\n               This selects those scheduled commands that must be\n               executed specifically by the computer named \"SYSA\" as\n               well as those commands that may be executed by any\n               computer in the configuration. (Scheduled commands\n               that must be executed specifically by the \"SYSB\"\n               computer are not selected).\n))SYSTEM(system ids) : This is an alias for SYSID.\n))OVERRIDE :   limits the deletion to only those scheduled commands\n               that are overrides. The default is EITHER.\n               Type HELP SCHEDULE O(OVERRIDE) for more information.\n))NOOVERRIDE : limits the deletion to only those scheduled commands\n               that are not overrides. The default is EITHER.\n               Type HELP SCHEDULE O(OVERRIDE) for more information.\n))BOTH :       deletes scheduled commands without reguard to whether\n               or not they are overrides. The default is EITHER.\n               Type HELP SCHEDULE O(OVERRIDE) for more information.\n))EITHER :     If the deletion of scheduled commands is limited to a\n               particular date (via the DATE, YESTERDAY, TODAY, or\n               TOMORROW operands), then for particular application\n               names if overriding scheduled commands exist for that\n               date, then they are deleted and the overridden commands\n               are not deleted. If no overriding commands exist for\n               that date for the application, then the non-overriding\n               commands are deleted.\n               If a specific date is not given, then EITHER functions\n               exactly like BOTH.\n               EITHER is the default.\n))PROMPT :     displays a descriptive message for each scheduled\n               command to be deleted, and then prompts you to may a\n               final delete/no-delete decision for that scheduled\n               command. This is the default.\n))LONG :       displays a discriptive message for each scheduled\n               command to be deleted, and then deletes it (without\n               prompting you for a final decision).\n               The default is PROMPT.\n))SHORT :      displays only a count of the number of scheduled\n               commands deleted. Individual descriptive messages are\n               not displayed. Nor are you prompted for a final\n               delete/no-delete decision.\n               The default is PROMPT.\n=END=E\n)F FUNCTION :  The END subcommand causes the SCHEDULE command processor\n               to end. If a SCHEDULE, CHANGE, or DELETE subcommand has\n               been issued, then the END subcommand automatically\n               causes a 'S SCHEDRUN' operator command to be issued.\n               By this means, the system is notified of possible\n               changes to the automatic operator commands schedule.\n)X SYNTAX :    END\n         Alias : The minimum abreviation is E.\n)O OPERANDS : none.\n./     ALIAS   NAME=SCHED\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TO": {"ttr": 37127, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x13\\x1f\\x00\\x94\\x13\\x1f\\x15B\\x00\\xf6\\x00\\xf6\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-11T00:00:00", "modifydate": "1994-05-11T15:42:00", "lines": 246, "newlines": 246, "modlines": 0, "user": "SYSPAJA"}, "text": "TOCP     TITLE '-   T O   - TSO-COMMAND.'\nTO       START 0\n         SPACE 1\n* AUTHOR : BILL GODFREY, PLANNING RESEARCH CORPORATION.\n* -------- INSTALLATION : PRC COMPUTER CENTER INC, MCLEAN VA.\n*          DATE WRITTEN : MARCH 5 1976.\n*          DATE UPDATED : DECEMBER 11 1980.\n*                         11DEC80 - CHANGE SS01 TO TSSO.\n*                         11DEC80 - 3-BYTE USERID NO LONGER ASSUMED\n*                                   IN MSG05, MSG07.\n*          ATTRIBUTES : RE-ENTRANT.\n*\n* DESCRIPTION : THIS TSO COMMAND SENDS A MESSAGE TO A TSO USER.\n* ------------- IT DIFFERS FROM THE 'SEND' COMMAND IN THAT THE\n*               MESSAGE IS NOT IN QUOTES, SO YOU DON'T HAVE TO\n*               THINK ABOUT QUOTES WITHIN YOUR MESSAGE.\n*\n*               THE SYNTAX IS : TO USERID MESSAGE-TEXT\n*\n*               EXAMPLES : TO JONES WHERE'S THAT REPORT\n*                          TO (JONES SMITH) OK, WE'LL TEST IT.\n*\n*               THIS COMMAND WILL NOT PUT A MESSAGE IN A USER'S\n*               BROADCAST MAIL.\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12,LV=@DATAL,TYPE=RENT\n         USING @DATA,R13\n        $TEW$EC NOTTSO=(,ONLY),MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE\n        $TEW$PP PARM=PARMLST,REG=R3,ATT=SETRC\n         LA    R4,USERID\n         LA    R5,SPACE\n         LA    R6,STRING\n         TM    STRING+6,X'80'      TEXT SPECIFIED?\n         BZ    ERRNOTXT            NO, BRANCH\n         MVI   MYTEXT-1,C' '\n         MVC   MYTEXT,MYTEXT-1     BLANK THE TEXT\n         LH    R1,STRING+4         GET LENGTH OF TEXT\n         LTR   R1,R1               LENGTH ZERO?\n         BNP   ERRNOTXT            YES, BRANCH\n         BCTR  R1,0                LENGTH MINUS 1\n         L     R14,STRING          GET ADDRESS OF TEXT\n         B     *+L'*+6\n         MVC   MYTEXT(0),0(R14)    MOVE TEXT\n         EX    R1,*-6              EXECUTE THE ABOVE MVC\n         LA    R14,MYTEXT+1(R1)    POINT PAST LAST BYTE OF TEXT\n         MVC   0(2,R14),=CL2' '\n         LA    R7,1+2+8(,R1)       TOTAL LENGTH IN R7\n         LA    R6,MYTEXT\n         L     R1,CVTPTR           ADDRESS OF CVT\n         USING CVT,R1\n         L     R1,CVTTCBP          TCB WORDS\n         DROP  R1\n         L     R1,4(,R1)           CURRENT TCB\n         USING TCB,R1\n         L     R1,TCBTIO           TIOT ADDRESS\n         DROP  R1\n         SPACE 1\n*------- IF THIS IS ISSUED FROM A BATCH JOB, THE LENGTH OF\n*        THE TEXT INCLUDES SOME TRAILING BLANKS, SO BACK UP\n*        TO THE LAST NON-BLANK TO APPEND THE JOB-NAME.\n         SPACE 1\n         MVC   2(8,R14),0(R1)      APPEND JOBNAME/USERID\n*         CLC   0(8,R1),=CL8'TSSO'  IS THIS &TO FROM CONSOLE?      -EU-\n*         BNE   USERLOOP            NO                             | S\n*         MVC   2(8,R14),=CL8' '    YES, ERASE THAT APPENDED NAME  | U\n*         LA    R0,12               BACK UP AS MANY AS 12 BYTES    | P\n*TRAIL    BCTR  R14,0               BACK UP 1 BYTE                 | P\n*         CLI   0(R14),C' '         IS IT A BLANK?                 | R\n*         BNE   TRAILX              NO, GO APPEND ID               | E\n*         BCT   R0,TRAIL            KEEP BACKING UP                | S\n*TRAILX   LA    R14,1(,R14)         POINT PAST NON-BLANK           | S\n*         MVC   2(8,R14),=CL8'OPER' APPEND OPER                    -EU-\nUSERLOOP TM    6(R4),X'80'         USERID SPECIFIED?\n         BZ    ERRNOUSR            NO, BRANCH\n         LH    R1,4(,R4)           GET LENGTH OF USERID\n         LTR   R1,R1               LENGTH ZERO?\n         BNP   ERRNOUSR            YES, BRANCH\n         MVC   MYUSER,=CL8' '      BLANK USERID\n         BCTR  R1,0                LENGTH MINUS 1\n         L     R14,0(R4)           GET ADDRESS OF USERID\n         B     *+L'*+6\n         MVC   MYUSER(0),0(R14)    MOVE TEXT\n         EX    R1,*-6              EXECUTE THE ABOVE MOVE\n         SPACE 1\n         L     R1,CVTPTR           CVTPTR\n         USING CVT,R1\n         L     R1,CVTASVT          POINT TO ADDRESS SPACE VECTOR\n         DROP  R1\n         USING ASVT,R1\n         L     R0,ASVTMAXU         MAX. NO. OF ADDRESS SPACES\n         LA    R1,ASVTENTY         FIRST ASID\n         DROP  R1\nASIDLOOP L     R15,0(,R1)          GET AN ASCB ADDRESS\n         LTR   R15,R15             IS THIS AN ACTIVE ADDRESS SPACE\n         BM    ASIDNEXT            NO, BRANCH\n         USING ASCB,R15\n         L     R14,ASCBTSB         ADDRESS OF TSB\n         LTR   R14,R14             IS THIS A TSO SESSION?\n         BZ    ASIDNEXT            NO, BRANCH\n         L     R14,ASCBJBNS        GET JOBNAME (USERID)\n         CLC   MYUSER,0(R14)       DOES USERID MATCH\n         BE    ASIDX               YES, BRANCH\nASIDNEXT LA    R1,4(,R1)           POINT TO NEXT ASVTENTY ENTRY\n         BCT   R0,ASIDLOOP         BRANCH UNTIL ASVTMAXU EXCEEDED\n         B     TPTL20\nASIDX    LH    R15,ASCBASID        GET ASID FROM ASCB\n         LR    R8,R15              COPY ASID\n         DROP  R15\n        TPUT   (R6),(R7),ASID=(R8)\n         B     *+L'*(R15)          HOW COMPLETE?\n         B     NEXTUSER            +0 - OK\n         B     TPTL04              +4 -\n         B     TPTL08              +8 -\n         B     TPTL12              +12 -\n         B     TPTL16              +16 -\n         B     TPTL20              +20 -\n         SPACE 1\nTPTL04   MVC   MYMSG(MSG03L),MSG03\n         MVC   MYMSG+(MSG03A-MSG03)(7),MYUSER\n         LA    R1,MYMSG\n         LA    R0,MSG03L\n         B     TPTLMSG\nTPTL08   MVC   MYMSG(MSG04L),MSG04\n         MVC   MYMSG+(MSG04A-MSG04)(7),MYUSER\n         LA    R1,MYMSG\n         LA    R0,MSG04L\n         B     TPTLMSG\nTPTL12   MVC   MYMSG(MSG05L),MSG05\n         MVC   MYMSG+(MSG05A-MSG05)(7),MYUSER\n         LA    R1,MYMSG\n         LA    R0,MSG05L\n         B     TPTLMSG\nTPTL16   MVC   MYMSG(MSG06L),MSG06\n         MVC   MYMSG+(MSG06A-MSG06)(7),MYUSER\n         LA    R1,MYMSG\n         LA    R0,MSG06L\n         B     TPTLMSG\nTPTL20   MVC   MYMSG(MSG07L),MSG07\n         MVC   MYMSG+(MSG07A-MSG07)(7),MYUSER\n         LA    R1,MYMSG\n         LA    R0,MSG07L\nTPTLMSG  BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE?\n         B     NEXTUSER            +0 - OK\n         B     SETRC               +4 - ERROR\n         SPACE 1\nNEXTUSER CLI   8(R4),X'FF'\n         BE    LEAVE\n         L     R4,8(,R4)\n         B     USERLOOP\nERRNOTXT LA    R1,MSG01\n         LA    R0,L'MSG01\n         B     SNDMSG\nERRNOUSR LA    R1,MSG02\n         LA    R0,L'MSG02\nSNDMSG   BAS   R14,PUTLNE\nSETRC    LA    R2,16               RC=16 ------------------------------\n         B     QUIT\nLEAVE    XR    R2,R2               RC=0 -------------------------------\nQUIT    IKJRLSA #TSANSW\n        $XRET  CC=(R2),LV=@DATAL,TYPE=RENT\n         EJECT\n*------- CONSTANTS.\n         SPACE 1\nMSG01    DC    C'NO TEXT SPECIFIED.'\nMSG02    DC    C'NO USERID SPECIFIED.'\nMSG03    DC    C'MESSAGE NOT SENT TO '\nMSG03A   DC    C'        - NO BUFFERS AVAILABLE.'\nMSG03L   EQU   *-MSG03\nMSG04    DC    C'MESSAGE NOT SENT TO '\nMSG04A   DC    C'        - ATTN INTERRUPT.'\nMSG04L   EQU   *-MSG04\nMSG05    DC    C'MESSAGE NOT SENT TO '\nMSG05A   DC    C'        - PROFILE NOINTERCOM.'\nMSG05L   EQU   *-MSG05\nMSG06    DC    C'MESSAGE NOT SENT TO '\nMSG06A   DC    C'        - LOGIC ERROR IN COMMAND.'\nMSG06L   EQU   *-MSG06\nMSG07    DC    C'MESSAGE NOT SENT TO '\nMSG07A   DC    C'        - NOT LOGGED ON.'\nMSG07L   EQU   *-MSG07\n         SPACE 1\n         LTORG\n         EJECT\n*------- PARSE PCL.\n         SPACE 1\n         PRINT NOGEN\nPARMLST  IKJPARM\nUSERID   IKJIDENT 'USERID',LIST,                                       X\n               FIRST=ANY,OTHER=ALPHANUM,MAXLNTH=7,                     X\n               VALIDCK=USEVC,                                          X\n               PROMPT='USERID TO WHOM MESSAGE IS TO BE SENT'\nSPACE    IKJPOSIT SPACE\nSTRING   IKJPOSIT STRING,ASIS,PROMPT='TEXT OF MESSAGE TO BE SENT'\n         IKJENDP\n         PRINT GEN\n         SPACE 1\n*------- THIS VALIDITY CHECK ROUTINE CHECKS THE FIRST CHARACTER\n*        OF EACH USERID SPECIFIED. THE IKJIDENT MACRO SPECIFIES\n*        FIRST=ANY SO THAT PARSE IS FORCED TO TREAT THE FIRST\n*        OPERAND ENTERED AS THE USERID. THEN THIS ROUTINE REJECTS\n*        IT AS IF IT WERE FIRST=ALPHA. SPECIFYING FIRST=ALPHA AND\n*        ENTERING SOMETHING LIKE \" TO 'XXX' \" WOULD CAUSE PARSE\n*        TO TAKE XXX' AS THE STRING AND PROMPT FOR USERID, WHICH\n*        IS NOT DESIRED HERE.\n         SPACE 1\n         DC    0H'0'\n         USING *,R10\nUSEVC    STM   R14,R12,12(R13)\n         USING VCPL,R1\n         LR    R10,R15\n         L     R2,PDEADR           POINT R2 TO PDE\n         DROP  R1\n         XR    R15,R15\n         L     R1,0(,R2)           POINT TO USERID\n         CLI   0(R1),C'A'          LESS THAN 'A'?\n         BL    *+L'*+8             YES\n         CLI   0(R1),C'Z'          GREATER THAN Z?\n         BNH   *+L'*+4             NO\n         LA    R15,4\n         L     R14,R12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n         DROP  R10\n         EJECT\n*------- DSECTS.\n         SPACE 1\n@DATA    DSECT\n         DS    18F\n        $TEW$WA\nMYUSER   DS    CL8\nMYMSG    DS    CL80\nMYTEXTB  DS    C                   MYTEXT MINUS 1\nMYTEXT   DS    256C\n@DATAL   EQU   (((*-@DATA)+7)/8)*8\n         SPACE 1\n         PRINT NOGEN\n        $TEW$DS VCPL=YES\n         IHAASVT\n         IHAASCB\n         IKJTCB\n         PRINT GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TO$": {"ttr": 37132, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15H\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:48:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//TO       JOB (........),'INSTALL  - T O -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=10\n//ASS     EXEC PAJ4AS3,OPT=',RENT',MBR=TO\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   TO\n  NAME    TO(R)\n/*\n//HLP     EXEC PAJHELP,MBR=TOH,DSS='->.SOURCE.FILE4'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TO@": {"ttr": 37134, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00 \\x00 \\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/11/85\n                                                      TO        1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *    TO : SEND A MESSAGE TO A USER    * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n   CBT origin : Extracted from CBT 84 JUN, file 300.\n   ------------\n\n   Function : The TO command sends a message to a user at another\n   ---------- terminal. It differs from the SEND command in that\n              the text of the message is not in quotes, so you don't\n              have to think about doubling quotes contained in your\n              text. Also, this command cannot put a message in the\n              user's broadcast mail.\n\n   Syntax   : TO  USERID  MESSAGE\n   ----------\n   Examples - TO X99XXXX WHERE'S THAT REPORT?\n              TO (Y99YYYY Z99ZZZZ) LET'S ME WRITE IT.\n   Required - USERID and MESSAGE\n   Defaults - none.\n   ALIAS    - none.\n\n   Operands :\n   ----------\n  USERID    -  one or more USERid's (enclosed between parentheses),\n               to whom the message is to be sent.\n  MESSAGE   -  the message text.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TOH": {"ttr": 37377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=TO\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION : THE \"TO\" COMMAND SENDS A MESSAGE TO A USER AT ANOTHER\n              TERMINAL. IT DIFFERS FROM THE \"SEND\" COMMAND IN THAT\n              THE TEXT OF THE MESSAGE IS NOT IN QUOTES, SO YOU DON'T\n              HAVE TO THINK ABOUT DOUBLING QUOTES CONTAINED IN YOUR\n              TEXT. ALSO, THIS COMMAND CANNOT PUT A MESSAGE IN THE\n              USER'S BROADCAST MAIL.\n)X SYNTAX   : TO  'USERID'  MESSAGE\n   EXAMPLES - TO X99XXXX WHERE'S THAT REPORT?\n              TO (Y99YYYY Z99ZZZZ) LET'S ME WRITE IT.\n   REQUIRED - USERID, MESSAGE\n   DEFAULTS - NONE.\n   ALIAS    - NONE.\n)O OPERANDS :\n  'USERID'  -  ONE OR MORE USERIDS, TO WHOM THE MESSAGE IS TO BE SENT.\n  'MESSAGE' -  THE MESSAGE TEXT.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WHATDSN": {"ttr": 37379, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94#\\x7f\\x00\\x94#\\x7f\\x16(\\x01j\\x01j\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-25T00:00:00", "modifydate": "1994-08-25T16:28:00", "lines": 362, "newlines": 362, "modlines": 0, "user": "SYSPAJA"}, "text": "WDSN     TITLE 'WHATDSN -- DSNAME(S) CLIST TSO-COMMAND.'\nWHATDSN  START 0\n         SPACE 1\n*--------------------------------------------------------------------*\n*                           W H A T D S N                            *\n*--------------------------------------------------------------------*\n*  ORIGIN :     EXTRACTED FROM TAPE CBT 89 FEB, FILE270.\n*  --------     ADAPTED BY MOINIL P.A.\n*\n*  COMMAND      OPERANDS\n*  --------     ------------------------------------------------------\n*  WHATDSN      DDNAME('DDNAME')  ALL  LIST\n*\n*  OPERANDS :\n*  ----------\n*  1. REQUIRED :\n*        DDNAME('DDNAME') = 'DDNAME' IS THE DDNAME THAT YOU WISH TO\n*                   HAVE THE DSNAME(S) THAT IS/ARE ASSOCIATED WITH\n*                   THAT DDNAME.\n*                   ALIASES : DDN, DD, D, FILE, FI OR F.\n*  2. OPTIONAL :\n*        ALL = IF ALL IS GIVEN, THIS COMMAND WILL RETURN ALL OF THE\n*                   DSNAMES WHICH MAY BE CONCATENATED TO THE DDNAME\n*                   IN CLIST VARIABLES &DSNAME1 THRU &DSNAME9 AND\n*                   &DSNSCNT WILL CONTAIN THE TOTAL NUMBER OF\n*                   DSNAMES ASSOCIATED WITH THE DDNAME (&DSNSCNT\n*                   COULD POTENTIALLY CONTAIN A VALUE GREATER THAN\n*                   9), HOWEVER, IF ALL IS NOT GIVEN, THEN ONLY THE\n*                   DSNAME THAT IS CONCATENATED \"AT THE TOP OF THE\n*                   STACK\" IS GIVEN AND RETURNED IN &DSNAME.\n*        LIST = FORCE SEND MESSAGE.\n*\n*  THIS COMMAND WILL ALSO RETURN A VALUE IN REGISTER 15 (THE RETURN\n*  CODE) REPRESENTING THE SUCCESS OR NONSUCCESS OF THIS COMMAND :\n*\n*        -----------------------------------------------------------\n*        | &LASTCC | MEANING                                       |\n*        |---------|-----------------------------------------------|\n*        |    0    | SUCCESSFUL COMPLETION                         |\n*        |---------|-----------------------------------------------|\n*        |    8    | DDNAME NOT ALLOCATED                          |\n*        |---------|-----------------------------------------------|\n*        |   12    | CONCATENATED DATA-SETS NAMES TABLE OVERFLOW   |\n*        |---------|-----------------------------------------------|\n*        |   96    | INVALID SYNTAX OF OPERAND(S)                  |\n*        -----------------------------------------------------------\n*\n*  ERROR RETURN CODE (&LASTCC) WITH NO OTHER CLIST VARIABLES SET :\n*            100 = PARSE ERROR OR INTERRUPT\n*            104 = RUN ERROR\n         EJECT\nWHATDSN  AMODE 24\nWHATDSN  RMODE 24\n         SPACE 1\n        $DEFREG\nNTBEL    EQU   99                  NUMBER OF DSNAMES IN TABLE,\n*                                  MAXIMUM POSSIBLE IS 255 (JCL LAW).\n         EJECT\n        $XENT  BASE=R12,LV=WORKLEN,TYPE=RENT\n         LR    R10,R13\n         USING WORKAREA,R10\n         LA    R2,18*4(R10)\n         L     R3,=A(WORKLEN-(18*4))\n         LR    R4,R2\n         XR    R5,R5\n         MVCL  R2,R4\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE\n        $TEW$PP PARM=PARMLST,REG=R6,ERR=PARSERR,ATT=PARSERR\n         SPACE 1\n*------- LOAD THE PARSED FIELD INTO THE DATA FIELD DDNAME\n*        (DDNAME WILL CONTAIN THE DDNAME ENTERED BY THE USER\n*        IN THE DDNAME KEYWORD)\n         SPACE 1\n         TM    DSTRING+6,X'80'     IS DDNAME PRESENT ?\n         BZ    OPNDERR             BRANCH IF NOT\n         MVC   DDNAME,=CL8' '      MOVE SPACES TO DDNAME\n         LA    R1,DDNAME           R1 ==> ADDR OF DATA FIELD DDNAME\n         L     R3,DSTRING          R3 ==> ADDRESS OF THE DDNAME\n         LH    R5,DSTRING+4        R5 ==> LENGTH OF THE DDNAME\n         CL    R5,=F'8'\n         BH    OPNDERR\n         BCT   R5,*+L'*+6          SUBTRACT 1 FOR EX\n         MVC   0(0,R1),0(R3)       MOVE THE DDNAME TO DDNAME\n         EX    R5,*-6\n         CLC   ALL,=XL2'0'         WAS ALL SPECIFIED ?\n         BE    *+L'*+4             BRANCH IF NOT\n         OI    SWITCH,ALLOFEM      SAY YES\n         CLC   LIST,=XL2'0'        WAS LIST SPECIFIED ?\n         BE    *+L'*+4             BRANCH IF NOT\n         OI    SWITCH,NCLIST       SAY YES, SET 'NOT CLIST' INDICATOR\n         DROP  R6\n         SPACE 1\n*------- CALL THE SUBROUTINE DSNTAB TO GET ALL CONCATENATED DATA-SETS\n*        NAMES TO THE GIVEN DDNAME (ALL OF THE ASSOCIATED DSNAMES AND\n*        THEIR LENGTHS ARE PASSED BACK).\n*        IF THE DDNAME IS ALLOCATED AND THERE ARE NO OVERFLOW OF THE\n*        CONCATENATED DATA-SETS NAMES TABLE, THE TABLE DSNSTABL IS\n*        LOADED WITH ALL OF THE DSNAMES WHICH ARE ASSOCIATED WITH\n*        THE DDNAME. THE NUMBER OF SIGNIFICANT ENTRIES IN THAT TABLE\n*        IS IN #OFDSNS.\n*        IF THE DDNAME IS NOT ALLOCATED, THEN EXIT WITH RC=8, AND\n*        IF THERE IS AN OVERFLOW OF THE DATA-SETS NAMES CONCATENATED\n*        TO THE DDNAME, THEN EXIT WITH RC=12\n         SPACE 1\n         LA    R1,LSTCALL\n         LA    R15,DDNAME\n         ST    R15,0(R1)\n         LA    R15,DSNSTABL\n         ST    R15,4(R1)\n         LA    R15,=Y(NTBEL*L'DSNSTABL)\n         ST    R15,8(R1)\n         LA    R15,#OFDSNS\n         ST    R15,12(R1)\n         OI    12(R1),X'80'\n         L     R15,=V(DSNTAB)\n         BASR  R14,R15\n         LTR   R15,R15\n         BZ    DSNSX\n         LA    R4,8                RC=8 -------------------------------\n         CL    R15,=F'4'           NOT ALLOCATED ?\n         BE    QUIT                YES, ELSE TOO MANY\n         LA    R4,12               RC=12 ------------------------------\n         B     QUIT\n         SPACE 1\n*------- CONSTRUCT PARM.LIST FOR IKJCT441\n         SPACE 1\nDSNSX    XR    R4,R4               RC=0 -------------------------------\n         L     R1,CVTPTR           FIND CVT\n         USING CVTMAP,R1\n         L     R8,CVTTVT           FIND THE TSVT\n         DROP  R1\n         LA    R1,TSVEUPDT\n         ST    R1,ENTRYCDE\n         LA    R1,ENTRYCDE\n         ST    R1,CT441PRM+0\n         LA    R1,VARINAME\n         ST    R1,NAMEADDR\n         LA    R1,NAMEADDR\n         ST    R1,CT441PRM+4\n         LA    R1,NAMELENG\n         ST    R1,CT441PRM+8\n         LA    R1,DATAADDR\n         ST    R1,CT441PRM+12\n         LA    R1,DATALENG\n         ST    R1,CT441PRM+16\n         LA    R1,TOKENPRM\n         ST    R1,CT441PRM+20\n         OI    CT441PRM+20,X'80'   SET VL=1\n         SPACE 1\n*------- STORE TSO CLIST VARIABLES\n         SPACE 1\n         MVC   NAMSVAR,=CL8'DSNME' SET VAR &DSNME\n         LA    R2,NAMSVAR          R2 ==> ADDRESS OF VAR NAME\n         LA    R3,5                R3 = LENGTH OF VAR NAME\n         LA    R5,DSNSTABL         R5 ==> ADDRESS OF DSN TABLE\n         USING DSNTDS,R5\n         LA    R1,DSNTDSN          R1 ==> ADDRESS OF VAR VALUE\n         XR    R0,R0               R0 = LENGTH OF DATA FIELD\n         ICM   R0,B'0011',DSNTDSL\n         BAS   R9,STOVAR\n         SPACE 1\n         TM    SWITCH,ALLOFEM      HAS ALL DSNAMES BEEN REQUESTED ?\n         BZ    QUIT                BRANCH IF NOT\n         SPACE 1\n         LH    R1,#OFDSNS          SET VAR &DSNSCNT\n         CVD   R1,DUBLWURD\n         UNPK  DUBLWURD(3),DUBLWURD+6(2)\n         OI    DUBLWURD+2,C'0'\n         LA    R1,DUBLWURD         R1 ==> ADDRESS OF VAR VALUE\n         LA    R0,3                R0 = LENGTH OF DATA FIELD\n         LA    R2,=C'DSNSCNT'      R2 ==> ADDRESS OF VAR NAME\n         LA    R3,7                R3 = LENGTH OF VAR NAME\n         BAS   R9,STOVAR\n         SPACE 1\n         LA    R6,1                SET VAR &DSNME1 THRU &DSNME...\nLOOP     CVD   R6,DUBLWURD\n         UNPK  DUBLWURD(3),DUBLWURD+6(2)\n         OI    DUBLWURD+2,C'0'\n         CH    R6,=H'100'\n         BNL   OV100\n         CH    R6,=H'10'\n         BNL   OV10\n         MVC   NAMSVAR+5(1),DUBLWURD+2\n         LA    R3,6                R3 = LENGTH OF VAR NAME\n         B     SETM\nOV10     MVC   NAMSVAR+5(2),DUBLWURD+1\n         LA    R3,7                R3 = LENGTH OF VAR NAME\n         B     SETM\nOV100    MVC   NAMSVAR+5(3),DUBLWURD\n         LA    R3,8                R3 = LENGTH OF VAR NAME\nSETM     LA    R2,NAMSVAR          R2 ==> ADDRESS OF VAR NAME\n         LA    R1,DSNTDSN          R1 ==> ADDRESS OF VAR VALUE\n         XR    R0,R0               R0 = LENGTH OF DATA FIELD\n         ICM   R0,B'0011',DSNTDSL\n         BAS   R9,STOVAR\n         LA    R5,L'DSNSTABL(,R5)\n         LA    R6,1(,R6)\n         CH    R6,#OFDSNS          NUMBER OF SIGNIFICANT DSNAMES\n         BNH   LOOP\n         DROP  R5\n         SPACE 1\n*------- END OF PROCESSING\n         SPACE 1\nQUIT    IKJRLSA #TSANSW\n        $XRET  CC=(R4),LV=WORKLEN,TYPE=RENT\nOPNDERR  LA    R4,96               RC=96 ------------------------------\n         B     QUIT\nPARSERR  LA    R4,100              RC=100 -----------------------------\n         B     QUIT\nSETRC    LA    R4,104              RC=104 -----------------------------\n         B     QUIT\n         EJECT\n* ------ 'STOVAR' ROUTINE : STORE A VARIABLE.\n*        FILL IKJCT441 PARM.LIST, THEN CHECK IKJCT441 SERVICE FOR\n*              ERROR AND SEND MESSAGE.\n*        CALLING SEQUENCE :\n*              LA   R0,VARIABLE VALUE LENGTH\n*              LA   R1,VARIABLE VALUE ADDRESS\n*              LA   R2,VARIABLE NAME ADDRESS\n*              LA   R3,VARIABLE NAME LENGTH\n*              BAS  R9,STOVAR\n*        REGISTERS USED : R0, R1, R2, R3, R14 AND R15.\n*                         R8 = ADDRESS OF TSVT.\n*                         R9 = LINK REGISTER.\n         SPACE 1\nSTOVAR   LR    R15,R3\n         BCT   R15,*+L'*+6         COMPUTE MOVE LENGTH\n         MVC   VARINAME(*-*),0(R2)\n         EX    R15,*-6             MOVE VARIABLE NAME\n         ST    R3,NAMELENG         SET VARIABLE NAME LENGTH\n         ST    R1,DATAADDR         SET VARIABLE VALUE ADDRESS\n         AR    R1,R0               POINT PAST END OF STRING\n         BCTR  R1,0                BACK UP TO THE PREVIOUS CHARACTER\n         CLI   0(R1),C' '\n         BNE   *+L'*+8\n         BCT   R0,*-10\n         LA    R0,1\n         ST    R0,DATALENG         SET VARIABLE VALUE LENGTH\n         TM    SWITCH,NCLIST       ARE WE IN CLIST ?\n         BO    STOLST+L'STOLST     NO, GO LIST\n         LA    R1,CT441PRM         YES, POINT AT PARM LIST\n         USING TSVT,R8\n         L     R15,TSVTVACC        LOAD THE VARIABLE ACCESS RTN\n         BASR  R14,R15             CALL IT\n         DROP  R8\n         LTR   R15,R15             ANY ERROR?\n         BZR   R9                  NO, OK\n         CH    R15,=H'40'          YES, IS IT 'NOT CLIST' RC ?\n         BE    STOLST              YES, GO LIST\n         MVC   MSGBUF(25),=CL25' -> IKJCT441 : RC =    / '\n         CVD   R15,DUBLWURD\n         OI    DUBLWURD+L'DUBLWURD-1,X'0F'\n         UNPK  MSGBUF+19(3),DUBLWURD+L'DUBLWURD-2(2)\n         MVI   MSGBUF+19,C' '\n         MVC   MSGBUF+25(L'MSGBUF-25),MSGBUF+24\n         L     R1,NAMELENG\n         BCT   R1,*+L'*+6\n         MVC   MSGBUF+25(*-*),VARINAME\n         EX    R1,*-6\n         MVC   WTOMSG(2),WSKEL\n         LA    R1,L'MSGBUF+4\n         STCM  R1,B'0011',WTOMSG+2\n         MVC   DCRC(4),WSKEL+6\n         LA    R1,WTOMSG\n         BAS   R14,PUTMSG\n         BR    R9\nSTOLST   OI    SWITCH,NCLIST       SET 'NOT CLIST' INDICATOR\n         MVI   MSGBUF,C' '         CLEAR BUFFER TO SPACES\n         MVC   MSGBUF+1(L'MSGBUF-1),MSGBUF\n         L     R1,NAMELENG\n         BCT   R1,*+L'*+6\n         MVC   MSGBUF+1(*-*),VARINAME\n         EX    R1,*-6\n         MVI   MSGBUF+10,C':'\n         L     R1,DATALENG\n         L     R2,DATAADDR\n         BCT   R1,*+L'*+6\n         MVC   MSGBUF+12(*-*),0(R2)\n         EX    R1,*-6\n         LA    R0,L'MSGBUF\n         LA    R1,MSGBUF\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     0(R9)               +0 - OK\n         B     SETRC               +4 - ERROR\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*             D A T A     A R E A     C O N S T A N T S             *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\nWSKEL   WTO    'XX',ROUTCDE=11,DESC=7,MF=L\n         SPACE 1\n        LTORG\n         SPACE 1\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*                     P A R S E     M A C R O S                     *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\n        PRINT  NOGEN\nPARMLST IKJPARM\nFILE    IKJKEYWD\n        IKJNAME 'FILE',SUBFLD=DDNAM,                                   X\n               ALIAS=('DDNAME','DDN','DD','D','FI','F')\nALL     IKJKEYWD\n        IKJNAME 'ALL'\nLIST    IKJKEYWD\n        IKJNAME 'LIST'\nDDNAM   IKJSUBF\nDSTRING IKJPOSIT DSNAME\n        IKJENDP\n        PRINT  GEN\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*               D Y N A M I C     W O R K     A R E A               *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\nWORKAREA DSECT\n         DS    18F                 SAVE AREA\nDUBLWURD DS    D\n        $TEW$WA\n         SPACE 1\nLSTCALL  DS    4A\nCT441PRM DS    6F                  IKJCT441 PARM.LIST\nENTRYCDE DS    F                   ENTRY CODE\nNAMEADDR DS    A                   ADDRESS OF VARIABLE NAME\nNAMELENG DS    F                   LENGTH OF VARIABLE NAME\nDATAADDR DS    A                   ADDRESS OF VARIABLE DATA\nDATALENG DS    F                   LENGTH OF VARIABLE DATA\nTOKENPRM DS    F                   TOKEN TO VARIABLE ACCESS SERVICE\nVARINAME DS    CL32                VARIABLE NAME FIELD\n         SPACE 1\nWTOMSG   DS    F                   WTO - TEXT LENGTH, MCSFLAGS\nMSGBUF   DS    CL72                MESSAGE AREA\nDCRC     DS    CL4                 WTO - DESCRIPTOR AND ROUTING CODES\n         SPACE 1\nNAMSVAR  DS    CL8\nDDNAME   DS    CL8\n#OFDSNS  DS    H\nSWITCH   DS    XL1\nALLOFEM  EQU   X'80'\nNCLIST   EQU   X'40'\n         SPACE 1\n         DS    0F\nDSNSTABL DS    (NTBEL)CL(DSNTDSEL)\n         SPACE 1\nWORKLEN  EQU   (((*-WORKAREA)+7)/8)*8\n         SPACE 1\n*------- DSNAME(S) TABLE DSECT\n         SPACE 1\nDSNTDS   DSECT\nDSNTDSL  DS    H\nDSNTDSN  DS    CL44\nDSNTDSEL EQU   *-DSNTDS\n         SPACE 1\n*------- OTHER DSECT'S\n         SPACE 1\n        PRINT  NOGEN\n        $TEW$DS\n        IKJTSVT\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WHATDSN$": {"ttr": 37386, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x943?\\x00\\x943?\\t'\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-29T00:00:00", "modifydate": "1994-11-29T09:27:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": "//WHATDSN  JOB (........),'INSTALL - WHATDSN -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=5\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                DSNTAB                                             *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ4AS3,OPT=',RENT',MBR=WHATDSN\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT'\n//SYSIN     DD *\n  INCLUDE SYSADD(DSNTAB)\n  ENTRY   WHATDSN\n  NAME    WHATDSN(R)\n/*\n//HLP     EXEC PAJHELP,MBR=WHATDSNH,DSS='->.SOURCE.FILE4'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WHATDSN@": {"ttr": 37388, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94#\\x7f\\x00\\x94#\\x7f\\x16A\\x00E\\x00E\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-25T00:00:00", "modifydate": "1994-08-25T16:41:00", "lines": 69, "newlines": 69, "modlines": 0, "user": "SYSPAJA"}, "text": "1   01/08/90\n                                                      WHATDSN   1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *         WHATDSN TSO command         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Command name :      WHATDSN\n  Author :            Jeff Sprehn\n  Agency :            WDPSC\n  Origin :            Extracted from tape CBT 89 FEB, file 270\n  Function :          The WHATDSN command is intended for use in\n                      command procedures. This command returns to\n                      the CLIST the DSNAME(s) of the data-set(s)\n                      which is/are allocated to the DDNAME given.\n                      This command is used to pass back to the CLIST :\n                         only the DSNAME of the data-set which is \"at\n                         the top of the stack\" (if several data-sets\n                         are concatenated to that DDNAME),\n                      or the DSNAME of each and every data-set (up to\n                         99) which are allocated to the DDNAME.\n             Remark : if this command is invoked outside a CLIST, the\n             -------- contents of all variables are displayed to the\n                      terminal, and no CLIST variables are set.\n  Syntax :\n  ____________________________________________________________________\n  Command    Operands\n  --------------------------------------------------------------------\n  WHATDSN    DDNAME('ddname') ALL LIST\n  --------------------------------------------------------------------\n\n  Operands :\n\n  1. Required :\n     DDNAME('ddname') = 'ddname' is the DDNAME for which you wish to\n                           know the data-set name.\n                        Aliases : DDN, DD, D, FILE, FI or F.\n\n  2. Optional :\n     ALL = if ALL is given, this command will return all of the DSNAMEs\n                           which may be concatenated to the DDNAME in\n                           CLIST variables &DSNME1 through &DSNME99 and\n                           the CLIST variable &DSNSCNT will contain the\n                           total number of DSNAMEs associated with the\n                           DDNAME (&DSNSCNT may contain a value greater\n                           than 99). If ALL is NOT given, then only the\n                           DSNAME that is concatenated \"at the top of\n                           the stack\" is given. It is returned in the\n                           CLIST variable &DSNME.\n     LIST = force display to the terminal (CLIST variables not set).\n1   01/08/90\n                                                      WHATDSN   2/2.\n\n  This command will also return a return code representing the success\n  or nonsuccess of this command.\n\n     --------------------------------------------------------------\n     |  &LASTCC  | Meaning                                        |\n     +-----------+------------------------------------------------+\n     |     0     | Successful completion                          |\n     +-----------+------------------------------------------------+\n     |     8     | DDNAME not allocated                           |\n     +-----------+------------------------------------------------+\n     |    12     | More than 99 data-sets concatenated to DDNAME  |\n     +-----------+------------------------------------------------+\n     |    96     | Invalid syntax of operand(s)                   |\n     --------------------------------------------------------------\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WHATDSNH": {"ttr": 37390, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94#\\x7f\\x00\\x94#\\x7f\\x16A\\x00)\\x00)\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-25T00:00:00", "modifydate": "1994-08-25T16:41:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=WHATDSN\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  the WHATDSN command is intended for use in command\n               procedures. This command returns to the CLIST the\n               DSNAME(s) of the data-set(s) which is/are allocated\n               to the DDNAME given.\n               This command is used to pass back to the CLIST :\n                  only the DSNAME of the data-set which is \"at the\n                  top of the stack\" (if several data-sets are\n                  concatenated to that DDNAME),\n               or the DSNAME of each and every data-set (up to 99)\n                  which are allocated to the DDNAME.\n               This command will also return a return code representing\n               the success or nonsuccess of this command :\n               &LASTCC    Meaning\n                  0       Successful completion\n                  8       DDNAME not allocated\n                 12       More than 99 data-sets concatenated to DDNAME\n                 96       Invalid syntax of operand(s)\n               Remark : if this command is invoked outside a CLIST, the\n               -------- contents of all variables are displayed to the\n                        terminal, and no CLIST variables are set.\n)X SYNTAX :    WHATDSN DDNAME('ddname') ALL LIST\n               Example : WHATDSN DDNAME(SYSPROC) ALL LIST\n)O OPERANDS :  Required - DDNAME('ddname')\n               Optional - ALL, LIST\n               Default  - None\n))DDNAME('ddname') : 'ddname' is the DDNAME for which you wish to know\n               the data-set name.\n               Aliases : DDN, DD, D, FILE, FI or F.\n))ALL :        if ALL is given, this command will return all of the\n               DSNAMEs which may be concatenated to the DDNAME in\n               CLIST variables &DSNME1 through &DSNME99 and the CLIST\n               variable &DSNSCNT will contain the total number of\n               DSNAMEs associated with the DDNAME (&DSNSCNT may\n               contain a value greater than 99).\n               If ALL is NOT given, then only the DSNAME that is\n               concatenated \"at the top of the stack\" is given. It is\n               returned in the CLIST variable &DSNME.\n))LIST :       force display to the terminal (CLIST variables not set).\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XREFASM": {"ttr": 37392, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882/\\x00\\x882/\\x177\\x06H\\x06H\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-17T00:00:00", "modifydate": "1988-11-17T17:37:00", "lines": 1608, "newlines": 1608, "modlines": 0, "user": "SYSPAJA"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "XREFASM$": {"ttr": 38150, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942o\\x00\\x942o\\x16(\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-22T00:00:00", "modifydate": "1994-11-22T16:28:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SYSPAJA"}, "text": "//XREFASM  JOB (........),'INSTALL -XREFASM-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=5\n//ASS     EXEC PAJ4AS3,MBR=XREFASM\n//LNK     EXEC PGM=HEWL,PARM='XREF,LIST,NCAL',COND=(4,LT)\n//SYSLMOD   DD DSN=->.TARGET.LINKLIB,DISP=OLD\n//SYSOBJ    DD DSN=&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSUT1    DD UNIT=VIO,SPACE=(CYL,(1,1))\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD  *\n  REPLACE      XREFOUT\n  INCLUDE      SYSOBJ\n  NAME    XREFIN(R)\n  REPLACE      XREFIN\n  INCLUDE      SYSOBJ\n  NAME    XREFOUT(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XREFASM@": {"ttr": 38152, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x943_\\x00\\x943_\\t\"\\x01\\xa4\\x01\\xa4\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-01T00:00:00", "modifydate": "1994-12-01T09:22:00", "lines": 420, "newlines": 420, "modlines": 0, "user": "SYSPAJA"}, "text": "1   16/06/87\n                                                      XREFASM   1/9.\n\n                              XREFASM\n                            Release 1.3\n            (A Global Cross-Reference Listing Generator)\n\n                           David B. Cole\n\n\n                       Printed February 01, 1985\n\n  CONTENTS\n    Disclaimer  . . . . . . . . . . . . . . . . . . . . . . . . . . 1\n    The XREFASM Programs  . . . . . . . . . . . . . . . . . . . . . 2\n    XREFIN  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n      EXEC Card Keyword : REGION=100K . . . . . . . . . . . . . . . 3\n      DDNAME : LISTING  . . . . . . . . . . . . . . . . . . . . . . 3\n      DDNAME : XREF . . . . . . . . . . . . . . . . . . . . . . . . 4\n      DDNAME : SYSPRINT . . . . . . . . . . . . . . . . . . . . . . 4\n      DDNAME : SYSTERM  . . . . . . . . . . . . . . . . . . . . . . 4\n      XREFIN Completion Codes . . . . . . . . . . . . . . . . . . . 4\n    XREFOUT . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n      EXEC Card Keyword : REGION= . . . . . . . . . . . . . . . . . 5\n      EXEC Card Keyword : PARM= . . . . . . . . . . . . . . . . . . 5\n      DDNAME : XREF . . . . . . . . . . . . . . . . . . . . . . . . 5\n      DDNAME : REWRITE  . . . . . . . . . . . . . . . . . . . . . . 5\n      DDNAME : SYSPRINT . . . . . . . . . . . . . . . . . . . . . . 6\n      DDNAME : SYSTERM  . . . . . . . . . . . . . . . . . . . . . . 6\n      DDNAME : SORTLIB  . . . . . . . . . . . . . . . . . . . . . . 6\n      DDNAMEs : SORTWK0n  . . . . . . . . . . . . . . . . . . . . . 6\n      XREFOUT Completion Codes  . . . . . . . . . . . . . . . . . . 6\n      Purging References to Obselete Assemblies . . . . . . . . . . 7\n\n  FIGURES\n      Figure 1  Sample XREFASM Output . . . . . . . . . . . . . . . 2\n\n  EXAMPLE\n      Sample job to assemble the JES2 modules and generate\n        master cross-reference entries for later display  . . . . . 8\n\n\n  DISCLAIMER\n  ----------\n         The author makes no representations or warranties expressed or\n    implies including, but not limited to, the implied warranties of\n    merchantability and fitness for a particular purpose, the warrenty\n    of freedom from rightfull claims by way of infringement and the\n    like, and any warranty as to accuracy.\n\n         The author shall not be liable for any loss or damage arising\n    out of the use of the XREFASM programs (XREFIN and XREFOUT), whether\n    such loss or damage be direct, indirect, consequential, special or\n    otherwise. Further, the author shall not be obligated to indemnify\n    the user of the XREFASM program in any manner for any loss which\n    the user may experience, of any kind or nature, arising out of the\n    use or misuse of the XREFASM programs.\n1   16/06/87\n                                                      XREFASM   2/9.\n\n  THE XREFASM PROGRAMS\n  --------------------\n         Many large programming systems are constructed from a large\n    of separately assembled or compiled sections. Such systems must\n    manage internal communications by means of a set of vector tables\n    and other control blocks that are known to each of the separate\n    sections; which is to say, such control blocks must contain fields\n    that may be referenced and/or changed by any or all of the\n    sections. Accordingly, a global cross-reference listing reporting\n    which sections reference which fields, is a very useful tool for\n    a large-systems developer to have.\n\n         XREFASM is a relatively simple system that generates such\n    global cross reference listings. Specifically, XREFASM generates a\n    report showing sorted list of all labels used in a given set of\n    separate assemblies or compilations. The entries for each label\n    show both which assemblies (or compilations) reference that label\n    and how many references each assembly has to that label.\n    Figure 1 shows a sample XREFASM output.\n\n    +----------------------------------------------------------------+\n    |                                                                |\n    |    MASTER CROSS-REFERENCE FOR <title info from the PARM field> |\n    |                                                                |\n    |    SYMBOL          ASSEMBLY-REFS     ...                       |\n    |                                                                |\n    |    DCTEOF               NUC-1    RTAM-16                       |\n    |    DCTERMNR            RTAM-19                                 |\n    |    DCTETX               NUC-1    RTAM-4                        |\n    |    DCTEWF              INIT-8     NUC-1    RTAM-3              |\n    |    DCTEXORG            COMM-5    INIT-5    MISC-5     NET-5    |\n    |                        PRPU-5     RDR-5    RTAM-5    SSSM-5    |\n    |    DCTEXZ              COMM-3                                  |\n    |    DCTFCB              COMM-8    INIT-11    NUC-1    PRPU-24   |\n    |    - - -                                                       |\n    |                                                                |\n    +----------------------------------------------------------------+\n    Figure 1  Sample XREFASM Output\n\n         Currently, XREFASM will produce global cross-reference listings\n    for programs assembled or compiled by the following processors :\n         - IBM's OS/VS DOS/VSE VM/370 Assembler\n         - IBM's Assembler-H Version 2, with or without the \"S.L.A.C.\"\n           mods.\n         - IBM's Series/1 Host Program Preparation Facility Assembler\n\n         Recognition by XREFASM of which kind of output is being\n    processed is automatic.\n         XREFASM actually consists of two programs. XREFIN accumulates\n    cross-reference data from each assembly or compilation. XREFOUT\n    sorts and edit the accumulated data and produces the global cross-\n    reference report.\n1   16/06/87\n                                                      XREFASM   3/9.\n\n  XREFIN\n  ------\n         XREFIN accumulates cross-reference data from individual\n    assemblies or compilations. It is designed to be used as follows :\n         One-step assembly jobs should be changed to two-step jobs\n           consisting of the assembly step followed by the XREFIN step.\n         The assembly step should write its listing file to a temporary\n           dataset rather than to spool.\n         The XREFIN step can then read the listing file and extract\n           from it the relevant cross-reference information. In\n           addition, the XREFIN program can echo the listing dataset\n           to a SYSPRINT file, if desired.\n\n         XREFIN extracts cross-reference data and writes it \"mod\" to an\n    accumulation dataset which will later be processed by XREFOUT. Each\n    record written is assigned both the name of the current assembly\n    and a timestamp associated with the current run. XREFIN infers the\n    assembly name by examining the page title lines appearing in the\n    assembly listing. The first word appearing in the title line is\n    taken to be the assembly name. For both the S/370 Assembler,\n    Assembler H, and the Series/1 Assembler, this first word is set\n    from the name field of the \"TITLE\" assembler statement.\n\n         The timestamp is stored so that later XREFOUT can control the\n    results of repeated assemblies of the same sections. If the same\n    is assembled twice and XREFIN is, therefore, executed twice for the\n    same section, the two complete sets of cross-reference data will be\n    written to the accumulation file. Because of the timestamps,\n    XREFOUT can recognize the situation and discard the older\n    cross-reference data.\n\n  XREFIN has the following JCL requirements.\n  ------------------------------------------\n\n    EXEC Card Keyword : REGION=100K\n         XREFIN's memory requirements are trivial. REGION=100K should\n         be more than enough.\n\n    DDNAME : LISTING\n             Attributes :\n             access method           QSAM\n             DSORG                   PS\n             RECFM                   any\n             LRECL                   any\n             BLKSIZE                 any\n             defaults                (PS,UA,255,255)\n         This file is required. It must contain the listing output\n    produced by preceeding assembly. XREFIN echos the file to SYSPRINT\n    (if available) and scans it for cross-reference data on the way.\n    All such data is saved in a accumulation file for later processing\n    by XREFOUT.\n1   16/06/87\n                                                      XREFASM   4/9.\n\n    DDNAME : XREF\n             Attributes :\n             access method           QSAM\n             DSORG                   PS\n             RECFM                   FB\n             LRECL                   158\n             BLKSIZE                 158*n\n             defaults                (PS,FB,158,3950)\n         This is the accumulation file. The cross-reference data is\n    extracted from the listing file and written to this file. It should\n    be allocated with DISP=MOD so as not to overwrite previously\n    accumulated data. It is a required file. If it is omitted, then\n    XREFIN will abend (probably with a 0C1).\n\n    DDNAME : SYSPRINT\n             Attributes :\n             access method           QSAM\n             DSORG                   PS\n             RECFM                   any\n             LRECL                   any\n             BLKSIZE                 any\n             defaults                the attributes of the LISTING file\n         This file is optional. If present, then it receives an echo\n    of the LISTING file. If omitted, then no echo is produced.\n\n    DDNAME : SYSTERM\n             Attributes :\n             access method           QSAM\n             DSORG                   PS\n             RECFM                   UA\n             BLKSIZE                 255\n         This file is optional. If present, then XREFIN's information\n    messages are written to it. If it is omitted, then the messages are\n    discarded (XREFIN does not issue any error messages).\n\n  XREFIN Completion Codes.\n  ------------------------\n       0 : XREFIN has completed processing without error.\n      16 : The LISTING file has not been given. XREFIN cannot proceed.\n1   15/07/87\n                                                      XREFASM   5/9.\n\n  XREFOUT\n  -------\n         XREFOUT sorts and edits accumulated cross-reference data and\n    produces global cross-reference report (see figure 1). If the\n    accumulation dataset contains either obsolete entries (due to\n    re-assemblies) or \"purged \" entries (see below), then XREFOUT will\n    discard them so that they will not affect the cross-reference\n    report. Further, XREFOUT may, at the user's option rewrite the\n    sorted and compressed accumulation file back either to the original\n    dataset or to a new one. This helps to control the size of the file.\n         XREFOUT performs the data sort  by dynamically invoking IBM's\n    Sort/Merge program. Any compatible substitute could be used instead\n    (e.g., SYNCSORT) XREFOUT links to Sort/Merge via the name \"SORT\".\n\n  XREFOUT has the following JCL requirements.\n  -------------------------------------------\n\n    EXEC Card Keyword : REGION=\n         XREFOUT's memory requirements are affected by the size of the\n         sort that needs to be done. Accordingly, the appropriate\n         Sort/Merge manual should be consulted and its recomendations\n         followed. Generally, REGION=1024K should be a good value.\n\n    EXEC Card Keyword : PARM=\n         Any string given in the PARM field is displayed in XREFOUT's\n         title line as the object of the preposition \"for\" (see\n         figure 1). If no PARM field is given, then the word \"for\" is\n         dropped from the title. May be preceeded by keyword \"ONLY/\"\n         to obtain a short instead of a fully cross-reference list.\n\n    DDNAME : XREF\n             Attributes :\n             access method           QSAM\n             DSORG                   PS\n             RECFM                   FB\n             LRECL                   158\n             BLKSIZE                 158*n\n         This file is required. It contains the accumulated cross-\n    reference data that is to be processed. In addition it may contain\n    \"purge control data\" as described below.\n\n    DDNAME : REWRITE\n             Attributes :\n             access method           QSAM\n             DSORG                   PS\n             RECFM                   FB\n             LRECL                   158\n             BLKSIZE                 158*n\n             defaults                same attributes as the XREF file\n         This file is optional. If present, then a copy of the XREF\n    file (with obsolete or purged entries edited out) is written to it.\n    This ddname may point to the identically same dataset as the XREF\n    ddname, since it is not opened until after the XREF file is closed.\n    If a REWRITE ddname is not given, then compressed cross-reference\n    data is not rewritten.\n1   16/06/87\n                                                      XREFASM   6/9.\n\n    DDNAME : SYSPRINT\n             Attributes :\n             access method           QSAM\n             DSORG                   PS\n             RECFM                   FBA\n             LRECL                   133\n             BLKSIZE                 133*n\n             defaults                (PS,FBA,133,3990)\n         This file is optional. If present, then the generated master\n    cross-reference listing is written to it. If it is not available,\n    then the cross-reference listing is discarded.\n\n    DDNAME : SYSTERM\n             Attributes :            Sort/Merge dependant\n             usage                   Sort/Merge message dataset\n         This file is required. It is used by Sort/Merge as its message\n    file (in place of SYSOUT). Its attributes are dependant upon the\n    particular Sort/Merge being used.\n\n    DDNAME : SORTLIB\n             Attributes :\n             access method           program fetch\n             DSORG                   PO\n             RECFM                   U\n             usage                   load library\n         This file may or may not be required depending upon the\n    Sort/Merge program being used. When required, this ddname should\n    point to the SYS1.SORTLIB dataset.\n\n    DDNAMEs : SORTWK0n\n             Attributes :\n             usage                   Sort/Merge work space\n             size                    large\n         One or more SORTWK0n files (n 1) may be required by Sort/Merge.\n    The work areas should be large enough to accomodate the number of\n    records being sorted. Refer to the appropriate Sort/Merge manual\n    for details.\n\n  XREFOUT Completion Codes.\n  -------------------------\n       0 : XREFOUT has completed processing without error.\n       4 : The number of assemblies being cross-referenced has\n           exceeded 1000.\n      16 : The XREF ddname has not been provided.\n           XREFOUT cannot proceed.\n1   16/06/87\n                                                      XREFASM   7/9.\n\n  Purging References to Obselete Assemblies.\n  ------------------------------------------\n\n         Sometimes it is desirable to purge from the accumulated cross-\n    reference references to assemblies that, for one reason or another,\n    have become obselete and have been dropped. This might also be\n    necessary if the name on the TITLE card for an assembly has been\n    changed thus making what really is the same assembly module appear\n    to XREFOUT to be two different assembly modules. To accomplish this\n    purging, the user should place into the accumulation file one or\n    more \"purge control records\". These are records that start with a\n    blank character (at offset +0) followed by an assembly module name\n    (at offset +1 for up to 8 characters). The remaining 149 bytes of\n    the purge control record are ignored.\n         When XREFOUT encounters a purge control record, it will then\n    delete from the accumulated data all records containing an assembly\n    module name that matches the one given by the purge record. Note\n    that an assembly module name that is entirely blank is valid. This\n    corresponds to the case where an assembly does not contain a TITLE\n    card or contains only ones having blank name fields.\n         Purge control records must be put into an accumulation file\n    manually. They may be placed anywhere in the file since XREFOUT\n    always sorts the file in a way that moves them to the top. Any\n    number of purge records may be put into the file, and redundant\n    records do not hurt.\n         There are any number of methods of placing purge records into\n    an accumulation file. They can be edited in assuming that the file\n    is not too big for the editor being used. They can be written in\n    with IEBGENER. Just be sure to use DISP=MOD. Or they can be placed\n    into a separate file which would then be concatenated via JCL to\n    the accumulation file when XREFOUT is executed. Be aware, though,\n    that XREFOUT does not support \"unlike concatenation\", thus the file\n    containing the purge records must have the same attributes as the\n    accumulation file.\n1   16/06/87\n                                                      XREFASM   8/9.\n\n  EXAMPLE\n  -------\n\n    Sample job to assemble a JES2 module and generate master\n    cross-reference entries for later display :\n\n    //XEQ     EXEC PGM=IFOX00,REGION=1024K,\n    //             PARM='TEST,DECK,NOLOAD,NORLD,TERM,BUFSIZE(MAX)'\n    //SYSLIB    DD DSN=JES2.MACLIB,DISP=SHR\n    //          DD DSN=SYS1.MACLIB,VOL=,DISP=SHR\n    //          DD DSN=SYS1.MODGEN,VOL=,DISP=SHR\n    //SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(15,1))\n    //SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(15,1))\n    //SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(15,1))\n    //SYSPRINT  DD UNIT=SYSDA,DSN=&&LISTING,SPACE=(CYL,(10,2),RLSE),\n    //             DCB=(RECFM=FBA,LRECL=121,BLKSIZE=3993),DISP=(,PASS)\n    //SYSPUNCH  DD DSN=JES2.OBJ(HASPXEQ),DISP=OLD\n    //SYSIN     DD DSN=JES2.ASM(HASPXEQ),DISP=SHR\n    //SYSTERM   DD SYSOUT=*\n    //XREFGEN EXEC PGM=XREFIN,REGION=100K\n    //LISTING   DD DSN=&&LISTING,DISP=(OLD,DELETE)\n    //XREF      DD DSN=JES2.XREF,DISP=MOD\n    //SYSTERM   DD SYSOUT=*\n    //SYSPRINT  DD SYSOUT=*\n\n    Sample job to assemble another JES2 module and generate\n    master cross-reference entries for later display :\n\n    //PRPU    EXEC PGM=IFOX00,REGION=1024K,\n    //             PARM='TEST,DECK,NOLOAD,NORLD,TERM,BUFSIZE(MAX)'\n    //SYSLIB    DD DSN=JES2.MACLIB,DISP=SHR\n    //          DD DSN=SYS1.MACLIB,VOL=,DISP=SHR\n    //          DD DSN=SYS1.MODGEN,VOL=,DISP=SHR\n    //SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(15,1))\n    //SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(15,1))\n    //SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(15,1))\n    //SYSPRINT  DD UNIT=SYSDA,DSN=&&LISTING,SPACE=(CYL,(10,2),RLSE),\n    //             DCB=(RECFM=FBA,LRECL=121,BLKSIZE=3993),DISP=(,PASS)\n    //SYSPUNCH  DD DSN=JES2.OBJ(HASPPRPU),DISP=OLD\n    //SYSIN     DD DSN=JES2.ASM(HASPPRPU),DISP=SHR\n    //SYSTERM   DD SYSOUT=*\n    //XREFGEN EXEC PGM=XREFIN,REGION=100K\n    //LISTING   DD DSN=&&LISTING,DISP=(OLD,DELETE)\n    //XREF      DD DSN=JES2.XREF,DISP=MOD\n    //SYSTERM   DD SYSOUT=*\n    //SYSPRINT  DD SYSOUT=*\n1   16/06/87\n                                                      XREFASM   9/9.\n\n    ...   ...   ...\n    Perform assemblies of all of the JES2 modules before running\n    the final job shown below.\n    ...   ...   ...\n\n    Sample job to sort and print the master cross-reference :\n\n    //XREF    EXEC PGM=XREFOUT,REGION=4096K,\n    //             PARM='JES2/SP V1.3.3 - PUT LEVEL 8401'\n    //XREF      DD DSN=JES2.XREF,DISP=OLD\n    //REWRITE   DD DSN=*.XREF,DISP=OLD\n    //SORTLIB   DD DSN=SYS1.SORTLIB,DISP=SHR\n    //SORTWK01  DD UNIT=SYSDA,SPACE=(CYL,(15),,CONTIG)\n    //SORTWK02  DD UNIT=SYSDA,SPACE=(CYL,(15),,CONTIG)\n    //SORTWK03  DD UNIT=SYSDA,SPACE=(CYL,(15),,CONTIG)\n    //SYSTERM   DD SYSOUT=*\n    //SYSPRINT  DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZAP": {"ttr": 38404, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95(\\x9f\\x00\\x95(\\x9f\\x133\\x16(\\x16(\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-10-16T00:00:00", "modifydate": "1995-10-16T13:33:00", "lines": 5672, "newlines": 5672, "modlines": 0, "user": "SYSPAJA"}, "text": "ZAP      TITLE 'ZAP --- DISPLAY AND MODIFY DATA-SETS --- TSO COMMAND.'\n         PRINT OFF                                                 -EU-\n         COPY  ZAPMAC                                              -EU-\n         PRINT ON                                                  -EU-\n***********************************************************************\n*                                                                     *\n*  THIS PROGRAM HAS BEEN THOROUGHLY TESTED, HOWEVER, NO               *\n*  RESPONSIBILITY OF ANY KIND CAN BE ASSUMED FOR ITS RELIABLE OR      *\n*  CORRECT OPERATION. THIS PROGRAM MAY NOT BE FURTHER DISTRIBUTED     *\n*  WITHOUT THE WRITTEN PERMISSION OF THE AUTHORS.                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        U C L A / O A C   ' Z A P '   T S O  C O M M A N D           *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* UPDATES :                                                           *\n*                                                                     *\n* 10/16/95 -EU-  - PFK5 ('L') CONTINUE CORRECTLY.                     *\n*                                                                     *\n* 10/04/95 -EU-  - SUPPORT PFK1 AS HELP AND PFK3 AS END-HELP (LIKE    *\n*                  ISPF USERS ARE FAMILIAR).                          *\n*                                                                     *\n* 10/03/95 -EU-  - ADDED FREEMAIN OF \"LCSOUT\" WORK-AREA.              *\n*                                                                     *\n* 10/02/95 -EU-  - SOME CODING ERRORS CORRECTED.                      *\n*                                                                     *\n* 12/11/89 -EU-  - PREVENT DE-ALLOCATION OF PRE-ALLOCATED DATA-SETS.  *\n*                                                                     *\n* 06/26/89 -EU-  - ADD CAPS ON/OFF COMMAND TO DRIVE ON HOW HANDLE     *\n*                  <STR> STRING COMMANDS.                             *\n*                                                                     *\n* 06/22/89 -EU-  - ADAPT L, F, S, X, O, N AND SET COMMANDS TO WORK    *\n*                  WITH ASCII OR ZCODE MODE ALSO (<STR>).             *\n*                                                                     *\n* 06/04/88 -EU-  - ONLY MVS/XA VERSION                                *\n*                                                                     *\n* 06/21/84 -EU-  - SENSITIVE DATA-SET ACCESS CONTROLED FOR ONLY       *\n*                  SYSTEM SUPPORT PEOPLE.                             *\n*                  MOVE ALL MACROS IN MEMBER \"ZAPMAC\".                *\n*                  FREE THE DATA-SET AT END, AND EVENTUALLY DEQUEUE   *\n*                  THE \"ALLOCDSN\" NAME WHEN USED FOR VTOC ALLOCATION. *\n*                                                                     *\n* 10/02/81 AFDSC - MODS AT AFDSC/PENTAGON BY BILL GODFREY :           *\n*                  SUPPORT PFK3 AS 'END'.                             *\n*                  SUPPORT PFK5 AS 'L' (REPEAT LOCATE OR FIND).       *\n*                  SUPPORT PFK7 AS 'U' (UP).                          *\n*                  SUPPORT PFK8 AS 'D' (DOWN).                        *\n*                  CHECK FOR PRE-ALLOCATED 'ZAPLOG' DD. THIS ALLOWS   *\n*                  USER TO PUT THE LOG SOMEWHERE BESIDES SYSOUT(A).   *\n*                  OACTMP MISSING. BYPASS INSERTED TO AVOID ABEND806. *\n*                  OACNOW MISSING. WROTE OUR OWN VERSION.             *\n*                  CALL INSTEAD OF LINK TO OACNOW.                    *\n*                  FREEMAIN THE AREA RETURNED BY OUR OACNOW.          *\n*                  SOURCE FOR OUR OACNOW APPENDED FOR BATCH ASSEMBLY. *\n*                  CHANGE TITLE LINE ON LOG LISTING.                  *\n*                                                                     *\n* 12/18/80 MAS3 :  ASK AT EXIT IF ZAP LOG REQUIRED, DELETE IF 'NO'.   *\n*                                                                     *\n* 12/18/80 MAS2 :  NAME(E) COMMAND - FIND TEXT BLOCK BY ORIG IN       *\n*                  PREVIOUS CONTROL RECORD (NOT JUST COUNTING BYTES). *\n*                  ADD J COMMAND - 'P' RELATIVE TO VOLUME.            *\n*                  FIX \"INPUT DATA LOST\" (TRCHARE HAS NO ORG AT END). *\n*                  DELETE 'FCME' COMMAND.                             *\n*                                                                     *\n* 12/18/80 MAS1 :  REMOVE ALL &CCN CODE (NO MORE CCN/MVT).            *\n*                  INCLUDE ZAPS --                                    *\n*                    VSAPL ZCODE TABLE.                               *\n*                    GTSIZE CODE TO ALLOW OTHER THAN 24 LINE SCREENS. *\n*                                                                     *\n* 12/27/79 LDW5 :  MODIFY FULLSCREEN FLAGS LOGIC (F3270 FSMODE).      *\n*                  SIMPLIFY \"DO\" COMMAND CODE.                        *\n*                  DELETE \"RESHOW\" COMMAND.                           *\n*                  FIX \"WINDOW\" COMMAND BUG.                          *\n*                  CHANGE VERSION TO 2.3.                             *\n*                  CHANGE SENSITIVE DATASET CRITERIA FOR GIBRALTAR.   *\n*                  MERGE \"INITSHOW\" FLAG INTO \"RESHOWF\".              *\n*                  PRE-BLANK REPLY BUFFER AFTER PUTGET.               *\n*                                                                     *\n* 12/27/79 SDM6 :  FIX COMSCAN TO HANDLE ZERO LENGTH REPLIES RIGHT.   *\n*                  FIX SHORT RESPONSE LOGIC FOR FULLSCR SUPPORT.      *\n*                                                                     *\n* 11/29/79 LDW4 :  FIX IDR & LOG USERID.                              *\n*                  PAUSE 'F' AT DS1LSTAR.                             *\n*                  ADD 'WM' ALIAS FOR WHATMEM COMMAND.                *\n*                  MAKE JCJ HAPPY: SAME CMD TWICE IN A ROW WILL GET   *\n*                    OUT OF A MODIFIED BLOCK WITHOUT \"ZAP\"ING IT      *\n*                    (\"NOZAP\" COMMAND REMOVED).                       *\n*                  CHANGE TO VERSION 2.2B.                            *\n*                  CHANGE MESSAGE ID'S FROM CSM3XX TO ZAP0XX.         *\n*                  FORCE LOG FOR ANY SYSN. DATASET.                   *\n*                  CHANGE TITLE ON LOG FROM UCLA-CCN TO GIS.          *\n*                  ADD USID TO ALLOCDSN PARSE ENTRY.                  *\n*                  ROUND UP BY 50 BYTES THE SIZE OF THE GETMAIN'D BUF.*\n*                  MOVE LASTDS1 TO ITS OWN FIELD.                     *\n*                  DIDDLE CODE IN 'FORMAT' TO PREVENT 0C4'S.          *\n*                                                                     *\n* 11/28/79 SDM5 :  CHANGE LINE01 LENGTH TO NORMAL.                    *\n*                  IMPROVE PARTIAL SCREEN DISPLAY CODE.               *\n*                  IMPROVE TGET ASIS CODE.                            *\n*                  MOVE BASE FROM R7 TO R9.                           *\n*                                                                     *\n* 11/27/79 SDM4 :  ELIMINATE 'UNLOCK KEYBOARD' FROM 3270 OUTPUT.      *\n*                  FIX ERROR MESSAGE BLANKING BUG.                    *\n*                  FIX HELP PROMPT FIELD CLEAR LENGTH BUG.            *\n*                  FIX HELP PROMPT FIELD MDT BUG.                     *\n*                                                                     *\n* 11/09/79 SDM3 :  FIX INTERMITTENT 0C4 IN 'L' COMMAND.               *\n*                                                                     *\n* 09/26/79 SDM2 :  ADD ROUTCDE=9 (SECURITY) TO WTO.                   *\n*                                                                     *\n* 09/05/79 LDW3 :  DELETE ALL SSL CODE.                               *\n*                                                                     *\n* 08/07/79 SDM1 :  1) CHANGE TGET WHEN IN FULLSCREEN MODE TO ASIS.    *\n*                  2) ADD ROUTCDE=2 (MASTER CONSOLE) TO WTO.          *\n*                                                                     *\n* 06/27/79 LDW2 :  1) CHANGE FULLSCREEN I/O TO ONLY TPUT CHANGED LINES*\n*                  2) FIX BUG IN FULLSCREEN HELP.                     *\n*                  3) ADD HELP INFO.                                  *\n*                                                                     *\n* 05/05/79 LDW1 :  THIS IS A MAJOR CLEANUP/REWRITE THAT KEPT MAINLY   *\n*                    THE ORIGINAL FRAMEWORK, BUT ALMOST EVERYTHING    *\n*                    WAS CHANGED SOMEWHAT.                            *\n*        1) CHANGE ACCESS METHOD FROM BDAM TO EXCP.                   *\n*        2) FIX SO \"X\" WORKS IF LOG IS ON.                            *\n*        3) FIX SO \"ZAP REQ'D\" WORKS IF LOG OFF.                      *\n*        4) CHANGE TPUT TO PUTLINE.                                   *\n*        5) MAKE SINGLE ASSEMBLY.                                     *\n*        6) INCLUDE CHAR FORM OF DATA AND ABS LOC IN LOG.             *\n*        7) VARIOUS RE-ARRANGING TO CONSERVE PAPER.                   *\n*        8) FULLSCREEN 3270 & SSL SUPPORT.                            *\n*        9) JUST \"M\" GIVES SAME MEMBER AGAIN (NOT DIRECTORY).         *\n*       10) DELETE LOGTEST MACRO, PUT CODE IN SUBROUTINE.             *\n*       11) UPDATE IDR FOR ALL ENTRY POINTS SELECTED.                 *\n*       12) MISC CODE CLEANUP, EG \"BLANKS\", EQU'S FOR TTR+3.          *\n*       13) ADD DUMPE COMMAND TO DUMP CURRENT REC TO EOF.             *\n*       14) ADD LINELEN=80 FEATURE/OPTION.                            *\n*       15) DIDDLE BASE REGISTERS & ADD ONE.                          *\n*       16) VTOC SUPPORT.                                             *\n*       17) CHANGE CSOUT TO USE QSAM, LARGE BLKSIZE, FIX BUGS.        *\n*       18) FIX EXPR HANDLER TO MULT/DIV.                             *\n*       19) NEW CMDS:  WHATMEM, F, V, LASTDS1, U, DISP, %.            *\n*       20) SET LOG DEFAULT, FIX SO DELETED IF UNUSED.                *\n*       21) REDESIGN \"CHKPT\" OPERATION.                               *\n*       22) USE 'HEX' MACRO.                                          *\n*       23) FIX 15 NIBBLE HEX STRING BUG.                             *\n*       24) ADD CONDITIONAL ASSEMBLY FOR MVT/MVS, SSL/NOSSL, CCN/\u00acCCN *\n*                                                                     *\n* 05/20/78 JCJ1 :  1) PROPAGATE LPR URSA ZAP FIXES TO TSO ZAP.        *\n*                  2) PROPAGATE ABS COMMAND FROM URSA ZAP TO TSO ZAP. *\n*                  3) FIX LOST SP 0 CORE AT EODAD BUG.                *\n*                  4) FIX VERBOSE MODE MSG OVERLAY BUG.               *\n*                                                                     *\n* 12/20/75 VIC : ADD 'NAME' COMMAND TO LOCATE ENTRY POINTS/CSECTS  *N**\n*                WITHIN LOAD MODULES.                              *N**\n*                                                                     *\n* 09/12/75 WDD :                                                      *\n*        . GET USERID FOR ZAP UPDATE RECORD, ALLOW USERS TO USE ZAP.  *\n*        . ALLOCATE DATASET PERM=NO, AND SET CORRECT DSNAME LENGTH.   *\n*                                                                     *\n***********************************************************************\n         EJECT\n*        POSSIBLE NEW FEATURES - BUGS - THINGS TO CHECK.\n*        -----------------------------------------------\n*  5) COMMAND STACKING.\n* 17) ENQ ON SPZAPLIB/SYSVTOC/SYSCTLG (SPZAPLIB L'RNAME=44).\n* 22) STORE TTR IN DEFINE TABLE, ADD P= COMMAND.\n* 26) OFFSET COMMAND?\n* 36) RECORD MAY BE > 32K BYTES... BUT O/S WON'T LET IT, SO NO PROBLEM.\n* 45) EXP IS SCREWED.\n* 46) SYSOUT ENQ LOG TO DEST C (DEST/BIN KEYWORDS?).\n* 47) NOTE WHERE IDR'S ARE WHILE LOOKING FOR ENTRY POINT.\n* 48) DO 256 READ COUNTS.\n* 55) RN GOES TO NEXT TRACK IF CURR TRK DOESN'T HAVE N RECORDS.\n* 63) OFFSET IN LOG WILL BE FISHY IF NOT ADJUSTED FOR DISPC/K/D.\n* 71) AUTO \"M\" IF MEMBER GIVEN?\n* 72) WSHORT & DELETE ALL 40 CHAR CODE?\n* 74) DON'T POSITION CURSOR UNLESS RMOD.\n* 76) MAKE HELP USE LONGER SCREEN LINES.\n* 81) DON'T DISP COUNT AS PART OF REC, HAVE SET COUNT CMD.\n* 82) USE 'MSG' FOR HELPS.\n* 83) CHANGE TRAILING BLANKS TO NULLS AT DISPLAY TIME.\n* 84) MOVE CSOUT MF=L TO TSDSECT.\n* 85) \"FORMAT\" COMMAND.\n* 86) SCAN OFF BLANKS BETWEEN COMMAND AND OPERAND.\n* 87) FEOF COMMAND TO FIND NEXT EOF.\n* 88) LC/UC COMMANDS.                                              LDW4\n* 89) BLKSIZE 0 SHOULD USE DEVTYPE FOR BUFLEN (WHAT ABOUT TRK OFLO?)\n         EJECT\n**********************************************************************\n*                                                                    *\n* PROGRAM : ZAP (UNDER TSO)                                          *\n* --------- THIS PROCESSOR IS RE-ENTRANT AND SERIALLY REUSABLE.      *\n*                                                                    *\n* PROGRAMMER : VIC TOLOMEI                                           *\n* ------------ FOR FULL DOCUMENTATION OF COMMANDS AND SO ON,         *\n*              SEE THE LISTING OF THE URSA VERSION IN BINDER         *\n*              'URSA MISCELLANEOUS VOLUME 3'.                        *\n*              WRITTEN FOR URSA : 5/22/73                            *\n*              CHANGE TO TSO VERSION : 1/22/75                       *\n*                                                                    *\n**********************************************************************\n         SPACE 1\n**********************************************************************\n*                                                                    *\n*                               Z A P                                *\n*                                                                    *\n*  GENERAL ZAP OUTLINE :                                             *\n*                                                                    *\n*  THIS SERVICE WILL DISPLAY ANY TYPE OF DATA-SET (EXCLUDING ISAM)   *\n*  IN DUMP FORMAT, ACCEPT VARIOUS DISPLAY FORMATTING AND MODIFYING   *\n*  COMMANDS, AND APPLY INTERACTIVE CHANGES AS DOES IBM'S SERVICE     *\n*  AID, IMASPZAP (SUPERZAP).                                         *\n*  HARDCOPY LINES ARE PRINTED FOR ALL DATA SET MODIFICATIONS AND     *\n*  'POTENTIAL MODIFICATIONS' (THOSE NOT YET APPLIED) AS WELL AS      *\n*  COMMENTS AND DUMPED BLOCKS. THE FOLLOWING CONDITIONS CAUSE A      *\n*  LINE TO BE WRITTEN INTO THE PRINT FILE : ACCESSING A DATA-SET,    *\n*  'ZAPPING' A BLOCK, STORING IN THE BUFFER (S,X,O,N, OR SET),       *\n*  SELECTING A MEMBER, CREATING A COMMENT, EJECTING A PAGE, OR       *\n*  DUMPING A BLOCK OR BLOCKS. THE FILE WILL BE PRINTED ONLY IF AN    *\n*  EXPLICIT DUMP, COMMENT, OR PERMANENT CHANGE IS MADE. THE FILE     *\n*  IS ACTUALLY RELEASED FOR PRINTING UPON EXIT FROM THE DATA-SET.    *\n*  IDR'S ARE UPDATED IN LOAD MODULE DATA-SETS IN THE FORMAT SUPERZAP *\n*  USES (WITH 'TSO--III' AS THE ID DATA FIELD).                      *\n*  END-OF-FILES MAY BE JUMPED TO VIEW DATA BEYOND UP TO THE EXTENT   *\n*  OF THE DATA-SET (USEFUL IF AN INADVERTANT EOF WAS WRITTEN IN THE  *\n*  MIDDLE OF A DATA-SET).                                            *\n*                                                                    *\n**********************************************************************\n         EJECT\n*  THE OLD SCREEN FORMAT WAS AS FOLLOWS :                          LDW1\n         SPACE 1\n*               ##########################################\n*               # *MSG*  *TALK*  Z  A  P  *BULL*  *OUT* >#\n*               #L'NOTHING'                              #\n*               #ENTER VALID COMMAND ABOVE OR ? FOR HELP #\n*               # ***** I/O ERROR: XXXXXXXXXXXXXXX ***** #\n*               #000000  F1F2 F3F4  F5F6 F7F8  |12345678|#\n*               #000008  F1F2 F3F4  F5F6 F7F8  |12345678|#\n*               #000010 >F1F2 F3F4  F5F6 F7F8  |12345678|#\n*               #000018  F1F2 F3F4  F5F6 F7F8  |12345678|#\n*               #000020  F1F2 F3F4  F5F6 F7F8  |12345678|#\n*               #000028  F1F2 F3F4  F5F6 F7F8  |12345678|#\n*               #000030  F1F2 F3F4  F5F6 F7F8  |12345678|#\n*               #000038  F1F2 F3F4  F5F6 F7F8  |12345678|#\n*               #000040  F1F2 F3F4  F5F6 F7F8  |12345678|#\n*               #000048  F1F2 F3F4  F5F6 F7F8  |12345678|#\n*               #000050  F1F2 F3F4  F5F6 F7F8  |12345678|#\n*               #000058  F1F2 F3F4  F5F6 F7F8  |12345678|#\n*               #000060  F1F2 F3F4  F5F6 F7F8  |12345678|#\n*               #        *****  SCAN MATCH  *****        #\n*               #DSN: CPC013.LDW.SCREEN.SAMPLE OFF:  0010#\n*               #TTR: 000001 CCHHR: 0022000301 LEN:   400#\n*               ##########################################\n         SPACE 1\n*  THE NEW FORMAT IS AS FOLLOWS :                                  LDW1\n*  (SOME BLANK COLUMNS HAVE BEEN OMITTED SO IT WILL FIT)           LDW1\n         SPACE 1\n*              *MSG*  *TALK*  Z  A  P  *BULL*  *OUT*                  >\n*(TYPE HERE)\n*ENTER VALID COMMAND ABOVE OR ? FOR HELP\n*L'12345678'\n*             ***** I/O ERROR: XXXXXXXXXXXXXXX *****\n*00000  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|\n*00010 >F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|\n*00020  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|\n*00030  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|\n*00040  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|\n*00050  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|\n*00060  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|\n*00070  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|\n*00080  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|\n*00090  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|\n*000A0  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|\n*000B0  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|\n*000C0  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|\n*000D0  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|\n*                    *****  SCAN MATCH  *****\n*OFF: 0010 (    16) ADDR: 00010 (     16) DSN: CPC013.LDW.SCREEN.SAMPLE\n*LEN: 0190 (   400) BASE: 00000 (      0) CCHHR: 0022003301 TTR: 000001\n         EJECT\nZAP      START 0\n         SPACE 1\nZAP     AMODE  24                                                  -EU-\nZAP     RMODE  24                                                  -EU-\n         SPACE 1\nF0       EQU   0\nF2       EQU   2\nF4       EQU   4\nF6       EQU   6\nF8       EQU   8\n         SPACE 2\n**********************************************************************\n*                                                                    *\n* REGISTERS USAGE : R0-R7...WORK REGS                                *\n*                   R8......PRIMARY BAS REG                          *\n*                   R9......FOURTH BASE REGISTER                     *\n*                   R10.....THIRD BASE REGISTER                      *\n*                   R11.....SECOND BASE REGISTER                     *\n*                   R12.....FIRST BASE REGISTER (BASE FOR EXP)       *\n*                   R13.....TS WORKAREA (SAVEAREA, 'CSAREA', ETC)    *\n*                   R14.....WORK AND RET ADDR                        *\n*                   R15.....WORK AND ENTRY POINT ADDR                *\n*                                                                    *\n**********************************************************************\n         SPACE 2                                                   -EU-\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *  -EU-\n*        AUTHORITY LEVELS DEFINITIONS.                          *  -EU-\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *  -EU-\n         SPACE 1                                                   -EU-\nLV0      EQU   0         REJECT LEVEL.                             -EU-\nLV14     EQU   14        HIGH SENSITIVE LEVEL.                     -EU-\n         SPACE 1                                                   -EU-\n        $MDL@IX ,        MODULE LEVEL.                             -EU-\n         EJECT\n*ZAP     TSENTRY BASE=R12,SYMREG=NO,PL=(PARSE,DAIR,MESSAGE,IO),    LDW1X\n               MACRO=YES,LOAD=(IKJPTGT,IKJPUTL)                    LDW1\nZAP      ENTR  PL=(PARSE,DAIR,IO),LOAD=(IKJPTGT,IKJPUTL),          LDW1X\n               ENV=CP,TSFAKE=YES,MACRO=YES,PARMREG=R5,             LDW1X\n               BASE=R12,BASE2=R11,BASE3=R10,BASE4=R9               LDW1\n         EJECT                                                     LDW1\nCSREG    EQU   13\n*LDW1    LA    R11,4095(,R12)           BASE #2                    LDW1\n*LDW1    LA    R11,1(,R11)                                         LDW1\n*LDW1    LA    R10,4095(,R11)           BASE #3                    LDW1\n*LDW1    LA    R10,1(,R10)                                         LDW1\n*LDW1    LA    R9,4095(,R10)            BASE #4                    LDW1\n*LDW1    LA    R9,1(,R10)                                          LDW1\n         SPACE 2\n         MVI   BLANKS,C' '              INIT                       LDW1\n         MVC   BLANKS+1(L'BLANKS-1),BLANKS                         LDW1\n         MVC   VERSION,BLANKS           INIT                       LDW1\n         MVC   VERSION(12),=C'VERSION=2.3 '                        LDW5\n         MVC   VERSION+13(7),ZAP+10     DATE                       LDW1\n*MAS2    MVC   VERSION+21(3),=C'LDW'                               LDW1\n         SPACE 1\n         TSFIND  PSCB,R1                -> PSCB                    LDW1\n         SPACE 1\n         MVC   USERID(7),0(R1)          GET THE TSO USER ID        LDW1\n         MVC   USERID+7(L'USERID-7),BLANKS   BLANK THE REST        LDW1\n*%       MVC   LINELEN,=H'80'           DEFAULT LINE LENGTH        LDW1\n         MVC   DISPCONS(DISPCONL),DSPCON80  CONSTANTS FOR LEN=80   LDW1\n         MVC   CTL3270,CTL3270C         INIT 3270 CONTROL BYTES    LDW1\n         MVC   END3270,END3270C         FINISH IT                  LDW1\n         LA    R0,SCREENL               GET TPUT LENGTH            LDW2\n         LA    R1,SCREEN                GET TPUT ADDR              SDM5\n         STM   R0,R1,REGS3270           SAVE FOR FULLSCR TPUT      LDW1\n         MVI   REGS3270+4,X'03'         SET FULLSCR TPUT FLAG      SDM5\n         XC    CURPOS,CURPOS            CLEAR CURSOR POSITION      LDW1\n         LA    R1,JFCB                  -> JFCB                    LDW1\n         ST    R1,EXLST                                            LDW1\n         MVI   EXLST,X'87'              CALL IT A JFCB             LDW1\n         SPACE 1\n         LA    R6,4095(,R13)            TEMP POINT TO EXTRA        LDW1\n         USING TSDSECT+4095,R6                                     LDW1\n         LA    R0,IDEFTAB                                          LDW3\n         ST    R0,AIDEFTAB                                         LDW1\n         LA    R1,ITRTAB                                           LDW1\n         ST    R1,AITRCTAB                                         LDW1\n         MVI   0(R1),X'FE'              SET TO INITIAL VALUE       LDW1\n         MVC   1(120-1,R1),0(R1)        SET THE WHOLE THING        LDW1\n         ST    R1,ITRAVAL               -> FIRST POS               LDW1\n         ST    R1,CURRITR               -> CURRENT POS             LDW1\n         MVI   ENDITAB,X'FF'            MARK THE END OF THE TABLE  LDW1\n         MVI   ITREND,X'FF'             DITTO                      LDW1\n         LA    R0,ITREND                POINT TO IT                LDW1\n         ST    R0,AITREND               SAVE                       LDW1\n         LA    R1,SCRWORK               -> WORK AREA               LDW2\n         ST    R1,ASCRWORK              SAVE ADDR                  LDW2\n         LA    R1,OLDSCR                -> SCREEN SAVE AREA        SDM5\n         ST    R1,AOLDSCR               SAVE ADDRESS               SDM5\n         DROP  R6                                                  LDW1\n         L     R1,=A(DCBMSK)            GET ADDR OF PATTERN DCB    LDW1\n         MVC   DCBU(DCBUL),0(R1)        SET UP DCB FOR INPUT       LDW1\n         XC    IOB(40),IOB              INIT IOB                   LDW1\n         MVI   IOB,X'42'                IOBFLAGS                   LDW1\n         LA    R0,ECB                   -> EXCP ECB                LDW1\n         ST    R0,IOB+4                                            LDW1\n         LA    R0,DCBU                                             LDW1\n         ST    R0,IOB+20                                           LDW1\n         MVC   CCWS(CCWL),CCWLIST       INIT CCWS                  LDW1\n         LA    R0,CCHHR                 PTR FOR SEARCH ID EQ       LDW1\n         STCMX R0,B'0111',CCW#R#S+1,BYTE=31   SET ADDR             LDW1\n         STCMX R0,B'0111',CCW#W#S+1,COPY=CCW#R#S+1     HERE TOO    LDW1\n         STCMX R0,B'0111',CCW#F#S+1,COPY=CCW#R#S+1     HERE TOO    LDW1\n         LA    R1,CCW#R#S               GET TIC ADDR               LDW1\n         STCMX R1,B'0111',CCW#R#T+1,BYTE=08    SET IT              LDW1\n         LA    R1,CCW#W#S               GET TIC ADDR               LDW1\n         STCMX R1,B'0111',CCW#W#T+1,BYTE=08    SET IT              LDW1\n         LA    R1,NAME                  -> KEY                     LDW1\n         STCMX R1,B'0111',CCW#D#S+1,BYTE=E9    SET IT              LDW1\n         LA    R1,CCW#D#S               GET TIC ADDR               LDW1\n         STCMX R1,B'0111',CCW#D#T+1,BYTE=08   SET IT               LDW1\n         LA    R1,CCW#F#S               GET TIC ADDR               LDW1\n         STCMX R1,B'0111',CCW#F#T+1,BYTE=08   SET IT               LDW1\n         MVI   FLAGS2,0                 INIT FLAGS                 LDW1\n         MVI   FLAGS3,0                 INIT FLAGS                 LDW5\n         SPACE 1                                                   LDW3\n*        GUESS IF THIS IS A 3270.                                  LDW1\n         SPACE 1                                                   LDW3\n         GTSIZE\n         LTR   R0,R0                    ANY LINES?        (ZAP)    MAS1\n         BZ    *+L'*+12                 NO, NOT 3270      (ZAP)    MAS1\n         CH    R1,=H'80'                80 COLUMNS?                LDW1\n         BNE   *+L'*+4                  NO, NOT 3270               LDW1\n         OI    FLAGS3,F3270+RESHOWF     24 LNS & 80 COLS ==> 3270  LDW5\n         EJECT                                                     LDW1\n*  PARSE THE INPUT LINE :\n*\n*        ZAP  'DSN'  VOL(VOLSER) CRT LOG TERSE/VERBOSE\n         SPACE 1\n         TSPARSE CBUF=(CPPLCBUF,I),PCL=(=V(PCL),I)\n         SPACE 1\n         BXLE  R15,R15,OKPARSE          IT'S OK\n         LA    R1,=CL40'INVALID INPUT'  OOOPS\n         B     CSIO#                    SHOW AND QUIT\nOKPARSE  L     R7,TSPARANS              POINT TO PARSE BLOCK\n         OACUSING IKJPARMD,R7           TEMP TO GET DSN AND VOL     MVS\n         CLI   NWK+1,2                  SEE IF TERSE\n         BNE   *+L'*+4                  IF NOT NO FLAG\n         OI    FLAGS2,TERSEF            SUPRESS WHERE\n         CLI   CRTK+1,1                 SEE IF CRT SPECIFIED\n         BNE   *+L'*+4                  IF NOT DONT SET FLAG\n         OI    FLAGS3,CRTF              IF SO SET FLAG             LDW5\n         CLI   LOGK+1,1                 SEE IF LOG SPECIFIED\n         BNE   *+L'*+4                  IF NOT NO LOG\n         OI    FLAGS2,LOGF\n         CLI   NOT3270K+1,1             NOT3270 SPECIFIED?         LDW1\n         BNE   *+L'*+4                  NO, SKIP                   LDW1\n         NI    FLAGS3,255-F3270         YES, TURN OFF FLAG         LDW5\n         XC    WIDTHS(4+4),WIDTHS       DEFAULT = CARET LINE ONLY  LDW1\n         TM    FLAGS3,F3270+CRTF        ANYTHING INTERESTING?      LDW5\n         BZ    NOT$FULL                 NO, SKIP                   LDW3\n         NI    FLAGS2,255-TERSEF        ANY OF THEM IMPLY VERBOSE  LDW5\n         MVC   WIDTHD(4),MAXWIDTH       SO 'D' WORKS               LDW1\n         MVC   WIDTHU(4),MAXWIDTH       DITTO                      LDW1\n         SPACE 1\n*        CHECK OUT THE USER. IF HE CAN'T GET IN, OR\n*        CAN'T TOUCH THE DATA-SET, KICK HIM OUT.\n         SPACE 1\nNOT$FULL L     R1,PDEPTR-PDE+PDLDSN     POINT TO DSN SUPPLIED      LDW1\n         LH    R15,PDELEN-PDE+PDLDSN    POINT TO ITS LEN (<= 45)\n         STH   R15,DSNAMEL              SET DSNAME LENGTH         *WDD*\n         BCTR  R15,0                    EX LEN\n         MVC   DSNAME(44),BLANKS        CLEAR TARGET               LDW1\n         MVC   VOLSER(6),BLANKS         BLANK VOL TOO\n         MVC   PASSWORD(8),BLANKS       AND THE PASSWORD           LDW1\n         MVC   DSNAME(0),0(R1)          << EXECUTED >>\n         EX    R15,*-6                  MOVE PARSE DSN TO FULL TARGET\n         MVC   DISPDSN,DSNAME           COPY FOR DISPLAYING        LDW1\n         CLC   DSNAME(7),=CL7'SYSCTLG'  IS IT OS-CATALOG           JCJ1\n         BE    SETSSTV                  IF YES MARK IT             -EU-\n         CLC   DSNAME(8),=CL8'CATALOG.' IS IT OUR VSAM-CATALOG     -EU-\n         BE    SETSSTV                  IF YES MARK IT             -EU-\n         CLC   DSNAME(5),=CL5'UCAT.'    IS IT OUR VSAM-CATALOG     -EU-\n         BNE   SETSSTV+L'SETSSTV        IF NOT LET IT BY           -EU-\nSETSSTV  OI    FLAGS2,SENSF+LOGF        MARK AS SENSITIVE\n         TM    PDLDSN+PDEFLAG3-PDE,PDEFPRES  PSWD PRESENT?         LDW1\n         BNO   NOPASS                   NO                         LDW1\n         L     R1,PDLDSN+PDEPTR3-PDE    -> PSWD                    LDW1\n         LH    R15,PDLDSN+PDELEN3-PDE   LENGTH                     LDW1\n         BCTR  R15,0                    -1 FOR EX                  LDW1\n         MVC   PASSWORD(0),0(R1)        << EXECUTED >>             LDW1\n         EX    R15,*-6                                             LDW1\nNOPASS   TM    PDEFLAG-PDE+VOLVOL,PDEFPRES   ANY VOL SPEC?         LDW1\n         BNO   NOVOL                    NO, BLANK (=DAIR CATALOG)\n         L     R1,PDEPTR-PDE+VOLVOL     GET PTR TO VOL SER\n         LH    R15,PDELEN-PDE+VOLVOL    YES, GET ITS LEN\n         BCTR  R15,0                    GET EX LEN\n         MVC   VOLSER(0),0(R1)          << EXECUTED >>\n         EX    R15,*-6                  MOVE VOL SPEC TO VOLSER\nNOVOL    MVC   ALLOCDSN,BLANKS          CLEAR FIELD                LDW1\n         TM    PDEFLAG-PDE+PDLALCDS,PDEFPRES   GIVEN?              LDW1\n         BNO   NOALCDSN                 NO, SKIP                   LDW1\n         L     R1,PDEPTR-PDE+PDLALCDS   POINT TO DSN               LDW1\n         LH    R15,PDELEN-PDE+PDLALCDS  GET LENGTH                 LDW1\n         STH   R15,ALLDSNL              SET LENGTH FOR ALLOC       -EU-\n         BCTR  R15,0                    -1 FOR EX                  LDW1\n         MVC   ALLOCDSN(0),0(R1)        << EXECUTED >>             LDW1\n         EX    R15,*-6                  MOVE IN DSN                LDW1\nNOALCDSN CLC   =C'FORMAT4.DSCB',DSNAME  VTOC?                      LDW1\n         BNE   NOTVTOCR\n         MVC   DSNAMEL(2),=H'44'                                  *WDD*\n         MVI   DSNAME,X'04'             YES, CHANGE DSN\n         MVC   DSNAME+1(43),DSNAME      TO 44X'04'\n         MVC   DISPDSN,BLANKS           RESET FIELD                LDW1\n         MVC   DISPDSN(8),=C'VTOC FOR'  SHOW SOMETHING GOOD        LDW1\n         MVC   DISPDSN+9(6),VOLSER      MOVE IN VOLUME NAME        LDW1\n         OI    FLAGS2,SENSF+LOGF        MARK AS SENSITIVE          LDW1\n         CLI   ALLOCDSN,C' '            ALLOCDSN GIVEN?            LDW1\n         BNE   NOTVTOCR                 YES, VOLSER IS IMPLIED     LDW1\n         CLI   VOLSER,C' '              CATALOG FOR VTOC?\n         BE    BADDSN1                  YES, WHAT DOES THAT MEAN?\nNOTVTOCR XC    REQAUT(REQAUTL),REQAUT                              -EU-\n         MVC   REQAUT+1(3),=AL3(MDL@IX)                            -EU-\n         LA    R1,RQA                                              -EU-\n         ST    R1,REQAUT+4                                         -EU-\n        $EACM  REQAUT                                              -EU-\n         L     R1,CVTPTR                ADDRESS OF CVT             -EU-\n         USING CVT,R1                                              -EU-\n         L     R1,CVTTCBP               OLD/CURRENT                -EU-\n         DROP  R1                                                  -EU-\n         L     R1,4(,R1)                CURRENT TCB                -EU-\n         USING TCB,R1                                              -EU-\n         MVC   ATIOT,TCBTIO             ADDRESS OF TIOT            -EU-\n         TM    FLAGS2,SENSF             SENSITIVE DATA-SET?        -EU-\n         BZ    OKDSNUP                  NO                         -EU-\n         L     R1,TCBJSCB               ADDRESS OF JSCB            -EU-\n         DROP  R1                                                  -EU-\n         USING IEZJSCB,R1                                          -EU-\n         L     R1,JSCBPSCB              ADDRESS OF TSO PSCB        -EU-\n         DROP  R1                                                  -EU-\n         LTR   R1,R1                    ANY PSCB?                  -EU-\n         BZ    BADDSN2                  NO, NOT A TSO SESSION      -EU-\n         CLI   RQA,LV0                  AUTHORIZED?                -EU-\n         BE    BADDSN3                  NO, NOT AUTHORIZED         -EU-\n         SETAUTH                                                   -EU-\n         OI    GODFLAG,GODAUTH          SET AUTHORIZED NOW         -EU-\nOKDSNUP  OI    GODFLAG,GOD              ASSUME HE CAN UPDATE       LDW1\n         L     R0,=A(256*L'TIOEDDNM)    ACQUIRE DD-NAMES AREA      -EU-\n         GETMAIN R,LV=(0)               MAKE IT UNCONDITIONAL      -EU-\n         ST    R1,TDDNMSV               SAVE STARTING ADDRESS      -EU-\n         LA    R2,256                   MAX. NO. OF DD-NAMES       -EU-\n         XR    R15,R15                  RETAIN ALL DD-NAMES TO     -EU-\n         L     R14,ATIOT                PREVENT DE-ALLOC. OF       -EU-\n         USING TIODSECT,R14             PRE-ALLOC. DS              -EU-\nSCNRTN   CLC   TIOELNGH(4),=D'0'        END OF TIOT ?              -EU-\n         BE    OKDSN5                   YES, CONTINUE          -EU-LDW1\n         CLC   TIOEDDNM(L'TIOEDDNM),=CL8' '                        -EU-\n         BE    *+L'*+24                                            -EU-\n         BCT   R2,*+L'*+4                                          -EU-\n         B     TOOMANY                                             -EU-\n         MVC   0(L'TIOEDDNM,R1),TIOEDDNM                           -EU-\n         LA    R1,L'TIOEDDNM(R1)                                   -EU-\n         XC    0(L'TIOEDDNM,R1),0(R1)                              -EU-\n         IC    R15,TIOELNGH                                        -EU-\n         ALR   R14,R15                                             -EU-\n         B     SCNRTN                                              -EU-\n         DROP  R14                                                 -EU-\n         SPACE 1                                                   LDW1\n*        INVALID DSN OR INVALID ACCESS. SORRY.\n         SPACE 1\nBADDSN   LA    R1,=CL40'DATA-SET UNAVAILABLE OR NON-EXISTENT'\n         B     CSIO#\nBADDSN1  LA    R1,=CL40'MISSING DSNAME TO ALLOCATE VOLUME'         -EU-\n         B     CSIO#                                               -EU-\nBADDSN2  LA    R1,=CL40'THIS IS NOT A TSO SESSION RUNNING'         -EU-\n         B     CSIO#                                               -EU-\nBADDSN3  LA    R1,=CL40'UNAUTHORIZED DATA-SET ACCESS'              -EU-\n         B     CSIO#                                               -EU-\nBADDSN4  LA    R1,=CL40'OPEN FAILED (ERROR)'                       -EU-\n         B     CSIO#                                               -EU-\nBADDSN5  LA    R1,=CL40'NO EXTENT IN DATA-SET'                     -EU-\n         B     CSIO#                                               -EU-\nTOOMANY  LA    R1,=CL40'DD-NAMES TABLE OVERFLOW'                   -EU-\n         B     CSIO#                                               -EU-\n         SPACE 1\n         DROP  R7                       NO NEED FOR IKJPARMD NOW\n         EJECT\n*        SET UP DEFAULTS AND INITIALS COND'S.\n         SPACE 1\nOKDSN5   DS    0H\n*LDW1    LA    R2,=C'ATTN SIGNALED'     WHAT TO SAY WHEN HE DOES\n*LDW1    LA    R3,13                    LENGTH\n         XC    STAXLIST(STAXL),STAXLIST INITIALIZE STAX LIST\n         L     R14,=A(STAXEXIT)         POINT TO STAX EXIT\n*LDW1    STAX  (R14),OBUF=((R2),(R3)),USADDR=(R13),MF=(E,STAXLIST)\n         STAX  (R14),USADDR=(R13),MF=(E,STAXLIST)                  LDW1\n         TM    FLAGS3,CRTF              SEE IF CRT SPECIFIED       LDW5\n         BNO   OKDSN5A                  IF NOT LEAVE WIDTH ASIS\n         MVC   WIDTHS(8),=XL8'0000000400000004'\nOKDSN5A  L     R1,=A(TRCHARE)           INITIALIZE PTR TO...   -EU-LDW1\n         ST    R1,TRTABADD              TR TABLE (THE EBCDIC ONE)\n         XC    TRTXTAB,TRTXTAB                                     -EU-\n         LA    R1,LINE06                PT TO FIRST AVAIL SCREEN LOC\n         ST    R1,FIRSTSCR              SAVE IT\n         LA    R1,LINE19                PT TO LAST AVAIL SCREEN LOC\n         ST    R1,MAXSCR                SAVE IT\n         XC    LOOKFOR(3*18),LOOKFOR    CLEAR SCAN STRNG SAVE AREA LDW1\n         XC    MEMTTR(3),MEMTTR         NO MEMBER YET\n         XC    TXTTTR(3),TXTTTR         NO TEXT FOR MEMBER YET      *N*\n         XC    ESDTTR(3),ESDTTR         NO ESD PTR YET             LDW1\n         MVC   ESDID(2),=H'1'           ESDID DEFAULTS TO 1 FOR IBM\n         MVI   CONTINUE,0               NO SCAN, STORES OR SETS YET\n         MVI   CPUTFLAG,NOCSERR         CSOUT WILL WORK FOR SURE\n         BAS   R8,CLEARDEF              INITIALIZE IDEF TABLE AND PTRS\n         MVC   TTR(4),=XL4'00000100'    INITIALIZE TTRN= 00000100\n         SPACE 2\n*        ZAP --- OPEN AND INITIALIZE I/O FILE.\n         SPACE 1\n         LA    R2,DSNAMEL               SET DSN                    -EU-\n         CLI   ALLOCDSN,C' '            ALLOC DSN GIVEN?           LDW3\n         BE    GO$ALLOC                 NO, GO DO IT               LDW1\n         LA    R2,ALLDSNL               CHANGE DSN                 -EU-\n         SPACE 1\n*        ALLOC THE FILE AND OPEN IT, UPDAT RIGHT OFF THE BAT.\n*        *** OPEN IT FOR INPUT ***                                 LDW1\n         SPACE 1\nGO$ALLOC ALLOC DSN=(R2),VOL=VOLSER,DISP=(SHR,KEEP,KEEP),       *WDD-EU-X\n               PERM=NO,PASSWD=PASSWORD                             LDW1\n         SPACE 1\n         BXH   R15,R15,BADDSN\n         MVC   DDNALL(8),DA08DDN-DAPB08+DAPBAREA  SAVE DDNAME      -EU-\n         OI    GODFLAG,GODALL           SET ALLOCATED              -EU-\n         LA    R0,DCBU                  POINT TO DCB               LDW1\n         ST    R0,DCBLIST               PUT IN OPEN/CLOSE LIST\n         MVI   DCBLIST,X'80'            INPUT                      LDW1\n         MVC   DCBDDNAM-IHADCB+DCBU(8),DDNALL     DDNAME           -EU-\n         LA    R0,EXLST                 SET UP FOR RDJFCB          LDW1\n         ST    R0,DCBEXLST+DCBU-IHADCB  SET IN DCB             -EU-LDW1\n         RDJFCB  MF=(E,DCBLIST)         GET THE JFCB               LDW1\n         L     R1,EXLST                 -> JFCB                    LDW1\n         MVC   0(44,R1),DSNAME          MAYBE CHANGE THE DSN       LDW3\n         OPEN  MF=(E,DCBLIST),TYPE=J    OPEN THE DATASET           LDW1\n         TM    DCBU+48,X'10'            DID IT OPEN?\n         BNO   BADDSN4                  NO DARN\n         SPACE 1\n*        GET VOLSER.\n         SPACE 1\n         L     R3,DCBDEBAD-IHADCB+DCBU  GET THE DEB PTR\n         L     R3,(DEBBASND-DEBBASIC)+(DEBUCBAD-DEBDASD)(R3) UCB   -EU-\n         MVC   VOLSER(6),SRTEVOLI-UCB(R3)  SAVE VOL=SER OF DATASET\n         CLI   DSNAME,X'04'             VTOC?                      LDW1\n         BNE   OKVOLSER                 NO, OK                     LDW1\n         CLI   DISPDSN+9,C' '           HAVE THE VOL ALREADY?      LDW1\n         BNE   OKVOLSER                 YES, SKIP                  LDW1\n         MVC   DISPDSN+9(6),VOLSER      NO, FILL IT IN             LDW1\n         SPACE 2\n*        FIND THE LAST TTR FROM THE FORMAT 1 DSCB OF\n*        THE DATA-SET, OBTAINED, CLEVERLY ENOUGH, BY\n*        AN 'OBTAIN' (ASSUMING IT'S NOT A VTOC).\n         SPACE 1\nOKVOLSER XC    ENDTTR,ENDTTR            SAY NO LAST TTR FOR DEFAULT\n         XC    DSCB(256),DSCB           CLEAR OUT DEFAULT DSCB\n         MVI   DSORG,0                  SAY NOT PARTITIONED FOR NOW\n*LDW1    CLI   DSNAME,X'04'             VTOC HERE?\n*LDW1    BE    NOLAST                   YES, DS1LSTAR DOESN'T EXIST\n*DSCBLIST CAMLST SEARCH,DSNAME,VOLSER,DSCB                         LDW1\n         MVC   DSCBLIST(4),=AL1(193,0,0,0) MOVE IN OPTIONS\n         LA    R14,DSNAME               DSNAME FOR OBTAIN\n         LA    R15,VOLSER               PT TO VOLSER\n         LA    R0,DSCB+44               DSCB BUFFER                LDW1\n         STM   R14,R0,DSCBLIST+4        STORE ALL 3 POINTERS\n         OBTAIN DSCBLIST                GET THE FMT1 DSCB\n         BXLE  R15,R15,GETLTTR1         IF OK USE INFO\n         SPACE 1\n*LDW1    TPUTX 'OBTAIN FAILED'\n*LDW1    B     END\nOBTFAIL  LA    R1,=CL40'OBTAIN FAILED'  POINT TO MSG               LDW1\n         B     CSIO#                    LEAVE                      LDW1\n         SPACE 1\nGOTVTOC  MVC   DS1BLKL,=H'96'           SET BLKSIZE OF VTOC        LDW1\n         MVI   DS1KEYL,44               SET KEYLEN OF VTOC         LDW1\n         MVI   DSORG,0                  NO DSORG                   LDW1\n         MVC   LASTFMT1(5),DSCB+45      SAVE PTR TO LAST FMT1 USED LDW4\n         B     NOLAST                   CONTINUE                   LDW1\n         SPACE 1\nGETLTTR1 DS    0H                                                  LDW1\n         CLI   DSNAME,X'04'             VTOC?                      LDW1\n         BE    GOTVTOC                  YES, GET INFO              LDW1\n         MVC   DSORG(1),DS1DSORG        SAVE DSORG FOR M           LDW1\n         MVC   ENDTTR,DS1LSTAR          SAVE IT                    LDW4\n         CLI   DS1NOEPV,0               ANY EXTENTS?              *LPR*\n         BE    BADDSN5                  NO, CAN'T ACCESS          *LPR*\n         TM    DS1OPTCD,DS1OPTIC        YES, ICF DATA-SET?         -EU-\n         BZ    NOLAST                   NO                         -EU-\n         CLI   RQA,LV14                 YES, AUTHORIZED?           -EU-\n         BL    BADDSN3                  NO, NOT AUTHORIZED         -EU-\n         SETAUTH                                                   -EU-\n         OI    GODFLAG,GODAUTH          SET AUTHORIZED NOW         -EU-\n         SPACE 1\n*        BUY BUFFER.                    (THIS CODE MOVED HERE BY LDW)\n         SPACE 1\nNOLAST   LH    R0,DS1BLKL               PICK IT UP                 LDW1\n         LTR   R0,R0                    ZERO BLKSIZE (LIKE JOBQ)?\n         BP    *+L'*+4                  NO, GO ON\n         LH    R0,=AL2(20*1024)         USE 20K FOR DEFAULT IN CASE\n         CH    R0,=H'264'               BELOW MIN (ESP PDS DIRECTORY)\n         BNL   *+L'*+4                  NO, LEAVE BLKSIZE AS IS\n         LH    R0,=H'264'               YES, SET MIN=PDS DIRECTORY SIZE\n         MVI   KEYLEN,0                 CLEAR FOR COPY             LDW1\n         MVC   KEYLEN+1(1),DS1KEYL      COPY KEYLEN                LDW1\n         AH    R0,KEYLEN                ADD TO BUFFERSIZE\n         AH    R0,=Y(8+1)               GET ROOM FOR COUNT         LDW1\n         SPACE 1\n*        THE +1 IS SO WILL ALWAYS HAVE RESIDUAL.                   LDW1\n         SPACE 1\n         LR    R1,R0                    COPY VALUE\n         AH    R0,=AL2(LCSOUT)          WORKAREA SIZE\n         STH   R1,BUFFSIZE              STORE AWAY FOR LATER USE\n         STH   R1,CCW#R#R+6             SET FOR MAX READ           LDW1\n         STH   R1,CCW##R0+6             DITTO FOR R0               LDW1\n         AH    R0,=Y(57)           SO NO 0C4'S NEAR BUFF. END  -EU-LDW4\n         SRL   R0,3                     ROUND UP TO DOUBLE-WORD    -EU-\n         SLL   R0,3                                                -EU-\n         ST    R0,SIZEWORK              SAVE AREA LENGTH           -EU-\n*LDW1    XC    GETLIST(GETLISTL),GETLIST  FIX IT\n*LDW1    GETMAIN  EC,LV=(0),A=ADDRWORK,MF=(E,GETLIST)\n*LDW1    L     R1,ADDRWORK              GET ADDR OF CORE WE HOPE\n*LDW1    BXLE  R15,R15,OKGETCS          IT WORKED\n*LDW1    BAS   R8,CLOSE                 NO, CLOSE THE DATASET AND\n*LDW1    LA    R1,=CL40'NOT ENOUGH CORE FOR BUFFERS'  POINT TO MSG\n*LDW1    B     CSIO#                    ABOUT HIS MISFORTUNE, THEN...\n         GETMAIN R,LV=(0)               MAKE IT UNCONDITIONAL      LDW1\n         ST    R1,ADDRWORK              SAVE ADDR FOR LATER        LDW1\n         AH    R1,=AL2(LCSOUT)          ADD WORKAREA SIZ TO PT TO BUFF\n         ST    R1,ADDRCNT               SAVE ADDR OF COUNT         LDW1\n         STCMX R1,B'0111',CCW#R#R+1,COPY=ADDRCNT+1                 LDW1\n         STCMX R1,B'0111',CCW##R0+1,COPY=ADDRCNT+1                 LDW1\n         STCMX R1,B'0111',CCW#F#W+1,COPY=ADDRCNT+1                 LDW1\n         LA    R1,8(,R1)                -> KEY FIELD               LDW1\n         ST    R1,ADDRKEY               SAVE ADDR OF KEY           LDW1\n         ST    R1,ADDRBUFF              DEFAULT DISPLAY IS KEY     LDW1\n         STCMX R1,B'0111',CCW#W#W+1,COPY=ADDRBUFF+1                LDW1\n         STCMX R1,B'0111',CCW#D#R+1,COPY=ADDRBUFF+1                LDW1\n         TM    FLAGS2,LOGF              ARE WE LOGGING?\n         BNO   *+L'*+4                  IF NOT SKIP OPEN\n         BAS   R8,OPENOUT               IF SO DO THE OPEN\n         SPACE 1\n*        GET FREE DEFINE TABLE SYMBOLS FOR\n*        'LRECL', 'KEYLEN' AND 'BLKSIZE'.\n         SPACE 1\n         L     R3,AIDEFTAB              PT TO DEFINE TABLE\n         MVI   0(R3),C'L'               GIVE SYMBOL 'L' FOR 'LRECL'\n         MVC   8(2,R3),DS1LRECL         GET LRECL, PUT IN TAB\n         MVC   10(2,R3),=C'BL'          GIVE 'BL' FOR BLKSIZE (MAX)\n         MVC   18(2,R3),DS1BLKL         GET BLKSIZE, PUT IN TAB    LDW1\n         MVI   20(R3),C'K'              GIVE 'K' FOR 'KEYLEN' SYMBOL\n         MVC   28(2,R3),KEYLEN          GET KEYLEN AND PUT IN TABLE\n         LA    R3,30(,R3)               UPDATE DEFINE TABLE PTR\n         ST    R3,IDEFAVAL              SAVE IT AS PTR TO CURR ENTRY\n         MVC   REP,BLANKS               CLEAR REPLY OUT            LDW1\n         MVC   ICREP,REP                                           -EU-\n         MVI   CAPSFLG,YESCAPS                                     -EU-\n         MVC   LINE19,BLANKS            CLEAR ERR MSG PART OF SCRN LDW1\n         XC    BASEVAL,BASEVAL          BASE = 0                   LDW1\n         TM    FLAGS3,F3270             3270 MODE?                 LDW5\n         BNO   NO$STFS                  NO, SKIP                   LDW1\n         STFSMODE  ON,INITIAL=YES       START IT UP                LDW1\n         OI    FLAGS3,FSMODE            IT'S ON, NOW               LDW5\n         B     NEW$READ                 DON'T TPUT VERSION LINE    LDW5\nNO$STFS  MVC   LINEBUFF(40),BLANKS      INIT                       LDW5\n         MVC   LINEBUFF(L'VERSION),VERSION                         LDW1\n         BAS   R14,PUTLINE$             SAY WHAT VERSION           LDW1\n         SPACE 2\n*        ZAP --- CREATE THE SCREEN DISPLAY AND GET COMMAND.\n*        HERE IF A NEW BLOCK IS TO BE READ AND\n*        THE SCREEN IS TO BE BUILT FROM IT.\n         SPACE 1                                                   LDW1\nNEW$READ XC    NOWSTUFF(NOWLEN-L'BASEVAL),NOWSTUFF RESET BUFF OFF  LDW1\n         BAS   R8,READBLK               GET A BLK FROM DS (BDAM)\n         B     NEW$DISP                 SKIP AROUND                LDW1\n         SPACE 1\n*        HERE IF BUILD SCREEN WITHOUT READING A NEW BUFFER IN.\n         SPACE 1\nNEWDSPNT MVI   TRACE,NOTRACE            SET FLAG                   LDW1\nNEW$DISP BAS   R8,CLEAR                 CLEAR THE SCREEN\n         OC    BLKLEN(2),BLKLEN         0 READ BEFORE?\n         BZ    DISPLAY                  YES, THERE'S NOTHING TO DISP\n         LH    R8,OLDPOINT              GET CARET OFFSET           LDW1\n         N     R8,NOWMASK               GET HIGH PART              LDW1\n         LR    R5,R8                    COPY                       LDW1\n         SH    R8,SCRBYTES              BACK UP TO SCREEN START    LDW1\n         BNM   *+L'*+2                  CONTINUE IF OK             LDW1\n         XR    R8,R8                    SCR START = BLK START      LDW1\n         A     R8,ADDRBUFF              GET ADDRESS INTO BUFFER\n         A     R5,ADDRBUFF              GET DBLW ADDRESS INTO BUFFER\n         L     R15,FIRSTSCR             PT TO FIRST AVAIL SCREEN POS\n         SPACE 1\n*        FORMAT ONE LINE OF SCREEN DISPLAY.\n         SPACE 1\nFORMAT   LR    R0,R8                    COPY BUFFER PTR            LDW1\n         S     R0,ADDRBUFF              OFFSET INTO BUFFER FOR SCR LDW1\n         ST    R0,TEMP                  SAVE FOR UNPK              LDW1\n         HEX   (0,R15),TEMP+1,LEN=3,DIGITS=5,HEXTAB=TRHEX          LDW1\n         MVC   TEMP(16),0(R8)           COPY CHAR FORM OF DATA     LDW1\n         UNPK  TEMP2+00(14+1),TEMP+00(7+1)   BYTES 01-07           LDW1\n         UNPK  TEMP2+14(14+1),TEMP+07(7+1)   BYTES 08-14           LDW1\n         UNPK  TEMP2+28(04+1),TEMP+14(2+1)   BYTES 15-16           LDW1\n         TR    TEMP2(32),TRHEX          MAKE EBCDIC                LDW1\n         L     R1,TRTABADD              GET RIGHT TRTAB PTR        LDW4\n         TR    TEMP(16),0(R1)           MAKE IT VALID CHARS        LDW4\n         LR    R1,R0                    COPY BLK OFFSET            LDW1\n         AH    R1,LINEHEX               GET NEXT OFFSET            LDW1\n         SH    R1,BLKLEN                COMPUTE AMOUNT SHORT       LDW1\n         BNP   FORMATOK                 SKIP IF THIS LINE FULL     LDW1\n         LA    R14,TEMP2                -> AREA                    LDW1\n         AH    R14,LINEHEX2             -> PAST END                LDW1\n         LA    R2,0(R1,R1)              GET LENGTH OF HEX GARBAGE  LDW1\n         SR    R14,R2                   -> GARBAGE HEX             LDW1\nFMTBLANK MVC   0(0,R14),BLANKS          << EXECUTED >>             LDW1\n         EX    R2,*-6                   BLANK THE GARBAGE HEX      LDW1\n         SPACE 1\n*        NOTE THAT TEMP2 IS LONG ENOUGH THAT BLANKING              LDW1\n*        1 CHAR TOO MANY DOESN'T HURT ANYTHING.                    LDW1\n         SPACE 1\n         LA    R14,TEMP                 -> CHARS                   LDW1\n         AH    R14,LINEHEX              -> PAST END                LDW1\n         SR    R14,R1                   -> GARBAGE CHARS           LDW1\n         BCTR  R1,0                     -1 FOR EX                  LDW1\n         EX    R1,FMTBLANK              CHARS ALSO GET TREATMENT   LDW1\n         SPACE 1\n*ORMATOK MVC   08(4,R15),TEMP2+00       MOVE HEX TO SCREEN         LDW1\n*        MVC   13(4,R15),TEMP2+04                                  LDW1\n*        MVC   19(4,R15),TEMP2+08                                  LDW1\n*        MVC   24(4,R15),TEMP2+12                                  LDW1\n*        MVC   31(4,R15),TEMP2+16                                  LDW1\n*        MVC   36(4,R15),TEMP2+20                                  LDW1\n*        MVC   42(4,R15),TEMP2+24                                  LDW1\n*        MVC   47(4,R15),TEMP2+28                                  LDW1\n*        MVI   54(R15),C'|'             PUT IN DELIM               LDW1\n*        MVC   55(16,R15),TEMP          MOVE CHARS                 LDW1\n*        MVI   71(R15),C'|'             ENDING DELIM               LDW1\n         SPACE 1\nFORMATOK MVC   TEMP2+32(2),=C' |'       MOVE IN CONSTANTS FOR TR   LDW1\n         CLI   LINELEN+1,40             WHICH ONE?                 LDW1\n         BE    FORMAT40                 SHORT                      LDW1\n         MVC   7(65,R15),DISPTR80       MOVE IN \"TRANSLATE\" TABLE  LDW1\n         TR    7(65,R15),TEMP           DISTRIBUTE HEX TO SCREEN   LDW1\n         B     FORMATXX                 CONTINUE                   LDW1\nFORMAT40 MVC   7(32,R15),DISPTR40       MOVE IN SHORT TABLE        LDW1\n         TR    7(32,R15),TEMP           DISTRIBUTE HEX TO SCREEN   LDW1\nFORMATXX CR    R8,R5                    BUFF PTR = DATA PTR?       LDW1\n         BNE   NO$CARET                 NO, SKIP CARET             LDW1\n         LR    R1,R15                   COPY LINE ADDR             LDW1\n         BCTR  R1,0                     BACK UP TO ATTR BYTE       LDW1\n         MVI   0(R1),X'E8'              HIGH INTENSITY PROTECTED   LDW1\n         LH    R1,OLDPOINT              GET CARET OFFSET           LDW1\n         N     R1,BITMASK               GET LOW ORDER PART         LDW1\n         LA    R3,BYTES(R1)             PT TO COLUMN OF SCRN       LDW1\n         IC    R1,0(,R3)                GET SCREEN COL FOR CARET   LDW1\n         LA    R14,0(R15,R1)            PT TO WHERE IT GOES        LDW1\n         MVI   0(R14),C'>'              ASSUME EVEN                LDW1\n         TM    OLDPOINT+1,1             IS IT?                     LDW1\n         BNO   *+L'*+4                  YES, SKIP                  LDW1\n         MVI   0(R14),C'<'              ODD POINTS THE OTHER WAY   LDW1\n         ST    R14,MIDLINE              SAVE PTR TO CARET LINE     LDW1\nNO$CARET AH    R8,LINEHEX               UPDATE BUFFER PTR          LDW1\n         LA    R15,$I(,R15)             UPDATE SCREEN PTR          LDW1\n         AH    R0,LINEHEX               NEXT OFFSET                LDW1\n         CH    R0,BLKLEN                PAST END OF BLOCK?         LDW1\n         BNL   DISPLAY                  YES, GO DISPLAY            LDW1\n         C     R15,MAXSCR               OUT OF SCREEN?             LDW1\n         BL    FORMAT                   NO, DO ANOTHER LINE        LDW1\n         B     DISPLAY                  SKIP (WE WILL TRACE)       LDW1\nDISPLYNT MVI   TRACE,NOTRACE            SET NOTRACE FLAG           LDW1\nDISPLAY  MVI   TTR+3,NOSEQRD            TURN OFF SEQ READ          LDW5\n         MVI   EOFRET,YESEOF            SAY EOF'S WILL BE RECOGNIZED\n         TM    FLAGS3,F3270             FULLSCREEN?                LDW5\n         BNO   *+L'*+8                  NO, SKIP                   LDW3\n         NI    FLAGS2,255-NOWHEREF      YES, DON'T SUPPRESS WHERE  LDW1\n         NI    FLAGS3,255-NODISPF       ... OR REDISPLAY           SDM6\n         TM    FLAGS3,NODISPF           SUPPRESS REDISPLAY?        SDM6\n         BO    NOTWHERE                 YES, GO DIRECT TO OUTPUT   SDM6\n         TM    FLAGS2,NOWHEREF+TERSEF   SEE IF WHERE SUPPRESSED\n         BNZ   NOTWHERE                 IF ON SUPPRESS IT\n     MVC LINE03(40),=CL40'ENTER VALID COMMAND ABOVE OR ? FOR HELP' LDW1\n         MVC   LINE03+72-L'VERSION(L'VERSION),VERSION              LDW1\n         MVC   LINE03+61(7),ZAP+10      PUT IN THE ASM DATE        LDW1\nWHEREAMI CLI   LINELEN+1,80             LONG LINES?                LDW1\n         BE    WHERE80                  YES, FORMAT MORE INFO      LDW1\n         MVC  LINE21+17(34),=C'TTR: XXXXXX CCHHR: XXXXXXXXXX LEN:' LDW1\n         HEX   LINE21+36,CCHHR,LEN=5                               LDW1\n         HEX   LINE21+22,TTR,LEN=3                                 LDW1\n         MVC   LINE20+17(4),=C'DSN:'    MOVE IN MASK               LDW1\n         MVC   LINE20+22(24),DISPDSN    SHOW THE DSNAME            LDW1\n         MVC   LINE20+47(4),=C'OFF:'    MOVE IN MASK               LDW1\n         HEX   LINE20+53,OLDPOINT,LEN=2 OFFSET                     LDW1\n         MVC   LINE21+52(5),EDMASK+3    GET READY TO EDIT IN BLKLN LDW1\n         LH    R1,BLKLEN                GET THE LENGTH READ        LDW1\n         CVD   R1,TEMP                  CONV TO DECIMAL            LDW1\n         ED    LINE21+51(6),TEMP+5      EDIT IT TO SCREEN          LDW1\n         B     NOTWHERE                 CONTINUE                   LDW1\nWHERE80  MVC   LINE20+00(4),=C'OFF:'                               LDW1\n         LH    R15,OLDPOINT             GET OFFSET IN BUFFER       LDW1\n         BAS   R14,NUMCONV              CONVERT IT                 LDW1\n         MVC   LINE20+05(4),TEMP2+12+4  MOVE IN HEX PART           LDW1\n         MVI   LINE20+10,C'('                                      LDW1\n         MVC   LINE20+11(6),TEMP2+6     DECIMAL PART               LDW1\n         MVC   LINE20+17(7),=C') ADDR:'                            LDW1\n         L     R15,OFFSET               GET IT                     LDW1\n         BAS   R14,NUMCONV              CONVERT                    LDW1\n         MVC   LINE20+25(5),TEMP2+12+3  HEX PART                   LDW1\n         MVI   LINE20+31,C'('                                      LDW1\n         MVC   LINE20+32(8),TEMP2+4     DECIMAL PART               LDW1\n         MVC   LINE20+40(6),=C') DSN:'                             LDW1\n         MVC   LINE20+47($L-47),DISPDSN DSN                        LDW1\n         MVC   LINE21+00(4),=C'LEN:'                               LDW1\n         LH    R15,BLKLEN               GET LENGTH OF BLOCK        LDW1\n         BAS   R14,NUMCONV              CONVERT                    LDW1\n         MVC   LINE21+05(4),TEMP2+12+4  HEX PART                   LDW1\n         MVI   LINE21+10,C'('                                      LDW1\n         MVC   LINE21+11(6),TEMP2+6     DECIMAL PART               LDW1\n         MVC   LINE21+17(7),=C') BASE:'                            LDW1\n         L     R15,BASEVAL              BASE                       LDW1\n         BAS   R14,NUMCONV              CONVERT                    LDW1\n         MVC   LINE21+25(5),TEMP2+12+3  HEX PART                   LDW1\n         MVI   LINE21+31,C'('                                      LDW1\n         MVC   LINE21+32(8),TEMP2+4     DECIMAL PART               LDW1\n         MVC   LINE21+40(8),=C') CCHHR:'                           LDW1\n         UNPK  LINE21+49(10+1),CCHHR(5+1)                          LDW1\n         TR    LINE21+49(10),TRHEX      MAKE IT EBCDIC             LDW1\n         MVC   LINE21+59(5),=C' TTR:'                              LDW1\n         HEX   LINE21+66,TTR,LEN=3                                 LDW1\nNOTWHERE NI    FLAGS2,255-NOWHEREF      ENABLE WHERE LINE          LDW1\n         BAS   R8,CSIO                  DISPLAY SCREEN JUST MADE   SDM6\n         EJECT\n*        ZAP --- COMMAND CHECKING AND EXECUTION.\n*        FIND REPLY LENGTH AND COPY IT TO TEMP2.\n         SPACE 1\nCOMSCAN  MVC   ICREP,REP                HANDLE A COPY              -EU-\n         OC    REP,BLANKS               MAKE IT UPPER CASE         LDW1\n         LH    R1,READLEN               GET READ LENGTH            SDM6\n         LA    R1,REP(R1)               POINT TO LAST CHAR + 1     SDM6\nCOMGET   BCTR  R1,0                     DECREMENT POINTER          SDM6\n         CLI   0(R1),C' '               END OF STRING?             SDM6\n         BE    COMGET                   NO, GO TEST ANOTHER CHAR   SDM6\n         LA    R0,REP-1                 GET LENGTH...              SDM6\n         SR    R1,R0                    ... OF DATA                SDM6\n         BNP   NEWDSPNT                 ZERO, IGNORE WITH NO TRACE SDM6\n         STH   R1,REALRDLN              PHONY UP THE ACTUAL READ LEN\n         MVC   TEMP2(40),REP            COPY START OF COMMAND      LDW1\n         SPACE 1\n*        (SOME ROUTINES MODIFY THE COMMAND IN TEMP2).              LDW1\n*        SEE IF THE COMMAND IS IN THE COMMAND TABLE.\n         SPACE 1\n         LR    R0,R1                    GET THE TRUE READ LENGTH   LDW1\n         XR    R1,R1                    CLEAR REG FOR IC'S\n         L     R2,=A(COMTAB)            PT TO COMMAND TABLE        LDW1\n         BAS   R14,*+L'*+4              SET LOOP ADDR & SKIP       LDW1\n         LA    R2,12(,R2)               -> NEXT TABLE ENTRY        LDW1\n         CLI   0(R2),X'FF'              END OF TABLE\n         BE    EXPR                     YES, NOT IN TAB, AN EXPRESS?\n         IC    R1,0(,R2)                NO, PICK UP LEN OF COMMAND\n         EX    R1,COMCLC                COMMAND MATCH?\n         BNER  R14                      NO, CHECK NEXT             LDW1\n         L     R2,8(,R2)                PICK UP ROUTINE ADDR\n         BCTR  R0,0                     COMPUTE LENGTH OF ...      LDW1\n         SR    R0,R1                    ... REMAINING INPUT        LDW1\n         LA    R1,TEMP2+1(R1)           -> START OF OPERANDS       LDW1\n         BR    R2                       GO DO IT\n         SPACE 1\n*        NOTE : CC IS SET FOR OPERAND LENGTH = 0 OR \u00ac=0.           LDW1\n         SPACE 1\nCOMCLC   CLC   REP(0),1(R2)             << EXECUTED >>             LDW1\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- EXPRESSION.\n*        *****  NO COMMAND (EXPRESSION)  *****\n         SPACE 1\nEXPR     LA    R1,REP                   GET EXPRESSION PTR         LDW1\n         LH    R0,REALRDLN              GET EXPRESSION LEN\nPARSE    L     R15,OFFSET               GET '*' (CURRENT VALUE)    LDW1\n         MVI   EXPOPT,YESSYMB           SAY 'LOOK AT THE SYMBOL TABLE'\n         BAS   R8,CALLEXP               GO PARSE                   LDW1\n         S     R15,BASEVAL              GET OFFSET IN BUFFER       LDW1\n         BNM   SETPOINT                 IT'S NON-NEG, SO WE'RE OK  LDW1\nSETPNT00 XR    R15,R15                  CAN'T HAVE NEGATIVE\n         CLC   ADDRBUFF,ADDRCNT         DISPLAYING COUNT FIELD?    LDW1\n         BNE   SETPOINT                 NO, OK                     LDW1\n         LA    R15,8                    YES, PUT CARET AT KEY      LDW1\nSETPOINT LH    R2,BLKLEN                GET BLKLENGTH              LDW1\n         BCTR  R2,0                     -1 FOR COMPARE\n         CR    R15,R2                   ARE WE STILL WITHIN THE BLK?\n         BNH   *+L'*+2                  YES, WE'RE OK\n         LR    R15,R2                   NO, MAKE IT THE END OF BLK\n         STH   R15,OLDPOINT             SAVE OFFSET FOR CURR LOC\n         A     R15,BASEVAL              RELOCATE IT                LDW1\n         ST    R15,OFFSET               SAVE ADDR                  LDW1\n         B     NEW$DISP                 GO DO IT\nINVEXPER LA    R2,INVEXP                YES, SAY INVALID SYNTAX\n         SPACE 1\n*        NOTE : R1 WILL PT TO THE COLUMN OF THE ERROR.\n         SPACE 1\n         B     BOTCH                    AND GO TELL HIM WITH NO TRACE\n         SPACE 2                        SPLIT HERE\n*        ZAP --- COMMAND EXECUTION --- HELP, ?.\n*        HELP (?, ?1, ?2, ?3, ?4, ?5, ?6, ?7, HELP, H, H1,...,H7)  LDW1\n         SPACE 1\nPFKHELP  MVC   LINE19,BLANKS            CLEAR THE ERROR MSG IF ANY -EU-\nHELPHELP TM    FLAGS3,F3270             FULLSCREEN?                LDW5\n         BZ    HELPALL                  NO, DO IT OLD WAY          LDW3\n         XR    R3,R3                    HE WANTS HELP #1 (\"HELP\")  LDW2\n         B     HELPOK                   AND PROCESS                LDW1\nHELP     BNP   HELPHELP                 JUST \"?\" - GIVE HIM \"?1\"   LDW1\n         TM    FLAGS3,F3270             FULLSCREEN?                LDW5\n         BZ    HELPALL                  NO, DO IT OLD WAY          LDW3\n         XR    R15,R15                  * = 0                      LDW1\n         BAS   R8,CALLEXP               PARSE OPERAND              LDW1\n         LTR   R3,R15                   GET THE ANSWER             LDW2\n         BNP   INVEXPER                 NO GOOD                    LDW1\n         BCTR  R3,0                     -1 FOR OFFSET              LDW2\n         CH    R3,=H'15'                GREATER THAN 9?            LDW2\n         BL    HELPOK                   NO, SKIP                   LDW1\n         SH    R3,=H'6'                 EXP THOUGHT IT WAS HEX     LDW1\nHELPOK   LA    R2,1+C'1'(,R3)           GET NEXT PROMPT            LDW1\n         BAS   R8,CLEAR                 CLEAR THE SCREEN FIRST     LDW1\n         CH    R3,=Y(13-1)              TOO BIG?                   LDW1\n         BH    INVEXPER                 YES, BYE BYE               LDW1\n         BL    *+L'*+4                  NO, USE IT, WE HAVE PROMPT LDW1\n         LA    R2,C'1'                  AT END, WRAP TO BEGIN      LDW1\n         LR    R1,R3                    COPY # TO BETTER REG       LDW1\n         OI    REP-1,X'01'              SET THE MDT FLAG           SDM4\n         MVC   REP,BLANKS               BLANK THE PROMPT           SDM4\n         MVI   REP,C'?'                 SET UP PROMPT              LDW1\n         STC   R2,REP+1                 DO IT                      LDW1\n         CLI   REP+1,X'FA'              TOO BIG?                   LDW1\n         BL    *+L'*+12 >==========+    NO, OK                     LDW1\n         MVI   REP+1,C'1'          |    SET FIRST DIGIT            LDW1\n         SH    R2,=H'10'           |    FIX OTHER DIGIT            LDW1\n         STC   R2,REP+2            |    SET IT                     LDW1\n         L     R2,=V(ZAPHELP)  <===+    POINT TO STUFF             LDW1\n         MH    R1,=H'520'               * LENGTH OF EACH           LDW1\n         A     R1,4(,R2)                POINT TO IMAGE             LDW1\n         LA    R2,LINE06                FIRST SCREEN LINE FOR HELP LDW1\n         LA    R14,$I                   BXLE INCR                  LDW1\n         LA    R15,LINE18+20            LAST SCREEN LINE FOR HELP  LDW1\n         LA    R0,40                    INCR FOR HELP              LDW1\n         CLI   LINELEN+1,80             LONG LINES?                LDW1\n         BNE   *+L'*+4                  NO, SKIP                   LDW1\n         LA    R2,LINE06+17             YES, CENTER IT             LDW1\n         MVC   0(40,R2),0(R1)           MOVE 1 LINE                LDW1\n         AR    R1,R0                    INCR SOURCE PTR            LDW1\n         BXLE  R2,R14,*-8               MOVE 520 BYTES             LDW1\n         B     DISPLYNT                 GIVE HIM SCR (NOTRACE)     LDW1\n         SPACE 1\n*        *****  HELP (NON FULLSCREEN TERMINALS)  *****\n         SPACE 1\nHELPALL  OI    FLAGS3,NODISPF           DON'T REDISPLAY AT END     SDM5\n         L     R2,=V(ZAPHELP)           POINT TO HELP              SDM6\n         L     R3,0(,R2)                GET NUMBER OF LINES TO TPUT\n         LA    R8,8(,R2)                -> INDICATOR BYTES         LDW1\n         L     R2,4(,R2)                -> FIRST LINE              LDW1\nHELPLOOP CLI   0(R8),0                  DUMP THIS LINE?            LDW1\n         BE    HELPSKIP                 NO, SKIP IT                LDW1\n         MVC   LINEBUFF(40),0(R2)       MOVE TO TEMP BUFFER        LDW1\n         BAS   R14,PUTLINE$             PRINT IT                   LDW1\n         TM    FLAGS2,ATTNHIT           SEE IF USER INTERRUPTED IT LDW5\n         BO    HELPINT                  I DON'T BLAME HIM\nHELPSKIP LA    R2,40(,R2)               POINT TO NEXT LINE         LDW1\n         LA    R8,1(,R8)                NEXT INDICATOR BYTE        LDW1\n         BCT   R3,HELPLOOP              GIVE HIM NEXT LINE\n         B     DISPLYNT                 GO BACK TO USER            SDM6\nHELPINT  NI    FLAGS2,255-ATTNHIT       TURN OFF INTERRUPT         LDW5\n         B     DISPLYNT                 GO BACK TO USER            SDM6\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- LOG, CRT, TERSE, VERBOSE, DISP.\n*        ***** LOG\n         SPACE 1\nLOG      BAS   R8,LOGTEST               OPEN THE DS IF NOT OPEN    LDW1\n         LA    R2,LOGONMSG              POINT TO MSG               LDW1\n         B     BOTCH                    DISPLAY MSG                LDW1\n         SPACE 1\n*        ***** CRT\n         SPACE 1\nCRT      OI    FLAGS3,CRTF              SET FLAG                   LDW5\n         MVC   WIDTHS(8),=XL8'0000000400000004' SET WIDTH\n         NI    FLAGS2,255-TERSEF        SET VERBOSE MODE\n         OI    FLAGS3,NODISPF           DON'T REDISPLAY            SDM6\n         B     DISPLYNT                 GO BACK TO USER, NO TRACE  SDM6\n         SPACE 1\n*        ***** TERSE/VERBOSE\n         SPACE 1\nTERSE    OI    FLAGS2,TERSEF            SUPPRESS WHERE\n         OI    FLAGS3,NODISPF           DON'T REDISPLAY            SDM6\n         B     DISPLYNT                 GO BACK TO USER, NO TRACE  SDM6\nVERBOSE  NI    FLAGS2,255-TERSEF        ALLOW WHERE\n         OI    FLAGS3,NODISPF           DON'T REDISPLAY            SDM6\n         B     DISPLYNT                 GO BACK TO USER, NO TRACE  SDM6\n         SPACE 1\n*        *****  DISP\n         SPACE 1\nDISPC    MVC   ADDRBUFF,ADDRCNT         -> COUNT                   LDW1\n         LH    R14,CCW#W#W+6            GET KL+DL                  LDW1\n         LA    R14,8(,R14)              INCLUDE LEN OF COUNT       LDW1\n         STH   R14,BLKLEN               SET DISPLAY BLOCK LENGTH   LDW1\n         LA    R15,8                    DISPLAY OFFSET             LDW1\n         B     SETPOINT                 RE-DISPLAY NEAR TOP        LDW1\nDISPK    MVC   ADDRBUFF,ADDRKEY         -> KEY                     LDW1\n         MVC   BLKLEN,CCW#W#W+6         SET DISPLAY BLOCK LENGTH   LDW1\n         B     SETPNT00                 RE-DISPLAY AT TOP          LDW1\nDISPD    MVC   ADDRBUFF,ADDRDATA        -> DATA                    LDW1\n         LH    R14,CCW#W#W+6            GET KL+DL                  LDW1\n         SH    R14,KEYLEN               DON'T DISPLAY KEY          LDW1\n         STH   R14,BLKLEN               SET DISPLAY BLOCK LENGTH   LDW1\n         B     SETPNT00                 RE-DISPLAY AT TOP          LDW1\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- END.                        LDW3\n*        *****  END  *****\n         SPACE 1\nENDPFK   MVC   REP,BLANKS\n         MVC   REP(3),=C'END'\nEND      BAS   R8,CHKPT                 CHECK TO SEE IF ZAP REQ\n         BAS   R8,KILL3270              TURN OFF 3270 MODE         LDW3\n         BAS   R8,CLOSE                 CLOSE THE FILE IF ANY\n         TM    GODFLAG,GODALL           ALLOCATED?                 -EU-\n         BZ    ENDALL                   NO                         -EU-\n         CLI   DSNAME,X'04'             WAS DSN CHANGED TO VTOC?   -EU-\n         BE    SKPCHK                   YES, SKIP CHECK            -EU-\n         L     R1,TDDNMSV               NO, CHECK TO PREVENT THE   -EU-\nSCNCHK   CLC   0(L'TIOEDDNM,R1),=D'0'   DE-ALLOC. OF PRE-ALLOC. DS -EU-\n         BE    SKPCHK                                              -EU-\n         CLC   0(L'TIOEDDNM,R1),DDNALL                             -EU-\n         BNE   *+L'*+8                                             -EU-\n         NI    GODFLAG,255-GODALL       RESET                      -EU-\n         B     ENDALL                                              -EU-\n         LA    R1,L'TIOEDDNM(R1)                                   -EU-\n         B     SCNCHK                                              -EU-\nSKPCHK   FREE  DDNAME=DDNALL            FREE IT                    -EU-\n         NI    GODFLAG,255-GODALL       RESET                      -EU-\n         CLI   DSNAME,X'04'             WAS DSN CHANGED TO VTOC?   -EU-\n         BNE   ENDALL                   NO, SKIP                   -EU-\n         CLI   ALLOCDSN,C' '            YES, ALLOCDSN GIVEN?       -EU-\n         BE    ENDALL                   NO, SKIP                   -EU-\n         SPACE 1                                                   -EU-\n*        THE ONLY WAY TO DEQUEUE THE \"ALLOCDSN\" NAME               -EU-\n*        IS TO RE-ALLOCATE IT, AND THEN FREE IT.                   -EU-\n         SPACE 1                                                   -EU-\n         ALLOC DSN=ALLDSNL,VOL=VOLSER,DISP=(SHR,KEEP,KEEP),        -EU-X\n               PERM=NO,PASSWD=PASSWORD                             -EU-\n         BXH   R15,R15,ENDALL           SKIP IF ANYTHING WRONG     -EU-\n         MVC   DDNALL(8),DA08DDN-DAPB08+DAPBAREA  GET DDNAME       -EU-\n         FREE  DDNAME=DDNALL            FREE IT                    -EU-\nENDALL   ICM   R1,B'1111',TDDNMSV       DD-NAMES AREA ADDRESS      -EU-\n         BZ    SKPFREE                                             -EU-\n         L     R0,=A(256*L'TIOEDDNM)    DD-NAMES AREA LENGTH       -EU-\n         FREEMAIN R,LV=(0),A=(1)                                   -EU-\nSKPFREE  TM    GODFLAG,GODAUTH          WAS AUTHORIZED?            -EU-\n         BZ    ENDXIT                   NO                         -EU-\n         RESAUTH                                                   -EU-\n         NI    GODFLAG,255-GODAUTH      RESET                      -EU-\nENDXIT   TM    FLAGS2,LOGF              SEE IF LOGGING\n         BNO   EXITOUT                  IF NOT NO CLOSE\n         L     R1,CSOUTWK               GET WORKAREA\n         LTR   R1,R1                    IF ANY\n         BZ    EXITOUT                  NONE, CAN'T BE OPEN THEN\n         CLI   ENQIT,0                  WAS ANYTHING IMPORTANT SAID?\n         BNE   EXITENQ                  YES, DO IT\nEXITSCR  TPUTX 'ZAP LOG DELETED'                                   MAS3\n         L     R1,CSOUTWK               @ CSOUT WORK AREA          MAS3\n*LDW1    CSOUT SCR,MF=(E,(1)),CALL=CALL DELETE FILE\n         MVI   0(R1),X'02'          (+) INDICATE SCRATCH\n         LR    R2,R1                (+) COPY WORKAREA PTR\n         L     R15,=V(CSOUT)        (+) POINT TO ROUTINE\n         LR    R1,CSREG             (+) GET CSAREA PTR\n         BASR  R14,R15              (+) CALL IT\n         B     EXITOUT                  THEN LEAVE\nEXITENQ  LA    R1,N5                    POINT TO DIGIT\n         BAS   R8,SETLINE               SET UP A LINE\n         B     EXITOUT                  NOT PRINTING?\n         MVC   20(33,R2),=C'FILE CLOSED - PROCESSING COMPLETE'\n         MVI   0(R2),C'-'               TRIPLE SPACE IT\n         BAS   R8,CPUT                  DUMP IT\n         TPUTX 'ZAP LOG REQUIRED? (YES,NO)',ASIS                   MAS3\n         LM    R0,R1,REGS3270     SCREENL, @ SCREEN                MAS3\n         LA    R1,0(,R1)          CLEAR TPUT FULSCR FLAG           MAS3\n         O     R1,=X'80000000'    MAKE IT TGET                     MAS3\n         TPUT  (1),(0),R          GET USER RESPONSE                MAS3\n         LTR   R15,R15            CHECK RC FROM TGET               MAS3\n         BNZ   EXITENQ1           GO ENQ IF ERROR ON INPUT         MAS3\n         CH    R1,=H'2'           EXACTLY 2 CHARS OF INPUT?        MAS3\n         BNE   EXITENQ1           BIF NOT 2 CHARS OF INPUT         MAS3\n         OC    SCREEN(2),BLANKS   MAP TO UPPER CASE                MAS3\n         CLC   SCREEN(2),=CL2'NO' EXACTLY 'NO'?                    MAS3\n         BE    EXITSCR                                             MAS3\nEXITENQ1 L     R1,CSOUTWK               RELOAD WORKAREA PTR\n*LDW1    LA    R14,HISBIN\n*LDW1    CSOUT ENQ,(14),=H'1',CALL=CALL,MF=(E,(1))\n         MVI   0(R1),X'40'          (+) FLAG AS ENQUEUE CALL\n*LDW1    ST    R14,4(,R1)           (+) STORE FIRST PARM\n*LDW1    LA    R0,=H'1'             (+)\n*LDW1    ST    R0,8(,R1)            (+) STORE SECOND PARM\n         LR    R2,R1                (+) COPY WORKAREA PTR\n         L     R15,=V(CSOUT)        (+) POINT TO ROUTINE\n         LR    R1,CSREG             (+) GET CSAREA PTR\n         BASR  R14,R15              (+) CALL IT\nEXITOUT  ICM   R1,B'1111',ADDRWORK      \"LCSOUT\" WORK-AREA?        -EU-\n         BZ    XQUIT                    NONE                       -EU-\n         L     R0,SIZEWORK              GET HIS SIZE               -EU-\n        FREEMAIN R,LV=(0),A=(1)         FREE IT                    -EU-\nXQUIT    L     R13,4(,R13)              RESTORE THE REG STUPID     -EU-\n         LM    R14,R12,12(R13)          RESTORE\n         XR    R15,R15                  RC=0\n         BR    R14                      BYE BYE\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- EBCDIC, ASCII, ZCODE,\n*                                      //DEBUG' LW\n*        *****  EBCDIC  *****\n         SPACE 1\nEBCDIC   L     R1,=A(TRCHARE)           PICK UP PTR TO EBCDIC TRTAB-EU-\n         LA    R2,EBCDCMSG              TELL HIM WHAT JUST HAPPENED\n         XR    R15,R15                                             -EU-\nEBCDIC#  ST    R1,TRTABADD              SAVE FOR LATER DISPLAYS\n         ST    R15,TRTXTAB                                         -EU-\n         OI    FLAGS2,NOWHEREF          SUPRESS WHERE\n         B     BOTCH                    GO DO IT AND DISPLAY\n         SPACE 1                                                   LDW1\n*        *****  ASCII  *****\n         SPACE 1\nASCII    L     R1,=A(IECTRASA)          PICK UP PTR TO ASCII TRTAB -EU-\n         LA    R2,ASCIIMSG              TELL HIM WHAT JUST HAPPENED\n         L     R15,=A(IECTSASA)                                    -EU-\n         B     EBCDIC#                  GO FINISH THE JOB\n         SPACE 1                                                   LDW1\n*        *****  ZCODE  *****\n         SPACE 1\nZCODE    L     R1,=A(TRCHARZ)           PICK UP PTR TO ZCODE TRTAB -EU-\n         LA    R2,ZCODEMSG              SAY WHAT TYPE OF TRANS\n         L     R15,=A(TRCHRZ)                                      -EU-\n         B     EBCDIC#                  AND DO IT FROM NOW ON\n         SPACE 1\n*        *****  //DEBUG  *****\n         SPACE 1\nDIEFAST  BAS   R8,KILL3270              TURN OFF 3270 MODE         LDW1\n         DC    X'00C1'                  \"HALT...\"                  LDW1\n         LA    R2,OUCH                  PT TO MSG                  LDW1\n         B     BOTCH                    RESUME IF \"GO\" FROM TEST   LDW1\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- #, LAST, LASTDS1.           LDW1\n*        *****  # (CALC)  *****\n         SPACE 1\nCALC     L     R15,OFFSET               GET '*' = CURRENT OFFSET   LDW1\n         MVI   EXPOPT,YESSYMB           TELL HIM SCAN SYMB TAB\n         BAS   R8,CALLEXP               PARSE & CHECK              LDW1\n         MVC   LINE19+17(20),=CL20'CALCULATE VALUE:'    MOVE IN MASK\n         BAS   R14,NUMCONV              CONVERT                    LDW1\n         MVC   LINE19+34(12),TEMP2      DECIMAL PART               LDW1\n         MVC   LINE19+48(8),TEMP2+12    HEX PART                   LDW1\n         B     NEWDSPNT                 GIVE IT TO HIM\n         SPACE 1\n*        *****  LAST  *****\n         SPACE 1\nLAST     BAS   R8,CHKPT                 CHECK TO SEE IF ZAP REQ\n         CLI   DSNAME,X'04'             IS THERE A LAST TTR (NOT VTOC)?\n         LA    R2,LASTINV               PT TO MESSAGE IN CASE\n         BE    BOTCH                    NO, TELL HIM               LDW1\n         MVC   TTR(3),ENDTTR            PICK UP LAST TTR           LDW4\n         B     NEW$READ                 GO GIVE IT TO HIM\n         SPACE 1\n*        *****  LASTDS1  *****                                     LDW1\n         SPACE 1\nLASTDS1  BAS   R8,CHKPT                 CHECK TO SEE IF ZAP REQ    LDW1\n         CLI   DSNAME,X'04'             IS THIS THE VTOC?          LDW1\n         LA    R2,NOTVTOC               PT TO MESSAGE IN CASE      LDW1\n         BNE   BOTCH                    NO, TELL HIM               LDW1\n         XC    DBLW,DBLW                CLEAR AREA FOR 'ABS'       LDW1\n         SPACE 1\n*        ASSUME VTOC IS 1 EXTENT ==> M=0.                          LDW1\n         SPACE 1\n         MVC   DBLW+3(5),LASTFMT1       SET CCHHR OF LAST FMT1     LDW1\n         B     ABSGOT1                  GO FAKE AN 'ABS' COMMAND   LDW1\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- D, U.                       LDW1\n*        *****  D  *****\n         SPACE 1\nPFKDOWN  MVC   REP,BLANKS                                       .AFDSC.\n         MVI   REP,C'D'                                         .AFDSC.\n         MVC   LINE19,BLANKS            CLEAR THE ERROR MSG IF ANY -EU-\n         XR    R0,R0                                            .AFDSC.\nDISPLAY# BNZ   PARSE                    MORE THAN A 'D'            LDW1\n         BAS   R8,DU$COM                GET # OF BYTES             LDW1\n         AR    R15,R14                  WHERE TO POINT TO NOW (OFFSET)\n         CH    R15,BLKLEN               PAST BLK?\n         BL    SETPOINT                 NO, GO ON\n         SRL   R14,1                    TRY HALF WAY THEN\n         SR    R15,R14                  MAYBE NOW?\n         CH    R15,BLKLEN               STILL ICKY?\n         BNL   OFLOD                    YES, GIVE UP AND NEXT BLK\n         LH    R15,BLKLEN               NO, PT TO END OF BLK + 1\n         B     SETPOINT                 GO GIVE IT TO HIM\nOFLOD    BAS   R8,CHKPT                 CHECK TO SEE IF ZAP REQ\n         BAS   R8,READNBLK              GET THE NEX BLK            LDW1\n         B     SETPNT00                 GO GIVE HIM OFFSET 0       LDW1\n         SPACE 1\n*        *****  U  *****                                           LDW1\n         SPACE 1\nPFKUP    MVC   REP,BLANKS                                       .AFDSC.\n         MVI   REP,C'U'                                         .AFDSC.\n         MVC   LINE19,BLANKS            CLEAR THE ERROR MSG IF ANY -EU-\n         XR    R0,R0                                            ,AFDSC.\nUP       BAS   R8,DU$COM                GET # OF BYTES             LDW1\n         SR    R15,R14                  BACK UP                    LDW1\n         BNM   SETPOINT                 USE IT IF OK               LDW1\n         B     SETPNT00                 TOO FAR, USE 0             LDW1\nDU$COM   L     R14,WIDTHD               GET # OF LINES BELOW       LDW1\n         A     R14,WIDTHU               ADD NUMBER OF LINES ABOVE  LDW1\n         LA    R14,1(,R14)              ADD CARET LINE             LDW1\n         MH    R14,LINEHEX              GET # OF BYTES DISPLAYED   LDW1\n         LH    R15,OLDPOINT             GET CURRENT OFFSET         LDW1\n         BR    R8                       RETURN TO \"D\" OR \"U\"       LDW1\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- =, NODEF.                   LDW1\n*        *****  =  *****\n         SPACE 1\nEQUALS   BNP   INVEXPER                 ERROR IF JUST '='          LDW1\n         LR    R7,R1                    -> STRING                  LDW1\n         LR    R1,R0                    LENGTH                     LDW1\n         BAS   R8,HEXCHECK              SEE IF VALID NUMBER        LDW1\n         B     EQUALBAD                 CAN'T USE #'S FOR SYMBOLS  LDW1\n         L     R4,IDEFAVAL              GET PTR TO 1ST AVAIL TABL POS\n         CLI   0(R4),X'FF'              END OF TABLE?\n         LA    R2,TABFULL               GET MSG ADDR IN CASE       LDW1\n         BE    BOTCH                    NO ROOM...                 LDW1\n         L     R3,AIDEFTAB              PT TO BEGINNING            LDW1\n         SPACE 1\n*        SEE IF THE SYMBOL IS ALREADY DEFINED.\n         SPACE 1\nICLOOP   CR    R3,R4                    UP TO FIRST AVAIL POS YET?\n         BNL   OKIDEF                   YES, NO DUPLICATE, SO DEFINE\n         CLC   0(8,R3),REP+1            NO, SYMBOL ALREADY HERE?  LDW1\n         BE    REDEF                    YES, SO REDEFINE IT\n         LA    R3,10(,R3)               NO, PT TO NEXT SPOT IN TABLE\n         B     ICLOOP                   KEEP GOING TILL OUT\nREDEF    MVC   0(8,R3),REP+1            MOVE IN THE SYMBOL         LDW1\n         MVC   8(2,R3),OFFSET+2         MOVE IN THE OFFSET         LDW1\n         LA    R2,REDEFMSG              PT TO MSG SAYING REDEFINED SYM\n         B     BOTCH                    DONT RESET FIRST AVAIL - LEAVE\nOKIDEF   MVC   0(8,R4),REP+1            MOVE IN THE SYMBOL TO TAB  LDW1\n*LDW1    MVC   8(2,R4),OLDPOINT         MOVE IN OFFSET INTO BLK\n         MVC   8(2,R4),OFFSET+2         MOVE IN THE OFFSET         LDW1\n         LA    R4,10(,R4)               POINT TO NEXT AVAIL\n         ST    R4,IDEFAVAL              SAVE FOR NEXT TIME\n         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES\n         B     NEWDSPNT                 DISPLAY (NOTRACE)\nEQUALBAD LA    R2,BADEQUAL              PT TO MSG                  LDW1\n         B     BOTCH                    MAS CAN'T COMPLAIN ANYMORE LDW1\n         SPACE 1\n*        *****  NODEF  *****\n         SPACE 1\nNODEF    BAS   R8,CLEARDEF              YES, LET HIM HAVE IT\n         LA    R2,DEFRESET              TELL HIM WE RESET THE TABLE\n         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES\n         B     BOTCH                    GO BACK TO DISPLAY (NOTRACE)\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- IDEF.\n*        *****  IDEF  *****\n         SPACE 1\nIDEF     BAS   R8,CLEAR                 CLEAR THE SCREEN\n         MVC   LINE06(16),=C' SYMBOL   OFFSET'  MOVE MASK FOR COL 1\n         MVC   LINE06+20(3*20-4),LINE06  MAKE 3 MORE COLUMNS       LDW1\n         LA    R1,LINE08                PT TO DISPLAY              LDW1\n         CLI   LINELEN+1,80             4 COLUMNS OK?              LDW1\n         BE    *+L'*+10                 YES, LEAVE IT              LDW1\n         MVC   LINE06+40($L-40),BLANKS  NO, KILL LAST 2            LDW1\n         LA    R1,LINE07                PT TO DISPLAY              LDW1\n         L     R2,IDEFAVAL              PT PAST LAST LOC TO FMT    LDW1\n         L     R3,AIDEFTAB              PT TO TABLE                LDW1\n         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES\nIDEFNEWL LA    R4,2                     ASSUME 2 COLUMNS           LDW1\n         CLI   LINELEN+1,80             RIGHT?                     LDW1\n         BNE   IFMTLOOP                 YES, OK                    LDW1\n         AR    R4,R4                    NO, MAKE IT 4 COLUMNS      LDW1\nIFMTLOOP CR    R3,R2                    DONE WITH FORMATTABLE STUFF?\n         BNL   DISPLYNT                 YES, DISPLAY WITH NO TRACE\n         MVC   0(8,R1),0(R3)            MOVE SYMBOL TO DISPLAY\n         HEX   (11,R1),(8,R3),LEN=2     MOVE IN OFFSET             LDW1\n         LA    R1,20(,R1)               UPDATE DISPLAY PTR\n         LA    R3,10(R3)                UPDATE TABLE PTR\n         BCT   R4,IFMTLOOP              DO ANOTHER                 LDW1\n         LA    R1,$I-4*20(,R1)          INCREMENT A LITTLE MORE    LDW1\n         CLI   LINELEN+1,80             WAS THAT ENOUGH MORE?      LDW1\n         BE    IDEFNEWL                 YES, DO ANOTHER LINE       LDW1\n         LA    R1,40(,R1)               NO, FIX IT                 LDW1\n         B     IFMTLOOP                 KEEP UP THE GOOD WORK\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- ITRACE.\n*        *****  ITRACE  *****\n         SPACE 1\nITRACE   L     R2,AITRCTAB              PT TO BEGINNING OF TABLE   LDW1\n         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES\n         BAS   R8,CLEAR                 CLEAR THE SCREEN\n         MVC   LINE06+1(11),=C' TTR   OFFS'   MOVE IN TITLE FOR COL 1\n         MVC   LINE06+14(13*5-2),LINE06+1     MAKE 5 MORE COLUMNS  LDW1\n         LA    R3,LINE08                FIRST AVAIL SCREEN POSIT   LDW1\n         CLI   LINELEN+1,80             6 COLUMNS OK?              LDW1\n         BE    NEWLINE                  YES, LEAVE IT              LDW1\n         MVC   LINE06+40($L-40),BLANKS  NO, KILL LAST 2            LDW1\n         LA    R3,LINE07                FIRST AVAIL SCREEN POSIT   LDW1\nNEWLINE  LA    R4,3                     CNT FOR GOOD OFFSET DISP LOOP\n         CLI   LINELEN+1,80             NEED 6 COLUMNS?            LDW1\n         BNE   ITRFMTLP                 NO, LEAVE IT               LDW1\n         AR    R4,R4                    YES, MAKE IT 6             LDW1\nITRFMTLP CLI   0(R2),X'FF'              END OF TABLE\n         BE    DISPLYNT                 GO DISPLAY (NOTRACE & NO REBLD)\n         HEX   (1,R3),(0,R2),LEN=3      MOVE IN TTR                LDW1\n         HEX   (8,R3),(3,R2),LEN=2      MOVE IN OFFSET             LDW1\n         C     R2,CURRITR               IS THIS THE CURRENT TRACE TAB\n         BNE   *+L'*+4                  NO, GO ON WITH FORMATTING\n         MVI   0(R3),C'>'               MOVE IN THE PTR TO CURR ENTRY\n         LA    R3,13(R3)                UPDATE SCREEN PTR\n         LA    R2,5(,R2)                UPDATE TABLE PTR\n         BCT   R4,ITRFMTLP              DO IT THRICE (OR 6)\n         LA    R3,$I-6*13(,R3)          MAKE UP FOR ODDBALL SCREEN LDW1\n         CLI   LINELEN+1,80             6 COLUMNS?                 LDW1\n         BE    NEWLINE                  YES, DO NEXT LINE          LDW1\n         LA    R3,39(,R3)               MAKE UP FOR ODDBALL SCREEN\n         B     NEWLINE                  DO IT ALL OVER\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- >, <.\n*        *****  >  *****\n         SPACE 1\nFORWARD  L     R3,ITRAVAL               PICK UP PTR TO NEXT TRACE\n         MVI   TRACE,NOTRACE            DON'T TRACE > FOR PETE'S SAKE\n         CLI   0(R3),X'FF'              END OF TABLE?\n         BNE   *+L'*+4                  NO, NO PROBLEM\n         L     R3,AITRCTAB              YES, SO WRAP TO TOP        LDW1\n         CLI   0(R3),X'FE'              EXIST YET?                 LDW1\n         LA    R2,INVFMSG               GET MSG ADDR IN CASE       LDW1\n         BE    BOTCH                    NO - TELL HIM NO GOOD      LDW1\n         LA    R2,5(,R3)                PT TO NEXT ONE AFTER THAT\n         LR    R4,R2                    SAVE NEXT CURRENT ONE\n         B     CARET                    FINISH ALL THE REST\n         SPACE 1                                                   LDW1\n*        *****  <  *****\n         SPACE 1\nBACKWARD MVI   TRACE,NOTRACE            DON'T TRACE A < EITHER\n         L     R2,AITRCTAB              PT TO TRACE TABLE          LDW1\n         L     R3,ITRAVAL               PT TO NEXT CURRENT ENTRY\n         CR    R3,R2                    CURRENT ENTRY = FIRST ENTRY?\n         BNE   *+L'*+4                  NO, NO PROBLEM (YET)\n         L     R3,AITREND               YES, MUST LOOP TO TAB END  LDW1\n         SH    R3,=H'5'                 BACKTRACK ONE ENTRY\n         LR    R4,R3                    SAVE FOR LATER ITRAVAL\n         CR    R3,R2                    IS THAT THE BEGINNING NOW?\n         BNE   *+L'*+4                  NO, NO MORE WORRIES\n         L     R3,AITREND               YES, WE LOOP TO ENDTAB     LDW1\n         SH    R3,=H'5'                 BACKTRACK ONE ENTRY\n         CLI   0(R3),X'FE'              DOES THAT ENTRY EXIST?     LDW1\n         BNE   CARET                    YES, WE'RE OK\n         LA    R2,INVBMSG               NO, TELL HIM SO AND\n         B     BOTCH                    GO TELL HIM\n         SPACE 1                                                   LDW1\n*        DO THE CARET. IF LEAVING BLOCK, CHECK TO SEE OF BLK REPLACED.\n         SPACE 1\nCARET    CLC   TTR(3),0(R3)             NEW BLOCK NEEDED?\n         BE    RDNOTNEC                 NO, DON'T BOTHER WITH CHECK\n         BAS   R8,CHKPT                 YES, MAKE SURE THIS ONES OK\n         MVC   TTR(3),0(R3)             NEW BLK, GET CORRECT TTR\n         ST    R3,TEMP                  SAVE PTR TO THE ENTRY\n         BAS   R8,READBLK               READ THE BLOCK IN\n         L     R3,TEMP                  PICK UP THE PTR BACK\nRDNOTNEC ST    R4,ITRAVAL               NEW TRACE TABLE PTR\n         ST    R3,CURRITR               SAVE CURRENT TRACE TAB ENTRY\n         MVC   TEMP(2),3(R3)            NOW GET OFFSET FROM TRACE TAB\n         LH    R15,TEMP                 INTO RIGHT REG             LDW1\n         B     SETPOINT                 GO FAKE A '+' COMMAND\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- T, P, %.                    LDW1\n*        *****  T  *****\n         SPACE 1\nTRACK    BAS   R8,CHKPT                 ANY ZAP NEEDED?\n         LTR   R0,R0                    TEST OPERAND LENGTH        LDW1\n         BNZ   MORET                    NOT JUST 'T'\n         LH    R15,TTR                  JUST A T (T=T+1)\n         LA    R15,1(R15)               POINT TO NEXT TRACK\n         B     POSTRACK                 GO DO IT\nMORET    LH    R15,TTR                  PICK UP '*' TRACK\n         BAS   R8,CALLEXP               PARSE & CHECK              LDW1\n         BM    TTRLT1                   NEGATIVE IS BAD            LDW1\nPOSTRACK STH   R15,TTR                  SAVE TRACK #\n         MVI   TTR+2,X'01'              GIVE HIM REC=01\n         B     NEW$READ                 READ AND DISPLAY\n         SPACE 1                                                   LDW1\n*        *****  P  *****\n         SPACE 1\nPOINT    BAS   R8,CHKPT                 ANY ZAP NEEDED?\n         LTR   R0,R0                    TEST OPERAND LENGTH        LDW1\n         BNZ   MOREP                    MORE THAN P - GET TTR\n         MVC   TTR(4),=XL4'00000100'    JUST 'P',GIVE HIM TTRN=00000100\n         B     NEW$READ                 DO IT\nMOREP    BAS   R6,TTRPARSE              GET THE TTR SPECIFIED      LDW1\n         MVC   TTR(3),TEMP+1            MOVE IN TTR\n         B     NEW$READ                 GO GET IT\n         SPACE 1\n*        *****  J  *****                                           MAS2\n*        (TTR FROM BEGINING OF VOLUME - FOR JES HASPACE)           MAS2\n         SPACE 1                                                   MAS2\nPOINT$J  BAS   R8,CHKPT                 ANY ZAP NEEDED?            MAS2\n         LTR   R0,R0                    TEST OPERAND LENGTH        MAS2\n         BNZ   POINT$J2                 MORE THAN P, GET TTR       MAS2\n         MVC   TTR(4),=XL4'00000100'    JUST 'P',GIVE HIM TTRN=00000100\n         B     NEW$READ                 DO IT                      MAS2\nPOINT$J2 BAS   R6,TTRPARSE              GET THE TTR SPECIFIED      MAS2\n         MVC   TTR(3),TEMP+1            MOVE IN TTR                MAS2\nPOINT$J3 L     R14,DCBU+12              @ DEVICE CHAR TABLE ENTRY  MAS2\n         L     R15,DCBU+44              @ DEB                      MAS2\n         LH    R0,32+6(,R15)            1ST EXTENT CYL BEGIN       MAS2\n         MH    R0,2(,R14)               * # OF TRKS/CYL            MAS2\n         AH    R0,32+8(,R15)            + 1ST EXTENT TRK BEGIN     MAS2\n         LH    R1,TTR                   GET TRACK SPECIFIED        MAS2\n         SR    R1,R0                      ON VOLUME                MAS2\n         STH   R1,TTR                       (FOR JES/VTOC TTRS)    MAS2\n         B     NEW$READ                 GO GET IT                  MAS2\n         SPACE 1\n*        *****  %  *****                                           LDW1\n         SPACE 1\nINDPOINT LH    R15,OLDPOINT             GET BUFFER OFFSET          LDW1\n         MVI   EXPOPT,YESSYMB           WANT SYM TAB LOOKUP        LDW1\n         BAS   R8,CALLEXP               EVALUATE OPERAND           LDW1\n         BM    INVEXPER                 NEG IS INVALID             LDW1\n         LH    R0,BLKLEN                GET BLOCK LENGTH           LDW1\n         SH    R0,=H'3'                 LAST POSSIBLE TTR          LDW1\n         CR    R15,R0                   PAST END?                  LDW1\n         BH    INVEXPER                 YES, ERROR                 LDW1\n         A     R15,ADDRBUFF             GET ADDR IN BUFFER         LDW1\n         BAS   R8,CHKPT                 CAN HE LEAVE?              LDW1\n         MVC   TTR(3),0(R15)            SET NEW TTR                LDW1\n         B     NEW$READ                 GO READ IT & DISPLAY       LDW1\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- ABS.\n*        *****  ABS *****\n         SPACE 1\nABS      BAS   R8,CHKPT                 SEE IF HE CAN LEAVE\n         LTR   R15,R0                   TEST OPERAND LENGTH        LDW1\n         BNP   INVEXPER                 IT'S BAD                   LDW1\n         CH    R15,=H'10'               CCHHR TOO LONG?\n         BNH   *+L'*+4                  NO, OK\n         LH    R15,=H'10'               YES, TRUNCATE\n         EX    R15,ABSTR                TRANSLATE TO \"HEX\", NO EX LEN\n         EX    R15,ABSPACK              GET 000CCHHR        NO EX LEN\n         SPACE 1\n*        FIND 'M'.\n         SPACE 1\n         L     R15,DCBDEBAD-IHADCB+DCBU GET DEB\n         XR    R1,R1                    START WITH M=0\n         XR    R0,R0                    FOR IC\n         IC    R0,DEBNMEXT-DEBBASIC(,R15)    GET NUMBER OF EXTENTS -EU-\nABSLOOP  CLC   DBLW+3(4),(DEBBASND-DEBBASIC)+(DEBSTRCC-DEBDASD)(R15)\n         BL    ABSNEXT                  NOT IN THIS EXTENT\n         CLC   DBLW+3(4),(DEBBASND-DEBBASIC)+(DEBENDCC-DEBDASD)(R15)\n         BNH   ABSGOT                   NOT IN THIS EXTENT\nABSNEXT  LA    R15,16(,R15)             NEXT EXTENT\n         LA    R1,1(,R1)                NEXT 'M'\n         BCT   R0,ABSLOOP               NEXT EXTENT\n         BAS   R8,CLEAR                 CLEAR THE SCREEN FIRST     LDW1\n         MVC   TTR(3),=X'FFFFFFFFFF'    SET UP A BAD TTR           LDW1\n         MVC   CCHHR(5),=X'FFFFFFFFFF'  HERE TOO                   LDW1\n         MVI   IOERROR,YESSYN           SAY \"IOERROR\"              LDW1\n         XC    BLKLEN,BLKLEN            NOTHING TO DISPLAY         LDW1\n         MVC   LINE05+17(40),IOERRMSG   MOVE IN MASK               LDW1\n         MVC   LINE05+35(15),=CL15'NOT IN DATA-SET'                LDW1\n         B     DISPLYNT                 GO SAY BOTCHED             LDW1\nABSGOT   STC   R1,DBLW                  SET 'M'\nABSGOT1  STM   R9,R12,56(R13)           SAVE REGS CONVERT KILLS\n         L     R1,DCBDEBAD-IHADCB+DCBU  GET DEB AGAIN\n         LA    R2,DBLW                  GET 'MBBCCHHR'\n         LR    R3,R13                   SAVE R13 TOO\n         L     R15,CVTPTR               CVT\n         L     R15,CVTPRLTV-CVT(,R15)   GET ABS=>REL CONVERT\n         BASR  R14,R15                  GO GET TTRZ\n         LR    R13,R3                   RESTORE R13\n         LM    R9,R12,56(R13)           RESTORE OTHER REGS\n         ST    R0,TTR                   SAVE TTR\n         B     NEW$READ                 GO READ/DISPLAY\nABSTR    TR    TEMP2+3(0),TRHEX         << EXECUTED >>             LDW1\nABSPACK  PACK  DBLW(9),TEMP2+3(0)       << EXECUTED >>\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- B, R.                       LDW1\n*        *****  B  *****\n         SPACE 1\nBACK     BAS   R8,CHKPT                 ANY ZAP NEEDED?\n         MVI   EOFRET,NOEOF             TREAT EOF'S AS DATA BLKS\n         XR    R15,R15                  CLEAR FOR IC               LDW1\n         IC    R15,TTR+2                GET R                      LDW1\n         SH    R15,=H'1'                BACK IT UP 1               LDW1\n         B     RBACK                    GO CHECK IT                LDW1\n         SPACE 1                                                   LDW1\n*        *****  R  *****\n         SPACE 1\nRECORD   BAS   R8,CHKPT                 ANY ZAP NEEDED?\n         CLI   DSORG,DSORGPO            ARE WE IN A PDS?\n         BNE   *+L'*+4                  NO, TELL HIM ABOUT EOF'S\n         MVI   EOFRET,NOEOF             YES, TREAT EOF'S AS DATA BLKS\n         LTR   R0,R0                    TEST OPERAND LENGTH        LDW1\n         BP    MORER                    NOT JUST 'R'\n         MVI   TTR+3,SEQREAD            GO TO NEXT RECORD\n         B     NEW$READ                 READ AND DISPLAY\nMORER    XR    R15,R15                  CLEAR FOR IC\n         IC    R15,TTR+2                GET CURRENT RECORD\n         BAS   R8,CALLEXP               PARSE & CHECK              LDW1\nRBACK    XR    R1,R1                    CLEAR FOR IC\n         IC    R1,TTR+2                 GET CURRENT RECORD\n         LR    R3,R15                   PRESERVE ABSOLUTE FOR BACK\n         SR    R3,R1                    FIND OFFSET\n         LR    R5,R15                   SAVE IT\n*        R3 IS RELATIVE OFFSET\n*        R5 IS ABSOLUTE VALUE\n         BZ    NEW$READ                 IF STILL HERE, REREAD\n         BM    RGOBACK                  IF NEGATIVE, BACK UP\n         SPACE 1\n*        OFFSET IS POSITIVE : READ FORWARD ENOUGH TIMES.\n         SPACE 1\nRGOFORW  MVI   EOFRET,YESEOF            WE WANT TO STOP AT EOF FOR +\n         BAS   R8,READNBLK              READ NEXT BLOCK            LDW1\n         CLI   IOERROR,YESSYN           WAS THERE AN I/O ERROR?\n         BE    NEWDSPNT                 YES, CUT THIS OUT\n         BCT   R3,RGOFORW               GO FORWARD\n         B     NEW$READ                 WHEN DONE, DISPLAY IT\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- R.                          LDW1\n*        OFFSET IS NEGATIVE : READ BACKWARD ENOUGH TIMES.\n         SPACE 1\nRGOBACK  LTR   R5,R5                    WAS ABSOLUTE ON THIS TRACK?\n         STC   R5,TTR+2                 ASSUME YES, SET NEW RECORD\n         BP    NEW$READ                 YES, READ IT               LDW1\n         SPACE 1\n*        BACK UP A TRACK.\n         SPACE 1\n         LH    R0,TTR                   GET TRACK NUMBER\n         BCTR  R0,0                     MINUS ONE\n         LTR   R0,R0                    BACK TO ZERO?\n         BNM   RCOUNT                   ITS GOOD, COUNT TRACK\n         MVC   TTR(4),=XL4'00000100'    BACKED UP TOO FAR\n         BAS   R8,SETMSG                MOVE MSG TO RIGHT PLACE    LDW1\n         DC    Y(TTRSMALL+1-ZAP)        'TTR < 000001 INVALID' -EU-LDW1\n         B     NEW$READ                 DISPLAY FIRST RECORD\nRCOUNT   STH   R0,TTR                   SAVE FOR COUNT\n         MVI   TTR+2,0                  IT WILL INCREMENT\n         MVC   TEMP(3),TTR              SAVE TTR\nBCKCNT   BAS   R8,READNBLK              GET A BLK                  LDW1\n         CLC   TEMP(2),TTR              STILL THIS TRACK?\n         BNE   RNEWTRK                  NO\n         CLI   IOERROR,YESSYN           I/O ERROR?\n         BE    NEWDSPNT                 GET OUTA HERE\n         MVC   TEMP+2(1),TTR+2          SAVE THIS RECORD\n         B     BCKCNT                   CONTINUE DOWN TRACK\nRNEWTRK  MVC   TTR(2),TEMP              RESTORE PREVIOUS TRACK\n         XR    R1,R1                    CLEAR FOR PICKUP\n         IC    R1,TEMP+2                GET NUMBER OF RECS\n         AR    R5,R1                    WE NOW ARE THIS FAR BACK\n         B     RGOBACK                  GO SEE IF ITS ON THIS TRK\n         SPACE 2                                                   -EU-\n*        ZAP --- COMMAND EXECUTION --- CAPSON, CAPSOFF.            -EU-\n         SPACE 1                                                   -EU-\nCAPSON   MVI   CAPSFLG,YESCAPS          SET CAPS ON                -EU-\n         LA    R2,CONMSG                TELL STATUS DONE           -EU-\n         B     BOTCH                    GO BACK TO DISPLAY         -EU-\nCAPSOFF  MVI   CAPSFLG,NOCAPS           SET CAPS OFF               -EU-\n         LA    R2,COFFMSG               TELL STATUS DONE           -EU-\n         B     BOTCH                    GO BACK TO DISPLAY         -EU-\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- L, F.\n         SPACE 1\nPFKLOC   MVC   REP,BLANKS                                       .AFDSC.\n         MVI   REP,C'L'                                         .AFDSC.\n         MVC   LINE19,BLANKS            CLEAR THE ERROR MSG IF ANY -EU-\n         XR    R0,R0                                            .AFDSC.\n         STH   R0,REALRDLN              FAKE THE READ LENGTH       -EU-\n         MVI   REALRDLN+1,1                                        -EU-\n         SPACE 1\n*        *****  F  *****\n         SPACE 1\nFIND     MVI   EOFRET,NOEOF             SET SO EOF'S COME BACK     LDW1\n         SPACE 1\n*        *****  L  *****\n         SPACE 1\nLOCATE   LTR   R3,R0                    TEST OPERAND LENGTH        LDW1\n         BZ    LGO                      JUST L, GO CONTINUE        LDW1\n         LR    R4,R1                    PT TO STRING               LDW1\n         LA    R5,LOOKFOR               POINT TO STRING SAVEAREA\n         BAS   R6,GETSTRNG              GET THE HEX OR CHAR STRING\n         B     AROUND1\n         SPACE 1\n*        CONTINUE SCAN.\n         SPACE 1\nLGO      TM    CONTINUE,YESCONTL        CAN WE CONTINUE SCAN?\n         LA    R2,LINMSG                ASSUME NO, PT TO MSG\n         BNO   BOTCH                    NO, NO SCAN WAS STARTED    LDW1\n         LH    R3,LOOKFOR               YES, GET THE SCAN LEN      LDW1\n         SPACE 1\n*        SET UP SCAN.\n         SPACE 1\nAROUND1  LA    R14,LOOKFOR              GET THE STRING ADDRESS     -EU-\n         BAS   R8,STRCNV                GO APPLY CONVERSION        -EU-\n         XR    R2,R2                    CLEAR REG FOR IC (WHAT ELSE?)\n         IC    R2,WKSTR                 GET 1ST CHAR TO FIND   -EU-LDW1\n         LA    R2,TEMPTRT(R2)           PT TO OFFSET IN TRTAB\n         XC    TEMPTRT(256),TEMPTRT     CLEAR TRTAB\n         MVI   0(R2),X'FF'              MOVE IN FF THERE\n         OI    CONTINUE,YESCONTL        SAY HE CAN CONTINUE SCAN NOW\n         LH    R1,OLDPOINT              GET CURRENT OFFSET         LDW1\n         CLI   REALRDLN+1,1             JUST 'L' ENTERED?          LDW1\n         BNE   *+L'*+4                  NO, START FROM HERE        LDW1\n         LA    R1,1(,R1)                YES, START FROM NEXT BYTE  LDW1\n         B     LOOK8                    GO ON\n         SPACE 2\n*        BLOCK SCAN LOOP.\n         SPACE 1\nLOOK7    XR    R1,R1                    RESET BUFFER PTR\nLOOK8    A     R1,ADDRBUFF              PT TO OFFSET IN BUFFER\n         BCTR  R1,0                     -1\n         LH    R5,BLKLEN                GET BLK LENGTH\n         A     R5,ADDRBUFF              PT TO END OF BLK\n         SPACE 1\n*        DO THE SCAN.\n         SPACE 1\n*SDM3    TRT   1(256,R1),TEMPTRT        IS 1ST CHAR THERE?\nLOOKLOOP LR    R2,R5                    GET END                    SDM3\n         SR    R2,R1                    COMPUTE LENGTH             SDM3\n         SH    R2,=H'2'                 GET LENGTH OF REMAINDER    SDM3\n         BM    TOOFAR                   NOT ENOUGH                 SDM3\n         EX    R2,SCANTRT               FIND INTERESTING STRING    SDM3\n         BZ    LOOK1                    NOT YET, KEEP TRYING\n         CR    R1,R5                    YES, BUT IS IT PAST THE BLK?\n         BNL   TOOFAR                   YES, SO GET A NEW ONE\n         EX    R3,SCANCLC               NO, IS ALL OF IT THERE?\n         BNE   LOOKLOOP                 NO, KEEP CHECKING\n         MVC   LINE19+17(40),=CL40'        *****  SCAN MATCH  *****'\n         S     R1,ADDRBUFF              YES, GET WHERE IT IS AND...\n         LR    R15,R1                   INTO RIGHT REG             LDW1\n         B     SETPOINT                 FAKE A '+' COMMAND TO IT\nSCANTRT  TRT   1(0,R1),TEMPTRT          << EXECUTED >>             SDM3\nSCANCLC  CLC   0(0,R1),WKSTR            << EXECUTED >>         -EU-LDW1\n*SDM3    LA    R1,256(R1)               UPDATE TRT PTR TO BUFFER\nLOOK1    N     R2,=XL4'FF'              GET CLEAN SINGLE BYTE      SDM3\n         LA    R1,1(R1,R2)              SET LOCATION TO TRY AGAIN  SDM3\n         CR    R1,R5                    PAST BLK?\n         BL    LOOKLOOP                 NO, KEEP SCANNING\nTOOFAR   BAS   R8,CHKPT                 ANY ZAP NEEDED?\nTOOFAR2  BAS   R8,READNBLK              GET NEXT BLK FOR SCANNING  LDW1\n         CLI   IOERROR,YESSYN           I/O ERROR?\n         BE    NEWDSPNT                 YES, GET OUT\n         CLI   DSNAME,X'04'             VTOC?                      LDW4\n         BE    TOOFAR4                  YES, DIFFERENT CHECK       LDW4\n         CLC   TTR(3),ENDTTR            HAVE WE ARRIVED?           LDW4\n         BE    TOOFAR3                  YES, PAUSE                 LDW4\nNOT2FAR  OC    BLKLEN,BLKLEN            ANYTHING HERE? (EOF IF 'F')LDW1\n         BE    TOOFAR2                  NO, GET NEXT BLOCK         LDW1\n         B     LOOK7                    GO SCAN IT THEN\nTOOFAR3  MVC   LINE19+22(33),=C'*****  HOLDING AT DS1LSTAR  *****' LDW4\n         B     SETPNT00                 DISP OFF 0, CURR BLK       LDW4\nTOOFAR4  CLC   CCHHR(5),LASTFMT1        IS THIS THE LAST FMT1?     LDW4\n         BNE   NOT2FAR                  NO, CONTINUE SCAN          LDW4\n         MVC   LINE19+22(33),=C'*****  HOLDING AT LASTFMT1  *****' LDW4\n         B     SETPNT00                 DISP OFF 0, CURR BLK       LDW4\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- S, X, O, N.\n*        *****  N  *****\n         SPACE 1\nAND      BAS   R2,SXON                  PT TO EX INSTR, GO DO IT   LDW1\n         NC    0(0,R5),WKSTR            << EXECUTED >>      'N'-EU-LDW1\n         SPACE 1\n*        *****  O  *****\n         SPACE 1\nOR       BAS   R2,SXON                  PT TO EX INSTR, GO DO IT   LDW1\n         OC    0(0,R5),WKSTR            << EXECUTED >>      'O'-EU-LDW1\n         SPACE 1\n*        *****  X  *****\n         SPACE 1\nEXOR     BAS   R2,SXON                  PT TO EX INSTR, GO DO IT   LDW1\n         XC    0(0,R5),WKSTR            << EXECUTED >>      'X'-EU-LDW1\n         SPACE 1\n*        *****  S  *****\n         SPACE 1\nSTORE    BAS   R2,SXON                  PT TO EX INSTR, GO DO IT   LDW1\n         MVC   0(0,R5),WKSTR            << EXECUTED >>      'S'-EU-LDW1\n         SPACE 2\n*        ALLOW HIM TO USE PREVIOUS STRING IF HE JUST ENTERS\n*        THE COMMAND WITH NO SUBSEQUENT STRING OPERAND.\n         SPACE 1\nSXON     ST    R2,0(,R13)               SAVE THE EX INSTR PTR\n         LTR   R3,R0                    TEST OPERAND LENGTH        LDW1\n         BP    SXONNEW#                 HAVE AN OPERAND - USE IT   LDW1\n         SPACE 1\n*        USE AN OLD STRING FOR S,X,O,N WITH NO OPERANDS.\n         SPACE 1\n         TM    CONTINUE,YESCONTS        JUST 'S'.  OLD STRING YET?\n         BO    SXONNEW                  YES, GO ON\n         B     INVEXPER                 SAY SYNTAX ERROR COL 2     LDW1\nINVALCOM LA    R2,INVCOM                PT TO MSG                  LDW1\n         B     BOTCH                    AND TELL HIM               LDW1\n         SPACE 1\n*        USE SPECIFIED STRING.\n         SPACE 1\nSXONNEW# LR    R4,R1                    POINT TO STRING OPERAND    LDW1\n         LA    R5,ZAPSTRNG              POINT TO STRING WORK AREA\n         BAS   R6,GETSTRNG              GET AL2(LEN),C'STRING'\n         SPACE 1\n*        AT THIS POINT, ZAPSTRNG CONTAINS\n*        THE INFO NECESSARY TO STORE :\n*        AL2(STRING_LENGTH),C'STRING'\n         SPACE 1\nSXONNEW  OC    BLKLEN(2),BLKLEN         ANYTHING TO CHANGE HERE?\n         BZ    INVALCOM                 NO, TELL HIM               LDW1\n         TM    GODFLAG,GOD              CAN HE EVER UPDATE?\n         BO    LETSTORE                 YES, SO GO ON\n         BAS   R8,SETMSG                MOVE MSG TO RIGHT PLACE    LDW1\n         DC    Y(STORMSG-ZAP)           TELL HIM NOT UPDATING      LDW1\nLETSTORE LA    R14,ZAPSTRNG             GET THE STRING ADDRESS     -EU-\n         BAS   R8,STRCNV                GO APPLY CONVERSION        -EU-\n         LH    R4,ZAPSTRNG              GET LEN                -EU-LDW1\n         LH    R5,OLDPOINT              PT TO ZAPPED OFFSET\n         SPACE 2                                                   LDW1\n*        CHECK TO SEE IF STRING WILL FIT IN THE REMAINING\n*        PART OF THE BLK WHERE HE IS POINTING.\n         SPACE 1                                                   LDW1\n         LH    R6,BLKLEN                GET LENGTH OF BLK\n         SR    R6,R5                    GET LENGTH OF PIECE REMAINING\n         CR    R6,R4                    IS IT SMALLER THAN THE STRING?\n         LA    R2,LENERR                ASSUME STRING IS INVALID LENGTH\n         BNH   BOTCH                    YES, SO GO TELL HIM        LDW1\n*        STRING WILL FIT.\n         A     R5,ADDRBUFF              PT TO ACTUAL ZAPPED DATA\n         OI    CONTINUE,YESCONTS        SAY HE CAN DO 'SXON' NO OPRND\n         LA    R1,N1                    MESSAGE NUMBER\n         BAS   R8,SETLINE               SET UP THE LINE\n         B     NOMSGEX                  NOT PRINTING\n         CLI   CHNGED,0                 VIRGIN BUFFER?\n         BNE   *+L'*+4                  NO, SINGLE SPACE\n         MVI   0(R2),C'0'               ELSE, DOUBLE SPACE FIRST CHANGE\n         MVC   31(16,R2),=C'OFFSET XXXX DATA'\n******%% MVC   31(27,R2),=C'OFFSET XXXX ADDR XXXXX DATA'    SOMEDAY\n         HEX   (38,R2),OLDPOINT,LEN=2   CONVERT OFFSET TO THE LINE LDW1\n         LA    R1,48(R2)                POINT TO SPOT\n         BAS   R8,SETSTRNG              CONVERT STRING TO LINE AS WAS\n         MVC   104(5,R2),=C'CCHHR'      MOVE IN IDENTIFIER         LDW1\n         HEX   (110,R2),CCHHR,LEN=5     GET THE CCHHR              LDW1\n         BAS   R8,CPUT                                             LDW1\n*LDW1    MVC   81(16,R2),=C'TO BE CHANGED TO'\n*LDW1    LA    R1,81+16+1(R2)           NEXT STRING LOCATION\n         LA    R1,N1                                               LDW1\n         BAS   R8,SETLINE                                          LDW1\n         EX    0,*                                                 LDW1\n         MVC   20(10,R2),19(R2)         BLANK THE TTR THIS TIME    LDW1\n         MVC   31(16,R2),=C'TO BE CHANGED TO'                      LDW1\n         LA    R1,48(,R2)                                          LDW1\n         L     R2,0(R13)                RESTORE EX INS PTR\n         EX    R4,0(R2)                 CHANGE DATA IN BUFFER\n         BAS   R8,SETSTRNG              RECORD THE CHANGE\n         BAS   R8,CPUT                  PUT THE LINE\n         MVI   CHNGED,255               MARK AS CHANGED FOR LATER\n         OI    FLAGS2,MUSTZAP           BLK NEEDS A ZAP NOW\n         MVC   OLDTTR(3),TTR            COPY FOR PRINTING\n         B     NEWDSPNT                 THEN RETURN TO HIM         LDW1\nNOMSGEX  L     R2,0(R13)                RESTORE EX INSTRUCTION PTR\n         EX    R4,0(R2)                 MAKE THE APPROPRIATE CHANGE\n         OI    FLAGS2,MUSTZAP           BLK NEEDS A ZAP NOW        LDW1\n         B     NEWDSPNT                 GIVE IT TO HIM\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- SET.\n*        *****  SET  *****\n         SPACE 1\nSET      LTR   R3,R0                    TEST OPERAND LENGTH        LDW1\n         BP    SETNEW#                  THERE IS ONE               LDW1\n         SPACE 1\n*        USE OLD STRING FOR SET NO OPERANDS.\n         SPACE 1\n         TM    CONTINUE,YESCONTT        IS THERE AN OLD ONE TO USE?\n         BO    SETNEW                   YES, USE IT                LDW1\n         B     INVEXPER                 INVALID SYNTAX COL 4       LDW1\n         SPACE 1\n*        USE SPECIFIED STRING.\n         SPACE 1\nSETNEW#  LR    R4,R1                    -> TO THE STRING OPERAND   LDW1\n         LA    R5,SETSTR                WHERE TO SAVE THE INFO\n         BAS   R6,GETSTRNG              GET AL2(LEN),C'STRING'\n         SPACE 2                                                   LDW1\n*        NOW SETSTR CONTAINS :\n*        AL2(SET_LEN),C'SET_STRING'\n         SPACE 1\nSETNEW   OC    BLKLEN(2),BLKLEN         IS THERE ANYTHING TO SET?\n         BZ    INVALCOM                 NO, SO DON'T AND TELL HIM\n         TM    GODFLAG,GOD              CAN HE EVER UPDATE?\n         BO    LETSET                   YES, WE HAVE NOTHING TO SAY\n         BAS   R8,SETMSG                MOVE MSG TO RIGHT PLACE    LDW1\n         DC    Y(STORMSG-ZAP)           TELL HIM NOT UPDATING      LDW1\nLETSET   LA    R14,SETSTR               GET THE STRING ADDRESS     -EU-\n         BAS   R8,STRCNV                GO APPLY CONVERSION        -EU-\n         LH    R4,SETSTR                GET BCTR'D STRING LEN  -EU-LDW1\n         LA    R5,WKSTR                 POINT TO STRING        -EU-LDW1\n         LA    R1,N2                    MSG NUMBER\n         BAS   R8,SETLINE               SET UP LINE\n         B     NOSETMSG                 OOPS, NOT PRINTING\n         CLI   CHNGED,0                 VIRGIN BUFFER?\n         BNE   *+L'*+4                  NO, SINGLE SPACE\n         MVI   0(R2),C'0'               ELSE, DOUBLE SPACE FIRST CHANGE\n*LDW1    MVC   31(18,R2),=C'BLOCK TO BE SET TO'  MOVE TEXT\n*LDW1    LA    R1,31+18+1(R2)           POINT WHERE IT GOES\n         MVC   31(28,R2),=C'FOLLOWING BLOCK TO BE SET TO'          LDW1\n         LA    R1,31+28+1(,R2)          POINT WHERE IT GOES        LDW1\n         BAS   R8,SETSTRNG              CONVERT THE STRING\n         BAS   R8,CPUT                  DUMP THE LINE NOW\n         MVI   CHNGED,255               ITS CHANGED NOW\n         MVC   OLDTTR(3),TTR            SAVE TTR\n         IC    R7,ENQIT                 PRESERVE FLAG              LDW1\n         BAS   R6,PREPDMPX              GET READY FOR THE DUMP     LDW1\n         BAS   R6,DUMPER                DUMP THE BLOCK             LDW1\n         STC   R7,ENQIT                 RESTORE FLAG               LDW1\n         LH    R4,SETSTR                RESTORE LENGTH             LDW1\nNOSETMSG OI    CONTINUE,YESCONTT        SAY HE CAN SET NO OPRND NOW\n         OI    FLAGS2,MUSTZAP           BLK NEEDS A ZAP NOW        LDW1\n         L     R5,ADDRBUFF              PT TO BUFFER\n         XR    R8,R8                    CLEAR REM REG FOR DIVIDE\n         LH    R7,BLKLEN                GET LEN OF BLK IN BUFFER\n         LA    R1,1(R4)                 GET REAL STRING LENGTH\n         DR    R8,R1                    HOW MANY STRINGS FIT IN BLK\n         LTR   R7,R7                    BLK SHORTER THAN STRING?\n         BZ    JUSTSPEW                 YES, JUST MOVE IN REMAINDER\n         SPACE 1\n*        R7 HAS BCT COUNT OF HOW MANY STRINGS CAN FIT\n*        IN THIS PARTICULAR BLK, WHILE R8 HAS THE LENGTH\n*        OF THE PIECE LEFT OVER.\n         SPACE 1\nSETLOOP  EX    R4,SETMVC                MOVE 1 STRING IN\n         LA    R5,1(R4,R5)              UPDATE BUFFER PTR FOR NEXT\n         BCT   R7,SETLOOP               FILL AS MUCH OF BUFFER AS CAN\nJUSTSPEW LTR   R8,R8                    IS THERE A SMALL PIECE LEFT?\n         BZ    NEWDSPNT                 NO, WE ARE ALL DONE\n         BCTR  R8,0                     YES, GET EXECUTE LEN\n         EX    R8,SETMVC                MOVE AS MUCH AS WILL FIT IN\n         B     NEWDSPNT                 AND GO DISPLAY WHAT WE DID\nSETMVC   MVC   0(0,R5),WKSTR            << EXECUTED >>         -EU-LDW1\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- ZAP/SAVE.\n*        *****  ZAP/SAVE  *****\n         SPACE 1\nREPLACE  CLI   IOERROR,YESSYN           WAS THERE AN I/O ERROR ON BLK?\n         BE    WRTNONO                  YES, CAN'T ZAP THAT\n         OC    BLKLEN(2),BLKLEN         NO, BUT IS THERE A BLK TO ZAP?\n         BZ    WRTNONO                  NO, SO DON'T ZAP ALREADY\n         TM    DCBLIST,X'0F'            UPDATING ALREADY?\n         BNZ   THERE                    YES, CONTINUE\n         TM    GODFLAG,GOD              CAN HE CHANGE FROM INPUT TO UP\n         BZ    WRTNONO                  NO, TOUGH BEANS FOR HIM\n         MVC   REP,BLANKS               CLEAR REPLY                LDW1\n         MVC   REP(3),=C'ZAP'           RE-PROMPT THE RIGHT THING  LDW1\n         CLOSE MF=(E,DCBLIST)           CLOSE THE DATASET SO THAT....\n         MVI   DCBLIST,X'84'            WE CAN OPEN FOR UPDATE\n         OPEN  MF=(E,DCBLIST),TYPE=J    THEN DO IT ALREADY         LDW1\n         TM    DCBU+48,X'10'            OPEN?\n         BO    THERE#                   YES, OK\n         BCR   0,1                      DRAIN PIPELINE\n         EX    0,*                      THIS BETTER NEVER HAPPEN\nTHERE#   TM    FLAGS2,LOGF              SEE IF LOGGING\n         BNO   THERE                    IF NOT, THEN NO MSG\n         L     R1,CSOUTWK               POINT TO WORK AREA\n         LTR   R1,R1                    SEE IF THERE\n         BZ    THERE                    IF NOT, NO MSG\n         LA    R8,THERE                 GET RETURN ADDR\n         ST    R8,DBLW                  STORE FOR SUBROUTINE\n         B     OPENMSG                  GO WRITE THE MESSAGE\nTHERE    BAS   R8,WRITE                 WRITE THE BUFFER OUT\n         CLI   IOERROR,YESSYN           I/O ERROR?\n         BE    NEWDSPNT                 YES, IGNORE TELLING HIM OK\n         MVI   CHNGED,0                 BUFFER HAS BEEN CHECKPOINTED\n         NI    FLAGS2,255-MUSTZAP       BLK NO LONGER NEEDS ZAP\n         SPACE 1\n*        UPDATE THE IDR IF APPLICABLE.\n*        IDR FOR SUPERZAP (AND THEREFORE ZAP)\n*        TAKES THE FOLLOWING FORM :\n*        BYTE  0.....'80' FOR ID\n*        BYTE  1.....LENGTH OF IDR (USUALLY X'FA' = 250.)\n*        BYTE  2.....WHO'S IDR IT IS (X'01' FOR SUPERZAP AND ZAP)\n*        BYTE  3.....NUMBER OF 13-BYTE IDR DATA ENTRIES (BITS 2-7)\n*        BYTES 4-16, 17-29,... IDR DATA ENTRY AS FOLLOWS :\n*              BYTES 0-1 --- ESD ID (DEFAULT 1)\n*              BYTES 2-4 --- DATE ('YYDDDF')\n*              BYTES 5-12 -- INFO ('TSO--UUU, WHERE UUU=ZAPPER'S UID)\n         SPACE 1\n         CLI   DSORG,DSORGPO            IS THIS A PDS?\n         BNE   FINZAP                   NO, FORGET THE IDR\n         CLI   DCBRECFM-IHADCB+DCBU,RECFMU  IS THIS A LIBRARY?\n         BNE   FINZAP                   NO, DON'T UPDATE THE 'IDR'\n         CLI   IDRFLAG,CHGIDR           ALREADY UPDATED THIS IDR\n         BE    FINZAP                   YES, DON'T DO IT AGAIN NOW\n         MVC   0(3,R13),TTR             LET'S SAVE WHERE HE WAS FIRST\n         OC    MEMTTR(3),MEMTTR         WAS THERE A 'M' COMMAND?\n         BZ    ENDIDR                   NO, FORGET IT\n         MVC   TTR(3),MEMTTR            PICK UP MEMBER PTR\n         BAS   R8,READBLK               READ 1ST BLK OF MEMBER\nIDRFIND  L     R1,ADDRBUFF              GET BUFFER PTR\n         TM    0(R1),X'01'              CONTROL RECORD OF SOME SORT?\n         BO    ENDIDR                   YES, WE ARE ALL DONE LOOKING\n         CLI   0(R1),X'80'              IDR?\n         BNE   NEWBLK                   NO, GET ANOTHER BLK\n         TM    2(R1),X'01'              YES, BUT DONE BY SUPERZAP?\n         BNO   NEWBLK                   NO, FORGET THIS ONE\n         XR    R2,R2                    CLEAR WORK REG\n         IC    R2,3(R1)                 PICK UP # OF IDR DATA ENTRIES\n         LR    R4,R2                    SAVE IT FOR LATER\n         N     R2,=XL4'0000003F'        WE JUST WANT BITS 2-7\n         MH    R2,=H'13'                EACH ENTRY IS 13 BYTES LONG\n         LA    R2,3(R2)                 IDR HDR IS 3 BYTES LONG\n*        SO NOW R2 HAS AN OFFSET TO THE NEXT\n*        AVAILABLE POSITION IN THE IDR.\n         XR    R3,R3                    CLEAR WORK REG\n         IC    R3,1(R1)                 PICK UP IDR LENGTH\n         CR    R3,R2                    ARE WE AT END OF IDR?\n         BH    UPDATIDR                 NO, SO UPDATE THE IDR\nNEWBLK   MVI   EOFRET,NOEOF             TREAT EOF'S AS DATA BLKS\n         BAS   R8,READNBLK              READ ON ANOTHER BLK        LDW1\n         CLC   LINE05+27(20),EOFMSG     DID I HIT END OF FILE?     LDW1\n         BE    ENDIDR                   YES, STOP THIS STUPID THING\n         CLI   IOERROR,YESSYN           I/O ERROR?\n         BE    ENDIDR                   YES, LEAVE\n         B     IDRFIND                  NO, CHECK THIS BLK\nUPDATIDR AR    R2,R1                    R2 PTS TO NEXT IDR SPOT\n         LA    R4,1(R4)                 INCREMENT # OF IDR ENTRIES...\n         STC   R4,3(R1)                 AND PUT IT BACK\n         MVC   1(2,R2),ESDID            MOVE IN ESDID (IF ANY)\n         TIME  ,                        GET THE DATE IN R1\n         ST    R1,DBLW                  SAVE IT IN TEMP WORD\n         MVC   3(3,R2),DBLW+1           MOVE YYDDDF TO IDR\n         MVI   6(R2),C'/'               INDICATE TSO USERID        LDW4\n         MVC   7(7,R2),USERID           MOVE IN THE CULPRIT        LDW4\n         BAS   R8,WRITE                 GO WRITE THE RECORD BACK   LDW4\n         CLI   IOERROR,YESSYN           I/O ERROR?\n         BE    ENDIDR                   YES, SAY WE DIDN'T UPDATE\n         MVI   IDRFLAG,CHGIDR           NO, SO WE DID UPDATE THE IDR\nENDIDR   LA    R1,N6                    ASSUME NOT UPDATED\n         CLI   IDRFLAG,CHGIDR           WAS THE IDR UPDATED?\n         BNE   *+L'*+4                  NO, WE WERE RIGHT\n         LA    R1,N7                    DID UPDATE\n         BAS   R8,SETLINE               SET UP OUTPUT LINE\n         B     PUTBACK                  NO PRINT FILE, LEAVE\n         MVI   0(R2),C'0'               DOUBLE SPACE\n         MVC   20(25,R2),=C'IDR FOR CSECT NOT UPDATED'\n         CLI   IDRFLAG,CHGIDR           WAS IT UPDATED?\n         BNE   PUTITOUT                 NO, MSG IS OK\n         MVC   34(3,R2),EDMASK+9        YES, SO GIVE ESDID          *N*\n         LH    R0,ESDID                 GET ESDID (USUALLY)         *N*\n         CVD   R0,DBLW                  IN DEC                      *N*\n         ED    33(4,R2),DBLW+6          ESDID TO MSG                *N*\nPUTITOUT BAS   R8,CPUT                  PUT MSG OUT\nPUTBACK  CLC   TTR(3),0(R13)            HAS HE MOVED ANY?\n         BE    FINZAP                   YES, DON'T BOTHER PUTTING BACK\n         MVI   TTR+3,NOSEQRD            GET THE RIGHT ONE, NOT THE NEXT\n         MVC   TTR(3),0(R13)            LET'S PUT HIM BACK WHERE HE WAS\n         BAS   R8,READBLK               HE'LL NEVER KNOW WHAT HAPPENED\nFINZAP   MVC   LINE19+17(40),=CL40'      *****  BLOCK REPLACED  *****'\n         MVI   ENQIT,255                FORCE ENQ NOW THAT ITS ZAPPED\n         LA    R1,N3                    MSG NUMBER\n         BAS   R8,SETLINE               SETUP THE LINE\n         B     NEWDSPNT                 NOT PRINTING\n         MVC   31(14,R2),=C'BLOCK REPLACED'\n         MVI   0(R2),C'0'               DOUBLE SPACE THIS ONE\n         BAS   R8,CPUT                  DUMP THE LINE\n*        TRUNCATE CURRENT LOG BLOCK, IN CASE OF SYSTEM/PROGRAM FAILURE.\n         L     R2,CSOUTWK               IT'S GOTTA BE HERE         LDW1\n         MVI   0(R2),X'01'              INDICATE TRUNC             LDW1\n         BAS   R8,CPUTRUNC              TRUNCATE THIS LOG BLOCK    LDW1\n         B     NEWDSPNT                 YES, DISPLAY WITH NO TRACE\nWRTNONO  LA    R2,WRITERR               TELL HIM WRITE NOT ALLOWED\n         MVC   REP,BLANKS               CLEAR OUT REPLY BUFF AND   LDW1\n*                                       SO DON'T TEMPT HIM TO RE-'ZAP'\n         B     BOTCH                    AND DISPLAY\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- DISASM, ASM.                LDW1\n*        *****  DISASM\n         SPACE 1\nDISASM   LH    R15,OLDPOINT             CURR OFFSET\n         MVI   EXPOPT,YESSYMB           WANT SYM TAB LOOKUP\n         BAS   R8,CALLEXP               PARSE & CHECK              LDW1\n         BM    INVEXPER                 NEG IS BAD                 LDW1\n         LH    R0,BLKLEN                GET LENGTH BLK\n         SH    R0,=H'2'                 LAST POSS INSTRUCTION\n         CR    R15,R0                   PAST END OF BLK?\n         BH    INVEXPER\n         A     R15,ADDRBUFF             GET ADDR IN BUFFER\n         LNR   R1,R15                   NEG FOR 'DISASM'\n         LA    R0,LINE19+24             GIVE HIM 33 BYTES TO WORK WITH\n         LA    R2,TEMP2                 GIVE HIM SOME WORKAREA TOO\n         L     R15,=V(ASMGASM)          POINT TO 'ASSEMBLER' HAR HAR\n         BASR  R14,R15                  DISASSEMBLE IT\n         LA    R2,INVOPCOD              ASSUME BOTCHUP\n         BXH   R15,R15,BOTCH            YUP\n         MVC   LINE19+17(7),=C'INSTR:'  NO, MOVE MASK\n         B     NEWDSPNT                 AND SHOW IT OFF\n         SPACE 1                                                   LDW1\n*        *****  ASM\n         SPACE 1\nASM      BNP   INVEXPER                 NO OPERAND - BAD           LDW1\n         L     R15,=V(ASMGASM)          PT TO SUB\n         BASR  R14,R15                  GET OBJECT\n         LA    R2,INVOPCOD              ASSUME NO\n         BXH   R15,R15,BOTCH\n         MVC   LINE19+17(8),=C'OP CODE:'  MASK\n         HEX   LINE19+27,(0,R1),LEN=1                              LDW1\n         B     NEWDSPNT                 SHOW IT\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- V, BASE.                    LDW1\n*        *****  V  *****\n         SPACE 1\nINDIRECT LH    R15,OLDPOINT             * = CURRENT OFFSET         LDW1\n         MVI   EXPOPT,YESSYMB           WANT SYM TAB LOOKUP        LDW1\n         BAS   R8,CALLEXP               PARSE & CHECK              LDW1\n         BM    INVEXPER                 NEG IS INVALID             LDW1\n         LH    R0,BLKLEN                GET BLOCK LENGTH           LDW1\n         SH    R0,=H'2'                 LAST POSSIBLE RDW          LDW1\n         CR    R15,R0                   PAST END?                  LDW1\n         BH    INVEXPER                 YES, BYE                   LDW1\n         A     R15,ADDRBUFF             GET ADDR IN BUFFER         LDW1\n         MVC   0(2,R13),0(R15)          REC LEN TO ALIGNED PLACE   LDW1\n         LH    R15,0(,R13)              GET RECORD LENGTH          LDW1\n         AH    R15,OLDPOINT             BUMP OFFSET                LDW1\n         B     SETPOINT                 GO SET IT                  LDW1\n*        DO WE WANT TO GO TO THE NEXT BLK IF NECESSARY?            LDW1\n         SPACE 1\n*        *****  BASE  *****                                        LDW1\n         SPACE 1\nBASE     L     R15,OFFSET               * = CURRENT OFFSET         LDW1\n         MVI   EXPOPT,YESSYMB           WANT SYM TAB LOOKUP        LDW1\n         BAS   R8,CALLEXP               PARSE & CHECK              LDW1\n         ST    R15,BASEVAL              SET NEW BASE VALUE         LDW1\n         AH    R15,OLDPOINT             ADD OLD BUFFER OFFSET      LDW1\n         ST    R15,OFFSET               SET NEW OFFSET             LDW1\n         B     NEWDSPNT                 GO SHOW IT OFF             LDW1\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- DO.\n*        *****  DO\n         SPACE 1\nDO       LTR   R3,R0                    TEST OPERAND LENGTH        LDW3\n         BNP   INVEXPER                 ERROR\nDOL      CLI   0(R1),C' '               SCAN OFF LEADING BLNKS\n         BNE   DO1                      FOUND A NON BLNK\n         LA    R1,1(R1)                 LOOK AT NXT CHAR\n         BCT   R3,DOL                   - THE COUNT\n         B     INVEXPER\nDO1      LR    R2,R1                    PUT IN RIGHT REG\n         BAS   R8,KILL3270              TURN OFF 3270 MODE IF ON   LDW3\n         TPUTX 'THE \"DO\" COMMAND IS NOT IMPLEMENTED'            .AFDSC.\n*        B     DO2                                          -EU-.AFDSC.\n*        SPACE 1                                                   -EU-\n*        XC    TMPLIST(TMPLISTL),TMPLIST CLEAR THE LIST            -EU-\n*        TPUTX 'DOING'                                             -EU-\n*        OACTMP CMD=((R2),(R3)),MF=(E,TMPLIST)  DO THE 'DO'        -EU-\n*        BXH   R15,R15,DO2                                         -EU-\n*        TPUTX 'DONE'                                              -EU-\n*        SPACE 1                                                   -EU-\nDO2      BAS   R8,TGET                  BRANCH ENTRY               LDW1\n         B     COMSCAN                  PARSE COMMAND\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- WHERE.\n*        *****  WHERE\n         SPACE 1\nWHERE    MVI   TRACE,NOTRACE            DONT TRACE\n         BAS   R8,CLEAR                 CLEAR SCREEN\n         B     WHEREAMI                 FORMAT LINE                LDW1\n         SPACE 1\n*        *****  NOT3270  *****                                     LDW1\n         SPACE 1\nNOT3270  BAS   R8,KILL3270              TURN OFF 3270 MODE IF ON   LDW1\n         NI    FLAGS3,255-F3270         TURN OFF FLAG              LDW5\n         B     NEWDSPNT                 DISPLAY AGAIN, NOTRACE     LDW1\n         SPACE 1\n*        *****  YES3270  *****                                     LDW2\n         SPACE 1\nYES3270  OI    FLAGS3,F3270+RESHOWF     TELL THE WORLD             LDW5\n         B     NEWDSPNT                 DISPLAY AGAIN, NOTRACE     LDW1\n         SPACE 1\n*        *****  LINE80  *****                                      LDW1\n         SPACE 1\nLINE80   MVC   DISPCONS(DISPCONL),DSPCON80  CONSTANTS FOR LEN=80   LDW1\n         B     NEWDSPNT                 GO DISPLAY, NOTRACE        LDW1\n         SPACE 1\n*        *****  LINE40  *****                                      LDW1\n         SPACE 1\nLINE40   MVC   DISPCONS(DISPCONL),DSPCON40  CONSTANTS FOR LEN=40   LDW1\n         B     NEWDSPNT                 GO DISPLAY, NOTRACE        LDW1\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- W (WINDOW).\n*        *****  W   (WINDOW)\n         SPACE 1\nWINDOW   BP    OKWIND                   GO PROCESS OPERANDS\n         XC    WIDTHS(4+4),WIDTHS       ONLY 'W', SET DEFAULTS\n         NI    FLAGS3,255-CRTF          TURN OFF CRT MODE          LDW1\n         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES\n         B     NEWDSPNT                 AND QUIT\nOKWIND   CLC   =C'FULL',REP+1           FULL WINDOW SPECIFIED?     LDW1\n         BNE   OKWIND#                  NO, GO ON\n         L     R6,MAXWIDTH              YES, SAY FULL              SDM6\n         LR    R7,R6                    SAY FULL HERE TOO          SDM6\n         B     WINDSAVE                 WE ARE DONE\nOKWIND#  LM    R6,R7,WIDTHS             ASSUME WIND=CURR WIND      SDM6\n         LR    R4,R0                    SAVE LEN OP(S)             SDM6\n         LR    R5,R1                    SAVE PTR TO OPERANDS       SDM6\n         SPACE 1\n*        W<DOWN>,<UP>.\n         SPACE 1\nWINDLOOP CLI   0(R5),C','               END 1ST OP?                SDM6\n         LA    R5,1(,R5)                ASSUME YES                 SDM6\n         BE    *+L'*+4                  RIGHT, DO 1ST\n         BCT   R4,WINDLOOP              TRY TRY                    SDM6\n         SR    R0,R4                    LEN 1ST                    SDM6\n         BZ    WIND2                    NO 1ST, DO 2ND\n         BAS   R3,WINDEXP               PARSE, R1 SET, *=0         SDM6\n         LR    R6,R15                   ALL OK, SAVE FOR <DOWN>    SDM6\nWIND2    LR    R0,R4                    LEN LEFT = LEN 2ND (ALMOST)SDM6\n         SH    R0,=H'1'                 -1 FOR COMMA (IF ANY)\n         BNP   WINDSAVE                 NO 2ND OP, LEAVE ALONE\n         LR    R1,R5                    SET OP PTR FOR EXP         SDM6\n         BAS   R3,WINDEXP               GO PARSE 2                 SDM6\n         LR    R7,R15                   ALL OK, SAVE <UP>          SDM6\nWINDSAVE STM   R6,R7,WIDTHS             SAVE THE 2 WIDTHS          SDM6\n         B     NEWDSPNT\nWINDEXP  XR    R15,R15                  * = 0                      LDW1\n         BAS   R8,CALLEXP               PARSE & CHECK              LDW1\n         BM    INVEXPER                 NEG IS BAD                 LDW1\n         CL    R15,MAXWIDTH             TOO BIG?                   LDW1\n         BNHR  R3                       NO, RETURN                 SDM6\n         B     INVEXPER                 YES, COMPLAIN              LDW1\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- FLOAT.\n*        *****  FLOAT\n         SPACE 1\n*        (ORIGINAL INTX SVCX 6 CODE WRITTEN BY STEVE SILVER.\n*              MODIFIED FOR ZAP USE BY JCJ AND VIC\n*              - IE : WE DON'T UNDERSTAND)\n         SPACE 1\nFLOAT    LTR   R2,R0                    TEST OPERAND LENGTH        LDW1\n         BP    FLOAT$                   GO USE IT                  LDW1\n         LH    R15,OLDPOINT             GET CURRENT OFFSET         LDW1\n         LR    R14,R15                  COPY                       LDW1\n         AH    R14,=H'8'                POINT PAST END OF OPERAND  LDW1\n         CH    R14,BLKLEN               IN BLOCK?                  LDW1\n         BNL   INVEXPER                 NO, ERROR                  LDW1\n         A     R15,ADDRBUFF             -> OPERAND                 LDW1\n         MVC   TEMP(8),0(R15)           GET IN ALIGNED PLACE       LDW1\n         B     FLOAT#                   CONTINUE WITH IT           LDW1\nFLOAT$   BCTR  R2,0                     GET EXECUTE LENGTH         LDW1\n         CH    R2,=H'15'                WAS THE OPERAND TOO LONG?\n         BH    LENERROR                 YES, TELL HIM AND QUIT\n         LR    R7,R1                    POINT TO THE STRING        LDW1\n         LA    R1,1(,R2)                PICK UP LENGTH OF STRING\n         BAS   R8,HEXCHECK              IS IT VALID HEX?\n         B     OKFLOAT                  YES, SO LET'S DO IT\n         LR    R1,R7                    NO, POINT TO THE ERROR\n         B     INVEXPER                 AND SAY SYNTAX ERROR\nOKFLOAT  EX    R2,TRFLOAT               START TRANSLATE TO REAL HEX\n         PACK  TEMP(8),TEMP2+5(15)      MAKE IT HONEST-TO-GOODNESS HEX\n         MVN   TEMP+7(1),TEMP2+20       GET THE LAST NIBBLE TOO\nFLOAT#   LD    F0,TEMP                  LOAD IT IN FLOAT REG 0     LDW1\n         LA    R7,LINE19+36             PT TO START OF SCRN RESULT AREA\n         SPACE 1\n*        SET THE PROGRAM MASK TO MASK OUT FIX PT OFLO,\n*        DEC OFLO, EXPON UNFLO, AND SIGNIFICANCE.\n*        SAVE IT IN R6 TO RESET IT LATER.\n         SPACE 1\n         XR    R2,R2                    0 R2 FOR SPM\n         BASR  R6,0                     SAVE PGM MASK FOR RESTORE\n         SPM   R2                       0 THE PGM MASK (NO INTERR)\n         MVI   16(R7),C'0'              ASSUME ANSWER IS 0\n         AD    F0,=D'0'                 NORMALIZE BY ADDING 0\n         LTDR  F0,F0                    CHECK THE SIGN\n         BZ    CVFCI3                   ZERO (WE'RE ALMOST DONE)\n         BP    CVFC00                   PLUS, GO ON\n         LPDR  F0,F0                    MINUS, MAKE IT PLUS ...\n         MVI   0(R7),C'-'               INSERT SIGN AND GO ON LIKE PLUS\nCVFC00   LA    R7,1(R7)                 UPDATE OUTPUT PTR EITHER CASE\n         CD    F0,=X'7FFFFFFFFFFFFF00'  DATA WILL CAUSE EXP OVERFLOW?\n         BNH   *+L'*+4                  NO - SKIP PREVENT LOAD\n         LD    F0,=X'7FFFFFFFFFFFFF00'  ELSE GET MAX ALLOWABLE\n*        MAX ALLOWABLE IS X'7FFFFFFFFFFFFF00'\n         MD    F0,=X'4110000000000010'  MULT BY FUDGE FACTOR\n         SPACE 2\n*        GENERATE THE NUMBER IN D-FORMAT.\n         SPACE 1\n         XR    R2,R2                    INITIALIZE EXPON REG\n         LD    F4,=D'10'                SET F4 TO 10\n         LD    F6,=D'1'                 SET F6 TO 1\n         LD    F2,=X'401999999999999A'  SET F2 TO .1\n         MVI   0(R7),C'.'               SET UP OUTPUT\n         LA    R7,1(R7)                 INCREMENT LINE POINTER\n         MVI   14(R7),C'D'              FORM THE OUTLINE OF EXPONENT\n         MVI   15(R7),C'+'              MOVE IN EXPONENT SIGN\n*        GET THE EXPONENT IN R2 (>=1).\nCVFC1A   CDR   F0,F6                    SEE IF # < 1\n         BL    CVFC2                    IF SO, GO TO NEXT PART\n         DDR   F0,F4                    NO, DIVIDE BY 10\n         LA    R2,1(R2)                 INCREMENT EXPONENT\n         B     CVFC1A                   CONTINUE\n*        GET THE EXPONENT (<.1).\nCVFC2    CDR   F0,F2                    SEE IF >= .1\n         BNL   CVFC3                    IF SO, GO TO NEXT PART\n         BCTR  R2,0                     DECREMENT EXPONENT\n         MDR   F0,F4                    MULT NUMBER BY 10\n         B     CVFC2                    CONTINUE\n*        GET EXPONENT SIGN.\nCVFC3    LTR   R2,R2                    SEE IF EXPONENT +\n         BNM   CVFC3A                   IF SO, SKIP CODE\n         LPR   R2,R2                    MAKE IT PLUS BUT ...\n         MVI   15(R7),C'-'              WRITE OUT A MINUS\nCVFC3A   LA    R0,10                    DIVISER FOR BELOW\n         SRDL  R2,32                    SET UP FOR DIVIDE\n         DR    R2,R0                    DO THE DIVIDE\n         LA    R2,C'0'(R2)              GET THE EBCDIC VALUE\n         LA    R3,C'0'(R3)              GET THE EBCDIC VALUE\n         STC   R2,17(R7)                AND STORE IT\n         STC   R3,16(R7)                AND STORE IT\n         LA    R0,14                    GET NUMBER OF DIGITS FOR BCT\n         LD    F6,=X'4100000000000000'  LOAD F6 WITH UN-NORMALIZER\n*        GET THE MANTISSA.\nCVFC4    MDR   F0,F4                    MULT NUMBER BY 10\n         AWR   F0,F6                    UN-NORMALIZE\n         STD   F0,TEMP                  STORE RESULT\n         XR    R4,R4                    ZERO FOR IC\n         IC    R4,TEMP+1                GET FIRST HEX DIGIT\n         SRA   R4,4                     KILL LOW NIBBLE (LAST HEX DIG)\n         LA    R3,C'0'(R4)              CONVERT TO CHAR\n         STC   R3,0(R7)                 MOVE RESULT TO OUTPUT\n         XC    TEMP(8),TEMP             SET UP DBLW\n         LA    R7,1(R7)                 POINT TO NEXT OUTPUT COL\n         LTR   R4,R4                    IS R4 0?\n         BZ    CVFC4#                   YES, WE HAVE NOTHING TO DO\n         MVI   TEMP,X'41'               MAKE DBLW INTERNAL FLOATING PT\n         SLL   R4,4                     MOVE NUMBER TO HIGH ORDR NIBBLE\n         STC   R4,TEMP+1                AND MOVE IT TO DBLW\n         SPACE 1\n*        WE HAVE NOW BUILT A DBLW WHICH MAY CONTAIN D'0' THROUGH D'10'.\n         SPACE 1\n         SD    F0,TEMP                  SUBTRACT THE INTEGER PART\nCVFC4#   BCT   R0,CVFC4                 DO TILL END\n         B     CVFCI3                   CLEAN UP AND GO AWAY\n         SPACE 1\n*        IF NUMBER IS ZERO TO BEGIN WITH, THERE'S NOTHING TO DO BUT ...\n         SPACE 1\n         MVI   16(R7),C'0'              SET UP ZERO RESULT\n         SPACE 1\n*        RESTORE PROGRAM MASK TO WHAT IT WAS.\n         SPACE 1\nCVFCI3   SPM   R6                       RESET PROGRAM MASK\n         MVC   LINE19+17(15),=CL15'FLOATING POINT:'\n         B     NEWDSPNT                 RETURN TO CALLER\nTRFLOAT  TR    TEMP2+5(0),TRHEX         << EXECUTED >>             LDW1\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- DUMP, DUMPE, DUMPF.         LDW1\n*        *****  DUMP, DUMPE  *****                                 LDW1\n         SPACE 1\nDUMP     BAS   R8,LOGTEST                                          LDW1\n         BAS   R8,CHKPT                 SEE IF HE CAN LEAVE        LDW1\n         CLI   CPUTFLAG,YESCSERR        CAN CSOUT ENQ NOW?\n         BE    BADCSOUT                 NO, WHY BOTHER TO DUMP THEN?\n         L     R7,=XL4'7FFFFFFF'        NUMBER OF BLOCKS TO READ (HAH)\n         MVC   0(3,R13),TTR             SAVE WHERE WE ARE\n         CLI   REP+4,C'E'               IS THIS REALLY DUMPE?      LDW1\n         BE    PREPDMPF                 YES, DUMP FROM HERE        LDW1\n         MVC   TTR(4),=XL4'00000100'    POINT TO BEGINNING OF DATA-SET\n         B     PREPDMPF                 START DUMPING TILL END OF DS\n         SPACE 1                                                   LDW1\n*        *****  DUMPF  *****\n         SPACE 1\nDUMPF    BAS   R8,LOGTEST                                          LDW1\n         BAS   R8,CHKPT                 SEE IF HE CAN LEAVE        LDW1\n         CLI   CPUTFLAG,YESCSERR        CAN CSOUT ENQ IT TO PRINT?\n         BE    BADCSOUT                 NO, SO WHY DUMP MAY I ASK?\n         LH    R0,REALRDLN              GET LEN OF COMMAND\n         SH    R0,=H'5'                 -5 FOR 'DUMPF' ACTUAL LEN\n         BNZ   DUMPFOR                  HE GAVE AN OPERAND, PROCESS IT\nJUSTDUMP LA    R7,1                     DUMP R* ONLY - R7 = # TO DUMP\n         B     STARTDF                  ALL SET, START THE DUMP-FOR\n         SPACE 1\n*        PROCESS OPERAND OF DUMPF COMMAND (NUMBER OF BLOCKS TO DUMP).\n         SPACE 1\nDUMPFOR  XR    R15,R15                  LOAD *, CURRENT LOC FOR 'EXP'\n         LA    R1,REP+5                 POINT TO OP. TO PARSE      LDW1\n         BAS   R8,CALLEXP               GO PARSE                   LDW1\n         BM    NOBACK                   NEG, WE CAN'T DUMP BACKWARDS\n         BZ    INVEXPER                 ZERO, INVALID SYNTAX\n         LR    R7,R15                   NUMBER OF BLOCKS TO DUMP\nSTARTDF  MVC   0(3,R13),TTR             SAVE WHERE WE ARE\nPREPDMPF MVI   TTR+3,NOSEQRD            1ST BLK, READ IT BEFORE DUMP\nDMPFLOOP BAS   R6,PREPDUMP              GET READY FOR THE DUMP\n         BAS   R6,DUMPER                DUMP A BLOCK\n         MVI   TTR+3,SEQREAD            SAY NEXT PASS, NOW READ BLK\n         BCT   R7,DMPFLOOP              DO ALL THE BLOCKS HE WANTS\nDUMPEND  MVC   TTR(3),0(R13)            PICK UP WHERE WE WERE\n         MVI   TTR+3,NOSEQRD            DON'T PUT HIM IN NEXT BLOCK\n         BAS   R8,READBLK               SO THAT HE'LL NEVER KNOW\n         LA    R2,DUMPWORK              IT WORKED SO TELL HIM\n         B     BOTCH                    DISPLAY (NOT REALLY A BOTCH)\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- DUMPT.\n*        *****  DUMPT  *****\n         SPACE 1\nDUMPT    BAS   R8,LOGTEST                                          LDW1\n         BAS   R8,CHKPT                 SEE IF HE CAN LEAVE        LDW1\n         CLI   CPUTFLAG,YESCSERR        CAN CSOUT ENQ TO PRINT?\n         BE    BADCSOUT                 NO, DON'T BOTHER WITH DUMP\n         LH    R0,REALRDLN              GET LEN OF READ\n         SH    R0,=H'5'                 -5 FOR 'DUMPT' ACTUAL LEN\n         BZ    JUSTDUMP                 NO OPERAND, JUST DUMP THIS BLK\n         SPACE 1\n*        PARSE OUT THE TTR OPERAND OF THE DUMPT COMMAND.\n         SPACE 1\n         LA    R1,REP+5                 POINT TO THE OPERAND       LDW1\n         BAS   R6,TTRPARSE              GO PARSE (USE POINT'S RTN) LDW1\n         CLC   TEMP+1(3),TTR            RESULT (TEMP+1) < CURRENT TTR?\n         BNL   OKDUMPT                  NO, HIS WISH IS MY COMMAND\nNOBACK   LA    R2,BACKDUMP              YES, WE CAN'T DUMP BACKWARDS\n         B     BOTCH                    WHAT DOES HE THINK WE ARE?\nOKDUMPT  MVC   STOPDUMP(3),TEMP+1       TTR TO STOP AT\n         MVC   0(3,R13),TTR             SAVE WHERE WE ARE\n         MVI   TTR+3,NOSEQRD            1ST BLK, READ 1ST BLK FOR DUMP\nDMPTLOOP BAS   R6,PREPDUMP              NO, SO PREPARE TO DUMP\n         BAS   R6,DUMPER                AND DUMP WHAT WE HAVE\n         MVI   TTR+3,SEQREAD            NOW WE CAN READ SEQ BLKS\n         CLC   TTR(3),STOPDUMP          ARE WE THERE OR PAST YET?\n         BNL   DUMPEND                  YES, WE ARE ALL DONE THEN\n         B     DMPTLOOP                 GO TILL WE ARE AT HIS TTR\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- WHATMEM.                    LDW1\n*        *****  WHATMEM  *****\n         SPACE 1\nWHATMEM  BAS   R8,CHKPT                 SEE IF HE CAN LEAVE        LDW1\n         CLI   DSORG,DSORGPO            IS IT PARTITIONED?         LDW1\n         LA    R2,NOMCOM                GET MSG ADDR IN CASE       LDW1\n         BNE   BOTCH                    NO, ERROR                  LDW1\n         MVC   0(3,R13),TTR             SAVE CURRENT TTR           LDW1\n         XC    STOPDUMP(3),STOPDUMP     SAVE CLOSEST TTR HERE      LDW1\n         XC    TTR(3),TTR               START AT BEGINNING OF DIR  LDW1\nWHATLOOP BAS   R8,READNBLK              GET NEXT DIRECTORY BLOCK   LDW1\n         CLI   IOERROR,YESSYN           DID IT WORK?               LDW1\n         BE    NEWDSPNT                 NO, ABORT                  LDW1\n         L     R3,ADDRDATA              -> BUFFER                  LDW1\n         LH    R2,0(,R3)                BLK LEN USED               LDW1\n         LA    R3,2(,R3)                -> REAL BEGIN LOC          LDW1\n         BCTR  R2,0                     -1                         LDW1\n         BCTR  R2,0                     AND -2 FOR REAL LEN USED   LDW1\nWMLOOP2  CLC   0(4,R3),=XL4'FFFFFFFF'   END OF DIRECTORY?          LDW1\n         BE    WMEND                    YES                        LDW1\n         CLC   8(3,R3),0(R13)           THIS MEM PAST CURRENT LOC? LDW1\n         BH    WMNEXT                   YES, TRY NEXT              LDW1\n         CLC   8(3,R3),STOPDUMP         NO, HIGHER THAN PREVIOUS?  LDW1\n         BL    WMNEXT                   NO, PREVIOUS IS CLOSER     LDW1\n         MVC   STOPDUMP(3),8(R3)        SAVE THIS TTR              LDW1\n         MVC   LINE19+35(8),0(R3)       SAVE MEMBER NAME           LDW1\nWMNEXT   BAS   R8,NXTDIRNT              INCR TO NEXT ENTRY         LDW1\n         BP    WMLOOP2                  CHECK NEXT                 LDW1\n         B     WHATLOOP                 GET ANOTHER DIR BLK        LDW1\nWMEND    MVC   TTR(3),0(R13)            RESTORE WHERE HE WAS       LDW1\n         OC    STOPDUMP(3),STOPDUMP     DID I FIND ANYTHING?       LDW1\n         BNZ   WMENDOK                  YES, DISPLAY IT            LDW1\n         MVC   LINE19,BLANKS            RESET THE LINE             LDW1\n         BAS   R8,SETMSG                MOVE IN MSG                LDW1\n         DC    Y(NOMEMFND-ZAP)          'NONE FOUND'               LDW1\n         B     WMDONE                   SKIP OTHER                 LDW1\nWMENDOK  MVC   LINE19+17(17),=C'CLOSEST MEMBER IS'                 LDW1\n         MVC   LINE19+44(6),=C'AT TTR'                             LDW1\n         HEX   LINE19+51,STOPDUMP,LEN=3 GIVE HIM THE START         LDW1\nWMDONE   BAS   R8,READBLK               PUT HIM BACK WHERE HE WAS  LDW1\n         B     NEWDSPNT                 AND GO DISPLAY             LDW1\n*        SEE NOTE AT END OF MLOOP2 (NEXT PAGE).                    LDW1\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- M.\n*        *****  M  *****\n         SPACE 1\nMEMBER#  BAS   R8,CHKPT                 NEED ZAP?\n         CLI   DSORG,DSORGPO            IS IT PARTITIONED?\n         LA    R2,NOMCOM                -> MSG IN CASE\n         BNE   BOTCH                    THE DATASET ISNT PARTITIONED\n         MVC   0(3,R13),TTR             SAVE TTR IN CASE NO FIND\n         LTR   R0,R0                    TEST OPERAND LENGTH        LDW1\n         BNP   JUSTM                    NONE, USE LAST MEM         LDW1\n         MVC   MEMBER(8),REP+1          MOVE MEMBER TO FIELD       LDW1\n         XC    TTR(3),TTR               POINT TO BEGINNING OF DIRECT -1\n         SPACE 1\n*        FIND THE MEMBER IN THE DIRECTORY.\n*        READ A DIRECTORY BLOCK.\n         SPACE 1\nMLOOP    BAS   R8,READNBLK              GET NEXT BLK               LDW1\n         CLI   IOERROR,YESSYN           I/O ERROR?\n         BE    NEWDSPNT                 YES, GET OUT\n         L     R3,ADDRKEY               GET BUFFER PTR             LDW1\n         CLC   MEMBER,0(R3)             IN THIS BLOCK?             LDW1\n         BH    MLOOP                    NO, GET NEXT               LDW1\n         LH    R2,8+0(,R3)              GET BLK LEN USED           LDW1\n         BCTR  R2,0                     -1\n         BCTR  R2,0                     AND -2 FOR REAL LEN USED\n         LA    R3,8+2(,R3)              POINT TO REAL BEGIN LOC    LDW1\n         SPACE 1\n*        MEMBER SCAN LOOP WITHIN BLK.\n         SPACE 1\nMLOOP2   CLC   0(4,R3),=XL4'FFFFFFFF'   END OF DIRECTORY?\n         BNE   NOTEND                   NO, THERE'S MORE TO LOOK\nMNF      MVC   TTR(3),0(R13)            PICK UP WHERE HE WAS\n         BAS   R8,SETMSG                MOVE MSG TO RIGHT PLACE    LDW1\n         DC    Y(INVMEM-ZAP)            SAY INV MEMBER (NOT FOUND) LDW1\n         BAS   R8,READBLK               PUT HIM BACK WHERE HE WAS\n         B     NEWDSPNT                 AND GO DISPLAY\n         SPACE 1\n*       NOTE : READBLK WILL RETURN ONLY IF THE USER IS NOT AT AN EOF\n*              IF EOF, SYNAD==>EODAD==>DISPLAY GET EXECUTED, SO THE\n*              MESSAGE MUST BE PRE-SET.\n         SPACE 1\nNOTEND   CLC   0(8,R3),MEMBER           MEMBER HERE?\n         BE    FOUNDM                   YES, GO WORK ON IT\n         BH    MNF                      IF PAST ALPHA SEQ GIVE UP *PCN*\n         BAS   R8,NXTDIRNT              INCR TO NEXT ENTRY         LDW1\n         BNP   MLOOP                    NEG, END BLK - READ ANOTHER\n         B     MLOOP2                   MORE TO GO - KEEP LOOKING\nFOUNDM   MVC   TTR(3),8(R3)             PICK UP MEMBER'S TTR\n         MVC   MEMTTR(3),8(R3)          SAVE IT FOR LATER USE\n         MVC   ESDID,=H'1'              RESET ESDID TO DEFAULT      *N*\n         MVI   IDRFLAG,NOCHGIDR         HAVEN'T CHANGED IDR YET   *LPR*\n         XC    TXTTTR(3),TXTTTR         ASSUME NOT A LOAD MOD       *N*\n         XC    CTL1TTR(3),CTL1TTR       NO 1ST CTL REC YET         MAS2\n         MVC   8(1,R13),11(R3)          FLAGS/LEN FROM DIR ENTRY   MAS2\n         NI    8(R13),B'01100000'       # TTR'S IN USER DATA FILED MAS2\n         CLI   8(R13),B'00100000'       AT LEAST ONE USER TTR?     MAS2\n         BL    FOUNDM1                  BRANCH IF NOT LOAD MODULE  MAS2\n         MVC   8(1,R13),11(R3)          FLAGS/LEN FROM DIR ENTRY   MAS2\n         NI    8(R13),B'00011111'       # H-WORDS USER DATA        MAS2\n         CLI   8(R13),12                AT LEAST 12 H-WORDS?       MAS2\n         BL    FOUNDM1                  BRANCH IF NOT LOAD MODULE  MAS2\n         CLI   DCBRECFM-IHADCB+DCBU,RECFMU   A LOAD MODULE?         *N*\n         BNE   FOUNDM1                  NO, NO TEXT THEN            *N*\n         MVC   TXTTTR(3),12(R3)         YES, SAVE 1ST TEXT BLK TTR  *N*\nFOUNDM1  LA    R1,N0                    POINT TO PROPER NUMBER\n         BAS   R8,SETLINE               SET UP LINE TO PUT\n         B     NEW$READ                 NOT PRINTING, EXIT\n         MVI   0(R2),C'0'               DOUBLE SPACE IT\n         MVC   20(24,R2),=C'MEMBER XXXXXXXX SELECTED'\n         MVC   27(8,R2),MEMBER          FILL IN THE MEMBER IN QUESTION\n         BAS   R8,CPUT                  NOW DUMP THE LINE OUT\n         B     NEW$READ                 GO DO IT\nJUSTM    MVC   TTR(3),MEMTTR            RESTORE START OF MEMBER    LDW1\n         B     NEW$READ                 GET IT                     LDW1\nNXTDIRNT IC    R4,11(,R3)               GET INDICATORS             LDW1\n         N     R4,=X'0000001F'          JUST # USER DATA HALFWORDS LDW1\n         LA    R4,12(R4,R4)             ENTRY LENGTH               LDW1\n         AR    R3,R4                    -> NEXT ENTRY              LDW1\n         SR    R2,R4                    DECR LENGTH REMAINING      LDW1\n         BR    R8                       RETURN WITH CC SET         LDW1\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- NAME.                        *N*\n*        *****  NAME  *****                                         *N*\n         SPACE 1                                                    *N*\nNAME#    BAS   R8,CHKPT                 NEED CHKPT?                 *N*\n         OC    TXTTTR(3),TXTTTR         IS THERE ANY TEXT?          *N*\n         BZ    NAMENFN#                 NO, CAN'T HAVE ESD'S THEN   *N*\n         MVC   NAME(8),MEMBER           ASSUME CSECT IS MODULE    *LPR*\n         LTR   R0,R0                    IS THERE AN ARGUMENT?      LDW1\n         BNP   *+L'*+6                  NO, OK THEN                LDW1\n         MVC   NAME(8),0(R1)            MOVE NAME TO FIELD         LDW1\n         MVI   FLAGESD,0                NO FLAGS YET                *N*\n         SPACE 1\n*        FIND THE ESD'S FIRST.                                      *N*\n         SPACE 1                                                    *N*\n         MVC   0(3,R13),TTR             REMEMBER WHERE WE ARE NOW   *N*\n         MVC   TTR(3),MEMTTR            START LOOKING AT BEGIN MEMB *N*\n         BAS   R8,READBLK               GET 1ST BLK                 *N*\nNAMEFIND L     R1,ADDRDATA              POINT TO RECORD            LDW1\n         TM    0(R1),X'01'              CONTROL REC?                *N*\n         BNO   NAMECHKE                 NO, POSSIBLE ESD OR SYM     *N*\nNAMENFND CLC   TTR(3),0(R13)            NOT FOUND. HAVE WE MOVED?   *N*\n         BE    NAMENFN#                 NO, NO RE-POSITION NECESSRY *N*\n         MVI   TTR+3,NOSEQRD            YES, NO SEQUENTIAL READ     *N*\n         MVC   TTR(3),0(R13)            RESET WHERE WE WERE         *N*\n         BAS   R8,READBLK               PUT US BACK                 *N*\nNAMENFN# LA    R2,NAMEMNF               'INVALID' MSG               *N*\n         B     BOTCH                    OH WELL                     *N*\nNAMECHKE CLI   0(R1),X'20'              ESD?                        *N*\n         BE    NAMEESD                  YES, HAVE ONE, TRY IT       *N*\nNAMEENXT MVI   EOFRET,NOEOF             EOF'S ARE DATA NOW          *N*\n         BAS   R8,READNBLK              GET NEXT BLK               LDW1\n         CLC   LINE05+27(20),EOFMSG     HIT EOF HERE?              LDW1\n         BE    NAMENFND                 YES, NOT FOUND              *N*\n         CLI   IOERROR,YESSYN           I/O ERROR                   *N*\n         BE    NAMENFND                 YES, NOT FOUND              *N*\n         B     NAMEFIND                 NONE, KEEP LOOKING          *N*\nNAMEESD  LH    R15,6(,R1)               GET LEN ESD DATA THIS BLK   *N*\n         LA    R1,8(,R1)                PT PAST ESD PREFIX TO DATA  *N*\n         AR    R15,R1                   PT PAST LAST ESD DATA       *N*\n         USING ESDDATA,R1               ESD ENTRIES                 *N*\nNAMECHK  CR    R1,R15                   PAST END THIS BLK?          *N*\n         BNL   NAMEENXT                 YES, NEXT ESD BLK           *N*\n         CLC   ESDDNAME(8),NAME         NO, NAME MATCH?             *N*\n         BE    NAMEGOT                  YES, WE MIGHT HAVE IT       *N*\nNAMEBNXT LA    R1,ESDDL(,R1)            NEXT ENTRY IN BLK           *N*\n         B     NAMECHK                  KEEP SCANNING BLK           *N*\n         SPACE 1\n*        THE ENTRY POINT EXISTS. FIND THE PLACE IN THE MODULE TEXT. *N*\n         SPACE 1                                                    *N*\nNAMEGOT  NI    ESDDTYPE,255-X'F0'       JUST WANT LOW NIBBLE        *N*\n         CLI   ESDDTYPE,X'02'           EXT REF ENTRY (ER)?         *N*\n         BE    NAMEBNXT                 YES, IGNORE, NEXT ENTRY     *N*\n         CLI   ESDDTYPE,X'0A'           WEAK EXT REF? (WEX)?        *N*\n         BE    NAMEBNXT                 YES, IGNORE, NEXT ENTRY     *N*\n         L     R3,ESDDADDR-1            NO, GET LKED ADDR OF EP     *N*\n         LA    R3,0(,R3)                GET RID OF TYPE BYTE        *N*\n         DROP  R1                       NO MORE ENTRIES             *N*\n         L     R15,ADDRDATA             PT TO ESD BLK PREFIX       LDW1\n         LH    R14,4(,R15)              GET ESDID 1ST NTRY THIS BLK *N*\n         LA    R15,8(,R15)              PT PAST PRFX TO 1ST ENTRY   *N*\n         SR    R1,R15                   OFFSET MTHC ENTRY FROM PRFX *N*\n         XR    R0,R0                    FOR DIVIDE                  *N*\n         D     R0,=A(ESDDL)             GET ESDID REL THIS BLK      *N*\n         AR    R1,R14                   GET ESDID MATCH ENTRY POINT *N*\n         STH   R1,ESDID                 SAVE FOR IDR UPDATE         *N*\n         MVI   TTR+3,NOSEQRD            NO MORE SEQ READ            *N*\n         MVC   TTR(3),CTL1TTR           START AT 1ST CTL RECORD    MAS2\n         OC    TTR(3),TTR               ANY 1ST CTL TTR?           MAS2\n         BNZ   *+L'*+6                  YES, HAVE TTR 1ST CTL REC  MAS2\n         MVC   TTR(3),MEMTTR            ELSE START AT MEMBER       MAS2\n         BAS   R8,READBLK               GET ESD, CTL, IDR RECORD   MAS2\n         NI    FLAGESD,255-FESDTEXT     NEXT BLK IS NOT TEXT       MAS2\nNAME$L1  TM    FLAGESD,FESDTEXT         IS THIS TEXT BLOCK?        MAS2\n         BO    NAME$T1                  BRANCH IF IS TEXT RECORD   MAS2\n         L     R1,ADDRDATA              @ NON-TEXT RECORD          MAS2\n         TM    0(R1),X'01'              CONTROL RECORD?            MAS2\n         BZ    NAME$NX                  NOT CTL REC, TRY NEXT      MAS2\n         OI    FLAGESD,FESDTEXT         NEXT BLK IS TEXT           MAS2\n         OC    CTL1TTR(3),CTL1TTR       HAVE SAVED 1ST CTL TTR?    MAS2\n         BNZ   *+L'*+6                                             MAS2\n         MVC   CTL1TTR(3),TTR           SAVE TTR 1ST CTL REC       MAS2\n         MVC   TXTORIG(4),8(R1)         LKED ORIG NXT BLK (TEXT)   MAS2\n         MVI   TXTORIG,0                CLEAR HIGH BYTE            MAS2\nNAME$NX  MVI   EOFRET,NOEOF             EOF'S ARE DATA              *N*\n         BAS   R8,READNBLK              GET NEXT LOADMOD BLK       LDW1\n         CLC   LINE05+27(20),EOFMSG     EOF?                       LDW1\n         BE    NAMENFND                 OOPS, CAN'T HAPPEN          *N*\n         B     NAME$L1                  CONTINUE SEARCH            MAS2\nNAME$T1  NI    FLAGESD,255-FESDTEXT     NEXT BLK IS NOT TEXT       MAS2\n         LR    R0,R3                    COPY ENTRY ORIGIN          MAS2\n         S     R0,TXTORIG               ENTRY - TXT BLOCK ORIG?    MAS2\n         BM    NAME$NX                  NOT IN NEXT TXT BLK        MAS2\n         CH    R0,BLKLEN                OFFSET IN BLOCK = BLKLEN   MAS2\n         BNL   NAME$NX                  NOT IN NEXT TXT BLK        MAS2\n         SPACE 1                                                   LDW1\n*        WE HAVE THE BLOCK AND OFFSET OF THE ENTRY POINT.           *N*\n*        NOTIFY/DISPLAY.                                            *N*\n         SPACE 1                                                    *N*\n         MVI   TTR+3,NOSEQRD            NO MORE SEQ READS          MAS2\n         LR    R3,R0                    OFFSET INTO BLOCK           *N*\n         LA    R1,N8                    MSG/WTO                     *N*\n         BAS   R8,SETLINE               SET IT UP                   *N*\n         B     NAMEDONE                 NOT PRINTING                *N*\n         MVI   0(R2),C'0'               DBL SPACE                   *N*\n         MVC   20(24,R2),=C'MEMBER XXXXXXXX SELECTED'  FOR SPACE    *N*\n         MVC   20(6,R2),=CL6'ENTRY'     MEMBER=ENTRY                *N*\n         MVC   27(8,R2),NAME            MOVE ENTRY NAME IN          *N*\n         BAS   R8,CPUT                  DO IT                       *N*\nNAMEDONE LR    R15,R3                   GET OFFSET INTO BLOCK       *N*\n         MVI   IDRFLAG,NOCHGIDR         HAVEN'T CHANGED IDR YET    LDW1\n         B     SETPOINT                 SIMULATE A '+' COMMAND      *N*\n         SPACE 2\n*        ZAP --- COMMAND EXECUTION --- NOTE, EJECT.                MAS2\n*        *****  NOTE  *****\n         SPACE 1\nNOTE     BAS   R8,LOGTEST                                          LDW1\n         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES\n         L     R2,CSOUTWK               FIND WORKAREA\n         LTR   R2,R2                    ANY THERE?\n         BZ    BADCSOUT                 NO, TELL HIM SORRY         LDW1\n         L     R2,0(,R2)                FIND THE NEXT LINE IMAGE\n         MVC   1($L-4,R2),REP+4         COPY NOTATION TO BUFFER    LDW1\n         MVI   ENQIT,255                FORCE IT TO BE ENQUEUED\n         MVI   0(R2),C'0'               DOUBLE SPACE NOTES\n         BAS   R8,CPUT                  DUMP THIS LINE NOW\n         B     NEWDSPNT                 THEN CONTINUE ON MERRY WAY\nBADCSOUT LA    R2,NOCSOUT               TELL HIM CAN'T ENQ\n         B     BOTCH                    BYE\n         SPACE 1                                                   LDW1\n*        *****  EJECT  *****\n         SPACE 1\nEJECT    BAS   R8,LOGTEST                                          LDW1\n         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES\n         L     R2,CSOUTWK               GET THE WORKAREA PTR\n         LTR   R2,R2                    IS THERE ONE?\n         BZ    BADCSOUT                 NO, GIVE UP ON THIS ENDEAVOR\n         L     R2,0(R2)                 FIND THE NEXT LINE IMAGE\n         MVI   0(R2),C'1'               PAGE EJECT\n         MVI   ENQIT,255                FORCE ENQ TO PRINT\n         BAS   R8,CPUT                  DO IT\n         B     NEWDSPNT                 ALL DONE\n         EJECT\n*        ZAP --- UTILITY BAS ROUTINES.\n         SPACE 1\n*  ROUTINES INCLUDE :\n*  ------------------\n*  CLEAR........CLEAR SCREEN\n*  READBLK......GET A DATA BLOCK\n*  CALLEXP......CALL EXP TO PARSE EXPR, CHECK ERROR RETURNS        LDW1\n*  HEXCHECK.....VALIDITY CHECK HEX\n*  GETSTRNG.....VALIDITY CHECK AND PARSE HEX/CHAR STRING\n*  NUMCONV......CONVERT A NUMBER TO HEX AND SIGNED DECIMAL         LDW1\n*  CSIO.........PRIMARY SCREEN DISPLAY\n*  CSIO#........SECONDARY SCREEN DISPLAY\n*  PUTLINE......PUTLINE 1 LINE TO TERMINAL                         LDW1\n*  TTRPARSE.....PARSE OUT SPECIFIED TTR\n*  PREPDUMP.....PREPARE FOR DUMP - GET BLOCK, PRINT HEADER LINE\n*  DUMPER.......DUMP A BLOCK IN DUMP FORMAT\n*  CLEARDEF.....RESET DEFINE TABLE\n*  CLOSE........CLOSE DATASET\n*  WRITE........EXCP WRITE OUT A BLK\n*  OPENMSG......GIVE PRINT FILE MSG OF DATASET OPEN\n*  CPUT.........ENQ TO PRINT AN OUTPUT LINE\n*  SETLINE......SET UP THE OUTPUT LINE FOR CPU\n*  SETSTRNG.....CONVERT VARIOUS CONSTANTS FOR CPUT\n*  SETMSG.......MOVE INFO MSG TO CORRECT PLACE ON SCREEN           LDW1\n*  BOTCH........DISPLAY ERROR MESSAGES\n*  EODAD........END OF FILE EXIT (SYNAD)\n*  CHKPT........CHECK IF ZAP NEEDED.  IF SO IGNORE COMMAND PENDING\n*  INIT3270.....TURN ON  3270 MODE CONSOLE I/O                     LDW1\n*  KILL3270.....TURN OFF 3270 MODE CONSOLE I/O                     LDW1\n         EJECT\n* * * * * * * * CLEAR * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*        CLEAR THE SCREEN BUFFER EXCEPT FOR ERROR AND I/O ERROR LINES.\n         SPACE 1\nCLEAR    LA    R15,LINE01-2             -> START                   SDM5\n         LA    R0,3                     NUMBER OF LINES            SDM5\n         BAS   R14,CLEARX               CLEAR 1-3                  SDM5\n         LA    R15,LINE06-2             -> START                   LDW1\n         LA    R0,13                    NUMBER OF LINES            LDW1\n         BAS   R14,CLEARX               CLEAR 6-18                 LDW1\n         LA    R15,LINE20-2             -> START                   LDW1\n         LA    R0,2                     NUMBER OF LINES            LDW1\n         BAS   R14,CLEARX               CLEAR 20-21                LDW1\n         MVI   LINE02-1,X'C8'           UNPROT HIGH                LDW1\n         XC    LINE02,LINE02            NULLS FOR THIS ONE         SDM5\n         MVC   LINE05-2(2),=X'1DE8'     I/O ERRMSG LINE (PROT HIGH)SDM5\n         MVC   LINE19-2(2),=X'1DE8'     AND OTHER ERRMSG LINE      SDM5\n         MVC   REP-2(2),LINE02-2        UNPROT HIGH                LDW1\n         BR    R8                       RETURN TO CALLER\n         SPACE 1\n*  X... ....  SET TO MAKE VALID CHAR                               LDW1\n*  .1.. ....  MUST BE 1                                            LDW1\n*  ..1. ....  PROT                                                 LDW1\n*  ...1 ....  NUMERIC                                              LDW1\n*  ..11 ....  AUTOSKIP                                             LDW1\n*  .... 00..  DISPLAY / NOT SELECTOR PEN DETECTABLE                LDW1\n*  .... 01..  DISPLAY / DETECTABLE                                 LDW1\n*  .... 10..  HIGH INTENSITY / DETECTABLE                          LDW1\n*  .... 11..  NO DISPLAY / NOT DETECTABLE                          LDW1\n*  .... ..0.  MUST BE 0                                            LDW1\n*  .... ...1  MDT FLAG                                             LDW1\n         SPACE 1\nCLEARX   MVC   0(2,R15),=X'1D60'        PROT AUTOSKIP LOW          LDW1\n         MVC   2($L,R15),BLANKS         BLANK THE LINE             LDW1\n         LA    R15,$I(,R15)             -> NEXT LINE               LDW1\n         BCT   R0,CLEARX                CONTINUE                   LDW1\n         BR    R14                      DONE THIS SECTION          LDW1\n         SPACE 1\n* * * * * * * * READBLK * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*        EXCP READ A BLOCK (PHYSICAL RECORD) INCLUDING KEY (IF ANY).\n*        IF TTR+3 CONTAINS A 1 (FLAG) THEN READ SEQUENTIALLY,\n*        SIMULATING BSAM.\n         SPACE 1\nREADNBLK MVI   TTR+3,SEQREAD            SET NEXT BLOCK FLAG        LDW1\nREADBLK  NI    FLAGS2,255-ATTNHIT       NO ATTN YET                LDW1\nREADBLK2 MVI   IOERROR,NOSYN            START WITH NO I/O ERROR\n         ST    R8,DBLW                  SAVE RETURN ADDR           LDW1\n         BAS   R8,CHKPT                 SEE IF HE CAN LEAVE        LDW1\n         CLI   TTR+3,SEQREAD            DO BLOCK +1?\n         BNE   READBLK#                 NO\n         IC    R15,TTR+2                GET RECORD NO\n         LA    R15,1(R15)               NEXT RECORD\n         STC   R15,TTR+2                NEXT ONE\nREADBLK# MVC   LINE05,BLANKS            CLEAR I/O ERR MSG IF ANY   LDW1\n         CLI   CHNGED,0                 BUFFER TAMPERED WITH W/O CHKPT?\n         BE    NORDBMSG                 NO, ITS OK TO READ THEN\n         MVI   CHNGED,0                 WELL IT'LL BE CLEAN NOW\n         NI    FLAGS2,255-MUSTZAP       NEW BLOCK, NO ZAP NEEDED YET\n         LA    R1,N4                    MSG NUMBER\n*LDW1    ST    R8,DBLW                  SAVE FOR LATER\n         BAS   R8,SETLINE               SETUP THE LINE\n         B     NORDBMSG                 NOT PRINTING               LDW1\n         MVC   31(18,R2),=C'BLOCK NOT REPLACED'\n         MVI   0(R2),C'0'               DOUBLE SPACE\n         HEX   (24,R2),OLDTTR,LEN=3     DIFF TTR THIS TIME         LDW1\n         BAS   R8,CPUT                  DUMP THE LINE\nNORDBMSG L     R8,DBLW                  RESTORE RET REG            LDW1\n         XC    BLKLEN(2),BLKLEN         ASSUME NOTHING READ        LDW1\n         LA    R15,CCW##R               -> CCW CHAIN               LDW1\n         CLI   TTR+2,0                  R0?                        LDW1\n         BNE   *+L'*+4                  NO, OK                     LDW1\n         LA    R15,CCW##R0              READ R0                    LDW1\n         ST    R15,IOBCCWA              SET IN IOB                 LDW1\n         L     R0,TTR                   GIVE HIM THE TTRN          LDW1\n         N     R0,=X'FFFFFF00'          MAKE IT A TTRN             LDW1\n         L     R1,DCBDEBAD+DCBU-IHADCB  GIVE HIM THE DEB           LDW1\n         LA    R2,MBBCCHHR              GIVE HIM A WORKAREA FOR IT LDW1\n         STM   R8,R12,52(R13)           SAVE SOME REGISTERS        LDW1\n         LR    R8,R13                   SAVE PTR TO SAVEAREA       LDW1\n         L     R15,CVTPTR               CVT PTR                    LDW1\n         L     R15,CVTPCNVT-CVT(,R15)   POINT TO THE ROUTINE       LDW1\n         BASR  R14,R15                  GO DO IT                   LDW1\n         LR    R13,R8                   RESTORE PTR TO SAVE AREA   LDW1\n         LM    R8,R12,52(R13)           RESTORE THE DEAD REGS      LDW1\n         LTR   R15,R15                  OUT OF DS?                 LDW1\n         BNZ   EXCP42                   YES, DON'T BOTHER READING  LDW1\n         IC    R1,CCHHR+4               GET \"R\"                    LDW1\n         BCTR  R1,0                     -1 FOR SEARCH ID           LDW1\n         STC   R1,CCHHR+4               SET BACK                   LDW1\n         EXCP  IOB                                                 LDW1\n         WAIT  ECB=ECB                                             LDW1\n         MVC   CCHHR+4(1),TTR+2         RESTORE \"R\"                LDW1\n         LH    R2,BUFFSIZE              GET BUFSIZ (MAX READ=BLKSI)LDW1\n         SH    R2,CSW+6                 =AMOUNT READ               LDW1\n         LR    R0,R2                    COPY 8+KL+DL               LDW1\n         SH    R0,=H'8'                 GET KEYLEN+DATALEN         LDW1\n         STH   R0,CCW#W#W+6             SAVE IT FOR LATER USE      LDW1\n         L     R1,ADDRCNT               -> COUNT                   LDW1\n         MVC   KEYLEN+1(1),5(R1)        SET UP KEYLEN              LDW1\n         LH    R15,KEYLEN               GET KEYLEN                 LDW1\n         LA    R0,8(R1,R15)             -> DATA                    LDW1\n         ST    R0,ADDRDATA              SET ADDR OF DATA           LDW1\n         CLC   ADDRBUFF,ADDRKEY         HOW MUCH DO WE DISPLAY?    LDW1\n         BL    SAVE$LEN                 COUNT + KEY + DATA         LDW1\n         BE    *+L'*+2                  KEY + DATA                 LDW1\n         SR    R2,R15                   JUST DATA                  LDW1\n         SH    R2,=H'8'                 NOT COUNT FIELD            LDW1\nSAVE$LEN STH   R2,BLKLEN                SAVE IT FINALLY            LDW1\n         SPACE 1\n*        NOW CHECK THE READ, FINALLY...                            LDW1\n         SPACE 1\n         CLI   ECB,X'7F'                OK?                        LDW1\n         BE    EXCPOK                                              LDW1\n         CLI   ECB,X'42'                END OF EXTENT              LDW1\n         BE    EXCP42                                              LDW1\n         CLI   ECB,X'41'                PERM ERROR?                LDW1\n         BE    EXCP41                                              LDW1\nREALERR  LA    R1,=CL15' TYPE UNKNOWN  '  GET MSG ADDR             LDW1\nEXCPERR  XR    R0,R0                    GET A ZERO                 LDW1\n         STH   R0,BLKLEN                NOTHING WAS READ           LDW1\n         STH   R0,CCW#W#W+6             AND NOTHING TO WRITE.      LDW1\nEXCPERR$ MVI   IOERROR,YESSYN           AND IT WAS IN ERROR        LDW1\n         MVC   LINE05+17(40),IOERRMSG   MOVE IN MASK               LDW1\n         MVC   LINE05+35(15),0(R1)      MOVE IN ERROR MSG          LDW1\n         MVI   TTR+3,NOSEQRD            TURN OFF SEQ READ FLAG     LDW1\n         BR    R8                                                  LDW1\nEXCP42   LA    R1,=CL15'NOT IN DATA-SET'  GET MSG ADDR             LDW1\n         B     EXCPERR                                             LDW1\nEXCP41   TM    CSW+4,X'01'              UNIT EXCEPTION?            LDW1\n         BO    EODAD                    YES, EOF                   LDW1\n         TM    IOB+3,X'08'              NRF?                       LDW1\n         BNO   NOT$NRF                  NO                         LDW1\nEXCP$NRF CLI   TTR+3,SEQREAD            NEXT BLOCK REQ?            LDW1\n         LA    R1,=CL15'NO RECORD FOUND'  GET MSG ADDR IN CASE     LDW1\n         BNE   EXCPERR                                             LDW1\n         LH    R15,TTR                  GET TRACK                  LDW1\n         LA    R15,1(,R15)              NEXT TRACK                 LDW1\n         STH   R15,TTR                  SAVE IT                    LDW1\n         MVI   TTR+2,1                  RECORD 1                   LDW1\n         MVI   TTR+3,NOSEQRD            RESET SEQ READ FLAG        LDW1\n         B     READBLK2                 GO REREAD                  LDW1\nNOT$NRF  TM    CSW+5,X'40'              INCORRECT LENGTH?          LDW1\n         BNO   REALERR                  NO, SOMETHING ELSE         LDW1\n         LA    R1,=CL15'INCORR. LENGTH '  GET MSG ADDR             LDW1\n         B     EXCPERR                  GO SAY INCORRECT LENGTH    LDW1\nEXCPOK   L     R15,ADDRCNT              -> COUNT                   LDW1\n         CLC   CCHHR(5),0(R15)          RIGHT RECORD?              LDW1\n         BE    EXCPOK$                  YES, CONTINUE              LDW1\n         LA    R1,=CL15'CCHHR INCORRECT'  GET MSG ADDR IN CASE     LDW1\n         CLC   CCHHR(4),0(R15)          RIGHT CCHH?                LDW1\n         BNE   EXCPERR$                 NO, ARRGH                  LDW1\n         CLI   4(R15),1                 IS IT R1?                  LDW1\n         BE    EXCP$NRF                 YES, IT'S REALLY NRF       LDW1\n         B     EXCPERR$                 NO, ARRGH                  LDW1\nEXCPOK$  MVI   TTR+3,NOSEQRD            TURN OFF SEQ READ FLAG     LDW1\n         OC    CSW+6(2),CSW+6           ANY RESIDUAL?              LDW1\n         LA    R1,=CL15'BLKLEN > BUFFSZ'   -> MSG IN CASE          LDW1\n         BZ    EXCPERR$                 NO, ERROR                  LDW1\n         TM    FLAGS2,ATTNHIT           WAS ATTN SIGNALED LATELY?  LDW5\n         BNOR  R8                       NO, ALL DONE, RETURN BLK\n         BAS   R8,CLEAR                 YES, CLEAR SCREEN\n         MVC   LINE19+17(40),=CL40'         *****  HOLDING  ******'\n         B     SETPNT00                 DISP OFF 0, CURR BLK       LDW1\n         SPACE 1\n* * * * * * * * CALLEXP * * * * * * * * * * * * * * * * * * * * *  LDW1\n         SPACE 1\n*        CALL EXP, CHECK ERROR RETURNS.                            LDW1\n*              R1 -> STRING.                                       LDW1\n*              R0  = LENGTH.                                       LDW1\n*              R8  = RETURN ADDRESS.                               LDW1\n*                    NOTE : CC IS SET ACCORDING RESULT'S SIGN.     LDW1\n         SPACE 1\nCALLEXP  LR    R2,R15                   COPY \"*\" VALUE             LDW1\n         L     R15,=A(EXP)              -> ROUTINE                 LDW1\n         BASR  R14,R15                  CALL IT                    LDW1\n         LTR   R1,R1                    WORK?                      LDW1\n         BNM   INVEXPER                 NO                         LDW1\n         SLL   R1,1                     YES                        -EU-\n         SRL   R1,1                     NEGATIVE BIT CLEARED       -EU-\n         LTR   R15,R15                  SET CC                     LDW1\n         BR    R8                       RETURN TO CALLER           LDW1\n         SPACE 1\n* * * * * * * * HEXCHECK  * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*        VALIDITY CHECK FOR HEXADECIMAL, DECIMAL, OR CHARACTER.\n*              R7 = POINTER TO STRING.\n*              R1 = LENGTH OF STRING.\n*              R8 = RETURN ADDRESS.\n*                   NOTE : 0(R8)=GOOD HEX, 4(R8)=BAD HEX AT 0(R7).\n*              R15 = 0 IF PURE DECIMAL UP TO EXIT, 4 IF HEX.\n         SPACE 1\nHEXCHECK XR    R15,R15                  ASSUME DECIMAL\nHEXCHK   TM    0(R7),X'F0'              NUMBER?\n         BO    OKHEX                    YES, ITS OK\n         CLI   0(R7),C'A'               LESS THAN ALPHA?\n         BL    4(R8)                    YES, MUST BE CHARACTER\n         CLI   0(R7),C'F'               'F' OR SMALLER?\n         BH    4(R8)                    NO, MUST BE CHARACTER\n         LA    R15,4                    INDICATE HEX (NOT DECIMAL)\nOKHEX    LA    R7,1(R7)                 SO FAR SO GOOD, UPDATE HEX PTR\n         BCT   R1,HEXCHK                DO THE WHOLE STRING\n         BR    R8                       WE'RE OK - ALL DONE\n         SPACE 1\n* * * * * * * * GETSTRNG  * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*        PARSE OUT HEX OR CHARACTER STRING FOR S, X, O, N, L AND\n*        SET COMMS. DETERMINE STRING LENGTH AND STRING ITSELF,\n*        AND SAVE BOTH IN AREA.\n*        IF DECIMAL - A FULLWORD IS STORED (< 2147483647.).\n*        IF HEXADECIMAL - UP TO 16 DIGITS (DOUBLEWORD) MAY BE STORED.\n*        IF CHARACTER - ANY DELIMITERS MAY SURROUND THE STRING EXCEPT\n*                       STRING EXCEPT HEX DIGITS) AND UP TO 16 CHAR\n*                       (2 DOUBLE-WORDS) MAY BE STORED.\n*              R3 = ACTUAL LENGTH OF STRING TO BE PARSED.\n*              R4 = PTR TO THE STRING ITSELF.\n*              R5 = PTR TO STRING SAVEAREA (1ST BYTE = LEN).\n         SPACE 1\nGETSTRNG LA    R1,1                     LEN OF HEX TO BE CHECKED\n         LR    R7,R4                    LOC OF HEX TO BE CHECKED\n         BAS   R8,HEXCHECK              DO IT\n         B     HEXSTR                   FIRST CHAR HEX - SO HEX STRING\n         SPACE 1\n*        CHARACTER STRING.\n         SPACE 1\n         CH    R3,=H'18'                STRING LONGER THAN 16 CHARS?\n         BH    LENERROR                 YES, SAY LENGTH ERROR      LDW1\n         XC    TEMPTRT(256),TEMPTRT     CLEAR OUT TRTAB\n         XR    R1,R1                    CLEAR OUT WORK REG\n         IC    R1,0(,R4)                GET DELIM FOR CHAR STRING\n         STC   R1,TEMPTRT(R1)           PUT IT IN RIGHT PLACE IN TRTAB\n         SH    R3,=H'2'                 GET ADJUST STRING LEN (DELIMS)\n         BNP   LENERROR                 HE ENTERED S'' OR LESS - ERROR\nDELIMTRT TRT   1(0,R4),TEMPTRT          << EXECUTED >>\n         EX    R3,DELIMTRT              FIND THE OTHER DELIMITER\n         LA    R2,=CL20'NO ENDING DELIMITER'   GET MSG ADDR IN CASE\n         BZ    BOTCH                    NO, TELL HIM               LDW1\n         LA    R3,1(,R4)                PT TO BEGINNING OF STRING\n         SR    R1,R3                    GET STRING LEN (NO DELIMS)\n         LR    R3,R1                    PUT IN RIGHT REG\n         BCTR  R3,0\n         LTR   R3,R3                    NULL INPUT?\n         BM    LENERROR                 YES, SAY LENGTH ERROR\n         LR    R1,R4                                               -EU-\n         CLI   CAPSFLG,YESCAPS                                     -EU-\n         BE    SKCAPS                                              -EU-\n         LA    R0,TEMP2                                            -EU-\n         SLR   R4,R0                                               -EU-\n         LA    R4,ICREP(R4)                                        -EU-\nSKCAPS   EX    R3,CHARMVC               MOVE STRING CHARS TO AREA  -EU-\n         LR    R4,R1                                               -EU-\n         B     FINSTR                   GO FINISH THE JOB\nCHARMVC  MVC   2(0,R5),1(R4)            << EXECUTED >>             LDW1\nLENERROR LA    R2,LENERR                YES, SAY LENGTH ERROR\n         B     BOTCH                    GO TELL HIM\n         SPACE 1\n*        HEX STRING.\n         SPACE 1\nHEXSTR   CH    R3,=H'16'                HEX STRING LONGER THAN 16?\n         BH    LENERROR                 YES, SAY LENGTH ERROR\n         LR    R1,R3                    PUT IT IN RIGHT REG FOR CHECK\n         LR    R7,R4                    POINT TO LOC TO CHECK\n         BAS   R8,HEXCHECK              CHECK THE HEX\n         B     OK1#                     ITS GOOD\n         CLI   0(R7),C' '               IS IT HEX?\n         BE    OK1#                     YES, GO DO IT\n         CLI   0(R7),C'.'               DECIMAL?\n         BE    DECMAYBE                 MAYBE SO\n         LA    R2,=CL20'INVALID HEXADECIMAL'   IT'S BAD - PT TO MSG\n         B     BOTCH                    TELL HIM\nOK1#     TR    0(16,R4),TRHEX           YES, START TO CONVERT TO HEX\n         CH    R3,=H'15'                IS THIS THE MAX CASE?\n         BL    HEXPACK                  NO, DO JUST ENOUGH\n         PACK  TEMP(5),0(9,R4)          PACK FIRST GROUP\n         PACK  TEMP+4(5),8(9,R4)        PACK SECOND GROUP\n         BH    HEX16                    SKIP IF 16 DIGITS          LDW1\n         LM    R14,R15,TEMP             GET THE RESULT             LDW1\n         SRDL  R14,4                    DOWN 1 NIBBLE              LDW1\n         STM   R14,R15,TEMP             RESTORE IT CORRECTLY       LDW1\nHEX16    LA    R3,7                     NUMBER OF BYTES (EX LEN)\n         MVC   2(8,R5),TEMP             GET HEX                    LDW1\n         B     FINSTR                   AND THEN RETURN TO CALLER\n         SPACE 1\n*        R3 IS NOT BCTRED BECAUSE WE NEED A FLIP BYTE ON THE END.\n         SPACE 1\nHEXPACK  PACK  TEMP(8),0(0,R4)          << EXECUTED >>\n         EX    R3,HEXPACK               PACK TO MAKE REAL HEX\n         LA    R3,1(,R3)                ROUND UP ...\n         SRL   R3,1                     AND FIND NUMBER OF BYTES\n         LA    R15,TEMP+7               POINT TO GORF BYTE\n         SR    R15,R3                   POINT TO FIRST BYTE\n         BCTR  R3,0                     GET EXECUTE LENGTH\nMOVEHEX  MVC   2(0,R5),0(R15)           << EXECUTED >>             LDW1\n         EX    R3,MOVEHEX               MOVE HEX TO OUTPUT LOCATION\nFINSTR   STH   R3,0(,R5)                SAVE THE LEN IN SCAN AREA  LDW1\n         BR    R6                       RET TO CALLER\n         SPACE 1\n*        DECIMAL STRING.\n         SPACE 1\nDECMAYBE BXLE  R15,R15,DECOK            IF REALLY DECIMAL - JUMP\n         LA    R2,INVDEC                NO, TELL HIM SO BECAUSE...\n         B     BOTCH                    ITS GOT A-F IN IT\nDECOK    CH    R3,=H'10'                APPROACHING LEN ERR (BCTR'D)?\n         BL    DECOK#                   NO, DON'T WORRY ABOUT IT\n         CLC   0(11,R4),=C'2147483647.' TOO BIG FOR FULLWORD?\n         BH    LENERROR                 YES, TELL HIM AND GET OUT\nDECPACK  PACK  TEMP(8),0(0,R4)          << EXECUTE >>\nDECOK#   LA    R0,1(R4)                 POINT TO STRING + 1 FOR TO....\n         SR    R7,R0                    GET EXECUTE LENGTH\n         EX    R7,DECPACK               PACK UP YOUR DECIMALS IN ...\n*        COMMENT TYPE=CONTINUED         IN YOUR OLD DOUBLE WORD\n         CVB   R1,TEMP                  AND CONVERT, CONVERT, CONVERT\n         ST    R1,TEMP                  SAVE IN ALIGNED PLACE\n         MVC   2(4,R5),TEMP             COPY TO OUTPUT STRING      LDW1\n         MVI   1(R5),3                  EXECUTE LENGTH             LDW1\n         BR    R6                       RETURN\n         SPACE 1\n* * * * * * * * NUMCONV * * * * * * * * * * * * * * * * * * * * *  LDW1\n         SPACE 1\n*              R15 = NUMBER TO BE CONVERTED.                       LDW1\n*              R14 = RETURN ADDRESS.                               LDW1\n*                    NUMBER IS CONVERTED TO 12 SIGNED DECIMAL      LDW1\n*                    DIGITS AT TEMP2, AND TO HEX AT TEMP2+12       LDW1\n*                    (8 CHARS).                                    LDW1\n         SPACE 1\nNUMCONV  ST    R15,TEMP                 SET FOR UNPK               LDW1\n         UNPK  TEMP2+12(8+1),TEMP(4+1)                             LDW1\n         TR    TEMP2+12(8),TRHEX        MAKE EBCDIC                LDW1\n         CVD   R15,TEMP                 GET IN PACKED FORM         LDW1\n         LA    R1,TEMP2+11              INIT LOC FOR FLOATING SIGN LDW1\n         MVC   TEMP2(12),EDMASK         MOVE IN EDIT MASK          LDW1\n         EDMK  TEMP2(12),TEMP+2         GET 11 DECIMAL DIGITS      LDW1\n         LTR   R15,R15                  IS IT NEGATIVE?            LDW1\n         BNMR  R14                      NO, ALL DONE               LDW1\n         BCTR  R1,0                     YES, SO BACK UP AND...     LDW1\n         MVI   0(R1),C'-'               ...PUT IN THE SIGN         LDW1\n         BR    R14                      NOW DONE                   LDW1\n         SPACE 1\n* * * * * * * * CSIO  * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*        MAIN SCREEN DISPLAY.\n*        CREATE TRACE TABLE ENTRY IF NECESSARY.\n*        DISPLAY WITH TPUTS FOR NOW.\n         SPACE 1\nCSIO     MVC   PREVREP,REP              SAVE FOR TWICE TEST        LDW4\n         TM    TRACE,NOTRACE            TRACE FOR THIS GUY?\n         BO    NOTRACIT                 NO, SO DONT\n         SPACE 1\n*        MAKE THE TRACE TABLE ENTRY.\n         SPACE 1\n         L     R1,ITRAVAL               PICK UP NEXT SPOT IN TABLE\n         CLI   0(R1),X'FF'              END?\n         BNE   MORETAB                  NO, THERE'S MORE\n         L     R1,AITRCTAB              YES, START OVER AT TOP     LDW1\n         ST    R1,ITRAVAL               AND RESET AVAIL POS PTR\nMORETAB  MVC   0(3,R1),TTR              MOVE TTR TO TABLE\n         MVC   3(2,R1),OLDPOINT         AND OFFSET TOO\n         ST    R1,CURRITR               SAVE PTR TO CURR TRACE ENTRY\n         LA    R1,5(,R1)                UPDATE AVAIL PTR\n         ST    R1,ITRAVAL               SAVE IT\nNOTRACIT MVI   TRACE,YESTRACE           MAKE IT TRACE AGAIN\n         TM    FLAGS3,NODISPF           DISPLAY SUPPRESSED ?       SDM6\n         BO    NOTSHORT                 YES, DON'T FIX STUFF TWICE SDM6\n         CLI   LINELEN+1,80             SHORT LINES?               LDW1\n         BE    NOTSHORT                 NO, OK AS IS               LDW1\n         MVC   LINE01($L-17),LINE01+17  SHIFT INFO LINES OVER      SDM5\n         MVC   LINE05($L-17),LINE05+17  SHIFT INFO LINES OVER      LDW1\n         MVC   LINE19($L-17),LINE19+17  SHIFT INFO LINES OVER      LDW1\n         MVC   LINE20($L-17),LINE20+17  SHIFT INFO LINES OVER      LDW1\n         MVC   LINE21($L-17),LINE21+17  SHIFT INFO LINES OVER      LDW1\nNOTSHORT TM    FLAGS3,F3270             FULLSCREEN?                LDW5\n         BO    CSIO3270                 YES, GO TO HIS STUFF       SDM6\n         TM    FLAGS3,NODISPF           DISPLAY SUPPRESSED ?       SDM6\n         BO    TGET                     MAKE IT SIMPLE, STUPID     SDM6\n         TM    FLAGS3,CRTF              CRT MODE?                  LDW5\n         BZ    NOFORMFD                 NO, DON'T CLEAR THE SCREEN LDW1\n         TPUTX =X'0C',1,CONTROL         CLEAR THE SCREEN           LDW1\nNOFORMFD LA    R6,$I                    BXLE INCR                  LDW1\n         LA    R1,LINE05                TPUT I/O ERROR MSG\n         BAS   R14,PUTLINE              (IF ANY)                   LDW1\n         L     R5,MIDLINE               ADDR OF CARET\n         LTR   R5,R5                    ANY CARET (BLK DISPLAY?)\n         BNZ   DOWINDOW                 YES, WINDOW SCREEN\n         LA    R3,LINE06                NO, FULL SCR, BEGIN\n         LA    R5,LINE18                END (BXLE)\n         B     DUMPSCR                  DUMP IT\n         SPACE 1\n*        CREATE TSO SCREEN WINDOW. DEFAULT SIZE IS ONLY CARET LINE.\n*        THE 'W' COMMAND CHANGES IT TILL NEXT 'W' COMMAND. LINES\n*        ABOVE AND BELOW 'CARET' LINE ARE SPECIFIED. THIS ALLOWS\n*        FEWER LINES FOR HARDCOPY TERMINALS. EG :\n*        D,U ... U LINES ABOVE, CARET LINE, D LINES BELOW.\n*        ,U .... U LINES ABOVE, CARET LINE, PREVIOUS D LINES BELOW.\n*        D|D, .. PREVIOUS U LINE ABOVE, CARET LINE, D LINES BELOW.\n         SPACE 1\nDOWINDOW S     R5,FIRSTSCR              OFFSET TO SCREEN CARET\n         XR    R4,R4                    DIVIDE\n         DR    R4,R6                    LINE NUMBER CARET\n         LR    R3,R5                    SAVE IT\n         S     R3,WIDTHU                BACK UP 'U' LINES <UP>\n         BNM   *+L'*+2                  SKIP IF OK\n         XR    R3,R3                    TOO FAR, MAKE IT TOP OF BUFF\n         A     R5,WIDTHD                GO DOWN 'D' LINES <DOWN>\n*LDW1    L     R0,MAXWIDTH              MAX LINE NUM\n*LDW1    BCTR  R0,0                     -1 FOR OFFSET\n         LA    R0,(LINE19-LINE06)/2     GET MAX # OF LINES         LDW1\n         CR    R5,R0                    BOTTOM TOO HIGH\n         BNH   *+L'*+2                  NO\n         LR    R5,R0                    YES, MAKE IT MAX LINE#\n         MR    R2,R6                    GET OFFSET TO TOP LINE\n         MR    R4,R6                    GET OFFSET TO BOTT LINE\n         A     R3,FIRSTSCR              POINT TO TOP\n         A     R5,FIRSTSCR              POINT TO BOTTOM\nDUMPSCR  LR    R4,R6                    GET LENGTH IN BXLE REG\n         SPACE 1\n*        R3=BEGIN, R4=LEN, R5=END.\n         SPACE 1\nTPUTL    LR    R1,R3                    COPY LINE ADDR             LDW1\n         BAS   R14,PUTLINE              PRINT IT IF NOT BLANK      LDW1\n         BXLE  R3,R4,TPUTL\n         LA    R2,LINE19                POSSIBLE MSGS BELOW WINDOW\n         LA    R3,3                     3 LINES\nTPUTL2   LR    R1,R2                    COPY LINE ADDR             LDW1\n         BAS   R14,PUTLINE              PRINT IT IF NOT BLANK      LDW1\n         AR    R2,R6                    DO ALL\n         BCT   R3,TPUTL2\nTGET     MVI   TSECB,0                  RESET ECB                  LDW1\n         MVC   PGPB(PGPBDCL),PGPBDC     INIT PARM BLOCK\n         NI    FLAGS2,255-ATTNHIT       RESET FLAG                 LDW1\n         L     R15,IKJPTGT              ADDR OF LOADED PUTGET\n         PUTGET PARM=PGPB,MF=(E,IOPL),ENTRY=(15)\n         LA    R14,8                                               LDW1\n         CR    R15,R14                                             LDW1\n         BL    *+L'*+12 >============+                             LDW1\n         BE    TGET                  |  ATTN, TRY AGAIN            LDW1\n         EX    0,*                   |                             LDW1\n         B     TGET                  |  RESUME IF TEST RESTARTS ME LDW1\n         NI    FLAGS3,255-NODISPF <==+  STOP SUPPRESSING DISPLAY   SDM6\n         L     R1,PGPBIBUF              POINT TO INPUT LINE\n         LH    R15,0(,R1)               GET LENGTH OF BUFFER\n         SH    R15,=H'4'                GET LENGTH OF REPLY\n         STH   R15,READLEN              SAVE REPLY LNTH\n         BZ    TGET1                    IF NO REPLY SKIP MOVE TO REPLY\n         CH    R15,=Y($L)               COMPARE WITH MAX           LDW1\n         BNH   TGET0                    OK\n         LH    R15,=Y($L)               USE MAX                    LDW1\n         STH   R15,READLEN              SAVE IT\nTGET0    MVC   REP,BLANKS               PRE-BLANK THE BUFFER       LDW5\n         BCTR  R15,0                    DECREMENT FOR EXECUTE\n         MVC   REP(*-*),4(R1)           EXECUTED\n         EX    R15,*-6                  MOVE IN THE REPLY\nTGET1    LH    R15,0(,R1)               GET LNTH AGAIN\n         LA    R0,1                     GET SP\n         SLL   R0,24                    SHIFT INTO PLACE\n         AR    R0,R15                   ADD IN LENGTH\n         FREEMAIN R,LV=(0),A=(1)\n         LH    R1,READLEN               GET REPLY LENGTH\n         MVC   LINE19,BLANKS            CLEAR ERROR MSG IF ANY     LDW1\n         XC    MIDLINE,MIDLINE          NO CARET LINE NOW\n         BR    R8                       YES, PARSE IT\n         SPACE 1                                                   LDW3\n*        THIS HUNK OF CODE MOVE DOWN HERE                          SDM6\n*        FROM SOMEWHERE IN \"DISPLAY\".                              SDM6\n         SPACE 1                                                   LDW3\nCSIO3270 TM    FLAGS3,FSMODE            IS FSMODE ON ?             LDW5\n         BO    CSIOINIT                 YES, THAT'S GOOD           LDW5\n         STFSMODE  ON                   SET 3270 FULLSCREEN MODE   LDW1\n         OI    FLAGS3,FSMODE            IT'S ON NOW                LDW5\nCSIOINIT MVC   LINE01,BLANKS            CLEAR THE TOPLINE          SDM6\n         MVC   LINE01+33(7),=C'Z  A  P' MOVE TOPLINE               SDM5\n         LA    R1,REP+$L-1              END OF REPROMPT BUFFER     SDM6\nCSIOCLR  CLI   0(R1),C' '               TRAILING BLANK?            SDM5\n         BNE   CSIOCLRX                 NO, LEAVE THE LOOP         SDM5\n         MVI   0(R1),X'00'              CHANGE TO TRAILING NULL    SDM5\n         BCT   R1,CSIOCLR               GO BACK AND CHECK AGAIN    SDM5\nCSIOCLRX L     R2,AOLDSCR               -> SAVED LINE1             SDM6\n         LA    R4,LINE01-2              -> CURRENT LINE1           SDM6\n         TM    FLAGS3,RESHOWF           FULL SCREEN TPUT?          LDW5\n         BNO   CSIOCHNG                 NO, PROCESS CHANGED LINES  LDW5\n         LA    R3,L'OLDSCR              GET SAVE AREA LENGTH       SDM6\n         LR    R5,R3                    COPY LENGTH FOR MVCL       SDM6\n         MVCL  R2,R4                    SAVE INITIAL SCREEN IMAGE  SDM6\nCSIOFULL LM    R0,R1,REGS3270           GET THE TPUT REGS          SDM5\n         B     CSIOTPUT                 GO WRITE THE WHOLE SCREEN  SDM5\nCSIOCHNG L     R3,ASCRWORK              -> WORK AREA               SDM5\n         MVC   0(L'CTL3270,R3),CTL3270  COPY CONTROL INFO          SDM5\n         LA    R3,L'CTL3270(,R3)        BUMP PTR                   SDM5\n         XR    R5,R5                    INITIAL SCREEN ADDRESS     SDM5\n         MVI   $I+2(R2),X'FE'           FORCE LINE02 MISMATCH      SDM5\n         MVI   3*$I+2(R2),X'FE'         FORCE LINE04 MISMATCH      SDM5\n         LA    R6,21                    NUMBER OF LINES TO TEST    SDM5\n         BAS   R14,CSIOTMOD             GO CHECK ONE               LDW2\n         BCT   R6,*-4                   CHECK ALL 21               SDM5\n         MVC   0(L'END3270M,R3),END3270M MOVE IN ENDING CTL STUFF  SDM5\n         LA    R0,L'END3270M(,R3)       GET END+1 ADDR             SDM5\n         L     R1,ASCRWORK              -> START OF WORK AREA      LDW2\n         SR    R0,R1                    GET LENGTH TO TPUT         LDW2\n         BP    *+8                      CONTINUE IF OK             LDW2\n         EX    0,*                      DIE IF LOGIC ERROR         LDW2\n         ICM   R1,B'1000',=X'03'        GET FULLSCR TPUT FLAG      LDW2\nCSIOTPUT TPUT  (1),(0),R                                           LDW1\n         NI    FLAGS3,255-RESHOWF-NODISPF   REFRESH IS DONE        SDM6\n         LA    R1,REPX                  BUFFER ADDR                LDW1\n         ICM   R1,B'1000',=X'81'        MAKE IT A TGET ASIS        SDM1\n         LA    R0,L'REPX                LENGTH OF INPUT BUFFER     LDW1\n         TGET  (1),(0),R                                           SDM5\n         NI    CTL3270,255-X'04'        CHANGE WCC TO NO ALARM     SDM4\n         CLI   REPX,X'7D'               ENTER?                  .AFDSC.\n         BE    NOTPFK                   YES, BYPASS PFK         .AFDSC.\n         CLI   REPX,X'6E'               PA2?  (RESHOW?)            SDM1\n         BE    CSIOFULL                 YES, GO DO IT              SDM6\n         OI    REPX,X'30'               PFK 13-24 LIKE 1-12     .AFDSC.\n         CLI   REPX,X'F5'               PF5? (L?)               .AFDSC.\n         BE    PFKLOC                   YES, GO DO IT           .AFDSC.\n         CLI   REPX,X'F8'               PF8? (D?)               .AFDSC.\n         BE    PFKDOWN                  YES, GO DO IT           .AFDSC.\n         CLI   REPX,X'F7'               PF7? (U?)               .AFDSC.\n         BE    PFKUP                    YES, GO DO IT           .AFDSC.\n         CLI   REPX,X'F1'               PF1? (H?)                  -EU-\n         BE    PFKHELP                  YES, GO DO IT              -EU-\n         CLI   REPX,X'F3'               PF3? (END?)             .AFDSC.\n         BNE   NOTPFK                   NO                         -EU-\n         CLI   REP,C'?'                 YES, BUT WAS IN HELP?      -EU-\n         BNE   ENDPFK                   NO, GO DO IT               -EU-\n         MVC   REP,BLANKS               YES, CLEAR REMEMBERED INPUT-EU-\n         LA    R2,REP                   FORCE NULL INPUT           -EU-\n         B     ASIS08                   AND GO BACK                -EU-\nNOTPFK   LA    R2,REP                   THIS IS WHERE IT WILL GO   SDM5\n         LA    R3,REPX+3                POINT SRC PAST CURSOR ADDR SDM1\n         LA    R4,REPX-1(R1)            END OF REPLY DATA          SDM1\n         CR    R3,R4                    TOO FAR?                   SDM5\n         BH    ASIS08                   YES, NO DATA CAME IN       SDM5\n         CLI   0(R3),X'11'              SBA SEQUENCE?              SDM5\n         BE    ASIS02                   YES, SCREEN IS FORMATTED   SDM5\n         OI    FLAGS3,RESHOWF           NO, FORCE FULL REWRITE     SDM5\nASIS02   CR    R3,R4                    TOO FAR?                   SDM1\n         BH    ASIS08                   YES, NO DATA CAME IN       SDM1\n         CLI   0(R3),X'11'              SBA SEQUENCE?              SDM5\n         BNE   ASIS05                   NO, DON'T WORRY ABOUT IT   SDM5\n         CLC   1(2,R3),=X'C1D1'         FIRST LINE INPUT?          SDM5\n         BE    ASIS04                   YES, ALL'S COOL SO FAR     SDM5\n         CLC   1(2,R3),=X'C3F1'         SECOND LINE INPUT?         SDM5\n         BE    ASIS03                   YES, GO CLEAR REP          SDM5\n         TPUTX '** SCREEN FORMAT ERROR **'   TOO BAD               SDM1\n         B     CSIOFULL                 GIVE HIM BACK WHOLE SCREEN SDM6\nASIS03   MVC   REP,BLANKS               CLEAR REMEMBERED INPUT     SDM5\nASIS04   LA    R3,3(,R3)                SKIP THE SBA SEQUENCE      SDM5\n         B     ASIS02                   AND TRY SOME MORE          SDM5\nASIS05   CLI   0(R3),C' '               LEADING BLANK?             SDM5\n         BNE   ASIS06                   NO, FOUND DATA             SDM5\n         LA    R3,1(,R3)                SKIP THE BLANK             SDM5\n         B     ASIS02                   GO LOOK FOR MORE           SDM5\nASIS06   MVC   REP,BLANKS               FORCE CLEAR REPLY          SDM5\nASIS07   CR    R3,R4                    TOO FAR?                   SDM1\n         BH    ASIS08                   YES, FILL IT UP NOW        SDM1\n         CLI   0(R3),X'11'              SBA?                       SDM1\n         BE    ASIS08                   YES, IGNORE THE 2ND LINE   SDM1\n         MVC   0(1,R2),0(R3)            MOVE ONE MORE BYTE         SDM1\n         LA    R2,1(,R2)                OK, UP THIS ONE            SDM1\n         LA    R3,1(,R3)                AND THE FROM POINTER, TOO  SDM1\n         B     ASIS07                   CONTINUE THIS TRAVESTY     SDM1\nASIS08   LA    R4,REP                   COMPUTE THE REAL           SDM1\n         SR    R2,R4                      LENGTH OF THE REPLY      SDM1\n         STH   R2,READLEN                   AND SAVE IT FOR LATER  SDM1\n         MVC   LINE19,BLANKS            CLEAR THE ERROR MSG IF ANY LDW1\n         BR    R8                       GO PARSE IT                LDW1\nCSIOTMOD CLC   0($I,R2),0(R4)           DOES IT MATCH ?            SDM5\n         BE    CSIONMOD                 YES, SKIP                  LDW2\n         MVI   0(R3),X'11'              SBA                        SDM5\n         LR    R0,R5                    COPY ADDRESS               SDM5\n         STC   R0,2(,R3)                STORE LOW 8 BITS           SDM5\n         NI    2(R3),B'00111111'        MAKE THAT LOW 6 BITS       SDM5\n         SRL   R0,6                     DOWNSHIFT                  LDW2\n         STC   R0,1(,R3)                STORE SOME MORE BITS       SDM5\n         NI    1(R3),B'00111111'        MAKE THAT HIGH 6 BITS      SDM5\n         TR    1(2,R3),TR3270           MAKE VALID CHARS           SDM5\n         MVC   0($I,R2),0(R4)           UPDATE SAVED SCREEN        SDM5\n         MVC   3($I,R3),0(R4)           MOVE IN NEW DATA           SDM5\n         LA    R3,$I+3(,R3)             -> NEXT SCRWORK AREA       SDM5\nCSIONMOD LA    R2,$I(,R2)               -> NEXT SCREEN LINE        SDM5\n         LA    R4,$I(,R4)               -> NEXT SCREEN LINE        SDM5\n         LA    R5,$I-1(,R5)             =NEXT SCREEN OFFSET        SDM5\n         BR    R14                      RETURN TO ABOVE            LDW2\n         SPACE 1\n* * * * * * * * CSIO# * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*        SECONDARY DISPLAY.\n*        SHORT SCREEN MSGS.\n*              R1 = ADDRESS OF BUFFER (40 BYTES ONLY).\n         SPACE 1\nCSIO#    MVC   LINEBUFF(40),0(R1)       COPY THE LINE              LDW1\n         BAS   R8,KILL3270              TURN OFF 3270 MODE IF ON   LDW1\n         NI    FLAGS3,255-F3270         TURN OFF THE FLAG          LDW1\n         BAS   R14,PUTLINE$             PUT THE SHORT LINE         LDW1\n         B     END                      QUIT THIS CP\n         SPACE 1\n* * * * * * * * PUTLINE * * * * * * * * * * * * * * * * * * * * *  LDW1\n         SPACE 1                                                   LDW1\nPUTLINE$ MVC   LINEDESC(4),=H'44,0'                                LDW1\n         B     PUTLINEX                                            LDW1\nPUTLINE  CLC   0($L,R1),BLANKS          BLANK LINE?                LDW1\n         BER   R14                      YES, DON'T TPUT IT         LDW1\n         MVC   LINEBUFF($L),0(R1)       COPY OUTPUT LINE           LDW1\n         MVC   LINEDESC(4),=Y($L+4,0)   SET DESCRIPTOR WORD        LDW1\nPUTLINEX TM    FLAGS2,ATTNHIT           STOP???                    LDW5\n         BOR   R14                      YES.                       LDW1\n         ST    R14,TERMSAVE             SAVE RETURN ADDR           LDW1\n         MVC   PTPB(PTPBDCL),PTPBDC     INIT PARM BLOCK            LDW1\n         LA    R0,LINEDESC              POINT TO O.L.D.            LDW1\n         ST    R0,PTPB+4                SET ADDR IN PARM BLOCK     LDW1\n         L     R15,IKJPUTL                                         LDW1\n         MVI   TSECB,0                  RESET ECB                  LDW1\n         PUTLINE  PARM=PTPB,MF=(E,IOPL),ENTRY=(15)                 LDW1\n         LA    R14,4                                               LDW1\n         CR    R15,R14                                             LDW1\n         L     R14,TERMSAVE             RESTORE RETURN ADDR        LDW1\n         BNHR  R14                                                 LDW1\n         EX    0,*                                                 LDW1\n         SPACE 1                                                   LDW1\n* * * * * * * * TTRPARSE  * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*        DETERMINES AND VALIDITY CHECKS TTR SPECIFIED.\n*              R1 POINTS TO THE TTR.\n*              R0 HAS ITS LENGTH.  OUTPUT IS IN TEMP+1(3)\n*              OUTPUT IS IN TEMP+1(3).\n         SPACE 1\nTTRPARSE L     R15,TTR                  GET '*' = CURRENT TTR\n         SRL   R15,8                    RIGHT JUSTIFY\n         BAS   R8,CALLEXP               GO PARSE                   LDW1\n         BNP   TTRLT1                   NOT POSITIVE IS INVALID    LDW1\n         ST    R15,TEMP                 SAVE THE VALUE RETURNED    LDW1\n         CLI   TEMP+3,0                 REC 0?                     LDW1\n         BNZR  R6                       NO, GIVE IT\n         LA    R2,REC0INV               YES, TELL HIM\n         B     BOTCH                    WITH A MSG\nTTRLT1   LA    R2,TTRSMALL              POINT TO ERROR MSG\n         B     BOTCH                    DISPLAY ERROR STYLE\n         SPACE 1\n* * * * * * * * PREPDUMP  * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*        THIS ROUTINE IS THE 'PREPROCESSOR' TO THE DUMPER. IT GETS\n*        THE BLOCK TO BE DUMPED, PREPARES AND WRITES OUT THE BLOCK\n*        HEADER LINE (WITH TTR, LENGTH, AND CCHHR), AND IF THERE IS\n*        AN EOF OR I/O ERROR AT THE BLOCK, AND MESSAGE IS PUT OUT TO\n*        THE RECORDING FILE AND THE 'BLOCK' IS NOT DUMPED.\n*        RETURNS : 0(R6) - NORMAL RETURN WITH DUMP OF BLOCK TO FOLLOW.\n*                  4(R6) - I/O ERROR OR EOF, RETURN WITH NO DUMP, OR\n*                          EXIT FROM ENTIRE DUMPING LOOP IF I/O ERROR\n*                          WAS 'OUT OF DATASET', MEANING THERE IS NO\n*                          MORE DATA-SET, NO MORE EXTENT.\n         SPACE 1\nPREPDUMP MVI   EOFRET,NOEOF             SAY ALSO EOF'S ARE DATA BLOCKS\n         BAS   R8,READBLK               GET THE BLOCK, SUCH AS IT IS\nPREPDMPX TM    FLAGS2,LOGF              ARE WE LOGGING\n         BNO   NEWDSPNT                 IF NOT FORGET THIS\n         L     R2,CSOUTWK               POINT TO THE OUTPUT WORKAREA\n         LTR   R2,R2                    IS THERE ONE?\n         BZ    NEWDSPNT                 NO, FORGET THIS WHOLE THING\n         L     R2,0(R2)                 GET ADDR IN REG\n         MVC   1+0(40,R2),=C'LENGTH=XXXXX TTR=XXXXXX CCHHR=XXXXXXXXXX'\n         LH    R1,BLKLEN                GET THE LENGTH OF THE BLK\n         CVD   R1,TEMP                  PACKED DEC\n         UNPK  1+7(5,R2),TEMP+5(3)      PUT LENGTH INTO MSG\n         OI    1+11(R2),X'F0'           FIX FLIP BYTE\n         HEX   (1+17,R2),TTR,LEN=3      CONVERT TTR                LDW1\n         HEX   (1+30,R2),CCHHR,LEN=5    CONVERT CCHHR              LDW1\n         MVI   0(R2),C'-'               TRIPLE SPACE BEFORE HDR PRINTED\n         MVI   ENQIT,255                FORCE ENQ TO PRINT\n         BAS   R8,CPUT#                 PUT OUT THE LINE\n         CLI   IOERROR,YESSYN           I/O ERROR IN READ BEFORE?\n         BE    OOPSDUMP                 YES, DON'T DUMP, JUST MSG\n         CLC   LINE05+27(20),EOFMSG     NO, BUT WAS THERE AN EOF?  LDW1\n         BNER  R6                       NO, RETURN NORMALLY AND DUMP\n         SPACE 1\n*        EITHER THE BLOCK HAS AN I/O ERROR WAS AN END-OF-FILE,\n*        SO WE CANNOT DUMP. INSTEAD, PRINT OUT, IF POSSIBLE, THE\n*        TYPE OF CONDITION WHICH HAS OCCURRED, AND RETURN BEYOND\n*        DUMP CODE - 4(R6). IF THE I/O ERROR 'NOT IN DATA-SET' HAS\n*        OCCURRED, THEN STOP THE PROCESS ALL TOGETHER. WE ARE AT\n*        THE REAL END OF THE DATA-SET.\n         SPACE 1\nOOPSDUMP TM    FLAGS2,LOGF              ARE WE LOGGING      %%NEED%%\n         BNO   NEWDSPNT                 IF NOT FORGET IT    %%THIS?%%\n         L     R2,CSOUTWK               PT TO OUTPUT BUFFER PTR\n         LTR   R2,R2                    AHA, IS THERE ONE, HE ASKS\n         BZ    NEWDSPNT                 NOPE, TOUGH LUCK, FELLA\n         L     R2,0(R2)                 GET ADDR OF BUFFER\n         MVC   1+0(40,R2),LINE05+17     COPY EXACTLY WHAT IS ON THE SCR\n         MVI   0(R2),C' '               CARRIAGE CONTROL\n         MVI   ENQIT,255                FORCE ENQ\n         BAS   R8,CPUT#                 WRITE IT OUT\n         CLC   LINE05+35(15),=CL15'NOT IN DATA-SET'   END OF EXTENT?\n         BE    NEW$DISP                 YES, GET OUT OF LOOP AND DISP\n         CLC   LINE05+27(20),EOFMSG     WAS IT EOF?                LDW1\n         BE    NEW$DISP                 YES, GET OUT AND DISPLAY LOC\n         B     4(R6)                    NO, BUT DON'T DUMP THIS 'BLK'\n         SPACE 1\n* * * * * * * * DUMPER  * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*        THIS ROUTINE DUMPS ANY SIZE BLOCK WHICH IS IN THE BUFFER TO\n*        THE OUTPUT RECORDING FILE. THE HEX OFFSETS, THE ACTUAL HEX\n*        DATA, AND THE TRANSLATION OF THAT DATA IS PRINTED OUT.\n*        NOTE : (1) GARBAGE DATA IS NOT PRINTED.  THAT IS, DATA IS\n*                   DISPLAYED ONLY UP TO THE LAST BYTE, AND NO FARTHER.\n*               (2) TRANSLATED DATA IS EITHER IN EBCDIC OR IN ASCII\n*                   TRANSLATION, DEPENDING ON WHICH COMMAND IS IN\n*                   EFFECT AT THE TIME OF THE DUMP, 'EBCDIC' OR\n*                   'ASCII'.\n*               (3) THE 'PREPROCESSOR' ROUTINE 'PREPDUMP' MUST BE\n*                   CALLED FIRST TO GET THE BLOCK, WRITE OUT THE BLOCK\n*                   HEADER LINE, AND TO CHECK FOR SYNAD AND EODAD\n*                   ON THE BLOCK.\n         SPACE 1\nDUMPER   L     R3,ADDRBUFF              PT TO INPUT BUFFER (THE BLOCK)\n         ST    R6,TEMP2+20              SAVE RETURN BAS ADDR\n         XR    R4,R4                    CLEAR REM REG FOR DIVIDE\n         LH    R5,BLKLEN                GET LEN OF BLK\n         D     R4,=F'32'                HOW MANY 4 DBLW LINES IN BLK\n         SPACE 1\n*        R4 HAS THE LENGTH OF THE OFLO 'SHORT' LINE. R5 HAS THE\n*        NUMBER OF LINES TO DUMP OUT (THE NUMBER OR 1 SHORT).\n         SPACE 1\n         LTR   R4,R4                    IS THERE A SHORT LAST LINE?\n         BZ    *+L'*+4                  NO, HAVE NUMBER OF LINES NOW\n         LA    R5,1(R5)                 YES, CORRECT NUM OF LINES\n         XC    TEMP(4),TEMP             INITIALIZE OFFSET COUNTER\nDMPFMTLP TM    FLAGS2,LOGF              ARE WE LOGGING\n         BNO   BADCSOUT\n         L     R2,CSOUTWK               PT TO CSOUT OUTPUT BUFFER\n         LTR   R2,R2                    IS THERE ONE?\n         BZ    BADCSOUT                 NO, TELL HIM UNABLE TO RECORD\n         L     R2,0(,R2)                YES, PICK UP BUFFER PTR\n         MVI   0(R2),C' '               CARRIAGE CONTROL\n         HEX   (1+0,R2),TEMP+1,LEN=3    GET OFFSET                 LDW1\n         MVC   1+91(32,R2),0(R3)        MOVE DATA TO DUMP SECTION\n         L     R15,TRTABADD             PICK UP CURRENT TRANSLATE TAB\n         TR    1+91(32,R2),0(R15)       TRANSLATE IT IN PLACE\n         MVI   1+90(R2),C'*'            MOVE IN DELIMITER\n         MVI   1+123(R2),C'*'           MOVE IN DELIMITER\n         SPACE 1\n*        FORMAT THE LINE.\n*        THE LINE IS COMPOSED OF 4 COMPLETE DOUBLE-WORDS. EACH\n*        DOUBLE-WORD IS FORMATTED INTO FULLWORDS SEPARATED BY A BLANK,\n*        AND EACH PAIR OF DOUBLE-WORDS IS SEPARATED BY 3 BLANKS. THUS\n*        DUMPER LOOPS TWICE A LOOP OF 4 PASSES, ONE PER FULLWORD.\n         SPACE 1\n         LA    R14,1+9(R2)              POINT TO 1ST AVAIL LINE POS\n         LA    R6,2                     BCT OUTER LOOP (2 PAIRS DBLW'S)\nLINELP1  LA    R4,4                     BCT INNER LOOP (4 FULLWORDS)\nLINELP2  HEX   (0,R14),(0,R3),LEN=4     GET ONE FULLWORD           LDW1\n         LA    R3,4(,R3)                UPDATE INPUT BUFFER PTR\n         LA    R14,9(,R14)              UPDATE OUTPUT LINE PTR\n         BCT   R4,LINELP2               DO IT FOR 4 FULLWORDS\n         LA    R14,3(,R14)              FOR NEXT PAIR OF DBLW'S, SPACE\n         BCT   R6,LINELP1               DO IT FOR 2 PAIRS OF DBLW'S\n         MVI   ENQIT,255                FORCE ENQ TO PRINT\n         CH    R5,=H'1'                 LAST LINE NOW?\n         BE    LASTLINE                 YES, CHECK FOR SHORT LAST LINE\n         L     R15,TEMP                 NO, UPDATE OFFSET BY GETTING\n         LA    R15,X'20'(R15)           IT IN THE REG, ADDING INCR,\n         ST    R15,TEMP                 AND PUTTING IT BACK\n         BAS   R8,CPUT#                 WRITE IT OUT\n         BCT   R5,DMPFMTLP              DO ALL THE LINES EXCEPT LAST\n         SPACE 1\n*        LAST LINE ROUTINE.\n*        IF THE LINE IS A SHORT LAST LINE, ONLY WRITE OUT\n*        THE CORRECT AMOUNT OF DATA.\n         SPACE 1\nLASTLINE LH    R1,BLKLEN                GET LEN OF BLK\n         N     R1,=F'31'                TURN OFF ALL BUT LOW ORDR BITS\n         LTR   R1,R1                    ARE THERE ANY LOW ORDER BITS?\n         BZ    BYELAST                  NO, FULL LAST LINE, DUMP IT\n         SPACE 1\n*        GET RID OF THE JUNK IN THE DUMP (TRANSLATED) PART FIRST.\n         SPACE 1\n         LA    R14,32-1-1               MAX WIDTH -1 FOR MVI -1 EX LEN\n         SR    R14,R1                   GET LEN OF JUNK\n         LA    R3,1+91(R2,R1)           POINT TO BEGINNING OF JUNK\n         MVI   0(R3),C' '               KILL THE FIRST BYTE\n         LTR   R14,R14                  ANY MORE STUFF TO BLANK?\n         BM    *+L'*+4                  NO, GO ON AND FIX THE LINE NOW\n         EX    R14,DMPBKMVC             KILL THAT JUNK\n         XR    R0,R0                    CLEAR REM REG FOR DIVIDE\n         D     R0,=F'4'                 HOW MANY FLWRD GRPS ARE THERE?\n         SPACE 1\n*        R0 HAS SLOPOVER WITHIN 1 FULLWORD, R1 HAS NUMBER\n*        OF FULLWORDS ON THE LAST LINE.\n         SPACE 1\n         LA    R4,DUMPOFFS(R1)          POIN TO THE TAB TABLE OFFSET\n         XR    R3,R3                    CLEAR REG FOR IC\n         IC    R3,0(R4)                 GET THE TAB TO THE COLUMN\n         SLL   R0,1                     *2 SLOPOVER FOR CHARACTER BYTES\n         AR    R3,R0                    OFFSET TO FIRST GARBAGE CHAR\n         LA    R4,86-1                  GET MAX LEN  OF LINE (-1 MVI)\n         SR    R4,R3                    GET LEN OF GARBAGE TO BLANK\n         LA    R3,1(R3,R2)              POINT TO 1ST GARBAGE BYTE\n         MVI   0(R3),C' '               BLANK OUT AT LEAST ONE\n         BCTR  R4,0                     GET EXECUTE LEN\n         LTR   R4,R4                    IS THERE ANY MORE TO GET RID OF\n         BM    BYELAST                  NO, GOOD BYE LAST LINE\nDMPBKMVC MVC   1(0,R3),0(R3)            << EXECUTED >>\n         EX    R4,DMPBKMVC              GET RID OF THE REST\nBYELAST  BAS   R8,CPUT#                 WRITE OUT LAST LINE\n         L     R6,TEMP2+20              RESTORE RET ADDR\n         BR    R6                       RETURN TO CALLER\n         SPACE 1\n* * * * * * * * CLEARDEF  * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*        RESET AND/OR INITIALIZE THE DEFINE TABLE.\n         SPACE 1\nCLEARDEF L     R2,AIDEFTAB              PT TO BEGINNING OF TABLE   LDW1\n         ST    R2,IDEFAVAL              MAKE THAT THE 1ST AVAIL POSIT\n         MVC   0(240,R2),BLANKS         CLEAR OUT THE TABLE ALSO   LDW1\n         BR    R8                       RET TO CALLER\n         SPACE 1\n* * * * * * * * CLOSE * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*        CLOSE THE DATA-SET.\n         SPACE 1\nCLOSE    TM    DCBU+48,X'10'            IS IT OPEN?\n         BNOR  R8                       NO, WHY CLOSE THEN?\n         CLOSE MF=(E,DCBLIST)           GOODBYE DATASET\n         BR    R8                       RET TO CALLER\n         SPACE 1\n* * * * * * * * WRITE * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nWRITE    LA    R14,CCW##W               -> CCW CHAIN               LDW1\nWRITE$GO ST    R14,IOBCCWA              SET IN IOB                 LDW1\n         EXCP  IOB                                                 LDW1\n         WAIT  ECB=ECB                                             LDW1\n         CLI   ECB,X'7F'                                           LDW1\n         BER   R8                                                  LDW1\n         B     REALERR                                             LDW1\n         SPACE 1\n* * * * * * * * OPENMSG * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*        IF WE MUST OPEN A DATA SET, CREATE A MESSAGE ABOUT IT.\n         SPACE 1\nLOGTEST  TM    FLAGS2,LOGF              ALREADY LOGGING?           LDW1\n         BOR   R8                       YES, ALL DONE              LDW1\nOPENOUT  ST    R8,DBLW                  SAVE FOR LATER\n         L     R1,CSOUTWK               FIND CSOUT'S WORKAREA\n         LTR   R1,R1                    ANY WORKAREA?\n         BZR   R8                       NO, EXIT NOW\n         OI    FLAGS2,LOGF              WE ARE NOW LOGGING         LDW1\n*LDW1    CSOUT OPN,=CL6'SYSDA3',=H'10',CALL=CALL,MF=(E,(1))  (10,10)\n         MVI   0(R1),X'80'          (+) FLAG AS OPEN CALL\n*LDW1    LA    0,=CL6'SYSDA3'       (+)\n*LDW1    ST    0,4(,R1)             (+) STORE FIRST PARM\n*LDW1    LA    R0,=H'10'            (+)\n*LDW1    ST    R0,8(,R1)            (+) STORE SECOND PARM\n         LR    R2,R1                (+) COPY WORKAREA PTR\n         L     R15,=V(CSOUT)        (+) POINT TO ROUTINE\n         LR    R1,CSREG             (+) GET CSAREA PTR\n         BASR  R14,R15              (+) CALL IT\n         LTR   R0,R0                    ERROR?\n         BZ    SAYOPEN                  NO\n         NI    FLAGS2,255-LOGF          TURN OFF FLAG              LDW1\n         LA    R1,=CL40'UNABLE TO ALLOCATE PRINT FILE'             LDW1\n         BAS   R8,CSIO#                 DISPLAY IT\n***  CSIO# DOESN'T RETURN ??????                                   LDW1\n         XC    CSOUTWK,CSOUTWK (NOOUT)  NO MORE TRIES AT IT\n         B     LOCRET                   RETURN TO CALLER\nSAYOPEN  MVI   ENQIT,0                  MAYBE\n         MVI   CHNGED,0                 VIRGIN BUFFER\n         L     R1,CSOUTWK               POINT TO WORK AREA\nOPENMSG  L     R1,0(R1)                 FIND LINE TO USE\n         L     R15,=A(OPNMSG)           ADDRESSIBILITY\n         MVC   0(OPNMSGL,R1),0(R15)\n         CLI   DSNAME,X'04'             VTOC?\n         BNE   *+L'*+4                  NO, INFORMATION ONLY\n         MVI   7(R1),C'A'      (ACTION) MAKE OPR SIT UP AND TAKE NOTICE\n*LDW4    MVC   9(6,R1),CSJOBNO (INFORM) CHARGE NUMBER...\n*LDW4    MVC   16(3,R1),CSINIT          INITIALS\n         MVC   9(L'USERID,R1),USERID    CULPRIT                    LDW4\n         TM    DCBLIST,X'0F'            NOW, WAS IT OPEN FOR INPUT?\n         BZ    DSNWTO                   YES, SO THERE'S NOTHING TO DO\n         MVI   7(R1),C'A'               IF UPDATING, ACTION MSG\n         MVC   35(6,R1),=CL6'UPDATE'    AND SAY UPDATE\nDSNWTO   CLI   DSNAME,X'04'             VTOC HERE?\n         MVC   42(44,R1),DISPDSN        MOVE IN DISPLAYABLE DSN    LDW1\n         BE    WTOIT                    YES, VOLSER ALREADY SET   LDW1\n         MVC   87(2,R1),=C'ON'          ADD                       *LPR*\n         MVC   90(6,R1),VOLSER            VOLSER                  *LPR*\nWTOIT    BAS   R8,CPUT                  DUMP THE LINE\nLOCRET   L     R8,DBLW                  PICK UP RET ADDR\n         BR    R8                       ALL OK - RETURN NORMALLY\n         SPACE 1\n* * * * * * * * CPUT  * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*        PASS A LINE TO THE RECORDING SUBROUTINE.\n*        ENTRY CPUT IS ENQUEUE TO PRINT WITH POSSIBLE WTO'S.\n*        ENTRY CPUT# IS ENQUEUE BUT WITH NO WTO'S (FOR DUMP COMMANDS).\n         SPACE 1\nCPUT     TM    FLAGS2,LOGF              SEE IF LOGGING\n         BNOR  R8                       IF NOT RETURN TO CALLER\n         L     R2,CSOUTWK               GET WA ADDR\n         LTR   R2,R2                    ANY THERE?\n         BZR   R8                       NO, EXIT NOW\n         MVI   0(R2),X'20'              SET INITIAL VALUE (WTO)\n         TM    FLAGS2,SENSF             IS DS SYS OR URSA?\n         BNO   CPUT#                    IF NOT NO WTO\n         TM    GODFLAG,GOD              CAN HE EVER UPDATE?        LDW1\n         BO    ISWTOCPT                 YES, DO THE WTO            LDW1\n*    IF HE CAN NEVER UPDATE, DON'T WTO (USER LOOKING AT SYS1. DS). LDW1\nCPUT#    L     R2,CSOUTWK               DUMP ENTRY - GET WORKAREA PTR\n         MVI   0(R2),0                  DON'T ISSUE WTO\nISWTOCPT CLI   CPUTFLAG,YESCSERR        WAS THERE A CSOUT ENQ ERROR?\n         BER   R8                       YES, ACT LIKE I ENQUEUED IT\nCPUTRUNC LR    R1,CSREG                 GET CSAREA PTR             LDW1\n         L     R15,=V(CSOUT)            FIND SUBROUTINE\n         BASR  R14,R15                  CALL IT\n         LTR   R0,R0                    DID IT WORK?\n         BZR   R8                       YES, RETURN TO CALLER\n         MVI   CPUTFLAG,YESCSERR        RECORD THAT THERE WAS AN ERROR\n         B     BADCSOUT                 AND TELL THE USER OF HIS FATE\n         SPACE 1\n* * * * * * * * SETLINE * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*        SET UP LINE FOR CPUT.\n*        INPUT : R1 POINTS TO SINGLE MESSAGE NUMBER IN CHAR FORM.\n*                R8 RETURN ADDRESS IF NOT PRINTING, +4 IF PRINTING.\n*        OUTPT : R2 POINTS TO LINE.\n         SPACE 1\nSETLINE  TM    FLAGS2,LOGF              ARE WE LOGGING?\n         BNOR  R8                       IF NOT RETURN\n         L     R2,CSOUTWK               FIND WORKAREA\n         LTR   R2,R2                    ANY THERE?\n         BZR   R8                       NO, EXIT ERROR\n         L     R2,0(,R2)                FIND THE LINE\n         MVC   1(7,R2),=C'ZAP01XI'      MOVE IN MESSAGE NUMBER     LDW4\n         MVC   6(1,R2),0(R1)            COPY CORRECT DIGIT\n*LDW4    MVC   9(6,R2),CSJOBNO          FIRST PART OF JOBNO\n*LDW4    MVC   15(08,R2),=C',XXX TTR'   REST OF MASK\n*LDW4    MVC   16(3,R2),CSINIT          INITIALS\n         MVC   9(L'USERID,R2),USERID    CULPRIT                    LDW4\n         MVC   9+L'USERID+1(3,R2),=C'TTR'                          LDW4\n         HEX   (24,R2),TTR,LEN=3        GET THIS TTR               LDW1\n         B     4(R8)                    NOW RETURN TO CALLER\n         SPACE 1\n* * * * * * * * SETSTRNG  * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*        CONVERT STRING FOR CPUTING.\n*        INPUT : R1 POINTER TO OUTPUT LINE.\n*                R8 RETURN ADDRESS.\n*                R4 EXECUTE LENGTH OF STRING.\n*                R5 ADDRESS OF DATA TO BE CONVERTED.\n         SPACE 1\nSETSTRNG UNPK  12(9,R13),0(5,R5)        CONVERT FIRST WORD\n         UNPK  20(9,R13),4(5,R5)        CONVERT SECOND\n         UNPK  28(9,R13),8(5,R5)        CONVERT THIRD\n         UNPK  36(9,R13),12(5,R5)       CONVERT FOURTH AND LAST\n         TR    12(32,R13),TRHEX         FIX UP HEX\n         LTR   R4,R4                    ANY?\n         BMR   R8                       NO, LEAVE IT BLANK\n         LA    R15,1(R4,R4)             GET EXECUTE LENGTH OF HEX\n         EX    R15,CPMVC                MOVE CONVERTED DATA\n         MVI   35(R1),C''''                                        LDW1\n         EX    R4,SETSTRMV              MOVE CHAR FORM TO BUFFER   LDW1\n         L     R15,TRTABADD             GET RIGHT TRTAB PTR        LDW1\n         EX    R4,SETSTRTR              TRANSLATE TO RIGHT CHARSET LDW1\n         LA    R15,36+1(R4,R1)                                     LDW1\n         MVI   0(R15),C''''                                        LDW1\n         BR    R8                       RETURN\nCPMVC    MVC   0(0,R1),12(R13)          << EXECUTED >>\nSETSTRMV MVC   36(0,R1),0(R5)           << EXECUTED >>             LDW1\nSETSTRTR TR    36(0,R1),0(R15)          << EXECUTED >>             LDW1\n         SPACE 1\n* * * * * * * * SETMSG  * * * * * * * * * * * * * * * * * * * * *  LDW1\n         SPACE 1\n*        MOVE MSG AND HYPHENS TO CORRECT POS ON SCREEN,            LDW1\n*        DEPENDING ON WHETHER IN FULLSCREEN MODE.                  LDW1\n*        INPUT : R1 POINTS TO CL20'MSG'.                           LDW1\n         SPACE 1\nSETMSG   LH    R1,0(,R8)                GET MSG OFFSET             LDW1\n         AR    R1,R12                   GET ADDR                   LDW1\nSETMSGX  TM    FLAGS3,F3270             FULLSCREEN?                LDW5\n         BZ    SETMSG1                  NO, SHORTER MSG            LDW3\n         MVC   LINE19+27(20),0(R1)      MOVE IT TO CENTER          LDW1\n         MVC   LINE19+17(9),=9C'='      MAKE IT FANCY              LDW1\n         MVC   LINE19+48(9),=9C'='      BUT DON'T GET CARRIED AWAY LDW1\n         B     2(,R8)                   RETURN PAST OFFSET         LDW1\nSETMSG1  MVC   LINE19+23(20),0(R1)      MOVE IT TO LEFT OF CENTER  LDW1\n         MVC   LINE19+17(3),=9C'='      MAKE IT FANCY              LDW1\n         B     2(,R8)                   RETURN PAST OFFSET         LDW1\n         SPACE 1\n* * * * * * * * BOTCH * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*        DISPLAY ERROR MESSAGES.\n*        MOVE IN MSG AND HYPHENS AROUND IT TO ERROR MSG LINE ON\n*        SCREEN. TRACE WILL BE DISABLED. IF SYNTAX ERROR MSG IS\n*        TO BE DISPLAYED, THE COLUMN IN QUESTION IS COMPUTED AND\n*        DISPLAYED WITH THE MSG.\n*              R2 = PTR TO MESSAGE.\n*              R1 = PTR TO INVALID LOC IN EXPRESSION (IF APPLICABLE).\n         SPACE 1\nBOTCH    XR    R15,R15                  CLEAR R15\n         IC    R15,0(,R2)               GET LENGTH\n         CH    R15,=H'20'               SEE IF WE ARE USING MSG\n         BH    BOTCH0                   IF NOT ASSUME LNTH 20\n         MVC   TEMP2(20),BLANKS         CLEAR AN AREA              LDW1\n         BCTR  R15,0                    DECREMENT FOR EXECUTE\n         MVC   TEMP2(0),1(R2)           << EXECUTED >>             LDW1\n         EX    R15,*-6                  MOVE IN MSG\n         LA    R2,TEMP2                 POINT TO MSG               LDW1\n         CLC   INVEXP+1(16),TEMP2       IS THIS AN INV EXPR MSG?   LDW1\n         BNE   BOTCH0                   NO, GO ON                  LDW1\n         LA    R3,TEMP2                 PT TO REPLY            -EU-LDW1\n         CLR   R3,R1                    IS THIS AREA USED FOR SCAN?-EU-\n         BNH   *+L'*+4                  YES                        -EU-\n         LA    R3,REP                   NO, PT TO REPLY        -EU-LDW1\n         SR    R1,R3                    GET OFFSET TO BAD HEX\n         LA    R1,1(R1)                 MAKE THE OFFSET A COLUMN #\n         CVD   R1,TEMP                  YES, GET OFFSET OF ERROR INTO\n         UNPK  TEMP2+18(2),TEMP+6(2)    THE EXPRESSION AND         LDW1\n         OI    TEMP2+19,C'0'            MOVE IT TO THE SCREEN      LDW1\n         BCTR  R1,0                     GET CURSOR POSITION        LDW1\n         STH   R1,CURPOS                SET IT                     LDW1\nBOTCH0   LR    R1,R2                    GET MSG ADDR               LDW1\n         LA    R8,NEWDSPNT-2            FAKE THE RETURN POINT      LDW1\n         B     SETMSGX                  SPECIAL ENTRY PT           LDW1\n         SPACE 1\n* * * * * * * * EODAD * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*        END-OF-FILE ROUTINE.                                      LDW1\n*        IF EOF'S ARE NOT COUNTED AS BLOCKS (AS IN A PDS),\n*        THEN DISPLAY END OF FILE. OTHERWISE HOP THEM.\n         SPACE 1\nEODAD    LR    R2,R8                    SAVE RET TO READ           LDW1\n         BAS   R8,CLEAR                 CLEAR SCREEN\n         MVC   LINE05,BLANKS            CLR TOP ERR MSG SO CAN SAY EOF\n*        LENGTH OF EOF RECORD IS ALREADY SET.                      LDW1\n         MVC   LINE05+27(20),EOFMSG     TELL HIM END-OF-FILE       LDW1\n         MVI   TTR+3,NOSEQRD            TURN OFF SEQ READ          LDW1\n         CLI   EOFRET,YESEOF            EOF ALLOWED HERE?\n         BE    NEW$DISP                 YES, SO EOF ALREADY        LDW1\n         BR    R2                       NO, EXIT FROM READBLK (EOF)\n*        THUS UNDER CERTAIN CIRCUMSTANCES EOF'S ARE COUNTED AS RECORDS.\n         SPACE 1\n* * * * * * * * CHKPT * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nCHKPT    TM    FLAGS2,MUSTZAP           BLOCK NEED A ZAP 1ST?\n         BNOR  R8                       NO, LET COMMAND THRU\n*LDW1    NI    FLAGS2,255-MUSTZAP       YES, WE TOLD HIM ONCE\n*LDW1    LA    R2,=CL20'**** ZAP NEEDED ****' TELL HIM, IGNORE COMMAND\n*LDW1    B     BOTCH                    HE CAN ALWAYS DO IT AGAIN\n         CLC   REP,PREVREP              SAME CMD TWICE IN A ROW?   LDW4\n         BER   R8                       YES, LET HIM DO IT         LDW4\n         MVC   LINE19+11(58),=C'******** ENTER \"ZAP\" OR RE-ENTER PREVIO$\n               US COMMAND ********'                                LDW4\n         B     NEWDSPNT                 TELL HIM HE CAN'T LEAVE    LDW1\n         SPACE 1\n* * * * * * * * KILL3270  * * * * * * * * * * * * * * * * * * * *  LDW1\n         SPACE 1\nKILL3270 TM    FLAGS3,FSMODE            FULL SCREEN MODE ON?       LDW5\n         BNOR  R8                       NO, JUST RETURN            LDW1\n         TPUT  CLR3270,CLR3270L,FULLSCR      CLEAR SCREEN          SDM5\n         STFSMODE  OFF                  TURN OFF FULLSCREEN MODE   LDW1\n         NI    FLAGS3,255-FSMODE        IT'S OFF NOW               LDW5\n         BR    R8                       RETURN TO CALLER           LDW1\n         SPACE 1                                                   -EU-\n* * * * * * * * STRCNV  * * * * * * * * * * * * * * * * * * * * *  -EU-\n*        STRING CONVERSION ROUTINE.                                -EU-\n*              R8 = RETURN ADDRESS (LINK REGISTER).                -EU-\n*              R14 = STRING ADDRESS.                               -EU-\n         SPACE 1                                                   -EU-\nSTRCNV   LH    R1,0(R14)                GET STRING LENGTH          -EU-\n         EX    R1,STRCNVM               TARGET OUTPUT STRING       -EU-\n         ICM   R15,B'1111',TRTXTAB                                 -EU-\n         BZR   R8                                                  -EU-\n         EX    R1,STRCNVT               TRANSLATE STRING           -EU-\n         BR    R8                       RETURN TO CALLER           -EU-\nSTRCNVM  MVC   WKSTR(*-*),2(R14)        <<EXECUTED>>               -EU-\nSTRCNVT  TR    WKSTR(*-*),0(R15)        <<EXECUTED>>               -EU-\n         EJECT\n*        ZAP --- CONSTANTS, DATA, FLAGS, ETC.\n         SPACE 1\n*%       PRINT NOGEN                                               LDW1\nIOERRMSG DC    CL40' ***** I/O ERROR: XXXXXXXXXXXXXXX *****'\nINVMEM   DC    CL20'MEMBER NOT FOUND'\nWRITERR  MSG   'WRITE NOT ALLOWED'\nEOFMSG   DC    CL20'*** END OF FILE ***'\nCONMSG   MSG   '<STR> CAPS ON'                                     -EU-\nCOFFMSG  MSG   '<STR> CAPS OFF'                                    -EU-\nASCIIMSG MSG   'ASCII TRANSLATION'\nZCODEMSG MSG   'ZCODE TRANSLATION'\nEBCDCMSG MSG   'EBCDIC TRANSLATION'\nINVFMSG  MSG   'NO FORWARD CHAIN'\nINVBMSG  MSG   'NO BACKWARD CHAIN'\nINVEXP   MSG   'SYNTAX ERROR COL. '                                LDW1\nLINMSG   MSG   'SCAN NOT IN EFFECT'\nTABFULL  MSG   'DEFINE TABLE FULL'\nREDEFMSG MSG   'SYMBOL REDEFINED'\nLASTINV  MSG   'INVALID IN VTOC'\nNOTVTOC  MSG   'DATASET NOT VTOC'                                  LDW1\nDEFRESET MSG   'DEFINE TABLE RESET'\nREC0INV  MSG   'RECORD 0 INVALID'\nINVCOM   MSG   'INVALID COMMAND'\nNOMCOM   MSG   'NOT PARTITIONED'\nINVOPCOD MSG   'INVALID OP CODE '\nINVDEC   MSG   'INVALID DECIMAL'\nTTRSMALL MSG   'TTR < 000001 INVALID'                          -EU-LDW1\nLENERR   MSG   'LENGTH INVALID'\nNOTJQMSG MSG   'DATA SET NOT JOBQ'\nSTORMSG  DC    CL20'NOTE: NOT UPDATING'\nBACKDUMP MSG   'REVERSE DUMP INVALID'                          -EU-LDW1\nNOCSOUT  MSG   '  UNABLE TO RECORD'\nDUMPWORK MSG   '  DUMP SUCCESSFUL'\nNAMEMNF  MSG   'NAME INVALID'                                   *N*\nLOGONMSG MSG   'LOGGING'                                           LDW1\nNOMEMFND DC    CL20'*NO DIRECTORY ENTRY*'                          LDW1\nBADEQUAL MSG   'INVALID SYMBOL'                                    LDW1\nOUCH     MSG   'OUCH!!'                                            LDW1\n         PRINT GEN                                                 LDW3\n         SPACE 2\n*        LITERAL POOL.\n         SPACE 1\n         LTORG\n         EJECT\n*        TABLE TO GENERATE VALID 3270 CHARS FROM 6 BIT CODELDW2.\n         SPACE 1\nTR3270   DC    X'40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'                 LDW2\n         DC    X'50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F'                 LDW2\n         DC    X'6061E2E3E4E5E6E7E8E96A6B6C6D6E6F'                 LDW2\n         DC    X'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F'                 LDW2\n         SPACE 2\n*        HEX TO CHAR HEX AND CHAR TO HEX TRTAB.\n         SPACE 1\n         DC    X'0A0B0C0D0E0F'          FOR CHAR TO HEX            LDW1\n         DC    41C'.'                   WASTED SPACE               LDW1\nNUMBERS  DC    C'0123456789ABCDEF'\nTRHEX    EQU   *-256\nN0       EQU   NUMBERS+0\nN1       EQU   NUMBERS+1\nN2       EQU   NUMBERS+2\nN3       EQU   NUMBERS+3\nN4       EQU   NUMBERS+4\nN5       EQU   NUMBERS+5\nN6       EQU   NUMBERS+6\nN7       EQU   NUMBERS+7\nN8       EQU   NUMBERS+8\nN9       EQU   NUMBERS+9\n         SPACE 1                                                   MAS2\nEDMASK   DC    X'402020202020202020202120'\n         SPACE 1\nDUMPOFFS DC    AL1(9,18,27,36,48,57,66,75)\n         SPACE 1\nMAXWIDTH DC    A((LINE19-LINE06-$I)/$I/2)                          LDW1\n         SPACE 1\nRECFMU   EQU   X'C0'                    RECFM=U\n         SPACE 1\nYESSYMB  EQU   X'FF'                    EXP LOOK AT SYMBOL TAB\nNOSYMB   EQU   X'00'                    EXP LOOK AT SYMBOL TAB\n         SPACE 1\nYESTRACE EQU   X'00'                    TRACE IN EFFECT\nNOTRACE  EQU   X'FF'                    NO TRACE\n         SPACE 1\nYESCONTL EQU   X'80'                    SCAN CONTINUE IS OK\nYESCONTS EQU   X'40'                    S,X,O,N NO OPERANDS OK\nYESCONTT EQU   X'20'                    SET NO OPERAND OK\n         SPACE 1\nYESSYN   EQU   X'FF'                    SYNAD I/O ERROR HAS OCCURRED\nNOSYN    EQU   X'00'                    NO ERROR HAS OCCURRED\n         SPACE 1\nYESCSERR EQU   X'FF'                    CSOUT CANNOT ENQ IN THIS DS\nNOCSERR  EQU   X'00'                    CSOUT HAS NO PROBLEMS\n         SPACE 1\n*GOD     EQU   X'FF'                    ONLY HE CAN CHANGE HIS MIND\n*NOGOD   EQU   X'00'                    TOUGH BANANAS\nGOD      EQU   X'01'                    ONLY HE CAN CHANGE HIS MIND-EU-\nGODAUTH  EQU   X'02'                    SENSITIVE DATA-SET AUTH.   -EU-\nGODALL   EQU   X'04'                    DATA-SET IS ALLOCATED      -EU-\n         SPACE 1                                                   -EU-\nYESCAPS  EQU   X'FF'                    CAPS ON                    -EU-\nNOCAPS   EQU   X'00'                    CAPS OFF                   -EU-\n         SPACE 1\nYESEOF   EQU   X'FF'                    DO NOT IGNORE EOF'S\nNOEOF    EQU   X'00'                    TREAT EOF'S AS DATA BLK\n         SPACE 1\nCHGIDR   EQU   X'FF'                    WE HAVE CHANGED THE IDR\nNOCHGIDR EQU   X'00'                    WE HAVE NOT UPDATED IT YET\n         SPACE 1\nSEQREAD  EQU   X'01'                    READ NEXT RECORD           LDW1\nNOSEQRD  EQU   X'00'                    READ THIS RECORD           LDW1\n         SPACE 1\nOLD      DC    F'1',A(HERALD)\nHERALD   DC    H'10',H'0',CL6' ZAP: '\n         SPACE 2\nPTPBDC   PUTLINE  OUTPUT=(LINEDESC-TSDSECT,TERM,SINGLE,DATA),      LDW1X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L             LDW1\nPTPBDCL  EQU   *-PTPBDC                                            LDW1\n         SPACE 1\nPGPBDC   PUTGET OUTPUT=(OLD,SINGLE,MODE),TERMGET=(EDIT,WAIT),          X\n               TERMPUT=(ASIS,WAIT,NOHOLD,NOBREAK),MF=L\nPGPBDCL  EQU   *-PGPBDC\n         SPACE 2\nCTL3270C DC    X'C3'                    WCC: RST KEB+RST MDT       SDM4\n         DC    X'115D7F114040'          SPF/TCAM PREFIX            LDW1\n         SPACE 1\nEND3270C DC    X'3C404000'              CLEAR WITH NULLS TO 1,1    SDM5\nEND3270M DC    X'11C1D113'              INSERT CURSOR AT 2,2       SDM5\n         SPACE 1\nCLR3270  DC    X'C3'                    WCC: RST KEB+RST MDT       SDM5\n         DC    X'115D7E114040'          SPF/TCAM PREFIX (ADDR 1,1) LDW1\n         DC    X'3C404000'              CLEAR WITH NULLS TO 1,1    LDW1\n         DC    X'13'                    INSERT CURSOR AT TOP       LDW1\nCLR3270L EQU   *-CLR3270                LENGTH                     SDM5\n         SPACE 2\n*        CONSTANTS FOR DISPLAY ROUTINE.\n         SPACE 1\nDSPCON80 DC    F'-16'                   MASK FOR HIGH ORDER BITS   LDW1\n         DC    F'15'                    MASK FOR LOW  ORDER BITS   LDW1\n         DC    H'80'                    LINE LENGTH                LDW1\n         DC    H'96'                    (HEX/SCREEN)/2             LDW1\n         DC    H'16'                    HEX BYTES / LINE           LDW1\n         DC    H'32'                    TWICE THE ABOVE            LDW1\n         DC    AL1(7,12,12,17,18,23,23,28,30,35,35,40,41,46,46,51) LDW1\nDISPTR80 DC    AL1(48)                  BLANK               +08    LDW1\n         DC    AL1(16,17,18,19,48)      BYTES 01, 02        +09    LDW1\n         DC    AL1(20,21,22,23,48,48)   BYTES 03, 04        +14    LDW1\n         DC    AL1(24,25,26,27,48)      BYTES 05, 06        +20    LDW1\n         DC    AL1(28,29,30,31,48,48,48)      07, 08        +25    LDW1\n         DC    AL1(32,33,34,35,48)            09, 10        +32    LDW1\n         DC    AL1(36,37,38,39,48,48)         11, 12        +37    LDW1\n         DC    AL1(40,41,42,43,48)            13, 14        +43    LDW1\n         DC    AL1(44,45,46,47)               15, 16        +48    LDW1\n         DC    AL1(48,48,48,49)         '   |'              +52    LDW1\n         DC    AL1(0,1,2,3,4,5,6,7)     FIRST 8 CHARS       +56    LDW1\n         DC    AL1(8,9,10,11,12,13,14,15)  LAST 8 CHARS     +64    LDW1\n         DC    AL1(49)                                      +72    LDW1\n         SPACE 1\nDSPCON40 DC    F'-8'                    MASK FOR HIGH ORDER BITS   LDW1\n         DC    F'7'                     MASK FOR LOW  ORDER BITS   LDW1\n         DC    H'40'                    LINE LENGTH                LDW1\n         DC    H'48'                    (HEX/SCREEN)/2             LDW1\n         DC    H'8'                     HEX BYTES / LINE           LDW1\n         DC    H'16'                    TWICE THE ABOVE            LDW1\n         DC    X'060B0B101116161B'      TABS FOR CARET ON SCREEN\n*%       DC    8X'00'                   PADDING                    LDW1\nDISPTR40 DC    AL1(16,17,18,19,48)      BYTES 01, 02        +08    LDW1\n         DC    AL1(20,21,22,23,48,48)   BYTES 03, 04        +13    LDW1\n         DC    AL1(24,25,26,27,48)      BYTES 05, 06        +19    LDW1\n         DC    AL1(28,29,30,31)         BYTES 07, 08        +24    LDW1\n         DC    AL1(48,48,49)            '  |'               +28    LDW1\n         DC    AL1(0,1,2,3,4,5,6,7)     CHARACTERS          +31    LDW1\n         DC    AL1(49)                  '|'                 +39    LDW1\n*%       DC    34AL1(48)\n         SPACE 2\nCCWLIST  CCW   X'03',0,X'40',1          NOP FOR NOW                LDW1\n         CCW   X'31',0,X'40',5          SEARCH ID EQ               LDW1\n         CCW   X'08',0,X'00',0          TIC *-8                    LDW1\n         CCW   X'1E',0,X'20',0          READ CKD                   LDW1\n         SPACE 1\n         CCW   X'31',0,X'40',5          SEARCH ID EQ               LDW1\n         CCW   X'08',0,X'00',0          TIC *-8                    LDW1\n         CCW   X'0D',0,X'20',0          WRITE KD                   LDW1\n         SPACE 1\n         CCW   X'16',0,X'20',0          READ R0                    LDW1\n         SPACE 1\n         CCW   X'16',0,X'70',1          READ R0 TO ORIENT          LDW1\n         CCW   X'E9',0,X'40',8          SEARCH KEY EQ/HI MT        LDW1\n         CCW   X'08',0,X'00',0          TIC *-8                    LDW1\n         CCW   X'0E',0,X'00',8+256      READ KD                    LDW1\n         SPACE 1\n         CCW   X'31',0,X'40',5          SEARCH ID EQ               LDW1\n         CCW   X'08',0,X'00',0          TIC *-8                    LDW1\n         CCW   X'1D',0,X'20',0          WRITE CKD                  LDW1\n         EJECT                                                     LDW3\n*        ZAP --- PATCH AREA.\n         SPACE 1\nPATCH    DC    128S(*)                                             LDW1\n         SPACE 2\n         OACDROP R12,R11,R10,R9                                     MVS\n         EJECT\n*        ZAP --- EXP : EXPRESSION ANALYZER.\n         SPACE 1\n*        EXP : THIS ROUTINE WILL ANALYZE AN EXPRESSION PASSED TO IT\n*              AND RETURN ITS VALUE CONCATENATED WITH A STARTING VALUE.\n*        INPUT : R13 - SAVE AREA.\n*                R14 - RETURN ADDRESS.\n*                      IF EXPOPT IS ZERO, TABLE NOT SCANNED,\n*                      ELSE SYMBOL TABLE IS SCANNED.\n*                R2  - STARTING VALUE OF '*'.                      LDW1\n*                R1  - ADDRESS OF EXPRESSION TO PARSE.\n*                R0  - LENGTH OF EXPRESSION TO PARSE.\n*        OUTPUT : R1  - RETURN CODE.\n*                       IF NEGATIVE : NO ERRORS DETECTED.\n*                       IF ZERO OR POSITIVE AN ERROR OCCURED AT ADDRESS\n*                       GIVEN IN R1.\n*                 R15 - IF NO ERROR, THE NEW VALUE CALCULATED.\n*\n*        THIS ROUTINE WAS WRITTEN BY DON WORTH.\n*        MODIFIED BY LEONARD D. WOREN TO DO MULT & DIV(12-27-78).  LDW1\n         SPACE 1\n         USING TSDSECT,R13\nEXP      STM   R14,R1,EXPARMS+12        SAVE CALLER'S REGS ONE PLACE\n         STM   R2,R12,12+(4*4)(R13)     SAVE REST IN OTHER PLACE\n         LR    R12,R15                  GET BASE                   LDW1\n         USING EXP,R12                                             LDW1\n         LR    R4,R2                    ALWAYS BEGIN WITH *        LDW1\n         ST    R2,EXPSTART              SAVE VALUE OF \"*\"          LDW1\n         LR    R3,R1                    START SCAN\n         BCTR  R3,0                     HE WILL ADD ONE FIRST\n         LR    R2,R0                    BCT INDEX\n*LDW1    XC    EXPFLAG(2),EXPFLAG       RESET FLAGS\n         MVI   EXPFLAG+1,0              RESET FLAGS                LDW1\n         LA    R2,1(R2)                 ALLOW FOR FIRST PASS\n         ST    R1,GORF                  FIRST BAD SPOT\n         B     EXPBACK                  START AFTER ITEM\n         SPACE 1\n*        SEE WHAT NEXT ITEM IS.\n         SPACE 1\nEXPITEM  LTR   R2,R2                    ANYTHING LEFT?\n         BP    EXPON                    YES\n         ST    R4,EXPSTART              NEW STARTER\n         OI    EXPPTR,X'80'             NO ERROR\n         B     EXPRET                   RETURN\nEXPON    CLI   0(R3),C' '               BLANK?\n         BNE   EXPCHECK                 NO, WE CAN USE IT\nEXPNEXT  LA    R3,1(R3)                 NEXT SPOT TO CHECK\n         BCT   R2,EXPITEM               CONTINUE\n         MVI   EXPFLAG+1,0              NOTHING FOR NEXT TIME\n         B     EXPCONV                  WHEN AT END, USE LAST IF ANY\nEXPCHECK ST    R3,GORF                  KEEP TRACK OF WHERE WE ARE\n         CLI   0(R3),C'*'               CURRENT LOC OR MULT?\n*LDW1    BE    EXPCURR                  YES, GO LOAD IT\n         BE    EXPSTAR                  YES, GO DECIDE WHICH       LDW1\n         CLI   0(R3),C'+'               ADD?\n         BE    EXPADD                   YES\n         CLI   0(R3),C'-'               SUBTRACT?\n         BE    EXPSUB                   YES\n         CLI   0(R3),C'.'               DECIMAL DONE?\n         BE    EXPDEC                   YES\n         CLI   0(R3),C'/'               DIVIDE?                    LDW1\n         BE    EXPDIV                   YES                        LDW1\n         OI    EXPFLAG+1,EXPEXOPR       EXPECTING OPERATOR NOW     LDW1\n         SPACE 1\n*        IF NO TERMINATOR IS FOUND, SAVE UP FOR LATER.\n         SPACE 1\n         LA    R0,EXPWORK+8             POINT PAST IT\n         CR    R0,R5                    TOO FAR?\n         BNH   EXPERR                   YES\n         MVC   0(1,R5),0(R3)            COPY IT TO WORKAREA\n         LA    R5,1(R5)\n         B     EXPNEXT                  CONTINUE\n         SPACE 1\n*        IF AN ERROR IS DETECTED, PASS BACK ADDRESS OF IT.\n         SPACE 1\nEXPERR   MVC   EXPPTR(4),GORF           SAVE POINTER FOR RETURN\nEXPRET   MVI   EXPOPT,NOSYMB            RESET NO SYMB TAB LOOKUP\n         LM    R14,R1,EXPARMS+X'C'      GET RETURN REGS\n         LM    R2,R12,12+(4*4)(R13)     RESTORE REST OF REGS FROM SAVE\n         BR    R14\n         SPACE 1\n*        '*' WAS ENTERED, DECIDE IF CURRENT LOC OR MULTIPLY.       LDW1\n         SPACE 1\nEXPSTAR  TM    EXPFLAG+1,EXPEXOPR       WHICH IS THIS?             LDW1\n         BO    EXPMULT                  MULTIPLY.                  LDW1\n         SPACE 1\n*        USE CURRENT VALUE.\n         SPACE 1\nEXPCURR  L     R15,EXPSTART             GET STARTING VALUE\n         MVI   EXPFLAG+1,EXPEXOPR       EXPECTING OPERATOR NOW     LDW1\n         B     EXPUSE                   AND GO USE IT\n         SPACE 1\n*        IF '+' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG.\n         SPACE 1\nEXPADD   MVI   EXPFLAG+1,EXPFPLUS       INDICATE ADD NEXT TIME\n         B     EXPCONV                  GO CONVERT IT\n         SPACE 1\n*        IF '-' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG.\n         SPACE 1\nEXPSUB   MVI   EXPFLAG+1,EXPFMINS       INDICATE ADD NEXT TIME\n         B     EXPCONV                  GO CONVERT IT\n         SPACE 1\n*        IF '*' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG.      LDW1\n         SPACE 1\nEXPMULT  MVI   EXPFLAG+1,EXPFMULT       INDICATE MULT NEXT TIME    LDW1\n         B     EXPCONV                  GO CONVERT IT              LDW1\n         SPACE 1\n*        IF '/' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG.      LDW1\n         SPACE 1\nEXPDIV   MVI   EXPFLAG+1,EXPFDIV        INDICATE DIV NEXT TIME     LDW1\n         B     EXPCONV                  GO CONVERT IT              LDW1\n         SPACE 1\n*        IF '.' WAS ENTERED, TERMINATE PREVIOUS AS DECIMAL.\n         SPACE 1\nEXPDEC   OI    EXPFLAG,EXPFDEC          INDICATE DECIMAL THIS TIM\n*        B     EXPCONV                  GO CONVERT IT\n         SPACE 1\n*        WHEN UP TO 8 CHARS SCANNED OUT, CONVERT THEM APPROPRIATELY.\n         SPACE 1\nEXPCONV  LA    R15,EXPWORK+1            POINT TO START\n         SR    R5,R15                   FIND EXECUTE LENGTH\n         LR    R15,R5                   SAVE IT                    LDW1\n         BNM   EXPCOK                   IF SOMETHINGS THERE, CONTINUE\n         TM    EXPFLAG,EXPFTERM         SOMETHING EXPECTED?\n         BZ    EXPBACK                  NO, IGNORE THIS TIME\n         B     EXPERR                   OTHERWISE ITS NO GOOD\nEXPCOK   MVC   DBLW(0),EXPWORK          << EXECUTED >>\n         MVI   DBLW,C' '\n         MVC   DBLW+1(7),DBLW           CLEAR AN AREA\n         EX    R15,EXPCOK               MOVE TO IT\n         SPACE 1\n*        IF SYMBOL TABLE SCAN REQUESTED, DO SO.\n         SPACE 1\n         CLI   EXPOPT,NOSYMB            SCAN LABEL TABLE?\n         BE    EXPNTAB                  NO, GO ON\n         TM    EXPFLAG,EXPFDEC          DECIMAL?\n         BO    EXPNTAB                  THEN CAN'T BE THIS\n         L     R14,AIDEFTAB             POINT TO TABLE\nEXPIDSCN CLI   0(R14),255               END OF TABLE?\n         BE    EXPNTAB                  THEN WE DIDN'T FIND IT\n         CLC   0(8,R14),DBLW            SEE IF THIS IS HIS LABEL\n         BE    EXPGLAB                  YES, IT IS\n         LA    R14,10(R14)              NEXT ENTRY IN TABLE\n         B     EXPIDSCN                 GO ON\nEXPGLAB  LH    R15,8(R14)               GET VALUE OF IT\n         B     EXPUSE                   AND USE IT\n         SPACE 1\n*        VALIDITY CHECK FOR NUMERICS.\n         SPACE 1\nEXPNTAB  LA    R0,1(R15)                GET LENGTH OF THINGY\n         LA    R14,EXPWORK              FIND IT\nEXPCCHK  CLI   0(R14),C'0'              IF ITS NUMERIC I ALWAYS LIKE IT\n         BNL   EXPCGOOD                 GO\n         TM    EXPFLAG,EXPFDEC          DECIMAL?\n         BO    EXPERR                   THEN NO GOOD\n         CLI   0(R14),C'A'              OTHERWISE NOT LESS THAN A\n         BL    EXPERR                   GO\n         CLI   0(R14),C'F'              OR GREATER THAN F\n         BH    EXPERR                   GO\n         IC    R1,0(R14)                GET IT\n         AH    R1,EXPFUDGE              MAKE FA-FF\n         STC   R1,0(R14)                REPLACE IT\nEXPCGOOD LA    R14,1(R14)               NEXT\n         BCT   R0,EXPCCHK               CONTINUE CHECKING\n         SPACE 1\n*        CONVERT DECIMAL.\n         SPACE 1\n         TM    EXPFLAG,EXPFDEC          DECIMAL?\n         BZ    EXPNDEC                  NO\nEXPPACK  PACK  DBLW(8),EXPWORK(0)       << EXECUTED >>\n         EX    R15,EXPPACK              PACK IT\n         CVB   R15,DBLW                 CONVERT IT\n         B     EXPUSE                   AND USE IT\n         SPACE 1\n*        CONVERT FOR HEX.\n         SPACE 1\nEXPNDEC  LA    R15,1(R15)               DO AN EXTRA CHAR\n         EX    R15,EXPPACK              PACK IT\n         LM    R14,R15,DBLW             GET OFFSET\n         SRDL  R14,8                    SHIFT OUT BAD BYTE (FLIP)\n*        B     EXPUSE                   GO USE IT\n         SPACE 1\n*        WHEN VALUE OBTAINED, ADD, SUB OR WHATEVER.\n         SPACE 1\nEXPUSE   TM    EXPFLAG,EXPFPLUS         ADDING?\n         BO    EXPUADD                  YES\n         TM    EXPFLAG,EXPFMINS         SUBTRACTING?\n         BO    EXPUSUB                  YES\n         TM    EXPFLAG,EXPFMULT         MULTIPLYING?               LDW1\n         BO    EXPUMULT                 YES                        LDW1\n         TM    EXPFLAG,EXPFDIV          DIVIDING?                  LDW1\n         BO    EXPUDIV                  YES                        LDW1\n         LR    R4,R15                   ELSE, OVERLAY\n         SPACE 1\nEXPBACK  LA    R5,EXPWORK               START AGAIN\n         MVC   EXPFLAG(1),EXPFLAG+1     NEW FLAGS\n         MVI   EXPFLAG+1,0              NO MORE\n         B     EXPNEXT                  SKIP LAST ONE\nEXPUADD  AR    R4,R15\n         B     EXPBACK                  GO ON\nEXPUSUB  SR    R4,R15                   SUBTRACT\n         B     EXPBACK                  GO\n         SPACE 1\nEXPUMULT LR    R5,R4                    GET INTO ODD REG           LDW1\n         MR    R5-1,R15                 DO THE MULTIPLY            LDW1\n         LR    R4,R5                    GET RESULT IN CORRECT REG  LDW1\n         B     EXPBACK                  GO ON                      LDW1\n         SPACE 1\nEXPUDIV  LR    R5,R4                    GET INTO ODD REG           LDW1\n         XR    R4,R4                    CLEAR FOR DIVIDE           LDW1\n         LTR   R15,R15                  DIVIDE BY 0?               LDW1\n         BZ    EXPERR                   YES, ERROR                 LDW1\n         DR    R5-1,R15                 DO THE MULTIPLY            LDW1\n         LR    R4,R5                    GET RESULT IN CORRECT REG  LDW1\n         B     EXPBACK                  GO ON                      LDW1\n         SPACE 2\n*        EXP'S DATA.\n         SPACE 1\nEXPFUDGE DC    0H'0',XL2'0039'\nEXPFPLUS EQU   X'80'                    ADD NEXT VALUE\nEXPFMINS EQU   X'40'                    SUBTRACT NEXT VALUE\nEXPFDEC  EQU   X'20'\nEXPFMULT EQU   X'10'                    MULT NEXT VALUE            LDW1\nEXPFDIV  EQU   X'08'                    DIV NEXT VALUE             LDW1\nEXPEXOPR EQU   X'04'                    EXPECTING OPERATOR NEXT    LDW1\n*        SOMETHING REQUIRED FLAG :\nEXPFTERM EQU   EXPFPLUS+EXPFMINS+EXPFDEC+EXPFMULT+EXPFDIV          LDW1\n         SPACE 2\n         PRINT GEN\n         LTORG\n         SPACE 2\n         DROP  ,                                                   LDW1\n         EJECT ,                                                   LDW1\nDCBMSK   DCB   MACRF=E,DDNAME=SYSLIB,DEVD=DA                       LDW1\n         DC    5F'0'                    STUPID MACRO & SYSTEM      LDW1\nDCBUL    EQU   *-DCBMSK\n         SPACE 2\nOPNMSG   DC    C'0ZAP009I CAW999.III HAS OPENED FOR INPUT '        LDW4\nOPNMSGL  EQU   *-OPNMSG\n         EJECT\n*        COMMAND TABLE.\n         SPACE 1\nCOMTAB   DC    0F'0'                             * = NO HELP INFO\n         DC    AL1(6),CL8'VERBOSE ',AL3(VERBOSE)\n         DC    AL1(6),CL8'CAPSOFF ',AL3(CAPSOFF)                   -EU-\n         DC    AL1(5),CL8'CAPSON  ',AL3(CAPSON)                    -EU-\n         DC    AL1(5),CL8'NOT3270 ',AL3(NOT3270)    %%TEMP%%     * LDW1\n         DC    AL1(5),CL8'YES3270 ',AL3(YES3270)    %%TEMP%%     * LDW1\n         DC    AL1(6),CL8'WHATMEM ',AL3(WHATMEM)                   LDW1\n         DC    AL1(6),CL8'//DEBUG ',AL3(DIEFAST)                 * LDW1\n         DC    AL1(6),CL8'LASTDS1 ',AL3(LASTDS1)                   LDW1\n         DC    AL1(6),CL8'X X X X ',AL3(*)   ZAP SPACE           * LDW1\n         DC    AL1(5),CL8'EBCDIC  ',AL3(EBCDIC)\n         DC    AL1(5),CL8'ITRACE  ',AL3(ITRACE)\n         DC    AL1(5),CL8'DISASM  ',AL3(DISASM)\n         DC    AL1(5),CL8'LINE80  ',AL3(LINE80)                    LDW1\n         DC    AL1(5),CL8'LINE40  ',AL3(LINE40)                    LDW1\n**%%     DC    AL1(5),CL8'NEWLOG  ',AL3(NEWLOG)                  * LDW1\n**%%     DC    AL1(5),CL8'FORMAT  ',AL3(FORMAT)                  * LDW1\n         DC    AL1(4),CL8'NODEF   ',AL3(NODEF)\n         DC    AL1(4),CL8'ASCII   ',AL3(ASCII)\n         DC    AL1(4),CL8'FLOAT   ',AL3(FLOAT)\n         DC    AL1(4),CL8'ZCODE   ',AL3(ZCODE)\n         DC    AL1(4),CL8'WHERE   ',AL3(WHERE)\n         DC    AL1(4),CL8'TERSE   ',AL3(TERSE)\n         DC    AL1(4),CL8'EJECT   ',AL3(EJECT)\n         DC    AL1(4),CL8'DUMPF   ',AL3(DUMPF)                     LDW3\n         DC    AL1(4),CL8'DUMPT   ',AL3(DUMPT)\n         DC    AL1(4),CL8'DISPC   ',AL3(DISPC)                     LDW1\n         DC    AL1(4),CL8'DISPK   ',AL3(DISPK)                     LDW1\n         DC    AL1(4),CL8'DISPD   ',AL3(DISPD)                     LDW1\n         DC    AL1(3),CL8'BASE    ',AL3(BASE)                      LDW1\n         DC    AL1(3),CL8'DUMP    ',AL3(DUMP)\n         DC    AL1(3),CL8'NOTE    ',AL3(NOTE)\n         DC    AL1(3),CL8'LAST    ',AL3(LAST)\n         DC    AL1(3),CL8'HELP    ',AL3(HELPHELP)                * LDW1\n         DC    AL1(3),CL8'NAME    ',AL3(NAME#)                      *N*\n         DC    AL1(3),CL8'IDEF    ',AL3(IDEF)\n         DC    AL1(3),CL8'SAVE    ',AL3(REPLACE)                 *\n         DC    AL1(3),CL8'ZSYM    ',AL3(ZCODE)                   *\n**%%     DC    AL1(3),CL8'VTOC    ',AL3(VTOCCMD)                 * LDW1\n         DC    AL1(2),CL8'ASM     ',AL3(ASM)\n         DC    AL1(2),CL8'CRT     ',AL3(CRT)\n         DC    AL1(2),CL8'LOG     ',AL3(LOG)\n         DC    AL1(2),CL8'ZAP     ',AL3(REPLACE)\n         DC    AL1(2),CL8'END     ',AL3(END)                       LDW3\n         DC    AL1(2),CL8'SET     ',AL3(SET)\n         DC    AL1(2),CL8'ABS     ',AL3(ABS)                       JCJ1\n**%%     DC    AL1(2),CL8'DSN     ',AL3(DSNCMD)                  * LDW1\n         DC    AL1(1),CL8'WM      ',AL3(WHATMEM)                   LDW4\n         DC    AL1(1),CL8'DO      ',AL3(DO)\n         DC    AL1(0),CL8'L       ',AL3(LOCATE)\n         DC    AL1(0),CL8'S       ',AL3(STORE)\n         DC    AL1(0),CL8'O       ',AL3(OR)\n         DC    AL1(0),CL8'X       ',AL3(EXOR)\n         DC    AL1(0),CL8'N       ',AL3(AND)\n         DC    AL1(0),CL8'F       ',AL3(FIND)                      LDW1\n         DC    AL1(0),CL8'>       ',AL3(FORWARD)\n         DC    AL1(0),CL8'<       ',AL3(BACKWARD)\n         DC    AL1(0),CL8'M       ',AL3(MEMBER#)\n         DC    AL1(0),CL8'E       ',AL3(NAME#)                    *LPR*\n         DC    AL1(0),CL8'B       ',AL3(BACK)\n         DC    AL1(0),CL8'D       ',AL3(DISPLAY#)\n         DC    AL1(0),CL8'V       ',AL3(INDIRECT)                  LDW1\n         DC    AL1(0),CL8'T       ',AL3(TRACK)\n         DC    AL1(0),CL8'R       ',AL3(RECORD)\n         DC    AL1(0),CL8'P       ',AL3(POINT)\n         DC    AL1(0),CL8'J       ',AL3(POINT$J)                   MAS2\n         DC    AL1(0),CL8'U       ',AL3(UP)                        LDW1\n         DC    AL1(0),CL8'=       ',AL3(EQUALS)\n         DC    AL1(0),CL8'?       ',AL3(HELP)\n         DC    AL1(0),CL8'H       ',AL3(HELP)                      LDW1\n         DC    AL1(0),CL8'#       ',AL3(CALC)\n         DC    AL1(0),CL8'W       ',AL3(WINDOW)\n         DC    AL1(0),CL8'%       ',AL3(INDPOINT)                  LDW1\n         DC    X'FF'\n         EJECT\n*        STAXEXIT ----- STAX EXIT.\n*              GIVEN PTR TO TSDSECT IN STAXLIST, TURN ON\n*              ATTENTION INDICATOR AND RETURN QUICKLY.\n         SPACE 1\n         USING STAXEXIT,R15                                        LDW1\nSTAXEXIT L     R3,8(,R1)                GET USADDR FIELD (R13)     LDW1\n         USING TSDSECT,R3                                          LDW1\n         LR    R2,R14                   SAVE RETURN ADDR\n         TM    GODFLAG,GODAUTH          WAS AUTHORIZED?            -EU-\n         BZ    STAXXIT                  NO                         -EU-\n         RESAUTH                                                   -EU-\n         NI    GODFLAG,255-GODAUTH      RESET                      -EU-\nSTAXXIT  TM    FLAGS2,ATTNHIT           ALREADY SET?               LDW5\n         BNO   *+L'*+6                  NO, OK                     LDW1\n         LA    R1,1000                  ABEND CODE                 LDW1\n         SVC   13                       LET HIM OUT QUICK          LDW1\n         OI    FLAGS2,ATTNHIT           INDICATE ATTN SIGNALED     LDW5\n         OI    FLAGS3,RESHOWF           ATTN CLEARS THE SCREEN     LDW5\n         POST  TSECB                    POST ATTN ECB\n         XR    R15,R15                  RC=0 TO STAX\n         BR    R2                       RETURN\n         DROP  R15,R3                                              LDW1\n         EJECT\n*        ZAP --- TRANSLATE TABLES ---\n         SPACE 2\n*        DUMP FORMAT TRTAB (*** ASCII ***).\n*        (THIS IS A MODIFIED VERSION OF ASMTRTAB RASA,             -EU-\n*        INTO WHICH ALL HEXADECIMAL VALUES LESS THAN X'3F'         -EU-\n*        HAVE BEEN REPLACED BY A PERIOD CHARACTER X'4B')           -EU-\n         SPACE 1\nIECTRASA EQU   *  0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' 0\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' 1\n         DC    X'404F7F7B5B6C507D4D5D5C4E6B604B61' 2\n         DC    X'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F' 3\n         DC    X'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6' 4\n         DC    X'D7D8D9E2E3E4E5E6E7E8E94AE05A5F6D' 5\n         DC    X'79818283848586878889919293949596' 6\n         DC    X'979899A2A3A4A5A6A7A8A9C06AD0A14B' 7\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' 8\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' 9\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' A\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' B\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' C\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' D\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' E\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' F\n         SPACE 2                                                   -EU-\n*        CONVERT STRING TRTAB (*** ASCII ***).                     -EU-\n*        (THIS IS THE VERSION OF ASMTRTAB SASA)                    -EU-\n         SPACE 1                                                   -EU-\nIECTSASA EQU   *  0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    X'000102031A091A7F1A1A1A0B0C0D0E0F' 0\n         DC    X'101112131A0A080018191A1A1C1D1E1F' 1\n         DC    X'1A1A1A1A1A0A171B1A1A1A1A1A050607' 2\n         DC    X'1A1A161A1A1A1A041A1A1A1A14151A1A' 3\n         DC    X'201A1A1A1A1A1A1A1A1A5B2E3C282B21' 4\n         DC    X'261A1A1A1A1A1A1A1A1A5D242A293B5E' 5\n         DC    X'2D2F1A1A1A1A1A1A1A1A7C2C255F3E3F' 6\n         DC    X'1A1A1A1A1A1A1A1A1A603A2340273D22' 7\n         DC    X'1A6162636465666768691A1A1A1A1A1A' 8\n         DC    X'1A6A6B6C6D6E6F7071721A1A1A1A1A1A' 9\n         DC    X'1A7E737475767778797A1A1A1A1A1A1A' A\n         DC    X'1A1A1A1A1A1A1A1A1A1A1A1A1A1A1A1A' B\n         DC    X'7B4142434445464748491A1A1A1A1A5C' C\n         DC    X'7D4A4B4C4D4E4F5051521A1A1A1A1A1A' D\n         DC    X'5C1A535455565758595A1A1A1A1A1A1A' E\n         DC    X'303132333435363738391A1A1A1A1A1A' F\n         SPACE 2\n*        DUMP FORMAT TRTAB (*** ZCODE ***).\n         SPACE 1\nTRCHARZ  DC    256C'.'\n         ORG   TRCHARZ+X'18'\n         DC    X'C0D0'\n         ORG   TRCHARZ+X'25'\n         DC    C'$'\n         ORG   TRCHARZ+X'40'\n         DC    C' ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n         DC    C'_ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n         DC    C'=0123456789'\n         ORG   TRCHARZ+X'90'\n         DC    C'+-'\n         ORG   TRCHARZ+X'9E'\n         DC    C'<'\n         ORG   TRCHARZ+X'A0'\n         DC    C'='\n         ORG   TRCHARZ+X'A2'\n         DC    C'>'\n         ORG   TRCHARZ+X'A4'\n         DC    C'-',X'5A'         EXCLAIM POINT\n         ORG   TRCHARZ+X'B5'\n         DC    C',?'\n         ORG   TRCHARZ+X'C4'\n         DC    C';:'\n         ORG   TRCHARZ+X'F9'\n         DC    C'#'\n*        ORG   TRCHARZ+4\n*        DC    C'$'\n*        ORG   TRCHARZ+14\n*        DC    C'??();/'\n*        ORG   TRCHARZ+26\n*        DC    C'+-*/*...?V<.=.>'\n*        ORG   TRCHARZ+47\n*        DC    C',?'\n*        ORG   TRCHARZ+54\n*        DC    C'\u00ac'\n*        ORG   TRCHARZ+61\n*        DC    C'_'\n*        ORG   TRCHARZ+82\n*        DC    C'??'\n*        ORG   TRCHARZ+86\n*        DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ-'\n*        ORG   TRCHARZ+113\n*        DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ='\n*        ORG   TRCHARZ+140\n*        DC    C'0123456789.. '':'\n         ORG   ,\n         SPACE 2                                                   -EU-\n*        CONVERT STRING TRTAB (*** ZCODE ***).                     -EU-\n*        (THIS IS THE PREVIOUS TABLE IN REVERSE ORDER JUST         -EU-\n*        BECAUSE I DIDN'T FOUND WHAT 'ZCODE' MEANS) MOINIL P.A.    -EU-\n         SPACE 1                                                   -EU-\nTRCHRZ   DC    256X'3F'                                            -EU-\n         ORG   TRCHRZ+X'40'                                        -EU-\n         DC    X'40'                                               -EU-\n         ORG   TRCHRZ+X'4C'        <                               -EU-\n         DC    X'9E'                                               -EU-\n         ORG   TRCHRZ+X'4E'        +                               -EU-\n         DC    X'90'                                               -EU-\n         ORG   TRCHRZ+X'5A'        !$                              -EU-\n         DC    X'A525'                                             -EU-\n         ORG   TRCHRZ+X'5E'        ;                               -EU-\n         DC    X'C4'                                               -EU-\n         ORG   TRCHRZ+X'60'        -                               -EU-\n         DC    X'91' OR X'A4'                                      -EU-\n         ORG   TRCHRZ+X'6B'        ,                               -EU-\n         DC    X'B5'                                               -EU-\n         ORG   TRCHRZ+X'6D'        _>?                             -EU-\n         DC    X'5BA2B6'                                           -EU-\n         ORG   TRCHRZ+X'7A'        :#                              -EU-\n         DC    X'C5F9'                                             -EU-\n         ORG   TRCHRZ+X'7E'        =                               -EU-\n         DC    X'76' OR X'A0'                                      -EU-\n         ORG   TRCHRZ+X'81'        ABCDEFGHI                       -EU-\n         DC    X'5C5D5E5F6061626364'                               -EU-\n         ORG   TRCHRZ+X'91'        JKLMNOPQR                       -EU-\n         DC    X'65666768696A6B6C6D'                               -EU-\n         ORG   TRCHRZ+X'A2'        STUVWXYZ                        -EU-\n         DC    X'6E6F707172737475'                                 -EU-\n         ORG   TRCHRZ+X'C0'        {ABCDEFGHI                      -EU-\n         DC    X'18414243444546474849'                             -EU-\n         ORG   TRCHRZ+X'D0'        }JKLMNOPQR                      -EU-\n         DC    X'194A4B4C4D4E4F505152'                             -EU-\n         ORG   TRCHRZ+X'E2'        STUVWXYZ                        -EU-\n         DC    X'535455565758595A'                                 -EU-\n         ORG   TRCHRZ+X'F0'        0123456789                      -EU-\n         DC    X'7778797A7B7C7D7E7F80'                             -EU-\n         ORG   ,                                                   -EU-\n         SPACE 2\n*        DUMP FORMAT TRTAB (*** EBCDIC ***).\n         SPACE 1\nTRCHARE  DC    256C'.'\n         ORG   TRCHARE+C' '\n         DC    C' '\n         ORG   TRCHARE+X'4A'            CENT SIGN\n         DC    X'4A',C'.<(+|&&'\n         ORG   TRCHARE+X'5A'            EXCLAMATION PT\n         DC    X'5A',C'$*);\u00ac-/'\n         ORG   TRCHARE+C','\n         DC    C',%_>?'\n         ORG   TRCHARE+C':'\n         DC    C':#@''=',X'7F'          DOUBLE QUOTE\n         ORG   TRCHARE+X'81'\n         DC    9AL1(*-TRCHARE)          LOWER CASE A-I\n         ORG   TRCHARE+X'91'\n         DC    9AL1(*-TRCHARE)          LOWER CASE J-R\n         ORG   TRCHARE+X'A2'\n         DC    8AL1(*-TRCHARE)          LOWER CASE S-Z\n         ORG   TRCHARE+C'A'\n         DC    9AL1(*-TRCHARE)          UPPER CASE A-I\n         ORG   TRCHARE+C'J'\n         DC    9AL1(*-TRCHARE)          UPPER CASE J-R\n         ORG   TRCHARE+C'S'\n         DC    8AL1(*-TRCHARE)          UPPER CASE S-Z\n         ORG   TRCHARE+C'0'\n         DC    10AL1(*-TRCHARE)         NUMBERS\n         ORG   ,\n         EJECT\n*        ZAP --- TSO PARSE DSECTS/CSECTS  -  PDL, PCL, PDE, ETC...\n         SPACE 1\nZAP      CSECT\n         PRINT NOGEN\nPCL      IKJPARM DSECT=IKJPARMD\nPDLDSN   IKJPOSIT DSNAME,USID,PROMPT='DATA-SET NAME'               LDW1\nPDLVOL   IKJKEYWD\n         IKJNAME 'VOLUME',SUBFLD=VOLUME\nPDLALC   IKJKEYWD  DEFAULT=                                        LDW1\n         IKJNAME  'ALLOCDSN',SUBFLD=PDLALCSF                       LDW1\nCRTK     IKJKEYWD\n         IKJNAME 'CRT'\nNOT3270K IKJKEYWD DEFAULT=                                         LDW1\n         IKJNAME 'NOT3270'                                         LDW1\nLOGK     IKJKEYWD DEFAULT='LOG  '                                  LDW1\n         IKJNAME 'LOG'\n         IKJNAME 'NOLOG'                                           LDW1\nNWK      IKJKEYWD DEFAULT='TERSE'\n         IKJNAME 'VERBOSE'\n         IKJNAME 'TERSE'\nVOLUME   IKJSUBF\nVOLVOL   IKJIDENT 'VOLUME SERIAL',FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=6\nPDLALCSF IKJSUBF\nPDLALCDS IKJPOSIT  DSNAME,USID,PROMPT='NAME OF DATA-SET TO ALLOC'  LDW4\n         IKJENDP\n         PRINT GEN\n         SPACE 2                                                   LDW1\nPDE      DSECT ,                        PARSE DESCRIPTOR ELEMENT\nPDEPTR   DS    A                        TEXT PTR\nPDELEN   DS    H                        LEN\nPDEFLAG  DS    X                        FLAGS\nPDEFPRES EQU   X'80'                    PARM PRESENT\n         DS    X                        RESERVED\nPDEPTR2  DS    A                                                   LDW1\nPDELEN2  DS    H                                                   LDW1\nPDEFLAG2 DS    X                                                   LDW1\n         DS    X                                                   LDW1\nPDEPTR3  DS    A                                                   LDW1\nPDELEN3  DS    H                                                   LDW1\nPDEFLAG3 DS    X                                                   LDW1\n         DS    X                                                   LDW1\nPDEL     EQU   *-PDE\n         EJECT\n*        ZAP --- DSECT MASK EXPANSIONS.\n         SPACE 1\n*IHADCB   DSECT ,                                             -EU- LDW1\n*LDW1     DCBD  DSORG=DA                DCB EXPANSION         -EU-\n*--- MACRO DCBD HAS BEEN INSERTED AT THE END --- - - - - - -  -EU-\n*         ORG   IHADCB+X'24'                                       LDW1\n*DCBRECFM DS    X                                                  LDW1\n*DCBEXLST DS    AL3                                                LDW1\n*DCBDDNAM DS    CL8                                                LDW1\n*         ORG   IHADCB+X'2C'                                       LDW1\n*DCBIFLGS DS    0X                                                 LDW1\n*DCBDEBAD DS    A                                                  LDW1\n         SPACE 2                                                   LDW1\n*CVT      DSECT ,                                             -EU-\n*LDW1     CVT                           CVT EXPANSION         -EU-\n*--- MACRO CVT HAS BEEN INSERTED AT THE END --- - - - - - - - -EU-\n*CVTPTR   EQU   16                                            -EU- LDW1\n*         ORG   CVT+X'1C'                                     -EU- LDW1\n*CVTPCNVT DS    A                                             -EU- LDW1\n*CVTPRLTV DS    A                                             -EU- LDW1\n         SPACE 2                                                   LDW1\n*UCB      DSECT ,                                             -EU-\n*LDW1     IEFUCBOB                      UCB EXPANSION         -EU-\n*--- MACRO IEFUCBOB HAS BEEN INSERTED AT THE END --- - - - -  -EU-\n*         ORG   UCB+X'1C'                                     -EU- LDW1\n*SRTEVOLI DS    CL6                                           -EU- LDW1\n         SPACE 2                                                   LDW1\n*DEB      DSECT ,                                             -EU- LDW1\n*LDW1     IEZDEB                        DEB EXPANSION         -EU-\n*--- MACRO IEZDEB HAS BEEN INSERTED AT THE END --- - - - - -  -EU-\n*         ORG   DEB+X'10'                                     -EU- LDW1\n*DEBNMEXT DS    C                       # OF EXTENTS          -EU- LDW1\n*         ORG   DEB+X'20'                                     -EU- LDW1\n*DEBUCBAD DS    F                                             -EU- LDW1\n*         DS    H                                             -EU- LDW1\n*DEBSTRCC DS    H                       STARTING CYLINDER     -EU- LDW1\n*         DS    H                                             -EU- LDW1\n*DEBENDCC DS    H                       ENDING CYLINDER       -EU- LDW1\n         EJECT\n*DSCB    DSECT\nTSDSECT  DSECT                          BACK TO THERE, MOMENTARILY LDW1\n         ORG   LINE07                                              LDW1\nDSCB     DS    0D                                                  LDW1\n         IECSDSL1 (1)                   FORMAT 1 DSCB EXPANSION\n         SPACE 1\n         ORG   ,                                                   LDW1\n         SPACE 2\nWORKAREA DSECT\n*LDW1    CSOUT MF=L,COUNT=YES\n         DS    0D                   (+)\n         DS    X,AL3                (+) FLAGS/ADDR OF LINE BUFFER\n         DS    860X                 (+) REMAINING DATA\n         SPACE 1\n         DS    0D     (BUFFER)\nLCSOUT   EQU   *-WORKAREA\n         SPACE 2                                                   LDW1\nESDDATA  DSECT ,                        ESD DATA ENTRY              *N*\nESDDNAME DS    CL8                      ENTRY PT NAME OF 8X'00'     *N*\nESDDTYPE DS    X                        TYPE                        *N*\nESDDADDR DS    AL3                      LKED ADDR OF ENTRY PT       *N*\nESDDSEG  DS    AL1                      SEGMENT NUMBER              *N*\nESDDLEN  DS    AL3                      LENGTH OF ENTRY             *N*\nESDDL    EQU   *-ESDDATA                LENGTH ESD DATA ENTRY       *N*\n         EJECT\n*        C S O U T -- URSA PROCESSOR PRINTING ROUTINE.\n         SPACE 1\n***********************************************************************\nCSOUT    CSECT                                                        *\n*        CSOUT : THIS ROUTINE WHEN CXCTLED TO OR CALLED BY AN URSA    *\n*                PROCESSOR WILL ALLOCATE A PRINT FILE, WRITE OUTPUT   *\n*                LINES INTO IT (OPTIONALLY WTOING THEM ALSO), AND     *\n*                ENQUEUE THE FILE TO BE PRINTED BY THE MOVE SERVICE.  *\n*                IT IS INVOKED BY THE CSOUT MACRO IN ONE OF THREE     *\n*                TYPES OF CALLS :                                     *\n*  INPUTS : R1 ==> CSAREA ADDRESS                                     *\n*           R2 ==> CSOUT WORKAREA ADDRESS                             *\n*                                                                     *\n*           CSOUT  OPN,VOLUME,TRKS,CALL=TYPE,MF=(TYPE,WORKAREA)       *\n*                                                                     *\n*                'OPN' REQUESTS THE FILE TO BE ALLOCATED AND OPENED.  *\n*                'VOLUME' IS THE ADDRESS OF A 6 BYTE FIELD CONTAINING *\n*                         THE VOLUME NAME TO BE USED FOR THE FILE.    *\n*                'TRKS' IS THE ADDRESS OF A HALFWORD CONTAINING THE   *\n*                         NUMBER OF TRACKS TO BE ALLOCATED.           *\n*                FOR CALL= 'TYPE' IS EITHER 'CXCTL' OR 'CALL'. IF     *\n*                'CXCTL' IS SPECIFIED CSOUT IS INVOKED VIA CXCTL.     *\n*                OTHERWISE IT IS VIA CALL.                            *\n*                MF=(TYPE,WORKAREA) WHERE TYPE IS B (SET UP FOR CALL) *\n*                         OR E (SET UP FOR CALL AND CALL). 'WORKAREA' *\n*                IS THE ADDRESS OF A ??? BYTE AREA ALIGNED ON A       *\n*                DOUBLE WORD TO BE USED BY CSOUT FOR WORK SPACE.      *\n*                                                                     *\n*                RETURN : R0 ==> 0 - NORMAL, FILE OPEN, PUTS ACCEPTED *\n*                               \u00ac0 - ERROR RETURN FROM CSLOC/CSOPN    *\n*                                                                     *\n*           CSOUT  PUT,CALL=,MF=,WTO=OPTION                           *\n*                                                                     *\n*                WHERE WTO=OPTION MAY BE WTO=YES OR WTO=NO TO CAUSE   *\n*                         THE LINE TO BE WTOED ALSO.                  *\n*                THE LINE BUFFER IS PRINTED. (SEE BELOW FOR WORKAREA  *\n*                DEFINITIONS)                                         *\n*                OUTPUT : R0 ==> 0 NORMAL RETURN                      *\n*                               \u00ac0 I/O ERROR                          *\n*                                                                     *\n*           CSOUT  ENQ,BIN,COPIES,MF=,CALL=                           *\n*                                                                     *\n*                ENQUEUES THE FILE TO PRINT, RETURNS TO START STATE.  *\n*                BIN IS ADDRESS OF 4 BYTE BIN NUMBER.                 *\n*                COPIES IS ADDRESS OF HALFWORD CONTAINING COPIES.     *\n*                MF AND CALL AS WITH OPN.                             *\n*                OUTPUT : R0 ==> 0 NORMAL, DATA SET ENQUEUED TO PRINT *\n*                               \u00ac0 ENQUEUE FAILED FOR SOME REASON     *\n*                                                                     *\n*                THE FIRST WORD OF THE WORKAREA CONTAINS THE ADDRESS  *\n*                OF THE INTERNAL LINE BUFFER TO BE FILLED BY THE      *\n*                CALLER EACH TIME HE DOES A PUT. IT IS SET AT 'OPN'   *\n*                TIME. THE BUFFER IS CLEARED AFTER EACH CALL.         *\n*                                                                     *\n*  PROGRAMMER : DON D WORTH                                           *\n*               ALTERED BY PCN FOR USE WITH TSO ZAP (1/30/77)         *\n*               MODIFIED BY LDW TO USE QSAM (12/26/78)                *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nDATA     DSECT\nOFLAGS   DS    0BL1\nOPNCALL  EQU   X'80'                    THIS IS AN OPEN CALL\nENQCALL  EQU   X'40'                    THIS IS AN ENQUEUE CALL\nPUTCALL  EQU   X'C0'                    THIS IS A PUT CALL (IF ZEROS)\nDOWTO    EQU   X'20'                    ISSUE AS A WTO ALSO\nOIOERROR EQU   X'04'                    AN I/O ERROR HAS OCCURED\nSCRCALL  EQU   X'02'                    THIS IS A SCRATCH CALL\nTRNCALL  EQU   X'01'                    THIS IS A TRUNC   CALL     LDW1\nLINELOC  DS    A                        ADDRESS OF LINE BUFFER\n*OVOLSER DS    A                        ADDRESS OF VOLUME NAME\n*BINNO   EQU   OVOLSER                  ADDRESS OF BIN NUMBER\n*SPACE   DS    A                        ADDRESS OF SPACE\n*COPIES  EQU   SPACE                    ADDRESS OF COPIES\nODBLW    DS    D                        SCRATCH DOUBLE WORD\nPAGE     DS    H                        PAGE COUNTER\nLINE     DS    H                        LINE COUNTER\nSAVEAREA DS    6F                       REGISTERS CHANGED GO HERE\nRETREG   DS    F\n         SPACE 1\n         PRINT NOGEN\nDCB      DCB   DDNAME=X,MACRF=PM,DSORG=PS,BLKSIZE=133,LRECL=133,   LDW1$\n               RECFM=FBA,SYNAD=0\nODSN     DS    CL44\n*OVOL    DS    CL6\nWTOBUFF  DS    F                                                   LDW1\n         ORG   *-1                      OVERLAY CC IN WTO PREFIX   LDW1\nOBUF     DS    CL133                    BUFFER ITSELF              LDW1\n         DS    XL4                      ROOM FOR ROUTCDE AND DESC  SDM1\nTTLBUFF  DS    CL133                    BUFFER FOR TITLE LINE      LDW1\nDATALEN  EQU   *-DATA\n         SPACE 1\n         PRINT GEN\n         EJECT\n*        C S O U T -- MAIN ENTRY, DETERMINE CALL TYPE.\n         SPACE 1\n*        HOUSEKEEPING.\n         SPACE 1\nCSOUT    CSECT\n         USING TSDSECT,R13                                         LDW1\n         TM    FLAGS2,LOGF              ARE WE LOGGING?\n         BNOR  R14                      IF NOT RETURN\n         LTR   R2,R2                    ANY WORKAREA?\n         BZR   R14                      NO, ICKY\n         STM   R9,R12,SAVEAREA-DATA(R2) SAVE SOME REGS\n         ST    R14,RETREG-DATA(R2)      SAVE WHERE TO GO BACK\n*LDW1    LR    R13,R1                   COPY TSDSECT PTR TO R13\n         LR    R12,R15                  GET BASE REG\n         LR    R10,R2                   GET WORKAREA ADDRESS\n*LDW1    OACUSING TSDSECT,R13\n         OACUSING DATA,R10                                          MVS\n         OACUSING CSOUT,R12                                         MVS\n         SPACE 1\n*        DETERMINE CALL TYPE.\n         SPACE 1\n         TM    OFLAGS,OPNCALL           OPEN?\n         BO    OPEN                     YES, GO OPEN\n         TM    OFLAGS,ENQCALL           ENQUEUE?\n         BO    ENQUEUE                  YES\n         TM    OFLAGS,SCRCALL           SCRATCH?\n         BO    SCRATCH                  YES                        LDW1\n         TM    OFLAGS,TRNCALL           TRUNCATE?                  LDW1\n         BO    TRUNC                    YES                        LDW1\n         B     PUTOUT                   NO, MUST BE PUT THEN       LDW1\n         SPACE 1\n*        WHEN DONE WITH WHATEVER, CLEAR LINE, AND PASS IT BACK.\n         SPACE 1\nEXIT     MVC   OBUF,BLANKS              CLEAR LINE BEFORE RETURN   LDW1\n         NI    OFLAGS,255-PUTCALL-DOWTO-TRNCALL  REMOVE CALL TYPE  LDW1\n         LR    R0,R15                   GET RETURN CODE\n         L     R14,RETREG               RESTORE RETURN REG\n         LM    R9,R12,SAVEAREA          RESTORE OTHER REGS\n         BR    R14                      RETURN TO CALLER\n         EJECT\n*        C S O U T -- OPEN ROUTINE.\n         SPACE 1\n*        OPEN -- PREPARE FOR CSLOC, CREATE A DATA-SET NAME.\n         SPACE 1\nOPEN     LA    R0,OBUF                  START IT OUT\n         IC    R14,LINELOC              SAVE FLAGS\n         ST    R0,LINELOC               STORE FIRST LINE ADDR\n         STC   R14,LINELOC              RESTORE FLAGS\n         MVC   ODSN(8),=CL8'ZAPLOG'     TRY ZAPLOG FIRST        .AFDSC.\n         DEVTYPE ODSN,ODSN+8            SEARCH TIOT             .AFDSC.\n         LTR   R15,R15                  IS ZAPLOG ALLOCATED     .AFDSC.\n         BZ    NOSYSOUT                 YES, BYPASS ALLOC       .AFDSC.\n         ALLOC SYSOUT='A',SPACE=(TRK,1,5,0,RLSE)                   LDW3\n         BXH   R15,R15,EXIT             RETRUN WITH ERROR CODE\n         MVC   ODSN(8),DA30DDN-DAPB30+DAPBAREA   COPY DDN\nNOSYSOUT XC    PAGE(4),PAGE             CLEAR PAGE AND LINE        LDW1\n         LA    R0,DCB                   POINT TO DCB\n         ST    R0,ODBLW                 STORE IN DCB LIST\n         MVI   ODBLW,X'8F'              MARK END OF LIST & OUTPUT\n         MVC   DCB(DCBLEN),ODCBMSK      COPY IN MASK\n         MVC   DCBDDNAM-IHADCB+DCB(8),ODSN COPY IN DDNAME          LDW3\n         OPEN  MF=(E,ODBLW)\n         TM    DCB+48,X'10'             SEE IF OPEN\n         BO    RC00                     IF SO RETURN OK\n         LA    R15,4                    IF NOT ERROR\n         B     EXIT\nTRUNC    TRUNC DCB                      WRITE OUT A SHORT BLOCK    LDW1\n         B     RC00                     THAT WAS EASY              LDW1\n         EJECT\n*        C S O U T -- PUT ROUTINE.\n         SPACE 1\n*        PUT -- CALCULATE LINE POSITION.\n         SPACE 1\nPUTOUT   LH    R0,LINE                  GET LINE NUMBER            LDW1\n         CLI   OBUF,C'1'                SKIP TO PAGE?              LDW1\n         BE    PUTPAGE                  YES, FORCE PAGE SKIP\n         CLI   OBUF,C'0'                DOUBLE SPACE?              LDW1\n         BE    SKIP2                    YES\n         CLI   OBUF,C'+'                SUPPRESS SKIP?             LDW1\n         BE    SKIP0                    YES\n         CLI   OBUF,C'-'                TRIPLE SPACE?              LDW1\n         BE    SKIP3                    NO, ANYTHING ELSE IS ONE SPACE\n         MVI   OBUF,C' '                ELSE FORCE SINGLE          LDW1\n         B     SKIP1                    AND COUNT ONE\nSKIP3    BCTR  R0,0\nSKIP2    BCTR  R0,0\nSKIP1    BCTR  R0,0\nSKIP0    LTR   R0,R0                    ANYTHING LEFT ON PAGE?\n         BNP   PUTPAGE                  NO, EJECT\n         STH   R0,LINE                  SAVE NEW LINE COUNTER\n         SPACE 1\n*        PRINT THE LINE NOW.\n         SPACE 1\n         PUT   DCB,OBUF                 DUMP OUT HIS LINE THEN     LDW1\n         SPACE 1\n*        IF WTOING, DO IT.\n         SPACE 1\n         TM    OFLAGS,DOWTO             DO WTO?\n         BZ    RC0                      NO, ALL DONE NOW\n*SDM1    XC    WTOBUFF(4),WTOBUFF       GIVE LENGTH/MCS FLAGS\n         MVC   WTOBUFF+2(2),=X'8000'    INDICATE ROUTCDE PRESENT   SDM1\n         LA    R1,WTOBUFF+123+4         LAST POSSIBLE\n         CLI   0(R1),C' '               END OF IT?\n         BNE   *+L'*+4                  YES\n         BCT   R1,*-8                   KEEP LOOKING\n         MVC   1(4,R1),=X'00004080'     SET ROUTCDE=(2,9)          SDM2\n         LA    R0,WTOBUFF-1             BEGINNING\n         SR    R1,R0                    LENGTH\n         BNP   RC0                      NULL\n         STH   R1,WTOBUFF               SAVE FOR WTO\n         WTO   MF=(E,WTOBUFF)           DO IT\nRC0      TM    OFLAGS,OIOERROR          IO ERROR?\n         BZ    RC00                     NO\n         NI    OFLAGS,255-OIOERROR      TURN OFF FLAG\n         LA    R15,8                    INDICATE IT\n         B     EXIT                     LEAVE\nRC00     XR    R15,R15                  SAY ALL IS WELL\n         B     EXIT                     THEN LEAVE\n         SPACE 1\n*        PUT OUT A TITLE IF AT TOP OF PAGE.\n         SPACE 1\nPUTPAGE  MVI   WTOBUFF+3,C'-'           TRIPLE SPACE FROM TITLE\n         MVC   LINE(2),=H'60'           RESET LINE COUNTER\n         LH    R1,PAGE                  GET PAGE COUNTER\n         LA    R1,1(R1)                 COUNT LAST PAGE\n         STH   R1,PAGE                  SAVE FOR LATER\n         CVD   R1,ODBLW                 CONVERT THE PAGE NUMBER\n         MVC   TTLBUFF,TITMSK           MOVE IN THE MASK           LDW1\n         ED    TTLBUFF+113(6),ODBLW+5   EDIT IN THE PAGE NUMBER    LDW1\n         XR    R1,R1                    ASK FOR CURRENT TIME\n         SPACE 1\n*        LINK  EP=OACNOW                GET CURRENT DATE/TIME       PCN\n         CALL  OACNOW                   GET CURRENT DATE/TIME   .AFDSC.\n* NOTE : RETURNS A PARMLIST POINTED TO BY R1 WITH THE CURRENT       PCN\n*        DATE AND TIME IN THE FORMS DESCRIBED IN THE 'NOWPARM'      PCN\n*        DSECT BELOW.                                               PCN\n         SPACE 1\n         OACUSING NOWPARM,R1                                        MVS\n         MVC   TTLBUFF+82(2),DAY        PICK UP DAY   (DD)         LDW1\n         CLI   TTLBUFF+82,C'/'          HAD THE DAY BEEN SQUISHED  LDW1\n         BNE   *+L'*+4                  NO, LEAVE IT              *VIC*\n         MVI   TTLBUFF+82,C' '          YES, BLANK IT OUT          LDW1\n         MVC   TTLBUFF+85(3),CHARDATE   PICK UP MONTH (MMM)        LDW1\n         MVC   TTLBUFF+89(2),YEAR       PICK UP YEAR  (YY)         LDW1\n*        MVC   TTLBUFF+96(8),TIME24     PICK UP TIME HH:MM:SS      LDW1\n         MVC   TTLBUFF+96(5),TIME24     PICK UP TIME HH:MM      .AFDSC.\n         OACDROP R1                                                 MVS\n         FREEMAIN R,LV=(0),A=(1)        FREE OACNOW RESULTS     .AFDSC.\n         PUT   DCB,TTLBUFF              GO DUMP THE TITLE          LDW1\n         B     PUTOUT                   NOW TRY THAT AGAIN\n         SPACE 1\n*        SYNAD : AND I/O ERROR HAS OCCURED.\n         SPACE 1\nOSYNAD   OI    OFLAGS,OIOERROR          SIGNAL ERROR\n         BR    R14                      AND RETURN\n         EJECT\nNOWPARM  DSECT                          NOWSVC (SSVC0) PARMLIST   *VIC*\n         SPACE 1\nTIME24   DS    0CL12                    TIME 24-HR....HH:MM:SS PST*VIC*\nTIME24HR DS    2C,C                     HH:                       *VIC*\nTIME24MN DS    2C,C                     MM:                       *VIC*\nTIME24SC DS    2C                       SS                        *VIC*\n         DS    C                        BLANK                     *VIC*\nTIME24TZ DS    3C                       PST OR PDT                *VIC*\n         DS    2C                       BLANKS                    *VIC*\n         SPACE 1\nNUMDATE  DS    0CL8                     THE DATE: (M)M/(D)D/YY    *VIC*\nMO       DS    2C,C                     (M)M/                     *VIC*\nDAY      DS    2C,C                     (D)D/                     *VIC*\nYEAR     DS    2C                       YY                        *VIC*\n         DS    2C                       BLANKS                    *VIC*\n         SPACE 1\nWEEKDAY  DS    9C                       THE WEEKDAY               *VIC*\n         DS    C                        BLANK                     *VIC*\n         SPACE 1\nCHARDATE DS    13C                      DATE: MMM(M) (D)D, 19YY   *VIC*\n         DS    2C                       BLANKS                    *VIC*\n         SPACE 1\nTIME12   DS    0CL15                    TIME 12-HR...HH:MM:SS AM PST\nTIME12HR DS    2C,C                     HH:                       *VIC*\nTIME12MN DS    2C,C                     MM:                       *VIC*\nTIME12SC DS    2C,C                     SS + BLANK                *VIC*\nAMPM     DS    2C                       AM OR PM                  *VIC*\n         DS    C                        BLANK                     *VIC*\nTIME12TZ DS    3C                       PDT OR PST                *VIC*\n         DS    2C                       BLANKS                    *VIC*\n         SPACE 1\nJULDATE  DS    0CL6                     THE DATE:  YY.DDD         *VIC*\nJULYEAR  DS    2C,C                     YY.                       *VIC*\nJULDAY   DS    3C                       DDD                       *VIC*\n         SPACE 2\nPARMLEN  EQU   *-NOWPARM                LENTGH OF PARMLIST (72)   *VIC*\nCSOUT    CSECT                                                    *VIC*\n         EJECT\n*        C S O U T -- ENQUEUE THE DATA-SET TO PRINT.\n         SPACE 1\n*        CLOSE THE OUTPUT DATA-SET AND FIND MTABLE.\n         SPACE 1\nENQUEUE  LA    R0,DCB                   FIND DCB                   LDW1\n         ST    R0,ODBLW                 SAVE IT\n         MVI   ODBLW,X'80'              CLOSE JUST THIS ONE\n         CLOSE MF=(E,ODBLW)             CLOSE THE DS\n         CLC   ODSN(8),=CL8'ZAPLOG'     WAS ZAPLOG PRE-ALLOC    .AFDSC.\n         BE    RC00                     YES, BYPASS UNALLOCATE  .AFDSC.\n         FREE  DDNAME=ODSN,SYSOUT='A'   AND FREE IT\n         B     RC00                     NOW RETURN TO CALLER\n         EJECT ,                                                   LDW1\nSCRATCH  LA    R0,DCB                   POINT TO DCB               LDW1\n         ST    R0,ODBLW                 STORE IN LIST\n         MVI   ODBLW,X'80'              MARK AS END OF LIST\n         CLOSE MF=(E,ODBLW)             CLOSE IT\n         CLC   ODSN(8),=CL8'ZAPLOG'     WAS ZAPLOG PRE-ALLOC    .AFDSC.\n         BE    RC00                     YES, BYPASS UNALLOCATE  .AFDSC.\n         FREE  DDNAME=ODSN,DISP=DELETE                             LDW1\n         B     RC00                     RETURN\n         EJECT\n*        C S O U T -- CONSTANTS.\n         SPACE 1\n*TITMSK  DC    CL133'1U C L A / O A C                         *** TSO Z\n*              AP  SESSION RECORD          *** DD MMM YY *** HH:MM:SS *\n*              ** PAGE _____'                                      LDW4\nTITMSK   DC    CL133'1A F D S C                               --- TSO ZX\n               AP  SESSION RECORD ---      *** DD MMM YY *** HH:MM *** X\n                  PAGE _____'                                   .AFDSC.\n         ORG   TITMSK+114\n         DC    X'2020202120'\n         ORG\n         SPACE 1\n*        DCB MASK.\n         SPACE 1\n         PRINT NOGEN\nODCBMSK  DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,RECFM=FBA,LRECL=133,  X\n               SYNAD=OSYNAD,BLKSIZE=4123,BUFNO=1                   LDW1\nDCBLEN   EQU   *-ODCBMSK\n         PRINT GEN\n         SPACE 2\n*        LITERAL POOL.\n         SPACE 1\n         LTORG\n         EJECT\n*        ZAP --- HELP FOR ZAP. (HLP)                               LDW1\n         SPACE 1\nZAPHELP  CSECT\n         DC    A(NUMHELPS)                                         LDW1\n         DC    A(FIRST)                                            LDW1\n         DC    AL1(0,0,0,0,0,0,0,0,0,0,0,0,0)    1                 LDW1\n         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,1,0)    2                 LDW2\n         DC    AL1(0,0,1,1,1,1,1,1,0,0,0,0,0)    3                 LDW4\n         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,1,1)    4                 LDW1\n         DC    AL1(0,0,1,1,1,1,1,1,1,1,1,1,1)    5                 LDW4\n         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,0,0)    6                 LDW3\n         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,0,1)    7                 LDW3\n         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,1,1)    8                 LDW1\n         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,1,1)    9                 LDW1\n         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,1,0)    10                LDW4\n         DC    AL1(0,0,1,1,1,1,1,1,1,1,1,1,1)    11                LDW4\n         DC    AL1(1,1,1,1,1,1,1,1,1,1,1,1,1)    12                LDW1\n         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,1,1)    13                LDW2\n         SPACE 1\nFIRST    DS    0F                                                  LDW1\n         SPACE 1\n*        IMAGE # 1.                                                LDW1\n         SPACE 1\n         DC    CL40'                CONTENTS                '      LDW1\n         DC    CL40'                                        '      LDW1\n         DC    CL40'?1       - THIS SCREEN                  '      LDW2\n         DC    CL40'?2, ?3   - GENERAL INFORMATION          '      LDW2\n         DC    CL40'?4, ?5   - INPUT/OUTPUT COMMANDS        '      LDW2\n         DC    CL40'?6       - SESSION CONTROL COMMANDS     '      LDW2\n         DC    CL40'?7       - DUMP COMMANDS                '      LDW2\n         DC    CL40'?8       - BYTE COMMANDS                '      LDW2\n         DC    CL40'?9       - STRING COMMANDS              '      LDW2\n         DC    CL40'?10, ?11 - MISCELLANEOUS COMMANDS       '      LDW2\n         DC    CL40'?12      - EXPLANATION OF SYMBOLS       '      LDW2\n         DC    CL40'?13      - SAMPLE ZAP SESSION           '      LDW2\n         DC    CL40'                                        '      LDW2\n         SPACE 1\n*        IMAGE # 2.                                                LDW1\n         SPACE 1\n         DC    CL40'              GENERAL INFO              '      LDW2\n         DC    CL40'                                        '      LDW2\n         DC    CL40'-- THE OPERANDS ARE ENTERED AFTER THE   '      LDW2\n         DC    CL40'   COMMAND, WITH NO INTERVENING BLANKS. '      LDW2\n         DC    CL40'-- THE BLOCK IS READ INTO A WORK BUFFER,'      LDW2\n         DC    CL40'   WHERE YOU MODIFY IT. WHEN YOU ENTER A'      LDW2\n         DC    CL40'   \"ZAP\" COMMAND, THE BLOCK IS WRITTEN  '      LDW2\n         DC    CL40'   BACK TO THE DATA-SET FROM THE BUFFER.'      LDW2\n         DC    CL40'   IF ANY OTHER JOB OR USER HAS UPDATED '      LDW2\n         DC    CL40'   THAT BLOCK IN BETWEEN WHEN YOU FIRST '      LDW2\n         DC    CL40'   DISPLAYED IT AND WHEN YOU \"ZAPPED\"   '      LDW2\n         DC    CL40'   IT, THE OTHER CHANGES WILL BE LOST.  '      LDW2\n         DC    CL40'                                        '      LDW2\n         SPACE 1\n*        IMAGE # 3.                                                LDW2\n         SPACE 1\n         DC    CL40'        GENERAL INFO (CONTINUED)        '      LDW2\n         DC    CL40'                                        '      LDW2\n         DC    CL40'-- IF YOU MAKE CHANGES TO A BLOCK, TO   '      LDW2\n         DC    CL40'   GO TO ANOTHER BLOCK YOU MUST EITHER  '      LDW2\n         DC    CL40'   \"ZAP\" THE BLOCK (RE-WRITE IT TO THE  '      LDW2\n         DC    CL40'   DATA-SET), OR ENTER THE COMMAND TWICE'      LDW4\n         DC    CL40'   IN A ROW WHICH WILL CAUSE YOU TO     '      LDW4\n         DC    CL40'   LEAVE TO CURRENT MODIFIED BLOCK.     '      LDW4\n         DC    CL40'                                        '      LDW4\n         DC    CL40'                                        '      LDW4\n         DC    CL40'                                        '      LDW2\n         DC    CL40'                                        '      LDW2\n         DC    CL40'                                        '      LDW2\n         SPACE 1                                                   LDW1\n*        IMAGE # 4.                                                LDW1\n         SPACE 1                                                   LDW1\n         DC    CL40'         INPUT/OUTPUT COMMANDS          '      LDW1\n         DC    CL40'                                        '      LDW1\n         DC    CL40'P<EXP> - POINT TO RECORD WHOSE TTR=EXP  '\n         DC    CL40'P      - POINT TO BEGINNING OF DATA-SET '\n         DC    CL40'T<EXP> - POINT TO TRACK <EXP>, RECORD 1 '\n         DC    CL40'T      - POINT TO NEXT TRACK, RECORD 1  '\n         DC    CL40'R<EXP> - SHOW BLOCK <EXP> RELATIVE TO   '       *N*\n         DC    CL40'         CURRENT                        '       *N*\n         DC    CL40'R      - POINT TO NEXT PHYSICAL RECORD  '       *N*\n         DC    CL40'B      - POINT TO PREVIOUS RECORD       '       *N*\n         DC    CL40'LAST   - POINT TO LAST RECORD (DS1LSTAR)'       *N*\n         DC    CL40'LASTDS1- POINT TO LAST FORMAT 1 IN VTOC '      LDW1\n         DC    CL40'ABS<EXP> - POINT TO REC. WITH CCHHR=EXP '      JCJ1\n         SPACE 1\n*        IMAGE # 5.                                                LDW1\n         SPACE 1\n         DC    CL40'       MORE INPUT/OUTPUT COMMANDS       '      LDW1\n         DC    CL40'                                        '      LDW1\n         DC    CL40'%<EXP> - POINT TO TTR @ LOC <EXP> IN    '      LDW1\n         DC    CL40'         BLOCK                          '      LDW1\n         DC    CL40'M<NAME>- FOR PDS, POINT TO MEMBER <NAME>'       *N*\n         DC    CL40'M      - POINT TO START OF THE CURRENT  '      LDW4\n         DC    CL40'         MEMBER                         '      LDW4\n         DC    CL40'NAME<N>- AFTER ''M'', SHOW ENTRY POINT <N>'     *N*\n         DC    CL40'NAME   - SELECT ENTRY POINT NAMED MEMBER'      LDW1\n         DC    CL40'E<N>   - SAME AS NAME<N>                '       *N*\n         DC    CL40'E      - SAME AS NAME                   '       *N*\n         DC    CL40'ZAP    - REPLACE BLOCK FROM THE CURRENT '\n         DC    CL40'         BUFFER                         '\n         SPACE 1\n*        IMAGE # 6.                                                LDW1\n         SPACE 1\n         DC    CL40'        SESSION CONTROL COMMANDS        '      LDW1\n         DC    CL40'                                        '      LDW1\n         DC    CL40'LOG      - START LOGGING THIS SESSION   '\n         DC    CL40'CRT      - SET WIDTH 4,4 AND VERBOSE    '\n         DC    CL40'TERSE    - DO NOT DO AUTO WHERE         '\n         DC    CL40'VERBOSE  - ALWAYS GIVE WHERE INFO       '\n         DC    CL40'W<D>,<U> - SET WINDOW DOWN/UP SIZE(S)   '\n         DC    CL40'WFULL    - SET SIZE TO URSA SCREEN SIZE '\n         DC    CL40'LINE40, LINE80 - SET LINE LENGTH 40 | 80'      LDW3\n         DC    CL40'NOTE<COMNT>-WRITE <COMNT> INTO LOG FILE '      LDW1\n         DC    CL40'EJECT    - EJECT A PAGE IN THE LOG FILE '      LDW1\n         DC    2CL40'                                        '     LDW3\n         SPACE 1                                                   LDW1\n*        IMAGE # 7.                                                LDW1\n         SPACE 1                                                   LDW1\n         DC    CL40'             DUMP COMMANDS              '      LDW1\n         DC    CL40'                                        '      LDW1\n         DC    CL40'DUMP       - DUMP ALL RECORDS IN THE    '\n         DC    CL40'             DATA-SET IN ABDUMP FORMAT  '\n         DC    CL40'DUMPT<EXP> - DUMP TO TTR <EXP> FROM     '\n         DC    CL40'             CURRENT RECORD             '\n         DC    CL40'DUMPT      - DUMP CURRENT RECORD ONLY   '\n         DC    CL40'DUMPF<EXP> - DUMP FOR <EXP> RECORDS FROM'\n         DC    CL40'             CURRENT RECORD             '\n         DC    CL40'DUMPF      - DUMP CURRENT RECORD        '\n         DC    CL40'DUMPE      - DUMP CURRENT RECORD TO EOF '      LDW1\n         DC    CL40'                                        '\n         DC    CL40'EOF, I/O ERROR OR END-OF-DS : HALT DUMP '\n         SPACE 1                                                   LDW1\n*        IMAGE # 8.                                                LDW1\n         SPACE 1                                                   LDW1\n         DC    CL40'             BYTE COMMANDS              '      LDW1\n         DC    CL40'                                        '      LDW1\n         DC    CL40'D<EXP> - DISPLAY BYTE AT OFFSET <EXP>   '\n         DC    CL40'<EXP>  - SAME AS D<EXP>                 '\n         DC    CL40'D      - PAGE TO NEXT SCREEN (D+#SCREEN)'      LDW1\n         DC    CL40'U      - PAGE TO PREV SCREEN (D-#SCREEN)'      LDW1\n         DC    CL40'>      - GO FORWARD IN TRACE TABLE      '\n         DC    CL40'<      - GO BACKWARD IN TRACE TABLE     '\n         DC    CL40'EBCDIC - EBCDIC TRANSLATION (DEFAULT)   '\n         DC    CL40'ASCII  - ASCII-8 TRANSLATION            '\n         DC    CL40'ZCODE  - ZCODE TRANSLATION              '\n         DC    CL40'=<LAB> - DEFINE <LAB> TO CURRENT LOC    '\n         DC    CL40'NODEF  - CLEAR ALL DEFINED LABELS FROM ='\n         SPACE 1                                                   LDW1\n*        IMAGE # 9.                                                LDW1\n         SPACE 1                                                   LDW1\n         DC    CL40'            STRING COMMANDS             '      LDW1\n         DC    CL40'                                        '      LDW1\n         DC    CL40'S<STR>   - STORE <STR> AT CURRENT LOC   '\n         DC    CL40'X<STR>   - EXCLUSIVE OR AT CURRENT LOC  '\n         DC    CL40'O<STR>   - OR AT CURRENT LOC            '\n         DC    CL40'N<STR>   - AND AT CURRENT LOC           '\n         DC    CL40'SET<STR> - SET ENTIRE RECORD TO <STR>   '\n         DC    CL40'           S,X,O,N,SET MAY BE ENTERED   '\n         DC    CL40'           ALONE TO USE PREVIOUS <STR>  '\n         DC    CL40'L<STR>   - LOOK FOR <STR> FROM NEXT BYTE'\n         DC    CL40'L        - CONTINUE LOOKING FOR <STR>   '\n         DC    CL40'F<STR>   - LIKE L<STR>, CONT''S PAST EOFS'     LDW1\n         DC    CL40'F        - LIKE L, CONTINUES PAST EOFS  '      LDW1\n         SPACE 1                                                   LDW1\n*        IMAGE # 10.                                               LDW1\n         SPACE 1                                                   LDW1\n         DC    CL40'         MISCELLANEOUS COMMANDS         '      LDW1\n         DC    CL40'                                        '      LDW1\n         DC    CL40'END    - EXIT ZAP                       '\n         DC    CL40'#<EXP> - FIND HEX/DECIMAL VALUE OF <EXP>'\n         DC    CL40'FLOAT<F> - FIND FLOATING PT VALUE OF <F>'\n         DC    CL40'IDEF   - DISPLAY DEFINE LABEL TABLE     '\n         DC    CL40'ITRACE - DISPLAY TRACE TABLE            '\n         DC    CL40'?N     - VIEW NTH HELP DISPLAY (1-13)   '      LDW1\n         DC    CL40'WHERE  - GIVE CURRENT LOCATION ETC...   '\n         DC    CL40'ASM<OP> - GIVE OBJECT CODE FOR MNEMONIC '\n         DC    CL40'DISASM<EXP> - DISASSEMBLE INSTRUCTION   '      LDW1\n         DC    CL40'         AT <EXP>                       '      LDW1\n         DC    CL40'CAPSON/CAPSOFF - FOR STRING COMMANDS    '  -EU-LDW4\n         SPACE 1\n*        IMAGE # 11.                                               LDW1\n         SPACE 1\n         DC    CL40'      MORE MISCELLANEOUS COMMANDS       '      LDW1\n         DC    CL40'                                        '      LDW1\n         DC    CL40'WHATMEM  - FIND DIRECTORY ENTRY CLOSEST '      LDW4\n         DC    CL40'           TO CURRENT RECORD            '      LDW4\n         DC    CL40'WM       - SAME AS WHATMEM              '      LDW4\n         DC    CL40'DO<CMD>  - EXECUTE TSO <CMD> AS AT READY'      LDW1\n         DC    CL40'V<EXP>   - ADD CONTENTS OF 2 BYTES AT   '      LDW5\n         DC    CL40'           <EXP> TO CURRENT VALUE OF LOC'      LDW5\n         DC    CL40'BASE<EXP>- ADD <EXP> TO BUFFER OFFSET   '      LDW1\n         DC    CL40'           WHEN COMPUTING ADDRESS       '      LDW1\n         DC    CL40'DISP<TYPE> - SET RECORD DISPLAY START   '      LDW1\n         DC    CL40'           POS. <TYPE> IS COUNT-KEY-DATA'      LDW1\n         DC    CL40'J<TTR>   - REL. TO BEGINING OF VOLUME   '      LDW5\n         SPACE 1                                                   LDW1\n*        IMAGE # 12.                                               LDW1\n         SPACE 1                                                   LDW1\n         DC    CL40'<EXP> IS COMPOSED OF OPERATORS (+,-,*,/)'      LDW1\n         DC    CL40'    DEFINE SYMBOLS (''='' COMMAND) AND    '\n         DC    CL40'    HEX OR DEC CONSTANTS. THE FOLLOWING '\n         DC    CL40'    SYMBOLS ARE PREDEFINED : * = CURRENT'\n         DC    CL40'    OFFSET, L = LOGICAL RECORD LENGTH,  '\n         DC    CL40'    K = KEY LENGTH, BL = MAX. BLKSIZE.  '\n         DC    CL40'<STR> MAY BE EITHER UP TO 16 CHARACTERS '\n         DC    CL40'    ENCLOSED IN ANY DELIMITER, OR UP    '\n         DC    CL40'    TO 16 HEX DIGITS, OR A DECIMAL VALUE'\n         DC    CL40'    ENDING WITH ''.'' (LENGTH 4 BYTES). '\n         DC    CL40'<LAB> MAY ANY 1 TO 8 CHARACTERS.        '\n         DC    CL40'<F>   IS ANY FLOATING POINT CONSTANT IN '\n         DC    CL40'    INTERNAL FORM (IE : FORTRAN A FORM).'\n         SPACE 1\n*        IMAGE # 13.                                               LDW2\n         SPACE 1\n         DC    CL40'           SAMPLE ZAP SESSION           '      LDW2\n         DC    CL40'                                        '      LDW2\n         DC    CL40'ZAP LOAD   READY LEVEL COMMAND ENTERED  '      LDW2\n         DC    CL40'MTEST      SELECT MEMBER \"TEST\"         '      LDW2\n         DC    CL40'EFIRST     SELECT ENTRY POINT \"FIRST\"   '      LDW2\n         DC    CL40'4C         GO TO OFFSET X''4C'' IN RECORD '    LDW2\n         DC    CL40'S00        STORE ONE BYTE HEXADECIMAL   '      LDW2\n         DC    CL40'+4         ADVANCE PTR 4 BYTES IN BLOCK '      LDW2\n         DC    CL40'NFF0F      TURN OFF ONE NIBBLE          '      LDW2\n         DC    CL40'ZAP        RE-WRITE THAT BLOCK          '      LDW2\n         DC    CL40'R+3        GO TO THIRD BLOCK FROM HERE  '      LDW2\n         DC    CL40'L/HELLO/   FIND SOME TEXT               '      LDW2\n         DC    CL40'END        ALL DONE - EXIT ZAP          '      LDW2\n         SPACE 2\nNUMHELPS EQU   (*-FIRST)/40                                        LDW1\n         EJECT\n*        ZAP --- ASMGASM --- OP CODE PARSE. (ASM)                  LDW1\n         SPACE 1\n*        ASSEMBLE OR DISASSEMBLE.\n         SPACE 1\nASMGASM  CSECT ,\n         SAVE  (14,12),,*\n         LR    R12,R15                  BASE\n         USING ASMGASM,R12\n         LTR   R1,R1                    ASM OR DISASM?\n         BM    DISASMIT                 GUESS...                   LDW1\n         SPACE 1\n*        ASM  ---  R1 = PTR TO CL4'MNEMONIC'.\n         SPACE 1\n         LA    R2,OPCODES               TABLE\n         L     R15,=A(OPEND-OPLEN)      END BXLE\n         LA    R14,OPLEN                LENGTH\nOPLOOP   CLC   0(4,R1),0(R2)            THIS ONE (KLUGE)\n         BE    GOTOP                    YES\n         BXLE  R2,R14,OPLOOP            TRY ALL POSSIBLES\nBADRET   LA    R15,4                    INVALID OP CODE\n         B     RETURN                   BYE\nGOTOP    LA    R1,5(,R2)                POINT TO OP IN HEX\nGOODRET  XR    R15,R15                  RC=0\nRETURN   L     R14,12(,R13)             RESTORE R14  **** NOTE R0 NOT\n         LM    R2,R12,12+16(R13)        REST REGS         RESTORED ****\n         BR    R14                      BYE\n         SPACE 1\n*  DISASM  ---  R1 = PTR TO BUFF LOC OF OBJECT CODE\n*               R0 = PTR TO OUTPUT BUFFER  (33 BYTES)\n*               R2 = PTR TO 5 DOUBLEWORDS WORKAREA\n*      OUTPUT : R15= RC\n*               R1 = INSTR LEN IF R15=0\n         SPACE 1\nDISASMIT LPR   R1,R1                    GET POS 1ST                LDW1\n         LR    R7,R2                    SAVE WORK BASE\n         LR    R9,R0                    SAVE OUTPUT BUFF PTR\n         SPACE 2\nJCJWORK  DSECT\nDOUBLE   DS    D\nDBL      DS    D                                                   LDW1\nEDITWORK DS    6C                                                  LDW1\nFLAGS    DS    X\n         SPACE 2\nASMGASM  CSECT ,\n         USING JCJWORK,R7\n         SPACE 1\n*        THIS ROUTINE WRITTEN BY JCJ 1/75.\n         SPACE 1\n         MVC   DBL(8),0(R1)             ALIGN POSSIBLE INSTRUCTION LDW1\n         LA    R6,DBL                   POINT TO INSTR             LDW1\n         SPACE 1\n***********************************************************************\n* DISASSEM                                                            *\n* RETURNS :                                                           *\n*        R15 - LENGTH OF INSTRUCTION OR ZERO IF NON-VALID OPCODE.     *\n*              FILLED IN SCREEN BUFFER IF OPCODE WAS VALID.           *\n* NOTE : WE GO THROUGH SOME CONTORTIONS IN ORDER TO BE ABLE TO        *\n*        SPECIFY THE OPCODE FLAG FIELDS IN EBCDIC CHARACTER FORM      *\n*        (IMAGE-ENTERABLE).                                           *\n***********************************************************************\n         SPACE 1\n         XR    R15,R15                  READY FOR IC\n         XR    R2,R2                    CLEAR TRT REG\n         TRT   0(1,R6),OPTAB            TRANSLATE THE OPCODE\n         BZ    BADRET                   BRANCH IF NON-VALID OPCODE\n         LA    R4,1                     GET F'1' FOR LATER\n         SLR   R2,R4                    FIX FOR PROPER TABLE INDEX\n         MH    R2,H6                    GET OFFSET INTO TABLE\n         LA    R1,OPCODES(R2)           PNT TO PROPER MNENOMIC\n         MVC   0(4,R9),0(R1)            MOVE IN MNENOMIC\n         MVC   FLAGS(1),4(R1)           GET THE FLAG BYTE\n         IC    R15,1(,R6)               GET THE REG BYTE\n         LR    R2,R15                   GET IT IN R2 FOR LATER\n         SPACE 1\n*        NOW CHECK IF IT IS AN EXTENDED MNENOMIC INSTRUCTION.\n         SPACE 1\n         TM    FLAGS,X'04'              EXTENDED MNENOMIC FLAG ON?\n         BZ    GETTYPE                  NO, GO ON WITH THE REST\n         TM    FLAGS,X'02'              INDEX REG FLAG ON?\n         BZ    GETMNE                   NO, GO GET THE MMENOMIC\n         SPACE 1\n*        GETMNE RETURNS TO GETINST - WE DON'T CARE IF WE GO THROUGH\n*        THIS CODE FOR NON-MNENOMICS THOUGH.\n         SPACE 1\nGETINST  CLI   1(R9),C'C'               GOT AN EXTENDED MNENOMIC?\n         BNE   *+L'*+4                  YES, SKIP THE BIT RESET\n         OI    FLAGS,X'02'              NO, FAKE OUT A RR(OR RX) TYPE\nGETTYPE  CLC   0(4,R9),OPCODES          IS IT SPM?\n         LA    R9,7(,R9)                INCREMENT LINE PNTR\n         BNE   GETTYPE#                 NO, SKIP FLAG RESET/BRANCH\n         MVI   FLAGS,C'<'               RESET FLAG FOR LATER TEST\n         B     GETRR#                   AND GO PROCESS SPM\nGETTYPE# TM    FLAGS,X'90'              IS LENGTH FOUR BYTES?\n         BZ    GETRR                    NO, GET 2 BYTE INSTRUCTION\n         BM    GETSS                    NO, GET 6 BYTE INSTRUCTION\n         SPACE 1\n*        HAVE AN FOUR BYTE TYPE WHEN WE FALL THROUGH TO HERE.\n         SPACE 1\n         CLI   FLAGS,C'M'  (GETRX)      DO WE WANT A REGISTER?\n         BNH   RXDISP                   NO, GO GET DISP FIELD\n         LR    R2,R15                   GET REG BYTE BACK\n         SRDL  R2,4                     SHIFT TO GET FIRST REG\n         BAS   R14,GETNUM               PUT CHAR VALUE IN SCREEN\n         BAS   R14,COMMA                PUT IN A COMMA\n         CLI   FLAGS,C'R'               TWO REGISTERS NEEDED?\n         BNE   RXDISP                   NO, GET DISPLACEMENT\n         SLDL  R2,4                     GET THE OTHER REG\n         BAS   R14,GETNUM               AND PUT IT IN SCREEN\n         BAS   R14,COMMA                MOVE IN A COMMA\nRXDISP   BAS   R5,GETDISP               GET THE DISP FIELD\n         TM    FLAGS,X'04'              NEED AN INDEX REG?\n         BZ    RXNOIND                  NO, GET THE BASE ONLY\n         SLDL  R2,4                     AND PICK UP THE INDEX REG\n         BAS   R14,GETNUM               PUT IT IN SCREEN\n         BAS   R14,COMMA                MOVE IN A COMMA\nRXNOIND  BAS   R5,GETBASE               GET THE BASE BYTE\n         CLI   FLAGS,C'L'               IMMEDIATE TYPE?\n         BNE   DISLEAVE                 NO, LEAVE\n         SPACE 1\n*        WE HAVE AN SI TYPE HERE.\n         SPACE 1\n         MVC   0(3,R9),SICHAR           MOVE IN ,X'\n         HEX   (3,R9),(1,R6),LEN=1,HEXTAB=HEXTAB,BYTE=C''''        LDW1\n         B     DISLEAVE                 AND LEAVE\n         SPACE 1\n*        TWO BYTE INSTRUCTIONS.\n         SPACE 1\nGETRR    LR    R2,R15                   GET REG BYTE BACK\n         CLI   FLAGS,C'+'               SVC?\n         BE    RRSVC                    YES, GO PROCESS IT\n         BL    MNENT                    EXTENDED MNENOMIC HERE\nGETRR#   SRDL  R2,4                     GET FIRST REGISTER VALUE\n         BAS   R14,GETNUM               MOVE IN THE CHAR VALUE\n         CLI   FLAGS,C'<'               SPM INST?\n         BE    DISLEAVE                 YES, LEAVE\n         BAS   R14,COMMA                MOVE IN A COMMA\nMNENT    XR    R2,R2                    ZERO PARM REG\n         SLDL  R2,4                     GET OTHER REG\nRRSVC    BAS   R14,GETNUM               MOVE IN THE CHAR AGAIN\n         B     DISLEAVE                 GO AWAY\n         SPACE 1\n*        THIS SECTION HANDLES 6 BYTE INSTRUCTIONS.\n         SPACE 1\nGETSS    LR    R0,R2                    SAVE THE REG BYTE (LENGTH)\n         BAS   R5,GETDISP               GEN FIRST DISPLACEMENT\n         LR    R2,R0                    GET THE REG BYTE BACK\n         TM    FLAGS,X'01'              ONLY ONE LENGTH FIELD?\n         BO    *+L'*+4                  YES, SKIP THE REG SHIFT\n         SRDL  R2,4                     GET THE FIRST LENGTH FIELD\n         BAS   R14,GETNUMI              MOVE IN THE CHAR VALUE\n         BAS   R14,COMMA                MOVE IN A COMMA\n         BAS   R5,GETBASE               GET THE BASE FIELD\n         BAS   R14,COMMA                MOVE IN A COMMA\n         LH    R2,4(,R6)                GET SECOND DISP FIELD\n         BAS   R5,GETDISP#              MOVE IT TO THE SCREEN\n         TM    FLAGS,X'01'              SINGLE LENGTH?\n         BO    SSL1                     YES, SKIP 2ND LEN PROCESSING\n         SLDL  R2,4                     GET 2ND LENGTH\n         BAS   R14,GETNUMI              AND MOVE IT TO SCREEN\n         BAS   R14,COMMA                A DELIMITER OR TWO\nSSL1     IC    R2,4(,R6)                GET SECOND BASE FIELD\n         BAS   R5,GETBASE#              GET THE BASE IN SCREEN\nDISLEAVE TM    FLAGS,X'10'              DO WE HAVE A BAD LENGTH?\n         BZ    *+L'*+4                  NO, HOP OVER THE BIT RESET\n         NI    FLAGS,255-X'40'          FIX FOR CORRECT LENGTH\n         XR    R1,R1                    SET UP FOR IC\n         IC    R1,FLAGS                 GET THE LENGTH\n         SRL   R1,5                     WIPE OUT FLAG BITS  = LENGTH\n         B     GOODRET                  EXIT OK\n         SPACE 1\n*        EXTENDED MNENOMIC ROUTINE.\n         SPACE 1\nGETMNE   SRDL  R2,4                     SHIFT TO CLEAR OUT REG NIBBLE\n         MH    R2,H6                    INDEX INTO TABLE\n         LA    R1,MNEOPS(R2)            PNT TO TABLE ENTRY\n         MVC   0(3,R9),0(R1)            MOVE IN PRIMARY MNEMONIC\n         CLI   3(R1),C' '               SECONDARY MNENOMIC PRESENT?\n         BE    GETMNE#                  NO, CONTINUE ON\n         MVC   5(3,R9),3(R1)            GET SECONDARY ONE\n         LR    R14,R9                   SAVE CURR BUFFER PNTR\n         AH    R9,H6                    AND UP WORK BUFFER PNTR\nGETMNE#  TM    FLAGS,X'80'              NON 2 BYTE INSTRUCTION?\n         BO    GETINST                  YES, LEAVE\n         CLI   3(R1),C' '               TWO MNENOMICS NEEDED?\n         BE    ONEMNE                   NO, SO DO ONE DUMMY...\n         BAS   R5,RLOOP                 PUT IN A 'R' (RR TYPE)\nONEMNE   LR    R14,R9                   PNT TO CURR MNEMONIC\n         LA    R5,GETINST               FAKE OUT A BAS AND RETURN\nRLOOP    ALR   R14,R4                   PNT TO NEXT CHAR\n         CLI   0(R14),C' '              A BLANK WAITING FOR 'R'?\n         BNE   RLOOP                    NO, INCREMENT\n         MVI   0(R14),C'R'              YES, PUT IN THE 'R'\n         BR    R5                       AND GO HOME\n         EJECT\n*        U T I L I T Y     R O U T I N E S.\n         SPACE 1\n*        DISASSEMBLER BAS ROUTINES - USED TO SAVE BYTES HERE AND THERE.\n*        THIS SECTION GETS THE BASE REG.\n         SPACE 1\nGETBASE  IC    R2,2(,R6)                GET THE BASE\nGETBASE# SRL   R2,4                     SHIFT OUT GARBAGE\n         BAS   R14,GETNUM               GO MOVE TO SCREEN\n         MVI   0(R9),C')'               PUT IN A R-PAREN\n         ALR   R9,R4                    INCREMENT LINE PNTR\n         BR    R5                       GO TO CALLER\n         SPACE 1\n*        THIS SECTION GETS THE DISPLACEMENT FIELD.\n         SPACE 1\nGETDISP  LH    R2,2(,R6)                LOAD THE DISPLACEMENT\nGETDISP# N     R2,DISPMASK              WIPE OUT BASE BITS\n         BAS   R14,GETNUM               DO THE MOVE TO SCREEN\n         CLI   FLAGS,C'J'               IS IT SVCX OR DIAGNOSE?\n         BE    DISLEAVE                 YES, GO AWAY\n         MVI   0(R9),C'('               ELSE MOVE IN A L-PAREN\n         ALR   R9,R4                    INCREMENT LINE PNTR\n         BR    R5                       GO TO CALLER\nCOMMA    MVI   0(R9),C','               MOVE IN A COMMA\n         ALR   R9,R4                    INCREMENT PNTR\n         BR    R14                      GO TO CALLER\n         SPACE 1\n*        THIS ROUTINE PUTS THE CHAR VALUE OF THE CONTENTS OF\n*        R2 INTO THE SCREEN (VIA R9) AND UPDATES R9 (POINT TO\n*        THE NEXT AVAILABLE POSITION).\n         SPACE 1\nGETNUMI  ALR   R2,R4                    INCREMENT FOR A LENGTH FIX\nGETNUM   CVD   R2,DOUBLE                GET IT IN DECIMAL\n         MVC   EDITWORK(6),EDITMASK     SET UP FOR EDIT\n         LA    R15,EDITWORK+5           PNT TO END OF AREA\n         LR    R1,R15                   SET UP R1 FOR EDMK\n         EDMK  EDITWORK(6),DOUBLE+5     DO THE EDIT\n         SR    R15,R1                   GET THE EXECUTE LENGTH\n         EX    R15,NUMMOVE              MOVE THE VALUE TO THE SCREEN\n         LA    R9,1(R15,R9)             UPDATE THE SCREEN PNTR\n         XR    R2,R2                    ZERO OUR WORK REG\n         BR    R14                      GO HOME\nNUMMOVE  MVC   0(0,R9),0(R1)            << EXECUTED >>\n         EJECT\n*        D A T A.\n         SPACE 1\nDISPMASK DC    0F'0',XL4'00000FFF'\nH6       DC    H'6'\nEDITMASK DC    X'402020202120'\nSICHAR   DC    C',X'''\n         DC    C'0123456789ABCDEF'\nHEXTAB   EQU   *-256\n         SPACE 2\n*        E X T E N D E D   M N E N O M I C   T A B L E.\n         SPACE 1\nMNEOPS   DC    CL6'NOP   '\n         DC    CL6'BO    '\n         DC    CL6'BH BP '\n         DC    CL6'BC    '\n         DC    CL6'BL BM '\n         DC    CL6'BC    '\n         DC    CL6'BC    '\n         DC    CL6'BNEBNZ'\n         DC    CL6'BE BZ '\n         DC    CL6'BC    '\n         DC    CL6'BC    '\n         DC    CL6'BNLBNM'\n         DC    CL6'BC    '\n         DC    CL6'BNHBNP'\n         DC    CL6'BNO   '\n         DC    CL6'B     '\n         SPACE 2\n*        O P C O D E   T R A N S L A T E   T A B L E.\n         SPACE 1\n*OPTAB   DC    X'0000000001020304050607000000000008090A0B0C0D0E0F'\n*LDW1    DC    X'101112131415161718191A1B1C1D1E1F2021222324252627'\n*LDW1    DC    X'28292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F'\n*LDW1    DC    X'404142434400454647480000494A4B4C4D4E4F5051525354'\n*LDW1    DC    X'55000000000000565758595A5B5C5D5E5F00000000000000'\n*LDW1    DC    X'60616263646566676800696A6B6C6D6E6F70717273747576'\n*LDW1    DC    X'7778797A7B7C7D7E7F000000808182830000000000000000'\n*LDW1    DC    X'000000000000000000000000000000000000000000000000'\n*LDW1    DC    X'00000000000000000000000000000000008485868788898A'\n*LDW1    DC    X'000000008B8C8D8E00000000000000000000000000000000'\n*LDW1    DC    X'008F9091000000009293949596970000'\n         SPACE 1                                                   LDW1\nOPTAB    DC    AL1(@00,@00,@00,@00,@04,@05,@06,@07)                LDW1\n         DC    AL1(@08,@09,@0A,@0B,@00,@0D,@0E,@0F)            -EU-LDW1\n         DC    AL1(@10,@11,@12,@13,@14,@15,@16,@17)                LDW1\n         DC    AL1(@18,@19,@1A,@1B,@1C,@1D,@1E,@1F)                LDW1\n         DC    AL1(@20,@21,@22,@23,@24,@25,@26,@27)                LDW1\n         DC    AL1(@28,@29,@2A,@2B,@2C,@2D,@2E,@2F)                LDW1\n         DC    AL1(@30,@31,@32,@33,@34,@35,@36,@37)                LDW1\n         DC    AL1(@38,@39,@3A,@3B,@3C,@3D,@3E,@3F)                LDW1\n         DC    AL1(@40,@41,@42,@43,@44,@45,@46,@47)                LDW1\n         DC    AL1(@48,@49,@4A,@4B,@4C,@4D,@4E,@4F)            -EU-LDW1\n         DC    AL1(@50,@51,@00,@00,@54,@55,@56,@57)                LDW1\n         DC    AL1(@58,@59,@5A,@5B,@5C,@5D,@5E,@5F)                LDW1\n         DC    AL1(@60,@00,@00,@00,@00,@00,@00,@67)                LDW1\n         DC    AL1(@68,@69,@6A,@6B,@6C,@6D,@6E,@6F)                LDW1\n         DC    AL1(@70,@00,@00,@00,@00,@00,@00,@00)                LDW1\n         DC    AL1(@78,@79,@7A,@7B,@7C,@7D,@7E,@7F)                LDW1\n         DC    AL1(@80,@00,@82,@83,@84,@85,@86,@87)                LDW1\n         DC    AL1(@88,@89,@8A,@8B,@8C,@8D,@8E,@8F)                LDW1\n         DC    AL1(@90,@91,@92,@93,@94,@95,@96,@97)                LDW1\n         DC    AL1(@98,@00,@00,@00,@9C,@9D,@9E,@9F)                LDW1\n         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)                LDW1\n         DC    AL1(@00,@00,@00,@00,@AC,@AD,@AE,@AF)                LDW1\n         DC    AL1(@00,@B1,@B2,@00,@00,@00,@B6,@B7)                LDW1\n         DC    AL1(@00,@00,@BA,@BB,@00,@BD,@BE,@BF)                LDW1\n         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)                LDW1\n         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)                LDW1\n         DC    AL1(@00,@D1,@D2,@D3,@D4,@D5,@D6,@D7)                LDW1\n         DC    AL1(@00,@00,@00,@00,@DC,@DD,@DE,@DF)                LDW1\n         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)                LDW1\n         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)                LDW1\n         DC    AL1(@F0,@F1,@F2,@F3,@00,@00,@00,@00)                LDW1\n         DC    AL1(@F8,@F9,@FA,@FB,@FC,@FD,@00,@00)                LDW1\n         EJECT\n*        O P C O D E   T A B L E.\n         SPACE 1\n* RR TYPE :\n*    C'(',X'4D' - EXTENDED MNEMONIC\n*    C'+',X'4E' - SVC       IMED\n*    C'|',X'4F' - NORMAL RR TYPE\n*    C'&',X'50' - SPM TYPE\n*\n* RX TYPE :\n*    C'O',X'D6' - INDEX REGISTER USED   R1,D2(X2,B2)\n*    C'M',X'D4' - EXTENDED MNENOMIC     D2(X2,B2)\n*    C'L',X'D3' - SI TYPE               D1(B1),I2\n*    C'J',X'D1' - DIAGNOSE,SVCX   IMED  I\n*    C'K',X'D2' - DISP(BASE) TYPE       D1(B1)\n*    C'R',X'D9' - BXLE,BXH,STM,LM       R1,R3,D2(B2)\n*    C'Q',X'D8' - REG SHIFT TYPE        R1,D2(B2)\n*\n* SS TYPE :\n*    C'S',X'E2' - TWO LENGTHS REQUIRED\n*    C'T',X'E3' - ONLY ONE LENGTH\n*\n*  TABLE FORMAT :\n*        CL4'MNEMONIC',C'FLAG',X'OPCODE'\n         SPACE 1\n         PRINT NOGEN\nOPCODES  DS    0C\n@00      EQU   0                        FOR UNDEFINED OPCODES      LDW1\n         OP    SPM,|,04\n         OP    BALR,|,05\n         OP    BCTR,|,06\n         OP    BCR,'(',07\n         OP    SSK,|,08\n         OP    ISK,|,09\n         OP    SVC,+,0A\n         OP    BSM,|,0B                                            -EU-\n         OP    BASR,|,0D                                           -EU-\n         OP    MVCL,|,0E                                           LDW1\n         OP    CLCL,|,0F                                           LDW1\n         OP    LPR,|,10\n         OP    LNR,|,11\n         OP    LTR,|,12\n         OP    LCR,|,13\n         OP    NR,|,14\n         OP    CLR,|,15\n         OP    OR,|,16\n         OP    XR,|,17\n         OP    LR,|,18\n         OP    CR,|,19\n         OP    AR,|,1A\n         OP    SR,|,1B\n         OP    MR,|,1C\n         OP    DR,|,1D\n         OP    ALR,|,1E\n         OP    SLR,|,1F\n         OP    LPDR,|,20\n         OP    LNDR,|,21\n         OP    LTDR,|,22\n         OP    LCDR,|,23\n         OP    HDR,|,24\n         OP    LRDR,|,25\n         OP    MXR,|,26\n         OP    MXDR,|,27\n         OP    LDR,|,28\n         OP    CDR,|,29\n         OP    ADR,|,2A\n         OP    SDR,|,2B\n         OP    MDR,|,2C\n         OP    DDR,|,2D\n         OP    AWR,|,2E\n         OP    SWR,|,2F\n         OP    LPER,|,30\n         OP    LNER,|,31\n         OP    LTER,|,32\n         OP    LCER,|,33\n         OP    HER,|,34\n         OP    LRER,|,35\n         OP    AXR,|,36\n         OP    SXR,|,37\n         OP    LER,|,38\n         OP    CER,|,39\n         OP    AER,|,3A\n         OP    SER,|,3B\n         OP    MER,|,3C\n         OP    DER,|,3D\n         OP    AUR,|,3E\n         OP    SUR,|,3F\n         OP    STH,O,40\n         OP    LA,O,41\n         OP    STC,O,42\n         OP    IC,O,43\n         OP    EX,O,44\n         OP    BAL,O,45\n         OP    BCT,O,46\n         OP    BC,M,47\n         OP    LH,O,48\n         OP    CH,O,49\n         OP    AH,O,4A\n         OP    SH,O,4B\n         OP    MH,O,4C\n         OP    BAS,O,4D                                            -EU-\n         OP    CVD,O,4E\n         OP    CVB,O,4F\n         OP    ST,O,50\n         OP    SVCX,J,51\n         OP    N,O,54\n         OP    CL,O,55\n         OP    O,O,56\n         OP    X,O,57\n         OP    L,O,58\n         OP    C,O,59\n         OP    A,O,5A\n         OP    S,O,5B\n         OP    M,O,5C\n         OP    D,O,5D\n         OP    AL,O,5E\n         OP    SL,O,5F\n         OP    STD,O,60\n         OP    MXD,O,67\n         OP    LD,O,68\n         OP    CD,O,69\n         OP    AD,O,6A\n         OP    SD,O,6B\n         OP    MD,O,6C\n         OP    DD,O,6D\n         OP    AW,O,6E\n         OP    SW,O,6F\n         OP    STE,O,70\n         OP    LE,O,78\n         OP    CE,O,79\n         OP    AE,O,7A\n         OP    SE,O,7B\n         OP    ME,O,7C\n         OP    DE,O,7D\n         OP    AU,O,7E\n         OP    SU,O,7F\n         OP    SSM,K,80\n         OP    LPSW,K,82\n         OP    DIAG,J,83\n         OP    WRD,L,84\n         OP    RDD,L,85\n         OP    BXH,R,86\n         OP    BXLE,R,87\n         OP    SRL,Q,88\n         OP    SLL,Q,89\n         OP    SRA,Q,8A\n         OP    SLA,Q,8B\n         OP    SRDL,Q,8C\n         OP    SLDL,Q,8D\n         OP    SRDA,Q,8E\n         OP    SLDA,Q,8F\n         OP    STM,R,90\n         OP    TM,L,91\n         OP    MVI,L,92\n         OP    TS,K,93\n         OP    NI,L,94\n         OP    CLI,L,95\n         OP    OI,L,96\n         OP    XI,L,97\n         OP    LM,R,98\n         OP    SIO,K,9C\n         OP    TIO,K,9D\n         OP    HIO,K,9E\n         OP    TCH,K,9F\n         OP    STNSM,L,AC                                          LDW1\n         OP    STOSM,L,AD                                          LDW1\n         OP    SIGP,R,AE                                           LDW1\n         OP    MC,L,AF                                             LDW1\n         OP    LRA,O,B1                                            LDW1\n         OP    S370,K,B2                                           LDW1\n         OP    STCTL,R,B6                                          LDW1\n         OP    LCTL,R,B7                                           LDW1\n         OP    CS,R,BA                                             LDW1\n         OP    CDS,R,BB                                            LDW1\n         OP    CLM,R,BD                                            LDW1\n         OP    STCM,R,BE                                           LDW1\n         OP    ICM,R,BF                                            LDW1\n         OP    MVN,C,D1\n         OP    MVC,C,D2\n         OP    MVZ,C,D3\n         OP    NC,C,D4\n         OP    CLC,C,D5\n         OP    OC,C,D6\n         OP    XC,C,D7\n         OP    TR,C,DC\n         OP    TRT,C,DD\n         OP    ED,C,DE\n         OP    EDMK,C,DF\n         OP    SRP,S,F0                                            LDW1\n         OP    MVO,B,F1\n         OP    PACK,B,F2\n         OP    UNPK,B,F3\n         OP    ZAP,B,F8\n         OP    CP,B,F9\n         OP    AP,B,FA\n         OP    SP,B,FB\n         OP    MP,B,FC\n         OP    DP,B,FD\nOPEND    EQU   *\nOPLEN    EQU   6\n         SPACE 2\n         LTORG\n         SPACE 2\n         CVT   DSECT=YES,LIST=YES                                  -EU-\n         IKJTCB ,                                                  -EU-\n         IEZJSCB ,                                                 -EU-\n         DCBD  DSORG=DA                                            -EU-\nTIODSECT DSECT ,                                                   -EU-\n         IEFTIOT1 ,                                                -EU-\nUCB      DSECT ,                                                   -EU-\n         IEFUCBOB ,                                                -EU-\n         IEZDEB LIST=YES                                           -EU-\n         SPACE 2\n         END\n", "mimetype": "application/x-dosexec", "datatype": "ebcdic", "extension": ".x-dosexec"}, "ZAP$": {"ttr": 40709, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15H\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:48:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": "//ZAP      JOB (........),'INSTALL  - Z A P -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=10\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASZ     EXEC PAJ4AS3,OPT=',RENT',MBR=ZAP\n//ASO     EXEC PAJ4AS1,OPT=',RENT',MBR=OACNOW\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   ZAP\n  NAME    ZAP(R)\n/*\n//HLP     EXEC PAJHELP,MBR=ZAPH,DSS='->.SOURCE.FILE4'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ZAP@": {"ttr": 40711, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x7f\\x00\\x89\\x17\\x7f\\x10$\\x01!\\x01!\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-26T00:00:00", "modifydate": "1989-06-26T10:24:00", "lines": 289, "newlines": 289, "modlines": 0, "user": "SYSPAJA"}, "text": "1   21/11/85\n                                                      ZAP       1/7.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *        Z A P   TSO COMMAND.         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n CBT origin : Extracted from CBT tape JUN 84, file 300.\n ------------\n\n Purpose :   ZAP (under TSO). This service will display any type\n ---------   of data-set (excluding ISAM) in dump format, accept\n   various display formatting and modifying commands, and apply\n   interactive changes as does IBM's Service Aid IMASPZAP (superzap).\n   Hardcopy lines are printed for all data-set modifications and\n   \"potential modifications\" (those not yet applied) as well as\n   comments and dumped blocks. The following conditions cause a line\n   to be written into the print file : accessing a data-set, ZAPping\n   a block, storing in the buffer (S,X,O,N, or SET), selecting a\n   member, creating a comment, ejecting a page, or dumping a block\n   or blocks. The file will be printed only if an explicit dump,\n   comment, or permanent change is made. The file is actually released\n   for printing upon exit from the data-set. IDR's are updated in load\n   module data-sets in the format superzap uses (with TSO--UUU as\n   the ID data field). END-OF-FILEs may be jumped to view data beyond\n   up to the extent of the data-set (usefull if an inadvertant EOF was\n   written in the middle of a data-set).\n\n Syntax : ZAP 'DSNAME' VOLUME('SERIAL') CRT NOT3270\n --------     TERSE/VERBOSE\n              NOLOG/LOG\n              ALLOCDSN('DSNTOALLOC')\n\n          Required : 'DSNAME'\n          Defaults : TERSE, NOLOG\n                     No volume implies a cataloged data-set.\n\n          Note : usage of the ALLOCDSN keyword is required only for\n                 the 'DSNAME' of FORMAT4.DSCB.\n1   06/04/88\n                                                      ZAP       2/7.\n\n Operands :\n ----------\n  'DSNAME' - the name of the data-set to be ZAP'd.\n\n  VOLUME   - the volume serial on which the data-set resides.\n             The volume must be online and RESIDENT or STORAGE.\n\n  CRT      - conditions ZAP to display four lines on either side of the\n             current position in the file.\n\n  NOT3270  - inhibits use of full screen display mode on a 3270-type\n             terminal and implies line by line display mode.\n\n  LOG      - conditions ZAP to log to SYSOUT all ZAP transactions to\n             the file. Note that ZAP may be put in the logging state\n             after it has been entered by use of the LOG command, and\n             that use of nay of the DUMP commands causes ZAP to\n             automatically enter the logging state.\n             The LOG goes to SYSOUT(A) unless DDNAME ZAPLOG is\n             pre-allocated to wherever you want it to go.\n\n  NOLOG    - suppress the hardcopy LOG.\n\n  ALLOCDSN - specifies the name of a cataloged data-set on the same\n             volume as the one to be ZAPped. ZAP will allocate this\n             data-set, but open the one given in the first operand.\n             Usage of this keyword is required for FORMAT4.DSCB\n             references. Note that a FORMAT4.DSCB reference is a\n             priviledged operation.\n\n  TERSE /VERBOSE -\n             conditions ZAP to omit the positional WHERE information\n             when displaying a portion of the file.\n\n  VERBOSE /TERSE -\n             conditions ZAP to give the positional WHERE information\n             when displaying a portion of the file.\n\n Subcommands : VERBOSE, NOT3270, YES3270, WHATMEM, LASTDS1, EBCDIC,\n ------------- ITRACE, DISASM, LINE80, LINE40, NODEF, ASCII, FLOAT,\n   ZCODE, WHERE, TERSE, EJECT, DUMPF, DUMPT, NOZAP, DISPC, DISPK,\n   DISPD, BASE, DUMP, NOTE, LAST, HELP, NAME, IDEF, SAVE, ZSYM, ASM,\n   CRT, LOG, ZAP, SSL, END, SET, ABS, DO, L, S, O, X, N, F, >, <, M,\n   E, B, D, V, T, R, P, U, =, ?, H, #, W, %.\n\n   Note : when in ZAP enter HELP for more details on subcommand syntax.\n1   23/09/85\n                                                      ZAP       3/7.\n\n Help subcommands images :\n -------------------------\n   Image 1 : Contents\n\n                    ?1       - this screen\n                    ?2, ?3   - General information\n                    ?4, ?5   - Input/Output commands\n                    ?6       - Session control commands\n                    ?7       - Dump commands\n                    ?8       - Byte commands\n                    ?9       - String commands\n                    ?10, ?11 - Miscellaneous commands\n                    ?12      - Explanation of symbols\n                    ?13      - Sample ZAP session\n\n   Image 2 : General information\n\n                    -- The operands are entered after the\n                       command, with no intervening blanks.\n                    -- The block is read into a work buffer,\n                       where you modify it. When you enter a\n                       \"ZAP\" command, the block is written\n                       back to the data-set from the buffer.\n                       If any other JOB or USER has updated\n                       that block in between when you first\n                       displayed it and when you \"ZAPped\"\n                       it, the other changes will be lost.\n\n\n   Image 3 : General information (continued)\n\n                    -- If you make changes to a block, to\n                       go to another block you must either\n                       \"ZAP\" the block (re-write it to the\n                       data-set), or enter the command twice\n                       in a row which will cause you to\n                       leave to current modified block.\n1   23/09/85\n                                                      ZAP       4/7.\n\n   Image 4 : Input/Output commands\n\n                    P<EXP> - point to record whose TTR=EXP\n                    P      - point to beginning of data-set\n                    T<EXP> - point to track <EXP>, record 1\n                    T      - point to next track, record 1\n                    R<EXP> - show block <EXP> relative to\n                             current\n                    R      - point to next physical record\n                    B      - point to previous record\n                    LAST   - point to last record (DS1LSTAR)\n                    LASTDS1- point to last format 1 in VTOC\n                    ABS<EXP> - point to rec. with CCHHR=EXP\n\n   Image 5 : More Input/Output commands\n\n                    %<EXP> - point to TTR @ loc <EXP> in\n                             block\n                    M<NAME>- for PDS, point to member <NAME>\n                    M      - point to start of the current\n                             member\n                    NAME<N>- after 'M', show entry-point <N>\n                    NAME   - select entry-point named member\n                    E<N>   - same as NAME<N>\n                    E      - same as NAME\n                    ZAP    - replace block from the current\n                             buffer\n\n   Image 6 : Session control commands\n\n                    LOG      - start logging this session\n                    CRT      - set width 4,4 and VERBOSE\n                    TERSE    - do not do AUTO where\n                    VERBOSE  - always give where info\n                    W<D>,<U> - set window down/up size(s)\n                    WFULL    - set size to URSA screen size\n                    LINE40, LINE80 - set line length 40 | 80\n                    NOTE<COMNT>-write <COMNT> into LOG file\n                    EJECT    - eject a page in the LOG file\n1   23/09/85\n                                                      ZAP       5/7.\n\n   Image 7 : Dump commands\n\n                    DUMP       - dump all records in the\n                                 data-set in abdump format\n                    DUMPT<EXP> - dump to TTR <EXP> from\n                                 current record\n                    DUMPT      - dump current record only\n                    DUMPF<EXP> - dump for <EXP> records from\n                                 current record\n                    DUMPF      - dump current record\n                    DUMPE      - dump current record to EOF\n\n                    EOF, I/O error or END-OF-DS : halt dump\n\n   Image 8 : Byte commands\n\n                    D<EXP> - display byte at offset <EXP>\n                    <EXP>  - same as D<EXP>\n                    D      - page to next screen (D+#SCREEN)\n                    U      - page to prev screen (D-#SCREEN)\n                    >      - go forward in trace table\n                    <      - go backward in trace table\n                    EBCDIC - EBCDIC translation (default)\n                    ASCII  - ASCII-8 translation\n                    ZCODE  - ZCODE translation\n                    =<LAB> - define <LAB> to current loc\n                    NODEF  - clear all defined labels from =\n\n   Image 9 : String commands\n\n                    S<STR>   - store <STR> at current loc\n                    X<STR>   - exclusive OR at current loc\n                    O<STR>   - OR at current loc\n                    N<STR>   - AND at current loc\n                    SET<STR> - set entire record to <STR>\n                               S,X,O,N,SET may be entered\n                               alone to use previous <STR>\n                    L<STR>   - look for <STR> from next byte\n                    L        - continue looking for <STR>\n                    F<STR>   - like L<STR>, cont's past EOFs\n                    F        - like L, continues past EOFs\n1   26/06/89\n                                                      ZAP       6/7.\n\n   Image 10 : Miscellaneous commands\n\n                    END    - exit ZAP\n                    #<EXP> - find hex/decimal value of <EXP>\n                    FLOAT<F> - find floating pt value of <F>\n                    IDEF   - display define label table\n                    ITRACE - display trace table\n                    ?N     - view nth HELP display (1-13)\n                    WHERE  - give current location etc...\n                    ASM<OP> - give object code for mnemonic\n                    DISASM<EXP> - disassemble instruction\n                             at <EXP>\n                    CAPSON/CAPSOFF - for string commands\n\n   Image 11 : More miscellaneous commands\n\n                    WHATMEM  - find directory entry closest\n                               to current record\n                    WM       - same as WHATMEM\n                    DO<CMD>  - execute TSO <CMD> as at ready\n                    V<EXP>   - add contents of 2 bytes at\n                               <EXP> to current value of loc\n                    BASE<EXP>- add <EXP> to buffer offset\n                               when computing address\n                    DISP<TYPE> - set record display start\n                               pos. <TYPE> is COUNT-KEY-DATA\n                    J<TTR>   - rel. to beginning of volume\n\n   Image 12 :       <EXP> is composed of operators (+,-,*,/)\n                        define symbols ('=' command) and\n                        hex or dec constants. The following\n                        symbols are predefined : * = current\n                        offset, L = logical record length,\n                        K = key length, BL = max. blksize.\n                    <STR> may be either up to 16 characters\n                        enclosed in any delimiter, or up\n                        to 16 hex digits, or a decimal value\n                        ending with ''.'' (length 4 bytes).\n                    <LAB> may any 1 to 8 characters.\n                    <F>   is any floating point constant in\n                        internal form (ie : FORTRAN A form).\n1   23/09/85\n                                                      ZAP       7/7.\n\n   Image 13 : Sample ZAP session\n\n                    ZAP LOAD   ready level command entered\n                    MTEST      select member \"TEST\"\n                    EFIRST     select entry-point \"FIRST\"\n                    4C         go to offset X'4C' in record\n                    S00        store one byte hexadecimal\n                    +4         advance ptr 4 bytes in block\n                    NFF0F      turn off one nibble\n                    ZAP        re-write that block\n                    R+3        go to third block from here\n                    L/HELLO/   find some text\n                    END        all done - exit ZAP\n\n IDR update : IDR for ZAP takes the following form :\n ------------\n\n         Byte  0..... X'80' for ID\n         Byte  1..... length of IDR (usually X'FA' = 250)\n         Byte  2..... who's IDR it is (X'01' for ZAP)\n         Byte  3..... number of 13-byte IDR data entries (bits 2-7)\n         Bytes 4-16, 17-29, ... IDR data entry as follows :\n                      bytes  0-1 --- ESD ID (default 1)\n                      bytes  2-4 --- date (YYDDDF)\n                      bytes 5-12 --- info (TSO--UUU, where UUU is the\n                                     ZAPper's UID)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZAPH": {"ttr": 40717, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\t\\x7f\\x00\\x88\\t\\x7f\\x17B\\x006\\x006\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-06T00:00:00", "modifydate": "1988-04-06T17:42:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=ZAP\n./     NUMBER  NEW1=100,INCR=100\n)S SUBCOMMANDS                                                         C\n   VERBOSE, NOT3270, YES3270, WHATMEM, LASTDS1, EBCDIC, ITRACE,\n   DISASM, LINE80, LINE40, NODEF, ASCII, FLOAT, ZCODE, WHERE, TERSE,\n   EJECT, DUMPF, DUMPT, NOZAP, DISPC, DISPK, DISPD, BASE, DUMP, NOTE,\n   LAST, HELP, NAME, IDEF, SAVE, ZSYM, ASM, CRT, LOG, ZAP, SSL, END,\n   SET, ABS, DO, L, S, O, X, N, F, >, <, M, E, B, D, V, T, R, P, U,\n   =, ?, H, #, W, %.\n   N.B. - When in ZAP enter HELP for more details on subcommand syntax.\n)F FUNCTION\n   The ZAP command is used to examine, dump, and modify any type of\n   sequential, partitioned, or direct access data-set (ISAM excluded).\n   Any RECFM is accepted. This command is the TSO interactive\n   equivalent of IBM's service aid 'IMASPZAP' or 'SUPERZAP'\n)X SYNTAX\n   ZAP 'dsname' VOLUME('serial') CRT NOT3270\n         TERSE/VERBOSE\n         NOLOG/LOG\n         ALLOCDSN('dsntoalloc')\n   REQUIRED : 'dsname'\n   DEFAULTS :  TERSE, NOLOG\n               No volume implies a cataloged data-set.\n   NOTE :  Usage of the ALLOCDSN keyword is required only for the\n           'dsname' of FORMAT4.DSCB.\n)O OPERANDS\n))'dsname' - The name of the data-set to be ZAP'd.\n))VOLUME   - The volume serial on which the data-set resides.\n             The volume must be online and resident or storage.\n))CRT      - Conditions ZAP to display four lines on either side of the\n             current position in the file.\n))NOT3270  - Inhibits use of full screen display mode on a 3270-type\n             terminal and implies line by line display mode.\n))LOG      - Conditions ZAP to log to SYSOUT all ZAP transactions to\n             the file. Note that ZAP may be put in the logging state\n             after it has been entered by use of the LOG command, and\n             that use of any of the DUMP commands causes ZAP to\n             automatically enter the logging state.\n             The log goes to SYSOUT(A) unless ddname 'ZAPLOG' is\n             pre-allocated to wherever you want it to go.\n))NOLOG    - suppress the hardcopy log.\n))ALLOCDSN - specifies the name of a cataloged data-set on the same\n             volume as the one to be zapped. ZAP will allocate this\n             data-set, but open the one given in the first operand.\n             Usage of this keyword is required for FORMAT4.DSCB\n             references. Note that a FORMAT4.DSCB reference is a\n             priviledged operation.\n))TERSE /VERBOSE -\n             Conditions ZAP to omit the positional 'WHERE' information\n             when displaying a portion of the file.\n))VERBOSE /TERSE -\n             Conditions ZAP to give the positional 'WHERE' information\n             when displaying a portion of the file.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZAPMAC": {"ttr": 40719, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x95'\\x7f\\x00\\x95'\\x7f\\x12R\\n\\xa9\\n\\xa9\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-10-04T00:00:00", "modifydate": "1995-10-04T12:52:00", "lines": 2729, "newlines": 2729, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n         PGPB  &J,&DSECT=YES\n         AIF   ('&DSECT' NE 'YES').L1\nPGPB     DSECT\n         AGO   .L2\n.L1      ANOP\nPGPB     DS    0F\n.L2      ANOP\n         SPACE 1\n***********************************************************************\n*    THE PUTGET PARAMETER BLOCK (PGPB) IS POINTED TO BY THE LIST      *\n*    PASSED TO PUTGET. PUTGET USES IT FOR CONTROL AS WELL AS          *\n*    RETURNING INFORMATION.                                           *\n***********************************************************************\n         SPACE 1\n         DS    0F\n         DS    CL12 .              INTERNAL TO GETLINE/PUTLINE\nPGPBIBUF DS    A .                 PTR TO OBTAINED INPUT LINE\n         MEND\n         MACRO\n         TSDMPL\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        (DMPL)    DAIR MESSAGE PARAMETER LIST.                       *\n*                                                                     *\n*        FUNCTION  THE ADDRESS OF THIS PARAMETER LIST IS PASSED IN    *\n*                  REGISTER 1 BY THE INVOKER OF IKJEFF18 TO DIAGNOSE  *\n*                  DAIR ERRORS AND PRINT APPROPRIATE MESSAGES.        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nDMPL     DS    0F .                DAIR MESSAGE PARAMETER LIST\nDMPLDAPL DS    A .                 PTR TO THE DAPL ADDRESS\nDMPLRC   DS    A .                 PTR TO THE DAIR RETURN CODE\nDMPLMSG  DS    A .                 PTR TO A(IKJEFT02) IF LOADED\nDMPLCALL DS    A .                 PTR TO THE CALLER NUMBER\nDMPLCODE DS    0F .                R15 SAVE IS DAIR RETURN CODE\nDMPLSAVE DS    3F .                REGISTER SAVEAREA FOR 15-1\nDMPLL    EQU   *-DMPL .            LENGTH OF THE DMPL\n         SPACE 1\n         MEND\n         MACRO\n&LBL     TSDAIR &Z,&DAPB=,&SYNAD=,&ENTRY=\n         GBLB   &TSDAIRE           WAS TSDAIRER ROUTINE GENERATED\n&LBL     OACINNER  F=&DAPB,T=DAPLDAPB,OP=MA,COM='DAPB ADDR'\n         LA    R1,DAPL\n         AIF   ('&ENTRY' EQ '').NOENT\n         $RXR  ,&ENTRY,15,A=       FROM REGISTER OR FULLWORD\n         BALR  R14,R15\n         AGO   .NOLINK\n.NOENT   LINK  EP=IKJDAIR\n.NOLINK  AIF   ('&SYNAD' EQ '').L1\n         LTR   R15,R15\n         BZ    TSD&SYSNDX+4\n         LA    R0,&SYNAD\n         L     R14,TSD&SYSNDX\n         BR    R14\n         AIF   ('&SYNAD' EQ '').L0\n         AIF   (&TSDAIRE).L0\n         TSDAIRER\n.L0      ANOP\nTSD&SYSNDX DC  A(TSDAIRER)\n.L1      MEND\n         MACRO\n         $RXQ  &TARGET,&SEND,&LEN\n         GBLB  &OMITTED\n&OMITTED SETB  0\n         AIF   ('&SEND' EQ '' ).NOSEND\n         AIF   ('&SEND'(1,1) EQ '(').REGSEND\n         AIF   ('&SEND'(1,1) EQ '''').QSEND\n         MVC   &TARGET,&SEND\n         AGO   .END\n.REGSEND MVC   &TARGET,0&SEND\n         AGO   .END\n.QSEND   MVC   &TARGET,=CL&LEN&SEND\n         AGO   .END\n.NOSEND  MVC   &TARGET,=CL&LEN' '  NOT SPECIFIED\n&OMITTED SETB  1                   OPERAND WAS OMMITTED\n.END     ANOP\n         MEND\n         MACRO\n         $MF   &MAP,&REG,&MF,&FAKE1,&SP=\n.******* &MAP=MAPPING DSECT NAME\n.******* &REG=REGISTER FOR ADDRESSIBILITY\n.******* &MF=(L|B|E,AREA)\n         GBLB  &OMITTED,&DROP\n         LCLC  &AREA\n&OMITTED SETB  0\n&DROP    SETB  0                   DO NOT DROP REGISTER\n         AIF   ('&MF' NE '').MFYES\n&OMITTED SETB  1                   PARAMETER WAS OMMITTED\n.MFYES   ANOP\n&AREA    SETC  'DAPBAREA'\n         AIF   ('&MF(2)' EQ '').USEAREA\n&AREA    SETC  '&MF(2)'\n.USEAREA AIF   ('&MF(1)' EQ 'E' OR '&MF(1)' EQ '').MF1OK\n         AIF   ('&MF(1)' EQ 'B').MF1OK\n         AIF   ('&MF(1)' EQ 'L').MF1OK\n         MNOTE 4,'MF=&MF(1) IS AN INVALID TYPE, MF=E ASSUMED'\n.MF1OK   $RXR   ,&AREA,&REG        MF=(L|B|E,AREA)\n         USING  &MAP,&REG          ADDRESSIBILITY\n&DROP    SETB  1                   DROP REGISTER\n         MEND\n         MACRO\n&LABEL   FREE  &DDNAME=,&DSN=,&MEMBER=,&PREFIX=NO,                     X\n               &FILE=,&DATASET=,                                       X\n               &SYSOUT=,                                               X\n               &JOBNAME=,                                              X\n               &DISP=,&PERM=YES,                                       X\n               &MF=,&SYNAD=\n         GBLB  &OMITTED,&DROP\n         LCLA  &PERMBIT\n&PERMBIT SETA  0                   PERM = X'10'\n         AIF   ('&PERM' NE 'YES').NOTPERM\n&PERMBIT SETA  16                  =X'10'\n.NOTPERM ANOP\n&LABEL   DS    0H\n         $MF   DAPB18,R15,&MF\n         XC    DAPB18(DAPB18L),DAPB18   INITIALIZE DAIR BLOCK TO ZERO\n         MVI   DA18CD+1,X'18'           DAIR ENTRY CODE FOR FREE\n         $RXR  DA18PDSN,&DSN&DATASET,0  POINTER TO DSNAME\n         $RXQ  DA18DDN,&DDNAME&FILE,8   DDNAME\n         $RXQ  DA18JBNM,&JOBNAME,8      JOBNAME\n         $RXQ  DA18SCLS,&SYSOUT,2       SYSOUT CLASS\n         AIF   (&OMITTED).MEM\n         MVI   DA18SCLS+1,C' '          BLANK 2ND BYTE OF OUTPUT CLASS\n.MEM     $RXQ  DA18MNM,&MEMBER,8        MEMBER NAME\n         AIF   ('&PREFIX' NE  'YES').NOPREF\n         OI    DA18CTL,DA18UID+&PERMBIT PREFIX CHARGENO.USERID TO DSN\n         AGO   .DISPOS\n.NOPREF  AIF   ('&PERM' NE 'YES').DISPOS FREE PERM DATASET?\n         OI    DA18CTL,&PERMBIT         FREE PERMANENTLY ALLOCATED DS\n.DISPOS  AIF   (T'&DISP    EQ 'O').NODISP2\n         AIF   ('&DISP'    NE 'KEEP').DELETE2\n         MVI   DA18DPS2,DA18KEEP        DISP=(,KEEP)\n         AGO   .DISP3\n.DELETE2 AIF   ('&DISP'    NE 'DELETE').CATLG2\n         MVI   DA18DPS2,DA18DEL         DISP=(,DELETE)\n         AGO   .DISP3\n.CATLG2  AIF   ('&DISP'    NE 'CATLG').UNCAT2\n         MVI   DA18DPS2,DA18CAT         DISP=(,CATLG)\n         AGO   .DISP3\n.UNCAT2  AIF   ('&DISP'    NE 'UNCATLG').DISPBAD\n         MVI   DA18DPS2,DA18UCAT        DISP=(,UNCATLG)\n         AGO   .DISP3\n.NODISP2 ANOP\n*        DISPOSITION SPECIFIED WHEN ALLOCATED WILL BE USED.\n         AGO   .DISP3\n.DISPBAD ANOP\n         MNOTE *,'*****************************************'\n         MNOTE 12,'-- INVALID DISPOSITON, DISP= &DISP  '\n         MNOTE *,'*****************************************'\n         AGO   .END\n.DISP3   AIF   ('&MF(1)' EQ 'B').ENDB\n         AIF   ('&MF(1)' EQ 'L').END\n         TSDAIR DAPB=(15),SYNAD=&SYNAD\n         AGO   .END\n.ENDB    ST    R15,DAPLDAPB\n         LA    R1,DAPL\n.END     AIF    (NOT &DROP).END1\n         DROP  R15                 DROP ADDRESSIBLITY TO DAIR BLOCK\n.END1    SPACE 1\n         MEND\n         MACRO\n&NAME    TPUTX &BFF,&SIZE,&EDIT,&WAIT,&HOLD,&BRKI,&PRTY,&TJID=,        X\n               &TJIDLOC=,&MF=I\n         GBLA  &GETLENL\n         GBLC  &$NFS\n         LCLA  &K,&I,&BITS\n         LCLA  &N,&MAXLEN\n         LCLB  &ED,&WA,&HO,&BR,&PR\n&$NFS    SETC  '&NAME'\n&K       SETA  3                        NORMAL PLACE TO START SCAN\n         AIF   ('&BFF' NE '').HAVEBFF\n         MNOTE 8,'*** MESSAGE OR MESSAGE ADDR OMITTED.'\n         MEXIT\n.HAVEBFF AIF   ('&BFF'(1,1) NE '''').NOTQ\n&K       SETA  K'&BFF-2                 LENGTH OF CHAR STRING\n&N       SETA  2                        START AT FIRST TEXT CHAR\n&MAXLEN  SETA  &K                       SET LENGTH OF CHAR STRING\n.QLOOP   AIF   ('&BFF'(&N,2) NE '''''' AND '&BFF'(&N,2) NE '&&').QCONT\n&K       SETA  &K-1                     ACCOUNT FOR DBLE CHAR\n&N       SETA  &N+1                     FUDGE PAST\n.QCONT   ANOP\n&N       SETA  &N+1\n         AIF   (&N LE &MAXLEN).QLOOP\n&$NFS    LA    R0,&K                    GET STRING LENGTH\n&$NFS    SETC  ''                       NAME FIELD SYMBOL DONE\n         LA    R1,=C&BFF\n&K       SETA  2                        ONLY ONE OPERAND FOR STRING\n         AGO   .GOTPTRS\n.NOTQ    ANOP\n&$NFS    $RXR  ,&BFF,1                  LOAD BUFFER PTR\n         $RXR  ,&SIZE,0                 LOAD BUFFER LENGTH\n.GOTPTRS AIF   ('&TJID' EQ '' AND '&TJIDLOC' EQ '').NOTJID\n         AIF   ('&TJID' EQ '').LOADTJ\n&$NFS    $RXR  ,&TJID,14                GET TJID\n         AGO   .ORTJ\n.LOADTJ  ANOP\n&$NFS    $RXR  ,&TJIDLOC,15             INDIRECT TJID\n         LH    R15,0(,R15)              LOAD TJID\n.ORTJ    SLL   R15,16                   TJID INTO TOP HALF\n         OR    R0,R15                   ADD TO PARM REG 0\n.NOTJID  ANOP\n&I       SETA  &K                       FIRST OPERAND TO CHECK\n.LOOP    AIF   (&I GT N'&SYSLIST).SETOP IF ALL ARE PROCESSED, JUMP OUT\n         AIF   ('&SYSLIST(&I)' EQ 'EDIT').EDIT\n         AIF   ('&SYSLIST(&I)' EQ 'ASIS').ASIS\n         AIF   ('&SYSLIST(&I)' EQ 'CONTROL').CONTROL\n         AIF   ('&SYSLIST(&I)' EQ 'FULLSCR').FULLS\n         AIF   ('&SYSLIST(&I)' EQ 'WAIT').WAIT\n         AIF   ('&SYSLIST(&I)' EQ 'NOWAIT').NOWAIT\n         AIF   ('&SYSLIST(&I)' EQ 'NOHOLD').NOHOLD\n         AIF   ('&SYSLIST(&I)' EQ 'HOLD').HOLD\n         AIF   ('&SYSLIST(&I)' EQ 'NOBREAK').NOBREAK\n         AIF   ('&SYSLIST(&I)' EQ 'BREAKIN').BREAKIN\n         AIF   ('&SYSLIST(&I)' EQ 'HIGHP').HIGHP\n         AIF   ('&SYSLIST(&I)' EQ 'LOWP').LOWP\n         AIF   ('&SYSLIST(&I)' EQ 'R').NEXTI\n         AIF   ('&SYSLIST(&I)'(1,4) EQ 'TJID').SETOP\n         MNOTE 8,'INVALID OPTION &SYSLIST(&I) - IGNORED'\n.NEXTI   ANOP\n&I       SETA  &I+1                     INCREMENT COUNTER\n         AGO   .LOOP                    GET NEXT OPTION IF ANY\n.MUTEX   MNOTE 8,'MUTUALLY EXCLUSIVE KEYWORDS'\n         AGO   .NEXTI\n.FULLS   ANOP\n&BITS    SETA  &BITS+3                  SET ASIS+CONTROL FOR FULL SCRN\n         AGO   .EDIT                    MAKE IT MUTUALLY EXCLUSIVE\n.ASIS    ANOP\n&BITS    SETA  &BITS+1                  SET ASIS OPTION\n         AGO   .EDIT                    MAKE IT MUTUALLY EXCLUSIVE\n.CONTROL ANOP\n&BITS    SETA  &BITS+2                  SET CONTROL OPTION\n.EDIT    AIF   (&ED).MUTEX\n&ED      SETB  1                        EDIT,ASIS OR CONTROL SET\n         AGO   .NEXTI\n.NOWAIT  ANOP\n&BITS    SETA  &BITS+16                 SET NOWAIT OPTION\n.WAIT    AIF   (&WA).MUTEX\n&WA      SETB  1                        WAIT OR NOWAIT SET\n         AGO   .NEXTI\n.HOLD    ANOP\n&BITS    SETA  &BITS+8                  SET HOLD OPTION\n.NOHOLD  AIF   (&HO).MUTEX\n&HO      SETB  1                        HOLD OR NOHOLD SET\n         AGO   .NEXTI\n.BREAKIN ANOP\n&BITS    SETA  &BITS+4                  SET BREAKIN OPTION\n.NOBREAK AIF   (&BR).MUTEX\n&BR      SETB  1                        BREAKIN OR NOBREAK SET\n         AGO   .NEXTI\n.LOWP    ANOP\n&BITS    SETA  &BITS+X'20'              FORCE LOW PRTY (EVEN IF KEY0)\n.HIGHP   AIF   (&PR).MUTEX\n&PR      SETB  1                        HIGHP OR LOWP SET\n         AGO   .NEXTI\n.SETOP   AIF   ('&BFF'(1,1) NE '(').NOTREG I MUST HAVE DONE LA\n&$NFS    LA    R1,0(,R1)                MAKE HIGH BYTE 0\n.NOTREG  AIF   (&BITS EQ 0).CALL\n         LA    R15,&BITS                GET OPTIONS\n         SLL   R15,24                   SHIFT TO TOP BYTE\n         OR    R1,R15                   OR IN OPTIONS\n.CALL    AIF   ('&MF' EQ 'I' OR '&MF' EQ 'B').CHK2\n         MNOTE 4,'*** INVALID MF OPTION'\n         MEXIT\n.CHK2    AIF   ('&MF' EQ 'I').CALLIT\n         MEXIT\n.CALLIT  SVC   93                       ISSUE TPUT SVC\n         MEND\n         MACRO\n&LBL     TSPARSE &Z,&PCL=,&CBUF=,&USER=,&SYNAD=,&ENTRY=,&MF=I\n         GBLC  &$NFS\n         LCLC  &IHBNX\n&IHBNX   SETC  'IHB&SYSNDX'\n&$NFS    SETC  '&LBL'\n         AIF  (('&MF' NE 'I') AND ('&MF' NE 'E') AND ('&MF' NE 'L')).E1\n        AIF (('&MF' EQ 'I') AND (('&PCL' EQ '') OR ('&CBUF' EQ ''))).E2\n&$NFS    OACINNER F=&PCL,T=PPLPCL,OP=MA,COM='MOVE IN PCL ADDR'\n&$NFS    OACINNER F=&CBUF,T=PPLCBUF,OP=MA,COM='MOVE IN CBUF ADDR'\n&$NFS    OACINNER F=&USER,T=PPLUWA,OP=MA,COM='MOVE IN UWA ADDR'\n         AIF   ('&MF' EQ 'L').DONE\n&$NFS    LA    R1,PPL\n&$NFS    SETC  ''\n         AIF   ('&ENTRY' EQ '').NOENT\n         $RXR  ,&ENTRY,15,A=            FROM REGISTER OR FULLWORD\n         BALR  R14,R15\n         AGO   .NOLINK\n.NOENT   LINK  EP=IKJPARS\n.NOLINK  AIF   ('&SYNAD' EQ '').DONE\n         LTR   R15,R15\n         BZ    &IHBNX+4\n         LA    R0,&SYNAD\n         L     R14,&IHBNX\n         BR    R14\n&IHBNX   DC    A(TSPARERR)\n.DONE    AIF   ('&$NFS' EQ '').MEND\n&$NFS    DS    0H                       DEFINE NAME\n.MEND    MEXIT\n.E1      MNOTE 12,'MF=&MF IS INVALID'\n         AGO   .DONE\n.E2      MNOTE 12,'PCL= AND CBUF= REQUIRED WITH MF=I'\n         AGO   .DONE\n         MEND\n         MACRO\n&LABEL   TSFIND &TYPE,&REG,&RG2\n         LCLA   &KEY\n&LABEL   L     &REG,CVTPTR              ADDRESS OF CVT\n         USING CVT,&REG\n         AIF   ('&TYPE' EQ 'CVT').END\n         AIF   ('&REG' NE '0' AND '&REG' NE 'R0').CONT\n.REG0    MNOTE 8,'REGISTER 0 IS NOT A VALID REGISTER'\n         AGO   .END\n.CONT    AIF   ('&TYPE' EQ 'TSCVT').TSCVT\n         AIF   ('&TYPE' EQ 'TJB').TJB\n         AIF   ('&TYPE' EQ 'TSB').TJB\n         AIF   ('&TYPE' EQ 'TJBX').TJB\n         AIF   ('&TYPE' EQ 'DSE').TJB\n         AIF   ('&TYPE' EQ 'TJBL').TJBL\n         AIF   ('&TYPE' EQ 'TJBTABLE').TJBTAB\n         L     &REG,CVTTCBP             OLD/CURRENT\n         DROP  &REG\n         L     &REG,4(,&REG)            CURRENT TCB\n         USING TCB,&REG\n         AIF   ('&TYPE' EQ 'TCB').END\n         AIF   ('&TYPE' EQ 'TCBFSA').TCBFSA\n         AIF   ('&TYPE' EQ 'TIOT').TIOT\n         AIF   ('&TYPE' EQ 'TJID').TJID\n         AIF   ('&TYPE' EQ 'JSCB').JSCB\n         AIF   ('&TYPE' EQ 'PBE').PSCB\n         AIF   ('&TYPE' EQ 'PSCB').PSCB\n         AIF   ('&TYPE' EQ 'UPT').PSCB\n         AIF   ('&TYPE' EQ 'TAT').TAT\n         AIF   ('&TYPE' EQ 'CCNUID').CCNUID\n         DROP  &REG\n         MNOTE 8,' &TYPE IS UNSUPPORTED'\n         AGO   .END\n.TIOT    L     &REG,TCBTIO              TCB.TIOT\n         AGO   .END\n.TCBFSA  L     &REG,TCBFSA              TCB.FSA\n         AGO   .END\n.JSCB    L     &REG,TCBJSCB             TCB.JSCB\n         AGO   .END\n.PSCB    L     &REG,TCBJSCB             TCB.JSCB\n         DROP  &REG\n         USING IEZJSCB,&REG\n         L     &REG,JSCBPSCB            JSCB.PSCB\n         AIF   ('&TYPE' EQ 'PSCB').END\n         DROP  &REG\n         USING PSCB,&REG\n         AIF   ('&TYPE' EQ 'UPT').UPT\n         L     &REG,PSCBU               PSCB.PBE\n         AGO   .END\n.UPT     L     &REG,PSCBUPT             PSCB.UPT\n         AGO   .END\n.TJID    L     &REG,TCBJSCB             TCB.JSCB\n         DROP  &REG\n         USING IEZJSCB,&REG\n         LH    &REG,JSCBTJID            JSCB.TJID\n         AGO   .END\n.TSCVT   L     &REG,228(,&REG)          CVT.TSCVT\n         AGO   .END\n.TJBL    L     &REG,228(,&REG)          CVT.TSCVT\n         LH    &REG,26(,&REG)           TSCVT.SZU\n         AGO   .END\n.TJBTAB  L     &REG,228(,&REG)          CVT.TSCVT\n         L     &REG,0(,&REG)            TSCVT.TJB (TABLE BEGINNING)\n         AGO   .END\n.TJB     AIF   ('&RG2' NE '').TJB1\n         MNOTE 8,'2ND REGISTER NOT SPECIFIED'\n         AGO   .END\n.TJB1    AIF   ('&RG2' NE '&REG').TJB2\n.REQ     MNOTE 8,'2ND REGISTER EQUAL 1ST REGISTER'\n         AGO   .END\n.TJB2    AIF   ('&RG2' EQ '0' OR  '&RG2' EQ 'R0').REG0\n         L     &RG2,CVTTCBP             OLD/CURRENT\n         L     &RG2,4(,&RG2)            CURRENT TCB\n         USING TCB,&RG2\n         L     &RG2,TCBJSCB             TCB.JSCB\n         DROP  &RG2\n         USING IEZJSCB,&RG2\n         LH    &RG2,JSCBTJID            JSCB.TJID\n         DROP  &RG2\n         L     &REG,228(,&REG)          CVT.TSCVT\n         MH    &RG2,26(,&REG)           TSCVT.SZU\n         L     &REG,0(,&REG)            TSCVT.TJB\n         AIF   ('&TYPE' EQ 'TJBX').TJBX\n         AIF   ('&TYPE' EQ 'TSB').TSB\n         AIF   ('&TYPE' EQ 'DSE').DSE\n         LA    &REG,0(&RG2,&REG)        USER'S TJB\n         AGO   .END\n.TJBX    L     &REG,8(&RG2,&REG)        TJB.TJBX\n         AGO   .END\n.TSB     L     &REG,0(&RG2,&REG)        TJB.TSB\n         AGO   .END\n.DSE     L     &REG,8(&RG2,&REG)        TJB.TJBX\n         L     &REG,8(&REG)             TJBX.DSE\n         AGO   .END\n.TAT     ANOP\n&KEY     SETA  1                        SEARCH FOR TAT\n         AGO   .TAT1\n.CCNUID  ANOP\n&KEY     SETA  5                        SEARCH FOR CCNUID\n.TAT1    AIF   ('&RG2' NE '').TAT2\n         MNOTE 8,'2ND REGISTER NOT SPECIFIED'\n         MEXIT\n.TAT2    AIF   ('&RG2' EQ '&REG').REQ\n         AIF   ('&RG2' EQ '0' OR  '&RG2' EQ 'R0').REG0\nL&SYSNDX L     &RG2,TCBUSER             TCB.USER\nL1&SYSNDX LA   &RG2,0(,&RG2)            CLEAR HIGH ORDER BYTE\n         LTR   &RG2,&RG2                END TCB.USER CHAIN ?\n         BZ    L2&SYSNDX                YES\n         CLI   0(&RG2),&KEY             THE BLOCK WERE LOOKING FOR ?\n         BE    LF&SYSNDX                YES\n         L     &RG2,0(,&RG2)            STEP DOWN CHAIN\n         B     L1&SYSNDX                SAME CHECKS ON THIS\nL2&SYSNDX L    &REG,TCBOTC              TCB.OTC\n         LTR   &REG,&REG                HIGHER TCB PRESENT ?\n         BZ    LF&SYSNDX                NO, REG=0 INDICATES NOT FOUND\n         TM    TCBTSFLG,TCBTSTSK        TCB.TSFLG = TCB.TSTSK\n         BO    L&SYSNDX\nLF&SYSNDX LTR  &REG,&RG2                TO RESULT REGISTER\n         MNOTE *,'&REG =ADDRESS OF &TYPE OR 0, CC HAS BEEN SET'\n.END     DROP  &REG\n         MEND\n         MACRO\n         TSIOPL\n         SPACE 1\n***********************************************************************\n*        THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF   *\n*        FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE  *\n*        ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE. *\n***********************************************************************\n         SPACE 1\nIOPL     DS    0A\nIOPLUPT  DS    A .                      PTR TO UPT\nIOPLECT  DS    A .                      PTR TO ECT\nIOPLECB  DS    A .                      PTR TO USER'S ECB\nIOPLIOPB DS    A .                      PTR TO THE I/O SRV RTN PARM BLK\nIOPLL    EQU   *-IOPL\n         SPACE 1\n         MEND\n         MACRO\n         TSDAPL\n         SPACE 1\n***********************************************************************\n*        THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER    *\n*        LIST (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER   *\n*        TO DAIR VIA REGISTER 1.                                      *\n***********************************************************************\n         SPACE 1\nDAPL     DS    0F\nDAPLUPT  DS    A .                      PTR TO UPT\nDAPLECT  DS    A .                      PTR TO ECT\nDAPLECB  DS    A .                      PTR TO CP'S ECB\nDAPLPSCB DS    A .                      PTR TO PSCB\nDAPLDAPB DS    A .                      PTR TO DAIR PARAMETER BLOCK\nDAPLL    EQU   *-DAPL\n         SPACE 1\n         MEND\n         MACRO\n         TSPPL\n         SPACE 1\n***********************************************************************\n*        THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES        *\n*        PASSED FROM THE INVOKER TO PARSE VIA REGISTER 1.             *\n***********************************************************************\n         SPACE 1\nPPL      DS    0A\nPPLUPT   DS    A .                      PTR TO UPT\nPPLECT   DS    A .                      PTR TO ECT\nPPLECB   DS    A .                      PTR TO CP'S ECB\nPPLPCL   DS    A .                      PTR TO PCL\nPPLANS   DS    A .                      PTR TO ANS PLACE\nPPLCBUF  DS    A .                      PTR TO CMD BUFFER\nPPLUWA   DS    A .                      PTR TO USER WORK AREA\n*                                       (FOR VALIDITY CHECK ROUTINES)\nPPLL     EQU   *-PPL\nTSPARANS DS    F .                      PARSE RETURNS PTR TO PDL HERE\n         SPACE 1\n         MEND\n         MACRO\n         TSCPPL\n         SPACE 1\n***********************************************************************\n*        THE COMMAND PROCESSOR PARAMETER LIST (CPPL) IS A LIST OF     *\n*        ADDRESSES PASSED FROM THE TMP TO THE CP VIA REGISTER 1.      *\n***********************************************************************\n         SPACE 1\nCPPL     DS    0A\nCPPLCBUF DS    A .                      PTR TO COMMAND BUFFER\nCPPLUPT  DS    A .                      PTR TO UPT\nCPPLPSCB DS    A .                      PTR TO PSCB\nCPPLECT  DS    A .                      PTR TO ECT\nCPPLL    EQU   *-CPPL\n         SPACE 1\n         MEND\n         MACRO\n         $$ASM &M=(JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC)\n         GBLC  &$$DATE1,&$$DATE2,&$$ASM\n         GBLC  &$$MM,&$$DD,&$$YY\n         GBLC  &$$MONTH,&$$DAY,&$$YEAR\n         LCLC  &D\n         LCLA  &I\n&D       SETC  '&SYSDATE'\n         AIF   ('&D'(3,1) EQ '/').D1\n&$$ASM   SETC  'G'\n&$$YY    SETC  '&D'(1,2)                GET YEAR YY\n&$$MONTH SETC  '&D'(3,3)                GET MONTH MMM\n         AIF   (K'&D EQ 6).D2\n&$$DD    SETC  '&D'(6,2)                GET DAY DD\n         AGO   .D3\n.D2      ANOP\n&$$DD    SETC  '0'.'&D'(6,1)            GET DAY 0D\n.D3      ANOP\n&$$DATE1 SETC  '&$$DD&$$MONTH&$$YY'     SET DDMMMYY\n.D3A     ANOP\n&I       SETA  &I+1\n         AIF   ('&$$MONTH' NE '&M(&I)').D3A  FIND MONTH NAME\n&$$MM    SETC  '&I'\n         AIF   (&I GT 9).D4\n&$$MM    SETC  '0&I'\n.D4      ANOP\n&$$DATE2 SETC  '&$$MM/&$$DD/&$$YY'      SET MM/DD/YY\n         AGO   .COMMON\n.D1      ANOP\n&$$DATE2 SETC  '&D'                     SET MM/DD/YY\n&$$MM    SETC  '&D'(1,2)                GET MM\n&$$DD    SETC  '&D'(4,2)                GET DD\n&$$YY    SETC  '&D'(7,2)                GET YY\n&$$MONTH SETC  '&M(&$$MM)'              GET MONTH MMM\n&$$DATE1 SETC  '&$$DD&$$MONTH&$$YY'\n&D       SETC  'ABCDEFGHI'\n         AIF   (K'&D EQ 8).D5           ASMF OR SPASM\n&$$ASM   SETC  'H'\n         AGO   .COMMON\n.D5      AIF   (K'&SYSTIME GT 5).D6\n&$$ASM   SETC  'F'\n         MEXIT\n.D6      ANOP\n&$$ASM   SETC  'S'\n.COMMON  ANOP\n&$$YEAR  SETC  '19&$$YY'                GET 19YY\n         MEND\n         MACRO\n&NFS     $RXR  &TARGET,&SEND,&REG,&H,&A=A\n         GBLB  &OMITTED\n         GBLC  &$NFS\n&OMITTED SETB  0\n         AIF   ('&SEND' EQ '' ).NOSEND  NO SOURCE FIELD\n         AIF   ('&SEND'(1,1) EQ '(').REGSEND SOURCE IS A REGISTER\n&NFS     L&A   &REG,&SEND\n&$NFS    SETC  ''\n         AIF   ('&TARGET' EQ '').END    LEAVE IN REGISTER\n         ST&H  &REG,&TARGET\n         AGO   .END\n.REGSEND AIF   ('&TARGET' NE '').RSTORE\n         AIF   ('&SEND(1)' EQ '&REG').END\n&NFS     LR    &REG,&SEND(1)\n&$NFS    SETC  ''\n         AGO   .END\n.RSTORE  ANOP\n&NFS     ST&H  &SEND(1),&TARGET\n&$NFS    SETC  ''\n         AGO   .END\n.NOSEND  ANOP\n&OMITTED SETB  1                        OPERAND WAS OMITTED\n.END     MEND\n         MACRO\n&LBL     MSG   &C\n         LCLA  &A\n&A       SETA  K'&C\n&A       SETA  &A-2\n&LBL     DC    AL1(&A),CL&A.&C\n         MEND\n         MACRO\n         REGEQU  &F=,&FR=,&PREFIX=R,&STARS=YES\n         GBLC  &$REGS$(15),&R,&FF\n         LCLA  &X\n&R       SETC  '&PREFIX'\n.RLOOP   ANOP\n&X       SETA  &X+1\n         AIF   (&X GT 15).GEN\n         AIF   ('&$REGS$(&X)' EQ '').GEN\n         AIF   ('&R' EQ '&$REGS$(&X)').NOGEN\n         AGO   .RLOOP\n.GEN     ANOP\n&$REGS$(&X) SETC '&R'\n         AIF   ('&STARS' NE 'YES').NOSTAR1\n***********************************************************************\n.NOSTAR1 ANOP\n&R.0     EQU   0\n&R.1     EQU   1\n&R.2     EQU   2\n&R.3     EQU   3\n&R.4     EQU   4\n&R.5     EQU   5                        *************\n&R.6     EQU   6                        *  DEFINE   *\n&R.7     EQU   7                        * SYMBOLIC  *\n&R.8     EQU   8                        * REGISTERS *\n&R.9     EQU   9                        *************\n&R.10    EQU   10\n&R.11    EQU   11\n&R.12    EQU   12\n&R.13    EQU   13\n&R.14    EQU   14\n&R.15    EQU   15\n         AGO   .CONT11\n.NOGEN   ANOP\n******** REGEQU ALREADY CODED FOR THIS PREFIX, IGNORED ****************\n.CONT11  AIF   ('&F&FR' EQ '').NOF\n&X       SETA  0                        RE-INIT\n&FF      SETC  '&F&FR'\n.FLOOP   ANOP\n&X       SETA  &X+1\n         AIF   (&X GT 15).FGEN\n         AIF   ('&$REGS$(&X)' EQ '').FGEN\n         AIF   ('&FF' EQ '&$REGS$(&X)').NOGENF\n         AGO   .FLOOP\n.FGEN    ANOP\n&$REGS$(&X) SETC '&FF'\n         SPACE 1\n&FF.0    EQU   0\n&FF.2    EQU   2\n&FF.4    EQU   4\n&FF.6    EQU   6\n.NOF     AIF   ('&STARS' NE 'YES').NOSTAR2\n***********************************************************************\n.NOSTAR2 SPACE\n         AGO   .MEND\n.NOGENF  ANOP\n******** REGEQU F= ALREADY CODED FOR THIS PREFIX, IGNORED *************\n.MEND    MEND\n         MACRO\n&LABEL   ALLOC &DDNAME=,&DSN=,&MEMBER=,                                X\n               &FILE=,&DATASET=,&PASSWD=,                              X\n               &PREFIX=NO,&DUMMY=NO,&PERM=YES,                         X\n               &SYSOUT=,&FORM=,&PROG=,&ATRNAME=,                       X\n               &UNIT=,&VOL=,                                           X\n               &SPACE=,&DISP=,                                         X\n               &MF=,&SYNAD=\n         GBLB  &OMITTED,&DROP\n         LCLC  &PER,&PRE,&DUM,&REL,&TYP\n         LCLC  &SER,&SRE,&SUM,&SEL,&SYP\n&LABEL   DS    0H\n         AIF   (T'&SYSOUT NE 'O').SYSOUT\n         AIF   ('&DSN' EQ '*' OR '&DATASET' EQ '*').TERMAL\n         $MF   DAPB08,R15,&MF\n         XC    DAPB08(DAPB08L),DAPB08   INITIALIZE DAIR BLOCK TO ZERO\n         MVI   DA08CD+1,X'08'           DAIR ENTRY CODE FOR ALLOCATE\n         $RXR  DA08PDSN,&DSN&DATASET,0  POINTER TO DATASET BUFFER\n         $RXQ  DA08DDN,&DDNAME&FILE,8   DDNAME\n         $RXQ  DA08UNIT,&UNIT,8         UNIT\n         $RXQ  DA08SER,&VOL,8           VOLUME NAME\n         AIF   (&OMITTED).MEMBER\n         MVC   DA08SER+6(2),=CL2' '     CLEAR LAST 2 BYTES OF VOLUME\n.MEMBER  $RXQ  DA08MNM,&MEMBER,8        MEMBER NAME\n         $RXQ  DA08PSWD,&PASSWD,8       PASSWORD\n         AIF   ('&DISP(1)' EQ 'OLD' AND '&SPACE(1)' NE '').SPACMSG\n         AIF   ('&DISP(1)' EQ 'SHR' AND '&SPACE(1)' NE '').SPACMSG\n         AIF   ('&SPACE' EQ '' ).NOSPACE\n         AIF   ( '&SPACE(1)' EQ '' ).SPACE2\n         AIF   ('&SPACE(1)' EQ 'TRK').TRK\n         AIF   ('&SPACE(1)' EQ 'CYL').CYL\n         $RXR  DA08BLK,&SPACE(1),0      AVERAGE BLOCK LENGTH\n&TYP     SETC  'DA08ABKL'\n&SYP     SETC  '+'\n*        ALLOCATION BY AVERAGE BLOCK LENGTH.\n         AGO   .SPACE2\n.TRK     ANOP\n&TYP     SETC  'DA08TRKS'\n&SYP     SETC  '+'\n*        ALLOCATION IN TRACKS.\n         AGO   .SPACE2\n.CYL     ANOP\n&TYP     SETC  'DA08CYLS'\n&SYP     SETC  '+'\n*        ALLOCATION IN CYLINDERS.\n         AGO   .SPACE2\n.NOSPACE ANOP\n         AGO   .DISP\n.SPACE2  ANOP\n         $RXR  DA08PQTY,&SPACE(2),0     PRIMARY SPACE ALLOCATION\n         $RXR  DA08SQTY,&SPACE(3),0     SECONDARY QUANTITY\n         $RXR  DA08DQTY,&SPACE(4),0     DIRECTORY QUANTITY\n         AGO   .SKIP\n.SPACMSG MNOTE *,'DISP=&DISP(1) SPECIFIED, SPACE PARAMETERS IGNORED'\n.SKIP    AIF   ('&SPACE(5)' NE 'RLSE').DISP\n&REL     SETC  'DA08RLSE'\n*        RELEASE REQUESTED.\n&SEL     SETC  '+'\n.DISP    AIF   ('&PREFIX' NE  'YES').NOPREF\n&PRE     SETC  'DA08UID'\n*        PREFIX WITH CHARGENO.USERID. REQUESTED.\n&SRE     SETC  '+'\n.NOPREF  AIF   ('&PERM' NE 'YES').NOTPERM\n&PER     SETC  'DA08PERM'\n*        DATASET MUST BE SPECIFICALLY FREED.\n&SER     SETC  '+'\n.NOTPERM AIF   ('&DUMMY' NE 'YES').NODUMMY\n&DUM     SETC  'DA08DMMY'\n*        THIS IS A DUMMY DATASET.\n&SUM     SETC  '+'\n.NODUMMY ANOP\n         AIF   ('&PRE' EQ ''  AND '&PER' EQ ''  AND '&REL' EQ ''       X\n               AND '&DUM' EQ '' AND '&TYP' EQ '').NOCTL\n         OI    DA08CTL,0&SYP&TYP&SER&PER&SEL&REL&SUM&DUM&SRE&PRE\n.NOCTL   AIF   (T'&DISP EQ 'O').NODISP\n         AIF   (T'&DISP(1) EQ 'O').NODISP1\n         AIF   ('&DISP(1)' NE 'NEW').OLD1\n         MVI   DA08DSP1,DA08NEW         DISP=NEW\n         AGO   .DISP2\n.OLD1    AIF   ('&DISP(1)' NE 'OLD').SHR1\n         MVI   DA08DSP1,DA08OLD         DISP=OLD\n         AGO   .DISP2\n.SHR1    AIF   ('&DISP(1)' NE 'SHR').MOD1\n         MVI   DA08DSP1,DA08SHR         DISP=SHR\n         AGO   .DISP2\n.MOD1    AIF   ('&DISP(1)' NE 'MOD').DISPBAD\n         MVI   DA08DSP1,DA08MOD         DISP=MOD\n         AGO   .DISP2\n.NODISP1 ANOP\n*        DEFAULT INITIAL DISPOSTION IS DISP=NEW.\n.DISP2   AIF   (T'&DISP(2) EQ 'O').NODISP2\n         AIF   ('&DISP(2)' NE 'KEEP').DELETE2\n         MVI   DA08DPS2,DA08KEEP        DISP=(,KEEP)\n         AGO   .DISP3\n.DELETE2 AIF   ('&DISP(2)' NE 'DELETE').CATLG2\n         MVI   DA08DPS2,DA08DEL         DISP=(,DELETE)\n         AGO   .DISP3\n.CATLG2  AIF   ('&DISP(2)' NE 'CATLG').UNCAT2\n         MVI   DA08DPS2,DA08CAT         DISP=(,CATLG)\n         AGO   .DISP3\n.UNCAT2  AIF   ('&DISP(2)' NE 'UNCATLG').DISPBAD\n         MVI   DA08DPS2,DA08UCAT        DISP=(,UNCATLG)\n         AGO   .DISP3\n.NODISP2 ANOP\n*        DEFAULT FINAL DISPOSITION IS DISP=(,KEEP).\n         AGO   .DISP3\n.DISP3   AIF   (T'&DISP(3) EQ 'O').MF\n         AIF   ('&DISP(3)' NE 'KEEP').DELETE3\n         MVI   DA08DPS3,DA08KEP         DISP=(,,KEEP)\n         AGO   .MF\n.DELETE3 AIF   ('&DISP(3)' NE 'DELETE').CATLG3\n         MVI   DA08DPS3,DA08DELE        DISP=(,,DELETE)\n         AGO   .MF\n.CATLG3  AIF   ('&DISP(3)' NE 'CATLG').UNCAT3\n         MVI   DA08DPS3,DA08CATL        DISP=(,,CATLG)\n         AGO   .MF\n.UNCAT3  AIF   ('&DISP(3)' NE 'UNCATLG').DISPBAD\n         MVI   DA08DPS3,DA08UNCT        DISP=(,,UNCATLG)\n         AGO   .MF\n.NODISP  ANOP\n*        DEFAULT DISPOSITION IS DISP=(NEW,KEEP).\n         AGO   .MF\n.DISPBAD ANOP\n         MNOTE  *,'********************************************'\n         MNOTE  12,'-- INVALID DISPOSITON, EXPANSION TERMINATED'\n         MNOTE  *,'********************************************'\n         MEXIT\n.MF      $RXQ  DA08ALN,&ATRNAME,8       ATTRIBUTE LIST NAME\n         AIF   (&OMITTED).LBE\n         OI    DA08CTL,DA08ATRL         ATTRIBUTE LIST SUPPLIED\n         AGO   .LBE\n.SYSOUT  $MF   DAPB30,R15,&MF\n         XC    DAPB30(DAPB30L),DAPB30   INITIALIZE DAIR BLOCK TO ZERO\n         MVI   DA30CD+1,X'30'           DAIR ENTRY CODE SYSOUT ALLOCATE\n         $RXR  DA30PDSN,&DSN&DATASET,0  POINTER TO DATASET NAME\n         $RXQ  DA30DDN,&DDNAME&FILE,8   DDNAME\n         $RXQ  DA30UNIT,&UNIT,8         UNITNAME\n         $RXQ  DA30SER,&VOL,8           VOLUME NAME\n         AIF   (&OMITTED).PROG\n         MVC   DA30SER+6(2),=CL2' '     CLEAR LAST 2 BYTES OF VOLUME\n.PROG    $RXQ  DA30PGNM,&PROG,8         PROGRAM NAME\n         AIF   (T'&SPACE EQ 'O').DISPS\n         AIF   ('&SPACE(1)' EQ 'TRK').TRKS\n         AIF   ('&SPACE(1)' EQ 'CYL').CYLS\n         $RXR  DA30BLK,&SPACE(1),0      AVERAGE BLOCK LENGTH\n&TYP     SETC  'DA30ABKL'\n&SYP     SETC  '+'\n*        ALLOCATION BY AVERAGE BLOCK LENGTH.\n         AGO   .SPACE2S\n.TRKS    ANOP\n&TYP     SETC  'DA30TRKS'\n&SYP     SETC  '+'\n*        ALLOCATION IN TRACKS.\n         AGO   .SPACE2S\n.CYLS    ANOP\n&TYP     SETC  'DA08CYLS'\n&SYP     SETC  '+'\n*        ALLOCATION IN CYLINDERS.\n.SPACE2S $RXR  DA30PQTY,&SPACE(2),0     PRIMARY ALLOCATION QUANTITY\n         $RXR  DA30SQTY,&SPACE(3),0     SECONDARY QUANTITY\n         AIF   (T'&SPACE(4) EQ 'O').SPACE5S\n        MNOTE *,'SPACE=, DIRECTORY QUANTITY INVALID FOR SYSOUT DATASET'\n.SPACE5S AIF   ('&SPACE(5)' NE 'RLSE').DISPS\n&REL     SETC  'DA30RLSE'\n*        RELEASE REQUESTED.\n&SEL     SETC  '+'\n.DISPS   AIF   ('&PREFIX' NE  'YES').NOPREFS\n&PRE     SETC  'DA30UID'\n*        PREFIX WITH CHARGENO.USERID. REQUESTED.\n&SRE     SETC  '+'\n.NOPREFS AIF   ('&PERM' NE 'YES').NOTPERS\n&PER     SETC  'DA30PERM'\n*        DATASET MUST BE SPECIFICALLY FREED.\n&SER     SETC  '+'\n.NOTPERS AIF   ('&DUMMY' NE 'YES').NODUMMS\n&DUM     SETC  'DA30DMMY'\n*        THIS IS A DUMMY DATASET.\n&SUM     SETC  '+'\n.NODUMMS AIF   ('&PRE' EQ ''  AND '&PER' EQ ''  AND '&REL' EQ ''       X\n               AND '&DUM' EQ '' AND '&TYP' EQ '').NOCTLS\n         OI DA30CTL,&TYP&SER&PER&SEL&REL&SUM&DUM&SRE&PRE\n.NOCTLS  $RXQ  DA30FORM,&FORM,4         FORM NUMBER\n         $RXQ  DA30OCLS,&SYSOUT,2       SYSOUT CLASS\n         AIF   (&OMITTED).CONT2\n         MVI   DA30OCLS+1,C' '          CLEAR SECOND BYTE\n         AGO   .CONT2\n.TERMAL  $MF   DAPB1C,R15,&MF\n         XC    DAPB1C(DAPB1CL),DAPB1C   INITIALIZE DAIR BLOCK TO ZERO\n         MVI   DA1CCD+1,X'1C' DAIR ENTRY CODE FOR TERMINAL ALLOCATION\n         AIF   ('&PERM' NE 'YES').NOPERMT\n         OI    DA1CCTL,DA1CPERM    PERMANENTYLY ALLOCATED BIT\n.NOPERMT $RXQ  DA1CDDN,&DDNAME&FILE,8   DDNAME\n         $RXQ  DA1CALN,&ATRNAME,8       ATTRIBUTE LIST NAME\n         AIF   (&OMITTED).LBE\n         OI    DA1CCTL,DA1CATRL         ATTRIBUTE LIST SUPPLIED\n         AGO   .LBE\n.CONT2   $RXQ  DA30ALN,&ATRNAME,8       ATTRIBUTE LIST NAME\n         AIF   (&OMITTED).LBE\n         OI    DA30CTL,DA30ATRL         ATTRIBUTE LIST SUPPLIED\n.LBE     AIF   ('&MF(1)' EQ 'B').ENDB\n         AIF   ('&MF(1)' EQ 'L').ENDS\n         TSDAIR DAPB=(15),SYNAD=&SYNAD\n         AGO   .ENDS\n.ENDB    ST    R15,DAPLDAPB\n         LA    R1,DAPL\n.ENDS    AIF   (NOT &DROP).END2S\n         DROP  R15                 DROP ADDRESSIBILITY TO DAIR BLOCK\n.END2S   SPACE 1\n         MEND\n         MACRO\n&N       OP    &M,&F,&O\n         GBLA  &#                                                  LDW1\n         LCLC  &F$\n&F$      SETC  '&F'\n         AIF   ('&F'(1,1) NE '''').OK\n&F$      SETC  '&F'(2,1)\n.OK      ANOP\n&#       SETA  &#+1                                                LDW1\n@&O      EQU   &#                                                  LDW1\n&N       DC    CL4'&M',C'&F$',X'&O'\n         MEND\n         MACRO\n&NFS     STCMX &REG,&MASK,&ADDR,&BYTE=,&COPY=                      LDW1\n&NFS     STCM  &REG,B'0111',&ADDR       DO IT RIGHT                LDW1\n         MEND\n         MACRO\n&N       TSWORK &DUMMY\n         EJECT\n*        OLD CS DSECT SORTA.\n         SPACE 1\nTSOBITS  DS    0F,4X                    GUESS\nGODFLAG  DS    X                        MOST USEFUL FLAG\nCSALTFLG DS    X                        BITS\nUSERID   DS    0C'CPC013.LDW'           HANDLE FOR BOTH            LDW1\nCSJOBNO  DS    CL6                      CHARGE NO\nCSDOT    DC    C'.'                                                LDW1\nCSINIT   DS    CL3                      UID\nDDNALL   DS    CL8                      SAVE DDNAME TO FREE IT     -EU-\nDISPCONS DS    0F                       DISPLAY CONSTANTS          LDW1\nNOWMASK  DS    F'-8'                                               LDW1\nBITMASK  DS    F'7'                                                LDW1\nLINELEN  DS    H'40'                    LENGTH OF LINES TO USE     LDW1\nSCRBYTES DS    H'96'                    (BYTES/SCREEN)/2           LDW1\nLINEHEX  DS    H'16'                    NUMBER OF BYTES/LINE HEX   LDW1\nLINEHEX2 DS    H'32'                    TWICE THE ABOVE            LDW1\nBYTES    DS    16AL1                    TRTAB FOR CARET            LDW1\nDISPCONL EQU   *-NOWMASK                LEN OF DISPLAY CONSTANTS   LDW1\n         SPACE 1\n*        ZAP'S DATA AREA FOR EXP.\n         SPACE 1\nGORF     DS    F                        SAVE AREA FOR PTR\nEXPOPT   DS    X                        WHETHER TO SCAN LABLE TAB\nDBLW     DS    D\nEXPWORK  DS    D\nEXPARMS  DS    0F                       'SAVEAREA' FOR 'EXP'\nEXPFLAG  DS    3F\n         DS    A\nEXPSTART DS    A\n         DS    F                        LENGTH\nEXPPTR   DS    A\n         SPACE 1\n*        ZAP'S DATA AREA.\n         SPACE 1\nNOWSTUFF DS    0F                                                  LDW1\n*        FOLLOWING 3 LINES *MUST*BE*TOGETHER*\nOLDPOINT DS    H                        OFFSET INTO BUFFER\nOFFSET   DS    F                        (OLDPOINT + BASEVAL)       LDW1\nBASEVAL  DS    F                        BASE VALUE                 LDW1\nNOWLEN   EQU   *-NOWSTUFF                                          LDW1\n         SPACE 1\nAIDEFTAB DS    A                        ADDR OF DEFINE TABLE\nAITRCTAB DS    A                        ADDR OF TRACE TABLE        LDW1\nAITREND  DS    A                        -> END OF TRACE TABLE      LDW1\nFIRSTSCR DS    A                        ADDR OF FIRST SCREEN LOC\nMAXSCR   DS    A                        ADDR OF END OF AVAIL SCR\nADDRWORK DS    F                        ADDRESS OF MSG AND WTO WORK\nSIZEWORK DS    F                        SIZE OF MSG AND WTO WORK\nCSOUTWK  EQU   ADDRWORK                 CSOUT WORKAREA IS FIRST\nTEMPTRT  DS    XL256                    TEMP TRTAB FOR STRING ANAL\n         SPACE 1\n$L       EQU   79                       LENGTH OF DISPLAY LINE     LDW1\n$I       EQU   81                       LINE INCREMENT (IN SCREEN) LDW1\nSCREEN   EQU   *                                                   SDM5\nCTL3270  DS    XL7                      WHERE THE 3270 STUFF GOES  LDW1\n         DS    X'1D60'                  PROT NORMAL                SDM5\nLINE01   DS    CL79,X'1DC8'             SCREEN BUFFER...           SDM5\nLINE02   DS    CL79,X'1D60'             .                          LDW1\nLINE03   DS    CL79,X'1DC8'             .                          LDW1\nREP      DS    CL79,X'1DF8'             .                          LDW1\nLINE05   DS    CL79,X'1D60'             .                          LDW1\nLINE06   DS    CL79,X'1D60'             .                          LDW1\nLINE07   DS    CL79,X'1D60'             .                          LDW1\nLINE08   DS    CL79,X'1D60'             .                          LDW1\nLINE09   DS    CL79,X'1D60'             .                          LDW1\nLINE10   DS    CL79,X'1D60'             .                          LDW1\nLINE11   DS    CL79,X'1D60'             .                          LDW1\nLINE12   DS    CL79,X'1D60'             .                          LDW1\nLINE13   DS    CL79,X'1D60'             .                          LDW1\nLINE14   DS    CL79,X'1D60'             .                          LDW1\nLINE15   DS    CL79,X'1D60'             .                          LDW1\nLINE16   DS    CL79,X'1D60'             .                          LDW1\nLINE17   DS    CL79,X'1D60'             .                          LDW1\nLINE18   DS    CL79,X'1DF8'             .                          LDW1\nLINE19   DS    CL79,X'1D60'             .                          LDW1\nLINE20   DS    CL79,X'1D60'             .                          LDW1\nLINE21   DS    CL79                     .                          SDM5\nEND3270  DS    XL8                      WHERE THE REST GOES        SDM5\nSCREENL  EQU   *-SCREEN                 LENGTH OF SCREEN DATA      SDM5\nREGS3270 DS    A(SCREEN,SCREENL)        TPUT FULLSCR REGS          SDM5\nASCRWORK DS    A(SCRWORK)               -> SCREEN WORK AREA        LDW2\nAOLDSCR  DS    A(OLDSCR)                -> SCREEN SAVE AREA        SDM5\nREPX     DS    CL(1+2+(3+79)*2)         REPLY BUFF FOR TGET ASIS   SDM1\nPREVREP  DS    CL79                     THE PREVIOUS REPLY         LDW4\nVERSION  DS    C'VERSION=V.MC DDMMMYY LDW'                         LDW1\nCURPOS   DS    H                        CURSOR POSITION            LDW1\nTERMSAVE DS    A                        SAVE FOR R14 IN PUTLINE    LDW1\nLINEDESC DC    Y($L+4,0)                THE \"OLD\" FOR PUTLINE      LDW1\nLINEBUFF DS    CL80                     PUTLINE'S BUFFER           LDW1\nDSNAMEL  DS    H                        LENGTH OF DSN (44)\nDSNAME   DS    CL44                     DSN\nPASSWORD DS    CL8                      GUESS WHAT?                LDW1\nDISPDSN  DS    CL44                     DISPLAYABLE DSN            LDW1\nALLDSNL  DS    H                        LENGTH OF DSN TO ALLOCATE  -EU-\nALLOCDSN DS    CL44                     DSN TO ALLOCATE            LDW1\n         SPACE 1                                                   -EU-\nATIOT    DC    F'0'                                                -EU-\nTDDNMSV  DC    F'0'                                                -EU-\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(*-*)            -EU-\nRQA      DC    XL1'0'                                              -EU-\nREQAUTL  EQU   *-REQAUT                                            -EU-\nCAPSFLG  DC    XL1'0'                                              -EU-\n         SPACE 1                                                   -EU-\nTTR      DS    F                        TTR OF BLK\n*        THE LAST BYTE OF \"TTR\" IS USED FOR A SEQUENTIAL READ FLAG.\nOLDTTR   DS    F                        TTR OF LAST STORE OR SET CMD\nSTOPDUMP DS    XL3                      TTR WHERE TO STOP DUMP\nDSORG    DS    X                        DSORG OF CURRENT DATASET\nDSORGPO  EQU   X'02'                    DSORG=PARTITIONED ORGANIZATION\n         SPACE 1\nIDEFAVAL DS    A                        1ST AVAL POSIT IN DEFINE TAB\nITRAVAL  DS    A                        1ST AVAIL TRACE TAB POSIT\nCURRITR  DS    F                        CURRENT TRACE TABLE ENTRY PTR\n         SPACE 1\nTEMP     DS    2D                       WORK AREA\nTEMP2    DS    5D                       WORK AREA\nTRTABADD DS    A                        PTR TO TRTAB FOR DUMP DISPLAY\nTRTXTAB  DS    A                        PTR TO TRTAB FOR STRING    -EU-\n         SPACE 1\nMIDLINE  DS    A                        CARET\nWIDTHS   DS    0F                       FOR WINDOWS       |**********|\nWIDTHD   DS    F                        FOR DOWN          |CONTIGUOUS|\nWIDTHU   DS    F                        UP                |**********|\n         SPACE 1\nREALRDLN DS    H                        ACTUAL COMND READ LENGTH\nREADLEN  DS    H                        READLENGTH FROM TGET\nTRACE    DS    X                        FLAG-TRACE IN EFFECT OR NOT\nCONTINUE DS    X                        STORES, SCAN, SET IN EFFECT\nIOERROR  DS    X                        FLAG-SYNAD I/O ERROR OR NOT\nCPUTFLAG DS    X                        WHETHER CSOUT CAN ENQ OR NOT\nEOFRET   DS    X                        IGNORE EOF'S?\nENQIT    DS    X                        WHETHER THERES ANYTHING TO ENQ\nCHNGED   DS    X                        SET IF BUFFER NEEDS CHKPOINTING\nIDRFLAG  DS    X                        WHETHER IDR WAS UPDATED OR NOT\n         SPACE 1\nFLAGS2   DS    X                        MISC FLAGS FOR TSO VERSION\nMUSTZAP  EQU   X'80'                    BLK NOT REP, ENTER SAVE/EN\nATTNHIT  EQU   X'40'                    ATTN HIT SINCE LAST TGET   LDW5\nSENSF    EQU   X'20'                    URSA OR SYS DS\nLOGF     EQU   X'10'                    IN LOGGING STATE\nNOWHEREF EQU   X'08'                    WHERE NOT NEEDED           SDM6\nTERSEF   EQU   X'04'                    PERMANENTLY SUPPRESS WHERE SDM6\n         SPACE 1\nFLAGS3   DS    X                        CRT AND 3270 FLAGS         LDW2\nRESHOWF  EQU   X'40'                    REFRESH WHOLE SCR NXT TPUT LDW2\nNODISPF  EQU   X'20'                    DON'T DISP SCRN THIS TIME  SDM6\nF3270    EQU   X'10'                    3270 OPTION ON             LDW5\nFSMODE   EQU   X'08'                    FULLSCR MODE ACTIVE        LDW5\nCRTF     EQU   X'04'                    CRT KEYWORD GIVEN          LDW5\n         SPACE 1\n         DS    X                        (UNUSED)                   LDW2\nLOOKFOR  DS    H,CL16                   SCAN WORK AREA (LEN+STRING)\nZAPSTRNG DS    H,CL16                   S,X,O,N WORK AREA (LEN+STRING)\nSETSTR   DS    H,CL16                   SET WORK AREA (LEN+STRING)\nWKSTR    DS    CL16                     WORK STRING AREA           -EU-\n         SPACE 1\nADDRCNT  DS    A                        ADDRESS OF RECORD COUNT    LDW1\nADDRKEY  DS    A                        ADDRESS OF RECORD KEY      LDW1\nADDRDATA DS    A                        ADDRESS OF RECORD DATA     LDW1\nADDRBUFF DS    A                        ONE OF THE ABOVE 3 ADDRS   LDW1\nBUFFSIZE DS    H                        MAX BUFFER SIZE             *N*\nKEYLEN   DS    H                        CURRENT KEY LENGTH          *N*\nBLKLEN   DS    H                        ACTUAL BLOCK LENGTH AFT READ*N*\n         SPACE 1\nESDID    DS    H                        ESD ID\nMEMTTR   DS    XL3                      SAVE MEMBER'S TTR\nTXTTTR   DS    XL3                      LOAD MOD'S FIRST TEXT BLK   *N*\nCTL1TTR  DS    XL3                      TTR OF 1ST CTL REC OR 0    MAS2\nTXTORIG  DS    F                        ORIG OF NXT TXT BLOCK      MAS2\nMEMBER   DS    CL8                      MEMBER FOR PDS SEARCH\nNAME     DS    CL8                      ENTRY NAME FOR EPA SEARCH   *N*\nENDTTR   DS    XL3                      TTR OF LAST BLK IN DATASET\nLASTFMT1 DS    XL5                      CCHHR OF LAST FMT1 DSCB    LDW4\nESDTTR   DS    XL3                      START OF ESD               LDW1\n         SPACE 1\nDCBLIST  DS    F                        DCB PTR MF=L OPEN AND CLOSE\nDSCBLIST EQU   TEMP2+16                                            LDW1\nVOLSER   DS    CL6                      VOL=SER OF DSN\n         SPACE 2\n*TMPLIST  OACTMP MF=L                    FOR 'DO'                  -EU-\n*TMPLISTL EQU   *-TMPLIST                LEN                       -EU-\n         SPACE 2\n*DCBU    DCB   MACRF=E,DDNAME=DDNAME,DEVD=DA                       LDW1\nDCBU     DCB   MACRF=E,DDNAME=DDNAME,DEVD=DA                       LDW1\n         DS    5F                       TURKEY SYSTEM (NEED 72 BYTELDW1\n         SPACE 2                                                   LDW1\nIOB      DC    X'42000000'              IOBFLAG                    LDW1\n         DC    A(ECB)                   IOBECBA                    LDW1\nCSW      DS    XL8                      IOBCSW                     LDW1\nIOBCCWA  DC    A(CCWS,DCBU,0,0)         IOBCCWA,IOBDCBA,?,?        LDW1\nMBBCCHHR DS    0XL8,XL3                 IOBSEEK                    LDW1\nCCHHR    DS    XL5                      INTERESTING PART           LDW1\n         SPACE 1                                                   LDW1\nECB      DS    A                        ECB FOR ECXP               LDW1\n         SPACE 1\nCCWS     DS    0D                       HANDLE FOR ALL CCWS        LDW1\nCCW##R   CCW   X'16',0,X'70',1          READ R0 TO ORIENT          LDW1\nCCW#R#S  CCW   X'31',CCHHR,X'40',5      SEARCH ID EQ               LDW1\nCCW#R#T  CCW   X'08',*-8,X'00',0        TIC *-8                    LDW1\nCCW#R#R  CCW   X'1E',*-*,X'20',*-*      READ CKD                   LDW1\n         SPACE 1\nCCW##W   DS    0D                                                  LDW1\nCCW#W#S  CCW   X'31',CCHHR,X'40',5      SEARCH ID EQ               LDW1\nCCW#W#T  CCW   X'08',*-8,X'00',0        TIC *-8                    LDW1\nCCW#W#W  CCW   X'0D',*-*,X'00',*-*      WRITE KD                   LDW1\n         SPACE 1\nCCW##R0  CCW   X'16',*-*,X'20',*-*      READ R0                    LDW1\n         SPACE 1\nCCW##D   CCW   X'16',0,X'70',1          READ R0 TO ORIENT          LDW1\nCCW#D#S  CCW   X'E9',NAME,X'40',8       SEARCH KEY EQ/HI MT        LDW1\nCCW#D#T  CCW   X'08',*-8,X'00',0        TIC *-8                    LDW1\nCCW#D#R  CCW   X'0E',*-*,X'00',8+256    READ KD                    LDW1\n         SPACE 1\nCCW##F   DS    0D                                                  LDW1\nCCW#F#S  CCW   X'31',CCHHR,X'40',5      SEARCH ID EQ               LDW1\nCCW#F#T  CCW   X'08',*-8,X'00',0        TIC *-8                    LDW1\nCCW#F#W  CCW   X'1D',*-*,X'20',*-*      WRITE CKD                  LDW1\n         SPACE 1\nCCWL     EQU   *-CCWS                   LENGTH OF CCW PATTERNS     LDW1\n         SPACE 2                                                   LDW1\n*STAXLIST STAX 0,MF=L\nSTAXLIST STAX  0,MF=L\nSTAXL    EQU   *-STAXLIST\n         SPACE 2\nFLAGESD  DS    X                        FLAGS                       *N*\nFESDTEXT EQU   X'80'                    NEXT BLOCK IS TEXT          *N*\n         SPACE 2                                                   LDW1\nPTPB     DS    0F,XL12                  FOR PUTLINE                LDW1\n*        PGPB  DSECT=NO\n         PGPB  DSECT=NO\n         SPACE 2\nEXLST    DS    A(JFCB)                  OBVIOUS                    LDW1\nJFCB     DS    44F                      OBVIOUS                    LDW1\n         SPACE 2                                                   -EU-\nICREP    DS    CL79                INTEGRAL COPY OF RESPONSE FIELD -EU-\nBLANKS   DS    CL256                    CONSTANT FOR CLEARING      LDW1\n         SPACE 2                                                   LDW3\nIDEFTAB  DS    24XL10                   24 ENTRY DEFINE TABLE\nENDITAB  DS    X                        END OF TABLE (X'FF')\n         SPACE 1\n*        EACH ENTRY ABOVE IS OF THE FORM (8C,H),\n*        CORRESPONDING TO 'SYMBOL,OFFSET'.\n         SPACE 2\nITRTAB   DS    24XL5                    TRACE TABLE\nITREND   DS    X                        END OF TABLE (X'FF')\n         SPACE 1\n*        EACH ENTRY ABOVE IS OF THE FORM (3X,2X),\n*        CORRESPONDING TO 'TTR,OFFSET'.\n         SPACE 2\nOLDSCR   DS    CL(21*$I)                SCREEN SAVE AREA           SDM5\nSCRWORK  DS    CL(SCREENL+3*21)         JUST PARTS THAT CHANGED    LDW2\n         SPACE 2\n         MEND\n         MACRO\n&NFS     ENTR  &BASE=12,&BASE2=,&BASE3=,&BASE4=,                       X\n               &SAVE=*,&REGS=(YES,R),&F=,                              X\n               &USING=,&SECTYPE=CSECT,&GETMAIN=,&PARMREG=,&LPARM=,     X\n               &SP=1,&ID=*,&EXIT=,&ADDRREG=,&LENREG=,&ENV=CALL,        X\n               &RC=,&RCLOC=,&T=T,&PL=,&LOAD=,&SYMREG=,&DSECT=,         X\n               &TSFAKE=,&PARSE=,&MACRO=,&PRINT=,&DATE=,&TIME=\n         GBLB  &GDAIRM,&GPARSEM         TO AVOID DUPLICATES\n         GBLB  &GDAIR,&GPARSE           DAIR OR PARSE LOADED\n         LCLC  &BA$E,&$AVE,&Q,&NAME,&RCRC,&LR,&AR,&T$FAKE,&GET1,&GET2\n         LCLC  &PARNAME\n         LCLC  &IHBNX,&BLANK1,&BLANK2\n         LCLC  &R0,&R1,&R2,&R3,&R12,&R13,&R14,&R15\n         LCLA  &L,&X\n         LCLB  &ENVTSO,&ENVCALL,&ENVCP,&ENVPLI,&ENVMVT,&ENVMVS\n         LCLB  &FKCALL,&FKCP,&MVSCVT\n         LCLB  &CSPL,&PARS,&DAIR,&IO,&MSG\n&IHBNX   SETC  'IHB&SYSNDX'\n&BLANK1  SETC  '        '\n&BLANK2  SETC  '        '\n&PARNAME SETC  ''\n         AIF   ('&PRINT' NE 'NOGEN').PRINTOK\n         AIF   ('&PRINT' NE '').PRINTOK\n         MNOTE 4,'WHAT DOES PRINT=&PRINT MEAN???'\n.PRINTOK AIF   ('&SYMREG' EQ '').NOSYMRG\n         MNOTE 0,'SYMREG= IS UNSUPPORTED -- USE REGS='\n.NOSYMRG AIF   ('&DSECT' EQ '').NOD$ECT\n         MNOTE 4,'DSECT= IS UNSUPPORTED'\n.NOD$ECT ANOP\n&X       SETA  0\n.ENVLOOP AIF   (N'&ENV EQ &X).ENVDONE\n&X       SETA  &X+1\n         AIF   ('&ENV(&X)' EQ 'TSO'  ).ENVTSO\n         AIF   ('&ENV(&X)' EQ 'CALL' ).ENVCALL\n         AIF   ('&ENV(&X)' EQ 'CP'   ).ENVCP\n         AIF   ('&ENV(&X)' EQ 'TSOCP').ENVCP\n         AIF   ('&ENV(&X)' EQ 'MVS'  ).ENVMVS\n         AIF   ('&ENV(&X)' EQ 'MVT'  ).ENVMVT\n         MNOTE 4,'ENV=&ENV(&X) IS INVALID -- IGNORED'\n         AGO   .ENVLOOP\n.ENVTSO  ANOP\n&ENVTSO  SETB  1\n         AGO   .ENVLOOP\n.ENVCALL ANOP\n&ENVCALL SETB  1\n         AGO   .ENVLOOP\n.ENVCP   ANOP\n&ENVCP   SETB  1\n&ENVTSO  SETB  1                        ENV=CP IMPLIES ENV=TSO\n         AGO   .ENVLOOP\n.ENVMVS  ANOP\n&ENVMVS  SETB  1\n         AGO   .ENVLOOP\n.ENVMVT  ANOP\n&ENVMVT  SETB  1\n         AGO   .ENVLOOP\n.ENVPLI  ANOP\n&ENVPLI  SETB  1\n         AIF   ('&BASE' NE '12' AND '&BASE' NE 'R12').ENVLOOP\n         MNOTE 0,'WARNING : BASE=&BASE IS NOT COMPATIBLE WITH ENV=PLIX'\n         AGO   .ENVLOOP\n.ENVDONE AIF   (NOT &ENVCALL OR NOT &ENVCP).ENVOK1\n        MNOTE 4,'ENV=(CALL,CP) MAY NOT BOTH BE GIVEN. \"CALL\" IGNORED.'\n&ENVCALL SETB  0                        IGNORE IT\n.ENVOK1  AIF   (NOT &ENVMVT OR NOT &ENVMVS).ENVOK2\n         MNOTE 4,'MAKE UP YOUR MIND : ENV=MVT OR ENV=MVS, BUT NOT BOTH.X\n                 MVT ASSUMED.'\n&ENVMVS  SETB  0                        IGNORE IT\n.ENVOK2  AIF   ('&TSFAKE' EQ '').NOFAKE\n&T$FAKE  SETC  '&TSFAKE'\n         AIF   ('&TSFAKE' NE 'YES').FAKENO\n&T$FAKE  SETC  '&IHBNX.F'\n.FAKENO  AIF   ('&PARMREG' NE '').OKFAKE0\n         MNOTE 4,'*** PARMREG= MUST BE GIVEN IF TSFAKE= IS GIVEN. TSFAKX\n               E=&TSFAKE IGNORED.'\n         AGO   .NOFAKE\n.OKFAKE0 AIF   (NOT &ENVCALL).NOFKCAL\n&FKCALL  SETB  1\n         AGO   .NOFAKE\n.NOFKCAL AIF   (NOT &ENVCP).NOFKCP\n&FKCP    SETB  1\n         AGO   .NOFAKE\n.NOFKCP  MNOTE 0,'WHAT TO FAKE?????'\n.NOFAKE  ANOP\n&$AVE    SETC  '&SAVE'                  INIT DEFAULT\n&GET1    SETC  '&GETMAIN(1)'\n&GET2    SETC  '&GETMAIN(2)'\n         AIF   ('&MACRO' NE 'YES').OKGET2\n         AIF   ('&GET1' NE '').OKGET1\n&GET1    SETC  'TSDSECTL'               SET DEFAULT\n.OKGET1  AIF   ('&GET2' NE '').OKGET2\n&GET2    SETC  'TSDSECT'                SET DEFAULT\n.OKGET2  AIF   ('&GETMAIN' EQ '').KEEPSAV\n         AIF   ('&GETMAIN(1)' NE '').GMOK1\n         AIF   ('&MACRO' EQ 'YES').GMOK1\n         MNOTE 8,'GETMAIN= CODED INCORRECTLY. MACRO TERMINATED'\n         MEXIT\n.GMOK1   ANOP\n&$AVE    SETC  ''                       NO SAVE AREA\n.KEEPSAV AIF   ('&BASE4' EQ '').NOBASE4\n         AIF   ('&BASE3' NE '').BASE3\n         MNOTE 8,'*** BASE4 IGNORED, INVALID WITHOUT BASE3= ***'\n.NOBASE4 AIF   ('&BASE3' EQ '').OKBASES\n.BASE3   AIF   ('&BASE2' NE '').OKBASES\n         MNOTE 8,'*** BASE3 IGNORED, INVALID WITHOUT BASE2= ***'\n.OKBASES AIF   (('&GETMAIN' EQ '') AND ('&MACRO' NE 'YES')).OK1\n         AIF   ('&SAVE'   EQ '*').OK1\n         AIF   ('&SAVE'    EQ '').OK1\n         MNOTE 12,'*** SAVE= MUTUALLY EXCLUSIVE WITH GETMAIN= AND/OR MA$\n               CRO=YES. MACRO TERMINATED ***'\n         MEXIT\n.OK1     AIF   ('&NFS' NE '').GOTNAME\n         MNOTE 12,'*** CSECT NAME OMMITTED ***'\n.GOTNAME AIF   ('&SECTYPE' NE 'CSECT').NOCSECT\n.DOCSECT ANOP\n&NFS     CSECT                          ENTR -- 09/27/79 -- LDW\n         AGO   .SECDONE\n.NOCSECT AIF   ('&SECTYPE' NE 'DSECT').NODSECT\n&NFS     DSECT                          ENTR -- 09/27/79 -- LDW\n         AGO   .SECDONE\n.NODSECT AIF   ('&SECTYPE' EQ 'NONE').SECNONE\n         AIF   ('&SECTYPE' EQ 'ENTRY').ENTRY\n       MNOTE 8,'*** SECTYPE=&SECTYPE IS INVALID, SECTYPE=CSECT ASSUMED'\n         AGO   .DOCSECT\n.ENTRY   ENTRY &NFS\n.SECNONE ANOP\n*        DEFINE NAME.\n&NFS     DC    0D'0'                    ENTR -- 09/27/79 -- LDW\n.SECDONE AIF   ('&REGS(1)' EQ '' AND '&REGS(2)' NE '').DOREGS\n         AIF   ('&REGS(1)' EQ 'NO').NOREGS\n         AIF   ('&REGS(2)' NE '').DOREGS\n&Q       SETC  'R'\n         AGO   .CONT1\n.DOREGS  ANOP\n&Q       SETC  '&REGS(2)'\n.CONT1   ANOP                           WAS SPACE 1\n&L       SETA  K'&Q\n***********************************************************************\n*        REGISTER EQUATES.                                            *\n         REGEQU  PREFIX=&Q,FR=&F\n         SPACE 1\n.NOREGS  ANOP\n&R0      SETC  '&Q'.'0'\n&R1      SETC  '&Q'.'1'\n&R2      SETC  '&Q'.'2'\n&R3      SETC  '&Q'.'3'\n&R12     SETC  '&Q'.'12'\n&R13     SETC  '&Q'.'13'\n&R14     SETC  '&Q'.'14'\n&R15     SETC  '&Q'.'15'\n&L       SETA  K'&REGS(2)\n         AIF   (&ENVCP AND '&PL' NE '').NOGM2   WILL BE GENERATED LATER\n         AIF   ('&GET2' EQ '').NOGM2\n&GET2    DSECT\n         DS    18F                      SAVE AREA\n         AIF   ('&TSFAKE' NE 'YES' OR &ENVCP).NOFKY1\n&T$FAKE  DS    A,2H,CL100               AREA FOR FAKE PARM FIELD\n.NOFKY1  AIF   (NOT &ENVCP).NO$CPPL\n         AIF   ('&PL' EQ '').NOTSECB\nTSECB    DS    F\n.NOTSECB SPACE 1\n         TSCPPL\n.NO$CPPL AIF   ('&LOAD' EQ '').NOLOAD1\n&X       SETA  0\n.LOADLP1 ANOP\n&X       SETA  &X+1\n&LOAD(&X) DS   A\n         AIF   (&X LT N'&LOAD).LOADLP1\n.NOLOAD1 SPACE 2\n&NFS     CSECT                          RESUME\n.NOGM2   AIF   ('&REGS(1)' EQ 'NO').REGBASE\n         AIF   ('&BASE'(1,&L) EQ '&REGS(2)').REGBASE\n&BA$E    SETC  '&Q&BASE'\n         AGO   .CONT2\n.REGBASE ANOP\n&BA$E    SETC  '&BASE'\n.CONT2   USING *,&R15                   TEMPORARY BASE\n         B     &IHBNX.B                 AROUND GORF\n         DROP  &R15                     DROP TEMP BASE\n         OACUSING &NFS,&BA$E\n         AIF   ('&ID(1)' EQ '*').IDSTAR\n         AIF   ('&ID(1)' EQ '' ).IDSTAR\n         AIF   ('&ID' EQ '*NONE*').DONEID\n         ID    &ID(1),&ID(2),DATE=&DATE,TIME=&TIME\n         AGO   .DONEID\n.IDSTAR  ID    &NFS,&ID(2),DATE=&DATE,TIME=&TIME\n.DONEID  AIF   ('&BASE2' EQ '').NOBASE2\n&IHBNX.A DC    A(&NFS+4096)             SECOND BASE REGISTER\n         AIF   ('&BASE3' EQ '').NOBASE2\n&IHBNX.Z DC    A(&NFS+8192)             LET'S NOT GET CARRIED AWAY...\n         AIF   ('&BASE4' EQ '').NOBASE2\n&IHBNX.Q DC    A(&NFS+12288)            BUT THIS IS GETTING REDICULOUS\n.NOBASE2 AIF   (('&$AVE' NE '*') OR ('&GET1' NE '')).NOSVSTR NO INL SA\n&IHBNX.S DC    18F'0'                   SAVE AREA\n&$AVE    SETC  '&IHBNX.S'\n.NOSVSTR AIF   ('&TSFAKE' NE 'YES' OR &ENVCP OR '&GET2' NE '').NOFKY2\n&T$FAKE  DC    A(0),2H'0',CL100' '      AREA FOR FAKE PARM FIELD\n.NOFKY2  AIF   ('&GET1&GET2' EQ '').NOSPLEN  NO SP & LENGTH\n         AIF   ('&BASE2' NE '').BASE2L\n         DC    0A(0)                    ALIGNMENT\n.BASE2L  ANOP                           DON'T NEED ALIGNMENT\n&IHBNX.L DC    AL1(&SP),AL3(&GET1)      GETMAIN SP AND LENGTH\n.NOSPLEN AIF   ('&EXIT' EQ '').NOEXIT\n         SPACE 1\n*=====================================================================*\n&RCRC    SETC  '&RC(1)'\n         AIF   ('&RC' NE '').OKRC1\n&RCRC    SETC  '&R15'\n.OKRC1   AIF   ('&RCLOC' EQ '').OKRC3\n         AIF   ('&RC'    EQ '').OKRC2\n         MNOTE 0,'*** RC= AND RCLOC= MUTUALLY EXCLUSIVE -- RC= IGNORED'\n.OKRC2   ANOP\n&RCRC    SETC  '&RCLOC'\n.OKRC3   ANOP\n&X       SETA  8-K'&RCRC                NUMBER OF BLANKS NEEDED\n         AIF   (&X GT 0).OKRCL\n&BLANK1  SETC  ''\n         AGO   .CHAR8RC\n.OKRCL   ANOP\n&BLANK1  SETC  '&BLANK1'(1,&X)\n.CHAR8RC ANOP\n&X       SETA  8-K'&EXIT(1)             NUMBER OF BLANKS NEEDED\n         AIF   (&X GT 0).OKEXITL\n&BLANK2  SETC  ''\n         AGO   .CHAR8EX\n.OKEXITL ANOP\n&BLANK2  SETC  '&BLANK2'(1,&X)\n.CHAR8EX AIF   ('&RC' EQ '').MREGRC\n         AIF   ('&RC'(1,1) EQ '(').MREGRC\n         MNOTE *,'-- BRANCH TO \"&EXIT\" TO EXIT WITH RETURN CODE=&RCRC  X\n                 &BLANK1   &BLANK2    *'\n         AGO   .MRCCONT\n.MREGRC  MNOTE *,'   BRANCH TO \"&EXIT\" TO EXIT WITH RETURN CODE IN &RCR$\n               C &BLANK1   &BLANK2    *'\n.MRCCONT ANOP\n*=====================================================================*\n&NAME    SETC  '&EXIT'\n         AIF   ('&RCRC' NE '0').RCNOT0\n&NAME    XR    &R15,&R15                SET RETURN CODE ZERO\n&NAME    SETC  ''\n         AGO   .HAVERC\n.RCNOT0  AIF   ('&RCLOC' EQ '').NORCLOC RCLOC NOT GIVEN\n         AIF   ('&GET2' EQ '').NORCUSE\n         USING &GET2,&R13               IN CASE RCLOC IS IN DSECT\n.NORCUSE AIF   (T'&RCLOC EQ 'F').RCLOCF\n         AIF   (T'&RCLOC EQ 'H').RCLOCH\n         MNOTE 0,'*** UNKNOWN TYPE FOR RCLOC=&RCLOC -- \"F\" ASSUMED'\n.RCLOCF  ANOP\n&NAME    L     &R15,&RCLOC              LOAD RETURN CODE\n         AGO   .RCCOM1                  GO TO COMMON\n.RCLOCH  ANOP\n&NAME    LH    &R15,&RCLOC              LOAD RETURN CODE\n.RCCOM1  AIF   ('&GET2' EQ '').RCCOM2\n         DROP  &R13                     IN CASE RCLOC IS IN DSECT\n         AGO   .RCCOM2                  GO TO COMMON\n.NORCLOC AIF   ('&RC' EQ '').HAVERC     RC IS IN A REG\n         AIF   ('&RC'(1,1) EQ '(').HAVERC    DITTO\n&NAME    LA    &R15,&RCRC               LOAD RETURN CODE\n.RCCOM2  ANOP                           COMMON POINT\n&NAME    SETC  ''\n.HAVERC  AIF   ('&GET1' EQ '').NOWORK1  NO DSA TO FREE\n&NAME    LR    &R1,&R13                 COPY DSA PTR\n&NAME    SETC  ''\n.NOWORK1 ANOP\n&NAME    L     &R13,4(,&R13)            DECHAIN SAVE AREAS\n&NAME    SETC  ''\n         AIF   ('&RC' EQ '').WORKE\n         AIF   ('&RC'(1,1) NE '(').NOWORKE\n.WORKE   AIF   ('&RCLOC' NE '').NOWORKE STORE R15\n         AIF   ('&GET1' EQ '').RCNOT1   RC=(1) IS OK IF NO DYNAMIC AREA\n         AIF   (('&RCRC' NE '&R1') AND ('&RCRC' NE '1')).RCNOT1\n         MNOTE 4,'YOU TURKEY. RC=(R1) DOESN''T WORK RIGHT IF YOU HAVE AX\n                DYNAMIC AREA'\n         MNOTE 0,'... I HOPE YOU INSTALLED ZAP...'\n.RCNOT1  ST    &RCRC,16(,&R13)          SET RETURN CODE\n         AGO   .WASRGRC\n.NOWORKE ST    &R15,16(,&R13)           SET RETURN CODE\n.WASRGRC AIF   ('&GET1' EQ '').NOWRKE2  NO DSA TO FREE\n         L     &R0,&IHBNX.L             PICK UP SP AND LENGTH\n*        FREEMAIN  R,A=(1),LV=(0)       FREE THE DSA\n         FREEMAIN  R,A=(1),LV=(0)\n.NOWRKE2 LM    &R14,&R12,12(&R13)       RESTORE CALLERS REGS\n         AIF   ('&T' NE 'T').BR14\n         MVI   12(&R13),X'FF'           FLAG SAVEAREA AS INACTIVE\n.BR14    BR    &R14                     RETURN TO CALLER\n.NOEXIT  SPACE 1\n*=====================================================================*\n*    ENTRY CODE                                                       *\n*=====================================================================*\n&IHBNX.B STM   &R14,&R12,12(&R13)       SAVE CALLER'S REGS\n         LR    &BA$E,&R15               LOAD BASE REGISTER\n         AIF   ('&BASE2' EQ '').BASEFIN\n         L     &BASE2,&IHBNX.A          LOAD SECOND BASE REGISTER\n         OACUSING &NFS+4096,&BASE2\n         AIF   ('&BASE3' EQ '').BASEFIN\n         L     &BASE3,&IHBNX.Z          LOAD BASE3 FOR MLE,BMD,VIC\n         OACUSING &NFS+8192,&BASE3\n         AIF   ('&BASE4' EQ '').BASEFIN\n         L     &BASE4,&IHBNX.Q          WHAT'S GOING ON HERE???\n         OACUSING &NFS+12288,&BASE4\n.BASEFIN AIF   (N'&USING LT 1).NOUSING\n&X       SETA  1\n.USINGLP OACUSING &USING(&X),&USING(&X+1)\n&X       SETA  &X+2\n         AIF   (&X LT N'&USING).USINGLP\n.NOUSING ANOP\n&AR      SETC  '&R14'                   SET DEFAULT FOR LENREG=\n&LR      SETC  '&R15'                   SET DEFAULT FOR ADDRREG=\n         AIF   (('&ADDRREG' EQ '') AND ('&LENREG' EQ '')).NO$AR\n         AIF   (('&ADDRREG' NE '') AND ('&LENREG' NE '')).ARLR\n         MNOTE 8,'ADDRREG= AND LENREG= MUST BOTH BE GIVEN'\n.ARLR    ANOP\n&AR      SETC  '&ADDRREG'\n&LR      SETC  '&LENREG'\n.NO$AR   AIF   ('&PARMREG' EQ '').NOPARMR\n         LR    &PARMREG,&R1             SAVE PARM POINTER\n.NOPARMR AIF   ('&LPARM' EQ '').NOLPARM\n&NAME    L     &LPARM,0(,&R1)           PICK UP PARM POINTER\n&NAME    SETC  ''\n         AIF   (&ENVTSO).NOLPARM\n         AIF   ('&ADDRREG' EQ '').NOLPARM\n         LH    &LR,0(,&LPARM)           GET PARM LENGTH\n         LA    &AR,2(,&LPARM)           POINT PAST LENGTH\n.NOLPARM AIF   ('&GET1' EQ '').STATIC\n&NAME    L     &R0,&IHBNX.L             PICK UP SP AND LENGTH\n&NAME    SETC  ''\n*        GETMAIN  R,LV=(0)              GET A WORKAREA (DSA)\n         GETMAIN  R,LV=(0)\n.USE1    ST    &R1,8(,&R13)             FORW CHAIN SAVE AREAS\n         ST    &R13,4(,&R1)             BACK CHAIN SAVE AREAS\n         LR    &R13,&R1                 GET NEW SAVE AREA ADDR\n         AIF   ('&GET2' EQ '').CONT3\n         OACUSING &GET2,&R13\n         AGO   .CONT3\n.STATIC  AIF   ('&PARMREG' NE '&R15').NOT15\n&NAME    LA    &R1,&$AVE                GET SAVE AREA ADDR\n&NAME    SETC  ''\n         AGO   .USE1\n.NOT15   LA    &R15,&$AVE               GET SAVE AREA ADDR\n         ST    &R15,8(,&R13)            FORW CHAIN SAVE AREAS\n         ST    &R13,4(,&R15)            BACK CHAIN SAVE AREAS\n         LR    &R13,&R15                GET NEW SAVE AREA ADDR\n.CONT3   AIF   ('&RCLOC' EQ '').CONT3B\n         XC    &RCLOC,&RCLOC            INIT RCLOC TO ZERO\n.CONT3B  SPACE 1\n         AIF   (NOT &ENVCP).NMVCPPL\n         MVC   CPPL(CPPLL),0(&PARMREG)  COPY CPPL TO SAFE PLACE\n.NMVCPPL AIF   (&FKCALL OR &FKCP).FAKE$A\n         AIF   ('&ADDRREG' EQ '').LOAD\n         AIF   (&ENVTSO).FAKE$A\n         L     &AR,0(,&PARMREG)         POINT TO PARM (LENGTH)\n         LH    &LR,0(,&AR)              GET PARM LENGTH\n         LA    &AR,2(,&AR)              POINT PAST LENGTH\n         AGO   .INUSE\n.FAKE$A  SPACE 2\n*        DETERMINE WHETHER WE HAVE BEEN CALLED\n*        AS A TSO CP OR THRU CALL.\n         SPACE 1\n         L     &R1,CVTPTR               CVTPTR\n         USING CVT,&R1\n         L     &R1,CVTTCBP              TCBWORDS\n         DROP  R1\n         L     &R1,4(,&R1)              TCB\n         USING TCB,R1\n*%%      TM    TCBTSFLG,TCBTSTSK        IS THIS TSO?                %%%\n*%%      BNO   &IHBNX.C                 NO, SKIP                    %%%\n         L     &R1,TCBJSCB              TCB.JSCB\n         DROP  R1\n         USING IEZJSCB,R1\n         L     &R1,JSCBPSCB             JSCB.PSCB\n         DROP  R1\n         LA    &R0,0(,&R1)              CLEAR HIGH BYTE\n         L     &R1,8(,&PARMREG)         POSSIBLE PSCB PTR\n         LA    &R1,0(,&R1)              CLEAR HIGH BYTE\n         TM    0(&PARMREG),X'80'        ONLY 1 PARM?\n         BO    &IHBNX.E                 YES, // EXEC OR TSO CALL\n         CR    &R0,&R1                  THIRD PARM -> PSCB?\n         AIF   (('&ADDRREG' NE '') OR (&FKCALL)).SETCPR\n         BE    &IHBNX.C                 YES, WERE CALLED AS A TSO CP\n         AGO   .CONT5                   SKIP AROUND\n.SETCPR  BNE   &IHBNX.E                 NO, NOT TSO CP\n         SPACE 1\n*        HAVE BEEN CALLED AS A CP.\n         SPACE 1\n         AIF   ('&ADDRREG' EQ '').NO$AR2\n         L     &R1,0(,&PARMREG)         CBUF PTR\n         LH    &LR,0(,&R1)              LENGTH OF CBUF\n         LH    &AR,2(,&R1)              OFFSET TO FIRST NON-BLANK\n         LA    &LR,0(&LR,&R1)           POINT PAST CBUF\n         LA    &AR,4(&AR,&R1)           POINT TO FIRST NON-BLANK\n         SR    &LR,&AR                  LENGTH OF PARMS\n.NO$AR2  AIF   (&FKCALL).CONT4\n         B     &IHBNX.C                 CONTINUE\n         AGO   .CONT5\n.CONT4   AIF   (NOT &FKCALL).NOFAKE1\n         STH   &LR,&T$FAKE+4            SET FAKED LENGTH OF PARM\n         LTR   &R1,&LR                  COPY LENGTH\n         AIF   ('&TSFAKE(2)' EQ '').NOMXCK1\n         CH    &R1,&TSFAKE(2)           PARM TOO BIG?\n         BNH   *+L'*+4                  NO, OK\n         LH    &R1,&TSFAKE(2)           TOO BIG, USE MAX\n         LTR   &R15,&R15                TEST PARM LENGTH\n.NOMXCK1 BNP   *+L'*+12                 SKIP IF NO PARM       >=====+\n         BCTR  &R1,0                    -1 FOR EXECUTE              |\n         EX    &R1,*+L'*                MOVE THE PARM TO WORKAREA   |\n         MVC   &T$FAKE+6(*-*),0(&AR)    << EXECUTED >>              |\n         LA    &R1,&T$FAKE+4            GET FAKE PARM ADDR    <=====+\n         ST    &R1,&T$FAKE              STORE IT\n         LA    &PARMREG,&T$FAKE         GET ADDR OF FAKED PARM\n         MVI   &T$FAKE,X'80'            SET END OF LIST BIT\n         B     &IHBNX.C                 CONTINUE\n         AGO   .CONT5\n.NOFAKE1 AIF   (NOT &FKCP).LOAD\n.CONT5   SPACE 2\n*        HAVE BEEN CALLED FROM BATCH, OR TSO CALL.\n         SPACE 1\n&IHBNX.E L     &AR,0(,&PARMREG)         POINT TO PARM LENGTH\n         LH    &LR,0(,&AR)              GET LENGTH OF PARM\n         LA    &AR,2(,&AR)              POINT PAST LENGTH\n         AIF   (NOT &FKCP).NOFAKE2\n*   CPPL=ADDR(CBUF,UPT,PSCB,ECT)\n         LA    &R1,&T$FAKE              GET ADDR OF FAKE CBUF\n         ST    &R1,CPPLCBUF             SET INTO CPPL                +0\n         LR    &R1,&R0                  COPY PSCB ADDR\n         ST    &R0,CPPLPSCB             SET INTO FAKE CPPL           +8\n         MVC   CPPLUPT(4),52(&R1)       MOVE UPT ADDR INTO CPPL      +4\n         L     &R1,48(,&R1)             PSCB.RLGB\n         L     &R1,256(,&R1)            RLGB.ECT\n         ST    &R1,CPPLECT              SET IN CPPL                 +12\n         SPACE 1\n*   CBUF=Y(CBUF_LEN,OFFSET_TO_NONBLANK),C'CMDNAME',C' ',C'OPERANDS'\n         MVC   &T$FAKE+4(8),12(&R1)     MOVE CMD NAME TO CBUF\n         MVI   &T$FAKE+4+8,C' '         PUT IN DELIMETER\n         NI    28(&R1),X'7F'            TURN OFF \"NO OPERANDS\" BIT\n         LTR   &LR,&LR                  ANY OPERANDS?\n         BP    *+L'*+4                  YES, SKIP\n         OI    28(&R1),X'80'            SET \"NO OPERANDS\" BIT IN ECT\n         LA    &R1,8+1                  OFFSET TO FIRST NON-BLANK\n         STH   &R1,&T$FAKE+2            SET IN FAKE CBUF\n         LA    &R0,8+1+4(,&LR)          GET LENGTH OF CBUF\n         STH   &R0,&T$FAKE              SET INTO FAKE CBUF\n         AIF   ('&TSFAKE(2)' NE '').MAXCK\n         LTR   &R1,&LR                  ANY OPERANDS?\n         AGO   .NOMXCK2                 CONTINUE\n.MAXCK   LR    &R1,&LR                  COPY PARM LENGTH\n         CH    &R1,&TSFAKE(2)           PARM TOO BIG?\n         BNH   *+L'*+4                  NO, OK\n         LH    &R1,&TSFAKE(2)           TOO BIG, USE MAX\n         LTR   &LR,&LR                  ANY OPERANDS?\n.NOMXCK2 BNP   *+L'*+12                 NO, SKIP              >=====+\n         BCTR  &R1,0                    -1 FOR EXECUTE              |\n         MVC   &T$FAKE+4+8+1(0),0(&AR)  << EXECUTED >>              |\n         EX    &R1,*-6                  MOVE THE PARM TO FAKE CBUF  |\n         LA    &PARMREG,CPPL            POINT TO CPPL         <=====+\n.NOFAKE2 SPACE 2\n&NAME    SETC  '&IHBNX.C'\n.LOAD    AIF   ('&LOAD' EQ '').NOLOAD\n&X       SETA  1\n.LOAD$LP AIF   ('&LOAD(&X)' EQ '').NOLOAD\n         AIF   (NOT &ENVMVS).YESLOAD\n&NAME    ENTR1I  &LOAD(&X),IKJPTGT,464\n&NAME    ENTR1I  &LOAD(&X),IKJPUTL,444\n&NAME    ENTR1I  &LOAD(&X),IKJGETL,348\n&NAME    ENTR1I  &LOAD(&X),IKJPARS,524\n&NAME    ENTR1I  &LOAD(&X),IKJDAIR,732\n&NAME    ENTR1I  &LOAD(&X),IKJSTCK,472\n&NAME    ENTR1I  &LOAD(&X),IKJSCAN,480\n&NAME    ENTR1I  &LOAD(&X),IKJEHCIR,740\n&NAME    ENTR1I  &LOAD(&X),IKJEHDEF,736\n&NAME    ENTR1I  &LOAD(&X),IKJEFF02,976                            SDM\n         AIF   (NOT &MVSCVT).YESLOAD    IT WAS NOT ONE OF THE ABOVE\n&NAME    SETC  ''\n.YESLOAD MNOTE *,'       LOAD  EPLOC==CL8''&LOAD(&X)'''\n&NAME    LOAD  EPLOC==CL8'&LOAD(&X)'\n&NAME    SETC  ''\n.ADDRSAV ST    &R0,&LOAD(&X)\n.SKIPASV SPACE 1\n         AIF   ('&LOAD(&X)' NE 'IKJDAIR').NO$DAIR\n&GDAIR   SETB  1                        DAIR LOADED\n         AGO   .LOADNXT\n.NO$DAIR AIF   ('&LOAD(&X)' NE 'IKJPARS').NO$PARS\n&GPARSE  SETB  1                        PARSE WAS LOADED\n&PARNAME SETC  'IKJPARS'\n.NO$PARS ANOP\n.LOADNXT ANOP\n&X       SETA  &X+1\n         AGO   .LOAD$LP\n.NOLOAD  AIF   ('&PL' EQ '').NO$PL$1\n&X       SETA  1\n.PLLOOP  AIF   ('&PL(&X)' NE 'CSCAN').PL2\n&CSPL    SETB  1\n         AGO   .PLNEXT\n.PL2     AIF   ('&PL(&X)' NE 'PARSE').PL3\n&PARS    SETB  1\n         AGO   .PLNEXT\n.PL3     AIF   ('&PL(&X)' NE 'DAIR').PL4\n&DAIR    SETB  1\n         AGO   .PLNEXT\n.PL4     AIF   ('&PL(&X)' NE 'IO').PL5\n&IO      SETB  1\n         AGO   .PLNEXT\n.PL5     AIF   ('&PL(&X)' NE 'MESSAGE').PL6\n&MSG     SETB  1\n         AGO   .PLNEXT\n.PL6     MNOTE 4,'PL=&PL(&X) UNKNOWN -- IGNORED'\n.PLNEXT  ANOP\n&X       SETA  &X+1\n         AIF   (&X LE N'&PL).PLLOOP\n.NO$PL$1 AIF   ('&PARSE(2)' EQ '').PLNOTM\n&MSG     SETB  1\n.PLNOTM  AIF   (NOT (&CSPL OR &PARS OR &DAIR OR &IO OR &MSG)).NOSETPL\n&NAME    L     &R1,CPPLUPT              GET UPT PTR\n&NAME    SETC  ''\n         L     &R2,CPPLECT              GET ECT PTR\n         LA    &R3,TSECB                GET ECB PTR\n         SR    &R0,&R0                  GET A 0\n         ST    &R0,TSECB                CLEAR ECB\n         AIF   (NOT &CSPL).NOSETC\n         STM   &R1,&R3,CSPL             INITIALIZE CSPL (UPT, ECT, ECB)\n         ST    &R0,CSFLG                ZERO CSFLG\n         LA    &R0,CSFLG\n         ST    &R0,CSPLFLG\n         LA    &R0,CSOA\n         ST    &R0,CSPLOA\n.NOSETC  AIF   (NOT &PARS).NOSETP\n         STM   &R1,&R3,PPL              INITIALIZE PPL (UPT, ECT, ECB)\n         LA    &R0,TSPARANS             PTR TO PARSE ANSWER PLACE\n         ST    &R0,PPLANS\n         ST    &R13,PPLUWA              PARSE USER WORK AREA PTR\n         XC    TSPARANS(4),TSPARANS     AVOID DUPLICATE IKJRLSA\n.NOSETP  AIF   (NOT &DAIR).NOSETD\n         STM   &R1,&R3,DAPL             INITIALIZE DMPL (UPT, ECT, ECB)\n         MVC   DAPLPSCB(4),CPPLPSCB\n.NOSETD  AIF   (NOT &IO).NOSETI\n         STM   &R1,&R3,IOPL             INITIALIZE IOPL (UPT, ECT, ECB)\n.NOSETI  AIF   (NOT &MSG).NOSETM\n         ST    &R3,MPLECB               INIT MPL ECB PTR\n         LA    &R0,CPPL\n         ST    &R0,MPLCPPL\n         LA    &R0,MPLCSECT             PTR TO MSG CSECT\n         ST    &R0,MPLCSECP\n         XC    MPLSW(MPLZL),MPLSW       INITIALIZE REMAINING MPL TO 0\n.NOSETM  ANOP\n.NOSETPL AIF   ('&PARSE(1)' EQ '').NOPARSE\n         SPACE 1\n*        PARSE THE COMMAND LINE.\n         SPACE 1\n         MNOTE *,'       TSPARSE CBUF=(CPPLCBUF,I),PCL=(=V(&PARSE(1)),I$\n               ),'\n         MNOTE *,'               SYNAD=&PARSE(2),ENTRY=&PARNAME'\n         TSPARSE  CBUF=(CPPLCBUF,I),PCL=(=V(&PARSE(1)),I),             X\n               SYNAD=&PARSE(2),ENTRY=&PARNAME\n&NAME    SETC  ''\n         AIF   ('&PARSE(2)' EQ '').NOPARSE   NO ERROR ANALYSIS ROUTINE\n&NAME    SETC  '&IHBNX.P'\n         B     &NAME                    SKIP AROUND PARSE ERR ANALYSIS\n         SPACE 1\n*        PARSE ERROR ANALYSIS SUBROUTINE.\n         SPACE 1\n         TSPARERR\n         SPACE 1\n.NOPARSE AIF   ('&NAME' EQ '').NONAME\n&NAME    DS    0H\n.NONAME  ANOP\n.INUSE   OACINUSE\n         SPACE 1\n         AIF   ('&PL' EQ '').MEND\n         AIF   ('&GET2' NE '').PLOK2\n         MNOTE 8,'*** PL= INVALID WITHOUT SECOND OPERAND OF GETMAIN='\n         MEXIT\n.PLOK2   EJECT\n&GET2    DSECT\n         DS    18F                      SAVE AREA\nTSECB    DS    F                        ECB FOR TSO SERVICES\n         SPACE 1\n         TSCPPL\n         AIF   ('&TSFAKE' NE 'YES').NOFAKED\n         SPACE 1\n&T$FAKE  DS    2H,CL256                 AREA FOR FAKE CBUF\n         AIF   ('&PRINT' NE 'NOGEN').NOFAKED\n         PRINT NOGEN                    SUPPRESS THE DSECTS\n.NOFAKED AIF   (NOT &CSPL).NOTCSPL\n         SPACE 1\n         TSCSPL\n.NOTCSPL AIF   (NOT &PARS).NOTPARS\n         SPACE 1\n         TSPPL\n.NOTPARS AIF   (NOT &DAIR).NOTDAIR\n         SPACE 1\n         TSDAPL\nDAPBAREA DS    22F                      AREA FOR DAIR PARAMETER BLOCK\n         SPACE 1\n         TSDMPL\n.NOTDAIR AIF   (NOT &IO).NOTIO\n         SPACE 1\n         TSIOPL\n.NOTIO   AIF   (NOT &MSG).NOTMSG\n         SPACE 1\n         TSMPL\n.NOTMSG  AIF   ('&PRINT' NE 'NOGEN').NOTMSGX\n         PRINT GEN\n.NOTMSGX AIF   ('&LOAD' EQ '').NOLOAD2\n         SPACE 1\n&X       SETA  1\n.NXTLOAD AIF   (&X GT N'&LOAD).NOLOAD2\n&LOAD(&X) DS   A\n&X       SETA  &X+1\n         AGO   .NXTLOAD\n.NOLOAD2 AIF   ('&MACRO' NE 'YES').NOMACRO\n         SPACE 1\n*        DYNAMIC STORAGE DEFINED BY USER TSWORK MACRO.\n         SPACE 1\n         TSWORK\n         SPACE 1\n&GET1    EQU   (((*-&GET2)+7)/8)*8      LNTH OF DYNAMIC AREA TO GETMAIN\n         SPACE 1\n.NOMACRO AIF   (NOT &DAIR).NODAPBS\n         AIF   (&GDAIRM).NODAPBS\n&GDAIRM  SETB  1\n         AIF   ('&PRINT' NE 'NOGEN').GEN4\n         PRINT NOGEN                    SAVE SOME PAPER\n.GEN4    EJECT\n         IKJDAP08\nDAPB08L  EQU   *-DAPB08\n         SPACE 2\n         IKJDAP18\nDAPB18L  EQU   *-DAPB18\n         SPACE 2\n         IKJDAP1C\nDAPB1CL  EQU   *-DAPB1C\n         SPACE 2\n         IKJDAP30\nDAPB30L  EQU   *-DAPB30\n         AIF   ('&PRINT' NE 'NOGEN').NODAPBS\n         PRINT GEN                      RESTORE\n         SPACE 1\n.NODAPBS ANOP\n&NFS     CSECT\n         SPACE 1\n.MEND    MEND\n         MACRO\n&NFS     HEX   &TO,&FROM,&L,&LEN=,&HEXTAB=,&BYTE=C' ',&DIGITS=\n         GBLC  &HEXTAB#\n         LCLA  &LT                      UNPK \"TO\" LENGTH\n         LCLA  &LF                      UNPK \"FROM\" LENGTH\n         LCLA  &LTR                     TR \"TO\" LENGTH\n         LCLA  &LL                      &LEN ONE WAY OR ANOTHER\n         LCLC  &F1,&F2,&T1,&T2,&LX\n&F1      SETC  '&FROM(1)'               FOR SHORTER STRING LATER\n&F2      SETC  '&FROM(2)'               FOR SHORTER STRING LATER\n&T1      SETC  '&TO(1)'                 FOR SHORTER STRING LATER\n&T2      SETC  '&TO(2)'                 FOR SHORTER STRING LATER\n&LX      SETC  '&L&LEN'                 GET LENGTH USING EITHER METHOD\n         AIF   ('&LX' EQ '').DEFLEN     LENGTH WILL DEFAULT TO 4\n&LL      SETA  &LX                      GET IT\n         AGO   .OKLEN\n.DEFLEN  ANOP\n&LL      SETA  4                        SET THE DEFAULT LENGTH\n.OKLEN   AIF   ('&HEXTAB' EQ '').OKHEX1\n&HEXTAB# SETC  '&HEXTAB'\n.OKHEX1  AIF   ('&HEXTAB#' NE '').OKHEX2\n&HEXTAB# SETC  'HEXTAB'\n.OKHEX2  ANOP\n&LT      SETA  &LL*2\n         AIF   ('&DIGITS' EQ '').OKDIGIT\n&LT      SETA  &DIGITS\n.OKDIGIT AIF   (N'&TO NE 2).TO1\n         AIF   (N'&FROM NE 2).T2F1\n&NFS     UNPK  &T1.(&LT+1,&T2),&F1.(&LL+1,&F2)\n         TR    &T1.(&LT,&T2),&HEXTAB#\n         MVI   &T1+&LT.(&T2),&BYTE\n         AGO   .DONE\n.T2F1    AIF   (N'&FROM NE 1).ERRF\n&NFS     UNPK  &T1.(&LT+1,&T2),&FROM.(&LL+1)\n         TR    &T1.(&LT,&T2),&HEXTAB#\n         MVI   &T1+&LT.(&T2),&BYTE\n         AGO   .DONE\n.TO1     AIF   (N'&TO NE 1).ERRT\n         AIF   (N'&FROM NE 2).T1F1\n&NFS     UNPK  &TO.(&LT+1),&F1.(&LL+1,&F2)\n         TR    &TO.(&LT),&HEXTAB#\n         MVI   &TO+&LT,&BYTE\n         AGO   .DONE\n.T1F1    AIF   (N'&FROM NE 1).ERRF\n&NFS     UNPK  &TO.(&LT+1),&FROM.(&LL+1)\n         TR    &TO.(&LT),&HEXTAB#\n         MVI   &TO+&LT,&BYTE\n         AGO   .DONE\n.ERRF    MNOTE 8,'ERROR IN \"FROM\" PARAMETER, MACRO TERMINATED'\n         MEXIT\n.ERRT    MNOTE 8,'ERROR IN \"TO\" PARAMETER, MACRO TERMINATED'\n         MEXIT\n.DONE    SPACE 1\n         MEND\n         MACRO\n&NFS     ID    &ID,&OPT,&DATE=,&TIME=\n         GBLC  &$$DATE1\n         LCLC  &XDATE,&XTIME\n         LCLA  &L\n&L       SETA  K'&ID\n         AIF   ('&OPT' EQ 'ASIS').ASIS\n         AIF   ('&OPT' NE 'NODATE').DATE\n.ASIS    ANOP\n&NFS     DC    AL1(&L),C'&ID'\n         MEXIT\n.DATE    $$ASM\n&XDATE   SETC  '&$$DATE1'\n         AIF   ('&DATE' EQ '').OKDATE\n&XDATE   SETC  '&DATE'                  USE WHAT HE WANTS\n.OKDATE  ANOP\n&L       SETA  &L+K'&XDATE+2\n         AIF   ('&OPT' NE 'NOTIME').TIME\n&NFS     DC    AL1(&L),C'&ID  &XDATE'\n         MEXIT\n.TIME    ANOP\n&XTIME   SETC  '&SYSTIME'               DEFAULT TO CURRENT TIME\n         AIF   ('&TIME' EQ '').OKTIME   HE DIDN'T SPECIFY, USE CURRENT\n&XTIME   SETC  '&TIME'                  USE WHAT HE WANTS\n.OKTIME  ANOP\n&L       SETA &L+K'&XTIME+1             =1+8\n         AIF   ('&OPT' NE '').BADOPT\n&NFS     DC    AL1(&L),C'&ID  &XDATE &XTIME'\n         MEXIT\n.BADOPT  MNOTE 0,'*** (ID MACRO) OPT=&OPT IS INVALID, IGNORED.'\n         MNOTE *,'(MUST BE NULL, \"NOTIME\", \"NODATE\", OR \"ASIS\")'\n         MEND\n         MACRO\n         OACDROP &PARMS\n         GBLC  &USELAB(16)        SAVED PROGRAM LABELS\n         GBLC  &USEREG(16)        SAVED REGISTER TABLE\n         LCLA  &UNDX,&II          USE INDICES,TEMP USAGE\n         LCLA  &PNDX,&DNDX        INPUT PARM,DROP STRING INDICES\n         LCLB  &GOTREG,&DROPALL   HAVE REGS TO DROP,DROP ALL TO DO\n         LCLC  &R(4),&B(4)        REGS TO DROP,PREVIOUS BASES FOR REGS\n         LCLC  &BLANKS            BLANKS TO PAD DROP LINE TO COMMENTS\n&DROPALL SETB  ((N'&SYSLIST EQ 0) OR ('&PARMS' EQ '')) SET DROPALL FLAG\n.LP#SYS  AIF   (&DROPALL).LP#SAV  BIF DROP ALL IN PROGRESS\n         AIF   (&PNDX GE N'&SYSLIST).CK#DROP LOOP TIL DONE WITH REGS\n&PNDX    SETA  &PNDX+1            UP THE COMMA/REG INDEX\n&UNDX    SETA  0                  RE-INITIALIZE USE ARRAY INDEX\n.LP#SAV  ANOP                     VALID DROP REG CHECK LOOP\n&UNDX    SETA  &UNDX+1            UP THE USE ARRAY COUNT\n         AIF   (&DROPALL).CK#ALL  BIF DROP ALL IN PROGRESS\n         AIF   ('&USEREG(&UNDX)' EQ '&SYSLIST(&PNDX)').DROP#R BIF MATCH\n         AIF   (&UNDX LT 16).LP#SAV LOOP FOR ALL ENTRIES IF NEEDED\n         MNOTE 4,'REGISTER &SYSLIST(&PNDX) WAS NOT A USNGX OPERAND'\n         AGO   .LP#SYS            CONTINUE\n.CK#ALL  AIF   (&UNDX GT 16).CK#DROP BIF END OF SAVE TABLE/CHECK DROPS\n         AIF   ('&USEREG(&UNDX)'  EQ '').LP#SAV BIF EMPTY SLOT\n.DROP#R  AIF   (&DNDX EQ 0).DROP$R BIF NO PREVIOUS REGISTER/BASE\n&R(&DNDX) SETC '&R(&DNDX)'.','    APPEND COMMA AFTER PREVIOUS REG\n&B(&DNDX) SETC '&B(&DNDX)'.','    APPEND COMMA AFTER PREVIOUS BASE\n.DROP$R  ANOP\n&DNDX    SETA  &DNDX+1            UP THE DROP STRING INDEX\n&R(&DNDX) SETC '&USEREG(&UNDX)'   GET PREVIOUS REGISTER\n&B(&DNDX) SETC '&USELAB(&UNDX)'   GET PREVIOUS BASE\n&USEREG(&UNDX) SETC ''            BLANK THE SAVE TABLE REG FIELD\n&USELAB(&UNDX) SETC ''            BLANK THE SAVE TABLE BASE FIELD\n         AIF   (&DNDX GE 4).DO#DR BIF DROP LINE FULL\n&GOTREG  SETB  1                  SAY HAVE SOMETHING TO DROP\n         AGO   .LP#SYS            GO CHECK FOR &SYSLIST/TABLE END\n.CK#DROP AIF   (NOT &GOTREG).EXIT SKIP THE DROP IF NOTHING TO DO\n.* NOTE THAT THIS MACRO ASSUMES OPERAND/COMMENT COLUMNS 16 AND 35.\n.DO#DR   ANOP\n&BLANKS  SETC  ' '                SET ONE BLANK IN CASE TOO LONG\n&II      SETA  (35-16)-K'&R(1)-K'&R(2)-K'&R(3)-K'&R(4) BLANK COUNT\n         AIF   (&II LE 1).DO$DR   BIF ONE BLANK CORRECT\n&BLANKS  SETC  '                  '(1,&II) ELSE SET CORRECT NUMBER\n.DO$DR   DROP  &R(1)&R(2)&R(3)&R(4)&BLANKS&B(1)&B(2)&B(3)&B(4)\n&GOTREG  SETB  0                  NOTHING TO DROP\n.DROP#CL AIF   (&DNDX EQ 0).LP#SYS BIF CLEARING DONE\n&R(&DNDX) SETC ''                 BLANK REG FIELD\n&B(&DNDX) SETC ''                 BLANK BASE FIELD\n&DNDX    SETA  &DNDX-1            DECREMENT INDEX\n         AGO   .DROP#CL           CONTINUE\n.EXIT    MEND\n         MACRO\n&LABEL   OACINNER &DUMMY,&F=,&FO=+0,&T=,&TO=+0,&L=4,&OP=MA,            X\n               &SETCC=NO,&RS=R0,&RT=R15,&COM=''\n         GBLC  &OACNAME\n         LCLC  &S,&SRC,&SRC1,&SRCT\n         LCLB  &SRCI\n         LCLC  &G,&TGT,&TGT1,&TGTT\n         LCLB  &TGTI\n         LCLC  &C,&COMM,&ARGS,&OPR,&LEN\n         LCLA  &P\n         LCLB &CC\n         AIF   ('&F' EQ '').MEND\n&CC      SETB  ('&SETCC' EQ 'YES')\n&OACNAME SETC  '&LABEL'\n&LEN     SETC  '&L'\n&COMM    SETC  '&COM'(2,K'&COM-2) STRIP OFF QUOTES\n&G       SETC  '&T'\n.TGT     ANOP\n&C       SETC  '&G'(1,1)          GET FIRST CHAR OF SOURCE\n         AIF   ('&C' NE '(').TGTA MUST BE A FORM ADDRESS\n         AIF   (K'&G LT 5).TGTR   MUST BE R FORM ADDRESS\n&C       SETC  '&G'(K'&G-2,3)     GET LAST THREE CHARS\n         AIF   ('&C' NE ',I)').TGTR MUST BE R FORM ADDRESS\n&TGTI    SETB  1                  MARK AS INDIRECT\n&G       SETC  '&G'(2,K'&G-4)     EXTRACT ADDRESS\n         AGO   .TGT               GO PROCESS THAT\n.TGTR    ANOP                     ADDRESS IS R FORM\n         AIF   ('&TO' EQ '+0').TGTR1 CHECK FOR OFFSET\n         MNOTE 4,'ENCOUNTERED OFFSET FROM (R) FORM ADDRESS'\n         MNOTE 4,'WILL FORCE ADDRESS FORM'\n&G       SETC  '0&G'              FORCE ADDR FORM\n         AGO   .TGTA              IT IS ADDR FORM\n.TGTR1   AIF   (NOT &TGTI).TGTR2\n         MNOTE 4,'ENCOUNTERED INDIRECT FROM (R)'\n         MNOTE 4,'WILL FORCE INDIRECT FROM 0(R)'\n&G       SETC  '0&G'\n         AGO   .TGTA              DO ADDRESS SCAN\n.TGTR2   ANOP                     ITS REALLY (R) FORM\n&TGTT    SETC  'R'                MARK TYPE\n&TGT     SETC  '&G'(2,K'&G-2)     STRIP OFF PARENS\n         AGO   .TGTEND\n.TGTA    ANOP                     ADDRESS FORM\n&C       SETC  '&G'(K'&G,1)       LOOK AT LAST CHAR\n         AIF   ('&C' EQ ')').TGTAR IT IS A O(R) FORM ADDRESS\n&TGTT    SETC  'A'\n&TGT     SETC  '&G'\n         AIF   ('&TO' EQ '+0').TGTEND\n&TGT     SETC  '&G.&TO'\n         AGO   .TGTEND\n.TGTAR   ANOP                     ITS A 0(R) FORM ADDRESS\n&P       SETA  K'&G               SCAN FOR THE LEFT PAREN\n.TGTLP   AIF   (&P EQ 0).TGTSNTX\n&C       SETC  '&G'(&P,1)\n&P       SETA  &P-1\n         AIF   ('&C' NE '(').TGTLP\n&TGTT    SETC  'AR'\n&TGT1    SETC  '&G'(&P+2,K'&G-&P+1) SAVE REG AND RIGHT PAREN\n         AIF   ('&TO' NE '+0').TGTAR1\n&TGT     SETC  '&G'(1,&P+1)\n         AGO   .TGTEND\n.TGTAR1  ANOP  MUST ADD OFFSETS\n&TGT     SETC  '&G'(1,&P)\n&TGT     SETC  '&TGT.&TO.('\n         AGO   .TGTEND\n.TGTSNTX MNOTE 12,'ILLEGAL SYNTAX: &T'\n         MEXIT\n.TGTEND  ANOP\n&C       SETC  '&TGT  '(1,2)\n         AIF   ('&C' NE '0+').TGTEND1\n&TGT     SETC  '&TGT'(3,K'&TGT-2)\n.TGTEND1 ANOP\n&S       SETC  '&F'\n.SRC     ANOP\n&C       SETC  '&S'(1,1)          GET FIRST CHAR OF SOURCE\n         AIF   ('&C' NE '(').SRCA MUST BE A FORM ADDRESS\n         AIF   (K'&S LT 5).SRCR   MUST BE R FORM ADDRESS\n&C       SETC  '&S'(K'&S-2,3)     GET LAST THREE CHARS\n.* BREAK\n         AIF   ('&C' NE ',I)').SRCR MUST BE R FORM ADDRESS\n&SRCI    SETB  1                  MARK AS INDIRECT\n&S       SETC  '&S'(2,K'&S-4)     EXTRACT ADDRESS\n         AGO   .SRC               GO PROCESS THAT\n.SRCR    ANOP                     ADDRESS IS R FORM\n         AIF   ('&FO' EQ '+0').SRCR1 CHECK FOR OFFSET\n         MNOTE 4,'ENCOUNTERED OFFSET FROM (R) FORM ADDRESS'\n         MNOTE 4,'WILL FORCE ADDRESS FORM'\n&S       SETC  '0&S'              FORCE ADDR FORM\n         AGO   .SRCA              IT IS ADDR FORM\n.SRCR1   AIF   (NOT &SRCI).SRCR2\n         MNOTE 4,'ENCOUNTERED INDIRECT FROM (R)'\n         MNOTE 4,'WILL FORCE INDIRECT FROM 0(R)'\n&S       SETC  '0&S'\n         AGO   .SRCA              DO ADDRESS SCAN\n.SRCR2   ANOP                     ITS REALLY (R) FORM\n&SRCT    SETC  'R'                MARK TYPE\n&SRC     SETC  '&S'(2,K'&S-2)     STRIP OFF PARENS\n         AGO   .SRCEND\n.SRCA    ANOP                     ADDRESS FORM\n&C       SETC  '&S'(K'&S,1)       LOOK AT LAST CHAR\n         AIF   ('&C' EQ ')').SRCAR IT IS A O(R) FORM ADDRESS\n&SRCT    SETC  'A'\n&SRC     SETC  '&S'\n         AIF   ('&FO' EQ '+0').SRCEND\n&SRC     SETC  '&S.&FO'\n         AGO   .SRCEND\n.SRCAR   ANOP                     ITS A 0(R) FORM ADDRESS\n&P       SETA  K'&S               SCAN FOR THE LEFT PAREN\n.SRCLP   AIF   (&P EQ 0).SRCSNTX\n&C       SETC  '&S'(&P,1)\n&P       SETA  &P-1\n         AIF   ('&C' NE '(').SRCLP\n&SRCT    SETC  'A'\n&SRC1    SETC  '&S'(&P+2,K'&S-&P+1) SAVE REG AND RIGHT PAREN\n         AIF   ('&FO' NE '+0').SRCAR1\n&SRC     SETC  '&S'\n&SRC1    SETC  ''\n         AGO   .SRCEND\n.SRCAR1  ANOP  MUST ADD OFFSETS\n&SRC     SETC  '&S'(1,&P)\n&SRC     SETC  '&SRC.&FO.(&SRC1'\n&SRC1    SETC  ''\n         AGO   .SRCEND\n.SRCSNTX MNOTE 12,'ILLEGAL SYNTAX: &F'\n         MEXIT\n.SRCEND  ANOP\n&C       SETC  '&SRC  '(1,2)\n         AIF   ('&C' NE '0+').SRCEND1\n&SRC     SETC  '&SRC'(3,K'&SRC-2)\n.SRCEND1 AIF   (NOT &TGTI).SIN    CHECK FOR TARGET INDIRECT\n&ARGS    SETC  '&RT,&TGT.&TGT1'   BUILD OPERANDS AND COMMENT\n         AIF   (K'&ARGS GE 18).TI1\n&ARGS    SETC  '&ARGS                   '(1,18)\n.TI1     ANOP\n&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS\n         AIF   (K'&ARGS GT 55).TI2 CHECK FOR OVERFLOW\n&OACNAME L     &ARGS\n&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE\n         AGO   .TI3\n.TI2     ANOP                     NO ROOM FOR COMMENT\n&OACNAME L     &RT,&TGT.&TGT1\n.TI3     ANOP\n&OACNAME SETC  ''\n&TGT     SETC  '0('               NEW TARGET\n&TGT1    SETC  '&RT)'\n&TGTT    SETC  'AR'               NEW TARGET TYPE\n&TGTI    SETB  0\n.SIN     AIF   (NOT &SRCI).OP     CHECK FOR SOURCE INDARECT\n         AIF   ('&OP' EQ 'MA').SIMA SPECIAL CASE FOR MA, SRCI\n         AIF   ('&OP' NE 'MAC').SIN1 MAC MAY ALSO BE SPECIAL\n         AIF   ('&TGTT' EQ 'A' OR '&TGTT' EQ 'AR').SIMAC\n.SIN1    ANOP\n&ARGS    SETC  '&RS,&SRC'         BUILD OPERANDS AND COMMENT\n         AIF   (K'&ARGS GE 18).SIN2\n&ARGS    SETC  '&ARGS                   '(1,18)\n.SIN2    ANOP\n.* BREAK\n&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS\n         AIF   (K'&ARGS GT 55).SIN3 CHECK FOR OVERFLOW\n&OACNAME L     &ARGS\n&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE\n         AGO   .SIN4\n.SIN3    ANOP                     NO ROOM FOR COMMENT\n&OACNAME L     &RS,&SRC\n.SIN4    ANOP\n&OACNAME SETC  ''\n&SRC     SETC  '0(&RS)'           NEW SOURCE\n&SRCT    SETC  'A'                NEW SOURCE TYPE\n&SRCI    SETB  0\n         AGO   .OP\n.SIMA    ANOP\n&SRCI    SETB  0\n         AIF   ('&TGTT' EQ 'R').L GENERATE LOAD INSTRUCTION\n         AGO   .MVC               MA SRCI IS A MVC\n.SIMAC   ANOP                     MAC SRCI IS MVC AND MVI\n         AIF   ('&TGTT' EQ 'AR').SIMACAR\n&C       SETC  '&TGT.(4),&SRC'     A FORM TARGET\n         AGO   .SIMAC1\n.SIMACAR ANOP\n&C       SETC  '&TGT.4,&TGT1,&SRC' AR FROM TARGET\n.SIMAC1  ANOP\n&ARGS    SETC  '&C'               BUILD ARGS AND COMMENT\n         AIF   (K'&ARGS GE 18).SIMAC2\n&ARGS    SETC  '&ARGS                   '(1,18)\n.SIMAC2  ANOP\n&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS\n         AIF   (K'&ARGS GT 55).SIMAC3 CHECK FOR OVERFLOW\n&OACNAME MVC   &ARGS\n&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE\n         AGO   .SIMAC4\n.SIMAC3  ANOP                     NO ROOM FOR COMMENT\n&OACNAME MVC   &C\n.SIMAC4  ANOP\n&OACNAME SETC  ''\n         MVI   &TGT.&TGT1,0       CLEAR HIGH BYTE\n&SRC     SETC  '&TGT,&TGT1'\n         AIF   (&CC).OC\n         MEXIT\n.OP      ANOP\n&C       SETC  '&TGTT'(1,1)\n         AIF   ('&C' EQ 'R' AND '&SRCT' EQ 'R').OPRR   RR FORM INST\n         AIF   ('&C' EQ 'R' AND '&SRCT' EQ 'A').OPRA\n         AIF   ('&C' EQ 'A' AND '&SRCT' EQ 'R').OPAR\n         AIF   ('&OP' EQ 'MA').LAST AA FORM\n         AIF   ('&OP' EQ 'MAC').LAST LA ST\n         AIF   ('&OP' EQ 'M').MVC\n         AIF   ('&OP' EQ 'O').OC\n         AIF   ('&OP' EQ 'X').XC\n         AIF   ('&OP' EQ 'N').NC\n         AIF   ('&OP' EQ 'CL').CLC\n&LEN     SETC  '1'\n         AIF   ('&OP' EQ 'MVI').MVI\n         AIF   ('&OP' EQ 'OI').OI\n         AIF   ('&OP' EQ 'XI').XI\n         AIF   ('&OP' EQ 'NI').NI\n         AIF   ('&OP' EQ 'CLI').CLI\n         AIF   ('&OP' EQ 'TM').TM\n.BADOP   MNOTE 12,'&OP IS UNSUPORTED WITH SUPPLIED ARGS'\n         MEXIT\n.OPRR    AIF   ('&OP' EQ 'MA').LR\n         AIF   ('&OP' EQ 'MAC').LA\n         AIF   ('&LEN' EQ '4').OPRR1\n.RLENERR MNOTE 12,'INVALID LENGTH WITH R FORM ADDRESS'\n         MEXIT\n.OPRR1   AIF   ('&OP' EQ 'M').LR\n         AIF   ('&OP' EQ 'O').OR\n         AIF   ('&OP' EQ 'X').XR\n         AIF   ('&OP' EQ 'N').NR\n         AIF   ('&OP' EQ 'CL').CR\n         AGO   .BADOP\n.OPRA    AIF   ('&OP' EQ 'MA').LA\n         AIF   ('&OP' EQ 'MAC').LA\n         AIF   ('&OP' NE 'M').OPRA1\n         AIF   ('&LEN' EQ '1').IC\n.* BREAK\n         AIF   ('&LEN' EQ '2').LH\n         AIF   ('&LEN' EQ '4').L\n         AGO   .RLENERR\n.OPRA1   AIF   ('&LEN' EQ '4').OPRA4\n         AIF   ('&LEN' NE '2').RLENERR\n         AIF   ('&OP' EQ 'CL').CH\n         AGO   .BADOP\n.OPRA4   AIF   ('&OP' EQ 'O').O\n         AIF   ('&OP' EQ 'X').X\n         AIF   ('&OP' EQ 'N').N\n         AIF   ('&OP' EQ 'CL').C\n         AGO   .BADOP\n.OPAR    AIF   ('&OP' EQ 'MA').ST\n         AIF   ('&OP' EQ 'MAC').STMVI ST THEN MVI\n         AIF   ('&OP' NE 'M').BADOP\n         AIF   ('&LEN' EQ '1').STC\n         AIF   ('&LEN' EQ '2').STH\n         AIF   ('&LEN' EQ '4').ST\n         AGO   .RLENERR\n.LR      AIF   (&CC).LTR\n         AIF   ('&TGT.&TGT1' NE '&SRC').LR1\n         AIF   ('&OACNAME' EQ '').LR0\n&OACNAME DC    0H'0'\n         MEXIT\n.LR1     ANOP\n&OPR     SETC  'LR'\n         AGO   .RR\n.LTR     ANOP\n&OPR     SETC  'LTR'\n&CC      SETB  0\n         AGO   .RR\n.OR      ANOP\n&OPR     SETC  'OR'\n&CC      SETB  0\n         AGO   .RR\n.XR      ANOP\n&OPR     SETC  'XR'\n&CC      SETB  0\n         AGO   .RR\n.NR      ANOP\n&OPR     SETC  'NR'\n&CC      SETB  0\n         AGO   .RR\n.CR      ANOP\n&OPR     SETC  'CR'\n&CC      SETB  0\n         AGO   .RR\n.MVI     ANOP\n&OPR     SETC  'MVI'\n         AGO   .SI\n.NI      ANOP\n&OPR     SETC  'NI'\n&CC      SETB  0\n         AGO   .SI\n.OI      ANOP\n&OPR     SETC  'OI'\n&CC      SETB  0\n         AGO   .SI\n.XI      ANOP\n&OPR     SETC  'XI'\n&CC      SETB  0\n         AGO   .SI\n.CLI     ANOP\n&OPR     SETC  'CLI'\n&CC      SETB  0\n         AGO   .SI\n.TM      ANOP\n&OPR     SETC  'TM'\n&CC      SETB  0\n         AGO   .SI\n.IC      ANOP\n&OPR     SETC  'IC'\n         AGO   .SR\n.L       ANOP\n&OPR     SETC  'L'\n         AGO   .SR\n.LH      ANOP\n.* BREAK\n&OPR     SETC  'LH'\n         AGO   .SR\n.LA      ANOP\n&OPR     SETC  'LA'\n&CC      SETB  0\n&C       SETC  '&SRC'(1,2)\n         AIF   ('&C' NE '0(').SR\n         AIF   ('&OP' EQ 'MAC').SR\n&SRC     SETC  '&SRC'(3,K'&SRC-3)\n&SRCT    SETC  'R'\n         AGO   .LR\n.CH      ANOP\n&OPR     SETC  'CH'\n&CC      SETB  0\n         AGO   .SR\n.O       ANOP\n&OPR     SETC  'O'\n&CC      SETB  0\n         AGO   .SR\n.X       ANOP\n&OPR     SETC  'X'\n&CC      SETB  0\n         AGO   .SR\n.N       ANOP\n&OPR     SETC  'N'\n&CC      SETB  0\n         AGO   .SR\n.C       ANOP\n&OPR     SETC  'C'\n&CC      SETB  0\n         AGO   .SR\n.STC     ANOP\n&OPR     SETC  'STC'\n         AGO   .RS\n.STH     ANOP\n&OPR     SETC  'STH'\n         AGO   .RS\n.ST      ANOP\n&OPR     SETC  'ST'\n         AGO   .RS\n.MVC     ANOP\n&OPR     SETC  'MVC'\n         AGO   .SS\n.OC      ANOP\n&OPR     SETC  'OC'\n&CC      SETB  0\n         AGO   .SS\n.XC      ANOP\n&OPR     SETC  'XC'\n&CC      SETB  0\n         AGO   .SS\n.NC      ANOP\n&OPR     SETC  'NC'\n&CC      SETB  0\n         AGO   .SS\n.CLC     ANOP\n&OPR     SETC  'CLC'\n&CC      SETB  0\n         AGO   .SS\n.SI      ANOP\n.RR      ANOP\n.SR      ANOP\n&ARGS    SETC  '&TGT.&TGT1,&SRC'\n         AGO   .INSTGEN\n.RS      ANOP\n&ARGS    SETC  '&SRC,&TGT.&TGT1'\n         AGO   .INSTGEN\n.SS      AIF   ('&TGTT' EQ 'AR').SSAR\n&ARGS    SETC  '&TGT.(&LEN),&SRC'\n         AGO   .INSTGEN\n.SSAR    ANOP\n&ARGS    SETC  '&TGT.&LEN,&TGT1,&SRC'\n.INSTGEN ANOP\n&C       SETC  '&ARGS'            BUILD OPERANDS AND COMMENT\n         AIF   (K'&C GE 18).INSTGN1\n&C       SETC  '&C                   '(1,18)\n.INSTGN1 ANOP\n.* BREAK\n&C       SETC  '&C &COMM'         TACK ON THE COMMENTS\n         AIF   (K'&C GT 55).INSTGN2 CHECK FOR OVERFLOW\n&OACNAME &OPR  &C\n&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE\n         AGO   .INSTGN3\n.INSTGN2 ANOP                     NO ROOM FOR COMMENT\n&OACNAME &OPR  &ARGS\n.INSTGN3 ANOP\n&OACNAME SETC  ''\n         AIF   (&CC).INSTGN4      CHECK FOR SET CONDITION CODE\n         MEXIT\n.INSTGN4 AIF   ('&TGTT' EQ 'R').INSTGNR\n&ARGS    SETC  '&ARGS'(1,K'&ARGS-K'&SRC) STRIP OFF OLD SRC\n         CLC   &ARGS.&TGT.&TGT1\n         MEXIT\n.INSTGNR ANOP\n         LTR   &TGT,&TGT\n         MEXIT\n.LAST    AIF   ('&OP' EQ 'MAC').LAST0\n&C       SETC  '&SRC'(1,2)\n         AIF   ('&C' NE '0(').LAST0\n&SRC     SETC  '&SRC'(3,K'&SRC-3)\n&SRCT    SETC  'R'\n         AGO   .ST\n.LAST0   ANOP\n&ARGS    SETC  '&RS,&SRC'         BUILD OPERANDS AND COMMENT\n         AIF   (K'&ARGS GE 18).LAST1\n&ARGS    SETC  '&ARGS                   '(1,18)\n.LAST1   ANOP\n&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS\n         AIF   (K'&ARGS GT 55).LAST2 CHECK FOR OVERFLOW\n&OACNAME LA    &ARGS\n&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE\n         AGO   .LAST3\n.LAST2   ANOP                     NO ROOM FOR COMMENT\n&OACNAME LA    &RS,&SRC\n.LAST3   ANOP\n&OACNAME SETC  ''\n         ST    &RS,&TGT.&TGT1\n         MEXIT\n.STMVI   ANOP\n&ARGS    SETC  '&SRC,&TGT.&TGT1'  BUILD OPERANDS AND COMMENT\n         AIF   (K'&ARGS GE 18).STMVI1\n&ARGS    SETC  '&ARGS                   '(1,18)\n.STMVI1  ANOP\n&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS\n         AIF   (K'&ARGS GT 55).STMVI2 CHECK FOR OVERFLOW\n&OACNAME ST    &ARGS\n&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE\n         AGO   .STMVI3\n.STMVI2  ANOP                     NO ROOM FOR COMMENT\n&OACNAME ST    &SRC,&TGT.&TGT1\n.STMVI3  ANOP\n&OACNAME SETC  ''\n         MVI   &TGT.&TGT1,0       CLEAR HIGH BYTE\n         MEXIT\n         AIF   (NOT &CC).MEND\n&SRC     SETC  '&TGT.&TGT1'\n&SRCT    SETC  'A'\n&LEN     SETC  '4'\n         AGO   .CLC\n.MEND    MEND\n         MACRO\n         OACINUSE &DUMMY,&PRINT=\n         GBLA  &OACPRTS\n         GBLB  &OACPRTF\n         GBLC  &OACPRT,&OACPRTG,&OACSTMX,&OACSTER\n         GBLC  &OACNAME\n         GBLC  &USELAB(16),&USEREG(16)  PGM LABELS,REGISTERS USED\n         LCLA  &UCNT                    USE INDEX\n         LCLB  &GOTREG                  WHETHER WE FOUND REGS IN USE\n         AIF   ((T'&PRINT EQ 'O') AND                                  @\n               (NOT &OACPRTF)).GO#USE   SKIP PUSH IF NOT NEEDED\n         OACPRTPM PRINT=&PRINT\n.GO#USE  SPACE 1\n         MNOTE *,'THE FOLLOWING REGISTER(S) ARE IN USE:'\n         SPACE 1\n.USELOOP ANOP                           USED REGS LOOP\n&UCNT    SETA  &UCNT+1                  UP THE USE INDEX\n         AIF   ('&USEREG(&UCNT)' EQ '').CHKEND THIS ENTRY IN USE?\n         MNOTE *,'       &USELAB(&UCNT),&USEREG(&UCNT)'\n&GOTREG  SETB  1                        SAY WE FOUND SOMETHING\n.CHKEND  AIF   (&UCNT LT 16).USELOOP    CHECK FOR END OF ARRAY\n         AIF   (&GOTREG).FINI           LEAVE IF WE HAD REGS IN USE\n         MNOTE *,'       *** NONE ****'\n.FINI    SPACE 2\n         AIF   ((T'&PRINT EQ 'O') AND                                  @\n               (NOT &OACPRTF)).EXIT     SKIP POP IF NOT NEEDED\n         POP   PRINT\n.EXIT    MEND\n         MACRO\n         OACPRTPM &DUMMY,&PRINT=\n.*\n.*       SETS  VALUES OF &OACPRT AND &OACPRTS DEPENDING ON\n.*       VALUES OF &OACPRTG, &OACPRTF, AND &PRINT\n.*\n.*       DOES  A PUSH PRINT AND A PRINT ON,GEN OR A\n.*       PRINT OFF,NOGEN DEPENDING ON THE CALCULATED VALUE\n.*       OF &OACPRT\n.*\n         GBLA  &OACPRTS\n         GBLB  &OACPRTF\n         GBLC  &OACPRT,&OACPRTG,&OACSTMX,&OACSTER\n         GBLC  &OACNAME\n&OACPRT  SETC  '&OACPRTG'\n         AIF   (&OACPRTF).L4\n         AIF   ('&PRINT' EQ '').L1DEF\n         AIF   ('&PRINT' NE 'ALL' ).L1\n&OACPRT  SETC  'ALL'\n         AGO   .L4\n.L1      AIF   ('&PRINT' NE 'SHORT').L2\n.L1DEF   ANOP                     DEFAULT PRINT VALUE\n&OACPRT  SETC  'SHORT'\n         AGO   .L4\n.L2      AIF   ('&PRINT' EQ 'NONE').L3\n         MNOTE 4,'UNRECOGNIZABLE PRINT VALUE ''NONE'' USED'\n.L3      ANOP\n&OACPRT  SETC  'NONE'\n.L4      ANOP\n         PUSH  PRINT\n         AIF   ('&OACPRT' NE 'ALL').L5\n&OACPRTS SETA  99\n         AGO   .L8\n.L5      AIF   ('&OACPRT' NE 'SHORT').L6\n&OACPRTS SETA  1\n         AGO   .L8\n.L6      AIF   ('&OACPRT' EQ 'NONE').L7\n         MNOTE 4,'UNRECOGNIZABLE VALUE OF &OACPRTG ''NONE'' SET'\n&OACPRTG SETC  'NONE'\n&OACPRT  SETC  '&OACPRTG'\n.L7      ANOP\n         PRINT OFF,GEN\n&OACPRTS SETA  1\n.L8      MEND\n         MACRO\n&LBL     OACTMP &CMD=(0,0),&CBUF=,&PGM=,&PARM=,                        X\n               &DCB=0,&TASKLIB=0,&CMDLIB=YES,                          X\n               &EXEC=YES,&STACK=YES,&SCMD=NO,&STAX=YES,&CMDFAIL=MSG,   X\n               &MF=I\n         LCLA  &F,&F1,&A\n         LCLC  &C\n         LCLB  &CBF,&CBR,&CS,&CR1,&CR2,&PGF,&PGS,&PGR\n         LCLB  &PRF,&PRS,&PRR,&HF,&HS,&HR\n         LCLB  &DCBR,&DCB0,&TSKR\n         LCLB  &STRS\n         LCLB  &MFL,&MFI,&MFB,&MFE\n         AIF   (('&LBL' EQ '') OR ('&MF' EQ 'L') ).L\n&LBL     DS    0H\n.L       AIF   ('&CBUF' EQ '').L1\n&CBF     SETB  1\n&F       SETA  X'80'\n&C       SETC  '&CBUF'(1,1)\n         AIF   ('&C' NE '(').L8\n&CBR     SETB  1\n         AGO   .L8\n.L1      ANOP\n&C       SETC  '&CMD(1)'(1,1)\n         AIF   ('&C' NE '''').L2\n&CS      SETB  1\n&STRS    SETB  1\n         AGO   .L4\n.L2      AIF   ('&C' NE '(').L3\n&CR1     SETB  1\n.L3      ANOP\n&C       SETC  '&CMD(2)'(1,1)\n         AIF   ('&C' NE '(').L4\n&CR2     SETB  1\n.L4      AIF   ('&PGM' EQ '').L7A\n&PGF     SETB  1\n&F1      SETA  X'80'\n&C       SETC  '&PGM'(1,1)\n         AIF   ('&C' NE '''').L5\n&PGS     SETB  1\n&STRS    SETB  1\n         AGO   .L6\n.L5      AIF   ('&C' NE '(').L6\n&PGR     SETB  1\n.L6      AIF   ('&PARM' EQ '').L8\n&PRF     SETB  1\n&C       SETC  '&PARM'(1,1)\n         AIF   ('&C' NE '''').L7\n&PRS     SETB  1\n&STRS    SETB  1\n         AGO   .L8\n.L7      AIF   ('&C' NE '(').L8\n&PRR     SETB  1\n         AGO   .L8\n.L7A     AIF   ('&CMD(1)' NE '0').L8\n         AIF   ('&MF(1)' EQ 'L').L8\n         MNOTE 8,'CMD, CBUF, OR PGM MUST BE SPECIFIED'\n         MEXIT\n.L8      AIF   ('&DCB' NE 'ENV').L8A\n&F       SETA  &F+X'40'\n&DCB0    SETB  1\n         AGO   .L9\n.L8A     AIF   ('&DCB' NE '0').L8B\n&DCB0    SETB  1\n         AGO   .L9\n.L8B     ANOP\n&C       SETC  '&DCB'(1,1)\n         AIF   ('&C' NE '(').L9\n&DCBR    SETB  1\n.L9      ANOP\n&C       SETC  '&TASKLIB'(1,1)\n         AIF   ('&C' NE '(').L10\n&TSKR    SETB  1\n.L10     AIF   ('&CMDLIB' NE 'NO').L11\n&F       SETA  &F+X'20'\n.L11     AIF   ('&EXEC'  NE 'NO').L12\n&F       SETA  &F+X'10'\n.L12     AIF   ('&STACK' NE 'NO').L13\n&F       SETA  &F+X'02'\n.L13     AIF   ('&SCMD' EQ 'NO').L14\n&F       SETA  &F+X'08'\n.L14     AIF   ('&STAX' NE 'NO').L15\n&F       SETA  &F+X'04'\n         AGO   .L17\n.L15     AIF   ('&STAX' EQ 'YES').L17\n&HF      SETB  1\n&C       SETC  '&STAX'(1,1)\n         AIF   ('&C' NE '''').L16\n&HS      SETB  1\n&STRS    SETB  1\n         AGO   .L17\n.L16     AIF   ('&C' NE '(').L17\n&HR      SETB  1\n.L17     AIF   ('&CMDFAIL' NE 'NOMSG').L18\n&F       SETA  &F+X'01'\n.L18     AIF   ('&MF' NE 'L').L19\n&MFL     SETB  1\n         AGO   .L23\n.L19     AIF   ('&MF' NE 'I').L20\n&MFI     SETB  1\n         AGO   .L23\n.L20     ANOP\n&C       SETC  '&MF(1)'\n         AIF   ('&C' NE 'B').L21\n&MFB     SETB  1\n         AGO   .L23\n.L21     AIF   ('&C' NE 'E').L22\n&MFE     SETB  1\n         AGO   .L23\n.L22     MNOTE 8,'UNRECOGNIZABE MF'\n         MEXIT\n.L23     AIF   (NOT &MFL).L37\n         AIF   (NOT (&CBR OR &CR1 OR &CR2 OR &PGR OR &PRR OR &DCBR OR  X\n               &TSKR)).L24\n         MNOTE 8,'R FORM NOT ALOWED WITH MF=L'\n         MEXIT\n.L24     ANOP\n&LBL     DS    0F                       FULLWORD ALIGNMENT\n         DC    AL1(&F)                  FLAGS\n         AIF   (NOT &DCB0).L25\n         DC    AL3(0)                   DCB ADDR\n         AGO   .L26\n.L25     DC    AL3(&DCB)                DCB ADDR\n.L26     AIF   (&PGF).L29\n         AIF   (&CBF).L28\n         AIF   (&CS).L27\n         DC    AL1(&CMD(2))             CMD LNTH\n         DC    AL3(&CMD(1))             CMD ADDR\n         AGO   .L31\n.L27     DC    AL1(L'TMPC&SYSNDX)       CMD LNTH\n         DC    AL3(TMPC&SYSNDX)         CMD ADDR\n         AGO   .L31\n.L28     DC    AL4(&CBUF)               PTR TO CBUF\n         AGO   .L31\n.L29     AIF   (&PGS).L30\n         DC    AL4(&PGM)                PGM NAME ADDR\n         AGO   .L31\n.L30     DC    AL4(TMPG&SYSNDX)         PGM NAME ADDR\n.L31     DC    AL1(&F1)                 FLAGS\n         DC    AL3(&TASKLIB)            TASKLIB\n         AIF   (&PRF).L32\n         DC    AL4(0)                   RETURN/COMPLETION CODE\n         AGO   .L34\n.L32     AIF   (&PRS).L33\n         DC    AL4(&PARM)               PARM PTR/RETURN-COMPLETION CODE\n         AGO   .L34\n.L33     DC    AL4(TMPR&SYSNDX)         PARM PTR/RETURN-COMPLETION CODE\n.L34     AIF   (&HF).L35\n         DC    AL4(0)                   UNUSED HERALD FIELD\n         AGO   .L38\n.L35     AIF   (&HS).L36\n         DC    AL4(&STAX)               HERALD/REPLY\n         AGO   .L38\n.L36     DC    AL4(TMPH&SYSNDX)         HERALD/REPLY\n.L37     AIF   (NOT (&STRS OR &MFI)).L38\n         B     TMPL&SYSNDX\n.L38     AIF   (NOT &CS).L39\nTMPC&SYSNDX DC C&CMD\n.L39     AIF   (NOT &PGS).L40\nTMPG&SYSNDX DC CL8&PGM                  PGM NAME\n.L40     AIF   (NOT &PRS).L41\n&A       SETA  K'&PARM\n&A       SETA  &A-2\nTMPR&SYSNDX DC 0F'0',XL1'80',AL3(TMPR&SYSNDX+6)\n         DC    F'&A'\n         DC    C&PARM\n.L41     AIF   (NOT &HS).L42\n&A       SETA  K'&STAX\n&A       SETA  &A-2\nTMPH&SYSNDX DC H'&A',C&STAX\n.L42     AIF   (NOT &MFL).L43\n         MEXIT\n.L43     AIF   (NOT &MFI).L44\nTMPT&SYSNDX DC 5F'0'                    CMD BLK FOR OACTMP\nTMPL&SYSNDX LA 1,TMPT&SYSNDX GET TBL ADDR\n         AGO   .L45A\n.L44     AIF   (NOT &STRS).L45\nTMPL&SYSNDX DS 0H\n.L45     AIF   ('&MF(2)' EQ '(1)').L45A\n         LA    1,&MF(2)                 GET TBL ADDR\n.L45A    ANOP\n         XC    0(20,1),0(1)             CLEAR TBL\n.L46     AIF   (&DCBR).L47\n         AIF   (&DCB0).L48\n         LA    0,&DCB                   GET DCB ADDR\n         ST    0,0(1)                   STORE IN TBL\n         AGO   .L48\n.L47     ST    &DCB(1),0(1)             STORE DCB ADDR\n.L48     AIF   ('&F' EQ '0').L49\n         MVI   0(1),&F                  MOVE IN FLAGS\n.L49     AIF   (&PGF).L54\n         AIF   (&CBF).L53A\n         AIF   (&CS).L53\n         AIF   (&CR1).L50\n         LA    0,&CMD(1)                GET CMD ADDR\n         ST    0,4(1)                   STORE IN LST\n         AGO   .L51\n.L50     ST    &CMD(1),4(1)\n.L51     AIF   (&CR2).L52\n         MVI   4(1),&CMD(2)             MOVE IN LNTH\n         AGO   .L57\n.L52     STC   &CMD(2),4(1)             STORE CMD LNTH\n         AGO   .L57\n.L53     LA    0,TMPC&SYSNDX            GET CMD ADDR\n         ST    0,4(1)                   STORE IN TBL\n         MVI   4(1),L'TMPC&SYSNDX       MOVE IN LNTH\n         AGO   .L57\n.L53A    AIF   (&CBR).L53B\n         LA    0,&CBUF                  GET CBUF ADDR\n         ST    0,4(1)                   STORE IN TBL\n         AGO   .L57\n.L53B    ST    &CBUF(1),4(1)            STORE CBUF ADDR\n         AGO   .L57\n.L54     AIF   (&PGS).L56\n         AIF   (&PGR).L55\n         LA    0,&PGM                   GET PGM NAME ADDR\n         ST    0,4(1)                   STORE IN TABLE\n         AGO   .L57\n.L55     ST    &PGM(1),4(1)             STORE PGM NAME ADDR\n         AGO   .L57\n.L56     LA    0,TMPG&SYSNDX            GET PGM NAME ADDR\n         ST    0,4(1)                   STORE IN TABLE\n.L57     AIF   ('&TASKLIB' EQ '0').L59\n         AIF   (&TSKR).L58\n         LA    0,&TASKLIB               GET ADDR OF TSK DCB\n         ST    0,8(1)                   STORE IN TAB\n         AGO   .L59\n.L58     ST    &TASKLIB(1),8(1)         STORE TSK DCB ADDR\n.L59     AIF   ('&F1' EQ '0').L60\n         MVI   8(1),&F1                 MOVE IN FLGS\n.L60     AIF   (NOT &PRF).L63\n         AIF   (&PRS).L62\n         AIF   (&PRR).L61\n         L     0,&PARM                  GET PARM ADDR\n         ST    0,12(1)                  STORE IN TABLE\n         AGO   .L63\n.L61     ST    &PARM(1),12(1)           ST PRM ADDR IN TABLE\n         AGO   .L63\n.L62     LA    0,TMPR&SYSNDX            GET PARM ADDR\n         ST    0,12(1)                  STORE IN TABLE\n.L63     AIF   (NOT &HF).L67\n         AIF   (&HS).L65\n         AIF   (&HR).L64\n         LA    0,&STAX                  GET HERALD ADDR\n         ST    0,16(1)                  STORE IN TABLE\n         AGO   .L67\n.L64     ST    &STAX(1),16(1)           STORE HERALD ADDR\n         AGO   .L67\n.L65     LA    0,TMPH&SYSNDX            GET HERALD ADDR\n         ST    0,16(1)                  STORE IN TBL\n.L67     AIF   (&MFB).L68\n         LINK  EP=OACTMP\n.L68     MEND\n         MACRO\n         OACUSING &PARMS\n         GBLC  &USELAB(16),&USEREG(16)  PGM LABELS,USE REGISTERS\n         LCLA  &RCNT,&PNDX,&UNDX        # OF OPERANDS,PARM/USE INDICES\n         LCLA  &TP1,&HOLE               TEMP WORK,1ST UNUSED SAVE ENTRY\n         LCLB  &GOTREG                  WHETHER TO DO USING OR NOT\n         LCLC  &CHR1,&CHR2,&C(16)       TEMPORARY WORK CHARS,COMMAS\n         LCLC  &R(16),&S                REGS\n         LCLC  &U,&V,&W                 R(15),C(16),R(16)\n&PNDX    SETA  1                        SET UP PARM STRING INDEX\n&RCNT    SETA  N'&SYSLIST               GET NUMBER OF OPERANDS\n         AIF   (&RCNT LE 1).ERR01       TOO FEW INPUT PARAMETERS\n         AIF   (&RCNT LE 17).SYS1#CK    CONTINUE IF LOW ENOUGH\n         MNOTE 4,'TOO MANY INPUT PARAMETERS. ONLY 17 PROCESSED'\n&RCNT    SETA  17                       SET MAX ALLOWABLE\n.SYS1#CK ANOP\n&S       SETC  '&SYSLIST(1)'            SET FOR SHORTER STRING BELOW\n.COMLOOP ANOP\n&PNDX    SETA  &PNDX+1                  INCREMENT INPUT STRING INDEX\n&UNDX    SETA  0                        INITIALIZE USE INDEX\n&HOLE    SETA  0                        INITIALIZE UNUSED ENTRY INDEX\n.USELOOP AIF   ('&SYSLIST(&PNDX)' EQ '').CHK#END BR IF NULL STRING\n&UNDX    SETA  &UNDX+1                  UP THE USE INDEX\n         AIF   ('&USEREG(&UNDX)' EQ '&SYSLIST(&PNDX)').DO#USE PREVUSE?\n         AIF   ((&HOLE NE 0) OR ('&USEREG(&UNDX)' NE '')).CHKEND\n.* WE BRANCH TO CHKEND IF WE ALREADY HAVE A HOLE OR NO HOLE EXISTS HERE\n&HOLE    SETA  &UNDX                    KEEP THE SAVE TABLE FREE INDEX\n.CHKEND  AIF   (&UNDX LT 16).USELOOP    LOOP FOR ALL ENTRIES\n&UNDX    SETA  &HOLE                    GET FREE ENTRY INDEX IN CASE\n         AIF   (&HOLE NE 0).DO#USE1     BRANCH IF SPACE FOR ENTRY\n         MNOTE 4,'OACUSING SAVE TABLE FULL. OPERAND TRUNCATED'\n         AGO   .USINGGO                 GO DO JUST WHAT WE CAN\n.DO#USE  ANOP\n&CHR1    SETC  '********'(1,K'&SYSLIST(&PNDX)) STARS FOR THE REG\n&CHR2    SETC  '****************'(1,K'&USELAB(&UNDX)) MAX 16 CHAR LABEL\n         MNOTE *,'*********&CHR1*********************&CHR2'\n         MNOTE *,'REGISTER &SYSLIST(&PNDX) PREVIOUSLY BASED ON &USELAB(@\n               &UNDX)'\n         MNOTE *,'*********&CHR1*********************&CHR2'\n.DO#USE1 ANOP                           LOG THE REG USE HERE\n&CHR1    SETC  '&SYSLIST(1)'            GET A DEFAULT LABEL\n         AIF   (&PNDX EQ 2).SETLAB      IF FIRST REG, NO +NNNN TO ADD\n&TP1     SETA  (&PNDX-2)*4096           ELSE GET ADDED AMOUNT\n&CHR1    SETC  '&CHR1'.'+'.'&TP1'       APPEND THE +NN FOR EXTRA REGS\n.SETLAB  ANOP                           MOVE IN THE SAVE LABELS HERE\n&USELAB(&UNDX) SETC '&CHR1'             SET SAVE TABLE DATA\n&USEREG(&UNDX) SETC '&SYSLIST(&PNDX)'   GET THE REG VALUE IN SAVEAREA\n&R(&PNDX-1) SETC '&SYSLIST(&PNDX)'      GET THE REG VALUE FOR USING\n&C(&PNDX-1) SETC ','                    AND A LEADING COMMA ALSO\n&GOTREG  SETB  1                        SAY WE CAN DO USING\n.CHK#END AIF   (&PNDX LT &RCNT).COMLOOP LOOP FOR ALL ENTRIES\n.USINGGO AIF   (NOT &GOTREG).EXIT       NOW TELL ASSEMBLER IF WE CAN\n&U       SETC  '&R(15)'                 SO WE HAVE A SHORTER STRING\n&V       SETC  '&C(16)'                 SO WE HAVE A SHORTER STRING\n&W       SETC  '&R(16)'                 SO WE HAVE A SHORTER STRING\n         USING &S&C(1)&R(1)&C(2)&R(2)&C(3)&R(3)&C(4)&R(4)&C(5)&R(5)&C(6@\n               )&R(6)&C(7)&R(7)&C(8)&R(8)&C(9)&R(9)&C(10)&R(10)&C(11)&R@\n               (11)&C(12)&R(12)&C(13)&R(13)&C(14)&R(14)&C(15)&U&V&W\n         MEXIT\n.ERR01   MNOTE 4,'MISSING INPUT PARAMETERS'\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT458/FILE458.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT458", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}