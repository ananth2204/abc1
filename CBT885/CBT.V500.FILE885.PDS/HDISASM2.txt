DIS2     TITLE '*** HDISASM DISASSEMBLY PHASE 2 ***'
* THIS SUB-PROGRAM IS CALLED BY HDISASM AFTER THE DIRECTORY
* ENTRY AND LOAD MODULE ARE PROCESSED. THE ESD AND RLD
* ENTRIES HAVE BEEN USED TO CREATE A PROGRAM LABEL TABLE,
* AND MODULE TEXT IS IN AN AREA OF STORAGE. A COMMON PARAMETER
* AREA IS DEFINED IN HDISASM, AND PASSED TO THIS PROGRAM.
*
* TEXT BYTES ARE USED TO CREATE ASSEMBLY LANGUAGE STATEMENTS,
* AND MACHINE INSTRUCTION STATEMENTS. OUTPUT IS WRITTEN
* TO THE WORK1 DATASET FOR FURTHER PROCESSING BY OTHER
* MODULES.
*   A TEXT BYTE IS CONSIDERED TO BE AN INSTRUCTION IF
* IT OCCURS ON A HALFWORD BOUNDARY, IS A VALID OP-CODE,
* AND IS FOLLOWED BY A VALID OP-CODE. UNCONDITIONAL BRANCHES
* NEED NOT BE FOLLOWED BY A VALID OP-CODE, HOWEVER. THE
* PRIVILEGED AND FLOATING POINT INSTRUCTIONS ARE NOT
* TREATED AS INSTRUCTIONS UNLESS THE USER SPECIFIED
* THEIR INCLUSION AT EXEC TIME.
*
* R3 - DATA AREA OF HDISAMS2
* R4 - WORK REGISTER OF SYSTEM CONTROL BLOCK SEARCHING
* R5 - COMMON AREA
* R6 - LABEL TABLE
* R7 - CURRENT TEXT
* R8 - WORK REGISTER
* R9 - LINKAGE REGISTER FOR SUBROUTINE
* R10- WORK REGISTER
* R11- WORK REGISTER
* R12- WORK REGISTER
*
* ORIGINAL AUTHOR R THORNTON - NOV 1977
*
* AMENDMENT ABSTRACT
* 1. UPDATE TABLE SGLOP AND DBLOP TO SUPPORT XA INSTRUCTION
*                                             ALBERT CHENG 10/13/87
* 2. HANDLE RRE AND SSE FORMAT                ALBERT CHENG 10/13/87
* 3. ENLARGE THE SVCOP TABLE FROM 14 TO 16    ALBERT CHENG 10/20/87
* 4. HANDLE SS3 FORMAT (SS3OPND)              ALBERT CHENG 10/21/87
* 5. EXTEND SVC TABLE, THE LARGEST SVC NO. CHANGED FROM 126 TO 139
*                                             ALBERT CHENG 11/06/87
* 6. FIX ENTRY CS AND CDS AT SGLOP FROM E4+EPR TO E4
*                                             ALBERT CHENG 01/21/88
* 7. FIX SOME BUGS AT ROUTINE INSTR           ALBERT CHENG 02/16/88
*
* 8. REMOVE THE RESTRICTION OF USING BASE
*    REGISTER 0 FOR PSA                       ALBERT CHENG 03/09/91
* 9. FORMAT EXTENDED MNEMONIC RR INSTRUCTION
*                                             ALBERT CHENG 09/09/91
* 10. FIX FORMAT NOP OPERAND
*                                             ALBERT CHENG 06/24/92
* 11. FIX COMMENT FIELD FOR SPKA
*                                             ALBERT CHENG 11/07/92
* 12. SUPPORT NEW ASSEMBLER INSTRUCTIONS
*                                             ALBERT CHENG 01/16/07
* 13. FIX BRANCH MNEMONIC CODE. USE NEW ASSEMBLER INSTR
*                                             ALBERT CHENG 04/27/12
* 14. A) GET RID OF PROGRAM BASE REGISTER. USE LARL TO
*        ESTABLISH THE ADDRESSIBILITY OF STATIC DATA
*     B) ADD ROUTINE SRCHDSCT TO FORMAT BDDD THEY ARE DEFINED IN THE
*        IN GLOBAL MAPPING TABLES.
*        Example:
*        E3E000100017   LLGT  R14,16                  CVT
*        E3FE007C0017   LLGT  R15,CVTIXVAL-CVT(R14)   I/O COMM AREA
*        E3EF00080017   LLGT  R14,IOCOMWPT-IOCOM(R15) MDY PART OF IOC
*                                                ALBERT CHENG 04/05/13
* 15. A) SUPPORT MULTIPLE DSECTS
*     B) CHANGE MAXIMUM LENGHT OF CONSTANT FROM 8 TO 48
*     C) SUPPORT CODE ONLY STATEMENT
*     D) SUPPORT INDEX REGISTER
*                                                ALBERT CHENG 10/07/13
* 16. A) SUPPORT CTLBK STATEMENT
*     B) FORMAT CHARACTER WITH MIXED CASE
*     C) REMOVE REDUNTANT CODE TO FORMAT CVT
*     D) WRITE 2ND LINE IF THE OPERAND EXCEEED COLUMN 72
*                                                ALBERT CHENG 03/12/14
* 17. A) FORMAT DIAGNOSE INSTRUCTION
*     B) FIX BUGS OF FORMATTING FLOATING POINT INSTRUCTION
*     C) CHANGE SYSTEM VARIABLE TABLES FROM FIX LENGTH TO
*        VARIABLE LENGTH.
*                                                ALBERT CHENG 06/25/14
* 18. A) NEW ROUTINE BITMAP TO FORMAT BIT MASK VARIABLES FOR
*        SI INSTRUCTION
*        TM    ASCBFL2A-ASCB(R9),ASCBNOPR     DO NOT SIGP ?
*     B) FORMAT ARs, CRs and FRs
*     C) WRITE CONTINOUS LINE IF THE DECODED INSTRUCTION EXCEEDS
*        COLUMN 72
*                                                ALBERT CHENG 10/17/14
* 19. A) ADD COMMENT FILED TO DSECT TABLE
*                                                ALBERT CHENG 01/22/15
* 20. A) ADD DATX STATEMENT
*     B) IF OFFSET 4 IS X'16C9' FORMAT IT AS MODID LENGLBL=24
*     C) FIX FORMAT PROBLEM OF NOPR
*     D) SUPPORT z/OS V.2 ASSEMBLER INSTRUCTION
*                                                ALBERT CHENG 03/26/15
* 21. A) SUPPORTS 6 CHARACTER INSTRUCTION NAME
*     B) SUPPORTS SSF AND SIL FORMAT OP CODES
*     C) ADD CONDITION CODE TABLE
*                                                ALBERT CHENG 05/20/15
* 22. A) PUT LABEL NAME INTO COMMENT FIELD
*     B) CHANGE PROGRAM FROM AMODE 24 TO AMODE 31 &
*                            RMODE 24 TO RMODE ANY
*     C) ENHANCE FORMAT IMMEDIATE FIELD OF TM,OI,NI,MVI and CLI
*                                                ALBERT CHENG 06/02/15
*
* 23. A) ADD SYSMODTB
*     B) PRINT REGUSE REPORT FOR DEBUGGING PURPOSE
*                                                ALBERT CHENG 07/16/15
*
* 24. A) ADD ! AS GLOBAL DSECT MAPPING INDICATOR
*        ADD % AS PROGRAM DSECT MAPPING INDICATOR
*        INIT DSECT TO BLANKS FOR @DUMMY
*                                                ALBERT CHENG 08/25/15
*
* 25. A) EXTEND THE LENGTH OF USER DEFINE LABEL FROM 8 TO 12
*     B) EXTEND THE LENGTH OF DSECT FIELD FROM 8 TO 12
*                                                ALBERT CHENG 10/26/15
*
* 26. A) FIX BUGS
*                                                ALBERT CHENG 01/05/16
*
* 27. A) ADD > and <  AS PROGRAM DSECT MAPPING INDICATOR
*     B) ADD COMMENT TO SOME INSTRUCTION
*                                                ALBERT CHENG 05/16/16
*
* 28. A) FIX FORMAT RXY AND RSY DISPLACEMENT
*     B) SUPPORT RIE AND SIY INSTRUCTION
*                                                ALBERT CHENG 09/04/16
*
* 29. A) SRCHDSCT AND BITMAP ROUTINE AS SUBPROGRAM
*     B) SUPPORT RRFE INSTRUCTION
*                                                ALBERT CHENG 02/01/17
*
* 30. A) AUTOMATIC MAPPING AND BUG FIXING
*     B) SUPPORT RRF/RSA INSTRUCTION SETS
*     C) CLEAR ALL DSECT
*                                                ALBERT CHENG 07/15/17
*
* 31. A) SUPPORT CTLBK COMMENT
*                                                ALBERT CHENG 05/26/19
*     SCHLBL BDXADR
******************************************************************
HDISASM2 CSECT
HDISASM2 RMODE ANY
HDISASM2 AMODE 31
         J     BEGIN                                             @14A
         DC    C'HDISASM2'             PROGRAM NAME              @14A
         DC    C'01.31'                VERSION NUMBER            @28C
         DC    C'&SYSDATE &SYSTIME'    ASSEMBLE DATE AND TIME
*---------------------------------------------------------------
*
*---------------------------------------------------------------
BEGIN    BAKR  R14,0                   SAVE REGISTERS            @14A
         LARL  R3,DATASTR2             SET DATA REGISTER         @14A
         USING DATASTR2,R3                 ADDRESSIBILITY        @14A
*        L     R5,0(R1)                GET PARM FIELD ADDRESS
         LR    R5,R1                   GET PARM FIELD ADDRESS
         USING COMMPARM,R5
*        LARL  R0,HDISDSTB             LOAD HDISDSTB             @15A
*        SR    R1,R1                                             @15A
*        SVC   8                       LOAD HDISDSTB             @15A
*        ST    R0,DATAAD               SAVE EPA OF HDISDSTB      @15A
*        LARL  R0,HDISSFTB             LOAD HDISSFTB             @15A
*        SR    R1,R1                                             @15A
*        SVC   8                       LOAD HDISD2TB             @15A
*        ST    R0,SFTAD                SAVE EPA OF HDISD2TB      @15A
         LA    R0,OPNDS                                          @17A
         AHI   R0,18                                             @17A
*        MVC   CTLOPTR,CTLSTRT                                   @28A
         SR    R0,R0                   CLEAR FOR ICM INSTR       @28A
         ICM   R0,7,AOFST              AOFST = TXTSTRT           @28A
         A     R0,TXTSTRT                        +  XOFST        @28A
         ST    R0,AOFST                                          @28A
* ****************************************************************
*                                                                *
* MAINLINE ROUTINE FOR DISASSEMBLY. EACH BYTE OF TEXT IS CHECKED *
* TO DETERMINE WHETHER IT MAY BE AN INSTRUCTION OP-CODE. IF NOT, *
* THE CONST ROUTINE IS PERFORMED TO HANDLE CONSTANT DATA. IF IT  *
* APPEARS TO BE AN OP-CODE, THE INSTR ROUTINE IS PERFORMED.      *
* WHEN TEXT IS EXHAUSTED, THIS PHASE TERMINATES AND CONTROL IS   *
* RETUERNED TO MAIN ROUTINE HDISASM.                             *
*                                                                *
******************************************************************
*
MAINLINE DS    0H                      MAINLINE ROUTINE
         L     R6,LBLTBL               @ LABEL TABLE
         USING LABELD,R6
         MVC   TXTCURR,TXTSTRT         COPY TEXT START ADDR
GETCURR  L     R7,TXTCURR              @ CURRENT TXT BYTE
         C     R7,TXTEND               END OF TEXT
         JNL   EOJ                     YES
         SR    R1,R1                   CLEAR WORK                  @12A
         LR    R12,R7                  COPY TEXT ADDR
         S     R12,TXTSTRT             COMPUTE OFFSET
         ST    R12,TXTOFST             SAVE OFFSET TO THIS BYTE
         CHI   R12,4                   OFFSET LOCATION 4 ?         @20A
         JNE   DATA050                 BRANCH IF NO                @20A
         CLC   XMODID,0(R7)            = X'16C9' ?                 @20A
         JNE   DATA050                 BRANCH IF NO                @20A
         AHI   R7,1                    STEP OVER 1 BYTE IN TEXT    @20A
         MVC   OPNDS(2),SXAPO          TYPE AND BEGIN QUOTE X'     @20A
         MVC   OPNDS+2(3),SX16         HARDCODE THE                @20A
         MVC   PRT(6),SC004              OPERAND TO X'16' &        @20A
         MVC   PRT+7(2),SX16             OFFSET TO 4               @20A
         J     DATA400                                             @28C
DATA050  L     R12,DATOCUR             LOAD DATA TABLE             @20C
         CLC   HIVAL(3),DATASTRT-DATAD(R12) END OF DATA NAME TABLE @20A
         JE    DATA750                 BRANCH IF YES               @20A
         CLC   TXTOFSET,DATASTRT-DATAD(R12)   LOWER ?              @20A
         JL    DATA750                 BRANCH IF NOT IN RANGE      @20A
         CLC   TXTOFSET,DATAEND-DATAD(R12)    HIGHER ?             @20A
         JH    DATA750                 BRANCH IF NOT IN RANGE      @20A
         CLI   DATATYPE-DATAD(R12),C'C'  NORMAL DATA TYPE ?        @20A
         JE    DATA750                 BRANCH IF YES               @20A
         CLI   DATATYPE-DATAD(R12),C'H'  NORMAL DATA TYPE ?        @20A
         JE    DATA200                 BRANCH IF YES               @20A
         J     DATA200    ????         BRANCH IF YES               @20A
*** HEX2 DATA TYPE not yet supported
         XR    R9,R9                                               @20A
         ICM   R9,7,DATAEND-DATAD(R12) LOAD ENDING OFFSET          @20A
         S     R9,TXTOFST              ENDING OFFSET - CURRENT     @20A
         CHI   R9,1                    > 1 ?                       @20A
         JL    DATA750                 BRANCH IF ALMOST END OF DATX@20A
         MVI   CONPROG,1                                           @20A
         LA    R12,CONDATA             @ CONSTANT DATA             @20A
         MVC   0(2,R12),0(R7)          COPY CONSTANT DATA          @20A
         JAS   R9,HEXPRT2              CONVERT TO PRINTABLE        @20A
         LA    R9,OPNDS                                            @28A
         CLI   LBLNAME+8,C' '                                      @28A
         JE    DATA300                                             @28A
         AHI   R9,1                                                @28A
*** HEXI DATA TYPE
DATA200  XR    R9,R9                                               @20A
         ICM   R9,7,DATAEND-DATAD(R12) LOAD ENDING OFFSET          @20A
         S     R9,TXTOFST              ENDING OFFSET - CURRENT     @20A
         CHI   R9,3                    > 3 ?                       @20A
         JL    DATA750                 BRANCH IF ALMOST END OF DATX@20A
         MVI   CONPROG,1                                           @20A
         LA    R12,CONDATA             @ CONSTANT DATA             @20A
         MVC   0(4,R12),0(R7)          COPY CONSTANT DATA          @20A
         JAS   R9,HEXPRT4              CONVERT TO PRINTABLE        @20A
         LA    R9,OPNDS                                            @28A
         CLI   LBLNAME+8,C' '                                      @28A
         JE    DATA300                                             @28A
         AHI   R9,1                                                @28A
DATA300  MVC   0(2,R9),SXAPO           TYPE AND BEGIN QUOTE X'     @28A
         MVC   2(8,R9),PRTABL          MVC   OPNDS+2(1),PRTABL     @28A
         MVI   10(R9),C''''            ENDING QUOTE '              @28A
         MVC   OFFSET,TXTOFSET         @ OFFSET TO INSTR           @20A
         MVI   LEN,X'04'               SET LENGTH TO 4             @20A
         MVC   TEXT(4),0(R7)           COPY TEXT                   @20A
         JAS   R9,TXTFMT               GO FORMAT HEX DATA          @20A
         AHI   R7,4                    STEP OVER 4 BYTE IN TEXT    @20A
DATA400  LA    R9,MNEMONIC                                         @28A
         CLI   LBLNAME+8,C' '                                      @28A
         JE    DATA500                                             @28A
         AHI   R9,4                                                @28A
DATA500  MVC   0(2,R9),S_DC            SET MNEMONIC DC             @28A
         CLC   LBLADR,TXTOFSET         SAME OFFSET ?               @20A
         JNE   DATA700                 BRANCH IF NOT TRUE          @20A
         CLI   LBLNAME+8,C' '                                      @28A
         JE    DATA600                                             @28A
         MVC   NAME(L'LBLNAME),LBLNAME  NAME TO OUTPUT             @28A
         J     DATA650                                             @28A
DATA600  MVC   NAME,LBLNAME            NAME TO OUTPUT              @20A
DATA650  AHI   R6,LABELL               POINT TO NEXT LABEL         @20A
DATA700  DS    0H                                                  @20A
         JAS   R9,WRTOUT               WRITE RECORD SYSPUNCH       @20A
         JAS   R9,PRINT                GO PRINT IT SYSPRINT        @20A
         ST    R7,TXTCURR              UPDATE TEXT ADDR            @20A
         J     GETCURR                 CONTINUE TEXT PROCESSING    @20A
* UPDATE DSECT TABLE
DATA750  DS    0H                      SET MNEMONIC DC             @20A
         L     R4,CTLOCUR              GET CTLBK ONLY TBL ADDR     @16A
         CLC   TXTOFSET,0(R4)          SAME OFFSET ??              @16A
         JL    CHGBASE                 CHANGE BASE REG IF LOWER    @16A
         CLC   TXTOFSET,0(R4)          SAME OFFSET ??              @31A
         JNE   DATA800                 CHANGE BASE REG IF LOWER    @31A
         CLI   CTLCOMM-CTLD(R4),C' '   NO COMMENT ??               @31A
         JE    DATA800                 BRANCH IF YES               @31A
         MVC   COMMENT(L'CTLCOMM),CTLCOMM-CTLD(R4)                 @31A
DATA800  XR    R14,R14                 CLEAR WORK REGISTER         @16A
         CLI   CTLREG-CTLD(R4),C'*'    COMMENT ENTRY               @31A
         JE    DATA900                 BRANCH IF YES               @31A
         CLI   CTLCOMM-CTLD(R4),C'?'   NOT SURE ENTRY ?            @31A
         JE    DATA900                 BRANCH IF YES               @31A
         IC    R14,CTLREG-CTLD(R4)     LOAD DSECT BASE REGISTER    @23C
         MHI   R14,DSREGEL             TABLE ENTRY LENGTH IS 13    @23C
         LA    R0,DSREGTBL             LOCATE REG TABLE            @23A
         AR    R14,R0                  R14 -> REG TABLE ENTRY      @23A
         CLI   CTLCOMM-CTLD(R4),C' '   BLANK COMMENT ??            @31A
         JE    DATA810                                             @31A
         MVC   4(DSREGL+1,R14),CTLCOMM-CTLD(R4)  COPY DSECT        @31A
         J     DATA900                                             @31A
DATA810  CLC   S_CLEAR,CTLDSECT-CTLD(R4) CLEAR REGISTER ??         @30A
         JE    DATA830                 BRANCH IF NOT CLEAR         @30A
         CLC   S_DUMMY,CTLDSECT-CTLD(R4) DUMMY DSECT ??            @24A
         JNE   DATA850                 BRANCH IF NOT DUMMY DSECT   @24A
         MVC   4(DSREGL+1,R14),BLANX   CLEAR REG TABLE ENTRY       @24A
         J     DATA900                                             @24A
DATA830  LA    R4,14                                               @30A
DATA835  MVC   4(DSREGL+1,R14),BLANX   CLEAR DSECT                 @30A
         LA    R14,DSREGEL(,R14)                                   @30A
         JCT   R4,DATA835                                          @30A
         J     DATA900                                             @30A
DATA850  MVC   4(DSREGL+1,R14),CTLTYPE-CTLD(R4)      COPY DSECT    @23C
DATA900  CLC   CTLOFST-CTLD(L'CTLOFST,R4),HIVAL      LAST ENTRY ?? @28A
         JH    CKCCODE                 BRANCH IF YES               @28A
         AHI   R4,CTLBK                NEXT ENTRY                  @16A
         ST    R4,CTLOCUR              UPDATE CURRENT DSECT PTR    @28A
CHGBASE  DS    0H
         CLC   NEXCHG,TXTOFSET         TIME TO CHANGE BASES
         JH    CKCCODE                 NO                          @15A
*****************************************************************
*                                                                *
* ENTERED WHENEVER THE CURRENT TEXT OFFSET IS PAST THE NEXCHG    *
* FIELD VALUE. THIS ROUTINE CREATES DROP CARDS FOR EXHAUSTED BASE*
* REGISTERS, AND USING STATEMENTS FOR NEW BASE REGISTERS. THE    *
* BASES TABLE IS SCANNED, AND ANY ENTRY WHICH IS NO LONGER IN USE*
* IS ZEROED OUT, AND A DROP RECORD IS CREATED. NEXT, THE USING   *
* TABLE IS SCANNED. WHEN AN ENTRY IS FOUND WHICH IS VALID AT THE *
* CURRENT OFFSET, THE BASE TABLE IS CHECKED. IF THE ENTRY IS NOT *
* IN USE, A USING STATEMENT IN CREATED, AND THE USING TABLE ENTRY*
* IS MOVED TO THE BASES TABLE. THE NEXCHG FIELD IS CHANGED TO    *
* CONTAIN THE OFFSET AT WHICH THE NEXT SCAN MUST BE MADE. AN IND-*
* ICATOR CALLED MORUSG IS SET TO SHOW WHEN ANY BASE REGISTERS ARE*
* CURRENTLY IN USE. WHEN NO MORE REGISTERS ARE AVAILABLE, THE    *
* NEXCHG FIELD IS SET TO HEX FF'S.                               *
*                                                                *
******************************************************************
*
*EXUSG   DS    0H                      *** GET NEXT BASE REG SET ***
         MVC   NEXCHG,HIVAL            RESET NEXT CHANGE ADDR
         MVI   MORUSG,0                CLEAR BASE REG AVAIL INDIC
         LA    R2,BASES                CLEAR R0 ELEMENT            @23A
         XC    0(USINGL,R2),0(R2)      CLEAR R0 USING TABLE ENTRY  @23A
         USING USINGD,R2
         AHI   R2,USINGL               @ R1'S ELEMENT OF BASE TABLE
         LA    R8,15                   Loop 15 times               @23A
****************************************************************
DRPCKND  DS    0H                                                  @09A
         CLC   USEND,XZROS             ENTRY USED
         JE    DRPSTEP                 NO
         CLC   TXTOFSET,USEND          PAST END OF THIS ONE
         JL    DRPSTEP                 NO
         MVC   MNEMONIC(4),S_DROP      SET OPERATION IS DROP
         MVI   OPNDS,C'R'              DELIMITER FOR REGS
         SR    R12,R12                 CLEAR WORK REGISTER
         IC    R12,USREG               GET USING REGISTER
         CVD   R12,DBLWD               CONVERT TO PACKED
         UNPK  DBLWD(2),DBLWD+6(2)       UNPACK
         OI    DBLWD+1,C'0'            CLEAR SIGN
         CHI   R12,10                  REG < 10
         JL    DPR1                    YES
         MVC   OPNDS+1(2),DBLWD        MOVE REG NBR
         J     WRTDROP                 GO WRITE DROP
DPR1     MVC   OPNDS+1(1),DBLWD+1      MOVE 1-DIGIT REG
WRTDROP  JAS   R9,WRTPUNCH             PUNCH DROP RECORD           @22A
         JAS   R9,PRINT                PRINT DROP RECORD
         XC    0(USINGL,R2),USBGN      CLEAR THE USING ENTRY       @25C
DRPSTEP  AHI   R2,USINGL               TO NEXT USING ELEMENT
         JCT   R8,DRPCKND              LOOP FOR 15 TIMES           @23C
******************************************************************
USGUSG   L     R2,USGSTRT              GET FIRST USING TBL ADDR
ENDUSE   CLI   0(R2),X'FF'             END OF TABLE ??
         JE    CKCCODE                 YES CHECK CODE RANGE        @15A
         CLC   TXTOFSET,USEND          PAST END OF THIS ONE
         JNL   ECSTEP                  YES
         OI    MORUSG,1                SHOW MORE BASES AVAIL
USBGCK   CLC   TXTOFSET,USBGN          CURR LOC BEFORE THIS
         JNL   CKNEWLO                 NO
         CLC   USBGN,NEXCHG            BEGINS BEFORE NEXT CHANGE
         JNL   ECSTEP                  NO
         MVC   NEXCHG,USBGN            YES, SET LOWER CHANGE OFFSET
         J     ECSTEP                  CONTINUE
CKNEWLO  CLC   USEND,NEXCHG            THIS ENTRY ENDS EARLIER
         JNL   ECMVC                   NO
         MVC   NEXCHG,USEND            YES, SET NEW END
ECMVC    CLI   USREG,15             *** REG NO > 15                @18A
         JH    CKCCODE              *** IMPOSSIBLE                 @18A
         SR    R0,R0                   CLEAR WORK                  @23C
         IC    R0,USREG                PICK UP REG                 @23C
         MHI   R0,USINGL               TIMES ENTRY LENGTH          @23C
         LA    R1,BASES                @ BASE TABLE ENTRY          @23C
         AR    R1,R0                   @ BASE TABLE ENTRY          @23C
         OI    MORUSG,X'80'            SHOW BASE IN USE
         CLC   0(USINGL,R2),0(R1)      OLD AND NEW IDENTICAL       @25C
         JE    ECSTEP                  YES
         MVC   0(USINGL,R1),0(R2)      NEW USING TO TABLE          @25C
         MVC   MNEMONIC(5),S_USING     OPERATION IS USING
         CLI   USTYPE,C'G'             IS IT A GLOABL DSECT        @25A
         JE    MVDSNAMG                YES                         @25A
         CLI   USTYPE,C'D'             IS IT A LOCAL DSECT
         JNE   CKUTPS                  NO
         ICM   R12,7,USVALU            YES, GET DSECT HEADER ADDRESS
         L     R11,DTBSTRT             @ 1ST DSECT HEADER ENTRY
DSCTEND  C     R11,DTBCURR             END OF DSECT HEADER TABLE
         JH    MVDSNAME                YES
         CLM   R12,7,DSECTHA-DSECTHD(R11) THIS THE HEADER ENTRY    @25A
         JNE   DSCTSTEP                NO
         LR    R12,R11                 YES, COPY IT'S ADDRESS
         J     MVDSNAME                CONTINUE
DSCTSTEP AHI   R11,DSECTHL             TO NEXT DSECT HEADER ENTRY
         J     DSCTEND                 LOOP THRU DSECT HEADER TABLE
MVDSNAMG ICM   R12,7,USVALU-USINGD(R1) LOAD GLOBAL MAPPING ENTRY   @25A
         MVC   OPNDS(8),7(R12)         DSECT NAME TO OPERANDS      @25A
         SR    R0,R0                   CLEAR FOR IC INSTRUCTION    @25A
         IC    R0,USREG-USINGD(R1)     GET BASE REGISTER           @25A
         MHI   R0,DSREGEL                                          @25A
         LA    R11,DSREGTBL            REGISTER DSECT TABLE        @25A
         AR    R11,R0                  LOCATE REGISTER TBL ENTRY   @25A
         MVI   4(R11),C'*'             SET DSECT MAPPING           @25A
         MVC   5(DSREGL,R11),1(R12)    COPY CNTL BLOCK DSECT NAME  @25A
         MVC   ENDOFST+1(L'USEND),USEND-USINGD(R1) ENDING OFFSET   @25A
         J     USFEBDNM                                            @25A
MVDSNAME MVC   OPNDS(8),0(R12)         DSECT NAME TO OPERANDS
USFEBDNM LA    R12,OPNDS+7             TO END OF NAME
USFRHED  CLI   0(R12),C' '             FOUND RHE
         JNE   USFMADD                 YES
         JCT   R12,USFRHED             BACK UP 1 AND LOOP
USFMADD  AHI   R12,1                   TO NEXT BYTE
USFMCMA  MVC   0(2,R12),SCOMMAR        DELIMITERS ',R'
         SR    R11,R11                 CLEAR WORK
         IC    R11,USREG               GET REGISTER NUMBER
         CVD   R11,DBLWD               CONVERT TO PACKED
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK REG NBR
         OI    DBLWD+1,C'0'            CLEAR SIGN
         CHI   R11,10                  REG < 10
         JL    USFMR1                  YES
         MVC   2(2,R12),DBLWD          MOVE 2-DIGIT REG NUMBER
         J     USINGOUT                GO WRITE USING
USFMR1   MVC   2(1,R12),DBLWD+1        MOVE 1-DIGIT REG NUMBER
USINGOUT JAS   R9,WRTOUT               WRITE USING STMT TO SYSPUNCH
         JAS   R9,PRINT                PRINT USING STMT TO SYSPRINT
         J     ECSTEP                  CONTINUE
CKUTPS   CLC   USVALU,TXTOFSET         USING AT CURR LOC
         JNE   USFMLBL                 NO
         MVI   OPNDS,C'*'          SET CURRENT LOC SYMBOL IN OPERAND
         LA    R12,OPNDS+1             GET NEXT POS ADDRESS
         J     USFMCMA                 GO FORMAT REG
USFMLBL  MVI   OPNDS,C'A'              SET 1ST CHAR OF LABEL NAME
         LA    R12,USVALU              GET OFFSET
         JAS   R9,HEXPRT3              CONVERT TO PRINTABLE
         MVC   OPNDS+1(6),PRTABL       PRINTABLE HEX TO LABEL
         LA    R12,OPNDS+7             TO NEXT LOC
         J     USFMCMA                 FORMAT REG
ECSTEP   AHI   R2,USINGL               TO NEXT USING ENTRY
         J     ENDUSE                  CONTINUE SCAN
         DROP  R2
********************************************************************
* If the instruction is within code only table, turn on switch
* CODPROG. Otherwise turn off switch CODPROG.
********************************************************************
CKCCODE  L     R12,CODOCUR                  GET CODE ONLY TBL ADDR @20C
         CLC   TXTOFSET,CODESTRT-CODED(R12) RANGE BEGINS LATER     @28C
         JL    CKDDATA                      BRANCH IF YES          @28C
         CLC   TXTOFSET,CODEEND-CODED(R12)  BYTE IN THE RANGE      @28C
         JNH   SETCODSW                YES                         @28C
         CLC   CODESTRT-CODED(3,R12),HIVAL                         @28A
         JE    CKDDATA                 BRANCH IF END OF TABLE      @15A
         AHI   R12,CODEL               NEXT CODE TABLE ENTRY       @28C
         ST    R12,CODOCUR             SAVE                        @28A
SETCODSW OI    CODPROG,X'80'           TURN ON CODE IN PROGRESS    @15A
         J     CKINSTR                 BRANCH                      @15A
****
CKDDATA  L     R12,DATOCUR             GET DATA ONLY TBL ADDR      @28C
         MVI   CODPROG,X'00'           TURN OFF CODE IN PROGRESS   @15A
         CLC   TXTOFSET,DATASTRT-DATAD(R12) RANGE BEGINS LATER
         JL    CKLOSEQ                 YES
         CLC   TXTOFSET,DATAEND-DATAD(R12)  BYTE IN THE RANGE
         JNH   CONST                   YES
         AHI   R12,DATAL               NEXT ENTRY                  @20C
         ST    R12,DATOCUR             SAVE UPDATED ADDR           @28C
         JAS   R9,FORCONST             YES, FORCE ANY CONSTANT OUT
         J     CKDDATA                 GO CHECK AGAIN
CKLOSEQ  CLC   TXTOFSET,LBLADR         LABEL ENTRY OUT OF SEQ
         JNH   GCKODD                  NO, CONTINUE
         JAS   R9,FORCONST             YES, FORCE ANY CONSTANT OUT
         MVC   NAME(L'LBLNAME),LBLNAME NAME TO OUTPUT
         MVC   MNEMONIC,S_EQU          MNEMONIC EQU                @13C
         MVI   OPNDS,C'*'              OPERAND
         MVC   COMMENT(14),S14Q        SHOW ERROR ?
         JAS   R9,WRTOUT               WRITE ERROR RECORD
         JAS   R9,PRINT                GO PRINT IT
         AHI   R6,LABELL               TO NEXT LABEL               @25C
         J     CKLOSEQ                 CONTINUE SEQ CHK
GCKODD   TM    TXTOFST+3,1             ODD ADDRESS                 @28C
         JO    CONST                   YES, NOT INSTR
         CLC   1(3,R7),0(R7)           4 CONSEC IDENTICAL BYTES
         JE    CONST                   YES, NOT INSTR
         CLC   X_7FFF,0(R7)            X'7FFFFFFF'                 @28A
         JE    CONST                   YES, NOT INSTR              @28A
         CLC   X_4000,0(R7)            X'40000000'                 @30A
         JE    CONST                   YES, NOT INSTR              @30A
         TM    CODPROG,X'80'           IS CODE IN PROGRESS ?       @17A
         JO    CKINSTR                 BRANCH IF YES               @17A
         CLC   IAHIR0,0(R7)            AHI R0,16 ?                 @29A
         JE    CKINSTR                 BRANCH IF YES               @29A
         TRT   0(1,R7),CHARTRAN        TEST TEXT BYTE
         JNZ   CKINSTR                 NOT CHARACTER
         CLI   CONPROG,1               IS CONSTANT IN PROGRESS
         JNE   CK6                     NO
         CLI   CONTYPE,C'C'            IS IT CHARACTER TYPE
         JE    CONST                   YES, ADD THIS TO CONSTANT
CK6      CLI   0(R7),X'A5'             L3 OPCODE ??                @29A
         JE    CKINSTR                 BRANCH IF YES               @29A
         CLC   0(2,R7),X_A7F4          UNCOND JUMP INSTR ??        @29A
         JE    CKINSTR                 BRANCH IF YES               @29A
         CLI   4(R7),X'A7'                                         @29A
         JE    CKINSTR                 YES, INSTRUCTION            @29A
         TRT   0(6,R7),CHARTRAN        6 CONSECUTIVE CHARACTERS
         JZ    CHKA7F4                 YES, NOT INSTRUCTION        @29C
CKINSTR  SR    R8,R8                   CLEAR WORK
         IC    R8,0(R7)                PICK UP TXT BYTE
         MHI   R8,SGOPLEN              TIMES TABLE LENGTH          @13C
*        LRL   R1,SGLOPAD                                          @13C
         L     R1,SGLOPAD                                          @13C
         AR    R8,R1
         MVC   INSTENT,0(R8)           SAVE SINGLE INSTR TBL ENTRY
         SR    R0,R0                   CLEAR FOR IC                @28A
         IC    R0,INLNG                                            @28A
         SRL   R0,4                    GET RID OF INSTR LENGTH     @28A
         STC   R0,IOLNG                SAVE OPERAND LENGTH         @28A
         NI    INLNG,X'0F'             CLEAR OPERAND LENGTH        @28A
         CLI   INAME,0                 IS IT AN INSTR OP-CODE
         JE    CONST                   NO
         CLI   ITYPE,TWO               TWO-BYTE OP-CODE ??         @13A
         JE    DBLNDS                                              @13A
         CLI   ITYPE,L3                TWO-BYTE OP-CODE L3 ??      @13A
         JE    L3LNDS                                              @13A
         CLI   ITYPE,L4                TWO-BYTE OP-CODE L4 ??      @13A
         JE    L4LNDS                                              @13A
         J     INSTR                   MUST BE 1 BYTE OP-CODE      @13A
CHKA7F4  CLC   0(2,R7),XA7F4                                       @29A
         JNE   CONST                   YES, NOT INSTRUCTION        @29A
         J     CKINSTR                                             @29A
*BLNDS   LRL   R8,DBLOPAD              YES, GET 2-BYTE TBL ADDR
DBLNDS   L     R8,DBLOPAD              YES, GET 2-BYTE TBL ADDR
DBLND    CLI   0(R8),X'FF'             END OF TABLE
         JE    CONST                   YES, NOT INSTR
         CLC   0(2,R8),0(R7)           THIS ENTRY MATCHES TXT
         JE    GOTDBLI                 YES
         AHI   R8,DGOPLEN              TO NEXT ENTRY
         J     DBLND                   LOOP THRU TBL
*3LNDS   LRL   R8,L3LOPAD                                          @13A
L3LNDS   L     R8,L3LOPAD                                          @13A
L3LND    CLI   0(R8),X'FF'             END OF TABLE                @13A
         JE    CONST                   YES, NOT INSTR              @13A
         CLC   0(1,R8),0(R7)           THIS ENTRY MATCHES TXT      @13A
         JNE   L3LNDXT                 YES                         @13A
         MVC   TEMP1,1(R7)                                         @13A
         NI    TEMP1,X'0F'             MASK OFF FIRST 4 BITS       @13A
         CLC   1(1,R8),TEMP1                                       @13A
         JE    GOTDBLI                 YES                         @13A
L3LNDXT  AHI   R8,L3OPLEN              TO NEXT ENTRY               @13A
         J     L3LND                   LOOP THRU TABLE             @13A
*4LNDS   LRL   R8,L4LOPAD                                          @04A
L4LNDS   L     R8,L4LOPAD                                          @04A
L4LND    CLI   0(R8),X'FF'             END OF TABLE                @04A
         JE    CONST                   YES, GET 2-BYTE TBL ADDR    @04A
         CLC   0(1,R8),0(R7)           1ST OPCODE MATCH ?          @04A
         JNE   L4LNDXT                 NO TRY NEXT ENTRY           @04A
         CLC   1(1,R8),5(R7)           2nd OPCODE MATCH ?          @04A
         JE    GOTDBLI                 YES THEN BRANCH             @04A
L4LNDXT  AHI   R8,L4OPLEN              TO NEXT ENTRY               @04A
         J     L4LND                   LOOP THRU TBL               @04A
GOTDBLI  AHI   R8,2                    SKIP DOUBLE BYTES OP CODE   @13A
         MVC   INSTENT,0(R8)           SAVE DOUBLE INSTR TBL ENTRY @13A
         SR    R0,R0                   CLEAR FOR IC                @28A
         IC    R0,INLNG                                            @28A
         SRL   R0,4                    GET RID OF INSTR LENGTH     @28A
         STC   R0,IOLNG                SAVE OPERAND LENGTH         @28A
         NI    INLNG,X'0F'             CLEAR OPERAND LENGTH        @28A
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED WHEN CURSORY CHECKS IN THE MAINLINE    *
* INDICATE THIS TEXT BYTE IS AN INSTRUCTION OP-CODE. FURTHER     *
* TESTING IS DONE BY THE IVERFY (NON-FLOATING POINT), OR FPVERFY *
* (FLOATING POINT) ROUTINES. BYTES PASSING THESE TESTS ARE       *
* ACCEPTED AS OP-CODES, AND ARE PASSED TO THE APPROPRIATE FORMAT *
* ROUTINES. FORMAT ROUTINES ARE ENTERED VIA A BRANCH TABLE USING *
* A BYTE IN THE INSTRUCTION OP-CODE TABLE ENTRY.                 *
*                                                                *
* THE ROUTINE CHECK THE NEXT TWO INSTRUCTION AND SEE WHETHER THEY*
* ARE VALID OP CODE.  IF THE NEXT TWO INSTRUCTION ARE OP CODE,   *
* CONTROL WILL BRANCH TO ICKTBL, OTHERWISE CONTROL WILL PASS TO  *
* ROUTINE CONSTANT.                                              *
*                                                                *
* R07 = ADDRESS OF CURRENT INSTRUCTION                           *
* R12 = ADDRESS OF NEXT INSTRUCTION                              *
* R14 = ADDRESS OF NEXT TWO INSTRUCTION                          *
******************************************************************
*
INSTR    EQU   *                       *** INSTRUCTIONS (POSSIBLY) ***
         MVC   ILENG+1(1),INLNG        SET INSTR LENGTH
         LH    R12,ILENG               PICK UP LENGTH
         AR    R12,R7                  ADDR OF NEXT OP CODE
         SR    R15,R15                 CLEAR WORK
         IC    R15,0(R12)              PICK UP NEXT OP-CODE
         MHI   R15,SGOPLEN             TIMES TBL ENTRY LENG        @13C
*        LRL   R1,SGLOPAD                                          @13C
         L     R1,SGLOPAD                                          @13C
         AR    R15,R1                  INSTR TBL ENTRY ADDR        @13C
*        LA    R15,SGLOP(R15)          INSTR TBL ENTRY ADDR        @13D
*                                      OP-CODE
*  HANDLE SPECIAL CASE                                             @07A
*                                                                  @07A
         CLI   0(R7),X'4B'             IS IT STRING '?'            @07A
         JE    CHECKDOT                BARNCH IF YES               @07A
         CLI   0(R7),X'F0'             IS IT STRING '0'            @07A
         JE    CHECKDOT                BARNCH IF YES               @07A
         CLI   0(R7),C'S'              IS IT STRING 'S'            @07A
         JE    CHECKDOT                BARNCH IF YES               @07A
         LH    R1,0(R7)                                            @12A
* R1 = OP OF NEXT INSTRUCTION
* R7 = ADDRESS OF NEXT INSTRUCTION
         J     ICKTBL    ???
CHECKDOT TM    CODPROG,X'80'           CODE IN PROGRESS            @15A
         JO    ICKSEC                                              @15A
         TRT   0(4,R7),CHARTRAN                                    @07A
         JZ    CONST                   BRANCH IF IT IS STRING      @07A
ICKSEC   SR    R1,R1                   CLEAR WORK
         IC    R1,INLNG-INSTENT(R15)   GET INSTR LENGTH OF NEXT OP CD
         AR    R1,R12                  ADDR OF NEXT TWO OP CODE
         SR    R14,R14                 CLEAR WORK
         IC    R14,0(R1)               PICK UP NEXT TWO OP-CODE
         MHI   R14,SGOPLEN             TIMES TBL ENTRY LENG        @13C
*        LRL   R1,SGLOPAD                                          @12C
         L     R1,SGLOPAD                                          @12C
         AR    R14,R1                  R14 = ADDR OF INSTR TBL ENT @12A
         CLI   INAME-INSTENT(R14),0    IS IT AN OP-CODE FOR NEXT 2 OP
         JNE   ICKTBL                  YES
         CLI   0(R7),X'4B'             IS IT SH INSTR ?            @30A
         JE    ICKTBL                  YES                         @30A
         CLI   0(R12),X'45'            IS IT BAL
         JE    ICKTBL                  YES, CONTINUE
         CLI   0(R12),X'07'            NO, IS IT BRANCH INSTR?
         JE    POSSB2                  YES
         CLI   0(R12),X'A7'            IS IT RELATIVE BRANCH       @13A
         JE    POSSB2                  YES                         @13A
         CLI   0(R12),X'47'            IS IT BRANCH OP CODE ?
         JNE   CONST                   NO, THEN THIS NOT INSTR
POSSB2   TM    1(R12),X'80'            IS IT COND BRANCH ??        @07A
         JNO   CONST                   NO, THEN THIS NOT INSTR
ICKTBL   LH    R12,ILENG               GET INSTR LENGTH
         AR    R12,R7                  @ NEXT TEXT LOC
         AHI   R12,-1                  BACK UP 1
         S     R12,TXTSTRT             RELATIVE SIZE IN CSECT
         CLM   R12,7,LBLADR            LBL TBL ADDR HERE
         JL    NOILBL                  NO
         CLC   TXTOFSET,LBLADR         LABEL AT INSTR START
         JNE   NOTINST                 NO, MUST BE CONSTANT
         CLI   LBLTYP,C'L'             IS IT A LABEL ONLY
         JNE   NOTINST                 NO
         CLI   CONPROG,1               CONSTANT IN PROGRESS
         JNE   CKLBLNG                 NO
         JAS   R9,FORCONST             YES, FORCE IT OUT
CKLBLNG  CLC   LBLLEN,INLNG            LENGTHS SAME
         JE    SETLBL                  YES
         CLI   LBLLEN,0                DON'T CARE LENGTH
         JE    SETLBL                  YES
*        JAS   R9,EQUSTMT              NO, BUILD EQU STATEMENT     @15D
         MVC   NAME,LBLNAME            NAME TO EQU STMT            @15A
         J     ISTPLBL                 CONTINUE
SETLBL   MVC   NAME,LBLNAME            LABEL ENTRY NAME TO INSTR
         MVC   CONLEN,LBLLEN           SET CONSTANT LENGTH IN CASE
ISTPLBL  DS    0H                      GET TEMP COPY OF LABEL TAB ENT
         AHI   R6,LABELL               TO NEXT LABEL TBL ENTRY     @25C
         CLM   R6,7,LBLADR             THIS ENTRY SAME ADDR
         JNE   ICKTBL                  NO
         AHI   R6,-LABELL              BACK UP TO 1ST ENTRY        @25C
         JAS   R9,EQUSTMT              GO BUILD EQU STATEMENT
         AHI   R6,LABELL               TO NEXT ENTRY               @25C
         J     ICKTBL             GO CHECK NEXT LABEL FOR NEXT INSTR
NOILBL   CLI   CONPROG,1               CONSTANT IN PROGRESS
         JNE   MVMNE                   NO
         JAS   R9,FORCONST             YES, FORCE IT OUT
MVMNE    MVC   MNEMONIC,0(R8)          SET INSTR MNEMONIC
         CLI   MNEMONIC,C'?'           UNDOC OP ??                 @13A
         JNE   DOCOP                   BRANCH IF DOC OP            @13A
         MVC   COMMENT(L'S17),S17      SET COMMENT UNDOC OPCODE    @13A
DOCOP    MVC   OFFSET,TXTOFSET         SET OFFSET
         MVC   INSTYP,6(R8)            SET INSTR TYPE              @21C
         MVI   TYPE,X'0D'              SHOW IT IS AN INSTRUCTION
         MVC   LEN,ILENG+1             SHOW LENGTH
         MVC   TEXT(6),0(R7)           MOVE ACTUAL TEXT
*        TM    ICLASS,FLTPT            FLOATING POINT OP-CODE      @17D
*        JO    FPVERFY                 YES, GO VERIFY              @17D
         CLI   IEDT,0                  ANY EDIT REQUIRED
         JE    PFMFMT                  NO
*        J     IVERFY                  YES, GO EDIT                @15D
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED FROM THE INSTR ROUTINE FOR NON FLOATING*
* POINT INSTRUCTIONS. VARIOUS EDITS ARE PERFORMED TO INSURE THE  *
* INPUT TEXT BYTE IS AN OP-CODE. IF IT IS, RETURN IS TO LABEL    *
* PFMFMT, OTHERWISE THE CONST ROUTINE IS PERFORMED.              *
*                                                                *
******************************************************************
*
IVERFY   EQU   *                       *** VERIFY POSSIBLE INSTRUCTION
         TM    IEDT,EPR                EVEN-ODD REG PAIR
         JZ    IVE2                    NO
         TM    1(R7),X'10'             R1 IS ODD
         JO    CONST                   YES, NOT INSTR
         CLI   0(R7),X'0E'             IS IT MVCL
         JE    IVTRG2                  YES
         CLI   0(R7),X'0F'             IS IT CLCL
         JNE   IVE2                    NO
IVTRG2   TM    1(R7),X'01'             R2 IS ODD
         JO    CONST                   YES, NOT INSTR
         SR    R1,R1                   CLEAR WORK
         SR    R2,R2                   CLEAR WORK
         IC    R1,1(R7)                GET R1R2
         SRL   R1,4                    SHIFT OUT R2
         PACK  DBLWD(1),1(1,R7)        FLIP R1R2 BYTE
         IC    R2,DBLWD                PICK UP R2R1
         SRL   R2,4                    SHIFT OUT R1
         CR    R1,R2                   R1=R2
         JE    CONST                   YES, NOT INSTR
         J     PFMFMT                  NO, GOOD INSTR
IVE2     TM    IEDT,E2                 HALFWORD STORAGE ALIGNMENT
         JZ    IVE4                    NO
         TM    3(R7),X'01'             DISPL IS ODD
         JZ    IVES2                   NO, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         JNZ   IVES2                   NO, CONTINUE
         CLI   0(R7),X'44'             EX OP CODE
         JE    CONST                   YES, NOT INSTR
         CLI   ITYPE,RS                RS INSTRUCTION
         JE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG IS 0
         JZ    CONST                   YES, NOT INSTR
         J     IVES2                   CONTINUE
IVE4     TM    IEDT,E4                 2ND OPND ON FULLWORD BOUND
         JZ    IVE8                    NO
         TM    3(R7),X'03'             DISPL DIV BY 4
         JZ    IVES2                   YES, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         JNZ   IVES2                   NO, CONTINUE
         CLI   ITYPE,RS                RS INSTRUCTION OP CODE
         JE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG = 0
         JZ    CONST                   YES, NOT INSTR
         J     IVES2                   NO, CONTINUE
IVE8     TM    IEDT,E8                 2ND OPND ON DBLWD BOUND
         JZ    IVES2                   NO
         TM    3(R7),X'07'             DISPL DIV BY 8
         JZ    IVES2                   YES, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         JNZ   IVES2                   NO
         TM    1(R7),X'0F'             INDEX REG = 0
         JZ    CONST                   YES, NOT INSTR
IVES2    CLI   PRIVASM,1               PRIVILEGED INSTR O.K.
         JE    PFMFMT                  YES
         TM    IEDT,S2                 OPND2 MUST HAVE BASE
         JZ    IVES1                   NO
         TM    2(R7),X'F0'             BASE REG = 0
         JNZ   PFMFMT                  NO, O.K.
         CLI   ITYPE,RS                RS INSTRUCTION
         JE    CONST                   YES, NOT INSTR
         CLI   0(R7),X'92'             IS IT MVI OP CODE
         JE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG = 0
         JZ    CONST                   YES, NOT INSTR
         J     PFMFMT                  NO, GOOD INSTR
IVES1    TM    IEDT,S1                 1ST OPND MUST HAVE BASE
         JZ    PFMFMT                  NO, CONTINUE
         TM    2(R7),X'F0'             1ST OPND HAS BASE
         JZ    CONST                   NO, NOT INSTR
PFMFMT   SR    R1,R1                   CLEAR WORK
         TM    IEDT,T8                                             @12A
         JNO   NOTTST                                              @12A
         CLC   ILTR15,0(R7)            LTR R15,R15                 @12A
         JNE   NOTTST                  BRANCH IF NO                @12A
         MVC   COMMENT(L'S09),S09      SET COMMENT TO TEST RC      @12A
NOTTST   SR    R1,R1                   CLEAR R1 FOR IC INSTR       @23C
         IC    R1,INSTYP               GET INSTRUCTION TYPE        @23C
         MVC   INSTENT,0(R8)           COPY INSTUCTION TABLE ENTRY @23A
         LARL  R15,OPNDCTL             R15= ADDRESS OF OPNDCTL     @13A
         AR    R15,R1                  R1 = ADDRESS OF FMT RTN     @13A
         BR    R15                     BRANCH TO INSTR FMT RTN     @13C
OPNDCTL  J     RROPND                  TYPE=0, RR
         J     RXOPND                  TYPE=4, RX
         J     SOPND                   TYPE=8, S
         J     SIOPND                  TYPE=C, SI
         J     RSOPND                  TYPE=10, RS
         J     SS1OPND                 TYPE=14, 1-LENGTH SS
         J     SS2OPND                 TYPE=18, 2-LENGTH SS
         J     SOPND                   TYPE=1C, 2-BYTE OP-CODES
         J     BCOPND                  TYPE=20, CONDITIONAL BRANCH
         J     SVCOPND                 TYPE=24, SVC
         J     INSTOUT                 TYPE=28, RRE 0              @20C
         J     RRE1OPND                TYPE=2C, RRE 1              @02A
         J     RRE2OPND                TYPE=30, RRE 2              @02A
         J     SSEOPND                 TYPE=34  SSE                @02A
         J     SS3OPND                 TYPE=38, SSE                @04A
         J     RI1OPND                 TYPE=3C, RI BRANCH          @13A
         J     RI2OPND                 TYPE=40, RI                 @13A
         J     RIL1OPND                TYPE=44, RIL RELATIVE OFSET @13A
         J     RIL2OPND                TYPE=48, RIL                @13A
         J     RSIOPND                 TYPE=4C, RSI                @13A
         J     RSEOPND                 TYPE=50, RSE                @13A
         J     RXOPND                  TYPE=54, RXY                @13A
         J     RSOPND                  TYPE=58, RSY                @13A
         J     SS4OPND                 TYPE=5C, SS4                @13A
         J     RXOPND                  TYPE=60, RXE                @13A
         J     EOPND                   TYPE=64, EXTEND             @02A
         J     SSFOPND                 TYPE=68, SSF                @21A
         J     SILOPND                 TYPE=6C, SIL                @21A
         J     SIYOPND                 TYPE=70, SIY                @21A
         J     RRFAOPND                TYPE=74, RRFA               @30A
         J     RRFBOPND                TYPE=78, RRFB               @30A
         J     RRFCOPND                TYPE=7C, RRFC               @30A
         J     RRFCOPND                TYPE=80, RRFD               @30A
         J     RRFEOPND                TYPE=84, RRFE               @30A
         J     RSOPND                  TYPE=88, RSY2               @22A
         J     RIEOPND                 TYPE=8C, RIE                @28A
         J     RSOPND                  TYPE=90, RSL 1              @28A
         J     RSOPND                  TYPE=94, RSL 2              @28A
         J     RSOPND                  TYPE=98, RSA                @30A
OPNDRTN  J     INSTOUT                 NORMAL OPERAND FORMAT RETURN
NOTINST  CLC   NAME,BLANX              IS NAME FILLED IN?
         JE    CONST
         AHI   R6,-LABELL              BACK UP                     @25C
         J     CONST
INSTOUT  CLI   COL72,C' '              COL72 IS BLANK ??           @18A
         JE    INSTOUT3                BRANCH IF YES               @18A
         MVI   COMMENT,C' '            CLEAR COMMENT FIELD         @18A
         MVC   COMMENT+1(L'COMMENT-1),COMMENT                      @18A
         MVC   SECOND_LINE,COL72                                   @18A
         MVI   COL72,C'X'              MOVE NONBLANK TO COL 72     @18A
         MVC   WORKREC+72(8),BLANX     CLEAR SEQUENCE NUMBER       @18A
         JAS   R9,WRTOUT      WRITE INSTRUCTION RECORD (SYSPUNCH)  @18A
         JAS   R9,TXTFMT               FORMAT HEX DATA             @18A
         JAS   R9,PRINT                GO PRINT IT TO SYSPRINT     @18A
         MVI   WORKREC,C' '                                        @18A
         MVC   WORKREC+1(L'WORKREC-1),WORKREC                      @18A
         MVC   WORKREC+15(56),SECOND_LINE                          @18A
         CLI   WORKREC+46,C' '                                     @22A
         JNE   INSTOUT2                                            @22A
         MVC   WORKREC+46(25),CCOMMENT      COPY COMMENT           @22A
INSTOUT2 JAS   R9,WRTOUT         WRITE INSTRUCTION RECORD (SYSPUNCH)
         JAS   R9,PRINT                GO PRINT IT TO SYSPRINT
         J     INSTOUT5
INSTOUT3 JAS   R9,WRTOUT         WRITE INSTRUCTION RECORD (SYSPUNCH)
         JAS   R9,TXTFMT               FORMAT HEX DATA
         JAS   R9,PRINT                GO PRINT IT TO SYSPRINT
INSTOUT5 AH    R7,ILENG                STEP TO NEXT TEXT BYTE
         MVI   WORKREC2,C' '           CLEAR WORKREC2              @18A
         MVC   WORKREC2+1(L'WORKREC2-1),WORKREC2                   @18A
HEX4RET  ST    R7,TXTCURR        SAVE NEXT ADDR
         CLI   ICCSET,X'00'                                        @17A
         JE    GETCURR           BRANCH IF YES                     @17A
         MVC   CCTYPE,ICCSET     SHOW COND CODE SET TYPE
         J     GETCURR           CONTINUE TXT PROCESSING
*
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED FROM THE INSTR ROUTINE FOR FLOATING    *
* POINT INSTRUCTIONS. VARIOUS EDITS ARE PERFORMED TO INSURE THE  *
* INPUT TEXT BYTE IS AN OP-CODE. IF IT IS, RETURN IS TO LABEL    *
* PFMFMT, OTHERWISE THE CONST ROUTINE IS PERFORMED.              *
*                                                                *
******************************************************************
*
FPVERFY  EQU   *                       *** VALIDATE FLOATING POINT OP-C
         TM    1(R7),X'90'             R1 IS 0, 2, 4, OR 6
         JNZ   CONST                   NO, NOT INSTR
         CLI   0(R7),X'27'             MXDR OP-CODE
         JE    FPR1EXT                 YES
         CLI   0(R7),X'67'             MXD OP-CODE
         JNE   FPCKTYP                 NO
FPR1EXT  TM    1(R7),X'B0'             R1 IS 0 OR 4
         JNZ   CONST                   NO, NOT INSTR
FPCKTYP  CLI   ITYPE,RR                RR TYPE INSTRUCTION
         JNE   FPRXVER                 NO
         CLI   0(R7),X'25'             LRDR OP CODE
         JE    FPR2EXT                 YES
         CLI   0(R7),X'37'             SXR OP-CODE
         JE    FPR2EXT                 YES
         CLI   0(R7),X'26'             MXR OP-CODE
         JE    FPR2EXT                 YES
         CLI   0(R7),X'36'             AXR OP-CODE
         JNE   PFMFMT                  NO, GOOD INSTR
FPR2EXT  TM    1(R7),X'0B'             R2 IS 0 OR 4
         JZ    PFMFMT                  YES, GOOD INSTR
         J     CONST                   NO, NOT INSTR
FPRXVER  CLI   PRIVASM,1               PRIVILEGED INSTRUCTIONS O.K.
         JE    FPALIGN                 YES
         TM    2(R7),X'F0'             ANT BASE REG
         JNZ   FPALIGN                 YES
         TM    1(R7),X'0F'             ANY INDEX REG
         JZ    CONST                   NO, NOT INSTR
FPALIGN  TM    2(R7),X'F0'             ANY BASE REG
         JNZ   PFMFMT                  YES, ACCEPT INSTR
         TM    1(R7),X'0F'             ANY INDEX REG
         JNZ   PFMFMT                  YES, ACCEPT INSTR
         TM    3(R7),X'03'             DISPL DIV BY 4
         JNZ   CONST                   NO, NOT INSTR
         CLI   ICLASS,FLSHT            SHORT PRECISION            @20A
         JE    PFMFMT                  YES, ACCEPT INSTRUCTION    @20A
         TM    3(R7),X'07'             DISPL DIV BY 8
         JZ    PFMFMT                  YES, ACCEPT INSTR
         J     CONST                   NO, NOT INSTR
*
*******************************************************************
*                                                                 *
* THIS ROUTINE IS ENTERED FROM VARIOUS OTHER ROUTINES WHEN THE    *
* CURRENT TEXT BYTE IS DETERMINED NOT TO BE AN INSTRUCTION OP     *
* CODE. A CONSTANT AREA IS BUILT TO CONTAIN THE CONSTANT, IT'S    *
* DATA TYPE, SYMBOL TO BE USED FOR ADCONS, LABEL TO BE USED, IF   *
* ANY, ETC. THE CONSTANT IS BUILT BYTE BY BYTE, AND IS TERMINATED *
* FOR OUTPUT BY THE FORCONST ROUTINE. THIS ROUTINE DETECTS END OF *
* CONSTANT WHEN THE CONSTANT IN PROGRESS EXCEEDS 2 BYTES FOR A    *
* HALFWORD, 4 BYTES FOR A FULLWORD, OR 48 BYTES AS A MAXIMUM. IT  *
* IS ALSO TERMINATED WHEN A CHANGE IN DATA TYPE OCCURS.           *
* IE MAXLEN   EQU 48                                              *
*******************************************************************
*
CONST    DS    0H                      *** PROCESS CONSTANTS ***
**       LA    R11,CONDATA    *DEBUG*  GET 1ST DATA BYTE ADDR      @28A
**       ST    R11,CONLOC     *DEBUG*  SET STARTING ADDRESS OF DATA@28A
         MVI   WORKREC,C' '            CLEAR WORK RECORD AREA
         MVC   WORKREC+1(L'WORKREC-1),WORKREC
         CLI   CONPROG,1               CONSTANT IN PROGRESS
         JNE   CCNEW                   NO
         CLC   TXTOFSET,LBLADR+40      LABEL+2 ENTRY               @30A
         JE    CSTNEW2                 YES                         @30A
         CLC   TXTOFSET,LBLADR         LABEL ENTRY HAS THIS OFFSET
         JNE   CGETYP                  NO
******** DATA TYPE CHANGE AND FORCE IT OUT ********************
CSTNEW   JAS   R9,FORCONST             FORCE IT OUT
         J     CCNEW                   GO START A NEW ONE
CSTNEW2  AHI   R6,40                   POINT TO LABEL+2            @30A
         J     CSTNEW                                              @30A
CGETYP   TRT   0(1,R7),MIXCTRAN        CHECK DATA TYPE OF BYTE     @16C
         JZ    CCONCAT                 BRANCH IF MIXCASE           @18A
         CLI   CONTYPE,C'X'            TYPE CHANGE ??              @18C
         JNE   CSTNEW                  NO                          @13C
******** CONCAT STRING  ***************************************
CCONCAT  DS    0H                      GET CURRENT LENGTH
*        TM    TXTOFST+3,1             ODD ADDRESS                 @28C
*        JO    CCN7FFF                 YES, SKIP
         CLC   X_7FFF,0(R7)            X'7FFFFFFF'                 @28A
         JE    CONST4                  YES, NOT INSTR              @28A
CCN7FFF  LH    R11,CONLEN              GET CURRENT LENGTH
         AHI   R11,1                   ADD 1
         STH   R11,CONLEN              UPDATE LENGTH
         L     R11,CONLOC              GET CURRENT LOC IN CONST DATA
         MVC   0(1,R11),0(R7)          MOVE BYTE TO DATA
         AHI   R11,1                   STEP OVER ONE BYTE
         ST    R11,CONLOC              SAVE UPDATED DATA ADDR
         CLI   CONTYPE,C'C'            CHARACTER CONSTANT
         JE    CCLNCHK                 YES CHECK CONSTANT LENGTH
**       TM    CONOFST+3,1             OFFSET IS ODD
**       JO    CCFIN1                  YES
         TM    CONOFST+3,2             HALFWORD OFFSET ??
         JZ    CCFWD                   BRANCH IF NOT HALFWORD CONST
         CLI   CONLEN+1,1              HALFWORD, IS LENGTH = 1
         JE    CCXIT1                  YES
         J     CCFIN1                  NO
CCFWD    CLI   CONLEN+1,4              NO, IS HEX CONST 4 BYTES
         JL    CCXIT1                  NOT YET
CCFIN1   JAS   R9,FORCONST             MAX LENG, FORCE IT OUT
         J     CCXIT1                  FINISH
CCLNCHK  CLI   CONLEN+1,MAXLEN         CONSTANT LENGTH < 48        @15C
         JNL   CCFIN1                  YES IF >= 48
CCXIT1   AHI   R7,1                    STEP OVER 1 BYTE IN TEXT
         ST    R7,TXTCURR              UPDATE TEXT ADDR
         J     GETCURR                 CONTINUE TEXT PROCESSING
CCNEW    MVI   CONPROG,1               SHOW CONSTANT IN PROGRESS
         MVC   CONOFST,TXTOFST         SET OFFSET TO 1ST BYTE
         MVC   CONNAME,BLANX           CLEAR NAME
         XC    CONDATA,CONDATA         CLEAR DATA AREA
         MVC   CONSYM,BLANX            CLEAR SYMBOL NAME
         MVC   CONLEN,XZROS            CLEAR LENGTH
         LA    R11,CONDATA             GET 1ST DATA BYTE ADDR
         ST    R11,CONLOC              SET STARTING ADDRESS OF DATA
         CLC   TXTOFSET,LBLADR         LABEL AT THIS OFFSET
         JE    CLBLD                   YES
*RTYPE   TRT   0(1,R7),MIXCTRAN        CHECK DATA TYPE OF BYTE     @16C
TRTYPE   TRT   0(2,R7),MIXCTRAN        2 BYTES ARE CHAR STRING     @31C
*        JNZ   CCSHX                   BRANCH IF HEXI STRING       @31D
         JNZ   CCSHX1                  BRANCH IF HEXI STRING       @31C
         MVI   CONTYPE,C'C'            IT'S CHAR, SO INDICATE
         J     CCONCAT                 GO COMPLETE
CCSHX1   CLIY  -4(R6),1                LBLLEN = 1 ?                @31C
         JNE   CCSHX2                  BRANCH IF LBLLEN NE 1       @31A
         TRT   0(1,R7),MIXCTRAN        CHECK 1 BYTE IS CHAR STRING @31A
         JNZ   CCSHX2                  BRANCH IF HEXI STRING       @31A
         MVI   CONTYPE,C'C'            IT'S CHAR, SO INDICATE      @31A
         J     CCONCAT                 GO COMPLETE                 @31A
CCSHX2   MVI   CONTYPE,C'X'            IT'S HEX, SO INDICATE       @31C
         J     CCONCAT                 GO COMPLETE
CLBLD    CLI   LBLTYP,C'L'             IS IT A LABEL ONLY
         JNE   CDATACON                NO
         MVC   CONNAME,LBLNAME         NAME TO CONSTANT WORK AREA
         MVC   CONLLEN,LBLLEN          SAVE LENGTH
         AHI   R6,LABELL               TO NEXT LABEL ENTRY         @25C
         CLC   TXTOFSET,LBLADR         THIS LABEL AT SAME ADDR
         JNE   TRTYPE                  NO
         CLI   LBLTYP,C'L'             THIS ANOTHER LABEL ONLY
         JNE   CDATACON                NO
         AHI   R6,-LABELL              BACK UP TO LABEL ENTRY      @25C
         JAS   R9,EQUSTMT              GO BUILD EQU STATEMENT
         AHI   R6,LABELL               TO NEXT LABEL ENTRY         @25C
         J     CCNEW                   GO TO NEXT LABEL
CDATACON MVC   CONTYPE,LBLTYP          TYPE TO CONSTANT AREA
         SR    R1,R1                   CLEAR WORK
         IC    R1,LBLLEN               PICK UP CONSTNT LENGTH
         STH   R1,CONLEN               SAVE CONSTANT LENGTH
         CHI   R1,44
         JL    GOODLEN
CRASH    DC    X'0000'        *** DEBUG **
GOODLEN  DS    0H
         AHI   R1,-1                   MINUS ONE FOR EXECUTE
         EX    R1,MCD                  MVC   CONDATA(1),0(R7)
         MVC   CONSYM,LBLNAME          SYMBOL TO CONSTANT AREA
         SR    R11,R11                 CLEAR WORK REG
         IC    R11,LBLLEN              PICK UP LENGTH
         AR    R7,R11                  STEP PAST TEXT
         ST    R7,TXTCURR              UPDATE TEXT ADDRESS
         JAS   R9,FORCONST             FORCE CONSTANT OUT
         AHI   R6,LABELL               STEP TO NEXT LABEL ENTRY    @25C
         J     GETCURR                 CONTINUE TEXT PROCESS
CONST4   MVI   CONLEN+1,4              SET CONLEN TO 4             @28A
         MVI   CONLLEN,4               SET CONLLEN TO 4            @28A
         MVI   CONTYPE,C'X'            SET CONTYPE TO 4            @28A
         MVC   CONDATA(4),0(R7)                                    @28A
         MVI   CONPROG,1               CONSTANT IN PROGRESS        @28A
         MVC   CONOFST,TXTOFST                                     @28A
         JAS   R9,FORCONST             FORCE CONSTANT OUT          @28A
         AHI   R7,4                                                @28A
         ST    R7,TXTCURR              UPDATE TEXT ADDRESS         @28A
         J     GETCURR                                             @28A
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED BY VARIOUS ROUTINES WHEN IT IS         *
* NECESSARY TO WRITE THE CONSTANT CURRENTLY IN PROGRESS, AND     *
* CLEAR FIELDS FOR THE NEXT CONSTANT TO BE CREATED.              *
* INPUT : CONLEN (LENGTH OF CONSTANT)                            *
*         CONTYPE, CONDATA AND CONNAME                           *
******************************************************************
*
FORCONST DS    0H                   *** FORCE OUT CONSTANT IN PROGRESS
         ST    R9,FC9                  SAVE RETURN ADDR
         CLC   CONNAME,BLANX           ANY LABEL NAME SET UP
         JE    CKCNPRG                 NO, CONTINUE
         CLC   CONLLEN,CONLEN+1        SAME LENGTH ?
         JE    CKCNPRG                 YES, CONTINUE
         ST    R6,FC6                  SAVE LABEL TABLE ADDR
         LA    R6,CONPSLBL             @ PSEUDO LABEL ENTRY
         CLI   CONTYPE,C'C'
         JNE   CHKEQU
         CLI   LBLLEN,MAXLEN           LENGTH > MAXIMUM LENGTH     @15A
         JL    SKIPEQU                 BRANCH IF LOWER             @15A
         CLI   CONTYPE,C'V'     DEBUG
         JE    SKIPEQU          DEBUG
CHKEQU   CLI   LBLLEN,5
         JL    SKIPEQU
         JAS   R9,EQUSTMT              GO BUILD EQU STATEMENT
         MVC   CONNAME,BLANX           CLR STATEMENT LABEL FIELD
SKIPEQU  MVC   CONNAME,LBLNAME         NAME TO EQU STMT            @15C
         L     R6,FC6                  RESTORE LABEL TABLE POINTER
CKCNPRG  CLI   CONPROG,1               CONSTANT IN PROGRESS
         JNE   FCCLR                   NO
         CLI   CONLEN+1,0              ANY DATA LENGTH
         JE    FCCLR                   NO
         XC    TEXT,TEXT               CLEAR TEXT FIELD
         CLI   CONNAME+8,X'00'                                     @24A
         JE    NORLABEL                JUMP IF NORMAL LABEL        @24A
         CLI   CONNAME+8,X'40'                                     @24A
         JE    NORLABEL                JUMP IF NORMAL LABEL        @24A
         MVC   MNEMONIC+4(2),S_DC      SET MNEMONIC DC             @24A
         MVC   NAME(L'CONNAME),CONNAME NAME TO RECORD              @24A
         LA    R14,OPNDS+2                                         @25A
         J     CKCONT                                              @24A
NORLABEL MVC   MNEMONIC(2),S_DC        SET MNEMONIC DC
         MVC   NAME,CONNAME            NAME TO RECORD
         LA    R14,OPNDS                                           @25A
CKCONT   MVC   0(1,R14),CONTYPE        SET TYPE                    @25C
         MVI   1(R14),C''''            OPERAND DELIMITER
         MVC   OFFSET,CONOFST+1        OFFSET TO RECORD
         MVI   INSTYP,0                NOT AN INSTRUCTION
         MVI   TYPE,2                  NON-ADDRESS CONSTANT
         MVC   LEN,CONLEN+1            GET DATA LENGTH
         LH    R11,CONLEN              DATA LENGTH
         BCTR  R11,R0                  MINUS DATA LENGTH FOR MOVE
         EX    R11,FMCON               MVC   TEXT(1),CONDATA
         CLI   CONTYPE,C'C'            CHARACTER TYPE
         JE    FCHAR                   YES
         CLI   CONTYPE,C'X'            HEX TYPE
         JNE   FSYMBOL                 NO
         TM    CONLEN+1,1              LENGTH IS ODD
         JO    FHEX                    YES FORMAT AS HEX
         CLI   CONLEN+1,2              HALF WORD ?                 @28A
         JE    FHWD2                   BRANCH IF YES               @28A
         TM    CONOFST+3,2             OFFSET DIVISIBLE BY 4
         JO    FHWD2                   NO FORMAT AS HALF WAORD     @15A
         CLI   CONLEN+1,4              IS IT 4-BYTES
         JNE   FHWD                    NO, JUST HALFWORD
         CLC   CONDATA(4),XZROS        CONSTANT IS ALL ZEROS
         JNE   FFCKNEG                 NO
         MVC   OPNDS(4),SF00           BUILD OPERANDS  F'0'
         J     FCWRT                   CONTINUE
FFCKNEG  DS    0H
         ICM   R11,15,CONDATA          GET DATA
         JM    FHEX                    NEG, TREAT AS HEX
         C     R11,F50000              VALUE EXCEEDS 50,000
         JH    FHEX                    YES, TREAT AS HEX
         TM    CONOFST+3,1             OFFSET                      @29A
         JO    FHEX3                   NO FORMAT AS HEX            @29A
         MVC   0(2,R14),SFAPO          OPERAND DATA TYPE IS F'     @26C
         CVD   R11,DBLWD               CONVERT VALUE TO PACKED
         UNPK  2(5,R14),DBLWD+5(3)     UNPACK INTO OPERAND         @26C
         OI    6(R14),C'0'             SET SIGN = F                @26C
         MVI   7(R14),C''''            ENDING QUOTE                @26C
         J     FCWRT                   CONTINUE
FHEX3    LR    R12,R7                                              @29A
         AHI   R12,-3                                              @29A
         MVC   0(2,R14),SXAPO          Type and begin quote X'     @29A
         JAS   R9,HEXPRT3              Convert to printable        @29A
         MVC   2(6,R14),PRTABL         Get rest of name            @29A
         MVI   8(R14),C''''            Ending quote                @29A
         BCTR  R7,0                                                @29A
         MVI   LEN,3                                               @29A
         J     FCWRT                   CONTINUE                    @29A
FHWD     DS    0H                                                  @15C
         CLI   LBLLEN,4                LABEL IS 4 BYTES ??         @15A
         JE    FHEX4                   BRANCH IF YES               @15A
FHWD2    LH    R11,CONDATA             PICK UP HALFWORD            @15C
         LTR   R11,R11                 TEST CONSTANT VALUE
         JM    FHEX                    NEGATIVE, TREAT AS HEX
         JNZ   FHCMAX                  NOT ZERO, CHECK MAX VALUE
         MVC   OPNDS(4),SH00           SET OPERAND FOR ZERO H'0'
         J     FCWRT                   CONTINUE
FHCMAX   DS    0H                      FOMAT HALF WORD             @28A
*        CLI   CONLLEN,4                                           @28A
*        JE    FCONST4                                             @28A
         CHI   R11,4096                VALUE EXCEEDS 4,096         @28C
         JH    FHEX                    YES, TREAT AS HEX
         CVD   R11,DBLWD               CONVERT TO PACKED
         OI    DBLWD+7,X'0F'           CLEAR SIGN TO F
         MVC   0(2,R14),SHAPO          SET DELIMITER IN OPERAND H' @28C
         UNPK  2(4,R14),DBLWD+5(3)     UNPACK VALUE TO OPERAND     @28C
         MVI   6(R14),C''''            ENDING DELIMITER            @28C
         J     FCWRT                   CONTINUE
FCHAR    MVC   0(2,R14),SCAPO   OPERAND DELIMITER FOR CHARACTER C' @25C
         CLI   NAME,C'A'               LABEL NAME EXIST            @15A
         JNE   FCHARC                  BRANCH IF NO LABEL          @15A
         LR    R12,R6                  POINT TO CURRENT LABEL      @15A
         AHI   R12,-LABELL             POINT TO PREVIOUS LABEL     @25C
         CLI   LBLLEN-LABELD(R12),4    PREVIOUS LBLLEN = 4 ??      @25C
         JNE   FCHARC                  BRANCH IF NOT 4             @15A
         LR    R12,R7                                              @15A
         SH    R12,CONLEN              LOCATE THE TEXT             @15A
*        TRT   0(4,R12),CHARTRAN       CONSECUTIVE 4 BYTES IS HEX  @16A
         TRT   0(4,R12),MIXCTRAN       CONSECUTIVE 4 BYTES IS HEX  @16A
         JNZ   FHEX4C                  BRANCH IF HEX               @16A
FCHARC   LH    R11,CONLEN              GET DATA LENGTH
         AHI   R11,-1                  MINUS LENGTH CODE BY 1 FOR MOVE
         EX    R11,FMCNT               MVC   2(1,R14),CONDATA
         LA    R11,3(R11,R14)          STEP PAST OPERAND DATA      @25C
         MVI   0(R11),C''''            ENDING QUOTE '
         J     FCWRT                   CONTINUE
FSYMBOL  CLC   CONSYM,BLANX            IS IT BLANK
         JE    FHEX                    YES, TREAT AS HEX
         CLI   CONTYPE,C'V'            VCON ?                      @27A
         JE    FCOPND4                 BRANCH IF YES               @27A
         CLI   CONLEN+1,8              IS IT 8-BYTES               @28A
         JE    FDBLADDR                YES, 8 BYTES AD             @28A
         CLI   CONLEN+1,4              LENGTH IS 4
         JH    FHEX                    NO, GREATER
         JE    FCOPND4                 YES, 4 BYTES
         CLI   CONLEN+1,3              LENGTH IS 3
         JE    FCOPND3                 YES
         CLI   CONLEN+1,2              LENGTH IS 2
         JE    FCOPND2                 YES
         MVC   OPNDS+1(2),SL1          OPND LENGTH L1
         J     FSLHE1                  CONTINUE
FCOPND2  MVC   OPNDS+1(2),SL2          OPND LENGHT L2
         J     FSLHE1                  CONTINUE
FCOPND3  MVC   OPNDS+1(2),SL3          OPND LENGTH L3
         J     FSLHE1                  CONTINUE
FCOPND4  LA    R11,1(R14)              STEP TO ( POS               @27C
         J     FSLHE                   CONTINUE
FSLHE1   LA    R11,3(R14)              STEP TO ( POS               @27C
FSLHE    MVI   0(R11),C'('             DELIMITER
         MVC   1(8,R11),CONSYM         SYMBOL TO RECORD
         CLI   CONSYM,C'V'             VCON  ???                   @13A
         JNE   CHKHIGH                 YES CHECK HIGH ORDER BIT    @13A
         CLI   CONSYM,C'A'             ADCON ???                   @13A
         JNE   NOT_LAST_PARM           BRANCH IF NOT ADCON ??      @13A
CHKHIGH  LR    R15,R7                                              @13A
         AHI   R15,-4                  POINT TO PREVIOUS 4 BYTES   @13A
         TM    0(R15),X'80'            LAST PARAMETER ??           @13A
         JNO   NOT_LAST_PARM        BRANCH IF HIGH ORDER BIT OFF   @13A
         CLC   S_AL3,OPNDS             'AL3' ?                     @13A
         JE    NOT_LAST_PARM           BRANCH IF AL3               @13A
         CLC   S_A0,1(R11)             A(A0xxxxx)                  @22A
         JNE   SETLOPND                BRANCH IF NOT EQUAL         @22A
SETSOPND MVC   8(12,R11),HIGHBITO      +X'80000000'                @22A
         J     FCEOPND                                             @13A
SETLOPND CLI   8(R11),C' '                                         @22A
         JE    SETSOPND                BRANCH IF EQUAL             @22A
         MVC   9(12,R11),HIGHBITO      +X'8000000                  @13A
FCEOPND  AHI   R11,21                  POINT TO END OF OPERAND     @13A
         J     FRHE                                                @13A
NOT_LAST_PARM  DS  0H                                              @13A
         AHI   R11,9                   @ RHE SYMBOL IN OPERAND
FRHE     CLI   0(R11),C' '             CHARACTER IS BLANK
         JNE   SETRPAR                 NO
         JCT   R11,FRHE                LOOP TO FIND RHE
SETRPAR  MVI   1(R11),C')'             SET CLOSING PAREN
         J     FCWRT                   CONTINUE
FCONST4  LR    R12,R7                                              @28A
         SH    R12,CONLEN                                          @28A
         MVC   NAME,CONNAME                                        @28A
         XC    CONLEN,CONLEN                                       @28A
         J     FHEX4X                  CONTINUE                    @28A
FHEX4    LR    R12,R7                  @ CONSTANT DATA             @15A
         SH    R12,CONLEN                                          @15A
FHEX4C   LA    R11,OPNDS                                           @26A
FHEX4X   MVC   0(2,R14),SXAPO          TYPE AND BEGIN QUOTE X'     @26C
         JAS   R9,HEXPRT4              CONVERT TO PRINTABLE        @15A
         MVC   2(8,R14),PRTABL                                     @26C
         MVI   10(R14),C''''           ENDING QUOTE '              @26C
         MVI   LEN,4                   SET LEN TO 4                @15A
         OI    FLAG1,FLGHEX4           TURN ON HEX4 FLAG           @15A
         J     FCWRT                   WRITE OUTPUT                @15A
FDBLADDR MVC   0(3,R14),S_ADBRC        OPERAND DATA TYPE IS AD(    @28A
         MVC   3(8,R14),LBLNAME        COPY LABEL                  @28A
         CLI   LBLNAME+7,C' '          8 CHARACTER LABEL ??        @28A
         JNE   FLABEL8                 BRANCH IF NO                @28A
         MVI   10(R14),C')'            ENDING BRACKET              @28A
         J     FCWRT                   CONTINUE                    @28A
FLABEL8  MVI   11(R14),C')'            ENDING BRACKET              @28A
         J     FCWRT                   CONTINUE                    @28A
FHEX     LA    R12,CONDATA             @ CONSTANT DATA
         MVC   0(2,R14),SXAPO          TYPE AND BEGIN QUOTE X'     @26C
         JAS   R9,HEXPRT4              CONVERT TO PRINTABLE
         LH    R12,CONLEN              GET DATA LENGTH
         SLL   R12,1                   DOUBLE DATA LENGTH
         AHI   R12,-1                  MINUS 1 FOR EX
         EX    R12,MVHX                MVC   2(1,R14),PRTABL
         LA    R12,2(R12,R14)          OPERAND END ADDRESS         @26C
         MVI   1(R12),C''''            ENDING QUOTE '
FCWRT    JAS   R9,WRTOUT               WRITE RECORD SYSPUNCH
         JAS   R9,TXTFMT               GO FORMAT HEX DATA
         JAS   R9,PRINT                GO PRINT IT SYSPRINT
FCCLR    MVI   CONPROG,0               RESET CONSTANT IN PROGRESS
         MVC   CONNAME,BLANX           CLEAR NAME
         MVI   CONTYPE,0               RESET TYPE
         XC    CONDATA,CONDATA         CLEAR CONSTANT DATA
         MVC   CONSYM,BLANX            CLEAR SYMBOL
         MVC   SAVLEN,CONLEN           SAVE CONLEN                 @15A
         XC    CONLEN,CONLEN           CLEAR LENGTH
         MVC   CONLOC,XZROS            CLEAR LOCATION
         MVC   CONOFST,XZROS           CLEAR OFFSET TO CONSTANT
         TM    FLAG1,FLGHEX4           HEX4 SWITCH IS ON ?         @15A
         JNO   FCRET                   BRANCH IF OFF               @15A
         NI    FLAG1,255-FLGHEX4       TURN OFF HEX4 FLAG          @15A
         LR    R12,R7                                              @15A
         SH    R12,SAVLEN              SAVE LENGTH                 @15A
         LA    R7,2(,R12)     ???                                  @28A
         J     HEX4RET                                             @15A
FCRET    L     R9,FC9                  GET RETURN ADDRESS
         BR    R9                      RETURN TO CALLER
*
******************************************************************
* THIS ROUTINE FORMATS RRE1-FORMAT INSTRUCTIONS FOR OUTPUT.      *
* IE   ONE OPERAND                                               *
******************************************************************
*
RRE1OPND DS    0H             *** RRE FORMAT INSTRUCTIONS ***      @20C
         SR    R1,R1                   CLEAR WORK                  @02A
         IC    R1,TEXT+3               GET FOURTH BYTE             @02A
         SRL   R1,4                    SHIFT OUT R2                @02A
         CVD   R1,DBLWD                CONVERT                     @02A
         OI    DBLWD+7,X'0F'           CLEAR SIGN                  @02A
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK                      @02A
         MVI   OPNDS,C'R'              BEGIN R1 OPERAND            @02A
         CHI   R1,10                   REG NBR > 9                 @02A
         JL    RRE11                   NO, 0-9                     @02A
         MVC   OPNDS+1(2),DBLWD        YES, 10-15                  @02A
         J     INSTOUT                 EXIT                        @02A
RRE11    MVC   OPNDS+1(1),DBLWD+1      MOVE REG NUMBER             @02A
         J     INSTOUT                 EXIT                        @02A
*
******************************************************************
* THIS ROUTINE FORMATS RRE2-FORMAT INSTRUCTIONS FOR OUTPUT.      *
* IE   TWO OPERAND2                                              *
******************************************************************
*
RRE2OPND DS    0H                   *** RRE2 FORMAT INSTRUCTIONS ***
         CLC   S_EREG,MNEMONIC         EREG OP ??                 @26A
         JE    SOPS29B                 BRANCH IF YES              @24A
         CLC   IBAKR,TEXT              IS IT BAKR R14,0 ??        @12A
         JNE   RRE2STRT                YES                        @12A
         MVC   COMMENT(L'S12),S12   SET COMMENT TO SAVE REGISTER  @12A
         J     RRE2STRT                                           @12A
SOPS29B  MVC   COMMENT(L'S29B),S29B    Extract stack registers    @24A
RRE2STRT SR    R1,R1                   CLEAR WORK                 @12A
         IC    R1,TEXT+3               GET FOURTH BYTE            @12A
         SRL   R1,4                    SHIFT OUT R2               @12A
         CVD   R1,DBLWD                CONVERT                    @12A
         OI    DBLWD+7,X'0F'           CLEAR SIGN                 @12A
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK                     @12A
         LA    R15,OPNDS               SET ACCESS REGISTERS       @13A
         CLI   ICLASS,AR2              AR2 INSTRUCTION ??         @22C
         JE    RRE2AR1                 BRANCH IF EQUAL            @22A
         CLI   ICLASS,AR1              AR1 INSTRUCTION ??         @21C
         JNE   RRE2GR1                 BRANCH IF NOT EQUAL        @13A
RRE2AR1  MVI   0(R15),C'A'             SET ACCESS REGISTERS       @13A
         AHI   R15,1                   TO NEXT POS                @13A
RRE2GR1  MVI   0(R15),C'R'             BEGINNING OPERAND 1        @13A
         AHI   R15,1                   TO NEXT POS                @13A
         CHI   R1,10                   REG NBR > 9                @13A
         JL    RRE211                  NO, 0-9                    @13A
         MVC   0(2,R15),DBLWD          YES, 10-15                 @13A
         AHI   R15,2                   TO NEXT POS                @13A
         J     RRE2CMA                 CONTINUE                   @13A
RRE211   MVC   0(1,R15),DBLWD+1        MOVE REG NUMBER            @13A
         AHI   R15,1                   TO NEXT POS                @13A
RRE2CMA  DS    0H                      TEST ANY SECOND OPERAND    @13A
         MVI   0(R15),C','                                        @13A
         AHI   R15,1                   TO NEXT POS                @13A
         CLI   ICLASS,AR2              AR2 INSTRUCTION ??         @22A
         JE    RRE2AR2                 BRANCH IF EQUAL            @22A
         CLI   ICLASS,AR3              AR3 INSTRUCTION ??         @21A
         JNE   RRE2GR3                 BRANCH IF NOT EQUAL        @13A
RRE2AR2  MVI   0(R15),C'A'             SET ACCESS REGISTERS       @13A
         AHI   R15,1                   TO NEXT POS                @13A
RRE2GR3  MVI   0(R15),C'R'             BEGINNING OPERAND 1        @13A
         AHI   R15,1                   TO NEXT POS                @13A
         PACK  DBLWD(1),TEXT+3(1)      FLIP 2ND BYTE              @13A
         SR    R1,R1                   CLEAR WORK                 @12A
         IC    R1,DBLWD                GET R2R1                   @12A
         SRL   R1,4                    SHIFT OUT R1               @12A
         CVD   R1,DBLWD                CONVERT                    @12A
         OI    DBLWD+7,X'0F'           CLEAR SIGN                 @12A
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK                     @12A
         CHI   R1,10                   R2 > 9                     @12A
         JL    RRE221                  NO, 0-9                    @12A
         MVC   0(2,R15),DBLWD          YES, MOVE REG 10-15        @12A
         J     RRE2EXIT                EXIT                       @22C
RRE221   MVC   0(1,R15),DBLWD+1        MOVE REG 0-9               @12A
RRE2EXIT TM    ICLASS,CDOR             IS IT CLEAR REGISTER OP    @22A
         JO    RRCLR0                  BRANCH IF YES              @22A
         CLC   ICPYA,TEXT              CPYA OP ??                 @26A
         JNE   INSTOUT                 BRANCH IF YES              @26A
         MVC   COMMENT(9),OPNDS        Copy CPYA operands         @26A
         CLI   COMMENT+3,C','                                     @26A
         JE    RRE2CPYA                                           @26A
         MVI   COMMENT+4,C'='          Replace ',' by '='         @26A
         J     INSTOUT                                            @26A
RRE2CPYA MVI   COMMENT+3,C'='          Replace ',' by '='         @26A
         J     INSTOUT                 EXIT                       @12A
*
******************************************************************
*                                                                *
* THIS ROUTINE FORMATS RR-FORMAT INSTRUCTIONS FOR OUTPUT.        *
*                                                                *
******************************************************************
*
RROPND   DS    0H                      *** RR FORMAT INSTRUCTIONS ***
         CLI   0(R7),X'0B'             IS IT BSM
         JE    RRAMODE
         CLI   0(R7),X'0C'             IS IT BASSM                @06A
         JE    RRBASR                                             @06A
         CLI   0(R7),X'0D'             IS IT BASR                 @06A
         JE    RRBASR                                             @06A
         CLI   0(R7),X'05'             IS IT BALR
         JNE   RRSTRT
RRBASR   CLI   1(R7),X'EF'             IS IT BALR 14,15
         JE    RRSTDL                  YES
         TM    1(R7),X'0F'             NO, IS R2 = 0
         JNZ   RRNSTD                  NO
         CLI   COMMENT,C' '            COMMENT EXIST ??           @31A
         JNE   RRSTRT                  BRANCH IF NOT BLANK        @31A
         MVC   COMMENT(11),S01         SET COMMENT TO ADDRESS SET
         J     RRSTRT                  CONTINUE
RRAMODE  MVC   COMMENT(20),S02         BRANCH AND SET AMODE
         CLI   1(R7),X'0E'
         JNE   RRSTRT
         MVC   COMMENT(L'S03),S03      RETURN AND SET AMODE
         J     RRSTRT                  CONTINUE
RRSTDL   CLI   COMMENT,C' '                                        @31A
         JNE   RRSTRT                                              @31A
         MVC   COMMENT(7),S05          SET COMMENT TO LINKAGE
         J     RRSTRT                  CONTINUE
RRNSTD   MVC   COMMENT(14),S04         SET COMMENT TO NONSTD LINKAGE
RRSTRT   SR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               GET 2ND BYTE
         SRL   R1,4                    SHIFT OUT R2
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         MVI   OPNDS,C'R'              BEGIN R1 OPERAND
         CHI   R1,10                   REG NBR > 9
         JL    RR11                    NO, 0-9
         MVC   OPNDS+1(2),DBLWD        YES, 10-15
         LA    R1,OPNDS+3              TO NEXT POS
         J     RRCMA                   CONTINUE
RR11     MVC   OPNDS+1(1),DBLWD+1      MOVE REG NBR
         LA    R1,OPNDS+2              TO NEXT POS
RRCMA    CLI   TEXT,X'04'              IS IT SPM
         JNE   RRCMA1                  NO
         TM    1(R7),X'0F'             YES, IS R2 FIELD = 0
         JZ    INSTOUT                 YES, GOOD INSTR
         J     NOTINST                 ERROR RETURN (NOT INSTR)
RRCMA1   MVC   0(2,R1),SCOMMAR         DELIMITERS
         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE
         SR    R15,R15                 CLEAR WORK
         IC    R15,DBLWD               GET R2R1
         SRL   R15,4                   SHIFT OUT R1
         CVD   R15,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CHI   R15,10                  R2 > 9
         JL    RR21                    NO, 0-9
         MVC   2(2,R1),DBLWD           YES, MOVE REG 10-15
         J     RR22                                              @17C
RR21     MVC   2(1,R1),DBLWD+1         MOVE REG 0-9
RR22     TM    ICLASS,CDOR             IS IT CLEAR REGISTER OP   @21C
         JO    RRCLR0                  BRANCH IF YES             @21C
         CLI   DBLWD+1,C'0'            REG 0 ??                  @13A
         JNE   INSTOUT                 BRANCH IF NOT REG0        @13A
         CLI   TEXT,X'06'              IS IT BCTR OP ??          @13A
         JNE   INSTOUT                 NO THEN BRANCH            @13A
         MVC   COMMENT(L'S27),S27      SET COMMENT TO MINUS ONE  @13A
         MVC   COMMENT+11(2),OPNDS+1   COPY REGISTER             @20A
         CLI   COMMENT+12,C','                                   @20A
         JNE   INSTOUT                                           @20A
         MVI   COMMENT+12,C' '         CLEAR COMMA               @20A
         J     INSTOUT                 EXIT                      @13A
RRCLR0   SR    R14,R14                 CLEAR R14 FOR ICM         @17A
         CLI   TEXT,X'B9'              DOUBLE BYTE OPCODE ?      @22A
         JE    RRCLR2                  BRANCH IF YES             @22A
         ICM   R14,1,TEXT+1            LOAD R1R2                 @17A
         J     RRCLR4                                            @22A
RRCLR2   ICM   R14,1,TEXT+3            LOAD R1R2                 @22A
         LR    R1,R15                                            @22A
         AHI   R1,-2                                             @22A
RRCLR4   LR    R15,R14                                           @17A
         NILL  R15,X'000F'             GET RID OF R1             @17A
         SRL   R14,4                   GET RID OF R2             @17A
         CR    R14,R15                 R1 = R2 ??                @17A
         JNE   INSTOUT                 EXIT                      @17A
         MVC   COMMENT(L'SCLREG),SCLREG   SET COMMENT TO CLEAR   @17A
         MVC   COMMENT+L'SCLREG(3),1(R1)      REGISTER XX        @17A
         J     INSTOUT                 EXIT                      @17A
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RX-TYPE  *
* INSTRUCTIONS. THE BDXADR ROUTINE IS CALLED TO FORMAT THE       *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
RXOPND   DS    0H                      *** RX FORMAT INSTRUCTIONS ***
RXSTRT   SR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               GET R1X2
         SRL   R1,4                    SHIFT OUT X2
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         LA    R15,OPNDS               BEGIN 1ST OPERAND           @18A
         CLI   ICLASS,FLTPT            FLOATING OP code ?          @18A
         JNE   RXNFLT                  BRANCH IF NOT FP INSTR      @18A
         MVI   0(R15),C'F'             SET FLOATING POINT REG      @18A
         AHI   R15,1                   TO NEXT POS                 @18A
RXNFLT   MVI   0(R15),C'R'                                         @18C
         CHI   R1,10                   R1 < 10
         JL    RXR11                   YES, 0-9
         MVC   1(2,R15),DBLWD          NO, MOVE REG 10-15          @18C
         AHI   R15,3                   TO NEXT POS                 @18C
         J     RXCMA                   CONTINUE
RXR11    MVC   1(1,R15),DBLWD+1        MOVE REG 0-9                @18C
         AHI   R15,2                   TO NEXT POS                 @18C
RXCMA    CLI   TEXT,X'46'              BCT OPCODE ??               @22A
         JNE   RXNBCT                  BRANCH IF NOT BCT           @22A
         MVC   COMMENT+12(2),OPNDS     COPY REGISTERS              @22A
RXNBCT   MVI   0(R15),C','             DELIMITER
         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP X2R1
         SRL   R10,4                   SHIFT OUT R1
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD
         ST    R15,BDX15               SAVE R15
         JAS   R9,BDXADR               CONVERT RX ADDRESS
         L     R15,BDX15               RESTORE R15
         EX    R10,BDXMVC              MVC   1(1,R15),OPNDWK
         CLI   0(R7),X'46'             IS IT BCT OP CODE ?         @21A
         JE    RXJCT                   YES                         @21A
         CLI   0(R7),X'4D'             IS IT BAS OP CODE ?
         JE    RRBAS                   YES
         CLI   0(R7),X'45'             IS IT BAL OP CODE ?
         JNE   RXCONT
RRBAS    JAS   R14,PRTREGS             PRINT REGISTER USEAGE       @26A
         CLI   COMMENT,C' '                                        @31A
         JNE   INSTOUT                                             @31A
         MVC   COMMENT(L'S06),S06      SET COMMENT TO PERFORM
         TM    1(R7),X'E0'             R1 = 0 OR 1
         JNZ   RXCONT                  NO
         MVC   COMMENT(L'S07),S07      SET COMMENT TO PARM SET BRANCH
         J     INSTOUT                                             @21A
RXCONT   CLC   IFRRS,0(R7)                                         @23A
         JNE   INSTOUT                                             @23A
         MVC   COMMENT(L'SFRRS),SFRRS  '!FRRS PSASTAK Normal Stk'  @23A
         J     INSTOUT                 WRITE INSTRUCTION RECORD    @14A
RXJCT    MVC   COMMENT(L'S32),S32      'LOOP UNTIL REG =0'         @21A
         J     INSTOUT                                             @21A
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RI1-TYPE *
* INSTRUCTIONS (IE RI BRANCH INSTRUCTIONS)                       *
*                                                                *
******************************************************************
RI1OPND  DS    0H                *** RI1 FORMAT INSTRUCTIONS ***   @12A
         SR    R1,R1                   CLEAR WORK                  @12A
         LA    R15,OPNDS               NEXT POS                    @12A
         SR    R10,R10                 CLEAR R10                   @22A
         IC    R10,TEXT+1              MASK OFF RI INSTR REGISTER  @12A
         NILL  R10,X'000F'               FIELD                     @12A
         CHI   R10,4                   RELATIVE BRANCH OP CODE ?   @12A
         JE    RI1JMP                  BRANCH IF A7?4 (JUMP)       @12A
         CHI   R10,6                   JCT OP CODE                 @21A
         JE    RI1JCT                  BRANCH IF A7?6 (JCT)        @21A
         CLI   COMMENT,C' '                                        @31A
         JNE   RI2OPND                                             @31A
         MVC   COMMENT(L'S30),S30      'Call sub-routine'          @12A
         J     RI2OPND                                             @12A
RI1JCT   MVC   COMMENT(L'S32),S32      'Loop UNTIL REG = 0'        @21A
         J     RI2OPND                                             @21A
RI1JMP   MVC   MNEMONIC,BLANX          SET MNEMONIC TO BLANK       @21C
         MVC   TEMP1,TEXT+1                                        @12A
         NI    TEMP1,X'F0'             MASK OFF LOW ORDER BYTES    @12A
         MVI   MNEMONIC,C'J'           SET JXX  OPERATION CODE     @12A
         CLI   TEMP1,X'00'             NOP ?                       @21A
         JE    RINOP                                               @21A
         CLI   TEMP1,X'F0'             UNCONDITIONAL BRANCH?       @21A
         JE    RISBR                                               @21A
         L     R12,CCODEAD             GET ADDRESS OF COND CODE TBL@21A
         LR    R0,R12                                              @21A
RI1CCIX  CLI   0(R12),X'FF'            END OF COND CODE TABLE?     @21A
         JE    RI1CDFT             IF END OF TABLE THEN USE DFT CC @21A
         CLC   CCTYPE,0(R12)           RIGHT CONDITION CODE INDEX  @21A
         JE    RI1FCCTB                BRANCH IF YES               @21A
         AHI   R12,CC1LEN              POINT TO NEXT INDEX ENTRY   @21A
         J     RI1CCIX                 TRY NEXT ENTRY              @21A
RI1CDFT  L     R12,CCODEAD             GET ADDRESS OF COND CODE TB @21A
         LR    R0,R12                                              @21A
RI1FCCTB AH    R0,2(R12)               LOCATE CC TABLE ENTRY       @21A
         LR    R12,R0                                              @21A
RI1FCCTE CLI   0(R12),X'FF'            END OF COND CODE TABLE?     @21A
         JE    RI1CDFT             IF END OF TABLE THEN USE DFT CC @21A
         CLC   TEMP1,0(R12)            RIGHT CONDITION CODE ??     @21A
         JE    RIFOUND                 BRANCH IF YES               @21A
         AHI   R12,CC2LEN              POINT TO NEXT TABLE ENTRY   @21A
         J     RI1FCCTE                TRY NEXT ENTRY              @21A
RIFOUND  DS    0H                                                  @21A
         MVC   COMMENT(L'SBRANCH),SBRANCH     COPY 'Jump if '      @21A
         MVC   COMMENT+8(17),3(R12)    COPY DESCRIPTION            @21A
         MVC   MNEMONIC+1(2),1(R12)                                @21A
         CLI   MNEMONIC+1,C'C'         BRANCH ON C?                @21A
         JNE   RI1CONT                 BRANCH IF NO                @21A
         SR    R1,R1                   CLEAR WORK                  @21A
         IC    R1,TEMP1                GET COND CODE               @21A
         SRL   R1,4                    SHIFT 4 BITS                @21A
         STC   R1,TEMP1                                            @21A
         CHI   R1,9                    COND CODE > 9               @21A
         JH    RIFCC2                  JUMP IF HIGHER              @21A
         OI    TEMP1,X'F0'             MAKE IT PRINTABLE           @21A
         MVC   0(1,R15),TEMP1          COPY COND CODE              @21A
         MVI   1(R15),C','                                         @21A
         AHI   R15,2                   NEXT POS                    @21A
         LA    R2,2                                                @21A
         J     RI1CONT                                             @21A
RIFCC2   MVI   0(R15),C'1'                                         @21A
         AHI   R1,-10                                              @21A
         STC   R1,TEMP1                                            @21A
         OI    TEMP1,X'F0'                                         @21A
         MVC   1(1,R15),TEMP1                                      @21A
         MVI   2(R15),C','                                         @21A
         AHI   R15,3                   NEXT POS                    @21A
         LA    R2,3                    ASSUME 3 BYTES              @21A
         J     RI1CONT                 YES                         @21A
RINOP    MVC   MNEMONIC,SJNOP          SET MNEMONIC TO NOP         @21A
         J     RI1CONT                 YES                         @21A
RISBR    MVC   COMMENT(5),SBRANCH      COPY 'JUMP '                @12A
RI1CONT  LR    R11,R7                  GET CURRENT OFFSET          @12A
         S     R11,TXTSTRT             MINUS PROGRAM START         @12A
         AH    R11,TEXT+2              ADD DDDD                    @12A
         AH    R11,TEXT+2              R11 = @CUR + 2*DDDD         @12A
         STCM  R11,7,0(R15)                                        @12A
         LR    R12,R15                 @ OFFSET                    @12A
         JAS   R9,HEXPRT3              GO CONVERT                  @12A
         MVI   0(R15),C'A'             ADDRESS CONSTANT            @12A
         MVC   1(6,R15),PRTABL         Get rest of name            @12A
         SR    R0,R0                   Clear R0                    @23A
         CH    R0,TEXT+2               DISPL < 0                   @23A
         JNL   RIEXIT                  Jump if backward reference  @23A
         JAS   R14,PRTREGS             Print register usage        @23A
         J     RIEXIT
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RI2-TYPE *
* INSTRUCTIONS                                                   *
*                                                                *
******************************************************************
RI2OPND  DS    0H                                                 @12A
         SR    R1,R1                   CLEAR WORK                 @12A
         LA    R15,OPNDS               ?? NEXT POS                @12A
         IC    R1,TEXT+1               GET R1                     @12A
         SRL   R1,4                                               @12A
         CVD   R1,DBLWD                CONVERT                    @12A
         OI    DBLWD+7,X'0F'           CLEAR SIGN                 @12A
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK                     @12A
         MVI   0(R15),C'R'             BEGIN 1ST OPERAND          @12A
         CHI   R1,10                   R1 < 10                    @12A
         JL    RIR11                   YES, 0-9                   @12A
         MVC   1(2,R15),DBLWD          NO, MOVE REG 10-15         @12A
         LA    R15,OPNDS+3             TO NEXT POS                @12A
         J     RICMA                                              @12A
RIR11    MVC   1(1,R15),DBLWD+1        MOVE REG 0-9               @12A
         LA    R15,OPNDS+2             TO NEXT POS                @12A
RICMA    CLC   S32,COMMENT             JCT OP                     @22A
         JNE   RINJCT                  BRANCH IF NOT JCT OPCODE   @22A
         MVC   COMMENT+12(2),OPNDS+1   COPY REGISTERS             @22A
RINJCT   MVI   0(R15),C','             DELIMITER                  @12A
         AHI   R15,1                                              @12A
         CLI   ITYPE,RI1                                          @12A
         JE    RI1CONT                                            @12A
         TM    IEDT,IM2                2 BYTES IMMEDIATE OPERAND  @12A
         JNO   RIARITH                 BRANCH IF NOT IM2 INSTR    @12A
RIHEX1   MVC   0(2,R15),SXAPO          DELIMITER FOR X'           @12A
         LA    R12,TEXT+2              @ HEX BYTE                 @12A
RIHEX2   JAS   R9,HEXPRT2              CONVERT                    @12A
         MVC   2(4,R15),PRTABL         PRINTABLE HEX TO OPERAND   @12A
         MVI   6(R15),C''''            FINAL QUOTE                @12A
         J     INSTOUT                                            @12A
RIARITH  LH    R11,TEXT+2              FORMAT 2 BYTES IMMEDIATE   @12A
         CVD   R11,DBLWD                  OPERANDS TO ARITHMETIC  @12A
         OI    DBLWD+7,X'0F'           CLEAR SIGN                 @12A
         UNPK  DBLWD(5),DBLWD+3(5)     UNPACK                     @12A
         CHI   R11,0                   TEST FOR + OR -            @12A
         JNL   RIPOSI                  BRANCH IF POSITIVE NUMBER  @12A
         MVI   0(R15),C'-'             SET NEGATIVE SIGN          @12A
         AHI   R15,1                                              @12A
         J     RI4DIGX                                            @29A
RIPOSI   CLI   DBLWD,C'0'              5 DIGITS ??                @12A
         JE    RI4DIG                  BRANCH IF 4 DIGITS         @12A
         CLC   X_DF80,TEXT+2                                      @29C
         JL    RIHEX1                  BRANCH IF OPERAND > X_DF80 @28A
         CLC   X_1FF0,TEXT+2                                      @29C
         JL    RIHEX1                  BRANCH IF OPERAND > X_1FF0 @28A
         MVC   0(5,R15),DBLWD          COPY 5 DIGITS OPERAND      @12A
         J     INSTOUT                                            @12A
RI4DIG   CLC   X_0FFF,TEXT+2                                      @29A
         JL    RIHEX1                  BRANCH IF OPERAND > X_0FFF @29A
RI4DIGX  CLI   DBLWD+1,C'0'            4 DIGITS ??                @12A
         JE    RI3DIG                  BRANCH IF 3 DIGITS         @12A
         MVC   0(4,R15),DBLWD+1        COPY 4 DIGITS OPERAND      @12A
         J     INSTOUT                                            @12A
RI3DIG   CLI   DBLWD+2,C'0'            3 DIGITS ??                @12A
         JE    RI2DIG                  BRANCH IF 4 DIGITS         @12A
         MVC   0(3,R15),DBLWD+2        COPY 3 DIGITS OPERAND      @12A
         J     INSTOUT                                            @12A
RI2DIG   CLI   DBLWD+3,C'0'            2 DIGITS ??                @12A
         JE    RI1DIG                  BRANCH IF 1 DIGIT          @12A
         MVC   0(2,R15),DBLWD+3        COPY 2 DIGITS OPERAND      @12A
         J     INSTOUT                                            @12A
RI1DIG   MVC   0(1,R15),DBLWD+4        COPY 1 DIGIT  OPERAND      @12A
RIEXIT   J     INSTOUT                 WRITE INSTRUCTION RECORD   @14C
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RIL-TYPE *
* INSTRUCTIONS                                                   *
*                                                                *
******************************************************************
RIL1OPND DS    0H                        *** I2L                  @13A
         CLC   MNEMONIC,S_LARL         LARL INSTR ??              @15A
         JNE   RIL1CNT1                BRANCH IF NO               @15A
         MVC   COMMENT(L'SCODERG),SCODERG   SET COMMENT           @15A
RIL1CNT1 IC    R10,TEXT+1                                         @12A
         NILL  R10,X'000F'             REMOVE CONDITION CODE      @12A
         CHI   R10,4                                              @13A
         JE    RILJMP                  BRANCH IF JUMP INSTR       @13A
         IC    R10,TEXT+1              PICK UP 2ND OP CODE        @12A
         SRL   R10,4                   REMOVE 2ND REG             @12A
         JAS   R9,FORRGC               FORMAT REG OPERAND         @13A
         AHI   R15,1                                              @13A
         MVI   0(R15),C','                                        @13A
         AHI   R15,1                                              @13A
RIL1ADR  LR    R11,R7                  GET CURRENT OFFSET         @13A
         S     R11,TXTSTRT             MINUS PROGRAM START        @13A
         A     R11,TEXT+2              ADD DDDDDDDD               @13A
         A     R11,TEXT+2              ADD DDDDDDDD               @13A
         STCM  R11,7,0(R15)                                       @13A
         LR    R12,R15                                            @13A
         JAS   R9,HEXPRT3              GO CONVERT TO HEXI         @13A
         MVI   0(R15),C'A'                                        @13A
         MVC   1(6,R15),PRTABL         REST OF NAME               @13A
         J     INSTOUT                 WRITE INSTRUCTION RECORD   @14C
****************************************************************
RIL2OPND DS    0H                        *** I2L                   @13A
         SR    R1,R1                   CLEAR WORK                  @13A
         IC    R1,TEXT+1               GET R1                      @13A
         SRL   R1,4                                                @12A
         CVD   R1,DBLWD                CONVERT                     @12A
         OI    DBLWD+7,X'0F'           CLEAR SIGN                  @12A
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK                      @12A
         MVI   OPNDS,C'R'              BEGIN 1ST OPERAND           @12A
         CHI   R1,10                   R1 < 10                     @12A
         JL    RILR11                  YES, 0-9                    @12A
         MVC   OPNDS+1(2),DBLWD        NO, MOVE REG 10-15          @12A
         LA    R15,OPNDS+3             TO NEXT POS                 @12A
         J     RILCMA                  CONTINUE                    @12A
RILR11   MVC   OPNDS+1(1),DBLWD+1      MOVE REG 0-9                @12A
         LA    R15,OPNDS+2             TO NEXT POS                 @12A
RILCMA   MVI   0(R15),C','             DELIMITER                   @12A
         AHI   R15,1                                               @12A
*****************************************************
RILFOPND DS    0H
         L     R11,TEXT+2              GET DDDDDDDD                @12A
         CVD   R11,DBLWD               CONVERT TO PACK DECIMAL     @12A
         OI    DBLWD+7,X'0F'           CLEAR SIGN                  @12A
         UNPK  DBLWD2(15),DBLWD(8)     UNPACK                      @12A
         CHI   R11,0                   NEGATIVE OR POSITIVE        @12A
         JNL   RLPOSI                  BRANCH IF NOT NEGATIVE      @12A
         MVI   0(R15),C'-'             SET MINUS SIGN              @12A
         AHI   R15,1                   BUMP UP POSITION COUNTER    @12A
RLPOSI   CHI   R11,9                   > 0                         @21A
         JH    RILHI9                  BRANCH IF YES               @21A
         MVC   0(1,R15),DBLWD2+14                                  @21A
         J     INSTOUT                 WRITE INSTRUCTION RECORD    @21A
RILHI9   MVC   0(10,R15),DBLWD2+5      COPY FULL WORD IMMEDIATE    @12A
         J     INSTOUT                 WRITE INSTRUCTION RECORD    @14C
*****************************************************
RILJMP   IC    R10,TEXT+1                                          @12A
         MVC   TEMP1,TEXT+1                                        @12A
         NI    TEMP1,X'F0'             REMOVE REGISTER FROM OPCOD  @12A
         LA    R15,OPNDS               POINT TO OPNDS              @12A
         CLI   TEMP1,X'00'             NOP ?                       @21A
         JE    RILNOP                                              @21A
         CLI   TEMP1,X'F0'             UNCONDITIONAL BRANCH ?      @21A
         JE    RILSBR                                              @21A
*        LRL   R12,CCODEAD             GET ADDRESS OF COND CODE TBL@21A
         L     R12,CCODEAD             GET ADDRESS OF COND CODE TBL@21A
         LR    R0,R12                  SAVE COND CODE TBL ADDRESS  @21A
RILCCIX  CLI   0(R12),X'FF'            END OF COND CODE TABLE?     @21A
         JE    RIL1CDFT            IF END OF TABLE THEN USE DFT CC @21A
         CLC   CCTYPE,0(R12)           RIGHT CONDITION CODE INDEX  @21A
         JE    RIL1FCTB                BRANCH IF YES               @21A
         AHI   R12,CC1LEN              POINT TO NEXT INDEX ENTRY   @21A
         J     RILCCIX                 TRY NEXT ENTRY              @21A
RIL1CDFT L     R12,CCODEAD             GET ADDRESS OF COND CODE TB @21A
         LR    R0,R12                                              @21A
RIL1FCTB AH    R0,2(R12)                                           @21A
         LR    R12,R0                                              @21A
RIL1FCTE CLI   0(R12),X'FF'            END OF COND CODE TABLE?     @20C
         JE    RIL1CDFT            IF END OF TABLE THEN USE DFT CC @21A
         CLC   TEMP1,0(R12)            RIGHT CONDITION CODE ??     @21A
         JE    RILFOUND                BRANCH IF YES               @21A
         AHI   R12,CC2LEN              POINT TO NEXT TABLE ENTRY   @21A
         J     RIL1FCTE                TRY NEXT ENTRY              @21A
RILFOUND DS    0H                                                  @21A
         MVC   COMMENT(L'SBRANCH),SBRANCH     COPY 'Jump if '      @21A
         MVC   COMMENT+8(17),3(R12)    COPY DESCRIPTION            @21A
         MVC   MNEMONIC+4(2),1(R12)                                @21A
         CLI   MNEMONIC+4,C'C'         BRANCH ON C?                @21A
         JNE   RI1CONT                 BRANCH IF NO                @21A
         SR    R1,R1                   CLEAR WORK                  @21A
         IC    R1,TEMP1                                            @21A
         SRL   R1,4                                                @21A
         STC   R1,TEMP1                                            @21A
         CHI   R1,10                                               @21A
         JH    RILFCC2                                             @21A
         OI    TEMP1,X'F0'                                         @21A
         MVC   0(1,R15),TEMP1          COPY COND CODE              @21A
         MVI   1(R15),C','                                         @21A
         AHI   R15,2                   NEXT POS                    @21A
         LA    R2,2                                                @21A
         J     RILCONT                                             @21A
RILFCC2  MVI   0(R15),C'1'                                         @21A
         AHI   R1,-10                                              @21A
         STC   R1,TEMP1                                            @21A
         OI    TEMP1,X'F0'                                         @21A
         MVC   1(1,R15),TEMP1                                      @21A
         MVI   2(R15),C','                                         @21A
         AHI   R15,3                   NEXT POS                    @21A
         LA    R2,3                    ASSUME 3 BYTES              @21A
         J     RILCONT                 YES                         @21A
RILNOP   MVC   MNEMONIC,SJLNOP         SET MNEMONIC TO JLNOP       @21A
         J     RILCONT                 YES                         @21A
RILSBR   MVC   COMMENT(5),SBRANCH      COPY 'JUMP '                @12A
RILCONT  LR    R11,R7                  GET CURRENT OFFSET          @12A
         S     R11,TXTSTRT             MINUS PROGRAM START         @12A
         AH    R11,TEXT+2              ADD DDDD                    @12A
         AH    R11,TEXT+2              R11 = @CUR + 2*DDDD         @12A
         STCM  R11,7,0(R15)                                        @12A
         LR    R12,R15                 @ OFFSET                    @12A
         JAS   R9,HEXPRT3              GO CONVERT                  @12A
         MVI   0(R15),C'A'             ADDRESS CONSTANT            @12A
         MVC   1(6,R15),PRTABL         REST OF NAME                @12A
         J     RIEXIT
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT S-TYPE   *
* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
SOPND    EQU   *                       *** S FORMAT INSTRUCTIONS ***
         CLI   0(R7),X'80'             IS IT SSM                  @14A
         JE    SOPSSM                  YES, CHECK FOR VALID SSM   @14A
         CLI   1(R7),0                 BYTE 2 OF INSTR IS ZERO
         JE    SOPND50                 YES
         CLI   0(R7),X'82'             NO, IS IT LPSW
         JE    NOTINST                 YES, NOT INSTR
         CLI   0(R7),X'93'             NO, IS IT TS
         JE    NOTINST                 YES, NOT INSTR
         LARL  R15,SOPTABLE                                       @27A
SOPND10  CLI   0(R15),X'FF'            END OF TABLE               @27A
         JE    SOPND50                 BRANCH IF END OF TABLE     @27A
         CLC   0(4,R15),0(R7)          INSTRUCTION FOUND ?        @27A
         JE    SOPND30                 BRANCH IF YES              @27A
         AHI   R15,36                  BUMP TO NEXT TABLE ENTRY   @27A
         J     SOPND10                 LOOP                       @27A
SOPND30  MVC   OPNDS(7),4(R15)         COPY OPERAND               @27A
         MVC   COMMENT(25),11(R15)     COPY COMMENT               @27A
         J     INSTOUT                 WRITE INSTRUCTION          @27A
SOPTABLE DS    0H
   DC    XL4'B20B0000',CL7' ',CL25'Insert PSW key from R2'   IPK  @27A
   DC    XL4'B2190000',CL7'0',CL25'Set ASC mode to primary'       @27A
   DC    XL4'B2190100',CL7'256',CL25'Set ASC mode to secondary'   @27A
   DC    XL4'B2190200',CL7'512',CL25'Set ASC mode to AR mode'     @27A
   DC    XL4'B2190300',CL7'768',CL25'Set ASC mode to home'        @27A
   DC    XL4'B2760000',CL7'   ',CL25'Cancel Subchannel'           @27A
   DC    XL4'B2F80000',CL7'   ',CL25'Transaction end'             @27A
   DC    XL2'FFFF'
SOPSSM   CLC   1(3,R7),XZROS           ALL ARE HEXI ZEROs         @16A
         JE    CONST                   YES, IT IS 80000000        @16A
         CLI   1(R7),X'00'                                        @14A
         JNE   CONST                   BRANCH NOT A VALID SSM INST@14A
SOPND50  SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD
         JAS   R9,BDADR                CONVERT BDDD ADDRESS
         EX    R10,SOPMVC              MVC   OPNDS(1),OPNDWK
         CLC   IPC,TEXT                PROGRAM CALL ??            @12A
         JNE   INSTOUT                 BRANCH IF NO               @12A
*********
* Program call handling routine
*********
         MVC   COMMENT(L'S10),S10      SET COMMENT PROGRAM CALL   @12A
         LR    R11,R7                                             @14A
         AHI   R11,-4                  BACK 4 BYTES               @14A
         CLI   0(R11),X'58'            LOAD INSTRUCTION ??        @14A
         JE    SOPLSFT                 BRANCH IF LOAD OP          @14A
         AHI   R11,-2                  BACK 2 BYTES               @14A
         CLI   0(R11),X'58'            LOAD INSTRUCTION ??        @14A
         JE    SOPLSFT                 BRANCH IF NO               @14A
         AHI   R11,-2                  BACK 2 BYTES               @14A
         CLI   0(R11),X'58'            LOAD INSTRUCTION ??        @14A
         JNE   INSTOUT                 BRANCH IF NO               @14A
SOPLSFT  LH    R11,2(R11)              PICK UP                    @14A
         NILH  R11,X'0000'             CLEAR                      @14A
         NILL  R11,X'0FFF'             MASK OFF BASE REGISTER     @14A
*        LRL   R12,SFTAD               GET ADDRESS OF SFT TABLE   @14A
         L     R12,SFTAD               GET ADDRESS OF SFT TABLE   @14A
SOPSFTL  CLI   0(R12),X'FF'            END OF TABLE ??            @14A
         JE    INSTOUT                 YES THEN EXIT              @14A
         CH    R11,0(R12)              CHECK SFT OFFSET ADR       @14A
         JE    SOPSFT                  BRANCH IF FIND             @14A
         AHI   R12,SFTLEN              POINT TO NEXT ENTRY        @14A
         J     SOPSFTL                 GET NEXT SFT ENTRY         @14A
SOPSFT   MVC   COMMENT+L'S10+1(16),2(R12)                         @14A
         J     INSTOUT                                            @14A
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SIY-TYPE *
* AND SIOPND INSTRUCTIONS. THE BDYADR ROUTINE IS CALLED TO       *
* FORMAT THE STORAGE OPERAND.                                    *
*                                                                *
* R10 R11 - WORK REGISTER                                        *
* R15     - CURRENT POINTER OF OPNDS                             *
* SEARCH BIT MASK TABLE                                          *
*                                                                *
******************************************************************
*
SIYOPND  DS    0H                                                 @21A
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         JAS   R9,BDYADR               CONVERT SIY ADDRESS        @28A
         J     SICOPY                                             @28A
SIOPND   DS    0H                      *** SI FORMAT INSTRUCTIONS ***
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         JAS   R9,BDADR                CONVERT BDDD ADDRESS
SICOPY   EX    R10,SOPMVC              MVC   OPNDS(1),OPNDWK  (BDDD)
         LA    R15,OPNDS(R10)
         CLI   0(R15),C' '
         JE    SI2OPND
         LA    R15,1(R15)
SI2OPND  MVI   0(R15),C','             DELIMITER
         TRT   TEXT+1(1),CHARTRAN      TEST IF CHARACTER
         JNZ   HEXIMM                  NO, HEX
         CLI   TEXT,X'95'              IS IT CLI OP CODE
         JE    CHIMM                   YES
         CLI   TEXT,X'92'              IS IT MVI OP CODE
         JNE   HEXIMM                  NO
CHIMM    MVC   1(2,R15),SCAPO          DELIMITER '
         MVC   3(1,R15),TEXT+1         CHARACTER TO OPERAND
         MVI   4(R15),C''''            ENDING QUOTE
         CLI   TEXT+1,X'7D'            IS IT QUOTE ?               @12A
         JNE   CHIMMEX                 BRANCH IF NOT QUOTE         @12A
         MVI   5(R15),C''''            MOVE ADDITIONAL QUOTE       @12A
CHIMMEX  J     CHKBMP                                              @24C
HEXIMM   MVC   1(2,R15),SXAPO          DELIMITER FOR X'
         LA    R12,TEXT+1              @ HEX BYTE
         JAS   R9,HEXPRT1              CONVERT
         MVC   3(2,R15),PRTABL         PRINTABLE HEX TO OPERAND
         MVI   5(R15),C''''            FINAL QUOTE
         CLI   TEXT,X'AF'              IS IT MC OP CODE ??         @20A
         JNE   NOTMC                   BRANCH IF NOT MC OP CODE    @20A
         MVC   COMMENT(L'S34),S34      TRACE SYSTEM ROUTINE        @20A
         J     INSTOUT                 WRITE RECORD                @20A
NOTMC    CLC   TEXT(2),XACFC           DISABLE I/O & EXT INTR ?    @20A
         JE    SISTNSM                 BRANCH IF YES               @20A
         CLC   TEXT(2),XAD03           ENABLE I/O & EXT INTR ?     @20A
         JE    SISTOSM                 BRANCH IF YES               @20A
CHKBMP   CLI   ICLASS,BMP              BIT MASK INSTUCTION ?       @18A
         JNE   INSTOUT                 BRANCH IF NOT               @18A
         ST    R15,BD15                SAVE R15                    @29A
         L     R15,BITMAP              LOAD BITMAP                 @29A
         BALR  R14,R15                 SEARCH BIT MASK TABLE       @29A
         J     INSTOUT                                             @20A
SISTNSM  MVC   COMMENT(L'SDISIE),SDISIE   DISABLE I/O & EXT INTR   @20A
         J     INSTOUT                                             @20A
SISTOSM  MVC   COMMENT(L'SENAIE),SENAIE   ENABLE I/O * EXT INTR    @20A
         J     INSTOUT                                             @20A
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SIL      *
* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *
* STORAGE OPERAND.                                               *
* R10 R11 - WORK REGISTER                                        *
* R15     - CURRENT POINTER OF OPNDS                             *
*                                                                *
******************************************************************
SILOPND  DS    0H                                                 @21A
         SR    R11,R11                 CLEAR WORK                 @21A
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS           @21A
         JAS   R9,BDADR                CONVERT BDDD ADDRESS       @21A
         LA    R15,OPNDS               TO NEXT POS                @21A
         CLC   ITBEGINC,0(R7)          OPCODE E561 ?              @21A
         JNE   SIL2000                                            @21A
         MVI   MNEMONIC+6,C'C'                                    @21A
         LA    R15,OPNDS+1             TO NEXT POS                @21A
*        MVC   COMMENT-5(L'STBEGINC),STBEGINC                     @25A
         MVC   COMMENT(L'STBEGINC),STBEGINC                       @25A
SIL2000  EX    R10,BDXMVC              MVC   1(1,R15),OPNDWK      @21A
         LA    R15,2(R15,R10)                                     @21A
         MVI   0(R15),C','                                        @21A
         AHI   R15,1                                              @21A
         MVC   0(2,R15),SXAPO          DELIMITER FOR X'           @21A
         LA    R12,TEXT+4              @ HEX BYTE                 @21A
         J     RIHEX2                                             @21A
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RIE-TYPE *
* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
RIEOPND  DS    0H                      *** FORMAT RIE INSTRUCTION ***
         LA    R15,OPNDS                                           @28A
         SR    R1,R1                                               @28A
         IC    R1,TEXT+1               LOAD R1R2                   @28A
         SRL   R1,4                    SHIFT OUT R2                @28A
         CVD   R1,DBLWD                CONVERT                     @28A
         OI    DBLWD+7,X'0F'           CLEAR SIGN                  @28A
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK                      @28A
         MVI   0(R15),C'R'             Beginning operand 1         @28A
         CHI   R1,10                   R1 < 10                     @28A
         JL    RIER11                  YES                         @28A
         MVC   1(2,R15),DBLWD          Move REG 10-15              @28A
         AHI   R15,3                   To next position            @28A
         J     RIER12                  continue                    @28A
RIER11   MVC   1(1,R15),DBLWD+1        Move REG 0-9                @28A
         AHI   R15,2                   To next position            @28A
RIER12   MVC   0(2,R15),SCOMMAR        DELIMITERS                  @28A
         AHI   R15,1                   To next position            @28A
         SR    R1,R1                                               @28A
         IC    R1,TEXT+1               LOAD R1R2                   @28A
         NILL  R1,X'000F'              CLEAR R1                    @28A
         CVD   R1,DBLWD                CONVERT                     @28A
         OI    DBLWD+7,X'0F'           CLEAR SIGN                  @28A
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK                      @28A
         CHI   R1,10                   R2 < 10                     @28A
         JL    RIER21                  YES                         @28A
         MVC   1(2,R15),DBLWD          Move REG 10-15              @28A
         AHI   R15,3                   To next position            @28A
         J     RIER22                  continue                    @28A
RIER21   MVC   1(1,R15),DBLWD+1        Move REG 0-9                @28A
         AHI   R15,2                   To next position            @28A
RIER22   MVI   0(R15),C','             Delimiters                  @28A
         AHI   R15,1                   To next position            @28A
         LR    R11,R7                  GET CURRENT OFFSET          @28A
         S     R11,TXTSTRT             MINUS PROGRAM START         @28A
         AH    R11,TEXT+2              ADD DDDD                    @28A
         AH    R11,TEXT+2              R11 = @CUR + 2*DDDD         @28A
         STCM  R11,7,0(R15)                                        @28A
         LR    R12,R15                 @ OFFSET                    @28A
         JAS   R9,HEXPRT3              GO CONVERT                  @28A
         MVI   0(R15),C'A'             ADDRESS CONSTANT            @28A
         MVC   1(6,R15),PRTABL         Get rest of name            @28A
         SR    R0,R0                   Clear R0                    @28A
         CH    R0,TEXT+2               DISPL < 0                   @28A
         JNL   INSTOUT                 Jump if backward reference  @28A
         JAS   R14,PRTREGS             Print register usage        @28A
         J     INSTOUT                                             @28A
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RS-TYPE  *
* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
RSIOPND  DS    0H                      *** RSI UNDER CONSTRUCTION ***
RSEOPND  DS    0H                      *** RSE UNDER CONSTRUCTION ***
RSYOPND  DS    0H                                                  @12A
RSOPND   DS    0H                      *** RS FORMAT INSTRUCTIONS ***
         CLI   TEXT,X'AE'              IS IT SIGP OP ??            @15A
         JE    RSSIGP                  YES                         @15A
         CLI   TEXT,X'9B'              IS IT STAM OP ??            @13A
         JE    RSSTAM                  YES                         @13A
         CLC   INAME(3),S_STM          Store multiple instr ?      @23A
         JE    RSSTM                   YES
         CLC   INAME(2),S_LM           Load multiple instr ?       @23A
         JNE   RSCLR1                  NO
         MVC   COMMENT(L'S11),S11      RESTORE REGS
         J     RSCLR1                  CONTINUE
RSSIGP   MVC   COMMENT(L'S37),S37      SIGNAL PROCESSOR            @15A
         J     RSCLR1                                              @15A
RSSTAM   MVC   COMMENT(L'S12A),S12A    SAVE ACCESS REGISTERS       @13A
         J     RSCLR1                                              @13A
RSSTM    MVC   COMMENT(L'S12),S12      SAVE REGS
RSCLR1   SR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               PICK UP R1R3
         SRL   R1,4                    SHIFT OUT R3
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         LA    R15,OPNDS                                           @13A
         CLI   ICLASS,AR2              AR2 INSTRUCTION ??          @21C
         JNE   RSCR1                   BRANCH IF NOT EQUAL         @13A
         MVI   OPNDS,C'A'              Set Access registers        @13A
         AHI   R15,1                                               @13A
RSCR1    TM    ICLASS,CR               Control Register OP ??      @13A
         JNO   RSAR1                   Branch if not CR OP         @13A
         MVI   OPNDS,C'C'              Set Control Register        @13A
         AHI   R15,1                                               @13A
RSAR1    MVI   0(R15),C'R'             Beginning operand 1
         CHI   R1,10                   Reg number < 10
         JL    RSR11                   YES
         MVC   1(2,R15),DBLWD          Move REG 10-15
         AHI   R15,3                   To next position
         J     RSCMA                   continue
RSR11    MVC   1(1,R15),DBLWD+1        Move REG 0-9
         AHI   R15,2                   TO next position
RSCMA    CLI   0(R7),X'88'             IS IT SHIFT INSTR
         JL    RSCMA1                  NO
         CLI   0(R7),X'8F'             IS IT SHIFT INSTR
         JH    RSCMA1                  NO
         TM    1(R7),X'0F'             SHIFT, IS R3 POS = 0
         JZ    RSBDD                   YES, GOOD SHIFT
         J     NOTINST                 NO, NOT INSTR               @12C
RSCMA1   MVI   0(R15),C','
         AHI   R15,1                   SET ACCESS REGISTERS        @13A
         CLI   ICLASS,AR2              AR2 INSTRUCTION ??          @21A
         JNE   RSCR2                   BRANCH IF NOT AR INSTR      @13A
         MVI   0(R15),C'A'             SET ACCESS REGISTERS        @13A
         AHI   R15,1                                               @13A
RSCR2    TM    ICLASS,CR               CONTROL REGISTER OP ??      @13A
         JNO   RSAR2                   BRANCH IF NOT EQUAL         @13A
         MVI   0(R15),C'C'             SET CONTROL REGISTERS       @13A
         AHI   R15,1                                               @13A
RSAR2    MVI   0(R15),C'R'                                         @13A
         TM    IEDT,T8                 CLM, STCM, OR ICM           @12A
         JNO   RSPK2                   BRANCH IF NOT ONE           @12A
         AHI   R15,-1               CLM, STCM, ICM HAVE MASK IN R3 P
RSPK2    PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE
         SR    R1,R1                   CLEAR WORK
         IC    R1,DBLWD                GET R3R1
         SRL   R1,4                    SHIFT OUT R1
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CHI   R1,10                   REG NBR < 10
         JL    RSR31                   YES, 0-9
         MVC   1(2,R15),DBLWD          MOVE REG 10-15
         AHI   R15,3                   TO NEXT POS
         J     RSBDD                   CONTINUE
RSR31    MVC   1(1,R15),DBLWD+1        MOVE REG 0-9
         AHI   R15,2                   TO NEXT POS
RSBDD    MVI   0(R15),C','             DELIMITER
         SR    R11,R11                 CLEAR WORK
         CLI   ITYPE,RSA               RSA INSTRUCTION             @30A
         JE    RS_BDD                                              @30A
         CLI   ITYPE,RSI               RSI INSTRUCTION             @14A
         JNE   RS_BDD                                              @14A
         LR    R11,R7                  GET CURRENT OFFSET          @12A
         S     R11,TXTSTRT             R11 = @CUR                  @12A
         AH    R11,TEXT+2              R11 = @CUR + DDDD           @12A
         AH    R11,TEXT+2              R11 = @CUR + 2*DDDD         @12A
         AHI   R15,1                                               @12A
         STCM  R11,7,0(R15)            SAVE R11 FOR HEX FORMAT     @12A
         LR    R12,R15                 @ OFFSET                    @12A
         JAS   R9,HEXPRT3              GO CONVERT                  @12A
         MVI   0(R15),C'A'             ADDRESS CONSTANT            @12A
         MVC   1(6,R15),PRTABL         REST OF NAME                @12A
         J     INSTOUT                                             @12A
RS_BDD   CLI   TEXT,X'83'              DIAG INSTR ??               @17A
         JNE   RSCBDD1                                             @17A
         MVC   1(2,R15),SXAPO          DELIMITER FOR X'            @17A
         LA    R12,TEXT+2              @ HEX BYTE                  @17A
         JAS   R9,HEXPRT2              CONVERT                     @17A
         MVC   3(4,R15),PRTABL         PRINTABLE HEX TO OPERAND    @17A
         MVI   7(R15),C''''            FINAL QUOTE                 @17A
         J     INSTOUT                                             @17A
RSCBDD1  ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         CLI   ITYPE,RSY               RSY INSTRUCTION ?           @28A
         JNE   RSCBDD3                 BRANCH IF NOT RSY INSTR     @28A
         JAS   R9,BDYADR               CONVERT RSY ADDRESS         @28A
         J     RSCBDD5                                             @28A
RSCBDD3  JAS   R9,BDADR                CONVERT BDDD ADDRESS
RSCBDD5  EX    R10,BDXMVC              MVC   1(1,R15),OPNDWK
         J     INSTOUT                 WRITE INSTRUCTION RECORD    @14C
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RRFA     *
* TYPE INSTRUCTION.     OPCODE  R1,R2,R3,M4                      *
*                                                                *
******************************************************************
RRFAOPND DS    0H                      *** RRFA FORMAT INSTRUCTIONS ***
         LA    R15,OPNDS                                           @30A
         CLIY  -1(R15),C' '                                        @30A
         JE    RRFAR10                                             @30A
         AHI   R15,1                                               @30A
RRFAR10  SR    R1,R1                                               @30A
         IC    R1,TEXT+3               LOAD R1R2                   @30A
         SRL   R1,4                    SHIFT OUT R2                @30A
         CVD   R1,DBLWD                CONVERT                     @30A
         OI    DBLWD+7,X'0F'           CLEAR SIGN                  @30A
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK                      @30A
         MVI   0(R15),C'R'             beginning operand 1         @30A
         CHI   R1,10                   R1 < 10                     @30A
         JL    RRFAR11                 branch if yes               @30A
         MVC   1(2,R15),DBLWD          move R1  10-15              @30A
         AHI   R15,3                   to next position            @30A
         J     RRFAR12                 continue                    @30A
RRFAR11  MVC   1(1,R15),DBLWD+1        move R2  0-9                @30A
         AHI   R15,2                   to next position            @30A
RRFAR12  MVC   0(2,R15),SCOMMAR        copy ',R'                   @30A
         SR    R1,R1                                               @30A
         IC    R1,TEXT+3               load R1R2                   @30A
         NILL  R1,X'000F'              clear R1                    @30A
         CVD   R1,DBLWD                convert R2 to decimal       @30A
         OI    DBLWD+7,X'0F'           clear sign                  @30A
         UNPK  DBLWD(2),DBLWD+6(2)     unpack                      @30A
         CHI   R1,10                   R2 < 10                     @30A
         JL    RRFAR21                 branch if yes               @30A
         MVC   2(2,R15),DBLWD          move R2  10-15              @30A
         AHI   R15,4                   to next position            @30A
         J     RRFAR22                 continue                    @30A
RRFAR21  MVC   2(1,R15),DBLWD+1        move R2  0-9                @30A
         AHI   R15,3                   to next position            @30A
RRFAR22  MVC   0(2,R15),SCOMMAR        copy ',R'                   @30A
         SR    R1,R1                                               @30A
         IC    R1,TEXT+2               Load R3M4                   @30A
         SRL   R1,4                    Shift right 4 bits          @30A
         CVD   R1,DBLWD                convert R3 to decimal       @30A
         OI    DBLWD+7,X'0F'           clear sign                  @30A
         UNPK  DBLWD(2),DBLWD+6(2)     unpack                      @30A
         CHI   R1,10                   R3   < 10                   @30A
         JL    RRFA31                  branch if yes               @30A
         MVC   2(2,R15),DBLWD          move R3  10-15              @30A
         AHI   R15,4                   to next position            @30A
         J     RRFA32                                              @30A
RRFA31   MVC   2(1,R15),DBLWD+1        move R3  0-9                @30A
         AHI   R15,3                   to next position            @30A
RRFA32   SR    R1,R1                                               @30A
* Format M4
         IC    R1,TEXT+2               load R3M4                   @30A
         NILL  R1,X'000F'              clear R1                    @30A
         JZ    INSTOUT                 branch if M4 is zero        @30A
         MVI   0(R15),C','                                         @30A
         CVD   R1,DBLWD                convert M4 to decimal       @30A
         OI    DBLWD+7,X'0F'           clear sign                  @30A
         UNPK  DBLWD(2),DBLWD+6(2)     unpack                      @30A
         CHI   R1,10                   M4 < 10                     @30A
         JL    RRFAMASK                branch if yes               @30A
         MVC   1(2,R15),DBLWD          Move M4  10-15              @30A
         J     INSTOUT                 write instruction record    @30A
RRFAMASK MVC   1(1,R15),DBLWD+1        Move M4  0-9                @30A
         J     INSTOUT                 write instruction record    @30A
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RRFA     *
* TYPE INSTRUCTION.     OPCODE  R1,R3,R2,M4                      *
*                                                                *
******************************************************************
RRFBOPND DS    0H                      *** RRFA FORMAT INSTRUCTIONS ***
         LA    R15,OPNDS                                           @30A
         SR    R1,R1                                               @30A
         IC    R1,TEXT+3               LOAD R1R2                   @30A
         SRL   R1,4                    SHIFT OUT R2                @30A
         CVD   R1,DBLWD                CONVERT                     @30A
         OI    DBLWD+7,X'0F'           CLEAR SIGN                  @30A
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK                      @30A
         MVI   0(R15),C'R'             Beginning operand 1         @30A
         CHI   R1,10                   R1 < 10                     @30A
         JL    RRFBR11                 YES                         @30A
         MVC   1(2,R15),DBLWD          Move R1  10-15              @30A
         AHI   R15,3                   To next position            @30A
         J     RRFBR31                 continue                    @30A
RRFBR11  MVC   1(1,R15),DBLWD+1        Move R1  0-9                @30A
         AHI   R15,2                   To next position            @30A
RRFBR31  MVC   0(2,R15),SCOMMAR        copy ',R'                   @30A
         SR    R1,R1                                               @30A
         IC    R1,TEXT+2               load R3M4                   @30A
         SRL   R1,4                    shift out M4                @30A
         CVD   R1,DBLWD                convert                     @30A
         OI    DBLWD+7,X'0F'           clear sign                  @30A
         UNPK  DBLWD(2),DBLWD+6(2)     unpack                      @30A
         CHI   R1,10                   R3 < 10                     @30A
         JL    RRFBR32                 branch if yes               @30A
         MVC   2(2,R15),DBLWD          move R3 10-15               @30A
         AHI   R15,4                   to next position            @30A
         J     RRFBR21                 continue                    @30A
RRFBR32  MVC   2(1,R15),DBLWD+1        move REG 0-9                @30A
         AHI   R15,3                   to next position            @30A
RRFBR21  MVC   0(2,R15),SCOMMAR        copy ',R'                   @30A
         SR    R1,R1                                               @30A
         IC    R1,TEXT+3               load R1R2                   @30A
         NILL  R1,X'000F'              clear R1                    @30A
         CVD   R1,DBLWD                convert R2 to decimal       @30A
         OI    DBLWD+7,X'0F'           clear sign                  @30A
         UNPK  DBLWD(2),DBLWD+6(2)     unpack                      @30A
         CHI   R1,10                   R2 < 10                     @30A
         JL    RRFBR22                 branch if yes               @30A
         MVC   2(2,R15),DBLWD          move R2 10-15               @30A
         AHI   R15,4                   to next position            @30A
         J     RRFBMSK1                branch if yes               @30A
RRFBR22  MVC   2(1,R15),DBLWD+1        move REG 0-9                @30A
         AHI   R15,3                   to next position            @30A
RRFBMSK1 MVI   0(R15),C','             copy ','                    @30A
         SR    R1,R1                                               @30A
         IC    R1,TEXT+2               load R3M4                   @30A
         SRL   R1,4                    shift out R3                @30A
         CVD   R1,DBLWD                convert M4                  @30A
         OI    DBLWD+7,X'0F'           clear sign                  @30A
         UNPK  DBLWD(2),DBLWD+6(2)     unpack M4                   @30A
         CHI   R1,10                   m4 < 10                     @30A
         JL    RRFBMSK2                branch if yes               @30A
         MVC   1(2,R15),DBLWD          move m4 10-15               @30A
         J     INSTOUT                 write instruction record    @30A
RRFBMSK2 MVC   1(1,R15),DBLWD+1        Move m4 0-9                 @30A
         J     INSTOUT                 write instruction record    @30A
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RRFC     *
* TYPE INSTRUCTION.          OPCODE R1,R2,M3                     *
*                                                                *
******************************************************************
RRFCOPND DS    0H                      *** RRFC FORMAT INSTRUCTIONS ***
         LA    R15,OPNDS                                           @30A
         SR    R1,R1                                               @30A
         IC    R1,TEXT+3               load R1R2                   @30A
         SRL   R1,4                    shift out R2                @30A
         CVD   R1,DBLWD                convert                     @30A
         OI    DBLWD+7,X'0F'           clear sign                  @30A
         UNPK  DBLWD(2),DBLWD+6(2)     unpack                      @30A
         MVI   0(R15),C'R'             beginning operand 1         @30A
         CHI   R1,10                   R1 < 10                     @30A
         JL    RRFCR11                 branch if yes               @30A
         MVC   1(2,R15),DBLWD          move R1  10-15              @30A
         AHI   R15,3                   to next position            @30A
         J     RRFCR12                 continue                    @30A
RRFCR11  MVC   1(1,R15),DBLWD+1        move R1  0-9                @30A
         AHI   R15,2                   to next position            @30A
RRFCR12  MVC   0(2,R15),SCOMMAR        copy ',R'                   @30A
         SR    R1,R1                                               @30A
         IC    R1,TEXT+3               load R1R2                   @30A
         NILL  R1,X'000F'              clear R1                    @30A
         CVD   R1,DBLWD                convert                     @30A
         OI    DBLWD+7,X'0F'           clear sign                  @30A
         UNPK  DBLWD(2),DBLWD+6(2)     unpack                      @30A
         CHI   R1,10                   R2 < 10                     @30A
         JL    RRFCR21                 YES                         @30A
         MVC   2(2,R15),DBLWD          Move REG 10-15              @30A
         AHI   R15,4                   To next position            @30A
         J     RRFCR22                 continue                    @30A
RRFCR21  MVC   2(1,R15),DBLWD+1        Move REG 0-9                @30A
         AHI   R15,3                   To next position            @30A
RRFCR22  MVI   0(R15),C','             Delimiters                  @30A
         SR    R1,R1                   clear R1                    @30A
         IC    R1,TEXT+2               Load mask                   @30A
         CLI   ITYPE,RRFC              RRF type C instruction ?    @30A
         JE    RRFCMSK1                branch if yes               @30A
         NILL  R1,X'000F'              R1 = M4                     @30A
         J     RRFCMSK2                                            @30A
RRFCMSK1 SRL   R1,4                    R1 = M3                     @30A
RRFCMSK2 CVD   R1,DBLWD                convert mask to decimal     @30A
         OI    DBLWD+7,X'0F'           clear sign                  @30A
         UNPK  DBLWD(2),DBLWD+6(2)     unpack                      @30A
         CHI   R1,10                   mask < 10                   @30A
         JL    RRFCMSK3                branch if yes               @30A
         MVC   1(2,R15),DBLWD          move MASK 11-15             @30A
         J     INSTOUT                 write instruction record    @30A
RRFCMSK3 MVC   1(1,R15),DBLWD+1        move MASK 0-9               @30A
         J     INSTOUT                 write instruction record    @30A
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RRFE     *
* TYPE INSTRUCTION.          OPCODE R1,M3,R2,M4                  *
*                                                                *
******************************************************************
RRFEOPND DS    0H                      *** RRF FORMAT INSTRUCTIONS ***
         LA    R15,OPNDS                                           @30A
         CLIY  -1(R15),C' '                                        @30A
         JE    RRFER10                                             @30A
         AHI   R15,1                                               @30A
RRFER10  MVI   0(R15),C'R'             Move                        @30A
         SR    R1,R1                                               @30A
         IC    R1,TEXT+3               load R1R2                   @30A
         SRL   R1,4                    shift out R2                @30A
         CVD   R1,DBLWD                convert R1 to decimal       @30A
         OI    DBLWD+7,X'0F'           clear sign                  @30A
         UNPK  DBLWD(2),DBLWD+6(2)     unpack                      @30A
         CHI   R1,10                   R1 < 10                     @30A
         JL    RRFER11                 branch if yes               @30A
         MVC   1(2,R15),DBLWD          move R1 11-15               @30A
         AHI   R15,3                   to next position            @30A
         J     RRFER12                 continue                    @30A
RRFER11  MVC   1(1,R15),DBLWD+1        move R1 0-9                 @30A
         AHI   R15,2                   to next position            @30A
RRFER12  MVI   0(R15),C','             copy comman                 @30A
         SR    R1,R1                   clear R1                    @30A
*  Format M3 @30A
         IC    R1,TEXT+2               load M3M4                   @30A
         SRL   R1,4                    shift out M4                @30A
         CVD   R1,DBLWD                convert M3 to decimal       @30A
         OI    DBLWD+7,X'0F'           clear sign                  @30A
         UNPK  DBLWD(2),DBLWD+6(2)     unpack M3                   @30A
         CHI   R1,10                   M3 < 10                     @30A
         JL    RRFEM31                 branch if yes               @30A
         MVC   1(2,R15),DBLWD          Move mask 10-15             @30A
         AHI   R15,3                   To next position            @30A
         J     RRFEM32                 branch if yes               @30A
RRFEM31  MVC   1(1,R15),DBLWD+1        move mask 0-9               @30A
         AHI   R15,2                   To next position            @30A
RRFEM32  MVC   0(2,R15),SCOMMAR        copy ',R'                   @30A
         SR    R1,R1                                               @30A
         IC    R1,TEXT+3               load R1R2                   @30A
         NILL  R1,X'000F'              clear R1                    @30A
         CVD   R1,DBLWD                convert R2 to decimal       @30A
         OI    DBLWD+7,X'0F'           clear sign                  @30A
         UNPK  DBLWD(2),DBLWD+6(2)     unpack R2                   @30A
         CHI   R1,10                   R2 < 10                     @30A
         JL    RRFER21                 branch if yes               @30A
         MVC   2(2,R15),DBLWD          move mask 10-15             @30A
         AHI   R15,4                   to next position            @30A
         J     RRFER22                 branch if yes               @30A
RRFER21  MVC   2(1,R15),DBLWD+1        move R2  0-9                @30A
         AHI   R15,3                   to next position            @30A
RRFER22  SR    R1,R1                                               @30A
*  Format M4
         IC    R1,TEXT+2               load M3M4                   @30A
         NILL  R1,X'000F'              clear M3                    @30A
         JZ    INSTOUT                                             @30A
         MVI   0(R15),C','             copy comma                  @30A
         CVD   R1,DBLWD                convert m4 to decimal       @30A
         OI    DBLWD+7,X'0F'           clear sign                  @30A
         UNPK  DBLWD(2),DBLWD+6(2)     unpack                      @30A
         CHI   R1,10                   M4 < 10                     @30A
         JL    RRFEM4                  branch if yes               @30A
         MVC   1(2,R15),DBLWD          move M4 10-15               @30A
         J     INSTOUT                 Write instruction record    @30A
RRFEM4   MVC   1(1,R15),DBLWD+1        Move M4 0-9                 @30A
         J     INSTOUT                 Write instruction record    @30A
******************************************************************
*       D1(L1,B1),D2(B2)                                         *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE  *
* INSTRUCTIONS OF THE SINGLE LENGTH VARIETY. THE BDLADR ROUTINE  *
* IS CALLED TO FORMAT THE 1ST STRG OPND, AND BDADR FOR THE 2ND.  *
*                                                                *
******************************************************************
SS1OPND  DS    0H                      *** SS FORMAT INSTRUCTIONS ***
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET LENGTH CODE
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         JAS   R9,BDLADR               CONVERT 1ST BDDD ADDRESS
         EX    R10,SOPMVC              MVC   OPNDS(1),OPNDWK
         LA    R15,OPNDS+1(R10)        TO NEXT POS
         MVI   0(R15),C','             DELIMITER
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET 2ND BDDD ADDRESS
         JAS   R9,BDADR                CONVERT 2ND OPERAND ADDRESS
         EX    R10,BDXMVC              MVC   1(1,R15),OPNDWK
         CLI   COMMENT,C' '            NO COMMENT ??               @14A
         JNE   INSTOUT                 BRANCH IF IT HAS COMMENT    @14A
         CLI   TEXT,X'D2'              MVC INSTRUCTION ??          @12A
         JNE   INSTOUT                 BRANCH IF NOT MVC OP CODE   @12A
         MVC   COMMENT(L'S28),S28      COPY DATA                   @12A
         J     INSTOUT                 WRITE INSTRUCTION RECORD    @14C
******************************************************************
*                                                                *
*       D1(L1,B1),D2(L2,B2)                                      *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE  *
* INSTRUCTIONS OF THE DOUBLE LENGTH VARIETY. THE BDLADR ROUTINE  *
* IS CALLED TO FORMAT THE STORAGE OPERANDS.                      *
*                                                                *
******************************************************************
SS2OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - 2 L
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET L1L2
         SRL   R10,4                   SHIFT OUT L2
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         JAS   R9,BDLADR               CONVERT ADDRESS
         EX    R10,SOPMVC              MVC   OPNDS(1),OPNDWK
         LA    R15,OPNDS+1(R10)        TO NEXT POS
         MVI   0(R15),C','             DELIMITER
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET 2ND BDDD ADDR
         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP L2L1
         SRL   R10,4                   SHIFT OUT L1
         CLI   TEXT,X'F0'              SRP OP-CODE
         JE    SRPOP2                  YES
         JAS   R9,BDLADR               CONVERT ADDRESS
         EX    R10,BDXMVC              MOVE 2ND OPERAND
         J     INSTOUT                 WRITE INSTRUCTION RECORD    @14C
SRPOP2   JAS   R9,BDADR                GO BUILD OPERAND 2
         EX    R10,BDXMVC              MVC   1(1,R15),OPNDWK
         LA    R15,2(R10,R15)          TO NEXT OPERAND POS
         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP I3L1
         SRL   R10,4                   SHIFT OUT L1
         CVD   R10,DBLWD               CONVERT I3
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         MVI   0(R15),C','             OPERAND SEPARATOR
         UNPK  1(1,R15),DBLWD+7(1)     UNPACK I3 TO OPERAND
         CHI   R2,10                   I3 < 10
         JL    INSTOUT                 YES
         UNPK  1(2,R15),DBLWD+6(2)     NO, UNPACK MORE
         J     INSTOUT                 CONTINUE
*
*
********************************************************************
* NEW ROUTINE TO HANDLE XMS SS3 INSTRUCTION                    @04A*
*                D1(R1,B1),D2(B2),R3                               *
*                                                                  *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS3-TYPE   *
* INSTRUCTIONS OF THE REGISTER LENGTH VARIETY. THE BDADR ROUTINE   *
* IS CALLED TO FORMAT THE SECOND STORAGE OPERAND. SUBROUTINE       *
* BDXADR IS CALLED TO FORMAT THE FIRST STORAGE OPERAND.            *
* D1(R1,B1),D2(B2),R3                                              *
********************************************************************
*
SS3OPND  EQU   *                       *** SS3 FORMAT INSTRUCTIONS ***
         MVC   COMMENT(9),S13          XMS INSTR
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              PICK UP R1R3
         SRL   R10,4                   SHIFT RIGHT 4 BIT TO REMOVE R3
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD
         JAS   R9,BDXADR               CONVERT RX ADDRESS
         LA    R15,OPNDS-1             TO NEXT POS
         EX    R10,BDXMVC              MOVE RX OPERAND
         LA    R15,OPNDS+1(R10)        TO NEXT POS
         MVI   0(R15),C','             DELIMITER
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET 2ND BDDD ADDRESS
         JAS   R9,BDADR                CONVERT 2ND BDDD ADDRESS
         EX    R10,BDXMVC              MVC   1(1,R15),OPNDWK
         LA    R15,2(R15,R10)          TO NEXT POSITION
         MVC   0(2,R15),SCOMMAR        DELIMITER3   ,R
         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE
         SR    R1,R1                   CLEAR WORK
         IC    R1,DBLWD                GET R2R3
         SRL   R1,4                    SHIFT OUT R1
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CHI   R1,10                   R3 > 9
         JL    RR31                    NO, 0-9
         MVC   2(2,R15),DBLWD          YES, MOVE REG 10-15
         J     INSTOUT                 WRITE INSTRUCTION RECORD
RR31     MVC   2(1,R15),DBLWD+1        MOVE REG 0-9
         J     INSTOUT                 WRITE INSTRUCTION RECORD    @14C
********************************************************************
* NEW ROUTINE TO HANDLE SS4 INSTRUCTION                        @04A*
*                D1(B1),D2(L2,B2)                                  *
*                                                                  *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS4-TYPE   *
* INSTRUCTIONS OF THE REGISTER LENGTH VARIETY. THE BDADR ROUTINE   *
* IS CALLED TO FORMAT THE SECOND STORAGE OPERAND. SUBROUTINE       *
* BDXADR IS CALLED TO FORMAT THE FIRST STORAGE OPERAND.            *
*                                                                  *
********************************************************************
SS4OPND  DS    0H                      *** SS4 FORMAT INSTRUCTIONS ***
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET 1ST BDDD ADDRESS
         JAS   R9,BDADR                CONVERT 1ST BDD ADDRESS
         EX    R10,SOPMVC              MVC   OPNDS(1),OPNDWK
         LA    R15,OPNDS+1(R10)        TO NEXT POS
         MVI   0(R15),C','             DELIMITER
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET LENGTH CODE
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET SECOND BDDD ADDRESS
         JAS   R9,BDLADR               CONVERT ADDRESS
         EX    R10,BDXMVC              MOVE 2ND OPERAND
         J     INSTOUT                 WRITE INSTRUCTION RECORD    @14C
********************************************************************
* NEW ROUTINE TO HANDLE SSE FORMAT INSTRUCTION                 @02A*
*                                                                  *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE    *
* INSTRUCTIONS OF THE REGISTER LENGTH VARIETY. THE BDADR ROUTINE   *
* IS CALLED TO FORMAT THE SECOND STORAGE OPERAND. SUBROUTINE       *
* BDXADR IS CALLED TO FORMAT THE FIRST STORAGE OPERAND.            *
*                                                                  *
********************************************************************
SSEOPND  EQU   *                       *** SSE FORMAT INSTRUCTIONS
         CLC   ITPROT,TEXT             TPROT OP CODE ??            @15A
         JNE   SSEOPND2                BRANCH IF NOT               @15A
         MVC   COMMENT(L'S38),S38      INVALID ADDRESS ??          @15A
SSEOPND2 SR    R11,R11                 CLEAR WORK                  @02A
         CLC   S_PLO,MNEMONIC          PLO INSTRUCTION ??          @29A
         JNE   SSEOPND3                BRANCH IF NOT               @29A
*  PLO   R1,D2(B2),R3,D4(B4)                                       @29A
         SR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               GET 2ND BYTE
         SRL   R1,4                    SHIFT OUT R2
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         MVI   OPNDS,C'R'              BEGIN R1 OPERAND
         CHI   R1,10                   REG NBR > 9
         JL    SSEPLO1                 NO, 0-9
         MVC   OPNDS+1(2),DBLWD        YES, 10-15
         LA    R15,OPNDS+3              TO NEXT POS
         J     SSEPLO2                 NO, 0-9
SSEPLO1  MVC   OPNDS+1(1),DBLWD+1      MOVE REG NBR
         LA    R15,OPNDS+2              TO NEXT POS
SSEPLO2  SR    R11,R11                                             @29A
         ICM   R11,3,TEXT+2            GET 1ST BDDD ADDRESS        @29A
         JAS   R9,BDADR                CONVERT 1ST BDDD ADDRESS    @29A
         MVI   0(R15),C','
         J     SSEOPND4                NO, 0-9
SSEOPND3 DS    0H                      CONTINUE
         ICM   R11,3,TEXT+2            GET 1ST BDDD ADDRESS        @02A
         JAS   R9,BDADR                CONVERT 1ST BDDD ADDRESS    @02A
         LA    R15,OPNDS-1             TO FIRST OPERAND            @02A
SSEOPND4 EX    R10,BDXMVC              MVC   1(1,R15),OPNDWK       @02A
         LA    R15,2(R10,R15)          TO NEXT POS                 @08A
         MVI   0(R15),C','             DELIMITER                   @02A
         SR    R11,R11                 CLEAR WORK                  @02A
         CLC   S_PLO,MNEMONIC          PLO INSTRUCTION             @29A
         JNE   SSEOPND5                                            @29A
         MVI   1(R15),C'R'                                         @02A
         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE
         IC    R11,DBLWD               GET R2R1
         SRL   R11,4                   SHIFT OUT R1
         CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CHI   R11,10                  R2 > 9
         JL    SSEPLO3                 NO, 0-9
         MVC   2(2,R15),DBLWD          YES, MOVE REG 10-15
         LA    R15,4(,R15)
         J     SSEPLO4                                             @29A
SSEPLO3  MVC   2(1,R15),DBLWD+1        MOVE REG 0-9
         LA    R15,3(,R15)
SSEPLO4  MVI   0(R15),C','                                         @02A
SSEOPND5 ICM   R11,3,TEXT+4            GET 2ND BDDD ADDRESS        @02A
         JAS   R9,BDADR                CONVERT 2ND BDDD ADDRESS    @02A
         EX    R10,BDXMVC              MVC   1(1,R15),OPNDWK       @02A
         CLC   S_LASP,MNEMONIC         LASP INSTRUCTION ??         @22A
         JNE   SSECOMT                 BRANCH IF NOT               @22A
         MVC   COMMENT(L'S40),S40                                  @22A
         J     INSTOUT                                             @22A
SSECOMT  CLI   COMMENT,C' '            SSE INSTR                   @02A
         JNE   INSTOUT                 WRITE INSTRUCTION RECORD    @15A
         MVC   COMMENT(L'S14),S14      SSE INSTR                   @15A
         J     INSTOUT                 WRITE INSTRUCTION RECORD    @14C
********************************************************************
* NEW ROUTINE TO HANDLE SSF INSTRUCTION                        @21A*
*                D1(B1),D2(B2),R3                                  *
*                                                                  *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS3-TYPE   *
* INSTRUCTIONS OF THE REGISTER LENGTH VARIETY. THE BDADR ROUTINE   *
* IS CALLED TO FORMAT THE FIRST AND SECOND OPERAND.                *
*                                                                  *
********************************************************************
SSFOPND  DS    0H                      *** SSF FORMAT INSTRUCTIONS @21A
         SR    R10,R10                 CLEAR WORK                  @21A
         IC    R10,TEXT+1              PICK UP X2R1                @21A
         SRL   R10,4                   SHIFT OUT R1                @21A
         SR    R11,R11                 CLEAR WORK                  @21A
         ICM   R11,3,TEXT+2            GET 1ST BDDD                @21A
         JAS   R9,BDADR                CONVERT 1ST BDDD ADDRESS    @21A
         LA    R15,OPNDS-1             TO NEXT POS                 @21A
         EX    R10,BDXMVC              MVC   1(1,R15),OPNDWK       @21A
         LA    R15,OPNDS+1(R10)        TO NEXT POS                 @21A
         MVI   0(R15),C','             DELIMITER                   @21A
         SR    R11,R11                 CLEAR WORK                  @21A
         ICM   R11,3,TEXT+4            GET 2ND BDDD ADDRESS        @21A
         JAS   R9,BDADR                CONVERT 2ND BDDD ADDRESS    @21A
         EX    R10,BDXMVC              MVC   1(1,R15),OPNDWK       @21A
         LA    R15,2(R15,R10)          TO NEXT POSITION            @21A
         MVC   0(2,R15),SCOMMAR        DELIMITER3   ,R             @21A
         SR    R1,R1                   CLEAR WORK                  @21A
         IC    R1,TEXT+1                                           @21A
         SRL   R1,4                    SHIFT OUT R1                @21A
         CVD   R1,DBLWD                CONVERT                     @21A
         OI    DBLWD+7,X'0F'           CLEAR SIGN                  @21A
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK                      @21A
         CHI   R1,10                   R3 > 9                      @21A
         JL    SSF31                   NO, 0-9                     @21A
         MVC   2(2,R15),DBLWD          YES, MOVE REG 10-15         @21A
         J     INSTOUT                 WRITE INSTRUCTION RECORD    @21A
SSF31    MVC   2(1,R15),DBLWD+1        MOVE REG 0-9                @21A
         J     INSTOUT                 WRITE INSTRUCTION RECORD    @21A
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT COND-    *
* ITIONAL BRANCH INSTRUCTIONS. AN ATTEMPT IS MADE TO USE THE     *
* EXTENDED MNEMONICS WHERE POSSIBLE. FOR RR-TYPE AND RX-TYPE     *
* INSTRUCTION USE CCTYPE TO SEARCH THE CONDITIONAL CODE TABLE    *
* TO GET MNEMONIC NAMES.                                         *
*                                                                *
* CCTYPE IS SAVED BY THE LAST CONDITION-CODE-SETTING INSTRUCTION *
******************************************************************
BCOPND   DS    0H                * CONDITIONAL BRANCH INSTRUCTION  @21A
         SR    R2,R2                                               @21A
         LA    R15,OPNDS               NEXT POS                    @21A
         MVC   TEMP1,TEXT+1            COPY COND CODE              @21A
         NI    TEMP1,X'F0'             CLEAR REGISTER OPERAND      @21A
         MVC   MNEMONIC,BLANX          CLEAR MNEMONIC              @21A
         MVI   MNEMONIC,C'B'           SET BXX MNEMONIC CODE       @21A
         CLI   TEMP1,X'00'             NOP ?                       @21A
         JE    BCNOP                   BRANCH IF YES               @21A
         CLI   TEMP1,X'F0'             UNCONDITIONAL BRANCH?       @21A
         JE    BCSBR                   BRANCH IF YES               @21A
         L     R12,CCODEAD             GET ADDRESS OF COND CODE    @21A
         LR    R0,R12                      TABLE INDEX ENTRY       @21A
BC1CCIX  CLI   0(R12),X'FF'            END OF COND CODE TABLE?     @21A
         JE    BCCDFT              IF END OF TABLE THEN USE DFT CC @21A
         CLC   CCTYPE,0(R12)           RIGHT CONDITION CODE INDEX  @21A
         JE    BCFCCTB                 BRANCH IF YES               @21A
         AHI   R12,CC1LEN              POINT TO NEXT INDEX ENTRY   @21A
         J     BC1CCIX                 TRY NEXT INDEX ENTRY        @21A
BCCDFT   L     R12,CCODEAD             GET ADDRESS OF COND CODE TB @21A
         LR    R0,R12                                              @21A
BCFCCTB  AH    R0,2(R12)               LOCATE COND CODE TABLE      @21A
         LR    R12,R0                         ENTRY                @21A
BCFCCTBE CLI   0(R12),X'FF'            END OF COND CODE TABLE?     @20C
         JE    BCCDFT              IF END OF TABLE THEN USE DFT CC @21A
         CLC   TEMP1,0(R12)            RIGHT CONDITION CODE ??     @21A
         JE    BCFOUND                 BRANCH IF YES               @21A
         AHI   R12,CC2LEN              POINT TO NEXT TABLE ENTRY   @21A
         J     BCFCCTBE                TRY NEXT ENTRY              @21A
BCFOUND  DS    0H                                                  @21A
         MVC   COMMENT(L'SBRANCH),SBRANCH     COPY 'Jump if '      @21A
         MVC   COMMENT+8(17),3(R12)    COPY DESCRIPTION            @21A
         MVC   MNEMONIC+1(2),1(R12)                                @21A
         CLI   MNEMONIC+1,C'C'         BRANCH ON C?                @21A
         JNE   BC1CONT                 BRANCH IF NO                @21A
         SR    R1,R1                   CLEAR WORK                  @21A
         IC    R1,TEMP1                GET COND CODE               @21A
         SRL   R1,4                    SHIFT 4 BITS                @21A
         STC   R1,TEMP1                SAVE COND CODE              @21A
         CHI   R1,9                    COND CODE > 9               @21A
         JH    BCFCC2                  JUMP IF CC > 9              @21A
         OI    TEMP1,X'F0'             MAKE IT CC PRINTABLE        @21A
         MVC   0(1,R15),TEMP1          COPY COND CODE              @21A
         MVI   1(R15),C','                                         @21A
         AHI   R15,2                   NEXT POS                    @21A
         LA    R2,2                                                @21A
         J     BC1CONT                                             @21A
BCFCC2   MVI   0(R15),C'1'                                         @21A
         AHI   R1,-10                                              @21A
         STC   R1,TEMP1                                            @21A
         OI    TEMP1,X'F0'                                         @21A
         MVC   1(1,R15),TEMP1                                      @21A
         MVI   2(R15),C','                                         @21A
         AHI   R15,3                   NEXT POS                    @21A
         LA    R2,3                    ASSUME 3 BYTES              @21A
         J     BC1CONT                 YES                         @21A
BCSBR    MVC   COMMENT(5),SBRANCH      COPY 'JUMP '                @12A
BC1CONT  DS    0H                                                  @12A
         CLI   TEXT,X'47'              BC INSTRUCTION ??           @12A
         JE    BCXOPND                 BRANCH IF YES               @12A
*                                      MUST BE BCR INSTRUCTION     @12A
         CLI   MNEMONIC+1,C' '         BCR INSTRUCTION R?          @12A
         JE    BCRBR1                                              @12A
         CLI   MNEMONIC+2,C' '         BCR INSTRUCTION R??         @12A
         JE    BCRBR2                                              @12A
         CLI   MNEMONIC+3,C' '                                     @12A
         JE    BCRBR3                                              @12A
         MVI   MNEMONIC+4,C'R'                                     @12A
         J     BC2CONT                                             @12A
BCRBR1   MVI   MNEMONIC+1,C'R'                                     @12A
         J     BC2CONT                                             @12A
BCRBR2   MVI   MNEMONIC+2,C'R'                                     @12A
         J     BC2CONT                                             @12A
BCRBR3   MVI   MNEMONIC+3,C'R'                                     @12A
BC2CONT  DS    0H                                                  @12A
         CLI   TEXT+1,X'FE'            IS IT BR R14 INSTR
         JNE   BCFOREG                 NO
         MVC   COMMENT(L'S19),S19      SET COMMENT TO EXIT
BCFOREG  JAS   R9,FORRG1               FORMAT OPERAND1             @12A
         CLI   INLNG,X'02'             TWO BYTES INSTRUCTION ??    @12A
         JE    INSTOUT                                             @12A
BCNOP    MVC   MNEMONIC(3),SNOP        SET MNEMONIC TO NOP         @20C
         CLI   TEXT,X'07'              NOPR OP CODE ?              @20A
         JNE   BCXOPND                                             @20A
         MVI   MNEMONIC+3,C'R'                                     @20A
         J     BCFOREG                 FORMAT REGISTER             @20A
BCXOPND  LA    R15,OPNDS-1             TO OPND POS                 @12A
         CLI   MNEMONIC+1,C'C'         BC MNEMONIC INSTR ??        @12A
         JNE   BCF2OPND                NO                          @12A
         AR    R15,R2                  SHIFT 2 OR 3 BYTES          @12A
BCF2OPND PACK  DBLWD(1),TEXT+1(1)      PACK 2ND BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP X2M1
         SRL   R10,4                   SHIFT OUT M1
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            PICK UP BDDD ADDRESS
         JAS   R9,BDXADR               CONVERT RX ADDRESS
         EX    R10,BDXMVC              MOVE OPERAND
         JAS   R14,PRTREGS             PRINT REGISTER USEAGE       @23A
         J     INSTOUT                 GO TO EXIT
******************************************************************
*                                                                *
* VALIDATE AND FORMAT SVC INSTRUCTIONS. IF THE SVC OP-CODE IS    *
* FOUND IN THE SVC TABLE, IT IS ACCEPTED AS AN SVC, AND THE TABLE*
* LITERAL IS MOVED TO THE COMMENTS FIELD OF THE INSTRUCTION.     *
*                                                                *
******************************************************************
SVCOPND  EQU   *                       *** SVC INSTRUCTIONS ***
         CLI   TEXT+1,139              SVC NO > 139
         JH    NOTSVC                  YES, NOT SVC
*        LRL   R1,SVCTBLAD             GET SVC TABLE ADDRESS
         L     R1,SVCTBLAD             GET SVC TABLE ADDRESS
SVCKND   CLI   0(R1),X'FF'             END OF SVC TABLE
         JE    NOTSVC                  YES, MUST NOT BE SVC
         CLC   0(1,R1),TEXT+1          THIS THE ENTRY
         JE    GOTSVC                  YES
         AHI   R1,SVCOPLEN             STEP TO NEXT SVC ENTRY
         J     SVCKND                  LOOP THRU SVC TABLE
NOTSVC   J     NOTINST                 ERROR RETURN                @12C
GOTSVC   CLI   COMMENT,C' '                                        @31A
         JNE   GOTSVC2                                             @31A
         MVC   COMMENT(16),1(R1)       COMMENT TO WORK AREA
GOTSVC2  SR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               GET SVC OPERAND
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK
         CHI   R1,100                  OPERAND > 100
         JL    SVCK10                  YES
         MVC   OPNDS(3),DBLWD          MOVE 3-DIGIT OPERAND
         J     INSTOUT                 EXIT
SVCK10   CHI   R1,10                   OPERAND < 10
         JL    SVCL10                  YES
         MVC   OPNDS(2),DBLWD+1        MOVE 2-DIGIT OPERAND
         J     INSTOUT                 WRITE INSTRUCTION RECORD
SVCL10   MVC   OPNDS(1),DBLWD+2        MOVE 1-DIGIT OPERAND
         J     INSTOUT                 WRITE INSTRUCTION RECORD    @14C
******************************************************************
* EXTENDED FORMAT                                                *
******************************************************************
EOPND    DS    0H                                                  @14A
         CLC   0(2,R7),ISAM64          SAM64 INSTR ??              @14A
         JNE   INSTOUT                                             @14A
         MVC   COMMENT(L'SSAM64),SSAM64     64 BIT ADDRESSING      @14A
         J     INSTOUT                 WRITE INSTRUCTION RECORD    @14C
******************************************************************
* BUILD EQU STATEMENTS USING THE LABEL TABLE ENTRY ADDRESSED BY  *
* REG 6 ON ENTRY.                                                *
*                                                                *
******************************************************************
EQUSTMT  EQU   *                       BUILD EQU STATEMENTS
         ST    R9,EQU9                 SAVE RETURN ADDR
         USING LABELD,R6
         MVC   NAME(L'LBLNAME),LBLNAME     NAME TO EQU STMT        @25C
         CLI   NAME+8,X'00'                                        @25A
         JE    CCXQUIT                                             @25A
         CLI   NAME+8,C' '                                         @25A
         JE    CCXQ03                                              @25A
         MVC   MNEMONIC+6(L'S_EQU),S_EQU   BUILD EQU STATEMENT     @28C
         LA    R9,OPNDS+5                                          @28A
         J     CCXQ05                                              @25A
CCXQ03   MVC   MNEMONIC(L'S_EQU),S_EQU     BUILD EQU STATEMENT     @20C
         LA    R9,OPNDS                                            @28A
CCXQ05   MVI   0(R9),C'*'              SET EQU OPERAND             @28C
         CLI   LBLLEN,1                LENGTH 0 OR 1
         JNH   CCXEQU                  YES
         SR    R0,R0                   CLEAR WORK
         IC    R0,LBLLEN               GET LENGTH
         CVD   R0,DBLWD                CONVERT
         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK
         OI    DBLWD+2,C'0'            CLEAR SIGN
         CHI   R0,100                  LENGTH < 100
         JL    CCXQ10                  YES
         MVC   2(3,R9),DBLWD           MOVE LENGTH                 @28C
         J     CCXEQC                  GO SET COMMA
CCXQ10   CHI   R0,10                   LENGTH < 10
         JL    CCXQ1                   YES
         MVC   2(2,R9),DBLWD+1         MOVE 2-DIGIT LENGTH         @28C
         J     CCXEQC                  GO SET COMMA
CCXQ1    MVC   2(1,R9),DBLWD+2         MOVE 1-DIGIT LENGTH         @28C
CCXEQC   MVI   1(R9),C','              SET COMMA                   @28C
CCXEQU   JAS   R9,WRTOUT               OUTPUT EQU STATEMENT
         JAS   R9,PRINT                GO PRINT IT
CCXQUIT  L     R9,EQU9                 GET RETURN ADDR
         BR    R9                      RETURN
         DROP  R6
WRTOUT   L     R15,WRITEOUT                                        @30A
         BALR  R14,R15                 WRITE SYSPRINT              @30A
WRTPUNCH DS    0H                                                  @30A
         L     R1,PUNCHDCB             @ SYSPUNCH DCB
         MVC   PRT+25(80),WORKREC      COPY WORKREC TO PRT         @14A
         TM    48(R1),X'10'            IS SYSPUNCH OPEN ?
         JZ    CLRWKR                  NO
         PUT   (1),WORKREC             WRITE SOURCE CARD TO SYSPUNCH
CLRWKR   MVI   WORKREC,C' '            CLEAR OUTPUT RECORD
         MVC   WORKREC+1(L'WORKREC-1),WORKREC
         MVC   COMMENT,WORKREC         CLEAR COMMENT              @18A
         MVI   OPNDWK,C' '             CLEAR OPNDWK TO BLANK      @15A
         MVC   OPNDWK+1(L'OPNDWK-1),OPNDWK                        @15A
         CLC   IBR14,0(R7)                                        @27A
         BNER  R9                                                 @27A
         TM    48(R1),X'10'            IS SYSPUNCH OPEN ?         @28A
         BZR   R9                      NO                         @28A
         L     R1,PUNCHDCB             @ SYSPUNCH DCB             @27A
         PUT   (1),COMTREC             WRITE COMMENT LINE         @27A
         BR    R9                      RETURN                     @30A
*
******************************************************************
*                                                                *
* FORMAT FIRST OPERAND FIELD TO REGISTER                         *
*                                                                *
******************************************************************
FORRG1   DS    0H                                                  @12A
         SR    R10,R10                 CLEAR WORK                  @12A
         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE               @12A
         IC    R10,DBLWD               PICK UP R2M1                @12A
         SRL   R10,4                   REMOVE 1ST REG              @12A
FORRGC   CVD   R10,DBLWD               CONVERT                     @12A
         OI    DBLWD+7,X'0F'           CLEAR SIGN                  @12A
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK                      @12A
         LA    R15,OPNDS-1             TO OPND POS                 @12A
         CLI   0(R15),C' '             MNEMOMIC CODE IS 6 ?        @20A
         JE    FORR5                                               @20A
         LA    R15,OPNDS               TO OPND POS                 @20A
FORR5    CLI   MNEMONIC+1,C'C'         BC MNEMONIC INSTR ??        @12A
         JNE   FORRC
         AR    R15,R2
FORRC    ST    R9,FORRG9               SAVE RETURN ADDR            @12A
         MVI   1(R15),C'R'             REGISTER DELIMITER          @12A
         CHI   R10,10                  REG NBR < 10                @12A
         JL    FORR1                   YES, 0-9                    @12A
         MVC   2(2,R15),DBLWD          MOVE 2-DIGIT REG NBR        @12A
         AHI   R15,1                                               @12A
         J     FORRG1EX                                            @12A
FORR1    MVC   2(1,R15),DBLWD+1        MOVE 1-DIGIT REG NBR        @12A
FORRG1EX DS    0H                                                  @12A
         AHI   R15,2                                               @12A
         L     R9,FORRG9                                           @12A
         BR    R9                      RETURN                      @12A
******************************************************************
*                                                                *
* BUILDS STORAGE OPERANDS CONTAINING BASE, DISPLACEMENT, AND     *
* LENGTH. ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS, AND REG 10 *
* CONTAINS THE LENGTH. THE SCHLBL ROUTINE IS CALLED TO CREATE A  *
* LABEL REFERENCE, IF THE BASE REG IS CURRENT, AND A LABEL EXISTS*
* IF SCHLBL IS UNSUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM     *
* DDDD(LLL,RRR) IS CREATED. EACH BASE REGISTER HAS CORRESPONDING *
* DSECT ENTRY. IF THE DSECT ENTRY IS NON BLANK, CALL SRCHDSCT    *
* TO GET VARIBALE NAME FROM GLOBAL AND LOCAL MAPPING.            *
* INPUT  : R1  = BDDD                                            *
* OUTPUT : R10 = LENGTH OF FORMATTED FIELD (ie LLL)              *
*          OPNDWK = FORMATTED OPERAND                            *
* WORKING VARIABLE : BASERG                                      *
******************************************************************
*
BDLADR   EQU   *                  *** FORMAT DDDD(LLL,RRR) OPERAND
         ST    R9,BDL9                 SAVE RETURN ADDR
         ST    R11,BD11                SAVE R11                    @15A
         SR    R0,R0                   CLEAR WORK REG
         LR    R1,R11                  COPY BDDD ADDRESS
         SLDL  R0,20                   BASE REG TO R0
         LTR   R0,R0                   IS BASE REG 0
         JNZ   BDLD020                 NO                          @15A
         CLI   ICLASS,NPSA             NOT REFER PSA               @21C
         JE    BDLD020                 YES                         @21C
         CLI   COMMENT,C' '            COMMENT FIELD IS BLANK      @15A
         JNE   BDLD020                 SKIP IF COMMENT IS NONBLANK @15A
         MVC   COMMENT(L'S20),S20      SET COMMENT TO REFER PSA
*
BDLD020  LR    R1,R11                  R1 = BDDD                   @15A
         SRL   R1,12                   GET RID OF DDD              @15A
         NILL  R1,X'000F'              R1 = BASE REGISTER          @15A
         NI    FLAG1,255-FLGPSA-FLGFOUND    OFF PSA VAR NAME FIND  @17A
         STC   R1,BASERG               SAVE BASE REGISTER          @15A
         LTR   R1,R1                   PSA MAPPING ?               @15A
         JNZ   BDLD040                 BRANCH IF NOT PSA MAPPING   @20C
         CLI   ICLASS,NPSA             NOT REFERENCE STORAGE ?     @20A
         JE    BDLD040                 BRANCH IF YES               @21C
         OI    FLAG1,FLGPSA            TURN ON PSA PSAFLAG         @15A
BDLD040  DS    0H                                                  @29A
         ST    R15,BD15                SAVE R15                    @29A
         L     R15,SRCHDSCT            GET E.P. ADDRESS            @29A
         BALR  R14,R15                 CALL SRCHDSCT               @29A
         LTR   R15,R15                 RC = 0 ?                    @29A
         JNZ   BDLSCHL                 BRANCH IF RC IS NOT ZERO    @29A
         L     R15,BD15                RESTORE R15                 @29A
         TM    FLAG1,FLGPSA            PSA DSECT ?                 @15A
         JO    BDLGCMPP                BRANCH IF YES               @15A
         MVI   0(R1),C'-'                                          @14A
         AHI   R1,1                    NEXT POSITION               @15A
         TM    FLAG1,FLGUDSCT          USER DEFINE MAPPING ?       @25A
         JO    BDLUMAP                 BRANCH IF YES               @25A
         AHI   R4,6                                                @15A
         SR    R11,R11                 CLEAR R11                   @15A
         IC    R11,0(R4)            GET LENGTH OF DSECT PREFIX     @15A
         EX    R11,MVDS    ***         COPY DSECT PREFIX           @15A
         LA    R1,1(R1,R11)            R1 = END OF OPNDWK          @15A
BDLD050  SR    R11,R11                 CLEAR R11 FOR ICM OP        @15A
         IC    R11,BASERG              GET BASE REGISTER           @15A
         J     BDLLPN                                              @21A
BDLUMAP  L     R11,UDSCTAD             LOAD DSECT HEADER ADDRESS   @25A
         MVC   0(8,R1),0(R11)          COPY DSECT PREFIX           @25A
         AHI   R1,7                    POINT TO THE LAST BYTE      @25A
BDLUMAP2 CLI   0(R1),C' '              FIND THE                    @25A
         JNE   BDLUMAP3                  LENGTH OF                 @25A
         BCTR  R1,R0                        DSECT                  @25A
         J     BDLUMAP2                                            @25A
BDLUMAP3 AHI   R1,1                    LOCATE END OF OPNDWK        @25A
         J     BDLD050                 CONTINUE                    @25A
******
BDLSCHL  L     R11,BD11                RESTORE R11                 @14A
         L     R15,BD15                RESTORE R15                 @29A
         JAS   R9,SCHLBL               SEARCH FOR LABEL
         J     BDLGLBL                 BRANCH IF LABEL FOUND
*** LABEL NOT FOUND
         LR    R1,R11                  COPY BDDD ADDRESS
         SLL   R1,20                   SHIFT OUT B
         SRL   R1,20                   RIGHT JUSTIFY DDD
         CVD   R1,DBLWD                CONVERT DDD
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK
         MVC   OPNDWK,BLANX            CLEAR WORK AREA
         CHI   R1,1000                 DISPL < 1000
         JL    BDLD100                 YES
         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGITS DISPLACEMENT
         LA    R1,OPNDWK+4             TO NEXT POS
         J     BDLLPN                  CONTINUE
BDLD100  CHI   R1,100                  DISPL < 100
         JL    BDLD10                  YES
         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGITS DISPLACEMENT
         LA    R1,OPNDWK+3             TO NEXT POS
         J     BDLLPN                  CONTINUE
BDLD10   CHI   R1,10                   DISPL < 10
         JL    BDLD1                   YES
         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGITS DISPLACEMENT
         LA    R1,OPNDWK+2             TO NEXT POS
         J     BDLLPN                  CONTINUE
BDLD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPLACEMENT
         LA    R1,OPNDWK+1             TO NEXT POS
BDLLPN   MVI   0(R1),C'('              LEFT PAREN DELIMITER
         AHI   R10,1                   COMPUTE ACTUAL LENGTH FROM LENG
         CVD   R10,DBLWD               CONVERT BASERG TO DECIMAL
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK
         CHI   R10,100                 LENGTH < 100
         JL    BDLL10                  YES
         MVC   1(3,R1),DBLWD           MOVE 3-DIGIT LENGTH
         AHI   R1,4                    TO NEXT POS
         J     BDLCMA                  CONTINUE
BDLL10   CHI   R10,10                  LENGTH < 10
         JL    BDLL1                   YES
         MVC   1(2,R1),DBLWD+1         MOVE 2-DIGIT LENGTH
         AHI   R1,3                    TO NEXT POS
         J     BDLCMA                  CONTINUE
BDLL1    MVC   1(1,R1),DBLWD+2         MOVE 1-DIGIT LENGTH
         AHI   R1,2                    TO NEXT POS
BDLCMA   MVC   0(2,R1),SCOMMAR         DELIMITERS ,R
         SR    R11,11                                              @21A
         IC    R11,BASERG                                          @21A
BDLCMAC  CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CHI   R11,10                  REG < 10
         JL    BDLR1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT REGISTER
         AHI   R1,4                    TO NEXT POS
         J     BDLRPN                  CONTINUE
BDLR1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT REG
         CLI   2(R1),C'0'              IS REG = 0
         JNE   BDLB1                   NO
         MVC   0(2,R1),BLANX           YES, BLANK IT
         J     BDLRPN                  CONTINUE
BDLB1    AHI   R1,3                    TO NEXT POS
BDLRPN   MVI   0(R1),C')'              FINAL DELIMITER
         LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE OPERAND LENGTH CODE
         L     R9,BDL9                 GET RETURN ADDR
         BR    R9                      EXIT
         USING DSECTD,R12
BDLGLBL  MVC   OPNDWK(L'DSLNAME),DSLNAME  LABEL ENTRY NAME TO WORK @25C
         CLI   DSLBTYP,C'D'            USER DEFINE DSECT ENTRY?    @19A
         JNE   BDLABEL                 BRANCH IF NO                @22A
         CLI   COMMENT,C' '   **DEBUG
         JNE   BDLABEL        **DEBUG
         MVC   COMMENT(L'DSCOMMT),DSCOMMT  COPY DSECT DESCRIPTION  @19A
BDLABEL  AHI   R10,1                   COMPUTE ACTUAL LENGTH
         LA    R1,OPNDWK+L'LBLNAME-1   @ LAST POSS CHARACTER       @25C
BDLGRHE  CLI   0(R1),X'00'             LAST POSS CHARACTER ?       @25A
         JE    BDLGRHE1                BRANCH IF HEXI ZERO         @25A
         CLI   0(R1),C' '              LAST POSS CHARACTER ?
         JNE   BDLGCKLN                BRANCH IF NOT BLANK
BDLGRHE1 BRCT  R1,BDLGRHE              LOOP TO GET @LAST POSS CHAR
BDLGCKLN MVI   1(R1),C'('              NO, DELIMITER
         CLM   R10,1,DSLENG            LBL AND INSTR LENGTHS SAME  @25C
         JE    BDLGCMP                 YES
         CVD   R10,DBLWD               CONVERT LENGTH
         UNPK  DBLWD(3),DBLWD+5(3)     UNPACK
         OI    DBLWD+2,C'0'            CLEAR SIGN
         CHI   R10,100                 LENGTH < 100
         JL    BDLG10                  YES
         MVC   2(3,R1),DBLWD           MOVE 3-DIGIT LENGTH
         AHI   R1,5                    TO NEXT POS
         J     BDLGRPN                 CONTINUE
BDLG10   CHI   R10,10                  LENGTH < 10
         JL    BDLG1                   YES
         MVC   2(2,R1),DBLWD+1         MOVE 2-DIGIT LENGTH
         AHI   R1,4                    TO NEXT POS
         J     BDLGRPN                 CONTINUE
BDLGCMPP BCTR  R1,0                    MINUS LENGTH FOR COPY       @15A
         J     BDLGCMP                                             @15A
BDLG1    MVC   2(1,R1),DBLWD+2         MOVE 1-DIGIT LENGTH
         AHI   R1,3                    TO NEXT POS
BDLGRPN  MVI   0(R1),C')'              FINAL DELIMITER
BDLGCMP  LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R12,SLSAV+12            RESTORE R12
         L     R9,BDL9                 GET RETURN ADDR
         BR    R9                      EXIT
         DROP  R12
******************************************************************
* BUILDS STORAGE OPERANDS CONTAINING BASE, DISPLACEMENT LOW,     *
* AND DISPLAYMENT HIGH AND INDEX. ON ENTRY, REG 11 CONTAINS      *
* THE BDDD ADDRESS, AND REG 10 CONTAINS THE INDEX REGISTER.      *
* THE SCHLBL ROUTINE IS CALLED TO FIND THE LABEL REFERENCE.      *
* IT BRANCHES TO ROUTINE BDAD400 TO COMPLETE THE Y OPERAND       *
* DATA FORMATING.                                                *
* DISPLACEMENT OF BDADR 4095 TO -4095                            *
*                                                                *
* INPUT  : R10    -> INDEX REGISTER                              *
*          R11    -> BDDD                                        *
*          R9     -> LINKAGE REGISTER                            *
*          TEXT   -> INSTRUCTION                                 *
******************************************************************
BDYADR   DS    0H              *** FORMAT BLLLHH OPERAND ***       @28A
         CLC   TEXT+3(2),X_FFFF        NEGATIVE DISPLACEMENT       @28A
         JE    BDADR                   BRANCH IF YES               @28A
         CLI   TEXT+4,X'00'            POSTIVE DISPLACEMENT        @28A
         JE    BDADR                                               @28A
         ST    R9,BD9                  SAVE RETURN ADDR            @28A
         JAS   R9,SCHLBL               GO SEARCH FOR LABEL         @28A
         J     BDAD700                 BRANCH IF FOUND             @28A
* LABEL IS NOT FOUND
         CLI   TEXT+4,X'FF'            NEGATIVE DISPLACEMENT ?     @28A
         JE    BDYNEG                  BRANCH IF YES               @28A
         SR    R1,R1                   CLEAR R1 FOR IC INSTRUCTION @28A
         IC    R1,TEXT+4               LOAD DISPLACEMENT HIGH      @28A
         SLL   R1,12                                               @28A
         SR    R9,R9                                               @28A
         ICM   R9,3,TEXT+2             LOAD DISPLACEMENT LOW       @28A
         NILL  R9,X'0FFF'                                          @28A
         AR    R1,R9                                               @28A
         CVD   R1,DBLWD                CONVERT                     @28A
         OI    DBLWD+7,X'0F'           CLEAR SIGN                  @28A
         UNPK  DBLWD2+2(6),DBLWD+5(3)  UNPACK                      @28A
         OI    DBLWD2+7,X'F0'                                      @28A
         MVC   OPNDWK(4),DBLWD2+4      MOVE 4-DIGIT DISPL          @28A
         CHI   R1,10000                DISPL < 10000               @28A
         JL    BDYADR4                 YES                         @28A
         MVC   OPNDWK(5),DBLWD2+3      MOVE 5-DIGIT DISPL          @28A
         LA    R1,OPNDWK+5             TO NEXT POS                 @28A
         J     BDAD400                 CONTINUE                    @28A
BDYADR4  LA    R1,OPNDWK+4             TO NEXT POS                 @28A
         J     BDAD400                 CONTINUE                    @28A
* Negative displacement                                            @28A
BDYNEG   MVC   DBLWD(2),TEXT+2         COPY DH                     @28A
         OI    DBLWD,X'F0'                                         @28A
         SR    R9,R9                                               @28A
         LH    R9,DBLWD                                            @28A
         LCR   R9,R9                                               @28A
         LA    R1,OPNDWK               TO NEXT POS                 @28A
         MVI   0(R1),C'-'                                          @28A
         AHI   R1,1                    NEXT POSITION               @28A
         CVD   R9,DBLWD                CONVERT DISPL               @28A
         OI    DBLWD+7,X'0F'           CLEAR SIGN                  @28A
         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK                      @28A
         OI    DBLWD+2,X'F0'                                       @28A
         CHI   R9,100                  > 100 ?                     @28A
         JL    BDY100                  Branch if less than 100     @28A
         MVC   0(3,R1),DBLWD                                       @28A
         AHI   R1,3                    NEXT POSITION               @28A
         J     BDAD400                 CONTINUE                    @28A
BDY100   CHI   R9,10                                               @28A
         JL    BDY200                                              @28A
         MVC   0(2,R1),DBLWD+1                                     @28A
         AHI   R1,2                    NEXT POSITION               @28A
         J     BDAD400                 CONTINUE                    @28A
BDY200   MVC   0(1,R1),DBLWD+2                                     @28A
         AHI   R1,1                    NEXT POSITION               @28A
         J     BDAD400                 CONTINUE                    @28A
******************************************************************
*                                                                *
* BUILDS STORAGE OPERANDS CONTAINING BASE AND DISPLACEMENT.      *
* CALL SRCHDSCT TO SEARCH GLOBAL MAPPING. IF NOT FOUND THE       *
* SCHLBL ROUTINE IS CALLED TO SEE WHETHER A LABEL REFERENCE MAY  *
* BE USED, RATHER THAN AN EXPLICIT ADDRESS. IF LBLSCH IS NOT     *
* SUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM DDDD(RRR) IS FORMED*
* ON ENTRY.                                                      *
* INPUT  :  REG 11 CONTAINS THE BDDD ADDRESS.                    *
* OUTPUT :  REG 10 CONTAINS THE LENGTH OF THE FORMATTED OPERAND  *
*           OPNDWK                                               *
******************************************************************
BDADR    DS    0H                      *** FORMAT DDDD(RRR) OPERANDS **
         NI    FLAG1,255-FLGFOUND      TURN OFF SYSVAR FIND FLAG @17A
         ST    R11,BD11                SAVE R11
         ST    R9,BD9                  SAVE RETURN ADDR
         SR    R0,R0                   CLEAR WORK REG
         LR    R1,R11                  COPY BDDD ADDRESS
         SLDL  R0,20                   BASE REG TO R0
         LTR   R0,R0                   IS BASE REG 0
         JNZ   BDSCHL                  NO
         SRL   R1,20                   RIGHT JUSTIFY DISPL
         CLI   TEXT,X'91'              TM OP ??                   @14A
         JE    BDAD050                                            @14A
         CLC   MNEMONIC(4),S21         = SPKA ?                   @26A
         JE    BDAD070                                            @26A
         CLI   ICLASS,NPSA             NOT REFER PSA              @20A
         JE    BDAD250                 YES                        @20A
         CLI   ICLASS,PRIVP            NOT REFER PSA              @22A
         JE    BDAD250                 YES                        @22A
BDAD050  CLI   COMMENT,C' '                                       @14A
         JNE   BDSCHL                                             @26C
         MVC   COMMENT(L'S20),S20      SET COMMENT TO REFER PSA
         J     BDSCHL                                              @26A
BDAD070  MVC   COMMENT(L'S23),S23      SET PSW KEY                 @11A
         CLC   TEXT+2(2),XZROS         TEST FOR KEY 0              @26A
         JE    BDAKEY0                                             @26A
         CLC   TEXT+2(2),X0050         TEST FOR KEY 8              @26A
         JE    BDAD080                                             @26A
         CLC   TEXT+2(2),X0010         TEST FOR KEY 1              @26A
         JNE   BDSCHL                                              @26A
         MVC   COMMENT+L'S23(L'S23B),S23B  Set PSW KEY to 1        @26A
         J     BDSCHL                                              @26A
BDAD080  MVC   COMMENT+L'S23(L'S23C),S23C  Set PSW KEY to 5        @26A
         J     BDSCHL                                              @26A
BDTABL   DC X'08',X'0C',X'10',X'14',X'34',X'38',X'50',X'58',X'70'  @27A
*              S    SI    RS   SSI   SSE   SS3   RSE   RSY   SIY   @27A
         DC    X'FF'                                               027A
BDAKEY0  MVC   COMMENT+L'S23(L'S23A),S23A  Set PSW KEY to 0        @26C
BDSCHL   DS    0H                                                  @14A
         LARL  R14,BDTABL                                          @27A
BDAD090  CLI   0(R14),X'FF'            END OF TABLE ?              @27C
         JE    BDAD220                 BRANCH IF YES               @27C
         CLC   ITYPE,0(R14)            INSTRUCTION TYPE FIND       @27C
         JE    BDAD100                 BRANCH IF EQUAL             @27C
         AHI   R14,1                   BUMP UP NEXT TABLE ENTRY    @27C
         J     BDAD090                 LOOP                        @27C
*
BDAD100  LR    R1,R11                  R1 = BDDD                   @14A
         SRL   R1,12                   GET RID OF DDD              @14A
         NILL  R1,X'000F'              R1 = BASE REGISTER          @14A
         NI    FLAG1,255-FLGPSA        TURN OFF PSA FLAG           @15A
         STC   R1,BASERG               SAVE BASE REGISTER          @14A
         LTR   R1,R1                   PSA MAPPING ?               @15A
         JNZ   BDAD120                 BRANCH IF NON ZERO          @15A
         OI    FLAG1,FLGPSA            TURN ON PSA PSAFLAG         @15A
BDAD120  CLC   MNEMONIC(4),S21         = SPKA ?                    @26A
         JE    BDAD250                                             @26A
         ST    R15,BD15                SAVE                        @29A
         L     R15,SRCHDSCT            GET E.P. ADDRESS            @29A
         BALR  R14,R15                 CALL SRCHDSCT               @29A
         LTR   R15,R15                 RC = 0 ?                    @29A
         JNZ   BDAD200                 BRANCH IF RC IS NOT ZERO    @29A
         L     R15,BD15                SAVE                        @29A
         TM    FLAG1,FLGPSA            PSA DSECT ?                 @15A
         JO    BDAD900                 BRANCH IF YES               @15A
         MVI   0(R1),C'-'                                          @14A
         AHI   R1,1                    NEXT POSITION               @14A
         TM    FLAG1,FLGUDSCT          USER DEFINE DSECT ?         @15A
         JO    BDAD140                 BRANCH IF YES               @15A
         SR    R11,R11                 CLEAR R11                   @14A
         AHI   R4,6                                                @15A
         IC    R11,0(R4)            GET LENGTH OF DSECT PREFIX     @15A
         EX    R11,MVDS    ***         COPY DSECT PREFIX           @14A
         LA    R1,1(R1,R11)            R1 = END OF OPNDWK          @14A
BDAD130  SR    R11,R11                 CLEAR R11 FOR ICM OP        @14A
         IC    R11,BASERG              GET BASE REGISTER           @14A
         J     BDAD500                                             @14A
BDAD140  L     R11,UDSCTAD             LOAD DSECT ADDRESS          @25A
         MVC   0(8,R1),0(R11)          COPY DSECT FIELD            @25A
         AHI   R1,7                    GET THE                     @25A
BDAD160  CLI   0(R1),C' '                THE END                   @25A
         JNE   BDAD180                           OF                @25A
         BCTR  R1,R0                                OPNDWK         @25A
         J     BDAD160                                             @25A
BDAD180  AHI   R1,1                    R1 = END OF OPNDWK          @25A
         J     BDAD130                                             @25A
* RC04 of SRCHDSCT
BDAD200  L     R11,BD11                RESTORE R11                 @14A
         L     R15,BD15                SAVE                        @29A
BDAD220  JAS   R9,SCHLBL               GO SEARCH FOR LABEL         @14A
         J     BDAD700                 BRANCH IF FOUND
*                                      IF LABEL DOES NOT EXIST
BDAD250  LR    R1,R11                     THEN COPY BDDD ADDRESS
         SLL   R1,20                   SHIFT OUT B
         SRL   R1,20                   RIGHT JUSTIFY DDD
         CLI   ITYPE,SIY               SIY OPERAND ?               @28A
         JNE   BDAD275                 BRANCH IF NO                @28A
         SR    R0,R0                   CLEAR R1 FOR IC INSTRUCTION @28A
         IC    R0,TEXT+4               LOAD DISPLACEMENT HIGH      @28A
         SLL   R0,12                                               @28A
         AR    R1,R0                   DISPLACEMENT = DH + DL      @28A
BDAD275  CVD   R1,DBLWD                CONVERT DISPL
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK
         MVC   OPNDWK(4),BLANX
         CHI   R1,1000                 DISPL < 1000
         JL    BDAD300                 YES
         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL
         LA    R1,OPNDWK+4             TO NEXT POS
         J     BDAD400                 CONTINUE
BDAD300  CHI   R1,100                  DISPL < 100
         JL    BDAD320                 YES                         @14C
         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL
         LA    R1,OPNDWK+3             TO NEXT POS
         J     BDAD400                 CONTINUE
BDAD320  CHI   R1,10                   DISPL < 10                  @14C
         JL    BDAD350                 YES                         @14C
         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL
         LA    R1,OPNDWK+2             TO NEXT POS
         J     BDAD400                 CONTINUE
BDAD350  MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL          @14C
         LA    R1,OPNDWK+1             TO NEXT POS
BDAD400  SRL   R11,12                  RE-JUSTIFY BASE REG         @14C
         CLI   ICLASS,NPSA             NOT REFER PSA ?             @20C
         JE    BDAD900                 BRANCH IF YES               @21A
         CLI   ICLASS,PRIVP            NOT REFER PSA ?             @22A
         JE    BDAD900                 BRANCH IF YES               @22A
         TM    FLAG1,FLGPSA            PSA DSECT ?                 @15A
         JO    BDAD900                 BRANCH IF YES               @15A
*        TM    FLAG1,FLGUDSCT          USER DSECT ?                @25A
*        JO    BDAD900                 BRANCH IF YES               @25A
BDAD500  MVC   0(2,R1),S25             DELIMITERS (R               @14C
         CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CHI   R11,10                  BASE REG < 10
         JL    BDAD600                 YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT BASE REG
         AHI   R1,4                    TO NEXT POS
         J     BDAD650                 CONTINUE
BDAD600  MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT BASE REG
         AHI   R1,3                    TO NEXT POS
BDAD650  MVI   0(R1),C')'              FINAL DELIMITER             @17C
         LR    R2,R1                   COPY END ADDRESS
         AHI   R2,-4                   BACK 4 BYTES
         J     BDCEXIT                                             @15A
         USING DSECTD,R12                                          @19C
BDAD700  MVC   OPNDWK(L'DSLNAME),DSLNAME     COPY LABEL ENTRY      @25C
         LA    R1,OPNDWK+L'DSLNAME-1   @ LAST POSSILE CHARACTER    @25C
         CLI   DSLBTYP,C'D'            USER DEFINE DSECT ENTRY?    @19A
         JNE   BDAD800                 BRANCH IF NO                @26C
         CLI   COMMENT,C' '  ***DEBUG                              @19A
         JNE   BDAD800       ***DEBUG  BRANCH IF NO                @26C
         MVC   COMMENT(L'DSCOMMT),DSCOMMT   COPY DSECT DESCRIPTION @19A
BDAD800  CLI   0(R1),C' '              LAST POSITION ?             @25A
         JNE   BDAD950                 JUMP IF YES                 @25A
         BCTR  R1,0                    PREVIOUS CHARACTER          @25A
         J     BDAD800                 LOOP                        @25A
BDAD900  BCTR  R1,0                    MINUS 1 FOR COPY            @16A
BDAD950  L     R12,SLSAV+12            RESTORE R12
BDCEXIT  LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R9,BD9                  GET RETURN ADDR
         BR    R9                      EXIT
*        CLC   TXTOFSET,XOFST    ** DEBUG
*        JNE   QQQQ5             ** DEBUG
*        JL    QQQQ5             ** DEBUG DATA STATEMENT
*        JAS   R14,PRTREGS
*        LA    R0,COMMENT
*        DC    X'0000'           ** DEBUG
*QQQ5    DS    0H                ** DEBUG
******************************************************************
* BUILDS STORAGE OPERANDS CONTAINING BASE, DISPLACEMENT, AND     *
* INDEX. ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS, AND REG 10  *
* CONTAINS THE INDEX. THE SCHLBL ROUTINE IS CALLED TO FIND THE   *
* LABEL REFERENCE AND COPY CONTENT OF THE LABEL TO COMMENT FOR   *
* LIOP INSTRUCTION TYPE, IF THE BASE REG IS CURRENT, AND A LABEL *
* EXISTS.                                                        *
* IF SCHLBL IS UNSUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM     *
* DDDD(XXX,RRR) IS CREATED.                                      *
*                                                                *
* INPUT  : R10    -> INDEX REGISTER                              *
*          R11    -> BDDD                                        *
*          R9     -> LINKAGE REGISTER                            *
*          TEXT   -> INSTRUCTION                                 *
* OUTPUT : R10    -> LENGTH OF THE FORMATTED OPERAND             *
*          OPNDWK -> THE FORMATTED OPERAND                       *
*          COMMENT-> CONTENT OF THE LABEL                        *
* FLAG1    X'40'  -> BASE REGISTER IS 0 (PSA Mapping)            *
*          X'20'  -> INDEX REGISTER IS 0                         *
******************************************************************
BDXADR   EQU   *              *** FORMAT DDDD(XXX,BBB) OPERAND
         ST    R9,BDX9                 SAVE RETURN ADDR
         ST    R11,BDR11               SAVE BDDD                  @28A
         CLI   ITYPE,RXE               RXE OP ??                  @14A
         JE    BDXD005                 BRANCH IF RXE OP CODE      @14A
         CLI   ITYPE,RXY               RXY OP ??                  @14A
         JE    BDXD005                 BRANCH IF RXY OP CODE      @14A
         CLI   TEXT,X'47'              B  INSTRUCTION ?           @21A
         JE    BDXD005                 BRANCH IF BRANCH INSTR     @26A
         CLI   ITYPE,SS3               SS3 OP ??                  @26A
         JE    BDXD005                 BRANCH IF SS3 OP CODE      @14A
         CLI   ITYPE,RX                RX OP ??                   @14A
         JNE   BDXD450                 BRANCH IF NOT RX OP CODE   @14A
BDXD005  LR    R1,R11                  R1  = BDDD                 @14A
         SRL   R1,12                   GET RID OF DDD             @14A
         NI    FLAG1,255-FLGPSA        TURN OFF BASER IS 0        @15A
         LTR   R1,R1                   BASE REGISTER IS 0 ??      @15A
         JNZ   BDXD020                 BRANCH IF NOT R0           @15A
         OI    FLAG1,FLGPSA            TURN ON BASE REG IS 0       @15A
         SR    R1,R1                   CLEAR REGISTER 1 FOR ICM    @15A
         ICM   R1,1,TEXT+1                                         @15A
         NILL  R1,X'000F'              R1  = INDEX REGISTER        @15A
         NI    FLAG1,255-FLGIXREG-FLGFOUND  OFF INDEX REG BIT      @15A
         LTR   R1,R1                   INDEX REGISTER IS 0 ??      @15A
         JNZ   BDXD020                 BRANCH IF INDEX REG NOT 0   @15A
         OI    FLAG1,FLGIXREG          TURN ON INDEX REG 0 SW      @15A
         STC   R1,BASERG               SET BASERG TO 0             @14A
         LR    R1,R10                  RESTORE INDEX REGISTER      @14A
         J     BDXD030                                             @15A
BDXD020  STC   R1,BASERG               BASE REG = INDEX REG        @14A
BDXD030  CLI   TEXT,X'41'              LA INSTRUCTION ?            @15A
         JNE   BDXD100                 BRANCH IF NOT LA INSTR      @15A
         TM    FLAG1,FLGPSA+FLGIXREG   INDEX/BASE REG IS 0         @15A
         JO    BDXD400                                             @15A
BDXD100  ST    R15,BD15                SAVE R15                    @29A
         L     R15,SRCHDSCT            GET E.P. ADDRESS OF SRCHDSCT@29A
         BALR  R14,R15                 CALL SRCHDSCT               @29A
         LTR   R15,R15                 RC = 0 ?                    @29A
         JNZ   BDXD400                 BRANCH IF RC IS NON ZERO    @29A
         L     R15,BD15                RESTORE R15                 @29A
         TM    FLAG1,FLGPSA+FLGIXREG   BASE AND INDEX REG ARE 0    @15A
         JO    BDXPSA                  BRANCH IF PSA MAPPING       @15A
         MVI   0(R1),C'-'                                          @14A
         AHI   R1,1                    NEXT POSITION               @14A
         TM    FLAG1,FLGUDSCT          USER DEFINE MAPPING         @25A
         JO    BDXD150                 BRANCH IF PSA MAPPING       @25A
         SR    R11,R11                 CLEAR R11                   @14A
         AHI   R4,6                    BUMP TO NEXT DSECT PREFIX   @15C
         IC    R11,0(R4)               GET LENGTH OF DSECT PREFIX  @15C
         EX    R11,MVDS                COPY DSECT PREFIX           @14A
         AR    R1,R11                  R1 = END OF OPNDWK          @14A
         J     BDXD300                 BRANCH IF PSA MAPPING       @25A
BDXD150  L     R11,UDSCTAD             LOAD DSECT ADDRESS          @25A
         MVC   0(8,R1),0(R11)          COPY DSECT NAME             @25A
         AHI   R1,7                    NEXT DSECT TABLE ENTRY      @25A
BDXD200  CLI   0(R1),C' '              FIND THE                    @25A
         JNE   BDXD300                   LENGTH                    @25A
         BCTR  R1,R0                       OF DSECT                @25A
         J     BDXD200                                             @25A
BDXD300  LTR   R10,R10                 INDEX REGISTER IS ZERO ?    @14A
         JNZ   BDXINDXR          BRANCH IF INDEX REG IS NON ZERO   @14A
         SR    R11,R11                                             @14A
         IC    R11,BASERG              RESTORE BASE REGISTER       @14A
         MVC   1(3,R1),S26             YES, DELIMITER  '(,R'       @14A
         AHI   R1,2                    NEXT POSITION               @14A
         CVD   R11,DBLWD               FORMAT BASE REGISTER        @14A
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK                      @14A
         OI    DBLWD+1,C'0'            CLEAR SIGN                  @14A
         CHI   R11,10                  LENGTH < 10                 @14A
         JL    BDXG1                   BRANCH IF BASE REG > 10     @14A
         J     BDXG2                   BRANCH IF BASE REG > 9      @14A
*****************************************************************  @14A
* NOT FIND IN DSECT TABLE                                          @14A
*****************************************************************  @14A
BDXD400  L     R11,BDR11               RESTORE BDDD                @28A
         L     R15,BD15                RESTORE R15                 @29A
BDXD450  LTR   R10,R10                 ANY INDEX REG
         JNZ   BDXSCHL                 YES
         SR    R0,R0                   CLEAR WORK REG
         LR    R1,R11                  COPY BDDD ADDRESS
         SLDL  R0,20                   BASE REG TO R0
         LTR   R0,R0                   IS BASE REG 0
         JNZ   BDXSCHL                 NO
         CLI   TEXT,X'41'              IS IT LA
         JE    BDXSCHL              YES THEN SKIP PUTTING COMMENT
         CLI   TEXT,X'51'              IS IT LAE                  @14A
         JE    BDXSCHL              YES THEN SKIP PUTTING COMMENT @14A
         CLI   ICLASS,NPSA             NOT REFER PSA ?            @14A
         JE    BDXSCHL                 YES                        @14A
         CLI   COMMENT,C' '                                       @15A
         JNE   BDXSCHL                                            @15A
         MVC   COMMENT(9),S20          COMMENT REFER PSA
BDXSCHL  JAS   R9,SCHLBL               GO SEARCH FOR LABEL
         J     BDXGLBL                 BRANCH IF FOUND
*  LABEL NOT FOUND
         LA    R0,OPNDWK                                           @28A
         LR    R1,R11                  COPY BDDD ADDRESS
         SLL   R1,20                   SHIFT OUT BASE REG
         SRL   R1,20                   RIGHT JUSTIFY DISPL
         SRL   R11,12                  RT JUSTIFY BASE REG
         CLI   ITYPE,SIY               SIY INSTRUCTION             @28A
         JE    BDXD460                 BRANCH IF SIY INSTRUCTION   @28A
         CLI   ITYPE,RXY               RXY INSTRUCTION             @28A
         JNE   BDXD470                 BRANCH IF NOT RXY INSTR     @28A
BDXD460  CLI   TEXT+4,X'FF'            NEGATIVE DISPLACEMENT       @28A
         JE    BDXD465                 BRANCH IF YES               @28A
         SR    R0,R0                   CLEAR R1 FOR IC INSTRUCTION @28A
         IC    R0,TEXT+4               LOAD DISPLACEMENT HIGH      @28A
         SLL   R0,12                                               @28A
         AR    R1,R0                   DISPLACEMENT = DH + DL      @28A
         LA    R0,OPNDWK                                           @28A
         J     BDXD470                                             @28A
BDXD465  AHI   R1,-4096                GET NEGATIVE DISPLACEMENT   @28A
         LCR   R1,R1                   CHANGE TO POSITIVE VALUE    @28A
         MVI   OPNDWK,C'-'                                         @28A
         LA    R0,OPNDWK+1                                         @28A
BDXD470  CVD   R1,DBLWD2               CONVERT
         OI    DBLWD2+7,X'0F'          CLEAR SIGN
         UNPK  DBLWD+2(6),DBLWD2+5(3)  UNPACK DISPLACEMENT         @28A
         LR    R9,R0                   RESTORE                     @28A
         CHI   R1,10000                DISPL < 10000               @28A
         JL    BDXD480                 YES                         @28A
         MVC   0(5,R9),DBLWD+3         MOVE 5-DIGIT DISPLACEMENT   @28A
         LA    R1,5(,R9)               TO NEXT POS                 @28A
         J     BDXLPN                  CONTINUE                    @28A
BDXD480  CHI   R1,1000                 DISPL < 1000
         JL    BDXD500                 YES
         MVC   0(4,R9),DBLWD+4         MOVE 4-DIGIT DISPLACEMENT   @28C
         LA    R1,4(,R9)               TO NEXT POS                 @28C
         J     BDXLPN                  CONTINUE
BDXD500  CHI   R1,100                  DISPL < 100
         JL    BDXD600                 YES
         MVC   0(3,R9),DBLWD+5         MOVE 3-DIGIT DISPLACEMENT   @28C
         LA    R1,3(,R9)               TO NEXT POS                 @28C
         J     BDXLPN                  CONTINUE
BDXD600  CHI   R1,10                   DISPL < 10
         JL    BDXD1                   YES
         MVC   0(2,R9),DBLWD+6         MOVE 2-DIGIT DISPLACEMENT   @28C
         LA    R1,2(,R9)               TO NEXT POS                 @28C
         J     BDXLPN                  CONTINUE
BDXD1    MVC   0(1,R9),DBLWD+7         MOVE 1-DIGIT DISPLACEMENT   @28C
         LA    R1,1(,R9)               TO NEXT POS                 @28C
BDXLPN   LTR   R10,R10                 ANY INDEX REG
         JNZ   BDXLPNR                 YES
         LTR   R11,R11                 ANY BASE REG
         JNZ   PREPB                   YES
         AHI   R1,-1                   NO, BACK UP TO RHE
         J     BDXCE                   CONTINUE
PREPB    MVC   0(3,R1),S26             MOVE DELIMETERS (,R)
         AHI   R1,1                    STEP OVER 1 BYTE
         J     BDXCBAS                 CONTINUE
* FORMAT INDEX REGISTER
BDXLPNR  MVC   0(2,R1),S25             MOVE DELIMIETERS (R
         CVD   R10,DBLWD               CONVERT INDEX REG
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CHI   R10,10                  INDEX REG < 10
         JL    BDXX1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT INDEX REG
         AHI   R1,4                    TO NEXT POSITION
         J     BDXCMA                  CONTINUE
BDXX1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT INDEX REGISTER
         AHI   R1,3                    TO NEXT POSITION
BDXCMA   TM    FLAG1,FLGPSA            BASE REGISTER = 0 ?         @18A
         JO    BDXRPN                  BRANCH IF YES               @18A
         SR    R11,R11                 CLEAR R11                   @18A
         IC    R11,TEXT+2              PICK UP BASE REGISTER       @18A
         SRL   R11,4                   GET RID OF LAST 4 BITS      @18A
         MVC   0(2,R1),SCOMMAR         DELIMITERS ',R'
* FORMAT BASE REGISTER
BDXCBAS  CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CHI   R11,10                  BASE REGISTERS < 10
         JL    BDXB1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT BASE REGISTERS
         AHI   R1,4                    TO NEXT POSITION
         J     BDXRPN                  CONTINUE
BDXB1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT BASE REG
         AHI   R1,3                    TO NEXT POS
BDXRPN   MVI   0(R1),C')'              FINAL DELIMITER             @17C
BDXCE    LR    R10,R1                  COPY END ADDR
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R9,BDX9                 GET RETURN ADDR
         BR    R9             ***      EXIT
*** LABEL IS FOUND *******
         USING DSECTD,R12                                          @19C
BDXGLBL  CLI   DSLBTYP,C'D'            DSECT ENTRY ?               @19A
         JNE   BDXGLBL2                BRANCH IF NO                @19A
         CLI   COMMENT,C' '  ***DEBUG                              @19A
         JNE   BDXGLBL2      ***DEBUG                              @19A
         MVC   COMMENT(L'DSCOMMT),DSCOMMT  COPY DSECT DESCRIPTION  @19A
         USING LABELD,R12                                          @25A
BDXGLBL2 MVC   TXTOFSTC,LBLADR         SAVE REFRENCE OFFSET        @23A
         CLI   ICLASS,LIOP             LIOP OP CODE ?              @22A
         JNE   BDXGLBL9                BRANCH IF NOT LOAD OP       @22A
         CLC   LBLADR,LABELL(R12)                                  @25C
         JNE   BDXGLBL9                BRANCH IF NOT EQUAL         @22A
         CLI   LBLLEN,4                                            @28A
         JE    BDXGLBL4                BRANCH IF YES               @28A
         CLI   LBLLEN,8                                            @28A
         JNE   BDXGLBL9                BRANCH IF LBLLEN NOT = 8    @28A
BDXGLBL8 MVC   COMMENT(3),S_ADBRC      ASSUME AD-TYPE ADDRESS      @28A
         MVC   COMMENT+3(L'LBLNAME),LBLNAME-LABELD+LABELL(R12)     @28A
         CLI   COMMENT+3,C'A'                                      @28A
         JE    BDXGLBL7                                            @28A
         MVC   COMMENT+11(4),CLOSEBK   EXTR AD LABLE CLOSE BRACKET @31C
         J     BDXGLBL9                                            @28A
BDXGLBL7 MVC   COMMENT+10(4),CLOSEBK   LOCAL AD LABLE CLOSE BRACKET@31C
         J     BDXGLBL9                                            @28A
BDXGLBL4 MVC   COMMENT(2),S_VBRC       ASSUME V-TYPE ADDRESS       @22A
         MVC   COMMENT+2(L'LBLNAME),LBLNAME-LABELD+LABELL(R12)     @25C
*                                COPY LABEL NAME TO COMMENT FIELD  @22A
         CLC   S_A0,LBLNAME-LABELD+LABELL(R12)  A-TYPE address ?   @25C
         JE    BDXGLBL5                Branch if yes               @22A
         MVI   COMMENT+10,C')'         V or W-TYPE address         @22A
         J     BDXGLBL6                                            @22A
BDXGLBL5 MVI   COMMENT,C'A'            A-TYPE address              @22A
         MVI   COMMENT+9,C')'                                      @22A
         J     BDXGLBL9                                            @23A
SYSMODTB DC    CL8'IEACVT  ',CL5'@CVT '                            @23A
         DC    CL8'IEAMASCB',CL5'@ASCB'                            @23A
         DC    CL8'IEAVESLA',CL5'@SLA '                            @23A
         DC    CL8'IEAVETVT',CL5'@TRVT'                            @23A
         DC    CL8'IEAVFACL',CL5'@FACL'                            @23A
         DC    CL8'IEAVGSDA',CL5'@GSDA'                            @23A
         DC    CL8'IOSVADIH',CL5'@ADIH'                            @23A
         DC    CL8'IOSVSSRB',CL5'@SSRB'                            @23A
         DC    X'FFFF'                                             @23A
BDXGLBL6 LARL  R14,SYSMODTB            SEARCH SYSMODTB FOR V-TYPE  @23A
** LOOP SEARCH SYSMOD TABLE TO FIND THE DSECT NAME                 @23A
BDXGSMOD CLI   0(R14),X'FF'            END OF SYSMODTB TABLE ?     @23A
         JE    BDXGLBL9                BRANCH IF YES               @23A
         CLC   COMMENT+2(8),0(R14)     COMPARE MODULE NAME         @23A
         JNE   BDXGNMOD                BRANCH IF NOT MATCH         @23A
         MVC   COMMENT(5),8(R14)       COPY DSECT NAME TO COMMENT  @23A
         MVC   COMMENT+5(8),BLANX      CLEAR GARBAGE               @23A
         J     BDXGLBL9                JUMP                        @23A
BDXGNMOD AHI   R14,13                  NEXT SYSMOD TABLE ENTRY     @23A
         J     BDXGSMOD                JUMP                        @23A
BDXGLBL9 MVC   OPNDWK(L'LBLNAME),LBLNAME   GET LABEL NAME          @22C
         LA    R1,OPNDWK+L'LBLNAME-1   @ LAST POSSILE CHARACTER    @25A
BDXFLPST CLI   0(R1),C' '              LAST CHARACTER ?            @25A
         JNE   BDXLPOST                JUMP IF YES                 @25A
         BCTR  R1,0                    TRY PREVIOUS CHARACTER      @25A
         J     BDXFLPST                LOOP                        @25A
BDXLPOST CLI   COMMENT,C' '            EMPTY COMMENT ?             @22A
         JNE   BDXGRHE                 JUMP FOR NON BLANK COMMENT  @22A
         CLI   LBLTYP,C'D'             DSECT LABEL ?               @29A
         JE    BDXGRHE                 BRANCH IF YES               @29A
         SR    R14,R14                 CLEAR R14                   @22A
         ICM   R14,7,LBLADR            GET OFFSET ADDRESS          @22A
         A     R14,TXTSTRT             R14 -> ACTUAL LABEL OFFSET  @22A
         MVC   COMMENT(1),0(R14)       COMMENT = CURRENT DATA      @22A
         SR    R12,R12                 CLEAR FOR IC INSTR          @28A
         IC    R12,IOLNG               LOAD OPERAND LENGTH         @28A
         LTR   R12,R12                 TEST OPERAND LENGTH         @28A
         JZ    BDXGRHE                 BRANCH IF ZERO OPERAND LEN  @29C
         BCTR  R12,0                   MINUS 1 FOR MVC             @28A
         EX    R12,MVLCOM              MVC   COMMENT(4),0(R14)     @28A
         MVC   TMPSTR(4),4(R14)                                    @29A
         TRT   0(4,R14),CHARTRAN       TEST CURRENT DATA           @22A
         JZ    BDXGRHE                 BRANCH IF CHARACTER         @22A
         LR    R12,R14                 FORMAT OPERAND              @22A
         JAS   R9,HEXPRT4                     INTO HEXIDECIMAL     @22A
         LA    R12,COMMENT                                         @22A
BDXGLBLA MVC   0(2,R12),SXAPO          COPY OPENING QUOTE          @22A
         MVC   2(2,R12),PRTABL         COPY HEXI STRING            @22A
         MVI   4(R12),C''''            ENDING QUOTE                @22A
         SR    R9,R9                   CLEAR FOR IC INSTRUCTION    @29A
         IC    R9,IOLNG                LOAD OPERAND LENGTH         @29A
         SLL   R9,1                    TIMES 2                     @29A
         EX    R9,MVHX2                MVC   2(1,R12),PRTABL       @29A
         CHI   R9,16                   8 BYTES OPERAND ?           @29A
         JNE   BDXGLBLC                BRANCH IF NOT               @29A
         LR    R0,R9                   SAVE R9                     @29A
         LR    R14,R12                 SAVE R12                    @29A
         LA    R12,TMPSTR              FORMAT OPERAND+4 INTO       @29A
         JAS   R9,HEXPRT4                  8 BYTES HEXIDECIMAL     @29A
         LR    R9,R0                   RESTORE R9                  @29A
         LR    R12,R14                 RESTORE R12                 @29A
         MVC   10(8,R12),PRTABL        COPY FORMATTED OPERAND      @29A
BDXGLBLC LA    R12,2(R9,R12)           POSITIION TO END OF STRING  @29A
         MVI   0(R12),C''''            ENDING QUOTE                @29C
         CLI   TEXT,X'43'              IC OPCODE ?                 @22A
         JE    BDXGRHE                 BRANCH IF YES               @22A
         CLI   TEXT,X'44'              EX OPCODE ?                 @23A
         JNE   BDXGRHE                 BRANCH IF YES               @23A
BDXGRHD  LA    R12,4(R14)              FORMAT OPERAND              @23A
         JAS   R9,HEXPRT2                     INTO HEXIDECIMAL     @23A
         LA    R12,COMMENT+10                                      @23A
         MVC   0(4,R12),PRTABL         COPY HEXI STRING            @23A
         MVI   4(R12),C''''            ENDING QUOTE                @23A
         LA    R1,OPNDWK+11            @LAST POSSIBLE CHARACTER    @23A
         J     BDXGRHS                                             @23A
BDXGRHE  LA    R1,OPNDWK+L'DSLNAME-1   @LAST POSSIBLE CHARACTER    @23C
BDXGRHS  CLI   0(R1),C' '              POSITION TO LAST            @23C
         JNE   BDXGCKLN                   NON BLANK
         JCT   R1,BDXGRHS              LOOP TO BDXGRHE             @23C
BDXGCKLN LTR   R10,R10                 ANY INDEX REGISTER
         JZ    BDXGCMP                 NO
* FORMAT INDEX REGISTER
BDXINDXR MVC   1(2,R1),S25             MOVE DELIMIETERS (R
         CVD   R10,DBLWD               CONVERT LENGTH
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         OI    DBLWD+1,C'0'            CLEAR SIGN
         CHI   R10,10                  LENGTH < 10
         JL    BDXG1I                  YES                         @14A
         MVC   3(2,R1),DBLWD           MOVE 2-DIGIT LENGTH         @14A
         AHI   R1,5                    TO NEXT POS                 @14A
         J     BDXBGT                  CONTINUE                    @18A
BDXG2    MVC   2(2,R1),DBLWD           MOVE 2-DIGIT LENGTH
         AHI   R1,4                    TO NEXT POS                 @18A
         J     BDXGRPN                 CONTINUE                    @18A
BDXG1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT LENGTH
         AHI   R1,3                    TO NEXT POS
         J     BDXGRPN
BDXPSA   BCTR  R1,R0                   MINUS 1                     @16A
         J     BDXGCMP                                             @16A
BDXG1I   MVC   3(1,R1),DBLWD+1         MOVE 1-DIGIT LENGTH         @14A
         AHI   R1,4                    TO NEXT POS                 @14A
BDXBGT   TM    FLAG1,FLGPSA            NON-ZERO BASE REGISTER?     @18A
         JNO   BDXCMA           BRANCH IF BASE REGISTER EXIST      @18A
BDXGRPN  MVI   0(R1),C')'              FINAL DELIMITER
BDXGCMP  LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE OPERAND LENGTH
         L     R12,SLSAV+12            RESTORE R12
         L     R9,BDX9                 GET RETURN ADDR
         BR    R9                      EXIT
******************************************************************
* SEARCHES THE BASE REGISTER TABLE TO FIND THE BASE REGISTER     *
* ASSOCIATED WITH THE BDDD OPERAND ADDRESS PASSED IN REG11 ON    *
* ENTRY.                                                         *
* IF THE BASE REGISTER GIVEN IS NOT A CURRENT BASE REGISTER      *
* THE UNSUCCESSFUL RETURN IS MADE TO 4 BYTES PAST THE ADDRESS    *
* IN REG 9 ON ENTRY. WHEN THE CURRENT BASE REGISTER ENTRY IS FOR *
* A PROGRAM BASE REG, THE DISPLACEMENT IS ADDED TO THE ASSUMED   *
* BASE REGISTER VALUE IS ADDED TO THE DISPLACEMENT TO GIVE AN    *
* OFFSET IN THE PROGRAM. THE LABEL TABLE IS SEARCHED FOR AN ENTRY*
* WITH THIS OFFSET, AND IF FOUND, IS RETURNED TO THE CALLER. WHEN*
* THE BASE REGISTER FOUND IS FOR A DSECT, THE DSECT HEADER ENTRY *
* ADDRESS IS GIVEN IN THE BASE TABLE ENTRY. THE DSECT HEADER HAS *
* THE ADDRESS OF THE FIELD DEFINITION TABLE FOR THE DSECT. THE   *
* FIELD DEFINITION TABLE IS SEARCHED FOR AN ENTRY HAVING THE     *
* DISPLACEMENT IN THE BDDD INSTRUCTION, AND IF FOUND IS PASSED   *
* BACK TO THE CALLER. IF THE LABEL/FIELD TABLE SEARCHES ARE      *
* UNSUCCESSFUL, RETURN IS TO 4 BYTES PAST REG 9.                 *
* INPUT : R11 -> BDDD                                            *
*         TEXT+4 DH (SIY & RXY)                                  *
* OUTPUT: R12 -> ADDRESS OF THE LABEL                            *
******************************************************************
*
         USING DSECTD,R12
SCHLBL   DS    0H              ** SEARCH FOR LABEL AT BDDD ADDRESS
         STM   R9,R12,SLSAV      YES, SAVE REGS USED
         LA    R1,4(R9)          R1 = R9 + 4                       @14A
         TM    MORUSG,X'80'      ANY BASES ACTIVE
         BZR   R1                NO, UNSUCCESSFUL EXIT
         LR    R12,R11           COPY BDDD ADDRESS
         SRL   R12,12            CLEAR DISPLACEMENT (BASE REG ONLY)
         LTR   R12,R12           BASE REG = 0 ?                    @31A
         JNZ   BASERNZ           BRANCH IF BASE REG IS NOT ZERO    @31A
         SR    R12,R12           CLEAR R12 FOR IC INSTRUCTION      @31A
         IC    R12,TEXT+1        LOAD INDEX REGISTER               @31A
         NILL  R12,X'000F'       GET INDEX REGISTER                @31A
BASERNZ  MHI   R12,USINGL        BASE or INDEX x BASE TBL ENTRY LENGTH
         LA    R0,BASES          R0  -> 1st BASE TABLE ENTRY       @23C
         AR    R12,R0            R12 -> Rxx BASE TABLE ENTRY       @23C
         USING USINGD,R12
         CLI   USTYPE,0                ENTRY IN USE ??
         JE    SCHNF                   EXIT IF NOT IN USE
         LR    R9,R11                  COPY BDDD ADDRESS
         SLL   R9,20                   SHIFT OUT BASE
         SRL   R9,20                   RIGHT JUSTIFY DDD
         CLI   ITYPE,SIY               SIY OP CODE ??              @28A
         JE    GETDH                   BRANCH IF SIY OP CODE       @28A
         CLI   ITYPE,RXY               RXY OP CODE ??              @28A
         JNE   GETDL                   BRANCH IF NOT TRUE          @28A
GETDH    CLI   TEXT+4,X'07'            DH > 07 ??                  @28A
         JH    CKLLTBL                 BRANCH IF OUT OF RANGE      @28A
         SR    R0,R0                   CLEAR FOR IC INSTRUCTION    @28A
         IC    R0,TEXT+4               GET DH                      @28A
         SLL   R0,12                                               @28A
         AR    R9,R0                   R9 = DH + DL                @28A
GETDL    ICM   R11,7,USVALU            GET BASE REG VALUE
         LA    R11,0(R11)              CLEAR HI-ORDER
         CLI   USTYPE,C'P'             PROGRAM BASE REG
         JE    PGMBASE                 YES
         CLI   USTYPE,C'G'             GLOBAL MAPPING DSECT        @25A
         JE    SCHNF                   YES                         @25A
         DROP  R12
         LR    R12,R11                 R12 = DSECT FIELD TABLE ADDRESS
         USING DSECTD,R12              @ LABEL TABLE
* SEARCH USER DEFINED DSECT
CKDSCTND CLM   R9,7,DSOFSET            THIS IS THE ENTRY
         JE    SCHFD                   YES
         CLC   DSOFSET,HIVAL           NO, AT TABLE END
         JE    SCHNF                   YES, NO LABEL FOUND
         AHI   R12,DSECTL              STEP TO NEXT DSECT ENTRY
         J     CKDSCTND                LOOP THRU DSECT FIELDS
PGMBASE  AR    R9,R11                  COMPUTE OFFSET BDDD
         DROP  R12
CKLLTBL  L     R12,LBLTBL              @ LABEL TABLE
         USING LABELD,R12
CKENTFD  CLM   R9,7,LBLADR             THIS IS THE ENTRY ?
         JE    SCHFD                   YES
         AHI   R12,LABELL              TO NEXT ENTRY               @25C
         C     R12,CURRLBL             END OF TBL ?
         JNL   SCHNF                   YES, NO LABEL
         J     CKENTFD                 NO, CONTINUE SEARCH
SCHNF    LM    R9,R12,SLSAV            NOT FOUND, RESTORE REGS
         AHI   R9,4                    ADD 4 TO RETURN ADDRESS     @12A
         BR    R9                      NOT FOUND RETURN            @12A
SCHFD    LM    R9,R11,SLSAV            FOUND RESTORE ALL BUT 12
         BR    R9                      FOUND RETURN
         DROP  R12
******************************************************************
*                                                                *
* PRINT REGISTER USAGE REPORT                                    *
*                                                                *
******************************************************************
PRTREGS  DS    0H                                                  @23A
         BAKR  R14,0                   SAVE REGISTERS              @23A
         L     R1,REGUSDCB             @ REGUSE  DCB               @23A
         TM    48(R1),X'10'            IS REGUSE OPEN              @23A
         JNO   REGQUIT                 NO                          @23A
         LA    R4,DSREGTBL             LOCATE DSECT TABLE          @23A
         LA    R6,4                                                @22A
         MVC   PRTLINE+9(7),1(R15)                                 @23A
         LA    R12,TXTOFST                                         @23A
         JAS   R9,HEXPRT4                                          @23A
         MVC   PRTLINE+1(6),PRTABL+2                               @23A
         MVC   PRTLINE+74(L'MNEMONIC),MNEMONIC                     @23A
NEWLN1   LA    R11,4                                               @23A
         LA    R8,PRTLINE+20                                       @23A
         L     R1,REGUSDCB             @ REGUSE  DCB               @23A
FILLDSC  MVC   0(11,R8),0(R4)          COPY Rxx-Ryy                @23A
         AHI   R4,DSREGEL              Next DSECT entry            @23A
         AHI   R8,DSREGEL              Next output entry           @23A
         JCT   R11,FILLDSC             Loop for 4 times            @23A
         PUT   (1),PRTLINE             Write                       @23A
         MVI   PRTLINE,C' '            Clear output PRTLINE        @23A
         MVC   PRTLINE+1(90),PRTLINE                               @23A
         JCT   R6,NEWLN1               Loop for 4 times            @22A
REGQUIT  PR                                                        @23A
******************************************************************
*                                                                *
* PRINT A LINE USING THE SYSPRINT DCB DEFINED IN HDISASM PHASE 0.*
*                                                                *
******************************************************************
*
PRINT    DS    0H                      PRINT ROUTINE
         L     R1,PRINTDCB             @ SYSPRINT DCB
         TM    48(R1),X'10'            IS SYSPRINT OPEN
         JNO   CLRPRT                  NO
         PUT   (1),PRTLINE             WRITE PRINT LINE
CLRPRT   MVI   PRT,C' '                CLEAR PRINT LINE
         MVC   PRT+1(L'PRT-1),PRT
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C' '                SINGLE SPACED
         JE    SETSGL                  YES
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C'0'                DOUBLE SPACED
         JE    SETSGL                  YES
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C'-'                TRIPLE SPACED
         JE    SETSGL                  YES
         ZAP   LINECT,P0               NO, MUST BE NEW PAGE
SETSGL   MVI   PCC,C' '                SET SINGLE SPACING
         CP    LINECT,P58              PAST END OF PAGE
         JH    NEWPAGE                 YES
         BR    R9                      EXIT
NEWPAGE  MVI   PCC,C'1'                SET SKIP TO HOF
         ZAP   LINECT,P0               RESET LINE COUNTER
         BR    R9                      EXIT
******************************************************************
*                                                                *
* CONVERT HEX DATA TO PRINTABLE FORM: 2 CHARACTERS PER BYTE. ON  *
* ENTRY, REG 12 CONTAINS THE ADDRESS OF THE LEFT END OF THE FIELD*
* TO BE CONVERTED, AND THE ENTRY POINT USED DETERMINES THE LENGTH*
* FORMATTED OUTPUT IS PLACED IN THE PRTABL FIELD.                *
* INPUT : R12  (ADDRESS OF INPUT HEX STRING)                     *
* OUTPUT: PRTABL                                                 *
******************************************************************
*
HEXPRT   DS    0H                      HEX TO PRINTABLE ROUTINE
HEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX
         J     HEXCLTR                 CONTINUE
HEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX
         J     HEXCLTR                 CONTINUE
HEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX
         J     HEXCLTR                 CONTINUE
HEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX
HEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE
         TR    PRTABL(8),TRTBL         MAKE PRINTABLE
         BR    R9                      EXIT
******************************************************************
*                                                                *
* FORMATS THE HEX DATA CORRESPONDING TO THE FORMATTED INSTRUCTION*
* BEING OUTPUT. PRINTABLE HEX IS PLACED AT THE RIGHT OF THE LINE *
* ON THE SYSPRINT OUTPUT.                                        *
* INPUT  TEXT                                                    *
*        LEN   LENGTH OF THE STRING                              *
******************************************************************
TXTFMT   EQU   *                       *** FORMAT TEXT FOR PRINT ***
         ST    R9,TX9                  SAVE RETURN ADDR
         LA    R11,PRT                 @ PRINT LINE
         MVI   PRT,C' '
         MVC   PRT+1(24),PRT
         CLI   TYPE,1                  ADCON
         JE    TFOFST                  YES
         CLI   TYPE,2                  CONSTANT
         JE    TFOFST                  YES
         CLI   TYPE,X'0D'              INSTRUCTION
         JNE   TXTCLEAN                NO
TFOFST   LA    R12,OFFSET              @ OFFSET TO INSTR
         JAS   R9,HEXPRT3              CONVERT TO PRINTABLE
         MVC   PRT(6),PRTABL           OFFSET TO PRINT             @14A
         TM    FLAG1,FLGHEX4           HEX4 IS ON                  @15A
         JNO   TXT0                                                @15A
         LR    R12,R7                                              @15A
         SH    R12,CONLEN                                          @15A
         J     TXTH                                                @15A
TXT0     LA    R12,TEXT                @ TEXT TO PRINT             @15C
TXTH     JAS   R9,HEXPRT4              CONVERT 1ST 4 BYTES         @15C
         CLI   LEN,4                   IS IT 4 BYTES
         JNL   TXT4                    YES, OR MORE
         CLI   LEN,3                   IS IT 3 BYTES
         JE    TXT3                    YES
         CLI   LEN,2                   IS IT 2 BYTES
         JE    TXT2                    YES
         MVC   PRT+7(2),PRTABL         TEXT TO PRINT               @14A
         J     TXTCLEAN                FINISH                      @14A
TXT2     MVC   PRT+7(4),PRTABL         TEXT TO PRINT               @14A
         J     TXTCLEAN                FINISH                      @14A
TXT3     MVC   PRT+7(6),PRTABL         TEXT TO PRINT               @14A
         J     TXTCLEAN                FINISH                      @14A
TXT4     MVC   PRT+7(8),PRTABL         TEXT TO PRINT               @14A
         CLI   LEN,4                   IS IT 4 BYTES
         JE    TXTCLEAN                YES, FINISH
         LA    R12,TEXT+4              @ TEXT
         JAS   R9,HEXPRT4              CONVERT
         CLI   LEN,8                   8 BYTES OF TEXT
         JE    TXT8                    YES
         CLI   LEN,7                   7 BYTES OF TEXT
         JE    TXT7                    YES
         CLI   LEN,6                   6 BYTES OF TEXT
         JE    TXT6                    YES
         MVC   PRT+11(2),PRTABL        TEXT TO PRINT               @14A
         CLI   LEN,5
         JE    TXTCLEAN                FINISH
         J     TXT8
TXT6     MVC   PRT+15(4),PRTABL        TEXT TO PRINT               @14A
         J     TXTCLEAN                FINISH                      @14A
TXT7     MVC   PRT+15(6),PRTABL        TEXT TO PRINT               @14A
         J     TXTCLEAN                FINISH                      @14A
TXT8     MVC   PRT+15(8),PRTABL        TEXT TO PRINT               @14A
TXTCLEAN XC    OFFSET,OFFSET           CLEAR
         L     R9,TX9                  GET RETURN ADDR
         BR    R9                      EXIT
******************************************************************
*                                                                *
* END OF PHASE 2 - RETURN TO PHASE 0                             *
*                                                                *
******************************************************************
EOJ      JAS   R9,FORCONST             YES, FORCE IT OUT
         PR
         CNOP  0,4                                                 @23A
*DATA2AD DS    V(DATADS)               @ DATA NAME TABLE           @14A
*SFTAD   DC    V(SFTCS)                @ SYSTEM FUNCTION TABLE     @15A
         DC    CL24'HDISASM2 VARIABLES ==>  '   EYE CATCHER        @14A
DATASTR2 DC    A(HDISASM2)             @ EPA of HDISASM2           @14A
WRITEOUT DC    V(WRITEOUT)             @ WRITE SYSPRINT            @29A
SRCHDSCT DC    V(SRCHDSCT)             @ Search DSECT              @30A
BITMAP   DC    V(BITMAP)               @ Search BIT Map            @29A
CCODEAD  DC    V(CCODECS)              @ CONDITION CODE TANLE      @21A
SVCTBLAD DC    V(SVCOPV)               @ SVC TABLE                 @13A
SGLOPAD  DC    V(SGLOPV)               @ ONE-BYTE OP-CODE TBL      @13A
DBLOPAD  DC    V(DBLOPV)               @ TWO-BYTE OP-CODE TBL      @13A
L3LOPAD  DC    V(L3LOPV)               @ RX AND RL OP-CODE TBL     @13A
L4LOPAD  DC    V(L4LOPV)               @ RXY OP-CODE TBL           @13A
MCD      MVC   CONDATA(1),0(R7)
FMCON    MVC   TEXT(1),CONDATA         DATA TO RECORD
FMCNT    MVC   2(1,R14),CONDATA        DATA TO OPERAND             @25C
MVHX     MVC   2(1,R14),PRTABL         HEX CHARS TO OPERAND        @26C
MVHX2    MVC   2(1,R12),PRTABL         HEX CHARS TO OPERAND        @26C
LINE2MVC MVC   OPNDS(1),0(R15)         MOVE RX OPERAND             @16A
BDXMVC   MVC   1(1,R15),OPNDWK         MOVE RX OPERAND
SOPMVC   MVC   OPNDS(1),OPNDWK         MOVE OPERAND
MVDS     MVC   0(1,R1),1(R4)           COPY DSECT                  @14A
MVLCOM   MVC   COMMENT(1),0(R14)                                   @28A
IFRRS    DC    XL8'41E00B8041500020'   PSASTAK !FRRS               @23A
X_A7F4   DC    XL2'A7F4'                                           @29C
X_DF80   DC    XL2'DF80'                                           @29C
X_1FF0   DC    XL2'1FF0'                                           @29A
X_0FFF   DC    XL2'0FFF'                                           @29A
ISAM64   DC    XL2'010E'               SAM64                       @13A
ILTR15   DC    XL2'12FF'               LTR  R15,R15                @15A
IPC      DC    XL2'B218'               PROGRAMM CALL OP CODE       @13A
IBR14    DC    XL2'07FE'               EXIT                        @27A
IBAKR    DC    XL4'B24000E0'           BAKR R14,0   OP CODE        @13A
IAHIR0   DC    X'A70A0010'             AHI R0,16                   @29A
UNIDEN   DC    X'A70A0010'             AHI R0,16                   @29A
ICPYA    DC    XL2'B24D'               CPYA                        @13A
ITPROT   DC    XL2'E501'               TEST PROTECT                @15A
ITBEGINC DC    XL2'E561'               TBEGINC OP CODE             @20A
X1814    DC    X'1814'
XACFC    DC    X'ACFC'                 STNSM DIS I/O EXT INT       @20A
XAD03    DC    X'AD03'                 STOSM ENA I/O EXT INT       @20A
XA7F4    DC    X'A7F4'                 J instruction               @29A
XMODID   DC    X'16C9'                 MODULE ID                   @20A
X_FFFF   DC    X'FFFF'                                             @30A
X_4000   DC    X'40000000'                                         @30A
X_7FFF   DC    X'7FFFFFFF'                                         @28A
*
AOFST    DC    F'0'          ** DEBUG ** ACTUAL DEBUGGING OFFSET   @28A
*XOFST   DC    XL3'000C80'   ** DEBUG ** RELATIVE OFFSET
*                                      x'80'    HEX4               @15A
*                                      x'40'    BASE REG IS 0      @15A
*                                      x'20'    INDEX REG IS 0     @15A
TEMP1    DC    X'00'
S_A0     DC    C'A0'                                               @22A
SL1      DC    C'L1'
SL2      DC    C'L2'
SL3      DC    C'L3'
P0       DC    P'0'                    CONSTANT 0
P1       DC    P'1'                    CONSTANT 1
P10      DC    P'10'                   CONSTANT 10
P58      DC    P'58'                   CONSTANT 58
S01      DC    C'Address set'
S02      DC    C'Branch and set Amode'
S03      DC    C'Return and set Amode'
S04      DC    C'Nonstd '               7
S05      DC    C'Linkage'               7
S06      DC    C'Perform    '
S07      DC    C'Parm set branch'
S08      DC    C'Compare'
S09      DC    C'Test return code'
S10      DC    C'PC'
S11      DC    C'Restore registers'
S12      DC    C'Save registers'
S12A     DC    C'Save access registers'
S13      DC    C'XMS instr'
S14      DC    C'SSE instr'
S15      DC    C'Prefetch data'                                    @29A
SJLNOP   DC    CL6'JLNOP '                                         @20A
SJNOP    DC    C'J'
SNOP     DC    CL5'NOP'                                            @20A
S17      DC    C'Undocument OP code'
S18      DC    C'Return'
S19      DC    C'Exit  '
S20      DC    C'         '
S21      DC    C'SPKA'
S23      DC    C'Set PSW key '
S23A     DC    C'to 0'
S23B     DC    C'to 1'
S23C     DC    C'to 5'
S25      DC    C'(R0)'
S26      DC    C'(,R'
S27      DC    C'Decrement REG by 1'                               @13A
S28      DC    C'Copy data'                                        @13A
S29B     DC    C'Extract Stack Register'                           @24A
S30      DC    C'Call Sub-Routine'                                 @13A
*S31     DC    C'RL jump instruction'                              @13A
S32      DC    C'Loop until REG = 0'                               @21A
S34      DC    C'Trace system routine'                             @14A
S37      DC    C'Signal processor'                                 @15A
S38      DC    C'Invalid address ?'                                @15A
S39      DC    C'C '                                               @17A
S40      DC    C'Update P/SASN'                                    @22A
S14Q     DC    14C'?'
SX16     DC    C'16'''                                             @20A
SC004    DC    C'000004'                                           @20A
S_EQU    DC    CL6'EQU'                                            @22C
S_VBRC   DC    C'V('                                               @22A
S_ADBRC  DC    C'AD('                                              @28A
S_AL3    DC    C'AL3'                                              @13A
S_LM     DC    C'LM'                                               @23A
S_PFD    DC    C'PFD'                                              @29A
S_EREG   DC    C'EREG'                                             @26A
S_LARL   DC    CL5'LARL '                                          @15A
S_CLEAR  DC    C'CLEAR'                           CLEAR DSECT      @30A
S_DUMMY  DC    C'DUMMY'                           DUMMY DSECT      @24A
CLOSEBK  DC    C')   '                                             @31A
SCOMMAR  DC    C',R'
SCOMMARF DC    C',FR'                                              @29A
SBRANCH  DC    C'Jump if '                                         @13A
SCLREG   DC    C'Clear '                                           @17A
SSAM64   DC    C'64 bit Addressing Mode'                           @13A
SDISIE   DC    C'Disable I/O and EXT interrupt'                    @20A
SENAIE   DC    C'Enable I/O and EXT interrupt'                     @20A
STBEGINC DC    C'Constrained Transaction Begin'                    @24A
SNOTCC0  DC    C'Branch if not cc 0'                               @20A
SCC0     DC    C'Branch if cc 0'                                   @20A
SFRRS    DC    C'!FRRS PSASTAK Normal Stk'                         @23A
S_DROP   DC    C'DROP'
S_LASP   DC    C'LASP'                                             @22A
S_PLO    DC    C'PLO'                                              @29A
SCODERG  DC    C'Data Register ??'                                 @13A
TMPSTR   DC    CL8' '                  For 8 bytes hexi conversion @29A
SF00     DC    C'F''0'''
SH00     DC    C'H''0'''
SFAPO    DC    C'F'''
SHAPO    DC    C'H'''
SCAPO    DC    C'C'''
HIGHBITO DC    C'+X''80000000'''            HIGH ORDER BIT IS ON   @13A
         DC    32X'FF'        *** DEBUG ***
DBLWD2   DC    2D'0'
         DC    32X'FF'        *** DEBUG ***
F50000   DC    F'50000'                                            @26C
*
USG12    DS    2F                      REG SAVE AREA
EQU9     DS    F                       RETURN ADDR FOR EQUSTMT
FC6      DS    F                       SAVE AREA FOR R6
FC9      DS    F                       FORCONST RETURN ADDR
TX9      DS    F                       RETURN ADDR FOR TXTFMT
BD9      DS    F                       RETURN FOR BDADR
BDX9     DS    F                       RETURN FOR BDXADR R9
BDL9     DS    F                       RETURN FOR BDLADR
BD11     DS    F                       SAVE FOR R11
BDR11    DS    F                       SAVE FOR R11                @28A
BDX15    DS    F                       SAVE FOR R15                @29A
FORRG9   DS    F                       RETURN FOR FORRG            @12A
SLSAV    DS    4F                      SAVE FOR SCHLBL
ILENG    DC    H'0'                    INSTRUCTION LENGTH  FIX***
SAVLEN   DC    H'0'                    CONLEN                      @12A
CODPROG  DC    X'00'                   CODE     IN PROGRESS INDIC  @15A
CONPROG  DC    X'00'                   CONSTANT IN PROGRESS INDIC
CONPSLBL DS    0CL14                   PSEUDO LABEL ENTRY FOR CONSTANTS
         DS    XL4
CONNAME  DS    CL12                    CONSTANT NAME               @24C
CONLLEN  DS    XL1                     LABEL LENGTH
CONTYPE  DS    CL1                     TYPE C, V OR X
         DS    0H
CONDATA  DS    XL48                    CONSTANT DATA 48 BYTES      @15C
MAXLEN   EQU   48                      MAX LENGTH OF TEXT          @15A
CONSYM   DS    CL8                     CONSTANT SYMBOL
CONLEN   DS    H                       CONSTANT LENGTH
CONOFST  DS    F                       RELATIVE OFFSET TO CONSTANT
CONLOC   DS    F                       @CURRENT BYTE IN CONSTANT
CCTYPE   DC    X'00'                   CC SET TYPE OF INSTR SETTING
*XTOFST  DS    0F
*        DS    X
*XTOFSET DS    XL3                     OFFSET TO TEXT BYTE
TXTOFSTR DS    0F
         DS    X
TXTOFSTC DS    XL3                     CURRENT REFERENCE OFFSET
OFFSET   DS    XL3                     OFFSET FROM PGM START
         DS    0D                      DOUBLE WORD ALIGNMENT
INSTYP   DS    CL1                     INSTRUCTION TYPE
TYPE     DS    XL1                     TYPE CODE
*                                       0=CSECT, 1=ADCON, 2=CONST
*                                       E=USING, D=INSTRUCTION
*                                       C=COMMENT, 9=ENTRY
*                                       A=EQU
LEN      DS    XL1                     TEXT LENGTH
X0010    DC    X'0010'                                             @26A
X0050    DC    X'0050'                                             @26A
NEXCHG   DC    XL3'00'                 OFFSET TO NEXT BASE REG CHG
MORUSG   DC    X'00'                   0=NO MORE BASES, 80=MORE BASES
*
* INSTRUCTION DISASSEMBLY TABLES. THESE TABLES DEFINE VALID
* INSTRUCTION OP-CODES, AND GIVE MNEMONICS, FORMAT-TYPES,
* AND AN INDICATOR TO SHOW CONDITION SETTING INSTRUCTIONS,
* PRIVILEGED INSTRUCTIONS, AND FLOATING POINT INSTRUCTIONS.
*
*
*IVAL    DC    4X'FF'                  CONSTANT X F'S
         DC    C'ASCIITB'                                          @25A
ASCIITBL DC    128X'FF'                TRT TABLE FOR CHAR/HEX
         ORG   ASCIITBL+32
         DC    C' !"#$%'
         DC    X'507D'
         DC    C'()*+,-./'
         DC    C'0123456789'
         DC    C':;<=>?@'
         DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
         DC    X'FFE0FFA16DB9'
         DC    C'abcdefghijklmnopqrstuvwxyz'
         DC    C'{|}'
         ORG
CHARTRAN DC    256X'FF'                TRT TABLE FOR CHAR/HEX
         ORG   CHARTRAN+C' '
         DC    X'00'                   BLANK IS CHARACTER
         ORG   CHARTRAN+X'4A'
         DC    5X'00'                    ? ARE CHARACTERS
         ORG   CHARTRAN+C'$' 5B                           4/16/87
         DC    4X'00'                   $* ARE CHARACTERS
         ORG   CHARTRAN+C'-' 60
         DC    2X'00'                   -/ ARE CHARACTERS
         ORG   CHARTRAN+C',' 6B                           4/16/87
         DC    5X'00'                ,%_>? ARE CHARACTERS
         ORG   CHARTRAN+C':' 7A                           4/16/87
         DC    6X'00'               :#@'=" ARE CHARACTERS
         ORG   CHARTRAN+C'~' A0
         DC    9X'00'                  S-Z ARE CHARACTERS
         ORG   CHARTRAN+C'A'
         DC    9X'00'                  A-I ARE CHARACTERS
         ORG   CHARTRAN+C'J'
         DC    9X'00'                  J-R ARE CHARACTERS
         ORG   CHARTRAN+C'S'
         DC    8X'00'                  S-Z ARE CHARACTERS
         ORG   CHARTRAN+C'0'
         DC    10X'00'                 0-9 ARE CHARACTERS
         ORG
         DC    C'MIXCTRAN'                                        @25A
MIXCTRAN DC    256X'FF'                TRT TABLE FOR CHAR/HEX     @16A
         ORG   MIXCTRAN+C' '
         DC    X'00'                   BLANK IS CHARACTER
         ORG   MIXCTRAN+X'4A'
         DC    6X'00'                    ? ARE CHARACTERS
         ORG   MIXCTRAN+C'$' 5B
         DC    4X'00'                   $* ARE CHARACTERS
         ORG   MIXCTRAN+C'-' 60
         DC    2X'00'                   -/ ARE CHARACTERS
         ORG   MIXCTRAN+C',' 6B
         DC    5X'00'                ,%_>? ARE CHARACTERS
         ORG   MIXCTRAN+C':' 7A
         DC    3X'00'                  :#@ ARE CHARACTERS
         ORG   MIXCTRAN+C'=' 7E
         DC    X'00'                   =  ARE CHARACTERS
         ORG   MIXCTRAN+C'a' 81
         DC    9X'00'                  a-i ARE CHARACTERS
         ORG   MIXCTRAN+C'j' 91
         DC    9X'00'                  j-r ARE CHARACTERS
         ORG   MIXCTRAN+C's' A2
         DC    8X'00'                  s-z ARE CHARACTERS
*        ORG   MIXCTRAN+C's' A2
*        DC    6X'00'                  s-w ARE CHARACTERS
*        ORG   MIXCTRAN+C'y' A8
*        DC    2X'00'                  y-z ARE CHARACTERS
         ORG   MIXCTRAN+C'A'
         DC    9X'00'                  A-I ARE CHARACTERS
         ORG   MIXCTRAN+C'J'
         DC    9X'00'                  J-R ARE CHARACTERS
         ORG   MIXCTRAN+C'S'
         DC    8X'00'                  S-Z ARE CHARACTERS
         ORG   MIXCTRAN+C'0'
         DC    10X'00'                 0-9 ARE CHARACTERS
         ORG
         DS    CL64                                                @15A
BASERG   DC    X'FF'                                               @15A
SECOND_LINE    DC CL80' '                                          @14A
         COPY  HDISTD
COMMPARM DSECT ,                       COMMON AREAS
         COPY  HDISTC
         END
         COPY  HDISOPT1                OPERATION CODE TABLE 1      @24C
         COPY  HDISOPT2                OPERATION CODE TABLE 2      @24C
         COPY  HDISCCTB                CONDITIONAL CODE TABLE      @21A
         COPY  HDISSVTB                SVC TABLE
*        COPY  HDISPSTB                PSA MAPPING
*        COPY  HDISD2TB                SYSTEM CONTROL BLOCK MAPPING
*        COPY  HDISSFTB                SYSTEM FUNCTION TABLE
         END
