DIS1     TITLE '*** ASMH DISASSEMBLY PHASE 1 ***'
* FUNCTION
* ========
* THIS SUB-PROGRAM IS CALLED BY HDISASM, AND IS PHASE 2 OF
* THE DISASSEMBLY-H PROCESS. A COMMON DATA AREA IS DEFINED
* IN HDISASM, AND PASSED TO THIS PROGRAM.
*
*    THE SYSIN FILE IS READ TO EXHAUSTION. USING CARDS ARE
* REFORMATTED AND STORED IN A TABLE - UP TO 256 USING
* STATEMENTS MAY BE ENTERED. DSECT CARDS MAY FOLLOW THE
* USING STATEMENTS. WHEN USED, DSECT STATEMENTS ARE
* REFORMATTED, AND BUILT INTO TABLES. A MAXIMUM OF 256 DSECTS
* MAY BE ENTERED  DATA ONLY CARDS MAY BE INCLUDED BEFORE, BETWEEN,
* OR AFTER DSECTS TO SHOW AREAS IN THE PROGRAETWHERE NO INSTRUCTIONS
* OCCUR. UP TO 256 DATA ONLY AREAS MAY BE SPECIFIED.
*
*     AT EOF ON SYSIN, A PSEUDO DIS-ASSEMBLY PASS IS MADE USING
* THE TEXT STORED BY HDISASM. ANY RESOLVABLE ADDRESS WITHIN THE
* TEXT IS USED TO CREATE A NEW ENTRY IN THE LABEL TABLE, WHICH
* WILL BE USED BY HDISASM2 IN THE ACTUAL DIS-ASSEMBLY PASS.
*
* THE USING CARDS FOR BASE REGISTERS ASSOCIATED WITH DSECT DEFINITIONS
* MUST BE ENTERED AT SOME POINT AFTER THE DSECT CARDS HAVE BEEN
* INCLUDED. USING CARDS FOR PROGRAM BASE REGISTERS MAY BE ENTERED
* AT ANY POINT. THE USING CARD FORMAT IS:
*       COL 1-5   : LITERAL 'USING'
*       COL 6     : BLANK
*       COL 7-12  : OFFSET TO BEGIN LOCATION FOR USING RANGE (HEX)
*       COL 13    : BLANK
*       COL 14-19 : OFFSET TO ENDING LOCATION FOR USING RANGE (HEX)
*       COL 20    : BLANK
*       COL 21    : BASE RESISTER TO BE USED (HEX, 1-F)
*       COL 22    : BLANK
*       COL 23    : TYPE, P=PROGRAM BASE, D=DSECT BASE
*       COL 24    : BLANK
*       COL 25-30 : INITIAL BASE REGISTER VALUE IF TYPE P (HEX)
*       COL 25-32 : DSECT NAME IF TYPE D
*
*     A DSECT IS ENTERED USING A HEADER CARD,FOLLOWED BY
* ONE OR MORE FIELD DEFINITION CARDS. ALL FIELD DEFINITION
* CARDS MUST FOLLOW THE DSECT HEADER CARD. USING CARDS MAY
* NOT BE INTERSPERSED WITH DSECT DEFINITIONS, BUT MAY PRECEDE
* OR FOLLOW ANY DSECT.
*     DSECT HEADER CARD FORMAT:
*        COL 1-8    : DSECT NAME
*        COL 9      : BLANK
*        COL 10-14  : LITERAL 'DSECT'
*        COL 15     : BLANK
*        COL 16-19  : NUMBER OF FIELD CARDS TO FOLLOW (DECIMAL)
*        COL 20     : BLANK
*        COL 21-28  : MAIN DSECT NAME
*
*     DSECT FIELD CARD FORMAT:
*        COL 1-12   : FIELD NAME
*        COL 13     : BLANK
*        COL 14-18  : OFFSET TO LEFT END OF FIELD (DECIMAL) 12345
*        COL 19     : BLANK
*        COL 20-22  : LENGTH OF FIELD IN BYTES (DECIMAL)    123
*        COL 23     : BLANK
*        COL 24-51  : COMMENT OR FILED DESCRIPTION (28 BYTES)
*
*     A DATA ONLY CARD IS USED TO DESIGNATE A RANGE OF OFFSETS
* BETWEEN WHICH NO INSTRUCTIONS EXIST. USE OF THESE CARDS ELIMINATES
* THE CHANCE THAT DATA ELEMENTS WILL BE TREATED AS INSTRUCTIONS
* BETWEEN THE OFFSETS SPECIFIED. FORMAT IS:
*        COL 1-4    : LITERAL 'DATA' , 'DATX/HEX4' 'HEX2'
*        COL 5      : BLANK
*        COL 6-11   : OFFSET TO BEGINNING OF AREA (HEX)
*        COL 12     : BLANK
*        COL 13-18  : OFFSET TO END OF AREA (HEX)
*
*     A CODE ONLY CARD IS USED TO DESIGNATE A RANGE OF OFFSETS
* BETWEEN WHICH REALLY INSTRUCTIONS.   USE OF THESE CARDS ELIMINATES
* THE CHANCE THAT INSTRUCTIONS WILL BE TREATED AS DATA BETWEEN THE
* THE OFFSETS SPECIFIED. FORMAT IS:
*        COL 1-4    : LITERAL 'CODE'
*        COL 5      : BLANK
*        COL 6-11   : OFFSET TO BEGINNING OF AREA (HEX)
*        COL 12     : BLANK
*        COL 13-18  : OFFSET TO END OF AREA (HEX)
*
*     USER LABEL CARDS ARE USED TO PERMIT SPECIFICATION OF
* LABELS OTHER THAN THE AXXXXXX NAMES CREATED BY HDISASM. THEY
* MAY APPEAR ANYWHERE IN THE SYSIN STREAM EXCEPT AS THE FIRST
* CARD, OR WITHIN A DSECT DEFINITION.
*        COL  1-5  : LITERAL 'ULABL'
*        COL   6   : BLANK
*        COL  7-18 : FIELD NAME
*        COL   19  : BLANK
*        COL 20-25 : OFFSET TO LEFT END OF AREA (HEX)
*        COL   26  : BLANK
*        COL 27-29 : FIELD LENGTH (DECIMAL)
*
*     LONG USER LABEL CARDS ARE USED TO PERMIT SPECIFICATION OF
* LABELS OTHER THAN THE AXXXXXX NAMES CREATED BY HDISASM. THEY
* MAY APPEAR ANYWHERE IN THE SYSIN STREAM EXCEPT AS THE FIRST
* CARD, OR WITHIN A DSECT DEFINITION.
*        COL  1-5  : LITERAL 'LLABL'
*        COL   6   : BLANK
*        COL  7-24 : FIELD NAME
*        COL   25  : BLANK
*        COL 26-31 : OFFSET TO LEFT END OF AREA (HEX)
*        COL   32  : BLANK
*        COL 33-35 : FIELD LENGTH (DECIMAL)
*
*     LONG USER LABEL CARDS ARE USED TO PERMIT SPECIFICATION OF
* LABELS OTHER THAN THE AXXXXXX NAMES CREATED BY HDISASM. THEY
* MAY APPEAR ANYWHERE IN THE SYSIN STREAM EXCEPT AS THE FIRST
* CARD, OR WITHIN A DSECT DEFINITION.
*        COL  1-5  : LITERAL 'FIELD'
*        COL   6   : BLANK
*        COL  7-12 : PROGRAM OFFSET
*        COL   13  : BLANK
*        COL 14-50 : DESCRIPTION (27 BYTES)
*
*     CTLBK CARDS ARE USED TO DEFINE THE USER DEFINE DSECTS WHICH
* ARE RELATED TO EACH OTHER. THE DSECT FIELDS ARE ASSEMBLED INTO
* LOAD MODULE HDISDSTB. FOR EXAMPLE CVT, PSA AND ETC
*
*        COL  1-5  : LITERAL 'CTLBK'
*        COL   6   : BLANK
*        COL   7   : @ OR !
*        COL  8-12 : DSECT NAME
*        COL   13  : BLANK
*        COL 14-19 : OFFSET TO BEGINNING OF THE AREA (HEX)
*        COL   20  : BLANK
*        COL   21  : BASE RESISTER TO BE USED (HEX, 1-F)
*
*      DISASSEMBLY TABLES ARE SET UP IDENTICALLY TO THOSE USED BY
* HDISASM2 FOR THE SIMULATED DISASSEMBLY PERFORMED IN THIS
* MODULE WHEN ANY PROGRAM BASE REGISTER USING STATEMENTS
* ARE ENTERED.
*
*     STORAGE IS OBTAINED FOR THE DSECT TABLE AND USING TABLE,
* AND ADDRESSES OF THESE TABLES ARE STORED IN THE COMMON PARAMETER
* AREA. USING AND DSECT CARDS ARE EDITED, REFORMATTED, AND PLACED
* IN THE APPROPRIATE TABLES. IF ANY ERRORS ARE FOUND, THEY ARE
* PRINTED, AND THE DISASSEMBLY WILL BE TERMINATED ON RETURN
* TO HDISASM.
*
*     STORAGE IS OBTAINED FOR THE LABEL TABLE, AND A SIMULATED
* DIS-ASSEMBLY IS PERFORMED TO CREATE LABEL TABLE ENTRIES FOR
* LABELS WHICH WILL BE GENERATED FOR BASE-DISPLACEMENT ADDRESSES
* BY HDISASM2. ON RETURN TO DISASM, THESE LABELS WILL BE SORTED
* WITH EXTERNAL SYMBOL AND RLD LABELS TO FORM THE FINAL LABEL
* TABLE TO BE USED BY HDISASM2.
*
* AUTHOR R THORNTON - FEB 1978
* CHANGE LOG :
* 01.  REMOVE THE RESTRICTION OF USING R0 BASE REGISTER TO
*      REFERENCE PSA DATA AREA DSECT          ALBERT CHENG NOV 1987
*
* 02.  FIX FORMATTING BRANCH INSTRUCTION
*                                             ALBERT CHENG SEP 1991
* 03.  SUPPORT NEW ASSEMBLER INSTRUCTION
*                                             ALBERT CHENG JUN 1992
* 04.  SUPPORT RRE2, SS3 AND RI INSTRUCTION
*                                             ALBERT CHENG JAN 2007
* 05.  A) SUPPORT RL, RSE AND RSI INSTRUCTIONS
*      B) FORMAT BC AND JC INSTRUCTIONS WITH EXTENDED MNEMONICS
*      C) FORMAT RI OPERAND WITH ADDRESS LABEL
*      D) USE NEW ASSEMBLER INSTRUCTION SUCH AS AHI, J AND ETC
*                                             ALBERT CHENG APR 2012
* 06. USE R4 AS DATA REGISTER AND NO CODE REGISTER
*                                             ALBERT CHENG JUL 2013
*
* 07. ADD CODE STATEMENT TO AVOID AN INSTRUCTION IS TREATED AS
*     DATA
*                                             ALBERT CHENG OCT 2013
* 08. SUPPORT CTLBK STATEMENT
*     DOES NOT GENERATE LABEL FOR USING STATEMENT
*                                             ALBERT CHENG MAR 2014
* 09. A) EACH DSECT ENTRY HAS 28 BYTES DESCRIPTION TO MAKE
*        MORE DE-CODE SOURCE MORE MEANINGFUL
*     B) ADD DATX STATEMENT TO FORMAT A DATA STRING AS HEXIDECIMAL
*     C) ENHANCE CTLBK STATMENT TO SEARCH
*         1)  @XXXXX SEARCH GLOBAL MAPPING WHERE XXXXX IS THE
*                    PRE-COMPILE GLOBAL DSECT
*         2)  $XXXXX SEARCH LOCAL MAPPING WHERE XXXXX IS THE
*                    INSTREAM DSECT TABLE
*                                             ALBERT CHENG AUG 2015
* 10. A) CHANGE LABEL TABLE SIZE FROM 16 TO 20
*     B) CHANGE DSECTD TABLE SIZE FROM 39 TO 45
*     C) EXTEND ULABEL LENGTH FROM 8 TO 12
*     D) EXTEND THE LENGTH OF DSECT FIELD NAME FROM 8 TO 12
*                                             ALBERT CHENG SEP 2015
* 11. A) FIX RXY DISPLACEMENT
*     B) SUPPORT RIE INSTRUCTION
*     C) ADD OPERAND LENGTH TO OPCODE TABLE
*                                             ALBERT CHENG JUL 2016
* 12. A) EXTEND THE DISPLACEMENT OF DSECT FIELD FROM 4 DIGITS
*        5 DIGITS.
*                                             ALBERT CHENG SEP 2016
* 13. A) REDEFINE
*                                             ALBERT CHENG DEC 2016
*
* 14. A) SUPPORT RRF/RSA INSTRUCTION SETS
*                                             ALBERT CHENG JUL 2017
*
* 15. A) FORMAT ASCII & FIELD DESCRIPTION
*                                             ALBERT CHENG DEC 2018
********************************************************************
*                                                                *
* CHECK FOR PRIVILEGED AND/OR FLOATING POINT INSTRUCTION OPTION. *
* IF THESE INSTRUCTIONS ARE NOT TO BE ASSEMBLED, CLEAR THEIR     *
* INSTRUCTION TABLE ENTRIES.                                     *
*                                                                *
******************************************************************
*
HDISASM1 CSECT
HDISASM1 RMODE ANY
HDISASM1 AMODE 31
         J     BEGIN                                              @05A
         DC    C'HDISASM1'              PROGRAM NAME              @05A
         DC    C'01.13'                 VERSION NUMBER            @13C
         DC    C'&SYSDATE &SYSTIME'     ASSEMBLER DATE & TIME     @05A
BEGIN    BAKR  R14,0                   SAVE RSA IN LINKAGE STACK  @05A
         LARL  R4,DATAASM1             SET R4 TO DATA REGISTER    @06A
         USING DATAASM1,R4                                        @06A
         LR    R5,R1                   GET PARM FIELD ADDRESS
         USING COMMPARM,R5
*        L     R0,CODSTRT
*        L     R2,CODOCUR
*        DC    X'0000'
         CLI   FLPTASM,1               FLOATING POINT INSTR O.K.
         JE    TSTPRIV                 YES
*        LRL   R12,SGLOPAD             POINT TO OP-CODE TBL
         L     R12,SGLOPAD             POINT TO OP-CODE TBL
TSTOPND  CLI   0(R12),X'FF'            END OF TBL
         JE    TSTPRIV                 YES
         TM    ICLASS-INSTENT(R12),FLTPT IS IT FLOATING POINT
         JZ    FLPSTP                  NO
         XC    0(SGOPLEN,R12),0(R12)   CLEAR ENTRY
FLPSTP   AHI   R12,SGOPLEN             TO NEXT ENTRY
         J     TSTOPND                 LOOP THRU TABLE
TSTPRIV  CLI   PRIVASM,1               PRIVILEGED INSTR O.K.
         JE    GETUSGTB                YES
*        LRL   R12,SGLOPAD             POINT TO OP-CODE TBL
         L     R12,SGLOPAD             POINT TO OP-CODE TBL
TTOPND   CLI   0(R12),X'FF'            END OF TABLE
         JE    CKDBLS                  YES
         TM    ICLASS-INSTENT(R12),PRIV PRIVILEGED INSTR
         JZ    PRIVSTP                 NO
         XC    0(SGOPLEN,R12),0(R12)   YES, CLEAR ENTRY
PRIVSTP  AHI   R12,SGOPLEN             TO NEXT ENTRY
         J     TTOPND                  LOOP THRU TABLE
*KDBLS   LRL   R12,DBLOPAD             @ 2-BYTE OP-CODE TBL
CKDBLS   L     R12,DBLOPAD             @ 2-BYTE OP-CODE TBL
CKDBND   CLI   0(R12),X'FF'            END OF TBL
         JE    GETUSGTB                YES
         TM    ICLASS-INSTENT+2(R12),PRIV PRIVILEGED OP-CODE
         JZ    DBSTP                   NO
         XC    0(DGOPLEN,R12),0(R12)   YES, CLEAR ENTRY
DBSTP    AHI   R12,DGOPLEN             TO NEXT ENTRY
         J     CKDBND                  LOOP THRU TABLE
*
******************************************************************
*                                                                *
* GET STORAGE FOR USING AND DSECT POINTER TABLES.                *
* 256 ENTRIES                                                    *
* SIZE OF USING TABLE ENTRY 12                                   *
* SIZE OF USING TABLE IS 256*11 = 2816 + 48 = 2864               *
* 48 BYTES RESERVED FIELD                                        *
******************************************************************
*
*ETUSGTB GETMAIN R,LV=2864             GET STORAGE FOR USING TABLE
*ETUSGTB LA    0,2864                  GETMAIN LENGTH             @06A
GETUSGTB LA    0,3632                  GETMAIN LENGTH             @06A
         OILH  R1,X'8000'              INDICATE GETMAIN           @06A
         SVC   10                      GETMAIN                    @06A
         MVI   0(R1),X'FF'             SET TABLE END INDIC
         ST    R1,USGSTRT              SAVE TABLE START ADDR
         ST    R1,USGCUR               SET TABLE CURRENT ADDR
         AHI   R1,2816                 COMPUTE TABLE END ADDR
         ST    R1,USGEND               SAVE USING TABLE END ADDR
         L     R2,INDCB                GET SYSIN DCB ADDR
         LARL  R1,EOFCARD              GET EOF ADDR               @06A
         STCM  R1,7,33(R2)             SET EOF ADDR IN DCB
*        GETMAIN LV=2864               GET STORAGE FOR DSECT TABLE
*        STORAGE OBTAIN,LENGTH=2864,LOC=24,COND=NO
*        LHI   R0,2864                 GETMAIN LENGTH             @09C
         LHI   R0,4912                 GETMAIN LENGTH             @09C
         OILH  R1,X'8000'              INDICATE GETMAIN           @06A
         SVC   10                      GETMAIN                    @06A
         MVI   0(R1),X'FF'             SET TABLE END ADDR
         ST    R1,DTBSTRT              SAVE DSECT TABLE START ADDR
         ST    R1,DTBCURR              SAVE DSECT TABLE CURRENT ADDR
         AHI   R1,2816                 COMPUTE TABLE END ADDR
         ST    R1,DTBEND               SAVE DSECT TABLE END ADDR
         L     R1,INDCB                @ SYSIN DCB
         TM    48(R1),X'10'            IS IT OPEN
         JZ    EOFCARD                 NO
*
******************************************************************
*                                                                *
* READ SYSIN CARDS, AND DISTRIBUTE TO THE APPROPRIATE PROCESSING *
* ROUTINE: USINGS, DSECTS, DATAS, CODES, CTLBKS OR ULABLS        *
* DETECT ANY ERRORS AND PRINT ALL CARDS WITH MESSGAES AS         *
* NECESSARY.                                                     *
*                                                                *
******************************************************************
*
RDCARD   DS    0H                      *** PROCESS SYSIN CARDS ***
         L     R1,INDCB                GET SYSIN DCB ADDR
         GET   (1)                     READ NEXT CARD
         MVC   WORKREC,0(R1)           MOVE IT TO WORK AREA
         CLI   F1SW,X'01'              FIRST TIME SWITCH           @06A
         JE    MVPRT                   BRANCH IF NOT FIRST TIME    @06A
         MVI   F1SW,X'01'              SET FIRST TIME SWITCH       @06A
         MVI   PCC,C'1'                SET SKIP TO HEAD
         MVC   PRT+10(26),U20
         JAS   R9,PRINT                GO PRINT
MVPRT    MVC   PRT(80),WORKREC         CARD TO PRINT
         LARL  R9,RCCKERR              GET RETURN ADDRESS          @06C
         CLI   WORKREC,C'*'            COMMENT CARD ?              @13A
         JE    RDCARD                  SKIP IF YES                 @13A
         CLC   S_EOD,WORKREC           IS IT END OF DATA  '/*'     @11A
         JE    EOFCARD                 YES                         @11A
         CLC   S_EOJ,WORKREC           IS IT END OF DATA  '//'     @11A
         JE    EOFCARD                 YES                         @11A
         CLC   S_USING,WORKREC         IS IT A USING CARD
         JE    USINGS                  YES
         CLC   WORKREC+9(5),S_DSECT    IS IT A DSECT HEADER
         JE    DSECTS                  YES
         CLC   S_DATA,WORKREC          IS IT DATA ONLY CARD
         JE    DATAS                   YES
         CLC   S_DATX,WORKREC          IS IT DATX ONLY CARD        @09A
         JE    HEX4                    YES                         @09A
         CLC   S_HEX4,WORKREC          IS IT HEX4 ONLY CARD        @13A
         JE    HEX4                    YES                         @13A
         CLC   S_HEX2,WORKREC          IS IT HEX2 ONLY CARD        @13A
         JE    HEX2                    YES                         @13A
         CLC   S_ASCII,WORKREC         IS IT CODE ASCII CARD       @15A
         JE    ASCII                   YES                         @15A
         CLC   S_CODE,WORKREC          IS IT CODE ASCII CARD       @07A
         JE    CODES                   YES                         @07A
         CLC   S_ULABL,WORKREC         IS IT A USER LABEL
         JE    ULABLS                  YES
         CLC   S_CTLBK,WORKREC         IS IT A CTLBK ?             @08A
         JE    CTLBKS                  YES                         @08A
         MVC   PRT+70(L'U31),U31       SET UNIDENT OR OUT OF SEQ   @10C
         MVI   USERR,X'FF'             SET ERROR FLAG
         J     UERRS                   WRITE ERROR MSG AND ABEND   @08A
RCCKERR  NI    USERR,X'FE'             RESET CURRENT ERROR FLAG
         JAS   R9,PRINT                GO PRINT
         J     RDCARD                  CONTINUE
EOFCARD  DS    0H             END OF FILE SYSIN ROUTINE
         CLI   USERR,0                 ANY ERRORS FOUND
         JNE   EOJ                     YES, EXIT
*
******************************************************************
*                                                                *
* CHECK FOR ANY USING CARDS ENTERED. IF NOT, NO PRE-ASSEMBLY IS  *
* NECESSARY. IF ANY USING CARDS FOUND, CREATE LABEL TABLE ENTRIES*
* SO THAT USING STATEMENTS WILL BE VALID.                        *
*                                                                *
* THIS ROUTINE CREATES USING LABEL WHICH ARE NOT REFERENCED BY   *
* THE PROGRAM. COMMENT OUT MOST OF THE CODING OF THIS ROUTINE    *
******************************************************************
*
         L     R1,DATOCUR              GET CURRENT DATA ONLY @
         MVC   NOINAD,DATSTRT          SAVE DATA TBL ADDR
         MVC   0(3,R1),HIVAL           SET END
         MVC   3(3,R1),HIVAL           SET END
CKPRE    L     R1,USGSTRT              GET USING TBL START ADDR
         J     MAINLINE                FORCE PRE-DISASM AS       @05A
*                          USING STATEMENT IS OPTIONAL PARAMETER
*                          AS BASE REGISTER IS NO LONGER COMPULSORY
******************************************************************
*                                                                *
* EDIT USING CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*
* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*
* USING TABLE.                                                   *
*                                                                *
******************************************************************
*
USINGS   DS    0H                      *** USING CARD PROCESSING ***
         L     R12,USGCUR              GET CURRENT USING TBL ADDR
         C     R12,USGEND              END OF TBL
         JNL   UERR6                   YES, TABLE FULL
         USING USINGD,R12
         LA    R14,WORKREC                                         @10A
         USING FUSID,R14                                           @10A
         TR    FUSIBOFT(L'FUSIBOFT),TRHEX    TRANSLATE TO MAKE HEX @10C
         TRT   FUSIBOFT(L'FUSIBOFT),TRTHEX   VALID HEXIDECIMAL     @10C
         JNZ   UERR1                   INVALID BEGIN ADDR
         TR    FUSIEOFT(L'FUSIEOFT),TRHEX    TRANSLATE TO MAKE HEX @10C
         TRT   FUSIEOFT(L'FUSIEOFT),TRTHEX   VALID HEXIDECIMAL     @10C
         JNZ   UERR2                   INVALID END ADDR
         TR    FUSIREG(1),TRHEX        TRANSLATE TO MAKE HEX       @10C
         TRT   FUSIREG(1),TRTHEX       VALID HEXIDECIMAL           @10C
         JNZ   UERR3                   INVALID REG
         CLI   FUSITYPE,C'P'           PROGRAM BASE ?              @10C
         JE    CKINIT                  YES, PROGRAM BASE
         CLI   FUSITYPE,C'D'           DSECT TYPE ?                @10C
         JNE   UERR8                   NO, ERROR
         L     R1,DTBSTRT              GET ADDRESS OF DSECT TABLE
CKDSEND  CLI   0(R1),X'FF'             END OF DSECT TABLE ?
         JE    GLOBAL_MAPPING          CHECK GLOBAL MAPPING TABLE  @10A
*        JE    UERR5             BRANCH IF END OF DATA MAPPING     @10A
         CLC   0(L'FUSIDSCT,R1),FUSIDSCT    THIS THE DSECT ENTRY   @10C
         JE    USDSMV                  YES
         AHI   R1,DSECTHL              TO NEXT DSECT ENTRY         @13C
         J     CKDSEND                 LOOP THRU DSECT TABLE
GLOBAL_MAPPING DS  0H                  CHECK GLOBAL MAPPING TABLE  @10A
         L     R1,DATAAD2        R4  = ADDRESS OF MVS MAPPING      @10A
         AHI   R1,40                   POSITION TO FIRST INX ENTRY @10A
CKGSEND  CLI   0(R1),X'FF'             END OF BUILD IN MAPPING     @10A
         JE    UERR5             BRANCH IF END OF DATA MAPPING     @10A
         CLC   1(5,R1),FUSIDSCT        DSECT NAME FOUND ?          @10A
         JE    USDSMG                  BRANCH IF FOUND             @10A
         AHI   R1,20                   NEXT DSECT ENTRY            @10A
         J     CKGSEND                 TRY NEXT DATA ENTRY         @10A
USDSMG   STCM  R1,7,USVALU             MOVE DSECT TABLE ADDRESS    @10A
         MVI   USTYPE,C'G'             SET GLOBAL MAPPING          @10A
         J     USFINI                  CONTINUE                    @10A
USDSMV   MVC   USVALU,8(R1)            MOVE DSECT TABLE ADDRESS
         J     USFINI                  CONTINUE
CKINIT   TR    FUSIPBAS(L'FUSIPBAS),TRHEX  TRANSLATE TO MAKE HEX   @10C
         TRT   FUSIPBAS(L'FUSIPBAS),TRTHEX    VALID HEXIDECIMAL    @10C
         JNZ   UERR4                   INVALID BASE REG VALUE
         PACK  DBLWD(4),FUSIPBAS(7)    PACK INITIAL PROG BASE      @10C
         MVC   USVALU,DBLWD            BASE REG VALUE TO USING TBL
USFINI   PACK  DBLWD(4),FUSIBOFT(7)    PACK BEGIN OFFSET TO HEXI   @10C
         MVC   USBGN,DBLWD             BEGIN ADDRESS TO USING TABLE
         PACK  DBLWD(4),FUSIEOFT(7)    PACK ENDING OFFSET TO HEXI  @10C
         MVC   USEND,DBLWD             END ADDRESS TO USING TABLE
         TM    USEND+2,1               IS IT ODD ADDRESS ?
         JO    UERR2                 YES, ERROR
         CLI   FUSITYPE,C'D'         DSECT BASE                    @10C
         JE    USFREG                YES
         CLC   USEND,CSTLENG+1       WITHIN PROGRAM
         JH    UERR2             ??  YES, ERROR
USFREG   MVC   USREG,FUSIREG         BASE REG TO USING TABLE       @10C
         CLI   USTYPE,C'G'           GLOBAL MAPPING ?              @10A
         JE    USGBL                 BRANCH IF YES                 @10A
         MVC   USTYPE,FUSITYPE       TYPE TO USING TABLE           @10C
USGBL    CLC   USBGN,USEND           END < BEGIN
         JH    UERR7                 YES, ERROR
         CLI   USTYPE,C'P'           PROGRAM BASE ?                @12A
         JNE   USNEXT                BRANCH IF IT IS FALSE         @12A
*        CLC   USVALU,USEND          INITIAL VALUE > END OFFSET    @12A
*        JH    UERR24                BRANCH IF IT IS FALSE         @12A
USNEXT   AHI   R12,USINGL            TO NEXT USING TBL ENTRY       @10C
         MVI   0(R12),X'FF'          SET TABLE END INDIC
         ST    R12,USGCUR            SAVE UPDATED TABLE ADDR
         BR    R9                    EXIT
         DROP  R14                                                 @10A
UERR1    MVC   PRT+85(22),U01        INVALID NAME COL 7-14
         J     UERRS                 CONTINUE
UERR2    MVC   PRT+70(L'U02),U02     INVALID HEX OFFSET COL 14-19
         J     UERRS                 CONTINUE
UERR3    MVC   PRT+70(L'U03),U03     INVALID REGISTER COL 21
         J     UERRS                 CONTINUE
UERR4    MVC   PRT+70(L'U04),U04     LABEL TABLE OVERFLOW
         J     UERRS                 CONTINUE
UERR5    MVC   PRT+70(L'U05),U05     UNDEFINED DSECT COL 25-32
         J     UERRS                 CONTINUE
UERR6    MVC   PRT+70(L'U06),U06     OVER 256 USING CARDS
         J     UERRS                 CONTINUE
UERR7    MVC   PRT+70(L'U07),U07     END BEFORE BEGIN
         J     UERRS                 CONTINUE
UERR8    MVC   PRT+79(L'U08),U08     INVALID TYPE COL 23
         J     UERRS                 CONTINUE                    @12A
UERR24   MVC   PRT+79(L'U24),U24                                 @12A
UERRS    MVI   USBGN,X'FF'           INSURE TABLE END INDIC
         MVI   USERR,X'FF'           SHOW ERROR
         L     R1,PRINTDCB           @SYSPRINT DCB
         TM    48(R1),X'10'          IS SYSPRINT OPEN ?
         JNO   USINGEX               JUMP IF NO
         PUT   (1),PRTLINE           WRITE ERROR MESSAGE         @05A
         ABEND 888                   USER ABEND 888
USINGEX  BR    R9                    EXIT
         DROP  R12
*
*
*
******************************************************************
*                                                                *
* EDIT ULABL CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*
* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*
* LABEL TABLE. SEARCH FOR ANY TYPE A (ADCON) ENTRIES HAVING A    *
* SYMBOL OF AXXXXXX, WHERE XXXXXX IS THE HEX OFFSET TO THE USER  *
* LABEL. IF AN A TYPE ENTRY IS FOUND, CHANGE ITS SYMBOLIC NAME TO*
* THAT OF THE USER LABEL.                                        *
*                                                                *
******************************************************************
*
ULABLS   EQU   *                       PROCESS USER LABEL CARDS
         STM   R6,R12,ULSAV            SAVE REGS
         LA    R14,WORKREC                                         @10A
         USING FULABLD,R14                                         @10A
         CLI   FULABLNM,C' '           1ST CHAR OF LABEL NAME      @10C
         JE    ULERR1                      CANNOT BE BLANK
         MVC   UNAME+1(6),FULABLOF     BUILD AXXXXXX NAME          @10C
         TR    FULABLOF(L'FULABLOF),TRHEX   TRANSLATE TO HEX       @10C
         TRT   FULABLOF(L'FULABLOF),TRTHEX  CHECK VALID HEX OFFSET @10C
         JNZ   ULERR2                  NOT VALID
         MVZ   NUMCK(3),FULABLNG       ZONES FOR NUMERIC TEST      @10C
         CLC   NUMCK(3),ZEROS          LENGTH IS NUMERIC           @12C
         JNE   ULERR3                  NO, ERROR
         L     R6,CURRLBL              GET CURRENT LABEL TABLE ADDRESS
         USING LABELD,R6
         C     R6,ENDLBL               END OF TABLE
         JNL   ULERR4                  YES, ERROR
         MVC   LBLNAME,FULABLNM        NAME TO LABEL ENTRY         @10C
         MVI   LBLTYP,C'U'             TYPE TO LABEL ENTRY
         PACK  DBLWD,FULABLNG(L'FULABLNG)   PACK LENGTH            @10C
         CP    DBLWD,P999              FIELD LENGTH > 999          @13C
         JH    ULERR3                  YES, ERROR                  @10C
         CVB   R12,DBLWD               CONVERT TO BINARY
         STC   R12,LBLLEN              LENGTH TO LABEL ENTRY
         PACK  DBLWD(4),FULABLOF(L'FULABLOF+1)   PCK TO HEX        @10C
         DROP  R14                                                 @10A
         MVC   LBLADR,DBLWD            OFFSET TO LABEL
         LA    R7,LABELL(R6)           @ NEXT LABEL ENTRY          @10C
         MVC   0(L'LBLADR,R7),HIVAL    SET END INDIC               @10C
         ST    R7,CURRLBL              SET NEW TABLE END ADDR
         LR    R7,R6                   SAVE NEW ENTRY ADDRESS
         L     R6,LBLTBL               GET 1ST LABEL ENTRY ADDR
ULBCKND  C     R6,CURRLBL              END OF TABLE
         JNL   ULXIT                   YES, EXIT
         CLI   LBLTYP,C'A'             IS IT ADCON ENTRY
         JNE   ULBSTEP                 NO
         CLC   LBLNAME,UNAME           ADCON SYMBOL AT USER LBL ADDR
         JNE   ULBSTEP                 NO
         MVC   LBLNAME,LBLNAME-LABELD(R7) SET USER SYMBOL IN ADCON
ULBSTEP  AHI   R6,LABELL               TO NEXT LABEL ENTRY         @10C
         J     ULBCKND                 LOOP THRU LABEL TABLE
ULERR1   MVC   PRT+85(L'U21),U21    'INVALID NAME COL 7-18'        @10C
         J     ULERRS               CONTINUE
ULERR2   MVC   PRT+85(L'U22),U22    'INVALID HEX OFFSET COL 20-25' @10C
         J     ULERRS               CONTINUE
ULERR3   MVC   PRT+85(L'U23),U23    'INVALID DECIMAL LENGTH COL 27-29'
         J     ULERRS               CONTINUE
ULERR4   MVC   PRT+85(L'U04),U04    'INVALID HEX OFFSET COL 25-29'
ULERRS   MVI   USERR,X'FF'          SET ERROR FLAG
         J     UERRS                                              @10A
ULXIT    LM    R6,R12,ULSAV         RESTORE REGS
         BR    R9                   EXIT
*
*
*
******************************************************************
*                                                                *
* EDIT DSECT CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*
* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*
* DSECT HEADER TABLE, GETMAIN AN AREA TO CONTAIN THE FIELD       *
* DESCRIPTION ENTRIES, READ AND BUILD FIELD ENTRIES FOR ALL FIELD*
* DESCRIPTION CARDS ENTERED.                                     *
*                                                                *
******************************************************************
*
DSECTS   EQU   *                       *** DSECT PROCESSING ***
         ST    R9,DSCT9                SAVE RETURN ADDR
         LA    R14,WORKREC                                         @10A
         USING FDSECT,R14                                          @10A
         CLI   FDSECTHN,C' '           NAME IS BLANK               @10C
         JE    DSERR1                  YES, ERROR
         MVZ   NUMCK(4),FDSECT#        ZONES FOR CHECK             @10C
         CLC   NUMCK(4),ZEROS          IS NBR FIELDS NUMERIC
         JNE   DSERR2                  NO, ERROR
         L     R12,DTBCURR             GET CURRENT DSECT TBL ADDR
         C     R12,DTBEND              AT END OF TABLE
         JNL   DSERR3                  YES, ERROR
         PACK  DBLWD,FDSECT#           PACK NUMBER OF ENTRIES      @13A
         CVB   R10,DBLWD               CONVERT TO BINARY           @13A
         MVC   0(8,R12),FDSECTHN       COPY NAME TO DSECT TABLE    @10C
         MVC   DSECTR-DSECTHD(8,R12),FDSECTR                       @13A
         CLI   FDSECTR,C' '                                        @13A
         JE    DS1000                                              @13A
* REDEFINE LABEL                                                   @13A
         L     R0,SDSECTL              RESTORE SIZE OF DSECTS      @13A
         OILH  R1,X'8000'              TURN ON HIGH ORDER BIT      @06A
         SVC   10                      ACQUIRE STORAGE FOR DSECT   @06A
         STCM  R1,7,DSECTHA-DSECTHD(R12)   SAVE DSECT FIELD TABLE ADR
         AHI   R12,-DSECTHL                                        @13A
         XR    R14,R14                                             @13A
         ICM   R14,7,DSECTHA-DSECTHD(R12)                          @13A
         LR    R0,R1                                               @13A
         L     R1,SDSECTL                                          @13A
         L     R15,SDSECTL                                         @13A
         MVCL  R0,R14                                              @13A
         OI    REDEFSW,X'80'                                       @13A
         AHI   R12,DSECTHL             TO NEXT DSECT TABLE ENTRY   @13A
         XR    R1,R1                                               @13A
         ICM   R1,7,DSECTHA-DSECTHD(R12)                           @13A
         ST    R1,SDSECTA                                          @13A
         J     DS2000                                              @13A
DS1000   PACK  DBLWD,FDSECT#           PACK NUMBER OF ENTRIES      @10C
         CVB   R10,DBLWD               CONVERT TO BINARY
         AHI   R10,4                   ADD FOR SAFETY
         MHI   R10,DSECTL              TIMES ENTRY LENGTH          @05C
         ST    R10,SDSECTL             SAVE SIZE OF DSECT FIELD TB @13A
*        SIZE OF DSECT TABLE = 47*(#ENTRIES+4)
*        GETMAIN R,LV=(10)             GET STORAGE FOR FIELD TABLE
         LR    R0,R10                  GETMAIN LENGTH              @06A
         OILH  R1,X'8000'              TURN ON HIGH ORDER BIT      @06A
         SVC   10                      GETMAIN                     @06A
         STCM  R1,7,DSECTHA-DSECTHD(R12)   SAVE DSECT FIELD TABLE ADR
         ST    R1,SDSECTA                  SAVE DSECT ADDRESS      @13A
DS2000   AHI   R12,DSECTHL             TO NEXT DSECT TABLE ENTRY
         ST    R12,DTBCURR             UPDATE CURRENT DSECT TBL ADDR
         MVI   0(R12),X'FF'            SET END INDIC
         LR    R12,R1                  COPY FIELD TABLE ADDR
         JAS   R9,PRINT                PRINT DSECT RECORD
         USING DSECTD,R12
         CVB   R11,DBLWD               NBR ENTRIES IN LOOP REG
READ_DSECTS_FIELD  DS  0H                                          @09C
         L     R1,INDCB                GET SYSIN DCB ADDR          @09C
         GET   (1)                     READ DSECT RECORD
         MVC   WORKREC,0(R1)           MOVE RECORD TO WORK AREA
         CLI   WORKREC,C'*'            COMMENT ?                   @14A
         JE    READ_DSECTS_FIELD       SKIP IF YES                 @14A
         LA    R14,WORKREC                                         @10A
         USING FDSECTD,R14                                         @10A
         MVC   PRT(80),WORKREC         MOVE RECORD TO PRINT AREA
         CLI   WORKREC,C' '            NAME FIELD BLANK
         JE    DSERR1                  YES, ERROR
         MVZ   NUMCK,FDSOFSET          ZONES FOR TEST              @10C
         CLC   NUMCK,ZEROS             IS OFFSET NUMERIC
         JNE   DSERR3                  NO, ERROR
         PACK  DBLWD,FDSOFSET(L'FDSOFSET)  PACK OFFSET             @10C
         CP    DBLWD,P32768            OFFSET > 32768              @11C
         JH    DSERR3                  YES, ERROR
         CVB   R1,DBLWD                CONVERT
         STCM  R1,7,TMPOFSET           OFFSET TO TABLE ENTRY       @13A
         TM    REDEFSW,X'80'                                       @13A
         JNO   DS4000                                              @13A
         L     R12,SDSECTA                                         @13A
DS3000   CLI   0(R12),X'FF'                                        @13A
         JE    DSERR5                                              @13A
         CLC   TMPOFSET,DSOFSET                                    @13A
         JE    DS4000                                              @13A
         AHI   R12,DSECTL                                          @13A
         J     DS3000                                              @13A
DS4000   MVC   DSOFSET,TMPOFSET                                    @13A
         MVZ   NUMCK(3),FDSLENG        TEST FILED LENGTH           @12C
         CLC   NUMCK(3),ZEROS          IS LENGTH NUMERIC           @12C
         JNE   DSERR4                  NO, ERROR
         PACK  DBLWD,FDSLENG           PACK LENGTH                 @10C
         CP    DBLWD,P999              LENGTH OVER 999             @13A
         JH    DSERR4                  YES, ERROR                  @13A
*        CP    DBLWD,P256              LENGTH OVER 256             @13A
*        JL    DS4500                                              @13A
*        MP    DBLWD,P256                                          @13A
DS4500   CVB   R1,DBLWD                CONVERT
         LTR   R1,R1                   LENGTH IS ZERO
         JZ    DSERR4                  YES, ERROR
         STC   R1,DSLENG               LENGTH TO TABLE ENTRY
         MVC   DSCOMMT,FDSCOMMT        COPY COMMENT                @10A
         MVC   DSLNAME,WORKREC         NAME TO ENTRY
         MVI   DSLBTYP,C'D'            SET LABEL TYPE              @10C
         AHI   R12,DSECTL              TO NEXT ENTRY
         TM    REDEFSW,X'80'                                       @13A
         JO    DS5000                                              @13A
         MVI   DSOFSET,X'FF'           SET TABLE END INDIC         @10C
DS5000   JAS   R9,PRINT                GO PRINT CARD
         JCT   R11,READ_DSECTS_FIELD   READ NEXT DSECT RECORD      @09C
         TM    REDEFSW,X'80'                                       @13A
         JO    DS6000                                              @13A
         MVC   DSOFSET,HIVAL           TABLE STOPPER
DS6000   MVI   REDEFSW,X'00'           CLEAR SWITCH                @13A
         L     R9,DSCT9                GET RETURN ADDR
         BR    R9                      EXIT
DSERR1   MVC   PRT+85(L'U09),U09       'INVALID NAME COL 1-12'
         J     DSERRS                  CONTINUE
DSERR2   MVC   PRT+85(L'U10),U10       'INVALID NBR FIELDS COL 16-19'
         J     DSERRS                  CONTINUE
DSERR3   MVC   PRT+85(L'U11),U11       'INVALID OFFSET COL 14-18'  @12C
         J     DSERRS                  CONTINUE
DSERR4   MVC   PRT+85(L'U12),U12       'INVALID LENGTH COL 20-22'  @12C
         J     DSERRS                  CONTINUE
DSERR5   MVC   PRT+85(L'U25),U25       'REDEFINE OFFSET NOT FIND'  @13A
DSERRS   MVI   USERR,X'FF'             SHOW ERROR FOUND            @13A
         J     UERRS
*        L     R9,DSCT9                GET RETURN ADDR
*        BR    R9                      EXIT
         DROP  R12
*
******************************************************************
*                                                                *
* EDIT DATA ONLY CARDS FOR VALIDITY. PLACE ERROR DESCRIPTION IN  *
* PRINT LINE IF ERRORS FOUND. CREATE DATA ONLY TABLE ENTRY IF NO *
* ERRORS ARE FOUND.                                              *
*                                                                *
******************************************************************
*                                      *** HEX2 CARD PROCESSING ***
HEX2     L     R1,DATOCUR              GET TBL ADDR                @13A
         USING DATAD,R1                                            @13A
         MVI   DATATYPE,C'H'           SET IT AS HALF WORD         @13C
         J     DATASS                                              @13A
*                                      *** HEX4 CARD PROCESSING ***
HEX4     L     R1,DATOCUR              GET TBL ADDR                @09A
*        USING DATAD,R1                                            @10A
         MVI   DATATYPE,C'X'           SET IT AS HEXIDECIMAL       @10C
         J     DATASS                                              @09A
*                                      *** HEX4 CARD PROCESSING ***
ASCII    L     R1,DATOCUR              GET TBL ADDR                @15A
*        USING DATAD,R1                                            @15A
         MVI   DATATYPE,C'A'           SET IT AS ASCII             @15A
         J     DATASS                                              @15A
DATAS    DS    0H                      *** DATA CARD PROCESSING ***
         L     R1,DATOCUR              GET TBL ADDR                @09A
         MVI   DATATYPE,C'C'           ASSUME DATA STATEMENT       @10C
DATASS   LA    R14,WORKREC                                         @10A
         USING FDATAD,R14                                          @10A
         TR    FDATASTR,TRHEX          TRANSLATE TO MAKE HEX       @10C
         TRT   FDATASTR,TRTHEX         CHECK VALID                 @10C
         JNZ   DERR1                   INVALID HEX
         TR    FDATAEND,TRHEX          TRANSLATE TO MAKE HEX       @10C
         TRT   FDATAEND,TRTHEX         CHECK VALID                 @10C
         JNZ   DERR2                   INVALID HEX
         PACK  DBLWD(4),FDATASTR(L'FDATASTR+1)   PACK TO MAKE HEX  @10C
         PACK  DBLWD+4(4),FDATAEND(L'FDATASTR+1) PACK TO MAKE HEX  @10C
         CLC   DBLWD(3),DBLWD+4        CHECK 1ST LOW
         JNL   DERR3                   1ST NOT LOW, ERROR
         L     R1,DATOCUR              GET TBL ADDR
         USING DATAD,R1
         MVC   DATASTRT,DBLWD          MOVE 1ST OFFSET TO TABLE    @10C
         MVC   DATAEND,DBLWD+4         MOVE 2ND OFFSET TO TABLE    @10C
         AHI   R1,7                    TO NEXT ENTRY               @09A
         ST    R1,DATOCUR              SAVE CURRENT ENTRY ADDR
         BR    R9                      EXIT
DERR1    MVC   PRT+85(L'U13),U13       '1ST OFFSET INVALID HEX'
         J     DERRS                   CONTINUE
DERR2    MVC   PRT+85(L'U14),U14       '2ND OFFSET INVALID HEX'
         J     DERRS                   CONTINUE
DERR3    MVC   PRT+85(L'U15),U15       'END OFFSET BEFORE BEGIN'
DERRS    MVI   USERR,X'FF'             FLAG ERROR
         J     UERRS                   WRITE ERROR MSG AND ABEND   @08A
*
******************************************************************
*                                                                *
* EDIT CODE ONLY CARDS FOR VALIDITY. PLACE ERROR DESCRIPTION IN  *
* PRINT LINE IF ERRORS FOUND. CREATE CODE ONLY TABLE ENTRY IF NO *
* ERRORS ARE FOUND.                                              *
*                                                                *
******************************************************************
*
CODES    EQU   *                    *** CODE CARD PROCESSING ***   @07A
         LA    R14,WORKREC                                         @10A
         USING FDATAD,R14                                          @10A
         TR    FDATASTR,TRHEX          TRANSLATE TO MAKE HEX       @10C
         TRT   FDATASTR,TRTHEX         CHECK VALID                 @10C
         JNZ   CERR1                   INVALID HEX                 @07A
         TR    FDATAEND,TRHEX          TRANSLATE TO MAKE HEX       @10C
         TRT   FDATAEND,TRTHEX         CHECK VALID                 @10C
         JNZ   CERR2                   INVALID HEX                 @07A
         PACK  DBLWD(4),FDATASTR(L'FDATASTR+1)   PACK TO MAKE HEX  @10C
         PACK  DBLWD+4(4),FDATAEND(L'FDATASTR+1) PACK TO MAKE HEX  @10C
         CLC   DBLWD(3),DBLWD+4        CHECK 1ST LOW               @07A
         JNL   CERR3                   1ST NOT LOW, ERROR          @07A
         L     R1,CODOCUR              GET TBL ADDR                @07A
         MVC   DATASTRT,DBLWD          MOVE 1ST OFFSET TO TABLE    @10C
         MVC   DATAEND,DBLWD+4         MOVE 2ND OFFSET TO TABLE    @10C
         AHI   R1,6                    TO NEXT ENTRY               @07A
         ST    R1,CODOCUR              SAVE CURRENT ENTRY ADDR     @07A
         MVC   0(3,R1),HIVAL           SET END                     @11A
         MVC   3(3,R1),HIVAL           SET END                     @11A
         BR    R9                      EXIT                        @07A
CERR1    MVC   PRT+85(L'U13),U13       '1ST OFFSET INVALID HEX'    @07A
         J     CERRS                   CONTINUE                    @07A
CERR2    MVC   PRT+85(L'U14),U14       '2ND OFFSET INVALID HEX'    @07A
         J     CERRS                   CONTINUE                    @07A
CERR3    MVC   PRT+85(L'U15),U15       'END OFFSET BEFORE BEGIN'   @07A
CERRS    MVI   USERR,X'FF'             FLAG ERROR                  @07A
         BR    R9                      EXIT                        @07A
****************************************************************** @08A
*                                                                * @08A
* EDIT CLTBK ONLY CARDS FOR VALIDITY. PLACE ERROR DESCRIPTION IN * @08A
* PRINT LINE IF ERRORS FOUND. CREATE CTLBK TABLE ENTRY IF NO     * @08A
* ERRORS ARE FOUND.                                              * @08A
* CTLBK @TCBXX 000082 2                                          * @08A
*  12345678901234567890                                          * @08A
****************************************************************** @08A
*                                                                  @08A
CTLBKS   EQU   *                   *** CTLBK CARD PROCESSING ***   @08A
         LA    R14,WORKREC                                         @09A
         USING FCTLBKD,R14                                         @09A
         TR    FCTLBOFS(L'FCTLBOFS),TRHEX  TRANSLATE OFFSET TO HEX @09C
         TRT   FCTLBOFS(L'FCTLBOFS),TRTHEX   CHECK VALID           @09C
         JNZ   CTLERR1                 INVALID HEX                 @08A
         CLI   FCTLREG,C'*'            COMMENT ??                  @15A
         JE    CTL1000                 BRANCH IF COMMENT           @15A
         TR    FCTLREG(1),TRHEX        TRANSLATE REG TO HEX        @09C
         TRT   FCTLREG(1),TRTHEX       CHECK VALID                 @09C
         JNZ   CTLERR2                 JUMP IF INVALID REG         @08A
CTL1000  PACK  DBLWD(4),FCTLBOFS(L'FCTLBOFS+1)   PACK TO MAKE HEX  @09C
         L     R1,CTLOCUR                                          @09A
         MVC   CTLOFST-CTLD(3,R1),DBLWD      COPY PROG OFFSET      @08A
         MVC   CTLREG-CTLD(1,R1),FCTLREG     COPY BASE REGISTER    @09C
         MVC   CTLTYPE-CTLD(L'FCTLBKN,R1),FCTLBKN  COPY DSECT NAME @09C
         MVC   CTLCOMM-CTLD(L'CTLCOMM,R1),FCTLCOMM                 @09C
         AHI   R1,CTLBK                TO NEXT ENTRY               @09C
         ST    R1,CTLOCUR              SAVE CURRENT ENTRY ADDR     @08A
         BR    R9                      EXIT                        @08A
         DROP  R14                                                 @09C
CTLERR1  MVC   PRT+85(L'U16),U16       INVALID OFFSET COL 14-19    @08A
         J     CTLERRS                 CONTINUE                    @08A
CTLERR2  MVC   PRT+85(L'U17),U17     INVALID DSECT REGISTER COL 21 @08A
CTLERRS  MVI   USERR,X'FF'             FLAG ERROR                  @08A
         J     UERRS                   WRITE ERROR MSG AND ABEND   @08A
*
*
******************************************************************
*                                                                *
* MAINLINE ROUTINE FOR THE PRE-DISASSEMBLY. PURPOSE OF THIS PART *
* OF THE PROGRAM IS TO ATTEMPT TO CREATE A LABEL ENTRY FOR INSTR-*
* UCTIONS HAVING STORAGE OPERANDS. THE RESULTING LABEL TABLE WILL*
* BE SORTED, AND DUPLICATE ENTRIES ELIMINATED BEFORE EXIT FROM   *
* THIS PHASE OF DISASSEMBLY.                                     *
*                                                                *
* R7 = @ CURRENT TXT                                             *
* R12= OFFSET OF CURRENT TXT                                     *
*                                                                *
******************************************************************
*
MAINLINE EQU   *                       MAINLINE ROUTINE
         L     R6,LBLTBL               @ LABEL TABLE
         USING LABELD,R6
         MVC   TXTCURR,TXTSTRT         COPY TEXT START ADDR
GETCURR  L     R7,TXTCURR              @ CURRENT TXT BYTE
         C     R7,TXTEND               END OF TEXT
         JNL   EOJ                     YES
         MVI   CONPROG,X'00'           TURN OFF CONSTANT IN PROG   @08A
         LR    R12,R7                  COPY TEXT ADDR
         S     R12,TXTSTRT             COMPUTE OFFSET
         ST    R12,TXTOFST             SAVE OFFSET TO THIS BYTE
         CLC   NEXCHG,TXTOFSET         TIME TO CHANGE USING TBLS
         JH    CKCCODE                 NO                          @07C
         JAS   R9,NEXUSG               YES, GO DO IT
CKCCODE  L     R12,CODSTRT             GET CODE ONLY TBL ADDR      @07A
CKCARNG  CLC   TXTOFSET,0(R12)         RANGE                       @07A
         JL    NEXTCODE                BRANCH IF NO                @07A
         CLC   TXTOFSET,3(R12)         THIS BYTE IN THE RANGE      @07A
         JL    SETCODSW                BRANCH IF YES               @07A
NEXTCODE AHI   R12,6                   NEXT CODE TABLE ENTRY       @07A
         CLC   0(3,R12),XZROS          END OF CODE TABLE ??        @07A
         JE    CKDARNG                 BRANCH IF END OF TABLE      @07A
         J     CKCARNG                 GO CHECK AGAIN              @07A
SETCODSW OI    CODPROG,X'80'           TURN ON CODE IN PROGRESS    @07A
         J     CKINSTR                 BRANCH IF YES               @07A
***   CHECK DATA ONLY TABLE
CKDARNG  L     R12,NOINAD              GET DATA ONLY ENTRY ADDRESS
         MVI   CODPROG,X'00'           TRUN OFF CODE IN PROGRESS   @07A
         CLC   TXTOFSET,0(R12)         NOT YET TO THIS RANGE
         JL    CKLOSEQ                 TRUE
         CLC   TXTOFSET,3(R12)         NOW IN THE RANGE
*        JNH   CONST                   TRUE, TREAT AS CONSTANT     @08D
         JNH   SKIPDATA                TURE, THE RANGE IS DATA     @08A
         AHI   R12,7                   PAST THIS ONE, STEP TO NEXT
         ST    R12,NOINAD              SAVE NEW DATA ONLY ADDRESS
         J     CKDARNG                 AND CHECK AGAIN
SKIPDATA DS    0H             THE ENTIRE RANGE IS DATA             @08A
         L     R7,TXTSTRT              GET PROGRAM STARTING OFFSET @08A
         SR    R0,R0                   CLEAR R0                    @08A
         ICM   R0,7,3(R12)             GET DATA ENDING OFFSET      @08A
         AR    R7,R0                   CALCULATE THE END           @08A
         AHI   R7,1                              DATA ADDRESS      @08A
         ST    R7,TXTCURR              SET TXTCURR TO END ADDRESS  @08A
         J     GETCURR                 NEXT INSTRUCTION            @08A
CKLOSEQ  C     R6,CURRLBL              END OF USED LABEL TABLE?
         JNL   GCKODD                  IF SO, IGNORE LABEL STUFF
         CLC   TXTOFSET,LBLADR         LABEL ENTRY OUT OF SEQ
         JNH   GCKODD                  NO, CONTINUE
         JAS   R9,FORCONST             YES, FORCE ANY CONSTANT OUT
         AHI   R6,LABELL               TO NEXT LABEL               @10C
*        CLC   LBLADR(3),TRTHEX   *** DEBUG
*        JNE   CKLOSEQ                 CONTINUE SEQ CHK
         J     CKLOSEQ
*CKODD   TM    TXTCURR+3,1             ODD ADDRESS
GCKODD   TM    TXTOFST+3,1             ODD ADDRESS
         JO    CONST                   YES, NOT INSTR
         CLC   1(3,R7),0(R7)           4 CONSEC IDENTICAL BYTES
         JE    CONST                   YES, NOT INSTR
         TRT   0(1,R7),CHARTRAN        TEST TEXT BYTE
         JNZ   CKINSTR                 NOT CHARACTER
         CLI   CONPROG,1               IS CONSTANT IN PROGRESS
         JNE   CK6                     NO
         CLI   CONTYPE,C'C'            IS IT CHARACTER TYPE
         JE    CONST                   YES, ADD THIS TO CONSTANT
CK6      CLI   4(R7),X'A7'
         JE    CKINSTR
         TRT   0(6,R7),CHARTRAN        6 CONSECUTIVE CHARACTERS
         JZ    CONST                   YES, NOT INSTRUCTION
CKINSTR  SR    R8,R8                   CLEAR WORK
         IC    R8,0(R7)                PICK UP TXT BYTE
         MHI   R8,SGOPLEN              TIMES TABLE LENGTH         @04C
*        LRL   R1,SGLOPAD                                         @04C
         L     R1,SGLOPAD                                         @04C
         AR    R8,R1
         MVC   INSTENT,0(R8)           SAVE INSTRUCTION TBL ENTRY @04A
         SR    R0,R0                   CLEAR FOR IC INSTR         @06A
         IC    R0,INLNG                                           @06A
         SRL   R0,4                    CLEAR INSTR LENGTH         @06A
         STC   R0,IOLNG                SAVE OEPRAND LENGTH        @06A
         NI    INLNG,X'0F'             CLEAR OPERAND LENGTH       006A
         CLI   INAME,0                 IS IT AN INSTR OP-CODE     @04A
         JE    CONST                   NO, IT MUST BE CONST       @04A
         CLI   ITYPE,TWO               TWO-BYTE OP-CODE ??        @04A
         JE    DBLNDS                                             @04A
         CLI   ITYPE,L3                TWO-BYTE OP-CODE L3        @04A
         JE    L3LNDS                                             @04A
         CLI   ITYPE,L4                TWO-BYTE OP-CODE L4        @04A
         JE    L4LNDS                                             @04A
         J     GOTINST                 NO, IT MUST BE ONE TYPE INSTR
*BLNDS   LRL   R8,DBLOPAD              YES, GET L3 TBL ADDR       @04A
DBLNDS   L     R8,DBLOPAD              YES, GET L3 TBL ADDR       @04A
DBLND    CLI   0(R8),X'FF'             END OF OPCODE TABLE        @04A
         JE    CONST                   NO IT MUST BE CONST        @04A
         CLC   0(2,R8),0(R7)           THIS ENTRY MATCHES TXT ?   @04A
         JE    GOTDBLI                 YES
         AHI   R8,DGOPLEN              TO NEXT ENTRY
         J     DBLND                   LOOP THRU TBL
*3LNDS   LRL   R8,L3LOPAD              LOAD L3 TBL                @04A
L3LNDS   L     R8,L3LOPAD              LOAD L3 TBL                @04A
L3LND    CLI   0(R8),X'FF'             END OF TABLE               @04A
         JE    CONST                   YES, GET L4 TBL ADDR       @04A
         CLC   0(1,R8),0(R7)                                      @04A
         JNE   L3LNDXT                                            @04A
         MVC   TEMP1,1(R7)             MASK OFF THE FIRST 4 BITS  @04A
         NI    TEMP1,X'0F'             OF THE 2ND BYTES           @04A
*                                      EX.  X4   ..> 04           @04A
         CLC   1(1,R8),TEMP1                                      @04A
         JE    GOTDBLI                 YES THEN BRANCH            @04A
L3LNDXT  AHI   R8,L3OPLEN              TO NEXT ENTRY              @04A
         J     L3LND                   LOOP THRU TBL              @04A
*4LNDS   LRL   R8,L4LOPAD                                         @04A
L4LNDS   L     R8,L4LOPAD                                         @04A
L4LND    CLI   0(R8),X'FF'             END OF TABLE               @04A
         JE    CONST                   YES, GET 2-BYTE TBL ADDR   @04A
         CLC   0(1,R8),0(R7)           1ST OP CODE MATCH ?        @04A
         JNE   L4LNDXT                 BRANCH IF NOT MATCH        @04A
         CLC   1(1,R8),5(R7)           2ND OP CODE MATCH ?        @04A
         JE    GOTDBLI                 YES THEN BRANCH            @04A
L4LNDXT  AHI   R8,L4OPLEN              TO NEXT ENTRY              @04A
         J     L4LND                   LOOP THRU TBL              @04A
GOTDBLI  AHI   R8,2                    BYPAS DOUBLE BYTE OPCODE   @04A
GOTINST  MVC   INSTENT,0(R8)           SAVE INSTRUCTION TBL ENTRY @04A
         SR    R0,R0                   CLEAR FOR IC INSTR         @06A
         IC    R0,INLNG                                           @06A
         SRL   R0,4                    CLEAR INSTR LENGTH         @06A
         STC   R0,IOLNG                SAVE OEPRAND LENGTH        @06A
         NI    INLNG,X'0F'             CLEAR OPERAND LENGTH       006A
         MVC   ILENG+1(1),INLNG        SET INSTR LENGTH           @04A
*
******************************************************************
*                                                                *
* CHECK TO SEE IF THIS BYTE OF THE PROGRAM IS AN INSTRUCTION OP  *
* CODE. IF SO, PERFORM THE APPROPRIATE PROCESSING ROUTINE.       *
*                                                                *
* R7 = ADDRESS OF CURRENT INSTRUCTION                            *
*                                                                *
******************************************************************
MVMNE    MVC   MNEMONIC,0(R8)          SET INSTR MNEMONIC
         MVC   OFFSET,TXTOFSET         SET OFFSET
         MVC   INSTYP,ITYPE            SET INSTR TYPE
*        MVC   INSTYP,5(R8)            SET INSTR TYPE
         MVI   TYPE,X'0D'              SHOW IT IS AN INSTRUCTION
         MVC   LEN,ILENG+1             SHOW LENGTH
         MVC   TEXT(6),0(R7)           MOVE ACTUAL TEXT
*        TM    ICLASS,FLTPT            FLOATING POINT OP-CODE
*        JO    FPVERFY                 YES, GO VERIFY
         CLI   IEDT,0                  ANY EDIT REQUIRED ??
         JE    PFMFMT                  BRANCH NO EDIT REQUIRED   @05A
******************************************************************
*                                                                *
* GENERAL OP-CODE TESTS TO VERIFY THAT NON-FLOATING-POINT OP     *
* CODES ARE INDEED OP-CODES.                                     *
*                                                                *
******************************************************************
*
IVERFY   EQU   *                       *** VERIFY POSSIBLE INSTRUCTION
         TM    IEDT,EPR                EVEN-ODD REG PAIR
         JZ    IVE2                    NO
         TM    1(R7),X'10'             R1 IS ODD
         JO    CONST                   YES, NOT INSTR
         CLI   0(R7),X'0E'             IS IT MVCL
         JE    IVTRG2                  YES
         CLI   0(R7),X'0F'             IS IT CLCL
         JNE   IVE2                    NO
IVTRG2   TM    1(R7),X'01'             R2 IS ODD
         JO    CONST                   YES, NOT INSTR
         SR    R1,R1                   CLEAR WORK
         SR    R2,R2                   CLEAR WORK
         IC    R1,1(R7)                GET R1R2
         SRL   R1,4                    SHIFT OUT R2
         PACK  DBLWD(1),1(1,R7)        FLIP R1R2 BYTE
         IC    R2,DBLWD                PICK UP R2R1
         SRL   R2,4                    SHIFT OUT R1
         CR    R1,R2                   R1=R2
         JE    CONST                   YES, NOT INSTR
         J     PFMFMT                  NO, GOOD INSTR
IVE2     TM    IEDT,E2                 HALFWORD STORAGE ALIGNMENT
         JZ    IVE4                    NO
         TM    3(R7),X'01'             DISPL IS ODD
         JZ    IVES2                   NO, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         JNZ   IVES2                   NO, CONTINUE
         CLI   ITYPE,RS                RS INSTRUCTION
         JE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG IS 0
         JZ    CONST                   YES, NOT INSTR
         J     IVES2                   CONTINUE
IVE4     TM    IEDT,E4                 2ND OPND ON FULLWORD BOUND
         JZ    IVE8                    NO
         TM    3(R7),X'03'             DISPL DIV BY 4
         JZ    IVES2                   YES, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         JNZ   IVES2                   NO, CONTINUE
         CLI   ITYPE,RS                RS INSTRUCTION OP CODE
         JE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG = 0
         JZ    CONST                   YES, NOT INSTR
         J     IVES2                   NO, CONTINUE
IVE8     TM    IEDT,E8                 2ND OPND ON DBLWD BOUND
         JZ    IVES2                   NO
         TM    3(R7),X'07'             DISPL DIV BY 8
         JZ    IVES2                   YES, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         JNZ   IVES2                   NO
         TM    1(R7),X'0F'             INDEX REG = 0
         JZ    CONST                   YES, NOT INSTR
IVES2    CLI   PRIVASM,1               PRIVILEGED INSTR O.K.
         JE    PFMFMT                  YES
         TM    IEDT,S2                 OPND2 MUST HAVE BASE
         JZ    IVES1                   NO
         TM    2(R7),X'F0'             BASE REG = 0
         JNZ   PFMFMT                  NO, O.K.
         CLI   ITYPE,RS                RS INSTRUCTION
         JE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG = 0
         JZ    CONST                   YES, NOT INSTR
         J     PFMFMT                  NO, GOOD INSTR
IVES1    TM    IEDT,S1                 1ST OPND MUST HAVE BASE
         JZ    PFMFMT                  NO, CONTINUE
         TM    2(R7),X'F0'             1ST OPND HAS BASE
         JZ    CONST                   NO, NOT INSTR
PFMFMT   DS    0H
*                                      OP-CODE
*  HANDLE SPECIAL CASE                                            @07A
*                                                                 @07A
         CLI   0(R7),X'4B'                                        @07A
         JE    CHECKDOT                YES, IS IT STRING ?        @07A
         CLI   0(R7),X'F0'                                        @07A
         JE    CHECKDOT                YES, IS IT STRING ?        @07A
         CLI   0(R7),C'S'                                         @07A
         JE    CHECKDOT                YES, IS IT STRING ?        @07A
         J     ICKSEC                                             @07A
CHECKDOT TM    CODPROG,X'80'           CODE IN PROGRESS           @07A
         JO    ICKSEC                                             @07A
         TRT   0(4,R7),CHARTRAN                                   @07A
         JZ    CONST                   BRANCH IF IT IS STRING     @07A
ICKSEC   DS    0H                                                 @07A
         SR    R1,R1                   CLEAR WORK
         IC    R1,INSTYP               GET INSTRUCTION TYPE
         CHI   R1,X'9C'                                           @15C
         JH    INSTOUT                                            @07A
         SR    R11,R11                 CLEAR WORK REG
         L     R9,OPND9           GET FORMAT ROUTINE RETURN ADDR
         LARL  R15,OPNDCTL             GET THE ADDRESS OF         @05A
         AR    R15,R1                    APPROPRIATE FORMATTING   @05A
         BR    R15                         ROUTINE                @05A
*        B     *+4(R1)          TO APPROPRIATE FORMATTING ROUTIN  @05D
OPNDCTL  J     INSTOUT                 TYPE=0, RR
         J     RXOPND                  TYPE=4, RX
         J     SOPND                   TYPE=8, S                  @02A
         J     SIOPND                  TYPE=C, SI
         J     RSOPND                  TYPE=10, RS
         J     SS1OPND                 TYPE=14, SS1
         J     SS2OPND                 TYPE=18, 2-LENGTH SS
         J     SOPND                   TYPE=1C, 2-BYTE OP-CODES
         J     RXOPND                  TYPE=20, CONDITIONAL BRANCH
         J     SVCOPND                 TYPE=24, SVC
         J     INSTOUT                 TYPE=28, RRE0            @01A
         J     INSTOUT                 TYPE=2C, RRE1            @09C
         J     INSTOUT                 TYPE=30, RRE2            @09C
         J     SS2OPND                 TYPE=34, SSE             @09C
         J     INSTOUT                 TYPE=38, SS3             @04A
         J     RI1OPND                 TYPE=3C, RI1             @04A
         J     INSTOUT                 TYPE=40, RI2             @04A
         J     RIL1OPND                TYPE=44, RIL1            @05A
         J     INSTOUT                 TYPE=48, RIL2            @05A
         J     RI1OPND                 TYPE=4C, RSI             @05A
         J     RSEOPND                 TYPE=50, RSE             @05A
         J     RXYOPND                 TYPE=54, RXY             @10C
         J     RSOPND                  TYPE=58, RSY             @05A
         J     SS4OPND                 TYPE=5C, SS4             @05A
         J     RXOPND                  TYPE=60, RXE             @05A
         J     INSTOUT                 TYPE=64, E               @09C
         J     INSTOUT                 TYPE=68, SSF             @09A
         J     INSTOUT                 TYPE=6C, SIL             @09A
         J     SIYOPND                 TYPE=70, SIY             @11A
         J     INSTOUT                 TYPE=74, RRFA            @14A
         J     INSTOUT                 TYPE=78, RRFB            @14A
         J     INSTOUT                 TYPE=7C, RRFC            @14A
         J     INSTOUT                 TYPE=80, RRFD            @14A
         J     INSTOUT                 TYPE=84, RRFE            @14A
         J     INSTOUT                 TYPE=88, RSY2            @09A
         J     RI1OPND                 TYPE=8C, RIE             @11A
         J     INSTOUT                 TYPE=90, RSL 1           @11A
         J     INSTOUT                 TYPE=94, RSL 2           @11A
         J     INSTOUT                 TYPE=98, RSA             @11A
         J     INSTOUT                 TYPE=9C, SSE2            @11A
OPNDRTN  J     INSTOUT                 NORMAL OPERAND FORMAT RETURN
NOTINST  J     CONST                   ERROR INSTRUCTION, TREAT AS CONS
INSTOUT  AH    R7,ILENG                STEP TO NEXT TEXT BYTE
         ST    R7,TXTCURR              SAVE NEXT ADDR
         MVC   CCTYPE,ICCSET           SHOW COND CODE SET TYPE
         J     GETCURR
*
******************************************************************
*                                                                *
* GENERAL OP-CODE TESTS TO VERIFY THAT FLOATING-POINT OP-CODES   *
* ARE INDEED OP-CODES.                                           *
*                                                                *
******************************************************************
*
FPVERFY  EQU   *                       *** VALIDATE FLOATING POINT OP-C
         TM    1(R7),X'90'             R1 IS 0, 2, 4, OR 6
         JNZ   CONST                   NO, NOT INSTR
         CLI   0(R7),X'27'             MXDR OP-CODE
         JE    FPR1EXT                 YES
         CLI   0(R7),X'67'             MXD OP-CODE
         JNE   FPCKTYP                 NO
FPR1EXT  TM    1(R7),X'B0'             R1 IS 0 OR 4
         JNZ   CONST                   NO, NOT INSTR
FPCKTYP  CLI   ITYPE,RR                RR TYPE INSTRUCTION
         JNE   FPRXVER                 NO
         TM    1(R7),X'09'             R2 IS 0, 2, 4, 6
         JNZ   CONST                   NO, NOT INSTR
         CLI   0(R7),X'25'             LRDR OP CODE
         JE    FPR2EXT                 YES
         CLI   0(R7),X'37'             SXR OP-CODE
         JE    FPR2EXT                 YES
         CLI   0(R7),X'26'             MXR OP-CODE
         JE    FPR2EXT                 YES
         CLI   0(R7),X'36'             AXR OP-CODE
         JNE   PFMFMT                  NO, GOOD INSTR
FPR2EXT  TM    1(R7),X'0B'             R2 IS 0 OR 4
         JZ    PFMFMT                  YES, GOOD INSTR
         J     CONST                   NO, NOT INSTR
FPRXVER  CLI   PRIVASM,1               PRIVILEGED INSTRUCTIONS O.K.
         JE    FPALIGN                 YES
         TM    2(R7),X'F0'             ANT BASE REG
         JNZ   FPALIGN                 YES
         TM    1(R7),X'0F'             ANY INDEX REG
         JZ    CONST                   NO, NOT INSTR
FPALIGN  TM    2(R7),X'F0'             ANY BASE REG
         JNZ   PFMFMT                  YES, ACCEPT INSTR
         TM    1(R7),X'0F'             ANY INDEX REG
         JNZ   PFMFMT                  YES, ACCEPT INSTR
         TM    3(R7),X'03'             DISPL DIV BY 4
         JNZ   CONST                   NO, NOT INSTR
         TM    ICLASS,FLSHT            SHORT PRECISION
         JO    PFMFMT                  YES, ACCEPT INSTRUCTION
         TM    3(R7),X'07'             DISPL DIV BY 8
         JZ    PFMFMT                  YES, ACCEPT INSTR
         J     CONST                   NO, NOT INSTR
*
******************************************************************
*                                                                *
* PROCESS TEXT BYTES DETERMINED TO BE CONSTANT DATA.             *
*                                                                *
******************************************************************
*
CONST    DS    0H                      *** PROCESS CONSTANTS ***
         MVI   WORKREC,C' '            CLEAR WORK RECORD AREA
         MVC   WORKREC+1(L'WORKREC-1),WORKREC
CCNEW    MVI   CONPROG,1               SHOW CONSTANT IN PROGRESS
         MVC   CONOFST,TXTOFST         SET OFFSET TO 1ST BYTE
         MVC   CONLEN,XZROS            CLEAR LENGTH
         CLC   TXTOFSET,LBLADR         LABEL AT THIS OFFSET
         JE    CLBLD                   YES
TRTYPE   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE
         JNZ   CCSHX                   IT'S HEX
         MVI   CONTYPE,C'C'            IT'S CHAR, SO INDICATE
         J     CUPDCON                 GO COMPLETE
CCSHX    MVI   CONTYPE,C'X'            IT'S HEX, SO INDICATE
         J     CUPDCON                 GO COMPLETE
CLBLD    CLI   LBLTYP,C'L'             IS IT A LABEL ONLY
         JNE   CDATACON                NO
         AHI   R6,LABELL               TO NEXT LABEL ENTRY        @10C
         CLC   TXTOFSET,LBLADR         THIS LABEL AT SAME ADDR
         JNE   TRTYPE                  NO
         CLI   LBLTYP,C'L'             THIS ANOTHER LABEL ONLY
         JNE   CDATACON                NO
         AHI   R6,LABELL               TO NEXT LABEL ENTRY        @10C
         J     CCNEW                   GO TO NEXT LABEL
*DATACON MVC   CONTYPE,LBLTYP    ??    TYPE TO CONSTANT AREA
CDATACON DS    0H                      TYPE TO CONSTANT AREA       @08A
         SR    R1,R1                   CLEAR WORK
         IC    R1,LBLLEN               PICK UP CONSTANT LENGTH
         STH   R1,CONLEN               SAVE CONSTANT LENGTH
         SR    R11,R11                 CLEAR WORK REG
         IC    R11,LBLLEN              PICK UP LENGTH
         AR    R7,R11                  STEP PAST TEXT
         ST    R7,TXTCURR              UPDATE TEXT ADDRESS
         JAS   R9,FORCONST             FORCE CONSTANT OUT
         AHI   R6,LABELL               STEP TO NEXT LABEL ENTRY    @10C
         J     GETCURR                 CONTINUE TEXT PROCESS
CUPDCON  LH    R11,CONLEN              GET CURRENT LENGTH
         AHI   R11,1                   ADD 1
         STH   R11,CONLEN              UPDATE LENGTH
         CLI   CONTYPE,C'C'            CHARACTER CONSTANT
         JE    CCK8                    YES
         TM    CONOFST+3,1             OFFSET IS ODD
         JO    CCFIN1                  YES
         TM    CONOFST+3,2             HALFWORD OFFSET
         JZ    CCFWD                   NO
         CLI   CONLEN+1,1              HALFWORD, IS LENGTH = 1
         JE    CCXIT1                  YES
         J     CCFIN1                  NO
CCFWD    CLI   CONLEN+1,4              NO, IS HEX CONST 4 BYTES
         JL    CCXIT1                  NOT YET
CCFIN1   JAS   R9,FORCONST             MAX LENG, FORCE IT OUT
         J     CCXIT1                  FINISH
CCK8     CLI   CONLEN+1,18             CHAR CONSTANT 18 BYTES     @06C
         JNL   CCFIN1                  YES
CCXIT1   AHI   R7,1                    STEP OVER 1 BYTE IN TEXT
         ST    R7,TXTCURR              UPDATE TEXT ADDR
         J     GETCURR                 CONTINUE TEXT PROCESSING
         DROP  R6
*
*
*
******************************************************************
*                                                                *
* CLEAR OUT AREAS SET UP FOR CONSTANT DATA.                      *
*                                                                *
******************************************************************
*
FORCONST EQU   *                   *** FORCE OUT CONSTANT IN PROGRESS
         MVI   CONPROG,0               RESET CONSTANT IN PROGRESS
         MVI   CONTYPE,0               RESET TYPE
         XC    CONLEN,CONLEN           CLEAR LENGTH
         MVC   CONOFST,XZROS           CLEAR OFFSET TO CONSTANT
         BR    R9                      EXIT
*
******************************************************************
*                                                                *
* PROCESS RX-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *
*                                                                *
******************************************************************
RXOPND   DS    0H                      *** RX FORMAT INSTRUCTIONS ***
         CLI   0(R7),X'07'             CONDBR REGISTER INSTR ??   @06A
         JE    INSTOUT                 YES                        @06A
         ICM   R11,3,TEXT+2            GET BDDD
         LHI   R10,4                   SET LENGTH = 4
         TM    INLNG,E4                FULLWORD OPERAND
         JO    RXBDDD                  YES
         LHI   R10,2                   SET LENGTH = 2
         TM    INLNG,E2                HALFWORD OPERAND
         JO    RXBDDD                  YES
         LHI   R10,1                   SET LENGTH = 1
         TM    INLNG,E8                DOUBLEWORD OPERAND
         JZ    RXBDDD                  NO
         LHI   R10,8                   YES, SET LENGTH = 8
RXBDDD   J     BDLADR                  CHECK LABEL
******************************************************************
* PROCESS RI-FORMAT INSTRUCTIONS. THE OPERAND IS RESOLVED BY     *
* ADR = CURRENT ADR + 2*OFFSET                                   *
* R11 = R11 + OFFSET + OFFSET                                    *
******************************************************************
RI1OPND  DS    0H                *** RI FORMAT INSTRUCTIONS ***
         LR    R11,R7                  LOAD CURRENT OFFSET      @04A
         S     R11,TXTSTRT             MINUS PROGRAM START      @04A
         AH    R11,2(R7)            R11 = RELATIVE BR ADDRESS   @04A
         AH    R11,2(R7)            R11 = CURRENT + 2*OFFSET    @04A
         C     R11,CSTLENG             IGNORE IF IT IS BEYOND   @04A
         JH    CONST                   THE PROGRAM BOUNDARY     @04A
         CHI   R11,0                   IGNORE IF IT IS BEYOND   @04A
         JL    CONST                   THE PROGRAM BOUNDARY     @04A
         J     BDLADDR                 ADD A NEW LABEL          @04A
******************************************************************
*                                                                *
* PROCESS RIL-FORMAT INSTRUCTIONS. THE OPERAND IS RESOLVED BY    *
* ADR = CURRENT ADR + 2*OFFSET                                   *
*                                                                *
******************************************************************
RIL1OPND DS    0H                     *** RIL FORMAT INSTRUCTIONS ***
         LR    R11,R7                  GET CURRENT OFFSET     @04A
         S     R11,TXTSTRT             MINUS PROGRAM START    @04A
         A     R11,2(R7)                                      @04A
         A     R11,2(R7)                                      @04A
         C     R11,CSTLENG             IGNORE IF IT IS BEYOND @04A
         JH    CONST                   THE PROGRAM BOUNDARY   @04A
         C     R11,XZROS               IGNORE IF IT IS BEYOND @04A
         JL    CONST                   THE PROGRAM BOUNDARY   @04A
         J     BDLADDR                 CHECK LABEL            @04A
******************************************************************
*                                                                *
* PROCESS S-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS   *
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *
*                                                                *
******************************************************************
*
SOPND    DS    0H                      *** S FORMAT INSTRUCTIONS ***
         CLI   1(R7),0                 BYTE 2 OF INSTR IS ZERO
         JE    SCK2                    YES
         CLI   0(R7),X'80'             NO, IS IT SSM D
         JE    NOTINST                 YES, NOT INSTR
         CLI   0(R7),X'82'             NO, IS IT LPSW
         JE    NOTINST                 YES, NOT INSTR
         CLI   0(R7),X'93'             NO, IS IT TS
         JE    NOTINST                 YES, NOT INSTR
SCK2     CLI   0(R7),X'A7'             OP-CODE IS A7             @04A
         JE    SSTRT                     BRANCH IF YES           @04A
         CLI   0(R7),X'C5'             OP-CODE IS C5             @04A
         JE    SSTRT                     BRANCH IF YES           @04A
         CLI   0(R7),X'C0'             OP-CODE IS C0             @04A
         JE    SSTRT                     BRANCH IF YES           @04A
         CLI   0(R7),X'B2'             OP-CODE IS B2             @02A
         JNE   SSTRT                     BRANCH IF NO            @02A
         CLC   2(2,R7),XZROS           3RD AND 4TH BYTES ZERO
         JE    SSTRT                   YES
         CLI   1(R7),X'0B'             IPK INSTRUCTION
         JE    NOTINST                 YES, NOT INSTR
         CLI   1(R7),X'0D'             PTLB INSTR
         JE    NOTINST                 YES, NOT INSTR
SSTRT    SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD
         LHI   R10,4                   SET LENGTH = 4
         TM    INLNG,E4                FULLWORD OPERAND
         JO    SBDDD                   YES
         LHI   R10,2                   SET LENGTH = 2
         TM    INLNG,E2                HALFWORD OPERAND
         JO    SBDDD                   YES
         LHI   R10,1                   SET LENGTH = 1
         TM    INLNG,E8                DOUBLEWORD OPERAND
         JZ    SBDDD                   NO
         LHI   R10,8                   YES, SET LENGTH = 8
SBDDD    J     BDLADR                  CHECK FOR LABEL
*
*
*
******************************************************************
*                                                                *
* PROCESS SI-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *
*                                                                *
******************************************************************
*
SIOPND   DS    0H                      *** BUILD SI OPERAND LABEL ***
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         SR    R10,R10                 LENGTH=DON'T CARE
         J     BDLADR                  CHECK FOR LABEL
******************************************************************
*                                                                *
* PROCESS SI-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *
*                                                                *
******************************************************************
*
SIYOPND  DS    0H                      *** BUILD SIY OPERAND LABEL
         CLI   TEXT+4,X'00'
         JNE   INSTOUT
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         SR    R10,R10                 LENGTH=DON'T CARE
         J     BDLADR                  CHECK FOR LABEL
******************************************************************
*                                                                *
* PROCESS RXY-FORMAT OPERAND                                     *
*                                                                *
******************************************************************
RXYOPND  DS    0H                      *** RXY INSTRUCTIONS  ***
         CLI   4(R7),X'00'                                         @11A
         JE    RSOPND                  BRANCH IF HI DISP IS ZERO   @11A
         SR    R11,R11
         ICM   R11,3,2(R7)             LOAD BDDD INTO R11
         LR    R2,R11                  COPY BDDD TO R2
         SRL   R2,12                   RIGHT JUSTIFY BASE REG
         MHI   R2,USINGL               TIMES ENTRY LENGTH
         LA    R2,BASESR(R2)           @ BASE REG TABLE ENTRY
         USING USINGD,R2
         CLI   USTYPE,C'P'             IS IT A PROGRAM BASE
         JNE   BDLXIT                  NO
         SLL   R11,20                  ISOLATE THE
         SRL   R11,20                  DDD IN R11
         SR    R1,R1                   CLEAR WORK
         ICM   R1,7,USVALU             GET BASE REG VALUE
         AR    R11,R1         R11 = DISPLACEMENT (R11) + BASE (R1)
         SR    R0,R0                   CLEAR R1 FOR IC INSTRUCTION @11A
         IC    R0,4(R7)                LOAD DISPLACEMENT HIGH      @11A
         SLL   R0,12                                               @11A
         AR    R11,R0                  R11 = DISP LOW + DISP HIGH  @11A
         J     BDRXY                                               @11A
*
******************************************************************
*                                                                *
* PROCESS RS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *
*                                                                *
******************************************************************
*
RSEOPND  EQU   *                       *** RSE FORMAT INSTR        ***
RSOPND   DS    0H                      *** RS FORMAT INSTRUCTIONS  ***
         CLI   ITYPE,L4                TWO-BYTE OP-CODE L4         @04A
         JE    RSCMA1                  BRANCH IF YES               @04A
         CLI   0(R7),X'88'             IS IT SHIFT INSTR
         JL    RSCMA1                  NO
         CLI   0(R7),X'8F'             IS IT SHIFT INSTR
         JH    RSCMA1                  NO
         TM    1(R7),X'0F'             SHIFT, IS R3 POS = 0
         BZR   R9                      YES, GOOD SHIFT
         J     NOTINST                 NO, NOT INSTR
RSCMA1   SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         LHI   R10,4                   SET LENGTH = 4
         TM    INLNG,E4                FULLWORD OPERAND
         JO    RSBDDD                  YES
         LHI   R10,2                   SET LENGTH = 2
         TM    INLNG,E2                HALFWORD OPERAND
         JO    RSBDDD                  YES
         LHI   R10,1                   SET LENGTH = 1
         TM    INLNG,E8                DOUBLEWORD OPERAND
         JZ    RSBDDD                  NO
         LHI   R10,8                   YES, SET LENGTH = 8
RSBDDD   J     BDLADR                  CHECK FOR LABEL
*
*
*
******************************************************************
*                                                                *
* PROCESS SS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESSES*
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION. THE     *
* SINGLE-LENGTH SS FORMAT INSTRUCTIONS ARE HANDLED HERE.         *
*                                                                *
******************************************************************
*
SS1OPND  DS    0H                      *** SS1 FORMAT INSTRUCTIONS ***
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET LENGTH CODE
         AHI   R10,1                   COMPUTE ACTUAL LENGTH
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         LARL  R1,SS1RTN               GET RTEURN ADDR            @06A
         MVC   SAVOP9,OPND9            SAVE NORMAL RETURN ADDR
         ST    R1,OPND9                CHANGE RETURN ADDR TO SS1RTN
         J     BDLADR                  CHECK LABEL
SS1RTN   DS    0H
         MVC   OPND9,SAVOP9            RESTORE NORMAL RETURN ADDR
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET SECOND BDDD ADDRESS
         SR    R10,R10                 CLEAR LENGTH REG
         IC    R10,TEXT+1              GET INSTR LENGTH
         AHI   R10,1                   COMPUTE ACTUAL LENGTH
         J     BDLADR                  CHECK FOR LABEL
*
*
*
******************************************************************
*                                                                *
* PROCESS SS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESSES*
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION. THE     *
* DOUBLE-LENGTH SS FORMAT INSTRUCTIONS ARE HANDLED HERE.         *
*                                                                *
******************************************************************
*
SS2OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - 2 L
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET L1L2
         SRL   R10,4                   SHIFT OUT L2
         AHI   R10,1                   COMPUTE ACTUAL LENGTH
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         LARL  R1,SS2RTN               GET RTEURN ADDR            @06A
         MVC   SAVOP9,OPND9            SAVE NORMAL RETURN ADDR
         ST    R1,OPND9                CHANGE RETURN ADDRESS
         J     BDLADR                  CHECK LABEL
SS2RTN   MVC   OPND9,SAVOP9            RESTORE NORMAL RETURN ADDR
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET 2ND BDDD ADDR
         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP L2L1
         SRL   R10,4                   SHIFT OUT L1
         CLI   TEXT,X'F0'              SRP OP-CODE
         JNE   SS2BDDD                 NO
         IC    R10,TEXT+1              GET INSTR LENGTH
         SRL   R10,4                   SHIFT OUT I3
SS2BDDD  AHI   R10,1                   COMPUTE ACTUAL LENGTH
         J     BDLADR                  CHECK LABEL
******************************************************************
*                                                                *
* PROCESS SS4 INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESSES      *
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION. THE     *
* SINGLE-LENGTH SS FORMAT INSTRUCTIONS ARE HANDLED HERE.         *
*                                                                *
******************************************************************
SS4OPND  DS    0H
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET FIRST BDDD ADDRESS
         SR    R10,R10                 CLEAR LENGTH REG
         IC    R10,TEXT+1              GET LENGTH
         AHI   R10,1                   COMPUTE ACTUAL LENGTH
         LARL  R1,SS4RTN               GET RTEURN ADDR            @06A
         MVC   SAVOP9,OPND9            SAVE NORMAL RETURN ADDR
         ST    R1,OPND9                CHANGE RETURN ADDR TO SS1RTN
         J     BDLADR                  CHECK FOR LABEL
SS4RTN   DS    0H                      *** SS1 FORMAT INSTRUCTIONS ***
         MVC   OPND9,SAVOP9            RESTORE NORMAL RETURN ADDR
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET LENGTH CODE
         AHI   R10,1                   COMPUTE ACTUAL LENGTH
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET SECOND BDDD ADDRESS
         J     BDLADR                  CHECK LABEL
*
*
*
******************************************************************
*                                                                *
* PROCESS SVC INSTRUCTIONS. THE SOLE PROCESSING IS TO VERIFY THAT*
* THIS IS A VALID SVC.                                           *
*                                                                *
******************************************************************
*
SVCOPND  EQU   *                       *** SVC INSTRUCTIONS ***
         CLI   TEXT+1,139              SVC NO > 139
         JH    NOTSVC                  YES, NOT SVC
*        LRL   R1,SVCTBLAD             GET SVC TABLE ADDRESS
         L     R1,SVCTBLAD             GET SVC TABLE ADDRESS
SVCKND   CLI   0(R1),X'FF'             END OF SVC TABLE
         JE    NOTSVC                  YES, MUST NOT BE SVC
         CLC   0(1,R1),TEXT+1          THIS THE ENTRY
         JE    GOTSVC                  YES
         AHI   R1,SVCOPLEN             STEP TO NEXT ENTRY
         J     SVCKND                  LOOP THRU TABLE
NOTSVC   B     4(R9)                   ERROR RETURN
GOTSVC   BR    R9                      EXIT, NO STORAGE OPND
*
*
*
******************************************************************
*                                                                *
* SET UP CURRENT BASE REGISTERS IN THE BASE TABLE. THE USING     *
* TABLE IS SCANNED FOR ENTRIES VALID AT THE CURRENT TEXT OFFSET. *
* WHEN A BASE REGISTER ENTRY IS FOUND TO BE VALID AT THE CURRENT *
* TEXT OFFSET, THE USING ENTRY IS MOVED TO THE APPROPRIATE LOC-  *
* ATION IN THE BASE TABLE FOR USE BY THE BDLADR ROUTINE. THE TEXT*
* OFFSET TO THE NEXT BASE REGISTER CHANGE IS SET SO THAT THIS    *
* ROUTINE WILL AGAIN BE ENTERED WHEN THE CURRENT BASE REGISTERS  *
* ARE EXHAUSTED.                                                 *
*                                                                *
******************************************************************
*
NEXUSG   EQU   *                       *** GET NEXT BASE REGS ***
         MVI   MORUSG,0                RESET INDICATOR
         XC    BASESR,BASESR           CLEAR OLD BASE REG VALUES
         MVC   NEXCHG,HIVAL            SET NEXT CHANGE LOC HIGH
         L     R2,USGSTRT              GET USING TBL START
         USING USINGD,R2
ENDUS    CLI   0(R2),X'FF'             END OF TABLE
         BER   R9                      YES, EXIT
         CLC   TXTOFSET,USEND          PAST THIS ONE
         JNL   ECSTEP                  YES
         OI    MORUSG,1                SHOW MORE BASES AVAILABLE
USBGCK   CLC   TXTOFSET,USBGN          THIS STARTS LATER
         JNL   CKNEWLO                 NO
         CLC   USBGN,NEXCHG            BEGINS BEFORE NEXT CHG
         DS    0H
         JNL   ECSTEP                  NO
         MVC   NEXCHG,USBGN            YES, SET NEW CHANGE OFFSET
         J     ECSTEP                  CONTINUE
CKNEWLO  CLC   USEND,NEXCHG            NEW LOW CHANGE ADDR
         JNL   ECMVC                   NO
         MVC   NEXCHG,USEND            YES, SET LOWER OFFSET
ECMVC    SR    R1,R1                   CLEAR WORK
         IC    R1,USREG                PICK UP REGISTER
         MHI   R1,USINGL               TIMES ENTRY LENGTH          @10C
         LA    R1,BASESR(R1)           @ TABLE ENTRY
         MVC   0(USINGL,R1),USBGN      ENTRY TO TABLE              @10C
         OI    MORUSG,X'80'            SHOW BASE REG CURRENT
ECSTEP   AHI   R2,USINGL               TO NEXT USING TBL ENTRY     @10C
         J     ENDUS                   LOOP THRU USING TBL
         DROP  R2
*
******************************************************************
*                                                                *
* A BASE-DISPLACEMENT IS PROVIDED IN REG 11 ON ENTRY. IF ANY     *
* BASE REGISTERS ARE CURRENT, AND THE BASE REGISTER FOR THE GIVEN*
* ADDRESS IS A CURRENT PROGRAM BASE REGISTER, A LABEL ENTRY IS   *
* BUILT. OFFSET TO THE LABEL WILL BE FOUND BY ADDING THE ASSUMED *
* BASE REGISTER VALUE TO THE GIVEN DISPLACEMENT. THE LABEL NAME  *
* WILL BE THE LETTER 'A' FOLLOWED BY THE OFFSET.                 *
* INPUT  : R11 CONTAINS BDDD                                     *
*                                                                *
*                                                                *
******************************************************************
*
BDLADR   EQU   *                       *** BUILD LABEL ENTRIES ***
         TM    MORUSG,1                ANY BASES CURRENT
         JZ    BDLXIT                  NO
         LR    R2,R11                  COPY BDDD ADDRESS
         SRL   R2,12                   RIGHT JUSTIFY BASE REG
         MHI   R2,USINGL               TIMES ENTRY LENGTH
         LA    R2,BASESR(R2)           @ BASE REG TABLE ENTRY
         USING USINGD,R2
         CLI   USTYPE,C'P'             IS IT A PROGRAM BASE
         JNE   BDLXIT                  NO
         SLL   R11,20                  ISOLATE THE
         SRL   R11,20                  DDD IN R11
         SR    R1,R1                   CLEAR WORK
         ICM   R1,7,USVALU             GET BASE REG VALUE
         AR    R11,R1            R11 = DISPLACEMENT (R11) + BASE (R1)
         DROP  R2
BDRXY    L     R1,CURRLBL              GET LBL TBL ADDR
         C     R1,ENDLBL               END OF TABLE
         JL    GOTHOLE                 NO
         JAS   R9,COMPLBL              YES, COMPRESS DUPLICATES
BDLADDR  DS    0H                      *** BUILD LABEL ENTRIES ***
         L     R1,CURRLBL              GET NEW CURRENT LBL ADDR
         C     R1,ENDLBL               STILL AT END
         JNL   CRASH        ** S0C1 ** YES, TERMINATE THIS STAGE
         USING LABELD,R1
GOTHOLE  STCM  R11,7,LBLADR            SET LABEL ENTRY OFFSET
         MVI   LBLNAME,C'A'            BEGIN LABEL NAME
         CLI   TEXT,X'44'              EXECUTE OP CODE ??         @07A
         JNE   NOTEXEC                 BRANCH IF NO               @07A
         MVI   LBLNAME,C'X'            BEGIN LABEL NAME X         @07A
NOTEXEC  LA    R12,LBLADR              @ OFFSET
         JAS   R9,HEXPRT3              GO CONVERT
         MVC   LBLNAME+1(L'LBLNAME-1),BLANX  INITIALISE TO BLANKS
         MVC   LBLNAME+1(6),PRTABL     REST OF NAME
         MVI   LBLTYP,C'L'             SET LABEL TYPE
         LR    R0,R7                   CALCULATE THE              @06A
         S     R0,TXTSTRT                   REFERENCE ADDRESS     @06A
         STCM  R0,7,LBLREF             SAVE REFERENCE ADDRESS     @06A
         CLI   IOLNG,X'00'             OPERAND LENGTH = 0 ?       @11A
         JNE   BDLLEN                  BRANCH IF NOT ZERO         @11A
         CLI   ITYPE,RB                BRANCH INSTRUCTION ??      @04A
         JNE   BDLSTP                  BRANCH IF NOT              @04A
INSTREF  SR    R12,R12                 CLEAR WORK REG
         A     R11,TXTSTRT             R11 = BASE + START
         LHI   R10,4                   ASSUME LENGTH IS 4
         TM    TEXT,X'C0'              OP CODE C0  ??             @04A
         JM    BDLSTP                  01 OR 10 IS 4-BYTE INSTR   @04A
         JO    BDLSIX                  YES, SIX-BYTE INSTR        @04A
         LHI   R10,2                   BOTH OFF, 2-BYTE INSTR     @04A
         J     BDLSTP                  CONTINUE                   @04A
BDLLEN   SR    R10,R10                 CLEAR FOR IC INSTR         @11A
         IC    R10,IOLNG               GET OPERAND LENGTH         @11A
         J     BDLSTP                  CONTINUE                   @11A
BDLSIX   LHI   R10,6                   SET LABEL LENGTH TO 6
BDLSTP   STC   R10,LBLLEN              LENGTH TO LABEL ENTRY
         CLI   ICLASS,X'00'                                       @06A
         JE    BDLNXT                                             @06A
         CLI   ICLASS,8                                           @06A
         JH    BDLNXT                                             @06A
         MVC   LBLLEN,ICLASS                                      @07A
BDLNXT   DS    0H                                                 @07A
         AHI   R1,LABELL               TO NEXT LABEL ENTRY        @10C
         ST    R1,CURRLBL              SAVE UPDATED TBL ADDR
BDLXIT   L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
         DROP  R1
*        CLC   XOFST,TXTOFSET   *** DEBUG
*        JNE   QQQQ2            *** DEBUG
*        DC    X'0000'          *** DEBUG
*QQQ2    DS    0H               *** DEBUG
******************************************************************
*                                                                *
* SORT THE LABEL TABLE AND ELIMINATE ANY DUPLICATE ENTRIES.      *
*                                                                *
* R7 = @ OF LBLTBL                                               *
*                                                                *
******************************************************************
*
COMPLBL  DS    0H                 *** COMPRESS AND SORT LABEL TABLE
         USING LABELD,R6
         L     R6,LBLTBL               GET LABEL TABLE ADDR D
LBSTPASS LA    R7,LABELL(R6)           @ NEXT LABEL TABLE ENTRY    @10C
LBLND    C     R7,CURRLBL              AT TABLE END
         JL    LBSAMPS                 NO
NEXPAS0  AHI   R6,LABELL               TO TEXT LABEL ENTRY         @10C
         C     R6,CURRLBL              END OF TABLE
         JL    LBSTPASS                NO
         J     LBFEND                  YES, FIND END
LBSAMPS  CLC   LBLADR,LBLADR-LABELD(R7) IDENTICAL OFFSETS
         JH    LBSWCH                  NO, FIRST HIGH, SWITCH
         JL    LBSTP                   NO, LOW, CONTINUE SCAN
         CLC   0(LABELL-3,R6),R7       ENTRIES ARE IDENTICAL       @07C
         JNE   LBCKLBL                 NO
LBNULL2  MVC   LBLADR-LABELD(L'LBLADR,R7),HIVAL    YES, NULL 2ND
         J     LBSTP                   AND CONTINUE SCAN
LBCKLBL  CLC   LBLNAME,LBLNAME-LABELD(R7) IDENTICAL LABELS
         JNE   LBCKTYP                 NO, CHECK TYPES
         CLC   LBLLEN,LBLLEN-LABELD(R7)                            @07C
         JH    LBNULL2
         MVC   LBLLEN,LBLLEN-LABELD(R7)                            @07C
*        DC    X'0000'
LBCKLN   CLI   LBLLEN,0                THIS ENTRY LENGTH = 0
         JNE   LBCKLN2                 NO
LBCKLN2  CLC   LBLLEN,LBLLEN-LABELD(R7) COMPARE LENGTHS
         JH    LBSWCH                  1ST LENGTH HIGH, SWITCH ENTRIES
         J     LBNULL2                 1ST LOW/=, NULL 2ND
LBCKTYP  CLC   LBLTYP,LBLTYP-LABELD(R7) SAME ENTRY TYPE
         JNE   LBCK1L                  NO, CHK TYPE ORDER
         CLI   LBLTYP,C'L'             TYPE LABLE ??
         JE    LBSTP                   YES, CONTINUE SCAN
         CLI   LBLTYP,C'U'             USER LABEL ??
         JNE   LBNULL2                 NO
         J     LBSTP                   YES
LBCK1L   CLI   LBLTYP,C'U'             1ST IS USER LABEL
         JNE   LBCK2L                  NO
         CLI   LBLTYP-LABELD(R7),C'L'   2ND IS TYPE L
         JE    LBNULL2                 YES, NULL THE 2ND
         J     LBSTP                   CONTINUE SCAN
LBCK2L   CLI   LBLTYP-LABELD(R7),C'U'   2ND IS USER LABEL
         JE    LBSWCH                  YES
         CLI   LBLTYP,C'L'             1ST IS LABEL TYPE
         JE    LBSTP                   YES, CONTINUE SCAN
LBSWCH   MVC   WORKREC(LABELL),0(R6)   HOLD 1ST ENTRY              @10C
         MVC   0(LABELL,R6),0(R7)      MOVE 2ND ENTRY TO 1ST       @10C
         MVC   0(LABELL,R7),WORKREC    1ST ENTRY TO 2ND LOCATION   @10C
         J     LBSAMPS                 GO RECHECK
LBSTP    AHI   R7,LABELL               TO NEXT LABEL ENTRY         @10C
         J     LBLND                   CONTINUE SCAN
LBFEND   L     R6,LBLTBL               @ LABEL TABLE
LBFCKFF  CLI   LBLADR,X'FF'            NULL ENTRY
         JE    LBSTCURR                YES
         C     R6,CURRLBL              AT FORMER END
         JE    LBSTCURR                YES
         AHI   R6,LABELL               TO NEXT ENTRY               @10C
         J     LBFCKFF                 LOOP TO FIND END
LBSTCURR ST    R6,CURRLBL              SAVE NEW TBL END ADDR
         L     R0,LBLTBL               GET LABEL TABLE ADDR D
         BR    R9                      EXIT
         DROP  R6
******************************************************************
*                                                                *
* END OF PHASE 1. SORT/COMPRESS THE LABEL TABLE AND RETURN.      *
*                                                                *
******************************************************************
EOJ      EQU   *                       END OF INPUT
         JAS   R9,COMPLBL              SORT/COMPRESS LABEL TBL
         L     R6,LBLTBL               GET LABEL TABLE ADDR
         USING LABELD,R6
EOJCKND  C     R6,CURRLBL              END OF TABLE ??
         JNL   EOJ2                    IF YES TERMINATE PROCESSING
         CLI   LBLTYP,C'U'             USER LABEL
         JNE   EOJSTEP                 NO
         MVI   LBLTYP,C'L'             YES, CHANGE TO TYPE L
EOJSTEP  AHI   R6,LABELL               TO NEXT ENTRY               @10C
         J     EOJCKND                 CONTINUE LOOP
         DROP  R6
EOJ2     DS    0H                      CLEAR PRINT
         MVI   PRT,C' '                CLEAR PRINT
         MVC   PRT+1(L'PRT-1),PRT
         MVC   0(3,R6),HIVAL    **DEBUG SET END INDIC             @05A
         MVC   CTLOCUR,CTLSTRT         SET CTLOCUR = CTLSTRT      @08A
         PR                            RETURN TO HDISASM          @05A
*
*
*
******************************************************************
*                                                                *
* CONVERT HEX BYTES TO THEIR PRINTABLE EQUIVALENTS. ON ENTRY, REG*
* 12 CONTAINS THE ADDRESS OF THE FIRST BYTE TO BE CONVERTED. THE *
* NUMBER OF BYTES IS DETERMINED BY THE ENTRY SELECTED. PRINTABLE *
* HEX IS PLACED IN THE FIELD PRTABL, TWO CHARACTERS PER BYTE.    *
*                                                                *
******************************************************************
*
HEXPRT   EQU   *                       HEX TO PRINTABLE ROUTINE
HEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX
         J     HEXCLTR                 CONTINUE
HEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX
         J     HEXCLTR                 CONTINUE
HEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX
         J     HEXCLTR                 CONTINUE
HEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX
HEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE
         TR    PRTABL(8),TRTBL         MAKE PRINTABLE
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* PRINT A LINE USING THE SYSPRINT DCB DEFINED IN DISASM PHASE 0. *
*                                                                *
******************************************************************
*
PRINT    EQU   *                       PRINT ROUTINE
         L     R1,PRINTDCB             @ SYSPRINT DCB
         TM    48(R1),X'10'            IS SYSPRINT OPEN
         JNO   CLRPRT                  NO
         PUT   (1),PRTLINE             WRITE PRINT LINE
CLRPRT   DS    0H
         MVI   PRT,C' '
         MVC   PRT+1(L'PRT-1),PRT
         AP    LINECT,P01              INCR LINE COUNTER
         CLI   PCC,C' '                SINGLE SPACED
         JE    SETSGL                  YES
         AP    LINECT,P01              INCR LINE COUNTER
         CLI   PCC,C'0'                DOUBLE SPACED
         JE    SETSGL                  YES
         AP    LINECT,P01              INCR LINE COUNTER
         CLI   PCC,C'-'                TRIPLE SPACED
         JE    SETSGL                  YES
         ZAP   LINECT,P00              NO, MUST BE NEW PAGE
SETSGL   MVI   PCC,C' '                SET SINGLE SPACING
         CP    LINECT,P58              PAST END OF PAGE
         JH    NEWPAGE                 YES
         BR    R9                      EXIT
NEWPAGE  MVI   PCC,C'1'                SET SKIP TO HOF
         ZAP   LINECT,P00              RESET LINE COUNTER
         BR    R9                      EXIT
         DC    CL22'HDISASM1 VARIABLES ==>'
DATAASM1 DS    0F                                                 @13A
SVCTBLAD DC    V(SVCOPV)               @ SVC TABLE                @05A
SGLOPAD  DC    V(SGLOPV)               @ ONE-BYTE OP-CODE TBL     @05A
DBLOPAD  DC    V(DBLOPV)               @ TWO-BYTE OP-CODE TBL     @05A
L3LOPAD  DC    V(L3LOPV)               @ RX AND RL OP-CODE TBL    @05A
L4LOPAD  DC    V(L4LOPV)               @ RXY OP-CODE TBL          @05A
CRASH    DC    X'0000'
OPND9    DC    A(OPNDRTN)              RETURN ADDR FOR OPERAND RTN
U01      DC    C'INVALID NAME COL 7-14'
U02      DC    C'INVALID HEX OFFSET COL 14-19'
U03      DC    C'INVALID REGISTER COL 21'                         @10C
*04      DC    C'LABEL TABLE OVERFLOW'
U04      DC    C'INVALID HEX OFFSET COL 25-29'
U05      DC    C'UNDEFINED DSECT COL 25-32'
U06      DC    C'OVER 256 USING CARDS'
U07      DC    C'END BEFORE BEGIN'
U08      DC    C'INVALID TYPE COL 23. MUST BE D OR P'             @10C
U09      DC    C'INVALID NAME COL 1-12'                           @10C
U10      DC    C'INVALID NBR FIELDS COL 16-19'
U11      DC    C'INVALID OFFSET COL 14-18'                        @12C
U12      DC    C'INVALID LENGTH COL 20-22'                        @12C
U13      DC    C'1ST OFFSET INVALID HEX'
U14      DC    C'2ND OFFSET INVALID HEX'
U15      DC    C'END OFFSET BEFORE BEGIN'
U16      DC    C'INVALID OFFSET COL 14-19 (CTLBK)'                @08A
U17      DC    C'INVALID DSECT REGISTER COL 21'                   @08A
U20      DC    C'*** USER ENTERED CARDS ***'
U21      DC    C'INVALID NAME COL 7-18'                           @10A
U22      DC    C'INVALID HEX OFFSET COL 20-25'                    @10A
U23      DC    C'INVALID DECIMAL LENGTH COL 27-29'                @10A
U24      DC    C'INITIAL VALUE > ENDING OFFET'                    @12A
U25      DC    C'REDEFINE OFFSET NOT FIND'                        @13A
U31      DC    C'UNIDENT OR OUT OF SEQ'                           @10C
*XOFST   DC    XL3'01BEB0'            ** DEBUG
S_EOD    DC    CL2'/*'                END OF DATA                 @06A
S_EOJ    DC    CL2'//'                END OF JOB                  @06A
*_USING  DC    CL5'USING'
S_DSECT  DC    CL5'DSECT'
S_DATA   DC    CL4'DATA'
S_DATX   DC    CL4'DATX'                                           @09A
S_HEX4   DC    CL4'HEX4'                                           @09A
S_HEX2   DC    CL4'HEX2'                                           @09A
S_CODE   DC    CL4'CODE'                                           @08A
S_ASCII  DC    CL5'ASCII'                                          @15A
S_CTLBK  DC    CL4'CTLBK'                                          @07A
S_ULABL  DC    CL5'ULABL'
TMPOFSET DC    XL3'00'                                             @13A
SDSECTL  DS    F                       LENGTH OF MAIN DSECT TBL    @13A
SDSECTA  DS    A                       ADDRESS OF MAIN DSECT TBL   @13A
DSCT9    DS    F                       RETURN FOR DSECTS
SAVOP9   DS    F                       SAVE AREA FOR OPND9
ULSAV    DS    7F                      SAVE AREA FOR CKADCON
NOINAD   DS    F                       DATA ONLY TABLE ADDRESS
NUMCK    DC    C'00000'                NUMERIC CHECK AREA          @12C
ZEROS    DC    C'00000'                CONSTANT ZEROS              @12C
ILENG    DC    H'0'                    INSTRUCTION LENGTH  FIX***
F1SW     DC    X'00'                   @ FIRST TIME SWITCH         @06A
REDEFSW  DC    X'00'                   REDEFINE SWITCH             @13A
CODPROG  DC    X'00'                   CODE     IN PROGRESS INDIC  @07A
CONPROG  DC    X'00'                   CONSTANT IN PROGRESS INDIC
BASESR   DC    XL256'0'                CURRENT BASE REGS
         DS    0H
NEXCHG   DC    XL3'00'                 NEXT BASE REG CHG OFFSET
MORUSG   DC    X'00'                   80=CURRENT BASE, 0=NO MORE BASES
CONTYPE  DS    CL1                     TYPE
CONLEN   DS    H                       CONSTANT LENGTH
CONOFST  DS    F                       RELATIVE OFFSET TO CONSTANT
CCTYPE   DC    X'00'                   CC SET TYPE OF INSTR SETTING
*XTOFST  DS    0F
*        DS    X
*XTOFSET DS    XL3                     OFFSET TO TEXT BYTE
OFFSET   DS    XL3                     OFFSET FROM PGM START
INSTYP   DS    CL1                     INSTRUCTION TYPE
TYPE     DS    XL1                     TYPE CODE
*                                       0=CSECT, 1==DCON, 2=CONST
*                                       E=USING, D=INSTRUCTION
*                                       C=COMMENT, 9=ENTRY
*                                       A=EQU
LEN      DS    XL1                     TEXT LENGTH
P00      DC    P'0'                    CONSTANT 0
P01      DC    P'1'                    CONSTANT 1
P58      DC    P'58'                   PACK CONSTANT 58
*P256    DC    P'256'                  PACK CONSTANT 256
P999     DC    P'999'                  PACK CONSTANT 999
P32768   DC    P'32768'                PACK DECIMAL CONSTANT 32768 @11C
UNAME    DC    CL8'A'                  USER NAME AREA
         DC    CL2' '
CHARTRAN DC    256X'FF'                TRT TABLE FOR CHAR/HEX DETERMINA
         ORG   CHARTRAN+C' '
         DC    X'00'                   BLANK IS CHARACTER
         ORG   CHARTRAN+C'.' 4B
         DC    4X'00'                  .   ARE CHARACTERS
         ORG   CHARTRAN+C'A'
         DC    9X'00'                  A-I ARE CHARACTERS
         ORG   CHARTRAN+C'J'
         DC    9X'00'                  J-R ARE CHARACTERS
         ORG   CHARTRAN+C'S'
         DC    8X'00'                  S-Z ARE CHARACTERS
         ORG   CHARTRAN+C'0'
         DC    10X'00'                 0-9 ARE CHARACTERS
         ORG
TRHEX    DC    256X'FF'                HEX TRANSLATION TABLE
         ORG   TRHEX+C'A'
         DC    X'0A0B0C0D0E0F'
         ORG   TRHEX+C'0'
         DC    X'00010203040506070809'
         ORG
TRTHEX   DS    0X                      VERIFY HEX TABLE
         DC    XL16'00'
         DC    XL240'FF'
         ORG
         LTORG
*
* INSTRUCTION DISASSEMBLY TABLES. THESE TABLES DEFINE VALID
* INSTRUCTION OP-CODES, AND GIVE MNEMONICS, FORMAT-TYPES,
* AND AN INDICATOR TO SHOW CONDITION SETTING INSTRUCTIONS,
* PRIVILEGED INSTRUCTIONS, AND FLOATING POINT INSTRUCTIONS.
*
*
TEMP1    DS    C                                                   @04A
* ------------------------------------------------
*
* ------------------------------------------------
         DS    0D
         COPY  HDISTD
COMMPARM DSECT ,                       COMMON AREAS
         COPY  HDISTC
         END
