{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011804000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 940576, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE335.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 940576, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 940576, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE335.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0f\\n'", "DS1TRBAL": "b'\\x1fX'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\x81\\x00\\x00\\x02\\x82\\x00\\x00\\x00\\x10'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"BITS": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x12o\\x00\\x98\\x12\\x7f\\x11\\x06\\x00\\xe2\\x00\\xe2\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-05-06T00:00:00", "modifydate": "1998-05-07T11:06:00", "lines": 226, "newlines": 226, "modlines": 0, "user": "XSSGSCH"}, "text": "??=ifdef MVS    //* RS\n   ??=pragma filetag(\"IBM-1047\")  //* RS\n??=endif                          //* RS\n/* bits.c -- output variable-length bit strings\n * Copyright (C) 1992-1993 Jean-loup Gailly\n * This is free software; you can redistribute it and/or modify it under the\n * terms of the GNU General Public License, see the file COPYING.\n */\n\n\n/*\n *  PURPOSE\n *\n *      Output variable-length bit strings. Compression can be done\n *      to a file or to memory. (The latter is not supported in this version.)\n *\n *  DISCUSSION\n *\n *      The PKZIP \"deflate\" file format interprets compressed file data\n *      as a sequence of bits.  Multi-bit strings in the file may cross\n *      byte boundaries without restriction.\n *\n *      The first bit of each byte is the low-order bit.\n *\n *      The routines in this file allow a variable-length bit value to\n *      be output right-to-left (useful for literal values). For\n *      left-to-right output (useful for code strings from the tree routines),\n *      the bits must have been reversed first with bi_reverse().\n *\n *      For in-memory compression, the compressed bit stream goes directly\n *      into the requested output buffer. The input data is read in blocks\n *      by the mem_read() function. The buffer is limited to 64K on 16 bit\n *      machines.\n *\n *  INTERFACE\n *\n *      void bi_init (FILE *zipfile)\n *          Initialize the bit string routines.\n *\n *      void send_bits (int value, int length)\n *          Write out a bit string, taking the source bits right to\n *          left.\n *\n *      int bi_reverse (int value, int length)\n *          Reverse the bits of a bit string, taking the source bits left to\n *          right and emitting them right to left.\n *\n *      void bi_windup (void)\n *          Write out any remaining bits in an incomplete byte.\n *\n *      void copy_block(char *buf, unsigned len, int header)\n *          Copy a stored block to the zip file, storing first the length and\n *          its one's complement if requested.\n *\n */\n\n#include \"tailor.h\"\n#include \"gzip.h\"\n#include \"crypt.h\"\n\n#ifdef DEBUG\n#  include <stdio.h>\n#endif\n\n#ifndef lint\nstatic char rcsid\u00dd\u00a8 = \"$Id: bits.c,v 0.9 1993/06/11 10:16:58 jloup Exp $\";\n#endif\n\n/* ===========================================================================\n * Local data used by the \"bit string\" routines.\n */\n#ifdef MVS               //* RS\n   local int zfile; /* output gzip file */\n#else                    //* RS\n   local file_t  zfile; /* output gzip file */\n#endif                   //* RS\n\nlocal unsigned short bi_buf;\n/* Output buffer. bits are inserted starting at the bottom (least significant\n * bits).\n */\n\n#define Buf_size (8 * 2*sizeof(char))\n/* Number of bits used within bi_buf. (bi_buf might be implemented on\n * more than 16 bits on some systems.)\n */\n\nlocal int bi_valid;\n/* Number of valid bits in bi_buf.  All bits above the last valid bit\n * are always zero.\n */\n\nint (*read_buf) OF((char *buf, unsigned size));\n/* Current input function. Set to mem_read for in-memory compression */\n\n#ifdef DEBUG\n  ulg bits_sent;   /* bit length of the compressed data */\n#endif\n\n/* ===========================================================================\n * Initialize the bit string routines.\n */\n#ifdef MVS        //* RS\n   void bi_init(int zipfile)\n#else             //* RS\n   void bi_init(zipfiles)\n       file_t zipfile; //*output zip file, NO_FILE for in-memory compr\n#endif\n{\n    zfile  = zipfile;\n    bi_buf = 0;\n    bi_valid = 0;\n#ifdef DEBUG\n    bits_sent = 0L;\n#endif\n    /* Set the defaults for file compression. They are set by memcompress\n     * for in-memory compression.\n     */\n    if (zfile != NO_FILE) {\n        read_buf  = file_read;\n    }\n}\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\n#ifdef MVS        //* RS\n   void send_bits(int value, int length)    //* RS\n#else             //* RS\n   void send_bits(value, length)    //* RS\n       int value;  /* value to send */\n       int length; /* number of bits */\n#endif            //* RS\n{\n#ifdef DEBUG\n    Tracev((stderr,\" l %2d v %4x \", length, value));\n    Assert(length > 0 && length <= 15, \"invalid length\");\n    bits_sent += (ulg)length;\n#endif\n    /* If not enough room in bi_buf, use (valid) bits from bi_buf and\n     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))\n     * unused bits in value.\n     */\n    if (bi_valid > (int)Buf_size - length) {\n        bi_buf |= (value << bi_valid);\n        put_short(bi_buf);\n        bi_buf = (ush)value >> (Buf_size - bi_valid);\n        bi_valid += length - Buf_size;\n    } else {\n        bi_buf |= value << bi_valid;\n        bi_valid += length;\n    }\n}\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\n#ifdef MVS        //* RS\n   unsigned bi_reverse(unsigned code, int len)\n#else             //* RS\n   unsigned bi_reverse(code, len)\n       unsigned code; /* the value to invert */\n       int len;       /* its bit length */\n#endif            //* RS\n{\n    register unsigned res = 0;\n    do {\n        res |= code & 1;\n        code >>= 1, res <<= 1;\n    } while (--len > 0);\n    return res >> 1;\n}\n\n/* ===========================================================================\n * Write out any remaining bits in an incomplete byte.\n */\nvoid bi_windup()\n{\n    if (bi_valid > 8) {\n        put_short(bi_buf);\n    } else if (bi_valid > 0) {\n        put_byte(bi_buf);\n    }\n    bi_buf = 0;\n    bi_valid = 0;\n#ifdef DEBUG\n    bits_sent = (bits_sent+7) & ~7;\n#endif\n}\n\n/* ===========================================================================\n * Copy a stored block to the zip file, storing first the length and its\n * one's complement if requested.\n */\n#ifdef MVS        //* RS\n   void copy_block(char *buf, unsigned len, int header)\n#else             //* RS\n   void copy_block(buf, len, header)\n   char     *buf;    /* the input data */\n   unsigned len;     /* its length */\n   int      header;  /* true if block header must be written */\n#endif            //* RS\n{\n    bi_windup();              /* align on byte boundary */\n\n    if (header) {\n        put_short((ush)len);\n        put_short((ush)~len);\n#ifdef DEBUG\n        bits_sent += 2*16;\n#endif\n    }\n#ifdef DEBUG\n    bits_sent += (ulg)len<<3;\n#endif\n    while (len--) {\n#ifdef CRYPT\n        int t;\n        if (key) zencode(*buf, t);\n#endif\n        put_byte(*buf++);\n    }\n}\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CBCCL": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x98\\x14\\x0f\\x00\\x98\\x14o\\x18B\\x00Z\\x00X\\x00\\x00\\xd9\\xd6\\xd3\\xc1\\xd5\\xc4\\xe2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1998-05-20T00:00:00", "modifydate": "1998-05-26T18:42:00", "lines": 90, "newlines": 88, "modlines": 0, "user": "ROLANDS"}, "text": "//CBCCL PROC INFILE=ROLANDS.C(TEST),      < INPUT ... REQUIRED\n//   CRUN=,                               < COMPILER RUNTIME OPTIONS\n//   CPARM='OPTFILE(DD:ROLANDS)',         < COMPILER OPTIONS\n//   CREGSIZ='4M',                        < COMPILER REGION SIZE\n//   LIBPRFX='CEE',                       < PREFIX FOR LIBRARY DSN\n//   LNGPRFX='CBC',                       < PREFIX FOR LANGUAGE DSN\n//   CLBPRFX='CBC',                       < PREFIX FOR CLASS LIBRARIES\n//   CLANG='EDCMSGE', <NOT USED IN THIS RELEASE. KEPT FOR COMPATIBILITY\n// CXXLANG='CBCMSGE', <NOT USED IN THIS RELEASE. KEPT FOR COMPATIBILITY\n//   PLANG='EDCPMSGE',                    < PRE-LINKER MESSAGE NAME\n//   PREGSIZ='2048K',                     < PRE-LINKER REGION SIZE\n//   PPARM='MAP,NOER',                    < PRE-LINKER OPTIONS\n//   LPARM='AMODE=31,MAP,RENT',           < LINKAGE EDITOR OPTIONS\n// OUTFILE='ROLANDS.LOAD(TEST),DISP=SHR',\n//   TUNIT='VIO'                          < UNIT FOR TEMPORARY FILES\n//*-------------------------------------------------------------------\n//*  COMPILE STEP:\n//*-------------------------------------------------------------------\n//COMPILE EXEC PGM=CBCDRVR,REGION=&CREGSIZ,\n//    PARM=('&CRUN/ &CPARM')\n//* LMKLIST CONTAINS THE C-COMPILER\n//STEPLIB  DD  DSN=&LIBPRFX..SCEERUN,DISP=SHR\n//*        DD  DSN=&LNGPRFX..SCBCCMP.SAVE,DISP=SHR,VOL=SER=OS39R4,\n//*            UNIT=DASD                                          -GSF\n//SYSMSGS  DD  DUMMY,DSN=&LNGPRFX..SCBC3MSG(&CLANG),DISP=SHR\n//SYSXMSGS DD  DUMMY,DSN=&LNGPRFX..SCBC3MSG(&CXXLANG),DISP=SHR\n//SYSIN    DD  DSN=&INFILE,DISP=SHR\n//SYSLIN   DD  DSN=ROLANDS.GZIP.OBJ(GZIP),DISP=SHR\n//*YSLIN   DD  DSN=&&LOADSET,UNIT=&TUNIT.,\n//*            DISP=(MOD,PASS),SPACE=(32000,(100,100)),\n//*            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSPRINT DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//SYSCPRT  DD  SYSOUT=*\n//SYSUT1   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSUT4   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSUT5   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT6   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT7   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT8   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT9   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=VB,LRECL=137,BLKSIZE=882)\n//SYSUT10  DD  SYSOUT=*\n//SYSUT14  DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT15  DD  SYSOUT=*\n//ROLANDS  DD  DISP=SHR,DSN=ROLANDS.GZIP390.CNTL(COPTS)\n//*\n//*-------------------------------------------------------------\n//* PRE-LINKEDIT STEP:\n//*-------------------------------------------------------------\n//PLKED  EXEC PGM=EDCPRLK,REGION=&PREGSIZ,COND=(8,LE,COMPILE),\n//       PARM='&PPARM'\n//STEPLIB  DD  DSN=&LIBPRFX..SCEERUN,DISP=SHR\n//SYSMSGS  DD  DSN=&LIBPRFX..SCEEMSGP(&PLANG),DISP=SHR\n//SYSLIB   DD  DSN=&LIBPRFX..SCEECPP,DISP=SHR\n//SYSIN    DD  DSN=*.COMPILE.SYSLIN,DISP=(MOD,PASS)\n//         DD  DSN=&CLBPRFX..SCLBSID(IOSTREAM),DISP=SHR\n//         DD  DSN=&CLBPRFX..SCLBSID(COMPLEX),DISP=SHR\n//         DD  DSN=&CLBPRFX..SCLBSID(ASCCOLL),DISP=SHR\n//         DD  DDNAME=SYSIN2\n//*YSMOD   DD  DSN=ROLANDS.GZIP.OBF(GZIP),DISP=SHR\n//SYSMOD   DD  DSN=&&PLKSET,UNIT=&TUNIT.,DISP=(NEW,PASS),\n//             SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSDEFSD DD  DUMMY\n//SYSOUT   DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSIN2   DD  DUMMY\n//*\n//*-------------------------------------------------------------------\n//* LINKEDIT STEP:\n//*-------------------------------------------------------------------\n//LKED   EXEC PGM=HEWL,REGION=1024K,COND=((8,LT,COMPILE),(8,LE,PLKED)),\n//       PARM='&LPARM'\n//SYSLIB   DD  DSN=&LIBPRFX..SCEELKED,DISP=SHR\n//SYSLIN   DD  DSN=*.PLKED.SYSMOD,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSN=&OUTFILE\n//SYSUT1   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30))\n//SYSUT2   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30))\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//       PEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CBCCO": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x98\\x14\\x0f\\x00\\x98\\x14o\\x18B\\x000\\x00E\\x00\\x00\\xd9\\xd6\\xd3\\xc1\\xd5\\xc4\\xe2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1998-05-20T00:00:00", "modifydate": "1998-05-26T18:42:00", "lines": 48, "newlines": 69, "modlines": 0, "user": "ROLANDS"}, "text": "//CBCCO PROC INFILE=ROLANDS.C(TEST),      < INPUT ... REQUIRED\n//   CRUN=,                               < COMPILER RUNTIME OPTIONS\n//   CPARM='OPTFILE(DD:ROLANDS)',         < COMPILER OPTIONS\n//   CREGSIZ='4M',                        < COMPILER REGION SIZE\n//   LIBPRFX='CEE',                       < PREFIX FOR LIBRARY DSN\n//   LNGPRFX='CBC',                       < PREFIX FOR LANGUAGE DSN\n//   CLANG='EDCMSGE', <NOT USED IN THIS RELEASE. KEPT FOR COMPATIBILITY\n// CXXLANG='CBCMSGE', <NOT USED IN THIS RELEASE. KEPT FOR COMPATIBILITY\n// OUTFILE='ROLANDS.LOAD(TEST),DISP=SHR',\n//   TUNIT='VIO'                          < UNIT FOR TEMPORARY FILES\n//*-------------------------------------------------------------------\n//*  COMPILE STEP:\n//*-------------------------------------------------------------------\n//COMPILE EXEC PGM=CBCDRVR,REGION=&CREGSIZ,\n//    PARM=('&CRUN/ &CPARM')\n//* LMKLIST CONTAINS THE C-COMPILER\n//STEPLIB  DD  DSN=&LIBPRFX..SCEERUN,DISP=SHR\n//*        DD  DSN=<THE.C370.COMPILER>,DISP=SHR\n//SYSMSGS  DD  DUMMY,DSN=&LNGPRFX..SCBC3MSG(&CLANG),DISP=SHR\n//SYSXMSGS DD  DUMMY,DSN=&LNGPRFX..SCBC3MSG(&CXXLANG),DISP=SHR\n//SYSIN    DD  DSN=&INFILE,DISP=SHR\n//SYSLIN   DD  DSN=&OUTFILE\n//*SYSLIN   DD  DSN=&&LOADSET,UNIT=&TUNIT.,\n//*             DISP=(MOD,PASS),SPACE=(512,(50,20)),\n//*             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSPRINT DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//SYSCPRT  DD  SYSOUT=*\n//SYSUT1   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSUT4   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSUT5   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT6   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT7   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT8   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT9   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=VB,LRECL=137,BLKSIZE=882)\n//SYSUT10  DD  SYSOUT=*\n//SYSUT14  DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT15  DD  SYSOUT=*\n//ROLANDS  DD  DISP=SHR,DSN=ROLANDS.GZIP390.CNTL(COPTS)\n//       PEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COPTS": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x98\\x12\\x0f\\x00\\x98\\x14o\\x185\\x00\\r\\x00\\x03\\x00\\x00\\xd9\\xd6\\xd3\\xc1\\xd5\\xc4\\xe2@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1998-04-30T00:00:00", "modifydate": "1998-05-26T18:35:00", "lines": 13, "newlines": 3, "modlines": 0, "user": "ROLANDS"}, "text": "SS\nTARG(LE)\nGONUMBER\nNOLOCALE\nLIST\nSEARCH('CEE.SCEEH.+')\nLSEARCH(GZIP390.+)\nNOMAR\nNOSEQ\nXREF\nTEST\nNOSHOWINC\nDEFINE(MVS,C370)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CRYPT": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x12o\\x00\\x98\\x12o\\x18A\\x00\\n\\x00\\n\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-05-06T00:00:00", "modifydate": "1998-05-06T18:41:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "XSSGSCH"}, "text": "??=ifdef MVS    //* RS\n   ??=pragma filetag(\"IBM-1047\")  //* RS\n??=endif                          //* RS\n/* crypt.c (dummy version) -- do not perform encryption\n * Hardly worth copyrighting :-)\n */\n#ifndef lint\nstatic char rcsid\u00dd\u00a8 = \"$Id: crypt.c,v 0.6 1993/03/22 09:48:47 jloup Exp $\";\n#endif\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "C370": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x00\\x00\\x98\\x11/\\x00\\x98\\x14/\\x10&\\x01T\\x01P\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "1998-04-22T00:00:00", "modifydate": "1998-05-22T10:26:00", "lines": 340, "newlines": 336, "modlines": 0, "user": "XSSGSCH"}, "text": "??=ifdef MVS    //* RS\n   ??=pragma filetag(\"IBM-1047\")  //* RS\n??=endif                          //* RS\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"c370.h\"\n\nvoid printhex( void *buf, int len )\n{ int i;\n   char *s = buf;\n   while (len >= 0) {\n      for (i=0;i < 16 && len >= 0; s++,i++,len--) {\n         int ch = (*s) & 0xff;\n         printf( \"%3d \", ch );\n      }\n      printf( \"\\n\" );\n   }\n   printf( \"\\n\" );\n}\n\n#undef fseek\nint myfseek( FILE *stream, long int offset, int origin )\n{ int i;\n   i = fseek( stream, offset, origin );\n   if (i != 0 && origin == SEEK_CUR) {\n      i = fseek( stream, ftell(stream) + offset, SEEK_SET );\n      if (i != 0)\n         printf(\"myfseek: ftell=%i, orig=%i, offset=%i, ret=%i\\n\",\n                ftell(stream), origin, offset, i );\n   }\n   return i;\n}\n\n#undef fread\nint myfread( void *buffer, size_t size, size_t count, FILE *stream )\n{ size_t i;\n   i = fread( buffer, size, count, stream );\n   if (count == 1 && size == 1 && i == 1) { /* skip padding zeroes */\n      char ch = *(char *)buffer;\n      fpos_t pos;\n      fgetpos( stream, &pos );\n      while ( ch == '\\0' && fread(&ch, 1, 1, stream) == 1);\n      fsetpos( stream, &pos );\n      if (ch == '\\0')\n         return 0;\n   }\n   return i;\n}\n\nint      fileno( FILE *fp )\n{\n   return (int)fp;\n}\n\nint      access( const char *filename, int how )\n{\n   struct stat buf;\n   return stat( filename, &buf );       /* dummy 'access' */\n}\n\nint      close( int fd )\n{\n   return fclose( (FILE *)fd );\n}\n\nint      isatty( int fd )\n{\n   return (fd==((int)stdin) \u00a6\u00a6 fd==((int)stdout) \u00a6\u00a6 fd==((int)stderr));\n}\n\noff_t    lseek( int fd, off_t offset, int whence )\n{\n   return fseek( (FILE *)fd, offset, whence );\n}\n\nsize_t   read( int fd, void *buf, size_t size )\n{\n   return fread( buf, 1, size, (FILE *)fd );\n}\n\nint      unlink( char *filename )\n{\n   return remove( filename );\n}\n\nint      write( int fd, void *buf, size_t len )\n{\n   return fwrite( buf, 1, len, (FILE *)fd );\n}\n\nchar dcb_flags\u00dd50\u00a8;\n\nstatic void access2mode( int access, char *mode)\n{\n   /* O_EXCL not supported */\n   switch (access & ~(O_BINARY \u00a6 O_MEMORY \u00a6 O_EXCL \u00a6 O_DCB)) {\n      case O_RDONLY                       : strcpy( mode, \"r\" ); break;\n      case O_RDWR                         : strcpy( mode, \"r+\" ); break;\n      case O_WRONLY                       :\n      case O_CREAT \u00a6 O_WRONLY             : strcpy( mode, \"w\" ); break;\n      case O_CREAT \u00a6 O_RDWR               : strcpy( mode, \"w+\" ); break;\n      case O_APPEND \u00a6 O_WRONLY            :\n      case O_APPEND \u00a6 O_CREAT \u00a6 O_WRONLY  : strcpy( mode, \"a\" ); break;\n      case O_APPEND \u00a6 O_RDWR              :\n      case O_APPEND \u00a6 O_CREAT \u00a6 O_RDWR    : strcpy( mode, \"a+\" ); break;\n      default                             : strcpy( mode, \"\" );\n   }\n   if (access & O_BINARY) strcat( mode, \"b\" );\n   if (access & O_MEMORY) strcat( mode, \",type=memory\" );\n   if (access & O_RECORD) strcat( mode, \",type=record\" );\n   if (access & O_DCB) strcat( mode, dcb_flags );\n}\n\nint  open(const char *path, int access)\n{\n   char mode\u00dd30\u00a8;\n   FILE *f;\n   access2mode( access, mode );\n   f = fopen( path, mode );\n   return (f == NULL ? -1 : fileno(f) );\n}\n\nint  eof( int fd )\n{\n    return feof( (FILE *)fd );\n}\n\nint  tell( int fd )\n{\n    return ftell( (FILE *)fd );\n}\n\nint  setmode(int fd, int access)\n{\n   char mode\u00dd30\u00a8;\n   FILE *f;\n\n   switch (fd) {\n      case 0: access \u00a6= O_RDONLY; fd = fileno(stdin);  break;\n      case 1: access \u00a6= O_WRONLY; fd = fileno(stdout); break;\n      case 2: access \u00a6= O_WRONLY; fd = fileno(stderr); break;\n   }\n   access2mode( access, mode );\n   f = freopen( \"\", mode, (FILE *)fd );\n   return (f == NULL ? -1 : fileno(f) );\n}\n\nint    chmod( const char* filename, mode_t mode )\n{\n   return 0;\n}\n\nint    stat(const char *filename, struct stat *buf )\n{\n   if ((buf->fp = fopen(filename, \"r\")) != NULL) {\n      fldata_t fdata;\n      if (fldata( buf->fp, buf->fname, &fdata ) == 0) {\n         buf->st_dev  = fdata.__device;\n         buf->st_mode = *(short *)(&fdata);\n      }\n      strcpy( buf->fname, filename );\n      fseek( buf->fp, 0, SEEK_END );\n      buf->st_size = ftell( buf->fp );\n      fclose(buf->fp);\n   }\n   return (buf->fp != NULL ? 0 : -1);\n}\n\nint    fstat(int fd, struct stat *buf )\n{\n   fldata_t fdata;\n\n   if ((fd != -1) && (fldata( (FILE *)fd, buf->fname, &fdata ) == 0))\n   {\n      buf->st_dev  = fdata.__device;\n      buf->st_mode = *(short *)(&fdata);\n      buf->fp      = (FILE *)fd;\n      return 0;\n   }\n   return -1;\n}\n\n\n#define ALIAS_MASK (unsigned int) 0x80\n#define SKIP_MASK (unsigned int) 0x1F\n#define TTRLEN      3\n#define RECLEN      254\ntypedef _Packed struct {\n   unsigned short int count;\n   char rest\u00ddRECLEN\u00a8;\n} RECORD;\nchar    *endmark = \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\";\n\nstatic int gen_node( DIR *dirp, RECORD *recptr )\n{\n   char *ptr, *name, ttr\u00ddTTRLEN\u00a8;\n   int skip, count = 2;\n   unsigned int info_byte, alias, ttrn;\n   struct dirent *new;\n\n   ptr = recptr->rest;\n   while (count < recptr->count) {\n      if (!memcmp( ptr, endmark, NAMELEN ))\n         return 1;\n      name = ptr;                    /* member name */\n      ptr += NAMELEN;\n      memcpy( ttr, ptr, TTRLEN );    /* ttr name    */\n      ptr += TTRLEN;\n      info_byte = (unsigned int) (*ptr);   /* info byte */\n      if ( !(info_byte & ALIAS_MASK) ) { /* no alias    */\n         new = malloc( sizeof(struct dirent) );\n         if (dirp->D_list == NULL)\n            dirp->D_list = dirp->D_curpos = new;\n         else\n            dirp->D_curpos = (dirp->D_curpos->d_next = new);\n         new->d_next = NULL;\n         memcpy( new->d_name, name, NAMELEN );\n         new->d_name\u00ddNAMELEN\u00a8 = '\\0';\n         if ((name = strchr( new->d_name, ' ' )) != NULL)\n            *name = '\\0';      /* skip trailing blanks */\n      }\n      skip = (info_byte & SKIP_MASK) * 2 + 1;\n      ptr += skip;\n      count += (TTRLEN + NAMELEN + skip);\n   }\n   return 0;\n}\n\nDIR *opendir(const char *dirname)\n{\n   int bytes, list_end = 0;\n   DIR *dirp;\n   FILE *fp;\n   RECORD rec;\n\n   fp = fopen( dirname, \"rb\" );\n   if (fp != NULL) {\n      dirp = malloc( sizeof(DIR) );\n      if (dirp != NULL) {\n         dirp->D_list = dirp->D_curpos = NULL;\n         strcpy( dirp->D_path, dirname );\n         do {\n            bytes = fread( &rec, 1, sizeof(rec), fp );\n            if (bytes == sizeof(rec))\n               list_end = gen_node( dirp, &rec );\n         } while (!feof(fp) && !list_end);\n         fclose( fp );\n         dirp->D_curpos = dirp->D_list;\n         return dirp;\n      }\n      fclose( fp );\n   }\n   return NULL;\n}\n\nstruct dirent *readdir(DIR *dirp)\n{\n   struct dirent *cur;\n\n   cur = dirp->D_curpos;\n   if (cur != NULL)\n      dirp->D_curpos = cur->d_next;\n   return cur;\n}\n\nvoid rewinddir(DIR *dirp)\n{\n   dirp->D_curpos = dirp->D_list;\n}\n\nint closedir(DIR *dirp)\n{\n   struct dirent *node;\n\n   while (dirp->D_list != NULL) {\n      node = dirp->D_list;\n      dirp->D_list = dirp->D_list->d_next;\n      free( node );\n   }\n   free( dirp );\n   return 0;\n}\n\n\n\n\n//* ebcdic-ascii converting, accustom to your local MVS-settings\n\n\nunsigned char ebcdic_ascii\u00dd\u00a8 = {\n0x00,0x00,0x00,0x00,0x00,0x09,0x00,0x00,0x00,0x00,0x00,0x0b,0x0c,0x0d,0x00,0x00,\n0x00,0x00,0x00,0x00,0x00,0x0a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2e,0x3c,0x28,0x2b,0x7c,\n0x26,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x21,0x24,0x2a,0x29,0x3b,0x5e,\n0x2d,0x2f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7c,0x2c,0x25,0x5f,0x3e,0x3f,\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x3a,0x23,0x40,0x27,0x3d,0x22,\n0x00,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x00,0x00,0x00,0x00,0x00,0x00,\n0x00,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x00,0x00,0x00,0x00,0x00,0x00,\n0x00,0x7e,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x00,0x00,0x00,0x5b,0x00,0x00,\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5d,0x00,0x00,\n0x7b,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x00,0x00,0x00,0x00,0x00,0x00,\n0x7d,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x00,0x00,0x00,0x00,0x00,0x00,\n0x5c,0x00,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x00,0x00,0x00,0x00,0x00,0x00,\n0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x00,0x00,0x00,0x00,0x00,0x00,\n};\n\nunsigned char ascii_ebcdic\u00dd\u00a8 = {\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2f,0x16,0x05,0x15,0x0b,0x0c,0x0d,0x00,0x00,\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n0x40,0x5a,0x7f,0x7b,0x5b,0x6c,0x50,0x7d,0x4d,0x5d,0x5c,0x4e,0x6b,0x60,0x4b,0x61,\n0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0x7a,0x5e,0x4c,0x7e,0x6e,0x6f,\n0x7c,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,\n0xd7,0xd8,0xd9,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xad,0xe0,0xbd,0x5f,0x6d,\n0x79,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x91,0x92,0x93,0x94,0x95,0x96,\n0x97,0x98,0x99,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xc0,0x6a,0xd0,0xa1,0x00,\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n};\n\nvoid ebcdic2ascii( unsigned char *buf, unsigned size )\n{\n   while (size--)\n     *(buf+size) = ebcdic_ascii\u00dd *(buf+size) \u00a8;\n}\n\nvoid ascii2ebcdic( unsigned char *buf, unsigned size )\n{\n   while (size--)\n     *(buf+size) = ascii_ebcdic\u00dd *(buf+size) \u00a8;\n}\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEFLATE": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x98\\x12o\\x00\\x98\\x12o R\\x03\\x07\\x03\\x07\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-05-06T00:00:00", "modifydate": "1998-05-06T20:52:00", "lines": 775, "newlines": 775, "modlines": 0, "user": "XSSGSCH"}, "text": "??=ifdef MVS    //* RS\n   ??=pragma filetag(\"IBM-1047\")  //* RS\n??=endif                          //* RS\n/* deflate.c -- compress data using the deflation algorithm\n * Copyright (C) 1992-1993 Jean-loup Gailly\n * This is free software; you can redistribute it and/or modify it under the\n * terms of the GNU General Public License, see the file COPYING.\n */\n\n/*\n *  PURPOSE\n *\n *      Identify new text as repetitions of old text within a fixed-\n *      length sliding window trailing behind the new text.\n *\n *  DISCUSSION\n *\n *      The \"deflation\" process depends on being able to identify portions\n *      of the input text which are identical to earlier input (within a\n *      sliding window trailing behind the input currently being processed).\n *\n *      The most straightforward technique turns out to be the fastest for\n *      most input files: try all possible matches and select the longest.\n *      The key feature of this algorithm is that insertions into the string\n *      dictionary are very simple and thus fast, and deletions are avoided\n *      completely. Insertions are performed at each input character, whereas\n *      string matches are performed only when the previous match ends. So it\n *      is preferable to spend more time in matches to allow very fast string\n *      insertions and avoid deletions. The matching algorithm for small\n *      strings is inspired from that of Rabin & Karp. A brute force approach\n *      is used to find longer strings when a small match has been found.\n *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze\n *      (by Leonid Broukhis).\n *         A previous version of this file used a more sophisticated algorithm\n *      (by Fiala and Greene) which is guaranteed to run in linear amortized\n *      time, but has a larger average cost, uses more memory and is patented.\n *      However the F&G algorithm may be faster for some highly redundant\n *      files if the parameter max_chain_length (described below) is too large.\n *\n *  ACKNOWLEDGEMENTS\n *\n *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and\n *      I found it in 'freeze' written by Leonid Broukhis.\n *      Thanks to many info-zippers for bug reports and testing.\n *\n *  REFERENCES\n *\n *      APPNOTE.TXT documentation file in PKZIP 1.93a distribution.\n *\n *      A description of the Rabin and Karp algorithm is given in the book\n *         \"Algorithms\" by R. Sedgewick, Addison-Wesley, p252.\n *\n *      Fiala,E.R., and Greene,D.H.\n *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595\n *\n *  INTERFACE\n *\n *      void lm_init (int pack_level, ush *flags)\n *          Initialize the \"longest match\" routines for a new file\n *\n *      ulg deflate (void)\n *          Processes a new input file and return its compressed length. Sets\n *          the compressed length, crc, deflate flags and internal file\n *          attributes.\n */\n\n#include <stdio.h>\n\n#include \"tailor.h\"\n#include \"gzip.h\"\n#include \"lzw.h\" /* just for consistency checking */\n\n#ifndef lint\nstatic char rcsid\u00dd\u00a8 = \"$Id: deflate.c,v 0.14 1993/06/12 20:11:10 jloup Exp $\";\n#endif\n\n/* ===========================================================================\n * Configuration parameters\n */\n\n/* Compile with MEDIUM_MEM to reduce the memory requirements or\n * with SMALL_MEM to use as little memory as possible. Use BIG_MEM if the\n * entire input file can be held in memory (not possible on 16 bit systems).\n * Warning: defining these symbols affects HASH_BITS (see below) and thus\n * affects the compression ratio. The compressed output\n * is still correct, and might even be smaller in some cases.\n */\n\n#ifdef SMALL_MEM\n#   define HASH_BITS  13  /* Number of bits used to hash strings */\n#endif\n#ifdef MEDIUM_MEM\n#   define HASH_BITS  14\n#endif\n#ifndef HASH_BITS\n#   define HASH_BITS  15\n   /* For portability to 16 bit machines, do not use values above 15. */\n#endif\n\n/* To save space (see unlzw.c), we overlay prev+head with tab_prefix and\n * window with tab_suffix. Check that we can do this:\n */\n#if (WSIZE<<1) > (1<<BITS)\n   error: cannot overlay window with tab_suffix and prev with tab_prefix0\n#endif\n#if HASH_BITS > BITS-1\n   error: cannot overlay head with tab_prefix1\n#endif\n\n#define HASH_SIZE (unsigned)(1<<HASH_BITS)\n#define HASH_MASK (HASH_SIZE-1)\n#define WMASK     (WSIZE-1)\n/* HASH_SIZE and WSIZE must be powers of two */\n\n#define NIL 0\n/* Tail of hash chains */\n\n#define FAST 4\n#define SLOW 2\n/* speed options for the general purpose bit flag */\n\n#ifndef TOO_FAR\n#  define TOO_FAR 4096\n#endif\n/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */\n\n/* ===========================================================================\n * Local data used by the \"longest match\" routines.\n */\n\ntypedef ush Pos;\ntypedef unsigned IPos;\n/* A Pos is an index in the character window. We use short instead of int to\n * save space in the various tables. IPos is used only for parameter passing.\n */\n\n/* DECLARE(uch, window, 2L*WSIZE); */\n/* Sliding window. Input bytes are read into the second half of the window,\n * and move to the first half later to keep a dictionary of at least WSIZE\n * bytes. With this organization, matches are limited to a distance of\n * WSIZE-MAX_MATCH bytes, but this ensures that IO is always\n * performed with a length multiple of the block size. Also, it limits\n * the window size to 64K, which is quite useful on MSDOS.\n * To do: limit the window size to WSIZE+BSZ if SMALL_MEM (the code would\n * be less efficient).\n */\n\n/* DECLARE(Pos, prev, WSIZE); */\n/* Link to older string with same hash index. To limit the size of this\n * array to 64K, this link is maintained only for the last 32K strings.\n * An index in this array is thus a window index modulo 32K.\n */\n\n/* DECLARE(Pos, head, 1<<HASH_BITS); */\n/* Heads of the hash chains or NIL. */\n\nulg window_size = (ulg)2*WSIZE;\n/* window size, 2*WSIZE except for MMAP or BIG_MEM, where it is the\n * input file length plus MIN_LOOKAHEAD.\n */\n\nlong block_start;\n/* window position at the beginning of the current output block. Gets\n * negative when the window is moved backwards.\n */\n\nlocal unsigned ins_h;  /* hash index of string to be inserted */\n\n#define H_SHIFT  ((HASH_BITS+MIN_MATCH-1)/MIN_MATCH)\n/* Number of bits by which ins_h and del_h must be shifted at each\n * input step. It must be such that after MIN_MATCH steps, the oldest\n * byte no longer takes part in the hash key, that is:\n *   H_SHIFT * MIN_MATCH >= HASH_BITS\n */\n\nunsigned int near prev_length;\n/* Length of the best match at previous step. Matches not greater than this\n * are discarded. This is used in the lazy match evaluation.\n */\n\n      unsigned near strstart;      /* start of string to insert */\n      unsigned near match_start;   /* start of matching string */\nlocal int           eofile;        /* flag set at end of input file */\nlocal unsigned      lookahead;     /* number of valid bytes ahead in window */\n\nunsigned near max_chain_length;\n/* To speed up deflation, hash chains are never searched beyond this length.\n * A higher limit improves compression ratio but degrades the speed.\n */\n\nlocal unsigned int max_lazy_match;\n/* Attempt to find a better match only when the current match is strictly\n * smaller than this value. This mechanism is used only for compression\n * levels >= 4.\n */\n#define max_insert_length  max_lazy_match\n/* Insert new strings in the hash table only if the match length\n * is not greater than this length. This saves time but degrades compression.\n * max_insert_length is used only for compression levels <= 3.\n */\n\nlocal int compr_level;\n/* compression level (1..9) */\n\nint near good_match;\n/* Use a faster search when the previous match is longer than this */\n\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\n\ntypedef struct config {\n   ush good_length; /* reduce lazy search above this match length */\n   ush max_lazy;    /* do not perform lazy search above this match length */\n   ush nice_length; /* quit search above this match length */\n   ush max_chain;\n} config;\n\n#ifdef  FULL_SEARCH\n# define nice_match MAX_MATCH\n#else\n  int near nice_match; /* Stop searching when current match exceeds this */\n#endif\n\nlocal config configuration_table\u00dd10\u00a8 = {\n/*      good lazy nice chain */\n/* 0 */ {0,    0,  0,    0},  /* store only */\n/* 1 */ {4,    4,  8,    4},  /* maximum speed, no lazy matches */\n/* 2 */ {4,    5, 16,    8},\n/* 3 */ {4,    6, 32,   32},\n\n/* 4 */ {4,    4, 16,   16},  /* lazy matches */\n/* 5 */ {8,   16, 32,   32},\n/* 6 */ {8,   16, 128, 128},\n/* 7 */ {8,   32, 128, 256},\n/* 8 */ {32, 128, 258, 1024},\n/* 9 */ {32, 258, 258, 4096}}; /* maximum compression */\n\n/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4\n * For deflate_fast() (levels <= 3) good is ignored and lazy has a different\n * meaning.\n */\n\n#define EQUAL 0\n/* result of memcmp for equal strings */\n\n/* ===========================================================================\n *  Prototypes for local functions.\n */\nlocal void fill_window   OF((void));\nlocal ulg deflate_fast   OF((void));\n\n      int  longest_match OF((IPos cur_match));\n#ifdef ASMV\n      void match_init OF((void)); /* asm code initialization */\n#endif\n\n#ifdef DEBUG\nlocal  void check_match OF((IPos start, IPos match, int length));\n#endif\n\n/* ===========================================================================\n * Update a hash value with the given input byte\n * IN  assertion: all calls to to UPDATE_HASH are made with consecutive\n *    input characters, so that a running hash key can be computed from the\n *    previous key instead of complete recalculation each time.\n */\n#define UPDATE_HASH(h,c) (h = (((h)<<H_SHIFT) \u00ac (c)) & HASH_MASK)\n\n/* ===========================================================================\n * Insert string s in the dictionary and set match_head to the previous head\n * of the hash chain (the most recent string with same hash key). Return\n * the previous length of the hash chain.\n * IN  assertion: all calls to to INSERT_STRING are made with consecutive\n *    input characters and the first MIN_MATCH bytes of s are valid\n *    (except for the last MIN_MATCH-1 bytes of the input file).\n */\n#define INSERT_STRING(s, match_head) \\\n   (UPDATE_HASH(ins_h, window\u00dd(s) + MIN_MATCH-1\u00a8), \\\n    prev\u00dd(s) & WMASK\u00a8 = match_head = head\u00ddins_h\u00a8, \\\n    head\u00ddins_h\u00a8 = (s))\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new file\n */\n#ifdef MVS               //* RS\n   void lm_init (int pack_level, ush *flags)\n#else                    //* RS\n   void lm_init (pack_level, flags)\n       int pack_level; /* 0:store, 1:best speed, 9:best compression */\n       ush *flags;     /* general purpose bit flag */\n#endif                   //* RS\n{\n    register unsigned j;\n\n    if (pack_level < 1 || pack_level > 9) error(\"bad pack level\");\n    compr_level = pack_level;\n\n    /* Initialize the hash table. */\n#if defined(MAXSEG_64K) && HASH_BITS == 15\n    for (j = 0;  j < HASH_SIZE; j++) head\u00ddj\u00a8 = NIL;\n#else\n    memzero((char*)head, HASH_SIZE*sizeof(*head));\n#endif\n    /* prev will be initialized on the fly */\n\n    /* Set the default configuration parameters:\n     */\n    max_lazy_match   = configuration_table\u00ddpack_level\u00a8.max_lazy;\n    good_match       = configuration_table\u00ddpack_level\u00a8.good_length;\n#ifndef FULL_SEARCH\n    nice_match       = configuration_table\u00ddpack_level\u00a8.nice_length;\n#endif\n    max_chain_length = configuration_table\u00ddpack_level\u00a8.max_chain;\n    if (pack_level == 1) {\n       *flags |= FAST;\n    } else if (pack_level == 9) {\n       *flags |= SLOW;\n    }\n    /* ??? reduce max_chain_length for binary files */\n\n    strstart = 0;\n    block_start = 0L;\n#ifdef ASMV\n    match_init(); /* initialize the asm code */\n#endif\n\n    lookahead = read_buf((char*)window,\n                         sizeof(int) <= 2 ? (unsigned)WSIZE : 2*WSIZE);\n\n    if (lookahead == 0 || lookahead == (unsigned)EOF) {\n       eofile = 1, lookahead = 0;\n       return;\n    }\n    eofile = 0;\n    /* Make sure that we always have enough lookahead. This is important\n     * if input comes from a device such as a tty.\n     */\n    while (lookahead < MIN_LOOKAHEAD && !eofile) fill_window();\n\n    ins_h = 0;\n    for (j=0; j<MIN_MATCH-1; j++) UPDATE_HASH(ins_h, window\u00ddj\u00a8);\n    /* If lookahead < MIN_MATCH, ins_h is garbage, but this is\n     * not important since only literal bytes will be emitted.\n     */\n}\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n */\n#ifndef ASMV\n/* For MSDOS, OS/2 and 386 Unix, an optimized version is in match.asm or\n * match.s. The code is functionally equivalent, so you can use the C version\n * if desired.\n */\n#ifdef MVS               //* RS\n   int longest_match(IPos cur_match)\n#else                    //* RS\n   int longest_match(cur_match)\n      IPos cur_match;                             /* current match */\n#endif                   //* RS\n{\n    unsigned chain_length = max_chain_length;   /* max hash chain length */\n    register uch *scan = window + strstart;     /* current string */\n    register uch *match;                        /* matched string */\n    register int len;                           /* length of current match */\n    int best_len = prev_length;                 /* best match length so far */\n    IPos limit = strstart > (IPos)MAX_DIST ? strstart - (IPos)MAX_DIST : NIL;\n    /* Stop when cur_match becomes <= limit. To simplify the code,\n     * we prevent matches with the string of window index 0.\n     */\n\n/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n * It is easy to get rid of this optimization if necessary.\n */\n#if HASH_BITS < 8 || MAX_MATCH != 258\n   error: Code too clever\n#endif\n\n#ifdef UNALIGNED_OK\n    /* Compare two bytes at a time. Note: this is not always beneficial.\n     * Try with and without -DUNALIGNED_OK to check.\n     */\n    register uch *strend = window + strstart + MAX_MATCH - 1;\n    register ush scan_start = *(ush*)scan;\n    register ush scan_end   = *(ush*)(scan+best_len-1);\n#else\n    register uch *strend = window + strstart + MAX_MATCH;\n    register uch scan_end1  = scan\u00ddbest_len-1\u00a8;\n    register uch scan_end   = scan\u00ddbest_len\u00a8;\n#endif\n\n    /* Do not waste too much time if we already have a good match: */\n    if (prev_length >= good_match) {\n        chain_length >>= 2;\n    }\n    Assert(strstart <= window_size-MIN_LOOKAHEAD, \"insufficient lookahead\");\n\n    do {\n        Assert(cur_match < strstart, \"no future\");\n        match = window + cur_match;\n\n        /* Skip to next match if the match length cannot increase\n         * or if the match length is less than 2:\n         */\n#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)\n        /* This code assumes sizeof(unsigned short) == 2. Do not use\n         * UNALIGNED_OK if your compiler uses a different size.\n         */\n        if (*(ush*)(match+best_len-1) != scan_end ||\n            *(ush*)match != scan_start) continue;\n\n        /* It is not necessary to compare scan\u00dd2\u00a8 and match\u00dd2\u00a8 since they are\n         * always equal when the other bytes match, given that the hash keys\n         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at\n         * strstart+3, +5, ... up to strstart+257. We check for insufficient\n         * lookahead only every 4th comparison; the 128th check will be made\n         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is\n         * necessary to put more guard bytes at the end of the window, or\n         * to check more often for insufficient lookahead.\n         */\n        scan++, match++;\n        do {\n        } while (*(ush*)(scan+=2) == *(ush*)(match+=2) &&\n                 *(ush*)(scan+=2) == *(ush*)(match+=2) &&\n                 *(ush*)(scan+=2) == *(ush*)(match+=2) &&\n                 *(ush*)(scan+=2) == *(ush*)(match+=2) &&\n                 scan < strend);\n        /* The funny \"do {}\" generates better code on most compilers */\n\n        /* Here, scan <= window+strstart+257 */\n        Assert(scan <= window+(unsigned)(window_size-1), \"wild scan\");\n        if (*scan == *match) scan++;\n\n        len = (MAX_MATCH - 1) - (int)(strend-scan);\n        scan = strend - (MAX_MATCH-1);\n\n#else /* UNALIGNED_OK */\n\n        if (match\u00ddbest_len\u00a8   != scan_end  ||\n            match\u00ddbest_len-1\u00a8 != scan_end1 ||\n            *match            != *scan     ||\n            *++match          != scan\u00dd1\u00a8)      continue;\n\n        /* The check at best_len-1 can be removed because it will be made\n         * again later. (This heuristic is not always a win.)\n         * It is not necessary to compare scan\u00dd2\u00a8 and match\u00dd2\u00a8 since they\n         * are always equal when the other bytes match, given that\n         * the hash keys are equal and that HASH_BITS >= 8.\n         */\n        scan += 2, match++;\n\n        /* We check for insufficient lookahead only every 8th comparison;\n         * the 256th check will be made at strstart+258.\n         */\n        do {\n        } while (*++scan == *++match && *++scan == *++match &&\n                 *++scan == *++match && *++scan == *++match &&\n                 *++scan == *++match && *++scan == *++match &&\n                 *++scan == *++match && *++scan == *++match &&\n                 scan < strend);\n\n        len = MAX_MATCH - (int)(strend - scan);\n        scan = strend - MAX_MATCH;\n\n#endif /* UNALIGNED_OK */\n\n        if (len > best_len) {\n            match_start = cur_match;\n            best_len = len;\n            if (len >= nice_match) break;\n#ifdef UNALIGNED_OK\n            scan_end = *(ush*)(scan+best_len-1);\n#else\n            scan_end1  = scan\u00ddbest_len-1\u00a8;\n            scan_end   = scan\u00ddbest_len\u00a8;\n#endif\n        }\n    } while ((cur_match = prev\u00ddcur_match & WMASK\u00a8) > limit\n             && --chain_length != 0);\n\n    return best_len;\n}\n#endif /* ASMV */\n\n#ifdef DEBUG\n/* ===========================================================================\n * Check that the match at match_start is indeed a match.\n */\nlocal void check_match(start, match, length)\n    IPos start, match;\n    int length;\n{\n    /* check that the match is indeed a match */\n    if (memcmp((char*)window + match,\n                (char*)window + start, length) != EQUAL) {\n        fprintf(stderr,\n            \" start %d, match %d, length %d\\n\",\n            start, match, length);\n        error(\"invalid match\");\n    }\n    if (verbose > 1) {\n        fprintf(stderr,\"\\\\\u00dd%d,%d\u00a8\", start-match, length);\n        do { putc(window\u00ddstart++\u00a8, stderr); } while (--length != 0);\n    }\n}\n#else\n#  define check_match(start, match, length)\n#endif\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead, and sets eofile if end of input file.\n * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0\n * OUT assertions: at least one byte has been read, or eofile is set;\n *    file reads are performed for at least two bytes (required for the\n *    translate_eol option).\n */\nlocal void fill_window()\n{\n    register unsigned n, m;\n    unsigned more = (unsigned)(window_size - (ulg)lookahead - (ulg)strstart);\n    /* Amount of free space at the end of the window. */\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (more == (unsigned)EOF) {\n        /* Very unlikely, but possible on 16 bit machine if strstart == 0\n         * and lookahead == 1 (input done one byte at time)\n         */\n        more--;\n    } else if (strstart >= WSIZE+MAX_DIST) {\n        /* By the IN assertion, the window is not empty so we can't confuse\n         * more == 0 with more == 64K on a 16 bit machine.\n         */\n        Assert(window_size == (ulg)2*WSIZE, \"no sliding with BIG_MEM\");\n\n        memcpy((char*)window, (char*)window+WSIZE, (unsigned)WSIZE);\n        match_start -= WSIZE;\n        strstart    -= WSIZE; /* we now have strstart >= MAX_DIST: */\n\n        block_start -= (long) WSIZE;\n\n        for (n = 0; n < HASH_SIZE; n++) {\n            m = head\u00ddn\u00a8;\n            head\u00ddn\u00a8 = (Pos)(m >= WSIZE ? m-WSIZE : NIL);\n        }\n        for (n = 0; n < WSIZE; n++) {\n            m = prev\u00ddn\u00a8;\n            prev\u00ddn\u00a8 = (Pos)(m >= WSIZE ? m-WSIZE : NIL);\n            /* If n is not on any hash chain, prev\u00ddn\u00a8 is garbage but\n             * its value will never be used.\n             */\n        }\n        more += WSIZE;\n    }\n    /* At this point, more >= 2 */\n    if (!eofile) {\n        n = read_buf((char*)window+strstart+lookahead, more);\n        if (n == 0 || n == (unsigned)EOF) {\n            eofile = 1;\n        } else {\n            lookahead += n;\n        }\n    }\n}\n\n/* ===========================================================================\n * Flush the current block, with given end-of-file flag.\n * IN assertion: strstart is set to the end of the current match.\n */\n#define FLUSH_BLOCK(eof) \\\n   flush_block(block_start >= 0L ? (char*)&window\u00dd(unsigned)block_start\u00a8 : \\\n                (char*)NULL, (long)strstart - block_start, (eof))\n\n/* ===========================================================================\n * Processes a new input file and return its compressed length. This\n * function does not perform lazy evaluationof matches and inserts\n * new strings in the dictionary only for unmatched strings. It is used\n * only for the fast compression options.\n */\nlocal ulg deflate_fast()\n{\n    IPos hash_head; /* head of the hash chain */\n    int flush;      /* set if current block must be flushed */\n    unsigned match_length = 0;  /* length of best match */\n\n    prev_length = MIN_MATCH-1;\n    while (lookahead != 0) {\n        /* Insert the string window\u00ddstrstart .. strstart+2\u00a8 in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        INSERT_STRING(strstart, hash_head);\n\n        /* Find the longest match, discarding those <= prev_length.\n         * At this point we have always match_length < MIN_MATCH\n         */\n        if (hash_head != NIL && strstart - hash_head <= MAX_DIST) {\n            /* To simplify the code, we prevent matches with the string\n             * of window index 0 (in particular we have to avoid a match\n             * of the string with itself at the start of the input file).\n             */\n            match_length = longest_match (hash_head);\n            /* longest_match() sets match_start */\n            if (match_length > lookahead) match_length = lookahead;\n        }\n        if (match_length >= MIN_MATCH) {\n            check_match(strstart, match_start, match_length);\n\n            flush = ct_tally(strstart-match_start, match_length - MIN_MATCH);\n\n            lookahead -= match_length;\n\n            /* Insert new strings in the hash table only if the match length\n             * is not too large. This saves time but degrades compression.\n             */\n            if (match_length <= max_insert_length) {\n                match_length--; /* string at strstart already in hash table */\n                do {\n                    strstart++;\n                    INSERT_STRING(strstart, hash_head);\n                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n                     * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\n                     * these bytes are garbage, but it does not matter since\n                     * the next lookahead bytes will be emitted as literals.\n                     */\n                } while (--match_length != 0);\n                strstart++;\n            } else {\n                strstart += match_length;\n                match_length = 0;\n                ins_h = window\u00ddstrstart\u00a8;\n                UPDATE_HASH(ins_h, window\u00ddstrstart+1\u00a8);\n#if MIN_MATCH != 3\n                Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n            }\n        } else {\n            /* No match, output a literal byte */\n            Tracevv((stderr,\"%c\",window\u00ddstrstart\u00a8));\n            flush = ct_tally (0, window\u00ddstrstart\u00a8);\n            lookahead--;\n            strstart++;\n        }\n        if (flush) FLUSH_BLOCK(0), block_start = strstart;\n\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        while (lookahead < MIN_LOOKAHEAD && !eofile) fill_window();\n\n    }\n    return FLUSH_BLOCK(1); /* eof */\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nulg deflate()\n{\n    IPos hash_head;          /* head of hash chain */\n    IPos prev_match;         /* previous match */\n    int flush;               /* set if current block must be flushed */\n    int match_available = 0; /* set if previous match exists */\n    register unsigned match_length = MIN_MATCH-1; /* length of best match */\n#ifdef DEBUG\n    extern long isize;        /* byte length of input file, for debug only */\n#endif\n\n    if (compr_level <= 3) return deflate_fast(); /* optimized for speed */\n\n    /* Process the input block. */\n    while (lookahead != 0) {\n        /* Insert the string window\u00ddstrstart .. strstart+2\u00a8 in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        INSERT_STRING(strstart, hash_head);\n\n        /* Find the longest match, discarding those <= prev_length.\n         */\n        prev_length = match_length, prev_match = match_start;\n        match_length = MIN_MATCH-1;\n\n        if (hash_head != NIL && prev_length < max_lazy_match &&\n            strstart - hash_head <= MAX_DIST) {\n            /* To simplify the code, we prevent matches with the string\n             * of window index 0 (in particular we have to avoid a match\n             * of the string with itself at the start of the input file).\n             */\n            match_length = longest_match (hash_head);\n            /* longest_match() sets match_start */\n            if (match_length > lookahead) match_length = lookahead;\n\n            /* Ignore a length 3 match if it is too distant: */\n            if (match_length == MIN_MATCH && strstart-match_start > TOO_FAR){\n                /* If prev_match is also MIN_MATCH, match_start is garbage\n                 * but we will ignore the current match anyway.\n                 */\n                match_length--;\n            }\n        }\n        /* If there was a match at the previous step and the current\n         * match is not better, output the previous match:\n         */\n        if (prev_length >= MIN_MATCH && match_length <= prev_length) {\n\n            check_match(strstart-1, prev_match, prev_length);\n\n            flush = ct_tally(strstart-1-prev_match, prev_length - MIN_MATCH);\n\n            /* Insert in hash table all strings up to the end of the match.\n             * strstart-1 and strstart are already inserted.\n             */\n            lookahead -= prev_length-1;\n            prev_length -= 2;\n            do {\n                strstart++;\n                INSERT_STRING(strstart, hash_head);\n                /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n                 * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\n                 * these bytes are garbage, but it does not matter since the\n                 * next lookahead bytes will always be emitted as literals.\n                 */\n            } while (--prev_length != 0);\n            match_available = 0;\n            match_length = MIN_MATCH-1;\n            strstart++;\n            if (flush) FLUSH_BLOCK(0), block_start = strstart;\n\n        } else if (match_available) {\n            /* If there was no match at the previous position, output a\n             * single literal. If there was a match but the current match\n             * is longer, truncate the previous match to a single literal.\n             */\n            Tracevv((stderr,\"%c\",window\u00ddstrstart-1\u00a8));\n            if (ct_tally (0, window\u00ddstrstart-1\u00a8)) {\n                FLUSH_BLOCK(0), block_start = strstart;\n            }\n            strstart++;\n            lookahead--;\n        } else {\n            /* There is no previous match to compare with, wait for\n             * the next step to decide.\n             */\n            match_available = 1;\n            strstart++;\n            lookahead--;\n        }\n        Assert (strstart <= isize && lookahead <= isize, \"a bit too far\");\n\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        while (lookahead < MIN_LOOKAHEAD && !eofile) fill_window();\n    }\n    if (match_available) ct_tally (0, window\u00ddstrstart-1\u00a8);\n\n    return FLUSH_BLOCK(1); /* eof */\n}\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DYNWTO": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x13\\x9f\\x00\\x98\\x13\\x9f\\x138\\x00\\x06\\x00\\x06\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-05-19T00:00:00", "modifydate": "1998-05-19T13:38:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "XSSGSCH"}, "text": "#pragma linkage(dynwto,OS)\nvoid dynwto(int, char *);\nmain()\n{\n dynwto(10,\"something\");\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "DYNWTOA": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x13\\x9f\\x00\\x98\\x13\\x9f\\x139\\x00\\x17\\x00\\x17\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-05-19T00:00:00", "modifydate": "1998-05-19T13:39:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "XSSGSCH"}, "text": "DYNWTO   CSECT\nDYNWTO   AMODE 31\nDYNWTO   RMODE ANY\n         PRINT GEN\n         EDCPRLG                    ALWAYS INCLUDE C PROLOG\n         L     6,=A(ACTMSG)         OVERLAY SVC35.ACTMSG WITH DYN MSG\n         LA    7,76                 LEN(MSG TO BE WTOED) - SET MAX 76\n         L     5,0(,1)              PARM1 IS LENGTH OF DYNAMIC MSG\n         L     5,0(,5)\n         O     5,=X'40000000'       1ST BYTE - PAD CHAR (BLANK)\n         L     4,4(,1)              PARM2 IS DYNAMIC MSG ADDRESS\n         MVCL  6,4                  COPY DYN MSG TO SVC35 STRUCT\n         CNOP  0,4\n         BAL   1,BARNDMSG           BRANCH AROUND SVC35 STRUCT\n         DC    AL2(80)              TEXT LENGTH (76+4)\n         DC    B'1000000000000000'  MCSFLAGS\nACTMSG   DC    CL76' '              ARBITRARY SIZE OF 76\n         DC    B'0000000000000000'  DESCRIPTOR CODES\n         DC    B'0100000000000000'  ROUTING CODES\nBARNDMSG DS    0H\n         SVC   35                   ISSUE SVC 35\n         EDCEPIL\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GETOPT": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x98\\x12\\x7f\\x00\\x98\\x12\\x7f\\x17)\\x02\\xf6\\x02\\xf2\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-05-07T00:00:00", "modifydate": "1998-05-07T17:29:00", "lines": 758, "newlines": 754, "modlines": 0, "user": "XSSGSCH"}, "text": "??=ifdef MVS    //* RS\n   ??=pragma filetag(\"IBM-1047\")  //* RS\n??=endif                          //* RS\n/* Getopt for GNU.\n   NOTE: getopt is now part of the C library, so if you don't know what\n   \"Keep this file name-space clean\" means, talk to roland@gnu.ai.mit.edu\n   before changing it!\n\n   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993\n        Free Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by the\n   Free Software Foundation; either version 2, or (at your option) any\n   later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#if !defined(__STDC__) && !defined(const)\n#define const\n#endif\n\n/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */\n#ifndef _NO_PROTO\n#define _NO_PROTO\n#endif\n\n#include <stdio.h>\n#include \"tailor.h\"\n\n/* Comment out all this code if we are using the GNU C Library, and are not\n   actually compiling the library itself.  This code is part of the GNU C\n   Library, but also included in many other GNU distributions.  Compiling\n   and linking in this code is a waste when using the GNU C library\n   (especially if it is a shared library).  Rather than having every GNU\n   program understand `configure --with-gnu-libc' and omit the object files,\n   it is simpler to just do this in the source for each such file.  */\n\n#if defined (_LIBC) || !defined (__GNU_LIBRARY__)\n\n\n/* This needs to come after some library #include\n   to get __GNU_LIBRARY__ defined.  */\n#ifdef  __GNU_LIBRARY__\n/* Don't include stdlib.h for non-GNU C libraries because some of them\n   contain conflicting prototypes for getopt.  */\n#include <stdlib.h>\n#endif  /* GNU C library.  */\n\n/* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a\n   long-named option.  Because this is not POSIX.2 compliant, it is\n   being phased out.  */\n/* #define GETOPT_COMPAT */\n\n/* This version of `getopt' appears to the caller like standard Unix `getopt'\n   but it behaves differently for the user, since it allows the user\n   to intersperse the options with the other arguments.\n\n   As `getopt' works, it permutes the elements of ARGV so that,\n   when it is done, all the options precede everything else.  Thus\n   all application programs are extended to handle flexible argument order.\n\n   Setting the environment variable POSIXLY_CORRECT disables permutation.\n   Then the behavior is completely standard.\n\n   GNU application programs can use a third alternative mode in which\n   they can distinguish the relative order of options and other arguments.  */\n\n#include \"getopt.h\"\n\n/* For communication from `getopt' to the caller.\n   When `getopt' finds an option that takes an argument,\n   the argument value is returned here.\n   Also, when `ordering' is RETURN_IN_ORDER,\n   each non-option ARGV-element is returned here.  */\n\nchar *optarg = 0;\n\n/* Index in ARGV of the next element to be scanned.\n   This is used for communication to and from the caller\n   and for communication between successive calls to `getopt'.\n\n   On entry to `getopt', zero means this is the first call; initialize.\n\n   When `getopt' returns EOF, this is the index of the first of the\n   non-option elements that the caller should itself scan.\n\n   Otherwise, `optind' communicates from one call to the next\n   how much of ARGV has been scanned so far.  */\n\n/* XXX 1003.2 says this must be 1 before any call.  */\nint optind = 0;\n\n/* The next char to be scanned in the option-element\n   in which the last option character we returned was found.\n   This allows us to pick up the scan where we left off.\n\n   If this is zero, or a null string, it means resume the scan\n   by advancing to the next ARGV-element.  */\n\nstatic char *nextchar;\n\n/* Callers store zero here to inhibit the error message\n   for unrecognized options.  */\n\nint opterr = 1;\n\n/* Set to an option character which was unrecognized.\n   This must be initialized on some systems to avoid linking in the\n   system's own getopt implementation.  */\n\nint optopt = '?';\n\n/* Describe how to deal with options that follow non-option ARGV-elements.\n\n   If the caller did not specify anything,\n   the default is REQUIRE_ORDER if the environment variable\n   POSIXLY_CORRECT is defined, PERMUTE otherwise.\n\n   REQUIRE_ORDER means don't recognize them as options;\n   stop option processing when the first non-option is seen.\n   This is what Unix does.\n   This mode of operation is selected by either setting the environment\n   variable POSIXLY_CORRECT, or using `+' as the first character\n   of the list of option characters.\n\n   PERMUTE is the default.  We permute the contents of ARGV as we scan,\n   so that eventually all the non-options are at the end.  This allows options\n   to be given in any order, even with programs that were not written to\n   expect this.\n\n   RETURN_IN_ORDER is an option available to programs that were written\n   to expect options and other ARGV-elements in any order and that care about\n   the ordering of the two.  We describe each non-option ARGV-element\n   as if it were the argument of an option with character code 1.\n   Using `-' as the first character of the list of option characters\n   selects this mode of operation.\n\n   The special argument `--' forces an end of option-scanning regardless\n   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only\n   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */\n\nstatic enum\n{\n  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER\n} ordering;\n\n#ifdef  __GNU_LIBRARY__\n/* We want to avoid inclusion of string.h with non-GNU libraries\n   because there are many ways it can cause trouble.\n   On some systems, it contains special magic macros that don't work\n   in GCC.  */\n#include <string.h>\n#define my_index        strchr\n#define my_strlen       strlen\n#else\n\n/* Avoid depending on library functions or files\n   whose names are inconsistent.  */\n\n#if __STDC__ || defined(PROTO)\nextern char *getenv(const char *name);\nextern int  strcmp (const char *s1, const char *s2);\nextern int  strncmp(const char *s1, const char *s2, int n);\n\nstatic int my_strlen(const char *s);\nstatic char *my_index (const char *str, int chr);\n#else\nextern char *getenv ();\n#endif\n\n#ifdef MVS   //* RS\nstatic int my_strlen (char *str) //* RS\n#else        //* RS\nstatic int\nmy_strlen (str),\n     const char *str;\n#endif       //* RS\n{\n  int n = 0;\n  while (*str++)\n    n++;\n  return n;\n}\n\nstatic char *\nmy_index (str, chr)\n     const char *str;\n     int chr;\n{\n  while (*str)\n    {\n      if (*str == chr)\n        return (char *) str;\n      str++;\n    }\n  return 0;\n}\n\n#endif                          /* GNU C library.  */\n\n/* Handle permutation of arguments.  */\n\n/* Describe the part of ARGV that contains non-options that have\n   been skipped.  `first_nonopt' is the index in ARGV of the first of them;\n   `last_nonopt' is the index after the last of them.  */\n\nstatic int first_nonopt;\nstatic int last_nonopt;\n\n/* Exchange two adjacent subsequences of ARGV.\n   One subsequence is elements \u00ddfirst_nonopt,last_nonopt)\n   which contains all the non-options that have been skipped so far.\n   The other is elements \u00ddlast_nonopt,optind), which contains all\n   the options processed since those non-options were skipped.\n\n   `first_nonopt' and `last_nonopt' are relocated so that they describe\n   the new indices of the non-options in ARGV after they are moved.\n\n   To perform the swap, we first reverse the order of all elements. So\n   all options now come before all non options, but they are in the\n   wrong order. So we put back the options and non options in original\n   order by reversing them again. For example:\n       original input:      a b c -x -y\n       reverse all:         -y -x c b a\n       reverse options:     -x -y c b a\n       reverse non options: -x -y a b c\n*/\n\n#if __STDC__ || defined(PROTO)\nstatic void exchange (char **argv);\n#endif\n\nstatic void\nexchange (argv)\n     char **argv;\n{\n  char *temp, **first, **last;\n\n  /* Reverse all the elements \u00ddfirst_nonopt, optind) */\n  first = &argv\u00ddfirst_nonopt\u00a8;\n  last  = &argv\u00ddoptind-1\u00a8;\n  while (first < last)\n    temp = *first, *first = *last, *last = temp, first++, last--;\n\n  /* Put back the options in order */\n  first = &argv\u00ddfirst_nonopt\u00a8;\n  first_nonopt += (optind - last_nonopt);\n  last  = &argv\u00ddfirst_nonopt - 1\u00a8;\n  while (first < last)\n    temp = *first, *first = *last, *last = temp, first++, last--;\n\n  /* Put back the non options in order */\n  first = &argv\u00ddfirst_nonopt\u00a8;\n  last_nonopt = optind;\n  last  = &argv\u00ddlast_nonopt-1\u00a8;\n  while (first < last)\n    temp = *first, *first = *last, *last = temp, first++, last--;\n}\n\n/* Scan elements of ARGV (whose length is ARGC) for option characters\n   given in OPTSTRING.\n\n   If an element of ARGV starts with '-', and is not exactly \"-\" or \"--\",\n   then it is an option element.  The characters of this element\n   (aside from the initial '-') are option characters.  If `getopt'\n   is called repeatedly, it returns successively each of the option characters\n   from each of the option elements.\n\n   If `getopt' finds another option character, it returns that character,\n   updating `optind' and `nextchar' so that the next call to `getopt' can\n   resume the scan with the following option character or ARGV-element.\n\n   If there are no more option characters, `getopt' returns `EOF'.\n   Then `optind' is the index in ARGV of the first ARGV-element\n   that is not an option.  (The ARGV-elements have been permuted\n   so that those that are not options now come last.)\n\n   OPTSTRING is a string containing the legitimate option characters.\n   If an option character is seen that is not listed in OPTSTRING,\n   return '?' after printing an error message.  If you set `opterr' to\n   zero, the error message is suppressed but we still return '?'.\n\n   If a char in OPTSTRING is followed by a colon, that means it wants an arg,\n   so the following text in the same ARGV-element, or the text of the following\n   ARGV-element, is returned in `optarg'.  Two colons mean an option that\n   wants an optional arg; if there is text in the current ARGV-element,\n   it is returned in `optarg', otherwise `optarg' is set to zero.\n\n   If OPTSTRING starts with `-' or `+', it requests different methods of\n   handling the non-option ARGV-elements.\n   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.\n\n   Long-named options begin with `--' instead of `-'.\n   Their names may be abbreviated as long as the abbreviation is unique\n   or is an exact match for some defined option.  If they have an\n   argument, it follows the option name in the same ARGV-element, separated\n   from the option name by a `=', or else the in next ARGV-element.\n   When `getopt' finds a long-named option, it returns 0 if that option's\n   `flag' field is nonzero, the value of the option's `val' field\n   if the `flag' field is zero.\n\n   The elements of ARGV aren't really const, because we permute them.\n   But we pretend they're const in the prototype to be compatible\n   with other systems.\n\n   LONGOPTS is a vector of `struct option' terminated by an\n   element containing a name which is zero.\n\n   LONGIND returns the index in LONGOPT of the long-named option found.\n   It is only valid when a long-named option has been found by the most\n   recent call.\n\n   If LONG_ONLY is nonzero, '-' as well as '--' can introduce\n   long-named options.  */\n\nint\n_getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n     int argc;\n     char *const *argv;\n     const char *optstring;\n     const struct option *longopts;\n     int *longind;\n     int long_only;\n{\n  int option_index;\n\n  optarg = 0;\n\n  /* Initialize the internal data when the first call is made.\n     Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n\n  if (optind == 0)\n    {\n      first_nonopt = last_nonopt = optind = 1;\n\n      nextchar = NULL;\n\n      /* Determine how to handle the ordering of options and nonoptions.  */\n\n      if (optstring\u00dd0\u00a8 == '-')\n        {\n          ordering = RETURN_IN_ORDER;\n          ++optstring;\n        }\n      else if (optstring\u00dd0\u00a8 == '+')\n        {\n          ordering = REQUIRE_ORDER;\n          ++optstring;\n        }\n      else if (getenv (\"POSIXLY_CORRECT\") != NULL)\n        ordering = REQUIRE_ORDER;\n      else\n        ordering = PERMUTE;\n    }\n\n  if (nextchar == NULL || *nextchar == '\\0')\n    {\n      if (ordering == PERMUTE)\n        {\n          /* If we have just processed some options following some non-options,\n             exchange them so that the options come first.  */\n\n          if (first_nonopt != last_nonopt && last_nonopt != optind)\n            exchange ((char **) argv);\n          else if (last_nonopt != optind)\n            first_nonopt = optind;\n\n          /* Now skip any additional non-options\n             and extend the range of non-options previously skipped.  */\n\n          while (optind < argc\n                 && (argv\u00ddoptind\u00a8\u00dd0\u00a8 != '-' || argv\u00ddoptind\u00a8\u00dd1\u00a8 == '\\0')\n#ifdef GETOPT_COMPAT\n                 && (longopts == NULL\n                     || argv\u00ddoptind\u00a8\u00dd0\u00a8 != '+' || argv\u00ddoptind\u00a8\u00dd1\u00a8 == '\\0')\n#endif                          /* GETOPT_COMPAT */\n                 )\n            optind++;\n          last_nonopt = optind;\n        }\n\n      /* Special ARGV-element `--' means premature end of options.\n         Skip it like a null option,\n         then exchange with previous non-options as if it were an option,\n         then skip everything else like a non-option.  */\n\n      if (optind != argc && !strcmp (argv\u00ddoptind\u00a8, \"--\"))\n        {\n          optind++;\n\n          if (first_nonopt != last_nonopt && last_nonopt != optind)\n            exchange ((char **) argv);\n          else if (first_nonopt == last_nonopt)\n            first_nonopt = optind;\n          last_nonopt = argc;\n\n          optind = argc;\n        }\n\n      /* If we have done all the ARGV-elements, stop the scan\n         and back over any non-options that we skipped and permuted.  */\n\n      if (optind == argc)\n        {\n          /* Set the next-arg-index to point at the non-options\n             that we previously skipped, so the caller will digest them.  */\n          if (first_nonopt != last_nonopt)\n            optind = first_nonopt;\n          return EOF;\n        }\n\n      /* If we have come to a non-option and did not permute it,\n         either stop the scan or describe it to the caller and pass it by.  */\n\n      if ((argv\u00ddoptind\u00a8\u00dd0\u00a8 != '-' || argv\u00ddoptind\u00a8\u00dd1\u00a8 == '\\0')\n#ifdef GETOPT_COMPAT\n          && (longopts == NULL\n              || argv\u00ddoptind\u00a8\u00dd0\u00a8 != '+' || argv\u00ddoptind\u00a8\u00dd1\u00a8 == '\\0')\n#endif                          /* GETOPT_COMPAT */\n          )\n        {\n          if (ordering == REQUIRE_ORDER)\n            return EOF;\n          optarg = argv\u00ddoptind++\u00a8;\n          return 1;\n        }\n\n      /* We have found another option-ARGV-element.\n         Start decoding its characters.  */\n\n      nextchar = (argv\u00ddoptind\u00a8 + 1\n                  + (longopts != NULL && argv\u00ddoptind\u00a8\u00dd1\u00a8 == '-'));\n    }\n\n  if (longopts != NULL\n      && ((argv\u00ddoptind\u00a8\u00dd0\u00a8 == '-'\n           && (argv\u00ddoptind\u00a8\u00dd1\u00a8 == '-' || long_only))\n#ifdef GETOPT_COMPAT\n          || argv\u00ddoptind\u00a8\u00dd0\u00a8 == '+'\n#endif                          /* GETOPT_COMPAT */\n          ))\n    {\n      const struct option *p;\n      char *s = nextchar;\n      int exact = 0;\n      int ambig = 0;\n      const struct option *pfound = NULL;\n      int indfound = 0;\n\n      while (*s && *s != '=')\n        s++;\n\n      /* Test all options for either exact match or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name;\n           p++, option_index++)\n        if (!strncmp (p->name, nextchar, s - nextchar))\n          {\n            if (s - nextchar == my_strlen (p->name))\n              {\n                /* Exact match found.  */\n                pfound = p;\n                indfound = option_index;\n                exact = 1;\n                break;\n              }\n            else if (pfound == NULL)\n              {\n                /* First nonexact match found.  */\n                pfound = p;\n                indfound = option_index;\n              }\n            else\n              /* Second nonexact match found.  */\n              ambig = 1;\n          }\n\n      if (ambig && !exact)\n        {\n          if (opterr)\n            fprintf (stderr, \"%s: option `%s' is ambiguous\\n\",\n                     argv\u00dd0\u00a8, argv\u00ddoptind\u00a8);\n          nextchar += my_strlen (nextchar);\n          optind++;\n          return '?';\n        }\n\n      if (pfound != NULL)\n        {\n          option_index = indfound;\n          optind++;\n          if (*s)\n            {\n              /* Don't test has_arg with >, because some C compilers don't\n                 allow it to be used on enums.  */\n              if (pfound->has_arg)\n                optarg = s + 1;\n              else\n                {\n                  if (opterr)\n                    {\n                      if (argv\u00ddoptind - 1\u00a8\u00dd1\u00a8 == '-')\n                        /* --option */\n                        fprintf (stderr,\n                                \"%s: option `--%s' doesn't allow an argument\\n\",\n                                 argv\u00dd0\u00a8, pfound->name);\n                      else\n                        /* +option or -option */\n                        fprintf (stderr,\n                             \"%s: option `%c%s' doesn't allow an argument\\n\",\n                             argv\u00dd0\u00a8, argv\u00ddoptind - 1\u00a8\u00dd0\u00a8, pfound->name);\n                    }\n                  nextchar += my_strlen (nextchar);\n                  return '?';\n                }\n            }\n          else if (pfound->has_arg == 1)\n            {\n              if (optind < argc)\n                optarg = argv\u00ddoptind++\u00a8;\n              else\n                {\n                  if (opterr)\n                    fprintf (stderr, \"%s: option `%s' requires an argument\\n\",\n                             argv\u00dd0\u00a8, argv\u00ddoptind - 1\u00a8);\n                  nextchar += my_strlen (nextchar);\n                  return optstring\u00dd0\u00a8 == ':' ? ':' : '?';\n                }\n            }\n          nextchar += my_strlen (nextchar);\n          if (longind != NULL)\n            *longind = option_index;\n          if (pfound->flag)\n            {\n              *(pfound->flag) = pfound->val;\n              return 0;\n            }\n          return pfound->val;\n        }\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n         or the option starts with '--' or is not a valid short\n         option, then it's an error.\n         Otherwise interpret it as a short option.  */\n      if (!long_only || argv\u00ddoptind\u00a8\u00dd1\u00a8 == '-'\n#ifdef GETOPT_COMPAT\n          || argv\u00ddoptind\u00a8\u00dd0\u00a8 == '+'\n#endif                          /* GETOPT_COMPAT */\n          || my_index (optstring, *nextchar) == NULL)\n        {\n          if (opterr)\n            {\n              if (argv\u00ddoptind\u00a8\u00dd1\u00a8 == '-')\n                /* --option */\n                fprintf (stderr, \"%s: unrecognized option `--%s'\\n\",\n                         argv\u00dd0\u00a8, nextchar);\n              else\n                /* +option or -option */\n                fprintf (stderr, \"%s: unrecognized option `%c%s'\\n\",\n                         argv\u00dd0\u00a8, argv\u00ddoptind\u00a8\u00dd0\u00a8, nextchar);\n            }\n          nextchar = (char *) \"\";\n          optind++;\n          return '?';\n        }\n    }\n\n  /* Look at and handle the next option-character.  */\n\n  {\n    char c = *nextchar++;\n    char *temp = my_index (optstring, c);\n\n    /* Increment `optind' when we start to process its last character.  */\n    if (*nextchar == '\\0')\n      ++optind;\n\n    if (temp == NULL || c == ':')\n      {\n        if (opterr)\n          {\n#if 0\n            if (c < 040 || c >= 0177)\n              fprintf (stderr, \"%s: unrecognized option, character code 0%o\\n\",\n                       argv\u00dd0\u00a8, c);\n            else\n              fprintf (stderr, \"%s: unrecognized option `-%c'\\n\", argv\u00dd0\u00a8, c);\n#else\n            /* 1003.2 specifies the format of this message.  */\n            fprintf (stderr, \"%s: illegal option -- %c\\n\", argv\u00dd0\u00a8, c);\n#endif\n          }\n        optopt = c;\n        return '?';\n      }\n    if (temp\u00dd1\u00a8 == ':')\n      {\n        if (temp\u00dd2\u00a8 == ':')\n          {\n            /* This is an option that accepts an argument optionally.  */\n            if (*nextchar != '\\0')\n              {\n                optarg = nextchar;\n                optind++;\n              }\n            else\n              optarg = 0;\n            nextchar = NULL;\n          }\n        else\n          {\n            /* This is an option that requires an argument.  */\n            if (*nextchar != '\\0')\n              {\n                optarg = nextchar;\n                /* If we end this ARGV-element by taking the rest as an arg,\n                   we must advance to the next element now.  */\n                optind++;\n              }\n            else if (optind == argc)\n              {\n                if (opterr)\n                  {\n#if 0\n                    fprintf (stderr, \"%s: option `-%c' requires an argument\\n\",\n                             argv\u00dd0\u00a8, c);\n#else\n                    /* 1003.2 specifies the format of this message.  */\n                    fprintf (stderr, \"%s: option requires an argument -- %c\\n\",\n                             argv\u00dd0\u00a8, c);\n#endif\n                  }\n                optopt = c;\n                if (optstring\u00dd0\u00a8 == ':')\n                  c = ':';\n                else\n                  c = '?';\n              }\n            else\n              /* We already incremented `optind' once;\n                 increment it again when taking next ARGV-elt as argument.  */\n              optarg = argv\u00ddoptind++\u00a8;\n            nextchar = NULL;\n          }\n      }\n    return c;\n  }\n}\n\nint\ngetopt (argc, argv, optstring)\n     int argc;\n     char *const *argv;\n     const char *optstring;\n{\n  return _getopt_internal (argc, argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0);\n}\n\nint\ngetopt_long (argc, argv, options, long_options, opt_index)\n     int argc;\n     char *const *argv;\n     const char *options;\n     const struct option *long_options;\n     int *opt_index;\n{\n  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);\n}\n\n#endif  /* _LIBC or not __GNU_LIBRARY__.  */\n\n#ifdef TEST\n\n/* Compile with -DTEST to make an executable for use in testing\n   the above definition of `getopt'.  */\n\nint\nmain (argc, argv)\n     int argc;\n     char **argv;\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == EOF)\n        break;\n\n      switch (c)\n        {\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value `%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv\u00ddoptind++\u00a8);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}\n\n#endif /* TEST */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GOGZIP": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x98\\x11/\\x00\\x98\\x14o\\x189\\x003\\x00\\x0c\\x00\\x00\\xd9\\xd6\\xd3\\xc1\\xd5\\xc4\\xe2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1998-04-22T00:00:00", "modifydate": "1998-05-26T18:39:00", "lines": 51, "newlines": 12, "modlines": 0, "user": "ROLANDS"}, "text": "//ROLANDSG JOB (SR015695),'SCHIRADIN, ROLAND',\n//             CLASS=X,MSGCLASS=T,MSGLEVEL=(1,1),\n//*\n//* Some sample JCL how to invoke GZIP\n//* If you use DD:.. the DD-Name OUTPUT is hardcoded and\n//* can not be changed!\n//*\n//             NOTIFY=&SYSUID\n//DEL     EXEC PGM=IDCAMS\n//SYSIN     DD *\n  DEL 'ROLANDS.PRIVATE.PS80.GZ' NONVSAM\n//SYSPRINT  DD SYSOUT=*\n//*\n//* STEP1 PACK FILE with DD-Name INPUT to DD-Name OUTPUT\n//*\n//STEP1   EXEC PGM=GZIP,REGION=0M,\n//             PARM='DD:INPUT -v'\n//*PARM='TEST(ALL,,PROMPT,\"VADTCPIP&148.251.22.159%8000:*\")/DD:INP -d'\n//*            PARM='DD:INP -va'\n//*O      EXEC PGM=GZIP,REGION=0M,\n//STEPLIB   DD DISP=SHR,DSN=ROLANDS.GZIP.LOAD\n//INPUT     DD DISP=SHR,DSN=ROLANDS.PRIVATE.PS80\n//OUTPUT    DD DISP=(,CATLG),DSN=ROLANDS.PRIVATE.PS80.GZ,\n//             LIKE=ROLANDS.PRIVATE.PS80\n//SYSUDUMP  DD SYSOUT=*\n//SYSTERM   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//*\n//* STEP2 PACK FILE with DD-Name INP to DD-Name OUTPUT\n//*       and start the remote C-Debuuger on 148.251.22.159 Port 8000\n//*\n//STEP2   EXEC PGM=GZIP,REGION=0M,\n// PARM='TEST(ALL,,PROMPT,\"VADTCPIP&148.251.22.159%8000:*\")/DD:INP -d'\n//STEPLIB   DD DISP=SHR,DSN=ROLANDS.GZIP.LOAD\n//INP       DD DISP=SHR,DSN=ROLANDS.PRIVATE.PS80\n//OUTPUT    DD DISP=(,CATLG),DSN=ROLANDS.PRIVATE.PS80.GZ,\n//             LIKE=ROLANDS.PRIVATE.PS80\n//SYSUDUMP  DD SYSOUT=*\n//SYSTERM   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//*\n//* STEP3 PACK FILE with DSN \"ROLANDS.PRIVATE.PS80' to\n//*       \"ROLANDS.PROVATE.PS80.GZ\". Allocation will be done\n//*       by SVC99. This SVC99 use a standard DCB, maybe\n//*       not enough for your needs.\n//STEP3   EXEC PGM=GZIP,REGION=0M,\n//             PARM='private.ps80 -v'\n//STEPLIB   DD DISP=SHR,DSN=ROLANDS.GZIP.LOAD\n//SYSUDUMP  DD SYSOUT=*\n//SYSTERM   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GZIP": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x98\\x12\\x7f\\x00\\x98\\x14\\x0f\\x15P\\x06\\xcb\\x06\\xa3\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1998-05-07T00:00:00", "modifydate": "1998-05-20T15:50:00", "lines": 1739, "newlines": 1699, "modlines": 0, "user": "XSSGSCH"}, "text": "??=ifdef MVS    //* RS\n   ??=pragma filetag(\"IBM-1047\")  //* RS\n??=endif                          //* RS\n/* gzip (GNU zip) -- compress files with zip algorithm and 'compress' interface\n * Copyright (C) 1992-1993 Jean-loup Gailly\n * The unzip code was written and put in the public domain by Mark Adler.\n * Portions of the lzw code are derived from the public domain 'compress'\n * written by Spencer Thomas, Joe Orost, James Woods, Jim McKie, Steve Davies,\n * Ken Turkowski, Dave Mack and Peter Jannesen.\n *\n * See the license_msg below and the file COPYING for the software license.\n * See the file algorithm.doc for the compression algorithms and file formats.\n */\n\nstatic char  *license_msg\u00dd\u00a8 = {\n\"   Copyright (C) 1992-1993 Jean-loup Gailly\",\n\"   This program is free software; you can redistribute it and/or modify\",\n\"   it under the terms of the GNU General Public License as published by\",\n\"   the Free Software Foundation; either version 2, or (at your option)\",\n\"   any later version.\",\n\"\",\n\"   This program is distributed in the hope that it will be useful,\",\n\"   but WITHOUT ANY WARRANTY; without even the implied warranty of\",\n\"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\",\n\"   GNU General Public License for more details.\",\n\"\",\n\"   You should have received a copy of the GNU General Public License\",\n\"   along with this program; if not, write to the Free Software\",\n\"   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\",\n0};\n\n/* Compress files with zip algorithm and 'compress' interface.\n * See usage() and help() functions below for all options.\n * Outputs:\n *        file.gz:   compressed file with same mode, owner, and utimes\n *     or stdout with -c option or if stdin used as input.\n * If the output file name had to be truncated, the original name is kept\n * in the compressed file.\n * On MSDOS, file.tmp -> file.tmz. On VMS, file.tmp -> file.tmp-gz.\n *\n * Using gz on MSDOS would create too many file name conflicts. For\n * example, foo.txt -> foo.tgz (.tgz must be reserved as shorthand for\n * tar.gz). Similarly, foo.dir and foo.doc would both be mapped to foo.dgz.\n * I also considered 12345678.txt -> 12345txt.gz but this truncates the name\n * too heavily. There is no ideal solution given the MSDOS 8+3 limitation.\n *\n * For the meaning of all compilation flags, see comments in Makefile.in.\n */\n\n#ifndef lint\nstatic char rcsid\u00dd\u00a8 = \"$Id: gzip.c,v 0.23 1993/06/17 11:40:33 jloup Exp $\";\n#endif\n\n#include <ctype.h>\n#ifndef C370            //* RS\n#include <sys/types.h>  //* RS\n#else                   //* RS\n#include \"c370.h\"       //* RS\n#endif /* C370 */       //* RS\n#include <signal.h>\n#include <sys/stat.h>\n#include <errno.h>\n\n#include \"tailor.h\"\n#include \"gzip.h\"\n#include \"lzw.h\"\n#include \"revision.h\"\n#include \"getopt.h\"\n\n                /* configuration */\n\n#ifdef NO_TIME_H\n#  include <sys/time.h>\n#else\n#  include <time.h>\n#endif\n\n#ifndef NO_FCNTL_H\n#  include <fcntl.h>\n#endif\n\n#ifdef HAVE_UNISTD_H\n#  include <unistd.h>\n#endif\n\n#if defined(STDC_HEADERS) || !defined(NO_STDLIB_H)\n#  include <stdlib.h>\n#else\n   extern int errno;\n#endif\n\n#if defined(DIRENT)\n#  include <dirent.h>\n#  ifdef ARCH\n     typedef struct direct dir_type;\n#  else\n     typedef struct dirent dir_type;\n#  endif\n#  define NLENGTH(dirent) ((int)strlen((dirent)->d_name))\n#  define DIR_OPT \"DIRENT\"\n#else\n#  define NLENGTH(dirent) ((dirent)->d_namlen)\n#  ifdef SYSDIR\n#    include <sys/dir.h>\n     typedef struct direct dir_type;\n#    define DIR_OPT \"SYSDIR\"\n#  else\n#    ifdef SYSNDIR\n#      include <sys/ndir.h>\n       typedef struct direct dir_type;\n#      define DIR_OPT \"SYSNDIR\"\n#    else\n#      ifdef NDIR\n#        include <ndir.h>\n         typedef struct direct dir_type;\n#        define DIR_OPT \"NDIR\"\n#      else\n#        define NO_DIR\n#        define DIR_OPT \"NO_DIR\"\n#      endif\n#    endif\n#  endif\n#endif\n\n#ifndef NO_UTIME\n#  ifndef NO_UTIME_H\n#    include <utime.h>\n#    define TIME_OPT \"UTIME\"\n#  else\n#    ifdef HAVE_SYS_UTIME_H\n#      include <sys/utime.h>\n#      define TIME_OPT \"SYS_UTIME\"\n#    else\n       struct utimbuf {\n         time_t actime;\n         time_t modtime;\n       };\n#      define TIME_OPT \"\"\n#    endif\n#  endif\n#else\n#  define TIME_OPT \"NO_UTIME\"\n#endif\n\n#if !defined(S_ISDIR) && defined(S_IFDIR)\n#  define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)\n#endif\n#if !defined(S_ISREG) && defined(S_IFREG)\n#  define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)\n#endif\n\ntypedef RETSIGTYPE (*sig_type) OF((int));\n\n#ifndef O_BINARY\n#  define  O_BINARY  0  /* creation mode for open() */\n#endif\n\n#ifndef O_CREAT\n   /* Pure BSD system? */\n#  include <sys/file.h>\n#  ifndef O_CREAT\n#    define O_CREAT FCREAT\n#  endif\n#  ifndef O_EXCL\n#    define O_EXCL FEXCL\n#  endif\n#endif\n\n#ifndef S_IRUSR\n#  define S_IRUSR 0400\n#endif\n#ifndef S_IWUSR\n#  define S_IWUSR 0200\n#endif\n#define RW_USER (S_IRUSR | S_IWUSR)  /* creation mode for open() */\n\n#ifndef MAX_PATH_LEN\n#  define MAX_PATH_LEN   1024 /* max pathname length */\n#endif\n\n#ifndef SEEK_END\n#  define SEEK_END 2\n#endif\n\n#ifndef C370                  //* RS\n  #ifdef NO_OFF_T\n    typedef long off_t;\n    off_t lseek OF((int fd, off_t offset, int whence));\n  #endif\n#endif                        //* RS\n\n/* Separator for file name parts (see shorten_name()) */\n#ifdef NO_MULTIPLE_DOTS\n#  define PART_SEP \"-\"\n#else\n#  define PART_SEP \".\"\n#endif\n\n                /* global buffers */\n\nDECLARE(uch, inbuf,  INBUFSIZ +INBUF_EXTRA);\nDECLARE(uch, outbuf, OUTBUFSIZ+OUTBUF_EXTRA);\nDECLARE(ush, d_buf,  DIST_BUFSIZE);\nDECLARE(uch, window, 2L*WSIZE);\n#ifndef MAXSEG_64K\n    DECLARE(ush, tab_prefix, 1L<<BITS);\n#else\n    DECLARE(ush, tab_prefix0, 1L<<(BITS-1));\n    DECLARE(ush, tab_prefix1, 1L<<(BITS-1));\n#endif\n\n                /* local variables */\n\nint ascii = 0;        /* convert end-of-lines to local OS conventions */\nint to_stdout = 0;    /* output to stdout (-c) */\nint decompress = 0;   /* decompress (-d) */\n#ifdef MVS            /* RS                        */\nint dd_names = 0;     /* RS use DD-Names under MVS */\n#endif                /* RS                        */\nint force = 0;        /* don't ask questions, compress links (-f) */\nint no_name = 0;      /* don't save or restore the original file name */\nint recursive = 0;    /* recurse through directories (-r) */\nint list = 0;         /* list the file contents (-l) */\nint verbose = 0;      /* be verbose (-v) */\nint quiet = 0;        /* be very quiet (-q) */\nint do_lzw = 0;       /* generate output compatible with old compress (-Z) */\nint test = 0;         /* test .gz file integrity */\nint foreground;       /* set if program run in foreground */\nchar *progname;       /* program name */\nint maxbits = BITS;   /* max bits per code for LZW */\nint method = DEFLATED;/* compression method */\nint level = 6;        /* compression level */\nint exit_code = OK;   /* program exit code */\nint save_orig_name;   /* set if original name must be saved */\nint last_member;      /* set for .zip and .Z files */\nint part_nb;          /* number of parts in .gz file */\nlong time_stamp;      /* original time stamp (modification time) */\nlong ifile_size;      /* input file size, -1 for devices (debug only) */\nchar *env;            /* contents of GZIP env variable */\nchar **args = NULL;   /* argv pointer if GZIP env variable defined */\nchar z_suffix\u00ddMAX_SUFFIX+1\u00a8; /* default suffix (can be set with --suffix) */\nint  z_len;           /* strlen(z_suffix) */\n\n\nlong bytes_in;             /* number of input bytes */\nlong bytes_out;            /* number of output bytes */\nlong total_in = 0;         /* input bytes for all files */\nlong total_out = 0;        /* output bytes for all files */\nchar ifname\u00ddMAX_PATH_LEN\u00a8; /* input file name */\nchar ofname\u00ddMAX_PATH_LEN\u00a8; /* output file name */\nint  remove_ofname = 0;    /* remove output file on error */\nstruct stat istat;         /* status for input file */\nint  ifd;                  /* input file descriptor */\nint  ofd;                  /* output file descriptor */\nunsigned insize;           /* valid bytes in inbuf */\nunsigned inptr;            /* index of next byte to be processed in inbuf */\nunsigned outcnt;           /* bytes in output buffer */\n\nstruct option longopts\u00dd\u00a8 =\n{\n /* { name  has_arg  *flag  val } */\n    {\"ascii\",      0, 0, 'a'}, /* ascii text mode */\n    {\"to-stdout\",  0, 0, 'c'}, /* write output on standard output */\n    {\"stdout\",     0, 0, 'c'}, /* write output on standard output */\n    {\"decompress\", 0, 0, 'd'}, /* decompress */\n    {\"uncompress\", 0, 0, 'd'}, /* decompress */\n /* {\"encrypt\",    0, 0, 'e'},    encrypt */\n    {\"force\",      0, 0, 'f'}, /* force overwrite of output file */\n    {\"help\",       0, 0, 'h'}, /* give help */\n /* {\"pkzip\",      0, 0, 'k'},    force output in pkzip format */\n    {\"list\",       0, 0, 'l'}, /* list .gz file contents */\n    {\"license\",    0, 0, 'L'}, /* display software license */\n    {\"no-name\",    0, 0, 'n'}, /* don't save or restore the original name */\n    {\"quiet\",      0, 0, 'q'}, /* quiet mode */\n    {\"silent\",     0, 0, 'q'}, /* quiet mode */\n    {\"recurse\",    0, 0, 'r'}, /* recurse through directories */\n    {\"suffix\",     1, 0, 'S'}, /* use given suffix instead of .gz */\n    {\"test\",       0, 0, 't'}, /* test compressed file integrity */\n    {\"verbose\",    0, 0, 'v'}, /* verbose mode */\n    {\"version\",    0, 0, 'V'}, /* display version number */\n    {\"fast\",       0, 0, '1'}, /* compress faster */\n    {\"best\",       0, 0, '9'}, /* compress better */\n    {\"lzw\",        0, 0, 'Z'}, /* make output compatible with old compress */\n    {\"bits\",       1, 0, 'b'}, /* max number of bits per code (implies -Z) */\n    { 0, 0, 0, 0 }\n};\n\n/* local functions */\n\nlocal void usage        OF((void));\nlocal void help         OF((void));\nlocal void license      OF((void));\nlocal void version      OF((void));\nlocal void treat_stdin  OF((void));\nlocal void treat_file   OF((char *iname));\nlocal int create_outfile OF((void));\nlocal int  do_stat      OF((char *name, struct stat *sbuf));\nlocal char *get_suffix  OF((char *name));\nlocal int  get_istat    OF((char *iname, struct stat *sbuf));\nlocal int  make_ofname  OF((void));\nlocal int  same_file    OF((struct stat *stat1, struct stat *stat2));\nlocal int name_too_long OF((char *name, struct stat *statb));\nlocal void shorten_name  OF((char *name));\nlocal int  get_method   OF((int in));\nlocal void do_list      OF((int ifd, int method));\nlocal int  check_ofname OF((void));\nlocal void copy_stat    OF((struct stat *ifstat));\nlocal void do_exit      OF((int exitcode));\n      int main          OF((int argc, char **argv));\nint (*work) OF((int infile, int outfile)) = zip; /* function to call */\n\n#ifndef NO_DIR\nlocal void treat_dir    OF((char *dir));\n#endif\n#ifndef NO_UTIME\nlocal void reset_times  OF((char *name, struct stat *statb));\n#endif\n\n#define strequ(s1, s2) (strcmp((s1),(s2)) == 0)\n\n/* ======================================================================== */\nlocal void usage()\n{\n    fprintf(stderr, \"usage: %s \u00dd-%scdfhlLn%stvV19\u00a8 \u00dd-S suffix\u00a8 \u00ddfile ...\u00a8\\n\",\n            progname,\n#if O_BINARY\n            \"a\",\n#else\n            \"\",\n#endif\n#ifdef NO_DIR\n            \"\"\n#else\n            \"r\"\n#endif\n            );\n}\n\n/* ======================================================================== */\nlocal void help()\n{\n    static char  *help_msg\u00dd\u00a8 = {\n#if O_BINARY\n \" -a --ascii       ascii text; convert end-of-lines using local conventions\",\n#endif\n \" -c --stdout      write on standard output, keep original files unchanged\",\n \" -d --decompress  decompress\",\n/* -e --encrypt     encrypt */\n \" -f --force       force overwrite of output file and compress links\",\n \" -h --help        give this help\",\n/* -k --pkzip       force output in pkzip format */\n \" -l --list        list .gz file contents\",\n \" -L --license     display software license\",\n \" -n --no-name     do not save or restore the original name\",\n \" -q --quiet       suppress all warnings\",\n#ifndef NO_DIR\n \" -r --recurse     recurse through directories\",\n#endif\n#ifdef MAX_EXT_CHARS\n \" -S .suf  --suffix .suf     use suffix .suf instead of .z\",\n#else\n \" -S .suf  --suffix .suf     use suffix .suf instead of .gz\",\n#endif\n \" -t --test        test compressed file integrity\",\n \" -v --verbose     verbose mode\",\n \" -V --version     display version number\",\n \" -1 --fast        compress faster\",\n \" -9 --best        compress better\",\n#ifdef LZW\n \" -Z --lzw         produce output compatible with old compress\",\n \" -b --bits maxbits   max number of bits per code (implies -Z)\",\n#endif\n \" file...          files to (de)compress. If none given, use standard input.\",\n  0};\n    char **p = help_msg;\n\n    fprintf(stderr,\"%s %s (%s)\\n\", progname, VERSION, REVDATE);\n    usage();\n    while (*p) fprintf(stderr, \"%s\\n\", *p++);\n}\n\n/* ======================================================================== */\nlocal void license()\n{\n    char **p = license_msg;\n\n    fprintf(stderr,\"%s %s (%s)\\n\", progname, VERSION, REVDATE);\n    while (*p) fprintf(stderr, \"%s\\n\", *p++);\n}\n\n/* ======================================================================== */\nlocal void version()\n{\n    fprintf(stderr,\"%s %s (%s)\\n\", progname, VERSION, REVDATE);\n\n    fprintf(stderr, \"Compilation options:\\n%s %s \", DIR_OPT, TIME_OPT);\n#ifdef STDC_HEADERS\n    fprintf(stderr, \"STDC_HEADERS \");\n#endif\n#ifdef HAVE_UNISTD_H\n    fprintf(stderr, \"HAVE_UNISTD_H \");\n#endif\n#ifdef NO_MEMORY_H\n    fprintf(stderr, \"NO_MEMORY_H \");\n#endif\n#ifdef NO_STRING_H\n    fprintf(stderr, \"NO_STRING_H \");\n#endif\n#ifdef NO_SYMLINK\n    fprintf(stderr, \"NO_SYMLINK \");\n#endif\n#ifdef NO_MULTIPLE_DOTS\n    fprintf(stderr, \"NO_MULTIPLE_DOTS \");\n#endif\n#ifdef NO_CHOWN\n    fprintf(stderr, \"NO_CHOWN \");\n#endif\n#ifdef PROTO\n    fprintf(stderr, \"PROTO \");\n#endif\n#ifdef ASMV\n    fprintf(stderr, \"ASMV \");\n#endif\n#ifdef DEBUG\n    fprintf(stderr, \"DEBUG \");\n#endif\n#ifdef DYN_ALLOC\n    fprintf(stderr, \"DYN_ALLOC \");\n#endif\n#ifdef MAXSEG_64K\n    fprintf(stderr, \"MAXSEG_64K\");\n#endif\n    fprintf(stderr, \"\\n\");\n}\n\n/* ======================================================================== */\nint main (argc, argv)\n    int argc;\n    char **argv;\n{\n    int file_count = 0; /* number of files to precess */\n    int proglen;        /* length of progname */\n    int optc;           /* current option */\n\n    EXPAND(argc, argv); /* wild card expansion if necessary */\n\n    progname = basename(argv\u00dd0\u00a8);\n    proglen = strlen(progname);\n\n    /* Suppress .exe for MSDOS, OS/2 and VMS: */\n    if (proglen > 4 && strequ(progname+proglen-4, \".exe\")) {\n        progname\u00ddproglen-4\u00a8 = '\\0';\n    }\n\n    /* Add options in GZIP environment variable if there is one */\n    env = add_envopt(&argc, &argv, OPTIONS_VAR);\n    if (env != NULL) args = argv;\n\n    foreground = signal(SIGINT, SIG_IGN) != SIG_IGN;\n    if (foreground) {\n        signal (SIGINT, (sig_type)abort_gzip);\n    }\n#ifdef SIGTERM\n    signal(SIGTERM, (sig_type)abort_gzip);\n#endif\n#ifdef SIGHUP\n    signal(SIGHUP,  (sig_type)abort_gzip);\n#endif\n\n#ifndef GNU_STANDARD\n    /* For compatibility with old compress, use program name as an option.\n     * If you compile with -DGNU_STANDARD, this program will behave as\n     * gzip even if it is invoked under the name gunzip or zcat.\n     *\n     * Systems which do not support links can still use -d or -dc.\n     * Ignore an .exe extension for MSDOS, OS/2 and VMS.\n     */\n    if (  strncmp(progname, \"un\",  2) == 0     /* ungzip, uncompress */\n       || strncmp(progname, \"gun\", 3) == 0) {  /* gunzip */\n        decompress = 1;\n    } else if (strequ(progname+1, \"cat\")       /* zcat, pcat, gcat */\n            || strequ(progname, \"gzcat\")) {    /* gzcat */\n        decompress = to_stdout = 1;\n    }\n#endif\n\n    strncpy(z_suffix, Z_SUFFIX, sizeof(z_suffix)-1);\n    z_len = strlen(z_suffix);\n\n    while ((optc = getopt_long (argc, argv, \"ab:cdfhlLnqrS:tvVZ123456789\",\n                                longopts, (int *)0)) != EOF) {\n        switch (optc) {\n        case 'a':\n            ascii = 1; break;\n        case 'b':\n            maxbits = atoi(optarg);\n            break;\n        case 'c':\n            to_stdout = 1; break;\n        case 'd':\n            decompress = 1; break;\n        case 'f':\n            force++; break;\n        case 'h': case 'H': case '?':\n            help(); do_exit(OK); break;\n        case 'l':\n            list = decompress = to_stdout = 1; break;\n        case 'L':\n            license(); do_exit(OK); break;\n        case 'n':\n            no_name = 1; break;\n        case 'q':\n            quiet = 1; verbose = 0; break;\n        case 'r':\n#ifdef NO_DIR\n            fprintf(stderr, \"%s: -r not supported on this system\\n\", progname);\n            usage();\n            do_exit(ERROR); break;\n#else\n            recursive = 1; break;\n#endif\n        case 'S':\n#ifdef NO_MULTIPLE_DOTS\n            if (*optarg == '.') optarg++;\n#endif\n            z_len = strlen(optarg);\n            strcpy(z_suffix, optarg);\n            break;\n        case 't':\n            test = decompress = to_stdout = 1;\n            break;\n        case 'v':\n            verbose++; quiet = 0; break;\n        case 'V':\n            version(); do_exit(OK); break;\n        case 'Z':\n#ifdef LZW\n            do_lzw = 1; break;\n#else\n            fprintf(stderr, \"%s: -Z not supported in this version\\n\",\n                    progname);\n            usage();\n            do_exit(ERROR); break;\n#endif\n        case '1':  case '2':  case '3':  case '4':\n        case '5':  case '6':  case '7':  case '8':  case '9':\n            level = optc - '0';\n            break;\n        default:\n            /* Error message already emitted by getopt_long. */\n            usage();\n            do_exit(ERROR);\n        }\n    } /* loop on all arguments */\n\n    file_count = argc - optind;\n\n#if O_BINARY\n#else\n    if (ascii && !quiet) {\n        fprintf(stderr, \"%s: option --ascii ignored on this system\\n\",\n                progname);\n    }\n#endif\n    if ((z_len == 0 && !decompress) || z_len > MAX_SUFFIX) {\n        fprintf(stderr, \"%s: incorrect suffix '%s'\\n\",\n                progname, optarg);\n        do_exit(ERROR);\n    }\n    if (do_lzw && !decompress) work = lzw;\n\n    /* Allocate all global buffers (for DYN_ALLOC option) */\n    ALLOC(uch, inbuf,  INBUFSIZ +INBUF_EXTRA);\n    ALLOC(uch, outbuf, OUTBUFSIZ+OUTBUF_EXTRA);\n    ALLOC(ush, d_buf,  DIST_BUFSIZE);\n    ALLOC(uch, window, 2L*WSIZE);\n#ifndef MAXSEG_64K\n    ALLOC(ush, tab_prefix, 1L<<BITS);\n#else\n    ALLOC(ush, tab_prefix0, 1L<<(BITS-1));\n    ALLOC(ush, tab_prefix1, 1L<<(BITS-1));\n#endif\n\n    /* And get to work */\n    if (file_count != 0) {\n        if (to_stdout && !test && !list && (!decompress || !ascii)) {\n            SET_BINARY_MODE(fileno(stdout));\n        }\n        while (optind < argc) {\n            treat_file(argv\u00ddoptind++\u00a8);\n        }\n    } else {  /* Standard input */\n        treat_stdin();\n    }\n    if (list && !quiet) {\n        do_list(-1, -1); /* print totals */\n    }\n    do_exit(exit_code);\n    return exit_code; /* just to avoid lint warning */\n}\n\n/* ========================================================================\n * Compress or decompress stdin\n */\nlocal void treat_stdin()\n{\n    if (!force && isatty(fileno((FILE *)(decompress ? stdin : stdout)))) {\n        /* Do not send compressed data to the terminal or read it from\n         * the terminal. We get here when user invoked the program\n         * without parameters, so be helpful. According to the GNU standards:\n         *\n         *   If there is one behavior you think is most useful when the output\n         *   is to a terminal, and another that you think is most useful when\n         *   the output is a file or a pipe, then it is usually best to make\n         *   the default behavior the one that is useful with output to a\n         *   terminal, and have an option for the other behavior.\n         *\n         * Here we use the --force option to get the other behavior.\n         */\n        fprintf(stderr,\n    \"%s: compressed data not %s a terminal. Use -f to force %scompression.\\n\",\n                progname, decompress ? \"read from\" : \"written to\",\n                decompress ? \"de\" : \"\");\n        fprintf(stderr,\"For help, type: %s -h\\n\", progname);\n        do_exit(ERROR);\n    }\n\n    if (decompress || !ascii) {\n        SET_BINARY_MODE(fileno(stdin));\n    }\n    if (!test && !list && (!decompress || !ascii)) {\n        SET_BINARY_MODE(fileno(stdout));\n    }\n    strcpy(ifname, \"stdin\");\n    strcpy(ofname, \"stdout\");\n\n    /* Get the time stamp on the input file. */\n#ifdef NO_STDIN_FSTAT\n    time_stamp = 0; /* time unknown */\n#else\n    if (fstat(fileno(stdin), &istat) != 0) {\n        error(\"fstat(stdin)\");\n    }\n    /* If you do not wish to save the time stamp when input comes from a pipe,\n     * compile with -DNO_PIPE_TIMESTAMP.\n     */\n#ifdef NO_PIPE_TIMESTAMP\n    if (!S_ISREG(istat.st_mode))\n        time_stamp = 0;\n    else\n#endif\n        time_stamp = istat.st_mtime;\n#endif\n    ifile_size = -1L; /* convention for unknown size */\n\n    clear_bufs(); /* clear input and output buffers */\n    to_stdout = 1;\n    part_nb = 0;\n\n    if (decompress) {\n        method = get_method(ifd);\n        if (method < 0) {\n            do_exit(exit_code); /* error message already emitted */\n        }\n    }\n    if (list) {\n        do_list(ifd, method);\n        return;\n    }\n\n    /* Actually do the compression/decompression. Loop over zipped members.\n     */\n    for (;;) {\n        if ((*work)(fileno(stdin), fileno(stdout)) != OK) return;\n\n        if (!decompress || last_member || inptr == insize) break;\n        /* end of file */\n\n        method = get_method(ifd);\n        if (method < 0) return; /* error message already emitted */\n        bytes_out = 0;            /* required for length check */\n    }\n\n    if (verbose) {\n        if (test) {\n            fprintf(stderr, \" OK\\n\");\n\n        } else if (!decompress) {\n            display_ratio(bytes_in-(bytes_out-header_bytes), bytes_in, stderr);\n            fprintf(stderr, \"\\n\");\n#ifdef DISPLAY_STDIN_RATIO\n        } else {\n            display_ratio(bytes_out-(bytes_in-header_bytes), bytes_out,stderr);\n            fprintf(stderr, \"\\n\");\n#endif\n        }\n    }\n}\n\n/* ========================================================================\n * Compress or decompress the given file\n */\nlocal void treat_file(iname)\n    char *iname;\n{\n#ifdef MVS                                /* RS */\n    if (strncmp(iname, \"DD:\",  3) == 0) { /* RS DD-Names ?   */\n        dd_names = 1;                     /* RS Remeber that */\n    }                                     /* RS */\n#endif                                    /* RS */\n    /* Check if the input file is present, set ifname and istat: */\n    if (get_istat(iname, &istat) != OK) return;\n\n    /* If the input name is that of a directory, recurse or ignore: */\n    if (S_ISDIR(istat.st_mode)) {\n#ifndef NO_DIR\n        if (recursive) {\n            struct stat st;\n            st = istat;\n            treat_dir(iname);\n            /* Warning: ifname is now garbage */\n#  ifndef NO_UTIME\n            reset_times (iname, &st);\n#  endif\n        } else\n#endif\n        WARN((stderr,\"%s: %s is a directory -- ignored\\n\", progname, ifname));\n        return;\n    }\n    if (!S_ISREG(istat.st_mode)) {\n        WARN((stderr,\n              \"%s: %s is not a directory or a regular file - ignored\\n\",\n              progname, ifname));\n        return;\n    }\n    if (istat.st_nlink > 1 && !to_stdout && !force) {\n        WARN((stderr, \"%s: %s has %d other link%c -- unchanged\\n\",\n              progname, ifname,\n              (int)istat.st_nlink - 1, istat.st_nlink > 2 ? 's' : ' '));\n        return;\n    }\n\n    ifile_size = istat.st_size;\n    time_stamp = istat.st_mtime;\n\n    /* Generate output file name */\n    if (to_stdout && !list) {\n        strcpy(ofname, \"stdout\");\n\n    } else if (make_ofname() != OK) {\n        return;\n    }\n\n    /* Open the input file and determine compression method. The mode\n     * parameter is ignored but required by some systems (VMS) and forbidden\n     * on other systems (MacOS).\n     */\n    ifd = OPEN(ifname, ascii && !decompress ? O_RDONLY : O_RDONLY | O_BINARY,\n               RW_USER);\n    if (ifd == -1) {\n        fprintf(stderr, \"%s: \", progname);\n        perror(ifname);\n        exit_code = ERROR;\n        return;\n    }\n    clear_bufs(); /* clear input and output buffers */\n    part_nb = 0;\n\n    if (decompress) {\n        method = get_method(ifd); /* updates ofname if original given */\n        if (method < 0) {\n            close(ifd);\n            return;               /* error message already emitted */\n        }\n    }\n    if (list) {\n        do_list(ifd, method);\n        close(ifd);\n        return;\n    }\n\n    /* If compressing to a file, check if ofname is not ambiguous\n     * because the operating system truncates names. Otherwise, generate\n     * a new ofname and save the original name in the compressed file.\n     */\n    if (to_stdout) {\n        ofd = fileno(stdout);\n        /* keep remove_ofname as zero */\n    } else {\n        if (create_outfile() != OK) return;\n\n        if (!decompress && save_orig_name && !verbose && !quiet) {\n            fprintf(stderr, \"%s: %s compressed to %s\\n\",\n                    progname, ifname, ofname);\n        }\n    }\n    /* Keep the name even if not truncated except with --no-name: */\n    if (!save_orig_name) save_orig_name = !no_name;\n\n    if (verbose) {\n        fprintf(stderr, \"%s:\\t%s\", ifname, (int)strlen(ifname) >= 15 ?\n                \"\" : ((int)strlen(ifname) >= 7 ? \"\\t\" : \"\\t\\t\"));\n    }\n\n    /* Actually do the compression/decompression. Loop over zipped members.\n     */\n    for (;;) {\n        if ((*work)(ifd, ofd) != OK) {\n            method = -1; /* force cleanup */\n            break;\n        }\n        if (!decompress || last_member || inptr == insize) break;\n        /* end of file */\n\n        method = get_method(ifd);\n        if (method < 0) break;    /* error message already emitted */\n        bytes_out = 0;            /* required for length check */\n    }\n\n    close(ifd);\n    if (!to_stdout && close(ofd)) {\n        write_error();\n    }\n    if (method == -1) {\n        if (!to_stdout) unlink (ofname);\n        return;\n    }\n    /* Display statistics */\n    if(verbose) {\n        if (test) {\n            fprintf(stderr, \" OK\");\n        } else if (decompress) {\n            display_ratio(bytes_out-(bytes_in-header_bytes), bytes_out,stderr);\n        } else {\n            display_ratio(bytes_in-(bytes_out-header_bytes), bytes_in, stderr);\n        }\n        if (!test && !to_stdout) {\n            fprintf(stderr, \" -- replaced with %s\", ofname);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n    /* Copy modes, times, ownership, and remove the input file */\n    if (!to_stdout) {\n        copy_stat(&istat);\n    }\n}\n\n/* ========================================================================\n * Create the output file. Return OK or ERROR.\n * Try several times if necessary to avoid truncating the z_suffix. For\n * example, do not create a compressed file of name \"1234567890123.\"\n * Sets save_orig_name to true if the file name has been truncated.\n * IN assertions: the input file has already been open (ifd is set) and\n *   ofname has already been updated if there was an original name.\n * OUT assertions: ifd and ofd are closed in case of error.\n */\nlocal int create_outfile()\n{\n    struct stat ostat; /* stat for ofname */\n    int flags = O_WRONLY | O_CREAT | O_EXCL | O_BINARY;\n\n    if (ascii && decompress) {\n        flags &= ~O_BINARY; /* force ascii text mode */\n    }\n    for (;;) {\n        /* Make sure that ofname is not an existing file */\n        if (check_ofname() != OK) {\n            close(ifd);\n            return ERROR;\n        }\n        /* Create the output file */\n        remove_ofname = 1;\n        ofd = OPEN(ofname, flags, RW_USER);\n        if (ofd == -1) {\n            perror(ofname);\n            close(ifd);\n            exit_code = ERROR;\n            return ERROR;\n        }\n\n        /* Check for name truncation on new file (1234567890123.gz) */\n#ifdef NO_FSTAT\n        if (stat(ofname, &ostat) != 0) {\n#else\n        if (fstat(ofd, &ostat) != 0) {\n#endif\n            fprintf(stderr, \"%s: \", progname);\n            perror(ofname);\n            close(ifd); close(ofd);\n            unlink(ofname);\n            exit_code = ERROR;\n            return ERROR;\n        }\n        if (!name_too_long(ofname, &ostat)) return OK;\n\n        if (decompress) {\n            /* name might be too long if an original name was saved */\n            WARN((stderr, \"%s: %s: warning, name truncated\\n\",\n                  progname, ofname));\n            return OK;\n        }\n        close(ofd);\n        unlink(ofname);\n#ifdef NO_MULTIPLE_DOTS\n        /* Should never happen, see check_ofname() */\n        fprintf(stderr, \"%s: %s: name too long\\n\", progname, ofname);\n        do_exit(ERROR);\n#endif\n        shorten_name(ofname);\n    }\n}\n\n/* ========================================================================\n * Use lstat if available, except for -c or -f. Use stat otherwise.\n * This allows links when not removing the original file.\n */\nlocal int do_stat(name, sbuf)\n    char *name;\n    struct stat *sbuf;\n{\n    errno = 0;\n#if (defined(S_IFLNK) || defined (S_ISLNK)) && !defined(NO_SYMLINK)\n    if (!to_stdout && !force) {\n        return lstat(name, sbuf);\n    }\n#endif\n    return stat(name, sbuf);\n}\n\n/* ========================================================================\n * Return a pointer to the 'z' suffix of a file name, or NULL. For all\n * systems, \".gz\", \".z\", \".Z\", \".taz\", \".tgz\", \"-gz\", \"-z\" and \"_z\" are\n * accepted suffixes, in addition to the value of the --suffix option.\n * \".tgz\" is a useful convention for tar.z files on systems limited\n * to 3 characters extensions. On such systems, \".?z\" and \".??z\" are\n * also accepted suffixes. For Unix, we do not want to accept any\n * .??z suffix as indicating a compressed file; some people use .xyz\n * to denote volume data.\n *   On systems allowing multiple versions of the same file (such as VMS),\n * this function removes any version suffix in the given name.\n */\nlocal char *get_suffix(name)\n    char *name;\n{\n    int nlen, slen;\n    char suffix\u00ddMAX_SUFFIX+3\u00a8; /* last chars of name, forced to lower case */\n    static char *known_suffixes\u00dd\u00a8 =\n#ifdef ARCH\n       {z_suffix, \"/gz\", \"/z\", \"/taz\", \"/tgz\", \"-gz\", \"-z\", \"_z\",\n#else\n       {z_suffix, \".gz\", \".z\", \".taz\", \".tgz\", \"-gz\", \"-z\", \"_z\",\n#endif\n#ifdef MAX_EXT_CHARS\n          \"z\",\n#endif\n          NULL};\n    char **suf = known_suffixes;\n\n    if (strequ(z_suffix, \"z\")) suf++; /* check long suffixes first */\n\n#ifdef SUFFIX_SEP\n    /* strip a version number from the file name */\n    {\n        char *v = strrchr(name, SUFFIX_SEP);\n        if (v != NULL) *v = '\\0';\n    }\n#endif\n    nlen = strlen(name);\n    if (nlen <= MAX_SUFFIX+2) {\n        strcpy(suffix, name);\n    } else {\n        strcpy(suffix, name+nlen-MAX_SUFFIX-2);\n    }\n    strlwr(suffix);\n    slen = strlen(suffix);\n    do {\n       int s = strlen(*suf);\n       if (slen > s && suffix\u00ddslen-s-1\u00a8 != PATH_SEP\n           && strequ(suffix + slen - s, *suf)) {\n           return name+nlen-s;\n       }\n    } while (*++suf != NULL);\n\n    return NULL;\n}\n\n\n/* ========================================================================\n * Set ifname to the input file name (with a suffix appended if necessary)\n * and istat to its stats. For decompression, if no file exists with the\n * original name, try adding successively z_suffix, .gz, .z, -z and .Z.\n * For MSDOS, we try only z_suffix and z.\n * Return OK or ERROR.\n */\nlocal int get_istat(iname, sbuf)\n    char *iname;\n    struct stat *sbuf;\n{\n    int ilen;  /* strlen(ifname) */\n    static char *suffixes\u00dd\u00a8 = {z_suffix, \".gz\", \".z\", \"-z\", \".Z\", NULL};\n    char **suf = suffixes;\n    char *s;\n#ifdef NO_MULTIPLE_DOTS\n    char *dot; /* pointer to ifname extension, or NULL */\n#endif\n\n    strcpy(ifname, iname);\n\n    /* If input file exists, return OK. */\n    if (do_stat(ifname, sbuf) == 0) return OK;\n\n    if (!decompress || errno != ENOENT) {\n        perror(ifname);\n        exit_code = ERROR;\n        return ERROR;\n    }\n    /* file.ext doesn't exist, try adding a suffix (after removing any\n     * version number for VMS).\n     */\n    s = get_suffix(ifname);\n    if (s != NULL) {\n        perror(ifname); /* ifname already has z suffix and does not exist */\n        exit_code = ERROR;\n        return ERROR;\n    }\n#ifdef NO_MULTIPLE_DOTS\n    dot = strrchr(ifname, '.');\n    if (dot == NULL) {\n        strcat(ifname, \".\");\n        dot = strrchr(ifname, '.');\n    }\n#endif\n    ilen = strlen(ifname);\n    if (strequ(z_suffix, \".gz\")) suf++;\n\n    /* Search for all suffixes */\n    do {\n        s = *suf;\n#ifdef NO_MULTIPLE_DOTS\n        if (*s == '.') s++;\n#endif\n#ifdef MAX_EXT_CHARS\n        strcpy(ifname, iname);\n        /* Needed if the suffixes are not sorted by increasing length */\n\n        if (*dot == '\\0') strcpy(dot, \".\");\n        dot\u00ddMAX_EXT_CHARS+1-strlen(s)\u00a8 = '\\0';\n#endif\n        strcat(ifname, s);\n        if (do_stat(ifname, sbuf) == 0) return OK;\n        ifname\u00ddilen\u00a8 = '\\0';\n    } while (*++suf != NULL);\n\n    /* No suffix found, complain using z_suffix: */\n#ifdef MAX_EXT_CHARS\n    strcpy(ifname, iname);\n    if (*dot == '\\0') strcpy(dot, \".\");\n    dot\u00ddMAX_EXT_CHARS+1-z_len\u00a8 = '\\0';\n#endif\n    strcat(ifname, z_suffix);\n    perror(ifname);\n    exit_code = ERROR;\n    return ERROR;\n}\n\n/* ========================================================================\n * Generate ofname given ifname. Return OK, or WARNING if file must be skipped.\n * Sets save_orig_name to true if the file name has been truncated.\n */\nlocal int make_ofname()\n{\n    char *suff;            /* ofname z suffix */\n\n    strcpy(ofname, ifname);\n#ifdef MVS                              /* RS  */\n    if (dd_names) {                     /* DD-Names switch ? */\n       strcpy(ofname, \"DD:OUTPUT\");     /*  yes, set fixed DD-Name */\n       return OK;                       /* Back */\n    }                                   /*  for output-file  */\n#endif                                  /* RS */\n\n    /* strip a version number if any and get the gzip suffix if present: */\n    suff = get_suffix(ofname);\n\n    if (decompress) {\n        if (suff == NULL) {\n            if (list) return OK;\n            /* Avoid annoying messages with -r */\n            if (verbose || (!recursive && !quiet)) {\n                WARN((stderr,\"%s: %s: unknown suffix -- ignored\\n\",\n                      progname, ifname));\n            }\n            return WARNING;\n        }\n        /* Make a special case for .tgz and .taz: */\n        strlwr(suff);\n        if (strequ(suff, \".tgz\") || strequ(suff, \".taz\")) {\n            strcpy(suff, \".tar\");\n        } else {\n            *suff = '\\0'; /* strip the z suffix */\n        }\n        /* ofname might be changed later if infile contains an original name */\n\n    } else if (suff != NULL) {\n        /* Avoid annoying messages with -r (see treat_dir()) */\n        if (verbose || (!recursive && !quiet)) {\n            fprintf(stderr, \"%s: %s already has %s suffix -- unchanged\\n\",\n                    progname, ifname, suff);\n        }\n        if (exit_code == OK) exit_code = WARNING;\n        return WARNING;\n    } else {\n        save_orig_name = 0;\n\n#ifdef NO_MULTIPLE_DOTS\n        suff = strrchr(ofname, '.');\n        if (suff == NULL) {\n            strcat(ofname, \".\");\n#  ifdef MAX_EXT_CHARS\n            if (strequ(z_suffix, \"z\")) {\n                strcat(ofname, \"gz\"); /* enough room */\n                return OK;\n            }\n        /* On the Atari and some versions of MSDOS, name_too_long()\n         * does not work correctly because of a bug in stat(). So we\n         * must truncate here.\n         */\n        } else if (strlen(suff)-1 + z_len > MAX_SUFFIX) {\n            suff\u00ddMAX_SUFFIX+1-z_len\u00a8 = '\\0';\n            save_orig_name = 1;\n#  endif\n        }\n#endif /* NO_MULTIPLE_DOTS */\n        strcat(ofname, z_suffix);\n\n    } /* decompress ? */\n    return OK;\n}\n\n\n/* ========================================================================\n * Check the magic number of the input file and update ofname if an\n * original name was given and to_stdout is not set.\n * Return the compression method, -1 for error, -2 for warning.\n * Set inptr to the offset of the next byte to be processed.\n * This function may be called repeatedly for an input file consisting\n * of several contiguous gzip'ed members.\n * IN assertions: there is at least one remaining compressed member.\n *   If the member is a zip file, it must be the only one.\n */\nlocal int get_method(in)\n    int in;        /* input file descriptor */\n{\n    uch flags;\n    char magic\u00dd2\u00a8; /* magic header */\n\n    /* If --force and --stdout, zcat == cat, so do not complain about\n     * premature end of file: use try_byte instead of get_byte.\n     */\n    if (force && to_stdout) {\n        magic\u00dd0\u00a8 = (char)try_byte();\n        magic\u00dd1\u00a8 = (char)try_byte();\n        /* If try_byte returned EOF, magic\u00dd1\u00a8 == 0xff */\n    } else {\n        magic\u00dd0\u00a8 = (char)get_byte();\n        magic\u00dd1\u00a8 = (char)get_byte();\n    }\n    time_stamp = istat.st_mtime; /* may be modified later for some methods */\n    method = -1;                 /* unknown yet */\n    part_nb++;                   /* number of parts in gzip file */\n    header_bytes = 0;\n    last_member = RECORD_IO;\n    /* assume multiple members in gzip file except for record oriented I/O */\n\n    if (memcmp(magic, GZIP_MAGIC, 2) == 0\n        || memcmp(magic, OLD_GZIP_MAGIC, 2) == 0) {\n\n        method = (int)get_byte();\n        if (method != DEFLATED) {\n            fprintf(stderr,\n                    \"%s: %s: unknown method %d -- get newer version of gzip\\n\",\n                    progname, ifname, method);\n            exit_code = ERROR;\n            return -1;\n        }\n        work = unzip;\n        flags  = (uch)get_byte();\n\n        if ((flags & ENCRYPTED) != 0) {\n            fprintf(stderr,\n                    \"%s: %s is encrypted -- get newer version of gzip\\n\",\n                    progname, ifname);\n            exit_code = ERROR;\n            return -1;\n        }\n        if ((flags & CONTINUATION) != 0) {\n            fprintf(stderr,\n           \"%s: %s is a a multi-part gzip file -- get newer version of gzip\\n\",\n                    progname, ifname);\n            exit_code = ERROR;\n            if (force <= 1) return -1;\n        }\n        if ((flags & RESERVED) != 0) {\n            fprintf(stderr,\n                    \"%s: %s has flags 0x%x -- get newer version of gzip\\n\",\n                    progname, ifname, flags);\n            exit_code = ERROR;\n            if (force <= 1) return -1;\n        }\n        time_stamp  = (ulg)get_byte();\n        time_stamp |= ((ulg)get_byte()) << 8;\n        time_stamp |= ((ulg)get_byte()) << 16;\n        time_stamp |= ((ulg)get_byte()) << 24;\n\n        (void)get_byte();  /* Ignore extra flags for the moment */\n        (void)get_byte();  /* Ignore OS type for the moment */\n\n        if ((flags & CONTINUATION) != 0) {\n            unsigned part = (unsigned)get_byte();\n            part |= ((unsigned)get_byte())<<8;\n            if (verbose) {\n                fprintf(stderr,\"%s: %s: part number %u\\n\",\n                        progname, ifname, part);\n            }\n        }\n        if ((flags & EXTRA_FIELD) != 0) {\n            unsigned len = (unsigned)get_byte();\n            len |= ((unsigned)get_byte())<<8;\n            if (verbose) {\n                fprintf(stderr,\"%s: %s: extra field of %u bytes ignored\\n\",\n                        progname, ifname, len);\n            }\n            while (len--) (void)get_byte();\n        }\n\n        /* Get original file name if it was truncated */\n        if ((flags & ORIG_NAME) != 0) {\n            if (no_name || (to_stdout && !list) || part_nb > 1) {\n                /* Discard the old name */\n                char c; /* dummy used for NeXTstep 3.0 cc optimizer bug */\n                while ((c=get_byte()) != 0) c++;\n            } else {\n                /* Copy the base name. Keep a directory prefix intact. */\n                char *p = basename(ofname);\n                char *base = p;\n                for (;;) {\n                    *p = (char)get_char();\n                    if (*p++ == '\\0') break;\n                    if (p >= ofname+sizeof(ofname)) {\n                        error(\"corrupted input -- file name too large\");\n                    }\n                }\n                /* If necessary, adapt the name to local OS conventions: */\n                if (!list) {\n                   MAKE_LEGAL_NAME(base);\n                   base++; /* avoid warning about unused variable */\n                }\n#ifdef MVS                              /* RS  */\n                if (dd_names) {    /* DD-Names switch ? */\n                    /*  yes, set fixed DD-Name for output-file */\n                    /*  do not use the name from the zipfile   */\n                    strcpy(ofname, \"DD:OUTPUT\");\n                }                       /* RS */\n#endif                                  /* RS */\n            } /* no_name || to_stdout */\n        } /* ORIG_NAME */\n\n        /* Discard file comment if any */\n        if ((flags & COMMENT) != 0) {\n            while (get_char() != 0) /* null */ ;\n        }\n        if (part_nb == 1) {\n            header_bytes = inptr + 2*sizeof(long); /* include crc and size */\n        }\n\n    } else if (memcmp(magic, PKZIP_MAGIC, 2) == 0 && inptr == 2\n            && memcmp((char*)inbuf, PKZIP_MAGIC, 4) == 0) {\n        /* To simplify the code, we support a zip file when alone only.\n         * We are thus guaranteed that the entire local header fits in inbuf.\n         */\n        inptr = 0;\n        work = unzip;\n        if (check_zipfile(in) != OK) return -1;\n        /* check_zipfile may get ofname from the local header */\n        last_member = 1;\n\n    } else if (memcmp(magic, PACK_MAGIC, 2) == 0) {\n        work = unpack;\n        method = PACKED;\n\n    } else if (memcmp(magic, LZW_MAGIC, 2) == 0) {\n        work = unlzw;\n        method = COMPRESSED;\n        last_member = 1;\n\n    } else if (memcmp(magic, LZH_MAGIC, 2) == 0) {\n        work = unlzh;\n        method = LZHED;\n        last_member = 1;\n\n    } else if (force && to_stdout) { /* pass input unchanged */\n        method = STORED;\n        work = copy;\n        inptr = 0;\n        last_member = 1;\n    }\n    if (method >= 0) return method;\n\n    if (part_nb == 1) {\n        fprintf(stderr, \"\\n%s: %s: not in gzip format\\n\", progname, ifname);\n        exit_code = ERROR;\n        return -1;\n    } else {\n        WARN((stderr, \"\\n%s: %s: decompression OK, trailing garbage ignored\\n\",\n              progname, ifname));\n        return -2;\n    }\n}\n\n/* ========================================================================\n * Display the characteristics of the compressed file.\n * If the given method is < 0, display the accumulated totals.\n * IN assertions: time_stamp, header_bytes and ifile_size are initialized.\n */\nlocal void do_list(ifd, method)\n    int ifd;     /* input file descriptor */\n    int method;  /* compression method */\n{\n    ulg crc;  /* original crc */\n    static int first_time = 1;\n    static char* methods\u00ddMAX_METHODS\u00a8 = {\n        \"store\",  /* 0 */\n        \"compr\",  /* 1 */\n        \"pack \",  /* 2 */\n        \"lzh  \",  /* 3 */\n        \"\", \"\", \"\", \"\", /* 4 to 7 reserved */\n        \"defla\"}; /* 8 */\n    char *date;\n\n    if (first_time && method >= 0) {\n        first_time = 0;\n        if (verbose)  {\n            printf(\"method  crc     date  time  \");\n        }\n        if (!quiet) {\n            printf(\"compressed  uncompr. ratio uncompressed_name\\n\");\n        }\n    } else if (method < 0) {\n        if (total_in <= 0 || total_out <= 0) return;\n        if (verbose) {\n            printf(\"                            %9lu %9lu \",\n                   total_in, total_out);\n        } else if (!quiet) {\n            printf(\"%9ld %9ld \", total_in, total_out);\n        }\n        display_ratio(total_out-(total_in-header_bytes), total_out, stdout);\n        /* header_bytes is not meaningful but used to ensure the same\n         * ratio if there is a single file.\n         */\n        printf(\" (totals)\\n\");\n        return;\n    }\n    crc = ~0; /* unknown */\n    bytes_out = -1L;\n    bytes_in = ifile_size;\n\n#if RECORD_IO == 0\n    if (method == DEFLATED && !last_member) {\n        /* Get the crc and uncompressed size for gzip'ed (not zip'ed) files.\n         * If the lseek fails, we could use read() to get to the end, but\n         * --list is used to get quick results.\n         * Use \"gunzip < foo.gz | wc -c\" to get the uncompressed size if\n         * you are not concerned about speed.\n         */\n        bytes_in = (long)lseek(ifd, (off_t)(-8), SEEK_END);\n        if (bytes_in != -1L) {\n            uch buf\u00dd8\u00a8;\n            bytes_in += 8L;\n            if (read(ifd, (char*)buf, sizeof(buf)) != sizeof(buf)) {\n                read_error();\n            }\n            crc       = LG(buf);\n            bytes_out = LG(buf+4);\n        }\n    }\n#endif /* RECORD_IO */\n    date = ctime((time_t*)&time_stamp) + 4; /* skip the day of the week */\n    date\u00dd12\u00a8 = '\\0';               /* suppress the 1/100sec and the year */\n    if (verbose) {\n        printf(\"%5s %08lx %11s \", methods\u00ddmethod\u00a8, crc, date);\n    }\n    printf(\"%9ld %9ld \", bytes_in, bytes_out);\n    if (bytes_in  == -1L) {\n        total_in = -1L;\n        bytes_in = bytes_out = header_bytes = 0;\n    } else if (total_in >= 0) {\n        total_in  += bytes_in;\n    }\n    if (bytes_out == -1L) {\n        total_out = -1L;\n        bytes_in = bytes_out = header_bytes = 0;\n    } else if (total_out >= 0) {\n        total_out += bytes_out;\n    }\n    display_ratio(bytes_out-(bytes_in-header_bytes), bytes_out, stdout);\n    printf(\" %s\\n\", ofname);\n}\n\n/* ========================================================================\n * Return true if the two stat structures correspond to the same file.\n */\nlocal int same_file(stat1, stat2)\n    struct stat *stat1;\n    struct stat *stat2;\n{\n    return stat1->st_ino   == stat2->st_ino\n        && stat1->st_dev   == stat2->st_dev\n#ifdef NO_ST_INO\n        /* Can't rely on st_ino and st_dev, use other fields: */\n        && stat1->st_mode  == stat2->st_mode\n        && stat1->st_uid   == stat2->st_uid\n        && stat1->st_gid   == stat2->st_gid\n        && stat1->st_size  == stat2->st_size\n        && stat1->st_atime == stat2->st_atime\n        && stat1->st_mtime == stat2->st_mtime\n        && stat1->st_ctime == stat2->st_ctime\n#endif\n            ;\n}\n\n/* ========================================================================\n * Return true if a file name is ambiguous because the operating system\n * truncates file names.\n */\nlocal int name_too_long(name, statb)\n    char *name;           /* file name to check */\n    struct stat *statb;   /* stat buf for this file name */\n{\n    int s = strlen(name);\n    char c = name\u00dds-1\u00a8;\n    struct stat tstat; /* stat for truncated name */\n    int res;\n\n    tstat = *statb;      /* Just in case OS does not fill all fields */\n    name\u00dds-1\u00a8 = '\\0';\n    res = stat(name, &tstat) == 0 && same_file(statb, &tstat);\n    name\u00dds-1\u00a8 = c;\n    Trace((stderr, \" too_long(%s) => %d\\n\", name, res));\n    return res;\n}\n\n/* ========================================================================\n * Shorten the given name by one character, or replace a .tar extension\n * with .tgz. Truncate the last part of the name which is longer than\n * MIN_PART characters: 1234.678.012.gz -> 123.678.012.gz. If the name\n * has only parts shorter than MIN_PART truncate the longest part.\n *\n * IN assertion: This function is only called for the compressed file;\n * the suffix of the given name is z_suffix.\n */\nlocal void shorten_name(name)\n    char *name;\n{\n    int len;                 /* length of name without z_suffix */\n    char *trunc = NULL;      /* character to be truncated */\n    int plen;                /* current part length */\n    int min_part = MIN_PART; /* current minimum part length */\n    char *p;\n\n    p = get_suffix(name);\n    if (p == NULL) error(\"can't recover suffix\\n\");\n    *p = '\\0';\n    len = strlen(name);\n    save_orig_name = 1;\n\n    /* compress 1234567890.tar to 1234567890.tgz */\n    if (len > 4 && strequ(p-4, \".tar\")) {\n        strcpy(p-4, \".tgz\");\n        return;\n    }\n    /* Try keeping short extensions intact:\n     * 1234.678.012.gz -> 123.678.012.gz\n     */\n    do {\n        p = strrchr(name, PATH_SEP);\n        p = p ? p+1 : name;\n        while (*p) {\n            plen = strcspn(p, PART_SEP);\n            p += plen;\n            if (plen > min_part) trunc = p-1;\n            if (*p) p++;\n        }\n    } while (trunc == NULL && --min_part != 0);\n\n    if (trunc != NULL) {\n        do {\n            trunc\u00dd0\u00a8 = trunc\u00dd1\u00a8;\n        } while (*trunc++);\n        trunc--;\n    } else {\n        trunc = strrchr(name, PART_SEP\u00dd0\u00a8);\n        if (trunc == NULL) error(\"internal error in shorten_name\");\n        if (trunc\u00dd1\u00a8 == '\\0') trunc--; /* force truncation */\n    }\n    strcpy(trunc, z_suffix);\n}\n\n/* ========================================================================\n * If compressing to a file, check if ofname is not ambiguous\n * because the operating system truncates names. Otherwise, generate\n * a new ofname and save the original name in the compressed file.\n * If the compressed file already exists, ask for confirmation.\n *    The check for name truncation is made dynamically, because different\n * file systems on the same OS might use different truncation rules (on SVR4\n * s5 truncates to 14 chars and ufs does not truncate).\n *    This function returns -1 if the file must be skipped, and\n * updates save_orig_name if necessary.\n * IN assertions: save_orig_name is already set if ofname has been\n * already truncated because of NO_MULTIPLE_DOTS. The input file has\n * already been open and istat is set.\n */\nlocal int check_ofname()\n{\n    struct stat ostat; /* stat for ofname */\n\n    if (stat(ofname, &ostat) != 0) return 0;\n\n    /* Check for name truncation on existing file: */\n    if (!decompress && name_too_long(ofname, &ostat)) {\n        shorten_name(ofname);\n        if (stat(ofname, &ostat) != 0) return 0;\n    }\n\n    /* Check that the input and output files are different (could be\n     * the same by name truncation or links).\n     */\n    if (same_file(&istat, &ostat)) {\n        fprintf(stderr, \"%s: %s and %s are the same file\\n\",\n                progname, ifname, ofname);\n        exit_code = ERROR;\n        return ERROR;\n    }\n#ifdef MVS             /* RS */\n    if (dd_names) {    /* DD-Names ? */\n        return OK;     /*  Yes do not check for overwrite and */\n    }                  /*  do not delete (UNLINK)             */\n                       /*  Thats a job for the OS             */\n#endif                 /* RS */\n    /* Ask permission to overwrite the existing file */\n    if (!force) {\n        char response\u00dd80\u00a8;\n        strcpy(response,\"n\");\n        //* RS added linefeed, without the prompt occurs to late\n        fprintf(stderr, \"%s: %s already exists \\n\", progname, ofname);\n        if (foreground && isatty(fileno(stdin))) {\n            //* RS added linefeed, without the prompt occurs to late\n            fprintf(stderr, \" do you wish to overwrite (y or n)?\\n\");\n            fflush(stderr);\n            (void)fgets(response, sizeof(response)-1, stdin);\n        }\n        if (tolow(*response) != 'y') {\n            fprintf(stderr, \"\\tnot overwritten\\n\");\n            if (exit_code == OK) exit_code = WARNING;\n            return ERROR;\n        }\n    }\n    (void) chmod(ofname, 0777);\n    if (unlink(ofname)) {\n        //* RS added linefeed, without the prompt occurs to late\n        fprintf(stderr, \"%s:\\n\", progname);\n        perror(ofname);\n        exit_code = ERROR;\n        return ERROR;\n    }\n    return OK;\n}\n\n\n#ifndef NO_UTIME\n/* ========================================================================\n * Set the access and modification times from the given stat buffer.\n */\nlocal void reset_times (name, statb)\n    char *name;\n    struct stat *statb;\n{\n    struct utimbuf      timep;\n\n    /* Copy the time stamp */\n    timep.actime  = statb->st_atime;\n    timep.modtime = statb->st_mtime;\n\n    /* Some systems (at least OS/2) do not support utime on directories */\n#ifdef ARCH\n    if (utime(name, &timep.actime) && !S_ISDIR(statb->st_mode) ) {\n#else\n    if (utime(name, &timep) && !S_ISDIR(statb->st_mode)) {\n#endif\n        WARN((stderr, \"%s: \", progname));\n        if (!quiet) perror(ofname);\n    }\n}\n#endif\n\n\n/* ========================================================================\n * Copy modes, times, ownership from input file to output file.\n * IN assertion: to_stdout is false.\n */\nlocal void copy_stat(ifstat)\n    struct stat *ifstat;\n{\n#ifndef NO_UTIME\n    if (decompress && time_stamp != 0 && ifstat->st_mtime != time_stamp) {\n        ifstat->st_mtime = time_stamp;\n        if (verbose) {\n            fprintf(stderr, \"%s: time stamp restored\\n\", ofname);\n        }\n    }\n    reset_times(ofname, ifstat);\n#endif\n    /* Copy the protection modes */\n    if (chmod(ofname, ifstat->st_mode & 07777)) {\n        WARN((stderr, \"%s: \", progname));\n        if (!quiet) perror(ofname);\n    }\n#ifndef NO_CHOWN\n    chown(ofname, ifstat->st_uid, ifstat->st_gid);  /* Copy ownership */\n#endif\n    remove_ofname = 0;\n    /* It's now safe to remove the input file: */\n    (void) chmod(ifname, 0777);\n#ifndef MVS                /* RS don't do that under MVS */\n    if (unlink(ifname)) {\n        WARN((stderr, \"%s: \", progname));\n        if (!quiet) perror(ifname);\n    }\n#endif                     /* it's not regular under MVS */\n}\n\n#ifndef NO_DIR\n\n/* ========================================================================\n * Recurse through the given directory. This code is taken from ncompress.\n */\nlocal void treat_dir(dir)\n    char *dir;\n{\n    dir_type *dp;\n    DIR      *dirp;\n    char     nbuf\u00ddMAX_PATH_LEN\u00a8;\n    int      len;\n\n    dirp = opendir(dir);\n\n    if (dirp == NULL) {\n        fprintf(stderr, \"%s: %s unreadable\\n\", progname, dir);\n        exit_code = ERROR;\n        return ;\n    }\n    /*\n     ** WARNING: the following algorithm could occasionally cause\n     ** compress to produce error warnings of the form \"<filename>.gz\n     ** already has .gz suffix - ignored\". This occurs when the\n     ** .gz output file is inserted into the directory below\n     ** readdir's current pointer.\n     ** These warnings are harmless but annoying, so they are suppressed\n     ** with option -r (except when -v is on). An alternative\n     ** to allowing this would be to store the entire directory\n     ** list in memory, then compress the entries in the stored\n     ** list. Given the depth-first recursive algorithm used here,\n     ** this could use up a tremendous amount of memory. I don't\n     ** think it's worth it. -- Dave Mack\n     ** (An other alternative might be two passes to avoid depth-first.)\n     */\n\n    while ((dp = readdir(dirp)) != NULL) {\n\n        if (strequ(dp->d_name,\".\") || strequ(dp->d_name,\"..\")) {\n            continue;\n        }\n        len = strlen(dir);\n        if (len + NLENGTH(dp) + 1 < MAX_PATH_LEN - 1) {\n            strcpy(nbuf,dir);\n            if (len != 0 /* dir = \"\" means current dir on Amiga */\n#ifdef PATH_SEP2\n                && dir\u00ddlen-1\u00a8 != PATH_SEP2\n#endif\n#ifdef PATH_SEP3\n                && dir\u00ddlen-1\u00a8 != PATH_SEP3\n#endif\n            ) {\n                nbuf\u00ddlen++\u00a8 = PATH_SEP;\n            }\n            strcpy(nbuf+len, dp->d_name);\n            treat_file(nbuf);\n        } else {\n            fprintf(stderr,\"%s: %s/%s: pathname too long\\n\",\n                    progname, dir, dp->d_name);\n            exit_code = ERROR;\n        }\n    }\n    closedir(dirp);\n}\n#endif /* ? NO_DIR */\n\n/* ========================================================================\n * Free all dynamically allocated variables and exit with the given code.\n */\nlocal void do_exit(exitcode)\n    int exitcode;\n{\n    if (env != NULL)  free(env),  env  = NULL;\n    if (args != NULL) free((char*)args), args = NULL;\n    FREE(inbuf);\n    FREE(outbuf);\n    FREE(d_buf);\n    FREE(window);\n#ifndef MAXSEG_64K\n    FREE(tab_prefix);\n#else\n    FREE(tab_prefix0);\n    FREE(tab_prefix1);\n#endif\n    exit(exitcode);\n}\n\n/* ========================================================================\n * Signal and error handler.\n */\nRETSIGTYPE abort_gzip()\n{\n   if (remove_ofname) {\n       close(ofd);\n       unlink (ofname);\n   }\n   do_exit(ERROR);\n}\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INFLATE": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x00\\x98\\x11/\\x00\\x98\\x12\\x7f\\x13\\x11\\x03\\xc0\\x03\\xbb\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1998-04-22T00:00:00", "modifydate": "1998-05-07T13:11:00", "lines": 960, "newlines": 955, "modlines": 0, "user": "XSSGSCH"}, "text": "??=ifdef MVS    //* RS\n   ??=pragma filetag(\"IBM-1047\")  //* RS\n??=endif                          //* RS\n/* inflate.c -- Not copyrighted 1992 by Mark Adler\n   version c10p1, 10 January 1993 */\n\n/* You can do whatever you like with this source file, though I would\n   prefer that if you modify it and redistribute it that you include\n   comments to that effect with your name and the date.  Thank you.\n   \u00ddThe history has been moved to the file ChangeLog.\u00a8\n */\n\n/*\n   Inflate deflated (PKZIP's method 8 compressed) data.  The compression\n   method searches for as much of the current string of bytes (up to a\n   length of 258) in the previous 32K bytes.  If it doesn't find any\n   matches (of at least length 3), it codes the next byte.  Otherwise, i\n   codes the length of the matched string and its distance backwards fro\n   the current position.  There is a single Huffman code that codes both\n   single bytes (called \"literals\") and match lengths.  A second Huffman\n   code codes the distance information, which follows a length code.  Ea\n   length or distance code actually represents a base value and a number\n   of \"extra\" (sometimes zero) bits to get to add to the base value.  At\n   the end of each deflated block is a special end-of-block (EOB) litera\n   length code.  The decoding process is basically: get a literal/length\n   code; if EOB then done; if a literal, emit the decoded byte; if a\n   length then get the distance and emit the referred-to bytes from the\n   sliding window of previously emitted data.\n\n   There are (currently) three kinds of inflate blocks: stored, fixed, a\n   dynamic.  The compressor deals with some chunk of data at a time, and\n   decides which method to use on a chunk-by-chunk basis.  A chunk might\n   typically be 32K or 64K.  If the chunk is uncompressible, then the\n   \"stored\" method is used.  In this case, the bytes are simply stored a\n   is, eight bits per byte, with none of the above coding.  The bytes ar\n   preceded by a count, since there is no longer an EOB code.\n\n   If the data is compressible, then either the fixed or dynamic methods\n   are used.  In the dynamic method, the compressed data is preceded by\n   an encoding of the literal/length and distance Huffman codes that are\n   to be used to decode this block.  The representation is itself Huffma\n   coded, and so is preceded by a description of that code.  These code\n   descriptions take up a little space, and so for small blocks, there i\n   a predefined set of codes, called the fixed codes.  The fixed method\n   used if the block codes up smaller that way (usually for quite small\n   chunks), otherwise the dynamic method is used.  In the latter case, t\n   codes are customized to the probabilities in the current block, and s\n   can code it much better than the pre-determined fixed codes.\n\n   The Huffman codes themselves are decoded using a mutli-level table\n   lookup, in order to maximize the speed of decoding plus the speed of\n   building the decoding tables.  See the comments below that precede th\n   lbits and dbits tuning parameters.\n */\n\n\n/*\n   Notes beyond the 1.93a appnote.txt:\n\n   1. Distance pointers never point before the beginning of the output\n      stream.\n   2. Distance pointers can point back across blocks, up to 32k away.\n   3. There is an implied maximum of 7 bits for the bit length table and\n      15 bits for the actual data.\n   4. If only one code exists, then it is encoded using one bit.  (Zero\n      would be more efficient, but perhaps a little confusing.)  If two\n      codes exist, they are coded using one bit each (0 and 1).\n   5. There is no way of sending zero distance codes--a dummy must be\n      sent if there are none.  (History: a pre 2.0 version of PKZIP woul\n      store blocks with no distance codes, but this was discovered to be\n      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow\n      zero distance codes, which is sent as one code of zero bits in\n      length.\n   6. There are up to 286 literal/length codes.  Code 256 represents the\n      end-of-block.  Note however that the static length tree defines\n      288 codes just to fill out the Huffman codes.  Codes 286 and 287\n      cannot be used though, since there is no length base or extra bits\n      defined for them.  Similarly, there are up to 30 distance codes.\n      However, static trees define 32 codes (all 5 bits) to fill out the\n      Huffman codes, but the last two had better not show up in the data\n   7. Unzip can check dynamic Huffman blocks for complete code sets.\n      The exception is that a single code would not be complete (see #4)\n   8. The five bits following the block type is really the number of\n      literal codes sent minus 257.\n   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits\n      (1+6+6).  Therefore, to output three times the length, you output\n      three codes (1+1+1), whereas to output four times the same length,\n      you only need two codes (1+3).  Hmm.\n  10. In the tree reconstruction algorithm, Code = Code + Increment\n      only if BitLength(i) is not zero.  (Pretty obvious.)\n  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)\n  12. Note: length code 284 can represent 227-258, but length code 285\n      really is 258.  The last length deserves its own, short code\n      since it gets used a lot in very redundant files.  The length\n      258 is special since 258 - 3 (the min match length) is 255.\n  13. The literal/length and distance code bit lengths are read as a\n      single stream of lengths.  It is possible (and advantageous) for\n      a repeat code (16, 17, or 18) to go across the boundary between\n      the two sets of lengths.\n */\n\n#ifndef lint\nstatic char rcsid\u00dd\u00a8 = \"$Id: inflate.c,v 0.14 1993/06/10 13:27:04 jloup E\";\n#endif\n\n#ifndef C370\n#include <sys/types.h>\n#endif /* C370 */\n\n#include \"tailor.h\"\n\n#if defined(STDC_HEADERS) \u00a6\u00a6 !defined(NO_STDLIB_H)\n#  include <stdlib.h>\n#endif\n\n#include \"gzip.h\"\n#define slide window\n\n/* Huffman code lookup table entry--this entry is four bytes for machine\n   that have 16-bit pointers (e.g. PC's in the small or medium model).\n   Valid extra bits are 0..13.  e == 15 is EOB (end of block), e == 16\n   means that v is a literal, 16 < e < 32 means that v is a pointer to\n   the next table, which codes e - 16 bits, and lastly e == 99 indicates\n   an unused code.  If a code with e == 99 is looked up, this implies an\n   error in the data. */\nstruct huft {\n  uch e;                /* number of extra bits or operation */\n  uch b;                /* number of bits in this code or subcode */\n  union {\n    ush n;              /* literal, length base, or distance base */\n    struct huft *t;     /* pointer to next level of table */\n  } v;\n};\n\n\n/* Function prototypes */\nint huft_build OF((unsigned *, unsigned, unsigned, ush *, ush *,\n                   struct huft **, int *));\nint huft_free OF((struct huft *));\nint inflate_codes OF((struct huft *, struct huft *, int, int));\nint inflate_stored OF((void));\nint inflate_fixed OF((void));\nint inflate_dynamic OF((void));\nint inflate_block OF((int *));\nint inflate OF((void));\n\n\n/* The inflate algorithm uses a sliding 32K byte window on the uncompres\n   stream to find repeated byte strings.  This is implemented here as a\n   circular buffer.  The index is updated simply by incrementing and the\n   and'ing with 0x7fff (32K-1). */\n/* It is left to other modules to supply the 32K area.  It is assumed\n   to be usable as if it were declared \"uch slide\u00dd32768\u00a8;\" or as just\n   \"uch *slide;\" and then malloc'ed in the latter case.  The definition\n   must be in unzip.h, included above. */\n/* unsigned wp;             current position in slide */\n#define wp outcnt\n#define flush_output(w) (wp=(w),flush_window())\n\n/* Tables for deflate from PKZIP's appnote.txt. */\nstatic unsigned border\u00dd\u00a8 = { /* Order of the bit length code lengths */\n        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\nstatic ush cplens\u00dd\u00a8 = {         /* Copy lengths for literal codes 257..2 */\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n        /* note: see note #13 above about the 258 in this list. */\nstatic ush cplext\u00dd\u00a8 = {         /* Extra bits for literal codes 257..285 */\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99}; /* 99==invalid */\nstatic ush cpdist\u00dd\u00a8 = {         /* Copy offsets for distance codes 0..29 */\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577};\nstatic ush cpdext\u00dd\u00a8 = {         /* Extra bits for distance codes */\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n        12, 12, 13, 13};\n\n\n\n/* Macros for inflate() bit peeking and grabbing.\n   The usage is:\n\n        NEEDBITS(j)\n        x = b & mask_bits\u00ddj\u00a8;\n        DUMPBITS(j)\n\n   where NEEDBITS makes sure that b has at least j bits in it, and\n   DUMPBITS removes the bits from b.  The macros use the variable k\n   for the number of bits in b.  Normally, b and k are register\n   variables for speed, and are initialized at the beginning of a\n   routine that uses these macros from a global bit buffer and count.\n\n   If we assume that EOB will be the longest code, then we will never\n   ask for bits with NEEDBITS that are beyond the end of the stream.\n   So, NEEDBITS should not read any more bytes than are needed to\n   meet the request.  Then no bytes need to be \"returned\" to the buffer\n   at the end of the last block.\n\n   However, this assumption is not true for fixed blocks--the EOB code\n   is 7 bits, but the other literal/length codes can be 8 or 9 bits.\n   (The EOB code is shorter than other codes because fixed blocks are\n   generally short.  So, while a block always has an EOB, many other\n   literal/length codes have a significantly lower probability of\n   showing up at all.)  However, by making the first table have a\n   lookup of seven bits, the EOB code will be found in that first\n   lookup, and so will not require that too many bits be pulled from\n   the stream.\n */\n\nulg bb;                         /* bit buffer */\nunsigned bk;                    /* bits in bit buffer */\n\nush mask_bits\u00dd\u00a8 = {\n    0x0000,\n    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,\n    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff\n};\n\n#ifdef CRYPT\n  uch cc;\n#  define NEXTBYTE() \\\n     (decrypt ? (cc = get_byte(), zdecode(cc), cc) : get_byte())\n#else\n#  define NEXTBYTE()  (uch)get_byte()\n#endif\n#define NEEDBITS(n) {while(k<(n)){b\u00a6=((ulg)NEXTBYTE())<<k;k+=8;}}\n#define DUMPBITS(n) {b>>=(n);k-=(n);}\n\n\n/*\n   Huffman code decoding is performed using a multi-level table lookup.\n   The fastest way to decode is to simply build a lookup table whose\n   size is determined by the longest code.  However, the time it takes\n   to build this table can also be a factor if the data being decoded\n   is not very long.  The most common codes are necessarily the\n   shortest codes, so those codes dominate the decoding time, and hence\n   the speed.  The idea is you can have a shorter table that decodes the\n   shorter, more probable codes, and then point to subsidiary tables for\n   the longer codes.  The time it costs to decode the longer codes is\n   then traded against the time it takes to make longer tables.\n\n   This results of this trade are in the variables lbits and dbits\n   below.  lbits is the number of bits the first level table for literal\n   length codes can decode in one step, and dbits is the same thing for\n   the distance codes.  Subsequent tables are also less than or equal to\n   those sizes.  These values may be adjusted either when all of the\n   codes are shorter than that, in which case the longest code length in\n   bits is used, or when the shortest code is *longer* than the requeste\n   table size, in which case the length of the shortest code in bits is\n   used.\n\n   There are two different values for the two tables, since they code a\n   different number of possibilities each.  The literal/length table\n   codes 286 possible values, or in a flat code, a little over eight\n   bits.  The distance table codes 30 possible values, or a little less\n   than five bits, flat.  The optimum values for speed end up being\n   about one bit more than those, so lbits is 8+1 and dbits is 5+1.\n   The optimum values may differ though from machine to machine, and\n   possibly even between compilers.  Your mileage may vary.\n */\n\n\nint lbits = 9;          /* bits in base literal/length lookup table */\nint dbits = 6;          /* bits in base distance lookup table */\n\n\n/* If BMAX needs to be larger than 16, then h and x\u00dd\u00a8 should be ulg. */\n#define BMAX 16         /* maximum bit length of any code (16 for explod */\n#define N_MAX 288       /* maximum number of codes in any set */\n\n\nunsigned hufts;         /* track memory usage */\n\n\nint huft_build(b, n, s, d, e, t, m)\nunsigned *b;            /* code lengths in bits (all assumed <= BMAX) */\nunsigned n;             /* number of codes (assumed <= N_MAX) */\nunsigned s;             /* number of simple-valued codes (0..s-1) */\nush *d;                 /* list of base values for non-simple codes */\nush *e;                 /* list of extra bits for non-simple codes */\nstruct huft **t;        /* result: starting table */\nint *m;                 /* maximum lookup bits, returns actual */\n/* Given a list of code lengths and a maximum table size, make a set of\n   tables to decode that set of codes.  Return zero on success, one if\n   the given code set is incomplete (the tables are still built in this\n   case), two if the input is invalid (all zero length codes or an\n   oversubscribed set of lengths), and three if not enough memory. */\n{\n  unsigned a;                   /* counter for codes of length k */\n  unsigned c\u00ddBMAX+1\u00a8;           /* bit length count table */\n  unsigned f;                   /* i repeats in table every f entries */\n  int g;                        /* maximum code length */\n  int h;                        /* table level */\n  register unsigned i;          /* counter, current code */\n  register unsigned j;          /* counter */\n  register int k;               /* number of bits in current code */\n  int l;                        /* bits per table (returned in m) */\n  register unsigned *p;         /* pointer into c\u00dd\u00a8, b\u00dd\u00a8, or v\u00dd\u00a8 */\n  register struct huft *q;      /* points to current table */\n  struct huft r;                /* table entry for structure assignment */\n  struct huft *u\u00ddBMAX\u00a8;         /* table stack */\n  unsigned v\u00ddN_MAX\u00a8;            /* values in order of bit length */\n  register int w;               /* bits before this table == (l * h) */\n  unsigned x\u00ddBMAX+1\u00a8;           /* bit offsets, then code stack */\n  unsigned *xp;                 /* pointer into x */\n  int y;                        /* number of dummy codes added */\n  unsigned z;                   /* number of entries in current table */\n\n\n  /* Generate counts for each bit length */\n  memzero(c, sizeof(c));\n  p = b;  i = n;\n  do {\n    Tracecv(*p, (stderr, ( isprint( n-i ) ? \"%c %d\\n\" : \"0x%x %d\\n\"),\n            n-i, *p));\n    c\u00dd*p++\u00a8++;                  /* assume all entries <= BMAX */\n  } while (--i);\n  if (c\u00dd0\u00a8 == n)                /* null input--all zero length codes */\n  {\n    *t = (struct huft *)NULL;\n    *m = 0;\n    return 0;\n  }\n\n\n  /* Find minimum and maximum length, bound *m by those */\n  l = *m;\n  for (j = 1; j <= BMAX; j++)\n    if (c\u00ddj\u00a8)\n      break;\n  k = j;                        /* minimum code length */\n  if ((unsigned)l < j)\n    l = j;\n  for (i = BMAX; i; i--)\n    if (c\u00ddi\u00a8)\n      break;\n  g = i;                        /* maximum code length */\n  if ((unsigned)l > i)\n    l = i;\n  *m = l;\n\n\n  /* Adjust last length count to fill out codes, if needed */\n  for (y = 1 << j; j < i; j++, y <<= 1)\n    if ((y -= c\u00ddj\u00a8) < 0)\n      return 2;                 /* bad input: more codes than bits */\n  if ((y -= c\u00ddi\u00a8) < 0)\n    return 2;\n  c\u00ddi\u00a8 += y;\n\n\n  /* Generate starting offsets into the value table for each length */\n  x\u00dd1\u00a8 = j = 0;\n  p = c + 1;  xp = x + 2;\n  while (--i) {                 /* note that i == g from above */\n    *xp++ = (j += *p++);\n  }\n\n\n  /* Make a table of values in order of bit lengths */\n  p = b;  i = 0;\n  do {\n    if ((j = *p++) != 0)\n      v\u00ddx\u00ddj\u00a8++\u00a8 = i;\n  } while (++i < n);\n\n\n  /* Generate the Huffman codes and for each, make the table entries */\n  x\u00dd0\u00a8 = i = 0;                 /* first Huffman code is zero */\n  p = v;                        /* grab values in bit order */\n  h = -1;                       /* no tables yet--level -1 */\n  w = -l;                       /* bits decoded == (l * h) */\n  u\u00dd0\u00a8 = (struct huft *)NULL; /* just to keep compilers happy */\n  q = (struct huft *)NULL;      /* ditto */\n  z = 0;                        /* ditto */\n\n  /* go through the bit lengths (k already is bits in shortest code) */\n  for (; k <= g; k++)\n  {\n    a = c\u00ddk\u00a8;\n    while (a--)\n    {\n      /* here i is the Huffman code of length k bits for value *p */\n      /* make tables up to required level */\n      while (k > w + l)\n      {\n        h++;\n        w += l;                 /* previous table always l bits */\n\n        /* compute minimum size table less than or equal to l bits */\n        z = (z = g - w) > (unsigned)l ? l : z;  /* upper limit on table */\n        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */\n        {                       /* too few codes for k-w bit table */\n          f -= a + 1;           /* deduct codes from patterns left */\n          xp = c + k;\n          while (++j < z)       /* try smaller tables up to z bits */\n          {\n            if ((f <<= 1) <= *++xp)\n              break;            /* enough codes to use up j bits */\n            f -= *xp;           /* else deduct codes from patterns */\n          }\n        }\n        z = 1 << j;             /* table entries for j-bit table */\n\n        /* allocate and link in new table */\n        if ((q = (struct huft *)malloc((z + 1)*sizeof(struct huft))) ==\n            (struct huft *)NULL)\n        {\n          if (h)\n            huft_free(u\u00dd0\u00a8);\n          return 3;             /* not enough memory */\n        }\n        hufts += z + 1;         /* track memory usage */\n        *t = q + 1;             /* link to list for huft_free() */\n        *(t = &(q->v.t)) = (struct huft *)NULL;\n        u\u00ddh\u00a8 = ++q;             /* table starts after link */\n\n        /* connect to last table, if there is one */\n        if (h)\n        {\n          x\u00ddh\u00a8 = i;             /* save pattern for backing up */\n          r.b = (uch)l;         /* bits to dump before this table */\n          r.e = (uch)(16 + j);  /* bits in this table */\n          r.v.t = q;            /* pointer to this table */\n          j = i >> (w - l);     /* (get around Turbo C bug) */\n          u\u00ddh-1\u00a8\u00ddj\u00a8 = r; /* connect to last table */\n        }\n      }\n\n      /* set up table entry in r */\n      r.b = (uch)(k - w);\n      if (p >= v + n)\n        r.e = 99;               /* out of values--invalid code */\n      else if (*p < s)\n      {\n        r.e = (uch)(*p < 256 ? 16 : 15);    /* 256 is end-of-block code */\n        r.v.n = (ush)(*p);             /* simple code is just the value */\n        p++;                           /* one compiler does not like *p+ */\n      }\n      else\n      {\n        r.e = (uch)e\u00dd*p - s\u00a8; /* non-simple--look up in lists */\n        r.v.n = d\u00dd*p++ - s\u00a8;\n      }\n\n      /* fill code-like entries with r */\n      f = 1 << (k - w);\n      for (j = i >> w; j < z; j += f)\n        q\u00ddj\u00a8 = r;\n\n      /* backwards increment the k-bit code i */\n      for (j = 1 << (k - 1); i & j; j >>= 1)\n        i \u00ac= j;\n      i \u00ac= j;\n\n      /* backup over finished tables */\n      while ((i & ((1 << w) - 1)) != x\u00ddh\u00a8)\n      {\n        h--;                    /* don't need to update q */\n        w -= l;\n      }\n    }\n  }\n\n\n  /* Return true (1) if we were given an incomplete table */\n  return y != 0 && g != 1;\n}\n\n\n\nint huft_free(t)\nstruct huft *t;         /* table to free */\n/* Free the malloc'ed tables built by huft_build(), which makes a linked\n   list of the tables it made, with the links in a dummy first entry of\n   each table. */\n{\n  register struct huft *p, *q;\n\n\n  /* Go through linked list, freeing from the malloced (t\u00dd-1\u00a8) address*/\n  p = t;\n  while (p != (struct huft *)NULL)\n  {\n    q = (--p)->v.t;\n    free((char*)p);\n    p = q;\n  }\n  return 0;\n}\n\n\nint inflate_codes(tl, td, bl, bd)\nstruct huft *tl, *td;   /* literal/length and distance decoder tables */\nint bl, bd;             /* number of bits decoded by tl\u00dd\u00a8 and td\u00dd\u00a8 */\n/* inflate (decompress) the codes in a deflated (compressed) block.\n   Return an error code or zero if it all goes ok. */\n{\n  register unsigned e;  /* table entry flag/number of extra bits */\n  unsigned n, d;        /* length and index for copy */\n  unsigned w;           /* current window position */\n  struct huft *t;       /* pointer to table entry */\n  unsigned ml, md;      /* masks for bl and bd bits */\n  register ulg b;       /* bit buffer */\n  register unsigned k;  /* number of bits in bit buffer */\n\n\n  /* make local copies of globals */\n  b = bb;                       /* initialize bit buffer */\n  k = bk;\n  w = wp;                       /* initialize window position */\n\n  /* inflate the coded data */\n  ml = mask_bits\u00ddbl\u00a8;           /* precompute masks for speed */\n  md = mask_bits\u00ddbd\u00a8;\n  for (;;)                      /* do until end of block */\n  {\n    NEEDBITS((unsigned)bl)\n    if ((e = (t = tl + ((unsigned)b & ml))->e) > 16)\n      do {\n        if (e == 99)\n          return 1;\n        DUMPBITS(t->b)\n        e -= 16;\n        NEEDBITS(e)\n      } while ((e = (t = t->v.t + ((unsigned)b & mask_bits\u00dde\u00a8))->e) > 16\n                );\n    DUMPBITS(t->b)\n    if (e == 16)                /* then it's a literal */\n    {\n      slide\u00ddw++\u00a8 = (uch)t->v.n;\n      Tracevv((stderr, \"%c\", slide\u00ddw-1\u00a8));\n      if (w == WSIZE)\n      {\n        flush_output(w);\n        w = 0;\n      }\n    }\n    else                        /* it's an EOB or a length */\n    {\n      /* exit if end of block */\n      if (e == 15)\n        break;\n\n      /* get length of block to copy */\n      NEEDBITS(e)\n      n = t->v.n + ((unsigned)b & mask_bits\u00dde\u00a8);\n      DUMPBITS(e);\n\n      /* decode distance of block to copy */\n      NEEDBITS((unsigned)bd)\n      if ((e = (t = td + ((unsigned)b & md))->e) > 16)\n        do {\n          if (e == 99)\n            return 1;\n          DUMPBITS(t->b)\n          e -= 16;\n          NEEDBITS(e)\n        } while ((e = (t = t->v.t + ((unsigned)b & mask_bits\u00dde\u00a8))->e) >\n                 16);\n      DUMPBITS(t->b)\n      NEEDBITS(e)\n      d = w - t->v.n - ((unsigned)b & mask_bits\u00dde\u00a8);\n      DUMPBITS(e)\n      Tracevv((stderr,\"\\\\\u00dd%d,%d\u00a8\", w-d, n));\n\n      /* do the copy */\n      do {\n        n -= (e = (e = WSIZE - ((d &= WSIZE-1) > w ? d : w)) > n ? n : e);\n#if !defined(NOMEMCPY) && !defined(DEBUG)\n        if (w - d >= e)         /* (this test assumes unsigned comparison*/\n        {\n          memcpy(slide + w, slide + d, e);\n          w += e;\n          d += e;\n        }\n        else                      /* do it slow to avoid memcpy() overlay*/\n#endif /* !NOMEMCPY */\n          do {\n            slide\u00ddw++\u00a8 = slide\u00ddd++\u00a8;\n            Tracevv((stderr, \"%c\", slide\u00ddw-1\u00a8));\n          } while (--e);\n        if (w == WSIZE)\n        {\n          flush_output(w);\n          w = 0;\n        }\n      } while (n);\n    }\n  }\n\n\n  /* restore the globals from the locals */\n  wp = w;                       /* restore global window pointer */\n  bb = b;                       /* restore global bit buffer */\n  bk = k;\n\n  /* done */\n  return 0;\n}\n\n\n\nint inflate_stored()\n/* \"decompress\" an inflated type 0 (stored) block. */\n{\n  unsigned n;           /* number of bytes in block */\n  unsigned w;           /* current window position */\n  register ulg b;       /* bit buffer */\n  register unsigned k;  /* number of bits in bit buffer */\n\n\n  /* make local copies of globals */\n  b = bb;                       /* initialize bit buffer */\n  k = bk;\n  w = wp;                       /* initialize window position */\n\n\n  /* go to byte boundary */\n  n = k & 7;\n  DUMPBITS(n);\n\n\n  /* get the length and its complement */\n  NEEDBITS(16)\n  n = ((unsigned)b & 0xffff);\n  DUMPBITS(16)\n  NEEDBITS(16)\n  if (n != (unsigned)((~b) & 0xffff))\n    return 1;                   /* error in compressed data */\n  DUMPBITS(16)\n\n\n  /* read and output the compressed data */\n  while (n--)\n  {\n    NEEDBITS(8)\n    slide\u00ddw++\u00a8 = (uch)b;\n    if (w == WSIZE)\n    {\n      flush_output(w);\n      w = 0;\n    }\n    DUMPBITS(8)\n  }\n\n\n  /* restore the globals from the locals */\n  wp = w;                       /* restore global window pointer */\n  bb = b;                       /* restore global bit buffer */\n  bk = k;\n  return 0;\n}\n\n\n\nint inflate_fixed()\n/* decompress an inflated type 1 (fixed Huffman codes) block.  We should\n   either replace this with a custom decoder, or at least precompute the\n   Huffman tables. */\n{\n  int i;                /* temporary variable */\n  struct huft *tl;      /* literal/length code table */\n  struct huft *td;      /* distance code table */\n  int bl;               /* lookup bits for tl */\n  int bd;               /* lookup bits for td */\n  unsigned l\u00dd288\u00a8;      /* length list for huft_build */\n\n\n  /* set up literal table */\n  for (i = 0; i < 144; i++)\n    l\u00ddi\u00a8 = 8;\n  for (; i < 256; i++)\n    l\u00ddi\u00a8 = 9;\n  for (; i < 280; i++)\n    l\u00ddi\u00a8 = 7;\n  for (; i < 288; i++)          /* make a complete, but wrong code set */\n    l\u00ddi\u00a8 = 8;\n  bl = 7;\n  if ((i = huft_build(l, 288, 257, cplens, cplext, &tl, &bl)) != 0)\n    return i;\n\n\n  /* set up distance table */\n  for (i = 0; i < 30; i++)      /* make an incomplete code set */\n    l\u00ddi\u00a8 = 5;\n  bd = 5;\n  if ((i = huft_build(l, 30, 0, cpdist, cpdext, &td, &bd)) > 1)\n  {\n    huft_free(tl);\n    return i;\n  }\n\n\n  /* decompress until an end-of-block code */\n  if (inflate_codes(tl, td, bl, bd))\n    return 1;\n\n\n  /* free the decoding tables, return */\n  huft_free(tl);\n  huft_free(td);\n  return 0;\n}\n\n\n\nint inflate_dynamic()\n/* decompress an inflated type 2 (dynamic Huffman codes) block. */\n{\n  int i;                /* temporary variables */\n  unsigned j;\n  unsigned l;           /* last length */\n  unsigned m;           /* mask for bit lengths table */\n  unsigned n;           /* number of lengths to get */\n  struct huft *tl;      /* literal/length code table */\n  struct huft *td;      /* distance code table */\n  int bl;               /* lookup bits for tl */\n  int bd;               /* lookup bits for td */\n  unsigned nb;          /* number of bit length codes */\n  unsigned nl;          /* number of literal/length codes */\n  unsigned nd;          /* number of distance codes */\n#ifdef PKZIP_BUG_WORKAROUND\n  unsigned ll\u00dd288+32\u00a8; /* literal/length and distance code lengths */\n#else\n  unsigned ll\u00dd286+30\u00a8; /* literal/length and distance code lengths */\n#endif\n  register ulg b;       /* bit buffer */\n  register unsigned k;  /* number of bits in bit buffer */\n\n\n  /* make local bit buffer */\n  b = bb;\n  k = bk;\n\n\n  /* read in table lengths */\n  NEEDBITS(5)\n  nl = 257 + ((unsigned)b & 0x1f);      /* number of literal/length code*/\n  DUMPBITS(5)\n  NEEDBITS(5)\n  nd = 1 + ((unsigned)b & 0x1f);        /* number of distance codes */\n  DUMPBITS(5)\n  NEEDBITS(4)\n  nb = 4 + ((unsigned)b & 0xf);         /* number of bit length codes */\n  DUMPBITS(4)\n#ifdef PKZIP_BUG_WORKAROUND\n  if (nl > 288 \u00a6\u00a6 nd > 32)\n#else\n  if (nl > 286 \u00a6\u00a6 nd > 30)\n#endif\n    return 1;                   /* bad lengths */\n\n\n  /* read in bit-length-code lengths */\n  for (j = 0; j < nb; j++)\n  {\n    NEEDBITS(3)\n    ll\u00ddborder\u00ddj\u00a8\u00a8 = (unsigned)b & 7;\n    DUMPBITS(3)\n  }\n  for (; j < 19; j++)\n    ll\u00ddborder\u00ddj\u00a8\u00a8 = 0;\n\n\n  /* build decoding table for trees--single level, 7 bit lookup */\n  bl = 7;\n  if ((i = huft_build(ll, 19, 19, NULL, NULL, &tl, &bl)) != 0)\n  {\n    if (i == 1)\n      huft_free(tl);\n    return i;                   /* incomplete code set */\n  }\n\n\n  /* read in literal and distance code lengths */\n  n = nl + nd;\n  m = mask_bits\u00ddbl\u00a8;\n  i = l = 0;\n  while ((unsigned)i < n)\n  {\n    NEEDBITS((unsigned)bl)\n    j = (td = tl + ((unsigned)b & m))->b;\n    DUMPBITS(j)\n    j = td->v.n;\n    if (j < 16)                 /* length of code in bits (0..15) */\n      ll\u00ddi++\u00a8 = l = j;          /* save last length in l */\n    else if (j == 16)           /* repeat last length 3 to 6 times */\n    {\n      NEEDBITS(2)\n      j = 3 + ((unsigned)b & 3);\n      DUMPBITS(2)\n      if ((unsigned)i + j > n)\n        return 1;\n      while (j--)\n        ll\u00ddi++\u00a8 = l;\n    }\n    else if (j == 17)           /* 3 to 10 zero length codes */\n    {\n      NEEDBITS(3)\n      j = 3 + ((unsigned)b & 7);\n      DUMPBITS(3)\n      if ((unsigned)i + j > n)\n        return 1;\n      while (j--)\n        ll\u00ddi++\u00a8 = 0;\n      l = 0;\n    }\n    else                        /* j == 18: 11 to 138 zero length codes */\n    {\n      NEEDBITS(7)\n      j = 11 + ((unsigned)b & 0x7f);\n      DUMPBITS(7)\n      if ((unsigned)i + j > n)\n        return 1;\n      while (j--)\n        ll\u00ddi++\u00a8 = 0;\n      l = 0;\n    }\n  }\n\n\n  /* free decoding table for trees */\n  huft_free(tl);\n\n\n  /* restore the global bit buffer */\n  bb = b;\n  bk = k;\n\n\n  /* build the decoding tables for literal/length and distance codes */\n  bl = lbits;\n  if ((i = huft_build(ll, nl, 257, cplens, cplext, &tl, &bl)) != 0)\n  {\n    if (i == 1) {\n      fprintf(stderr, \" incomplete literal tree\\n\");\n      huft_free(tl);\n    }\n    return i;                   /* incomplete code set */\n  }\n  bd = dbits;\n  if ((i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &td, &bd)) != 0)\n  {\n    if (i == 1) {\n      fprintf(stderr, \" incomplete distance tree\\n\");\n#ifdef PKZIP_BUG_WORKAROUND\n      i = 0;\n    }\n#else\n      huft_free(td);\n    }\n    huft_free(tl);\n    return i;                   /* incomplete code set */\n#endif\n  }\n\n\n  /* decompress until an end-of-block code */\n  if (inflate_codes(tl, td, bl, bd))\n    return 1;\n\n\n  /* free the decoding tables, return */\n  huft_free(tl);\n  huft_free(td);\n  return 0;\n}\n\n\n\nint inflate_block(e)\nint *e;                 /* last block flag */\n/* decompress an inflated block */\n{\n  unsigned t;           /* block type */\n  register ulg b;       /* bit buffer */\n  register unsigned k;  /* number of bits in bit buffer */\n\n\n  /* make local bit buffer */\n  b = bb;\n  k = bk;\n\n\n  /* read in last block bit */\n  NEEDBITS(1)\n  *e = (int)b & 1;\n  DUMPBITS(1)\n\n\n  /* read in block type */\n  NEEDBITS(2)\n  t = (unsigned)b & 3;\n  DUMPBITS(2)\n\n\n  /* restore the global bit buffer */\n  bb = b;\n  bk = k;\n\n\n  /* inflate that block type */\n  if (t == 2)\n    return inflate_dynamic();\n  if (t == 0)\n    return inflate_stored();\n  if (t == 1)\n    return inflate_fixed();\n\n\n  /* bad block type */\n  return 2;\n}\n\n\n\nint inflate()\n/* decompress an inflated entry */\n{\n  int e;                /* last block flag */\n  int r;                /* result code */\n  unsigned h;           /* maximum struct huft's malloc'ed */\n\n\n  /* initialize window, bit buffer */\n  wp = 0;\n  bk = 0;\n  bb = 0;\n\n\n  /* decompress until the last block */\n  h = 0;\n  do {\n    hufts = 0;\n    if ((r = inflate_block(&e)) != 0)\n      return r;\n    if (hufts > h)\n      h = hufts;\n  } while (!e);\n\n  /* Undo too much lookahead. The next read will be byte aligned so we\n   * can discard unused bits in the last meaningful byte.\n   */\n  while (bk >= 8) {\n    bk -= 8;\n    inptr--;\n  }\n\n  /* flush out slide */\n  flush_output(wp);\n\n\n  /* return success */\n#ifdef DEBUG\n  fprintf(stderr, \"<%u> \", h);\n#endif /* DEBUG */\n  return 0;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LZW": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x98\\x11/\\x00\\x98\\x13\\x1f\\x10P\\x00\\x1c\\x00\\x19\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1998-04-22T00:00:00", "modifydate": "1998-05-11T10:50:00", "lines": 28, "newlines": 25, "modlines": 0, "user": "XSSGSCH"}, "text": "??=ifdef MVS    //* RS\n   ??=pragma filetag(\"IBM-1047\")  //* RS\n??=endif                          //* RS\n/* lzw.c -- compress files in LZW format.\n * This is a dummy version avoiding patent problems.\n */\n\n#ifndef lint\nstatic char rcsid\u00dd\u00a8 = \"$Id: lzw.c,v 0.9 1993/06/10 13:27:31 jloup Exp $\";\n#endif\n\n#include \"tailor.h\"\n#include \"gzip.h\"\n#include \"lzw.h\"\n\nstatic int msg_done = 0;\n\n/* Compress in to out with lzw method. */\nint lzw(in, out)\n    int in, out;\n{\n    if (msg_done) return ERROR;\n    msg_done = 1;\n    fprintf(stderr,\"output in compress .Z format not supported\\n\");\n    in++, out++; /* avoid warnings on unused variables */\n    exit_code = ERROR;\n    return ERROR;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAKEGZIP": {"ttr": 2567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x98\\x14\\x0f\\x00\\x98\\x18\\x9f \\x05\\x000\\x00,\\x00\\x00\\xd9\\xd6\\xd3\\xc1\\xd5\\xc4\\xe2@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1998-05-20T00:00:00", "modifydate": "1998-07-08T20:05:00", "lines": 48, "newlines": 44, "modlines": 0, "user": "ROLANDS"}, "text": "//ROLANDSC JOB (ACCT#),C-COMPILE,\n// NOTIFY=&SYSUID,\n// CLASS=A,\n// MSGCLASS=X\n//MLIB   JCLLIB ORDER=(ROLANDS.GZIP390.CNTL)\n//* I HAVE COMPILED GZIP WITH ALL TEST-OPTIONS!IF YOU\n//* HAVE PERFORMENCE PROBLEMS JUST CHANGE THE COPTS-MEMBER\n//* PROC CBCCO COMPILE/PRELINK/GENERATE C-PROGRAMM_OBJECT'S\n//* PROC CBCCL PRELINK/BIND             C-PROGRAMM_OBJECT'S\n//BITS  EXEC PROC=CBCCO,INFILE=ROLANDS.GZIP390.C(BITS),\n// OUTFILE='ROLANDS.GZIP.OBJ(BITS),DISP=SHR'\n//CRYPT EXEC PROC=CBCCO,INFILE=ROLANDS.GZIP390.C(CRYPT),\n// OUTFILE='ROLANDS.GZIP.OBJ(CRYPT),DISP=SHR'\n//C370  EXEC PROC=CBCCO,INFILE=ROLANDS.GZIP390.C(C370),\n// OUTFILE='ROLANDS.GZIP.OBJ(C370),DISP=SHR'\n//DEFLATE EXEC PROC=CBCCO,INFILE=ROLANDS.GZIP390.C(DEFLATE),\n// OUTFILE='ROLANDS.GZIP.OBJ(DEFLATE),DISP=SHR'\n//GETOPT EXEC PROC=CBCCO,INFILE=ROLANDS.GZIP390.C(GETOPT),\n// OUTFILE='ROLANDS.GZIP.OBJ(GETOPT),DISP=SHR'\n//GZIP   EXEC PROC=CBCCO,INFILE=ROLANDS.GZIP390.C(GZIP),\n// OUTFILE='ROLANDS.GZIP.OBJ(GZIP),DISP=SHR'\n//INFLATE EXEC PROC=CBCCO,INFILE=ROLANDS.GZIP390.C(INFLATE),\n// OUTFILE='ROLANDS.GZIP.OBJ(INFLATE),DISP=SHR'\n//LZW    EXEC PROC=CBCCO,INFILE=ROLANDS.GZIP390.C(LZW),\n// OUTFILE='ROLANDS.GZIP.OBJ(LZW),DISP=SHR'\n//TREES  EXEC PROC=CBCCO,INFILE=ROLANDS.GZIP390.C(TREES),\n// OUTFILE='ROLANDS.GZIP.OBJ(TREES),DISP=SHR'\n//UNLZH  EXEC PROC=CBCCO,INFILE=ROLANDS.GZIP390.C(UNLZH),\n// OUTFILE='ROLANDS.GZIP.OBJ(UNLZH),DISP=SHR'\n//UNLZW  EXEC PROC=CBCCO,INFILE=ROLANDS.GZIP390.C(UNLZW),\n// OUTFILE='ROLANDS.GZIP.OBJ(UNLZW),DISP=SHR'\n//UNPACK EXEC PROC=CBCCO,INFILE=ROLANDS.GZIP390.C(UNPACK),\n// OUTFILE='ROLANDS.GZIP.OBJ(UNPACK),DISP=SHR'\n//UNZIP  EXEC PROC=CBCCO,INFILE=ROLANDS.GZIP390.C(UNZIP),\n// OUTFILE='ROLANDS.GZIP.OBJ(UNZIP),DISP=SHR'\n//UTIL   EXEC PROC=CBCCO,INFILE=ROLANDS.GZIP390.C(UTIL),\n// OUTFILE='ROLANDS.GZIP.OBJ(UTIL),DISP=SHR'\n//ZIP    EXEC PROC=CBCCO,INFILE=ROLANDS.GZIP390.C(ZIP),\n// OUTFILE='ROLANDS.GZIP.OBJ(ZIP),DISP=SHR'\n//* NOW THE EXECUTABLE\n//COMP  EXEC PROC=CBCCL,INFILE=ROLANDS.GZIP390.C(GZIP),\n//   LPARM='AMODE=31,MAP,RENT',           < LINKAGE EDITOR OPTIONS\n// OUTFILE='ROLANDS.GZIP.PDS.LOAD(GZIP),DISP=SHR'\n//PLKED.SYSLIB DD\n//             DD DISP=SHR,DSN=ROLANDS.GZIP.OBJ\n//PLKED.SYSIN2 DD  *\nINCLUDE  SYSLIB(C370,GZIP,ZIP,DEFLATE,TREES,BITS,UNZIP,INFLATE)\nINCLUDE  SYSLIB(UTIL,CRYPT,LZW,UNLZW,UNPACK,GETOPT,UNLZH)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCANNER": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x98\\x12\\x8f\\x00\\x98\\x13\\x8f\\x13%\\x01.\\x01*\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-05-08T00:00:00", "modifydate": "1998-05-18T13:25:00", "lines": 302, "newlines": 298, "modlines": 0, "user": "XSSGSCH"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TREES": {"ttr": 2817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x98\\x12o\\x00\\x98\\x12\\x7f\\x11\\x10\\x04>\\x04=\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-05-06T00:00:00", "modifydate": "1998-05-07T11:10:00", "lines": 1086, "newlines": 1085, "modlines": 0, "user": "XSSGSCH"}, "text": "??=ifdef MVS    //* RS\n   ??=pragma filetag(\"IBM-1047\")  //* RS\n??=endif                          //* RS\n/* trees.c -- output deflated data using Huffman coding\n * Copyright (C) 1992-1993 Jean-loup Gailly\n * This is free software; you can redistribute it and/or modify it under the\n * terms of the GNU General Public License, see the file COPYING.\n */\n\n/*\n *  PURPOSE\n *\n *      Encode various sets of source values using variable-length\n *      binary code trees.\n *\n *  DISCUSSION\n *\n *      The PKZIP \"deflation\" process uses several Huffman trees. The more\n *      common source values are represented by shorter bit sequences.\n *\n *      Each code tree is stored in the ZIP file in a compressed form\n *      which is itself a Huffman encoding of the lengths of\n *      all the code strings (in ascending order by source values).\n *      The actual code strings are reconstructed from the lengths in\n *      the UNZIP process, as described in the \"application note\"\n *      (APPNOTE.TXT) distributed as part of PKWARE's PKZIP program.\n *\n *  REFERENCES\n *\n *      Lynch, Thomas J.\n *          Data Compression:  Techniques and Applications, pp. 53-55.\n *          Lifetime Learning Publications, 1985.  ISBN 0-534-03418-7.\n *\n *      Storer, James A.\n *          Data Compression:  Methods and Theory, pp. 49-50.\n *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.\n *\n *      Sedgewick, R.\n *          Algorithms, p290.\n *          Addison-Wesley, 1983. ISBN 0-201-06672-6.\n *\n *  INTERFACE\n *\n *      void ct_init (ush *attr, int *methodp)\n *          Allocate the match buffer, initialize the various tables and save\n *          the location of the internal file attribute (ascii/binary) and\n *          method (DEFLATE/STORE)\n *\n *      void ct_tally (int dist, int lc);\n *          Save the match info and tally the frequency counts.\n *\n *      long flush_block (char *buf, ulg stored_len, int eof)\n *          Determine the best encoding for the current block: dynamic trees,\n *          static trees or store, and output the encoded block to the zip\n *          file. Returns the total compressed length for the file so far.\n *\n */\n\n#include <ctype.h>\n\n#include \"tailor.h\"\n#include \"gzip.h\"\n\n#ifndef lint\nstatic char rcsid\u00dd\u00a8 = \"$Id: trees.c,v 0.12 1993/06/10 13:27:54 jloup Exp     $\";\n#endif\n\n/* ===========================================================================\n * Constants\n */\n\n#define MAX_BITS 15\n/* All codes must not exceed MAX_BITS bits */\n\n#define MAX_BL_BITS 7\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\n#define LENGTH_CODES 29\n/* number of length codes, not counting the special END_BLOCK code */\n\n#define LITERALS  256\n/* number of literal bytes 0..255 */\n\n#define END_BLOCK 256\n/* end of block literal code */\n\n#define L_CODES (LITERALS+1+LENGTH_CODES)\n/* number of Literal or Length codes, including the END_BLOCK code */\n\n#define D_CODES   30\n/* number of distance codes */\n\n#define BL_CODES  19\n/* number of codes used to transfer the bit lengths */\n\n\nlocal int near extra_lbits\u00ddLENGTH_CODES\u00a8 //* extra bits for each length     code\n   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};\n\nlocal int near extra_dbits\u00ddD_CODES\u00a8 /* extra bits for each distance code */\n   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};\n\nlocal int near extra_blbits\u00ddBL_CODES\u00a8 //* extra bits f.each bit length code\n   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};\n\n#define STORED_BLOCK 0\n#define STATIC_TREES 1\n#define DYN_TREES    2\n/* The three kinds of block type */\n\n#ifndef LIT_BUFSIZE\n#  ifdef SMALL_MEM\n#    define LIT_BUFSIZE  0x2000\n#  else\n#  ifdef MEDIUM_MEM\n#    define LIT_BUFSIZE  0x4000\n#  else\n#    define LIT_BUFSIZE  0x8000\n#  endif\n#  endif\n#endif\n#ifndef DIST_BUFSIZE\n#  define DIST_BUFSIZE  LIT_BUFSIZE\n#endif\n/* Sizes of match buffers for literals/lengths and distances.  There are\n * 4 reasons for limiting LIT_BUFSIZE to 64K:\n *   - frequencies can be kept in 16 bit counters\n *   - if compression is not successful for the first block, all input data is\n *     still in the window so we can still emit a stored block even when input\n *     comes from standard input.  (This can also be done for all blocks if\n *     LIT_BUFSIZE is not greater than 32K.)\n *   - if compression is not successful for a file smaller than 64K, we can\n *     even emit a stored file instead of a stored block (saving 5 bytes).\n *   - creating new Huffman trees less frequently may not provide fast\n *     adaptation to changes in the input data statistics. (Take for\n *     example a binary file with poorly compressible code followed by\n *     a highly compressible string table.) Smaller buffer sizes give\n *     fast adaptation but have of course the overhead of transmitting trees\n *     more frequently.\n *   - I can't count above 4\n * The current code is general and allows DIST_BUFSIZE < LIT_BUFSIZE (to save\n * memory at the expense of compression). Some optimizations would be possible\n * if we rely on DIST_BUFSIZE == LIT_BUFSIZE.\n */\n#if LIT_BUFSIZE > INBUFSIZ\n    error cannot overlay l_buf and inbuf\n#endif\n\n#define REP_3_6      16\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\n#define REPZ_3_10    17\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\n#define REPZ_11_138  18\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* ===========================================================================\n * Local data\n */\n\n/* Data structure describing a single value and its code string. */\ntypedef struct ct_data {\n    union {\n        ush  freq;       /* frequency count */\n        ush  code;       /* bit string */\n    } fc;\n    union {\n        ush  dad;        /* father node in Huffman tree */\n        ush  len;        /* length of bit string */\n    } dl;\n} ct_data;\n\n#define Freq fc.freq\n#define Code fc.code\n#define Dad  dl.dad\n#define Len  dl.len\n\n#define HEAP_SIZE (2*L_CODES+1)\n/* maximum heap size */\n\nlocal ct_data near dyn_ltree\u00ddHEAP_SIZE\u00a8; /* literal and length tree */\nlocal ct_data near dyn_dtree\u00dd2*D_CODES+1\u00a8; /* distance tree */\n\nlocal ct_data near static_ltree\u00ddL_CODES+2\u00a8;\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see ct_init\n * below).\n */\n\nlocal ct_data near static_dtree\u00ddD_CODES\u00a8;\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nlocal ct_data near bl_tree\u00dd2*BL_CODES+1\u00a8;\n/* Huffman tree for the bit lengths */\n\ntypedef struct tree_desc {\n    ct_data near *dyn_tree;      /* the dynamic tree */\n    ct_data near *static_tree;   /* corresponding static tree or NULL */\n    int     near *extra_bits;    /* extra bits for each code or NULL */\n    int     extra_base;          /* base index for extra_bits */\n    int     elems;               /* max number of elements in the tree */\n    int     max_length;          /* max bit length for the codes */\n    int     max_code;            /* largest code with non zero frequency */\n} tree_desc;\n\nlocal tree_desc near l_desc =\n{dyn_ltree, static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS, 0};\n\nlocal tree_desc near d_desc =\n{dyn_dtree, static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS, 0};\n\nlocal tree_desc near bl_desc =\n{bl_tree, (ct_data near *)0, extra_blbits, 0,      BL_CODES, MAX_BL_BITS, 0};\n\n\nlocal ush near bl_count\u00ddMAX_BITS+1\u00a8;\n/* number of codes at each bit length for an optimal tree */\n\nlocal uch near bl_order\u00ddBL_CODES\u00a8\n   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\nlocal int near heap\u00dd2*L_CODES+1\u00a8; /* heap used to build the Huffman trees     */\nlocal int heap_len;               /* number of elements in the heap */\nlocal int heap_max;               /* element of largest frequency */\n/* The sons of heap\u00ddn\u00a8 are heap\u00dd2*n\u00a8 and heap\u00dd2*n+1\u00a8.\nheap\u00dd0\u00a8 is not used.\n * The same heap array is used to build all trees.\n */\n\nlocal uch near depth\u00dd2*L_CODES+1\u00a8;\n/* Depth of each subtree used as tie breaker for trees of equal frequency */\n\nlocal uch length_code\u00ddMAX_MATCH-MIN_MATCH+1\u00a8;\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nlocal uch dist_code\u00dd512\u00a8;\n/* distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nlocal int near base_length\u00ddLENGTH_CODES\u00a8;\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nlocal int near base_dist\u00ddD_CODES\u00a8;\n/* First normalized distance for each code (0 = distance of 1) */\n\n#define l_buf inbuf\n/* DECLARE(uch, l_buf, LIT_BUFSIZE);  buffer for literals or lengths */\n\n/* DECLARE(ush, d_buf, DIST_BUFSIZE); buffer for distances */\n\nlocal uch near flag_buf\u00dd(LIT_BUFSIZE/8)\u00a8;\n/* flag_buf is a bit array distinguishing literals from lengths in\n * l_buf, thus indicating the presence or absence of a distance.\n */\n\nlocal unsigned last_lit;    /* running index in l_buf */\nlocal unsigned last_dist;   /* running index in d_buf */\nlocal unsigned last_flags;  /* running index in flag_buf */\nlocal uch flags;            /* current flags not yet saved in flag_buf */\nlocal uch flag_bit;         /* current bit used in flags */\n/* bits are filled in flags starting at bit 0 (least significant).\n * Note: these flags are overkill in the current code since we don't\n * take advantage of DIST_BUFSIZE == LIT_BUFSIZE.\n */\n\nlocal ulg opt_len;        /* bit length of current block with optimal trees */\nlocal ulg static_len;     /* bit length of current block with static trees */\n\nlocal ulg compressed_len; /* total bit length of compressed file */\n\nlocal ulg input_len;      /* total byte length of input file */\n/* input_len is for debugging only since we can get it by other means. */\n\nush *file_type;        /* pointer to UNKNOWN, BINARY or ASCII */\nint *file_method;      /* pointer to DEFLATE or STORE */\n\n#ifdef DEBUG\nextern ulg bits_sent;  /* bit length of the compressed data */\nextern long isize;     /* byte length of input file */\n#endif\n\nextern long block_start;       /* window offset of current block */\nextern unsigned near strstart; /* window offset of current string */\n\n/* ===========================================================================\n * Local (static) routines in this file.\n */\n\nlocal void init_block     OF((void));\nlocal void pqdownheap     OF((ct_data near *tree, int k));\nlocal void gen_bitlen     OF((tree_desc near *desc));\nlocal void gen_codes      OF((ct_data near *tree, int max_code));\nlocal void build_tree     OF((tree_desc near *desc));\nlocal void scan_tree      OF((ct_data near *tree, int max_code));\nlocal void send_tree      OF((ct_data near *tree, int max_code));\nlocal int  build_bl_tree  OF((void));\nlocal void send_all_trees OF((int lcodes, int dcodes, int blcodes));\nlocal void compress_block OF((ct_data near *ltree, ct_data near *dtree));\nlocal void set_file_type  OF((void));\n\n\n#ifndef DEBUG\n#  define send_code(c, tree) send_bits(tree\u00ddc\u00a8.Code, tree\u00ddc\u00a8.Len)\n   /* Send a code of the given tree. c and tree must not have side effects */\n\n#else /* DEBUG */\n#  define send_code(c, tree) \\\n     { if (verbose>1) fprintf(stderr,\"\\ncd %3d \",(c)); \\\n       send_bits(tree\u00ddc\u00a8.Code, tree\u00ddc\u00a8.Len); }\n#endif\n\n#define d_code(dist) \\\n   ((dist) < 256 ? dist_code\u00dddist\u00a8 : dist_code\u00dd256+((dist)>>7)\u00a8)\n/* Mapping from a distance to a distance code. dist is the distance - 1 and\n * must not have side effects. dist_code\u00dd256\u00a8 and\n *  dist_code\u00dd257\u00a8 are never used.\n */\n\n#define MAX(a,b) (a >= b ? a : b)\n/* the arguments must not have side effects */\n\n/* ===========================================================================\n * Allocate the match buffer, initialize the various tables and save the\n * location of the internal file attribute (ascii/binary) and method\n * (DEFLATE/STORE).\n */\nvoid ct_init(attr, methodp)\n    ush  *attr;   /* pointer to internal file attribute */\n    int  *methodp; /* pointer to compression method */\n{\n    int n;        /* iterates over tree elements */\n    int bits;     /* bit counter */\n    int length;   /* length value */\n    int code;     /* code value */\n    int dist;     /* distance index */\n\n    file_type = attr;\n    file_method = methodp;\n    compressed_len = input_len = 0L;\n\n    if (static_dtree\u00dd0\u00a8.Len != 0) return; /* ct_init already called */\n\n    /* Initialize the mapping length (0..255) -> length code (0..28) */\n    length = 0;\n    for (code = 0; code < LENGTH_CODES-1; code++) {\n        base_length\u00ddcode\u00a8 = length;\n        for (n = 0; n < (1<<extra_lbits\u00ddcode\u00a8); n++) {\n            length_code\u00ddlength++\u00a8 = (uch)code;\n        }\n    }\n    Assert (length == 256, \"ct_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code\u00dd255\u00a8 to use the best encoding:\n     */\n    length_code\u00ddlength-1\u00a8 = (uch)code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for (code = 0 ; code < 16; code++) {\n        base_dist\u00ddcode\u00a8 = dist;\n        for (n = 0; n < (1<<extra_dbits\u00ddcode\u00a8); n++) {\n            dist_code\u00dddist++\u00a8 = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"ct_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */\n    for ( ; code < D_CODES; code++) {\n        base_dist\u00ddcode\u00a8 = dist << 7;\n        for (n = 0; n < (1<<(extra_dbits\u00ddcode\u00a8-7)); n++) {\n            dist_code\u00dd256 + dist++\u00a8 = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"ct_init: 256+dist != 512\");\n\n    /* Construct the codes of the static literal tree */\n    for (bits = 0; bits <= MAX_BITS; bits++) bl_count\u00ddbits\u00a8 = 0;\n    n = 0;\n    while (n <= 143) static_ltree\u00ddn++\u00a8.Len = 8, bl_count\u00dd8\u00a8++;\n    while (n <= 255) static_ltree\u00ddn++\u00a8.Len = 9, bl_count\u00dd9\u00a8++;\n    while (n <= 279) static_ltree\u00ddn++\u00a8.Len = 7, bl_count\u00dd7\u00a8++;\n    while (n <= 287) static_ltree\u00ddn++\u00a8.Len = 8, bl_count\u00dd8\u00a8++;\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    gen_codes((ct_data near *)static_ltree, L_CODES+1);\n\n    /* The static distance tree is trivial: */\n    for (n = 0; n < D_CODES; n++) {\n        static_dtree\u00ddn\u00a8.Len = 5;\n        static_dtree\u00ddn\u00a8.Code = bi_reverse(n, 5);\n    }\n\n    /* Initialize the first block of the first file: */\n    init_block();\n}\n\n/* ===========================================================================\n * Initialize a new block.\n */\nlocal void init_block()\n{\n    int n; /* iterates over tree elements */\n\n    /* Initialize the trees. */\n    for (n = 0; n < L_CODES;  n++) dyn_ltree\u00ddn\u00a8.Freq = 0;\n    for (n = 0; n < D_CODES;  n++) dyn_dtree\u00ddn\u00a8.Freq = 0;\n    for (n = 0; n < BL_CODES; n++) bl_tree\u00ddn\u00a8.Freq = 0;\n\n    dyn_ltree\u00ddEND_BLOCK\u00a8.Freq = 1;\n    opt_len = static_len = 0L;\n    last_lit = last_dist = last_flags = 0;\n    flags = 0; flag_bit = 1;\n}\n\n#define SMALLEST 1\n/* Index within the heap array of least frequent node in the Huffman tree */\n\n\n/* ===========================================================================\n * Remove the smallest element from the heap and recreate the heap with\n * one less element. Updates heap and heap_len.\n */\n#define pqremove(tree, top) \\\n{\\\n    top = heap\u00ddSMALLEST\u00a8; \\\n    heap\u00ddSMALLEST\u00a8 = heap\u00ddheap_len--\u00a8; \\\n    pqdownheap(tree, SMALLEST); \\\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\n#define smaller(tree, n, m) \\\n   (tree\u00ddn\u00a8.Freq < tree\u00ddm\u00a8.Freq \u00a6\u00a6 \\\n   (tree\u00ddn\u00a8.Freq == tree\u00ddm\u00a8.Freq && depth\u00ddn\u00a8 <= depth\u00ddm\u00a8))\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nlocal void pqdownheap(tree, k)\n    ct_data near *tree;  /* the tree to restore */\n    int k;               /* node to move down */\n{\n    int v = heap\u00ddk\u00a8;\n    int j = k << 1;  /* left son of k */\n    while (j <= heap_len) {\n        /* Set j to the smallest of the two sons: */\n        if (j < heap_len && smaller(tree, heap\u00ddj+1\u00a8, heap\u00ddj\u00a8)) j++;\n\n        /* Exit if v is smaller than both sons */\n        if (smaller(tree, v, heap\u00ddj\u00a8)) break;\n\n        /* Exchange v with the smallest son */\n        heap\u00ddk\u00a8 = heap\u00ddj\u00a8; k = j;\n\n        /* And continue down the tree, setting j to the left son of k */\n        j <<= 1;\n    }\n    heap\u00ddk\u00a8 = v;\n}\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap\u00ddheap_max\u00a8 and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nlocal void gen_bitlen(desc)\n    tree_desc near *desc; /* the tree descriptor */\n{\n    ct_data near *tree  = desc->dyn_tree;\n    int near *extra     = desc->extra_bits;\n    int base            = desc->extra_base;\n    int max_code        = desc->max_code;\n    int max_length      = desc->max_length;\n    ct_data near *stree = desc->static_tree;\n    int h;              /* heap index */\n    int n, m;           /* iterate over the tree elements */\n    int bits;           /* bit length */\n    int xbits;          /* extra bits */\n    ush f;              /* frequency */\n    int overflow = 0;   /* number of elements with bit length too large */\n\n    for (bits = 0; bits <= MAX_BITS; bits++) bl_count\u00ddbits\u00a8 = 0;\n\n    /* In a first pass, compute the optimal bit lengths (which may\n     * overflow in the case of the bit length tree).\n     */\n    tree\u00ddheap\u00ddheap_max\u00a8\u00a8.Len = 0; /* root of the heap */\n\n    for (h = heap_max+1; h < HEAP_SIZE; h++) {\n        n = heap\u00ddh\u00a8;\n        bits = tree\u00ddtree\u00ddn\u00a8.Dad\u00a8.Len + 1;\n        if (bits > max_length) bits = max_length, overflow++;\n        tree\u00ddn\u00a8.Len = (ush)bits;\n        /* We overwrite tree\u00ddn\u00a8.Dad which is no longer needed */\n\n        if (n > max_code) continue; /* not a leaf node */\n\n        bl_count\u00ddbits\u00a8++;\n        xbits = 0;\n        if (n >= base) xbits = extra\u00ddn-base\u00a8;\n        f = tree\u00ddn\u00a8.Freq;\n        opt_len += (ulg)f * (bits + xbits);\n        if (stree) static_len += (ulg)f * (stree\u00ddn\u00a8.Len + xbits);\n    }\n    if (overflow == 0) return;\n\n    Trace((stderr,\"\\nbit length overflow\\n\"));\n    /* This happens for example on obj2 and pic of the Calgary corpus */\n\n    /* Find the first bit length which could increase: */\n    do {\n        bits = max_length-1;\n        while (bl_count\u00ddbits\u00a8 == 0) bits--;\n        bl_count\u00ddbits\u00a8--;      /* move one leaf down the tree */\n        bl_count\u00ddbits+1\u00a8 += 2; /* move one overflow item as its brother */\n        bl_count\u00ddmax_length\u00a8--;\n        /* The brother of the overflow item also moves one step up,\n         * but this does not affect bl_count\u00ddmax_length\u00a8\n         */\n        overflow -= 2;\n    } while (overflow > 0);\n\n    /* Now recompute all bit lengths, scanning in increasing frequency.\n     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n     * lengths instead of fixing only the wrong ones. This idea is taken\n     * from 'ar' written by Haruhiko Okumura.)\n     */\n    for (bits = max_length; bits != 0; bits--) {\n        n = bl_count\u00ddbits\u00a8;\n        while (n != 0) {\n            m = heap\u00dd--h\u00a8;\n            if (m > max_code) continue;\n            if (tree\u00ddm\u00a8.Len != (unsigned) bits) {\n                Trace((stderr,\"code %d bits %d->%d\\n\", m,\n                       tree\u00ddm\u00a8.Len, bits));\n                opt_len += ((long)bits-(long)tree\u00ddm\u00a8.Len)*\n                            (long)tree\u00ddm\u00a8.Freq;\n                tree\u00ddm\u00a8.Len = (ush)bits;\n            }\n            n--;\n        }\n    }\n}\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nlocal void gen_codes (tree, max_code)\n    ct_data near *tree;        /* the tree to decorate */\n    int max_code;              /* largest code with non zero frequency */\n{\n    ush next_code\u00ddMAX_BITS+1\u00a8; /* next code value for each bit length */\n    ush code = 0;              /* running code value */\n    int bits;                  /* bit index */\n    int n;                     /* code index */\n\n    /* The distribution counts are first used to generate the code values\n     * without bit reversal.\n     */\n    for (bits = 1; bits <= MAX_BITS; bits++) {\n        next_code\u00ddbits\u00a8 = code = (code + bl_count\u00ddbits-1\u00a8) << 1;\n    }\n    /* Check that the bit counts in bl_count are consistent. The last code\n     * must be all ones.\n     */\n    Assert (code + bl_count\u00ddMAX_BITS\u00a8-1 == (1<<MAX_BITS)-1,\n            \"inconsistent bit counts\");\n    Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n    for (n = 0;  n <= max_code; n++) {\n        int len = tree\u00ddn\u00a8.Len;\n        if (len == 0) continue;\n        /* Now reverse the bits */\n        tree\u00ddn\u00a8.Code = bi_reverse(next_code\u00ddlen\u00a8++, len);\n\n        Tracec(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n             n, (isgraph(n) ? n : ' '), len,\n    tree     \u00ddn\u00a8.Code, next_code\u00ddlen\u00a8-1));\n    }\n}\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nlocal void build_tree(desc)\n    tree_desc near *desc; /* the tree descriptor */\n{\n    ct_data near *tree   = desc->dyn_tree;\n    ct_data near *stree  = desc->static_tree;\n    int elems            = desc->elems;\n    int n, m;          /* iterate over heap elements */\n    int max_code = -1; /* largest code with non zero frequency */\n    int node = elems;  /* next internal node of the tree */\n\n    /* Construct the initial heap, with least frequent element in\n     * heap\u00ddSMALLEST\u00a8. The sons of heap\u00ddn\u00a8 are heap\u00dd2*n\u00a8 and\n     heap\u00dd2*n+1\u00a8.\n     * heap\u00dd0\u00a8 is not used.\n     */\n    heap_len = 0, heap_max = HEAP_SIZE;\n\n    for (n = 0; n < elems; n++) {\n        if (tree\u00ddn\u00a8.Freq != 0) {\n            heap\u00dd++heap_len\u00a8 = max_code = n;\n            depth\u00ddn\u00a8 = 0;\n        } else {\n            tree\u00ddn\u00a8.Len = 0;\n        }\n    }\n\n    /* The pkzip format requires that at least one distance code exists,\n     * and that at least one bit should be sent even if there is only one\n     * possible code. So to avoid special checks later on we force at least\n     * two codes of non zero frequency.\n     */\n    while (heap_len < 2) {\n        int new = heap\u00dd++heap_len\u00a8 = (max_code < 2 ? ++max_code : 0);\n        tree\u00ddnew\u00a8.Freq = 1;\n        depth\u00ddnew\u00a8 = 0;\n        opt_len--; if (stree) static_len -= stree\u00ddnew\u00a8.Len;\n        /* new is 0 or 1 so it does not have extra bits */\n    }\n    desc->max_code = max_code;\n\n    /* The elements heap\u00ddheap_len/2+1 .. heap_len\u00a8 are leaves of the tree,\n     * establish sub-heaps of increasing lengths:\n     */\n    for (n = heap_len/2; n >= 1; n--) pqdownheap(tree, n);\n\n    /* Construct the Huffman tree by repeatedly combining the least two\n     * frequent nodes.\n     */\n    do {\n        pqremove(tree, n);   /* n = node of least frequency */\n        m = heap\u00ddSMALLEST\u00a8; /* m = node of next least frequency */\n\n        heap\u00dd--heap_max\u00a8 = n; /* keep the nodes sorted by frequency */\n        heap\u00dd--heap_max\u00a8 = m;\n\n        /* Create a new node father of n and m */\n        tree\u00ddnode\u00a8.Freq = tree\u00ddn\u00a8.Freq + tree\u00ddm\u00a8.Freq;\n        depth\u00ddnode\u00a8 = (uch) (MAX(depth\u00ddn\u00a8, depth\u00ddm\u00a8) + 1);\n        tree\u00ddn\u00a8.Dad = tree\u00ddm\u00a8.Dad = (ush)node;\n#ifdef DUMP_BL_TREE\n        if (tree == bl_tree) {\n            fprintf(stderr,\"\\nnode %d(%d), sons %d(%d) %d(%d)\",\n                    node, tree\u00ddnode\u00a8.Freq, n,\n                    tree\u00ddn\u00a8.Freq, m, tree\u00ddm\u00a8.Freq);\n        }\n#endif\n        /* and insert the new node in the heap */\n        heap\u00ddSMALLEST\u00a8 = node++;\n        pqdownheap(tree, SMALLEST);\n\n    } while (heap_len >= 2);\n\n    heap\u00dd--heap_max\u00a8 = heap\u00ddSMALLEST\u00a8;\n\n    /* At this point, the fields freq and dad are set. We can now\n     * generate the bit lengths.\n     */\n    gen_bitlen((tree_desc near *)desc);\n\n    /* The field len is now set, we can generate the bit codes */\n    gen_codes ((ct_data near *)tree, max_code);\n}\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree. Updates opt_len to take into account the repeat\n * counts. (The contribution of the bit length codes will be added later\n * during the construction of bl_tree.)\n */\nlocal void scan_tree (tree, max_code)\n    ct_data near *tree; /* the tree to be scanned */\n    int max_code;       /* and its largest code of non zero frequency */\n{\n    int n;                     /* iterates over all tree elements */\n    int prevlen = -1;          /* last emitted length */\n    int curlen;                /* length of current code */\n    int nextlen = tree\u00dd0\u00a8.Len; /* length of next code */\n    int count = 0;             /* repeat count of the current code */\n    int max_count = 7;         /* max repeat count */\n    int min_count = 4;         /* min repeat count */\n\n    if (nextlen == 0) max_count = 138, min_count = 3;\n    tree\u00ddmax_code+1\u00a8.Len = (ush)0xffff; /* guard */\n\n    for (n = 0; n <= max_code; n++) {\n        curlen = nextlen; nextlen = tree\u00ddn+1\u00a8.Len;\n        if (++count < max_count && curlen == nextlen) {\n            continue;\n        } else if (count < min_count) {\n            bl_tree\u00ddcurlen\u00a8.Freq += count;\n        } else if (curlen != 0) {\n            if (curlen != prevlen) bl_tree\u00ddcurlen\u00a8.Freq++;\n            bl_tree\u00ddREP_3_6\u00a8.Freq++;\n        } else if (count <= 10) {\n            bl_tree\u00ddREPZ_3_10\u00a8.Freq++;\n        } else {\n            bl_tree\u00ddREPZ_11_138\u00a8.Freq++;\n        }\n        count = 0; prevlen = curlen;\n        if (nextlen == 0) {\n            max_count = 138, min_count = 3;\n        } else if (curlen == nextlen) {\n            max_count = 6, min_count = 3;\n        } else {\n            max_count = 7, min_count = 4;\n        }\n    }\n}\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nlocal void send_tree (tree, max_code)\n    ct_data near *tree; /* the tree to be scanned */\n    int max_code;       /* and its largest code of non zero frequency */\n{\n    int n;                     /* iterates over all tree elements */\n    int prevlen = -1;          /* last emitted length */\n    int curlen;                /* length of current code */\n    int nextlen = tree\u00dd0\u00a8.Len; /* length of next code */\n    int count = 0;             /* repeat count of the current code */\n    int max_count = 7;         /* max repeat count */\n    int min_count = 4;         /* min repeat count */\n\n    /* tree\u00ddmax_code+1\u00a8.Len = -1; */ /* guard already set */\n    if (nextlen == 0) max_count = 138, min_count = 3;\n\n    for (n = 0; n <= max_code; n++) {\n        curlen = nextlen; nextlen = tree\u00ddn+1\u00a8.Len;\n        if (++count < max_count && curlen == nextlen) {\n            continue;\n        } else if (count < min_count) {\n            do { send_code(curlen, bl_tree); } while (--count != 0);\n\n        } else if (curlen != 0) {\n            if (curlen != prevlen) {\n                send_code(curlen, bl_tree); count--;\n            }\n            Assert(count >= 3 && count <= 6, \" 3_6?\");\n            send_code(REP_3_6, bl_tree); send_bits(count-3, 2);\n\n        } else if (count <= 10) {\n            send_code(REPZ_3_10, bl_tree); send_bits(count-3, 3);\n\n        } else {\n            send_code(REPZ_11_138, bl_tree); send_bits(count-11, 7);\n        }\n        count = 0; prevlen = curlen;\n        if (nextlen == 0) {\n            max_count = 138, min_count = 3;\n        } else if (curlen == nextlen) {\n            max_count = 6, min_count = 3;\n        } else {\n            max_count = 7, min_count = 4;\n        }\n    }\n}\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nlocal int build_bl_tree()\n{\n    int max_blindex;  /* index of last bit length code of non zero freq */\n\n    /* Determine the bit length frequencies for literal and distance trees */\n    scan_tree((ct_data near *)dyn_ltree, l_desc.max_code);\n    scan_tree((ct_data near *)dyn_dtree, d_desc.max_code);\n\n    /* Build the bit length tree: */\n    build_tree((tree_desc near *)(&bl_desc));\n    /* opt_len now includes the length of the tree representations, except\n     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n     */\n\n    /* Determine the number of bit length codes to send. The pkzip format\n     * requires that at least 4 bit length codes be sent. (appnote.txt says\n     * 3 but the actual value used is 4.)\n     */\n    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {\n        if (bl_tree\u00ddbl_order\u00ddmax_blindex\u00a8\u00a8.Len != 0) break;\n    }\n    /* Update opt_len to include the bit length tree and counts */\n    opt_len += 3*(max_blindex+1) + 5+5+4;\n    Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\", opt_len, static_len));\n\n    return max_blindex;\n}\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nlocal void send_all_trees(lcodes, dcodes, blcodes)\n    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n    int rank;                    /* index in bl_order */\n\n    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n            \"too many codes\");\n    Tracev((stderr, \"\\nbl counts: \"));\n    send_bits(lcodes-257, 5); /* not +255 as stated in appnote.txt */\n    send_bits(dcodes-1,   5);\n    send_bits(blcodes-4,  4); /* not -3 as stated in appnote.txt */\n    for (rank = 0; rank < blcodes; rank++) {\n        Tracev((stderr, \"\\nbl code %2d \", bl_order\u00ddrank\u00a8));\n        send_bits(bl_tree\u00ddbl_order\u00ddrank\u00a8\u00a8.Len, 3);\n    }\n    Tracev((stderr, \"\\nbl tree: sent %ld\", bits_sent));\n\n    send_tree((ct_data near *)dyn_ltree, lcodes-1); /* send the literal tree */\n    Tracev((stderr, \"\\nlit tree: sent %ld\", bits_sent));\n\n    send_tree((ct_data near *)dyn_dtree, dcodes-1); /* send the distance tree */\n    Tracev((stderr, \"\\ndist tree: sent %ld\", bits_sent));\n}\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file. This function\n * returns the total compressed length for the file so far.\n */\nulg flush_block(buf, stored_len, eof)\n    char *buf;        /* input block, or NULL if too old */\n    ulg stored_len;   /* length of input block */\n    int eof;          /* true if this is the last block for a file */\n{\n    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */\n    int max_blindex;  /* index of last bit length code of non zero freq */\n\n    flag_buf\u00ddlast_flags\u00a8 = flags; /* Save the flags for the last 8 items */\n\n     /* Check if the file is ascii or binary */\n    if (*file_type == (ush)UNKNOWN) set_file_type();\n\n    /* Construct the literal and distance trees */\n    build_tree((tree_desc near *)(&l_desc));\n    Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", opt_len, static_len));\n\n    build_tree((tree_desc near *)(&d_desc));\n    Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", opt_len, static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree();\n\n    /* Determine the best encoding. Compute first the block length in bytes */\n    opt_lenb = (opt_len+3+7)>>3;\n    static_lenb = (static_len+3+7)>>3;\n    input_len += stored_len; /* for debugging only */\n\n    Trace((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u \",\n            opt_lenb, opt_len, static_lenb, static_len, stored_len,\n            last_lit, last_dist));\n\n    if (static_lenb <= opt_lenb) opt_lenb = static_lenb;\n\n    /* If compression failed and this is the first and last block,\n     * and if the zip file can be seeked (to rewrite the local header),\n     * the whole file is transformed into a stored file:\n     */\n#ifdef FORCE_METHOD\n    if (level == 1 && eof && compressed_len == 0L) { /* force stored file */\n#else\n    if (stored_len <= opt_lenb && eof && compressed_len == 0L && seekable()) {\n#endif\n        /* Since LIT_BUFSIZE <= 2*WSIZE, the input data must be there: */\n        if (buf == (char*)0) error (\"block vanished\");\n\n        copy_block(buf, (unsigned)stored_len, 0); /* without header */\n        compressed_len = stored_len << 3;\n        *file_method = STORED;\n\n#ifdef FORCE_METHOD\n    } else if (level == 2 && buf != (char*)0) { /* force stored block */\n#else\n    } else if (stored_len+4 <= opt_lenb && buf != (char*)0) {\n                       /* 4: two words for the lengths */\n#endif\n        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n         * Otherwise we can't have processed more than WSIZE input bytes since\n         * the last block flush, because compression would have been\n         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n         * transform a block into a stored block.\n         */\n        send_bits((STORED_BLOCK<<1)+eof, 3);  /* send block type */\n        compressed_len = (compressed_len + 3 + 7) & ~7L;\n        compressed_len += (stored_len + 4) << 3;\n\n        copy_block(buf, (unsigned)stored_len, 1); /* with header */\n\n#ifdef FORCE_METHOD\n    } else if (level == 3) { /* force static trees */\n#else\n    } else if (static_lenb == opt_lenb) {\n#endif\n        send_bits((STATIC_TREES<<1)+eof, 3);\n        compress_block((ct_data near *)static_ltree,\n                       (ct_data near *)static_dtree);\n        compressed_len += 3 + static_len;\n    } else {\n        send_bits((DYN_TREES<<1)+eof, 3);\n        send_all_trees(l_desc.max_code+1, d_desc.max_code+1, max_blindex+1);\n        compress_block((ct_data near *)dyn_ltree, (ct_data near *)dyn_dtree);\n        compressed_len += 3 + opt_len;\n    }\n    Assert (compressed_len == bits_sent, \"bad compressed size\");\n    init_block();\n\n    if (eof) {\n        Assert (input_len == isize, \"bad input size\");\n        bi_windup();\n        compressed_len += 7;  /* align on byte boundary */\n    }\n    Tracev((stderr,\"\\ncomprlen %lu(%lu) \", compressed_len>>3,\n           compressed_len-7*eof));\n\n    return compressed_len >> 3;\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nint ct_tally (dist, lc)\n    int dist;  /* distance of matched string */\n    int lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n    l_buf\u00ddlast_lit++\u00a8 = (uch)lc;\n    if (dist == 0) {\n        /* lc is the unmatched char */\n        dyn_ltree\u00ddlc\u00a8.Freq++;\n    } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        dist--;             /* dist = match distance - 1 */\n        Assert((ush)dist < (ush)MAX_DIST &&\n               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n               (ush)d_code(dist) < (ush)D_CODES,  \"ct_tally: bad match\");\n\n        dyn_ltree\u00ddlength_code\u00ddlc\u00a8+LITERALS+1\u00a8.Freq++;\n        dyn_dtree\u00ddd_code(dist)\u00a8.Freq++;\n\n        d_buf\u00ddlast_dist++\u00a8 = (ush)dist;\n        flags \u00a6= flag_bit;\n    }\n    flag_bit <<= 1;\n\n    /* Output the flags if they fill a byte: */\n    if ((last_lit & 7) == 0) {\n        flag_buf\u00ddlast_flags++\u00a8 = flags;\n        flags = 0, flag_bit = 1;\n    }\n    /* Try to guess if it is profitable to stop the current block here */\n    if (level > 2 && (last_lit & 0xfff) == 0) {\n        /* Compute an upper bound for the compressed length */\n        ulg out_length = (ulg)last_lit*8L;\n        ulg in_length = (ulg)strstart-block_start;\n        int dcode;\n        for (dcode = 0; dcode < D_CODES; dcode++) {\n            out_length += (ulg)dyn_dtree\u00dddcode\u00a8.Freq*\n                          (5L+extra_dbits\u00dddcode\u00a8);\n        }\n        out_length >>= 3;\n        Trace((stderr,\"\\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) \",\n               last_lit, last_dist, in_length, out_length,\n               100L - out_length*100L/in_length));\n        if (last_dist < last_lit/2 && out_length < in_length/2) return 1;\n    }\n    return (last_lit == LIT_BUFSIZE-1 \u00a6\u00a6 last_dist == DIST_BUFSIZE);\n    /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K\n     * on 16 bit machines and because stored blocks are restricted to\n     * 64K-1 bytes.\n     */\n}\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nlocal void compress_block(ltree, dtree)\n    ct_data near *ltree; /* literal tree */\n    ct_data near *dtree; /* distance tree */\n{\n    unsigned dist;      /* distance of matched string */\n    int lc;             /* match length or unmatched char (if dist == 0) */\n    unsigned lx = 0;    /* running index in l_buf */\n    unsigned dx = 0;    /* running index in d_buf */\n    unsigned fx = 0;    /* running index in flag_buf */\n    uch flag = 0;       /* current flags */\n    unsigned code;      /* the code to send */\n    int extra;          /* number of extra bits to send */\n\n    if (last_lit != 0) do {\n        if ((lx & 7) == 0) flag = flag_buf\u00ddfx++\u00a8;\n        lc = l_buf\u00ddlx++\u00a8;\n        if ((flag & 1) == 0) {\n            send_code(lc, ltree); /* send a literal byte */\n            Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n        } else {\n            /* Here, lc is the match length - MIN_MATCH */\n            code = length_code\u00ddlc\u00a8;\n            send_code(code+LITERALS+1, ltree); /* send the length code */\n            extra = extra_lbits\u00ddcode\u00a8;\n            if (extra != 0) {\n                lc -= base_length\u00ddcode\u00a8;\n                send_bits(lc, extra);        /* send the extra length bits */\n            }\n            dist = d_buf\u00dddx++\u00a8;\n            /* Here, dist is the match distance - 1 */\n            code = d_code(dist);\n            Assert (code < D_CODES, \"bad d_code\");\n\n            send_code(code, dtree);       /* send the distance code */\n            extra = extra_dbits\u00ddcode\u00a8;\n            if (extra != 0) {\n                dist -= base_dist\u00ddcode\u00a8;\n                send_bits(dist, extra);   /* send the extra distance bits */\n            }\n        } /* literal or match pair ? */\n        flag >>= 1;\n    } while (lx < last_lit);\n\n    send_code(END_BLOCK, ltree);\n}\n\n/* ===========================================================================\n * Set the file type to ASCII or BINARY, using a crude approximation:\n * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.\n * IN assertion: the fields freq of dyn_ltree are set and the total of all\n * frequencies does not exceed 64K (to fit in an int on 16 bit machines).\n */\nlocal void set_file_type()\n{\n    int n = 0;\n    unsigned ascii_freq = 0;\n    unsigned bin_freq = 0;\n    while (n < 7)        bin_freq += dyn_ltree\u00ddn++\u00a8.Freq;\n    while (n < 128)    ascii_freq += dyn_ltree\u00ddn++\u00a8.Freq;\n    while (n < LITERALS) bin_freq += dyn_ltree\u00ddn++\u00a8.Freq;\n    *file_type = bin_freq > (ascii_freq >> 2) ? BINARY : ASCII;\n    if (*file_type == BINARY && translate_eol) {\n        warn(\"-l used on binary file\", \"\");\n    }\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNLZH": {"ttr": 3081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x12o\\x00\\x98\\x12\\x7f\\x11\\x10\\x01\\x94\\x01\\x94\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-05-06T00:00:00", "modifydate": "1998-05-07T11:10:00", "lines": 404, "newlines": 404, "modlines": 0, "user": "XSSGSCH"}, "text": "??=ifdef MVS    //* RS\n   ??=pragma filetag(\"IBM-1047\")  //* RS\n??=endif                          //* RS\n/* unlzh.c -- decompress files in SCO compress -H (LZH) format.\n * The code in this file is directly derived from the public domain 'ar002'\n * written by Haruhiko Okumura.\n */\n\n#ifndef lint\nstatic char rcsid\u00dd\u00a8 = \"$Id: $\";\n#endif\n\n#include <stdio.h>\n\n#include \"tailor.h\"\n#include \"gzip.h\"\n#include \"lzw.h\" /* just for consistency checking */\n\n/* decode.c */\n\nlocal unsigned  decode  OF((unsigned count, uch buffer\u00dd\u00a8));\nlocal void decode_start OF((void));\n\n/* huf.c */\nlocal void huf_decode_start OF((void));\nlocal unsigned decode_c     OF((void));\nlocal unsigned decode_p     OF((void));\nlocal void read_pt_len      OF((int nn, int nbit, int i_special));\nlocal void read_c_len       OF((void));\n\n/* io.c */\nlocal void fillbuf      OF((int n));\nlocal unsigned getbits  OF((int n));\nlocal void init_getbits OF((void));\n\n/* maketbl.c */\n\nlocal void make_table OF((int nchar, uch bitlen\u00dd\u00a8,\n                          int tablebits, ush table\u00dd\u00a8));\n\n\n#define DICBIT    13    /* 12(-lh4-) or 13(-lh5-) */\n#define DICSIZ ((unsigned) 1 << DICBIT)\n\n#ifndef CHAR_BIT\n#  define CHAR_BIT 8\n#endif\n\n#ifndef UCHAR_MAX\n#  define UCHAR_MAX 255\n#endif\n\n#define BITBUFSIZ (CHAR_BIT * 2 * sizeof(char))\n/* Do not use CHAR_BIT * sizeof(bitbuf), does not work on machines\n * for which short is not on 16 bits (Cray).\n */\n\n/* encode.c and decode.c */\n\n#define MAXMATCH 256    /* formerly F (not more than UCHAR_MAX + 1) */\n#define THRESHOLD  3    /* choose optimal value */\n\n/* huf.c */\n\n#define NC (UCHAR_MAX + MAXMATCH + 2 - THRESHOLD)\n        /* alphabet = {0, 1, 2, ..., NC - 1} */\n#define CBIT 9  /* $\\lfloor \\log_2 NC \\rfloor + 1$ */\n#define CODE_BIT  16  /* codeword length */\n\n#define NP (DICBIT + 1)\n#define NT (CODE_BIT + 3)\n#define PBIT 4  /* smallest integer such that (1U << PBIT) > NP */\n#define TBIT 5  /* smallest integer such that (1U << TBIT) > NT */\n#if NT > NP\n# define NPT NT\n#else\n# define NPT NP\n#endif\n\n/* local ush left\u00dd2 * NC - 1\u00a8; */\n/* local ush right\u00dd2 * NC - 1\u00a8; */\n#define left  prev\n#define right head\n#if NC > (1<<(BITS-2))\n    error cannot overlay left+right and prev\n#endif\n\n/* local uch c_len\u00ddNC\u00a8; */\n#define c_len outbuf\n#if NC > OUTBUFSIZ\n    error cannot overlay c_len and outbuf\n#endif\n\nlocal uch pt_len\u00ddNPT\u00a8;\nlocal unsigned blocksize;\nlocal ush pt_table\u00dd256\u00a8;\n\n/* local ush c_table\u00dd4096\u00a8; */\n#define c_table d_buf\n#if (DIST_BUFSIZE-1) < 4095\n    error cannot overlay c_table and d_buf\n#endif\n\n/***********************************************************\n        io.c -- input/output\n***********************************************************/\n\nlocal ush       bitbuf;\nlocal unsigned  subbitbuf;\nlocal int       bitcount;\n\nlocal void fillbuf(n)  /* Shift bitbuf n bits left, read n bits */\n    int n;\n{\n    bitbuf <<= n;\n    while (n > bitcount) {\n        bitbuf \u00a6= subbitbuf << (n -= bitcount);\n        subbitbuf = (unsigned)try_byte();\n        if ((int)subbitbuf == EOF) subbitbuf = 0;\n        bitcount = CHAR_BIT;\n    }\n    bitbuf \u00a6= subbitbuf >> (bitcount -= n);\n}\n\nlocal unsigned getbits(n)\n    int n;\n{\n    unsigned x;\n\n    x = bitbuf >> (BITBUFSIZ - n);  fillbuf(n);\n    return x;\n}\n\nlocal void init_getbits()\n{\n    bitbuf = 0;  subbitbuf = 0;  bitcount = 0;\n    fillbuf(BITBUFSIZ);\n}\n\n/***********************************************************\n        maketbl.c -- make table for decoding\n***********************************************************/\n\nlocal void make_table(nchar, bitlen, tablebits, table)\n    int nchar;\n    uch bitlen\u00dd\u00a8;\n    int tablebits;\n    ush table\u00dd\u00a8;\n{\n    ush count\u00dd17\u00a8, weight\u00dd17\u00a8, start\u00dd18\u00a8, *p;\n    unsigned i, k, len, ch, jutbits, avail, nextcode, mask;\n\n    for (i = 1; i <= 16; i++) count\u00ddi\u00a8 = 0;\n    for (i = 0; i < nchar; i++) count\u00ddbitlen\u00ddi\u00a8\u00a8++;\n\n    start\u00dd1\u00a8 = 0;\n    for (i = 1; i <= 16; i++)\n        start\u00ddi + 1\u00a8 = start\u00ddi\u00a8 + (count\u00ddi\u00a8 << (16 - i));\n    if ((start\u00dd17\u00a8 & 0xffff) != 0)\n        error(\"Bad table\\n\");\n\n    jutbits = 16 - tablebits;\n    for (i = 1; i <= tablebits; i++) {\n        start\u00ddi\u00a8 >>= jutbits;\n        weight\u00ddi\u00a8 = (unsigned) 1 << (tablebits - i);\n    }\n    while (i <= 16) {\n        weight\u00ddi\u00a8 = (unsigned) 1 << (16 - i);\n        i++;\n    }\n\n    i = start\u00ddtablebits + 1\u00a8 >> jutbits;\n    if (i != 0) {\n        k = 1 << tablebits;\n        while (i != k) table\u00ddi++\u00a8 = 0;\n    }\n\n    avail = nchar;\n    mask = (unsigned) 1 << (15 - tablebits);\n    for (ch = 0; ch < nchar; ch++) {\n        if ((len = bitlen\u00ddch\u00a8) == 0) continue;\n        nextcode = start\u00ddlen\u00a8 + weight\u00ddlen\u00a8;\n        if (len <= tablebits) {\n            for (i = start\u00ddlen\u00a8; i < nextcode; i++) table\u00ddi\u00a8 = ch;\n        } else {\n            k = start\u00ddlen\u00a8;\n            p = &table\u00ddk >> jutbits\u00a8;\n            i = len - tablebits;\n            while (i != 0) {\n                if (*p == 0) {\n                    right\u00ddavail\u00a8 = left\u00ddavail\u00a8 = 0;\n                    *p = avail++;\n                }\n                if (k & mask) p = &right\u00dd*p\u00a8;\n                else          p = &left\u00dd*p\u00a8;\n                k <<= 1;  i--;\n            }\n            *p = ch;\n        }\n        start\u00ddlen\u00a8 = nextcode;\n    }\n}\n\n/***********************************************************\n        huf.c -- static Huffman\n***********************************************************/\n\nlocal void read_pt_len(nn, nbit, i_special)\n    int nn;\n    int nbit;\n    int i_special;\n{\n    int i, c, n;\n    unsigned mask;\n\n    n = getbits(nbit);\n    if (n == 0) {\n        c = getbits(nbit);\n        for (i = 0; i < nn; i++) pt_len\u00ddi\u00a8 = 0;\n        for (i = 0; i < 256; i++) pt_table\u00ddi\u00a8 = c;\n    } else {\n        i = 0;\n        while (i < n) {\n            c = bitbuf >> (BITBUFSIZ - 3);\n            if (c == 7) {\n                mask = (unsigned) 1 << (BITBUFSIZ - 1 - 3);\n                while (mask & bitbuf) { mask >>= 1; c++;    }\n            }\n            fillbuf((c < 7) ? 3 : c - 3);\n            pt_len\u00ddi++\u00a8 = c;\n            if (i == i_special) {\n                c = getbits(2);\n                while (--c >= 0) pt_len\u00ddi++\u00a8 = 0;\n            }\n        }\n        while (i < nn) pt_len\u00ddi++\u00a8 = 0;\n        make_table(nn, pt_len, 8, pt_table);\n    }\n}\n\nlocal void read_c_len()\n{\n    int i, c, n;\n    unsigned mask;\n\n    n = getbits(CBIT);\n    if (n == 0) {\n        c = getbits(CBIT);\n        for (i = 0; i < NC; i++) c_len\u00ddi\u00a8 = 0;\n        for (i = 0; i < 4096; i++) c_table\u00ddi\u00a8 = c;\n    } else {\n        i = 0;\n        while (i < n) {\n            c = pt_table\u00ddbitbuf >> (BITBUFSIZ - 8)\u00a8;\n            if (c >= NT) {\n                mask = (unsigned) 1 << (BITBUFSIZ - 1 - 8);\n                do {\n                    if (bitbuf & mask) c = right\u00ddc\u00a8;\n                    else               c = left \u00ddc\u00a8;\n                    mask >>= 1;\n                } while (c >= NT);\n            }\n            fillbuf((int) pt_len\u00ddc\u00a8);\n            if (c <= 2) {\n                if      (c == 0) c = 1;\n                else if (c == 1) c = getbits(4) + 3;\n                else             c = getbits(CBIT) + 20;\n                while (--c >= 0) c_len\u00ddi++\u00a8 = 0;\n            } else c_len\u00ddi++\u00a8 = c - 2;\n        }\n        while (i < NC) c_len\u00ddi++\u00a8 = 0;\n        make_table(NC, c_len, 12, c_table);\n    }\n}\n\nlocal unsigned decode_c()\n{\n    unsigned j, mask;\n\n    if (blocksize == 0) {\n        blocksize = getbits(16);\n        if (blocksize == 0) {\n            return NC; /* end of file */\n        }\n        read_pt_len(NT, TBIT, 3);\n        read_c_len();\n        read_pt_len(NP, PBIT, -1);\n    }\n    blocksize--;\n    j = c_table\u00ddbitbuf >> (BITBUFSIZ - 12)\u00a8;\n    if (j >= NC) {\n        mask = (unsigned) 1 << (BITBUFSIZ - 1 - 12);\n        do {\n            if (bitbuf & mask) j = right\u00ddj\u00a8;\n            else               j = left \u00ddj\u00a8;\n            mask >>= 1;\n        } while (j >= NC);\n    }\n    fillbuf((int) c_len\u00ddj\u00a8);\n    return j;\n}\n\nlocal unsigned decode_p()\n{\n    unsigned j, mask;\n\n    j = pt_table\u00ddbitbuf >> (BITBUFSIZ - 8)\u00a8;\n    if (j >= NP) {\n        mask = (unsigned) 1 << (BITBUFSIZ - 1 - 8);\n        do {\n            if (bitbuf & mask) j = right\u00ddj\u00a8;\n            else               j = left \u00ddj\u00a8;\n            mask >>= 1;\n        } while (j >= NP);\n    }\n    fillbuf((int) pt_len\u00ddj\u00a8);\n    if (j != 0) j = ((unsigned) 1 << (j - 1)) + getbits((int) (j - 1));\n    return j;\n}\n\nlocal void huf_decode_start()\n{\n    init_getbits();  blocksize = 0;\n}\n\n/***********************************************************\n        decode.c\n***********************************************************/\n\nlocal int j;    /* remaining bytes to copy */\nlocal int done; /* set at end of input */\n\nlocal void decode_start()\n{\n    huf_decode_start();\n    j = 0;\n    done = 0;\n}\n\n/* Decode the input and return the number of decoded bytes put in buffer\n */\nlocal unsigned decode(count, buffer)\n    unsigned count;\n    uch buffer\u00dd\u00a8;\n    /* The calling function must keep the number of\n       bytes to be processed.  This function decodes\n       either 'count' bytes or 'DICSIZ' bytes, whichever\n       is smaller, into the array 'buffer\u00dd\u00a8' of size\n       'DICSIZ' or more.\n       Call decode_start() once for each new file\n       before calling this function.\n     */\n{\n    local unsigned i;\n    unsigned r, c;\n\n    r = 0;\n    while (--j >= 0) {\n        buffer\u00ddr\u00a8 = buffer\u00ddi\u00a8;\n        i = (i + 1) & (DICSIZ - 1);\n        if (++r == count) return r;\n    }\n    for ( ; ; ) {\n        c = decode_c();\n        if (c == NC) {\n            done = 1;\n            return r;\n        }\n        if (c <= UCHAR_MAX) {\n            buffer\u00ddr\u00a8 = c;\n            if (++r == count) return r;\n        } else {\n            j = c - (UCHAR_MAX + 1 - THRESHOLD);\n            i = (r - decode_p() - 1) & (DICSIZ - 1);\n            while (--j >= 0) {\n                buffer\u00ddr\u00a8 = buffer\u00ddi\u00a8;\n                i = (i + 1) & (DICSIZ - 1);\n                if (++r == count) return r;\n            }\n        }\n    }\n}\n\n\n/* ===========================================================================\n * Unlzh in to out. Return OK or ERROR.\n */\nint unlzh(in, out)\n    int in;\n    int out;\n{\n    unsigned n;\n    ifd = in;\n    ofd = out;\n\n    decode_start();\n    while (!done) {\n        n = decode((unsigned) DICSIZ, window);\n        if (!test && n > 0) {\n            write_buf(out, (char*)window, n);\n        }\n    }\n    return OK;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNLZW": {"ttr": 3334, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x98\\x12o\\x00\\x98\\x12\\x7f\\x11\\x11\\x01}\\x01x\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-05-06T00:00:00", "modifydate": "1998-05-07T11:11:00", "lines": 381, "newlines": 376, "modlines": 0, "user": "XSSGSCH"}, "text": "??=ifdef MVS    //* RS\n   ??=pragma filetag(\"IBM-1047\")  //* RS\n??=endif                          //* RS\n/* unlzw.c -- decompress files in LZW format.\n * The code in this file is directly derived from the public domain 'compress'\n * written by Spencer Thomas, Joe Orost, James Woods, Jim McKie, Steve Davies,\n * Ken Turkowski, Dave Mack and Peter Jannesen.\n *\n * This is a temporary version which will be rewritten in some future version\n * to accommodate in-memory decompression.\n */\n\n#ifndef lint\nstatic char rcsid\u00dd\u00a8 = \"$Id: unlzw.c,v 0.15 1993/06/10 13:28:35 jloup Exp     $\";\n#endif\n\n#ifndef C370\n#include <sys/types.h>\n#endif /* C370 */\n\n#include \"tailor.h\"\n\n#ifdef HAVE_UNISTD_H\n#  include <unistd.h>\n#endif\n#ifndef NO_FCNTL_H\n#  include <fcntl.h>\n#endif\n\n#include \"gzip.h\"\n#include \"lzw.h\"\n\ntypedef unsigned char   char_type;\ntypedef          long   code_int;\ntypedef unsigned long   count_int;\ntypedef unsigned short  count_short;\ntypedef unsigned long   cmp_code_int;\n\n#define MAXCODE(n)      (1L << (n))\n\n#ifndef REGISTERS\n#       define  REGISTERS       2\n#endif\n#define REG1\n#define REG2\n#define REG3\n#define REG4\n#define REG5\n#define REG6\n#define REG7\n#define REG8\n#define REG9\n#define REG10\n#define REG11\n#define REG12\n#define REG13\n#define REG14\n#define REG15\n#define REG16\n#if REGISTERS >= 1\n#       undef   REG1\n#       define  REG1    register\n#endif\n#if REGISTERS >= 2\n#       undef   REG2\n#       define  REG2    register\n#endif\n#if REGISTERS >= 3\n#       undef   REG3\n#       define  REG3    register\n#endif\n#if REGISTERS >= 4\n#       undef   REG4\n#       define  REG4    register\n#endif\n#if REGISTERS >= 5\n#       undef   REG5\n#       define  REG5    register\n#endif\n#if REGISTERS >= 6\n#       undef   REG6\n#       define  REG6    register\n#endif\n#if REGISTERS >= 7\n#       undef   REG7\n#       define  REG7    register\n#endif\n#if REGISTERS >= 8\n#       undef   REG8\n#       define  REG8    register\n#endif\n#if REGISTERS >= 9\n#       undef   REG9\n#       define  REG9    register\n#endif\n#if REGISTERS >= 10\n#       undef   REG10\n#       define  REG10   register\n#endif\n#if REGISTERS >= 11\n#       undef   REG11\n#       define  REG11   register\n#endif\n#if REGISTERS >= 12\n#       undef   REG12\n#       define  REG12   register\n#endif\n#if REGISTERS >= 13\n#       undef   REG13\n#       define  REG13   register\n#endif\n#if REGISTERS >= 14\n#       undef   REG14\n#       define  REG14   register\n#endif\n#if REGISTERS >= 15\n#       undef   REG15\n#       define  REG15   register\n#endif\n#if REGISTERS >= 16\n#       undef   REG16\n#       define  REG16   register\n#endif\n\n#ifndef BYTEORDER\n#       define  BYTEORDER       0000\n#endif\n\n#ifndef NOALLIGN\n#       define  NOALLIGN        0\n#endif\n\n\nunion   bytes {\n    long  word;\n    struct {\n#if BYTEORDER == 4321\n        char_type       b1;\n        char_type       b2;\n        char_type       b3;\n        char_type       b4;\n#else\n#if BYTEORDER == 1234\n        char_type       b4;\n        char_type       b3;\n        char_type       b2;\n        char_type       b1;\n#else\n#       undef   BYTEORDER\n        int  dummy;\n#endif\n#endif\n    } bytes;\n};\n\n#if BYTEORDER == 4321 && NOALLIGN == 1\n#  define input(b,o,c,n,m){ \\\n     (c) = (*(long *)(&(b)\u00dd(o)>>3\u00a8)>>((o)&0x7))&(m); \\\n     (o) += (n); \\\n   }\n#else\n#  define input(b,o,c,n,m){ \\\n     REG1 char_type *p = &(b)\u00dd(o)>>3\u00a8; \\\n     (c) = ((((long)(p\u00dd0\u00a8))\u00a6((long)(p\u00dd1\u00a8)<<8)\u00a6 \\\n     ((long)(p\u00dd2\u00a8)<<16))>>((o)&0x7))&(m); \\\n     (o) += (n); \\\n   }\n#endif\n\n#ifndef MAXSEG_64K\n   /* DECLARE(ush, tab_prefix, (1<<BITS)); -- prefix code */\n#  define tab_prefixof(i) tab_prefix\u00ddi\u00a8\n#  define clear_tab_prefixof()  memzero(tab_prefix, 256);\n#else\n   /* DECLARE(ush, tab_prefix0, (1<<(BITS-1)); -- prefix for even codes */\n   /* DECLARE(ush, tab_prefix1, (1<<(BITS-1)); -- prefix for odd  codes */\n   ush *tab_prefix\u00dd2\u00a8;\n#  define tab_prefixof(i) tab_prefix\u00dd(i)&1\u00a8\u00dd(i)>>1\u00a8\n#  define clear_tab_prefixof()  \\\n      memzero(tab_prefix0, 128), \\\n      memzero(tab_prefix1, 128);\n#endif\n#define de_stack        ((char_type *)(&d_buf\u00ddDIST_BUFSIZE-1\u00a8))\n#define tab_suffixof(i) tab_suffix\u00ddi\u00a8\n\nint block_mode = BLOCK_MODE; /* block compress mode -C compatible with 2.0 */\n\n/* ============================================================================\n * Decompress in to out.  This routine adapts to the codes in the\n * file building the \"string\" table on-the-fly; requiring no table to\n * be stored in the compressed file.\n * IN assertions: the buffer inbuf contains already the beginning of\n *   the compressed data, from offsets iptr to insize-1 included.\n *   The magic header has already been checked and skipped.\n *   bytes_in and bytes_out have been initialized.\n */\nint unlzw(in, out)\n    int in, out;    /* input and output file descriptors */\n{\n    REG2   char_type  *stackp;\n    REG3   code_int   code;\n    REG4   int        finchar;\n    REG5   code_int   oldcode;\n    REG6   code_int   incode;\n    REG7   long       inbits;\n    REG8   long       posbits;\n    REG9   int        outpos;\n/*  REG10  int        insize; (global) */\n    REG11  unsigned   bitmask;\n    REG12  code_int   free_ent;\n    REG13  code_int   maxcode;\n    REG14  code_int   maxmaxcode;\n    REG15  int        n_bits;\n    REG16  int        rsize;\n\n#ifdef MAXSEG_64K\n    tab_prefix\u00dd0\u00a8 = tab_prefix0;\n    tab_prefix\u00dd1\u00a8 = tab_prefix1;\n#endif\n    maxbits = get_byte();\n    block_mode = maxbits & BLOCK_MODE;\n    if ((maxbits & LZW_RESERVED) != 0) {\n        WARN((stderr, \"\\n%s: %s: warning, unknown flags 0x%x\\n\",\n              progname, ifname, maxbits & LZW_RESERVED));\n    }\n    maxbits &= BIT_MASK;\n    maxmaxcode = MAXCODE(maxbits);\n\n    if (maxbits > BITS) {\n        fprintf(stderr,\n                \"\\n%s: %s: compressed with %d bits, can only handle %d bits\\n\",\n                progname, ifname, maxbits, BITS);\n        exit_code = ERROR;\n        return ERROR;\n    }\n    rsize = insize;\n    maxcode = MAXCODE(n_bits = INIT_BITS)-1;\n    bitmask = (1<<n_bits)-1;\n    oldcode = -1;\n    finchar = 0;\n    outpos = 0;\n    posbits = inptr<<3;\n\n    free_ent = ((block_mode) ? FIRST : 256);\n\n    clear_tab_prefixof(); /* Initialize the first 256 entries in the table. */\n\n    for (code = 255 ; code >= 0 ; --code) {\n        tab_suffixof(code) = (char_type)code;\n    }\n    do {\n        REG1 int i;\n        int  e;\n        int  o;\n\n    resetbuf:\n        e = insize-(o = (posbits>>3));\n\n        for (i = 0 ; i < e ; ++i) {\n            inbuf\u00ddi\u00a8 = inbuf\u00ddi+o\u00a8;\n        }\n        insize = e;\n        posbits = 0;\n\n        if (insize < INBUF_EXTRA) {\n            if ((rsize = read(in, (char*)inbuf+insize, INBUFSIZ)) == EOF) {\n                read_error();\n            }\n            insize += rsize;\n            bytes_in += (ulg)rsize;\n        }\n        inbits = ((rsize != 0) ? ((long)insize - insize%n_bits)<<3 :\n                  ((long)insize<<3)-(n_bits-1));\n\n        while (inbits > posbits) {\n            if (free_ent > maxcode) {\n                posbits = ((posbits-1) +\n                           ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));\n                ++n_bits;\n                if (n_bits == maxbits) {\n                    maxcode = maxmaxcode;\n                } else {\n                    maxcode = MAXCODE(n_bits)-1;\n                }\n                bitmask = (1<<n_bits)-1;\n                goto resetbuf;\n            }\n            input(inbuf,posbits,code,n_bits,bitmask);\n\n            if (oldcode == -1) {\n                outbuf\u00ddoutpos++\u00a8 =\n                        (char_type)(finchar = (int)(oldcode=code));\n                continue;\n            }\n            if (code == CLEAR && block_mode) {\n                clear_tab_prefixof();\n                free_ent = FIRST - 1;\n                posbits = ((posbits-1) +\n                           ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));\n                maxcode = MAXCODE(n_bits = INIT_BITS)-1;\n                bitmask = (1<<n_bits)-1;\n                goto resetbuf;\n            }\n            incode = code;\n            stackp = de_stack;\n\n            if (code >= free_ent) { /* Special case for KwKwK string. */\n                if (code > free_ent) {\n#ifdef DEBUG\n                    char_type *p;\n\n                    posbits -= n_bits;\n                    p = &inbuf\u00ddposbits>>3\u00a8;\n                    fprintf(stderr,\n                            \"code:%ld free_ent:%ld n_bits:%d insize:%u\\n\",\n                            code, free_ent, n_bits, insize);\n                    fprintf(stderr,\n                            \"posbits:%ld inbuf:%02X %02X %02X %02X %02X\\n\",\n                            posbits,\n                            p\u00dd-1\u00a8,p\u00dd0\u00a8,p\u00dd1\u00a8,p\u00dd2\u00a8,p\u00dd3\u00a8);\n#endif\n                    if (!test && outpos > 0) {\n                        write_buf(out, (char*)outbuf, outpos);\n                        bytes_out += (ulg)outpos;\n                    }\n                    error(\"corrupt input. Use zcat to recover some data.\");\n                }\n                *--stackp = (char_type)finchar;\n                code = oldcode;\n            }\n\n            while ((cmp_code_int)code >= (cmp_code_int)256) {\n                /* Generate output characters in reverse order */\n                *--stackp = tab_suffixof(code);\n                code = tab_prefixof(code);\n            }\n            *--stackp = (char_type)(finchar = tab_suffixof(code));\n\n            /* And put them out in forward order */\n            {\n                REG1 int        i;\n\n                if (outpos+(i = (de_stack-stackp)) >= OUTBUFSIZ) {\n                    do {\n                        if (i > OUTBUFSIZ-outpos) i = OUTBUFSIZ-outpos;\n\n                        if (i > 0) {\n                            memcpy(outbuf+outpos, stackp, i);\n                            outpos += i;\n                        }\n                        if (outpos >= OUTBUFSIZ) {\n                            if (!test) {\n                                write_buf(out, (char*)outbuf, outpos);\n                                bytes_out += (ulg)outpos;\n                            }\n                            outpos = 0;\n                        }\n                        stackp+= i;\n                    } while ((i = (de_stack-stackp)) > 0);\n                } else {\n                    memcpy(outbuf+outpos, stackp, i);\n                    outpos += i;\n                }\n            }\n\n            if ((code = free_ent) < maxmaxcode) { //* Generate the new entry.\n\n                tab_prefixof(code) = (unsigned short)oldcode;\n                tab_suffixof(code) = (char_type)finchar;\n                free_ent = code+1;\n            }\n            oldcode = incode;   /* Remember previous code.      */\n        }\n    } while (rsize != 0);\n\n    if (!test && outpos > 0) {\n        write_buf(out, (char*)outbuf, outpos);\n        bytes_out += (ulg)outpos;\n    }\n    return OK;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNPACK": {"ttr": 3587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x98\\x12o\\x00\\x98\\x12\\x7f\\x11\\x11\\x00\\xf2\\x00\\xef\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-05-06T00:00:00", "modifydate": "1998-05-07T11:11:00", "lines": 242, "newlines": 239, "modlines": 0, "user": "XSSGSCH"}, "text": "??=ifdef MVS    //* RS\n   ??=pragma filetag(\"IBM-1047\")  //* RS\n??=endif                          //* RS\n/* unpack.c -- decompress files in pack format.\n * Copyright (C) 1992-1993 Jean-loup Gailly\n * This is free software; you can redistribute it and/or modify it under the\n * terms of the GNU General Public License, see the file COPYING.\n */\n\n#ifndef lint\nstatic char rcsid\u00dd\u00a8 = \"$Id: unpack.c,v 1.4 1993/06/11 19:25:36 jloup Exp     $\";\n#endif\n\n#include \"tailor.h\"\n#include \"gzip.h\"\n#include \"crypt.h\"\n\n#define MIN(a,b) ((a) <= (b) ? (a) : (b))\n/* The arguments must not have side effects. */\n\n#define MAX_BITLEN 25\n/* Maximum length of Huffman codes. (Minor modifications to the code\n * would be needed to support 32 bits codes, but pack never generates\n * more than 24 bits anyway.)\n */\n\n#define LITERALS 256\n/* Number of literals, excluding the End of Block (EOB) code */\n\n#define MAX_PEEK 12\n/* Maximum number of 'peek' bits used to optimize traversal of the\n * Huffman tree.\n */\n\nlocal ulg orig_len;       /* original uncompressed length */\nlocal int max_len;        /* maximum bit length of Huffman codes */\n\nlocal uch literal\u00ddLITERALS\u00a8;\n/* The literal bytes present in the Huffman tree. The EOB code is not\n * represented.\n */\n\nlocal int lit_base\u00ddMAX_BITLEN+1\u00a8;\n/* All literals of a given bit length are contiguous in literal\u00dd\u00a8 and\n * have contiguous codes. literal\u00ddcode+lit_base\u00ddlen\u00a8\u00a8 is the literal\n * for a code of len bits.\n */\n\nlocal int leaves \u00ddMAX_BITLEN+1\u00a8; /* Number of leaves for each bit length */\nlocal int parents\u00ddMAX_BITLEN+1\u00a8; /* Number of parents for each bit length     */\n\nlocal int peek_bits; /* Number of peek bits currently used */\n\n/* local uch prefix_len\u00dd1 << MAX_PEEK\u00a8; */\n#define prefix_len outbuf\n/* For each bit pattern b of peek_bits bits, prefix_len\u00ddb\u00a8 is the length\n * of the Huffman code starting with a prefix of b (upper bits), or 0\n * if all codes of prefix b have more than peek_bits bits. It is not\n * necessary to have a huge table (large MAX_PEEK) because most of the\n * codes encountered in the input stream are short codes (by construction).\n * So for most codes a single lookup will be necessary.\n */\n#if 1<<MAX_PEEK > OUTBUFSIZ\n    error cannot overlay prefix_len and outbuf\n#endif\n\nlocal ulg bitbuf;\n/* Bits are added on the low part of bitbuf and read from the high part. */\n\nlocal int valid;                  /* number of valid bits in bitbuf */\n/* all bits above the last valid bit are always zero */\n\n/* Set code to the next 'bits' input bits without skipping them. code\n * must be the name of a simple variable and bits must not have side effects.\n * IN assertions: bits <= 25 (so that we still have room for an extra byte\n * when valid is only 24), and mask = (1<<bits)-1.\n */\n#define look_bits(code,bits,mask) \\\n{ \\\n  while (valid < (bits)) bitbuf = (bitbuf<<8) \u00a6 (ulg)get_byte(), valid += 8; \\\n  code = (bitbuf >> (valid-(bits))) & (mask); \\\n}\n\n/* Skip the given number of bits (after having peeked at them): */\n#define skip_bits(bits)  (valid -= (bits))\n\n#define clear_bitbuf() (valid = 0, bitbuf = 0)\n\n/* Local functions */\n\nlocal void read_tree  OF((void));\nlocal void build_tree OF((void));\n\n/* ===========================================================================\n * Read the Huffman tree.\n */\nlocal void read_tree()\n{\n    int len;  /* bit length */\n    int base; /* base offset for a sequence of leaves */\n    int n;\n\n    /* Read the original input size, MSB first */\n    orig_len = 0;\n    for (n = 1; n <= 4; n++) orig_len = (orig_len << 8) \u00a6 (ulg)get_byte();\n\n    max_len = (int)get_byte(); /* maximum bit length of Huffman codes */\n    if (max_len > MAX_BITLEN) {\n        error(\"invalid compressed data -- Huffman code > 32 bits\");\n    }\n\n    /* Get the number of leaves at each bit length */\n    n = 0;\n    for (len = 1; len <= max_len; len++) {\n        leaves\u00ddlen\u00a8 = (int)get_byte();\n        n += leaves\u00ddlen\u00a8;\n    }\n    if (n > LITERALS) {\n        error(\"too many leaves in Huffman tree\");\n    }\n    Trace((stderr, \"orig_len %ld, max_len %d, leaves %d\\n\",\n           orig_len, max_len, n));\n    /* There are at least 2 and at most 256 leaves of length max_len.\n     * (Pack arbitrarily rejects empty files and files consisting of\n     * a single byte even repeated.) To fit the last leaf count in a\n     * byte, it is offset by 2. However, the last literal is the EOB\n     * code, and is not transmitted explicitly in the tree, so we must\n     * adjust here by one only.\n     */\n    leaves\u00ddmax_len\u00a8++;\n\n    /* Now read the leaves themselves */\n    base = 0;\n    for (len = 1; len <= max_len; len++) {\n        /* Remember where the literals of this length start in literal\u00dd\u00a8 */\n        lit_base\u00ddlen\u00a8 = base;\n        /* And read the literals: */\n        for (n = leaves\u00ddlen\u00a8; n > 0; n--) {\n            literal\u00ddbase++\u00a8 = (uch)get_byte();\n        }\n    }\n    leaves\u00ddmax_len\u00a8++; /* Now include the EOB code in the Huffman tree */\n}\n\n/* ===========================================================================\n * Build the Huffman tree and the prefix table.\n */\nlocal void build_tree()\n{\n    int nodes = 0; /* number of nodes (parents+leaves) at current bit length */\n    int len;       /* current bit length */\n    uch *prefixp;  /* pointer in prefix_len */\n\n    for (len = max_len; len >= 1; len--) {\n        /* The number of parent nodes at this level is half the total\n         * number of nodes at parent level:\n         */\n        nodes >>= 1;\n        parents\u00ddlen\u00a8 = nodes;\n        /* Update lit_base by the appropriate bias to skip the parent nodes\n         * (which are not represented in the literal array):\n         */\n        lit_base\u00ddlen\u00a8 -= nodes;\n        /* Restore nodes to be parents+leaves: */\n        nodes += leaves\u00ddlen\u00a8;\n    }\n    /* Construct the prefix table, from shortest leaves to longest ones.\n     * The shortest code is all ones, so we start at the end of the table.\n     */\n    peek_bits = MIN(max_len, MAX_PEEK);\n    prefixp = &prefix_len\u00dd1<<peek_bits\u00a8;\n    for (len = 1; len <= peek_bits; len++) {\n        int prefixes = leaves\u00ddlen\u00a8 << (peek_bits-len); /* may be 0 */\n        while (prefixes--) *--prefixp = (uch)len;\n    }\n    /* The length of all other codes is unknown: */\n    while (prefixp > prefix_len) *--prefixp = 0;\n}\n\n/* ===========================================================================\n * Unpack in to out.  This routine does not support the old pack format\n * with magic header \\037\\037.\n *\n * IN assertions: the buffer inbuf contains already the beginning of\n *   the compressed data, from offsets inptr to insize-1 included.\n *   The magic header has already been checked. The output buffer is cleared.\n */\nint unpack(in, out)\n    int in, out;            /* input and output file descriptors */\n{\n    int len;                /* Bit length of current code */\n    unsigned eob;           /* End Of Block code */\n    register unsigned peek; /* lookahead bits */\n    unsigned peek_mask;     /* Mask for peek_bits bits */\n\n    ifd = in;\n    ofd = out;\n\n    read_tree();     /* Read the Huffman tree */\n    build_tree();    /* Build the prefix table */\n    clear_bitbuf();  /* Initialize bit input */\n    peek_mask = (1<<peek_bits)-1;\n\n    /* The eob code is the largest code among all leaves of maximal length: */\n    eob = leaves\u00ddmax_len\u00a8-1;\n    Trace((stderr, \"eob %d %x\\n\", max_len, eob));\n\n    /* Decode the input data: */\n    for (;;) {\n        /* Since eob is the longest code and not shorter than max_len,\n         * we can peek at max_len bits without having the risk of reading\n         * beyond the end of file.\n         */\n        look_bits(peek, peek_bits, peek_mask);\n        len = prefix_len\u00ddpeek\u00a8;\n        if (len > 0) {\n            peek >>= peek_bits - len; /* discard the extra bits */\n        } else {\n            /* Code of more than peek_bits bits, we must traverse the tree */\n            ulg mask = peek_mask;\n            len = peek_bits;\n            do {\n                len++, mask = (mask<<1)+1;\n                look_bits(peek, len, mask);\n            } while (peek < parents\u00ddlen\u00a8);\n            /* loop as long as peek is a parent node */\n        }\n        /* At this point, peek is the next complete code, of len bits */\n        if (peek == eob && len == max_len) break; /* end of file? */\n        put_ubyte(literal\u00ddpeek+lit_base\u00ddlen\u00a8\u00a8);\n        Tracev((stderr,\"%02d %04x %c\\n\", len, peek,\n                literal\u00ddpeek+lit_base\u00ddlen\u00a8\u00a8));\n        skip_bits(len);\n    } /* for (;;) */\n\n    flush_window();\n    Trace((stderr, \"bytes_out %ld\\n\", bytes_out));\n    if (orig_len != bytes_out) {\n        error(\"invalid compressed data--length error\");\n    }\n    return OK;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNZIP": {"ttr": 3592, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x12o\\x00\\x98\\x12\\x7f\\x11\\x11\\x00\\xca\\x00\\xca\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-05-06T00:00:00", "modifydate": "1998-05-07T11:11:00", "lines": 202, "newlines": 202, "modlines": 0, "user": "XSSGSCH"}, "text": "??=ifdef MVS    //* RS\n   ??=pragma filetag(\"IBM-1047\")  //* RS\n??=endif                          //* RS\n/* unzip.c -- decompress files in gzip or pkzip format.\n * Copyright (C) 1992-1993 Jean-loup Gailly\n * This is free software; you can redistribute it and/or modify it under the\n * terms of the GNU General Public License, see the file COPYING.\n *\n * The code in this file is derived from the file funzip.c written\n * and put in the public domain by Mark Adler.\n */\n\n/*\n   This version can extract files in gzip or pkzip format.\n   For the latter, only the first entry is extracted, and it has to be\n   either deflated or stored.\n */\n\n#ifndef lint\nstatic char rcsid\u00dd\u00a8 = \"$Id: unzip.c,v 0.13 1993/06/10 13:29:00 jloup Exp     $\";\n#endif\n\n#include \"tailor.h\"\n#include \"gzip.h\"\n#include \"crypt.h\"\n\n/* PKZIP header definitions */\n#define LOCSIG 0x04034b50L      /* four-byte lead-in (lsb first) */\n#define LOCFLG 6                /* offset of bit flag */\n#define  CRPFLG 1               /*  bit for encrypted entry */\n#define  EXTFLG 8               /*  bit for extended local header */\n#define LOCHOW 8                /* offset of compression method */\n#define LOCTIM 10               /* file mod time (for decryption) */\n#define LOCCRC 14               /* offset of crc */\n#define LOCSIZ 18               /* offset of compressed size */\n#define LOCLEN 22               /* offset of uncompressed length */\n#define LOCFIL 26               /* offset of file name field length */\n#define LOCEXT 28               /* offset of extra field length */\n#define LOCHDR 30               /* size of local header, including sig */\n#define EXTHDR 16               /* size of extended local header, inc sig */\n\n\n/* Globals */\n\nint decrypt;        /* flag to turn on decryption */\nchar *key;          /* not used--needed to link crypt.c */\nint pkzip = 0;      /* set for a pkzip file */\nint ext_header = 0; /* set if extended local header */\n\n/* ===========================================================================\n * Check zip file and advance inptr to the start of the compressed data.\n * Get ofname from the local header if necessary.\n */\nint check_zipfile(in)\n    int in;   /* input file descriptors */\n{\n    uch *h = inbuf + inptr; /* first local header */\n\n    ifd = in;\n\n    /* Check validity of local header, and skip name and extra fields */\n    inptr += LOCHDR + SH(h + LOCFIL) + SH(h + LOCEXT);\n\n    if (inptr > insize \u00a6\u00a6 LG(h) != LOCSIG) {\n        fprintf(stderr, \"\\n%s: %s: not a valid zip file\\n\",\n                progname, ifname);\n        exit_code = ERROR;\n        return ERROR;\n    }\n    method = h\u00ddLOCHOW\u00a8;\n    if (method != STORED && method != DEFLATED) {\n        fprintf(stderr,\n                \"\\n%s: %s: first entry not deflated or stored -- use unzip\\n\",\n                progname, ifname);\n        exit_code = ERROR;\n        return ERROR;\n    }\n\n    /* If entry encrypted, decrypt and validate encryption header */\n    if ((decrypt = h\u00ddLOCFLG\u00a8 & CRPFLG) != 0) {\n        fprintf(stderr, \"\\n%s: %s: encrypted file -- use unzip\\n\",\n                progname, ifname);\n        exit_code = ERROR;\n        return ERROR;\n    }\n\n    /* Save flags for unzip() */\n    ext_header = (h\u00ddLOCFLG\u00a8 & EXTFLG) != 0;\n    pkzip = 1;\n\n    /* Get ofname and time stamp from local header (to be done) */\n    return OK;\n}\n\n/* ===========================================================================\n * Unzip in to out.  This routine works on both gzip and pkzip files.\n *\n * IN assertions: the buffer inbuf contains already the beginning of\n *   the compressed data, from offsets inptr to insize-1 included.\n *   The magic header has already been checked. The output buffer is cleared.\n */\nint unzip(in, out)\n    int in, out;   /* input and output file descriptors */\n{\n    ulg orig_crc = 0;       /* original crc */\n    ulg orig_len = 0;       /* original uncompressed length */\n    int n;\n    uch buf\u00ddEXTHDR\u00a8;        /* extended local header */\n\n    ifd = in;\n    ofd = out;\n\n    updcrc(NULL, 0);           /* initialize crc */\n\n    if (pkzip && !ext_header) { /* crc and length at the end otherwise */\n        orig_crc = LG(inbuf + LOCCRC);\n        orig_len = LG(inbuf + LOCLEN);\n    }\n\n    /* Decompress */\n    if (method == DEFLATED)  {\n\n        int res = inflate();\n\n        if (res == 3) {\n            error(\"out of memory\");\n        } else if (res != 0) {\n            error(\"invalid compressed data--format violated\");\n        }\n\n    } else if (pkzip && method == STORED) {\n\n        register ulg n = LG(inbuf + LOCLEN);\n\n        if (n != LG(inbuf + LOCSIZ) - (decrypt ? RAND_HEAD_LEN : 0)) {\n\n            fprintf(stderr, \"len %ld, siz %ld\\n\", n, LG(inbuf + LOCSIZ));\n            error(\"invalid compressed data--length mismatch\");\n        }\n        while (n--) {\n            uch c = (uch)get_byte();\n#ifdef CRYPT\n            if (decrypt) zdecode(c);\n#endif\n            put_ubyte(c);\n        }\n        flush_window();\n    } else {\n        error(\"internal error, invalid method\");\n    }\n\n    /* Get the crc and original length */\n    if (!pkzip) {\n        /* crc32  (see algorithm.doc)\n         * uncompressed input size modulo 2\u00ac32\n         */\n        for (n = 0; n < 8; n++) {\n            buf\u00ddn\u00a8 = (uch)get_byte(); /* may cause an error if EOF */\n        }\n        orig_crc = LG(buf);\n        orig_len = LG(buf+4);\n\n    } else if (ext_header) { /* If extended header, check it */\n        /* signature - 4bytes: 0x50 0x4b 0x07 0x08\n         * CRC-32 value\n         * compressed size 4-bytes\n         * uncompressed size 4-bytes\n         */\n        for (n = 0; n < EXTHDR; n++) {\n            buf\u00ddn\u00a8 = (uch)get_byte(); /* may cause an error if EOF */\n        }\n        orig_crc = LG(buf+4);\n        orig_len = LG(buf+12);\n    }\n\n    /* Validate decompression */\n    if (orig_crc != updcrc(outbuf, 0)) {\n        error(\"invalid compressed data--crc error\");\n    }\n    if (orig_len != bytes_out) {\n        error(\"invalid compressed data--length error\");\n    }\n\n    /* Check if there are more entries in a pkzip file */\n    if (pkzip && inptr + 4 < insize && LG(inbuf+inptr) == LOCSIG) {\n        if (to_stdout) {\n            WARN((stderr,\n                  \"%s: %s has more than one entry--rest ignored\\n\",\n                  progname, ifname));\n        } else {\n            /* Don't destroy the input zip file */\n            fprintf(stderr,\n                    \"%s: %s has more than one entry -- unchanged\\n\",\n                    progname, ifname);\n            exit_code = ERROR;\n            ext_header = pkzip = 0;\n            return ERROR;\n        }\n    }\n    ext_header = pkzip = 0; /* for next file */\n    return OK;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UTIL": {"ttr": 3596, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x12o\\x00\\x98\\x12\\x7f\\x11\\x12\\x01\\xdd\\x01\\xdd\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-05-06T00:00:00", "modifydate": "1998-05-07T11:12:00", "lines": 477, "newlines": 477, "modlines": 0, "user": "XSSGSCH"}, "text": "??=ifdef MVS    //* RS\n   ??=pragma filetag(\"IBM-1047\")  //* RS\n??=endif                          //* RS\n/* util.c -- utility functions for gzip support\n * Copyright (C) 1992-1993 Jean-loup Gailly\n * This is free software; you can redistribute it and/or modify it under the\n * terms of the GNU General Public License, see the file COPYING.\n */\n\n#ifndef lint\nstatic char rcsid\u00dd\u00a8 = \"$Id: util.c,v 0.15 1993/06/15 09:04:13 jloup Exp $\";\n#endif\n\n#include <ctype.h>\n#include <errno.h>\n#ifndef C370\n#include <sys/types.h>\n#endif /* C370 */\n\n#include \"tailor.h\"\n\n#ifdef HAVE_UNISTD_H\n#  include <unistd.h>\n#endif\n#ifndef NO_FCNTL_H\n#  include <fcntl.h>\n#endif\n\n#if defined(STDC_HEADERS) \u00a6\u00a6 !defined(NO_STDLIB_H)\n#  include <stdlib.h>\n#else\n   extern int errno;\n#endif\n\n#include \"gzip.h\"\n#include \"crypt.h\"\n\nextern ulg crc_32_tab\u00dd\u00a8; /* crc table, defined below */\n\n/* ===========================================================================\n * Copy input to output unchanged: zcat == cat with --force.\n * IN assertion: insize bytes have already been read in inbuf.\n */\nint copy(in, out)\n    int in, out;   /* input and output file descriptors */\n{\n    errno = 0;\n    while (insize != 0 && (int)insize != EOF) {\n        write_buf(out, (char*)inbuf, insize);\n        bytes_out += insize;\n        insize = read(in, (char*)inbuf, INBUFSIZ);\n    }\n    if ((int)insize == EOF && errno != 0) {\n        read_error();\n    }\n    bytes_in = bytes_out;\n    return OK;\n}\n\n/* ===========================================================================\n * Run a set of bytes through the crc shift register.  If s is a NULL\n * pointer, then initialize the crc shift register contents instead.\n * Return the current crc in either case.\n */\nulg updcrc(s, n)\n    uch *s;                 /* pointer to bytes to pump through */\n    unsigned n;             /* number of bytes in s\u00dd\u00a8 */\n{\n    register ulg c;         /* temporary variable */\n\n    static ulg crc = (ulg)0xffffffffL; /* shift register contents */\n\n    if (s == NULL) {\n        c = 0xffffffffL;\n    } else {\n        c = crc;\n        if (n) do {\n            c = crc_32_tab\u00dd((int)c \u00ac (*s++)) & 0xff\u00a8 \u00ac (c >> 8);\n        } while (--n);\n    }\n    crc = c;\n    return c \u00ac 0xffffffffL;       /* (instead of ~c for 64-bit machines) */\n}\n\n/* ===========================================================================\n * Clear input and output buffers\n */\nvoid clear_bufs()\n{\n    outcnt = 0;\n    insize = inptr = 0;\n    bytes_in = bytes_out = 0L;\n}\n\n/* ===========================================================================\n * Fill the input buffer. This is called only when the buffer is empty.\n */\nint fill_inbuf(eof_ok)\n    int eof_ok;          /* set if EOF acceptable as a result */\n{\n    int len;\n\n    /* Read as much as possible */\n    insize = 0;\n    errno = 0;\n    do {\n        len = read(ifd, (char*)inbuf+insize, INBUFSIZ-insize);\n        if (len == 0 \u00a6\u00a6 len == EOF) break;\n        insize += len;\n    } while (insize < INBUFSIZ);\n\n    if (insize == 0) {\n        if (eof_ok) return EOF;\n        read_error();\n    }\n    bytes_in += (ulg)insize;\n    inptr = 1;\n    return inbuf\u00dd0\u00a8;\n}\n\n/* ===========================================================================\n * Write the output buffer outbuf\u00dd0..outcnt-1\u00a8 and update bytes_out.\n * (used for the compressed data only)\n */\nvoid flush_outbuf()\n{\n    if (outcnt == 0) return;\n\n    write_buf(ofd, (char *)outbuf, outcnt);\n    bytes_out += (ulg)outcnt;\n    outcnt = 0;\n}\n\n/* ===========================================================================\n * Write the output window window\u00dd0..outcnt-1\u00a8 and update crc and     bytes_out.\n * (Used for the decompressed data only.)\n */\nvoid flush_window()\n{\n    if (outcnt == 0) return;\n    updcrc(window, outcnt);\n\n    if (!test) {\n#ifdef C370\n    if (ascii && decompress) {\n       memcpy( (char *)window+WSIZE, (char *)window, outcnt );\n       ascii2ebcdic( (char *)window+WSIZE, outcnt );\n       write_buf( ofd, (char *)window+WSIZE, outcnt );\n    } else {\n       write_buf( ofd, (char *)window, outcnt );\n    }\n#else\n              write_buf(ofd, (char *)window, outcnt);\n#endif /* C370 */\n    }\n    bytes_out += (ulg)outcnt;\n    outcnt = 0;\n}\n\n/* ===========================================================================\n * Does the same as write(), but also handles partial pipe writes and checks\n * for error return.\n */\nvoid write_buf(fd, buf, cnt)\n    int       fd;\n    voidp     buf;\n    unsigned  cnt;\n{\n    unsigned  n;\n\n    while ((n = write(fd, buf, cnt)) != cnt) {\n        if (n == (unsigned)(-1)) {\n            write_error();\n        }\n        cnt -= n;\n        buf = (voidp)((char*)buf+n);\n    }\n}\n\n/* ========================================================================\n * Put string s in lower case, return s.\n */\nchar *strlwr(s)\n    char *s;\n{\n    char *t;\n    for (t = s; *t; t++) *t = tolow(*t);\n    return s;\n}\n\n/* ========================================================================\n * Return the base name of a file (remove any directory prefix and\n * any version suffix). For systems with file names that are not\n * case sensitive, force the base name to lower case.\n */\nchar *basename(fname)\n    char *fname;\n{\n    char *p;\n\n    if ((p = strrchr(fname, PATH_SEP))  != NULL) fname = p+1;\n#ifdef PATH_SEP2\n    if ((p = strrchr(fname, PATH_SEP2)) != NULL) fname = p+1;\n#endif\n#ifdef PATH_SEP3\n    if ((p = strrchr(fname, PATH_SEP3)) != NULL) fname = p+1;\n#endif\n#ifdef SUFFIX_SEP\n    if ((p = strrchr(fname, SUFFIX_SEP)) != NULL) *p = '\\0';\n#endif\n    if (casemap('A') == 'a') strlwr(fname);\n    return fname;\n}\n\n/* ========================================================================\n * Make a file name legal for file systems not allowing file names with\n * multiple dots or starting with a dot (such as MSDOS), by changing\n * all dots except the last one into underlines.  A target dependent\n * function can be used instead of this simple function by defining the macro\n * MAKE_LEGAL_NAME in tailor.h and providing the function in a target\n * dependent module.\n */\nvoid make_simple_name(name)\n    char *name;\n{\n    char *p = strrchr(name, '.');\n    if (p == NULL) return;\n    if (p == name) p++;\n    do {\n        if (*--p == '.') *p = '_';\n    } while (p != name);\n}\n\n\n#if defined(NO_STRING_H) && !defined(STDC_HEADERS)\n\n/* Provide missing strspn and strcspn functions. */\n\n#  ifndef __STDC__\n#    define const\n#  endif\n\nint strspn  OF((const char *s, const char *accept));\nint strcspn OF((const char *s, const char *reject));\n\n/* ========================================================================\n * Return the length of the maximum initial segment\n * of s which contains only characters in accept.\n */\nint strspn(s, accept)\n    const char *s;\n    const char *accept;\n{\n    register const char *p;\n    register const char *a;\n    register int count = 0;\n\n    for (p = s; *p != '\\0'; ++p) {\n        for (a = accept; *a != '\\0'; ++a) {\n            if (*p == *a) break;\n        }\n        if (*a == '\\0') return count;\n        ++count;\n    }\n    return count;\n}\n\n/* ========================================================================\n * Return the length of the maximum inital segment of s\n * which contains no characters from reject.\n */\nint strcspn(s, reject)\n    const char *s;\n    const char *reject;\n{\n    register int count = 0;\n\n    while (*s != '\\0') {\n        if (strchr(reject, *s++) != NULL) return count;\n        ++count;\n    }\n    return count;\n}\n\n#endif /* NO_STRING_H */\n\n/* ========================================================================\n * Add an environment variable (if any) before argv, and update argc.\n * Return the expanded environment variable to be freed later, or NULL\n * if no options were added to argv.\n */\n#define SEPARATOR       \" \\t\"   /* separators in env variable */\n\nchar *add_envopt(argcp, argvp, env)\n    int *argcp;          /* pointer to argc */\n    char ***argvp;       /* pointer to argv */\n    char *env;           /* name of environment variable */\n{\n    char *p;             /* running pointer through env variable */\n    char **oargv;        /* runs through old argv array */\n    char **nargv;        /* runs through new argv array */\n    int  oargc = *argcp; /* old argc */\n    int  nargc = 0;      /* number of arguments in env variable */\n\n    env = (char*)getenv(env);\n    if (env == NULL) return NULL;\n\n    p = (char*)xmalloc(strlen(env)+1);\n    env = strcpy(p, env);                    /* keep env variable intact */\n\n    for (p = env; *p; nargc++ ) {            /* move through env */\n        p += strspn(p, SEPARATOR);           /* skip leading separators */\n        if (*p == '\\0') break;\n\n        p += strcspn(p, SEPARATOR);          /* find end of word */\n        if (*p) *p++ = '\\0';                 /* mark it */\n    }\n    if (nargc == 0) {\n        free(env); env = NULL;\n        return NULL;\n    }\n    *argcp += nargc;\n    /* Allocate the new argv array, with an extra element just in case\n     * the original arg list did not end with a NULL.\n     */\n    nargv = (char**)calloc(*argcp+1, sizeof(char *));\n    if (nargv == NULL) error(\"out of memory\");\n    oargv  = *argvp;\n    *argvp = nargv;\n\n    /* Copy the program name first */\n    if (oargc-- < 0) error(\"argc<=0\");\n    *(nargv++) = *(oargv++);\n\n    /* Then copy the environment args */\n    for (p = env; nargc > 0; nargc--) {\n        p += strspn(p, SEPARATOR);           /* skip separators */\n        *(nargv++) = p;                      /* store start */\n        while (*p++) ;                       /* skip over word */\n    }\n\n    /* Finally copy the old args and add a NULL (usual convention) */\n    while (oargc--) *(nargv++) = *(oargv++);\n    *nargv = NULL;\n    return env;\n}\n\n/* ========================================================================\n * Error handlers.\n */\nvoid error(m)\n    char *m;\n{\n    fprintf(stderr, \"\\n%s: %s: %s\\n\", progname, ifname, m);\n    abort_gzip();\n}\n\nvoid warn(a, b)\n    char *a, *b;            /* message strings juxtaposed in output */\n{\n    WARN((stderr, \"%s: %s: warning: %s%s\\n\", progname, ifname, a, b));\n}\n\nvoid read_error()\n{\n    fprintf(stderr, \"\\n%s: \", progname);\n    if (errno != 0) {\n        perror(ifname);\n    } else {\n        fprintf(stderr, \"%s: unexpected end of file\\n\", ifname);\n    }\n    abort_gzip();\n}\n\nvoid write_error()\n{\n    fprintf(stderr, \"\\n%s: \", progname);\n    perror(ofname);\n    abort_gzip();\n}\n\n/* ========================================================================\n * Display compression ratio on the given stream on 6 characters.\n */\nvoid display_ratio(num, den, file)\n    long num;\n    long den;\n    FILE *file;\n{\n    long ratio;  /* 1000 times the compression ratio */\n\n    if (den == 0) {\n        ratio = 0; /* no compression */\n    } else if (den < 2147483L) { /* (2**31 -1)/1000 */\n        ratio = 1000L*num/den;\n    } else {\n        ratio = num/(den/1000L);\n    }\n    if (ratio < 0) {\n        putc('-', file);\n        ratio = -ratio;\n    } else {\n        putc(' ', file);\n    }\n    fprintf(file, \"%2ld.%1ld%%\", ratio / 10L, ratio % 10L);\n}\n\n\n/* ========================================================================\n * Semi-safe malloc -- never returns NULL.\n */\nvoidp xmalloc (size)\n    unsigned size;\n{\n    voidp cp = (voidp)malloc (size);\n\n    if (cp == NULL) error(\"out of memory\");\n    return cp;\n}\n\n/* ========================================================================\n * Table of CRC-32's of all single-byte values (made by makecrc.c)\n */\nulg crc_32_tab\u00dd\u00a8 = {\n  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,\n  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,\n  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,\n  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,\n  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,\n  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,\n  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,\n  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,\n  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,\n  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,\n  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,\n  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,\n  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,\n  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,\n  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,\n  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,\n  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,\n  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,\n  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,\n  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,\n  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,\n  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,\n  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,\n  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,\n  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,\n  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,\n  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,\n  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,\n  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,\n  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,\n  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,\n  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,\n  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,\n  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,\n  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,\n  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,\n  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,\n  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,\n  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,\n  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,\n  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,\n  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,\n  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,\n  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,\n  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,\n  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,\n  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,\n  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,\n  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,\n  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,\n  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,\n  0x2d02ef8dL\n};\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZIP": {"ttr": 3848, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x12o\\x00\\x98\\x12\\x7f\\x11\\x12\\x00\\x81\\x00\\x81\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-05-06T00:00:00", "modifydate": "1998-05-07T11:12:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "XSSGSCH"}, "text": "??=ifdef MVS    //* RS\n   ??=pragma filetag(\"IBM-1047\")  //* RS\n??=endif                          //* RS\n/* zip.c -- compress files to the gzip or pkzip format\n * Copyright (C) 1992-1993 Jean-loup Gailly\n * This is free software; you can redistribute it and/or modify it under the\n * terms of the GNU General Public License, see the file COPYING.\n */\n\n#ifndef lint\nstatic char rcsid\u00dd\u00a8 = \"$Id: zip.c,v 0.17 1993/06/10 13:29:25 jloup Exp $\";\n#endif\n\n#include <ctype.h>\n#ifndef C370\n#include <sys/types.h>\n#endif /* C370 */\n\n#include \"tailor.h\"\n#include \"gzip.h\"\n#include \"crypt.h\"\n\n#ifdef HAVE_UNISTD_H\n#  include <unistd.h>\n#endif\n#ifndef NO_FCNTL_H\n#  include <fcntl.h>\n#endif\n\nlocal ulg crc;       /* crc on uncompressed file data */\nlong header_bytes;   /* number of bytes in gzip header */\n\n/* ===========================================================================\n * Deflate in to out.\n * IN assertions: the input and output buffers are cleared.\n *   The variables time_stamp and save_orig_name are initialized.\n */\nint zip(in, out)\n    int in, out;            /* input and output file descriptors */\n{\n    uch  flags = 0;         /* general purpose bit flags */\n    ush  attr = 0;          /* ascii/binary flag */\n    ush  deflate_flags = 0; /* pkzip -es, -en or -ex equivalent */\n\n    ifd = in;\n    ofd = out;\n    outcnt = 0;\n\n    /* Write the header to the gzip file. See algorithm.doc for the format */\n\n    method = DEFLATED;\n    put_byte(GZIP_MAGIC\u00dd0\u00a8); /* magic header */\n    put_byte(GZIP_MAGIC\u00dd1\u00a8);\n    put_byte(DEFLATED);      /* compression method */\n\n    if (save_orig_name) {\n        flags \u00a6= ORIG_NAME;\n    }\n    put_byte(flags);         /* general flags */\n    put_long(time_stamp);\n\n    /* Write deflated file to zip file */\n    crc = updcrc(0, 0);\n\n    bi_init(out);\n    ct_init(&attr, &method);\n    lm_init(level, &deflate_flags);\n\n    put_byte((uch)deflate_flags); /* extra flags */\n    put_byte(OS_CODE);            /* OS identifier */\n\n    if (save_orig_name) {\n        char *p = basename(ifname); /* Don't save the directory part. */\n        do {\n#ifdef C370\n            put_char( (ascii) ? ebcdic_ascii\u00dd*p\u00a8 : *p );\n#else\n            put_char(*p);\n#endif\n        } while (*p++);\n    }\n    header_bytes = (long)outcnt;\n\n    (void)deflate();\n\n#if !defined(NO_SIZE_CHECK) && !defined(RECORD_IO)\n  /* Check input size (but not in VMS -- variable record lengths mess it up)\n   * and not on MSDOS -- diet in TSR mode reports an incorrect file size)\n   */\n    if (ifile_size != -1L && isize != (ulg)ifile_size) {\n        Trace((stderr, \" actual=%ld, read=%ld \", ifile_size, isize));\n        fprintf(stderr, \"%s: %s: file size changed while zipping\\n\",\n                progname, ifname);\n    }\n#endif\n\n    /* Write the crc and uncompressed size */\n    put_long(crc);\n    put_long(isize);\n    header_bytes += 2*sizeof(long);\n\n    flush_outbuf();\n    return OK;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input file, perform end-of-line\n * translation, and update the crc and input file size.\n * IN assertion: size >= 2 (for end-of-line translation)\n */\nint file_read(buf, size)\n    char *buf;\n    unsigned size;\n{\n    unsigned len;\n\n    Assert(insize == 0, \"inbuf not empty\");\n\n    len = read(ifd, buf, size);\n    if (len == (unsigned)(-1) \u00a6\u00a6 len == 0) return (int)len;\n#ifdef C370\n    if (ascii && !decompress) ebcdic2ascii( (uch *)buf, len );\n#endif\n\n    crc = updcrc((uch*)buf, len);\n    isize += (ulg)len;\n    return (int)len;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT335/FILE335.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT335", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}